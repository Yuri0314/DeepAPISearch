LibGraal#isAvailable()::: lib graal is available:::return->inLibGraal
LibGraal#inLibGraal()::: lib graal in lib graal:::return
LibGraal#registerNativeMethods(HotSpotJVMCIRuntime, Class)::: lib graal register native methods:::if->clazz->isPrimitive->throw->new->IllegalArgumentException->if->inLibGraal->isAvailable->throw->new->IllegalStateException->runtime->registerNativeMethods
LibGraal#translate(HotSpotJVMCIRuntime, Object)::: lib graal translate:::if->isAvailable->throw->new->IllegalStateException->if->inLibGraal->get->throw->getName->new->IllegalStateException->return->runtime->translate
LibGraal#unhand(HotSpotJVMCIRuntime, Class, long)::: lib graal unhand:::if->isAvailable->throw->new->IllegalStateException->if->inLibGraal->get->throw->getName->new->IllegalStateException->return->runtime->unhand
LibGraal#initializeLibgraal()::: lib graal initialize libgraal:::try->Services->initializeJVMCI->runtime->HotSpotJVMCIRuntime->runtime->nativeInterface->runtime->registerNativeMethods->return->catch->return->finally
LibGraal#isCurrentThreadAttached(HotSpotJVMCIRuntime)::: lib graal is current thread attached:::return->runtime->isCurrentThreadAttached
LibGraal#attachCurrentThread(HotSpotJVMCIRuntime)::: lib graal attach current thread:::return->runtime->attachCurrentThread
LibGraal#detachCurrentThread(HotSpotJVMCIRuntime)::: lib graal detach current thread:::runtime->detachCurrentThread
LibGraal#getCurrentIsolateThread(long)::: lib graal get current isolate thread:::
LibGraalScope#getIsolateThread():::Gets the isolate thread associated with the current thread:::scope->currentScope->get->if->throw->getSimpleName->new->IllegalStateException->return
LibGraalScope#close()::: lib graal scope close:::if->LibGraal->detachCurrentThread->currentScope->set
OptionsEncoder#isValueSupported(Object):::Determines if value is supported by #encode(Map).:::if->return->valueClass->value->getClass->return->value->getClass->isEnum
OptionsEncoder#encode(Map):::Encodes options into a byte array.:::try->baout->new->ByteArrayOutputStream->try->out->new->DataOutputStream->out->options->size->writeInt->foreach->options->entrySet->key->e->getKey->out->writeUTF->value->e->getValue->valueClz->value->getClass->if->out->writeByte->out->writeBoolean->else->if->out->writeByte->out->writeByte->else->if->out->writeByte->out->writeShort->else->if->out->writeByte->out->writeChar->else->if->out->writeByte->out->writeInt->else->if->out->writeByte->out->writeLong->else->if->out->writeByte->out->writeFloat->else->if->out->writeByte->out->writeDouble->else->if->out->writeByte->out->writeUTF->else->if->valueClz->isEnum->out->writeByte->out->name->writeUTF->else->throw->String->format->new->IllegalArgumentException->catch->finally->return->baout->toByteArray->catch->throw->new->IllegalArgumentException->finally
OptionsEncoder#decode(byte[]):::Decodes input into a name/value map.:::res->new->HashMap<>->try->in->new->ByteArrayInputStream->new->DataInputStream->size->in->readInt->for->i->if->in->available->throw->in->available->new->IllegalArgumentException->catch->throw->new->IllegalArgumentException->finally->return
