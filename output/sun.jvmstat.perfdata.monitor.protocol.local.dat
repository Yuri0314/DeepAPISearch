LocalEventTimer#getInstance():::Get the singleton LocalEventTimer instance:::if->new->LocalEventTimer->return
LocalMonitoredVm#detach():::.:::if->if->task->cancel->super->detach
LocalMonitoredVm#addVmListener(VmListener):::.:::synchronized->listeners->add->if->new->NotifierTask->timer->LocalEventTimer->getInstance->timer->schedule
LocalMonitoredVm#removeVmListener(VmListener):::.:::synchronized->listeners->remove->if->listeners->isEmpty->task->cancel
LocalMonitoredVm#setInterval(int):::.:::synchronized->if->return->oldInterval->super->setInterval->if->task->cancel->oldTask->new->NotifierTask->timer->LocalEventTimer->getInstance->CountedTimerTaskUtils->reschedule
LocalMonitoredVm#fireMonitorStatusChangedEvents(List, List):::Fire MonitoredVmStructureChanged events.:::ev->registered->synchronized->listeners->clone->for->i->registered->iterator->i->hasNext
LocalMonitoredVm#fireMonitorsUpdatedEvents():::Fire MonitoredUpdated events.:::ev->registered->synchronized->listeners->clone->cast->foreach->if->new->VmEvent->l->monitorsUpdated
LocalMonitoredVm.NotifierTask#run()::: notifier task run:::super->run->try->status->getMonitorStatus->inserted->status->getInserted->removed->status->getRemoved->if->inserted->isEmpty->removed->isEmpty->fireMonitorStatusChangedEvents->fireMonitorsUpdatedEvents->catch->getVmIdentifier->println->e->printStackTrace->finally
LocalMonitoredVm#cast(Object)::: local monitored vm cast:::return
LocalVmManager#activeVms():::Return the current set of monitorable Java Virtual Machines:::jvmSet->new->HashSet<Integer>->foreach->tmpdir->new->File->if->tmpdir->isDirectory->continue->if->dirs->tmpdir->listFiles->for->i->else->files->tmpdir->listFiles->if->for->j->files->tmpdir->listFiles->if->for->j->return
MonitoredHostLocalService#getMonitoredHost(HostIdentifier)::: monitored host local service get monitored host:::return->new->MonitoredHostProvider
MonitoredHostLocalService#getScheme()::: monitored host local service get scheme:::return
MonitoredHostProvider#getMonitoredVm(VmIdentifier)::: monitored host provider get monitored vm:::return->getMonitoredVm
MonitoredHostProvider#getMonitoredVm(VmIdentifier, int)::: monitored host provider get monitored vm:::try->nvmid->hostId->resolve->return->new->LocalMonitoredVm->catch->throw->vmid->toString->new->IllegalArgumentException->finally
MonitoredHostProvider#detach(MonitoredVm)::: monitored host provider detach:::vm->detach
MonitoredHostProvider#addHostListener(HostListener)::: monitored host provider add host listener:::synchronized->listeners->add->if->new->NotifierTask->timer->LocalEventTimer->getInstance->timer->schedule
MonitoredHostProvider#removeHostListener(HostListener)::: monitored host provider remove host listener:::synchronized->listeners->remove->if->listeners->isEmpty->task->cancel
MonitoredHostProvider#setInterval(int)::: monitored host provider set interval:::synchronized->if->return->oldInterval->super->setInterval->if->task->cancel->oldTask->new->NotifierTask->timer->LocalEventTimer->getInstance->CountedTimerTaskUtils->reschedule
MonitoredHostProvider#activeVms()::: monitored host provider active vms:::return->vmManager->activeVms
MonitoredHostProvider#fireVmStatusChangedEvents(Set, Set, Set):::Fire VmEvent events.:::registered->ev->synchronized->listeners->clone->for->i->registered->iterator->i->hasNext
MonitoredHostProvider.NotifierTask#run()::: notifier task run:::super->run->lastActiveVms->vmManager->activeVms->if->activeVms->isEmpty->return->startedVms->new->HashSet<>->terminatedVms->new->HashSet<>->for->i->activeVms->iterator->i->hasNext->for->i->lastActiveVms->iterator->i->hasNext->if->startedVms->isEmpty->terminatedVms->isEmpty->fireVmStatusChangedEvents
PerfDataFile#getFile(int):::Get a File object for the instrumentation backing store file for the JVM identified by the given local Vm Identifier:::if->return->tmpDirs->getTempDirectories->newest->foreach->tmpDir->new->File->files->tmpDir->new->FilenameFilter->list->newestTime->foreach->f->new->File->candidate->if->f->exists->f->isDirectory->name->f->getAbsolutePath->new->File->if->candidate->exists->f->getAbsolutePath->platSupport->getNamespaceVmId->new->File->else->if->f->exists->f->isFile->else->if->candidate->exists->candidate->isFile->candidate->canRead->modTime->candidate->lastModified->if->return
PerfDataFile#getFile(String, int):::Return the File object for the backing store file for the specified Java Virtual Machine:::if->return->tmpDirs->getTempDirectories->basename->f->foreach->new->File->if->f->exists->f->isFile->f->canRead->return->platSupport->getNamespaceVmId->new->File->if->f->exists->f->isFile->f->canRead->return->newestTime->newest->for->i->return
PerfDataFile#getLocalVmId(File):::Method to extract a local Java Virtual Machine Identifier from the file name of the given File object.:::try->return->platSupport->getLocalVmId->catch->finally->name->file->getName->if->name->startsWith->first->name->indexOf->last->name->lastIndexOf->try->if->return->Integer->name->substring->parseInt->else->return->Integer->name->substring->parseInt->catch->finally->throw->new->IllegalArgumentException
PerfDataFile#getTempDirectory():::Return the name of the temporary directory being searched for HotSpot PerfData backing store files:::return->PlatformSupport->getTemporaryDirectory
PerfDataFile#getTempDirectory(String):::Return the name of the temporary directory to be searched for HotSpot PerfData backing store files for a given user:::return->getTempDirectory
PerfDataFile#getTempDirectories(String, int):::Return the names of the temporary directories being searched for HotSpot PerfData backing store files:::list->platSupport->getTemporaryDirectories->if->return->nameList->list->stream->map->Collectors->toList->collect->return
