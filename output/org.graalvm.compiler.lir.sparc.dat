SPARCAddressValue#toAddress()::: address value to address:::
SPARCAddressValue#isValidImplicitNullCheckFor(Value, int)::: address value is valid implicit null check for:::
SPARCArithmetic.FloatConvertOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: float convert op emit code:::notOrdered->new->Label->switch->masm->asRegister->asRegister->fcmp->FBPCC->emit->masm->asRegister->asRegister->fstox->masm->asRegister->asRegister->fxtod->masm->asRegister->asRegister->asRegister->fsubd->masm->bind->break->masm->asRegister->asRegister->fcmp->FBPCC->emit->masm->asRegister->asRegister->fstoi->masm->asRegister->asRegister->fitos->masm->asRegister->asRegister->asRegister->fsubs->masm->bind->break->masm->asRegister->asRegister->fcmp->FBPCC->emit->masm->asRegister->asRegister->fdtox->masm->asRegister->asRegister->fxtod->masm->asRegister->asRegister->asRegister->fsubd->masm->bind->break->masm->asRegister->asRegister->fcmp->FBPCC->emit->masm->asRegister->asRegister->fdtoi->masm->asRegister->asRegister->fitos->masm->asRegister->asRegister->asRegister->fsubs->masm->bind->break->throw->GraalError->shouldNotReachHere
SPARCArithmetic.RemOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: rem op emit code:::if->isJavaConstant->isJavaConstant->switch->if->crb->masm->position->recordImplicitException->masm->asRegister->crb->asIntConst->asRegister->udivx->masm->asRegister->crb->asIntConst->asRegister->mulx->getDelayedControlTransfer->emitControlTransfer->masm->asRegister->asRegister->asRegister->sub->break->GraalError->unimplemented->break->throw->GraalError->shouldNotReachHere->else->if->isRegister->isRegister->xLeft->switch->if->isJavaConstant->masm->crb->asLongConst->asRegister->setx->if->crb->masm->position->recordImplicitException->masm->asRegister->asRegister->asRegister->udivx->masm->asRegister->asRegister->asRegister->mulx->getDelayedControlTransfer->emitControlTransfer->masm->asRegister->asRegister->asRegister->sub->break->masm->asRegister->asRegister->srl->masm->asRegister->asRegister->srl->if->crb->masm->position->recordImplicitException->masm->asRegister->asRegister->asRegister->udivx->masm->asRegister->asRegister->asRegister->mulx->getDelayedControlTransfer->emitControlTransfer->masm->asRegister->asRegister->asRegister->sub->break->throw->GraalError->shouldNotReachHere->else->throw->GraalError->shouldNotReachHere
SPARCArithmetic.SPARCIMulccOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: mulcc op emit code:::try->tmpScratch->masm->getScratchRegister->tmp->tmpScratch->getRegister->resultRegister->asRegister->xRegister->asRegister->yRegister->asRegister->masm->sra->masm->sra->masm->mulx->noOverflow->new->Label->masm->sra->masm->compareBranch->masm->wrccr->masm->bind->catch->finally
SPARCArithmetic.SPARCLMulccOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: mulcc op emit code:::noOverflow->new->Label->masm->asRegister->asRegister->asRegister->mulx->masm->asRegister->asRegister->asRegister->umulxhi->masm->asRegister->asRegister->srax->masm->asRegister->asRegister->asRegister->and->masm->asRegister->asRegister->asRegister->sub->masm->asRegister->asRegister->srax->masm->asRegister->asRegister->asRegister->and->masm->asRegister->asRegister->asRegister->sub->masm->asRegister->asRegister->srax->masm->asRegister->asRegister->cmp->BPCC->emit->masm->nop->masm->wrccr->masm->bind
SPARCArithmetic.MulHighOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: mul high op emit code:::switch->masm->asRegister->asRegister->sra->masm->asRegister->asRegister->sra->masm->asRegister->asRegister->asRegister->mulx->masm->asRegister->asRegister->srax->break->masm->asRegister->asRegister->asRegister->umulxhi->masm->asRegister->asRegister->srlx->masm->asRegister->asRegister->asRegister->mulx->masm->asRegister->asRegister->asRegister->sub->masm->asRegister->asRegister->srlx->masm->asRegister->asRegister->asRegister->mulx->masm->asRegister->asRegister->asRegister->sub->break->throw->GraalError->shouldNotReachHere
SPARCArrayEqualsOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: array equals op emit code:::result->asRegister->array1->asRegister->array2->asRegister->length->asRegister->trueLabel->new->Label->falseLabel->new->Label->done->new->Label->masm->asRegister->add->masm->asRegister->add->masm->asRegister->mulx->masm->mov->emit8ByteCompare->emitTailCompares->masm->bind->masm->mov->masm->jmp->masm->bind->masm->mov->masm->bind
SPARCArrayEqualsOp#emit8ByteCompare(SPARCMacroAssembler, Register, Register, Register, Register, Label, Label):::Emits code that uses 8-byte vector compares.:::loop->new->Label->compareTail->new->Label->compareTailCorrectVectorEnd->new->Label->tempReg1->asRegister->tempReg2->asRegister->masm->sra->masm->and->masm->andcc->BPCC->emit->masm->sub->masm->add->masm->add->masm->sub->masm->new->SPARCAddress->ldx->masm->new->SPARCAddress->ldx->masm->compareBranch->masm->compareBranch->masm->new->SPARCAddress->ldx->masm->bind->masm->new->SPARCAddress->ldx->masm->cmp->BPCC->emit->masm->addcc->BPCC->emit->masm->new->SPARCAddress->ldx->masm->compareBranch->masm->bind->masm->add->masm->add->masm->bind
SPARCArrayEqualsOp#emitTailCompares(SPARCMacroAssembler, Register, Register, Register, Label, Label):::Emits code to compare the remaining 1 to 4 bytes.:::compare2Bytes->new->Label->compare1Byte->new->Label->tempReg1->asRegister->tempReg2->asRegister->if->kind->getByteCount->masm->compareBranch->masm->new->SPARCAddress->lduw->masm->new->SPARCAddress->lduw->masm->compareBranch->if->kind->getByteCount->masm->add->masm->add->masm->sub->masm->bind->masm->compareBranch->masm->new->SPARCAddress->lduh->masm->new->SPARCAddress->lduh->masm->compareBranch->if->kind->getByteCount->masm->add->masm->add->masm->sub->masm->bind->masm->compareBranch->masm->new->SPARCAddress->ldub->masm->new->SPARCAddress->ldub->masm->compareBranch->else->masm->bind->else->masm->bind
SPARCBitManipulationOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: bit manipulation op emit code:::dst->asRegister->if->isRegister->src->asRegister->switch->tkind->input->getPlatformKind->if->masm->sub->masm->andn->masm->srl->masm->popc->else->if->masm->sub->masm->andn->masm->popc->else->throw->GraalError->shouldNotReachHere->break->ikind->input->getPlatformKind->tmp->asRegister->masm->srl->masm->srl->masm->or->masm->srl->masm->or->masm->srl->masm->or->masm->srl->masm->or->masm->srl->masm->or->masm->popc->masm->sub->break->lkind->input->getPlatformKind->tmp->asRegister->masm->srlx->masm->or->masm->srlx->masm->or->masm->srlx->masm->or->masm->srlx->masm->or->masm->srlx->masm->or->masm->srlx->masm->or->masm->popc->masm->sub->break->throw->GraalError->shouldNotReachHere->else->throw->GraalError->shouldNotReachHere
SPARCBlockEndOp#getSPARCLIRInstructionStore()::: block end op get instruction store:::return
SPARCBlockEndOp#emitCode(CompilationResultBuilder)::: block end op emit code:::emitCode
SPARCBlockEndOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: block end op emit code:::
SPARCBreakpointOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: breakpoint op emit code:::masm->ta
SPARCByteSwapOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: byte swap op emit code:::addr->crb->asAddress->SPARCMove->result->getPlatformKind->emitStore->if->addr->getIndex->equals->tempReg->ValueUtil->asRegister->masm->addr->getDisplacement->setx->addr->getBase->new->SPARCAddress->getDelayedControlTransfer->emitControlTransfer->switch->input->getPlatformKind->masm->addr->getBase->addr->getIndex->asRegister->lduwa->break->masm->addr->getBase->addr->getIndex->asRegister->ldxa->break->throw->GraalError->shouldNotReachHere
SPARCCall.CallOp#destroysCallerSavedRegisters()::: call op destroys caller saved registers:::return
SPARCCall.DirectCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: direct call op emit code:::if->emitCallPrefixCode->directCall->else->after->masm->position->if->masm->nop->else->if->else->GraalError->shouldNotReachHere->masm->position->crb->recordDirectCall->crb->recordExceptionHandlers->masm->ensureUniquePC
SPARCCall.DirectCallOp#emitCallPrefixCode(CompilationResultBuilder, SPARCMacroAssembler)::: direct call op emit call prefix code:::
SPARCCall.DirectCallOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)::: direct call op emit control transfer:::emitCallPrefixCode->masm->call
SPARCCall.DirectCallOp#resetState()::: direct call op reset state:::
SPARCCall.IndirectCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: indirect call op emit code:::asRegister->indirectCall
SPARCCall.IndirectCallOp#verify()::: indirect call op verify:::super->verify
SPARCCall.ForeignCallOp#destroysCallerSavedRegisters()::: foreign call op destroys caller saved registers:::return->callTarget->destroysRegisters
SPARCCall.DirectNearForeignCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: direct near foreign call op emit code:::directCall
SPARCCall.DirectFarForeignCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: direct far foreign call op emit code:::try->scratch->masm->getScratchRegister->scratch->getRegister->directCall->catch->finally
SPARCCall#directCall(CompilationResultBuilder, SPARCMacroAssembler, InvokeTarget, Register, LIRFrameState)::: call direct call:::before->if->masm->position->masm->sethix->masm->jmpl->else->masm->call->masm->nop->after->masm->position->crb->recordDirectCall->crb->recordExceptionHandlers->masm->ensureUniquePC
SPARCCall#indirectJmp(CompilationResultBuilder, SPARCMacroAssembler, Register, InvokeTarget)::: call indirect jmp:::before->masm->position->masm->sethix->masm->new->SPARCAddress->jmp->masm->nop->after->masm->position->crb->recordIndirectCall->masm->ensureUniquePC
SPARCCall#indirectCall(CompilationResultBuilder, SPARCMacroAssembler, Register, InvokeTarget, LIRFrameState)::: call indirect call:::before->masm->jmpl->masm->nop->after->masm->position->crb->recordIndirectCall->crb->recordExceptionHandlers->masm->ensureUniquePC
SPARCControlFlow.ReturnOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: return op emit code:::emitCodeHelper
SPARCControlFlow.ReturnOp#emitCodeHelper(CompilationResultBuilder, SPARCMacroAssembler)::: return op emit code helper:::masm->ret->leave
SPARCControlFlow.CompareBranchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: compare branch op emit code:::if->if->requestHints->targetPosition->getTargetPosition->if->canUseShortBranch->emitShortCompareBranch->if->emitLongCompareBranch
SPARCControlFlow.CompareBranchOp#emitLongCompareBranch(CompilationResultBuilder, SPARCMacroAssembler, boolean)::: compare branch op emit long compare branch:::emitOp3->return->emitBranch
SPARCControlFlow.CompareBranchOp#getTargetPosition(Assembler)::: compare branch op get target position:::return->asm->position
SPARCControlFlow.CompareBranchOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)::: compare branch op emit control transfer:::requestHints->targetPosition->getTargetPosition->if->canUseShortBranch->emitLongCompareBranch->if->masm->position
SPARCControlFlow.CompareBranchOp#requestHints(SPARCMacroAssembler)::: compare branch op request hints:::if->masm->trueDestination->label->requestLabelHint->if->masm->falseDestination->label->requestLabelHint
SPARCControlFlow.CompareBranchOp#emitShortCompareBranch(CompilationResultBuilder, SPARCMacroAssembler):::Tries to use the emit the compare/branch instruction:::isLong->actualConditionFlag->actualTrueTarget->trueDestination->label->actualFalseTarget->falseDestination->label->tmpTarget->needJump->if->crb->isSuccessorEdge->conditionFlag->negate->else->crb->isSuccessorEdge->targetPosition->getTargetPosition->if->isShortBranch->actualConditionFlag->negate->emitCBCond->if->masm->jmp->masm->nop->return
SPARCControlFlow.CompareBranchOp#emitCBCond(SPARCMacroAssembler, Value, Value, Label, ConditionFlag, boolean)::: compare branch op emit cond:::xKind->actualX->getPlatformKind->rs1->asRegister->if->isJavaConstant->c->asJavaConstant->constantY->c->isNull->c->asLong->try->scratch->masm->getScratchRegister->if->SPARCMacroAssembler->isSimm5->CBCOND->emit->else->rs2->scratch->getRegister->masm->setx->CBCOND->emit->catch->finally->else->rs2->asRegister->CBCOND->emit
SPARCControlFlow.CompareBranchOp#canUseShortBranch(CompilationResultBuilder, SPARCAssembler, int)::: compare branch op can use short branch:::if->asm->hasFeature->return->if->x->getPlatformKind->isInteger->return->if->isJavaConstant->asJavaConstant->isSimm5->asJavaConstant->isSimm13->return->hasShortJumpTarget->if->crb->isSuccessorEdge->trueDestination->label->isShortBranch->if->crb->isSuccessorEdge->falseDestination->label->isShortBranch->return
SPARCControlFlow.CompareBranchOp#resetState()::: compare branch op reset state:::
SPARCControlFlow.CompareBranchOp#verify()::: compare branch op verify:::super->verify
SPARCControlFlow#isShortBranch(SPARCAssembler, int, LabelHint, Label)::: control flow is short branch:::disp->dispValid->if->label->isBound->label->position->else->if->hint->isValid->hint->getTarget->hint->getPosition->else->if->if->else->return->isSimm10->else->if->asm->requestLabelHint->return
SPARCControlFlow.BranchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: branch op emit code:::emitBranch
SPARCControlFlow#emitBranch(CompilationResultBuilder, SPARCMacroAssembler, SPARCKind, ConditionFlag, LabelRef, LabelRef, boolean, double)::: control flow emit branch:::actualTarget->actualConditionFlag->needJump->predictTaken->if->crb->isSuccessorEdge->conditionFlag->negate->falseDestination->label->else->trueDestination->label->crb->isSuccessorEdge->if->return->if->kind->isFloat->FBPCC->emit->else->cc->kind->equals->BPCC->emit->if->masm->nop->if->masm->falseDestination->label->jmp->return
SPARCControlFlow.StrategySwitchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: strategy switch op emit code:::keyRegister->asRegister->constantBaseRegister->equals->asRegister->strategy->new->SwitchClosure->run
SPARCControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition):::This method caches the generated labels over two assembly passes to get information about branch lengths.:::label->if->conditionalLabels->size->new->Label->conditionalLabels->add->conditionalLabels->size->else->conditionalLabels->get->conditionalJump->return
SPARCControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition, Label)::: switch closure conditional jump:::constant->conditionCode->bits->constant->asLong->switch->constant->getJavaKind->break->break->throw->new->GraalError->conditionFlag->keyRegister->getRegisterCategory->equals->fromCondition->hint->requestHint->isShortConstant->isSimm5->cbCondPosition->masm->position->if->canUseShortBranch->masm->hasFeature->isShortBranch->if->if->CBCOND->emit->else->scratchRegister->asRegister->const2reg->CBCOND->emit->else->if->isSimm13->masm->cmp->else->scratchRegister->asRegister->const2reg->masm->cmp->BPCC->emit->masm->nop
SPARCControlFlow.StrategySwitchOp#requestHint(SPARCMacroAssembler, Label)::: strategy switch op request hint:::hint->labelHints->get->if->masm->requestLabelHint->labelHints->put->return
SPARCControlFlow.StrategySwitchOp#estimateEmbeddedSize(Constant)::: strategy switch op estimate embedded size:::v->if->SPARCAssembler->isSimm13->return->v->getJavaKind->getByteCount->else->return
SPARCControlFlow.StrategySwitchOp#estimateSize()::: strategy switch op estimate size:::constantBytes->foreach->estimateEmbeddedSize->return->new->SizeEstimate
SPARCControlFlow.TableSwitchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: table switch op emit code:::value->asRegister->scratchReg->asRegister->highKey->if->isSimm13->masm->sub->else->try->sc->masm->getScratchRegister->scratch2->sc->getRegister->masm->setx->masm->sub->catch->finally->upperLimit->try->sc->masm->getScratchRegister->scratch2->sc->getRegister->if->isSimm13->masm->cmp->else->masm->setx->masm->cmp->if->BPCC->defaultTarget->label->emit->masm->nop->masm->sll->masm->srl->masm->rdpc->masm->add->masm->jmpl->catch->finally->masm->nop->foreach->BPCC->target->label->emit->masm->nop
SPARCControlFlow.TableSwitchOp#estimateSize()::: table switch op estimate size:::return->SizeEstimate->create
SPARCControlFlow.CondMoveOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: cond move op emit code:::if->result->equals->condition->negate->cmove->else->if->result->equals->cmove->else->actualCondition->actualTrueValue->actualFalseValue->if->isJavaConstant->asJavaConstant->isSimm11->condition->negate->SPARCMove->move->cmove
SPARCControlFlow.CondMoveOp#cmove(SPARCMacroAssembler, ConditionFlag, Value)::: cond move op cmove:::if->isConstantValue->cmove->asJavaConstant->asImmediate->asRegister->emit->else->cmove->asRegister->asRegister->emit
SPARCControlFlow.CondMoveOp#estimateSize()::: cond move op estimate size:::constantSize->if->isJavaConstant->SPARCAssembler->asJavaConstant->isSimm13->trueValue->getPlatformKind->getSizeInBytes->if->isJavaConstant->SPARCAssembler->asJavaConstant->isSimm13->trueValue->getPlatformKind->getSizeInBytes->return->SizeEstimate->create
SPARCControlFlow#fromCondition(boolean, Condition, boolean)::: control flow from condition:::if->switch->return->return->return->return->return->return->return->return->return->return->throw->GraalError->shouldNotReachHere->else->switch->return->return->return->return->return->return->throw->GraalError->shouldNotReachHere
SPARCDelayedControlTransfer#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler):::This method must be called, to generate the control transfer, but without any Nop in the delay slot.:::
SPARCDelayedControlTransfer#resetState()::: delayed control transfer reset state:::
SPARCFloatCompareOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: float compare op emit code:::getDelayedControlTransfer->emitControlTransfer->asRegister->asRegister->emitFcmp
SPARCFloatCompareOp#verify()::: float compare op verify:::
SPARCFrameMap#totalFrameSize()::: frame map total frame size:::return->frameSize
SPARCFrameMap#currentFrameSize()::: frame map current frame size:::return->alignFrameSize
SPARCFrameMap#spillSlotSize(ValueKind):::In SPARC we have spill slots word aligned.:::return->kind->getPlatformKind->getSizeInBytes
SPARCFrameMap#offsetForStackSlot(StackSlot)::: frame map offset for stack slot:::return->super->offsetForStackSlot
SPARCFrameMap#frameNeedsAllocating()::: frame map frame needs allocating:::return->super->frameNeedsAllocating
SPARCFrameMap#allocateDeoptimizationRescueSlot()::: frame map allocate deoptimization rescue slot:::return->LIRKind->value->allocateSpillSlot
SPARCFrameMapBuilder#allocateDeoptimizationRescueSlot()::: frame map builder allocate deoptimization rescue slot:::return->getFrameMap->allocateDeoptimizationRescueSlot
SPARCImmediateAddressValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)::: immediate address value for each component:::newBase->proc->doValue->if->base->identityEquals->return->getValueKind->new->SPARCImmediateAddressValue->return
SPARCImmediateAddressValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)::: immediate address value visit each component:::proc->visitValue
SPARCImmediateAddressValue#toAddress()::: immediate address value to address:::return->asRegister->new->SPARCAddress
SPARCImmediateAddressValue#isValidImplicitNullCheckFor(Value, int)::: immediate address value is valid implicit null check for:::return->value->equals
SPARCImmediateAddressValue#toString()::: immediate address value to string:::s->new->StringBuilder->sep->if->isLegal->s->append->if->s->append->append->else->if->s->append->append->s->append->return->s->toString
SPARCImmediateAddressValue#equals(Object)::: immediate address value equals:::if->addr->return->getValueKind->addr->getValueKind->equals->base->equals->return
SPARCImmediateAddressValue#hashCode()::: immediate address value hash code:::return->base->hashCode->getValueKind->hashCode
SPARCIndexedAddressValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)::: indexed address value for each component:::newBase->proc->doValue->newIndex->proc->doValue->if->base->identityEquals->index->identityEquals->return->getValueKind->new->SPARCIndexedAddressValue->return
SPARCIndexedAddressValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)::: indexed address value visit each component:::proc->visitValue->proc->visitValue
SPARCIndexedAddressValue#toAddress()::: indexed address value to address:::return->asRegister->asRegister->new->SPARCAddress
SPARCIndexedAddressValue#isValidImplicitNullCheckFor(Value, int)::: indexed address value is valid implicit null check for:::return
SPARCIndexedAddressValue#toString()::: indexed address value to string:::s->new->StringBuilder->sep->if->isLegal->s->append->if->isLegal->s->append->append->s->append->return->s->toString
SPARCIndexedAddressValue#equals(Object)::: indexed address value equals:::if->addr->return->getValueKind->addr->getValueKind->equals->base->equals->index->equals->return
SPARCIndexedAddressValue#hashCode()::: indexed address value hash code:::return->base->hashCode->index->hashCode->getValueKind->hashCode
SPARCJumpOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)::: jump op emit control transfer:::if->crb->destination->isSuccessorEdge->BPCC->destination->label->emit->masm->position
SPARCJumpOp#emitCode(CompilationResultBuilder)::: jump op emit code:::if->crb->destination->isSuccessorEdge->if->masm->masm->destination->label->jmp->else->disp->position
SPARCJumpOp#resetState()::: jump op reset state:::
SPARCJumpOp#getSPARCLIRInstructionStore()::: jump op get instruction store:::return
SPARCLIRInstruction#emitCode(CompilationResultBuilder)::: instruction emit code:::emitCode
SPARCLIRInstruction#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: instruction emit code:::
SPARCLIRInstruction#getSPARCLIRInstructionStore()::: instruction get instruction store:::return
SPARCLIRInstruction#asImmediate(JavaConstant)::: instruction as immediate:::if->value->isNull->return->else->val->value->asLong->return
SPARCLIRInstructionMixin#leavesRegisterWindow()::: instruction mixin leaves register window:::return
SPARCLIRInstructionMixin#estimateSize()::: instruction mixin estimate size:::return->getSPARCLIRInstructionStore
SPARCLIRInstructionMixin#getSPARCLIRInstructionStore()::: instruction mixin get instruction store:::
SPARCLIRInstructionMixin.SizeEstimate#create(int, int)::: size estimate create:::if->return->else->return->new->SizeEstimate
SPARCLIRInstructionMixin.SizeEstimate#create(int)::: size estimate create:::if->return->else->return->new->SizeEstimate
SPARCLIRInstructionMixin.SizeEstimate#toString()::: size estimate to string:::return
SPARCLIRInstructionMixin.SPARCLIRInstructionMixinStore#toString()::: instruction mixin store to string:::return->estimate->toString
SPARCLoadConstantTableBaseOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load constant table base op emit code:::baseRegister->asRegister->beforePosition->masm->position->masm->rdpc->masm->SPARCAssembler->minSimm->add->masm->sub
SPARCLoadConstantTableBaseOp#getResult()::: load constant table base op get result:::return
SPARCLoadConstantTableBaseOp#setAlive(LIR, boolean)::: load constant table base op set alive:::if->placeHolder->replace->else->placeHolder->remove
SPARCMove.LoadInlineConstant#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load inline constant emit code:::if->isRegister->getDelayedControlTransfer->const2reg->else->if->isStackSlot->slot->asStackSlot->getDelayedControlTransfer->const2stack
SPARCMove.LoadInlineConstant#getConstant()::: load inline constant get constant:::return
SPARCMove.LoadInlineConstant#getResult()::: load inline constant get result:::return
SPARCMove.LoadConstantFromTable#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load constant from table emit code:::byteCount->result->getPlatformKind->getSizeInBytes->baseRegister->asRegister->if->isRegister->resultRegister->asRegister->getDelayedControlTransfer->loadFromConstantTable->else->if->isStackSlot->try->scratch->masm->getScratchRegister->scratchRegister->scratch->getRegister->getDelayedControlTransfer->loadFromConstantTable->slot->asStackSlot->scratchRegister->asValue->getDelayedControlTransfer->reg2stack->catch->finally
SPARCMove.Move#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: move emit code:::getResult->getInput->getDelayedControlTransfer->move
SPARCMove.Move#getInput()::: move get input:::return
SPARCMove.Move#getResult()::: move get result:::return
SPARCMove.MoveFpGp#getInput()::: move fp gp get input:::return
SPARCMove.MoveFpGp#getResult()::: move fp gp get result:::return
SPARCMove.MoveFpGp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: move fp gp emit code:::inputKind->input->getPlatformKind->resultKind->result->getPlatformKind->if->equals->moveDirect->else->moveViaStack
SPARCMove.MoveFpGp#moveDirect(CompilationResultBuilder, SPARCMacroAssembler, SPARCKind, SPARCKind)::: move fp gp move direct:::getDelayedControlTransfer->emitControlTransfer->if->if->masm->asRegister->asRegister->movwtos->else->throw->GraalError->shouldNotReachHere->else->if->if->masm->asRegister->asRegister->movxtod->else->masm->asRegister->asRegister->movxtod->else->if->if->masm->asRegister->asRegister->movstosw->else->masm->asRegister->asRegister->movstouw->else->if->if->masm->asRegister->asRegister->movdtox->else->throw->GraalError->shouldNotReachHere
SPARCMove.MoveFpGp#moveViaStack(CompilationResultBuilder, SPARCMacroAssembler, SPARCKind, SPARCKind)::: move fp gp move via stack:::resultKindSize->resultKind->getSizeInBytes->try->sc->masm->getScratchRegister->scratch->sc->getRegister->tempAddress->crb->asAddress->generateSimm13OffsetLoad->masm->asRegister->st->getDelayedControlTransfer->emitControlTransfer->masm->asRegister->ld->catch->finally
SPARCMove.MemOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)::: mem op emit mem access:::
SPARCMove.MemOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: mem op emit code:::emitMemAccess
SPARCMove.MemOp#makeNullCheckFor(Value, LIRFrameState, int)::: mem op make null check for:::if->address->isValidImplicitNullCheckFor->return->return
SPARCMove.LoadOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)::: load op emit mem access:::address->toAddress->getDelayedControlTransfer->emitLoad
SPARCMove.LoadAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load address op emit code:::address->addressValue->toAddress->asRegister->getDelayedControlTransfer->loadEffectiveAddress
SPARCMove.LoadDataAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load data address op emit code:::addr->crb->getSizeInBytes->data->getAlignment->max->recordDataReferenceInCode->forceRelocatable->dstReg->asRegister->masm->setx
SPARCMove.LoadDataAddressOp#estimateSize()::: load data address op estimate size:::return->SizeEstimate->data->getSerializedSize->create
SPARCMove.MembarOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: membar op emit code:::getDelayedControlTransfer->emitControlTransfer->masm->membar
SPARCMove.MembarOp#verify()::: membar op verify:::
SPARCMove.NullCheckOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: null check op emit code:::getDelayedControlTransfer->emitControlTransfer->addr->input->toAddress->crb->masm->position->recordImplicitException->masm->ldub
SPARCMove.NullCheckOp#getCheckedValue()::: null check op get checked value:::return
SPARCMove.NullCheckOp#getState()::: null check op get state:::return
SPARCMove.CompareAndSwapOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: compare and swap op emit code:::move->getDelayedControlTransfer->compareAndSwap
SPARCMove.StackLoadAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: stack load address op emit code:::address->crb->asAddress->asRegister->getDelayedControlTransfer->loadEffectiveAddress
SPARCMove#loadEffectiveAddress(CompilationResultBuilder, SPARCMacroAssembler, SPARCAddress, Register, SPARCDelayedControlTransfer)::: move load effective address:::if->address->getIndex->equals->if->address->getDisplacement->isSimm13->delaySlotHolder->emitControlTransfer->masm->address->getBase->address->getDisplacement->add->else->masm->address->getDisplacement->setx->delaySlotHolder->emitControlTransfer->masm->address->getBase->add->else->delaySlotHolder->emitControlTransfer->masm->address->getBase->address->getIndex->add
SPARCMove.StoreOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)::: store op emit mem access:::address->toAddress->getDelayedControlTransfer->emitStore
SPARCMove.StoreConstantOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)::: store constant op emit mem access:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->addr->address->toAddress->generateSimm13OffsetLoad->getDelayedControlTransfer->emitControlTransfer->if->crb->masm->position->recordImplicitException->byteCount->kind->getSizeInBytes->masm->st->catch->finally
SPARCMove#move(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)::: move move:::move
SPARCMove#move(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, Value, SPARCDelayedControlTransfer)::: move move:::if->isRegister->if->isRegister->reg2reg->else->if->isStackSlot->reg2stack->else->throw->GraalError->shouldNotReachHere->else->if->isStackSlot->if->isRegister->inputAddress->crb->asAddress->input->getPlatformKind->emitLoad->else->if->isStackSlot->stack2stack->else->throw->GraalError->shouldNotReachHere->else->if->isJavaConstant->constant->asJavaConstant->if->isRegister->const2reg->else->if->isStackSlot->const2stack->else->throw->GraalError->shouldNotReachHere->else->throw->GraalError->shouldNotReachHere
SPARCMove#const2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, SPARCDelayedControlTransfer, JavaConstant)::: move const2stack:::if->constant->isDefaultForKind->constant->isNull->resultAddress->crb->asAddress->g0->LIRKind->combine->asValue->result->getPlatformKind->emitStore->else->try->sc->masm->getScratchRegister->scratchRegisterValue->sc->getRegister->LIRKind->combine->asValue->const2reg->resultAddress->crb->asAddress->result->getPlatformKind->emitStore->catch->finally
SPARCMove#stack2stack(CompilationResultBuilder, SPARCMacroAssembler, PlatformKind, PlatformKind, Value, Value, SPARCDelayedControlTransfer)::: move stack2stack:::try->sc->masm->getScratchRegister->inputAddress->crb->asAddress->scratchRegisterValue->sc->getRegister->LIRKind->combine->asValue->emitLoad->resultAddress->crb->asAddress->emitStore->catch->finally
SPARCMove#stack2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)::: move stack2stack:::result->getPlatformKind->input->getPlatformKind->stack2stack
SPARCMove#reg2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)::: move reg2stack:::resultAddress->crb->asAddress->result->getPlatformKind->emitStore
SPARCMove#reg2reg(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)::: move reg2reg:::src->asRegister->dst->asRegister->if->src->equals->return->delaySlotLir->emitControlTransfer->if->isCPURegister->isCPURegister->masm->mov->else->if->isSingleFloatRegister->isSingleFloatRegister->masm->fsrc2s->else->if->isDoubleFloatRegister->isDoubleFloatRegister->masm->fsrc2d->else->throw->GraalError->String->format->shouldNotReachHere
SPARCMove#generateSimm13OffsetLoad(SPARCAddress, SPARCMacroAssembler, Register):::Guarantees that the given SPARCAddress given before is loadable by subsequent load/store instruction:::displacementOutOfBound->addr->getIndex->equals->SPARCAssembler->addr->getDisplacement->isSimm13->if->masm->addr->getDisplacement->setx->return->addr->getBase->new->SPARCAddress->else->return
SPARCMove#const2reg(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, JavaConstant, SPARCDelayedControlTransfer)::: move const2reg:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->cpuFeatures->getFeatures->hasVIS1->cpuFeatures->contains->hasVIS3->cpuFeatures->contains->resultRegister->asRegister->switch->input->getJavaKind->getStackKind->if->input->isDefaultForKind->delaySlotLir->emitControlTransfer->masm->clr->else->if->input->asInt->isSimm13->delaySlotLir->emitControlTransfer->masm->input->asInt->or->else->if->constantTableBase->equals->throw->GraalError->shouldNotReachHere->else->loadFromConstantTable->break->if->input->isDefaultForKind->delaySlotLir->emitControlTransfer->masm->clr->else->if->input->asLong->isSimm13->delaySlotLir->emitControlTransfer->masm->input->asLong->or->else->loadFromConstantTable->break->constant->input->asFloat->constantBits->floatToIntBits->if->delaySlotLir->emitControlTransfer->masm->fzeros->else->if->isSimm13->masm->or->delaySlotLir->emitControlTransfer->masm->movwtos->else->loadFromConstantTable->break->constant->input->asDouble->constantBits->doubleToRawLongBits->if->delaySlotLir->emitControlTransfer->masm->fzerod->else->if->isSimm13->masm->or->delaySlotLir->emitControlTransfer->masm->movxtod->else->loadFromConstantTable->break->if->input->isNull->delaySlotLir->emitControlTransfer->masm->clr->else->loadFromConstantTable->break->throw->GraalError->input->getJavaKind->shouldNotReachHere->catch->finally
SPARCMove#compareAndSwap(CompilationResultBuilder, SPARCMacroAssembler, AllocatableValue, AllocatableValue, AllocatableValue, SPARCDelayedControlTransfer)::: move compare and swap:::delay->emitControlTransfer->switch->cmpValue->getPlatformKind->masm->asRegister->asRegister->asRegister->cas->break->masm->asRegister->asRegister->asRegister->casx->break->throw->GraalError->shouldNotReachHere
SPARCMove#emitLoad(CompilationResultBuilder, SPARCMacroAssembler, SPARCAddress, Value, boolean, PlatformKind, SPARCDelayedControlTransfer, LIRFrameState)::: move emit load:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->addr->generateSimm13OffsetLoad->dst->asRegister->delayedControlTransfer->emitControlTransfer->if->crb->masm->position->recordImplicitException->byteCount->kind->getSizeInBytes->masm->ld->catch->finally
SPARCMove#emitStore(Value, SPARCAddress, PlatformKind, SPARCDelayedControlTransfer, LIRFrameState, CompilationResultBuilder, SPARCMacroAssembler)::: move emit store:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->addr->generateSimm13OffsetLoad->delayedControlTransfer->emitControlTransfer->if->crb->masm->position->recordImplicitException->byteCount->kind->getSizeInBytes->masm->asRegister->st->catch->finally
SPARCMove#loadFromConstantTable(CompilationResultBuilder, SPARCMacroAssembler, Register, Constant, Register, SPARCDelayedControlTransfer):::This method creates a load from the constant section:::address->scratch->try->data->crb->createDataItem->size->data->getSize->if->masm->isImmediateConstantLoad->new->SPARCAddress->delaySlotInstruction->emitControlTransfer->crb->recordDataReferenceInCode->else->masm->getScratchRegister->sr->scratch->getRegister->crb->recordDataReferenceInCode->masm->sethix->new->SPARCAddress->masm->ld->return->catch->finally->if->scratch->close
SPARCOP3Op#newUnary(Op3s, Value, AllocatableValue)::: p3 op new unary:::return->newUnary
SPARCOP3Op#newUnary(Op3s, Value, AllocatableValue, LIRFrameState)::: p3 op new unary:::return->g0->LIRKind->rs2->getPlatformKind->value->asValue->new->SPARCOP3Op
SPARCOP3Op#newBinaryVoid(Op3s, AllocatableValue, Value)::: p3 op new binary void:::return->newBinaryVoid
SPARCOP3Op#newBinaryVoid(Op3s, AllocatableValue, Value, LIRFrameState)::: p3 op new binary void:::return->g0->LIRKind->rs2->getPlatformKind->value->asValue->new->SPARCOP3Op
SPARCOP3Op#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: p3 op emit code:::getDelayedControlTransfer->emitControlTransfer->if->crb->masm->position->recordImplicitException->emitOp3
SPARCOP3Op#emitOp3(SPARCMacroAssembler, Op3s, Value, Value)::: p3 op emit op3:::g0->LIRKind->rs2->getPlatformKind->value->asValue->emitOp3
SPARCOP3Op#emitOp3(SPARCMacroAssembler, Op3s, Value, Value, Value)::: p3 op emit op3:::if->isJavaConstant->constant->asJavaConstant->simm13->if->constant->isNull->else->constant->asLong->asRegister->asRegister->emit->else->if->isRegister->asRegister->asRegister->asRegister->emit->else->throw->String->format->shouldNotReachHere
SPARCOPFOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: op emit code:::getDelayedControlTransfer->emitControlTransfer->if->crb->masm->position->recordImplicitException->asRegister->asRegister->asRegister->emit
SPARCPauseOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: pause op emit code:::masm->pause
SPARCPrefetchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: prefetch op emit code:::masm->address->toAddress->prefetch
SPARCSaveRegistersOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: save registers op emit code:::slot0Address->crb->asAddress->masm->stx->masm->lddf->for->i
SPARCSaveRegistersOp#getSlots()::: save registers op get slots:::return
SPARCSaveRegistersOp#supportsRemove()::: save registers op supports remove:::return
SPARCSaveRegistersOp#remove(EconomicSet)::: save registers op remove:::if->throw->new->UnsupportedOperationException->return->prune
SPARCSaveRegistersOp#prune(EconomicSet, Register[])::: save registers op prune:::pruned->for->i->return
SPARCSaveRegistersOp#getMap(FrameMap)::: save registers op get map:::total->for->i->keys->new->RegisterArr->values->new->intArr->if->mapIndex->for->i->return->new->RegisterSaveLayout
SPARCSaveRegistersOp#indexForStackSlot(FrameMap, StackSlot):::Computes the index of a stack slot relative to slot 0:::value->frameMap->offsetForStackSlot->frameMap->getTarget->return
SPARCTailDelayedLIRInstruction#setDelayedControlTransfer(SPARCDelayedControlTransfer)::: tail delayed instruction set delayed control transfer:::getSPARCLIRInstructionStore
SPARCTailDelayedLIRInstruction#getDelayedControlTransfer()::: tail delayed instruction get delayed control transfer:::return->getSPARCLIRInstructionStore
