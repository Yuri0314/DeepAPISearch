org.graalvm.compiler.lir.sparc.SPARCAddressValue#toAddress()->SPARCAddress::: address value to address
org.graalvm.compiler.lir.sparc.SPARCAddressValue#isValidImplicitNullCheckFor(Value, int)->boolean::: address value is valid implicit null check for
org.graalvm.compiler.lir.sparc.SPARCArithmetic.FloatConvertOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: float convert op emit code
org.graalvm.compiler.lir.sparc.SPARCArithmetic.RemOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: rem op emit code
org.graalvm.compiler.lir.sparc.SPARCArithmetic.SPARCIMulccOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: mulcc op emit code
org.graalvm.compiler.lir.sparc.SPARCArithmetic.SPARCLMulccOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: mulcc op emit code
org.graalvm.compiler.lir.sparc.SPARCArithmetic.MulHighOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: mul high op emit code
org.graalvm.compiler.lir.sparc.SPARCArrayEqualsOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: array equals op emit code
org.graalvm.compiler.lir.sparc.SPARCBitManipulationOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: bit manipulation op emit code
org.graalvm.compiler.lir.sparc.SPARCBlockEndOp#getSPARCLIRInstructionStore()->SPARCLIRInstructionMixinStore::: block end op get instruction store
org.graalvm.compiler.lir.sparc.SPARCBlockEndOp#emitCode(CompilationResultBuilder)->void::: block end op emit code
org.graalvm.compiler.lir.sparc.SPARCBlockEndOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: block end op emit code
org.graalvm.compiler.lir.sparc.SPARCBreakpointOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: breakpoint op emit code
org.graalvm.compiler.lir.sparc.SPARCByteSwapOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: byte swap op emit code
org.graalvm.compiler.lir.sparc.SPARCCall.CallOp#destroysCallerSavedRegisters()->boolean::: call op destroys caller saved registers
org.graalvm.compiler.lir.sparc.SPARCCall.DirectCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: direct call op emit code
org.graalvm.compiler.lir.sparc.SPARCCall.DirectCallOp#emitCallPrefixCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: direct call op emit call prefix code
org.graalvm.compiler.lir.sparc.SPARCCall.DirectCallOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)->void::: direct call op emit control transfer
org.graalvm.compiler.lir.sparc.SPARCCall.DirectCallOp#resetState()->void::: direct call op reset state
org.graalvm.compiler.lir.sparc.SPARCCall.IndirectCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: indirect call op emit code
org.graalvm.compiler.lir.sparc.SPARCCall.IndirectCallOp#verify()->void::: indirect call op verify
org.graalvm.compiler.lir.sparc.SPARCCall.ForeignCallOp#destroysCallerSavedRegisters()->boolean::: foreign call op destroys caller saved registers
org.graalvm.compiler.lir.sparc.SPARCCall.DirectNearForeignCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: direct near foreign call op emit code
org.graalvm.compiler.lir.sparc.SPARCCall.DirectFarForeignCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: direct far foreign call op emit code
org.graalvm.compiler.lir.sparc.SPARCCall#directCall(CompilationResultBuilder, SPARCMacroAssembler, InvokeTarget, Register, LIRFrameState)->void::: call direct call
org.graalvm.compiler.lir.sparc.SPARCCall#indirectJmp(CompilationResultBuilder, SPARCMacroAssembler, Register, InvokeTarget)->void::: call indirect jmp
org.graalvm.compiler.lir.sparc.SPARCCall#indirectCall(CompilationResultBuilder, SPARCMacroAssembler, Register, InvokeTarget, LIRFrameState)->void::: call indirect call
org.graalvm.compiler.lir.sparc.SPARCControlFlow.ReturnOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: return op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.ReturnOp#emitCodeHelper(CompilationResultBuilder, SPARCMacroAssembler)->void::: return op emit code helper
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CompareBranchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: compare branch op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CompareBranchOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)->void::: compare branch op emit control transfer
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CompareBranchOp#resetState()->void::: compare branch op reset state
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CompareBranchOp#verify()->void::: compare branch op verify
org.graalvm.compiler.lir.sparc.SPARCControlFlow#isShortBranch(SPARCAssembler, int, LabelHint, Label)->boolean::: control flow is short branch
org.graalvm.compiler.lir.sparc.SPARCControlFlow.BranchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: branch op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: strategy switch op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition)->Label:::This method caches the generated labels over two assembly passes to get information about branch lengths.
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition, Label)->void::: switch closure conditional jump
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp#requestHint(SPARCMacroAssembler, Label)->LabelHint::: strategy switch op request hint
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp#estimateEmbeddedSize(Constant)->int::: strategy switch op estimate embedded size
org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp#estimateSize()->SizeEstimate::: strategy switch op estimate size
org.graalvm.compiler.lir.sparc.SPARCControlFlow.TableSwitchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: table switch op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.TableSwitchOp#estimateSize()->SizeEstimate::: table switch op estimate size
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CondMoveOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: cond move op emit code
org.graalvm.compiler.lir.sparc.SPARCControlFlow.CondMoveOp#estimateSize()->SizeEstimate::: cond move op estimate size
org.graalvm.compiler.lir.sparc.SPARCControlFlow#fromCondition(boolean, Condition, boolean)->ConditionFlag::: control flow from condition
org.graalvm.compiler.lir.sparc.SPARCDelayedControlTransfer#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)->void:::This method must be called, to generate the control transfer, but without any Nop in the delay slot.
org.graalvm.compiler.lir.sparc.SPARCDelayedControlTransfer#resetState()->void::: delayed control transfer reset state
org.graalvm.compiler.lir.sparc.SPARCFloatCompareOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: float compare op emit code
org.graalvm.compiler.lir.sparc.SPARCFloatCompareOp#verify()->void::: float compare op verify
org.graalvm.compiler.lir.sparc.SPARCFrameMap#totalFrameSize()->int::: frame map total frame size
org.graalvm.compiler.lir.sparc.SPARCFrameMap#currentFrameSize()->int::: frame map current frame size
org.graalvm.compiler.lir.sparc.SPARCFrameMap#spillSlotSize(ValueKind)->int:::In SPARC we have spill slots word aligned.
org.graalvm.compiler.lir.sparc.SPARCFrameMap#offsetForStackSlot(StackSlot)->int::: frame map offset for stack slot
org.graalvm.compiler.lir.sparc.SPARCFrameMap#frameNeedsAllocating()->boolean::: frame map frame needs allocating
org.graalvm.compiler.lir.sparc.SPARCFrameMap#allocateDeoptimizationRescueSlot()->StackSlot::: frame map allocate deoptimization rescue slot
org.graalvm.compiler.lir.sparc.SPARCFrameMapBuilder#allocateDeoptimizationRescueSlot()->StackSlot::: frame map builder allocate deoptimization rescue slot
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)->CompositeValue::: immediate address value for each component
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)->void::: immediate address value visit each component
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#toAddress()->SPARCAddress::: immediate address value to address
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#isValidImplicitNullCheckFor(Value, int)->boolean::: immediate address value is valid implicit null check for
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#toString()->String::: immediate address value to string
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#equals(Object)->boolean::: immediate address value equals
org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue#hashCode()->int::: immediate address value hash code
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)->CompositeValue::: indexed address value for each component
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)->void::: indexed address value visit each component
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#toAddress()->SPARCAddress::: indexed address value to address
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#isValidImplicitNullCheckFor(Value, int)->boolean::: indexed address value is valid implicit null check for
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#toString()->String::: indexed address value to string
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#equals(Object)->boolean::: indexed address value equals
org.graalvm.compiler.lir.sparc.SPARCIndexedAddressValue#hashCode()->int::: indexed address value hash code
org.graalvm.compiler.lir.sparc.SPARCJumpOp#emitControlTransfer(CompilationResultBuilder, SPARCMacroAssembler)->void::: jump op emit control transfer
org.graalvm.compiler.lir.sparc.SPARCJumpOp#emitCode(CompilationResultBuilder)->void::: jump op emit code
org.graalvm.compiler.lir.sparc.SPARCJumpOp#resetState()->void::: jump op reset state
org.graalvm.compiler.lir.sparc.SPARCJumpOp#getSPARCLIRInstructionStore()->SPARCLIRInstructionMixinStore::: jump op get instruction store
org.graalvm.compiler.lir.sparc.SPARCLIRInstruction#emitCode(CompilationResultBuilder)->void::: instruction emit code
org.graalvm.compiler.lir.sparc.SPARCLIRInstruction#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: instruction emit code
org.graalvm.compiler.lir.sparc.SPARCLIRInstruction#getSPARCLIRInstructionStore()->SPARCLIRInstructionMixinStore::: instruction get instruction store
org.graalvm.compiler.lir.sparc.SPARCLIRInstruction#asImmediate(JavaConstant)->int::: instruction as immediate
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin#leavesRegisterWindow()->boolean::: instruction mixin leaves register window
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin#estimateSize()->SizeEstimate::: instruction mixin estimate size
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin#getSPARCLIRInstructionStore()->SPARCLIRInstructionMixinStore::: instruction mixin get instruction store
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SizeEstimate#create(int, int)->SizeEstimate::: size estimate create
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SizeEstimate#create(int)->SizeEstimate::: size estimate create
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SizeEstimate#toString()->String::: size estimate to string
org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SPARCLIRInstructionMixinStore#toString()->String::: instruction mixin store to string
org.graalvm.compiler.lir.sparc.SPARCLoadConstantTableBaseOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: load constant table base op emit code
org.graalvm.compiler.lir.sparc.SPARCLoadConstantTableBaseOp#getResult()->AllocatableValue::: load constant table base op get result
org.graalvm.compiler.lir.sparc.SPARCLoadConstantTableBaseOp#setAlive(LIR, boolean)->void::: load constant table base op set alive
org.graalvm.compiler.lir.sparc.SPARCMove.LoadInlineConstant#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: load inline constant emit code
org.graalvm.compiler.lir.sparc.SPARCMove.LoadInlineConstant#getConstant()->Constant::: load inline constant get constant
org.graalvm.compiler.lir.sparc.SPARCMove.LoadInlineConstant#getResult()->AllocatableValue::: load inline constant get result
org.graalvm.compiler.lir.sparc.SPARCMove.LoadConstantFromTable#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: load constant from table emit code
org.graalvm.compiler.lir.sparc.SPARCMove.Move#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: move emit code
org.graalvm.compiler.lir.sparc.SPARCMove.Move#getInput()->AllocatableValue::: move get input
org.graalvm.compiler.lir.sparc.SPARCMove.Move#getResult()->AllocatableValue::: move get result
org.graalvm.compiler.lir.sparc.SPARCMove.MoveFpGp#getInput()->AllocatableValue::: move fp gp get input
org.graalvm.compiler.lir.sparc.SPARCMove.MoveFpGp#getResult()->AllocatableValue::: move fp gp get result
org.graalvm.compiler.lir.sparc.SPARCMove.MoveFpGp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: move fp gp emit code
org.graalvm.compiler.lir.sparc.SPARCMove.MemOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)->void::: mem op emit mem access
org.graalvm.compiler.lir.sparc.SPARCMove.MemOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: mem op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.MemOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: mem op make null check for
org.graalvm.compiler.lir.sparc.SPARCMove.LoadOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)->void::: load op emit mem access
org.graalvm.compiler.lir.sparc.SPARCMove.LoadAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: load address op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.LoadDataAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: load data address op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.LoadDataAddressOp#estimateSize()->SizeEstimate::: load data address op estimate size
org.graalvm.compiler.lir.sparc.SPARCMove.MembarOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: membar op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.MembarOp#verify()->void::: membar op verify
org.graalvm.compiler.lir.sparc.SPARCMove.NullCheckOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: null check op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.NullCheckOp#getCheckedValue()->Value::: null check op get checked value
org.graalvm.compiler.lir.sparc.SPARCMove.NullCheckOp#getState()->LIRFrameState::: null check op get state
org.graalvm.compiler.lir.sparc.SPARCMove.CompareAndSwapOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: compare and swap op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.StackLoadAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: stack load address op emit code
org.graalvm.compiler.lir.sparc.SPARCMove.StoreOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)->void::: store op emit mem access
org.graalvm.compiler.lir.sparc.SPARCMove.StoreConstantOp#emitMemAccess(CompilationResultBuilder, SPARCMacroAssembler)->void::: store constant op emit mem access
org.graalvm.compiler.lir.sparc.SPARCMove#move(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)->void::: move move
org.graalvm.compiler.lir.sparc.SPARCMove#move(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, Value, SPARCDelayedControlTransfer)->void::: move move
org.graalvm.compiler.lir.sparc.SPARCMove#const2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, SPARCDelayedControlTransfer, JavaConstant)->void::: move const2stack
org.graalvm.compiler.lir.sparc.SPARCMove#stack2stack(CompilationResultBuilder, SPARCMacroAssembler, PlatformKind, PlatformKind, Value, Value, SPARCDelayedControlTransfer)->void::: move stack2stack
org.graalvm.compiler.lir.sparc.SPARCMove#stack2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)->void::: move stack2stack
org.graalvm.compiler.lir.sparc.SPARCMove#reg2stack(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)->void::: move reg2stack
org.graalvm.compiler.lir.sparc.SPARCMove#reg2reg(CompilationResultBuilder, SPARCMacroAssembler, Value, Value, SPARCDelayedControlTransfer)->void::: move reg2reg
org.graalvm.compiler.lir.sparc.SPARCMove#generateSimm13OffsetLoad(SPARCAddress, SPARCMacroAssembler, Register)->SPARCAddress:::Guarantees that the given SPARCAddress given before is loadable by subsequent load/store instruction
org.graalvm.compiler.lir.sparc.SPARCMove#const2reg(CompilationResultBuilder, SPARCMacroAssembler, Value, Register, JavaConstant, SPARCDelayedControlTransfer)->void::: move const2reg
org.graalvm.compiler.lir.sparc.SPARCMove#compareAndSwap(CompilationResultBuilder, SPARCMacroAssembler, AllocatableValue, AllocatableValue, AllocatableValue, SPARCDelayedControlTransfer)->void::: move compare and swap
org.graalvm.compiler.lir.sparc.SPARCMove#emitLoad(CompilationResultBuilder, SPARCMacroAssembler, SPARCAddress, Value, boolean, PlatformKind, SPARCDelayedControlTransfer, LIRFrameState)->void::: move emit load
org.graalvm.compiler.lir.sparc.SPARCMove#emitStore(Value, SPARCAddress, PlatformKind, SPARCDelayedControlTransfer, LIRFrameState, CompilationResultBuilder, SPARCMacroAssembler)->void::: move emit store
org.graalvm.compiler.lir.sparc.SPARCMove#loadFromConstantTable(CompilationResultBuilder, SPARCMacroAssembler, Register, Constant, Register, SPARCDelayedControlTransfer)->int:::This method creates a load from the constant section
org.graalvm.compiler.lir.sparc.SPARCOP3Op#newUnary(Op3s, Value, AllocatableValue)->SPARCOP3Op::: p3 op new unary
org.graalvm.compiler.lir.sparc.SPARCOP3Op#newUnary(Op3s, Value, AllocatableValue, LIRFrameState)->SPARCOP3Op::: p3 op new unary
org.graalvm.compiler.lir.sparc.SPARCOP3Op#newBinaryVoid(Op3s, AllocatableValue, Value)->SPARCOP3Op::: p3 op new binary void
org.graalvm.compiler.lir.sparc.SPARCOP3Op#newBinaryVoid(Op3s, AllocatableValue, Value, LIRFrameState)->SPARCOP3Op::: p3 op new binary void
org.graalvm.compiler.lir.sparc.SPARCOP3Op#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: p3 op emit code
org.graalvm.compiler.lir.sparc.SPARCOP3Op#emitOp3(SPARCMacroAssembler, Op3s, Value, Value)->void::: p3 op emit op3
org.graalvm.compiler.lir.sparc.SPARCOP3Op#emitOp3(SPARCMacroAssembler, Op3s, Value, Value, Value)->void::: p3 op emit op3
org.graalvm.compiler.lir.sparc.SPARCOPFOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.sparc.SPARCPauseOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: pause op emit code
org.graalvm.compiler.lir.sparc.SPARCPrefetchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: prefetch op emit code
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)->void::: save registers op emit code
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#getSlots()->AllocatableValue[]::: save registers op get slots
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#supportsRemove()->boolean::: save registers op supports remove
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#remove(EconomicSet)->int::: save registers op remove
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#prune(EconomicSet, Register[])->int::: save registers op prune
org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp#getMap(FrameMap)->RegisterSaveLayout::: save registers op get map
org.graalvm.compiler.lir.sparc.SPARCTailDelayedLIRInstruction#setDelayedControlTransfer(SPARCDelayedControlTransfer)->void::: tail delayed instruction set delayed control transfer
org.graalvm.compiler.lir.sparc.SPARCTailDelayedLIRInstruction#getDelayedControlTransfer()->SPARCDelayedControlTransfer::: tail delayed instruction get delayed control transfer
