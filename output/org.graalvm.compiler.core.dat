GraalCompilerOptions_OptionDescriptors#get(String)::: graal compiler options_ option descriptors get:::switch->return->OptionDescriptor->create->return->OptionDescriptor->new->StringArr->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return
GraalCompilerOptions_OptionDescriptors#iterator()::: graal compiler options_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
CompilationPrinter#begin(OptionValues, CompilationIdentifier, JavaMethod, int):::Gets an object that will report statistics for a compilation if GraalCompilerOptions#PrintCompilation is enabled and TTY is not suppressed:::if->PrintCompilation->getValue->TTY->isSuppressed->return->new->CompilationPrinter->return
CompilationPrinter#getMethodDescription()::: compilation printer get method description:::return->String->id->toString->method->getDeclaringClass->getName->method->getName->method->getSignature->toMethodDescriptor->format
CompilationPrinter#finish(CompilationResult):::Notifies this object that the compilation finished and the informational line should be printed to TTY.:::if->stop->System->nanoTime->duration->targetCodeSize->result->getTargetCodeSize->bytecodeSize->result->getBytecodeSize->if->TTY->getMethodDescription->String->format->println->else->allocatedBytesAfter->getCurrentThreadAllocatedBytes->allocatedKBytes->TTY->getMethodDescription->String->format->println
CompilationWrapper#handleException(Throwable):::Handles an uncaught exception.:::
CompilationWrapper#lookupAction(OptionValues, Throwable):::Gets the action to take based on the value of GraalCompilerOptions#CompilationBailoutAsFailure, GraalCompilerOptions#CompilationFailureAction and GraalCompilerOptions#ExitVMOnException in options:::if->CompilationBailoutAsFailure->getValue->return->if->ExitVMOnException->getValue->if->CompilationFailureAction->hasBeenSet->CompilationFailureAction->getValue->TTY->CompilationFailureAction->getName->CompilationFailureAction->getValue->ExitVMOnException->getName->printf->return->return->CompilationFailureAction->getValue
CompilationWrapper#performCompilation(DebugContext):::Perform the compilation wrapped by this object.:::
CompilationWrapper#toString():::Gets a value that represents the input to the compilation.:::
CompilationWrapper#createRetryDebugContext(DebugContext, OptionValues, PrintStream):::Creates the DebugContext to use when retrying a compilation.:::
CompilationWrapper#run(DebugContext)::: compilation wrapper run:::try->return->performCompilation->catch->initialOptions->initialDebug->getOptions->synchronized->action->lookupAction->adjustAction->if->return->handleException->if->baos->new->ByteArrayOutputStream->try->ps->new->PrintStream->ps->Thread->currentThread->printf->cause->printStackTrace->ps->CompilationFailureAction->getName->CompilationFailureAction->getName->printf->ps->CompilationFailureAction->getName->CompilationFailureAction->getName->printf->catch->finally->TTY->baos->toString->print->return->handleException->if->Dump->hasBeenSet->return->handleException->dumpPath->try->dir->getPath->if->dumpName->PathUtilities->toString->sanitizeFileName->new->File->dumpPath->mkdirs->if->dumpPath->exists->TTY->println->catch->TTY->println->t->printStackTrace->finally->message->baos->new->ByteArrayOutputStream->try->ps->new->PrintStream->ps->Thread->currentThread->printf->cause->printStackTrace->ps->CompilationFailureAction->getName->CompilationFailureAction->getName->printf->ps->CompilationFailureAction->getName->CompilationFailureAction->getName->printf->if->ps->println->else->ps->println->baos->toString->catch->finally->TTY->print->if->return->handleException->retryLogFile->new->File->try->ps->new->FileOutputStream->new->PrintStream->ps->print->catch->TTY->printf->finally->retryOptions->dumpPath->getPath->new->OptionValues->logBaos->new->ByteArrayOutputStream->ps->new->PrintStream->try->retryDebug->createRetryDebugContext->res->performCompilation->ps->println->maybeExitVM->return->catch->ps->println->e->printStackTrace->res->handleException->maybeExitVM->return->finally->ps->close->try->fos->new->FileOutputStream->fos->logBaos->toByteArray->write->catch->TTY->printf->finally->finally
CompilationWrapper#exitHostVM(int):::Calls System#exit(int) in the runtime embedding the Graal compiler:::
CompilationWrapper#maybeExitVM(ExceptionAction)::: compilation wrapper maybe exit m:::if->TTY->println->exitHostVM
CompilationWrapper#adjustAction(OptionValues, ExceptionAction):::Adjusts initialAction if necessary based on GraalCompilerOptions#MaxCompilationProblemsPerAction.:::action->maxProblems->MaxCompilationProblemsPerAction->getValue->if->synchronized->while->problems->problemsHandledPerAction->getOrDefault->if->if->TTY->action->quieter->printf->problemsHandledPerAction->put->action->quieter->else->break->problemsHandledPerAction->problemsHandledPerAction->getOrDefault->put->return
CompilerThread#run()::: compiler thread run:::getClass->getClassLoader->setContextClassLoader->super->run
CompilerThreadFactory#newThread(Runnable)::: compiler thread factory new thread:::return->new->CompilerThread
GraalCompiler.Request#execute():::Executes this compilation request.:::return->GraalCompiler->compile
GraalCompiler#compileGraph(StructuredGraph, ResolvedJavaMethod, Providers, Backend, PhaseSuite, OptimisticOptimizations, ProfilingInfo, Suites, LIRSuites, T, CompilationResultBuilderFactory, boolean):::Requests compilation of a given graph.:::return->new->Request<>->compile
GraalCompiler#compile(Request):::Services a given compilation request.:::debug->getDebug->try->alarm->CompilationAlarm->getOptions->trackCompilationPeriod->try->s0->debug->getCodeCache->scope->a->CompilerTimer->start->emitFrontEnd->emitBackEnd->if->catch->throw->debug->handle->finally->checkForRequestedCrash->return->catch->finally
GraalCompiler#checkForRequestedCrash(StructuredGraph):::Checks whether the GraalCompilerOptions#CrashAt option indicates that the compilation of graph should result in an exception.:::value->graph->getOptions->getValue->if->bailout->permanentBailout->methodPattern->if->value->endsWith->value->value->length->length->substring->else->if->value->endsWith->value->value->length->length->substring->crashLabel->if->contains->if->method->graph->method->filters->MethodFilter->parse->foreach->if->filter->matches->method->format->if->if->throw->new->PermanentBailoutException->if->throw->new->RetryableBailoutException->throw->new->RuntimeException
GraalCompiler#emitFrontEnd(Providers, TargetProvider, StructuredGraph, PhaseSuite, OptimisticOptimizations, ProfilingInfo, Suites):::Builds the graph, optimizes it.:::debug->graph->getDebug->try->s->debug->scope->a->FrontEnd->start->highTierContext->new->HighTierContext->if->graph->start->next->graphBuilderSuite->apply->new->DeadCodeEliminationPhase->apply->debug->dump->else->debug->dump->suites->getHighTier->apply->graph->maybeCompress->debug->dump->midTierContext->new->MidTierContext->suites->getMidTier->apply->graph->maybeCompress->debug->dump->lowTierContext->new->LowTierContext->suites->getLowTier->apply->debug->dump->debug->graph->getLastSchedule->dump->graph->logInliningTree->catch->throw->debug->handle->finally->graph->checkCancellation
GraalCompiler#getCompilationUnitName(StructuredGraph, T)::: graal compiler get compilation unit name:::if->compilationResult->getName->return->compilationResult->getName->method->graph->method->if->return->return->method->format
GraalServiceThread#run()::: graal service thread run:::beforeRun->try->runnable->run->catch->finally->afterRun
GraalServiceThread#afterRun():::Substituted by {@code com.oracle.svm.graal.hotspot.libgraal:::
GraalServiceThread#beforeRun():::Substituted by {@code com.oracle.svm.graal.hotspot.libgraal:::
LIRGenerationPhase#run(TargetDescription, LIRGenerationResult, LIRGenerationPhase.LIRGenerationContext)::: generation phase run:::nodeLirBuilder->graph->schedule->blocks->lirGenRes->getLIR->getControlFlowGraph->getBlocks->foreach->matchBlock->foreach->schedule->getBlockToNodesMap->emitBlock->beforeRegisterAllocation->nodeCount->graph->getDebug->graph->getNodeCount->add
LIRGenerationPhase#emitBlock(NodeLIRBuilderTool, LIRGenerationResult, Block, StructuredGraph, BlockMap>)::: generation phase emit block:::nodeLirGen->doBlock->lir->lirGenRes->getLIR->debug->lir->getDebug->instructionCounter->lir->getLIRforBlock->size->add
LIRGenerationPhase#matchBlock(NodeLIRBuilderTool, Block, StructuredGraph, ScheduleResult)::: generation phase match block:::nodeLirGen->matchBlock
LIRGenerationPhase#verifyPredecessors(LIRGenerationResult, Block)::: generation phase verify predecessors:::foreach->block->getPredecessors->if->block->isLoopHeader->pred->isLoopEnd->return
LIRGenerationPhase#isProcessed(LIRGenerationResult, Block)::: generation phase is processed:::return->lirGenRes->getLIR->getLIRforBlock
