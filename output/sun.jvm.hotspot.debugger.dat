sun.jvm.hotspot.debugger.Address#equals(Object)->boolean:::This is stated explicitly here because it is important for       implementations to understand that equals() and hashCode() must       absolutely, positively work properly -- i.e., two Address       objects representing the same address are both equal (via       equals()) and have the same hash code.
sun.jvm.hotspot.debugger.Address#hashCode()->int:::This is stated explicitly here because it is important for       implementations to understand that equals() and hashCode() must       absolutely, positively work properly -- i.e., two Address       objects representing the same address are both equal (via       equals()) and have the same hash code.
sun.jvm.hotspot.debugger.Address#getCIntegerAt(long, long, boolean)->long::: address get integer at
sun.jvm.hotspot.debugger.Address#getAddressAt(long)->Address:::This returns null if the address at the given offset is NULL.
sun.jvm.hotspot.debugger.Address#getCompOopAddressAt(long)->Address:::Returns the decoded address at the given offset
sun.jvm.hotspot.debugger.Address#getCompKlassAddressAt(long)->Address::: address get comp klass address at
sun.jvm.hotspot.debugger.Address#getJBooleanAt(long)->boolean::: address get boolean at
sun.jvm.hotspot.debugger.Address#getJByteAt(long)->byte::: address get byte at
sun.jvm.hotspot.debugger.Address#getJCharAt(long)->char::: address get char at
sun.jvm.hotspot.debugger.Address#getJDoubleAt(long)->double::: address get double at
sun.jvm.hotspot.debugger.Address#getJFloatAt(long)->float::: address get float at
sun.jvm.hotspot.debugger.Address#getJIntAt(long)->int::: address get int at
sun.jvm.hotspot.debugger.Address#getJLongAt(long)->long::: address get long at
sun.jvm.hotspot.debugger.Address#getJShortAt(long)->short::: address get short at
sun.jvm.hotspot.debugger.Address#getOopHandleAt(long)->OopHandle:::This returns null if the address at the given offset is NULL.
sun.jvm.hotspot.debugger.Address#getCompOopHandleAt(long)->OopHandle::: address get comp oop handle at
sun.jvm.hotspot.debugger.Address#setCIntegerAt(long, long, long)->void:::Sets a C integer numBytes in size at the specified offset
sun.jvm.hotspot.debugger.Address#setAddressAt(long, Address)->void:::Sets an Address at the specified location.
sun.jvm.hotspot.debugger.Address#setJBooleanAt(long, boolean)->void::: address set boolean at
sun.jvm.hotspot.debugger.Address#setJByteAt(long, byte)->void::: address set byte at
sun.jvm.hotspot.debugger.Address#setJCharAt(long, char)->void::: address set char at
sun.jvm.hotspot.debugger.Address#setJDoubleAt(long, double)->void::: address set double at
sun.jvm.hotspot.debugger.Address#setJFloatAt(long, float)->void::: address set float at
sun.jvm.hotspot.debugger.Address#setJIntAt(long, int)->void::: address set int at
sun.jvm.hotspot.debugger.Address#setJLongAt(long, long)->void::: address set long at
sun.jvm.hotspot.debugger.Address#setJShortAt(long, short)->void::: address set short at
sun.jvm.hotspot.debugger.Address#setOopHandleAt(long, OopHandle)->void::: address set oop handle at
sun.jvm.hotspot.debugger.Address#addOffsetTo(long)->Address:::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle, because interior object pointers       are not allowed
sun.jvm.hotspot.debugger.Address#addOffsetToAsOopHandle(long)->OopHandle:::This method had to be added in order to support heap iteration       in the debugging system, and is effectively the dangerous       operation of allowing interior object pointers
sun.jvm.hotspot.debugger.Address#minus(Address)->long:::Performs the subtraction "this - arg", returning the resulting       offset in bytes
sun.jvm.hotspot.debugger.Address#lessThan(Address)->boolean:::Performs unsigned comparison "this < arg"
sun.jvm.hotspot.debugger.Address#lessThanOrEqual(Address)->boolean:::Performs unsigned comparison "this <= arg"
sun.jvm.hotspot.debugger.Address#greaterThan(Address)->boolean:::Performs unsigned comparison "this > arg"
sun.jvm.hotspot.debugger.Address#greaterThanOrEqual(Address)->boolean:::Performs unsigned comparison "this >= arg"
sun.jvm.hotspot.debugger.Address#andWithMask(long)->Address:::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle
sun.jvm.hotspot.debugger.Address#orWithMask(long)->Address:::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle
sun.jvm.hotspot.debugger.Address#xorWithMask(long)->Address:::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle
sun.jvm.hotspot.debugger.Address#asLongValue()->long::: address as long value
sun.jvm.hotspot.debugger.AddressException#getAddress()->long::: address exception get address
sun.jvm.hotspot.debugger.AddressException#getMessage()->String::: address exception get message
sun.jvm.hotspot.debugger.DataSource#readByte()->byte::: data source read byte
sun.jvm.hotspot.debugger.DataSource#readShort()->short::: data source read short
sun.jvm.hotspot.debugger.DataSource#readInt()->int::: data source read int
sun.jvm.hotspot.debugger.DataSource#readLong()->long::: data source read long
sun.jvm.hotspot.debugger.DataSource#read(byte[])->int::: data source read
sun.jvm.hotspot.debugger.DataSource#seek(long)->void::: data source seek
sun.jvm.hotspot.debugger.DataSource#getFilePointer()->long::: data source get file pointer
sun.jvm.hotspot.debugger.DataSource#close()->void::: data source close
sun.jvm.hotspot.debugger.Debugger#hasProcessList()->boolean:::Indicates whether this underlying debugger can provide a list of       currently-running processes.
sun.jvm.hotspot.debugger.Debugger#getProcessList()->List:::Provide a snapshot of the list of currently-running processes in       the form of a List of ProcessInfo objects
sun.jvm.hotspot.debugger.Debugger#attach(int)->void:::If an error occurs during attachment (i.e., "no such process"),       the thrown DebuggerException will contain a description of the       error in its message string.
sun.jvm.hotspot.debugger.Debugger#attach(String, String)->void:::This attaches the debugger to the given coreFileName, which is       assumed to have been generated from the specified       executableName
sun.jvm.hotspot.debugger.Debugger#detach()->boolean:::Detach from the remote process
sun.jvm.hotspot.debugger.Debugger#parseAddress(String)->Address:::Parse an address from a hex string in the format "0xFFFFFFFF"
sun.jvm.hotspot.debugger.Debugger#getAddressValue(Address)->long:::Returns the 64-bit value of an Address
sun.jvm.hotspot.debugger.Debugger#getOS()->String:::Support for remote debugging
sun.jvm.hotspot.debugger.Debugger#getCPU()->String:::Support for remote debugging
sun.jvm.hotspot.debugger.Debugger#getMachineDescription()->MachineDescription:::Retrieve the machine description for the underlying hardware for       the cases in which we need to do, for example, machine-dependent       byte swapping
sun.jvm.hotspot.debugger.Debugger#hasConsole()->boolean:::Find out whether this debugger has a console available on which       commands can be executed; see executeCommandOnConsole, below
sun.jvm.hotspot.debugger.Debugger#consoleExecuteCommand(String)->String:::If the underlying debugger has a console (as dbx does), this       provides access to it
sun.jvm.hotspot.debugger.Debugger#getConsolePrompt()->String:::If the underlying debugger has a console, this returns the       debugger-specific prompt which should be displayed.
sun.jvm.hotspot.debugger.Debugger#getCDebugger()->CDebugger:::If this platform supports C/C++ debugging via the CDebugger       interface, returns a CDebugger object; otherwise returns       null.
sun.jvm.hotspot.debugger.Debugger#getJBooleanSize()->long:::the following methods are intended only for RemoteDebuggerClient
sun.jvm.hotspot.debugger.Debugger#getJByteSize()->long::: debugger get byte size
sun.jvm.hotspot.debugger.Debugger#getJCharSize()->long::: debugger get char size
sun.jvm.hotspot.debugger.Debugger#getJDoubleSize()->long::: debugger get double size
sun.jvm.hotspot.debugger.Debugger#getJFloatSize()->long::: debugger get float size
sun.jvm.hotspot.debugger.Debugger#getJIntSize()->long::: debugger get int size
sun.jvm.hotspot.debugger.Debugger#getJLongSize()->long::: debugger get long size
sun.jvm.hotspot.debugger.Debugger#getJShortSize()->long::: debugger get short size
sun.jvm.hotspot.debugger.Debugger#getHeapOopSize()->long::: debugger get heap oop size
sun.jvm.hotspot.debugger.Debugger#getNarrowOopBase()->long::: debugger get narrow oop base
sun.jvm.hotspot.debugger.Debugger#getNarrowOopShift()->int::: debugger get narrow oop shift
sun.jvm.hotspot.debugger.Debugger#getKlassPtrSize()->long::: debugger get klass ptr size
sun.jvm.hotspot.debugger.Debugger#getNarrowKlassBase()->long::: debugger get narrow klass base
sun.jvm.hotspot.debugger.Debugger#getNarrowKlassShift()->int::: debugger get narrow klass shift
sun.jvm.hotspot.debugger.Debugger#readBytesFromProcess(long, long)->ReadResult::: debugger read bytes from process
sun.jvm.hotspot.debugger.Debugger#writeBytesToProcess(long, long, byte[])->void::: debugger write bytes to process
sun.jvm.hotspot.debugger.DebuggerBase.Fetcher#fetchPage(long, long)->Page::: fetcher fetch page
sun.jvm.hotspot.debugger.DebuggerBase#configureJavaPrimitiveTypeSizes(long, long, long, long, long, long, long, long)->void:::From the JVMDebugger interface
sun.jvm.hotspot.debugger.DebuggerBase#putHeapConst(long, long, long, int, long, int)->void::: debugger base put heap const
sun.jvm.hotspot.debugger.DebuggerBase#initCache(long, long)->void:::May be called by subclasses if desired to initialize the page       cache but may not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#setBigEndian(boolean)->void:::May be called by subclasses if needed (if the machine       description is not available at the time of cache       initialization, as on Solaris) but may not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#clearCache()->void:::May be called by subclasses to clear out the cache but may not       be overridden
sun.jvm.hotspot.debugger.DebuggerBase#disableCache()->void:::May be called by subclasses to disable the cache (for example,       when the target process has been resumed) but may not be       overridden
sun.jvm.hotspot.debugger.DebuggerBase#enableCache()->void:::May be called by subclasses to re-enable the cache (for example,       when the target process has been suspended) but may not be       overridden
sun.jvm.hotspot.debugger.DebuggerBase#readBytes(long, long)->byte[]:::May be called by subclasses directly but may not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#writeBytes(long, long, byte[])->void:::May be called by subclasses directly but may not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#readJBoolean(long)->boolean::: debugger base read boolean
sun.jvm.hotspot.debugger.DebuggerBase#readJByte(long)->byte::: debugger base read byte
sun.jvm.hotspot.debugger.DebuggerBase#readJChar(long)->char::: debugger base read char
sun.jvm.hotspot.debugger.DebuggerBase#readJDouble(long)->double::: debugger base read double
sun.jvm.hotspot.debugger.DebuggerBase#readJFloat(long)->float::: debugger base read float
sun.jvm.hotspot.debugger.DebuggerBase#readJInt(long)->int::: debugger base read int
sun.jvm.hotspot.debugger.DebuggerBase#readJLong(long)->long::: debugger base read long
sun.jvm.hotspot.debugger.DebuggerBase#readJShort(long)->short::: debugger base read short
sun.jvm.hotspot.debugger.DebuggerBase#readCInteger(long, long, boolean)->long::: debugger base read integer
sun.jvm.hotspot.debugger.DebuggerBase#writeJBoolean(long, boolean)->void::: debugger base write boolean
sun.jvm.hotspot.debugger.DebuggerBase#writeJByte(long, byte)->void::: debugger base write byte
sun.jvm.hotspot.debugger.DebuggerBase#writeJChar(long, char)->void::: debugger base write char
sun.jvm.hotspot.debugger.DebuggerBase#writeJDouble(long, double)->void::: debugger base write double
sun.jvm.hotspot.debugger.DebuggerBase#writeJFloat(long, float)->void::: debugger base write float
sun.jvm.hotspot.debugger.DebuggerBase#writeJInt(long, int)->void::: debugger base write int
sun.jvm.hotspot.debugger.DebuggerBase#writeJLong(long, long)->void::: debugger base write long
sun.jvm.hotspot.debugger.DebuggerBase#writeJShort(long, short)->void::: debugger base write short
sun.jvm.hotspot.debugger.DebuggerBase#writeCInteger(long, long, long)->void::: debugger base write integer
sun.jvm.hotspot.debugger.DebuggerBase#readAddressValue(long)->long::: debugger base read address value
sun.jvm.hotspot.debugger.DebuggerBase#readCompOopAddressValue(long)->long::: debugger base read comp oop address value
sun.jvm.hotspot.debugger.DebuggerBase#readCompKlassAddressValue(long)->long::: debugger base read comp klass address value
sun.jvm.hotspot.debugger.DebuggerBase#writeAddressValue(long, long)->void::: debugger base write address value
sun.jvm.hotspot.debugger.DebuggerBase#checkConfigured()->void:::Can be called by subclasses but can not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#checkJavaConfigured()->void:::Can be called by subclasses but can not be overridden
sun.jvm.hotspot.debugger.DebuggerBase#parseCacheNumPagesProperty(int)->int:::Possibly override page cache size with user-specified property
sun.jvm.hotspot.debugger.DebuggerBase#invalidatePageCache(long, long)->void:::Interim solution for allowing subclasses to write bytes to       process until we make that functionality available in the basic       Address interface
sun.jvm.hotspot.debugger.DebuggerBase#getJBooleanSize()->long::: debugger base get boolean size
sun.jvm.hotspot.debugger.DebuggerBase#getJByteSize()->long::: debugger base get byte size
sun.jvm.hotspot.debugger.DebuggerBase#getJCharSize()->long::: debugger base get char size
sun.jvm.hotspot.debugger.DebuggerBase#getJDoubleSize()->long::: debugger base get double size
sun.jvm.hotspot.debugger.DebuggerBase#getJFloatSize()->long::: debugger base get float size
sun.jvm.hotspot.debugger.DebuggerBase#getJIntSize()->long::: debugger base get int size
sun.jvm.hotspot.debugger.DebuggerBase#getJLongSize()->long::: debugger base get long size
sun.jvm.hotspot.debugger.DebuggerBase#getJShortSize()->long::: debugger base get short size
sun.jvm.hotspot.debugger.DebuggerBase#getHeapOopSize()->long::: debugger base get heap oop size
sun.jvm.hotspot.debugger.DebuggerBase#getNarrowOopBase()->long::: debugger base get narrow oop base
sun.jvm.hotspot.debugger.DebuggerBase#getNarrowOopShift()->int::: debugger base get narrow oop shift
sun.jvm.hotspot.debugger.DebuggerBase#getKlassPtrSize()->long::: debugger base get klass ptr size
sun.jvm.hotspot.debugger.DebuggerBase#getNarrowKlassBase()->long::: debugger base get narrow klass base
sun.jvm.hotspot.debugger.DebuggerBase#getNarrowKlassShift()->int::: debugger base get narrow klass shift
sun.jvm.hotspot.debugger.DebuggerUtilities#addressValueToString(long)->String::: debugger utilities address value to string
sun.jvm.hotspot.debugger.DebuggerUtilities#checkAlignment(long, long)->void::: debugger utilities check alignment
sun.jvm.hotspot.debugger.DebuggerUtilities#scanAddress(String)->long::: debugger utilities scan address
sun.jvm.hotspot.debugger.DebuggerUtilities#charToNibble(char)->int::: debugger utilities char to nibble
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJBoolean(byte[], long)->boolean::: debugger utilities data to boolean
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJByte(byte[], long)->byte::: debugger utilities data to byte
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJChar(byte[], long)->char::: debugger utilities data to char
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJDouble(byte[], long)->double::: debugger utilities data to double
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJFloat(byte[], long)->float::: debugger utilities data to float
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJInt(byte[], long)->int::: debugger utilities data to int
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJLong(byte[], long)->long::: debugger utilities data to long
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToJShort(byte[], long)->short::: debugger utilities data to short
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToCInteger(byte[], boolean)->long::: debugger utilities data to integer
sun.jvm.hotspot.debugger.DebuggerUtilities#dataToAddressValue(byte[])->long::: debugger utilities data to address value
sun.jvm.hotspot.debugger.DebuggerUtilities#jbooleanToData(boolean)->byte[]::: debugger utilities jboolean to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jbyteToData(byte)->byte[]::: debugger utilities jbyte to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jcharToData(char)->byte[]::: debugger utilities jchar to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jdoubleToData(double)->byte[]::: debugger utilities jdouble to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jfloatToData(float)->byte[]::: debugger utilities jfloat to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jintToData(int)->byte[]::: debugger utilities jint to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jlongToData(long)->byte[]::: debugger utilities jlong to data
sun.jvm.hotspot.debugger.DebuggerUtilities#jshortToData(short)->byte[]::: debugger utilities jshort to data
sun.jvm.hotspot.debugger.DebuggerUtilities#cIntegerToData(long, long)->byte[]::: debugger utilities c integer to data
sun.jvm.hotspot.debugger.InputLexer#close()->void::: input lexer close
sun.jvm.hotspot.debugger.InputLexer#parseBoolean()->boolean:::Parses a boolean (really either a 0 or 1 integer in US-ASCII       encoding) on the input stream
sun.jvm.hotspot.debugger.InputLexer#parseInt()->int:::Parses an int in US-ASCII encoding on the input stream
sun.jvm.hotspot.debugger.InputLexer#parseLong()->long:::Parses a long in US-ASCII encoding on the input stream
sun.jvm.hotspot.debugger.InputLexer#parseAddress()->long:::Parses an address in the form 0x12345678 in US-ASCII encoding on       the input stream
sun.jvm.hotspot.debugger.InputLexer#skipByte()->void::: input lexer skip byte
sun.jvm.hotspot.debugger.InputLexer#readByte()->byte:::Reads binary data; one byte
sun.jvm.hotspot.debugger.InputLexer#readBytes(byte[], int, int)->void:::Reads a block of binary data in BLOCKING fashion
sun.jvm.hotspot.debugger.InputLexer#readChar()->char:::Reads binary data; one 16-bit character in big-endian format
sun.jvm.hotspot.debugger.InputLexer#readUnsignedInt()->long:::Reads binary data; one 32-bit unsigned int in big-endian format
sun.jvm.hotspot.debugger.InputLexer#readByteString(int)->String:::Reads binary data; a US-ASCII string of the specified length
sun.jvm.hotspot.debugger.InputLexer#readCharString(int)->String:::Reads binary data; a Unicode string of the specified length
sun.jvm.hotspot.debugger.JVMDebugger#configureJavaPrimitiveTypeSizes(long, long, long, long, long, long, long, long)->void:::This intent is that this can be called late in the bootstrapping       sequence, after which the debugger can handle reading of Java       primitive types, and thereby implement the Java functionality in       class Address
sun.jvm.hotspot.debugger.JVMDebugger#putHeapConst(long, long, long, int, long, int)->void::: debugger put heap const
sun.jvm.hotspot.debugger.LongHashMap.Entry#getKey()->long:::Returns the key corresponding to this entry.
sun.jvm.hotspot.debugger.LongHashMap.Entry#getValue()->Object:::Returns the value corresponding to this entry
sun.jvm.hotspot.debugger.LongHashMap.Entry#setValue(Object)->Object:::Replaces the value corresponding to this entry with the specified value (optional operation)
sun.jvm.hotspot.debugger.LongHashMap.Entry#equals(Object)->boolean:::Compares the specified object with this entry for equality
sun.jvm.hotspot.debugger.LongHashMap.Entry#hashCode()->int:::Returns the hash code value for this map entry
sun.jvm.hotspot.debugger.LongHashMap#size()->int:::Returns the number of key-value mappings in this map.
sun.jvm.hotspot.debugger.LongHashMap#isEmpty()->boolean:::Returns <tt>true</tt> if this map contains no key-value mappings.
sun.jvm.hotspot.debugger.LongHashMap#get(long)->Object:::Returns the value to which this map maps the specified key
sun.jvm.hotspot.debugger.LongHashMap#containsKey(long)->boolean:::Returns <tt>true</tt> if this map contains a mapping for the specified key.
sun.jvm.hotspot.debugger.LongHashMap#getEntry(long)->Entry:::Returns the entry associated with the specified key in the HashMap
sun.jvm.hotspot.debugger.LongHashMap#containsValue(Object)->boolean:::Returns <tt>true</tt> if this map maps one or more keys to the specified value.
sun.jvm.hotspot.debugger.LongHashMap#put(long, Object)->Object:::Associates the specified value with the specified key in this map
sun.jvm.hotspot.debugger.LongHashMap#remove(long)->Object:::Removes the mapping for this key from this map if present.
sun.jvm.hotspot.debugger.LongHashMap#removeEntryForKey(long)->Entry:::Removes and returns the entry associated with the specified key in the HashMap
sun.jvm.hotspot.debugger.LongHashMap#removeEntry(Entry)->void:::Removes the specified entry from this HashMap (and increments modCount).
sun.jvm.hotspot.debugger.LongHashMap#clear()->void:::Removes all mappings from this map.
sun.jvm.hotspot.debugger.LongHashMap#rehash()->void:::Rehashes the contents of this map into a new <tt>HashMap</tt> instance with a larger capacity
sun.jvm.hotspot.debugger.LongHashMap#eq(Object, Object)->boolean::: long hash map eq
sun.jvm.hotspot.debugger.LongHashMap#newEntry(int, long, Object, Entry)->Entry::: long hash map new entry
sun.jvm.hotspot.debugger.LongHashMap#capacity()->int::: long hash map capacity
sun.jvm.hotspot.debugger.LongHashMap#loadFactor()->float::: long hash map load factor
sun.jvm.hotspot.debugger.MachineDescription#getAddressSize()->long:::Returns the size of an address in bytes
sun.jvm.hotspot.debugger.MachineDescription#cIntegerTypeMaxValue(long, boolean)->long:::Returns the maximum value of the C integer type with the given       size in bytes and signedness
sun.jvm.hotspot.debugger.MachineDescription#cIntegerTypeMinValue(long, boolean)->long:::Returns the minimum value of the C integer type with the given       size in bytes and signedness
sun.jvm.hotspot.debugger.MachineDescription#isBigEndian()->boolean:::Indicates whether the CPU is big- or little-endian
sun.jvm.hotspot.debugger.MachineDescription#isLP64()->boolean:::Indicates whether the underlying machine supports the LP64 data       model (currently only SPARC/64).
sun.jvm.hotspot.debugger.MachineDescriptionAArch64#getAddressSize()->long::: machine description arch64 get address size
sun.jvm.hotspot.debugger.MachineDescriptionAArch64#isLP64()->boolean::: machine description arch64 is p64
sun.jvm.hotspot.debugger.MachineDescriptionAArch64#isBigEndian()->boolean::: machine description arch64 is big endian
sun.jvm.hotspot.debugger.MachineDescriptionAMD64#getAddressSize()->long::: machine description d64 get address size
sun.jvm.hotspot.debugger.MachineDescriptionAMD64#isLP64()->boolean::: machine description d64 is p64
sun.jvm.hotspot.debugger.MachineDescriptionAMD64#isBigEndian()->boolean::: machine description d64 is big endian
sun.jvm.hotspot.debugger.MachineDescriptionIntelX86#getAddressSize()->long::: machine description intel x86 get address size
sun.jvm.hotspot.debugger.MachineDescriptionIntelX86#isBigEndian()->boolean::: machine description intel x86 is big endian
sun.jvm.hotspot.debugger.MachineDescriptionPPC64#getAddressSize()->long::: machine description c64 get address size
sun.jvm.hotspot.debugger.MachineDescriptionPPC64#isLP64()->boolean::: machine description c64 is p64
sun.jvm.hotspot.debugger.MachineDescriptionPPC64#isBigEndian()->boolean::: machine description c64 is big endian
sun.jvm.hotspot.debugger.MachineDescriptionSPARC32Bit#getAddressSize()->long::: machine description c32 bit get address size
sun.jvm.hotspot.debugger.MachineDescriptionSPARC32Bit#isBigEndian()->boolean::: machine description c32 bit is big endian
sun.jvm.hotspot.debugger.MachineDescriptionSPARC64Bit#getAddressSize()->long::: machine description c64 bit get address size
sun.jvm.hotspot.debugger.MachineDescriptionSPARC64Bit#isBigEndian()->boolean::: machine description c64 bit is big endian
sun.jvm.hotspot.debugger.MachineDescriptionSPARC64Bit#isLP64()->boolean::: machine description c64 bit is p64
sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement#cIntegerTypeMaxValue(long, boolean)->long::: machine description twos complement c integer type max value
sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement#cIntegerTypeMinValue(long, boolean)->long::: machine description twos complement c integer type min value
sun.jvm.hotspot.debugger.MachineDescriptionTwosComplement#isLP64()->boolean::: machine description twos complement is p64
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#readByte()->byte::: mapped byte buffer data source read byte
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#readShort()->short::: mapped byte buffer data source read short
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#readInt()->int::: mapped byte buffer data source read int
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#readLong()->long::: mapped byte buffer data source read long
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#read(byte[])->int::: mapped byte buffer data source read
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#seek(long)->void::: mapped byte buffer data source seek
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#getFilePointer()->long::: mapped byte buffer data source get file pointer
sun.jvm.hotspot.debugger.MappedByteBufferDataSource#close()->void::: mapped byte buffer data source close
sun.jvm.hotspot.debugger.NoSuchSymbolException#getSymbol()->String::: no such symbol exception get symbol
sun.jvm.hotspot.debugger.Page#getBaseAddress()->long::: page get base address
sun.jvm.hotspot.debugger.Page#getSize()->long::: page get size
sun.jvm.hotspot.debugger.Page#isMapped()->boolean:::Indicates whether this page is mapped in the remote process's       address space
sun.jvm.hotspot.debugger.Page#getPrev()->Page::: page get prev
sun.jvm.hotspot.debugger.Page#setPrev(Page)->void::: page set prev
sun.jvm.hotspot.debugger.Page#getNext()->Page::: page get next
sun.jvm.hotspot.debugger.Page#setNext(Page)->void::: page set next
sun.jvm.hotspot.debugger.Page#getData(long, long, int[], long)->void:::Throws IndexOutOfBoundsException if the number of bytes       requested is greater than the page size, or if the start address       doesn't fall within the page
sun.jvm.hotspot.debugger.Page#getDataAsBytes(long, long, byte[], long)->void:::Throws IndexOutOfBoundsException if the number of bytes       requested is greater than the page size, or if the start address       doesn't fall within the page
sun.jvm.hotspot.debugger.Page#getBoolean(long)->boolean::: page get boolean
sun.jvm.hotspot.debugger.Page#getByte(long)->byte::: page get byte
sun.jvm.hotspot.debugger.Page#getShort(long, boolean)->short::: page get short
sun.jvm.hotspot.debugger.Page#getChar(long, boolean)->char::: page get char
sun.jvm.hotspot.debugger.Page#getInt(long, boolean)->int::: page get int
sun.jvm.hotspot.debugger.Page#getLong(long, boolean)->long::: page get long
sun.jvm.hotspot.debugger.Page#getFloat(long, boolean)->float::: page get float
sun.jvm.hotspot.debugger.Page#getDouble(long, boolean)->double::: page get double
sun.jvm.hotspot.debugger.PageCache#getData(long, long)->byte[]:::This handles fetches which span multiple pages by virtue of the       presence of the PageFetcher
sun.jvm.hotspot.debugger.PageCache#getBoolean(long)->boolean::: page cache get boolean
sun.jvm.hotspot.debugger.PageCache#getByte(long)->byte::: page cache get byte
sun.jvm.hotspot.debugger.PageCache#getShort(long, boolean)->short::: page cache get short
sun.jvm.hotspot.debugger.PageCache#getChar(long, boolean)->char::: page cache get char
sun.jvm.hotspot.debugger.PageCache#getInt(long, boolean)->int::: page cache get int
sun.jvm.hotspot.debugger.PageCache#getLong(long, boolean)->long::: page cache get long
sun.jvm.hotspot.debugger.PageCache#getFloat(long, boolean)->float::: page cache get float
sun.jvm.hotspot.debugger.PageCache#getDouble(long, boolean)->double::: page cache get double
sun.jvm.hotspot.debugger.PageCache#clear(long, long)->void:::A mechanism for clearing cached data covering the given region
sun.jvm.hotspot.debugger.PageCache#clear()->void:::A mechanism for clearing out the cache is necessary to handle       detaching and reattaching
sun.jvm.hotspot.debugger.PageCache#disable()->void:::Disables the page cache; no further pages will be added to the       cache and all existing pages will be flushed
sun.jvm.hotspot.debugger.PageCache#enable()->void:::Enables the page cache; fetched pages will be added to the       cache
sun.jvm.hotspot.debugger.PageFetcher#fetchPage(long, long)->Page::: page fetcher fetch page
sun.jvm.hotspot.debugger.ProcessInfo#getName()->String::: process info get name
sun.jvm.hotspot.debugger.ProcessInfo#getPid()->int::: process info get pid
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#readByte()->byte::: random access file data source read byte
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#readShort()->short::: random access file data source read short
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#readInt()->int::: random access file data source read int
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#readLong()->long::: random access file data source read long
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#read(byte[])->int::: random access file data source read
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#seek(long)->void::: random access file data source seek
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#getFilePointer()->long::: random access file data source get file pointer
sun.jvm.hotspot.debugger.RandomAccessFileDataSource#close()->void::: random access file data source close
sun.jvm.hotspot.debugger.ReadResult#getData()->byte[]::: read result get data
sun.jvm.hotspot.debugger.ReadResult#getFailureAddress()->long::: read result get failure address
sun.jvm.hotspot.debugger.SymbolLookup#lookup(String, String)->Address:::Looks up the given symbol in the context of the given object
sun.jvm.hotspot.debugger.SymbolLookup#lookupOop(String, String)->OopHandle:::Looks up the given symbol in the context of the given object,       assuming that symbol refers to a Java object
sun.jvm.hotspot.debugger.ThreadAccess#getThreadForIdentifierAddress(Address)->ThreadProxy:::Gets an abstract ThreadProxy object for the thread identified by       the contents of the memory location pointed to by addr
sun.jvm.hotspot.debugger.ThreadAccess#getThreadForThreadId(long)->ThreadProxy:::Gets an abstract ThreadProxy object for the thread identified by       id or handle that is platform dependent
sun.jvm.hotspot.debugger.ThreadContext#getNumRegisters()->int:::Number of integer registers in the context
sun.jvm.hotspot.debugger.ThreadContext#getRegisterName(int)->String:::Get the name of the specified register (0..getNumRegisters() -       1)
sun.jvm.hotspot.debugger.ThreadContext#getRegister(int)->long:::Get the value of the specified register (0..getNumRegisters() -       1)
sun.jvm.hotspot.debugger.ThreadContext#setRegister(int, long)->void:::Set the value of the specified register (0..getNumRegisters() -       1)
sun.jvm.hotspot.debugger.ThreadContext#getRegisterAsAddress(int)->Address:::Get the value of the specified register (0..getNumRegisters() -       1) as an Address
sun.jvm.hotspot.debugger.ThreadContext#setRegisterAsAddress(int, Address)->void:::Set the value of the specified register (0..getNumRegisters() -       1) as an Address
sun.jvm.hotspot.debugger.ThreadContext#getTopFrame(Debugger)->CFrame::: thread context get top frame
sun.jvm.hotspot.debugger.ThreadProxy#getContext()->ThreadContext:::Retrieves the context for the given thread
sun.jvm.hotspot.debugger.ThreadProxy#canSetContext()->boolean:::Indicates whether calls to setContext() are valid.
sun.jvm.hotspot.debugger.ThreadProxy#setContext(ThreadContext)->void:::Sets the context for the given thread
