Address#equals(Object):::This is stated explicitly here because it is important for       implementations to understand that equals() and hashCode() must       absolutely, positively work properly -- i.e., two Address       objects representing the same address are both equal (via       equals()) and have the same hash code.:::
Address#hashCode():::This is stated explicitly here because it is important for       implementations to understand that equals() and hashCode() must       absolutely, positively work properly -- i.e., two Address       objects representing the same address are both equal (via       equals()) and have the same hash code.:::
Address#getCIntegerAt(long, long, boolean)::: address get integer at:::
Address#getAddressAt(long):::This returns null if the address at the given offset is NULL.:::
Address#getCompOopAddressAt(long):::Returns the decoded address at the given offset:::
Address#getCompKlassAddressAt(long)::: address get comp klass address at:::
Address#getJBooleanAt(long)::: address get boolean at:::
Address#getJByteAt(long)::: address get byte at:::
Address#getJCharAt(long)::: address get char at:::
Address#getJDoubleAt(long)::: address get double at:::
Address#getJFloatAt(long)::: address get float at:::
Address#getJIntAt(long)::: address get int at:::
Address#getJLongAt(long)::: address get long at:::
Address#getJShortAt(long)::: address get short at:::
Address#getOopHandleAt(long):::This returns null if the address at the given offset is NULL.:::
Address#getCompOopHandleAt(long)::: address get comp oop handle at:::
Address#setCIntegerAt(long, long, long):::Sets a C integer numBytes in size at the specified offset:::
Address#setAddressAt(long, Address):::Sets an Address at the specified location.:::
Address#setJBooleanAt(long, boolean)::: address set boolean at:::
Address#setJByteAt(long, byte)::: address set byte at:::
Address#setJCharAt(long, char)::: address set char at:::
Address#setJDoubleAt(long, double)::: address set double at:::
Address#setJFloatAt(long, float)::: address set float at:::
Address#setJIntAt(long, int)::: address set int at:::
Address#setJLongAt(long, long)::: address set long at:::
Address#setJShortAt(long, short)::: address set short at:::
Address#setOopHandleAt(long, OopHandle)::: address set oop handle at:::
Address#addOffsetTo(long):::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle, because interior object pointers       are not allowed:::
Address#addOffsetToAsOopHandle(long):::This method had to be added in order to support heap iteration       in the debugging system, and is effectively the dangerous       operation of allowing interior object pointers:::
Address#minus(Address):::Performs the subtraction "this - arg", returning the resulting       offset in bytes:::
Address#lessThan(Address):::Performs unsigned comparison "this < arg":::
Address#lessThanOrEqual(Address):::Performs unsigned comparison "this <= arg":::
Address#greaterThan(Address):::Performs unsigned comparison "this > arg":::
Address#greaterThanOrEqual(Address):::Performs unsigned comparison "this >= arg":::
Address#andWithMask(long):::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle:::
Address#orWithMask(long):::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle:::
Address#xorWithMask(long):::This throws an UnsupportedOperationException if this address happens       to actually be an OopHandle:::
Address#asLongValue()::: address as long value:::
AddressException#getAddress()::: address exception get address:::return
AddressException#getMessage()::: address exception get message:::return->Long->toHexString
DataSource#readByte()::: data source read byte:::
DataSource#readShort()::: data source read short:::
DataSource#readInt()::: data source read int:::
DataSource#readLong()::: data source read long:::
DataSource#read(byte[])::: data source read:::
DataSource#seek(long)::: data source seek:::
DataSource#getFilePointer()::: data source get file pointer:::
DataSource#close()::: data source close:::
Debugger#hasProcessList():::Indicates whether this underlying debugger can provide a list of       currently-running processes.:::
Debugger#getProcessList():::Provide a snapshot of the list of currently-running processes in       the form of a List of ProcessInfo objects:::
Debugger#attach(int):::If an error occurs during attachment (i.e., "no such process"),       the thrown DebuggerException will contain a description of the       error in its message string.:::
Debugger#attach(String, String):::This attaches the debugger to the given coreFileName, which is       assumed to have been generated from the specified       executableName:::
Debugger#detach():::Detach from the remote process:::
Debugger#parseAddress(String):::Parse an address from a hex string in the format "0xFFFFFFFF":::
Debugger#getAddressValue(Address):::Returns the 64-bit value of an Address:::
Debugger#getOS():::Support for remote debugging:::
Debugger#getCPU():::Support for remote debugging:::
Debugger#getMachineDescription():::Retrieve the machine description for the underlying hardware for       the cases in which we need to do, for example, machine-dependent       byte swapping:::
Debugger#hasConsole():::Find out whether this debugger has a console available on which       commands can be executed; see executeCommandOnConsole, below:::
Debugger#consoleExecuteCommand(String):::If the underlying debugger has a console (as dbx does), this       provides access to it:::
Debugger#getConsolePrompt():::If the underlying debugger has a console, this returns the       debugger-specific prompt which should be displayed.:::
Debugger#getCDebugger():::If this platform supports C/C++ debugging via the CDebugger       interface, returns a CDebugger object; otherwise returns       null.:::
Debugger#getJBooleanSize():::the following methods are intended only for RemoteDebuggerClient:::
Debugger#getJByteSize()::: debugger get byte size:::
Debugger#getJCharSize()::: debugger get char size:::
Debugger#getJDoubleSize()::: debugger get double size:::
Debugger#getJFloatSize()::: debugger get float size:::
Debugger#getJIntSize()::: debugger get int size:::
Debugger#getJLongSize()::: debugger get long size:::
Debugger#getJShortSize()::: debugger get short size:::
Debugger#getHeapOopSize()::: debugger get heap oop size:::
Debugger#getNarrowOopBase()::: debugger get narrow oop base:::
Debugger#getNarrowOopShift()::: debugger get narrow oop shift:::
Debugger#getKlassPtrSize()::: debugger get klass ptr size:::
Debugger#getNarrowKlassBase()::: debugger get narrow klass base:::
Debugger#getNarrowKlassShift()::: debugger get narrow klass shift:::
Debugger#readBytesFromProcess(long, long)::: debugger read bytes from process:::
Debugger#writeBytesToProcess(long, long, byte[])::: debugger write bytes to process:::
DebuggerBase.Fetcher#fetchPage(long, long)::: fetcher fetch page:::res->readBytesFromProcess->if->res->getData->return->new->Page->return->res->getData->new->Page
DebuggerBase#configureJavaPrimitiveTypeSizes(long, long, long, long, long, long, long, long):::From the JVMDebugger interface:::if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException
DebuggerBase#putHeapConst(long, long, long, int, long, int)::: debugger base put heap const:::
DebuggerBase#initCache(long, long):::May be called by subclasses if desired to initialize the page       cache but may not be overridden:::new->Fetcher->new->PageCache->if->machDesc->isBigEndian
DebuggerBase#setBigEndian(boolean):::May be called by subclasses if needed (if the machine       description is not available at the time of cache       initialization, as on Solaris) but may not be overridden:::
DebuggerBase#clearCache():::May be called by subclasses to clear out the cache but may not       be overridden:::if->cache->clear
DebuggerBase#disableCache():::May be called by subclasses to disable the cache (for example,       when the target process has been resumed) but may not be       overridden:::if->cache->disable
DebuggerBase#enableCache():::May be called by subclasses to re-enable the cache (for example,       when the target process has been suspended) but may not be       overridden:::if->cache->enable
DebuggerBase#readBytes(long, long):::May be called by subclasses directly but may not be overridden:::if->return->cache->getData->else->res->readBytesFromProcess->if->res->getData->return->res->getData->throw->res->getFailureAddress->new->UnmappedAddressException
DebuggerBase#writeBytes(long, long, byte[]):::May be called by subclasses directly but may not be overridden:::if->cache->clear->writeBytesToProcess
DebuggerBase#readJBoolean(long)::: debugger base read boolean:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getByte->else->data->readBytes->return->utils->dataToJBoolean
DebuggerBase#readJByte(long)::: debugger base read byte:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getByte->else->data->readBytes->return->utils->dataToJByte
DebuggerBase#readJChar(long)::: debugger base read char:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getChar->else->data->readBytes->return->utils->dataToJChar
DebuggerBase#readJDouble(long)::: debugger base read double:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getDouble->else->data->readBytes->return->utils->dataToJDouble
DebuggerBase#readJFloat(long)::: debugger base read float:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getFloat->else->data->readBytes->return->utils->dataToJFloat
DebuggerBase#readJInt(long)::: debugger base read int:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getInt->else->data->readBytes->return->utils->dataToJInt
DebuggerBase#readJLong(long)::: debugger base read long:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getLong->else->data->readBytes->return->utils->dataToJLong
DebuggerBase#readJShort(long)::: debugger base read short:::checkJavaConfigured->utils->checkAlignment->if->return->cache->getShort->else->data->readBytes->return->utils->dataToJShort
DebuggerBase#readCInteger(long, long, boolean)::: debugger base read integer:::checkConfigured->utils->checkAlignment->if->if->switch->return->cache->getByte->return->cache->getShort->return->cache->getInt->return->cache->getLong->data->readBytes->return->utils->dataToCInteger->else->switch->return->cache->getByte->return->cache->getShort->return->cache->getInt->return->cache->getLong->data->readBytes->return->utils->dataToCInteger->else->data->readBytes->return->utils->dataToCInteger
DebuggerBase#writeJBoolean(long, boolean)::: debugger base write boolean:::checkJavaConfigured->utils->checkAlignment->data->utils->jbooleanToData->writeBytes
DebuggerBase#writeJByte(long, byte)::: debugger base write byte:::checkJavaConfigured->utils->checkAlignment->data->utils->jbyteToData->writeBytes
DebuggerBase#writeJChar(long, char)::: debugger base write char:::checkJavaConfigured->utils->checkAlignment->data->utils->jcharToData->writeBytes
DebuggerBase#writeJDouble(long, double)::: debugger base write double:::checkJavaConfigured->utils->checkAlignment->data->utils->jdoubleToData->writeBytes
DebuggerBase#writeJFloat(long, float)::: debugger base write float:::checkJavaConfigured->utils->checkAlignment->data->utils->jfloatToData->writeBytes
DebuggerBase#writeJInt(long, int)::: debugger base write int:::checkJavaConfigured->utils->checkAlignment->data->utils->jintToData->writeBytes
DebuggerBase#writeJLong(long, long)::: debugger base write long:::checkJavaConfigured->utils->checkAlignment->data->utils->jlongToData->writeBytes
DebuggerBase#writeJShort(long, short)::: debugger base write short:::checkJavaConfigured->utils->checkAlignment->data->utils->jshortToData->writeBytes
DebuggerBase#writeCInteger(long, long, long)::: debugger base write integer:::checkConfigured->utils->checkAlignment->data->utils->cIntegerToData->writeBytes
DebuggerBase#readAddressValue(long)::: debugger base read address value:::return->machDesc->getAddressSize->readCInteger
DebuggerBase#readCompOopAddressValue(long)::: debugger base read comp oop address value:::value->getHeapOopSize->readCInteger->if->return
DebuggerBase#readCompKlassAddressValue(long)::: debugger base read comp klass address value:::value->getKlassPtrSize->readCInteger->if->return
DebuggerBase#writeAddressValue(long, long)::: debugger base write address value:::machDesc->getAddressSize->writeCInteger
DebuggerBase#checkConfigured():::Can be called by subclasses but can not be overridden:::if->throw->new->RuntimeException->if->throw->new->RuntimeException
DebuggerBase#checkJavaConfigured():::Can be called by subclasses but can not be overridden:::checkConfigured->if->throw->new->RuntimeException
DebuggerBase#parseCacheNumPagesProperty(int):::Possibly override page cache size with user-specified property:::cacheNumPagesString->System->getProperty->if->try->return->Integer->parseInt->catch->println->e->printStackTrace->finally->return
DebuggerBase#invalidatePageCache(long, long):::Interim solution for allowing subclasses to write bytes to       process until we make that functionality available in the basic       Address interface:::cache->clear
DebuggerBase#getJBooleanSize()::: debugger base get boolean size:::return
DebuggerBase#getJByteSize()::: debugger base get byte size:::return
DebuggerBase#getJCharSize()::: debugger base get char size:::return
DebuggerBase#getJDoubleSize()::: debugger base get double size:::return
DebuggerBase#getJFloatSize()::: debugger base get float size:::return
DebuggerBase#getJIntSize()::: debugger base get int size:::return
DebuggerBase#getJLongSize()::: debugger base get long size:::return
DebuggerBase#getJShortSize()::: debugger base get short size:::return
DebuggerBase#getHeapOopSize()::: debugger base get heap oop size:::return
DebuggerBase#getNarrowOopBase()::: debugger base get narrow oop base:::return
DebuggerBase#getNarrowOopShift()::: debugger base get narrow oop shift:::return
DebuggerBase#getKlassPtrSize()::: debugger base get klass ptr size:::return
DebuggerBase#getNarrowKlassBase()::: debugger base get narrow klass base:::return
DebuggerBase#getNarrowKlassShift()::: debugger base get narrow klass shift:::return
DebuggerUtilities#addressValueToString(long)::: debugger utilities address value to string:::buf->new->StringBuffer->buf->append->val->if->Long->toHexString->else->Integer->toHexString->for->i->val->length->buf->append->return->buf->toString
DebuggerUtilities#checkAlignment(long, long)::: debugger utilities check alignment:::if->throw->addressValueToString->new->UnalignedAddressException
DebuggerUtilities#scanAddress(String)::: debugger utilities scan address:::s->addrStr->trim->if->s->startsWith->throw->new->NumberFormatException->l->for->i->s->length->return
DebuggerUtilities#charToNibble(char)::: debugger utilities char to nibble:::if->return->else->if->return->else->if->return->throw->new->Character->toString->new->NumberFormatException
DebuggerUtilities#dataToJBoolean(byte[], long)::: debugger utilities data to boolean:::checkDataContents->return
DebuggerUtilities#dataToJByte(byte[], long)::: debugger utilities data to byte:::checkDataContents->return
DebuggerUtilities#dataToJChar(byte[], long)::: debugger utilities data to char:::checkDataContents->if->byteSwap->return
DebuggerUtilities#dataToJDouble(byte[], long)::: debugger utilities data to double:::longBits->dataToJLong->return->Double->longBitsToDouble
DebuggerUtilities#dataToJFloat(byte[], long)::: debugger utilities data to float:::intBits->dataToJInt->return->Float->intBitsToFloat
DebuggerUtilities#dataToJInt(byte[], long)::: debugger utilities data to int:::checkDataContents->if->byteSwap->return
DebuggerUtilities#dataToJLong(byte[], long)::: debugger utilities data to long:::checkDataContents->if->byteSwap->return->rawDataToJLong
DebuggerUtilities#dataToJShort(byte[], long)::: debugger utilities data to short:::checkDataContents->if->byteSwap->return
DebuggerUtilities#dataToCInteger(byte[], boolean)::: debugger utilities data to integer:::checkDataContents->if->byteSwap->if->newData->new->byteArr->for->i->return->rawDataToJLong
DebuggerUtilities#dataToAddressValue(byte[])::: debugger utilities data to address value:::checkDataContents->if->byteSwap->return->rawDataToJLong
DebuggerUtilities#jbooleanToData(boolean)::: debugger utilities jboolean to data:::res->new->byteArr->return
DebuggerUtilities#jbyteToData(byte)::: debugger utilities jbyte to data:::res->new->byteArr->return
DebuggerUtilities#jcharToData(char)::: debugger utilities jchar to data:::res->new->byteArr->if->byteSwap->return
DebuggerUtilities#jdoubleToData(double)::: debugger utilities jdouble to data:::return->Double->doubleToLongBits->jlongToData
DebuggerUtilities#jfloatToData(float)::: debugger utilities jfloat to data:::return->Float->floatToIntBits->jintToData
DebuggerUtilities#jintToData(int)::: debugger utilities jint to data:::res->new->byteArr->for->i->if->byteSwap->return
DebuggerUtilities#jlongToData(long)::: debugger utilities jlong to data:::res->new->byteArr->for->i->if->byteSwap->return
DebuggerUtilities#jshortToData(short)::: debugger utilities jshort to data:::res->new->byteArr->if->byteSwap->return
DebuggerUtilities#cIntegerToData(long, long)::: debugger utilities c integer to data:::numBytes->res->new->byteArr->for->i->if->byteSwap->return
DebuggerUtilities#checkDataContents(byte[], long)::: debugger utilities check data contents:::if->throw->new->InternalError
DebuggerUtilities#byteSwap(byte[])::: debugger utilities byte swap:::for->i
DebuggerUtilities#rawDataToJLong(byte[])::: debugger utilities raw data to long:::addr->for->i->return
InputLexer#close()::: input lexer close:::in->close
InputLexer#parseBoolean():::Parses a boolean (really either a 0 or 1 integer in US-ASCII       encoding) on the input stream:::val->parseInt->return
InputLexer#parseInt():::Parses an int in US-ASCII encoding on the input stream:::l->parseLong->mask->if->throw->new->IOException->return
InputLexer#parseLong():::Parses a long in US-ASCII encoding on the input stream:::skipWhitespace->b->readByte->if->Character->isDigit->error->l->while->Character->isDigit->readByte->pushBack->return
InputLexer#parseAddress():::Parses an address in the form 0x12345678 in US-ASCII encoding on       the input stream:::skipWhitespace->b->if->readByte->error->readByte->if->error->val->while->readByte->isHexDigit->Character->digit->pushBack->return
InputLexer#skipByte()::: input lexer skip byte:::readByte
InputLexer#readByte():::Reads binary data; one byte:::if->return->return->readByteInternal
InputLexer#readBytes(byte[], int, int):::Reads a block of binary data in BLOCKING fashion:::startIdx->numRead->if->while->in->read
InputLexer#readChar():::Reads binary data; one 16-bit character in big-endian format:::hi->readByte->lo->readByte->return
InputLexer#readUnsignedInt():::Reads binary data; one 32-bit unsigned int in big-endian format:::b1->readByte->b2->readByte->b3->readByte->b4->readByte->return
InputLexer#readByteString(int):::Reads binary data; a US-ASCII string of the specified length:::b->new->byteArr->for->i->try->return->new->String->catch->throw->e->toString->new->IOException->finally
InputLexer#readCharString(int):::Reads binary data; a Unicode string of the specified length:::c->new->charArr->for->i->return->new->String
InputLexer#skipWhitespace()::: input lexer skip whitespace:::b->while->Character->readByte->isWhitespace->pushBack
InputLexer#isHexDigit(char)::: input lexer is hex digit:::return
InputLexer#pushBack(byte)::: input lexer push back:::if->throw->new->InternalError
InputLexer#readByteInternal()::: input lexer read byte internal:::i->in->read->if->throw->new->IOException->return
InputLexer#error()::: input lexer error:::throw->new->IOException
JVMDebugger#configureJavaPrimitiveTypeSizes(long, long, long, long, long, long, long, long):::This intent is that this can be called late in the bootstrapping       sequence, after which the debugger can handle reading of Java       primitive types, and thereby implement the Java functionality in       class Address:::
JVMDebugger#putHeapConst(long, long, long, int, long, int)::: debugger put heap const:::
LongHashMap.Entry#getKey():::Returns the key corresponding to this entry.:::return
LongHashMap.Entry#getValue():::Returns the value corresponding to this entry:::return
LongHashMap.Entry#setValue(Object):::Replaces the value corresponding to this entry with the specified value (optional operation):::oldValue->return
LongHashMap.Entry#equals(Object):::Compares the specified object with this entry for equality:::if->return->e->return->e->getKey->e->getValue->eq
LongHashMap.Entry#hashCode():::Returns the hash code value for this map entry:::return->value->hashCode
LongHashMap#size():::Returns the number of key-value mappings in this map.:::return
LongHashMap#isEmpty():::Returns <tt>true</tt> if this map contains no key-value mappings.:::return
LongHashMap#get(long):::Returns the value to which this map maps the specified key:::e->getEntry->return
LongHashMap#containsKey(long):::Returns <tt>true</tt> if this map contains a mapping for the specified key.:::return->getEntry
LongHashMap#getEntry(long):::Returns the entry associated with the specified key in the HashMap:::tab->hash->index->for->e->return
LongHashMap#containsValue(Object):::Returns <tt>true</tt> if this map maps one or more keys to the specified value.:::tab->if->for->i->else->for->i->return
LongHashMap#put(long, Object):::Associates the specified value with the specified key in this map:::tab->hash->index->for->e->if->rehash->newEntry->return
LongHashMap#remove(long):::Removes the mapping for this key from this map if present.:::e->removeEntryForKey->return
LongHashMap#removeEntryForKey(long):::Removes and returns the entry associated with the specified key in the HashMap:::tab->hash->index->for->e->prev->return
LongHashMap#removeEntry(Entry):::Removes the specified entry from this HashMap (and increments modCount).:::tab->index->for->e->prev->throw->new->ConcurrentModificationException
LongHashMap#clear():::Removes all mappings from this map.:::tab->for->index
LongHashMap#rehash():::Rehashes the contents of this map into a new <tt>HashMap</tt> instance with a larger capacity:::oldTable->oldCapacity->newCapacity->newTable->new->EntryArr->for->i
LongHashMap#eq(Object, Object)::: long hash map eq:::return->o1->equals
LongHashMap#newEntry(int, long, Object, Entry)::: long hash map new entry:::return->new->Entry
LongHashMap#capacity()::: long hash map capacity:::return
LongHashMap#loadFactor()::: long hash map load factor:::return
MachineDescription#getAddressSize():::Returns the size of an address in bytes:::
MachineDescription#cIntegerTypeMaxValue(long, boolean):::Returns the maximum value of the C integer type with the given       size in bytes and signedness:::
MachineDescription#cIntegerTypeMinValue(long, boolean):::Returns the minimum value of the C integer type with the given       size in bytes and signedness:::
MachineDescription#isBigEndian():::Indicates whether the CPU is big- or little-endian:::
MachineDescription#isLP64():::Indicates whether the underlying machine supports the LP64 data       model (currently only SPARC/64).:::
MachineDescriptionAArch64#getAddressSize()::: machine description arch64 get address size:::return
MachineDescriptionAArch64#isLP64()::: machine description arch64 is p64:::return
MachineDescriptionAArch64#isBigEndian()::: machine description arch64 is big endian:::return
MachineDescriptionAMD64#getAddressSize()::: machine description d64 get address size:::return
MachineDescriptionAMD64#isLP64()::: machine description d64 is p64:::return
MachineDescriptionAMD64#isBigEndian()::: machine description d64 is big endian:::return
MachineDescriptionIntelX86#getAddressSize()::: machine description intel x86 get address size:::return
MachineDescriptionIntelX86#isBigEndian()::: machine description intel x86 is big endian:::return
MachineDescriptionPPC64#getAddressSize()::: machine description c64 get address size:::return
MachineDescriptionPPC64#isLP64()::: machine description c64 is p64:::return
MachineDescriptionPPC64#isBigEndian()::: machine description c64 is big endian:::return->System->getProperty->equals
MachineDescriptionSPARC32Bit#getAddressSize()::: machine description c32 bit get address size:::return
MachineDescriptionSPARC32Bit#isBigEndian()::: machine description c32 bit is big endian:::return
MachineDescriptionSPARC64Bit#getAddressSize()::: machine description c64 bit get address size:::return
MachineDescriptionSPARC64Bit#isBigEndian()::: machine description c64 bit is big endian:::return
MachineDescriptionSPARC64Bit#isLP64()::: machine description c64 bit is p64:::return
MachineDescriptionTwosComplement#cIntegerTypeMaxValue(long, boolean)::: machine description twos complement c integer type max value:::if->return->tableLookup->else->return->tableLookup
MachineDescriptionTwosComplement#cIntegerTypeMinValue(long, boolean)::: machine description twos complement c integer type min value:::if->return->return->tableLookup
MachineDescriptionTwosComplement#isLP64()::: machine description twos complement is p64:::return
MachineDescriptionTwosComplement#tableLookup(long, long[])::: machine description twos complement table lookup:::switch->return->return->return->return->throw->new->IllegalArgumentException
MappedByteBufferDataSource#readByte()::: mapped byte buffer data source read byte:::return->buf->get
MappedByteBufferDataSource#readShort()::: mapped byte buffer data source read short:::return->buf->getShort
MappedByteBufferDataSource#readInt()::: mapped byte buffer data source read int:::return->buf->getInt
MappedByteBufferDataSource#readLong()::: mapped byte buffer data source read long:::return->buf->getLong
MappedByteBufferDataSource#read(byte[])::: mapped byte buffer data source read:::buf->get->return
MappedByteBufferDataSource#seek(long)::: mapped byte buffer data source seek:::try->buf->position->catch->Long->toHexString->println->throw->finally
MappedByteBufferDataSource#getFilePointer()::: mapped byte buffer data source get file pointer:::return->buf->position
MappedByteBufferDataSource#close()::: mapped byte buffer data source close:::
NoSuchSymbolException#getSymbol()::: no such symbol exception get symbol:::return
Page#getBaseAddress()::: page get base address:::return
Page#getSize()::: page get size:::if->return->else->return
Page#isMapped():::Indicates whether this page is mapped in the remote process's       address space:::return
Page#getPrev()::: page get prev:::return
Page#setPrev(Page)::: page set prev:::
Page#getNext()::: page get next:::return
Page#setNext(Page)::: page set next:::
Page#getData(long, long, int[], long):::Throws IndexOutOfBoundsException if the number of bytes       requested is greater than the page size, or if the start address       doesn't fall within the page:::startOffset->if->throw->new->IndexOutOfBoundsException->for->i
Page#getDataAsBytes(long, long, byte[], long):::Throws IndexOutOfBoundsException if the number of bytes       requested is greater than the page size, or if the start address       doesn't fall within the page:::startOffset->if->throw->new->RuntimeException->System->arraycopy
Page#getBoolean(long)::: page get boolean:::return->getByte
Page#getByte(long)::: page get byte:::return
Page#getShort(long, boolean)::: page get short:::start->if->return->else->return
Page#getChar(long, boolean)::: page get char:::return->getShort
Page#getInt(long, boolean)::: page get int:::start->if->return->else->return
Page#getLong(long, boolean)::: page get long:::start->if->return->else->return
Page#getFloat(long, boolean)::: page get float:::return->Float->getInt->intBitsToFloat
Page#getDouble(long, boolean)::: page get double:::return->Double->getLong->longBitsToDouble
PageCache#getData(long, long):::This handles fetches which span multiple pages by virtue of the       presence of the PageFetcher:::data->new->byteArr->numRead->while->pageBaseAddress->page->getPage->checkPage->pageOffset->numBytesFromPage->Math->min->page->getDataAsBytes->return
PageCache#getBoolean(long)::: page cache get boolean:::return->getByte
PageCache#getByte(long)::: page cache get byte:::return->getPage->checkPage->getByte
PageCache#getShort(long, boolean)::: page cache get short:::return->getPage->checkPage->getShort
PageCache#getChar(long, boolean)::: page cache get char:::return->getPage->checkPage->getChar
PageCache#getInt(long, boolean)::: page cache get int:::return->getPage->checkPage->getInt
PageCache#getLong(long, boolean)::: page cache get long:::return->getPage->checkPage->getLong
PageCache#getFloat(long, boolean)::: page cache get float:::return->getPage->checkPage->getFloat
PageCache#getDouble(long, boolean)::: page cache get double:::return->getPage->checkPage->getDouble
PageCache#clear(long, long):::A mechanism for clearing cached data covering the given region:::pageBaseAddress->endAddress->while->flushPage
PageCache#clear():::A mechanism for clearing out the cache is necessary to handle       detaching and reattaching:::addressToPageMap->clear
PageCache#disable():::Disables the page cache; no further pages will be added to the       cache and all existing pages will be flushed:::clear
PageCache#enable():::Enables the page cache; fetched pages will be added to the       cache:::
PageCache#getPage(long):::Page fetcher plus LRU functionality:::if->if->lruList->getBaseAddress->return->key->page->addressToPageMap->get->if->fetcher->fetchPage->if->addressToPageMap->put->if->Assert->addressToPageMap->get->that->addPageToList->if->evictedPage->lruList->getPrev->removePageFromList->addressToPageMap->evictedPage->getBaseAddress->remove->else->else->removePageFromList->addPageToList->return
PageCache#checkPage(Page, long)::: page cache check page:::if->page->isMapped->throw->new->UnmappedAddressException->return
PageCache#countPages()::: page cache count pages:::page->num->if->return->do->page->getNext->while->return
PageCache#flushPage(long)::: page cache flush page:::key->page->addressToPageMap->remove->if->removePageFromList
PageCache#addPageToList(Page)::: page cache add page to list:::if->page->setNext->page->setPrev->else->page->setNext->page->lruList->getPrev->setPrev->lruList->getPrev->setNext->lruList->setPrev
PageCache#removePageFromList(Page)::: page cache remove page from list:::if->page->getNext->else->if->page->getNext->page->getPrev->page->getNext->setNext->page->getNext->page->getPrev->setPrev->page->setPrev->page->setNext
PageCache#checkPageInfo(long, long):::Ensure that page size fits within 32 bits and is a power of two, and that maxNumPages > 0:::if->throw->new->IllegalArgumentException->tmpPageSize->if->throw->new->IllegalArgumentException->numNonZeroBits->for->i
PageFetcher#fetchPage(long, long)::: page fetcher fetch page:::
ProcessInfo#getName()::: process info get name:::return
ProcessInfo#getPid()::: process info get pid:::return
RandomAccessFileDataSource#readByte()::: random access file data source read byte:::return->file->readByte
RandomAccessFileDataSource#readShort()::: random access file data source read short:::return->file->readShort
RandomAccessFileDataSource#readInt()::: random access file data source read int:::return->file->readInt
RandomAccessFileDataSource#readLong()::: random access file data source read long:::return->file->readLong
RandomAccessFileDataSource#read(byte[])::: random access file data source read:::return->file->read
RandomAccessFileDataSource#seek(long)::: random access file data source seek:::file->seek
RandomAccessFileDataSource#getFilePointer()::: random access file data source get file pointer:::return->file->getFilePointer
RandomAccessFileDataSource#close()::: random access file data source close:::file->close
ReadResult#getData()::: read result get data:::return
ReadResult#getFailureAddress()::: read result get failure address:::return
SymbolLookup#lookup(String, String):::Looks up the given symbol in the context of the given object:::
SymbolLookup#lookupOop(String, String):::Looks up the given symbol in the context of the given object,       assuming that symbol refers to a Java object:::
ThreadAccess#getThreadForIdentifierAddress(Address):::Gets an abstract ThreadProxy object for the thread identified by       the contents of the memory location pointed to by addr:::
ThreadAccess#getThreadForThreadId(long):::Gets an abstract ThreadProxy object for the thread identified by       id or handle that is platform dependent:::
ThreadContext#getNumRegisters():::Number of integer registers in the context:::
ThreadContext#getRegisterName(int):::Get the name of the specified register (0..getNumRegisters() -       1):::
ThreadContext#getRegister(int):::Get the value of the specified register (0..getNumRegisters() -       1):::
ThreadContext#setRegister(int, long):::Set the value of the specified register (0..getNumRegisters() -       1):::
ThreadContext#getRegisterAsAddress(int):::Get the value of the specified register (0..getNumRegisters() -       1) as an Address:::
ThreadContext#setRegisterAsAddress(int, Address):::Set the value of the specified register (0..getNumRegisters() -       1) as an Address:::
ThreadContext#getTopFrame(Debugger)::: thread context get top frame:::
ThreadProxy#getContext():::Retrieves the context for the given thread:::
ThreadProxy#canSetContext():::Indicates whether calls to setContext() are valid.:::
ThreadProxy#setContext(ThreadContext):::Sets the context for the given thread:::
