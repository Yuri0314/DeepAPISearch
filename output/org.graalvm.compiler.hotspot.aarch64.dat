AArch64HotSpotBackend#newFrameMapBuilder(RegisterConfig)::: arch64 hot spot backend new frame map builder:::registerConfigNonNull->getCodeCache->getRegisterConfig->frameMap->getCodeCache->new->AArch64FrameMap->return->getCodeCache->new->AArch64FrameMapBuilder
AArch64HotSpotBackend#newLIRGenerator(LIRGenerationResult)::: arch64 hot spot backend new generator:::return->getProviders->new->AArch64HotSpotLIRGenerator
AArch64HotSpotBackend#newLIRGenerationResult(CompilationIdentifier, LIR, RegisterConfig, StructuredGraph, Object)::: arch64 hot spot backend new generation result:::return->newFrameMapBuilder->makeCallingConvention->config->graph->getMethods->requiresReservedStackCheck->new->HotSpotLIRGenerationResult
AArch64HotSpotBackend#newNodeLIRBuilder(StructuredGraph, LIRGeneratorTool)::: arch64 hot spot backend new node builder:::return->new->AArch64NodeMatchRules->new->AArch64HotSpotNodeLIRBuilder
AArch64HotSpotBackend#bangStackWithOffset(CompilationResultBuilder, int)::: arch64 hot spot backend bang stack with offset:::masm->try->sc->masm->getScratchRegister->scratch->sc->getRegister->address->masm->makeAddress->masm->str->catch->finally
AArch64HotSpotBackend#createInstalledCode(DebugContext, ResolvedJavaMethod, CompilationRequest, CompilationResult, InstalledCode, boolean, Object[])::: arch64 hot spot backend create installed code:::isStub->isAOT->compilationResult->isImmutablePIC->if->return->super->createInstalledCode
AArch64HotSpotBackend#hasInvalidatePlaceholder(CompilationResult)::: arch64 hot spot backend has invalidate placeholder:::targetCode->compilationResult->getTargetCode->verifiedEntryOffset->foreach->compilationResult->getMarks->markId->if->break->unsafe->GraalUnsafeAccess->getUnsafe->instruction->unsafe->unsafe->arrayBaseOffset->getIntVolatile->masm->getTarget->new->AArch64MacroAssembler->masm->nop->return->masm->getInt
AArch64HotSpotBackend.HotSpotFrameContext#enter(CompilationResultBuilder)::: hot spot frame context enter:::frameMap->frameSize->frameMap->frameSize->totalFrameSize->frameMap->totalFrameSize->masm->if->emitStackOverflowCheck->crb->blockComment->try->sc->masm->getScratchRegister->wordSize->getWordSize->rscratch1->sc->getRegister->if->masm->sub->masm->AArch64Address->createScaledImmediateAddress->stp->else->masm->AArch64Address->createPreIndexedImmediateAddress->stp->if->masm->sub->else->masm->mov->masm->sub->catch->finally->if->ZapStackOnMethodEntry->crb->getOptions->getValue->try->sc->masm->getScratchRegister->scratch->sc->getRegister->longSize->masm->mov->address->AArch64Address->createPostIndexedImmediateAddress->try->sc2->masm->getScratchRegister->value->sc2->getRegister->masm->mov->for->i->catch->finally->catch->finally->crb->blockComment
AArch64HotSpotBackend.HotSpotFrameContext#leave(CompilationResultBuilder)::: hot spot frame context leave:::masm->frameMap->totalFrameSize->frameMap->totalFrameSize->crb->blockComment->try->sc->masm->getScratchRegister->wordSize->getWordSize->rscratch1->sc->getRegister->frameSize->frameMap->frameSize->if->masm->AArch64Address->createScaledImmediateAddress->ldp->masm->add->else->if->masm->add->else->masm->mov->masm->add->masm->AArch64Address->createPostIndexedImmediateAddress->ldp->catch->finally
AArch64HotSpotBackend.HotSpotFrameContext#hasFrame()::: hot spot frame context has frame:::return
AArch64HotSpotBackend#newCompilationResultBuilder(LIRGenerationResult, FrameMap, CompilationResult, CompilationResultBuilderFactory)::: arch64 hot spot backend new compilation result builder:::gen->lir->gen->getLIR->stub->gen->getStub->masm->getTarget->new->AArch64MacroAssembler->frameContext->new->HotSpotFrameContext->dataBuilder->getCodeCache->getTarget->new->HotSpotDataBuilder->crb->factory->getCodeCache->getForeignCalls->lir->getOptions->lir->getDebug->createBuilder->crb->frameMap->totalFrameSize->setTotalFrameSize->crb->gen->getMaxInterpreterFrameSize->setMaxInterpreterFrameSize->deoptimizationRescueSlot->gen->getDeoptimizationRescueSlot->if->setCustomStackAreaOffset->if->destroyedCallerRegisters->gatherDestroyedCallerRegisters->gen->getCalleeSaveInfo->updateStub->return
AArch64HotSpotBackend#emitCode(CompilationResultBuilder, LIR, ResolvedJavaMethod)::: arch64 hot spot backend emit code:::verifiedStub->new->Label->crb->buildLabelOffsets->try->emitCode->catch->crb->setConservativeLabelRanges->crb->resetForEmittingCode->lir->resetLabels->verifiedStub->reset->emitCode->finally
AArch64HotSpotBackend#emitCode(CompilationResultBuilder, LIR, ResolvedJavaMethod, Label)::: arch64 hot spot backend emit code:::masm->frameMap->regConfig->frameMap->getRegisterConfig->emitCodePrefix->emitCodeBody->emitCodeSuffix
AArch64HotSpotBackend#emitCodePrefix(CompilationResultBuilder, ResolvedJavaMethod, AArch64MacroAssembler, RegisterConfig, Label)::: arch64 hot spot backend emit code prefix:::providers->getProviders->if->installedCodeOwner->getModifiers->isStatic->crb->recordMark->cc->regConfig->new->JavaTypeArr->providers->getMetaAccess->lookupJavaType->getCallingConvention->inlineCacheKlass->receiver->cc->getArgument->asRegister->transferSize->klassAddress->masm->makeAddress->klass->if->masm->ldr->AArch64HotSpotMove->config->getKlassEncoding->decodeKlassPointer->else->masm->ldr->masm->cmp->masm->branchConditionally->AArch64Call->getForeignCalls->lookupForeignCall->directJmp->masm->align->crb->recordMark->masm->bind->crb->recordMark->if->GeneratePIC->crb->getOptions->getValue->frameContext->if->crb->LIRKind->value->new->HotSpotSentinelConstant->recordInlineDataInCodeWithNote->try->sc->masm->getScratchRegister->scratch->sc->getRegister->masm->addressOf->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->noCall->new->Label->masm->cbz->AArch64Call->getForeignCalls->lookupForeignCall->directJmp->masm->bind->catch->finally
AArch64HotSpotBackend#emitCodeBody(CompilationResultBuilder, LIR, AArch64MacroAssembler)::: arch64 hot spot backend emit code body:::emitInvalidatePlaceholder->crb->emit
AArch64HotSpotBackend#emitInvalidatePlaceholder(CompilationResultBuilder, AArch64MacroAssembler):::Insert a nop at the start of the prolog so we can patch in a branch if we need to invalidate the method later.:::if->GeneratePIC->crb->getOptions->getValue->crb->blockComment->masm->nop
AArch64HotSpotBackend#emitCodeSuffix(CompilationResultBuilder, AArch64MacroAssembler, FrameMap)::: arch64 hot spot backend emit code suffix:::providers->getProviders->frameContext->if->foreignCalls->providers->getForeignCalls->try->sc->masm->getScratchRegister->scratch->sc->getRegister->crb->recordMark->linkage->foreignCalls->lookupForeignCall->helper->AArch64Call->isNearCall->AArch64Call->directCall->catch->finally->crb->recordMark->linkage->foreignCalls->lookupForeignCall->masm->adr->AArch64Call->directJmp->else
AArch64HotSpotBackend#newRegisterAllocationConfig(RegisterConfig, String[])::: arch64 hot spot backend new register allocation config:::registerConfigNonNull->getCodeCache->getRegisterConfig->return->new->AArch64HotSpotRegisterAllocationConfig
AArch64HotSpotBackend#translateToCallerRegisters(EconomicSet)::: arch64 hot spot backend translate to caller registers:::return
AArch64HotSpotBackendFactory#getName()::: arch64 hot spot backend factory get name:::return
AArch64HotSpotBackendFactory#getArchitecture()::: arch64 hot spot backend factory get architecture:::return
AArch64HotSpotBackendFactory#createBackend(HotSpotGraalRuntimeProvider, CompilerConfiguration, HotSpotJVMCIRuntime, HotSpotBackend)::: arch64 hot spot backend factory create backend:::jvmci->jvmciRuntime->getHostJVMCIBackend->config->graalRuntime->getVMConfig->providers->registers->codeCache->jvmci->getCodeCache->target->codeCache->getTarget->foreignCalls->nativeABICallerSaveRegisters->metaAccess->jvmci->getMetaAccess->constantReflection->jvmci->getConstantReflection->constantFieldProvider->new->HotSpotGraalConstantFieldProvider->lowerer->stampProvider->gc->snippetReflection->replacements->suites->wordTypes->plugins->bytecodeProvider->try->t->timer->try->rt->timer->createRegisters->catch->finally->try->rt->timer->codeCache->getRegisterConfig->createNativeABICallerSaveRegisters->catch->finally->try->rt->timer->createWordTypes->catch->finally->try->rt->timer->createForeignCalls->catch->finally->try->rt->timer->createLowerer->catch->finally->try->rt->timer->createStampProvider->catch->finally->try->rt->timer->createGCProvider->catch->finally->p->new->Providers->try->rt->timer->createSnippetReflection->catch->finally->try->rt->timer->createBytecodeProvider->catch->finally->try->rt->timer->createReplacements->catch->finally->try->rt->timer->graalRuntime->getOptions->createGraphBuilderPlugins->replacements->setGraphBuilderPlugins->catch->finally->try->rt->timer->createSuites->catch->finally->new->HotSpotProviders->replacements->setProviders->catch->finally->try->rt->timer->return->createBackend->catch->finally
AArch64HotSpotBackendFactory#createGraphBuilderPlugins(CompilerConfiguration, GraalHotSpotVMConfig, HotSpotConstantReflectionProvider, HotSpotHostForeignCallsProvider, HotSpotMetaAccessProvider, HotSpotSnippetReflectionProvider, HotSpotReplacementsImpl, HotSpotWordTypes, OptionValues)::: arch64 hot spot backend factory create graph builder plugins:::plugins->HotSpotGraphBuilderPlugins->create->AArch64GraphBuilderPlugins->replacements->getDefaultReplacementBytecodeProvider->register->return
AArch64HotSpotBackendFactory#createBackend(GraalHotSpotVMConfig, HotSpotGraalRuntimeProvider, HotSpotProviders)::: arch64 hot spot backend factory create backend:::return->new->AArch64HotSpotBackend
AArch64HotSpotBackendFactory#createRegisters()::: arch64 hot spot backend factory create registers:::return->new->HotSpotRegisters
AArch64HotSpotBackendFactory#createForeignCalls(HotSpotJVMCIRuntime, HotSpotGraalRuntimeProvider, HotSpotMetaAccessProvider, HotSpotCodeCacheProvider, WordTypes, Value[])::: arch64 hot spot backend factory create foreign calls:::return->new->AArch64HotSpotForeignCallsProvider
AArch64HotSpotBackendFactory#createSuites(GraalHotSpotVMConfig, HotSpotGraalRuntimeProvider, CompilerConfiguration, Plugins, Replacements)::: arch64 hot spot backend factory create suites:::suitesCreator->Arrays->asList->new->AArch64SuitesCreator->addressLoweringPhase->new->AArch64LIRKindTool->new->AArch64AddressLoweringByUse->new->AddressLoweringByUsePhase->return->new->AddressLoweringHotSpotSuitesProvider
AArch64HotSpotBackendFactory#createLowerer(HotSpotGraalRuntimeProvider, HotSpotMetaAccessProvider, HotSpotForeignCallsProvider, HotSpotRegistersProvider, HotSpotConstantReflectionProvider, TargetDescription)::: arch64 hot spot backend factory create lowerer:::return->new->AArch64HotSpotLoweringProvider
AArch64HotSpotBackendFactory#createNativeABICallerSaveRegisters(GraalHotSpotVMConfig, RegisterConfig)::: arch64 hot spot backend factory create native caller save registers:::callerSave->regConfig->getAllocatableRegisters->asList->new->ArrayList<>->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->callerSave->remove->nativeABICallerSaveRegisters->callerSave->size->new->ValueArr->for->i->callerSave->size->return
AArch64HotSpotBackendFactory#toString()::: arch64 hot spot backend factory to string:::return
AArch64HotSpotConstantRetrievalOp.CollectTemporaries#asArray()::: collect temporaries as array:::copy->values->size->new->ValueArr->return->values->toArray
AArch64HotSpotConstantRetrievalOp.CollectTemporaries#doValue(Value, OperandMode, EnumSet)::: collect temporaries do value:::values->add->return
AArch64HotSpotConstantRetrievalOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot constant retrieval op emit code:::for->i->for->i->before->masm->position->masm->bl->after->masm->position->crb->recordDirectCall
AArch64HotSpotCRuntimeCallEpilogueOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot runtime call epilogue op emit code:::masm->masm->makeAddress->str->masm->masm->makeAddress->str
AArch64HotSpotCRuntimeCallPrologueOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot runtime call prologue op emit code:::scratchRegister->asRegister->masm->movx->masm->masm->makeAddress->str->masm->adr->masm->masm->makeAddress->str
AArch64HotSpotDeoptimizeCallerOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot deoptimize caller op emit code:::leaveFrame->AArch64Call->lookupForeignCall->directJmp
AArch64HotSpotDeoptimizeOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot deoptimize op emit code:::try->scratch->masm->getScratchRegister->AArch64Call->lookupForeignCall->scratch->getRegister->directCall->catch->finally
AArch64HotSpotDirectStaticCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot direct static call op emit code:::crb->recordMark->masm->movNativeAddress->super->emitCode
AArch64HotSpotDirectVirtualCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot direct virtual call op emit code:::crb->recordMark->masm->movNativeAddress->super->emitCode
AArch64HotSpotEpilogueOp#leaveFrame(CompilationResultBuilder, AArch64MacroAssembler, boolean, boolean)::: arch64 hot spot epilogue op leave frame:::leave->if->foreignCalls->noReserved->new->Label->try->sc->masm->getScratchRegister->scratch->sc->getRegister->masm->masm->makeAddress->ldr->masm->subs->catch->finally->masm->branchConditionally->enableStackReservedZone->foreignCalls->lookupForeignCall->cc->enableStackReservedZone->getOutgoingCallingConvention->arg0->cc->getArgument->getRegister->masm->mov->try->sc->masm->getScratchRegister->masm->AArch64Address->createPreIndexedImmediateAddress->stp->AArch64Call->sc->getRegister->directCall->masm->AArch64Address->createPostIndexedImmediateAddress->ldp->catch->finally->AArch64Call->foreignCalls->lookupForeignCall->directJmp->masm->bind->if->try->sc->masm->getScratchRegister->scratch->sc->getRegister->AArch64HotSpotSafepointOp->emitCode->catch->finally
AArch64HotSpotForeignCallsProvider#initialize(HotSpotProviders, OptionValues)::: arch64 hot spot foreign calls provider initialize:::config->runtime->getVMConfig->target->providers->getCodeCache->getTarget->word->getWordKind->exception->r0->LIRKind->reference->asValue->exceptionPc->r3->LIRKind->value->asValue->exceptionCc->new->CallingConvention->any->new->HotSpotForeignCallLinkageImpl->register->any->new->HotSpotForeignCallLinkageImpl->register->if->any->registerForeignCall->if->any->registerForeignCall->super->initialize
AArch64HotSpotForeignCallsProvider#getNativeABICallerSaveRegisters()::: arch64 hot spot foreign calls provider get native caller save registers:::return
AArch64HotSpotJumpToExceptionHandlerInCallerOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot jump to exception handler in caller op emit code:::leaveFrame->if->try->sc->masm->getScratchRegister->scratch->sc->getRegister->allowOverwrite->address->masm->makeAddress->masm->ldr->noRestore->new->Label->masm->cbz->masm->mov->masm->bind->catch->finally->masm->asRegister->jmp
AArch64HotSpotLIRGenerator#getProviders()::: arch64 hot spot generator get providers:::return->super->getProviders
AArch64HotSpotLIRGenerator#needOnlyOopMaps()::: arch64 hot spot generator need only oop maps:::return->getResult->getStub
AArch64HotSpotLIRGenerator#emitForeignCallOp(ForeignCallLinkage, Value, Value[], Value[], LIRFrameState)::: arch64 hot spot generator emit foreign call op:::if->AArch64Call->isNearCall->new->AArch64Call.DirectNearForeignCallOp->append->else->new->AArch64Call.DirectFarForeignCallOp->append
AArch64HotSpotLIRGenerator#emitTailcall(Value[], Value)::: arch64 hot spot generator emit tailcall:::throw->GraalError->unimplemented
AArch64HotSpotLIRGenerator#emitCCall(long, CallingConvention, Value[])::: arch64 hot spot generator emit call:::argLocations->new->ValueArr->getResult->getFrameMapBuilder->callsMethod->for->i->ptr->LIRKind->value->JavaConstant->forLong->emitLoadConstant->nativeCallingConvention->getReturn->new->AArch64CCall->append
AArch64HotSpotLIRGenerator#emitSaveRegisters(Register[], AllocatableValue[], boolean)::: arch64 hot spot generator emit save registers:::save->new->AArch64SaveRegistersOp->append->return
AArch64HotSpotLIRGenerator#allocateSaveRegisterLocation(Register):::Allocate a stack slot for saving a register.:::kind->target->register->getRegisterCategory->getLargestStorableKind->if->kind->getVectorLength->return->getResult->getFrameMapBuilder->LIRKind->value->allocateSpillSlot
AArch64HotSpotLIRGenerator#emitSaveAllRegisters(Register[], boolean):::Adds a node to the graph that saves all allocatable registers to the stack.:::savedRegisterLocations->new->AllocatableValueArr->for->i->return->emitSaveRegisters
AArch64HotSpotLIRGenerator#emitRestoreRegisters(AArch64SaveRegistersOp)::: arch64 hot spot generator emit restore registers:::save->getSlots->clone->new->AArch64RestoreRegistersOp->append
AArch64HotSpotLIRGenerator#getLockSlot(int)::: arch64 hot spot generator get lock slot:::return->getLockStack->makeLockSlot
AArch64HotSpotLIRGenerator#getLockStack()::: arch64 hot spot generator get lock stack:::return->debugInfoBuilder->lockStack
AArch64HotSpotLIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)::: arch64 hot spot generator emit compare branch:::localX->localY->if->load->if->load->super->emitCompareBranch
AArch64HotSpotLIRGenerator#emitCompare(PlatformKind, Value, Value, Condition, boolean)::: arch64 hot spot generator emit compare:::localA->localB->if->isConstantValue->c->asConstant->if->equals->LIRKind->value->asValue->else->if->load->if->isConstantValue->c->asConstant->if->equals->LIRKind->value->asValue->else->if->load->return->super->emitCompare
AArch64HotSpotLIRGenerator#emitCompress(Value, CompressEncoding, boolean)::: arch64 hot spot generator emit compress:::inputKind->pointer->getValueKind->lirKindTool->getLIRKindTool->if->inputKind->isReference->result->LIRKind->compressedReference->newVariable->asAllocatable->getProviders->getRegisters->getHeapBaseRegister->asValue->new->AArch64HotSpotMove.CompressPointer->append->return->else->result->LIRKind->value->newVariable->base->options->getResult->getLIR->getOptions->if->encoding->hasBase->GeneratePIC->getValue->if->GeneratePIC->getValue->baseAddress->lirKindTool->getWordKind->newVariable->move->new->AArch64HotSpotMove.BaseMove->append->else->LIRKind->value->JavaConstant->encoding->getBase->forLong->emitLoadConstant->asAllocatable->new->AArch64HotSpotMove.CompressPointer->append->return
AArch64HotSpotLIRGenerator#emitUncompress(Value, CompressEncoding, boolean)::: arch64 hot spot generator emit uncompress:::inputKind->pointer->getValueKind->if->inputKind->isReference->result->LIRKind->reference->newVariable->asAllocatable->getProviders->getRegisters->getHeapBaseRegister->asValue->new->AArch64HotSpotMove.UncompressPointer->append->return->else->result->LIRKind->value->newVariable->base->options->getResult->getLIR->getOptions->if->encoding->hasBase->GeneratePIC->getValue->if->GeneratePIC->getValue->baseAddress->LIRKind->value->newVariable->move->new->AArch64HotSpotMove.BaseMove->append->else->LIRKind->value->JavaConstant->encoding->getBase->forLong->emitLoadConstant->asAllocatable->new->AArch64HotSpotMove.UncompressPointer->append->return
AArch64HotSpotLIRGenerator#emitNullCheck(Value, LIRFrameState)::: arch64 hot spot generator emit null check:::if->address->getValueKind->getPlatformKind->encoding->config->getOopEncoding->uncompressed->emitUncompress->asAddressValue->new->AArch64Move.NullCheckOp->append->else->super->emitNullCheck
AArch64HotSpotLIRGenerator#emitPrefetchAllocate(Value)::: arch64 hot spot generator emit prefetch allocate:::asAddressValue->new->AArch64PrefetchOp->append
AArch64HotSpotLIRGenerator#beforeRegisterAllocation()::: arch64 hot spot generator before register allocation:::super->beforeRegisterAllocation->hasDebugInfo->getResult->getLIR->hasDebugInfo->if->getResult->getResult->getFrameMapBuilder->allocateDeoptimizationRescueSlot->setDeoptimizationRescueSlot->getResult->debugInfoBuilder->maxInterpreterFrameSize->setMaxInterpreterFrameSize
AArch64HotSpotLIRGenerator#emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...)::: arch64 hot spot generator emit foreign call:::hotspotLinkage->destroysRegisters->hotspotLinkage->destroysRegisters->save->stub->getStub->if->if->stub->preservesRegisters->savedRegisters->getRegisterConfig->getAllocatableRegisters->toArray->emitSaveAllRegisters->result->debugInfo->if->hotspotLinkage->needsDebugInfo->if->hotspotLinkage->needsJavaFrameAnchor->registers->getProviders->getRegisters->thread->registers->getThreadRegister->scratch->LIRKind->target->getWordKind->value->newVariable->new->Label->config->threadLastJavaSpOffset->config->threadLastJavaPcOffset->new->AArch64HotSpotCRuntimeCallPrologueOp->append->super->emitForeignCall->config->threadLastJavaSpOffset->config->threadLastJavaPcOffset->new->AArch64HotSpotCRuntimeCallEpilogueOp->append->else->super->emitForeignCall->if->if->if->stub->preservesRegisters->generationResult->getResult->key->if->generationResult->getCalleeSaveInfo->put->emitRestoreRegisters->return
AArch64HotSpotLIRGenerator#emitDeoptimizeCaller(DeoptimizationAction, DeoptimizationReason)::: arch64 hot spot generator emit deoptimize caller:::actionAndReason->getMetaAccess->encodeDeoptActionAndReason->emitJavaConstant->speculation->getMetaAccess->encodeSpeculation->emitJavaConstant->moveDeoptValuesToThread->new->AArch64HotSpotDeoptimizeCallerOp->append
AArch64HotSpotLIRGenerator#emitDeoptimize(Value, Value, LIRFrameState)::: arch64 hot spot generator emit deoptimize:::moveDeoptValuesToThread->new->AArch64HotSpotDeoptimizeOp->append
AArch64HotSpotLIRGenerator#moveDeoptValuesToThread(Value, Value)::: arch64 hot spot generator move deopt values to thread:::moveValueToThread->moveValueToThread
AArch64HotSpotLIRGenerator#moveValueToThread(Value, int)::: arch64 hot spot generator move value to thread:::wordKind->LIRKind->target->getWordKind->value->thread->getProviders->getRegisters->getThreadRegister->asValue->transferSize->value->getValueKind->getPlatformKind->getSizeInBytes->address->value->getValueKind->new->AArch64AddressValue->value->getPlatformKind->loadReg->new->StoreOp->append
AArch64HotSpotLIRGenerator#emitUnwind(Value)::: arch64 hot spot generator emit unwind:::linkage->getForeignCalls->lookupForeignCall->outgoingCc->linkage->getOutgoingCallingConvention->exceptionParameter->outgoingCc->getArgument->emitMove->new->AArch64HotSpotUnwindOp->append
AArch64HotSpotLIRGenerator#emitLoadObjectAddress(Constant)::: arch64 hot spot generator emit load object address:::objectConstant->kind->objectConstant->isCompressed->getLIRKindTool->getNarrowOopKind->getLIRKindTool->getObjectKind->result->newVariable->new->AArch64HotSpotLoadAddressOp->append->return
AArch64HotSpotLIRGenerator#emitLoadMetaspaceAddress(Constant, HotSpotConstantLoadAction)::: arch64 hot spot generator emit load metaspace address:::metaspaceConstant->kind->metaspaceConstant->isCompressed->getLIRKindTool->getNarrowPointerKind->getLIRKindTool->getWordKind->result->newVariable->new->AArch64HotSpotLoadAddressOp->append->return
AArch64HotSpotLIRGenerator#emitConstantRetrieval(ForeignCallDescriptor, Object[], Constant[], AllocatableValue[], LIRFrameState)::: arch64 hot spot generator emit constant retrieval:::linkage->getForeignCalls->lookupForeignCall->new->AArch64HotSpotConstantRetrievalOp->append->result->linkage->getOutgoingCallingConvention->getReturn->return->emitMove
AArch64HotSpotLIRGenerator#emitConstantRetrieval(ForeignCallDescriptor, HotSpotConstantLoadAction, Constant, AllocatableValue[], LIRFrameState)::: arch64 hot spot generator emit constant retrieval:::constants->new->ConstantArr->notes->new->ObjectArr->return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitResolveDynamicInvoke(Constant, LIRFrameState)::: arch64 hot spot generator emit resolve dynamic invoke:::constantDescriptions->new->AllocatableValueArr->return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitLoadConfigValue(int, LIRKind)::: arch64 hot spot generator emit load config value:::result->newVariable->new->AArch64HotSpotLoadConfigValueOp->append->return
AArch64HotSpotLIRGenerator#emitConstantRetrieval(ForeignCallDescriptor, HotSpotConstantLoadAction, Constant, Value, LIRFrameState)::: arch64 hot spot generator emit constant retrieval:::constantDescriptions->new->AllocatableValueArr->asAllocatable->return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitObjectConstantRetrieval(Constant, Value, LIRFrameState)::: arch64 hot spot generator emit object constant retrieval:::return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitMetaspaceConstantRetrieval(Constant, Value, LIRFrameState)::: arch64 hot spot generator emit metaspace constant retrieval:::return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitReturn(JavaKind, Value)::: arch64 hot spot generator emit return:::operand->if->input->getValueKind->resultOperandFor->emitMove->thread->getProviders->getRegisters->getThreadRegister->getStub->getResult->requiresReservedStackAccessCheck->new->AArch64HotSpotReturnOp->append
AArch64HotSpotLIRGenerator#emitKlassInitializationAndRetrieval(Constant, Value, LIRFrameState)::: arch64 hot spot generator emit klass initialization and retrieval:::return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#emitResolveMethodAndLoadCounters(Constant, Value, Value, LIRFrameState)::: arch64 hot spot generator emit resolve method and load counters:::constantDescriptions->new->AllocatableValueArr->asAllocatable->asAllocatable->return->emitConstantRetrieval
AArch64HotSpotLIRGenerator#getStub():::Gets the Stub this generator is generating code for or null if a stub is not being generated.:::return->getResult->getStub
AArch64HotSpotLIRGenerator#getResult()::: arch64 hot spot generator get result:::return->super->getResult
AArch64HotSpotLIRGenerator#createStrategySwitchOp(SwitchStrategy, LabelRef[], LabelRef, Variable, AllocatableValue, Function)::: arch64 hot spot generator create strategy switch op:::return->new->AArch64HotSpotStrategySwitchOp
AArch64HotSpotLIRGenerator#setDebugInfoBuilder(HotSpotDebugInfoBuilder)::: arch64 hot spot generator set debug info builder:::
AArch64HotSpotLIRGenerator#createZapRegisters(Register[], JavaConstant[])::: arch64 hot spot generator create zap registers:::throw->GraalError->unimplemented
AArch64HotSpotLIRGenerator#createZapArgumentSpace(StackSlot[], JavaConstant[])::: arch64 hot spot generator create zap argument space:::throw->GraalError->unimplemented
AArch64HotSpotLoadAddressOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot load address op emit code:::crb->recordInlineDataInCodeWithNote->kind->result->getPlatformKind->size->switch->break->break->throw->GraalError->shouldNotReachHere->if->isImmutablePIC->dst->asRegister->masm->addressOf->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->else->masm->asRegister->masm->getPlaceholder->ldr
AArch64HotSpotLoadConfigValueOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot load config value op emit code:::if->GeneratePIC->crb->getOptions->getValue->kind->result->getPlatformKind->reg->asRegister->masm->adrp->masm->add->switch->masm->AArch64Address->createBaseRegisterOnlyAddress->ldrs->break->masm->AArch64Address->createBaseRegisterOnlyAddress->ldrs->break->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->break->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->break->throw->GraalError->unimplemented->masm->nop->else->throw->GraalError->unimplemented->crb->recordMark
AArch64HotSpotLoweringProvider#initialize(OptionValues, Iterable, HotSpotProviders, GraalHotSpotVMConfig)::: arch64 hot spot lowering provider initialize:::providers->getSnippetReflection->providers->getCodeCache->getTarget->new->AArch64IntegerArithmeticSnippets->providers->getSnippetReflection->providers->getCodeCache->getTarget->new->AArch64FloatArithmeticSnippets->super->initialize
AArch64HotSpotLoweringProvider#lower(Node, LoweringTool)::: arch64 hot spot lowering provider lower:::if->integerArithmeticSnippets->lower->else->if->floatArithmeticSnippets->lower->else->if->else->super->lower
AArch64HotSpotMove.LoadHotSpotObjectConstantInline#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: load hot spot object constant inline emit code:::crb->recordInlineDataInCode->if->constant->isCompressed->masm->asRegister->movNarrowAddress->else->masm->asRegister->movNativeAddress
AArch64HotSpotMove.LoadHotSpotObjectConstantInline#getResult()::: load hot spot object constant inline get result:::return
AArch64HotSpotMove.LoadHotSpotObjectConstantInline#getConstant()::: load hot spot object constant inline get constant:::return
AArch64HotSpotMove.BaseMove#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: base move emit code:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->masm->adrp->masm->add->masm->asRegister->AArch64Address->createBaseRegisterOnlyAddress->ldr->masm->nop->crb->recordMark->catch->finally
AArch64HotSpotMove.CompressPointer#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: compress pointer emit code:::resultRegister->asRegister->ptr->asRegister->base->isRegister->asRegister->if->encoding->hasBase->if->encoding->hasShift->masm->encoding->getShift->lshr->else->masm->movx->else->if->masm->sub->if->encoding->hasShift->masm->encoding->getShift->lshr->else->masm->cmp->masm->cmov->masm->sub->if->encoding->hasShift->masm->encoding->getShift->lshr
AArch64HotSpotMove.UncompressPointer#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: uncompress pointer emit code:::inputRegister->asRegister->resultRegister->asRegister->base->encoding->hasBase->asRegister->encoding->getShift->emitUncompressCode
AArch64HotSpotMove.UncompressPointer#emitUncompressCode(AArch64MacroAssembler, Register, Register, Register, int, boolean)::: uncompress pointer emit uncompress code:::if->if->masm->shl->else->if->resReg->equals->masm->movx->return->if->masm->add->else->done->new->Label->if->resReg->equals->masm->mov->masm->cbz->masm->add->masm->bind
AArch64HotSpotMove#decodeKlassPointer(CompilationResultBuilder, AArch64MacroAssembler, Register, Register, CompressEncoding, GraalHotSpotVMConfig)::: arch64 hot spot move decode klass pointer:::try->sc->masm->getScratchRegister->scratch->sc->getRegister->pic->GeneratePIC->crb->getOptions->getValue->if->encoding->hasBase->encoding->getShift->if->masm->addressOf->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->masm->encoding->getShift->add->crb->recordMark->else->masm->encoding->getBase->mov->masm->encoding->getShift->add->catch->finally
AArch64HotSpotMoveFactory#canInlineConstant(Constant)::: arch64 hot spot move factory can inline constant:::if->equals->return->else->if->return->else->return->super->canInlineConstant
AArch64HotSpotMoveFactory#createLoad(AllocatableValue, Constant)::: arch64 hot spot move factory create load:::usedSource->if->COMPRESSED_NULL->equals->else->if->isNull->else->if->constant->if->constant->isCompressed->return->new->AArch64HotSpotMove.LoadHotSpotObjectConstantInline->else->return->new->AArch64HotSpotMove.LoadHotSpotObjectConstantInline->else->return->super->createLoad
AArch64HotSpotNodeLIRBuilder#createDebugInfoBuilder(StructuredGraph, NodeValueMap)::: arch64 hot spot node builder create debug info builder:::lockStack->gen->getResult->getFrameMapBuilder->LIRKind->value->new->HotSpotLockStack->return->new->HotSpotDebugInfoBuilder
AArch64HotSpotNodeLIRBuilder#getGen()::: arch64 hot spot node builder get gen:::return
AArch64HotSpotNodeLIRBuilder#emitPrologue(StructuredGraph)::: arch64 hot spot node builder emit prologue:::incomingArguments->gen->getResult->getCallingConvention->params->incomingArguments->getArgumentCount->new->ValueArr->for->i->incomingArguments->getArgumentCount->fp->LIRKind->value->asValue->lr->LIRKind->value->asValue->gen->emitIncomingValues->foreach->graph->getNodes->paramValue->param->index->gen->emitMove->setResult
AArch64HotSpotNodeLIRBuilder#visitSafepointNode(SafepointNode)::: arch64 hot spot node builder visit safepoint node:::info->state->thread->getGen->getProviders->getRegisters->getThreadRegister->scratch->gen->LIRKind->getGen->target->getWordKind->value->newVariable->getGen->new->AArch64HotSpotSafepointOp->append
AArch64HotSpotNodeLIRBuilder#emitDirectCall(DirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: arch64 hot spot node builder emit direct call:::invokeKind->invokeKind->if->invokeKind->isIndirect->callTarget->targetMethod->getGen->new->AArch64HotSpotDirectVirtualCallOp->append->else->resolvedMethod->callTarget->targetMethod->callTarget->targetMethod->getGen->new->AArch64HotSpotDirectStaticCallOp->append
AArch64HotSpotNodeLIRBuilder#emitIndirectCall(IndirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: arch64 hot spot node builder emit indirect call:::metaspaceMethodSrc->metaspaceMethod->operand->targetAddressSrc->callTarget->computedAddress->operand->metaspaceMethodDst->metaspaceMethodRegister->metaspaceMethodSrc->getValueKind->asValue->targetAddressDst->inlineCacheRegister->targetAddressSrc->getValueKind->asValue->gen->emitMove->gen->emitMove->callTarget->targetMethod->getGen->new->AArch64IndirectCallOp->append
AArch64HotSpotNodeLIRBuilder#emitPatchReturnAddress(ValueNode)::: arch64 hot spot node builder emit patch return address:::gen->operand->load->new->AArch64HotSpotPatchReturnAddressOp->append
AArch64HotSpotNodeLIRBuilder#emitJumpToExceptionHandlerInCaller(ValueNode, ValueNode, ValueNode)::: arch64 hot spot node builder emit jump to exception handler in caller:::handler->gen->operand->load->linkage->gen->getForeignCalls->lookupForeignCall->outgoingCc->linkage->getOutgoingCallingConvention->exceptionFixed->outgoingCc->getArgument->exceptionPcFixed->outgoingCc->getArgument->gen->operand->emitMove->gen->operand->emitMove->thread->getGen->getProviders->getRegisters->getThreadRegister->op->getGen->getGen->new->AArch64HotSpotJumpToExceptionHandlerInCallerOp->append
AArch64HotSpotNodeLIRBuilder#visitFullInfopointNode(FullInfopointNode)::: arch64 hot spot node builder visit full infopoint node:::if->i->getState->i->getState->i->getDebug->log->else->super->visitFullInfopointNode
AArch64HotSpotNodeLIRBuilder#visitBreakpointNode(BreakpointNode)::: arch64 hot spot node builder visit breakpoint node:::sig->node->arguments->size->new->JavaTypeArr->for->i->parameters->gen->getRegisterConfig->getCallingConvention->node->arguments->visitInvokeArguments->new->AArch64BreakpointOp->append
AArch64HotSpotPatchReturnAddressOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot patch return address op emit code:::frameSize->frameSize->lrAddress->AArch64Address->createUnscaledImmediateAddress->masm->asRegister->str
AArch64HotSpotRegisterAllocationConfig#initAllocatable(RegisterArray)::: arch64 hot spot register allocation config init allocatable:::regMap->registerConfig->getAllocatableRegisters->size->new->BitSet->foreach->regMap->set->allocatableRegisters->registers->size->new->ArrayList<>->foreach->if->regMap->get->allocatableRegisters->add->return->super->new->RegisterArray->initAllocatable
AArch64HotSpotReturnOp#validReturnValue(Value)::: arch64 hot spot return op valid return value:::if->result->equals->return->return->asRegister
AArch64HotSpotReturnOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot return op emit code:::emitSafepoint->leaveFrame->masm->ret
AArch64HotSpotSafepointOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot safepoint op emit code:::scratch->asRegister->emitCode
AArch64HotSpotSafepointOp#isPollingPageFar(GraalHotSpotVMConfig):::Conservatively checks whether we can load the safepoint polling address with a single ldr instruction or not.:::pollingPageAddress->return->NumUtil->isSignedNbit->NumUtil->isSignedNbit
AArch64HotSpotSafepointOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler, GraalHotSpotVMConfig, boolean, Register, Register, LIRFrameState)::: arch64 hot spot safepoint op emit code:::if->emitThreadLocalPoll->else->emitGlobalPoll
AArch64HotSpotSafepointOp#emitGlobalPoll(CompilationResultBuilder, AArch64MacroAssembler, GraalHotSpotVMConfig, boolean, Register, LIRFrameState)::: arch64 hot spot safepoint op emit global poll:::if->isPollingPageFar->crb->recordMark->masm->movNativeAddress->crb->recordMark->if->crb->masm->position->recordInfopoint->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr->else->crb->recordMark->if->crb->masm->position->recordInfopoint->masm->AArch64Address->createPcLiteralAddress->ldr
AArch64HotSpotSafepointOp#emitThreadLocalPoll(CompilationResultBuilder, AArch64MacroAssembler, GraalHotSpotVMConfig, boolean, Register, Register, LIRFrameState)::: arch64 hot spot safepoint op emit thread local poll:::masm->masm->makeAddress->ldr->crb->recordMark->if->crb->masm->position->recordInfopoint->masm->AArch64Address->createBaseRegisterOnlyAddress->ldr
AArch64HotSpotStrategySwitchOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot strategy switch op emit code:::strategy->asRegister->new->HotSpotSwitchClosure->run
AArch64HotSpotStrategySwitchOp.HotSpotSwitchClosure#emitComparison(Constant)::: hot spot switch closure emit comparison:::if->meta->if->meta->isCompressed->crb->recordInlineDataInCode->throw->GraalError->unimplemented->else->crb->recordInlineDataInCode->masm->asRegister->movNativeAddress->masm->asRegister->cmp->else->super->emitComparison
AArch64HotSpotUnwindOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 hot spot unwind op emit code:::leaveFrame->linkage->lookupForeignCall->cc->linkage->getOutgoingCallingConvention->returnAddress->cc->getArgument->asRegister->masm->movx->AArch64Call->directJmp
AArch64IndirectCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 indirect call op emit code:::crb->recordMark->callReg->asRegister->pcOffset->masm->position->AArch64Call->indirectCall->crb->getPosition->recordInlineInvokeCallOp
AArch64IndirectCallOp#verify()::: arch64 indirect call op verify:::super->verify
