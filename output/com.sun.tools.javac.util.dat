AbstractDiagnosticFormatter#formatArguments(JCDiagnostic, Locale):::Format the arguments of a given diagnostic.:::buf->new->ListBuffer<>->foreach->d->getArgs->buf->formatArgument->append->return->buf->toList
AbstractDiagnosticFormatter#formatArgument(JCDiagnostic, Object, Locale):::Format a single argument of a given diagnostic.:::if->s->try->formatMessage->catch->finally->return->else->if->return->expr2String->else->if->return->formatIterable->else->if->return->printer->visit->else->if->return->printer->visit->else->if->return->getName->else->if->return->else->if->return->else->if->return->toString->else->if->return->else->if->return->else->return->String->valueOf
AbstractDiagnosticFormatter#formatIterable(JCDiagnostic, Iterable, Locale):::Format an iterable argument of a given diagnostic.:::sbuf->new->StringBuilder->sep->foreach->sbuf->append->sbuf->formatArgument->append->return->sbuf->toString
AbstractDiagnosticFormatter#formatSubdiagnostics(JCDiagnostic, Locale):::Format all the subdiagnostics attached to a given diagnostic.:::subdiagnostics->List->nil->maxDepth->config->getMultilineLimit->if->try->maxCount->config->getMultilineLimit->count->foreach->d->getSubdiagnostics->if->subdiagnostics->formatSubdiagnostic->append->else->break->catch->finally->return
AbstractDiagnosticFormatter#formatSubdiagnostic(JCDiagnostic, JCDiagnostic, Locale):::Format a subdiagnostics attached to a given diagnostic.:::return->formatMessage
AbstractDiagnosticFormatter#formatSourceLine(JCDiagnostic, int):::Format the faulty source code line and point to the error.:::buf->new->StringBuilder->source->d->getDiagnosticSource->pos->d->getIntPosition->if->d->getIntPosition->throw->new->AssertionError->line->source->getLine->if->return->buf->indent->append->col->source->getColumnNumber->if->config->isCaretEnabled->buf->append->for->i->buf->indent->append->return->buf->toString
AbstractDiagnosticFormatter#localize(Locale, String, Object...):::Converts a String into a locale-dependent representation accordingly to a given locale.:::return->messages->getLocalizedString
AbstractDiagnosticFormatter#indentString(int):::Creates a string with a given amount of empty spaces:::spaces->if->spaces->length->return->spaces->substring->else->buf->new->StringBuilder->for->i->return->buf->toString
AbstractDiagnosticFormatter#indent(String, int):::Indent a string by prepending a given amount of empty spaces to each line of the string.:::indent->indentString->buf->new->StringBuilder->nl->foreach->s->split->buf->append->buf->append->return->buf->toString
AbstractDiagnosticFormatter.SimpleConfiguration#setCaretEnabled(boolean):::Shows a '^' sign under the source line displayed by the formatter (if applicable).:::
AbstractDiagnosticFormatter.SimpleConfiguration#isCaretEnabled():::Tells whether the caret display is active or not.:::return
AbstractLog#useSource(JavaFileObject):::Re-assign source, returning previous setting.:::prev->source->getFile->getSource->return
AbstractLog#currentSource():::Return the underlying diagnostic source:::return
AbstractLog#error(String, Object...):::Report an error, unless another error was already reported at same  source position.:::diags->errorKey->error
AbstractLog#error(Error):::Report an error, unless another error was already reported at same  source position.:::diags->error->report
AbstractLog#error(DiagnosticPosition, Error):::Report an error, unless another error was already reported at same  source position.:::diags->error->report
AbstractLog#error(DiagnosticFlag, DiagnosticPosition, Error):::Report an error, unless another error was already reported at same  source position.:::diags->error->report
AbstractLog#error(int, String, Object...):::Report an error, unless another error was already reported at same  source position.:::diags->errorKey->error
AbstractLog#error(int, Error):::Report an error, unless another error was already reported at same  source position.:::diags->wrap->error->report
AbstractLog#error(DiagnosticFlag, int, Error):::Report an error, unless another error was already reported at same  source position.:::diags->wrap->error->report
AbstractLog#warning(Warning):::Report a warning, unless suppressed by the  -nowarn option or the  maximum number of warnings has been reached.:::diags->warning->report
AbstractLog#warning(LintCategory, Warning):::Report a lint warning, unless suppressed by the  -nowarn option or the  maximum number of warnings has been reached.:::diags->warning->report
AbstractLog#warning(DiagnosticPosition, Warning):::Report a warning, unless suppressed by the  -nowarn option or the  maximum number of warnings has been reached.:::diags->warning->report
AbstractLog#warning(LintCategory, DiagnosticPosition, Warning):::Report a lint warning, unless suppressed by the  -nowarn option or the  maximum number of warnings has been reached.:::diags->warning->report
AbstractLog#warning(int, Warning):::Report a warning, unless suppressed by the  -nowarn option or the  maximum number of warnings has been reached.:::diags->wrap->warning->report
AbstractLog#mandatoryWarning(DiagnosticPosition, Warning):::Report a warning.:::diags->mandatoryWarning->report
AbstractLog#mandatoryWarning(LintCategory, DiagnosticPosition, Warning):::Report a warning.:::diags->mandatoryWarning->report
AbstractLog#note(Note):::Provide a non-fatal notification, unless suppressed by the -nowarn option.:::diags->note->report
AbstractLog#note(DiagnosticPosition, Note):::Provide a non-fatal notification, unless suppressed by the -nowarn option.:::diags->note->report
AbstractLog#note(int, Note):::Provide a non-fatal notification, unless suppressed by the -nowarn option.:::diags->wrap->note->report
AbstractLog#note(JavaFileObject, Note):::Provide a non-fatal notification, unless suppressed by the -nowarn option.:::diags->getSource->note->report
AbstractLog#mandatoryNote(JavaFileObject, Note):::Provide a non-fatal notification, unless suppressed by the -nowarn option.:::diags->getSource->mandatoryNote->report
Assert#check(boolean):::Equivalent to   assert cond;:::if->error
Assert#checkNull(Object):::Equivalent to   assert (o == null);:::if->error
Assert#checkNonNull(T):::Equivalent to   assert (t != null); return t;:::if->error->return
Assert#check(boolean, int):::Equivalent to   assert cond : value;:::if->String->valueOf->error
Assert#check(boolean, long):::Equivalent to   assert cond : value;:::if->String->valueOf->error
Assert#check(boolean, Object):::Equivalent to   assert cond : value;:::if->String->valueOf->error
Assert#check(boolean, String):::Equivalent to   assert cond : msg;:::if->error
Assert#check(boolean, Supplier):::Equivalent to   assert cond : msg.get();  Note: message string is computed lazily.:::if->msg->get->error
Assert#checkNull(Object, Object):::Equivalent to   assert (o == null) : value;:::if->String->valueOf->error
Assert#checkNull(Object, String):::Equivalent to   assert (o == null) : msg;:::if->error
Assert#checkNull(Object, Supplier):::Equivalent to   assert (o == null) : msg.get();  Note: message string is computed lazily.:::if->msg->get->error
Assert#checkNonNull(T, String):::Equivalent to   assert (o != null) : msg;:::if->error->return
Assert#checkNonNull(T, Supplier):::Equivalent to   assert (o != null) : msg.get();  Note: message string is computed lazily.:::if->msg->get->error->return
Assert#error():::Equivalent to   assert false;:::throw->new->AssertionError
Assert#error(String):::Equivalent to   assert false : msg;:::throw->new->AssertionError
BasicDiagnosticFormatter.BasicConfiguration#getIndentation(DiagnosticPart):::Get the amount of spaces for a given indentation kind:::return->indentationLevels->get
BasicDiagnosticFormatter.BasicConfiguration#setIndentation(DiagnosticPart, int):::Set the indentation level for various element of a given diagnostic - this might lead to more readable diagnostics:::indentationLevels->put
BasicDiagnosticFormatter.BasicConfiguration#setSourcePosition(SourcePosition):::Set the source line positioning used by this formatter:::
BasicDiagnosticFormatter.BasicConfiguration#getSourcePosition():::Get the source line positioning used by this formatter:::return
BasicDiagnosticFormatter.BasicConfiguration#setFormat(BasicFormatKind, String):::Set a metachar string for a specific format:::availableFormats->put
BasicDiagnosticFormatter.BasicConfiguration#getFormat(BasicFormatKind):::Get a metachar string for a specific format:::return->availableFormats->get
Bits#clear():::This set = {}.:::Assert->check->for->i
Bits#dup():::Return a copy of this set.:::Assert->check->tmp->new->Bits->dupBits->return
Bits#incl(int):::Include x in this set.:::Assert->check->Assert->check->sizeTo
Bits#inclRange(int, int):::Include [start..limit) in this set.:::Assert->check->sizeTo->for->x
Bits#excludeFrom(int):::Exclude [start...end] from this set.:::Assert->check->temp->new->Bits->temp->sizeTo->temp->inclRange->internalAndSet
Bits#excl(int):::Exclude x from this set.:::Assert->check->Assert->check->sizeTo
Bits#isMember(int):::Is x an element of this set?:::Assert->check->return
Bits#andSet(Bits):::this set = this set & xs.:::Assert->check->internalAndSet->return
Bits#orSet(Bits):::this set = this set | xs.:::Assert->check->sizeTo->for->i->return
Bits#diffSet(Bits):::this set = this set \ xs.:::Assert->check->for->i->return
Bits#xorSet(Bits):::this set = this set ^ xs.:::Assert->check->sizeTo->for->i->return
Bits#nextBit(int):::Return the index of the least bit position &ge; x that is set:::Assert->check->windex->if->return->word->while->if->return->trailingZeroBits->if->return
Bits#toString():::a string representation of this set.:::if->digits->new->charArr->for->i->return->new->String->else->return
ByteBuffer#appendByte(int):::Append byte to this buffer.:::ArrayUtils->ensureCapacity
ByteBuffer#appendBytes(byte[], int, int):::Append `len' bytes from byte array,  starting at given `start' offset.:::ArrayUtils->ensureCapacity->System->arraycopy
ByteBuffer#appendBytes(byte[]):::Append all bytes from given byte array.:::appendBytes
ByteBuffer#appendChar(int):::Append a character as a two byte number.:::ArrayUtils->ensureCapacity
ByteBuffer#appendInt(int):::Append an integer as a four byte number.:::ArrayUtils->ensureCapacity
ByteBuffer#appendLong(long):::Append a long as an eight byte number.:::buffer->new->ByteArrayOutputStream->bufout->new->DataOutputStream->try->bufout->writeLong->buffer->toByteArray->appendBytes->catch->throw->new->AssertionError->finally
ByteBuffer#appendFloat(float):::Append a float as a four byte number.:::buffer->new->ByteArrayOutputStream->bufout->new->DataOutputStream->try->bufout->writeFloat->buffer->toByteArray->appendBytes->catch->throw->new->AssertionError->finally
ByteBuffer#appendDouble(double):::Append a double as a eight byte number.:::buffer->new->ByteArrayOutputStream->bufout->new->DataOutputStream->try->bufout->writeDouble->buffer->toByteArray->appendBytes->catch->throw->new->AssertionError->finally
ByteBuffer#appendName(Name):::Append a name.:::name->getByteArray->name->getByteOffset->name->getByteLength->appendBytes
ByteBuffer#reset():::Reset to zero length.:::
ByteBuffer#toName(Names):::Convert contents to name.:::return->names->fromUtf
Constants#decode(Object, Type):::Converts a constant in internal representation (in which boolean, char, byte, short, and int are each represented by an Integer) into standard representation:::if->i->switch->type->getTag->return->return->return->return->return
Constants#format(Object, Type):::Returns a string representation of a constant value (given in internal representation), quoted and formatted as in Java source.:::decode->switch->type->getTag->return->formatByte->return->formatLong->return->formatFloat->return->formatDouble->return->formatChar->if->return->formatString->return
Constants#format(Object):::Returns a string representation of a constant value (given in standard wrapped representation), quoted and formatted as in Java source.:::if->return->formatByte->if->return->formatShort->if->return->formatLong->if->return->formatFloat->if->return->formatDouble->if->return->formatChar->if->return->formatString->if->return->value->toString->else->throw->value->getClass->getName->new->IllegalArgumentException
Context#put(Key, Factory):::Set the factory for the key in this context.:::checkState->old->ht->put->if->throw->new->AssertionError->checkState->ft->put
Context#put(Key, T):::Set the value for the key in this context.:::if->throw->new->AssertionError->checkState->old->ht->put->if->throw->new->AssertionError
Context#get(Key):::Get the value for the key in this context.:::checkState->o->ht->get->if->fac->fac->make->if->throw->new->AssertionError->Assert->ht->get->check->return->Context->uncheckedCast
Convert#string2int(String, int):::Convert string to integer.:::if->return->Integer->parseInt->else->cs->s->toCharArray->limit->n->foreach->d->Character->digit->if->throw->new->NumberFormatException->return
Convert#string2long(String, int):::Convert string to long integer.:::if->return->Long->parseLong->else->cs->s->toCharArray->limit->n->foreach->d->Character->digit->if->throw->new->NumberFormatException->return
Convert#utf2chars(byte[], int, char[], int, int):::Convert `len' bytes from utf8 to characters:::i->j->limit->while->b->if->else->if->return
Convert#utf2chars(byte[], int, int):::Return bytes in Utf8 representation as an array of characters.:::dst->new->charArr->len1->utf2chars->result->new->charArr->System->arraycopy->return
Convert#utf2chars(byte[]):::Return all bytes of a given array in Utf8 representation  as an array of characters.:::return->utf2chars
Convert#utf2string(byte[], int, int):::Return bytes in Utf8 representation as a string.:::dst->new->charArr->len1->utf2chars->return->new->String
Convert#utf2string(byte[]):::Return all bytes of a given array in Utf8 representation  as a string.:::return->utf2string
Convert#chars2utf(char[], int, byte[], int, int):::Copy characters in source array to bytes in target array,  converting them to Utf8 representation:::j->limit->for->i->return
Convert#chars2utf(char[], int, int):::Return characters as an array of bytes in Utf8 representation.:::dst->new->byteArr->len1->chars2utf->result->new->byteArr->System->arraycopy->return
Convert#chars2utf(char[]):::Return all characters in given array as an array of bytes  in Utf8 representation.:::return->chars2utf
Convert#string2utf(String):::Return string as an array of bytes in in Utf8 representation.:::return->s->toCharArray->chars2utf
Convert#quote(String):::Escapes each character in a string that has an escape sequence or is non-printable ASCII:::buf->new->StringBuilder->for->i->s->length->return->buf->toString
Convert#quote(char):::Escapes a character if it has an escape sequence or is non-printable ASCII:::switch->return->return->return->return->return->return->return->return->return->isPrintableAscii->String->valueOf->String->format
Convert#escapeUnicode(String):::Escape all unicode characters in string.:::len->s->length->i->while->ch->s->charAt->if->buf->new->StringBuilder->buf->s->substring->append->while->s->charAt->if->buf->append->buf->Character->forDigit->append->buf->Character->forDigit->append->buf->Character->forDigit->append->buf->Character->forDigit->append->else->buf->append->buf->toString->else->return
Convert#shortName(Name):::Return the last part of a qualified name.:::start->name->lastIndexOf->end->name->getByteLength->if->name->length->return->return->name->name->lastIndexOf->name->getByteLength->subName
Convert#shortName(String):::Return the last part of a qualified name from its string representation:::return->name->name->lastIndexOf->substring
Convert#packagePart(Name):::Return the package name of a class name, excluding the trailing '.',  "" if not existent.:::return->classname->classname->lastIndexOf->subName
Dependencies#push(ClassSymbol, CompletionCause):::Push a new completion node on the stack.:::
Dependencies#pop():::Remove current dependency node from the stack.:::
Dependencies.GraphDependencies#preRegister(Context):::Register a Context.Factory to create a Dependencies.:::context->GraphDependencies->new->put
Dependencies.GraphDependencies#push(Node, CompletionCause):::Push a new dependency on the stack.:::cachedNode->dependencyNodeMap->get->if->dependencyNodeMap->put->else->if->nodeStack->isEmpty->currentNode->nodeStack->peek->currentNode->addDependency->nodeStack->push->return
DiagnosticSource#getFile():::Return the underlying file object handled by this  DiagnosticSource object.:::return
DiagnosticSource#getLineNumber(int):::Return the one-based line number associated with a given pos for the current source file:::try->if->findLine->return->return->catch->finally
DiagnosticSource#getColumnNumber(int, boolean):::Return the one-based column number associated with a given pos for the current source file:::try->if->findLine->column->for->bp->return->return->catch->finally
DiagnosticSource#getLine(int):::Return the content of the line containing a given pos.:::try->if->findLine->return->lineEnd->while->if->return->return->new->String->catch->finally
DiagnosticSource#findLine(int):::Find the line in the buffer that contains the current position:::if->return->try->if->refBuf->get->if->initBuf->else->if->bp->while->switch->if->break->break->return->catch->log->directError->new->charArr->return->finally
Filter#accepts(T):::Does this element match against the filter?:::
ForwardingDiagnosticFormatter#getDelegatedFormatter():::Returns the underlying delegated formatter:::return
ForwardingDiagnosticFormatter.ForwardingConfiguration#getDelegatedConfiguration():::Returns the underlying delegated configuration.:::return
GraphUtils.Node#accept(NodeVisitor, A):::visitor method.:::
GraphUtils.NodeVisitor#visitNode(N, A):::Visitor action for nodes.:::
GraphUtils.NodeVisitor#visitDependency(DependencyKind, N, N, A):::Visitor action for a dependency between 'from' and 'to' with given kind.:::
GraphUtils.NodeVisitor#visit(Collection, A):::Visitor entry point.:::foreach->new->ArrayList<>->n->accept
GraphUtils.DottableNode#nodeAttributes():::Retrieves the set of dot attributes associated with the node.:::
GraphUtils.DottableNode#dependencyAttributes(N, DependencyKind):::Retrieves the set of dot attributes associated with a given dependency.:::
GraphUtils.AbstractNode#getSupportedDependencyKinds():::Get an array of the dependency kinds supported by this node.:::
GraphUtils.AbstractNode#getDependenciesByKind(DependencyKind):::Get all dependencies of a given kind:::
GraphUtils#tarjan(Iterable):::Tarjan's algorithm to determine strongly connected components of a directed graph in linear time:::tarjan->new->Tarjan<>->return->tarjan->findSCC
GraphUtils#toDot(Collection, String, String):::Debugging: dot representation of a set of connected nodes:::buf->new->StringBuilder->buf->String->format->append->buf->String->DotVisitor->wrap->format->append->dotVisitor->new->DotVisitor<>->dotVisitor->visit->buf->append->return->buf->toString
IntHashTable#hash(Object):::Compute the hash code of a given object.:::return->System->identityHashCode
IntHashTable#lookup(Object, int):::Find either the index of a key's value, or the index of an available space.:::node->hash1->hash2->deleted->for->i
IntHashTable#lookup(Object):::Lookup a given key's value in the hash table.:::return->hash->lookup
IntHashTable#getFromIndex(int):::Return the value stored at the specified index in the table.:::node->return
IntHashTable#putAtIndex(Object, int, int):::Associates the specified key with the specified value in this map.:::old->if->if->if->rehash->return->else->oldValue->return
IntHashTable#rehash():::Expand the hash table when it exceeds the load factor:::oldObjsTable->oldIntsTable->oldCapacity->newCapacity->newObjTable->new->ObjectArr->newIntTable->new->intArr->newMask->key->for->i
IntHashTable#clear():::Removes all mappings from this map.:::for->i
JavacMessages#instance(Context):::Get the JavacMessages instance for this context.:::instance->context->get->if->new->JavacMessages->return
JavacMessages#getLocalizedString(String, Object...):::Gets the localized string corresponding to a key, formatted with a set of args.:::return->getLocalizedString
JavacMessages.ResourceBundleHelper#getResourceBundle(Locale):::Gets the ResourceBundle.:::
JCDiagnostic.Factory#instance(Context):::Get the Factory instance for this context.:::instance->context->get->if->new->Factory->return
JCDiagnostic.Factory#error(DiagnosticFlag, DiagnosticSource, DiagnosticPosition, String, Object...):::Create an error diagnostic:::return->errorKey->error
JCDiagnostic.Factory#error(DiagnosticFlag, DiagnosticSource, DiagnosticPosition, Error):::Create an error diagnostic:::diag->EnumSet->copyOf->create->if->diag->setFlag->return
JCDiagnostic.Factory#mandatoryWarning(LintCategory, DiagnosticSource, DiagnosticPosition, String, Object...):::Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.:::return->warningKey->mandatoryWarning
JCDiagnostic.Factory#mandatoryWarning(LintCategory, DiagnosticSource, DiagnosticPosition, Warning):::Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.:::return->EnumSet->of->create
JCDiagnostic.Factory#warning(LintCategory, DiagnosticSource, DiagnosticPosition, String, Object...):::Create a warning diagnostic.:::return->warningKey->warning
JCDiagnostic.Factory#warning(LintCategory, DiagnosticSource, DiagnosticPosition, Warning):::Create a warning diagnostic.:::return->EnumSet->noneOf->create
JCDiagnostic.Factory#mandatoryNote(DiagnosticSource, String, Object...):::Create a note diagnostic that will not be hidden by the -nowarn or -Xlint:none options.:::return->noteKey->mandatoryNote
JCDiagnostic.Factory#mandatoryNote(DiagnosticSource, Note):::Create a note diagnostic that will not be hidden by the -nowarn or -Xlint:none options.:::return->EnumSet->of->create
JCDiagnostic.Factory#note(DiagnosticSource, DiagnosticPosition, String, Object...):::Create a note diagnostic.:::return->noteKey->note
JCDiagnostic.Factory#note(DiagnosticSource, DiagnosticPosition, Note):::Create a note diagnostic.:::return->EnumSet->noneOf->create
JCDiagnostic.Factory#fragment(String, Object...):::Create a fragment diagnostic, for use as an argument in other diagnostics:::return->fragmentKey->fragment
JCDiagnostic.Factory#fragment(Fragment):::Create a fragment diagnostic, for use as an argument in other diagnostics:::return->EnumSet->noneOf->create
JCDiagnostic.Factory#create(DiagnosticType, DiagnosticSource, DiagnosticPosition, String, Object...):::Create a new diagnostic of the given kind, which is not mandatory and which has no lint category.:::return->EnumSet->noneOf->DiagnosticInfo->of->create
JCDiagnostic.Factory#create(DiagnosticSource, DiagnosticPosition, DiagnosticInfo):::Create a new diagnostic of the given kind, which is not mandatory and which has no lint category.:::return->EnumSet->noneOf->create
JCDiagnostic.Factory#create(DiagnosticType, LintCategory, Set, DiagnosticSource, DiagnosticPosition, String, Object...):::Create a new diagnostic of the given kind.:::return->DiagnosticInfo->of->create
JCDiagnostic.Factory#create(LintCategory, Set, DiagnosticSource, DiagnosticPosition, DiagnosticInfo):::Create a new diagnostic with given key.:::return->normalize->new->JCDiagnostic
JCDiagnostic.Factory#errorKey(String, Object...):::Create a new error key.:::return->DiagnosticInfo->of
JCDiagnostic.Factory#warningKey(String, Object...):::Create a new warning key.:::return->DiagnosticInfo->of
JCDiagnostic.Factory#noteKey(String, Object...):::Create a new note key.:::return->DiagnosticInfo->of
JCDiagnostic.Factory#fragmentKey(String, Object...):::Create a new fragment key.:::return->DiagnosticInfo->of
JCDiagnostic#fragment(String, Object...):::Create a fragment diagnostic, for use as an argument in other diagnostics:::return->getFragmentFormatter->DiagnosticInfo->of->EnumSet->noneOf->new->JCDiagnostic
JCDiagnostic.DiagnosticPosition#getTree():::Gets the tree node, if any, to which the diagnostic applies.:::
JCDiagnostic.DiagnosticPosition#getStartPosition():::If there is a tree node, get the start position of the tree node:::
JCDiagnostic.DiagnosticPosition#getPreferredPosition():::Get the position within the file that most accurately defines the  location for the diagnostic.:::
JCDiagnostic.DiagnosticPosition#getEndPosition(EndPosTable):::If there is a tree node, and if endPositions are available, get  the end position of the tree node:::
JCDiagnostic.DiagnosticInfo#key():::Compute the resource key.:::return
JCDiagnostic.DiagnosticInfo#of(DiagnosticType, String, String, Object...):::Static factory method; build a custom diagnostic key using given kind, prefix, code and args.:::switch->return->new->Error->return->new->Warning->return->new->Note->return->new->Fragment->Assert->error->return
JCDiagnostic.DiagnosticInfo#getCode():::Returns the code for this diagnostic info, provided mainly for backward compatibility:::return
JCDiagnostic.DiagnosticInfo#getArgs():::Returns the arguments for this diagnostic info, provided mainly for backward compatibility:::return
JCDiagnostic#getType():::Get the type of this diagnostic.:::return
JCDiagnostic#getSubdiagnostics():::Get the subdiagnostic list:::return->List->nil
JCDiagnostic#isMandatory():::Check whether or not this diagnostic is required to be shown.:::return->flags->contains
JCDiagnostic#hasLintCategory():::Check whether this diagnostic has an associated lint category.:::return
JCDiagnostic#getLintCategory():::Get the associated lint category, or null if none.:::return
JCDiagnostic#getSource():::Get the name of the source file referred to by this diagnostic.:::if->return->else->return->source->getFile
JCDiagnostic#getDiagnosticSource():::Get the source referred to by this diagnostic.:::return
JCDiagnostic#getLineNumber():::Get the line number within the source referred to by this diagnostic.:::if->new->SourcePosition->return->sourcePosition->getLineNumber
JCDiagnostic#getColumnNumber():::Get the column number within the line of source referred to by this diagnostic.:::if->new->SourcePosition->return->sourcePosition->getColumnNumber
JCDiagnostic#getArgs():::Get the arguments to be included in the text of the diagnostic.:::return
JCDiagnostic#getPrefix():::Get the prefix string associated with this type of diagnostic.:::return->getPrefix
JCDiagnostic#getPrefix(DiagnosticType):::Get the prefix string associated with a particular type of diagnostic.:::return->defaultFormatter->Locale->getDefault->formatKind
JCDiagnostic#toString():::Return the standard presentation of this diagnostic.:::return->defaultFormatter->Locale->getDefault->format
List#nil():::Construct an empty list.:::return
List#filter(List, A):::Returns the list obtained from 'l' after removing all elements 'elem':::Assert->checkNonNull->res->List->nil->foreach->if->a->equals->res->prepend->return->res->reverse
List#take(int):::Create a new list from the first n elements of this list:::buf->new->ListBuffer<>->count->foreach->if->break->buf->append->return->buf->toList
List#of(A):::Construct a list consisting of given element.:::return->List->nil->new->List<>
List#of(A, A):::Construct a list consisting of given elements.:::return->of->new->List<>
List#of(A, A, A):::Construct a list consisting of given elements.:::return->of->new->List<>
List#of(A, A, A, A...):::Construct a list consisting of given elements.:::return->from->new->List<>->new->List<>->new->List<>
List#from(A[]):::Construct a list consisting all elements of given array.:::xs->nil->if->for->i->return
List#fill(int, A):::Construct a list consisting of a given number of identical elements.:::l->nil->for->i->return
List#isEmpty():::Does list have no elements?:::return
List#prepend(A):::Prepend given element to front of list, forming and returning  a new list.:::return->new->List<>
List#prependList(List):::Prepend given list of elements to front of list, forming and returning  a new list.:::if->this->isEmpty->return->if->xs->isEmpty->return->if->isEmpty->return->prepend->result->rev->xs->reverse->Assert->check->while->rev->nonEmpty->h->h->setTail->return
List#reverse():::Reverse list:::if->isEmpty->tail->isEmpty->return->rev->nil->for->l->l->nonEmpty->return
List#append(A):::Append given element at length, forming and returning  a new list.:::return->of->prependList
List#appendList(List):::Append given list at length, forming and returning  a new list.:::return->x->prependList
List#appendList(ListBuffer):::Append given list buffer at length, forming and returning a new list.:::return->x->toList->appendList
List#toArray(T[]):::Copy successive elements of this list into given vector until  list is exhausted or end of vector is reached.:::i->l->dest->while->l->nonEmpty->if->l->isEmpty->if->return->Array->vec->getClass->getComponentType->size->newInstance->return->toArray
List#toString(String):::Form a string listing all elements with given separator character.:::if->isEmpty->return->else->buf->new->StringBuilder->buf->append->for->l->l->nonEmpty->return->buf->toString
List#toString():::Form a string listing all elements with comma as the separator character.:::return->toString
List#hashCode():::Compute a hash code, overrides Object:::l->h->while->hashCode->return
List#equals(Object):::Is this list the same as other list?:::if->return->equals->if->t->oIter->iterator->while->oIter->hasNext->o->oIter->next->if->equals->return->return->t->isEmpty->oIter->hasNext->return
List#equals(List, List):::Are the two lists the same?:::while->if->if->return->else->if->equals->return->return
List#contains(Object):::Does the list contain the specified element?:::l->while->if->if->return->else->if->equals->return->return
List#last():::The last element in the list, if any, or null.:::last->t->while->return
List#collector():::Collect elements into a new list (using a @code{ListBuffer}):::return->Collector->ListBuffer->new->ListBuffer->add->buf1->addAll->return->ListBuffer->toList->of
ListBuffer#length():::Return the number of elements in this buffer.:::return
ListBuffer#isEmpty():::Is buffer empty?:::return
ListBuffer#nonEmpty():::Is buffer not empty?:::return
ListBuffer#prepend(A):::Prepend an element to buffer.:::elems->prepend->if->return
ListBuffer#append(A):::Append an element to buffer.:::Assert->checkNonNull->if->copy->newLast->List->of->if->else->return
ListBuffer#appendList(List):::Append all elements in a list to buffer.:::while->xs->nonEmpty->append->return
ListBuffer#appendList(ListBuffer):::Append all elements in a list to buffer.:::return->xs->toList->appendList
ListBuffer#appendArray(A[]):::Append all elements in an array to buffer.:::foreach->append->return
ListBuffer#toList():::Convert buffer to a list of all its elements.:::return
ListBuffer#contains(Object):::Does the list contain the specified element?:::return->elems->contains
ListBuffer#toArray(T[]):::Convert buffer to an array:::return->elems->toArray
ListBuffer#first():::The first element in this buffer.:::return
ListBuffer#next():::Return first element in this buffer and remove:::x->if->elems->isEmpty->if->elems->isEmpty->return
ListBuffer#iterator():::An enumeration of all elements in this buffer.:::return->new->Iterator<A>
Log.DiagnosticHandler#install(Log):::Install this diagnostic handler as the current one, recording the previous one.:::
Log.DiagnosticHandler#report(JCDiagnostic):::Handle a diagnostic.:::
Log.DeferredDiagnosticHandler#reportDeferredDiagnostics():::Report all deferred diagnostics.:::EnumSet->allOf->reportDeferredDiagnostics
Log.DeferredDiagnosticHandler#reportDeferredDiagnostics(Set):::Report selected deferred diagnostics.:::d->while->deferred->poll->if->kinds->d->getKind->contains->prev->report
Log#instance(Context):::Get the Log instance for this context.:::instance->context->get->if->new->Log->return
Log#preRegister(Context, PrintWriter):::Register a Context.Factory to create a Log.:::context->new->Log->put
Log#getDefaultMaxErrors():::Default value for -Xmaxerrs.:::return
Log#getDefaultMaxWarnings():::Default value for -Xmaxwarns.:::return
Log#currentSourceFile():::Return current sourcefile.:::return->source->getFile
Log#getDiagnosticFormatter():::Get the current diagnostic formatter.:::return
Log#setDiagnosticFormatter(DiagnosticFormatter):::Set the current diagnostic formatter.:::
Log#popDiagnosticHandler(DiagnosticHandler):::Replace the specified diagnostic handler with the handler that was current at the time this handler was created:::Assert->check
Log#flush():::Flush the logs:::foreach->writers->values->pw->flush
Log#shouldReport(JavaFileObject, int):::Returns true if an error needs to be reported for a given source name and pos.:::if->return->coords->new->Pair<>->shouldReport->recorded->contains->if->recorded->add->return
Log#prompt():::Prompt user after an error.:::if->localize->println->try->while->switch->read->System->exit->return->return->throw->new->AssertionError->catch->finally
Log#printRawLines(String):::Print the text of a message, translating newlines appropriately  for the platform.:::noticeWriter->writers->get->printRawLines
Log#printRawLines(WriterKind, String):::Print the text of a message, translating newlines appropriately  for the platform.:::getWriter->printRawLines
Log#printRawLines(PrintWriter, String):::Print the text of a message, translating newlines appropriately  for the platform.:::nl->while->msg->indexOf->writer->msg->substring->println->msg->substring->if->msg->length->writer->println
Log#printVerbose(String, Object...):::Print the localized text of a "verbose" message to the noticeWriter stream.:::noticeWriter->writers->get->localize->printRawLines
Log#strictWarning(DiagnosticPosition, String, Object...):::Report a warning that cannot be suppressed.:::diags->warning->writeDiagnostic
Log#report(JCDiagnostic):::Primary method to report a diagnostic.:::diagnosticHandler->report
Log#writeDiagnostic(JCDiagnostic):::Write out a diagnostic.:::if->diagListener->report->return->writer->diag->getType->getWriterForDiagnosticType->diagFormatter->messages->getCurrentLocale->format->printRawLines->if->switch->diag->getType->prompt->if->new->RuntimeException->printStackTrace->writer->flush
Log#getLocalizedString(String, Object...):::Find a localized string in the resource bundle:::return->JavacMessages->key->getDefaultLocalizedString
Log#localize(String, Object...):::Find a localized string in the resource bundle.:::return->localize
Log#localize(PrefixKind, String, Object...):::Find a localized string in the resource bundle.:::if->return->pk->key->else->return->messages->pk->key->getLocalizedString
Log#rawError(int, String):::report an error::::errWriter->writers->get->if->currentSourceFile->shouldReport->printRawDiag->prompt->errWriter->flush
Log#rawWarning(int, String):::report a warning::::warnWriter->writers->get->if->printRawDiag->prompt->warnWriter->flush
MandatoryWarningHandler#report(DiagnosticPosition, Warning):::Report a mandatory warning.:::currentSource->log->currentSourceFile->if->if->new->HashSet<>->if->logMandatoryWarning->sourcesWithReportedWarnings->add->else->if->if->sourcesWithReportedWarnings->contains->else->else->if->equal->else->if->else->if->equal
MandatoryWarningHandler#reportDeferredDiagnostic():::Report any diagnostic that might have been deferred by previous calls of report().:::if->if->deferredDiagnosticKind->getKey->logMandatoryNote->else->deferredDiagnosticKind->getKey->logMandatoryNote->if->logMandatoryNote
MatchingUtils#isValidImportString(String):::Return true if the argument string is a valid import-style string specifying claimed annotations; return false otherwise.:::if->s->equals->return->valid->t->index->t->indexOf->if->if->t->length->if->t->charAt->t->t->length->substring->else->return->if->javaIds->t->t->length->split->foreach->SourceVersion->isIdentifier->return
Name#append(Name):::Return the concatenation of this name and name `n'.:::len->getByteLength->bs->n->getByteLength->new->byteArr->getBytes->n->getBytes->return->table->fromUtf
Name#append(char, Name):::Return the concatenation of this name, the given ASCII  character, and name `n'.:::len->getByteLength->bs->n->getByteLength->new->byteArr->getBytes->n->getBytes->return->table->fromUtf
Name#compareTo(Name):::An arbitrary but consistent complete order among all Names.:::return->other->getIndex->this->getIndex
Name#isEmpty():::Return true if this is the empty name.:::return->getByteLength
Name#lastIndexOf(byte):::Returns last occurrence of byte b in this name, -1 if not found.:::bytes->getByteArray->offset->getByteOffset->i->getByteLength->while->return
Name#startsWith(Name):::Does this name start with prefix?:::thisBytes->this->getByteArray->thisOffset->this->getByteOffset->thisLength->this->getByteLength->prefixBytes->prefix->getByteArray->prefixOffset->prefix->getByteOffset->prefixLength->prefix->getByteLength->if->return->i->while->return
Name#subName(int, int):::Returns the sub-name starting at position start, up to and  excluding position end.:::if->return->table->getByteArray->getByteOffset->fromUtf
Name#toString():::Return the string representation of this name.:::return->Convert->getByteArray->getByteOffset->getByteLength->utf2string
Name#toUtf():::Return the Utf8 representation of this name.:::bs->getByteLength->new->byteArr->getBytes->return
Name#getByteLength():::Get the length (in bytes) of this name.:::
Name#getByteAt(int):::Returns i'th byte of this name.:::
Name#getBytes(byte[], int):::Copy all bytes of this name to buffer cs, starting at start.:::System->getByteArray->getByteOffset->getByteLength->arraycopy
Name#getByteArray():::Get the underlying byte array for this name:::
Name#getByteOffset():::Get the start offset of this name within its byte array.:::
Name.Table#fromChars(char[], int, int):::Get the name from the characters in cs[start..start+len-1].:::
Name.Table#fromString(String):::Get the name for the characters in string s.:::cs->s->toCharArray->return->fromChars
Name.Table#fromUtf(byte[]):::Get the name for the bytes in array cs:::return->fromUtf
Name.Table#fromUtf(byte[], int, int):::get the name for the bytes in cs[start..start+len-1]:::
Name.Table#dispose():::Release any resources used by this table.:::
Name.Table#hashValue(byte[], int, int):::The hashcode of a name.:::h->off->for->i->return
Name.Table#equals(byte[], int, byte[], int, int):::Compare two subarrays:::i->while->return
Options#instance(Context):::Get the Options instance for this context.:::instance->context->get->if->new->Options->return
Options#get(String):::Get the value for an undocumented option.:::return->values->get
Options#get(Option):::Get the value for an option.:::return->values->get
Options#getBoolean(String):::Get the boolean value for an option, patterned after Boolean.getBoolean, essentially will return true, iff the value exists and is set to "true".:::return->getBoolean
Options#getBoolean(String, boolean):::Get the boolean with a default value if the option is not set.:::value->get->return->Boolean->parseBoolean
Options#isSet(String):::Check if the value for an undocumented option has been set.:::return->values->get
Options#isSet(Option):::Check if the value for an option has been set.:::return->values->get
Options#isSet(Option, String):::Check if the value for a choice option has been set to a specific value.:::return->values->get
Options#isLintSet(String):::Check if the value for a lint option has been explicitly set, either with -Xlint:opt  or if all lint options have enabled and this one not disabled with -Xlint:-opt.:::return->isSet->isSet->isSet->isUnset
Options#isUnset(String):::Check if the value for an undocumented option has not been set.:::return->values->get
Options#isUnset(Option):::Check if the value for an option has not been set.:::return->values->get
Options#isUnset(Option, String):::Check if the value for a choice option has not been set to a specific value.:::return->values->get
Position#makeLineMap(char[], int, boolean):::A two-way map between line/column numbers and positions,  derived from a scan done at creation time:::lineMap->new->LineTabMapImpl->new->LineMapImpl->lineMap->build->return
Position#encodePosition(int, int):::Encode line and column numbers in an integer as:  line-number << LINESHIFT + column-number :::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->if->return->return
Position.LineMap#getStartPosition(int):::Find the start position of a line.:::
Position.LineMap#getPosition(int, int):::Find the position corresponding to a (line,column).:::
Position.LineMap#getLineNumber(int):::Find the line containing a position; a line termination character is on the line it terminates.:::
Position.LineMap#getColumnNumber(int):::Find the column for a character position:::
RichDiagnosticFormatter#instance(Context):::Get the DiagnosticFormatter instance for this context.:::instance->context->get->if->new->RichDiagnosticFormatter->return
RichDiagnosticFormatter#setRichPrinter(RichPrinter):::Sets the type/symbol printer used by this formatter.:::formatter->setPrinter
RichDiagnosticFormatter#getRichPrinter():::Returns the type/symbol printer used by this formatter.:::return
RichDiagnosticFormatter#preprocessDiagnostic(JCDiagnostic):::Preprocess a given diagnostic by looking both into its arguments and into its subdiagnostics (if any):::foreach->diag->getArgs->if->preprocessArgument->if->diag->isMultiline->foreach->diag->getSubdiagnostics->preprocessDiagnostic
RichDiagnosticFormatter#preprocessArgument(Object):::Preprocess a diagnostic argument:::if->preprocessType->else->if->preprocessSymbol->else->if->preprocessDiagnostic->else->if->foreach->preprocessArgument
RichDiagnosticFormatter#getWhereClauses():::Build a list of multiline diagnostics containing detailed info about type-variables, captured types, and intersection types:::clauses->List->nil->foreach->WhereClauseKind->values->lines->List->nil->foreach->whereClauses->get->entrySet->lines->entry->getValue->prepend->if->lines->isEmpty->key->kind->key->if->lines->size->d->diags->whereClauses->get->keySet->fragment->lines->reverse->new->JCDiagnostic.MultilineDiagnostic->clauses->prepend->return->clauses->reverse
RichDiagnosticFormatter.ClassNameSimplifier#addUsage(Symbol):::Add a name usage to the simplifier's internal cache:::n->sym->getSimpleName->conflicts->nameClashes->get->if->List->nil->if->conflicts->contains->nameClashes->conflicts->append->put
RichDiagnosticFormatter#preprocessType(Type):::Preprocess a given type looking for (i) additional info (where clauses) to be added to the main diagnostic (ii) names to be compacted.:::typePreprocessor->visit
RichDiagnosticFormatter#preprocessSymbol(Symbol):::Preprocess a given symbol looking for (i) additional info (where clauses) to be added to the main diagnostic (ii) names to be compacted:::symbolPreprocessor->visit
RichDiagnosticFormatter.RichConfiguration#getAvailableFeatures():::Returns a list of all the features supported by the rich formatter.:::return->RichFormatterFeature->values
RichDiagnosticFormatter.RichConfiguration#enable(RichFormatterFeature):::Enable a specific feature on this rich formatter.:::features->add
RichDiagnosticFormatter.RichConfiguration#disable(RichFormatterFeature):::Disable a specific feature on this rich formatter.:::features->remove
RichDiagnosticFormatter.RichConfiguration#isEnabled(RichFormatterFeature):::Is a given feature enabled on this formatter?:::return->features->contains
SharedNameTable.NameImpl#hashCode():::Return the hash value of this name.:::return
SharedNameTable.NameImpl#equals(Object):::Is this name equal to other?:::if->return->getIndex->else->return
StringUtils#toLowerCase(String):::Converts the given String to lower case using the Locale#US US Locale:::return->source->toLowerCase
StringUtils#toUpperCase(String):::Converts the given String to upper case using the Locale#US US Locale:::return->source->toUpperCase
StringUtils#indexOfIgnoreCase(String, String):::Case insensitive version of String#indexOf(java.lang.String):::return->indexOfIgnoreCase
StringUtils#indexOfIgnoreCase(String, String, int):::Case insensitive version of String#indexOf(java.lang.String, int):::m->Pattern->Pattern->quote->compile->matcher->return->m->find->m->start
