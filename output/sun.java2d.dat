DestSurfaceProvider#getDestSurface():::Returns a surface currently used as a destination surface for rendering.:::
Disposer#addRecord(Object, long, long):::Registers the object and the native data for later disposal.:::disposerInstance->new->DefaultDisposerRecord->add
Disposer#addRecord(Object, DisposerRecord):::Registers the object and the native data for later disposal.:::disposerInstance->add
Disposer#add(Object, DisposerRecord):::Performs the actual registration of the target object to be disposed.:::if->getDisposerReferent->ref->if->new->PhantomReference<>->else->new->WeakReference<>->records->put
DisposerTarget#getDisposerReferent():::Returns an object which will be used as the referent in the ReferenceQueue:::
FontSupport#getFontConfiguration():::Returns the current font configuration.:::
NullSurfaceData#invalidate():::Sets this SurfaceData object to the invalid state:::
NullSurfaceData#getReplacement():::Return a new SurfaceData object that represents the current state of the destination that this SurfaceData object describes:::return
NullSurfaceData#getRaster(int, int, int, int):::Return a readable Raster which contains the pixels for the specified rectangular region of the destination surface:::throw->new->InvalidPipeException
NullSurfaceData#useTightBBoxes():::Does the pixel accessibility of the destination surface suggest that rendering algorithms might want to take extra time to calculate a more accurate bounding box for the operation being performed? The typical case when this will be true is when a copy of the pixels has to be made when doing a getRaster:::return
NullSurfaceData#pixelFor(int):::Returns the pixel data for the specified Argb value packed into an integer for easy storage and conveyance.:::return
NullSurfaceData#rgbFor(int):::Returns the Argb representation for the specified integer value which is packed in the format of the associated ColorModel.:::return
NullSurfaceData#getBounds():::Returns the bounds of the destination surface.:::return->new->Rectangle
NullSurfaceData#checkCustomComposite():::Performs Security Permissions checks to see if a Custom Composite object should be allowed access to the pixels of this surface.:::return
NullSurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int):::Performs a copyarea within this surface:::return
NullSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData (null):::return
ReentrantContextProvider#newContext():::Create a new ReentrantContext instance:::
ReentrantContextProvider#acquire():::Give a ReentrantContext instance for the current thread:::
ReentrantContextProvider#release(K):::Restore the given ReentrantContext instance for reuse:::
ReentrantContextProviderCLQ#acquire():::Give a ReentrantContext instance for the current thread:::ctx->ref->while->ctxQueue->poll->ref->get->if->newContext->return
ReentrantContextProviderCLQ#release(K):::Restore the given ReentrantContext instance for reuse:::if->ctxQueue->getOrCreateReference->offer
ReentrantContextProviderTL#acquire():::Give a ReentrantContext instance for the current thread:::ctx->ref->ctxTL->get->if->ref->get->if->newContext->ctxTL->getOrCreateReference->set->if->else->ctxProviderCLQ->acquire->return
ReentrantContextProviderTL#release(K):::Restore the given ReentrantContext instance for reuse:::if->else->ctxProviderCLQ->release
ScreenUpdateManager#createGraphics(SurfaceData, WComponentPeer, Color, Color, Font):::Creates a SunGraphics2D object for the surface, given the parameters.:::return->new->SunGraphics2D
ScreenUpdateManager#createScreenSurface(Win32GraphicsConfig, WComponentPeer, int, boolean):::Creates and returns the surface for the peer:::return->gc->createSurfaceData
ScreenUpdateManager#dropScreenSurface(SurfaceData):::Drops the passed surface from the list of managed surfaces:::
ScreenUpdateManager#getReplacementScreenSurface(WComponentPeer, SurfaceData):::Returns a replacement SurfaceData for the invalid passed one:::surfaceData->peer->getSurfaceData->if->surfaceData->isValid->return->peer->replaceSurfaceData->return->peer->getSurfaceData
ScreenUpdateManager#getInstance():::Returns an (singleton) instance of the screen surfaces manager class.:::if->if->WindowsFlags->isD3DEnabled->new->D3DScreenUpdateManager->else->new->ScreenUpdateManager->return
Spans#add(float, float):::Add a span covering the half open interval including start up to but not including end.:::if->mSpans->new->Span->add->if->sortAndCollapse
Spans#addInfinite():::Add a span which covers the entire range:::
Spans#intersects(float, float):::Returns true if the span defined by the half-open interval from start up to, but not including, end intersects any of the spans defined by this instance.:::doesIntersect->if->if->sortAndCollapse->found->Collections->new->Span->binarySearch->else->return
Spans.Span#getStart():::Return the start of the Span:::return
Spans.Span#getEnd():::Return the end of the Span:::return
Spans.Span#setStart(float):::Change the initial position of the Span.:::
Spans.Span#setEnd(float):::Change the terminal position of the Span.:::
Spans.Span#subsume(Span):::Attempt to alter this Span to include otherSpan without altering this span's starting position:::isSubsumed->contains->if->return
Spans.Span#contains(float):::Return true if the passed in position lies in the half-open interval defined by this Span.:::return
Spans.Span#compareTo(Span):::Rank spans according to their starting position:::otherStart->otherSpan->getStart->result->if->else->if->else->return
StateTrackable#getState():::Returns the general state of the complex data held by this object:::
StateTrackable#getStateTracker():::Returns an object which can track future changes to the complex data stored in this object:::
StateTrackableDelegate#createInstance(State):::Returns a StateTrackableDelegate instance with the specified initial State State:::switch->return->return->new->StateTrackableDelegate->return->new->StateTrackableDelegate->return->throw->new->InternalError
StateTrackableDelegate#setImmutable():::This method provides an easy way for delegating classes to change the overall State State of the delegate to State#IMMUTABLE IMMUTABLE.:::if->throw->new->IllegalStateException
StateTrackableDelegate#setUntrackable():::This method provides an easy way for delegating classes to change the overall State State of the delegate to State#UNTRACKABLE UNTRACKABLE:::if->throw->new->IllegalStateException
StateTrackableDelegate#addDynamicAgent():::This method provides an easy way for delegating classes to manage temporarily setting the overall State State of the delegate to State#DYNAMIC DYNAMIC during well-defined time frames of dynamic pixel updating:::if->throw->new->IllegalStateException->if
StateTrackableDelegate#removeDynamicAgent():::This method provides an easy way for delegating classes to manage restoring the overall State State of the delegate back to State#STABLE STABLE after a well-defined time frame of dynamic pixel updating:::if
StateTrackableDelegate#markDirty():::This method provides an easy way for delegating classes to indicate that the contents have changed:::
StateTracker#isCurrent():::Returns true iff the contents of the complex data of the associated StateTrackable object have not changed since the time that this StateTracker was returned from its getStateTracker() method.:::
SunCompositeContext#dispose():::Release resources allocated for context.:::
SunCompositeContext#compose(Raster, Raster, WritableRaster):::This method composes the two source tiles and places the result in the destination tile:::src->w->h->if->dst->setDataElements->if->else->src1->createCompatibleWritableRaster->src->setDataElements->Math->src->getWidth->src2->getWidth->min->Math->src->getHeight->src2->getHeight->min->srcImg->srcCM->isAlphaPremultiplied->new->BufferedImage->dstImg->dstCM->isAlphaPremultiplied->new->BufferedImage->srcData->BufImgSurfaceData->createData->dstData->BufImgSurfaceData->createData->blit->Blit->srcData->getSurfaceType->dstData->getSurfaceType->getFromCache->blit->Blit
SunGraphics2D#create():::Create a new SunGraphics2D based on this one.:::return->clone
SunGraphics2D#constrain(int, int, int, int, Region):::Constrain rendering for lightweight objects.:::if->translate->if->clipRect->return->scaleX->transform->getScaleX->scaleY->transform->getScaleY->transform->getTranslateX->transform->getTranslateY->Region->Region->clipScale->dimAdd->Region->Region->clipScale->dimAdd->c->if->Region->getInstanceXYXY->else->c->getIntersectionXYXY->if->region->getScaledRegion->region->getTranslatedRegion->c->getIntersection->if->return->if->devClip->isInsideQuickCheck->devClip->getIntersection->validateCompClip
SunGraphics2D#constrain(int, int, int, int):::Constrain rendering for lightweight objects:::constrain
SunGraphics2D#hit(Rectangle, Shape, boolean):::Checks to see if a Path intersects the specified Rectangle in device space:::if->stroke->createStrokedShape->transformShape->if->new->Rectangle->rect->translate->return->s->intersects
SunGraphics2D#getDeviceColorModel():::Return the ColorModel associated with this Graphics2D.:::return->surfaceData->getColorModel
SunGraphics2D#getDeviceConfiguration():::Return the device configuration associated with this Graphics2D.:::return->surfaceData->getDeviceConfiguration
SunGraphics2D#getSurfaceData():::Return the SurfaceData object assigned to manage the destination drawable surface of this Graphics2D.:::return
SunGraphics2D#setComposite(Composite):::Sets the Composite in the current graphics state:::if->return->newCompState->newCompType->if->alphacomp->CompositeType->forAlphaComposite->if->if->paint->getTransparency->else->else->if->else->if->surfaceData->getTransparency->else->else->if->else->if->throw->new->IllegalArgumentException->else->surfaceData->checkCustomComposite->if->invalidatePipe->if->validateColor
SunGraphics2D#setPaint(Paint):::Sets the Paint in the current graphics state.:::if->setColor->return->if->return->if->if->paint->getTransparency->if->else->if->paintClass->paint->getClass->if->else->if->else->if->else->if->else->invalidatePipe
SunGraphics2D#setRenderingHint(Key, Object):::Sets the preferences for the rendering algorithms:::if->hintKey->isCompatibleValue->throw->new->IllegalArgumentException->if->stateChanged->textStateChanged->recognized->sunKey->newHint->if->intValue->else->getIndex->switch->sunKey->getIndex->if->if->break->if->if->validateBasicStroke->break->break->break->break->switch->break->break->break->break->break->break->break->if->if->invalidatePipe->if->if->hints->put->return->if->makeHints->hints->put
SunGraphics2D#getRenderingHint(Key):::Returns the preferences for the rendering algorithms.:::if->return->hints->get->if->return->keyindex->getIndex->switch->return->get->return->get->return->get->return->get->return->switch->return->return->return->return->return->get->return->get->return
SunGraphics2D#setRenderingHints(Map):::Sets the preferences for the rendering algorithms:::customHintPresent->iter->hints->keySet->iterator->while->iter->hasNext->key->iter->next->if->hints->get->setRenderingHint->else->if->makeHints->invalidatePipe
SunGraphics2D#addRenderingHints(Map):::Adds a number of preferences for the rendering algorithms:::customHintPresent->iter->hints->keySet->iterator->while->iter->hasNext->key->iter->next->if->hints->get->setRenderingHint->else->if->if->makeHints->else->putAll
SunGraphics2D#getRenderingHints():::Gets the preferences for the rendering algorithms:::if->return->makeHints->else->return->hints->clone
SunGraphics2D#translate(double, double):::Concatenates the current transform of this Graphics2D with a translation transformation:::transform->translate->invalidateTransform
SunGraphics2D#rotate(double):::Concatenates the current transform of this Graphics2D with a rotation transformation:::transform->rotate->invalidateTransform
SunGraphics2D#rotate(double, double, double):::Concatenates the current transform of this Graphics2D with a translated rotation transformation:::transform->rotate->invalidateTransform
SunGraphics2D#scale(double, double):::Concatenates the current transform of this Graphics2D with a scaling transformation:::transform->scale->invalidateTransform
SunGraphics2D#shear(double, double):::Concatenates the current transform of this Graphics2D with a shearing transformation:::transform->shear->invalidateTransform
SunGraphics2D#transform(AffineTransform):::Composes a Transform object with the transform in this Graphics2D according to the rule last-specified-first-applied:::concatenate->invalidateTransform
SunGraphics2D#translate(int, int):::Translate:::transform->translate->if->else->invalidateTransform
SunGraphics2D#setTransform(AffineTransform):::Sets the Transform in the current graphics state.:::if->transform->setTransform->else->transform->setToTranslation->transform->concatenate->invalidateTransform
SunGraphics2D#getTransform():::Returns the current Transform in the Graphics2D state.:::if->return->new->AffineTransform->tx->AffineTransform->getTranslateInstance->tx->concatenate->return
SunGraphics2D#cloneTransform():::Returns the current Transform ignoring the "constrain" rectangle.:::return->new->AffineTransform
SunGraphics2D#getPaint():::Returns the current Paint in the Graphics2D state.:::return
SunGraphics2D#getComposite():::Returns the current Composite in the Graphics2D state.:::return
SunGraphics2D#setBackground(Color):::Sets the background color in this context used for clearing a region:::
SunGraphics2D#getBackground():::Returns the background color used for clearing a region.:::return
SunGraphics2D#getStroke():::Returns the current Stroke in the Graphics2D state.:::return
SunGraphics2D#clip(Shape):::Intersects the current clip with the specified Path and sets the current clip to the resulting intersection:::transformShape->if->intersectShapes->validateCompClip
SunGraphics2D#draw(Shape):::Strokes the outline of a Path using the settings of the current graphics state:::try->shapepipe->draw->catch->try->revalidateAll->shapepipe->draw->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fill(Shape):::Fills the interior of a Path using the settings of the current graphics state:::try->shapepipe->fill->catch->try->revalidateAll->shapepipe->fill->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawRenderedImage(RenderedImage, AffineTransform):::Draws an image, applying a transform from image space into user space before drawing:::if->return->if->bufImg->drawImage->return->isIntegerTranslate->isIntegerTranslation->pad->clip->try->getCompClip->catch->return->finally->region->getImageRegion->if->return->if->xform->getTranslateX->xform->getTranslateY->drawTranslatedRenderedImage->return->raster->img->getData->wRaster->Raster->raster->getSampleModel->raster->getDataBuffer->createWritableRaster->minX->raster->getMinX->minY->raster->getMinY->width->raster->getWidth->height->raster->getHeight->px->raster->getSampleModelTranslateX->py->raster->getSampleModelTranslateY->if->wRaster->getWidth->wRaster->getHeight->wRaster->createWritableChild->transXform->xform->clone->transXform->translate->cm->img->getColorModel->bufImg->cm->isAlphaPremultiplied->new->BufferedImage->drawImage
SunGraphics2D#drawImage(Image, int, int, int, int, ImageObserver):::Draws an image scaled to x,y,w,h in nonblocking mode with a callback object.:::return->drawImage
SunGraphics2D#copyImage(Image, int, int, int, int, int, int, Color, ImageObserver):::Not part of the advertised API but a useful utility method to call internally:::try->return->imagepipe->copyImage->catch->try->revalidateAll->return->imagepipe->copyImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, int, int, Color, ImageObserver):::Draws an image scaled to x,y,w,h in nonblocking mode with a solid background color and a callback object.:::if->return->if->return->imgW->img->getWidth->imgH->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->if->return->copyImage->try->return->imagepipe->scaleImage->catch->try->revalidateAll->return->imagepipe->scaleImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, ImageObserver):::Draws an image at x,y in nonblocking mode.:::return->drawImage
SunGraphics2D#drawImage(Image, int, int, Color, ImageObserver):::Draws an image at x,y in nonblocking mode with a solid background color and a callback object.:::if->return->imgW->img->getWidth->imgH->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->try->return->imagepipe->copyImage->catch->try->revalidateAll->return->imagepipe->copyImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, int, int, int, int, int, int, ImageObserver):::Draws a subrectangle of an image scaled to a destination rectangle in nonblocking mode with a callback object.:::return->drawImage
SunGraphics2D#drawImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver):::Draws a subrectangle of an image scaled to a destination rectangle in nonblocking mode with a solid background color and a callback object.:::if->return->if->return->hidpiImageDrawn->drawHiDPIImage->if->return->if->srcX->srcY->dstX->dstY->width->height->if->else->if->else->return->copyImage->try->return->imagepipe->scaleImage->catch->try->revalidateAll->return->imagepipe->scaleImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, AffineTransform, ImageObserver):::Draw an image, applying a transform from image space into user space before drawing:::if->return->if->xform->isIdentity->return->drawImage->w->img->getWidth->h->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->return->transformImage
SunGraphics2D#getFontRenderContext():::Get the rendering context of the font within this Graphics2D context.:::if->aahint->if->tx->if->if->transform->getTranslateX->transform->getTranslateY->else->transform->getScaleX->transform->getShearY->transform->getShearX->transform->getScaleY->new->AffineTransform->get->get->new->FontRenderContext->return
SunGraphics2D#dispose():::This object has no resources to dispose of per se, but the doc comments for the base method in java.awt.Graphics imply that this object will not be useable after it is disposed:::invalidatePipe
SunGraphics2D#finalize():::Graphics has a finalize method that automatically calls dispose() for subclasses:::
SunGraphics2D#getDestination():::Returns destination that this Graphics renders to:::return->surfaceData->getDestination
SunGraphicsEnvironment#getScreenDevices():::Returns an array of all of the screen devices.:::ret->if->num->getNumScreens->new->GraphicsDeviceArr->for->i->return
SunGraphicsEnvironment#getNumScreens():::Returns the number of screen devices of this graphics environment.:::
SunGraphicsEnvironment#makeScreenDevice(int):::Create and return the screen device with the specified number:::
SunGraphicsEnvironment#getDefaultScreenDevice():::Returns the default screen graphics device.:::screens->getScreenDevices->if->throw->new->AWTError->return
SunGraphicsEnvironment#createGraphics(BufferedImage):::Returns a Graphics2D object for rendering into the given BufferedImage.:::if->throw->new->NullPointerException->sd->SurfaceData->getPrimarySurfaceData->return->new->SunGraphics2D
SunGraphicsEnvironment#getAllFonts():::Returns all fonts available in this environment.:::fm->getFontManagerForSGE->installedFonts->fm->getAllInstalledFonts->created->fm->getCreatedFonts->if->return->else->newlen->fonts->copyOf->System->arraycopy->return
SunGraphicsEnvironment#getUsableBounds(GraphicsDevice):::Return the bounds of a GraphicsDevice, less its screen insets:::gc->gd->getDefaultConfiguration->insets->Toolkit->getDefaultToolkit->getScreenInsets->usableBounds->gc->getBounds->return
SunGraphicsEnvironment#displayChanged():::From the DisplayChangedListener interface; called when the display mode has been changed.:::foreach->getScreenDevices->if->displayChanged->displayChanger->notifyListeners
SunGraphicsEnvironment#paletteChanged():::Part of the DisplayChangedListener interface: propagate this event to listeners:::displayChanger->notifyPaletteChanged
SunGraphicsEnvironment#isDisplayLocal():::Returns true when the display is local, false for remote displays.:::
SunGraphicsEnvironment#addDisplayChangedListener(DisplayChangedListener):::Add a DisplayChangeListener to be notified when the display settings are changed.:::displayChanger->add
SunGraphicsEnvironment#removeDisplayChangedListener(DisplayChangedListener):::Remove a DisplayChangeListener from Win32GraphicsEnvironment:::displayChanger->remove
SunGraphicsEnvironment#isFlipStrategyPreferred(ComponentPeer):::Returns true if FlipBufferStrategy with COPIED buffer contents is preferred for this peer's GraphicsConfiguration over BlitBufferStrategy, false otherwise:::return
SunGraphicsEnvironment#getGraphicsConfigurationAtPoint(GraphicsConfiguration, double, double):::Returns the graphics configuration which bounds contain the given point.:::if->current->getBounds->contains->return->env->getLocalGraphicsEnvironment->foreach->env->getScreenDevices->config->device->getDefaultConfiguration->if->config->getBounds->contains->return->return
SunGraphicsEnvironment#convertToDeviceSpace(double, double):::Converts coordinates from the user's space to the device space using appropriate device transformation.:::gc->getLocalGraphicsEnvironment->getDefaultScreenDevice->getDefaultConfiguration->getGraphicsConfigurationAtPoint->tx->gc->getDefaultTransform->Region->tx->getScaleX->clipRound->Region->tx->getScaleY->clipRound->return->new->Point
SurfaceData#setBlitProxyKey(Object):::Subclasses can set a "blit proxy key" which will be used along with the SurfaceManager.getCacheData() mechanism to store acceleration-compatible cached copies of source images:::if->SurfaceDataProxy->isCachingAllowed
SurfaceData#getSourceSurfaceData(Image, int, CompositeType, Color):::This method is called on a destination SurfaceData to choose the best SurfaceData from a source Image for an imaging operation, with help from its SurfaceManager:::srcMgr->SurfaceManager->getManager->srcData->srcMgr->getPrimarySurfaceData->if->img->getAccelerationPriority->sdp->srcMgr->getCacheData->if->sdp->isValid->if->srcData->getState->else->makeProxyFor->srcMgr->setCacheData->sdp->replaceData->return
SurfaceData#makeProxyFor(SurfaceData):::This method is called on a destination SurfaceData to choose a proper SurfaceDataProxy subclass for a source SurfaceData to use to control when and with what surface to override a given image operation:::return
SurfaceData#getPrimarySurfaceData(Image):::Extracts the SurfaceManager from the given Image, and then returns the SurfaceData object that would best be suited as the destination surface in some rendering operation.:::sMgr->SurfaceManager->getManager->return->sMgr->getPrimarySurfaceData
SurfaceData#restoreContents(Image):::Restores the contents of the given Image and then returns the new SurfaceData object in use by the Image's SurfaceManager.:::sMgr->SurfaceManager->getManager->return->sMgr->restoreContents
SurfaceData#markDirty():::Marks this surface as dirty.:::stateDelegate->markDirty
SurfaceData#setSurfaceLost(boolean):::Sets the value of the surfaceLost variable, which indicates whether something has happened to the rendering surface such that it needs to be restored and re-rendered.:::stateDelegate->markDirty
SurfaceData#isValid():::Returns a boolean indicating whether or not this SurfaceData is valid.:::return
SurfaceData#invalidate():::Sets this SurfaceData object to the invalid state:::stateDelegate->markDirty
SurfaceData#getReplacement():::Certain changes in the configuration of a surface require the invalidation of existing associated SurfaceData objects and the creation of brand new ones:::
SurfaceData#getMaskFill(SunGraphics2D):::Returns a MaskFill object that can be used on this destination with the source (paint) and composite types determined by the given SunGraphics2D, or null if no such MaskFill object can be located:::src->getPaintSurfaceType->comp->getFillCompositeType->dst->getSurfaceType->return->MaskFill->getFromCache
SurfaceData#getRenderLoops(SunGraphics2D):::Return a RenderLoops object containing all of the basic GraphicsPrimitive objects for rendering to the destination surface with the current attributes of the given SunGraphics2D.:::src->getPaintSurfaceType->comp->getFillCompositeType->dst->sg2d->getSurfaceData->getSurfaceType->o->loopcache->get->if->return->loops->makeRenderLoops->loopcache->put->return
SurfaceData#makeRenderLoops(SurfaceType, CompositeType, SurfaceType):::Construct and return a RenderLoops object containing all of the basic GraphicsPrimitive objects for rendering to the destination surface with the given source, destination, and composite types.:::loops->new->RenderLoops->DrawLine->locate->FillRect->locate->DrawRect->locate->DrawPolygons->locate->DrawPath->locate->FillPath->locate->FillSpans->locate->FillParallelogram->locate->DrawParallelogram->locate->DrawGlyphList->locate->DrawGlyphListAA->locate->DrawGlyphListLCD->locate->return
SurfaceData#getDeviceConfiguration():::Return the GraphicsConfiguration object that describes this destination surface.:::
SurfaceData#getSurfaceType():::Return the SurfaceType object that describes the destination surface.:::return
SurfaceData#getColorModel():::Return the ColorModel for the destination surface.:::return
SurfaceData#getTransparency():::Returns the type of this Transparency.:::return->getColorModel->getTransparency
SurfaceData#getRaster(int, int, int, int):::Return a readable Raster which contains the pixels for the specified rectangular region of the destination surface:::
SurfaceData#useTightBBoxes():::Does the pixel accessibility of the destination surface suggest that rendering algorithms might want to take extra time to calculate a more accurate bounding box for the operation being performed? The typical case when this will be true is when a copy of the pixels has to be made when doing a getRaster:::return
SurfaceData#pixelFor(int):::Returns the pixel data for the specified Argb value packed into an integer for easy storage and conveyance.:::return->surfaceType->pixelFor
SurfaceData#pixelFor(Color):::Returns the pixel data for the specified color packed into an integer for easy storage and conveyance:::return->c->getRGB->pixelFor
SurfaceData#rgbFor(int):::Returns the Argb representation for the specified integer value which is packed in the format of the associated ColorModel.:::return->surfaceType->rgbFor
SurfaceData#getBounds():::Returns the bounds of the destination surface.:::
SurfaceData#checkCustomComposite():::Performs Security Permissions checks to see if a Custom Composite object should be allowed access to the pixels of this surface.:::sm->System->getSecurityManager->if->if->new->java.awt.AWTPermission->sm->checkPermission
SurfaceData#isOpaqueGray(IndexColorModel):::Fetches private field IndexColorModel.allgrayopaque which is true when all palette entries in the color model are gray and opaque.:::
SurfaceData#isNull(SurfaceData):::For our purposes null and NullSurfaceData are the same as they represent a disposed surface.:::if->return->return
SurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int):::Performs a copyarea within this surface:::return
SurfaceData#flush():::Synchronously releases resources associated with this surface.:::
SurfaceData#getDestination():::Returns destination associated with this SurfaceData:::
SurfaceData#getDefaultScaleX():::Returns default horizontal scale factor of the destination surface:::return
SurfaceData#getDefaultScaleY():::Returns default vertical scale factor of the destination surface:::return
SurfaceDataProxy#isSupportedOperation(SurfaceData, int, CompositeType, Color):::Determine if an alternate form for the srcData is needed and appropriate from the given operational parameters.:::
SurfaceDataProxy#validateSurfaceData(SurfaceData, SurfaceData, int, int):::Construct an alternate form of the given SurfaceData:::
SurfaceDataProxy#getRetryTracker(SurfaceData):::If the subclass is unable to validate or create a cached SurfaceData then this method will be used to get a StateTracker object that will indicate when to attempt to validate the surface again:::return->new->CountdownTracker
SurfaceDataProxy#isValid():::Returns true iff this SurfaceData proxy is still the best way to control caching of the given source on the given destination.:::return
SurfaceDataProxy#invalidate():::Sets the valid state to false so that the next time this proxy is fetched to generate a replacement SurfaceData, the code in SurfaceData knows to replace the proxy first.:::
SurfaceDataProxy#flush(boolean):::Flush all cached resources as per the FlushableCacheData interface:::if->invalidate->flush->return->isValid
SurfaceDataProxy#flush():::Actively flushes (drops and invalidates) the cached surface so that it can be reclaimed quickly.:::csd->if->csd->flush
SurfaceDataProxy#isAccelerated():::Returns true iff this SurfaceData proxy is still valid and if it has a currently cached replacement that is also valid and current.:::return->isValid->srcTracker->isCurrent->cacheTracker->isCurrent
SurfaceDataProxy#activateDisplayListener():::This method should be called from subclasses which create cached SurfaceData objects that depend on the current properties of the display.:::ge->GraphicsEnvironment->getLocalGraphicsEnvironment->if->addDisplayChangedListener
SurfaceDataProxy#displayChanged():::Invoked when the display mode has changed:::flush
SurfaceDataProxy#paletteChanged():::Invoked when the palette has changed.:::
SurfaceDataProxy#replaceData(SurfaceData, int, CompositeType, Color):::This method attempts to replace the srcData with a cached version:::if->isSupportedOperation->if->srcTracker->isCurrent->synchronized->srcData->getStateTracker->if->srcTracker->isCurrent->if->srcData->getState->invalidate->flush->return->csd->if->cacheTracker->isCurrent->synchronized->if->return->r->srcData->getBounds->w->h->curTracker->validateSurfaceData->if->synchronized->if->getRetryTracker->return->updateSurfaceData->if->csd->isValid->return->synchronized->if->curTracker->isCurrent->csd->getStateTracker->if->return->return
SurfaceDataProxy#updateSurfaceData(SurfaceData, SurfaceData, int, int):::This is the default implementation for updating the cached SurfaceData from the source (primary) SurfaceData:::srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blit->Blit->getFromCache->blit->Blit->dstData->markDirty
SurfaceDataProxy#updateSurfaceDataBg(SurfaceData, SurfaceData, int, int, Color):::This is an alternate implementation for updating the cached SurfaceData from the source (primary) SurfaceData using a background color for transparent pixels:::srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blitbg->BlitBg->getFromCache->blitbg->bgColor->getRGB->BlitBg->dstData->markDirty
SurfaceManagerFactory#getInstance():::Returns the surface manager factory instance:::if->throw->new->IllegalStateException->return
SurfaceManagerFactory#setInstance(SurfaceManagerFactory):::Sets the surface manager factory:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalStateException
SurfaceManagerFactory#createVolatileManager(SunVolatileImage, Object):::Creates a new instance of a VolatileSurfaceManager given any arbitrary SunVolatileImage:::
WindowsSurfaceManagerFactory#createVolatileManager(SunVolatileImage, Object):::Creates a new instance of a VolatileSurfaceManager given any arbitrary SunVolatileImage:::gc->vImg->getGraphicsConfig->if->return->new->D3DVolatileSurfaceManager->else->if->return->new->WGLVolatileSurfaceManager->else->return->new->BufImgVolatileSurfaceManager
