DefaultDisposerRecord#dispose()::: default disposer record dispose:::invokeNativeDispose
DefaultDisposerRecord#getDataPointer()::: default disposer record get data pointer:::return
DefaultDisposerRecord#getDisposerMethodPointer()::: default disposer record get disposer method pointer:::return
DefaultDisposerRecord#invokeNativeDispose(long, long)::: default disposer record invoke native dispose:::
DestSurfaceProvider#getDestSurface():::Returns a surface currently used as a destination surface for rendering.:::
Disposer#addRecord(Object, long, long):::Registers the object and the native data for later disposal.:::disposerInstance->new->DefaultDisposerRecord->add
Disposer#addRecord(Object, DisposerRecord):::Registers the object and the native data for later disposal.:::disposerInstance->add
Disposer#add(Object, DisposerRecord):::Performs the actual registration of the target object to be disposed.:::if->getDisposerReferent->ref->if->new->PhantomReference<>->else->new->WeakReference<>->records->put
Disposer#run()::: disposer run:::while->try->obj->queue->remove->clear->rec->records->remove->rec->dispose->clearDeferredRecords->catch->println->finally
Disposer#clearDeferredRecords()::: disposer clear deferred records:::if->deferredRecords->isEmpty->return->for->i->deferredRecords->size->deferredRecords->clear
Disposer#pollRemove()::: disposer poll remove:::if->return->obj->freed->deferred->try->while->queue->poll->clear->rec->records->remove->if->rec->dispose->else->if->continue->if->new->ArrayList<DisposerRecord>->deferredRecords->add->catch->println->finally
Disposer#initIDs()::: disposer init ds:::
Disposer#addReference(Reference, DisposerRecord)::: disposer add reference:::records->put
Disposer#addObjectRecord(Object, DisposerRecord)::: disposer add object record:::records->new->WeakReference<>->put
Disposer#getQueue()::: disposer get queue:::return
DisposerRecord#dispose()::: disposer record dispose:::
DisposerTarget#getDisposerReferent():::Returns an object which will be used as the referent in the ReferenceQueue:::
FontSupport#getFontConfiguration():::Returns the current font configuration.:::
HeadlessGraphicsEnvironment#getScreenDevices()::: headless graphics environment get screen devices:::throw->new->HeadlessException
HeadlessGraphicsEnvironment#getDefaultScreenDevice()::: headless graphics environment get default screen device:::throw->new->HeadlessException
HeadlessGraphicsEnvironment#getCenterPoint()::: headless graphics environment get center point:::throw->new->HeadlessException
HeadlessGraphicsEnvironment#getMaximumWindowBounds()::: headless graphics environment get maximum window bounds:::throw->new->HeadlessException
HeadlessGraphicsEnvironment#createGraphics(BufferedImage)::: headless graphics environment create graphics:::return->ge->createGraphics
HeadlessGraphicsEnvironment#getAllFonts()::: headless graphics environment get all fonts:::return->ge->getAllFonts
HeadlessGraphicsEnvironment#getAvailableFontFamilyNames()::: headless graphics environment get available font family names:::return->ge->getAvailableFontFamilyNames
HeadlessGraphicsEnvironment#getAvailableFontFamilyNames(Locale)::: headless graphics environment get available font family names:::return->ge->getAvailableFontFamilyNames
HeadlessGraphicsEnvironment#getSunGraphicsEnvironment()::: headless graphics environment get sun graphics environment:::return
NullSurfaceData#invalidate():::Sets this SurfaceData object to the invalid state:::
NullSurfaceData#getReplacement():::Return a new SurfaceData object that represents the current state of the destination that this SurfaceData object describes:::return
NullSurfaceData#validatePipe(SunGraphics2D)::: null surface data validate pipe:::
NullSurfaceData#getDeviceConfiguration()::: null surface data get device configuration:::return
NullSurfaceData#getRaster(int, int, int, int):::Return a readable Raster which contains the pixels for the specified rectangular region of the destination surface:::throw->new->InvalidPipeException
NullSurfaceData#useTightBBoxes():::Does the pixel accessibility of the destination surface suggest that rendering algorithms might want to take extra time to calculate a more accurate bounding box for the operation being performed? The typical case when this will be true is when a copy of the pixels has to be made when doing a getRaster:::return
NullSurfaceData#pixelFor(int):::Returns the pixel data for the specified Argb value packed into an integer for easy storage and conveyance.:::return
NullSurfaceData#rgbFor(int):::Returns the Argb representation for the specified integer value which is packed in the format of the associated ColorModel.:::return
NullSurfaceData#getBounds():::Returns the bounds of the destination surface.:::return->new->Rectangle
NullSurfaceData#checkCustomComposite():::Performs Security Permissions checks to see if a Custom Composite object should be allowed access to the pixels of this surface.:::return
NullSurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int):::Performs a copyarea within this surface:::return
NullSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData (null):::return
ReentrantContextProvider#newContext():::Create a new ReentrantContext instance:::
ReentrantContextProvider#acquire():::Give a ReentrantContext instance for the current thread:::
ReentrantContextProvider#release(K):::Restore the given ReentrantContext instance for reuse:::
ReentrantContextProvider#getOrCreateReference(K)::: reentrant context provider get or create reference:::if->switch->new->HardReference<K>->break->new->SoftReference<K>->break->new->WeakReference<K>->break->return
ReentrantContextProvider.HardReference#get()::: hard reference get:::return
ReentrantContextProviderCLQ#acquire():::Give a ReentrantContext instance for the current thread:::ctx->ref->while->ctxQueue->poll->ref->get->if->newContext->return
ReentrantContextProviderCLQ#release(K):::Restore the given ReentrantContext instance for reuse:::if->ctxQueue->getOrCreateReference->offer
ReentrantContextProviderTL#acquire():::Give a ReentrantContext instance for the current thread:::ctx->ref->ctxTL->get->if->ref->get->if->newContext->ctxTL->getOrCreateReference->set->if->else->ctxProviderCLQ->acquire->return
ReentrantContextProviderTL#release(K):::Restore the given ReentrantContext instance for reuse:::if->else->ctxProviderCLQ->release
ScreenUpdateManager#createGraphics(SurfaceData, WComponentPeer, Color, Color, Font):::Creates a SunGraphics2D object for the surface, given the parameters.:::return->new->SunGraphics2D
ScreenUpdateManager#createScreenSurface(Win32GraphicsConfig, WComponentPeer, int, boolean):::Creates and returns the surface for the peer:::return->gc->createSurfaceData
ScreenUpdateManager#dropScreenSurface(SurfaceData):::Drops the passed surface from the list of managed surfaces:::
ScreenUpdateManager#getReplacementScreenSurface(WComponentPeer, SurfaceData):::Returns a replacement SurfaceData for the invalid passed one:::surfaceData->peer->getSurfaceData->if->surfaceData->isValid->return->peer->replaceSurfaceData->return->peer->getSurfaceData
ScreenUpdateManager#getInstance():::Returns an (singleton) instance of the screen surfaces manager class.:::if->if->WindowsFlags->isD3DEnabled->new->D3DScreenUpdateManager->else->new->ScreenUpdateManager->return
Spans#add(float, float):::Add a span covering the half open interval including start up to but not including end.:::if->mSpans->new->Span->add->if->sortAndCollapse
Spans#addInfinite():::Add a span which covers the entire range:::
Spans#intersects(float, float):::Returns true if the span defined by the half-open interval from start up to, but not including, end intersects any of the spans defined by this instance.:::doesIntersect->if->if->sortAndCollapse->found->Collections->new->Span->binarySearch->else->return
Spans#sortAndCollapse():::Sort the spans in ascending order by their start position:::Collections->sort->iter->mSpans->iterator->span->if->iter->hasNext->iter->next->while->iter->hasNext->nextSpan->iter->next->if->span->subsume->iter->remove->else
Spans.Span#getStart():::Return the start of the Span:::return
Spans.Span#getEnd():::Return the end of the Span:::return
Spans.Span#setStart(float):::Change the initial position of the Span.:::
Spans.Span#setEnd(float):::Change the terminal position of the Span.:::
Spans.Span#subsume(Span):::Attempt to alter this Span to include otherSpan without altering this span's starting position:::isSubsumed->contains->if->return
Spans.Span#contains(float):::Return true if the passed in position lies in the half-open interval defined by this Span.:::return
Spans.Span#compareTo(Span):::Rank spans according to their starting position:::otherStart->otherSpan->getStart->result->if->else->if->else->return
Spans.Span#toString()::: span to string:::return
Spans.SpanIntersection#compare(Span, Span)::: span intersection compare:::result->if->span1->getEnd->span2->getStart->else->if->span1->getStart->span2->getEnd->else->return
StateTrackable#getState():::Returns the general state of the complex data held by this object:::
StateTrackable#getStateTracker():::Returns an object which can track future changes to the complex data stored in this object:::
StateTrackableDelegate#createInstance(State):::Returns a StateTrackableDelegate instance with the specified initial State State:::switch->return->return->new->StateTrackableDelegate->return->new->StateTrackableDelegate->return->throw->new->InternalError
StateTrackableDelegate#getState()::: state trackable delegate get state:::return
StateTrackableDelegate#getStateTracker()::: state trackable delegate get state tracker:::st->if->switch->break->new->StateTracker->break->break->return
StateTrackableDelegate#setImmutable():::This method provides an easy way for delegating classes to change the overall State State of the delegate to State#IMMUTABLE IMMUTABLE.:::if->throw->new->IllegalStateException
StateTrackableDelegate#setUntrackable():::This method provides an easy way for delegating classes to change the overall State State of the delegate to State#UNTRACKABLE UNTRACKABLE:::if->throw->new->IllegalStateException
StateTrackableDelegate#addDynamicAgent():::This method provides an easy way for delegating classes to manage temporarily setting the overall State State of the delegate to State#DYNAMIC DYNAMIC during well-defined time frames of dynamic pixel updating:::if->throw->new->IllegalStateException->if
StateTrackableDelegate#removeDynamicAgent():::This method provides an easy way for delegating classes to manage restoring the overall State State of the delegate back to State#STABLE STABLE after a well-defined time frame of dynamic pixel updating:::if
StateTrackableDelegate#markDirty():::This method provides an easy way for delegating classes to indicate that the contents have changed:::
StateTracker#isCurrent():::Returns true iff the contents of the complex data of the associated StateTrackable object have not changed since the time that this StateTracker was returned from its getStateTracker() method.:::
SunCompositeContext#dispose():::Release resources allocated for context.:::
SunCompositeContext#compose(Raster, Raster, WritableRaster):::This method composes the two source tiles and places the result in the destination tile:::src->w->h->if->dst->setDataElements->if->else->src1->createCompatibleWritableRaster->src->setDataElements->Math->src->getWidth->src2->getWidth->min->Math->src->getHeight->src2->getHeight->min->srcImg->srcCM->isAlphaPremultiplied->new->BufferedImage->dstImg->dstCM->isAlphaPremultiplied->new->BufferedImage->srcData->BufImgSurfaceData->createData->dstData->BufImgSurfaceData->createData->blit->Blit->srcData->getSurfaceType->dstData->getSurfaceType->getFromCache->blit->Blit
SunGraphics2D#getDefaultTransform()::: sun graphics2 d get default transform:::gc->getDeviceConfiguration->return->new->AffineTransform->gc->getDefaultTransform
SunGraphics2D#clone()::: sun graphics2 d clone:::try->g->super->clone->new->AffineTransform->if->clone->if->if->clone->else->if->clone->return->catch->finally->return
SunGraphics2D#create():::Create a new SunGraphics2D based on this one.:::return->clone
SunGraphics2D#setDevClip(int, int, int, int)::: sun graphics2 d set dev clip:::c->if->Region->getInstanceXYWH->else->c->getIntersectionXYWH->validateCompClip
SunGraphics2D#setDevClip(Rectangle)::: sun graphics2 d set dev clip:::setDevClip
SunGraphics2D#constrain(int, int, int, int, Region):::Constrain rendering for lightweight objects.:::if->translate->if->clipRect->return->scaleX->transform->getScaleX->scaleY->transform->getScaleY->transform->getTranslateX->transform->getTranslateY->Region->Region->clipScale->dimAdd->Region->Region->clipScale->dimAdd->c->if->Region->getInstanceXYXY->else->c->getIntersectionXYXY->if->region->getScaledRegion->region->getTranslatedRegion->c->getIntersection->if->return->if->devClip->isInsideQuickCheck->devClip->getIntersection->validateCompClip
SunGraphics2D#constrain(int, int, int, int):::Constrain rendering for lightweight objects:::constrain
SunGraphics2D#invalidatePipe()::: sun graphics2 d invalidate pipe:::
SunGraphics2D#validatePipe()::: sun graphics2 d validate pipe:::if->surfaceData->isValid->throw->new->InvalidPipeException->surfaceData->validatePipe
SunGraphics2D#intersectShapes(Shape, Shape, boolean, boolean)::: sun graphics2 d intersect shapes:::if->return->intersection->if->return->intersectRectShape->else->if->return->intersectRectShape->return->intersectByArea
SunGraphics2D#intersectRectShape(Rectangle2D, Shape, boolean, boolean)::: sun graphics2 d intersect rect shape:::if->r2->outrect->if->else->if->else->new->Rectangle2D.Float->x1->Math->r->getX->r2->getX->max->x2->Math->r->getX->r->getWidth->r2->getX->r2->getWidth->min->y1->Math->r->getY->r2->getY->max->y2->Math->r->getY->r->getHeight->r2->getY->r2->getHeight->min->if->outrect->setFrameFromDiagonal->else->outrect->setFrameFromDiagonal->return->if->r->s->getBounds2D->contains->if->cloneShape->return->return->intersectByArea
SunGraphics2D#cloneShape(Shape)::: sun graphics2 d clone shape:::return->new->GeneralPath
SunGraphics2D#intersectByArea(Shape, Shape, boolean, boolean)::: sun graphics2 d intersect by area:::a1->a2->if->else->if->else->new->Area->if->else->new->Area->a1->intersect->if->a1->isRectangular->return->a1->getBounds->return
SunGraphics2D#getCompClip()::: sun graphics2 d get comp clip:::if->surfaceData->isValid->revalidateAll->return
SunGraphics2D#getFont()::: sun graphics2 d get font:::if->return
SunGraphics2D#checkFontInfo(FontInfo, Font, FontRenderContext)::: sun graphics2 d check font info:::if->new->FontInfo->ptSize->font->getSize2D->txFontType->devAt->textAt->if->font->isTransformed->font->getTransform->textAt->scale->textAt->getType->textAt->getTranslateX->textAt->getTranslateY->textAt->translate->if->transform->new->doubleArr->getMatrix->new->AffineTransform->textAt->preConcatenate->else->textAt->new->doubleArr->getMatrix->shearx->textAt->getShearX->scaley->textAt->getScaleY->if->Math->sqrt->Math->abs->else->if->transform->new->doubleArr->getMatrix->new->AffineTransform->new->doubleArr->for->i->new->AffineTransform->shearx->transform->getShearX->scaley->transform->getScaleY->if->Math->sqrt->Math->abs->else->pszInt->if->else->if->new->doubleArr->new->AffineTransform->FontUtilities->getFont2D->fmhint->if->aahint->if->else->frc->getAntiAliasingHint->getIndex->if->if->else->else->if->if->useAAForPtSize->else->else->if->if->surfaceData->canRenderLCDText->else->if->else->if->getStrike->return
SunGraphics2D#isRotated(double[])::: sun graphics2 d is rotated:::if->return->return
SunGraphics2D#setFont(Font)::: sun graphics2 d set font:::if->if->font->isTransformed->FontUtilities->getFont2D->font->getSize->useAAForPtSize
SunGraphics2D#getFontInfo()::: sun graphics2 d get font info:::if->checkFontInfo->return
SunGraphics2D#getGVFontInfo(Font, FontRenderContext)::: sun graphics2 d get font info:::if->return->else->return->checkFontInfo
SunGraphics2D#getFontMetrics()::: sun graphics2 d get font metrics:::if->return->return->FontDesignMetrics->getFontRenderContext->getMetrics
SunGraphics2D#getFontMetrics(Font)::: sun graphics2 d get font metrics:::if->return->fm->FontDesignMetrics->getFontRenderContext->getMetrics->if->return
SunGraphics2D#hit(Rectangle, Shape, boolean):::Checks to see if a Path intersects the specified Rectangle in device space:::if->stroke->createStrokedShape->transformShape->if->new->Rectangle->rect->translate->return->s->intersects
SunGraphics2D#getDeviceColorModel():::Return the ColorModel associated with this Graphics2D.:::return->surfaceData->getColorModel
SunGraphics2D#getDeviceConfiguration():::Return the device configuration associated with this Graphics2D.:::return->surfaceData->getDeviceConfiguration
SunGraphics2D#getSurfaceData():::Return the SurfaceData object assigned to manage the destination drawable surface of this Graphics2D.:::return
SunGraphics2D#setComposite(Composite):::Sets the Composite in the current graphics state:::if->return->newCompState->newCompType->if->alphacomp->CompositeType->forAlphaComposite->if->if->paint->getTransparency->else->else->if->else->if->surfaceData->getTransparency->else->else->if->else->if->throw->new->IllegalArgumentException->else->surfaceData->checkCustomComposite->if->invalidatePipe->if->validateColor
SunGraphics2D#setPaint(Paint):::Sets the Paint in the current graphics state.:::if->setColor->return->if->return->if->if->paint->getTransparency->if->else->if->paintClass->paint->getClass->if->else->if->else->if->else->if->else->invalidatePipe
SunGraphics2D#validateBasicStroke(BasicStroke)::: sun graphics2 d validate basic stroke:::aa->if->if->if->bs->getLineWidth->if->bs->getDashArray->else->else->else->if->else->if->bs->getLineWidth->if->bs->getDashArray->else->else->else->widthsquared->if->transform->getType->Math->transform->getDeterminant->abs->else->A->transform->getScaleX->C->transform->getShearX->B->transform->getShearY->D->transform->getScaleY->EA->EB->EC->hypot->Math->sqrt->if->bs->getLineWidth->bs->getLineWidth->if->if->bs->getDashArray->else->else
SunGraphics2D#setStroke(Stroke)::: sun graphics2 d set stroke:::if->throw->new->IllegalArgumentException->saveStrokeState->if->validateBasicStroke->else->if->invalidatePipe
SunGraphics2D#setRenderingHint(Key, Object):::Sets the preferences for the rendering algorithms:::if->hintKey->isCompatibleValue->throw->new->IllegalArgumentException->if->stateChanged->textStateChanged->recognized->sunKey->newHint->if->intValue->else->getIndex->switch->sunKey->getIndex->if->if->break->if->if->validateBasicStroke->break->break->break->break->switch->break->break->break->break->break->break->break->if->if->invalidatePipe->if->if->hints->put->return->if->makeHints->hints->put
SunGraphics2D#getRenderingHint(Key):::Returns the preferences for the rendering algorithms.:::if->return->hints->get->if->return->keyindex->getIndex->switch->return->get->return->get->return->get->return->get->return->switch->return->return->return->return->return->get->return->get->return
SunGraphics2D#setRenderingHints(Map):::Sets the preferences for the rendering algorithms:::customHintPresent->iter->hints->keySet->iterator->while->iter->hasNext->key->iter->next->if->hints->get->setRenderingHint->else->if->makeHints->invalidatePipe
SunGraphics2D#addRenderingHints(Map):::Adds a number of preferences for the rendering algorithms:::customHintPresent->iter->hints->keySet->iterator->while->iter->hasNext->key->iter->next->if->hints->get->setRenderingHint->else->if->if->makeHints->else->putAll
SunGraphics2D#getRenderingHints():::Gets the preferences for the rendering algorithms:::if->return->makeHints->else->return->hints->clone
SunGraphics2D#makeHints(Map)::: sun graphics2 d make hints:::model->new->RenderingHints->if->model->putAll->model->get->put->model->get->put->model->get->put->model->get->put->model->Integer->valueOf->put->value->switch->break->break->break->break->if->model->put->model->get->put->return
SunGraphics2D#translate(double, double):::Concatenates the current transform of this Graphics2D with a translation transformation:::transform->translate->invalidateTransform
SunGraphics2D#rotate(double):::Concatenates the current transform of this Graphics2D with a rotation transformation:::transform->rotate->invalidateTransform
SunGraphics2D#rotate(double, double, double):::Concatenates the current transform of this Graphics2D with a translated rotation transformation:::transform->rotate->invalidateTransform
SunGraphics2D#scale(double, double):::Concatenates the current transform of this Graphics2D with a scaling transformation:::transform->scale->invalidateTransform
SunGraphics2D#shear(double, double):::Concatenates the current transform of this Graphics2D with a shearing transformation:::transform->shear->invalidateTransform
SunGraphics2D#transform(AffineTransform):::Composes a Transform object with the transform in this Graphics2D according to the rule last-specified-first-applied:::concatenate->invalidateTransform
SunGraphics2D#translate(int, int):::Translate:::transform->translate->if->else->invalidateTransform
SunGraphics2D#setTransform(AffineTransform):::Sets the Transform in the current graphics state.:::if->transform->setTransform->else->transform->setToTranslation->transform->concatenate->invalidateTransform
SunGraphics2D#invalidateTransform()::: sun graphics2 d invalidate transform:::type->transform->getType->origTransformState->if->else->if->dtx->transform->getTranslateX->dty->transform->getTranslateY->Math->floor->Math->floor->if->else->else->if->else->if->if->invalidatePipe->if->validateBasicStroke
SunGraphics2D#getTransform():::Returns the current Transform in the Graphics2D state.:::if->return->new->AffineTransform->tx->AffineTransform->getTranslateInstance->tx->concatenate->return
SunGraphics2D#cloneTransform():::Returns the current Transform ignoring the "constrain" rectangle.:::return->new->AffineTransform
SunGraphics2D#getPaint():::Returns the current Paint in the Graphics2D state.:::return
SunGraphics2D#getComposite():::Returns the current Composite in the Graphics2D state.:::return
SunGraphics2D#getColor()::: sun graphics2 d get color:::return
SunGraphics2D#validateColor()::: sun graphics2 d validate color:::eargb->if->else->foregroundColor->getRGB->if->alphacomp->a->Math->alphacomp->getAlpha->round->surfaceData->pixelFor
SunGraphics2D#setColor(Color)::: sun graphics2 d set color:::if->return->validateColor->if->if->return->if->else->if->return->if->invalidatePipe
SunGraphics2D#setBackground(Color):::Sets the background color in this context used for clearing a region:::
SunGraphics2D#getBackground():::Returns the background color used for clearing a region.:::return
SunGraphics2D#getStroke():::Returns the current Stroke in the Graphics2D state.:::return
SunGraphics2D#getClipBounds()::: sun graphics2 d get clip bounds:::if->return->return->new->Rectangle->getClipBounds
SunGraphics2D#getClipBounds(Rectangle)::: sun graphics2 d get clip bounds:::if->if->if->r->setBounds->else->r->usrClip->getBounds2D->setFrame->r->translate->else->r->getClip->getBounds2D->setFrame->else->if->throw->new->NullPointerException->return
SunGraphics2D#hitClip(int, int, int, int)::: sun graphics2 d hit clip:::if->return->if->d->transform->transform->Math->Math->Math->min->Math->min->min->floor->Math->Math->Math->min->Math->min->min->floor->Math->Math->Math->max->Math->max->max->ceil->Math->Math->Math->max->Math->max->max->ceil->else->try->if->getCompClip->intersectsQuickCheckXYXY->return->catch->return->finally->return
SunGraphics2D#validateCompClip()::: sun graphics2 d validate comp clip:::origClipState->if->else->if->devClip->getIntersection->else->cpi->usrClip->getPathIterator->box->new->intArr->sr->LoopPipe->getFillSSI->try->sr->setOutputArea->sr->appendPath->sr->getPathBox->r->Region->getInstance->r->isRectangular->catch->finally->sr->dispose->if->invalidatePipe
SunGraphics2D#transformShape(Shape)::: sun graphics2 d transform shape:::if->return->if->return->transformShape->else->return->transformShape
SunGraphics2D#untransformShape(Shape)::: sun graphics2 d untransform shape:::if->return->if->try->return->transform->createInverse->transformShape->catch->return->finally->else->return->transformShape
SunGraphics2D#transformShape(int, int, Shape)::: sun graphics2 d transform shape:::if->return->if->r->s->getBounds->r->translate->return->if->rect->return->rect->getX->rect->getY->rect->getWidth->rect->getHeight->new->Rectangle2D.Double->if->return->cloneShape->mat->AffineTransform->getTranslateInstance->return->mat->createTransformedShape
SunGraphics2D#transformShape(AffineTransform, Shape)::: sun graphics2 d transform shape:::if->return->if->tx->getType->rect->matrix->new->doubleArr->rect->getX->rect->getY->rect->getWidth->rect->getHeight->tx->transform->fixRectangleOrientation->return->new->Rectangle2D.Double->if->tx->isIdentity->return->cloneShape->return->tx->createTransformedShape
SunGraphics2D#fixRectangleOrientation(double[], Rectangle2D):::Sets orientation of the rectangle according to the clip.:::if->clip->getWidth->t->if->clip->getHeight->t
SunGraphics2D#clipRect(int, int, int, int)::: sun graphics2 d clip rect:::new->Rectangle->clip
SunGraphics2D#setClip(int, int, int, int)::: sun graphics2 d set clip:::new->Rectangle->setClip
SunGraphics2D#getClip()::: sun graphics2 d get clip:::return->untransformShape
SunGraphics2D#setClip(Shape)::: sun graphics2 d set clip:::transformShape->validateCompClip
SunGraphics2D#clip(Shape):::Intersects the current clip with the specified Path and sets the current clip to the resulting intersection:::transformShape->if->intersectShapes->validateCompClip
SunGraphics2D#setPaintMode()::: sun graphics2 d set paint mode:::setComposite
SunGraphics2D#setXORMode(Color)::: sun graphics2 d set mode:::if->throw->new->IllegalArgumentException->new->XORComposite->setComposite
SunGraphics2D#copyArea(int, int, int, int, int, int)::: sun graphics2 d copy area:::try->doCopyArea->catch->try->revalidateAll->doCopyArea->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#doCopyArea(int, int, int, int, int, int)::: sun graphics2 d do copy area:::if->return->if->else->if->else->if->coords->transform->transform->Math->ceil->Math->ceil->Math->ceil->Math->ceil->Math->ceil->Math->ceil->if->if->else->throw->new->InternalError->theData->if->theData->copyArea->return->clip->getCompClip->comp->if->dsttype->theData->getSurfaceType->comptype->if->equals->theData->getTransparency->Blit->locate->ob->if->while->partW->Math->min->sx->ob->Blit->return->if->while->partH->Math->min->sy->ob->Blit->return->ob->Blit
SunGraphics2D#drawLine(int, int, int, int)::: sun graphics2 d draw line:::try->drawpipe->drawLine->catch->try->revalidateAll->drawpipe->drawLine->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawRoundRect(int, int, int, int, int, int)::: sun graphics2 d draw round rect:::try->drawpipe->drawRoundRect->catch->try->revalidateAll->drawpipe->drawRoundRect->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fillRoundRect(int, int, int, int, int, int)::: sun graphics2 d fill round rect:::try->fillpipe->fillRoundRect->catch->try->revalidateAll->fillpipe->fillRoundRect->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawOval(int, int, int, int)::: sun graphics2 d draw oval:::try->drawpipe->drawOval->catch->try->revalidateAll->drawpipe->drawOval->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fillOval(int, int, int, int)::: sun graphics2 d fill oval:::try->fillpipe->fillOval->catch->try->revalidateAll->fillpipe->fillOval->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawArc(int, int, int, int, int, int)::: sun graphics2 d draw arc:::try->drawpipe->drawArc->catch->try->revalidateAll->drawpipe->drawArc->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fillArc(int, int, int, int, int, int)::: sun graphics2 d fill arc:::try->fillpipe->fillArc->catch->try->revalidateAll->fillpipe->fillArc->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawPolyline(int[], int[], int)::: sun graphics2 d draw polyline:::try->drawpipe->drawPolyline->catch->try->revalidateAll->drawpipe->drawPolyline->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawPolygon(int[], int[], int)::: sun graphics2 d draw polygon:::try->drawpipe->drawPolygon->catch->try->revalidateAll->drawpipe->drawPolygon->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fillPolygon(int[], int[], int)::: sun graphics2 d fill polygon:::try->fillpipe->fillPolygon->catch->try->revalidateAll->fillpipe->fillPolygon->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawRect(int, int, int, int)::: sun graphics2 d draw rect:::try->drawpipe->drawRect->catch->try->revalidateAll->drawpipe->drawRect->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fillRect(int, int, int, int)::: sun graphics2 d fill rect:::try->fillpipe->fillRect->catch->try->revalidateAll->fillpipe->fillRect->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#revalidateAll()::: sun graphics2 d revalidate all:::try->surfaceData->getReplacement->if->invalidatePipe->surfaceData->getBounds->setDevClip->if->validateColor->if->c->getXorColor->new->XORComposite->setComposite->validatePipe->catch->finally
SunGraphics2D#clearRect(int, int, int, int)::: sun graphics2 d clear rect:::c->p->setComposite->getBackground->setColor->fillRect->setPaint->setComposite
SunGraphics2D#draw(Shape):::Strokes the outline of a Path using the settings of the current graphics state:::try->shapepipe->draw->catch->try->revalidateAll->shapepipe->draw->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#fill(Shape):::Fills the interior of a Path using the settings of the current graphics state:::try->shapepipe->fill->catch->try->revalidateAll->shapepipe->fill->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#isIntegerTranslation(AffineTransform):::Returns true if the given AffineTransform is an integer translation.:::if->xform->isIdentity->return->if->xform->getType->tx->xform->getTranslateX->ty->xform->getTranslateY->return->return
SunGraphics2D#getTileIndex(int, int, int):::Returns the index of the tile corresponding to the supplied position given the tile grid offset and size along the same axis.:::if->return
SunGraphics2D#getImageRegion(RenderedImage, Region, AffineTransform, AffineTransform, int, int):::Returns a rectangle in image coordinates that may be required in order to draw the given image into the given clipping region through a pair of AffineTransforms:::imageRect->img->getMinX->img->getMinY->img->getWidth->img->getHeight->new->Rectangle->result->try->p->new->doubleArr->compClip->getLoX->compClip->getHiX->compClip->getLoY->compClip->getHiY->transform->inverseTransform->xform->inverseTransform->x0->x1->y0->y1->for->i->x->w->y->h->clipRect->new->Rectangle->clipRect->intersection->catch->finally->return
SunGraphics2D#drawRenderedImage(RenderedImage, AffineTransform):::Draws an image, applying a transform from image space into user space before drawing:::if->return->if->bufImg->drawImage->return->isIntegerTranslate->isIntegerTranslation->pad->clip->try->getCompClip->catch->return->finally->region->getImageRegion->if->return->if->xform->getTranslateX->xform->getTranslateY->drawTranslatedRenderedImage->return->raster->img->getData->wRaster->Raster->raster->getSampleModel->raster->getDataBuffer->createWritableRaster->minX->raster->getMinX->minY->raster->getMinY->width->raster->getWidth->height->raster->getHeight->px->raster->getSampleModelTranslateX->py->raster->getSampleModelTranslateY->if->wRaster->getWidth->wRaster->getHeight->wRaster->createWritableChild->transXform->xform->clone->transXform->translate->cm->img->getColorModel->bufImg->cm->isAlphaPremultiplied->new->BufferedImage->drawImage
SunGraphics2D#clipTo(Rectangle, Rectangle):::Intersects destRect with clip and overwrites destRect with the result:::x1->Math->max->x2->Math->min->y1->Math->max->y2->Math->min->if->return->else->return
SunGraphics2D#drawTranslatedRenderedImage(RenderedImage, Rectangle, int, int):::Draw a portion of a RenderedImage tile-by-tile with a given integer image to user space translation:::tileGridXOffset->img->getTileGridXOffset->tileGridYOffset->img->getTileGridYOffset->tileWidth->img->getTileWidth->tileHeight->img->getTileHeight->minTileX->getTileIndex->minTileY->getTileIndex->maxTileX->getTileIndex->maxTileY->getTileIndex->colorModel->img->getColorModel->tileRect->new->Rectangle->for->ty
SunGraphics2D#drawRenderableImage(RenderableImage, AffineTransform)::: sun graphics2 d draw renderable image:::if->return->pipeTransform->concatTransform->new->AffineTransform->concatTransform->concatenate->reverseTransform->rc->new->RenderContext->try->pipeTransform->createInverse->catch->new->RenderContext->new->AffineTransform->finally->rendering->img->createRendering->drawRenderedImage
SunGraphics2D#transformBounds(Rectangle, AffineTransform)::: sun graphics2 d transform bounds:::if->tx->isIdentity->return->s->transformShape->return->s->getBounds
SunGraphics2D#drawString(String, int, int)::: sun graphics2 d draw string:::if->throw->new->NullPointerException->if->font->hasLayoutAttributes->if->str->length->return->getFontRenderContext->new->TextLayout->draw->return->try->textpipe->drawString->catch->try->revalidateAll->textpipe->drawString->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawString(String, float, float)::: sun graphics2 d draw string:::if->throw->new->NullPointerException->if->font->hasLayoutAttributes->if->str->length->return->getFontRenderContext->new->TextLayout->draw->return->try->textpipe->drawString->catch->try->revalidateAll->textpipe->drawString->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawString(AttributedCharacterIterator, int, int)::: sun graphics2 d draw string:::if->throw->new->NullPointerException->if->iterator->getBeginIndex->iterator->getEndIndex->return->tl->getFontRenderContext->new->TextLayout->tl->draw
SunGraphics2D#drawString(AttributedCharacterIterator, float, float)::: sun graphics2 d draw string:::if->throw->new->NullPointerException->if->iterator->getBeginIndex->iterator->getEndIndex->return->tl->getFontRenderContext->new->TextLayout->tl->draw
SunGraphics2D#drawGlyphVector(GlyphVector, float, float)::: sun graphics2 d draw glyph vector:::if->throw->new->NullPointerException->try->textpipe->drawGlyphVector->catch->try->revalidateAll->textpipe->drawGlyphVector->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawChars(char[], int, int, int, int)::: sun graphics2 d draw chars:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->if->font->hasLayoutAttributes->if->return->new->String->getFontRenderContext->new->TextLayout->draw->return->try->textpipe->drawChars->catch->try->revalidateAll->textpipe->drawChars->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawBytes(byte[], int, int, int, int)::: sun graphics2 d draw bytes:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->chData->new->charArr->for->i->if->font->hasLayoutAttributes->if->return->new->String->getFontRenderContext->new->TextLayout->draw->return->try->textpipe->drawChars->catch->try->revalidateAll->textpipe->drawChars->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#drawHiDPIImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver, AffineTransform)::: sun graphics2 d draw hi image:::if->sd->SurfaceManager->getManager->getPrimarySurfaceData->scaleX->sd->getDefaultScaleX->scaleY->sd->getDefaultScaleY->if->return->Region->clipRound->Region->clipRound->Region->clipRound->Region->clipRound->tx->if->new->AffineTransform->transform->result->scaleImage->if->transform->setTransform->invalidateTransform->return->else->if->width->img->getWidth->height->img->getHeight->mrImage->resolutionVariant->getResolutionVariant->if->rvObserver->MultiResolutionToolkitImage->getResolutionVariantObserver->rvWidth->resolutionVariant->getWidth->rvHeight->resolutionVariant->getHeight->if->widthScale->heightScale->if->sd->SurfaceManager->getManager->getPrimarySurfaceData->sd->getDefaultScaleX->sd->getDefaultScaleY->Region->clipScale->Region->clipScale->Region->clipScale->Region->clipScale->if->renderTX->new->AffineTransform->renderTX->scale->return->transformImage->return->scaleImage->return
SunGraphics2D#scaleImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver)::: sun graphics2 d scale image:::try->return->imagepipe->scaleImage->catch->try->revalidateAll->return->imagepipe->scaleImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#transformImage(Image, AffineTransform, ImageObserver)::: sun graphics2 d transform image:::try->return->imagepipe->transformImage->catch->try->revalidateAll->return->imagepipe->transformImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#getResolutionVariant(MultiResolutionImage, int, int, int, int, int, int, int, int, int, int, AffineTransform)::: sun graphics2 d get resolution variant:::if->return->sw->sh->if->return->tx->if->else->new->AffineTransform->tx->concatenate->type->tx->getType->dw->dh->destImageWidth->destImageHeight->if->else->if->configTransform->getDefaultTransform->if->configTransform->isIdentity->else->configTransform->getScaleX->configTransform->getScaleY->else->destRegionWidth->destRegionHeight->if->else->if->tx->getScaleX->tx->getScaleY->else->Math->tx->getScaleX->tx->getShearY->hypot->Math->tx->getShearX->tx->getScaleY->hypot->Math->abs->Math->abs->resolutionVariant->img->getResolutionVariant->if->hasError->return->return
SunGraphics2D#drawImage(Image, int, int, int, int, ImageObserver):::Draws an image scaled to x,y,w,h in nonblocking mode with a callback object.:::return->drawImage
SunGraphics2D#copyImage(Image, int, int, int, int, int, int, Color, ImageObserver):::Not part of the advertised API but a useful utility method to call internally:::try->return->imagepipe->copyImage->catch->try->revalidateAll->return->imagepipe->copyImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, int, int, Color, ImageObserver):::Draws an image scaled to x,y,w,h in nonblocking mode with a solid background color and a callback object.:::if->return->if->return->imgW->img->getWidth->imgH->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->if->return->copyImage->try->return->imagepipe->scaleImage->catch->try->revalidateAll->return->imagepipe->scaleImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, ImageObserver):::Draws an image at x,y in nonblocking mode.:::return->drawImage
SunGraphics2D#drawImage(Image, int, int, Color, ImageObserver):::Draws an image at x,y in nonblocking mode with a solid background color and a callback object.:::if->return->imgW->img->getWidth->imgH->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->try->return->imagepipe->copyImage->catch->try->revalidateAll->return->imagepipe->copyImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, int, int, int, int, int, int, int, int, ImageObserver):::Draws a subrectangle of an image scaled to a destination rectangle in nonblocking mode with a callback object.:::return->drawImage
SunGraphics2D#drawImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver):::Draws a subrectangle of an image scaled to a destination rectangle in nonblocking mode with a solid background color and a callback object.:::if->return->if->return->hidpiImageDrawn->drawHiDPIImage->if->return->if->srcX->srcY->dstX->dstY->width->height->if->else->if->else->return->copyImage->try->return->imagepipe->scaleImage->catch->try->revalidateAll->return->imagepipe->scaleImage->catch->return->finally->finally->surfaceData->markDirty
SunGraphics2D#drawImage(Image, AffineTransform, ImageObserver):::Draw an image, applying a transform from image space into user space before drawing:::if->return->if->xform->isIdentity->return->drawImage->w->img->getWidth->h->img->getHeight->hidpiImageDrawn->drawHiDPIImage->if->return->return->transformImage
SunGraphics2D#drawImage(BufferedImage, BufferedImageOp, int, int)::: sun graphics2 d draw image:::if->return->try->imagepipe->transformImage->catch->try->revalidateAll->imagepipe->transformImage->catch->finally->finally->surfaceData->markDirty
SunGraphics2D#getFontRenderContext():::Get the rendering context of the font within this Graphics2D context.:::if->aahint->if->tx->if->if->transform->getTranslateX->transform->getTranslateY->else->transform->getScaleX->transform->getShearY->transform->getShearX->transform->getScaleY->new->AffineTransform->get->get->new->FontRenderContext->return
SunGraphics2D#dispose():::This object has no resources to dispose of per se, but the doc comments for the base method in java.awt.Graphics imply that this object will not be useable after it is disposed:::invalidatePipe
SunGraphics2D#finalize():::Graphics has a finalize method that automatically calls dispose() for subclasses:::
SunGraphics2D#getDestination():::Returns destination that this Graphics renders to:::return->surfaceData->getDestination
SunGraphics2D#getDestSurface()::: sun graphics2 d get dest surface:::return
SunGraphicsEnvironment#getScreenDevices():::Returns an array of all of the screen devices.:::ret->if->num->getNumScreens->new->GraphicsDeviceArr->for->i->return
SunGraphicsEnvironment#getNumScreens():::Returns the number of screen devices of this graphics environment.:::
SunGraphicsEnvironment#makeScreenDevice(int):::Create and return the screen device with the specified number:::
SunGraphicsEnvironment#getDefaultScreenDevice():::Returns the default screen graphics device.:::screens->getScreenDevices->if->throw->new->AWTError->return
SunGraphicsEnvironment#createGraphics(BufferedImage):::Returns a Graphics2D object for rendering into the given BufferedImage.:::if->throw->new->NullPointerException->sd->SurfaceData->getPrimarySurfaceData->return->new->SunGraphics2D
SunGraphicsEnvironment#getFontManagerForSGE()::: sun graphics environment get font manager for e:::fm->FontManagerFactory->getInstance->return
SunGraphicsEnvironment#useAlternateFontforJALocales()::: sun graphics environment use alternate fontfor locales:::getFontManagerForSGE->useAlternateFontforJALocales
SunGraphicsEnvironment#getAllFonts():::Returns all fonts available in this environment.:::fm->getFontManagerForSGE->installedFonts->fm->getAllInstalledFonts->created->fm->getCreatedFonts->if->return->else->newlen->fonts->copyOf->System->arraycopy->return
SunGraphicsEnvironment#getAvailableFontFamilyNames(Locale)::: sun graphics environment get available font family names:::fm->getFontManagerForSGE->installed->fm->getInstalledFontFamilyNames->map->fm->getCreatedFontFamilyNames->if->map->size->return->else->for->i->retval->map->size->new->StringArr->keyNames->map->keySet->toArray->for->i->return
SunGraphicsEnvironment#getAvailableFontFamilyNames()::: sun graphics environment get available font family names:::return->Locale->getDefault->getAvailableFontFamilyNames
SunGraphicsEnvironment#getUsableBounds(GraphicsDevice):::Return the bounds of a GraphicsDevice, less its screen insets:::gc->gd->getDefaultConfiguration->insets->Toolkit->getDefaultToolkit->getScreenInsets->usableBounds->gc->getBounds->return
SunGraphicsEnvironment#displayChanged():::From the DisplayChangedListener interface; called when the display mode has been changed.:::foreach->getScreenDevices->if->displayChanged->displayChanger->notifyListeners
SunGraphicsEnvironment#paletteChanged():::Part of the DisplayChangedListener interface: propagate this event to listeners:::displayChanger->notifyPaletteChanged
SunGraphicsEnvironment#isDisplayLocal():::Returns true when the display is local, false for remote displays.:::
SunGraphicsEnvironment#addDisplayChangedListener(DisplayChangedListener):::Add a DisplayChangeListener to be notified when the display settings are changed.:::displayChanger->add
SunGraphicsEnvironment#removeDisplayChangedListener(DisplayChangedListener):::Remove a DisplayChangeListener from Win32GraphicsEnvironment:::displayChanger->remove
SunGraphicsEnvironment#isFlipStrategyPreferred(ComponentPeer):::Returns true if FlipBufferStrategy with COPIED buffer contents is preferred for this peer's GraphicsConfiguration over BlitBufferStrategy, false otherwise:::return
SunGraphicsEnvironment#isUIScaleEnabled()::: sun graphics environment is scale enabled:::return
SunGraphicsEnvironment#getDebugScale()::: sun graphics environment get debug scale:::return
SunGraphicsEnvironment#getScaleFactor(String)::: sun graphics environment get scale factor:::scaleFactor->AccessController->new->GetPropertyAction->doPrivileged->if->scaleFactor->equals->return->try->units->if->scaleFactor->endsWith->scaleFactor->scaleFactor->length->substring->else->if->scaleFactor->endsWith->scaleFactor->scaleFactor->length->substring->else->if->scaleFactor->endsWith->scaleFactor->scaleFactor->length->substring->scale->Double->parseDouble->return->catch->return->finally
SunGraphicsEnvironment#getGraphicsConfigurationAtPoint(GraphicsConfiguration, double, double):::Returns the graphics configuration which bounds contain the given point.:::if->current->getBounds->contains->return->env->getLocalGraphicsEnvironment->foreach->env->getScreenDevices->config->device->getDefaultConfiguration->if->config->getBounds->contains->return->return
SunGraphicsEnvironment#convertToDeviceSpace(double, double):::Converts coordinates from the user's space to the device space using appropriate device transformation.:::gc->getLocalGraphicsEnvironment->getDefaultScreenDevice->getDefaultConfiguration->getGraphicsConfigurationAtPoint->tx->gc->getDefaultTransform->Region->tx->getScaleX->clipRound->Region->tx->getScaleY->clipRound->return->new->Point
SurfaceData#initIDs()::: surface data init ds:::
SurfaceData#setBlitProxyKey(Object):::Subclasses can set a "blit proxy key" which will be used along with the SurfaceManager.getCacheData() mechanism to store acceleration-compatible cached copies of source images:::if->SurfaceDataProxy->isCachingAllowed
SurfaceData#getSourceSurfaceData(Image, int, CompositeType, Color):::This method is called on a destination SurfaceData to choose the best SurfaceData from a source Image for an imaging operation, with help from its SurfaceManager:::srcMgr->SurfaceManager->getManager->srcData->srcMgr->getPrimarySurfaceData->if->img->getAccelerationPriority->sdp->srcMgr->getCacheData->if->sdp->isValid->if->srcData->getState->else->makeProxyFor->srcMgr->setCacheData->sdp->replaceData->return
SurfaceData#makeProxyFor(SurfaceData):::This method is called on a destination SurfaceData to choose a proper SurfaceDataProxy subclass for a source SurfaceData to use to control when and with what surface to override a given image operation:::return
SurfaceData#getPrimarySurfaceData(Image):::Extracts the SurfaceManager from the given Image, and then returns the SurfaceData object that would best be suited as the destination surface in some rendering operation.:::sMgr->SurfaceManager->getManager->return->sMgr->getPrimarySurfaceData
SurfaceData#restoreContents(Image):::Restores the contents of the given Image and then returns the new SurfaceData object in use by the Image's SurfaceManager.:::sMgr->SurfaceManager->getManager->return->sMgr->restoreContents
SurfaceData#getState()::: surface data get state:::return->stateDelegate->getState
SurfaceData#getStateTracker()::: surface data get state tracker:::return->stateDelegate->getStateTracker
SurfaceData#markDirty():::Marks this surface as dirty.:::stateDelegate->markDirty
SurfaceData#setSurfaceLost(boolean):::Sets the value of the surfaceLost variable, which indicates whether something has happened to the rendering surface such that it needs to be restored and re-rendered.:::stateDelegate->markDirty
SurfaceData#isSurfaceLost()::: surface data is surface lost:::return
SurfaceData#isValid():::Returns a boolean indicating whether or not this SurfaceData is valid.:::return
SurfaceData#getDisposerReferent()::: surface data get disposer referent:::return
SurfaceData#getNativeOps()::: surface data get native ops:::return
SurfaceData#invalidate():::Sets this SurfaceData object to the invalid state:::stateDelegate->markDirty
SurfaceData#getReplacement():::Certain changes in the configuration of a surface require the invalidation of existing associated SurfaceData objects and the creation of brand new ones:::
SurfaceData#makeConverter(AAShapePipe, ParallelogramPipe)::: surface data make converter:::return->new->PixelToParallelogramConverter
SurfaceData#makeConverter(AAShapePipe)::: surface data make converter:::return->makeConverter
SurfaceData#canRenderLCDText(SunGraphics2D)::: surface data can render text:::if->getTransparency->if->loop->DrawGlyphListLCD->getSurfaceType->locate->return->return
SurfaceData#canRenderParallelograms(SunGraphics2D)::: surface data can render parallelograms:::if->if->if->loop->FillParallelogram->getSurfaceType->locate->return->else->if->if->loop->FillParallelogram->getSurfaceType->locate->return->return
SurfaceData#validatePipe(SunGraphics2D)::: surface data validate pipe:::if->if->else->converter->if->canRenderParallelograms->else->if->else->if->else->if->else->else->if->if->if->else->else->if->else->else->if->getMaskFill->if->if->else->converter->canDoParallelograms->if->else->getTextPipe->else->if->else->else->if->getMaskFill->if->if->else->else->if->else->else->converter->if->canRenderParallelograms->else->if->else->if->else->getTextPipe->if->getRenderLoops
SurfaceData#getTextPipe(SunGraphics2D, boolean)::: surface data get text pipe:::switch->if->return->else->return->return->return->switch->sg2d->getFontInfo->return->return->return->if->return->else->return
SurfaceData#getPaintSurfaceType(SunGraphics2D)::: surface data get paint surface type:::switch->return->return->if->getTransparency->return->else->return->if->getTransparency->return->else->return->if->getTransparency->return->else->return->if->getTransparency->return->else->return->return
SurfaceData#getFillCompositeType(SunGraphics2D)::: surface data get fill composite type:::compType->if->if->else->return
SurfaceData#getMaskFill(SunGraphics2D):::Returns a MaskFill object that can be used on this destination with the source (paint) and composite types determined by the given SunGraphics2D, or null if no such MaskFill object can be located:::src->getPaintSurfaceType->comp->getFillCompositeType->dst->getSurfaceType->return->MaskFill->getFromCache
SurfaceData#getRenderLoops(SunGraphics2D):::Return a RenderLoops object containing all of the basic GraphicsPrimitive objects for rendering to the destination surface with the current attributes of the given SunGraphics2D.:::src->getPaintSurfaceType->comp->getFillCompositeType->dst->sg2d->getSurfaceData->getSurfaceType->o->loopcache->get->if->return->loops->makeRenderLoops->loopcache->put->return
SurfaceData#makeRenderLoops(SurfaceType, CompositeType, SurfaceType):::Construct and return a RenderLoops object containing all of the basic GraphicsPrimitive objects for rendering to the destination surface with the given source, destination, and composite types.:::loops->new->RenderLoops->DrawLine->locate->FillRect->locate->DrawRect->locate->DrawPolygons->locate->DrawPath->locate->FillPath->locate->FillSpans->locate->FillParallelogram->locate->DrawParallelogram->locate->DrawGlyphList->locate->DrawGlyphListAA->locate->DrawGlyphListLCD->locate->return
SurfaceData#getDeviceConfiguration():::Return the GraphicsConfiguration object that describes this destination surface.:::
SurfaceData#getSurfaceType():::Return the SurfaceType object that describes the destination surface.:::return
SurfaceData#getColorModel():::Return the ColorModel for the destination surface.:::return
SurfaceData#getTransparency():::Returns the type of this Transparency.:::return->getColorModel->getTransparency
SurfaceData#getRaster(int, int, int, int):::Return a readable Raster which contains the pixels for the specified rectangular region of the destination surface:::
SurfaceData#useTightBBoxes():::Does the pixel accessibility of the destination surface suggest that rendering algorithms might want to take extra time to calculate a more accurate bounding box for the operation being performed? The typical case when this will be true is when a copy of the pixels has to be made when doing a getRaster:::return
SurfaceData#pixelFor(int):::Returns the pixel data for the specified Argb value packed into an integer for easy storage and conveyance.:::return->surfaceType->pixelFor
SurfaceData#pixelFor(Color):::Returns the pixel data for the specified color packed into an integer for easy storage and conveyance:::return->c->getRGB->pixelFor
SurfaceData#rgbFor(int):::Returns the Argb representation for the specified integer value which is packed in the format of the associated ColorModel.:::return->surfaceType->rgbFor
SurfaceData#getBounds():::Returns the bounds of the destination surface.:::
SurfaceData#checkCustomComposite():::Performs Security Permissions checks to see if a Custom Composite object should be allowed access to the pixels of this surface.:::sm->System->getSecurityManager->if->if->new->java.awt.AWTPermission->sm->checkPermission
SurfaceData#isOpaqueGray(IndexColorModel):::Fetches private field IndexColorModel.allgrayopaque which is true when all palette entries in the color model are gray and opaque.:::
SurfaceData#isNull(SurfaceData):::For our purposes null and NullSurfaceData are the same as they represent a disposed surface.:::if->return->return
SurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int):::Performs a copyarea within this surface:::return
SurfaceData#flush():::Synchronously releases resources associated with this surface.:::
SurfaceData#getDestination():::Returns destination associated with this SurfaceData:::
SurfaceData#getDefaultScaleX():::Returns default horizontal scale factor of the destination surface:::return
SurfaceData#getDefaultScaleY():::Returns default vertical scale factor of the destination surface:::return
SurfaceDataProxy#isCachingAllowed()::: surface data proxy is caching allowed:::return
SurfaceDataProxy#isSupportedOperation(SurfaceData, int, CompositeType, Color):::Determine if an alternate form for the srcData is needed and appropriate from the given operational parameters.:::
SurfaceDataProxy#validateSurfaceData(SurfaceData, SurfaceData, int, int):::Construct an alternate form of the given SurfaceData:::
SurfaceDataProxy#getRetryTracker(SurfaceData):::If the subclass is unable to validate or create a cached SurfaceData then this method will be used to get a StateTracker object that will indicate when to attempt to validate the surface again:::return->new->CountdownTracker
SurfaceDataProxy.CountdownTracker#isCurrent()::: countdown tracker is current:::return
SurfaceDataProxy#isValid():::Returns true iff this SurfaceData proxy is still the best way to control caching of the given source on the given destination.:::return
SurfaceDataProxy#invalidate():::Sets the valid state to false so that the next time this proxy is fetched to generate a replacement SurfaceData, the code in SurfaceData knows to replace the proxy first.:::
SurfaceDataProxy#flush(boolean):::Flush all cached resources as per the FlushableCacheData interface:::if->invalidate->flush->return->isValid
SurfaceDataProxy#flush():::Actively flushes (drops and invalidates) the cached surface so that it can be reclaimed quickly.:::csd->if->csd->flush
SurfaceDataProxy#isAccelerated():::Returns true iff this SurfaceData proxy is still valid and if it has a currently cached replacement that is also valid and current.:::return->isValid->srcTracker->isCurrent->cacheTracker->isCurrent
SurfaceDataProxy#activateDisplayListener():::This method should be called from subclasses which create cached SurfaceData objects that depend on the current properties of the display.:::ge->GraphicsEnvironment->getLocalGraphicsEnvironment->if->addDisplayChangedListener
SurfaceDataProxy#displayChanged():::Invoked when the display mode has changed:::flush
SurfaceDataProxy#paletteChanged():::Invoked when the palette has changed.:::
SurfaceDataProxy#replaceData(SurfaceData, int, CompositeType, Color):::This method attempts to replace the srcData with a cached version:::if->isSupportedOperation->if->srcTracker->isCurrent->synchronized->srcData->getStateTracker->if->srcTracker->isCurrent->if->srcData->getState->invalidate->flush->return->csd->if->cacheTracker->isCurrent->synchronized->if->return->r->srcData->getBounds->w->h->curTracker->validateSurfaceData->if->synchronized->if->getRetryTracker->return->updateSurfaceData->if->csd->isValid->return->synchronized->if->curTracker->isCurrent->csd->getStateTracker->if->return->return
SurfaceDataProxy#updateSurfaceData(SurfaceData, SurfaceData, int, int):::This is the default implementation for updating the cached SurfaceData from the source (primary) SurfaceData:::srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blit->Blit->getFromCache->blit->Blit->dstData->markDirty
SurfaceDataProxy#updateSurfaceDataBg(SurfaceData, SurfaceData, int, int, Color):::This is an alternate implementation for updating the cached SurfaceData from the source (primary) SurfaceData using a background color for transparent pixels:::srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blitbg->BlitBg->getFromCache->blitbg->bgColor->getRGB->BlitBg->dstData->markDirty
SurfaceManagerFactory#getInstance():::Returns the surface manager factory instance:::if->throw->new->IllegalStateException->return
SurfaceManagerFactory#setInstance(SurfaceManagerFactory):::Sets the surface manager factory:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalStateException
SurfaceManagerFactory#createVolatileManager(SunVolatileImage, Object):::Creates a new instance of a VolatileSurfaceManager given any arbitrary SunVolatileImage:::
WindowsSurfaceManagerFactory#createVolatileManager(SunVolatileImage, Object):::Creates a new instance of a VolatileSurfaceManager given any arbitrary SunVolatileImage:::gc->vImg->getGraphicsConfig->if->return->new->D3DVolatileSurfaceManager->else->if->return->new->WGLVolatileSurfaceManager->else->return->new->BufImgVolatileSurfaceManager
