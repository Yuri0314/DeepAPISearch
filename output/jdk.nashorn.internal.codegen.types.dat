jdk.nashorn.internal.codegen.types.ArrayType#getElementType()->Type:::Get the element type of the array elements e.g
jdk.nashorn.internal.codegen.types.ArrayType#astore(MethodVisitor)->void::: array type astore
jdk.nashorn.internal.codegen.types.ArrayType#aload(MethodVisitor)->Type::: array type aload
jdk.nashorn.internal.codegen.types.ArrayType#arraylength(MethodVisitor)->Type::: array type arraylength
jdk.nashorn.internal.codegen.types.ArrayType#newarray(MethodVisitor)->Type::: array type newarray
jdk.nashorn.internal.codegen.types.ArrayType#newarray(MethodVisitor, int)->Type::: array type newarray
jdk.nashorn.internal.codegen.types.ArrayType#load(MethodVisitor, int)->Type::: array type load
jdk.nashorn.internal.codegen.types.ArrayType#toString()->String::: array type to string
jdk.nashorn.internal.codegen.types.ArrayType#convert(MethodVisitor, Type)->Type::: array type convert
jdk.nashorn.internal.codegen.types.BooleanType#nextWider()->Type::: boolean type next wider
jdk.nashorn.internal.codegen.types.BooleanType#getBoxedType()->Class::: boolean type get boxed type
jdk.nashorn.internal.codegen.types.BooleanType#getBytecodeStackType()->char::: boolean type get bytecode stack type
jdk.nashorn.internal.codegen.types.BooleanType#loadUndefined(MethodVisitor)->Type::: boolean type load undefined
jdk.nashorn.internal.codegen.types.BooleanType#loadForcedInitializer(MethodVisitor)->Type::: boolean type load forced initializer
jdk.nashorn.internal.codegen.types.BooleanType#_return(MethodVisitor)->void::: boolean type _return
jdk.nashorn.internal.codegen.types.BooleanType#load(MethodVisitor, int)->Type::: boolean type load
jdk.nashorn.internal.codegen.types.BooleanType#store(MethodVisitor, int)->void::: boolean type store
jdk.nashorn.internal.codegen.types.BooleanType#ldc(MethodVisitor, Object)->Type::: boolean type ldc
jdk.nashorn.internal.codegen.types.BooleanType#convert(MethodVisitor, Type)->Type::: boolean type convert
jdk.nashorn.internal.codegen.types.BooleanType#add(MethodVisitor, int)->Type::: boolean type add
jdk.nashorn.internal.codegen.types.BytecodeArrayOps#aload(MethodVisitor)->Type:::Load an array element given that the array and its index are already on the stack
jdk.nashorn.internal.codegen.types.BytecodeArrayOps#astore(MethodVisitor)->void:::Store an array element given that the array and its index and the element are on the stack
jdk.nashorn.internal.codegen.types.BytecodeArrayOps#arraylength(MethodVisitor)->Type:::Generate an array length operation
jdk.nashorn.internal.codegen.types.BytecodeArrayOps#newarray(MethodVisitor)->Type:::Create a new array of this array type and length on stack
jdk.nashorn.internal.codegen.types.BytecodeArrayOps#newarray(MethodVisitor, int)->Type:::Create a new multi array of this array type and allocate the number of dimensions given
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#shr(MethodVisitor)->Type:::Pop and logically shift the two values on top of the stack (steps, value) right and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#sar(MethodVisitor)->Type:::Pop and arithmetically shift of the two values on top of the stack (steps, value) right and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#shl(MethodVisitor)->Type:::Pop and logically shift of the two values on top of the stack (steps, value) left and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#and(MethodVisitor)->Type:::Pop and AND the two values on top of the stack and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#or(MethodVisitor)->Type:::Pop and OR the two values on top of the stack and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#xor(MethodVisitor)->Type:::Pop and XOR the two values on top of the stack and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeBitwiseOps#cmp(MethodVisitor)->Type:::Comparison with int return value, e.g
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#neg(MethodVisitor, int)->Type:::Pop and negate the value on top of the stack and push the result
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#sub(MethodVisitor, int)->Type:::Pop two values on top of the stack and subtract the first from the second, pushing the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#mul(MethodVisitor, int)->Type:::Pop and multiply the two values on top of the stack and push the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#div(MethodVisitor, int)->Type:::Pop two values on top of the stack and divide the first with the second, pushing the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#rem(MethodVisitor, int)->Type:::Pop two values on top of the stack and compute the modulo of the first with the second, pushing the result on the stack  Note that the rem method never takes a program point, because it can never be more optimistic than its widest operand - an int/int rem operation or a long/long rem operation can never return a winder remainder than the int or the long
jdk.nashorn.internal.codegen.types.BytecodeNumericOps#cmp(MethodVisitor, boolean)->Type:::Comparison with int return value, e.g
jdk.nashorn.internal.codegen.types.BytecodeOps#dup(MethodVisitor, int)->Type:::Duplicate top entry of stack
jdk.nashorn.internal.codegen.types.BytecodeOps#pop(MethodVisitor)->Type:::Pop an entry of this type from the top of the bytecode stack
jdk.nashorn.internal.codegen.types.BytecodeOps#swap(MethodVisitor, Type)->Type:::Swap this type with the bytecode stack with the one below Generate appropriate code no matter the categories of the two types
jdk.nashorn.internal.codegen.types.BytecodeOps#add(MethodVisitor, int)->Type:::Pop two values on top of the stack and add the first to the second, pushing the result on the stack
jdk.nashorn.internal.codegen.types.BytecodeOps#load(MethodVisitor, int)->Type:::Load a variable from a local slot to the stack
jdk.nashorn.internal.codegen.types.BytecodeOps#store(MethodVisitor, int)->void:::Store a variable from the stack to a local slot
jdk.nashorn.internal.codegen.types.BytecodeOps#ldc(MethodVisitor, Object)->Type:::Load a constant to the stack.
jdk.nashorn.internal.codegen.types.BytecodeOps#loadUndefined(MethodVisitor)->Type:::Load the "undefined" value to the stack
jdk.nashorn.internal.codegen.types.BytecodeOps#loadForcedInitializer(MethodVisitor)->Type:::Load the "forced initializer" value to the stack, used to ensure that a local variable has a value when it is read by the unwarranted optimism catch block.
jdk.nashorn.internal.codegen.types.BytecodeOps#loadEmpty(MethodVisitor)->Type:::Load the "empty" value to the stack.
jdk.nashorn.internal.codegen.types.BytecodeOps#convert(MethodVisitor, Type)->Type:::Generate code that pops and casts the element on top of the stack to another type, given as parameter
jdk.nashorn.internal.codegen.types.BytecodeOps#_return(MethodVisitor)->void:::Return the parameter on top of the stack from a method
jdk.nashorn.internal.codegen.types.IntType#nextWider()->Type::: int type next wider
jdk.nashorn.internal.codegen.types.IntType#getBoxedType()->Class::: int type get boxed type
jdk.nashorn.internal.codegen.types.IntType#getBytecodeStackType()->char::: int type get bytecode stack type
jdk.nashorn.internal.codegen.types.IntType#ldc(MethodVisitor, Object)->Type::: int type ldc
jdk.nashorn.internal.codegen.types.IntType#convert(MethodVisitor, Type)->Type::: int type convert
jdk.nashorn.internal.codegen.types.IntType#add(MethodVisitor, int)->Type::: int type add
jdk.nashorn.internal.codegen.types.IntType#shr(MethodVisitor)->Type::: int type shr
jdk.nashorn.internal.codegen.types.IntType#sar(MethodVisitor)->Type::: int type sar
jdk.nashorn.internal.codegen.types.IntType#shl(MethodVisitor)->Type::: int type shl
jdk.nashorn.internal.codegen.types.IntType#and(MethodVisitor)->Type::: int type and
jdk.nashorn.internal.codegen.types.IntType#or(MethodVisitor)->Type::: int type or
jdk.nashorn.internal.codegen.types.IntType#xor(MethodVisitor)->Type::: int type xor
jdk.nashorn.internal.codegen.types.IntType#load(MethodVisitor, int)->Type::: int type load
jdk.nashorn.internal.codegen.types.IntType#store(MethodVisitor, int)->void::: int type store
jdk.nashorn.internal.codegen.types.IntType#sub(MethodVisitor, int)->Type::: int type sub
jdk.nashorn.internal.codegen.types.IntType#mul(MethodVisitor, int)->Type::: int type mul
jdk.nashorn.internal.codegen.types.IntType#div(MethodVisitor, int)->Type::: int type div
jdk.nashorn.internal.codegen.types.IntType#rem(MethodVisitor, int)->Type::: int type rem
jdk.nashorn.internal.codegen.types.IntType#neg(MethodVisitor, int)->Type::: int type neg
jdk.nashorn.internal.codegen.types.IntType#_return(MethodVisitor)->void::: int type _return
jdk.nashorn.internal.codegen.types.IntType#loadUndefined(MethodVisitor)->Type::: int type load undefined
jdk.nashorn.internal.codegen.types.IntType#loadForcedInitializer(MethodVisitor)->Type::: int type load forced initializer
jdk.nashorn.internal.codegen.types.IntType#cmp(MethodVisitor, boolean)->Type::: int type cmp
jdk.nashorn.internal.codegen.types.IntType#cmp(MethodVisitor)->Type::: int type cmp
jdk.nashorn.internal.codegen.types.LongType#nextWider()->Type::: long type next wider
jdk.nashorn.internal.codegen.types.LongType#getBoxedType()->Class::: long type get boxed type
jdk.nashorn.internal.codegen.types.LongType#getBytecodeStackType()->char::: long type get bytecode stack type
jdk.nashorn.internal.codegen.types.LongType#load(MethodVisitor, int)->Type::: long type load
jdk.nashorn.internal.codegen.types.LongType#store(MethodVisitor, int)->void::: long type store
jdk.nashorn.internal.codegen.types.LongType#ldc(MethodVisitor, Object)->Type::: long type ldc
jdk.nashorn.internal.codegen.types.LongType#convert(MethodVisitor, Type)->Type::: long type convert
jdk.nashorn.internal.codegen.types.LongType#add(MethodVisitor, int)->Type::: long type add
jdk.nashorn.internal.codegen.types.LongType#_return(MethodVisitor)->void::: long type _return
jdk.nashorn.internal.codegen.types.LongType#loadUndefined(MethodVisitor)->Type::: long type load undefined
jdk.nashorn.internal.codegen.types.LongType#loadForcedInitializer(MethodVisitor)->Type::: long type load forced initializer
jdk.nashorn.internal.codegen.types.NumberType#nextWider()->Type::: number type next wider
jdk.nashorn.internal.codegen.types.NumberType#getBoxedType()->Class::: number type get boxed type
jdk.nashorn.internal.codegen.types.NumberType#getBytecodeStackType()->char::: number type get bytecode stack type
jdk.nashorn.internal.codegen.types.NumberType#cmp(MethodVisitor, boolean)->Type::: number type cmp
jdk.nashorn.internal.codegen.types.NumberType#load(MethodVisitor, int)->Type::: number type load
jdk.nashorn.internal.codegen.types.NumberType#store(MethodVisitor, int)->void::: number type store
jdk.nashorn.internal.codegen.types.NumberType#loadUndefined(MethodVisitor)->Type::: number type load undefined
jdk.nashorn.internal.codegen.types.NumberType#loadForcedInitializer(MethodVisitor)->Type::: number type load forced initializer
jdk.nashorn.internal.codegen.types.NumberType#ldc(MethodVisitor, Object)->Type::: number type ldc
jdk.nashorn.internal.codegen.types.NumberType#convert(MethodVisitor, Type)->Type::: number type convert
jdk.nashorn.internal.codegen.types.NumberType#add(MethodVisitor, int)->Type::: number type add
jdk.nashorn.internal.codegen.types.NumberType#sub(MethodVisitor, int)->Type::: number type sub
jdk.nashorn.internal.codegen.types.NumberType#mul(MethodVisitor, int)->Type::: number type mul
jdk.nashorn.internal.codegen.types.NumberType#div(MethodVisitor, int)->Type::: number type div
jdk.nashorn.internal.codegen.types.NumberType#rem(MethodVisitor, int)->Type::: number type rem
jdk.nashorn.internal.codegen.types.NumberType#neg(MethodVisitor, int)->Type::: number type neg
jdk.nashorn.internal.codegen.types.NumberType#_return(MethodVisitor)->void::: number type _return
jdk.nashorn.internal.codegen.types.ObjectType#toString()->String::: object type to string
jdk.nashorn.internal.codegen.types.ObjectType#getShortDescriptor()->String::: object type get short descriptor
jdk.nashorn.internal.codegen.types.ObjectType#add(MethodVisitor, int)->Type::: object type add
jdk.nashorn.internal.codegen.types.ObjectType#load(MethodVisitor, int)->Type::: object type load
jdk.nashorn.internal.codegen.types.ObjectType#store(MethodVisitor, int)->void::: object type store
jdk.nashorn.internal.codegen.types.ObjectType#loadUndefined(MethodVisitor)->Type::: object type load undefined
jdk.nashorn.internal.codegen.types.ObjectType#loadForcedInitializer(MethodVisitor)->Type::: object type load forced initializer
jdk.nashorn.internal.codegen.types.ObjectType#loadEmpty(MethodVisitor)->Type::: object type load empty
jdk.nashorn.internal.codegen.types.ObjectType#ldc(MethodVisitor, Object)->Type::: object type ldc
jdk.nashorn.internal.codegen.types.ObjectType#convert(MethodVisitor, Type)->Type::: object type convert
jdk.nashorn.internal.codegen.types.ObjectType#_return(MethodVisitor)->void::: object type _return
jdk.nashorn.internal.codegen.types.ObjectType#getBytecodeStackType()->char::: object type get bytecode stack type
jdk.nashorn.internal.codegen.types.Type#getWeight()->int:::Get the weight of this type - use this e.g
jdk.nashorn.internal.codegen.types.Type#getTypeClass()->Class:::Get the Class representing this type
jdk.nashorn.internal.codegen.types.Type#nextWider()->Type:::For specialization, return the next, slightly more difficulty, type to test.
jdk.nashorn.internal.codegen.types.Type#getBoxedType()->Class:::Get the boxed type for this class
jdk.nashorn.internal.codegen.types.Type#getBytecodeStackType()->char:::Returns the character describing the bytecode type for this value on the stack or local variable, identical to what would be used as the prefix for a bytecode LOAD or STORE instruction, therefore it must be one of A, F, D, I, L
jdk.nashorn.internal.codegen.types.Type#getMethodDescriptor(Type, Type...)->String:::Generate a method descriptor given a return type and a param array
jdk.nashorn.internal.codegen.types.Type#getMethodDescriptor(Class, Class...)->String:::Generate a method descriptor given a return type and a param array
jdk.nashorn.internal.codegen.types.Type#getShortSignatureDescriptor(Type)->char:::Return a character representing type in a method signature.
jdk.nashorn.internal.codegen.types.Type#getMethodReturnType(String)->Type:::Get the return type for a method
jdk.nashorn.internal.codegen.types.Type#getMethodArguments(String)->Type[]:::Get type array representing arguments of a method in order
jdk.nashorn.internal.codegen.types.Type#writeTypeMap(Map, DataOutput)->void:::Write a map of int to Type to an output stream
jdk.nashorn.internal.codegen.types.Type#readTypeMap(DataInput)->Map:::Read a map of int to Type from an input stream
jdk.nashorn.internal.codegen.types.Type#getInternalType(String)->jdk.internal.org.objectweb.asm.Type::: type get internal type
jdk.nashorn.internal.codegen.types.Type#invokestatic(MethodVisitor, Call)->void::: type invokestatic
jdk.nashorn.internal.codegen.types.Type#getInternalName()->String:::Get the internal JVM name of a type
jdk.nashorn.internal.codegen.types.Type#getInternalName(Class)->String:::Get the internal JVM name of type type represented by a given Java class
jdk.nashorn.internal.codegen.types.Type#isUnknown()->boolean:::Determines whether a type is the UNKNOWN type, i.e
jdk.nashorn.internal.codegen.types.Type#isJSPrimitive()->boolean:::Determines whether this type represents an primitive type according to the ECMAScript specification, which includes Boolean, Number, and String.
jdk.nashorn.internal.codegen.types.Type#isBoolean()->boolean:::Determines whether a type is the BOOLEAN type
jdk.nashorn.internal.codegen.types.Type#isInteger()->boolean:::Determines whether a type is the INT type
jdk.nashorn.internal.codegen.types.Type#isLong()->boolean:::Determines whether a type is the LONG type
jdk.nashorn.internal.codegen.types.Type#isNumber()->boolean:::Determines whether a type is the NUMBER type
jdk.nashorn.internal.codegen.types.Type#isNumeric()->boolean:::Determines whether a type is numeric, i.e
jdk.nashorn.internal.codegen.types.Type#isArray()->boolean:::Determines whether a type is an array type, i.e
jdk.nashorn.internal.codegen.types.Type#isCategory2()->boolean:::Determines if a type takes up two bytecode slots or not
jdk.nashorn.internal.codegen.types.Type#isObject()->boolean:::Determines whether a type is an OBJECT type, e.g
jdk.nashorn.internal.codegen.types.Type#isPrimitive()->boolean:::Is this a primitive type (e.g int, long, double, boolean)
jdk.nashorn.internal.codegen.types.Type#isString()->boolean:::Determines whether a type is a STRING type
jdk.nashorn.internal.codegen.types.Type#isCharSequence()->boolean:::Determines whether a type is a CHARSEQUENCE type used internally strings
jdk.nashorn.internal.codegen.types.Type#isEquivalentTo(Type)->boolean:::Determine if two types are equivalent, i.e
jdk.nashorn.internal.codegen.types.Type#isAssignableFrom(Type, Type)->boolean:::Determine if a type can be assigned to from another
jdk.nashorn.internal.codegen.types.Type#isAssignableFrom(Type)->boolean:::Determine if this type is assignable from another type
jdk.nashorn.internal.codegen.types.Type#areEquivalent(Type, Type)->boolean:::Determines is this type is equivalent to another, i.e
jdk.nashorn.internal.codegen.types.Type#getSlots()->int:::Determine the number of bytecode slots a type takes up
jdk.nashorn.internal.codegen.types.Type#widest(Type, Type)->Type:::Returns the widest or most common of two types
jdk.nashorn.internal.codegen.types.Type#widest(Class, Class)->Class:::Returns the widest or most common of two types, given as classes
jdk.nashorn.internal.codegen.types.Type#widestReturnType(Type, Type)->Type:::When doing widening for return types of a function or a ternary operator, it is not valid to widen a boolean to anything other than object
jdk.nashorn.internal.codegen.types.Type#generic(Type)->Type:::Returns a generic version of the type
jdk.nashorn.internal.codegen.types.Type#narrowest(Type, Type)->Type:::Returns the narrowest or least common of two types
jdk.nashorn.internal.codegen.types.Type#narrowerThan(Type)->boolean:::Check whether this type is strictly narrower than another one
jdk.nashorn.internal.codegen.types.Type#widerThan(Type)->boolean:::Check whether this type is strictly wider than another one
jdk.nashorn.internal.codegen.types.Type#widest(Type, Type, Type)->Type:::Returns the widest or most common of two types, but no wider than "limit"
jdk.nashorn.internal.codegen.types.Type#narrowest(Type, Type, Type)->Type:::Returns the widest or most common of two types, but no narrower than "limit"
jdk.nashorn.internal.codegen.types.Type#narrowest(Type)->Type:::Returns the narrowest of this type and another
jdk.nashorn.internal.codegen.types.Type#widest(Type)->Type:::Returns the widest of this type and another
jdk.nashorn.internal.codegen.types.Type#weight()->int:::Returns the weight of a type, used for type comparison between wider and narrower types
jdk.nashorn.internal.codegen.types.Type#getDescriptor()->String:::Return the descriptor of a type, used for e.g
jdk.nashorn.internal.codegen.types.Type#getShortDescriptor()->String:::Return the descriptor of a type, short version Used mainly for debugging purposes
jdk.nashorn.internal.codegen.types.Type#toString()->String::: type to string
jdk.nashorn.internal.codegen.types.Type#typeFor(Class)->Type:::Return the (possibly cached) Type object for this class
jdk.nashorn.internal.codegen.types.Type#compareTo(Type)->int::: type compare to
jdk.nashorn.internal.codegen.types.Type#dup(MethodVisitor, int)->Type:::Common logic for implementing dup for all types
jdk.nashorn.internal.codegen.types.Type#swap(MethodVisitor, Type)->Type:::Common logic for implementing swap for all types
jdk.nashorn.internal.codegen.types.Type#pop(MethodVisitor)->Type:::Common logic for implementing pop for all types
jdk.nashorn.internal.codegen.types.Type#loadEmpty(MethodVisitor)->Type::: type load empty
jdk.nashorn.internal.codegen.types.Type#pop(MethodVisitor, Type)->void:::Superclass logic for pop for all types
jdk.nashorn.internal.codegen.types.Type#readResolve()->Object:::Read resolve
