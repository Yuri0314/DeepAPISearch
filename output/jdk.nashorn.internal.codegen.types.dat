ArrayType#getElementType():::Get the element type of the array elements e.g:::return->Type->getTypeClass->getComponentType->typeFor
BytecodeArrayOps#aload(MethodVisitor):::Load an array element given that the array and its index are already on the stack:::
BytecodeArrayOps#astore(MethodVisitor):::Store an array element given that the array and its index and the element are on the stack:::
BytecodeArrayOps#arraylength(MethodVisitor):::Generate an array length operation:::
BytecodeArrayOps#newarray(MethodVisitor):::Create a new array of this array type and length on stack:::
BytecodeArrayOps#newarray(MethodVisitor, int):::Create a new multi array of this array type and allocate the number of dimensions given:::
BytecodeBitwiseOps#shr(MethodVisitor):::Pop and logically shift the two values on top of the stack (steps, value) right and push the result on the stack:::
BytecodeBitwiseOps#sar(MethodVisitor):::Pop and arithmetically shift of the two values on top of the stack (steps, value) right and push the result on the stack:::
BytecodeBitwiseOps#shl(MethodVisitor):::Pop and logically shift of the two values on top of the stack (steps, value) left and push the result on the stack:::
BytecodeBitwiseOps#and(MethodVisitor):::Pop and AND the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#or(MethodVisitor):::Pop and OR the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#xor(MethodVisitor):::Pop and XOR the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#cmp(MethodVisitor):::Comparison with int return value, e.g:::
BytecodeNumericOps#neg(MethodVisitor, int):::Pop and negate the value on top of the stack and push the result:::
BytecodeNumericOps#sub(MethodVisitor, int):::Pop two values on top of the stack and subtract the first from the second, pushing the result on the stack:::
BytecodeNumericOps#mul(MethodVisitor, int):::Pop and multiply the two values on top of the stack and push the result on the stack:::
BytecodeNumericOps#div(MethodVisitor, int):::Pop two values on top of the stack and divide the first with the second, pushing the result on the stack:::
BytecodeNumericOps#rem(MethodVisitor, int):::Pop two values on top of the stack and compute the modulo of the first with the second, pushing the result on the stack  Note that the rem method never takes a program point, because it can never be more optimistic than its widest operand - an int/int rem operation or a long/long rem operation can never return a winder remainder than the int or the long:::
BytecodeNumericOps#cmp(MethodVisitor, boolean):::Comparison with int return value, e.g:::
BytecodeOps#dup(MethodVisitor, int):::Duplicate top entry of stack:::
BytecodeOps#pop(MethodVisitor):::Pop an entry of this type from the top of the bytecode stack:::
BytecodeOps#swap(MethodVisitor, Type):::Swap this type with the bytecode stack with the one below Generate appropriate code no matter the categories of the two types:::
BytecodeOps#add(MethodVisitor, int):::Pop two values on top of the stack and add the first to the second, pushing the result on the stack:::
BytecodeOps#load(MethodVisitor, int):::Load a variable from a local slot to the stack:::
BytecodeOps#store(MethodVisitor, int):::Store a variable from the stack to a local slot:::
BytecodeOps#ldc(MethodVisitor, Object):::Load a constant to the stack.:::
BytecodeOps#loadUndefined(MethodVisitor):::Load the "undefined" value to the stack:::
BytecodeOps#loadForcedInitializer(MethodVisitor):::Load the "forced initializer" value to the stack, used to ensure that a local variable has a value when it is read by the unwarranted optimism catch block.:::
BytecodeOps#loadEmpty(MethodVisitor):::Load the "empty" value to the stack.:::
BytecodeOps#convert(MethodVisitor, Type):::Generate code that pops and casts the element on top of the stack to another type, given as parameter:::
BytecodeOps#_return(MethodVisitor):::Return the parameter on top of the stack from a method:::
Type#getWeight():::Get the weight of this type - use this e.g:::return
Type#getTypeClass():::Get the Class representing this type:::return
Type#nextWider():::For specialization, return the next, slightly more difficulty, type to test.:::return
Type#getBoxedType():::Get the boxed type for this class:::return
Type#getBytecodeStackType():::Returns the character describing the bytecode type for this value on the stack or local variable, identical to what would be used as the prefix for a bytecode LOAD or STORE instruction, therefore it must be one of A, F, D, I, L:::
Type#getMethodDescriptor(Type, Type...):::Generate a method descriptor given a return type and a param array:::itypes->new->jdk.internal.org.objectweb.asm.TypeArr->for->i->return->returnType->getInternalType->getMethodDescriptor
Type#getMethodDescriptor(Class, Class...):::Generate a method descriptor given a return type and a param array:::itypes->new->jdk.internal.org.objectweb.asm.TypeArr->for->i->return->getInternalType->getMethodDescriptor
Type#getShortSignatureDescriptor(Type):::Return a character representing type in a method signature.:::if->return->return->type->getBytecodeStackType
Type#getMethodReturnType(String):::Get the return type for a method:::return->Type->getReturnType->typeFor
Type#getMethodArguments(String):::Get type array representing arguments of a method in order:::itypes->getArgumentTypes->types->new->TypeArr->for->i->return
Type#writeTypeMap(Map, DataOutput):::Write a map of int to Type to an output stream:::if->output->writeInt->else->output->typeMap->size->writeInt->foreach->typeMap->entrySet->output->e->getKey->writeInt->typeChar->type->e->getValue->if->else->if->else->if->else->throw->new->AssertionError->output->writeByte
Type#readTypeMap(DataInput):::Read a map of int to Type from an input stream:::size->input->readInt->if->return->map->new->TreeMap<>->for->i->return
Type#getInternalName():::Get the internal JVM name of a type:::return->getTypeClass->getInternalName
Type#getInternalName(Class):::Get the internal JVM name of type type represented by a given Java class:::return->getInternalName
Type#isUnknown():::Determines whether a type is the UNKNOWN type, i.e:::return->this->equals
Type#isJSPrimitive():::Determines whether this type represents an primitive type according to the ECMAScript specification, which includes Boolean, Number, and String.:::return->isObject->isString
Type#isBoolean():::Determines whether a type is the BOOLEAN type:::return->this->equals
Type#isInteger():::Determines whether a type is the INT type:::return->this->equals
Type#isLong():::Determines whether a type is the LONG type:::return->this->equals
Type#isNumber():::Determines whether a type is the NUMBER type:::return->this->equals
Type#isNumeric():::Determines whether a type is numeric, i.e:::return
Type#isArray():::Determines whether a type is an array type, i.e:::return
Type#isCategory2():::Determines if a type takes up two bytecode slots or not:::return->getSlots
Type#isObject():::Determines whether a type is an OBJECT type, e.g:::return
Type#isPrimitive():::Is this a primitive type (e.g int, long, double, boolean):::return->isObject
Type#isString():::Determines whether a type is a STRING type:::return->this->equals
Type#isCharSequence():::Determines whether a type is a CHARSEQUENCE type used internally strings:::return->this->equals
Type#isEquivalentTo(Type):::Determine if two types are equivalent, i.e:::return->this->weight->type->weight->isObject->type->isObject
Type#isAssignableFrom(Type, Type):::Determine if a type can be assigned to from another:::if->type0->isObject->type1->isObject->return->type0->weight->type1->weight->return->type0->weight->type1->weight
Type#isAssignableFrom(Type):::Determine if this type is assignable from another type:::return->Type->isAssignableFrom
Type#areEquivalent(Type, Type):::Determines is this type is equivalent to another, i.e:::return->type0->isEquivalentTo
Type#getSlots():::Determine the number of bytecode slots a type takes up:::return
Type#widest(Type, Type):::Returns the widest or most common of two types:::if->type0->isArray->type1->isArray->return->getElementType->getElementType->else->if->type0->isArray->type1->isArray->return->else->if->type0->isObject->type1->isObject->type0->getTypeClass->type1->getTypeClass->return->return->type0->weight->type1->weight
Type#widest(Class, Class):::Returns the widest or most common of two types, given as classes:::return->Type->typeFor->Type->typeFor->widest->getTypeClass
Type#widestReturnType(Type, Type):::When doing widening for return types of a function or a ternary operator, it is not valid to widen a boolean to anything other than object:::if->t1->isUnknown->return->else->if->t2->isUnknown->return->else->if->t1->isBoolean->t2->isBoolean->t1->isNumeric->t2->isNumeric->return->return->Type->widest
Type#generic(Type):::Returns a generic version of the type:::return->type->isObject
Type#narrowest(Type, Type):::Returns the narrowest or least common of two types:::return->type0->narrowerThan
Type#narrowerThan(Type):::Check whether this type is strictly narrower than another one:::return->weight->type->weight
Type#widerThan(Type):::Check whether this type is strictly wider than another one:::return->weight->type->weight
Type#widest(Type, Type, Type):::Returns the widest or most common of two types, but no wider than "limit":::type->Type->widest->if->type->weight->limit->weight->return->return
Type#narrowest(Type, Type, Type):::Returns the widest or most common of two types, but no narrower than "limit":::type->type0->weight->type1->weight->if->type->weight->limit->weight->return->return
Type#narrowest(Type):::Returns the narrowest of this type and another:::return->Type->narrowest
Type#widest(Type):::Returns the widest of this type and another:::return->Type->widest
Type#weight():::Returns the weight of a type, used for type comparison between wider and narrower types:::return
Type#getDescriptor():::Return the descriptor of a type, used for e.g:::return
Type#getShortDescriptor():::Return the descriptor of a type, short version Used mainly for debugging purposes:::return
Type#typeFor(Class):::Return the (possibly cached) Type object for this class:::return->cache->return->keyClass->isArray->new->ArrayType->new->ObjectType->computeIfAbsent
Type#dup(MethodVisitor, int):::Common logic for implementing dup for all types:::return->Type->dup
Type#swap(MethodVisitor, Type):::Common logic for implementing swap for all types:::Type->swap->return
Type#pop(MethodVisitor):::Common logic for implementing pop for all types:::Type->pop->return
Type#pop(MethodVisitor, Type):::Superclass logic for pop for all types:::method->type->isCategory2->visitInsn
Type#readResolve():::Read resolve:::return->Type->typeFor
