ArrayType#getElementType():::Get the element type of the array elements e.g:::return->Type->getTypeClass->getComponentType->typeFor
ArrayType#astore(MethodVisitor)::: array type astore:::method->visitInsn
ArrayType#aload(MethodVisitor)::: array type aload:::method->visitInsn->return->getElementType
ArrayType#arraylength(MethodVisitor)::: array type arraylength:::method->visitInsn->return
ArrayType#newarray(MethodVisitor)::: array type newarray:::method->getElementType->getInternalName->visitTypeInsn->return
ArrayType#newarray(MethodVisitor, int)::: array type newarray:::method->getInternalName->visitMultiANewArrayInsn->return
ArrayType#load(MethodVisitor, int)::: array type load:::method->visitVarInsn->return
ArrayType#toString()::: array type to string:::return->getElementType->getTypeClass->getSimpleName
ArrayType#convert(MethodVisitor, Type)::: array type convert:::return
BooleanType#nextWider()::: boolean type next wider:::return
BooleanType#getBoxedType()::: boolean type get boxed type:::return
BooleanType#getBytecodeStackType()::: boolean type get bytecode stack type:::return
BooleanType#loadUndefined(MethodVisitor)::: boolean type load undefined:::method->visitLdcInsn->return
BooleanType#loadForcedInitializer(MethodVisitor)::: boolean type load forced initializer:::method->visitInsn->return
BooleanType#_return(MethodVisitor)::: boolean type _return:::method->visitInsn
BooleanType#load(MethodVisitor, int)::: boolean type load:::method->visitVarInsn->return
BooleanType#store(MethodVisitor, int)::: boolean type store:::method->visitVarInsn
BooleanType#ldc(MethodVisitor, Object)::: boolean type ldc:::method->visitInsn->return
BooleanType#convert(MethodVisitor, Type)::: boolean type convert:::if->isEquivalentTo->return->if->to->isNumber->method->visitInsn->else->if->to->isLong->method->visitInsn->else->if->to->isInteger->else->if->to->isString->invokestatic->else->if->to->isObject->invokestatic->else->throw->new->UnsupportedOperationException->return
BooleanType#add(MethodVisitor, int)::: boolean type add:::return->add
BytecodeArrayOps#aload(MethodVisitor):::Load an array element given that the array and its index are already on the stack:::
BytecodeArrayOps#astore(MethodVisitor):::Store an array element given that the array and its index and the element are on the stack:::
BytecodeArrayOps#arraylength(MethodVisitor):::Generate an array length operation:::
BytecodeArrayOps#newarray(MethodVisitor):::Create a new array of this array type and length on stack:::
BytecodeArrayOps#newarray(MethodVisitor, int):::Create a new multi array of this array type and allocate the number of dimensions given:::
BytecodeBitwiseOps#shr(MethodVisitor):::Pop and logically shift the two values on top of the stack (steps, value) right and push the result on the stack:::
BytecodeBitwiseOps#sar(MethodVisitor):::Pop and arithmetically shift of the two values on top of the stack (steps, value) right and push the result on the stack:::
BytecodeBitwiseOps#shl(MethodVisitor):::Pop and logically shift of the two values on top of the stack (steps, value) left and push the result on the stack:::
BytecodeBitwiseOps#and(MethodVisitor):::Pop and AND the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#or(MethodVisitor):::Pop and OR the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#xor(MethodVisitor):::Pop and XOR the two values on top of the stack and push the result on the stack:::
BytecodeBitwiseOps#cmp(MethodVisitor):::Comparison with int return value, e.g:::
BytecodeNumericOps#neg(MethodVisitor, int):::Pop and negate the value on top of the stack and push the result:::
BytecodeNumericOps#sub(MethodVisitor, int):::Pop two values on top of the stack and subtract the first from the second, pushing the result on the stack:::
BytecodeNumericOps#mul(MethodVisitor, int):::Pop and multiply the two values on top of the stack and push the result on the stack:::
BytecodeNumericOps#div(MethodVisitor, int):::Pop two values on top of the stack and divide the first with the second, pushing the result on the stack:::
BytecodeNumericOps#rem(MethodVisitor, int):::Pop two values on top of the stack and compute the modulo of the first with the second, pushing the result on the stack  Note that the rem method never takes a program point, because it can never be more optimistic than its widest operand - an int/int rem operation or a long/long rem operation can never return a winder remainder than the int or the long:::
BytecodeNumericOps#cmp(MethodVisitor, boolean):::Comparison with int return value, e.g:::
BytecodeOps#dup(MethodVisitor, int):::Duplicate top entry of stack:::
BytecodeOps#pop(MethodVisitor):::Pop an entry of this type from the top of the bytecode stack:::
BytecodeOps#swap(MethodVisitor, Type):::Swap this type with the bytecode stack with the one below Generate appropriate code no matter the categories of the two types:::
BytecodeOps#add(MethodVisitor, int):::Pop two values on top of the stack and add the first to the second, pushing the result on the stack:::
BytecodeOps#load(MethodVisitor, int):::Load a variable from a local slot to the stack:::
BytecodeOps#store(MethodVisitor, int):::Store a variable from the stack to a local slot:::
BytecodeOps#ldc(MethodVisitor, Object):::Load a constant to the stack.:::
BytecodeOps#loadUndefined(MethodVisitor):::Load the "undefined" value to the stack:::
BytecodeOps#loadForcedInitializer(MethodVisitor):::Load the "forced initializer" value to the stack, used to ensure that a local variable has a value when it is read by the unwarranted optimism catch block.:::
BytecodeOps#loadEmpty(MethodVisitor):::Load the "empty" value to the stack.:::
BytecodeOps#convert(MethodVisitor, Type):::Generate code that pops and casts the element on top of the stack to another type, given as parameter:::
BytecodeOps#_return(MethodVisitor):::Return the parameter on top of the stack from a method:::
IntType#nextWider()::: int type next wider:::return
IntType#getBoxedType()::: int type get boxed type:::return
IntType#getBytecodeStackType()::: int type get bytecode stack type:::return
IntType#ldc(MethodVisitor, Object)::: int type ldc:::value->switch->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->if->method->visitIntInsn->else->if->method->visitIntInsn->else->method->visitLdcInsn->break->return
IntType#convert(MethodVisitor, Type)::: int type convert:::if->to->isEquivalentTo->return->if->to->isNumber->method->visitInsn->else->if->to->isLong->method->visitInsn->else->if->to->isBoolean->invokestatic->else->if->to->isString->invokestatic->else->if->to->isObject->invokestatic->else->throw->new->UnsupportedOperationException->return
IntType#add(MethodVisitor, int)::: int type add:::if->method->visitInsn->else->ldc->invoke->return
IntType#shr(MethodVisitor)::: int type shr:::method->visitInsn->return
IntType#sar(MethodVisitor)::: int type sar:::method->visitInsn->return
IntType#shl(MethodVisitor)::: int type shl:::method->visitInsn->return
IntType#and(MethodVisitor)::: int type and:::method->visitInsn->return
IntType#or(MethodVisitor)::: int type or:::method->visitInsn->return
IntType#xor(MethodVisitor)::: int type xor:::method->visitInsn->return
IntType#load(MethodVisitor, int)::: int type load:::method->visitVarInsn->return
IntType#store(MethodVisitor, int)::: int type store:::method->visitVarInsn
IntType#sub(MethodVisitor, int)::: int type sub:::if->method->visitInsn->else->ldc->invoke->return
IntType#mul(MethodVisitor, int)::: int type mul:::if->method->visitInsn->else->ldc->invoke->return
IntType#div(MethodVisitor, int)::: int type div:::if->invoke->else->ldc->invoke->return
IntType#rem(MethodVisitor, int)::: int type rem:::if->invoke->else->ldc->invoke->return
IntType#neg(MethodVisitor, int)::: int type neg:::if->method->visitInsn->else->ldc->invoke->return
IntType#_return(MethodVisitor)::: int type _return:::method->visitInsn
IntType#loadUndefined(MethodVisitor)::: int type load undefined:::method->visitLdcInsn->return
IntType#loadForcedInitializer(MethodVisitor)::: int type load forced initializer:::method->visitInsn->return
IntType#cmp(MethodVisitor, boolean)::: int type cmp:::throw->new->UnsupportedOperationException
IntType#cmp(MethodVisitor)::: int type cmp:::throw->new->UnsupportedOperationException
LongType#nextWider()::: long type next wider:::return
LongType#getBoxedType()::: long type get boxed type:::return
LongType#getBytecodeStackType()::: long type get bytecode stack type:::return
LongType#load(MethodVisitor, int)::: long type load:::method->visitVarInsn->return
LongType#store(MethodVisitor, int)::: long type store:::method->visitVarInsn
LongType#ldc(MethodVisitor, Object)::: long type ldc:::value->if->method->visitInsn->else->if->method->visitInsn->else->method->visitLdcInsn->return
LongType#convert(MethodVisitor, Type)::: long type convert:::if->isEquivalentTo->return->if->to->isNumber->method->visitInsn->else->if->to->isInteger->invokestatic->else->if->to->isBoolean->method->visitInsn->else->if->to->isObject->invokestatic->else->return
LongType#add(MethodVisitor, int)::: long type add:::throw->new->UnsupportedOperationException
LongType#_return(MethodVisitor)::: long type _return:::method->visitInsn
LongType#loadUndefined(MethodVisitor)::: long type load undefined:::method->visitLdcInsn->return
LongType#loadForcedInitializer(MethodVisitor)::: long type load forced initializer:::method->visitInsn->return
NumberType#nextWider()::: number type next wider:::return
NumberType#getBoxedType()::: number type get boxed type:::return
NumberType#getBytecodeStackType()::: number type get bytecode stack type:::return
NumberType#cmp(MethodVisitor, boolean)::: number type cmp:::method->visitInsn->return
NumberType#load(MethodVisitor, int)::: number type load:::method->visitVarInsn->return
NumberType#store(MethodVisitor, int)::: number type store:::method->visitVarInsn
NumberType#loadUndefined(MethodVisitor)::: number type load undefined:::method->visitLdcInsn->return
NumberType#loadForcedInitializer(MethodVisitor)::: number type load forced initializer:::method->visitInsn->return
NumberType#ldc(MethodVisitor, Object)::: number type ldc:::value->if->Double->doubleToLongBits->method->visitInsn->else->if->method->visitInsn->else->method->visitLdcInsn->return
NumberType#convert(MethodVisitor, Type)::: number type convert:::if->isEquivalentTo->return->if->to->isInteger->invokestatic->else->if->to->isLong->invokestatic->else->if->to->isBoolean->invokestatic->else->if->to->isString->invokestatic->else->if->to->isObject->invokestatic->else->throw->new->UnsupportedOperationException->return
NumberType#add(MethodVisitor, int)::: number type add:::method->visitInsn->return
NumberType#sub(MethodVisitor, int)::: number type sub:::method->visitInsn->return
NumberType#mul(MethodVisitor, int)::: number type mul:::method->visitInsn->return
NumberType#div(MethodVisitor, int)::: number type div:::method->visitInsn->return
NumberType#rem(MethodVisitor, int)::: number type rem:::method->visitInsn->return
NumberType#neg(MethodVisitor, int)::: number type neg:::method->visitInsn->return
NumberType#_return(MethodVisitor)::: number type _return:::method->visitInsn
ObjectType#toString()::: object type to string:::return->getTypeClass->getTypeClass->getSimpleName
ObjectType#getShortDescriptor()::: object type get short descriptor:::return->getTypeClass->getTypeClass->getSimpleName
ObjectType#add(MethodVisitor, int)::: object type add:::invokestatic->return
ObjectType#load(MethodVisitor, int)::: object type load:::method->visitVarInsn->return
ObjectType#store(MethodVisitor, int)::: object type store:::method->visitVarInsn
ObjectType#loadUndefined(MethodVisitor)::: object type load undefined:::method->className->typeDescriptor->visitFieldInsn->return
ObjectType#loadForcedInitializer(MethodVisitor)::: object type load forced initializer:::method->visitInsn->return
ObjectType#loadEmpty(MethodVisitor)::: object type load empty:::method->className->typeDescriptor->visitFieldInsn->return
ObjectType#ldc(MethodVisitor, Object)::: object type ldc:::if->method->visitInsn->else->if->return->loadUndefined->else->if->method->visitLdcInsn->return->else->if->method->visitLdcInsn->return->Type->typeFor->else->throw->c->getClass->new->UnsupportedOperationException->return
ObjectType#convert(MethodVisitor, Type)::: object type convert:::toString->to->isString->if->if->to->isArray->elemType->getElementType->if->elemType->isString->method->CompilerConstants->className->visitTypeInsn->else->if->elemType->isNumber->method->CompilerConstants->className->visitTypeInsn->else->if->elemType->isLong->method->CompilerConstants->className->visitTypeInsn->else->if->elemType->isInteger->method->CompilerConstants->className->visitTypeInsn->else->method->CompilerConstants->className->visitTypeInsn->return->else->if->to->isObject->toClass->to->getTypeClass->if->toClass->getTypeClass->isAssignableFrom->method->CompilerConstants->className->visitTypeInsn->return->else->if->isString->return->if->to->isInteger->invokestatic->else->if->to->isNumber->invokestatic->else->if->to->isLong->invokestatic->else->if->to->isBoolean->invokestatic->else->if->to->isString->invokestatic->else->if->to->isCharSequence->invokestatic->else->throw->isString->new->UnsupportedOperationException->return
ObjectType#_return(MethodVisitor)::: object type _return:::method->visitInsn
ObjectType#getBytecodeStackType()::: object type get bytecode stack type:::return
Type#getWeight():::Get the weight of this type - use this e.g:::return
Type#getTypeClass():::Get the Class representing this type:::return
Type#nextWider():::For specialization, return the next, slightly more difficulty, type to test.:::return
Type#getBoxedType():::Get the boxed type for this class:::return
Type#getBytecodeStackType():::Returns the character describing the bytecode type for this value on the stack or local variable, identical to what would be used as the prefix for a bytecode LOAD or STORE instruction, therefore it must be one of A, F, D, I, L:::
Type#getMethodDescriptor(Type, Type...):::Generate a method descriptor given a return type and a param array:::itypes->new->jdk.internal.org.objectweb.asm.TypeArr->for->i->return->returnType->getInternalType->getMethodDescriptor
Type#getMethodDescriptor(Class, Class...):::Generate a method descriptor given a return type and a param array:::itypes->new->jdk.internal.org.objectweb.asm.TypeArr->for->i->return->getInternalType->getMethodDescriptor
Type#getShortSignatureDescriptor(Type):::Return a character representing type in a method signature.:::if->return->return->type->getBytecodeStackType
Type#typeFor(jdk.internal.org.objectweb.asm.Type):::Return the type for an internal type, package private - do not use outside code gen:::switch->itype->getSort->return->return->return->return->if->Context->itype->getClassName->isStructureClass->return->return->cacheByName->itype->getClassName->try->return->Type->Class->forName->typeFor->catch->throw->new->AssertionError->finally->computeIfAbsent->return->switch->itype->getElementType->getSort->return->return->return->return->break->return
Type#getMethodReturnType(String):::Get the return type for a method:::return->Type->getReturnType->typeFor
Type#getMethodArguments(String):::Get type array representing arguments of a method in order:::itypes->getArgumentTypes->types->new->TypeArr->for->i->return
Type#writeTypeMap(Map, DataOutput):::Write a map of int to Type to an output stream:::if->output->writeInt->else->output->typeMap->size->writeInt->foreach->typeMap->entrySet->output->e->getKey->writeInt->typeChar->type->e->getValue->if->else->if->else->if->else->throw->new->AssertionError->output->writeByte
Type#readTypeMap(DataInput):::Read a map of int to Type from an input stream:::size->input->readInt->if->return->map->new->TreeMap<>->for->i->return
Type#getInternalType(String)::: type get internal type:::return->getType
Type#getInternalType()::: type get internal type:::return
Type#lookupInternalType(Class)::: type lookup internal type:::c->itype->c->get->if->return->getType->c->put->return
Type#getInternalType(Class)::: type get internal type:::return->lookupInternalType
Type#invokestatic(MethodVisitor, Call)::: type invokestatic:::method->call->className->call->name->call->descriptor->visitMethodInsn
Type#getInternalName():::Get the internal JVM name of a type:::return->getTypeClass->getInternalName
Type#getInternalName(Class):::Get the internal JVM name of type type represented by a given Java class:::return->getInternalName
Type#isUnknown():::Determines whether a type is the UNKNOWN type, i.e:::return->this->equals
Type#isJSPrimitive():::Determines whether this type represents an primitive type according to the ECMAScript specification, which includes Boolean, Number, and String.:::return->isObject->isString
Type#isBoolean():::Determines whether a type is the BOOLEAN type:::return->this->equals
Type#isInteger():::Determines whether a type is the INT type:::return->this->equals
Type#isLong():::Determines whether a type is the LONG type:::return->this->equals
Type#isNumber():::Determines whether a type is the NUMBER type:::return->this->equals
Type#isNumeric():::Determines whether a type is numeric, i.e:::return
Type#isArray():::Determines whether a type is an array type, i.e:::return
Type#isCategory2():::Determines if a type takes up two bytecode slots or not:::return->getSlots
Type#isObject():::Determines whether a type is an OBJECT type, e.g:::return
Type#isPrimitive():::Is this a primitive type (e.g int, long, double, boolean):::return->isObject
Type#isString():::Determines whether a type is a STRING type:::return->this->equals
Type#isCharSequence():::Determines whether a type is a CHARSEQUENCE type used internally strings:::return->this->equals
Type#isEquivalentTo(Type):::Determine if two types are equivalent, i.e:::return->this->weight->type->weight->isObject->type->isObject
Type#isAssignableFrom(Type, Type):::Determine if a type can be assigned to from another:::if->type0->isObject->type1->isObject->return->type0->weight->type1->weight->return->type0->weight->type1->weight
Type#isAssignableFrom(Type):::Determine if this type is assignable from another type:::return->Type->isAssignableFrom
Type#areEquivalent(Type, Type):::Determines is this type is equivalent to another, i.e:::return->type0->isEquivalentTo
Type#getSlots():::Determine the number of bytecode slots a type takes up:::return
Type#widest(Type, Type):::Returns the widest or most common of two types:::if->type0->isArray->type1->isArray->return->getElementType->getElementType->else->if->type0->isArray->type1->isArray->return->else->if->type0->isObject->type1->isObject->type0->getTypeClass->type1->getTypeClass->return->return->type0->weight->type1->weight
Type#widest(Class, Class):::Returns the widest or most common of two types, given as classes:::return->Type->typeFor->Type->typeFor->widest->getTypeClass
Type#widestReturnType(Type, Type):::When doing widening for return types of a function or a ternary operator, it is not valid to widen a boolean to anything other than object:::if->t1->isUnknown->return->else->if->t2->isUnknown->return->else->if->t1->isBoolean->t2->isBoolean->t1->isNumeric->t2->isNumeric->return->return->Type->widest
Type#generic(Type):::Returns a generic version of the type:::return->type->isObject
Type#narrowest(Type, Type):::Returns the narrowest or least common of two types:::return->type0->narrowerThan
Type#narrowerThan(Type):::Check whether this type is strictly narrower than another one:::return->weight->type->weight
Type#widerThan(Type):::Check whether this type is strictly wider than another one:::return->weight->type->weight
Type#widest(Type, Type, Type):::Returns the widest or most common of two types, but no wider than "limit":::type->Type->widest->if->type->weight->limit->weight->return->return
Type#narrowest(Type, Type, Type):::Returns the widest or most common of two types, but no narrower than "limit":::type->type0->weight->type1->weight->if->type->weight->limit->weight->return->return
Type#narrowest(Type):::Returns the narrowest of this type and another:::return->Type->narrowest
Type#widest(Type):::Returns the widest of this type and another:::return->Type->widest
Type#weight():::Returns the weight of a type, used for type comparison between wider and narrower types:::return
Type#getDescriptor():::Return the descriptor of a type, used for e.g:::return
Type#getShortDescriptor():::Return the descriptor of a type, short version Used mainly for debugging purposes:::return
Type#toString()::: type to string:::return
Type#typeFor(Class):::Return the (possibly cached) Type object for this class:::return->cache->return->keyClass->isArray->new->ArrayType->new->ObjectType->computeIfAbsent
Type#compareTo(Type)::: type compare to:::return->o->weight->weight
Type#dup(MethodVisitor, int):::Common logic for implementing dup for all types:::return->Type->dup
Type#swap(MethodVisitor, Type):::Common logic for implementing swap for all types:::Type->swap->return
Type#pop(MethodVisitor):::Common logic for implementing pop for all types:::Type->pop->return
Type#loadEmpty(MethodVisitor)::: type load empty:::return
Type#pop(MethodVisitor, Type):::Superclass logic for pop for all types:::method->type->isCategory2->visitInsn
Type#dup(MethodVisitor, Type, int)::: type dup:::cat2->type->isCategory2->switch->method->visitInsn->break->method->visitInsn->break->method->visitInsn->break->return->return
Type#swap(MethodVisitor, Type, Type)::: type swap:::if->below->isCategory2->if->above->isCategory2->method->visitInsn->method->visitInsn->else->method->visitInsn->method->visitInsn->else->if->above->isCategory2->method->visitInsn->method->visitInsn->else->method->visitInsn
Type.ValueLessType#load(MethodVisitor, int)::: value less type load:::throw->new->UnsupportedOperationException
Type.ValueLessType#store(MethodVisitor, int)::: value less type store:::throw->new->UnsupportedOperationException
Type.ValueLessType#ldc(MethodVisitor, Object)::: value less type ldc:::throw->new->UnsupportedOperationException
Type.ValueLessType#loadUndefined(MethodVisitor)::: value less type load undefined:::throw->new->UnsupportedOperationException
Type.ValueLessType#loadForcedInitializer(MethodVisitor)::: value less type load forced initializer:::throw->new->UnsupportedOperationException
Type.ValueLessType#convert(MethodVisitor, Type)::: value less type convert:::throw->new->UnsupportedOperationException
Type.ValueLessType#_return(MethodVisitor)::: value less type _return:::throw->new->UnsupportedOperationException
Type.ValueLessType#add(MethodVisitor, int)::: value less type add:::throw->new->UnsupportedOperationException
Type#putInCache(T)::: type put in cache:::cache->type->getTypeClass->put->return
Type#readResolve():::Read resolve:::return->Type->typeFor
