Plugin_MemoryAnchorNode_anchor#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ memory anchor node_anchor execute:::node->new->org.graalvm.compiler.nodes.memory.MemoryAnchorNode->b->addPush->return
Plugin_MemoryAnchorNode_anchor#getSource()::: plugin_ memory anchor node_anchor get source:::return
PluginFactory_MemoryAnchorNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ memory anchor node register plugins:::plugins->new->Plugin_MemoryAnchorNode_anchor->register
AbstractWriteNode#stateAfter()::: abstract write node state after:::return
AbstractWriteNode#setStateAfter(FrameState)::: abstract write node set state after:::updateUsages
AbstractWriteNode#hasSideEffect()::: abstract write node has side effect:::return
AbstractWriteNode#value()::: abstract write node value:::return
AbstractWriteNode#isAllowedUsageType(InputType)::: abstract write node is allowed usage type:::return->getNullCheck->super->isAllowedUsageType
AbstractWriteNode#getLastLocationAccess()::: abstract write node get last location access:::return
AbstractWriteNode#setLastLocationAccess(MemoryNode)::: abstract write node set last location access:::newLla->ValueNodeUtil->asNode->updateUsages
AbstractWriteNode#getAccessStamp()::: abstract write node get access stamp:::
Access#getAddress()::: access get address:::
Access#setAddress(AddressNode)::: access set address:::
Access#getLocationIdentity()::: access get location identity:::
Access#canNullCheck()::: access can null check:::
FixedAccessNode#getAddress()::: fixed access node get address:::return
FixedAccessNode#setAddress(AddressNode)::: fixed access node set address:::updateUsages
FixedAccessNode#getLocationIdentity()::: fixed access node get location identity:::return
FixedAccessNode#getNullCheck()::: fixed access node get null check:::return
FixedAccessNode#setNullCheck(boolean)::: fixed access node set null check:::
FixedAccessNode#canDeoptimize()::: fixed access node can deoptimize:::return
FixedAccessNode#getGuard()::: fixed access node get guard:::return
FixedAccessNode#setGuard(GuardingNode)::: fixed access node set guard:::updateUsagesInterface
FixedAccessNode#getBarrierType()::: fixed access node get barrier type:::return
FloatableAccessNode#asFloatingNode()::: floatable access node as floating node:::
FloatableAccessNode#setForceFixed(boolean)::: floatable access node set force fixed:::
FloatableAccessNode#canFloat():::AccessNodes can float only if their location identities are not ANY_LOCATION:::return->getLocationIdentity->isSingle->getBarrierType
FloatingAccessNode#getAddress()::: floating access node get address:::return
FloatingAccessNode#setAddress(AddressNode)::: floating access node set address:::updateUsages
FloatingAccessNode#getLocationIdentity()::: floating access node get location identity:::return
FloatingAccessNode#getBarrierType()::: floating access node get barrier type:::return
FloatingAccessNode#canNullCheck()::: floating access node can null check:::return
FloatingAccessNode#asFixedNode()::: floating access node as fixed node:::
FloatingReadNode#getLastLocationAccess()::: floating read node get last location access:::return
FloatingReadNode#setLastLocationAccess(MemoryNode)::: floating read node set last location access:::ValueNodeUtil->asNode->ValueNodeUtil->asNode->updateUsages
FloatingReadNode#generate(NodeLIRBuilderTool)::: floating read node generate:::readKind->gen->getLIRGeneratorTool->stamp->getLIRKind->gen->gen->getLIRGeneratorTool->getArithmetic->gen->operand->emitLoad->setResult
FloatingReadNode#canonical(CanonicalizerTool)::: floating read node canonical:::result->ReadNode->getAddress->getLocationIdentity->canonicalizeRead->if->return->if->tool->canonicalizeReads->getAddress->hasMoreThanOneUsage->write->if->write->getAddress->getAddress->write->getAccessStamp->getAccessStamp->isCompatible->return->write->value->return
FloatingReadNode#asFixedNode()::: floating read node as fixed node:::try->position->withNodeSourcePosition->result->graph->getAddress->getLocationIdentity->stamp->getBarrierType->new->ReadNode->add->result->getGuard->setGuard->return->catch->finally
FloatingReadNode#verify()::: floating read node verify:::lla->getLastLocationAccess->return->super->verify
FloatingReadNode#getAccessStamp()::: floating read node get access stamp:::return->stamp
HeapAccess#getBarrierType():::Gets the write barrier type for that particular access.:::
LIRLowerableAccess#getAccessStamp()::: lowerable access get access stamp:::
MemoryAccess#getLocationIdentity()::: memory access get location identity:::
MemoryAccess#getLastLocationAccess()::: memory access get last location access:::
MemoryAccess#setLastLocationAccess(MemoryNode)::: memory access set last location access:::
MemoryAnchorNode#generate(NodeLIRBuilderTool)::: memory anchor node generate:::
MemoryAnchorNode#canonical(CanonicalizerTool)::: memory anchor node canonical:::return->tool->allUsagesAvailable->hasNoUsages
MemoryAnchorNode#anchor()::: memory anchor node anchor:::
MemoryCheckpoint.Single#getLocationIdentity():::This method is used to determine which memory location is killed by this node:::
MemoryCheckpoint.Multi#getLocationIdentities():::This method is used to determine which set of memory locations is killed by this node:::
MemoryCheckpoint.TypeAssertion#correctType(Node)::: type assertion correct type:::return
MemoryMap#getLastLocationAccess(LocationIdentity):::Gets the last node that that (potentially) wrote to locationIdentity.:::
MemoryMap#getLocations():::Gets the location identities in the domain of this map.:::
MemoryMapNode#checkOrder(EconomicMap)::: memory map node check order:::for->i->locationIdentities->size->return
MemoryMapNode#isEmpty()::: memory map node is empty:::if->locationIdentities->isEmpty->return->if->locationIdentities->size->if->nodes->get->return->return
MemoryMapNode#getLastLocationAccess(LocationIdentity)::: memory map node get last location access:::if->locationIdentity->isImmutable->return->else->index->locationIdentities->indexOf->if->locationIdentities->any->indexOf->return->nodes->get
MemoryMapNode#getLocations()::: memory map node get locations:::return
MemoryMapNode#toMap()::: memory map node to map:::res->EconomicMap->locationIdentities->size->create->for->i->nodes->size->return
MemoryMapNode#generate(NodeLIRBuilderTool)::: memory map node generate:::
MemoryPhiNode#getLocationIdentity()::: memory phi node get location identity:::return
MemoryPhiNode#values()::: memory phi node values:::return
MemoryPhiNode#valueDescription()::: memory phi node value description:::return->locationIdentity->toString
ReadNode#getLastLocationAccess()::: read node get last location access:::return
ReadNode#setLastLocationAccess(MemoryNode)::: read node set last location access:::ValueNodeUtil->asNode->ValueNodeUtil->asNode->updateUsages
ReadNode#generate(NodeLIRBuilderTool)::: read node generate:::readKind->gen->getLIRGeneratorTool->getAccessStamp->getLIRKind->gen->gen->getLIRGeneratorTool->getArithmetic->gen->operand->gen->state->emitLoad->setResult
ReadNode#canonical(CanonicalizerTool)::: read node canonical:::if->tool->allUsagesAvailable->hasNoUsages->return->if->getNullCheck->return->getAddress->getLocationIdentity->canonicalizeRead->else->return
ReadNode#asFloatingNode()::: read node as floating node:::try->position->withNodeSourcePosition->return->graph->getAddress->getLocationIdentity->stamp->getGuard->getBarrierType->new->FloatingReadNode->unique->catch->finally
ReadNode#isAllowedUsageType(InputType)::: read node is allowed usage type:::return->getNullCheck->super->isAllowedUsageType
ReadNode#canonicalizeRead(ValueNode, AddressNode, LocationIdentity, CanonicalizerTool)::: read node canonicalize read:::view->NodeView->from->metaAccess->tool->getMetaAccess->if->tool->canonicalizeReads->objAddress->object->objAddress->getBase->if->object->isConstant->object->isNullConstant->objAddress->getOffset->isConstant->displacement->objAddress->getOffset->asJavaConstant->asLong->stableDimension->getStableDimension->if->locationIdentity->isImmutable->constant->read->stamp->tool->getConstantReflection->getMemoryAccessProvider->object->asConstant->readConstant->isDefaultStable->locationIdentity->isImmutable->isDefaultStable->if->constant->isDefaultForKind->return->ConstantNode->read->stamp->Math->max->forConstant->if->locationIdentity->equals->length->GraphUtil->tool->getConstantReflection->arrayLength->if->return->if->canonicalize->result->canonicalize->canonicalizeRead->return->return
ReadNode#virtualize(VirtualizerTool)::: read node virtualize:::throw->GraalError->shouldNotReachHere
ReadNode#canNullCheck()::: read node can null check:::return
ReadNode#getAccessStamp()::: read node get access stamp:::return->stamp
WriteNode#generate(NodeLIRBuilderTool)::: write node generate:::writeKind->gen->getLIRGeneratorTool->value->stamp->getLIRKind->gen->getLIRGeneratorTool->getArithmetic->gen->operand->gen->value->operand->gen->state->emitStore
WriteNode#canNullCheck()::: write node can null check:::return
WriteNode#getAccessStamp()::: write node get access stamp:::return->value->stamp
WriteNode#canonical(CanonicalizerTool)::: write node canonical:::if->tool->canonicalizeReads->hasExactlyOneUsage->next->write->next->if->write->getAddress->getAddress->getAccessStamp->write->getAccessStamp->isCompatible->write->getLastLocationAccess->setLastLocationAccess->return->return
