org.graalvm.compiler.core.gen.BytecodeParserTool#storeLocal(int, Value)->void::: bytecode parser tool store local
org.graalvm.compiler.core.gen.DebugInfoBuilder#build(FrameState, LabelRef)->LIRFrameState::: debug info builder build
org.graalvm.compiler.core.gen.DebugInfoBuilder#storageKind(JavaType)->JavaKind::: debug info builder storage kind
org.graalvm.compiler.core.gen.DebugInfoBuilder#newLIRFrameState(LabelRef, BytecodeFrame, VirtualObject[])->LIRFrameState::: debug info builder new frame state
org.graalvm.compiler.core.gen.DebugInfoBuilder#computeFrameForState(FrameState)->BytecodeFrame::: debug info builder compute frame for state
org.graalvm.compiler.core.gen.DebugInfoBuilder#computeLocals(FrameState, int, JavaValue[], JavaKind[])->void::: debug info builder compute locals
org.graalvm.compiler.core.gen.DebugInfoBuilder#computeStack(FrameState, int, int, JavaValue[], JavaKind[])->void::: debug info builder compute stack
org.graalvm.compiler.core.gen.DebugInfoBuilder#computeLocks(FrameState, JavaValue[])->void::: debug info builder compute locks
org.graalvm.compiler.core.gen.DebugInfoBuilder#computeLockValue(FrameState, int)->JavaValue::: debug info builder compute lock value
org.graalvm.compiler.core.gen.DebugInfoBuilder#toJavaValue(ValueNode)->JavaValue::: debug info builder to java value
org.graalvm.compiler.core.gen.InstructionPrinter#out()->LogStream::: instruction printer out
org.graalvm.compiler.core.gen.InstructionPrinter#printInstructionListingHeader()->void:::Prints a header for the tabulated data printed by #printInstructionListing(ValueNode) .
org.graalvm.compiler.core.gen.InstructionPrinter#printInstructionListing(ValueNode)->void:::Prints an instruction listing on one line
org.graalvm.compiler.core.gen.InstructionPrinter#printInstruction(ValueNode)->void::: instruction printer print instruction
org.graalvm.compiler.core.gen.LIRCompilerBackend#emitBackEnd(StructuredGraph, Object, ResolvedJavaMethod, Backend, T, CompilationResultBuilderFactory, RegisterConfig, LIRSuites)->void::: compiler backend emit back end
org.graalvm.compiler.core.gen.LIRCompilerBackend#emitLIR(Backend, StructuredGraph, Object, RegisterConfig, LIRSuites)->LIRGenerationResult::: compiler backend emit r
org.graalvm.compiler.core.gen.LIRCompilerBackend#emitCode(Backend, Assumptions, ResolvedJavaMethod, Collection, EconomicSet, SpeculationLog, int, LIRGenerationResult, CompilationResult, ResolvedJavaMethod, CompilationResultBuilderFactory)->void::: compiler backend emit code
org.graalvm.compiler.core.gen.LIRGenerationProvider#newLIRGenerator(LIRGenerationResult)->LIRGeneratorTool::: generation provider new generator
org.graalvm.compiler.core.gen.LIRGenerationProvider#newLIRGenerationResult(CompilationIdentifier, LIR, RegisterConfig, StructuredGraph, Object)->LIRGenerationResult::: generation provider new generation result
org.graalvm.compiler.core.gen.LIRGenerationProvider#newNodeLIRBuilder(StructuredGraph, LIRGeneratorTool)->NodeLIRBuilderTool::: generation provider new node builder
org.graalvm.compiler.core.gen.LIRGenerationProvider#newCompilationResultBuilder(LIRGenerationResult, FrameMap, CompilationResult, CompilationResultBuilderFactory)->CompilationResultBuilder:::Creates the object used to fill in the details of a given compilation result.
org.graalvm.compiler.core.gen.LIRGenerationProvider#emitCode(CompilationResultBuilder, LIR, ResolvedJavaMethod)->void:::Emits the code for a given graph.
org.graalvm.compiler.core.gen.NodeLIRBuilder#getNodeMatchRules()->NodeMatchRules::: node builder get node match rules
org.graalvm.compiler.core.gen.NodeLIRBuilder#createDebugInfoBuilder(StructuredGraph, NodeValueMap)->DebugInfoBuilder::: node builder create debug info builder
org.graalvm.compiler.core.gen.NodeLIRBuilder#operand(Node)->Value:::Returns the operand that has been previously initialized by #setResult(ValueNode, Value) with the result of an instruction
org.graalvm.compiler.core.gen.NodeLIRBuilder#hasOperand(Node)->boolean::: node builder has operand
org.graalvm.compiler.core.gen.NodeLIRBuilder#valueForOperand(Value)->ValueNode::: node builder value for operand
org.graalvm.compiler.core.gen.NodeLIRBuilder#getSourceForOperand(Value)->Object::: node builder get source for operand
org.graalvm.compiler.core.gen.NodeLIRBuilder#setResult(ValueNode, Value)->Value::: node builder set result
org.graalvm.compiler.core.gen.NodeLIRBuilder#setMatchResult(Node, Value)->void:::Used by the MatchStatement machinery to override the generation LIR for some ValueNodes.
org.graalvm.compiler.core.gen.NodeLIRBuilder#getLIRBlock(FixedNode)->LabelRef::: node builder get block
org.graalvm.compiler.core.gen.NodeLIRBuilder#append(LIRInstruction)->void::: node builder append
org.graalvm.compiler.core.gen.NodeLIRBuilder#getExactPhiKind(PhiNode)->LIRKind::: node builder get exact phi kind
org.graalvm.compiler.core.gen.NodeLIRBuilder#doBlockPrologue(Block, OptionValues)->void::: node builder do block prologue
org.graalvm.compiler.core.gen.NodeLIRBuilder#doBlock(Block, StructuredGraph, BlockMap>)->void::: node builder do block
org.graalvm.compiler.core.gen.NodeLIRBuilder#matchBlock(Block, StructuredGraph, StructuredGraph.ScheduleResult)->void::: node builder match block
org.graalvm.compiler.core.gen.NodeLIRBuilder#matchComplexExpressions(Block, StructuredGraph.ScheduleResult)->void::: node builder match complex expressions
org.graalvm.compiler.core.gen.NodeLIRBuilder#peephole(ValueNode)->boolean::: node builder peephole
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitNode(ValueNode)->void::: node builder emit node
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitPrologue(StructuredGraph)->void::: node builder emit prologue
org.graalvm.compiler.core.gen.NodeLIRBuilder#visitMerge(AbstractMergeNode)->void::: node builder visit merge
org.graalvm.compiler.core.gen.NodeLIRBuilder#visitEndNode(AbstractEndNode)->void::: node builder visit end node
org.graalvm.compiler.core.gen.NodeLIRBuilder#visitLoopEnd(LoopEndNode)->void:::Runtime specific classes can override this to insert a safepoint at the end of a loop.
org.graalvm.compiler.core.gen.NodeLIRBuilder#newJumpOp(LabelRef)->JumpOp::: node builder new jump op
org.graalvm.compiler.core.gen.NodeLIRBuilder#getPhiKind(PhiNode)->LIRKind::: node builder get phi kind
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitIf(IfNode)->void::: node builder emit if
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitBranch(LogicNode, LabelRef, LabelRef, double)->void::: node builder emit branch
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitCompareBranch(CompareNode, LabelRef, LabelRef, double)->void::: node builder emit compare branch
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitIntegerTestBranch(IntegerTestNode, LabelRef, LabelRef, double)->void::: node builder emit integer test branch
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitConstantBranch(boolean, LabelRef, LabelRef)->void::: node builder emit constant branch
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitConditional(ConditionalNode)->void::: node builder emit conditional
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitConditional(LogicNode, Value, Value)->Variable::: node builder emit conditional
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitInvoke(Invoke)->void::: node builder emit invoke
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitDirectCall(DirectCallTargetNode, Value, Value[], Value[], LIRFrameState)->void::: node builder emit direct call
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitIndirectCall(IndirectCallTargetNode, Value, Value[], Value[], LIRFrameState)->void::: node builder emit indirect call
org.graalvm.compiler.core.gen.NodeLIRBuilder#visitInvokeArguments(CallingConvention, Collection)->Value[]::: node builder visit invoke arguments
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitSwitch(SwitchNode)->void:::This method tries to create a switch implementation that is optimal for the given switch
org.graalvm.compiler.core.gen.NodeLIRBuilder#getDebugInfoBuilder()->DebugInfoBuilder::: node builder get debug info builder
org.graalvm.compiler.core.gen.NodeLIRBuilder#state(DeoptimizingNode)->LIRFrameState::: node builder state
org.graalvm.compiler.core.gen.NodeLIRBuilder#stateWithExceptionEdge(DeoptimizingNode, LabelRef)->LIRFrameState::: node builder state with exception edge
org.graalvm.compiler.core.gen.NodeLIRBuilder#stateFor(FrameState)->LIRFrameState::: node builder state for
org.graalvm.compiler.core.gen.NodeLIRBuilder#stateForWithExceptionEdge(FrameState, LabelRef)->LIRFrameState::: node builder state for with exception edge
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitOverflowCheckBranch(AbstractBeginNode, AbstractBeginNode, Stamp, double)->void::: node builder emit overflow check branch
org.graalvm.compiler.core.gen.NodeLIRBuilder#visitFullInfopointNode(FullInfopointNode)->void::: node builder visit full infopoint node
org.graalvm.compiler.core.gen.NodeLIRBuilder#setSourcePosition(NodeSourcePosition)->void::: node builder set source position
org.graalvm.compiler.core.gen.NodeLIRBuilder#getLIRGeneratorTool()->LIRGeneratorTool::: node builder get generator tool
org.graalvm.compiler.core.gen.NodeLIRBuilder#emitReadExceptionObject(ValueNode)->void::: node builder emit read exception object
org.graalvm.compiler.core.gen.NodeMatchRules#getLIRGeneratorTool()->LIRGeneratorTool::: node match rules get generator tool
org.graalvm.compiler.core.gen.NodeMatchRules#operand(Node)->Value::: node match rules operand
org.graalvm.compiler.core.gen.NodeMatchRules#state(DeoptimizingNode)->LIRFrameState::: node match rules state
org.graalvm.compiler.core.gen.NodeMatchRules#getLIRBlock(FixedNode)->LabelRef::: node match rules get block
org.graalvm.compiler.core.gen.NodeMatchRules#append(LIRInstruction)->void::: node match rules append
