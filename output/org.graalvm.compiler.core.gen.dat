BytecodeParserTool#storeLocal(int, Value)::: bytecode parser tool store local:::
DebugInfoBuilder#build(FrameState, LabelRef)::: debug info builder build:::current->do->if->current->virtualObjectMappingCount->foreach->current->virtualObjectMappings->if->objectStates->state->object->containsKey->if->materializedValue->state->object->objectStates->state->object->put->current->outerFrameState->while->frame->computeFrameForState->virtualObjectsArray->if->virtualObjects->size->vobjNode->while->pendingVirtualObjects->poll->vobjValue->virtualObjects->get->values->slotKinds->entryCount->vobjNode->entryCount->if->else->new->JavaValueArr->new->JavaKindArr->if->currentField->objectStates->get->pos->for->i->if->Arrays->copyOf->Arrays->copyOf->vobjValue->setValues->virtualObjects->size->new->VirtualObjectArr->index->foreach->virtualObjects->getValues->virtualObjects->clear->objectStates->clear->return->newLIRFrameState
DebugInfoBuilder#checkValues(ResolvedJavaType, JavaValue[], JavaKind[])::: debug info builder check values:::if->if->type->isArray->fields->type->getInstanceFields->fieldIndex->for->valueIndex->else->componentKind->type->getComponentType->storageKind->getStackKind->if->for->i->else->for->i->return
DebugInfoBuilder#storageKind(JavaType)::: debug info builder storage kind:::return->type->getJavaKind
DebugInfoBuilder#newLIRFrameState(LabelRef, BytecodeFrame, VirtualObject[])::: debug info builder new frame state:::return->new->LIRFrameState
DebugInfoBuilder#computeFrameForState(FrameState)::: debug info builder compute frame for state:::try->numLocals->state->localsSize->numStack->state->stackSize->numLocks->state->locksSize->numValues->numKinds->values->new->JavaValueArr->slotKinds->new->JavaKindArr->computeLocals->computeStack->computeLocks->caller->if->state->outerFrameState->state->outerFrameState->computeFrameForState->if->state->canProduceBytecodeFrame->ste->state->getCode->state->getCode->asStackTraceElement->toString->state->toString->throw->new->GraalError->return->state->getMethod->state->rethrowException->state->duringCall->new->BytecodeFrame->catch->throw->e->addContext->finally
DebugInfoBuilder#computeLocals(FrameState, int, JavaValue[], JavaKind[])::: debug info builder compute locals:::for->i
DebugInfoBuilder#computeStack(FrameState, int, int, JavaValue[], JavaKind[])::: debug info builder compute stack:::for->i
DebugInfoBuilder#computeLocks(FrameState, JavaValue[])::: debug info builder compute locks:::for->i->state->locksSize
DebugInfoBuilder#computeLockValue(FrameState, int)::: debug info builder compute lock value:::return->state->lockAt->toJavaValue
DebugInfoBuilder#toSlotKind(ValueNode)::: debug info builder to slot kind:::if->return->else->return->value->getStackKind
DebugInfoBuilder#toJavaValue(ValueNode)::: debug info builder to java value:::try->if->obj->state->objectStates->get->if->obj->entryCount->throw->new->GraalError->if->return->materializedValue->toJavaValue->else->vobject->virtualObjects->get->if->isAutoBox->GraalServices->obj->type->virtualObjects->size->createVirtualObject->virtualObjects->put->pendingVirtualObjects->add->STATE_VIRTUAL_OBJECTS->increment->return->else->unproxied->GraphUtil->unproxify->if->STATE_CONSTANTS->increment->return->unproxied->asJavaConstant->else->if->STATE_VARIABLES->increment->operand->nodeValueMap->operand->if->isJavaConstant->return->getJavaConstant->else->return->else->STATE_ILLEGALS->increment->return->catch->throw->e->addContext->finally
InstructionPrinter#out()::: instruction printer out:::return
InstructionPrinter#printInstructionListingHeader():::Prints a header for the tabulated data printed by #printInstructionListing(ValueNode) .:::BCI->printLabel->USE->printLabel->VALUE->printLabel->INSTRUCTION->printLabel->END->printLabel->out->println
InstructionPrinter#printInstructionListing(ValueNode):::Prints an instruction listing on one line:::indentation->out->indentationLevel->out->fillTo->print->fillTo->print->fillTo->ValueNodeUtil->valueString->print->fillTo->printInstruction->if->out->stateAfter->print->out->println
InstructionPrinter#printInstruction(ValueNode)::: instruction printer print instruction:::out->node->toString->print
LIRCompilerBackend#emitBackEnd(StructuredGraph, Object, ResolvedJavaMethod, Backend, T, CompilationResultBuilderFactory, RegisterConfig, LIRSuites)::: compiler backend emit back end:::debug->graph->getDebug->try->s->debug->graph->getLastSchedule->scope->a->BackEnd->start->lirGen->emitLIR->try->s2->debug->lirGen->getLIR->scope->bytecodeSize->graph->method->graph->getBytecodeSize->compilationResult->graph->hasUnsafeAccess->setHasUnsafeAccess->graph->getAssumptions->graph->method->graph->getMethods->graph->getFields->graph->getSpeculationLog->emitCode->catch->throw->debug->handle->finally->catch->throw->debug->handle->finally->graph->checkCancellation
LIRCompilerBackend#emitLIR(Backend, StructuredGraph, Object, RegisterConfig, LIRSuites)::: compiler backend emit r:::registerPressure->graph->getOptions->getValue->allocationRestrictedTo->registerPressure->split->try->return->emitLIR0->catch->if->return->emitLIR0->throw->new->GraalError->finally->graph->checkCancellation
LIRCompilerBackend#emitLIR0(Backend, StructuredGraph, Object, RegisterConfig, LIRSuites, String[])::: compiler backend emit r0:::debug->graph->getDebug->try->ds->debug->scope->a->EmitLIR->start->schedule->graph->getLastSchedule->blocks->schedule->getCFG->getBlocks->startBlock->schedule->getCFG->getStartBlock->codeEmittingOrder->ComputeBlockOrder->computeCodeEmittingOrder->linearScanOrder->ComputeBlockOrder->computeLinearScanOrder->lir->schedule->getCFG->graph->getOptions->graph->getDebug->new->LIR->lirBackend->lirGenRes->lirBackend->graph->compilationId->newLIRGenerationResult->lirGen->lirBackend->newLIRGenerator->nodeLirGen->lirBackend->newNodeLIRBuilder->context->new->LIRGenerationContext->new->LIRGenerationPhase->backend->getTarget->apply->try->s->debug->scope->debug->graph->getLastSchedule->dump->result->backend->getTarget->backend->newRegisterAllocationConfig->emitLowLevel->return->catch->throw->debug->handle->finally->catch->throw->debug->handle->finally->graph->checkCancellation
LIRCompilerBackend#emitLowLevel(TargetDescription, LIRGenerationResult, LIRGeneratorTool, LIRSuites, RegisterAllocationConfig)::: compiler backend emit low level:::debug->lirGenRes->getLIR->getDebug->preAllocOptContext->new->PreAllocationOptimizationContext->lirSuites->getPreAllocationOptimizationStage->apply->debug->lirGenRes->getLIR->dump->allocContext->lirGen->getSpillMoveFactory->new->AllocationContext->lirSuites->getAllocationStage->apply->debug->lirGenRes->getLIR->dump->postAllocOptContext->new->PostAllocationOptimizationContext->lirSuites->getPostAllocationOptimizationStage->apply->debug->lirGenRes->getLIR->dump->return
LIRCompilerBackend#emitCode(Backend, Assumptions, ResolvedJavaMethod, Collection, EconomicSet, SpeculationLog, int, LIRGenerationResult, CompilationResult, ResolvedJavaMethod, CompilationResultBuilderFactory)::: compiler backend emit code:::debug->lirGenRes->getLIR->getDebug->try->a->EmitCode->start->lirBackend->frameMap->lirGenRes->getFrameMap->crb->lirBackend->newCompilationResultBuilder->lirBackend->lirGenRes->getLIR->emitCode->if->assumptions->isEmpty->compilationResult->assumptions->toArray->setAssumptions->if->compilationResult->setMethods->compilationResult->setFields->compilationResult->setBytecodeSize->if->compilationResult->setSpeculationLog->crb->finish->if->debug->isCountEnabled->ldp->compilationResult->getDataPatches->kindValues->JavaKind->values->dms->new->CounterKeyArr->for->i->foreach->kind->if->constant->getConstant->if->getJavaKind->kind->ordinal->add->DebugContext->counter->increment->DebugContext->counter->compilationResult->getTargetCodeSize->add->DebugContext->counter->compilationResult->getInfopoints->size->add->DebugContext->counter->ldp->size->add->DebugContext->counter->compilationResult->getExceptionHandlers->size->add->debug->dump->catch->finally
LIRGenerationProvider#newLIRGenerator(LIRGenerationResult)::: generation provider new generator:::
LIRGenerationProvider#newLIRGenerationResult(CompilationIdentifier, LIR, RegisterConfig, StructuredGraph, Object)::: generation provider new generation result:::
LIRGenerationProvider#newNodeLIRBuilder(StructuredGraph, LIRGeneratorTool)::: generation provider new node builder:::
LIRGenerationProvider#newCompilationResultBuilder(LIRGenerationResult, FrameMap, CompilationResult, CompilationResultBuilderFactory):::Creates the object used to fill in the details of a given compilation result.:::
LIRGenerationProvider#emitCode(CompilationResultBuilder, LIR, ResolvedJavaMethod):::Emits the code for a given graph.:::
NodeLIRBuilder#getNodeMatchRules()::: node builder get node match rules:::return
NodeLIRBuilder#createDebugInfoBuilder(StructuredGraph, NodeValueMap)::: node builder create debug info builder:::return->graph->getDebug->new->DebugInfoBuilder
NodeLIRBuilder#operand(Node):::Returns the operand that has been previously initialized by #setResult(ValueNode, Value) with the result of an instruction:::operand->getOperand->return
NodeLIRBuilder#hasOperand(Node)::: node builder has operand:::return->getOperand
NodeLIRBuilder#getOperand(Node)::: node builder get operand:::if->return->return->nodeOperands->get
NodeLIRBuilder#valueForOperand(Value)::: node builder value for operand:::cursor->nodeOperands->getEntries->while->cursor->advance->if->cursor->getValue->equals->return->cursor->getKey->return
NodeLIRBuilder#getSourceForOperand(Value)::: node builder get source for operand:::return->valueForOperand
NodeLIRBuilder#setResult(ValueNode, Value)::: node builder set result:::nodeOperands->set->return
NodeLIRBuilder#setMatchResult(Node, Value):::Used by the MatchStatement machinery to override the generation LIR for some ValueNodes.:::nodeOperands->set
NodeLIRBuilder#getLIRBlock(FixedNode)::: node builder get block:::result->gen->getResult->getLIR->getControlFlowGraph->blockFor->suxIndex->foreach->gen->getCurrentBlock->getSuccessors->if->return->LabelRef->gen->getResult->getLIR->gen->getCurrentBlock->forSuccessor->throw->GraalError->shouldNotReachHere
NodeLIRBuilder#append(LIRInstruction)::: node builder append:::if->nodeOperands->graph->getOptions->getValue->TTY->isSuppressed->if->ip->TTY->out->new->InstructionPrinter->ip->printInstructionListing->gen->append
NodeLIRBuilder#getExactPhiKind(PhiNode)::: node builder get exact phi kind:::derivedKind->gen->gen->phi->stamp->getLIRKind->toRegisterKind->for->i->phi->valueCount->derivedKind->isUnknownReference->return
NodeLIRBuilder#isPhiInputFromBackedge(PhiNode, int)::: node builder is phi input from backedge:::merge->phi->merge->end->merge->phiPredecessorAt->return->loopBegin->equals
NodeLIRBuilder#createPhiIn(AbstractMergeNode)::: node builder create phi in:::values->new->ArrayList<>->foreach->merge->valuePhis->value->gen->getExactPhiKind->newVariable->values->add->setResult->return->values->values->size->new->ValueArr->toArray
NodeLIRBuilder#createPhiOut(AbstractMergeNode, AbstractEndNode)::: node builder create phi out:::values->new->ArrayList<>->foreach->merge->valuePhis->node->phi->valueAt->value->operand->if->isRegister->gen->emitMove->else->if->node->isConstant->gen->getSpillMoveFactory->node->asConstant->allowConstantToStackMove->LIRKind->isValue->result->gen->value->getValueKind->newVariable->gen->emitMove->values->add->return->values->values->size->new->ValueArr->toArray
NodeLIRBuilder#doBlockPrologue(Block, OptionValues)::: node builder do block prologue:::if->MitigateSpeculativeExecutionAttacks->getValue->hasControlSplitPredecessor->foreach->block->getPredecessors->if->b->getSuccessorCount->break->isStartBlock->block->getPredecessorCount->if->getLIRGeneratorTool->emitSpeculationFence
NodeLIRBuilder#doBlock(Block, StructuredGraph, BlockMap>)::: node builder do block:::options->graph->getOptions->try->blockScope->gen->getBlockScope->setSourcePosition->if->gen->getResult->getLIR->getControlFlowGraph->getStartBlock->emitPrologue->else->begin->block->getBeginNode->if->merge->label->gen->getResult->getLIR->getLIRforBlock->get->label->createPhiIn->setPhiValues->if->getValue->TTY->isSuppressed->TTY->println->doBlockPrologue->nodes->blockMap->get->trace->for->i->nodes->size->if->gen->hasBlockEnd->successors->block->getEndNode->successors->if->block->getSuccessorCount->throw->block->getEndNode->new->GraalError->gen->successors->first->getLIRBlock->emitJump->catch->finally
NodeLIRBuilder#matchBlock(Block, StructuredGraph, StructuredGraph.ScheduleResult)::: node builder match block:::try->matchScope->gen->getMatchScope->matchComplexExpressions->catch->finally
NodeLIRBuilder#matchComplexExpressions(Block, StructuredGraph.ScheduleResult)::: node builder match complex expressions:::if->debug->gen->getResult->getLIR->getDebug->try->s->debug->scope->nodes->schedule->getBlockToNodesMap->get->if->LogVerbose->nodeOperands->graph->getOptions->getValue->i->foreach->debug->node->getUsageCount->log->for->index->nodes->size->catch->finally
NodeLIRBuilder#peephole(ValueNode)::: node builder peephole:::
NodeLIRBuilder#doRoot(ValueNode)::: node builder do root:::if->TTY->println->debug->instr->getDebug->debug->log->emitNode->debug->getOperand->log
NodeLIRBuilder#emitNode(ValueNode)::: node builder emit node:::if->node->getDebug->isLogEnabled->node->stamp->isEmpty->node->getDebug->log->if->generate->else->throw->GraalError->shouldNotReachHere
NodeLIRBuilder#emitPrologue(StructuredGraph)::: node builder emit prologue:::incomingArguments->gen->getResult->getCallingConvention->params->incomingArguments->getArgumentCount->new->ValueArr->for->i->gen->emitIncomingValues->foreach->graph->getNodes->paramValue->param->index->gen->emitMove->setResult
NodeLIRBuilder#visitMerge(AbstractMergeNode)::: node builder visit merge:::
NodeLIRBuilder#visitEndNode(AbstractEndNode)::: node builder visit end node:::merge->end->merge->jump->getLIRBlock->newJumpOp->jump->createPhiOut->setPhiValues->append
NodeLIRBuilder#visitLoopEnd(LoopEndNode):::Runtime specific classes can override this to insert a safepoint at the end of a loop.:::
NodeLIRBuilder#newJumpOp(LabelRef)::: node builder new jump op:::return->new->JumpOp
NodeLIRBuilder#getPhiKind(PhiNode)::: node builder get phi kind:::return->gen->phi->stamp->getLIRKind
NodeLIRBuilder#emitIf(IfNode)::: node builder emit if:::x->condition->x->trueSuccessor->getLIRBlock->x->falseSuccessor->getLIRBlock->x->x->trueSuccessor->probability->emitBranch
NodeLIRBuilder#emitBranch(LogicNode, LabelRef, LabelRef, double)::: node builder emit branch:::if->emitNullCheckBranch->else->if->emitCompareBranch->else->if->getValue->emitConstantBranch->else->if->emitIntegerTestBranch->else->throw->GraalError->node->toString->unimplemented
NodeLIRBuilder#emitNullCheckBranch(IsNullNode, LabelRef, LabelRef, double)::: node builder emit null check branch:::kind->gen->node->getValue->stamp->getLIRKind->nullValue->gen->node->nullConstant->emitConstant->gen->kind->getPlatformKind->node->getValue->operand->emitCompareBranch
NodeLIRBuilder#emitCompareBranch(CompareNode, LabelRef, LabelRef, double)::: node builder emit compare branch:::kind->gen->compare->getX->stamp->getLIRKind->getPlatformKind->gen->compare->getX->operand->compare->getY->operand->compare->condition->asCondition->compare->unorderedIsTrue->emitCompareBranch
NodeLIRBuilder#emitIntegerTestBranch(IntegerTestNode, LabelRef, LabelRef, double)::: node builder emit integer test branch:::gen->test->getX->operand->test->getY->operand->emitIntegerTestBranch
NodeLIRBuilder#emitConstantBranch(boolean, LabelRef, LabelRef)::: node builder emit constant branch:::block->gen->emitJump
NodeLIRBuilder#emitConditional(ConditionalNode)::: node builder emit conditional:::tVal->conditional->trueValue->operand->fVal->conditional->falseValue->operand->conditional->condition->emitConditional->setResult
NodeLIRBuilder#emitConditional(LogicNode, Value, Value)::: node builder emit conditional:::if->isNullNode->kind->gen->isNullNode->getValue->stamp->getLIRKind->nullValue->gen->isNullNode->nullConstant->emitConstant->return->gen->kind->getPlatformKind->isNullNode->getValue->operand->emitConditionalMove->else->if->compare->kind->gen->compare->getX->stamp->getLIRKind->getPlatformKind->return->gen->compare->getX->operand->compare->getY->operand->compare->condition->asCondition->compare->unorderedIsTrue->emitConditionalMove->else->if->return->gen->getValue->emitMove->else->if->test->return->gen->test->getX->operand->test->getY->operand->emitIntegerTestMove->else->throw->GraalError->node->toString->unimplemented
NodeLIRBuilder#emitInvoke(Invoke)::: node builder emit invoke:::callTarget->x->callTarget->frameMapBuilder->gen->getResult->getFrameMapBuilder->invokeCc->frameMapBuilder->getRegisterConfig->callTarget->callType->x->asNode->stamp->gen->getMetaAccess->javaType->callTarget->signature->getCallingConvention->frameMapBuilder->callsMethod->parameters->callTarget->arguments->visitInvokeArguments->exceptionEdge->if->exceptionEdge->getLIRBlock->callState->stateWithExceptionEdge->result->invokeCc->getReturn->if->emitDirectCall->else->if->emitIndirectCall->else->throw->GraalError->shouldNotReachHere->if->isLegal->x->asNode->gen->emitMove->setResult->if->gen->next->getLIRBlock->emitJump
NodeLIRBuilder#emitDirectCall(DirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: node builder emit direct call:::
NodeLIRBuilder#emitIndirectCall(IndirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: node builder emit indirect call:::
NodeLIRBuilder#visitInvokeArguments(CallingConvention, Collection)::: node builder visit invoke arguments:::result->arguments->size->new->ValueArr->j->foreach->if->operand->invokeCc->getArgument->gen->operand->emitMove->else->throw->GraalError->shouldNotReachHere->return
NodeLIRBuilder#emitSwitch(SwitchNode):::This method tries to create a switch implementation that is optimal for the given switch:::defaultTarget->x->defaultSuccessor->getLIRBlock->keyCount->x->keyCount->if->gen->emitJump->else->value->gen->x->value->operand->load->if->probability->x->x->keySuccessor->probability->kind->gen->x->value->stamp->getLIRKind->key->gen->x->keyAt->emitConstant->gen->kind->getPlatformKind->gen->x->value->operand->load->x->keySuccessor->getLIRBlock->emitCompareBranch->else->if->x->isSorted->intSwitch->keyTargets->new->LabelRefArr->keyConstants->new->JavaConstantArr->keyProbabilities->new->doubleArr->keyKind->intSwitch->keyAt->getJavaKind->for->i->gen->emitStrategySwitch->else->keyTargets->new->LabelRefArr->keyConstants->new->ConstantArr->keyProbabilities->new->doubleArr->for->i->gen->new->SwitchStrategy.SequentialStrategy->emitStrategySwitch
NodeLIRBuilder#getDebugInfoBuilder()::: node builder get debug info builder:::return
NodeLIRBuilder#getFrameState(DeoptimizingNode)::: node builder get frame state:::if->return->stateBefore->else->if->return->stateDuring->else->return->stateAfter
NodeLIRBuilder#state(DeoptimizingNode)::: node builder state:::if->deopt->canDeoptimize->return->return->getFrameState->stateFor
NodeLIRBuilder#stateWithExceptionEdge(DeoptimizingNode, LabelRef)::: node builder state with exception edge:::if->deopt->canDeoptimize->return->return->getFrameState->stateForWithExceptionEdge
NodeLIRBuilder#stateFor(FrameState)::: node builder state for:::return->stateForWithExceptionEdge
NodeLIRBuilder#stateForWithExceptionEdge(FrameState, LabelRef)::: node builder state for with exception edge:::if->gen->needOnlyOopMaps->return->new->LIRFrameState->return->getDebugInfoBuilder->build
NodeLIRBuilder#emitOverflowCheckBranch(AbstractBeginNode, AbstractBeginNode, Stamp, double)::: node builder emit overflow check branch:::cmpKind->getLIRGeneratorTool->getLIRKind->gen->getLIRBlock->getLIRBlock->emitOverflowCheckBranch
NodeLIRBuilder#visitFullInfopointNode(FullInfopointNode)::: node builder visit full infopoint node:::i->getState->stateFor->i->getReason->new->FullInfopointOp->append
NodeLIRBuilder#setSourcePosition(NodeSourcePosition)::: node builder set source position:::gen->setSourcePosition
NodeLIRBuilder#getLIRGeneratorTool()::: node builder get generator tool:::return
NodeLIRBuilder#emitReadExceptionObject(ValueNode)::: node builder emit read exception object:::lirGenTool->getLIRGeneratorTool->returnRegister->lirGenTool->getRegisterConfig->node->getStackKind->getReturnRegister->LIRKind->lirGenTool->target->node->getStackKind->fromJavaKind->asValue->lirGenTool->new->ValueArr->emitIncomingValues->lirGenTool->emitMove->setResult
NodeMatchRules#getLIRGeneratorTool()::: node match rules get generator tool:::return
NodeMatchRules#operand(Node)::: node match rules operand:::return->lirBuilder->operand
NodeMatchRules#state(DeoptimizingNode)::: node match rules state:::return->lirBuilder->state
NodeMatchRules#getLIRBlock(FixedNode)::: node match rules get block:::return->lirBuilder->getLIRBlock
NodeMatchRules#append(LIRInstruction)::: node match rules append:::lirBuilder->append
