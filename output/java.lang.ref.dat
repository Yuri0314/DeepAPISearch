java.lang.ref.Cleaner#create()->Cleaner:::Returns a new {@code Cleaner}
java.lang.ref.Cleaner#create(ThreadFactory)->Cleaner:::Returns a new {@code Cleaner} using a {@code Thread} from the {@code ThreadFactory}
java.lang.ref.Cleaner#register(Object, Runnable)->Cleanable:::Registers an object and a cleaning action to run when the object  becomes phantom reachable
java.lang.ref.Cleaner.Cleanable#clean()->void:::Unregisters the cleanable and invokes the cleaning action
java.lang.ref.Finalizer#getQueue()->ReferenceQueue<Object>:::
java.lang.ref.Finalizer#register(Object)->void:::
java.lang.ref.Finalizer#runFinalization()->void:::
java.lang.ref.Finalizer.FinalizerThread#run()->void:::
java.lang.ref.FinalizerHistogram.Entry#getInstanceCount()->int:::
java.lang.ref.FinalizerHistogram.Entry#increment()->void:::
java.lang.ref.FinalizerHistogram#getFinalizerHistogram()->Entry[]:::
java.lang.ref.FinalReference#enqueue()->boolean:::
java.lang.ref.PhantomReference#get()->T:::Returns this reference object's referent
java.lang.ref.Reference.ReferenceHandler#run()->void:::
java.lang.ref.Reference#get()->T:::Returns this reference object's referent
java.lang.ref.Reference#clear()->void:::Clears this reference object
java.lang.ref.Reference#isEnqueued()->boolean:::Tells whether or not this reference object has been enqueued, either by  the program or by the garbage collector
java.lang.ref.Reference#enqueue()->boolean:::Clears this reference object and adds it to the queue with which  it is registered, if any
java.lang.ref.Reference#clone()->Object:::Throws {@link CloneNotSupportedException}
java.lang.ref.Reference#reachabilityFence(Object)->void:::Ensures that the object referenced by the given reference remains  <a href="package-summary.html#reachability"><em>strongly reachable</em></a>,  regardless of any prior actions of the program that might otherwise cause  the object to become unreachable; thus, the referenced object is not  reclaimable by garbage collection at least until after the invocation of  this method
java.lang.ref.ReferenceQueue.Null#enqueue(Reference<?>)->boolean:::
java.lang.ref.ReferenceQueue#enqueue(Reference<? extends T>)->boolean:::
java.lang.ref.ReferenceQueue#extends T> poll()->Reference<?:::Polls this queue to see if a reference object is available
java.lang.ref.ReferenceQueue#extends T> remove(long)->Reference<?:::Removes the next reference object in this queue, blocking until either  one becomes available or the given timeout period expires
java.lang.ref.ReferenceQueue#extends T> remove()->Reference<?:::Removes the next reference object in this queue, blocking until one  becomes available.
java.lang.ref.ReferenceQueue#forEach(Consumer<? super Reference<? extends T>>)->void:::Iterate queue and invoke given action with each Reference
java.lang.ref.SoftReference#get()->T:::Returns this reference object's referent
