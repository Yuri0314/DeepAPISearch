Adler32#update(int):::Updates the checksum with the specified byte (the low eight bits of the argument b).:::update
Adler32#update(byte[], int, int):::Updates the checksum with the specified array of bytes.:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->updateBytes
Adler32#update(ByteBuffer):::Updates the checksum with the bytes from the specified buffer:::pos->buffer->position->limit->buffer->limit->rem->if->return->if->address->updateByteBuffer->else->if->buffer->hasArray->buffer->array->buffer->arrayOffset->updateBytes->else->b->Math->buffer->remaining->min->new->byteArr->while->buffer->hasRemaining->length->Math->buffer->remaining->min->buffer->get->update->buffer->position
Adler32#reset():::Resets the checksum to initial value.:::
Adler32#getValue():::Returns the checksum value.:::return
CheckedInputStream#read():::Reads a byte:::b->in->read->if->cksum->update->return
CheckedInputStream#read(byte[], int, int):::Reads into an array of bytes:::in->read->if->cksum->update->return
CheckedInputStream#skip(long):::Skips specified number of bytes of input.:::buf->new->byteArr->total->while->len->read->if->return->return
CheckedInputStream#getChecksum():::Returns the Checksum for this input stream.:::return
CheckedOutputStream#write(int):::Writes a byte:::out->write->cksum->update
CheckedOutputStream#write(byte[], int, int):::Writes an array of bytes:::out->write->cksum->update
CheckedOutputStream#getChecksum():::Returns the Checksum for this output stream.:::return
Checksum#update(int):::Updates the current checksum with the specified byte.:::
Checksum#update(byte[]):::Updates the current checksum with the specified array of bytes.:::update
Checksum#update(byte[], int, int):::Updates the current checksum with the specified array of bytes.:::
Checksum#update(ByteBuffer):::Updates the current checksum with the bytes from the specified buffer:::pos->buffer->position->limit->buffer->limit->rem->if->return->if->buffer->hasArray->buffer->array->buffer->arrayOffset->update->else->b->Math->buffer->remaining->min->new->byteArr->while->buffer->hasRemaining->length->Math->buffer->remaining->min->buffer->get->update->buffer->position
Checksum#getValue():::Returns the current checksum value.:::
Checksum#reset():::Resets the checksum to its initial value.:::
CRC32#update(int):::Updates the CRC-32 checksum with the specified byte (the low eight bits of the argument b).:::update
CRC32#update(byte[], int, int):::Updates the CRC-32 checksum with the specified array of bytes.:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->updateBytes
CRC32#update(ByteBuffer):::Updates the CRC-32 checksum with the bytes from the specified buffer:::pos->buffer->position->limit->buffer->limit->rem->if->return->if->address->updateByteBuffer->else->if->buffer->hasArray->buffer->array->buffer->arrayOffset->updateBytes->else->b->Math->buffer->remaining->min->new->byteArr->while->buffer->hasRemaining->length->Math->buffer->remaining->min->buffer->get->update->buffer->position
CRC32#reset():::Resets CRC-32 to initial value.:::
CRC32#getValue():::Returns CRC-32 value.:::return
CRC32C#update(int):::Updates the CRC-32C checksum with the specified byte (the low eight bits of the argument b).:::
CRC32C#update(byte[], int, int):::Updates the CRC-32C checksum with the specified array of bytes.:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->updateBytes
CRC32C#update(ByteBuffer):::Updates the CRC-32C checksum with the bytes from the specified buffer:::pos->buffer->position->limit->buffer->limit->rem->if->return->if->address->updateDirectByteBuffer->else->if->buffer->hasArray->buffer->array->buffer->arrayOffset->buffer->arrayOffset->updateBytes->else->b->Math->buffer->remaining->min->new->byteArr->while->buffer->hasRemaining->length->Math->buffer->remaining->min->buffer->get->update->buffer->position
CRC32C#reset():::Resets CRC-32C to initial value.:::
CRC32C#getValue():::Returns CRC-32C value.:::return
Deflater#setInput(byte[], int, int):::Sets input data for compression:::if->throw->new->ArrayIndexOutOfBoundsException->synchronized
Deflater#setInput(byte[]):::Sets input data for compression:::setInput
Deflater#setInput(ByteBuffer):::Sets input data for compression:::Objects->requireNonNull->synchronized
Deflater#setDictionary(byte[], int, int):::Sets preset dictionary for compression:::if->throw->new->ArrayIndexOutOfBoundsException->synchronized->ensureOpen->zsRef->address->setDictionary
Deflater#setDictionary(byte[]):::Sets preset dictionary for compression:::setDictionary
Deflater#setDictionary(ByteBuffer):::Sets preset dictionary for compression:::synchronized->position->dictionary->position->remaining->Math->dictionary->limit->max->ensureOpen->if->dictionary->isDirect->address->address->try->zsRef->address->setDictionaryBuffer->catch->finally->Reference->reachabilityFence->else->array->ZipUtils->getBufferArray->offset->ZipUtils->getBufferOffset->zsRef->address->setDictionary->dictionary->position
Deflater#setStrategy(int):::Sets the compression strategy to the specified value:::switch->break->throw->new->IllegalArgumentException->synchronized->if
Deflater#setLevel(int):::Sets the compression level to the specified value:::if->throw->new->IllegalArgumentException->synchronized->if
Deflater#needsInput():::Returns true if no data remains in the input buffer:::synchronized->input->return->input->hasRemaining
Deflater#finish():::When called, indicates that compression should end with the current contents of the input buffer.:::synchronized
Deflater#finished():::Returns true if the end of the compressed data output stream has been reached.:::synchronized->return
Deflater#deflate(byte[], int, int):::Compresses the input data and fills specified buffer with compressed data:::return->deflate
Deflater#deflate(byte[]):::Compresses the input data and fills specified buffer with compressed data:::return->deflate
Deflater#deflate(ByteBuffer):::Compresses the input data and fills specified buffer with compressed data:::return->deflate
Deflater#deflate(byte[], int, int, int):::Compresses the input data and fills the specified buffer with compressed data:::if->throw->new->ArrayIndexOutOfBoundsException->if->throw->new->IllegalArgumentException->synchronized->ensureOpen->input->if->params->if->else->inputPos->result->if->zsRef->address->deflateBytesBytes->else->input->position->inputRem->Math->input->limit->max->if->input->isDirect->try->inputAddress->address->zsRef->address->deflateBufferBytes->catch->finally->Reference->reachabilityFence->else->inputArray->ZipUtils->getBufferArray->inputOffset->ZipUtils->getBufferOffset->zsRef->address->deflateBytesBytes->read->written->if->if->if->input->position->else->return
Deflater#deflate(ByteBuffer, int):::Compresses the input data and fills the specified buffer with compressed data:::if->output->isReadOnly->throw->new->ReadOnlyBufferException->if->throw->new->IllegalArgumentException->synchronized->ensureOpen->input->if->params->if->else->outputPos->output->position->outputRem->Math->output->limit->max->inputPos->result->if->if->output->isDirect->outputAddress->address->try->zsRef->address->deflateBytesBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->deflateBytesBytes->else->input->position->inputRem->Math->input->limit->max->if->input->isDirect->inputAddress->address->try->if->output->isDirect->outputAddress->address->try->zsRef->address->deflateBufferBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->deflateBufferBytes->catch->finally->Reference->reachabilityFence->else->inputArray->ZipUtils->getBufferArray->inputOffset->ZipUtils->getBufferOffset->if->output->isDirect->outputAddress->address->try->zsRef->address->deflateBytesBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->deflateBytesBytes->read->written->if->if->if->input->position->else->output->position->return
Deflater#getAdler():::Returns the ADLER-32 value of the uncompressed data.:::synchronized->ensureOpen->return->zsRef->address->getAdler
Deflater#getTotalIn():::Returns the total number of uncompressed bytes input so far:::return->getBytesRead
Deflater#getBytesRead():::Returns the total number of uncompressed bytes input so far.:::synchronized->ensureOpen->return
Deflater#getTotalOut():::Returns the total number of compressed bytes output so far:::return->getBytesWritten
Deflater#getBytesWritten():::Returns the total number of compressed bytes output so far.:::synchronized->ensureOpen->return
Deflater#reset():::Resets deflater so that a new set of input data can be processed:::synchronized->ensureOpen->zsRef->address->reset
Deflater#end():::Closes the compressor and discards any unprocessed input:::synchronized->zsRef->clean
Deflater#finalize():::Closes the compressor when garbage is collected.:::
DeflaterInputStream#close():::Closes this input stream and its underlying input stream, discarding any pending uncompressed data.:::if->try->if->def->end->in->close->catch->finally
DeflaterInputStream#read():::Reads a single byte of compressed data from the input stream:::len->read->if->return->return
DeflaterInputStream#read(byte[], int, int):::Reads compressed data into a byte array:::ensureOpen->if->throw->new->NullPointerException->else->if->throw->new->IndexOutOfBoundsException->else->if->return->cnt->while->def->finished->n->if->def->needsInput->in->read->if->def->finish->else->if->def->setInput->def->deflate->if->def->finished->return
DeflaterInputStream#skip(long):::Skips over and discards data from the input stream:::if->throw->new->IllegalArgumentException->ensureOpen->if->new->byteArr->total->Math->min->cnt->while->len->read->if->break->return
DeflaterInputStream#available():::Returns 0 after EOF has been reached, otherwise always return 1:::ensureOpen->if->return->return
DeflaterInputStream#markSupported():::Always returns false because this input stream does not support the #mark mark() and #reset reset() methods.:::return
DeflaterInputStream#mark(int):::This operation is not supported.:::
DeflaterInputStream#reset():::This operation is not supported.:::throw->new->IOException
DeflaterOutputStream#write(int):::Writes a byte to the compressed output stream:::buf->new->byteArr->write
DeflaterOutputStream#write(byte[], int, int):::Writes an array of bytes to the compressed output stream:::if->def->finished->throw->new->IOException->if->throw->new->IndexOutOfBoundsException->else->if->return->if->def->finished->def->setInput->while->def->needsInput->deflate
DeflaterOutputStream#finish():::Finishes writing compressed data to the output stream without closing the underlying stream:::if->def->finished->def->finish->while->def->finished->deflate
DeflaterOutputStream#close():::Writes remaining compressed data to the output stream and closes the underlying stream.:::if->finish->if->def->end->out->close
DeflaterOutputStream#deflate():::Writes next block of compressed data to the output stream.:::len->def->deflate->if->out->write
DeflaterOutputStream#flush():::Flushes the compressed output stream:::if->def->finished->len->while->def->deflate->out->write->if->break->out->flush
GZIPInputStream#read(byte[], int, int):::Reads uncompressed data into an array of bytes:::ensureOpen->if->return->n->super->read->if->if->readTrailer->else->return->this->read->else->crc->update->return
GZIPInputStream#close():::Closes this input stream and releases any system resources associated with the stream.:::if->super->close
GZIPOutputStream#write(byte[], int, int):::Writes array of bytes to the compressed output stream:::super->write->crc->update
GZIPOutputStream#finish():::Finishes writing compressed data to the output stream without closing the underlying stream:::if->def->finished->def->finish->while->def->finished->len->def->deflate->if->def->finished->writeTrailer->out->write->return->if->out->write->trailer->new->byteArr->writeTrailer->out->write
Inflater#setInput(byte[], int, int):::Sets input data for decompression:::if->throw->new->ArrayIndexOutOfBoundsException->synchronized
Inflater#setInput(byte[]):::Sets input data for decompression:::setInput
Inflater#setInput(ByteBuffer):::Sets input data for decompression:::Objects->requireNonNull->synchronized
Inflater#setDictionary(byte[], int, int):::Sets the preset dictionary to the given array of bytes:::if->throw->new->ArrayIndexOutOfBoundsException->synchronized->ensureOpen->zsRef->address->setDictionary
Inflater#setDictionary(byte[]):::Sets the preset dictionary to the given array of bytes:::setDictionary
Inflater#setDictionary(ByteBuffer):::Sets the preset dictionary to the bytes in the given buffer:::synchronized->position->dictionary->position->remaining->Math->dictionary->limit->max->ensureOpen->if->dictionary->isDirect->address->address->try->zsRef->address->setDictionaryBuffer->catch->finally->Reference->reachabilityFence->else->array->ZipUtils->getBufferArray->offset->ZipUtils->getBufferOffset->zsRef->address->setDictionary->dictionary->position
Inflater#getRemaining():::Returns the total number of bytes remaining in the input buffer:::synchronized->input->return->input->remaining
Inflater#needsInput():::Returns true if no data remains in the input buffer:::synchronized->input->return->input->hasRemaining
Inflater#needsDictionary():::Returns true if a preset dictionary is needed for decompression.:::synchronized->return
Inflater#finished():::Returns true if the end of the compressed data stream has been reached.:::synchronized->return
Inflater#inflate(byte[], int, int):::Uncompresses bytes into specified buffer:::if->throw->new->ArrayIndexOutOfBoundsException->synchronized->ensureOpen->input->result->inputPos->try->if->try->zsRef->address->inflateBytesBytes->catch->throw->finally->else->input->position->try->inputRem->Math->input->limit->max->if->input->isDirect->try->inputAddress->address->zsRef->address->inflateBufferBytes->catch->finally->Reference->reachabilityFence->else->inputArray->ZipUtils->getBufferArray->inputOffset->ZipUtils->getBufferOffset->zsRef->address->inflateBytesBytes->catch->input->position->throw->finally->catch->written->throw->finally->read->written->if->if->if->input->position->else->return
Inflater#inflate(byte[]):::Uncompresses bytes into specified buffer:::return->inflate
Inflater#inflate(ByteBuffer):::Uncompresses bytes into specified buffer:::if->output->isReadOnly->throw->new->ReadOnlyBufferException->synchronized->ensureOpen->input->result->inputPos->outputPos->output->position->outputRem->Math->output->limit->max->try->if->try->if->output->isDirect->outputAddress->address->try->zsRef->address->inflateBytesBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->inflateBytesBytes->catch->throw->finally->else->input->position->inputRem->Math->input->limit->max->try->if->input->isDirect->inputAddress->address->try->if->output->isDirect->outputAddress->address->try->zsRef->address->inflateBufferBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->inflateBufferBytes->catch->finally->Reference->reachabilityFence->else->inputArray->ZipUtils->getBufferArray->inputOffset->ZipUtils->getBufferOffset->if->output->isDirect->outputAddress->address->try->zsRef->address->inflateBytesBuffer->catch->finally->Reference->reachabilityFence->else->outputArray->ZipUtils->getBufferArray->outputOffset->ZipUtils->getBufferOffset->zsRef->address->inflateBytesBytes->catch->input->position->throw->finally->catch->written->output->position->throw->finally->read->written->if->if->if->input->position->else->output->position->return
Inflater#getAdler():::Returns the ADLER-32 value of the uncompressed data.:::synchronized->ensureOpen->return->zsRef->address->getAdler
Inflater#getTotalIn():::Returns the total number of compressed bytes input so far:::return->getBytesRead
Inflater#getBytesRead():::Returns the total number of compressed bytes input so far.:::synchronized->ensureOpen->return
Inflater#getTotalOut():::Returns the total number of uncompressed bytes output so far:::return->getBytesWritten
Inflater#getBytesWritten():::Returns the total number of uncompressed bytes output so far.:::synchronized->ensureOpen->return
Inflater#reset():::Resets inflater so that a new set of input data can be processed.:::synchronized->ensureOpen->zsRef->address->reset
Inflater#end():::Closes the decompressor and discards any unprocessed input:::synchronized->zsRef->clean
Inflater#finalize():::Closes the decompressor when garbage is collected.:::
InflaterInputStream#read():::Reads a byte of uncompressed data:::ensureOpen->return->read->Byte->toUnsignedInt
InflaterInputStream#read(byte[], int, int):::Reads uncompressed data into an array of bytes:::ensureOpen->if->throw->new->NullPointerException->else->if->throw->new->IndexOutOfBoundsException->else->if->return->try->n->while->inf->inflate->if->inf->finished->inf->needsDictionary->return->if->inf->needsInput->fill->return->catch->s->e->getMessage->throw->new->ZipException->finally
InflaterInputStream#available():::Returns 0 after EOF has been reached, otherwise always return 1:::ensureOpen->if->return->else->if->inf->finished->return->else->return
InflaterInputStream#skip(long):::Skips specified number of bytes of uncompressed data.:::if->throw->new->IllegalArgumentException->ensureOpen->max->Math->min->total->while->len->if->read->if->break->return
InflaterInputStream#close():::Closes this input stream and releases any system resources associated with the stream.:::if->if->inf->end->in->close
InflaterInputStream#fill():::Fills input buffer with more data to decompress.:::ensureOpen->in->read->if->throw->new->EOFException->inf->setInput
InflaterInputStream#markSupported():::Tests if this input stream supports the mark and reset methods:::return
InflaterInputStream#mark(int):::Marks the current position in this input stream:::
InflaterInputStream#reset():::Repositions this stream to the position at the time the mark method was last called on this input stream:::throw->new->IOException
InflaterOutputStream#close():::Writes any remaining uncompressed data to the output stream and closes the underlying output stream.:::if->try->finish->catch->finally->out->close
InflaterOutputStream#flush():::Flushes this output stream, forcing any pending buffered output bytes to be written.:::ensureOpen->if->inf->finished->try->while->inf->finished->inf->needsInput->n->inf->inflate->if->break->out->write->super->flush->catch->msg->ex->getMessage->if->throw->new->ZipException->finally
InflaterOutputStream#finish():::Finishes writing uncompressed data to the output stream without closing the underlying stream:::ensureOpen->flush->if->inf->end
InflaterOutputStream#write(int):::Writes a byte to the uncompressed output stream.:::write
InflaterOutputStream#write(byte[], int, int):::Writes an array of bytes to the uncompressed output stream.:::ensureOpen->if->throw->new->NullPointerException->else->if->throw->new->IndexOutOfBoundsException->else->if->return->try->for->catch->msg->ex->getMessage->if->throw->new->ZipException->finally
ZipEntry#getName():::Returns the name of the entry.:::return
ZipEntry#setTime(long):::Sets the last modification time of the entry:::javaToExtendedDosTime->if->else->FileTime->from
ZipEntry#getTime():::Returns the last modification time of the entry:::if->return->mtime->toMillis->return->extendedDosToJavaTime
ZipEntry#setTimeLocal(LocalDateTime):::Sets the last modification time of the entry in local date-time:::year->time->getYear->if->else->time->getMonthValue->time->getDayOfMonth->time->getHour->time->getMinute->time->getSecond->time->getSecond->time->getNano->if->else->FileTime->ZonedDateTime->ZoneId->systemDefault->of->toInstant->from
ZipEntry#getTimeLocal():::Returns the last modification time of the entry in local date-time:::if->return->LocalDateTime->mtime->toInstant->ZoneId->systemDefault->ofInstant->ms->return->LocalDateTime->of
ZipEntry#setLastModifiedTime(FileTime):::Sets the last modification time of the entry:::Objects->requireNonNull->time->to->javaToExtendedDosTime->return
ZipEntry#getLastModifiedTime():::Returns the last modification time of the entry:::if->return->if->return->return->FileTime->getTime->from
ZipEntry#setLastAccessTime(FileTime):::Sets the last access time of the entry:::Objects->requireNonNull->return
ZipEntry#getLastAccessTime():::Returns the last access time of the entry:::return
ZipEntry#setCreationTime(FileTime):::Sets the creation time of the entry:::Objects->requireNonNull->return
ZipEntry#getCreationTime():::Returns the creation time of the entry:::return
ZipEntry#setSize(long):::Sets the uncompressed size of the entry data.:::if->throw->new->IllegalArgumentException
ZipEntry#getSize():::Returns the uncompressed size of the entry data.:::return
ZipEntry#getCompressedSize():::Returns the size of the compressed entry data:::return
ZipEntry#setCompressedSize(long):::Sets the size of the compressed entry data.:::
ZipEntry#setCrc(long):::Sets the CRC-32 checksum of the uncompressed entry data.:::if->throw->new->IllegalArgumentException
ZipEntry#getCrc():::Returns the CRC-32 checksum of the uncompressed entry data.:::return
ZipEntry#setMethod(int):::Sets the compression method for the entry.:::if->throw->new->IllegalArgumentException
ZipEntry#getMethod():::Returns the compression method of the entry.:::return
ZipEntry#setExtra(byte[]):::Sets the optional extra field data for the entry:::setExtra0
ZipEntry#setExtra0(byte[], boolean):::Sets the optional extra field data for the entry.:::if->if->throw->new->IllegalArgumentException->off->len->while->tag->get16->sz->get16->if->break->switch->if->if->get64->get64->break->if->break->pos->if->get16->get16->break->wtime->get64->if->winTimeToFileTime->get64->if->winTimeToFileTime->get64->if->winTimeToFileTime->break->flag->Byte->toUnsignedInt->sz0->if->get32S->unixTimeToFileTime->if->get32S->unixTimeToFileTime->if->get32S->unixTimeToFileTime->break
ZipEntry#getExtra():::Returns the extra field data for the entry.:::return
ZipEntry#setComment(String):::Sets the optional comment string for the entry:::
ZipEntry#getComment():::Returns the comment string for the entry.:::return
ZipEntry#isDirectory():::Returns true if this is a directory entry:::return->name->endsWith
ZipEntry#toString():::Returns a string representation of the ZIP entry.:::return->getName
ZipEntry#hashCode():::Returns the hash code value for this entry.:::return->name->hashCode
ZipEntry#clone():::Returns a copy of this entry.:::try->e->super->clone->extra->clone->return->catch->throw->new->InternalError->finally
ZipFile#getComment():::Returns the zip file comment, or null if none.:::synchronized->ensureOpen->if->return->return->zc->toString
ZipFile#getEntry(String):::Returns the zip file entry for the specified name, or null if not found.:::return->ZipEntry->new->getEntry
ZipFile#getInputStream(ZipEntry):::Returns an input stream for reading the contents of the specified zip file entry:::Objects->requireNonNull->pos->in->zsrc->istreams->synchronized->ensureOpen->if->Objects->equals->else->if->zc->isUTF8->zsrc->zc->getBytesUTF8->getEntryPos->else->zsrc->zc->getBytes->getEntryPos->if->return->new->ZipFileInputStream->switch->CENHOW->synchronized->istreams->add->return->size->CENLEN->if->if->is->new->ZipFileInflaterInputStream->synchronized->istreams->add->return->throw->new->ZipException
ZipFile#getName():::Returns the path name of the ZIP file.:::return
ZipFile#entries():::Returns an enumeration of the ZIP file entries.:::synchronized->ensureOpen->return->ZipEntry->new->new->ZipEntryIterator<ZipEntry>
ZipFile#stream():::Returns an ordered Stream over the ZIP file entries:::synchronized->ensureOpen->return->StreamSupport->ZipEntry->new->getZipEntry->new->EntrySpliterator<>->stream
ZipFile#size():::Returns the number of entries in the ZIP file.:::synchronized->ensureOpen->return
ZipFile#close():::Closes the ZIP file:::if->return->synchronized->try->res->clean->catch->throw->ioe->getCause->finally
ZipFile#finalize():::Ensures that the system resources held by this ZipFile object are released when there are no more references to it.:::
ZipInputStream#getNextEntry():::Reads the next ZIP file entry and positions the stream at the beginning of the entry data.:::ensureOpen->if->closeEntry->crc->reset->inf->reset->if->readLOC->return->if->return
ZipInputStream#closeEntry():::Closes the current ZIP entry and positions the stream for reading the next entry.:::ensureOpen->while->read
ZipInputStream#available():::Returns 0 after EOF has reached for the current entry data, otherwise always return 1:::ensureOpen->if->return->else->return
ZipInputStream#read(byte[], int, int):::Reads from the current ZIP entry into an array of bytes:::ensureOpen->if->throw->new->IndexOutOfBoundsException->else->if->return->if->return->switch->super->read->if->readEnd->else->crc->update->return->if->return->if->in->read->if->throw->new->ZipException->crc->update->if->crc->getValue->throw->Long->toHexString->Long->crc->getValue->toHexString->new->ZipException->return->throw->new->ZipException
ZipInputStream#skip(long):::Skips specified number of bytes in the current ZIP entry.:::if->throw->new->IllegalArgumentException->ensureOpen->max->Math->min->total->while->len->if->read->if->break->return
ZipInputStream#close():::Closes this input stream and releases any system resources associated with the stream.:::if->super->close
ZipInputStream#createZipEntry(String):::Creates a new ZipEntry object for the specified entry name.:::return->new->ZipEntry
ZipOutputStream#setComment(String):::Sets the ZIP file comment.:::if->zc->getBytes->if->throw->new->IllegalArgumentException
ZipOutputStream#setMethod(int):::Sets the default compression method for subsequent entries:::if->throw->new->IllegalArgumentException
ZipOutputStream#setLevel(int):::Sets the compression level for subsequent entries which are DEFLATED:::def->setLevel
ZipOutputStream#putNextEntry(ZipEntry):::Begins writing a new ZIP file entry and positions the stream to the start of the entry data:::ensureOpen->if->closeEntry->if->e->System->currentTimeMillis->setTime->if->switch->if->break->if->else->if->else->if->throw->new->ZipException->if->throw->new->ZipException->break->throw->new->ZipException->if->names->add->throw->new->ZipException->if->zc->isUTF8->new->XEntry->xentries->add->writeLOC
ZipOutputStream#closeEntry():::Closes the current ZIP entry and positions the stream for writing the next entry.:::ensureOpen->if->e->switch->def->finish->while->def->finished->deflate->if->if->def->getBytesRead->throw->def->getBytesRead->new->ZipException->if->def->getBytesWritten->throw->def->getBytesWritten->new->ZipException->if->crc->getValue->throw->Long->toHexString->Long->crc->getValue->toHexString->new->ZipException->else->def->getBytesRead->def->getBytesWritten->crc->getValue->writeEXT->def->reset->break->if->throw->new->ZipException->if->crc->getValue->throw->Long->toHexString->Long->crc->getValue->toHexString->new->ZipException->break->throw->new->ZipException->crc->reset
ZipOutputStream#write(byte[], int, int):::Writes an array of bytes to the current ZIP entry data:::ensureOpen->if->throw->new->IndexOutOfBoundsException->else->if->return->if->throw->new->ZipException->entry->switch->super->write->break->if->throw->new->ZipException->out->write->break->throw->new->ZipException->crc->update
ZipOutputStream#finish():::Finishes writing the contents of the ZIP output stream without closing the underlying stream:::ensureOpen->if->return->if->closeEntry->off->foreach->writeCEN->writeEND
ZipOutputStream#close():::Closes the ZIP output stream as well as the stream being filtered.:::if->super->close
ZipUtils#winTimeToFileTime(long):::Converts Windows time (in microseconds, UTC/GMT) time to FileTime.:::return->FileTime->from
ZipUtils#fileTimeToWinTime(FileTime):::Converts FileTime to Windows time.:::return->ftime->to
ZipUtils#unixTimeToFileTime(long):::Converts "standard Unix time"(in seconds, UTC/GMT) to FileTime:::return->FileTime->from
ZipUtils#fileTimeToUnixTime(FileTime):::Converts FileTime to "standard Unix time".:::return->ftime->to
ZipUtils#dosToJavaTime(long):::Converts DOS time to Java time (number of milliseconds since epoch).:::year->month->day->hour->minute->second->if->try->ldt->LocalDateTime->of->return->ldt->ZoneId->systemDefault->getRules->getOffset->toEpochSecond->convert->catch->finally->return->overflowDosToJavaTime
ZipUtils#extendedDosToJavaTime(long):::Converts extended DOS time to Java time, where up to 1999 milliseconds might be encoded into the upper half of the returned long.:::time->dosToJavaTime->return
ZipUtils#javaToExtendedDosTime(long):::Converts Java time to DOS time, encoding any milliseconds lost in the conversion into the upper half of the returned long.:::if->return->dostime->javaToDosTime->return
ZipUtils#get16(byte[], int):::Fetches unsigned 16-bit value from byte array at specified offset:::return
ZipUtils#get32(byte[], int):::Fetches unsigned 32-bit value from byte array at specified offset:::return->get16->get16
ZipUtils#get64(byte[], int):::Fetches signed 64-bit value from byte array at specified offset:::return->get32->get32
ZipUtils#get32S(byte[], int):::Fetches signed 32-bit value from byte array at specified offset:::return->get16->get16
ZipUtils#loadLibrary():::Loads zip native library, if not already laoded:::sm->System->getSecurityManager->if->System->loadLibrary->else->pa->System->loadLibrary->return->AccessController->doPrivileged
