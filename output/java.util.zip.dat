java.util.zip.Adler32#update(int)->void:::Updates the checksum with the specified byte (the low eight bits of the argument b).
java.util.zip.Adler32#update(byte[], int, int)->void:::Updates the checksum with the specified array of bytes.
java.util.zip.Adler32#update(ByteBuffer)->void:::Updates the checksum with the bytes from the specified buffer
java.util.zip.Adler32#reset()->void:::Resets the checksum to initial value.
java.util.zip.Adler32#getValue()->long:::Returns the checksum value.
java.util.zip.CheckedInputStream#read()->int:::Reads a byte
java.util.zip.CheckedInputStream#read(byte[], int, int)->int:::Reads into an array of bytes
java.util.zip.CheckedInputStream#skip(long)->long:::Skips specified number of bytes of input.
java.util.zip.CheckedInputStream#getChecksum()->Checksum:::Returns the Checksum for this input stream.
java.util.zip.CheckedOutputStream#write(int)->void:::Writes a byte
java.util.zip.CheckedOutputStream#write(byte[], int, int)->void:::Writes an array of bytes
java.util.zip.CheckedOutputStream#getChecksum()->Checksum:::Returns the Checksum for this output stream.
java.util.zip.Checksum#update(int)->void:::Updates the current checksum with the specified byte.
java.util.zip.Checksum#update(byte[])->void:::Updates the current checksum with the specified array of bytes.
java.util.zip.Checksum#update(byte[], int, int)->void:::Updates the current checksum with the specified array of bytes.
java.util.zip.Checksum#update(ByteBuffer)->void:::Updates the current checksum with the bytes from the specified buffer
java.util.zip.Checksum#getValue()->long:::Returns the current checksum value.
java.util.zip.Checksum#reset()->void:::Resets the checksum to its initial value.
java.util.zip.CRC32#update(int)->void:::Updates the CRC-32 checksum with the specified byte (the low eight bits of the argument b).
java.util.zip.CRC32#update(byte[], int, int)->void:::Updates the CRC-32 checksum with the specified array of bytes.
java.util.zip.CRC32#update(ByteBuffer)->void:::Updates the CRC-32 checksum with the bytes from the specified buffer
java.util.zip.CRC32#reset()->void:::Resets CRC-32 to initial value.
java.util.zip.CRC32#getValue()->long:::Returns CRC-32 value.
java.util.zip.CRC32C#update(int)->void:::Updates the CRC-32C checksum with the specified byte (the low eight bits of the argument b).
java.util.zip.CRC32C#update(byte[], int, int)->void:::Updates the CRC-32C checksum with the specified array of bytes.
java.util.zip.CRC32C#update(ByteBuffer)->void:::Updates the CRC-32C checksum with the bytes from the specified buffer
java.util.zip.CRC32C#reset()->void:::Resets CRC-32C to initial value.
java.util.zip.CRC32C#getValue()->long:::Returns CRC-32C value.
java.util.zip.Deflater#setInput(byte[], int, int)->void:::Sets input data for compression
java.util.zip.Deflater#setInput(byte[])->void:::Sets input data for compression
java.util.zip.Deflater#setInput(ByteBuffer)->void:::Sets input data for compression
java.util.zip.Deflater#setDictionary(byte[], int, int)->void:::Sets preset dictionary for compression
java.util.zip.Deflater#setDictionary(byte[])->void:::Sets preset dictionary for compression
java.util.zip.Deflater#setDictionary(ByteBuffer)->void:::Sets preset dictionary for compression
java.util.zip.Deflater#setStrategy(int)->void:::Sets the compression strategy to the specified value
java.util.zip.Deflater#setLevel(int)->void:::Sets the compression level to the specified value
java.util.zip.Deflater#needsInput()->boolean:::Returns true if no data remains in the input buffer
java.util.zip.Deflater#finish()->void:::When called, indicates that compression should end with the current contents of the input buffer.
java.util.zip.Deflater#finished()->boolean:::Returns true if the end of the compressed data output stream has been reached.
java.util.zip.Deflater#deflate(byte[], int, int)->int:::Compresses the input data and fills specified buffer with compressed data
java.util.zip.Deflater#deflate(byte[])->int:::Compresses the input data and fills specified buffer with compressed data
java.util.zip.Deflater#deflate(ByteBuffer)->int:::Compresses the input data and fills specified buffer with compressed data
java.util.zip.Deflater#deflate(byte[], int, int, int)->int:::Compresses the input data and fills the specified buffer with compressed data
java.util.zip.Deflater#deflate(ByteBuffer, int)->int:::Compresses the input data and fills the specified buffer with compressed data
java.util.zip.Deflater#getAdler()->int:::Returns the ADLER-32 value of the uncompressed data.
java.util.zip.Deflater#getTotalIn()->int:::Returns the total number of uncompressed bytes input so far
java.util.zip.Deflater#getBytesRead()->long:::Returns the total number of uncompressed bytes input so far.
java.util.zip.Deflater#getTotalOut()->int:::Returns the total number of compressed bytes output so far
java.util.zip.Deflater#getBytesWritten()->long:::Returns the total number of compressed bytes output so far.
java.util.zip.Deflater#reset()->void:::Resets deflater so that a new set of input data can be processed
java.util.zip.Deflater#end()->void:::Closes the compressor and discards any unprocessed input
java.util.zip.Deflater#finalize()->void:::Closes the compressor when garbage is collected.
java.util.zip.Deflater.DeflaterZStreamRef#address()->long:::
java.util.zip.Deflater.DeflaterZStreamRef#clean()->void:::
java.util.zip.Deflater.DeflaterZStreamRef#run()->void:::
java.util.zip.Deflater.DeflaterZStreamRef#get(Deflater, long)->DeflaterZStreamRef:::
java.util.zip.DeflaterInputStream#close()->void:::Closes this input stream and its underlying input stream, discarding any pending uncompressed data.
java.util.zip.DeflaterInputStream#read()->int:::Reads a single byte of compressed data from the input stream
java.util.zip.DeflaterInputStream#read(byte[], int, int)->int:::Reads compressed data into a byte array
java.util.zip.DeflaterInputStream#skip(long)->long:::Skips over and discards data from the input stream
java.util.zip.DeflaterInputStream#available()->int:::Returns 0 after EOF has been reached, otherwise always return 1
java.util.zip.DeflaterInputStream#markSupported()->boolean:::Always returns false because this input stream does not support the {@link #mark mark()} and {@link #reset reset()} methods.
java.util.zip.DeflaterInputStream#mark(int)->void:::This operation is not supported.
java.util.zip.DeflaterInputStream#reset()->void:::This operation is not supported.
java.util.zip.DeflaterOutputStream#write(int)->void:::Writes a byte to the compressed output stream
java.util.zip.DeflaterOutputStream#write(byte[], int, int)->void:::Writes an array of bytes to the compressed output stream
java.util.zip.DeflaterOutputStream#finish()->void:::Finishes writing compressed data to the output stream without closing the underlying stream
java.util.zip.DeflaterOutputStream#close()->void:::Writes remaining compressed data to the output stream and closes the underlying stream.
java.util.zip.DeflaterOutputStream#deflate()->void:::Writes next block of compressed data to the output stream.
java.util.zip.DeflaterOutputStream#flush()->void:::Flushes the compressed output stream
java.util.zip.GZIPInputStream#read(byte[], int, int)->int:::Reads uncompressed data into an array of bytes
java.util.zip.GZIPInputStream#close()->void:::Closes this input stream and releases any system resources associated with the stream.
java.util.zip.GZIPOutputStream#write(byte[], int, int)->void:::Writes array of bytes to the compressed output stream
java.util.zip.GZIPOutputStream#finish()->void:::Finishes writing compressed data to the output stream without closing the underlying stream
java.util.zip.Inflater#setInput(byte[], int, int)->void:::Sets input data for decompression
java.util.zip.Inflater#setInput(byte[])->void:::Sets input data for decompression
java.util.zip.Inflater#setInput(ByteBuffer)->void:::Sets input data for decompression
java.util.zip.Inflater#setDictionary(byte[], int, int)->void:::Sets the preset dictionary to the given array of bytes
java.util.zip.Inflater#setDictionary(byte[])->void:::Sets the preset dictionary to the given array of bytes
java.util.zip.Inflater#setDictionary(ByteBuffer)->void:::Sets the preset dictionary to the bytes in the given buffer
java.util.zip.Inflater#getRemaining()->int:::Returns the total number of bytes remaining in the input buffer
java.util.zip.Inflater#needsInput()->boolean:::Returns true if no data remains in the input buffer
java.util.zip.Inflater#needsDictionary()->boolean:::Returns true if a preset dictionary is needed for decompression.
java.util.zip.Inflater#finished()->boolean:::Returns true if the end of the compressed data stream has been reached.
java.util.zip.Inflater#inflate(byte[], int, int)->int:::Uncompresses bytes into specified buffer
java.util.zip.Inflater#inflate(byte[])->int:::Uncompresses bytes into specified buffer
java.util.zip.Inflater#inflate(ByteBuffer)->int:::Uncompresses bytes into specified buffer
java.util.zip.Inflater#getAdler()->int:::Returns the ADLER-32 value of the uncompressed data.
java.util.zip.Inflater#getTotalIn()->int:::Returns the total number of compressed bytes input so far
java.util.zip.Inflater#getBytesRead()->long:::Returns the total number of compressed bytes input so far.
java.util.zip.Inflater#getTotalOut()->int:::Returns the total number of uncompressed bytes output so far
java.util.zip.Inflater#getBytesWritten()->long:::Returns the total number of uncompressed bytes output so far.
java.util.zip.Inflater#reset()->void:::Resets inflater so that a new set of input data can be processed.
java.util.zip.Inflater#end()->void:::Closes the decompressor and discards any unprocessed input
java.util.zip.Inflater#finalize()->void:::Closes the decompressor when garbage is collected.
java.util.zip.Inflater.InflaterZStreamRef#address()->long:::
java.util.zip.Inflater.InflaterZStreamRef#clean()->void:::
java.util.zip.Inflater.InflaterZStreamRef#run()->void:::
java.util.zip.Inflater.InflaterZStreamRef#get(Inflater, long)->InflaterZStreamRef:::
java.util.zip.InflaterInputStream#read()->int:::Reads a byte of uncompressed data
java.util.zip.InflaterInputStream#read(byte[], int, int)->int:::Reads uncompressed data into an array of bytes
java.util.zip.InflaterInputStream#available()->int:::Returns 0 after EOF has been reached, otherwise always return 1
java.util.zip.InflaterInputStream#skip(long)->long:::Skips specified number of bytes of uncompressed data.
java.util.zip.InflaterInputStream#close()->void:::Closes this input stream and releases any system resources associated with the stream.
java.util.zip.InflaterInputStream#fill()->void:::Fills input buffer with more data to decompress.
java.util.zip.InflaterInputStream#markSupported()->boolean:::Tests if this input stream supports the mark and reset methods
java.util.zip.InflaterInputStream#mark(int)->void:::Marks the current position in this input stream
java.util.zip.InflaterInputStream#reset()->void:::Repositions this stream to the position at the time the mark method was last called on this input stream
java.util.zip.InflaterOutputStream#close()->void:::Writes any remaining uncompressed data to the output stream and closes the underlying output stream.
java.util.zip.InflaterOutputStream#flush()->void:::Flushes this output stream, forcing any pending buffered output bytes to be written.
java.util.zip.InflaterOutputStream#finish()->void:::Finishes writing uncompressed data to the output stream without closing the underlying stream
java.util.zip.InflaterOutputStream#write(int)->void:::Writes a byte to the uncompressed output stream.
java.util.zip.InflaterOutputStream#write(byte[], int, int)->void:::Writes an array of bytes to the uncompressed output stream.
java.util.zip.ZipCoder.UTF8#isUTF8()->boolean:::
java.util.zip.ZipCoder.UTF8#toString(byte[], int, int)->String:::
java.util.zip.ZipCoder.UTF8#getBytes(String)->byte[]:::
java.util.zip.ZipCoder#get(Charset)->ZipCoder:::
java.util.zip.ZipCoder#toString(byte[], int, int)->String:::
java.util.zip.ZipCoder#toString(byte[], int)->String:::
java.util.zip.ZipCoder#toString(byte[])->String:::
java.util.zip.ZipCoder#getBytes(String)->byte[]:::
java.util.zip.ZipCoder#getBytesUTF8(String)->byte[]:::
java.util.zip.ZipCoder#toStringUTF8(byte[], int)->String:::
java.util.zip.ZipCoder#toStringUTF8(byte[], int, int)->String:::
java.util.zip.ZipCoder#isUTF8()->boolean:::
java.util.zip.ZipCoder#decoder()->CharsetDecoder:::
java.util.zip.ZipCoder#encoder()->CharsetEncoder:::
java.util.zip.ZipEntry#getName()->String:::Returns the name of the entry.
java.util.zip.ZipEntry#setTime(long)->void:::Sets the last modification time of the entry
java.util.zip.ZipEntry#getTime()->long:::Returns the last modification time of the entry
java.util.zip.ZipEntry#setTimeLocal(LocalDateTime)->void:::Sets the last modification time of the entry in local date-time
java.util.zip.ZipEntry#getTimeLocal()->LocalDateTime:::Returns the last modification time of the entry in local date-time
java.util.zip.ZipEntry#setLastModifiedTime(FileTime)->ZipEntry:::Sets the last modification time of the entry
java.util.zip.ZipEntry#getLastModifiedTime()->FileTime:::Returns the last modification time of the entry
java.util.zip.ZipEntry#setLastAccessTime(FileTime)->ZipEntry:::Sets the last access time of the entry
java.util.zip.ZipEntry#getLastAccessTime()->FileTime:::Returns the last access time of the entry
java.util.zip.ZipEntry#setCreationTime(FileTime)->ZipEntry:::Sets the creation time of the entry
java.util.zip.ZipEntry#getCreationTime()->FileTime:::Returns the creation time of the entry
java.util.zip.ZipEntry#setSize(long)->void:::Sets the uncompressed size of the entry data.
java.util.zip.ZipEntry#getSize()->long:::Returns the uncompressed size of the entry data.
java.util.zip.ZipEntry#getCompressedSize()->long:::Returns the size of the compressed entry data
java.util.zip.ZipEntry#setCompressedSize(long)->void:::Sets the size of the compressed entry data.
java.util.zip.ZipEntry#setCrc(long)->void:::Sets the CRC-32 checksum of the uncompressed entry data.
java.util.zip.ZipEntry#getCrc()->long:::Returns the CRC-32 checksum of the uncompressed entry data.
java.util.zip.ZipEntry#setMethod(int)->void:::Sets the compression method for the entry.
java.util.zip.ZipEntry#getMethod()->int:::Returns the compression method of the entry.
java.util.zip.ZipEntry#setExtra(byte[])->void:::Sets the optional extra field data for the entry
java.util.zip.ZipEntry#setExtra0(byte[], boolean)->void:::Sets the optional extra field data for the entry.
java.util.zip.ZipEntry#getExtra()->byte[]:::Returns the extra field data for the entry.
java.util.zip.ZipEntry#setComment(String)->void:::Sets the optional comment string for the entry
java.util.zip.ZipEntry#getComment()->String:::Returns the comment string for the entry.
java.util.zip.ZipEntry#isDirectory()->boolean:::Returns true if this is a directory entry
java.util.zip.ZipEntry#toString()->String:::Returns a string representation of the ZIP entry.
java.util.zip.ZipEntry#hashCode()->int:::Returns the hash code value for this entry.
java.util.zip.ZipEntry#clone()->Object:::Returns a copy of this entry.
java.util.zip.ZipFile#getComment()->String:::Returns the zip file comment, or null if none.
java.util.zip.ZipFile#getEntry(String)->ZipEntry:::Returns the zip file entry for the specified name, or null if not found.
java.util.zip.ZipFile#getInputStream(ZipEntry)->InputStream:::Returns an input stream for reading the contents of the specified zip file entry
java.util.zip.ZipFile#getName()->String:::Returns the path name of the ZIP file.
java.util.zip.ZipFile#entries()->Enumeration<? extends ZipEntry>:::Returns an enumeration of the ZIP file entries.
java.util.zip.ZipFile#stream()->Stream<? extends ZipEntry>:::Returns an ordered Stream over the ZIP file entries
java.util.zip.ZipFile#size()->int:::Returns the number of entries in the ZIP file.
java.util.zip.ZipFile#close()->void:::Closes the ZIP file
java.util.zip.ZipFile#finalize()->void:::Ensures that the system resources held by this ZipFile object are released when there are no more references to it.
java.util.zip.ZipInputStream#getNextEntry()->ZipEntry:::Reads the next ZIP file entry and positions the stream at the beginning of the entry data.
java.util.zip.ZipInputStream#closeEntry()->void:::Closes the current ZIP entry and positions the stream for reading the next entry.
java.util.zip.ZipInputStream#available()->int:::Returns 0 after EOF has reached for the current entry data, otherwise always return 1
java.util.zip.ZipInputStream#read(byte[], int, int)->int:::Reads from the current ZIP entry into an array of bytes
java.util.zip.ZipInputStream#skip(long)->long:::Skips specified number of bytes in the current ZIP entry.
java.util.zip.ZipInputStream#close()->void:::Closes this input stream and releases any system resources associated with the stream.
java.util.zip.ZipInputStream#createZipEntry(String)->ZipEntry:::Creates a new ZipEntry object for the specified entry name.
java.util.zip.ZipOutputStream#setComment(String)->void:::Sets the ZIP file comment.
java.util.zip.ZipOutputStream#setMethod(int)->void:::Sets the default compression method for subsequent entries
java.util.zip.ZipOutputStream#setLevel(int)->void:::Sets the compression level for subsequent entries which are DEFLATED
java.util.zip.ZipOutputStream#putNextEntry(ZipEntry)->void:::Begins writing a new ZIP file entry and positions the stream to the start of the entry data
java.util.zip.ZipOutputStream#closeEntry()->void:::Closes the current ZIP entry and positions the stream for writing the next entry.
java.util.zip.ZipOutputStream#write(byte[], int, int)->void:::Writes an array of bytes to the current ZIP entry data
java.util.zip.ZipOutputStream#finish()->void:::Finishes writing the contents of the ZIP output stream without closing the underlying stream
java.util.zip.ZipOutputStream#close()->void:::Closes the ZIP output stream as well as the stream being filtered.
java.util.zip.ZipUtils#winTimeToFileTime(long)->FileTime:::Converts Windows time (in microseconds, UTC/GMT) time to FileTime.
java.util.zip.ZipUtils#fileTimeToWinTime(FileTime)->long:::Converts FileTime to Windows time.
java.util.zip.ZipUtils#unixTimeToFileTime(long)->FileTime:::Converts "standard Unix time"(in seconds, UTC/GMT) to FileTime
java.util.zip.ZipUtils#fileTimeToUnixTime(FileTime)->long:::Converts FileTime to "standard Unix time".
java.util.zip.ZipUtils#dosToJavaTime(long)->long:::Converts DOS time to Java time (number of milliseconds since epoch).
java.util.zip.ZipUtils#extendedDosToJavaTime(long)->long:::Converts extended DOS time to Java time, where up to 1999 milliseconds might be encoded into the upper half of the returned long.
java.util.zip.ZipUtils#javaToExtendedDosTime(long)->long:::Converts Java time to DOS time, encoding any milliseconds lost in the conversion into the upper half of the returned long.
java.util.zip.ZipUtils#get16(byte[], int)->int:::Fetches unsigned 16-bit value from byte array at specified offset
java.util.zip.ZipUtils#get32(byte[], int)->long:::Fetches unsigned 32-bit value from byte array at specified offset
java.util.zip.ZipUtils#get64(byte[], int)->long:::Fetches signed 64-bit value from byte array at specified offset
java.util.zip.ZipUtils#get32S(byte[], int)->int:::Fetches signed 32-bit value from byte array at specified offset
java.util.zip.ZipUtils#CH(byte[], int)->int:::
java.util.zip.ZipUtils#SH(byte[], int)->int:::
java.util.zip.ZipUtils#LG(byte[], int)->long:::
java.util.zip.ZipUtils#LL(byte[], int)->long:::
java.util.zip.ZipUtils#GETSIG(byte[])->long:::
java.util.zip.ZipUtils#LOCSIG(byte[])->long:::
java.util.zip.ZipUtils#LOCVER(byte[])->int:::
java.util.zip.ZipUtils#LOCFLG(byte[])->int:::
java.util.zip.ZipUtils#LOCHOW(byte[])->int:::
java.util.zip.ZipUtils#LOCTIM(byte[])->long:::
java.util.zip.ZipUtils#LOCCRC(byte[])->long:::
java.util.zip.ZipUtils#LOCSIZ(byte[])->long:::
java.util.zip.ZipUtils#LOCLEN(byte[])->long:::
java.util.zip.ZipUtils#LOCNAM(byte[])->int:::
java.util.zip.ZipUtils#LOCEXT(byte[])->int:::
java.util.zip.ZipUtils#EXTCRC(byte[])->long:::
java.util.zip.ZipUtils#EXTSIZ(byte[])->long:::
java.util.zip.ZipUtils#EXTLEN(byte[])->long:::
java.util.zip.ZipUtils#ENDSUB(byte[])->int:::
java.util.zip.ZipUtils#ENDTOT(byte[])->int:::
java.util.zip.ZipUtils#ENDSIZ(byte[])->long:::
java.util.zip.ZipUtils#ENDOFF(byte[])->long:::
java.util.zip.ZipUtils#ENDCOM(byte[])->int:::
java.util.zip.ZipUtils#ENDCOM(byte[], int)->int:::
java.util.zip.ZipUtils#ZIP64_ENDTOD(byte[])->long:::
java.util.zip.ZipUtils#ZIP64_ENDTOT(byte[])->long:::
java.util.zip.ZipUtils#ZIP64_ENDSIZ(byte[])->long:::
java.util.zip.ZipUtils#ZIP64_ENDOFF(byte[])->long:::
java.util.zip.ZipUtils#ZIP64_LOCOFF(byte[])->long:::
java.util.zip.ZipUtils#CENSIG(byte[], int)->long:::
java.util.zip.ZipUtils#CENVEM(byte[], int)->int:::
java.util.zip.ZipUtils#CENVER(byte[], int)->int:::
java.util.zip.ZipUtils#CENFLG(byte[], int)->int:::
java.util.zip.ZipUtils#CENHOW(byte[], int)->int:::
java.util.zip.ZipUtils#CENTIM(byte[], int)->long:::
java.util.zip.ZipUtils#CENCRC(byte[], int)->long:::
java.util.zip.ZipUtils#CENSIZ(byte[], int)->long:::
java.util.zip.ZipUtils#CENLEN(byte[], int)->long:::
java.util.zip.ZipUtils#CENNAM(byte[], int)->int:::
java.util.zip.ZipUtils#CENEXT(byte[], int)->int:::
java.util.zip.ZipUtils#CENCOM(byte[], int)->int:::
java.util.zip.ZipUtils#CENDSK(byte[], int)->int:::
java.util.zip.ZipUtils#CENATT(byte[], int)->int:::
java.util.zip.ZipUtils#CENATX(byte[], int)->long:::
java.util.zip.ZipUtils#CENOFF(byte[], int)->long:::
java.util.zip.ZipUtils#loadLibrary()->void:::Loads zip native library, if not already laoded
java.util.zip.ZipUtils#getBufferArray(ByteBuffer)->byte[]:::
java.util.zip.ZipUtils#getBufferOffset(ByteBuffer)->int:::
