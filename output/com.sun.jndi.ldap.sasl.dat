DefaultCallbackHandler#handle(Callback[])::: default callback handler handle:::for->i
DefaultCallbackHandler#clearPassword()::: default callback handler clear password:::if->for->i
DefaultCallbackHandler#finalize()::: default callback handler finalize:::clearPassword
LdapSasl#saslBind(LdapClient, Connection, String, String, Object, String, Hashtable, Control[]):::Performs SASL bind:::saslClnt->cleanupHandler->cbh->env->get->if->env->get->new->DefaultCallbackHandler->authzId->env->get->mechs->getSaslMechanismNames->try->Sasl->createSaslClient->if->throw->new->AuthenticationNotSupportedException->res->mechName->saslClnt->getMechanismName->response->saslClnt->hasInitialResponse->saslClnt->evaluateChallenge->clnt->ldapBind->while->saslClnt->isComplete->saslClnt->evaluateChallenge->if->if->throw->new->AuthenticationException->break->clnt->ldapBind->if->if->saslClnt->isComplete->throw->new->AuthenticationException->qop->saslClnt->getNegotiatedProperty->if->qop->equalsIgnoreCase->qop->equalsIgnoreCase->newIn->new->SaslInputStream->newOut->new->SaslOutputStream->conn->replaceStreams->else->saslClnt->dispose->return->catch->ne->new->AuthenticationException->ne->setRootCause->throw->finally->if->clearPassword
LdapSasl#getSaslMechanismNames(String):::Returns an array of SASL mechanisms given a string of space separated SASL mechanism names.:::parser->new->StringTokenizer->mechs->new->Vector<>->while->parser->hasMoreTokens->mechs->parser->nextToken->addElement->mechNames->mechs->size->new->StringArr->for->i->mechs->size->return
SaslInputStream#read()::: sasl input stream read:::inBuf->new->byteArr->count->read->if->return->else->return
SaslInputStream#read(byte[], int, int)::: sasl input stream read:::if->actual->fill->while->fill->if->return->avail->if->System->arraycopy->return->else->System->arraycopy->return
SaslInputStream#fill():::Fills the buf with more data by reading a SASL buffer, unwrapping it, and leaving the bytes in buf for read() to return.:::actual->readFully->if->return->len->networkByteOrderToInt->if->throw->new->IOException->if->println->readFully->if->throw->new->EOFException->sc->unwrap->return
SaslInputStream#readFully(byte[], int):::Read requested number of bytes before returning.:::count->pos->if->println->while->in->read->if->println->if->return->return
SaslInputStream#available()::: sasl input stream available:::return
SaslInputStream#close()::: sasl input stream close:::save->try->sc->dispose->catch->finally->in->close->if->throw
SaslInputStream#networkByteOrderToInt(byte[], int, int)::: sasl input stream network byte order to int:::if->throw->new->IllegalArgumentException->answer->for->i->return
SaslOutputStream#write(int)::: sasl output stream write:::buffer->new->byteArr->write
SaslOutputStream#write(byte[], int, int):::Override this method to "wrap" the outgoing buffer before writing it to the underlying output stream.:::count->wrappedToken->saslBuffer->if->println->for->i
SaslOutputStream#close()::: sasl output stream close:::save->try->sc->dispose->catch->finally->super->close->if->throw
SaslOutputStream#intToNetworkByteOrder(int, byte[], int, int):::Encodes an integer into 4 bytes in network byte order in the buffer supplied.:::if->throw->new->IllegalArgumentException->for->i
