Analyzer.StatementAnalyzer#isEnabled():::Is this analyzer allowed to run?:::return->analyzerModes->contains
Analyzer.StatementAnalyzer#match(S):::Should this analyzer be rewriting the given tree?:::
Analyzer.StatementAnalyzer#rewrite(S):::Rewrite a given AST node into a new one(s):::
Analyzer.StatementAnalyzer#process(S, T, boolean):::Entry-point for comparing results and generating diagnostics.:::
Analyzer.RedundantLocalVarTypeAnalyzerBase#rewriteVarType(JCVariableDecl):::Map a variable tree into a new declaration using implicit type.:::newTree->copier->copy->return
Analyzer.RedundantLocalVarTypeAnalyzerBase#processVar(JCVariableDecl, JCVariableDecl, boolean):::Analyze results of local variable inference.:::if->if->types->isSameType->log->warning
Analyzer#copyEnvIfNeeded(JCTree, Env):::Create a copy of Env if needed.:::if->analyzerModes->isEmpty->TreeInfo->isStatement->tree->hasTag->analyzeEnv->env->dupUnshared->dup->dup->attr->new->ResultInfo->return->else->return
Analyzer#analyzeIfNeeded(JCTree, Env):::Analyze an AST node if needed.:::if->stmt->analyze
Analyzer#analyze(JCStatement, Env):::Analyze an AST node; this involves collecting a list of all the nodes that needs rewriting, and speculatively type-check the rewritten code to compare results against previously attributed code.:::statementScanner->new->StatementScanner->statementScanner->scan->if->isEmpty->foreach->deferredAnalysisHelper->queue
Analyzer.DeferredAnalysisHelper#queue(RewritingContext):::Add a new analysis task to the queue.:::
Analyzer.DeferredAnalysisHelper#flush(Env):::Flush queue with given attribution env.:::
Analyzer.RewritingContext#diagHandler():::Simple deferred diagnostic handler which filters out all messages and keep track of errors.:::return->if->d->getType->return->new->Log.DeferredDiagnosticHandler
Annotate#blockAnnotations():::Called when annotations processing needs to be postponed.:::
Annotate#unblockAnnotations():::Called when annotation processing can be resumed.:::if->flush
Annotate#unblockAnnotationsNoFlush():::Variant which allows for a delayed flush of annotations:::
Annotate#annotationsBlocked():::are we blocking annotation processing?:::return
Annotate#normal(Runnable):::Annotate (used for everything else):::q->append
Annotate#validate(Runnable):::Validate, triggers after 'normal':::validateQ->append
Annotate#flush():::Flush all annotation queues:::if->annotationsBlocked->return->if->isFlushing->return->startFlushing->try->while->q->nonEmpty->q->next->run->while->typesQ->nonEmpty->typesQ->next->run->while->afterTypesQ->nonEmpty->afterTypesQ->next->run->while->validateQ->nonEmpty->validateQ->next->run->catch->finally->doneFlushing
Annotate#annotateLater(List, Env, Symbol, DiagnosticPosition):::Queue annotations for later attribution and entering:::if->annotations->isEmpty->return->s->resetAnnotations->Assert->s->annotationsPendingCompletion->check->prev->log->useSource->prevLintPos->deferredLintHandler->setPos->deferredLintHandler->immediate->prevLint->chk->setLint->try->if->s->hasAnnotations->annotations->nonEmpty->log->Errors->Kinds->kindName->AlreadyAnnotated->error->Assert->checkNonNull->annotateNow->catch->finally->if->chk->setLint->deferredLintHandler->setPos->log->useSource->normal->prev->log->useSource->try->chk->validateAnnotations->catch->finally->log->useSource->validate
Annotate#annotateDefaultValueLater(JCExpression, Env, MethodSymbol, DiagnosticPosition):::Queue processing of an attribute default value.:::prev->log->useSource->prevLintPos->deferredLintHandler->setPos->try->enterDefaultValue->catch->finally->deferredLintHandler->setPos->log->useSource->normal->prev->log->useSource->try->chk->validateAnnotationTree->catch->finally->log->useSource->validate
Annotate#attributeAnnotation(JCAnnotation, Type, Env):::Attribute and store a semantic representation of the annotation tree tree into the tree.attribute field.:::if->return->elems->attributeAnnotationValues->ac->new->Attribute.Compound->return
Annotate#attributeTypeAnnotation(JCAnnotation, Type, Env):::Attribute and store a semantic representation of the type annotation tree tree into the tree.attribute field.:::if->elems->attributeAnnotationValues->tc->new->Attribute.TypeCompound->return->else->return
Annotate#enterTypeAnnotations(List, Env, Symbol, DiagnosticPosition, boolean):::Attribute the list of annotations and enter them onto s.:::Assert->checkNonNull->prev->log->useSource->prevLintPos->if->deferredLintHandler->setPos->try->annotateNow->catch->finally->if->deferredLintHandler->setPos->log->useSource
Annotate#queueScanTreeAndTypeAnnotate(JCTree, Env, Symbol, DiagnosticPosition):::Enqueue tree for scanning of type annotations, attaching to the Symbol sym.:::Assert->checkNonNull->tree->new->TypeAnnotate->accept->normal
Annotate#annotateTypeSecondStage(JCTree, List, Type):::Apply the annotations to the particular type.:::compounds->fromAnnotations->Assert->annotations->size->compounds->size->check->storeAt->getMetadataOfKind->new->TypeMetadata.Annotations->combine->typeAnnotation
Annotate#annotateTypeParameterSecondStage(JCTree, List):::Apply the annotations to the particular type.:::compounds->fromAnnotations->Assert->annotations->size->compounds->size->check->typeAnnotation
ArgumentAttr#setResult(JCExpression, Type):::Set the results of method attribution.:::if
ArgumentAttr#checkSpeculative(JCExpression, ResultInfo):::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.:::return->checkSpeculative
ArgumentAttr#checkSpeculative(DiagnosticPosition, Type, ResultInfo):::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.:::if->t->hasTag->return->check->else->return->resultInfo->check
ArgumentAttr#withLocalCacheContext():::Returns a local caching context in which argument types can safely be cached without the risk of polluting enclosing contexts:::return->new->LocalCacheContext
ArgumentAttr#attribArg(JCTree, Env):::Main entry point for attributing an argument with given tree and attribution environment.:::prevEnv->try->tree->accept->return->catch->finally
ArgumentAttr#processArg(T, Function):::Process a method argument; this method takes care of performing a speculative pass over the argument tree and calling a well-defined entry point to build the argument type associated with such tree.:::pos->new->UniquePos->speculativeTree->deferredAttr->attr->new->MethodAttrInfo->attribSpeculative->return->argumentTypeFactory->apply->processArg
ArgumentAttr#processArg(T, Supplier):::Process a method argument; this method allows the caller to specify a custom speculative attribution logic (this is used e.g:::pos->new->UniquePos->cached->argumentTypeCache->get->if->cached->dup->setResult->else->res->argumentTypeFactory->get->argumentTypeCache->put->setResult
ArgumentAttr.ArgumentType#overloadCheck(ResultInfo, DeferredAttrContext):::Performs an overload check against a given target result.:::
ArgumentAttr.ArgumentType#dup(T, Env):::Creates a copy of this argument type with given tree and environment.:::
ArgumentAttr.ExplicitLambdaType#argtypes():::Compute argument types (if needed).:::return->argtypes->res->TreeInfo->types->Optional->of->return->orElseGet
ArgumentAttr.ExplicitLambdaType#returnExpressions():::Compute return expressions (if needed).:::return->returnExpressions->res->buf->new->ListBuffer<>->new->LambdaReturnScanner->scan->buf->toList->Optional->of->return->orElseGet
ArgumentAttr.ExplicitLambdaType#checkReturnInStatementLambda(JCReturn, ResultInfo):::This is an inlined version of Attr#visitReturn(JCReturn).:::if->hasTag->speculativeTree->pos->diags->fragment->report->else->if->hasTag->if->speculativeTree->pos->diags->fragment->report->checkSpeculative
ArgumentAttr.ExplicitLambdaType#getReturnType(JCReturn):::Get the type associated with given return expression.:::if->return->else->return
ArgumentAttr.ResolvedMemberType#resultInfo(ResultInfo):::Get the result info to be used for performing an overload check.:::
ArgumentAttr.ResolvedMemberType#methodType():::Get the method type to be used for performing an overload check.:::
Attr#check(JCTree, Type, KindSelector, ResultInfo):::Check kind and type of given tree against protokind and prototype:::inferenceContext->inferenceContext->owntype->shouldCheck->found->hasTag->hasTag->hasTag->if->ownkind->subset->log->tree->pos->Errors->kindNames->ownkind->kindNames->UnexpectedType->error->types->createErrorType->else->if->inferenceContext->free->if->installPostInferenceHook->inferenceContext->List->of->pendingResult->resultInfo->inferenceContext->asInstType->dup->inferenceContext->asInstType->check->addFreeTypeListener->else->resultInfo->check->if->updateTreeType->return
Attr#isAssignableAsBlankFinal(VarSymbol, Env):::Is given blank final variable assignable, i.e:::owner->return->owner->flags->v->flags->Resolve->isStatic
Attr#checkAssignable(DiagnosticPosition, VarSymbol, JCTree, Env):::Check that variable can be assigned to.:::if->log->error->else->if->v->flags->v->flags->TreeInfo->isThisQualifier->isAssignableAsBlankFinal->if->v->isResourceVariable->log->Errors->TryResourceMayNotBeAssigned->error->else->log->Errors->CantAssignValToFinalVar->error
Attr#isStaticReference(JCTree):::Does tree represent a static reference to an identifier?  It is assumed that tree is either a SELECT or an IDENT:::if->tree->hasTag->lsym->TreeInfo->symbol->if->return->return
Attr#isType(Symbol):::Is this symbol a type?:::return
Attr#thisSym(DiagnosticPosition, Env):::The current `this' symbol.:::return->rs->resolveSelf
Attr#attribIdent(JCTree, JCCompilationUnit):::Attribute a parsed identifier.:::localEnv->enter->topLevelEnv->make->make->Modifiers->ClassDef->return->attribIdent
Attr#attribIdent(JCTree, Env):::Attribute a parsed identifier.:::return->tree->accept
Attr.ResultInfo#needsArgumentAttr(JCTree):::Should Attr#attribTree use the  visitor instead of this one?:::return
Attr#attribTree(JCTree, Env, ResultInfo):::Visitor method: attribute a tree, catching any completion failure  exceptions:::prevEnv->prevResult->try->if->resultInfo->needsArgumentAttr->argumentAttr->attribArg->else->tree->accept->if->deferredAttrContext->throw->copyEnv->new->BreakAttr->return->catch->return->chk->tree->pos->completionError->finally
Attr#attribExpr(JCTree, Env, Type):::Derived visitor method: attribute an expression tree.:::return->pt->hasTag->new->ResultInfo->attribTree
Attr#attribExpr(JCTree, Env):::Derived visitor method: attribute an expression tree with  no constraints on the computed type.:::return->attribTree
Attr#attribType(JCTree, Env):::Derived visitor method: attribute a type tree.:::result->attribType->return
Attr#attribType(JCTree, Env, Type):::Derived visitor method: attribute a type tree.:::result->new->ResultInfo->attribTree->return
Attr#attribStat(JCTree, Env):::Derived visitor method: attribute a statement or definition tree.:::analyzeEnv->analyzer->copyEnvIfNeeded->try->return->attribTree->catch->finally->analyzer->analyzeIfNeeded
Attr#attribExprs(List, Env, Type):::Attribute a list of expressions, returning a list of types.:::ts->new->ListBuffer<>->for->l->l->nonEmpty->return->ts->toList
Attr#attribStats(List, Env):::Attribute a list of statements, returning nothing.:::for->l->l->nonEmpty
Attr#attribArgs(KindSelector, List, Env, ListBuffer):::Attribute the arguments in a method call, returning the method kind.:::kind->foreach->argtype->chk->attribTree->checkNonVoid->if->argtype->hasTag->KindSelector->of->argtypes->append->return
Attr#attribAnyTypes(List, Env):::Attribute a type argument list, returning a list of types:::argtypes->new->ListBuffer<>->for->l->l->nonEmpty->return->argtypes->toList
Attr#attribTypes(List, Env):::Attribute a type argument list, returning a list of types:::types->attribAnyTypes->return->chk->checkRefTypes
Attr#attribTypeVariables(List, Env):::Attribute type variables (of generic classes or methods):::foreach->a->if->isEmpty->bounds->List->attribType->of->foreach->bounds->attribType->prepend->types->bounds->reverse->setBounds->else->types->List->of->setBounds->foreach->chk->tvar->pos->checkNonCyclic
Attr#attribAnnotationTypes(List, Env):::Attribute the type references in a list of annotations.:::for->al->al->nonEmpty
Attr#attribLazyConstantValue(Env, JCVariableDecl, Type):::Attribute a "lazy constant value".:::prevLintPos->deferredLintHandler->variable->pos->setPos->prevSource->log->useSource->try->itype->attribExpr->if->variable->isImplicitlyTyped->chk->itype->baseType->checkLocalVarType->if->itype->constValue->return->coerce->constValue->else->return->catch->finally->log->useSource->deferredLintHandler->setPos
Attr#attribBase(JCTree, Env, boolean, boolean, boolean):::Attribute type reference in an `extends' or `implements' clause:::t->attribType->return->checkBase
Attr#condType(DiagnosticPosition, Type, Type):::Compute the type of a conditional expression, after  checking that it exists:::if->types->isSameType->return->thentype->baseType->thenUnboxed->thentype->isPrimitive->types->unboxedType->elseUnboxed->elsetype->isPrimitive->types->unboxedType->if->thenUnboxed->isPrimitive->elseUnboxed->isPrimitive->if->thenUnboxed->getTag->isStrictSubRangeOf->elseUnboxed->hasTag->types->isAssignable->return->thenUnboxed->baseType->if->elseUnboxed->getTag->isStrictSubRangeOf->thenUnboxed->hasTag->types->isAssignable->return->elseUnboxed->baseType->foreach->candidate->tag->ordinal->if->types->isSubtype->types->isSubtype->return->if->thentype->isPrimitive->types->boxedClass->if->elsetype->isPrimitive->types->boxedClass->if->types->isSubtype->return->elsetype->baseType->if->types->isSubtype->return->thentype->baseType->if->thentype->hasTag->elsetype->hasTag->log->Errors->NeitherConditionalSubtype->error->return->thentype->baseType->return->types->thentype->baseType->elsetype->baseType->lub
Attr#visitApply(JCMethodInvocation):::Visitor method for method invocations:::localEnv->env->dup->dup->argtypes->typeargtypes->methName->TreeInfo->name->isConstructorCall->argtypesBuf->new->ListBuffer<>->if->if->checkFirstConstructorStat->kind->attribArgs->argtypesBuf->toList->attribTypes->site->if->if->log->pos->Errors->NoSuperclass->error->types->createErrorType->else->types->supertype->if->site->hasTag->encl->site->getEnclosingType->while->encl->hasTag->encl->getUpperBound->if->encl->hasTag->if->hasTag->qualifier->chk->qualifier->pos->attribExpr->checkRefType->else->if->rs->pos->resolveImplicitThis->else->if->hasTag->log->pos->Errors->IllegalQualNotIcls->error->if->argtypes->prepend->prepend->selectSuperPrev->sym->rs->pos->resolveConstructor->TreeInfo->setSymbol->mpt->newMethodTemplate->new->ResultInfo->checkId->else->kind->attribArgs->argtypesBuf->toList->attribAnyTypes->mpt->newMethodTemplate->mtype->new->ResultInfo->attribTree->restype->mtype->getReturnType->if->restype->hasTag->throw->new->AssertionError->qualifier->hasTag->msym->TreeInfo->symbol->adjustMethodReturnType->chk->checkRefTypes->capturedRes->inferenceContext->cachedCapture->check->chk->validate
Attr#checkFirstConstructorStat(JCMethodInvocation, Env):::Check that given application node appears as first statement  in a constructor call.:::enclMethod->if->body->if->hasTag->return->log->tree->pos->Errors->TreeInfo->name->CallMustBeFirstStmtInCtor->error->return
Attr#newMethodTemplate(Type, List, List):::Obtain a method type with given argument types.:::mt->List->nil->new->MethodType->return->new->ForAll
Attr#makeNullCheck(JCExpression):::Make an attributed null check tree.:::if->arg->getTag->return->name->TreeInfo->name->if->return->optag->tree->make->at->Unary->operators->resolveUnary->return
Attr#checkLambdaCompatible(JCLambda, Type, CheckContext):::Lambda compatibility:::returnType->checkContext->inferenceContext->descriptor->getReturnType->asUndetVar->if->tree->getBodyKind->returnType->hasTag->msg->Fragments->Fragments->MissingRetVal->IncompatibleRetTypeInLambda->checkContext->diags->fragment->report->argTypes->checkContext->inferenceContext->descriptor->getParameterTypes->asUndetVars->if->types->TreeInfo->types->isSameTypes->checkContext->diags->fragment->report
Attr#checkId(JCTree, Type, Symbol, Env, ResultInfo):::Determine type of identifier or select expression and check that  (1) the referenced symbol is not deprecated  (2) the symbol's type is safe (@see checkSafe)  (3) if symbol is a variable, check that its type and kind are      compatible with the prototype and protokind:::return->hasTag->hasTag->checkMethodIdInternal->checkIdInternal
Attr#enclosingInitEnv(Env):::Returns the enclosing init environment associated with this env (if any):::while->switch->getTag->vdecl->if->return->break->if->hasTag->return->break->return->Assert->checkNonNull
Attr#checkMethod(Type, Symbol, ResultInfo, Env, List, List, List):::Check that method arguments conform to its instantiation.:::if->sym->flags->site->hasTag->site->hasTag->s->types->asOuterSuper->if->s->isRaw->types->getParameterTypes->sym->erasure->getParameterTypes->isSameTypes->chk->pos->Warnings->UncheckedCallMbrOfRawType->warnUnchecked->if->foreach->types->interfaces->types->supertype->prepend->if->sym->enclClass->isSubClass->types->isSameType->continue->icand_sup->types->interfaceCandidates->if->icand_sup->nonEmpty->enclClass->overrides->log->pos->Errors->Fragments->OverriddenDefault->IllegalDefaultSuperCall->error->break->if->sym->isStatic->site->isInterface->hasTag->app->if->hasTag->TreeInfo->isStaticSelector->log->pos->Errors->IllegalStaticIntfMethCall->error->noteWarner->new->Warner->try->owntype->rs->checkMethod->checkDeferredMap->deferredAttr->new->DeferredTypeMap->argtypes->map->if->noteWarner->hasNonSilentLint->chk->pos->Warnings->kindName->rs->getParameterTypes->methodArguments->rs->argtypes->map->methodArguments->sym->location->kindName->sym->location->UncheckedMethInvocationApplied->warnUnchecked->if->owntype->hasTag->owntype->isPartial->owntype->getParameterTypes->types->owntype->getReturnType->erasure->types->owntype->getThrownTypes->erasure->new->MethodType->pkind->hasTag->getReturnType->containsAny->TreeInfo->setPolyKind->return->chk->lastResolveVarargs->inferenceContext->checkMethod->catch->pos->ex->getDiagnostic->report->return->types->createErrorType->diag->ex->getDiagnostic->errSym->rs->new->InapplicableSymbolError->argtypes2->argtypes->rs->new->ResolveDeferredRecoveryMap->map->errDiag->errSym->getDiagnostic->log->report->return->types->createErrorType->finally
Attr#litType(TypeTag):::Return the type of a literal with given type tag.:::return->tag->ordinal
Attr#visitTypeApply(JCTypeApply):::Visitor method for parameterized types:::owntype->types->createErrorType->clazztype->chk->pos->attribType->checkClassType->actuals->attribTypes->if->clazztype->hasTag->formals->getTypeArguments->if->actuals->isEmpty->if->actuals->length->formals->length->a->f->while->a->nonEmpty->withTypeVar->clazzOuter->clazztype->getEnclosingType->if->clazzOuter->hasTag->site->clazz->TreeInfo->typeIn->if->clazz->hasTag->else->if->clazz->hasTag->else->throw->new->AssertionError->if->clazzOuter->hasTag->if->site->hasTag->types->asOuterSuper->if->types->erasure->clazztype->getMetadata->new->ClassType->else->if->formals->length->log->tree->pos->Errors->Integer->formals->length->toString->WrongNumberTypeArgs->error->else->log->tree->pos->Errors->TypeDoesntTakeParams->error->types->createErrorType->check
Attr#visitTree(JCTree):::Default visitor method for all other trees.:::throw->new->AssertionError
Attr#attrib(Env):::Attribute an env for either a top level tree or class or module declaration.:::switch->getTag->pos->attribModule->break->attribTopLevel->break->pos->attribPackage->break->pos->attribClass
Attr#attribTopLevel(Env):::Attribute a top level tree:::toplevel->try->annotate->flush->catch->chk->toplevel->pos->completionError->finally
Attr#attribClass(DiagnosticPosition, ClassSymbol):::Main method: attribute class definition associated with given class symbol:::try->annotate->flush->attribClass->catch->chk->completionError->finally
Attr#attribClass(ClassSymbol):::Attribute class definition associated with given class symbol.:::if->hasTag->return->chk->checkNonCyclic->st->types->supertype->if->if->st->hasTag->attribClass->if->hasTag->attribClass->if->env->typeEnvs->get->lintEnv->while->augment->prevLint->chk->setLint->prev->log->useSource->prevReturnRes->try->deferredLintHandler->flush->if->log->pos->error->if->log->pos->error->if->isSerializable->attribClassBody->chk->pos->checkDeprecatedAnnotation->chk->pos->checkClassOverrideEqualsAndHashIfNeeded->chk->checkFunctionalInterface->chk->checkLeaksNotAccessible->catch->finally->log->useSource->chk->setLint
Attr#isSerializable(Type):::check if a type is a subtype of Serializable, if that is available.:::try->complete->catch->return->finally->return->types->isSubtype
Attr#postAttr(JCTree):::Handle missing types/symbols in an AST:::new->PostAttrAnalyzer->scan
AttrContext#dup(WriteableScope):::Duplicate this context, replacing scope field and copying all others.:::info->new->AttrContext->return
AttrContext#dup():::Duplicate this context, copying all fields.:::return->dup
Check#warnDeprecated(DiagnosticPosition, Symbol):::Warn about deprecated symbol.:::if->sym->isDeprecatedForRemoval->if->lint->isSuppressed->if->removalHandler->Warnings->HasBeenDeprecatedForRemovalModule->report->else->removalHandler->Warnings->sym->location->HasBeenDeprecatedForRemoval->report->else->if->lint->isSuppressed->if->deprecationHandler->Warnings->HasBeenDeprecatedModule->report->else->deprecationHandler->Warnings->sym->location->HasBeenDeprecated->report
Check#warnUnchecked(DiagnosticPosition, Warning):::Warn about unchecked operation.:::if->lint->isSuppressed->uncheckedHandler->report
Check#warnUnsafeVararg(DiagnosticPosition, Warning):::Warn about unsafe vararg method decl.:::if->lint->isEnabled->allowedInSource->log->warning
Check#warnDivZero(DiagnosticPosition):::Warn about division by integer constant zero.:::if->lint->isEnabled->log->warning
Check#reportDeferredDiagnostics():::Report any deferred diagnostics.:::deprecationHandler->reportDeferredDiagnostic->removalHandler->reportDeferredDiagnostic->uncheckedHandler->reportDeferredDiagnostic->sunApiHandler->reportDeferredDiagnostic
Check#completionError(DiagnosticPosition, CompletionFailure):::Report a failure to complete a class.:::log->Errors->ex->getDetailValue->CantAccess->error->return
Check#typeTagError(DiagnosticPosition, JCDiagnostic, Object):::Report an error that wrong type tag was found.:::if->hasTag->log->error->return->log->Errors->TypeFoundReq->error->return->types->createErrorType
Check#earlyRefError(DiagnosticPosition, Symbol):::Report an error that symbol cannot be referenced before super  has been called.:::log->Errors->CantRefBeforeCtorCalled->error
Check#duplicateError(DiagnosticPosition, Symbol):::Report duplicate declaration error.:::if->isErroneous->location->sym->location->if->isStaticOrInstanceInit->log->Errors->kindName->sym->location->kindName->sym->location->enclClass->kindName->sym->location->enclClass->AlreadyDefinedInClinit->error->else->log->Errors->kindName->sym->location->kindName->sym->location->AlreadyDefined->error
Check#varargsDuplicateError(DiagnosticPosition, Symbol, Symbol):::Report array/varargs duplicate declaration:::if->isErroneous->isErroneous->log->Errors->sym2->location->ArrayAndVarargs->error
Check#checkTransparentVar(DiagnosticPosition, VarSymbol, Scope):::Check that variable does not hide variable with same name in  immediately enclosing local scope.:::foreach->s->getSymbolsByName->if->break->if->matches->duplicateError->return
Check#checkTransparentClass(DiagnosticPosition, ClassSymbol, Scope):::Check that a class or interface does not hide a class or  interface with same name in immediately enclosing local scope.:::foreach->s->getSymbolsByName->if->break->if->hasTag->matches->duplicateError->return
Check#checkUniqueClassName(DiagnosticPosition, Name, Scope):::Check that class does not have the same name as one of  its enclosing classes, or as a class defined in its enclosing scope:::foreach->s->getSymbolsByName->if->duplicateError->return->for->sym->return
Check#localClassName(ClassSymbol):::Return name of local class:::enclFlatname->enclClass->enclFlatnameStr->enclFlatname->toString->key->new->Pair<>->index->localClassNameIndexes->get->for->i
Check.CheckContext#compatible(Type, Type, Warner):::Is type 'found' compatible with type 'req' in given context:::
Check.CheckContext#report(DiagnosticPosition, JCDiagnostic):::Report a check error:::
Check.CheckContext#checkWarner(DiagnosticPosition, Type, Type):::Obtain a warner for this check context:::
Check#checkType(DiagnosticPosition, Type, Type):::Check that a given type is assignable to a given proto-type:::return->checkType
Check#checkCastable(DiagnosticPosition, Type, Type):::Check that a given type can be cast to a given target type:::return->checkCastable
Check#checkRedundantCast(Env, JCTypeCast):::Check for redundant casts (i.e:::if->isErroneous->types->isSameType->TreeInfo->containsTypeAnnotation->is292targetTypeCast->deferredLintHandler->if->lint->isEnabled->log->tree->pos->Warnings->RedundantCast->warning->report
Check#checkNonVoid(DiagnosticPosition, Type):::Check that type is different from 'void'.:::if->t->hasTag->log->error->return->types->createErrorType->else->return
Check#checkClassType(DiagnosticPosition, Type):::Check that type is a class or interface type.:::if->t->hasTag->t->hasTag->return->diags->fragment->asTypeParam->typeTagError->else->return
Check#checkConstructorRefType(DiagnosticPosition, Type):::Check that type is a valid qualifier for a constructor reference expression:::checkClassOrArrayType->if->t->hasTag->if->flags->log->Errors->AbstractCantBeInstantiated->error->types->createErrorType->else->if->flags->log->error->types->createErrorType->else->checkClassType->else->if->t->hasTag->if->types->isReifiable->log->error->types->createErrorType->return
Check#checkClassType(DiagnosticPosition, Type, boolean):::Check that type is a class or interface type.:::checkClassType->if->t->isParameterized->args->t->getTypeArguments->while->args->nonEmpty->if->hasTag->return->diags->fragment->typeTagError->return
Check#checkRefType(DiagnosticPosition, Type):::Check that type is a reference type, i.e:::if->t->isReference->return->else->return->diags->fragment->typeTagError
Check#checkRefTypes(List, List):::Check that each type is a reference type, i.e:::tl->for->l->l->nonEmpty->return
Check#checkNullOrRefType(DiagnosticPosition, Type):::Check that type is a null or reference type.:::if->t->isReference->t->hasTag->return->else->return->diags->fragment->typeTagError
Check#checkDisjoint(DiagnosticPosition, long, long, long):::Check that flag set does not contain elements of two conflicting sets:::if->log->Errors->TreeInfo->firstFlag->asFlagSet->TreeInfo->firstFlag->asFlagSet->IllegalCombinationOfModifiers->error->return->else->return
Check#checkDiamond(JCNewClass, Type):::Check that usage of diamond operator is correct (i.e:::if->TreeInfo->isDiamond->t->isErroneous->return->pos->checkClassType->else->if->allowedInSource->log->pos->Errors->fragment->CantApplyDiamond1->error->if->getTypeArguments->isEmpty->log->pos->Errors->Fragments->DiamondNonGeneric->CantApplyDiamond1->error->return->types->createErrorType->else->if->nonEmpty->log->pos->Errors->Fragments->DiamondAndExplicitParams->CantApplyDiamond1->error->return->types->createErrorType->else->return
Check#checkDiamondDenotable(ClassType):::Check that the type inferred using the diamond operator does not contain  non-denotable types such as captured types or intersection types.:::buf->new->ListBuffer<>->foreach->t->allparams->if->checkDenotable->buf->append->return->buf->toList
Check#checkValidGenericType(Type):::Check that type 't' is a valid instantiation of a generic class (see JLS 4.5):::return->firstIncompatibleTypeArg
Check#checkFlags(DiagnosticPosition, long, Symbol, JCTree):::Check that given modifiers are legal for given symbol and  return modifiers together with any implicit modifiers for that symbol:::mask->implicit->switch->if->TreeInfo->isReceiverParam->else->if->else->if->else->break->if->if->else->else->if->if->else->if->if->else->else->if->break->if->sym->isLocal->if->log->error->else->if->if->else->if->log->error->if->else->if->if->implicitEnumFinalFlag->break->throw->new->AssertionError->illegal->if->if->log->error->else->log->Errors->asFlagSet->ModNotAllowedHere->error->else->if->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->return
Check#validate(JCTree, Env):::Validate a type expression:::validate
Check#validate(List, Env):::Visitor method: Validate a list of type expressions.:::for->l->l->nonEmpty
Check.Validator#visitTree(JCTree):::Default visitor method: do nothing.:::
Check#subset(Type, List):::Is given type a subtype of some of the types in given list?:::for->l->l->nonEmpty->return
Check#intersects(Type, List):::Is given type a subtype or supertype of  some of the types in given list?:::for->l->l->nonEmpty->return
Check#incl(Type, List):::Add type set to given type list, unless it is a subclass of some class  in the list.:::return->subset->excl->prepend
Check#excl(Type, List):::Remove type set from type set list.:::if->ts->isEmpty->return->else->ts1->excl->if->types->isSubtype->return->else->if->return->else->return->ts1->prepend
Check#union(List, List):::Form the union of two type set lists.:::ts->for->l->l->nonEmpty->return
Check#diff(List, List):::Form the difference of two type lists.:::ts->for->l->l->nonEmpty->return
Check#intersect(List, List):::Form the intersection of two type lists.:::ts->List->nil->for->l->l->nonEmpty->for->l->l->nonEmpty->return
Check#isUnchecked(ClassSymbol):::Is exc an exception symbol that need not be declared?:::return->exc->isSubClass->exc->isSubClass
Check#isUnchecked(Type):::Is exc an exception type that need not be declared?:::return->exc->hasTag->types->supertype->isUnchecked->exc->hasTag->isUnchecked->exc->hasTag
Check#isUnchecked(DiagnosticPosition, Type):::Same, but handling completion failures.:::try->return->isUnchecked->catch->completionError->return->finally
Check#isHandled(Type, List):::Is exc handled by given exception list?:::return->isUnchecked->subset
Check#unhandled(List, List):::Return all exceptions in thrown list that are not in handled list.:::unhandled->List->nil->for->l->l->nonEmpty->return
Check#protection(long):::The level of access protection given by a flag set,  where PRIVATE is highest and PUBLIC is lowest.:::switch->return->return->return->return
Check#cannotOverride(MethodSymbol, MethodSymbol):::A customized "cannot override" error message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->CantOverride->else->if->flags->return->Fragments->CantImplement->else->return->Fragments->ClashesWith
Check#uncheckedOverrides(MethodSymbol, MethodSymbol):::A customized "override" warning message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->UncheckedOverride->else->if->flags->return->Fragments->UncheckedImplement->else->return->Fragments->UncheckedClashWith
Check#varargsOverrides(MethodSymbol, MethodSymbol):::A customized "override" warning message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->VarargsOverride->else->if->flags->return->Fragments->VarargsImplement->else->return->Fragments->VarargsClashWith
Check#checkOverride(JCTree, MethodSymbol, MethodSymbol, ClassSymbol):::Check that this method conforms with overridden method 'other':::if->m->flags->other->flags->return->if->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideStatic->error->return->if->other->flags->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->other->flags->asFlagSet->OverrideMeth->error->return->if->flags->return->if->m->flags->protection->other->flags->protection->log->TreeInfo->diagnosticPositionFor->other->flags->Errors->cannotOverride->OverrideWeakerAccess->Errors->cannotOverride->other->flags->asFlagSet->OverrideWeakerAccess->error->return->mt->types->memberType->ot->types->memberType->mtvars->mt->getTypeArguments->otvars->ot->getTypeArguments->mtres->mt->getReturnType->otres->types->ot->getReturnType->subst->overrideWarner->clear->resultTypesOK->types->returnTypeSubstitutable->if->if->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->Fragments->m->location->other->location->CantHide->OverrideIncompatibleRet->error->else->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideIncompatibleRet->error->return->else->if->overrideWarner->hasNonSilentLint->TreeInfo->diagnosticPositionFor->Warnings->uncheckedOverrides->OverrideUncheckedRet->warnUnchecked->otthrown->types->ot->getThrownTypes->subst->unhandledErased->mt->getThrownTypes->types->erasure->unhandled->unhandledUnerased->mt->getThrownTypes->unhandled->if->unhandledErased->nonEmpty->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideMethDoesntThrow->error->return->else->if->unhandledUnerased->nonEmpty->TreeInfo->diagnosticPositionFor->Warnings->cannotOverride->OverrideUncheckedThrown->warnUnchecked->return->if->m->flags->other->flags->lint->isEnabled->log->TreeInfo->diagnosticPositionFor->m->flags->Warnings->varargsOverrides->OverrideVarargsMissing->Warnings->varargsOverrides->OverrideVarargsExtra->warning->if->other->flags->log->TreeInfo->diagnosticPositionFor->Warnings->uncheckedOverrides->OverrideBridge->warning->if->isDeprecatedOverrideIgnorable->prevLint->lint->augment->setLint->try->TreeInfo->diagnosticPositionFor->checkDeprecated->catch->finally->setLint
Check#checkCompatibleConcretes(DiagnosticPosition, Type):::Check that a class does not inherit two concrete methods  with the same signature.:::sup->types->supertype->if->sup->hasTag->return->for->t1->t1->hasTag->isParameterized->types->supertype
Check#checkCompatibleAbstracts(DiagnosticPosition, Type, Type, Type):::Check that classes (or interfaces) do not each define an abstract  method with same name and arguments but incompatible return types.:::if->flags->types->capture->types->capture->return->firstIncompatibility
Check#checkOverride(Env, JCMethodDecl, MethodSymbol):::Check that a given method conforms with any method it overrides.:::origin->if->origin->flags->equals->if->m->overrides->log->tree->pos->error->return->for->t->t->hasTag->types->supertype->explicitOverride->m->attribute->mustOverride->m->isConstructor->m->isPrivate->if->isOverrider->pos->tree->pos->foreach->tree->getModifiers->if->a->pos->break->log->m->isStatic->Errors->AnonymousDiamondMethodDoesNotOverrideSuperclass->error
Check#checkAllDefined(DiagnosticPosition, ClassSymbol):::Check that all abstract members of given class have definitions.:::undef->types->firstUnimplementedAbstract->if->undef1->undef->flags->types->memberType->new->MethodSymbol->log->Errors->undef1->location->DoesNotOverrideAbstract->error
Check#checkNonCyclic(DiagnosticPosition, Type):::Check for cyclic references:::checkNonCyclicInternal
Check#checkImplementations(JCClassDecl):::Check that all methods which implement some  method conform to the method they implement.:::checkImplementations
Check#checkImplementations(JCTree, ClassSymbol, ClassSymbol):::Check that all methods which implement some  method in `ic' conform to the method they implement.:::for->l->types->closure->l->nonEmpty
Check#checkCompatibleSupertypes(DiagnosticPosition, Type):::Check that all abstract methods implemented by a class are  mutually compatible.:::supertypes->types->interfaces->supertype->types->supertype->if->supertype->hasTag->flags->supertypes->prepend->for->l->l->nonEmpty->checkCompatibleConcretes
Check#checkOverrideClashes(DiagnosticPosition, Type, MethodSymbol):::Check that all non-override equivalent methods accessible from 'site'  are mutually compatible (JLS 8.4.8/9.4.1).:::cf->new->ClashFilter->potentiallyAmbiguousList->List->nil->overridesAny->foreach->types->membersClosure->getSymbolsByName->if->sym->overrides->if->continue->if->potentiallyAmbiguousList->prepend->continue->if->List->nil->foreach->types->membersClosure->getSymbolsByName->if->continue->if->types->types->memberType->allowedInSource->isSubSignature->types->m2->erasure->m1->erasure->hasSameArgs->if->log->Errors->types->memberType->asMethodType->getParameterTypes->m1->location->types->memberType->asMethodType->getParameterTypes->m2->location->NameClashSameErasureNoOverride->error->else->ct->kind->ct->isInterface->log->Errors->types->memberType->asMethodType->getParameterTypes->m1->location->types->memberType->asMethodType->getParameterTypes->m2->location->NameClashSameErasureNoOverride1->error->return->if->foreach->checkPotentiallyAmbiguousOverloads
Check#checkHideClashes(DiagnosticPosition, Type, MethodSymbol):::Check that all static methods accessible from 'site' are  mutually compatible (JLS 8.4.8).:::cf->new->ClashFilter->foreach->types->membersClosure->getSymbolsByName->if->types->types->memberType->allowedInSource->isSubSignature->if->types->s->erasure->sym->erasure->hasSameArgs->log->Errors->sym->location->s->location->NameClashSameErasureNoHide->error->return->else->checkPotentiallyAmbiguousOverloads
Check#checkPotentiallyAmbiguousOverloads(DiagnosticPosition, Type, MethodSymbol, MethodSymbol):::Report warnings for potentially ambiguous method declarations:::if->allowedInSource->lint->isEnabled->msym1->flags->msym2->flags->mt1->types->memberType->mt2->types->memberType->if->mt1->hasTag->mt2->hasTag->types->hasSameBounds->types->subst->maxLength->Math->mt1->getParameterTypes->length->mt2->getParameterTypes->length->max->args1->rs->mt1->getParameterTypes->adjustArgs->args2->rs->mt2->getParameterTypes->adjustArgs->if->args1->length->args2->length->return->potentiallyAmbiguous->while->args1->nonEmpty->args2->nonEmpty->s->t->if->types->isSubtype->types->isSubtype->if->types->isFunctionalInterface->types->isFunctionalInterface->types->findDescriptorType->getParameterTypes->length->types->findDescriptorType->getParameterTypes->length->types->findDescriptorType->getParameterTypes->length->else->break->if->log->Warnings->msym1->location->msym2->location->PotentiallyAmbiguousOverload->warning->return
Check#checkClassBounds(DiagnosticPosition, Type):::Check that class c does not implement directly or indirectly  the same parameterized interface with two different argument lists.:::new->HashMap<TypeSymbol,Type>->checkClassBounds
Check#checkClassBounds(DiagnosticPosition, Map, Type):::Enter all interfaces of type `type' into the hash table `seensofar'  with their class symbol as key and their type as value:::if->type->isErroneous->return->for->l->types->interfaces->l->nonEmpty->st->types->supertype->if->checkClassBounds
Check#checkNotRepeated(DiagnosticPosition, Type, Set):::Enter interface into into set:::if->its->contains->log->error->else->its->add
Check#validateAnnotationTree(JCTree):::Recursively validate annotations values:::tree->new->AnnotationValidator->accept
Check#validateAnnotationType(JCTree)::: {@literal  Annotation types are restricted to primitives, String, an  enum, an annotation, Class, Class<?>, Class<? extends  Anything>, arrays of the preceding:::if->restype->pos->validateAnnotationType
Check#validateAnnotationMethod(DiagnosticPosition, MethodSymbol):::"It is also a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any public or protected method declared in class Object or in the interface annotation.Annotation.":::for->sup->sup->hasTag->types->supertype
Check#validateAnnotations(List, Symbol):::Check the annotations of a symbol.:::foreach->validateAnnotation
Check#validateTypeAnnotations(List, boolean):::Check the type annotations.:::foreach->validateTypeAnnotation
Check#validateRepeatable(TypeSymbol, Attribute.Compound, DiagnosticPosition):::Validate the proposed container 'repeatable' on the annotation type symbol 's':::Assert->types->isSameType->check->t->l->if->l->isEmpty->Assert->check->getValue->if->return->validateValue->validateRetention->validateDocumented->validateInherited->validateTarget->validateDefault
Check#isOverrider(Symbol):::Is s a method symbol that overrides a method in a superclass?:::if->s->isStatic->return->m->owner->foreach->types->closure->if->continue->scope->members->foreach->scope->getSymbolsByName->if->sym->isStatic->m->overrides->return->return
Check#isTypeAnnotation(JCAnnotation, boolean):::Is the annotation applicable to types?:::targets->typeAnnotations->annotationTargets->return->targets->stream->isTypeAnnotation->anyMatch
Check#annotationApplicable(JCAnnotation, Symbol):::Is the annotation applicable to the symbol?:::arr->getAttributeTargetAttribute->targets->if->defaultTargetMetaInfo->else->new->NameArr->for->i->foreach->if->if->return->else->if->if->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->flags->return->else->if->if->return->else->if->if->hasTag->return->else->if->s->isConstructor->getReturnType->hasTag->s->isConstructor->return->else->if->if->hasTag->return->else->return->return
Check#validateAnnotationDeferErrors(JCAnnotation):::Check an annotation value.:::res->diagHandler->new->Log.DiscardDiagnosticHandler->try->validateAnnotation->catch->finally->log->popDiagnosticHandler->return
Check#checkNonCyclicElements(JCClassDecl):::Check for cycles in the graph of annotation elements.:::if->return->Assert->check->try->foreach->if->def->hasTag->continue->meth->meth->pos->checkAnnotationResType->catch->finally
Check#checkCyclicConstructors(JCClassDecl):::Check for cycles in the graph of constructors calling other  constructors.:::callMap->new->HashMap<>->for->l->l->nonEmpty->ctors->new->SymbolArr->callMap->keySet->toArray->foreach->checkCyclicConstructor
Check#checkDivZero(DiagnosticPosition, Symbol, Type)::: Check for division by integer constant zero:::if->operand->constValue->operand->getTag->isSubRangeOf->operand->constValue->longValue->opc->if->deferredLintHandler->warnDivZero->report
Check#checkEmptyIf(JCIf):::Check for empty statements after if:::if->hasTag->lint->isEnabled->log->pos->warning
Check#checkUnique(DiagnosticPosition, Symbol, Scope):::Check that symbol is unique in given scope.:::if->isErroneous->return->if->return->foreach->s->getSymbolsByName->if->byName->flags->types->hasSameArgs->types->types->erasure->types->erasure->hasSameArgs->if->sym->flags->byName->flags->varargsDuplicateError->return->else->if->types->hasSameArgs->duplicateErasureError->return->else->duplicateError->return->return
Check#duplicateErasureError(DiagnosticPosition, Symbol, Symbol):::Report duplicate declaration error.:::if->isErroneous->isErroneous->log->Errors->NameClashSameErasure->error
Check#checkImportsUnique(JCCompilationUnit):::Check that types imported through the ordinary imports don't clash with types imported by other (static or ordinary) imports:::ordinallyImportedSoFar->WriteableScope->create->staticallyImportedSoFar->WriteableScope->create->topLevelScope->foreach->if->def->hasTag->continue->imp->if->continue->foreach->getSymbols->if->imp->isStatic->imp->pos->checkUniqueImport->staticallyImportedSoFar->enter->else->imp->pos->checkUniqueImport->ordinallyImportedSoFar->enter
Check#checkCanonical(JCTree):::Check that a qualified name is in canonical form (for import decls).:::if->isCanonical->log->tree->pos->Errors->TreeInfo->symbol->ImportRequiresCanonical->error
Check#checkForBadAuxiliaryClassAccess(DiagnosticPosition, Env, ClassSymbol):::Check that an auxiliary class is not accessed from any other file than its own.:::if->lint->isEnabled->c->flags->rs->isAccessible->fileManager->isSameFile->log->Warnings->AuxiliaryClassAccessedFromOutsideOfItsSourceFile->warning
CompileStates#instance(Context):::Get the CompileStates instance for this context.:::instance->context->get->if->new->CompileStates->return
ConstFold#fold1(int, Type):::Fold unary operation.:::try->od->operand->constValue->switch->return->return->intValue->constType->return->intValue->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->Long->longValue->valueOf->constType->return->Long->longValue->valueOf->constType->return->Float->floatValue->valueOf->constType->return->Double->doubleValue->valueOf->constType->return->catch->return->finally
ConstFold#fold2(int, Type, Type):::Fold binary operation.:::try->if->t1->fold2->return->t1->constValue->fold1->else->l->left->constValue->r->right->constValue->switch->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->if->longValue->longValue->return->constType->else->if->longValue->longValue->return->constType->else->return->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->if->floatValue->floatValue->return->constType->else->if->floatValue->floatValue->return->constType->else->if->floatValue->floatValue->return->constType->else->if->return->constType->else->return->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->if->doubleValue->doubleValue->return->constType->else->if->doubleValue->doubleValue->return->constType->else->if->doubleValue->doubleValue->return->constType->else->if->return->constType->else->return->constType->return->l->equals->b2i->constType->return->l->equals->b2i->constType->return->left->stringValue->right->stringValue->constType->return->catch->return->finally
ConstFold#coerce(Type, Type):::Coerce constant type to target type.:::if->return->if->etype->isNumeric->n->etype->constValue->switch->ttype->getTag->return->intValue->constType->return->intValue->constType->return->intValue->constType->return->intValue->constType->return->longValue->constType->return->floatValue->constType->return->doubleValue->constType->return
DeferredAttr.DeferredType.SpeculativeCache#get(Symbol, MethodResolutionPhase):::Retrieve a speculative cache entry corresponding to given symbol and resolution phase:::entries->cache->get->if->return->foreach->if->e->matches->return->return
DeferredAttr.DeferredType.SpeculativeCache#put(JCTree, ResultInfo):::Stores a speculative cache entry corresponding to given symbol and resolution phase:::msym->deferredAttrContext->entries->cache->get->if->List->nil->cache->entries->new->Entry->prepend->put
DeferredAttr.DeferredType#speculativeType(Symbol, MethodResolutionPhase):::Get the type that has been computed during a speculative attribution round:::e->speculativeCache->get->return
DeferredAttr.DeferredType#check(ResultInfo):::Check a deferred type against a potential target-type:::deferredStuckPolicy->if->hasTag->isErroneous->else->if->deferredAttrContext->deferredAttrContext->insideOverloadPhase->new->OverloadStuckPolicy->else->new->CheckStuckPolicy->return->completer->check
DeferredAttr.DeferredTypeCompleter#complete(DeferredType, ResultInfo, DeferredAttrContext):::Entry point for type-checking a deferred type:::
DeferredAttr.DeferredStuckPolicy#isStuck():::Has the policy detected that a given expression should be considered stuck?:::
DeferredAttr.DeferredStuckPolicy#stuckVars():::Get the set of inference variables a given expression depends upon.:::
DeferredAttr.DeferredStuckPolicy#depVars():::Get the set of inference variables which might get new constraints if a given expression is being type-checked.:::
DeferredAttr#attribSpeculativeLambda(JCLambda, Env, ResultInfo):::Performs speculative attribution of a lambda body and returns the speculative lambda tree, in the absence of a target-type:::stats->new->ListBuffer<>->stats->addAll->if->that->getBodyKind->stats->make->Return->add->else->stats->add->lambdaBlock->make->at->stats->toList->Block->localEnv->attr->lambdaEnv->try->speculativeTree->attribSpeculative->args->speculativeTree->getStatements->stream->s->hasTag->filter->map->List->collector->collect->lambdaBody->speculativeTree->getStatements->last->if->lambdaBody->hasTag->speculativeLambda->make->Lambda->attr->preFlow->flow->analyzeLambda->return->catch->finally->leave
DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo):::Routine that performs speculative type-checking; the input AST node is cloned (to avoid side-effects cause by Attr) and compiler state is restored after type-checking:::return->new->DeferredAttrDiagHandler->attribSpeculative
DeferredAttr.DeferredAttrContext#addDeferredAttrNode(DeferredType, ResultInfo, DeferredStuckPolicy):::Adds a node to the list of deferred attribution nodes - used by Resolve.rawCheckArgumentsApplicable Nodes added this way act as 'roots' for the out-of-order method checking process.:::deferredAttrNodes->new->DeferredAttrNode->add
DeferredAttr.DeferredAttrContext#complete():::Incrementally process all nodes, by skipping 'stuck' nodes and attributing 'unstuck' ones:::while->deferredAttrNodes->isEmpty->progress->foreach->List->from->if->deferredAttrNode->process->deferredAttrNodes->remove->if->if->insideOverloadPhase->foreach->return->try->toUnstuck->pickDeferredNode->inferenceContext->List->stuckVars->from->solveAny->inferenceContext->notifyChange->catch->break->finally
DeferredAttr.DeferredAttrContext#pickDeferredNode():::Pick the deferred node to be unstuck:::stuckGraph->buildStuckGraph->csn->GraphUtils->tarjan->get->return->csn->length->csn->get->deferredAttrNodes->get
DeferredAttr.DeferredAttrNode#process(DeferredAttrContext):::Process a deferred attribution node:::switch->if->deferredStuckPolicy->isStuck->dt->new->StructuralStuckChecker->check->return->else->Assert->error->if->deferredStuckPolicy->isStuck->if->Type->List->deferredStuckPolicy->stuckVars->from->containsAny->resultInfo->new->Check.NestedCheckContext->dup->addDeferredAttrNode->return->else->return->else->Assert->deferredAttrContext->insideOverloadPhase->check->instResultInfo->resultInfo->asInstType->dup->dt->check->return->throw->new->AssertionError
DeferredAttr.FilterScanner#skip(JCTree):::handler that is executed when a node has been discarded:::
Enter#getEnv(TypeSymbol):::Accessor for typeEnvs:::return->typeEnvs->get
Enter#classEnv(JCClassDecl, Env):::Create a fresh environment for class bodies:::localEnv->env->WriteableScope->create->dup->dup->TreeInfo->isDiamond->return
Enter#topLevelEnv(JCCompilationUnit):::Create a fresh environment for toplevels.:::localEnv->new->AttrContext->new->Env<>->WriteableScope->create->new->NamedImportScope->new->StarImportScope->return
Enter#enterScope(Env):::The scope in which a member definition in environment env is to be entered  This is usually the environment's scope, except for class environments,  where the local scope is for type variables, and the this and super symbol  only, and members go into the class member scope.:::return->hasTag
Enter#moduleEnv(JCModuleDecl, Env):::Create a fresh environment for modules.:::Assert->checkNonNull->localEnv->env->WriteableScope->create->dup->dup->return
Enter#classEnter(JCTree, Env):::Visitor method: enter all classes in given tree, catching any  completion failure exceptions:::prevEnv->try->annotate->blockAnnotations->tree->accept->return->catch->return->chk->tree->pos->completionError->finally->annotate->unblockAnnotations
Enter#classEnter(List, Env):::Visitor method: enter classes of a list of trees, returning a list of types.:::ts->new->ListBuffer<>->for->l->l->nonEmpty->return->ts->toList
Enter#duplicateClass(DiagnosticPosition, ClassSymbol):::Complain about a duplicate class.:::log->Errors->DuplicateClass->error
Enter#visitTypeParameter(JCTypeParameter):::Class enter visitor method for type parameters:::a->new->TypeVar->if->chk->tree->pos->checkUnique->enter
Enter#visitTree(JCTree):::Default class enter visitor method: do nothing.:::
Enter#main(List):::Main method: enter all classes in a list of toplevel trees.:::complete
Enter#complete(List, ClassSymbol):::Main method: enter classes from the list of toplevel trees, possibly  skipping TypeEnter for all but 'c' by placing them on the uncompleted  list.:::annotate->blockAnnotations->prevUncompleted->if->new->ListBuffer<>->try->classEnter->if->while->uncompleted->nonEmpty->clazz->uncompleted->next->if->clazz->complete->else->prevUncompleted->append->if->modules->modulesInitialized->foreach->if->cut->getModuleDecl->unfinishedModules->append->else->typeEnter->List->of->ensureImportsChecked->else->typeEnter->unfinishedModules->toList->ensureImportsChecked->unfinishedModules->clear->typeEnter->ensureImportsChecked->catch->finally->annotate->unblockAnnotations
Env#dup(JCTree, A):::Duplicate this environment, updating with given tree and info,  and copying all other fields.:::return->new->Env<>->dupto
Env#dupto(Env):::Duplicate this environment into a given Environment,  using its tree and info, and copying all other fields.:::return
Env#dup(JCTree):::Duplicate this environment, updating with given tree,  and copying all other fields.:::return->dup
Env#enclosing(JCTree.Tag):::Return closest enclosing environment which points to a tree with given tag.:::env1->while->hasTag->return
Flow.BaseAnalyzer#recordExit(P):::Record an outward transfer of control.:::pendingExits->append->markDead
Flow.BaseAnalyzer#resolveContinues(JCTree):::Resolve all continues of this statement.:::return->new->ListBuffer<P>->resolveJump
Flow.BaseAnalyzer#resolveBreaks(JCTree, ListBuffer):::Resolve all breaks of this statement.:::return->resolveJump
Flow.AliveAnalyzer#scanDef(JCTree):::Analyze a definition.:::scanStat->if->tree->hasTag->log->tree->pos->error
Flow.AliveAnalyzer#scanStat(JCTree):::Analyze a statement:::if->log->tree->pos->error->if->tree->hasTag->scan
Flow.AliveAnalyzer#scanStats(List):::Analyze list of statements.:::if->for->l->l->nonEmpty
Flow.AliveAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.FlowAnalyzer#errorUncaught():::Complain that pending exceptions are not caught.:::for->exit->pendingExits->next->pendingExits->next
Flow.FlowAnalyzer#markThrown(JCTree, Type):::Record that exception is potentially thrown and check that it  is caught.:::if->chk->tree->pos->isUnchecked->if->chk->isHandled->pendingExits->new->FlowPendingExit->append->chk->incl
Flow.FlowAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.AssignAnalyzer#trackable(VarSymbol):::Do we need to track init/uninit state of this symbol?  I.e:::return->isFinalUninitializedField
Flow.AssignAnalyzer#newVar(JCVariableDecl):::Initialize new trackable variable by setting its address field  to the next available sequence number and entering it under that  index into the vars array.:::sym->ArrayUtils->ensureCapacity->if->sym->flags->inits->excl->uninits->incl
Flow.AssignAnalyzer#letInit(DiagnosticPosition, VarSymbol):::Record an initialization of a trackable variable.:::if->trackable->if->sym->flags->if->uninits->isMember->else->uninit->else->if->sym->flags->if->sym->flags->if->sym->flags->log->Errors->MulticatchParameterMayNotBeAssigned->error->else->log->Errors->FinalParameterMayNotBeAssigned->error->else->if->uninits->isMember->log->diags->errorKey->error->else->uninit->inits->incl->else->if->sym->flags->log->Errors->VarMightAlreadyBeAssigned->error
Flow.AssignAnalyzer#letInit(JCTree):::If tree is either a simple name or of the form this.name or  C.this.name, and tree represents a trackable variable,  record an initialization of the variable.:::TreeInfo->skipParens->if->tree->hasTag->tree->hasTag->sym->TreeInfo->symbol->if->tree->pos->letInit
Flow.AssignAnalyzer#checkInit(DiagnosticPosition, VarSymbol):::Check that trackable variable is initialized.:::Errors->VarMightNotHaveBeenInitialized->checkInit
Flow.AssignAnalyzer#split(boolean):::Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets:::initsWhenFalse->assign->uninitsWhenFalse->assign->initsWhenTrue->assign->uninitsWhenTrue->assign->if->resetBits
Flow.AssignAnalyzer#merge():::Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.:::inits->initsWhenFalse->andSet->assign->uninits->uninitsWhenFalse->andSet->assign
Flow.AssignAnalyzer#scanExpr(JCTree):::Analyze an expression:::if->scan->if->inits->isReset->merge
Flow.AssignAnalyzer#scanExprs(List):::Analyze a list of expressions.:::if->for->l->l->nonEmpty
Flow.AssignAnalyzer#scanCond(JCTree):::Analyze a condition:::if->isFalse->if->inits->isReset->merge->initsWhenTrue->assign->initsWhenTrue->inclRange->uninitsWhenTrue->assign->uninitsWhenTrue->inclRange->initsWhenFalse->assign->uninitsWhenFalse->assign->else->if->isTrue->if->inits->isReset->merge->initsWhenFalse->assign->initsWhenFalse->inclRange->uninitsWhenFalse->assign->uninitsWhenFalse->inclRange->initsWhenTrue->assign->uninitsWhenTrue->assign->else->scan->if->inits->isReset->split->if->resetBits
Flow.AssignAnalyzer#analyzeTree(Env):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.CaptureAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Infer#instantiateMethod(Env, List, MethodType, Attr.ResultInfo, MethodSymbol, List, boolean, boolean, Resolve.MethodResolutionContext, Warner):::Main inference entry point - instantiate a generic method type using given argument types and (possibly) an expected target-type.:::inferenceContext->new->InferenceContext->try->deferredAttrContext->resolveContext->deferredAttrContext->mt->getParameterTypes->argumentsAcceptable->if->doIncorporation->return->new->PartiallyInferredMethodType->else->if->doIncorporation->if->warn->hasNonSilentLint->shouldPropagate->mt->getReturnType->shouldPropagate->minContext->inferenceContext->roots->min->newRestype->generateReturnConstraints->types->createMethodTypeWithReturn->if->minContext->inferenceContext->dupTo->deferredAttrContext->complete->return->deferredAttrContext->complete->if->inferenceContext->solve->else->inferenceContext->solveLegacy->inferenceContext->asInstType->if->inferenceContext->restvars->nonEmpty->warn->hasNonSilentLint->generateReturnConstraints->inferenceContext->solveLegacy->inferenceContext->asInstType->if->contains->log->Notes->DeferredMethodInst->note->return->catch->finally->if->inferenceContext->notifyChange->else->inferenceContext->inferenceContext->boundedVars->notifyChange->if->clear->dumpGraphsIfNeeded
Infer.PartiallyInferredMethodType#check(Attr.ResultInfo):::Checks this type against a target; this means generating return type constraints, solve and then roll back the results (to avoid poolluting the context).:::noWarnings->new->Warner->saved_undet->try->inferenceContext->save->unchecked->warn->hasNonSilentLint->if->shouldPropagate->getReturnType->shouldPropagate->minContext->inferenceContext->asMethodType->roots->min->other->minContext->asMethodType->update->newRestype->generateReturnConstraints->if->minContext->inferenceContext->deferredAttrContext->insideOverloadPhase->dupTo->return->inferenceContext->solve->ret->inferenceContext->asInstType->getReturnType->if->types->erasure->return->resultInfo->check->catch->ex->getDiagnostic->report->Assert->error->return->finally->if->inferenceContext->rollback
Infer#generateReturnConstraints(JCTree, Attr.ResultInfo, MethodType, InferenceContext):::Generate constraints from the generic method's return type:::rsInfoInfContext->inferenceContext->from->mt->getReturnType->if->mt->getReturnType->containsAny->types->capture->foreach->from->getTypeArguments->if->t->hasTag->isCaptured->inferenceContext->addVar->qtype->inferenceContext->asUndetVar->to->if->qtype->hasTag->else->if->to->hasTag->from->isPrimitive->else->if->qtype->hasTag->if->needsEagerInstantiation->to->isPrimitive->generateReferenceToTargetConstraint->else->if->rsInfoInfContext->free->inferenceContext->rsInfoInfContext->updateTreeType->cachedCapture->asUndetVar->Assert->rsInfoInfContext->free->check->retWarn->new->Warner->if->rsInfoInfContext->asUndetVar->compatible->retWarn->hasLint->throw->diags->Fragments->inferenceContext->restvars->mt->getReturnType->InferNoConformingInstanceExists->fragment->error->return
Infer#instantiateAsUninferredVars(List, InferenceContext):::Infer cyclic inference variables as described in 15.12.2.8.:::todo->new->ListBuffer<>->foreach->uv->inferenceContext->asUndetVar->upperBounds->uv->getBounds->if->Type->containsAny->fresh_tvar->new->TypeVariableSymbol->types->uv->getBounds->makeIntersectionType->new->TypeVar->todo->append->uv->setInst->else->if->upperBounds->nonEmpty->uv->types->glb->setInst->else->uv->setInst->formals->foreach->uv->ct->uv->getInst->types->inferenceContext->types->getBounds->asInstTypes->glb->if->isErroneous->reportBoundError
Infer#instantiatePolymorphicSignatureInstance(Env, MethodSymbol, Resolve.MethodResolutionContext, List):::Compute a synthetic method type corresponding to the requested polymorphic method signature:::restype->if->types->spMethod->getReturnType->isSameType->switch->getTag->castTree->TreeInfo->skipParens->break->execTree->TreeInfo->skipParens->break->else->spMethod->getReturnType->paramtypes->argtypes->new->ImplicitArgType->map->exType->spMethod->getThrownTypes->List->of->mtype->new->MethodType->return
Infer#instantiateFunctionalInterface(DiagnosticPosition, Type, List, Check.CheckContext):::This method is used to infer a suitable target SAM in case the original SAM type contains one or more wildcards:::if->types->capture->return->else->formalInterface->funcInterfaceContext->getTypeArguments->new->InferenceContext->Assert->check->descParameterTypes->types->findDescriptorType->getParameterTypes->if->descParameterTypes->size->paramTypes->size->checkContext->diags->fragment->report->return->types->createErrorType->foreach->if->types->funcInterfaceContext->asUndetVar->isSameType->checkContext->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->report->return->types->createErrorType->actualTypeargs->funcInterface->getTypeArguments->foreach->uv->inst->uv->getBounds->stream->b->formalInterface->getTypeArguments->containsAny->filter->findFirst->uv->inst->orElse->setInst->owntype->funcInterfaceContext->asInstType->if->chk->checkValidGenericType->checkContext->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->report->checkContext->compatible->return
Infer.IncorporationAction#apply(InferenceContext, Warner):::Incorporation action entry-point:::
Infer.IncorporationAction#isSubtype(Type, Type, Warner):::Helper function: perform subtyping through incorporation cache.:::return->doIncorporationOp
Infer.IncorporationAction#isSameType(Type, Type):::Helper function: perform type-equivalence through incorporation cache.:::return->doIncorporationOp
Infer.CheckBounds#boundsToCheck():::The list of bound kinds to be checked.:::return->EnumSet->allOf->EnumSet->EnumSet->of->complementOf
Infer.CheckBounds#checkBound(Type, Type, InferenceBound, InferenceBound, Warner):::Is source type 's' compatible with target type 't' given source and target bound kinds?:::if->ib_s->lessThan->return->isSubtype->else->if->ib_t->lessThan->return->isSubtype->else->return->isSameType
Infer.CheckBounds#report(InferenceBound, InferenceBound):::Report a bound check error.:::if->reportBoundError->else->if->reportBoundError->else->reportBoundError
Infer.SubstBounds#checkCompatibleUpperBounds(UndetVar, InferenceContext):::Make sure that the upper bounds we got so far lead to a solvable inference variable by making sure that a glb exists.:::hibounds->Type->uv->getBounds->new->BoundFilter->filter->hb->if->hibounds->isEmpty->else->if->isEmpty->else->types->glb->if->hb->isErroneous->reportBoundError
Infer#incorporationEngine():::Get the incorporation engine to be used in this compilation.:::return
Infer#doIncorporation(InferenceContext, Warner):::Check bounds and perform incorporation.:::try->progress->round->while->foreach->uv->if->isEmpty->removeFirst->apply->catch->finally->incorporationCache->clear
Infer#reportInstError(UndetVar, InferenceBound):::Incorporation error: mismatch between inferred type and given bound.:::switch->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToEqBounds->fragment->error->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToLowerBounds->fragment->error->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToUpperBounds->fragment->error
Infer#reportBoundError(UndetVar, InferenceBound):::Incorporation error: mismatch between two (or more) bounds of same kind.:::switch->throw->diags->Fragments->uv->getBounds->IncompatibleEqBounds->fragment->error->throw->diags->Fragments->uv->getBounds->IncompatibleUpperBounds->fragment->error->throw->new->AssertionError
Infer#reportBoundError(UndetVar, InferenceBound, InferenceBound):::Incorporation error: mismatch between two (or more) bounds of different kinds.:::throw->diags->Fragments->uv->getBounds->getBoundFragment->uv->getBounds->getBoundFragment->IncompatibleBounds->fragment->error
Infer.GraphStrategy#pickNode(InferenceGraph):::Pick the next node (leaf) to solve in the graph:::
Infer.GraphStrategy#done():::Is this the last step?:::
Infer.BestLeafSolver#computeTreeToLeafs(Node):::Computes a path that goes from a given node to the leafs in the graph:::cachedPath->treeCache->get->if->if->n->isLeaf->List->of->length->new->Pair<>->else->path->List->of->length->new->Pair<>->foreach->n->getAllDependencies->if->continue->subpath->computeTreeToLeafs->prependList->new->Pair<>->treeCache->put->return
Infer.BestLeafSolver#pickNode(InferenceGraph):::Pick the leaf that minimize cost:::treeCache->clear->bestPath->foreach->if->Collections->disjoint->path->computeTreeToLeafs->if->if->throw->new->NodeNotFoundException->return
Infer.GraphSolver#solve(GraphStrategy):::Solve variables in a given inference context:::doIncorporation->inferenceGraph->new->InferenceGraph->while->sstrategy->done->if->pendingGraphs->inferenceGraph->toDot->prepend->nodeToSolve->sstrategy->pickNode->varsToSolve->List->from->saved_undet->inferenceContext->save->try->while->Type->inferenceContext->restvars->containsAny->foreach->GraphInferenceSteps->values->if->inferenceContext->solveBasic->nonEmpty->doIncorporation->continue->throw->error->catch->inferenceContext->rollback->instantiateAsUninferredVars->doIncorporation->finally->inferenceGraph->deleteNode
Infer.GraphSolver.InferenceGraph.Node#addDependency(Node):::Adds dependency with given kind.:::deps->add
Infer.GraphSolver.InferenceGraph.Node#addDependencies(Set):::Add multiple dependencies of same given kind.:::foreach->addDependency
Infer.GraphSolver.InferenceGraph.Node#removeDependency(Node):::Remove a dependency, regardless of its kind.:::return->deps->remove
Infer.GraphSolver.InferenceGraph.Node#closure():::Compute closure of a give node, by recursively walking through all its dependencies.:::closure->new->HashSet<>->closureInternal->return
Infer.GraphSolver.InferenceGraph.Node#isLeaf():::Is this node a leaf? This means either the node has no dependencies, or it just has self-dependencies.:::if->deps->isEmpty->return->foreach->if->return->return
Infer.GraphSolver.InferenceGraph.Node#mergeWith(List):::Merge this node with another node, acquiring its dependencies:::foreach->Assert->length->check->data->appendList->addDependencies->deps2->new->LinkedHashSet<>->foreach->if->data->first->contains->deps2->add->else->deps2->add
Infer.GraphSolver.InferenceGraph#findNode(Type):::Basic lookup helper for retrieving a graph node given an inference variable type.:::foreach->if->contains->return->return
Infer.GraphSolver.InferenceGraph#deleteNode(Node):::Delete a node from the graph:::Assert->nodes->contains->check->nodes->remove->notifyUpdate
Infer.GraphSolver.InferenceGraph#notifyUpdate(Node, Node):::Notify all nodes of a change in the graph:::foreach->n->graphChanged
Infer.GraphSolver.InferenceGraph#initNodes():::Create the graph nodes:::new->ArrayList<>->foreach->inferenceContext->restvars->nodes->new->Node->add->foreach->i->first->foreach->j->first->if->uv_i->inferenceContext->asUndetVar->if->Type->uv_i->InferenceBound->values->getBounds->List->of->containsAny->n_i->addDependency->acyclicNodes->new->ArrayList<>->foreach->GraphUtils->tarjan->if->conSubGraph->length->root->root->mergeWith->foreach->notifyUpdate->acyclicNodes->add
Infer.GraphSolver.InferenceGraph#toDot():::Debugging: dot representation of this graph:::buf->new->StringBuilder->foreach->uv->buf->String->uv->getBounds->uv->getBounds->uv->getBounds->format->append->return->GraphUtils->hashCode->buf->toString->toDot
InferenceContext#addVar(TypeVar):::add a new inference var to this inference context:::apply->prepend->prepend
InferenceContext#inferenceVars():::returns the list of free variables (as type-variables) in this inference context:::return
InferenceContext#undetVars():::returns the list of undetermined variables in this inference context:::return
InferenceContext#restvars():::returns the list of uninstantiated variables (as type-variables) in this inference context:::return->uv->getInst->filterVars
InferenceContext#instvars():::returns the list of instantiated variables (as type-variables) in this inference context:::return->uv->getInst->filterVars
InferenceContext#boundedVars():::Get list of bounded inference variables (where bound is other than declared bounds).:::return->uv->getBounds->uv->getDeclaredBounds->diff->uv->getBounds->appendList->nonEmpty->filterVars
InferenceContext#free(Type):::is this type free?:::return->t->containsAny
InferenceContext#freeVarsIn(Type):::Returns a list of free variables in a given type:::buf->new->ListBuffer<>->foreach->inferenceVars->if->t->contains->buf->add->return->buf->toList
InferenceContext#asUndetVar(Type):::Replace all free variables in a given type with corresponding undet vars (used ahead of subtyping/compatibility checks to allow propagation of inference constraints).:::return->types->subst
InferenceContext#asInstType(Type):::Replace all free variables in a given type with corresponding instantiated types - if one or more free variable has not been fully instantiated, it will still be available in the resulting type.:::return->types->instTypes->subst
InferenceContext#addFreeTypeListener(List, FreeTypeListener):::Add custom hook for performing post-inference action:::freeTypeListeners->freeVarsIn->put
InferenceContext#notifyChange():::Mark the inference context as complete and trigger evaluation of all deferred checks.:::inferencevars->restvars->diff->notifyChange
InferenceContext#save():::Save the state of this inference context:::buf->new->ListBuffer<>->foreach->buf->dup->add->return->buf->toList
InferenceContext#rollback(List):::Restore the state of this inference context to the previous known checkpoint:::Assert->check->newUndetVars->new->ListBuffer<>->newInferenceVars->new->ListBuffer<>->while->saved_undet->nonEmpty->undetvars->nonEmpty->uv->uv_saved->if->uv_saved->dupTo->newUndetVars->add->newInferenceVars->add->else->newUndetVars->toList->newInferenceVars->toList
InferenceContext#dupTo(InferenceContext):::Copy variable in this inference context to the given context:::dupTo
InferenceContext#solve(Warner):::Solve all variables in this context.:::infer->new->LeafSolver->solve
InferenceContext#solve(List, Warner):::Solve all variables in the given list.:::infer->new->BestLeafSolver->solve
InferenceContext#solveAny(List, Warner):::Solve at least one variable in given list.:::infer->varsToSolve->restvars->intersect->new->BestLeafSolver->solve
InferenceContext#solveLegacy(boolean, Warner, EnumSet):::Instantiate inference variables in legacy mode (JLS 15.12.2.7, 15.12.2.8):::while->solvedVars->solveBasic->if->restvars->isEmpty->break->else->if->solvedVars->isEmpty->infer->restvars->instantiateAsUninferredVars->break->else->foreach->uv->uv->asInstTypes->substBounds->infer->doIncorporation
LambdaToMethod#visitClassDef(JCClassDecl):::Visit a class:::if->analyzer->analyzeAndPreprocessClass->prevKlassInfo->try->new->KlassInfo->super->visitClassDef->if->isEmpty->prevPos->try->make->at->kInfo->makeDeserializeMethod->addMethod->catch->finally->make->at->newMethods->toList->appendList->foreach->members->enter->catch->finally
LambdaToMethod#visitLambda(JCLambda):::Translate a lambda into a method to be inserted into the class:::localContext->sym->lambdaType->owner->owner->getRawTypeAttributes->owner->setTypeAttributes->sym->setTypeAttributes->apportionTypeAnnotations->init->if->owner->getInitTypeAttributes->owner->getClassInitTypeAttributes->owner->setInitTypeAttributes->owner->setClassInitTypeAttributes->sym->appendUniqueTypeAttributes->apportionTypeAnnotations->if->getKind->owner->getRawTypeAttributes->owner->setTypeAttributes->sym->appendUniqueTypeAttributes->apportionTypeAnnotations->lambdaDecl->make->make->Modifiers->make->lambdaType->getReturnType->QualIdent->List->nil->lambdaType->getThrownTypes->List->nil->make->lambdaType->getThrownTypes->Types->MethodDef->makeLambdaBody->translate->dedupe->if->localContext->isSerializable->dedupedLambda->new->DedupedLambda->existing->putIfAbsent->if->if->log->Notes->VerboseL2mDeduplicate->note->if->kInfo->addMethod->syntheticInits->new->ListBuffer<>->if->syntheticInits->append->else->if->sym->isStatic->syntheticInits->enclClass->asType->enclClass->makeThis->append->foreach->localContext->getSymbolMap->keySet->if->captured_local->make->Ident->setType->syntheticInits->append->foreach->localContext->getSymbolMap->keySet->captured_local->make->QualThis->syntheticInits->append->indy_args->syntheticInits->toList->translate->refKind->referenceKind->makeMetafactoryIndyCall
LambdaToMethod#visitReference(JCMemberReference):::Translate a method reference into an invokedynamic call to the meta-factory.:::localContext->refSym->init->switch->enclClass->asType->enclClass->makeThis->break->tree->getQualifierExpression->attr->makeNullCheck->break->break->throw->new->InternalError->indy_args->List->nil->List->of->translate->localContext->referenceKind->makeMetafactoryIndyCall
LambdaToMethod#visitIdent(JCIdent):::Translate identifiers within a lambda to the mapped identifier:::if->analyzer->lambdaIdentSymbolFilter->super->visitIdent->else->prevPos->try->make->at->lambdaContext->ltree->lambdaContext->translate->if->else->super->visitIdent->catch->finally->make->at
LambdaToMethod#visitSelect(JCFieldAccess):::Translate qualified `this' references within a lambda to the mapped identifier:::if->analyzer->lambdaFieldAccessFilter->super->visitSelect->else->prevPos->try->make->at->lambdaContext->ltree->lambdaContext->translate->if->else->super->visitSelect->catch->finally->make->at
LambdaToMethod#visitNewClass(JCNewClass):::Translate instance creation expressions with implicit enclosing instances:::if->analyzer->lambdaNewClassFilter->super->visitNewClass->else->prevPos->try->make->at->lambdaContext->lambdaContext->translate->super->visitNewClass->catch->finally->make->at
LambdaToMethod#makeNewClass(Type, List, Symbol):::Make an attributed class instance creation expression.:::tree->make->make->QualIdent->NewClass->return
LambdaToMethod#makeNewClass(Type, List):::Make an attributed class instance creation expression.:::return->rs->TreeInfo->types->List->nil->resolveConstructor->makeNewClass
LambdaToMethod.LambdaAnalyzerPreprocessor#visitReference(JCMemberReference):::Method references to local class constructors, may, if the local class references local variables, have implicit constructor parameters added in Lower; As a result, the invokedynamic bootstrap information added in the LambdaToMethod pass will have the wrong signature:::rcontext->new->ReferenceTranslationContext->contextMap->put->if->rcontext->needsConversionToLambda->conv->owner->new->MemberReferenceToLambda->conv->lambda->conv->getReceiverExpression->analyzeLambda->else->super->visitReference->if->log->Notes->rcontext->needsAltMetafactory->MrefStat->note
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#needsAltMetafactory():::does this functional expression need to be created using alternate metafactory?:::return->isIntersection->isSerializable->bridges->length
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#isSerializable():::does this functional expression require serialization support?:::if->return->return->types->asSuper
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(Symbol, LambdaSymbolKind):::Translate a symbol of a given kind into something suitable for the synthetic lambda body:::ret->switch->break->sym->flags->types->erasure->new->VarSymbol->break->types->erasure->new->VarSymbol->break->name->names->sym->flatName->toString->replace->new->String->fromString->types->erasure->new->VarSymbol->break->sym->flags->new->VarSymbol->break->sym->flags->types->erasure->new->VarSymbol->break->Assert->skind->name->error->throw->new->AssertionError->if->skind->propagateAnnotations->ret->sym->getRawAttributes->setDeclarationAttributes->ret->sym->getRawTypeAttributes->setTypeAttributes->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#complete():::The translatedSym is not complete/accurate until the analysis is finished:::if->return->inInterface->isInterface->thisReferenced->getSymbolMap->isEmpty->params->new->ListBuffer<>->parameterSymbols->new->ListBuffer<>->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->params->toList->parameterSymbols->toList->isSerializable->serializedLambdaName->lambdaName->types->generatedLambdaSig->TreeInfo->types->createMethodTypeWithParameters
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#referenceKind():::Get the opcode associated with this method reference:::return->LambdaToMethod.this->referenceKind
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isPrivateInOtherClass():::The VM does not support access across nested classes (8010319):::return->flags->types->types->enclClass->asType->erasure->types->owner->enclClass->asType->erasure->isSameType
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#interfaceParameterIsIntersectionOrUnionType():::Erasure destroys the implementation parameter subtype relationship for intersection types:::tl->tree->getDescriptorType->getParameterTypes->for->tl->nonEmpty->return
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#needsConversionToLambda():::Does this reference need to be converted to a lambda (i.e:::return->interfaceParameterIsIntersectionOrUnionType->needsVarArgsConversion->isArrayOp->isPrivateInOtherClass->isProtectedInSuperClassOfEnclosingClassInOtherPackage->receiverAccessible->tree->getMode->isLocal->isInner
Lower.ClassMap#visitClassDef(JCClassDecl):::All encountered class defs are entered into classdefs table.:::classdefs->put->super->visitClassDef
Lower#classDef(ClassSymbol):::Map a class symbol to its definition.:::def->classdefs->get->if->classMap->scan->classdefs->get->if->classMap->scan->classdefs->get->return
Lower.BasicFreeVarCollector#addFreeVars(ClassSymbol):::Add all free variables of class c to fvs list  unless they are already there.:::
Lower.BasicFreeVarCollector#visitIdent(JCIdent):::If tree refers to a variable in owner of local class, add it to  free variables list.:::visitSymbol
Lower.BasicFreeVarCollector#visitNewClass(JCNewClass):::If tree refers to a class instance creation expression  add all free variables of the freshly created class.:::c->addFreeVars->super->visitNewClass
Lower.BasicFreeVarCollector#visitApply(JCMethodInvocation):::If tree refers to a superclass constructor call,  add all free variables of the superclass.:::if->TreeInfo->name->TreeInfo->symbol->addFreeVars->super->visitApply
Lower.FreeVarCollector#visitNewClass(JCNewClass):::If tree refers to a class instance creation expression  add all free variables of the freshly created class.:::c->if->c->hasOuterInstance->visitSymbol->super->visitNewClass
Lower.FreeVarCollector#visitSelect(JCFieldAccess):::If tree refers to a qualified this or super expression  for anything but the current class, add the outer this  stack as a free variable.:::if->visitSymbol->super->visitSelect
Lower.FreeVarCollector#visitApply(JCMethodInvocation):::If tree refers to a superclass constructor call,  add all free variables of the superclass.:::if->TreeInfo->name->constructor->TreeInfo->symbol->c->if->c->hasOuterInstance->hasTag->visitSymbol->super->visitApply
Lower#freevars(ClassSymbol):::Return the variables accessed from within a local class, which  are declared in the local class' owner:::fvs->freevarCache->get->if->return->if->matches->collector->new->FreeVarCollector->collector->classDef->scan->freevarCache->put->return->else->owner->ownerToCopyFreeVarsFrom->if->freevarCache->get->freevarCache->put->return->else->return->List->nil
Lower#make_at(DiagnosticPosition):::Equivalent to make.at(pos.getStartPosition()) with side effect of caching  pos as make_pos, for use in diagnostics.:::return->make->at
Lower#makeLit(Type, Object):::Make an attributed tree representing a literal:::return->make->type->getTag->Literal->type->constType->setType
Lower#makeNull():::Make an attributed tree representing null.:::return->makeLit
Lower#makeNewClass(Type, List):::Make an attributed class instance creation expression.:::tree->make->make->QualIdent->NewClass->rs->TreeInfo->types->List->nil->resolveConstructor->return
Lower#makeUnary(JCTree.Tag, JCExpression):::Make an attributed unary expression.:::tree->make->Unary->operators->resolveUnary->getReturnType->return
Lower#makeBinary(JCTree.Tag, JCExpression, JCExpression):::Make an attributed binary expression.:::tree->make->Binary->operators->resolveBinary->getReturnType->return
Lower#makeAssignop(JCTree.Tag, JCTree, JCTree):::Make an attributed assignop expression.:::tree->make->Assignop->operators->tree->getTag->noAssignOp->resolveBinary->return
Lower#makeString(JCExpression):::Convert tree into string object, unless it has already a  reference type..:::if->isPrimitiveOrVoid->return->else->valueOfSym->tree->pos->List->of->lookupMethod->return->make->make->QualIdent->List->of->App
Lower#makeEmptyClass(long, ClassSymbol):::Create an empty anonymous class definition and enter and complete  its symbol:::return->makeEmptyClass
Lower#checkConflicts(List):::Check whether synthetic symbols generated during lowering conflict  with user-defined symbols.:::foreach->t->accept
Lower#accessName(int, int):::The name of the access method with number `anum' and access code `acode'.:::return->names->target->syntheticNameChar->fromString
Lower#accessSymbol(Symbol, JCTree, JCTree, boolean, boolean):::Return access symbol for a private or protected symbol from an inner class.:::accOwner->accessClass->vsym->if->sym->clone->actualSymbols->put->anum->accessNums->get->if->accessed->length->accessNums->put->accessSyms->new->MethodSymbolArr->put->accessed->append->acode->argtypes->restype->thrown->switch->accessCode->if->operator->enclOp->getTag->binaryAccessOperator->if->List->of->else->getParameterTypes->else->if->List->vsym->erasure->of->else->List->nil->vsym->erasure->List->nil->break->vsym->erasure->getParameterTypes->vsym->erasure->getReturnType->getThrownTypes->break->throw->new->AssertionError->if->if->vsym->flags->argtypes->erasure->prepend->accessors->accessSyms->get->accessor->if->accOwner->isInterface->anum->intValue->accessName->new->MethodType->new->MethodSymbol->tree->pos->accOwner->members->enterSynthetic->return
Lower#accessBase(DiagnosticPosition, Symbol):::The qualifier to be used for accessing a symbol in an outer class:::return->sym->flags->make->pos->getStartPosition->at->QualIdent->access->makeOwnerThis
Lower#needsPrivateAccess(Symbol):::Do we need an access method to reference private symbol?:::if->target->hasNestmateAccess->return->if->sym->flags->return->else->if->isLocal->return->else->return
Lower#needsProtectedAccess(Symbol, JCTree):::Do we need an access method to reference symbol in other package?:::if->return->if->sym->flags->sym->packge->currentClass->packge->return->if->currentClass->isSubClass->return->if->sym->flags->tree->hasTag->TreeInfo->name->return->return->isSubClass
Lower#accessClass(Symbol, boolean, JCTree):::The class in which an access method for given symbol goes.:::if->qualifier->c->if->tree->hasTag->sym->flags->while->qualifier->isSubClass->enclClass->return->else->while->c->isSubClass->enclClass->return->else->return->enclClass
Lower#access(Symbol, JCExpression, JCExpression, boolean):::Ensure that identifier is accessible, return tree accessing the identifier.:::while->enclClass->cv->getConstValue->if->make->at->return->makeLit->proxies->get->Assert->check->make->at->Ident->base->tree->hasTag->switch->if->flatname->Convert->sym->flatName->shortName->while->TreeInfo->symbol->TreeInfo->symbol->base->hasTag->if->tree->hasTag->else->if->make->at->Ident->else->break->if->protAccess->needsPrivateAccess->needsProtectedAccess->accReq->needsPrivateAccess->baseReq->sym->isMemberOf->if->make->at->if->cv->getConstValue->if->addPrunedInfo->return->makeLit->if->args->List->nil->if->sym->flags->if->tree->pos->makeOwnerThis->args->prepend->access->accessSymbol->receiver->make->make->QualIdent->Select->return->make->App->else->if->return->make->at->tree->pos->accessBase->Select->setType->else->if->translatedSym->lambdaTranslationMap->get->if->make->at->Ident->return
Lower#access(JCExpression):::Ensure that identifier is accessible, return tree accessing the identifier.:::sym->TreeInfo->symbol->return->access
Lower#accessConstructor(DiagnosticPosition, Symbol):::Return access constructor for a private constructor,  or the constructor itself, if no access constructor is needed.:::if->needsPrivateAccess->accOwner->enclClass->aconstr->accessConstrs->get->if->argtypes->getParameterTypes->if->argtypes->prepend->prepend->argtypes->accessConstructorTag->erasure->append->getReturnType->getThrownTypes->new->MethodType->new->MethodSymbol->accOwner->members->enterSynthetic->accessConstrs->put->accessed->append->return->else->return
Lower#accessConstructorTag():::Return an anonymous class nested in this toplevel class.:::topClass->currentClass->outermostClass->topModle->topClass->packge->for->i
Lower#makeAccessible(Symbol):::Add all required access methods for a private symbol to enclosing class.:::cdef->enclClass->classDef->if->Assert->error->if->accessConstrs->get->accessConstructorDef->prepend->else->accessors->accessSyms->get->for->i
Lower#accessDef(int, Symbol, MethodSymbol, int):::Construct definition of an access method.:::enclClass->make->at->md->make->MethodDef->sym->actualSymbols->get->if->ref->args->if->sym->flags->make->Ident->make->Idents->else->site->make->Ident->if->site->types->types->enclClass->supertype->erasure->setType->make->Select->make->Idents->stat->if->acode1->expr->aCode->AccessCode->getFromCode->switch->break->make->Assign->break->makeUnary->break->make->binaryAccessOperator->treeTag->Assignop->binaryAccessOperator->make->expr->setType->Return->else->make->make->App->Call->make->List->of->Block->for->l->l->nonEmpty->access->for->l->l->nonEmpty->return
Lower#accessConstructorDef(int, Symbol, MethodSymbol):::Construct definition of an access constructor.:::make->at->md->make->accessor->externalType->MethodDef->callee->make->Ident->make->List->make->make->make->reverse->reverse->Idents->App->Call->of->Block->return
Lower#proxyName(Name, int):::The name of a free variable proxy.:::proxyName->names->target->syntheticNameChar->fromString->if->proxyName->names->target->syntheticNameChar->fromString->append->return
Lower#freevarDefs(int, List, Symbol):::Proxy definitions for all free variables in given list, in reverse order.:::return->freevarDefs
Lower#outerThisName(Type, Symbol):::The name of a this$n field:::t->type->getEnclosingType->nestingLevel->while->t->hasTag->t->getEnclosingType->result->names->target->syntheticNameChar->fromString->while->members->findFirst->names->result->toString->target->syntheticNameChar->fromString->return
Lower#outerThisDef(int, MethodSymbol):::Definition for this$n field.:::c->owner->enclClass->isMandated->owner->isConstructor->owner->isAnonymous->owner->isConstructor->c->isInner->c->isPrivate->c->isStatic->flags->outerThis->makeOuterThisVarSymbol->prepend->return->makeOuterThisVarDecl
Lower#outerThisDef(int, ClassSymbol):::Definition for this$n field.:::outerThis->makeOuterThisVarSymbol->return->makeOuterThisVarDecl
Lower#loadFreevars(DiagnosticPosition, List):::Return a list of trees that load the free variables in given list,  in reverse order.:::args->List->nil->for->l->l->nonEmpty->return
Lower#makeThis(DiagnosticPosition, TypeSymbol):::Construct a tree simulating the expression C.this.:::if->return->make->at->c->erasure->This->else->return->makeOuterThis
Lower#makeTwrTry(JCTry):::Optionally replace a try statement with the desugaring of a try-with-resources statement:::tree->pos->make_at->twrVars->dup->twrBlock->makeTwrBlock->if->isEmpty->translate->else->make->Try->translate->twrVars->leave->return
Lower#makeOuterThis(DiagnosticPosition, TypeSymbol):::Construct a tree that represents the outer instance  C.this:::ots->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->makeNull->ot->tree->make->at->Ident->access->otc->while->do->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->while->if->otc->hasOuterInstance->chk->earlyRefError->Assert->error->return->makeNull->make->at->Select->access->return
Lower#makeOwnerThis(DiagnosticPosition, Symbol, boolean):::Construct a tree that represents the closest outer instance  C.this such that the given symbol is a member of C.:::c->if->sym->isMemberOf->currentClass->isSubClass->return->make->at->c->erasure->This->else->return->makeOwnerThisN
Lower#makeOwnerThisN(DiagnosticPosition, Symbol, boolean):::Similar to makeOwnerThis but will never pick "this".:::c->ots->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->makeNull->ot->tree->make->at->Ident->access->otc->while->sym->isMemberOf->otc->isSubClass->do->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->while->make->at->Select->access->return
Lower#initField(int, Symbol, Symbol):::Return tree simulating the assignment this.name = name, where  name is the name of a free variable.:::Assert->check->Assert->check->make->at->return->make->make->make->make->erasure->This->Select->make->Ident->Assign->lhs->erasure->setType->Exec
Lower#initOuterThis(int):::Return tree simulating the assignment this.this$n = this$n.:::rhs->Assert->check->lhs->Assert->check->make->at->return->make->make->make->make->erasure->This->Select->make->Ident->Assign->lhs->erasure->setType->Exec
Lower#abstractRval(JCExpression, Type, TreeBuilder):::Construct an expression using the builder, with the given rval  expression as an argument to the builder:::TreeInfo->skipParens->switch->rval->getTag->return->builder->build->id->if->flags->return->builder->build->name->TreeInfo->name->if->return->builder->build->var->names->target->syntheticNameChar->rval->hashCode->fromString->new->VarSymbol->convert->def->make->VarDef->built->builder->make->Ident->build->res->make->LetExpr->return
Lower#translate(T):::Visitor method: Translate a single node:::if->return->else->tree->pos->make_at->result->super->translate->if->endPosTable->replaceTree->return
Lower#translate(T, Type):::Visitor method: Translate a single node, boxing or unboxing if needed.:::return->translate->boxIfNeeded
Lower#translate(T, JCExpression):::Visitor method: Translate tree.:::prevEnclOp->res->translate->return
Lower#translate(List, Type):::Visitor method: Translate list of trees.:::if->return->for->l->l->nonEmpty->return
Lower#visitConditional(JCConditional):::Visitor method for conditional expressions.:::cond->translate->if->isTrue->translate->convert->addPrunedInfo->else->if->isFalse->translate->convert->addPrunedInfo->else->translate->translate
Lower#visitIf(JCIf):::Visitor method for if statements.:::cond->translate->if->isTrue->translate->addPrunedInfo->else->if->isFalse->if->translate->else->make->Skip->addPrunedInfo->else->translate->translate
Lower#visitAssert(JCAssert):::Visitor method for assert statements:::translate->if->isTrue->cond->tree->pos->assertFlagTest->exnArgs->List->nil->List->translate->of->if->isFalse->makeUnary->makeBinary->make->make_at->makeNewClass->Throw->If->else->make->Skip
Lower#boxIfNeeded(T, Type):::Expand a boxing or unboxing conversion if needed.:::havePrimitive->isPrimitive->if->type->isPrimitive->return->if->unboxedTarget->types->unboxedType->if->unboxedTarget->hasTag->if->types->isSubtype->unboxedTarget->constValue->constType->return->types->erasure->boxPrimitive->else->boxPrimitive->else->unbox->return
Lower#boxPrimitive(JCExpression):::Box up a single primitive expression.:::return->types->boxedClass->boxPrimitive
Lower#boxPrimitive(JCExpression, Type):::Box up a single primitive expression.:::tree->pos->make_at->valueOfSym->tree->pos->List->nil->prepend->lookupMethod->return->make->make->QualIdent->List->of->App
Lower#unbox(JCExpression, Type):::Unbox an object to a primitive value.:::unboxedType->types->unboxedType->if->unboxedType->hasTag->if->unboxedType->isPrimitive->throw->new->AssertionError->tree->pos->make_at->make->types->boxedClass->TypeCast->else->if->types->isSubtype->throw->new->AssertionError->tree->pos->make_at->valueSym->tree->pos->append->List->nil->lookupMethod->return->make->make->Select->App
Lower#visitParens(JCParens):::Visitor method for parenthesized expressions:::expr->translate
Lower#lowerBoxedPostop(JCUnary):::Lower a tree of the form e++ or e-- where e is an object type:::cast->TreeInfo->skipParens->hasTag->return->opcode->tree->hasTag->lhs->tmp1->clone->make->TypeCast->update->make->Literal->makeAssignop->return->makeComma->abstractRval->abstractLval
Lower#visitForeachLoop(JCEnhancedForLoop):::Translate away the foreach loop.:::if->types->elemtype->visitIterableForeachLoop->else->visitArrayForeachLoop
Lower#translateTopLevelClass(Env, JCTree, TreeMaker):::Translate a toplevel class and return a list consisting of  the translated class and translated versions of all inner classes.:::translated->try->cdef->hasTag->new->ListBuffer<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->WriteableScope->create->List->nil->new->HashMap<>->new->HashMap<>->new->HashMap<>->List->nil->new->ListBuffer<>->translate->for->l->accessed->toList->l->nonEmpty->foreach->enumSwitchMap->values->map->translate->toList->checkConflicts->checkAccessConstructorTags->catch->finally->enumSwitchMap->clear->return->translated->toList
MemberEnter#signature(MethodSymbol, List, List, JCTree, JCVariableDecl, List, Env):::Construct method type from method signature.:::tvars->enter->classEnter->attr->attribTypeVariables->argbuf->new->ListBuffer<>->for->l->l->nonEmpty->restype->attr->attribType->recvtype->if->memberEnter->else->thrownbuf->new->ListBuffer<>->for->l->l->nonEmpty->mtype->argbuf->toList->thrownbuf->toList->new->MethodType->return->tvars->isEmpty->new->ForAll
MemberEnter#memberEnter(JCTree, Env):::Enter field and method definitions and process import  clauses, catching any completion failure exceptions.:::prevEnv->try->tree->accept->catch->chk->tree->pos->completionError->finally
MemberEnter#memberEnter(List, Env):::Enter members from a list of trees.:::for->l->l->nonEmpty
MemberEnter#methodEnv(JCMethodDecl, Env):::Create a fresh environment for method bodies.:::localEnv->env->dupUnshared->dup->dup->if->attr->getReturnType->new->ResultInfo->if->return
MemberEnter#initEnv(JCVariableDecl, Env):::Create a fresh environment for a variable's initializer:::localEnv->env->dup->new->AttrContextEnv->dupto->if->dupUnshared->if->flags->return
MemberEnter#visitTree(JCTree):::Default member enter visitor method: do nothing:::
Operators#unaryPromotion(Type):::Perform unary promotion of a type; this routine implements JLS 5.6.1:::unboxed->types->unboxedTypeOrType->switch->unboxed->getTag->return->return
Operators#binaryPromotion(Type, Type):::Perform binary promotion of a pair of types; this routine implements JLS 5.6.2:::unboxedT1->types->unboxedTypeOrType->unboxedT2->types->unboxedTypeOrType->if->unboxedT1->isNumeric->unboxedT2->isNumeric->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->return->else->if->types->isSameType->return->else->return
Operators#resolveUnary(DiagnosticPosition, JCTree.Tag, Type):::Entry point for resolving a unary operator given an operator tag and an argument type.:::return->unop->test->unop->resolve->reportErrorIfNeeded->resolve
Operators#resolveBinary(DiagnosticPosition, JCTree.Tag, Type, Type):::Entry point for resolving a binary operator given an operator tag and a pair of argument types.:::return->binop->test->binop->resolve->reportErrorIfNeeded->resolve
Operators#operatorName(JCTree.Tag):::Return name of operator with given tree tag.:::return->tag->operatorIndex
Operators.OperatorHelper#doLookup(Predicate):::This routine implements the main operator lookup process:::return->Stream->alternatives->this->initOperators->orElseGet->of->filter->findFirst->orElse
Operators.UnaryOperatorHelper#doLookup(Type):::This routine implements the unary operator lookup process:::return->isUnaryOperatorApplicable->doLookup
Operators.UnaryOperatorHelper#isUnaryOperatorApplicable(OperatorSymbol, Type):::Unary operator applicability test - is the input type the same as the expected operand type?:::return->types->getParameterTypes->isSameType
Operators.UnaryOperatorHelper#addUnaryOperator(OperatorType, OperatorType, int...):::Adds a unary operator symbol.:::operatorSuppliers->List->of->makeOperator->prepend->return
Operators.UnaryOperatorHelper#resolve(Type):::This method will be overridden by unary operator helpers to provide custom resolution logic.:::
Operators.BinaryOperatorHelper#doLookup(Type, Type):::This routine implements the binary operator lookup process:::return->isBinaryOperatorApplicable->doLookup
Operators.BinaryOperatorHelper#isBinaryOperatorApplicable(OperatorSymbol, Type, Type):::Binary operator applicability test - are the input types the same as the expected operand types?:::formals->getParameterTypes->return->types->isSameType->types->isSameType
Operators.BinaryOperatorHelper#addBinaryOperator(OperatorType, OperatorType, OperatorType, int...):::Adds a binary operator symbol.:::operatorSuppliers->List->of->makeOperator->prepend->return
Operators.BinaryOperatorHelper#resolve(Type, Type):::This method will be overridden by binary operator helpers to provide custom resolution logic.:::
Resolve#isStatic(Env):::An environment is "static" if its static level is greater than  the one of its outer environment:::return
Resolve#isInitializer(Env):::An environment is an "initializer" if it is a constructor or  an instance initializer.:::owner->return->owner->isConstructor->owner->flags->owner->flags
Resolve#isAccessible(Env, TypeSymbol):::Is class accessible in given evironment?:::return->isAccessible
Resolve#isAccessible(Env, Type, Symbol):::Is symbol accessible as a member of given type in given environment?:::return->isAccessible
Resolve#checkAccessibleType(Env, Type):::Performs a recursive scan of a type looking for accessibility problems from current attribution environment:::accessibilityChecker->visit
Resolve#rawInstantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner):::Try to instantiate the type of a method so that it fits  given type arguments and argument types:::mt->types->memberType->tvars->List->nil->if->List->nil->if->mt->hasTag->typeargtypes->nonEmpty->else->if->mt->hasTag->typeargtypes->nonEmpty->pmt->if->typeargtypes->length->length->throw->diags->Fragments->Integer->length->toString->WrongNumberTypeArgs->fragment->new->InapplicableMethodException->formals->actuals->while->formals->nonEmpty->actuals->nonEmpty->bounds->types->types->getBounds->subst->for->bounds->nonEmpty->types->subst->else->if->mt->hasTag->pmt->tvars1->types->newInstances->tvars->appendList->types->subst->instNeeded->for->l->if->return->infer->instantiateMethod->dc->currentResolutionContext->deferredAttrContext->mt->getParameterTypes->argumentsAcceptable->dc->complete->return
Resolve#instantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner):::Same but returns null instead throwing a NoInstanceException:::try->return->rawInstantiate->catch->return->finally
Resolve.MethodCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner):::Main method check routine:::
Resolve.MethodCheck#mostSpecificCheck(List):::Retrieve the method check object that will be used during a most specific check.:::
Resolve.AbstractMethodCheck#checkArg(DiagnosticPosition, boolean, Type, Type, DeferredAttrContext, Warner):::Does the actual argument conforms to the corresponding formal?:::
Resolve.MostSpecificCheck#methodCheckResult(Type, DeferredAttr.DeferredAttrContext, Warner, Type):::Create a method check context to be used during the most specific applicability check:::return->attr->new->MostSpecificCheckContext->new->ResultInfo
Resolve#findField(Env, Type, Name, TypeSymbol):::Find field:::while->hasTag->getUpperBound->bestSoFar->sym->foreach->c->members->getSymbolsByName->if->return->isAccessible->new->AccessError->st->types->supertype->if->st->hasTag->st->hasTag->findField->bestOf->for->l->types->interfaces->l->nonEmpty->return
Resolve#resolveInternalField(DiagnosticPosition, Env, Type, Name):::Resolve a field identifier, throw a fatal error if not found.:::sym->findField->if->return->else->throw->diags->Fragments->FatalErrCantLocateField->fragment->new->FatalError
Resolve#findVar(Env, Name):::Find unqualified variable or field with given name:::bestSoFar->env1->staticOnly->while->sym->if->isStatic->foreach->getSymbolsByName->if->break->if->findField->if->sym->exists->if->sym->flags->return->new->StaticError->else->return->else->bestOf->if->flags->sym->findField->if->sym->exists->return->if->bestSoFar->exists->return->origin->foreach->new->ScopeArr->foreach->sc->getSymbolsByName->if->continue->if->isResolutionError->return->new->AmbiguityError->else->if->betterThan->sc->getOrigin->isAccessible->new->AccessError->if->bestSoFar->exists->break->if->return->bestSoFar->clone->else->return
Resolve#selectBest(Env, Type, List, List, Symbol, Symbol, boolean, boolean):::Select the best method for a call site among two choices.:::if->sym->isInheritedIn->notOverriddenIn->return->else->if->sym->flags->return->isResolutionError->bestSoFar->baseSymbol->new->BadVarargsMethod->Assert->isResolutionError->check->try->clear->mt->rawInstantiate->currentResolutionContext->addApplicableCandidate->catch->currentResolutionContext->ex->getDiagnostic->addInapplicableCandidate->switch->return->new->InapplicableSymbolError->new->InapplicableSymbolsError->return->finally->if->isAccessible->return->new->AccessError->return->isResolutionError->mostSpecific
Resolve#findMethod(Env, Type, Name, List, List, boolean, boolean):::Find best qualified method matching given name, type and value  arguments.:::bestSoFar->findMethod->return
Resolve#superclasses(Type):::Return an Iterable object to scan the superclasses of a given type:::return->new->Iterator<TypeSymbol>
Resolve#findFun(Env, Name, List, List, boolean, boolean):::Find unqualified method matching given name, type and value arguments.:::bestSoFar->env1->staticOnly->while->if->isStatic->Assert->check->try->sym->findMethod->if->sym->exists->if->sym->flags->return->new->StaticError->else->return->else->bestOf->catch->finally->if->flags->sym->findMethod->if->sym->exists->return->foreach->getSymbolsByName->origin->getOrigin->if->if->currentSym->clone->if->isAccessible->new->AccessError->selectBest->if->bestSoFar->exists->return->foreach->getSymbolsByName->origin->getOrigin->if->if->currentSym->clone->if->isAccessible->new->AccessError->selectBest->return
Resolve#loadClass(Env, Name, RecoveryLoadClass):::Load toplevel or member class with given fully qualified name and  verify that it is accessible.:::try->c->finder->loadClass->return->isAccessible->new->AccessError->catch->return->new->BadClassFileError->candidate->recoveryLoadClass->loadClass->if->return->return->finally
Resolve#findImmediateMemberType(Env, Type, Name, TypeSymbol):::Find a type declared in a scope (not inherited):::foreach->c->members->getSymbolsByName->if->return->isAccessible->new->AccessError->return
Resolve#findInheritedMemberType(Env, Type, Name, TypeSymbol):::Find a member type inherited from a superclass or interface.:::bestSoFar->sym->st->types->supertype->if->st->hasTag->findMemberType->bestOf->for->l->types->interfaces->l->nonEmpty->return
Resolve#findMemberType(Env, Type, Name, TypeSymbol):::Find qualified member type.:::sym->findImmediateMemberType->if->return->return->findInheritedMemberType
Resolve#findGlobalType(Env, Scope, Name, RecoveryLoadClass):::Find a global type in given scope and load corresponding class.:::bestSoFar->foreach->scope->getSymbolsByName->sym->s->flatName->loadClass->if->return->new->AmbiguityError->else->bestOf->return
Resolve#findType(Env, Name):::Find an unqualified type symbol.:::if->return->bestSoFar->sym->staticOnly->for->env1->if->hasTag->findGlobalType->if->sym->exists->return->else->bestOf->findGlobalType->if->sym->exists->return->else->bestOf->members->findGlobalType->if->sym->exists->return->else->bestOf->findGlobalType->if->sym->exists->return->else->bestOf->return
Resolve#findIdent(Env, Name, KindSelector):::Find an unqualified identifier which matches a specified kind set.:::return->findIdentInternal->checkVarType
Resolve#findIdentInPackage(Env, TypeSymbol, Name, KindSelector):::Find an identifier in a package which matches a specified kind set.:::return->findIdentInPackageInternal->checkVarType
Resolve#findIdentInType(Env, Type, Name, KindSelector):::Find an identifier among the members of a given type `site'.:::return->findIdentInTypeInternal->checkVarType
Resolve#accessInternal(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List, LogResolveHelper):::If `sym' is a bad symbol: report error and return errSymbol  else pass through unchanged,  additional arguments duplicate what has been used in trying to find the  symbol (--> flyweight pattern):::if->isResolutionError->errSym->sym->baseSymbol->errSym->access->logResolveHelper->getArgumentTypes->if->logResolveHelper->resolveDiagnosticNeeded->logResolveError->return
Resolve#accessMethod(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List):::Variant of the generalized access routine, to be used for generating method resolution diagnostics:::return->accessInternal
Resolve#accessMethod(Symbol, DiagnosticPosition, Type, Name, boolean, List, List):::Same as original accessMethod(), but without location.:::return->accessMethod
Resolve#accessBase(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean):::Variant of the generalized access routine, to be used for generating variable, type resolution diagnostics:::return->List->nil->accessInternal
Resolve#accessBase(Symbol, DiagnosticPosition, Type, Name, boolean):::Same as original accessBase(), but without location.:::return->accessBase
Resolve#checkNonAbstract(DiagnosticPosition, Symbol):::Check that sym is not an abstract method.:::if->sym->flags->sym->flags->log->Errors->kindName->sym->location->AbstractCantBeAccessedDirectly->error
Resolve#resolveIdent(DiagnosticPosition, Env, Name, KindSelector):::Resolve an unqualified (non-method) identifier.:::return->findIdent->accessBase
Resolve#resolveMethod(DiagnosticPosition, Env, Name, List, List):::Resolve an unqualified method identifier.:::return->new->BasicLookupHelper->lookupMethod
Resolve#resolveQualifiedMethod(DiagnosticPosition, Env, Type, Name, List, List):::Resolve a qualified method identifier:::return->resolveQualifiedMethod
Resolve#findPolymorphicSignatureInstance(Env, Symbol, List):::Find or create an implicit method of exactly the given type (after erasure):::mtype->infer->instantiatePolymorphicSignatureInstance->return->findPolymorphicSignatureInstance
Resolve#resolveInternalMethod(DiagnosticPosition, Env, Type, Name, List, List):::Resolve a qualified method identifier, throw a fatal error if not  found.:::resolveContext->new->MethodResolutionContext->sym->resolveQualifiedMethod->if->return->else->throw->diags->Fragments->FatalErrCantLocateMeth->fragment->new->FatalError
Resolve#resolveConstructor(DiagnosticPosition, Env, Type, List, List):::Resolve constructor.:::return->new->MethodResolutionContext->resolveConstructor
Resolve#resolveInternalConstructor(DiagnosticPosition, Env, Type, List, List):::Resolve a constructor, throw a fatal error if not found.:::resolveContext->new->MethodResolutionContext->sym->resolveConstructor->if->return->else->throw->diags->Fragments->FatalErrCantLocateCtor->fragment->new->FatalError
Resolve#resolveDiamond(DiagnosticPosition, Env, Type, List, List):::Resolve constructor using diamond inference.:::return->new->BasicLookupHelper->lookupMethod
Resolve#resolveMemberReference(Env, JCMemberReference, Type, Name, List, List, Type, MethodCheck, InferenceContext, ReferenceChooser):::Resolution of member references is typically done as a single overload resolution step, where the argument types A are inferred from the target functional descriptor:::boundLookupHelper->makeReferenceLookupHelper->boundEnv->env->dup->dup->boundSearchResolveContext->new->MethodResolutionContext->boundSym->pos->lookupMethod->boundRes->new->ReferenceLookupResult->unboundSym->unboundEnv->env->dup->dup->unboundLookupHelper->boundLookupHelper->unboundLookup->unboundRes->if->unboundSearchResolveContext->new->MethodResolutionContext->pos->lookupMethod->new->ReferenceLookupResult->res->bestRes->referenceChooser->result->new->Pair<>->if->isResolutionError->msym->if->msym->flags->findPolymorphicSignatureInstance->new->Pair<>->return
Resolve.ReferenceLookupResult#isSuccess():::Does this result corresponds to a successful lookup (i.e:::return
Resolve.ReferenceLookupResult#hasKind(StaticKind):::Does this result have given static kind?:::return
Resolve.ReferenceLookupResult#canIgnore():::Error recovery helper: can this lookup result be ignored (for the purpose of returning some 'better' result) ?:::switch->return->errSym->sym->baseSymbol->return->regex->new->Template->errSym->errCandidate->matches->errSyms->sym->baseSymbol->return->errSyms->errSyms->mapCandidates->filterCandidates->isEmpty->return
Resolve.ReferenceChooser#result(ReferenceLookupResult, ReferenceLookupResult):::Generate a result from a pair of lookup result objects:::return->unboundResult->boundResult
Resolve.ReferenceChooser#boundResult(ReferenceLookupResult):::Generate a symbol from a given bound lookup result.:::
Resolve.ReferenceChooser#unboundResult(ReferenceLookupResult, ReferenceLookupResult):::Generate a symbol from a pair of bound/unbound lookup results.:::
Resolve.LookupHelper#shouldStop(Symbol, MethodResolutionPhase):::Should lookup stop at given phase with given result:::return->phase->ordinal->maxPhase->ordinal->isResolutionError
Resolve.LookupHelper#lookup(Env, MethodResolutionPhase):::Search for a symbol under a given overload resolution phase - this method is usually called several times, once per each overload resolution phase:::
Resolve.LookupHelper#debug(DiagnosticPosition, Symbol):::Dump overload resolution info:::
Resolve.LookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol):::Validate the result of the lookup:::
Resolve.ReferenceLookupHelper#unboundLookup(InferenceContext):::Returns an unbound version of this lookup helper:::return
Resolve.ReferenceLookupHelper#referenceKind(Symbol):::Get the kind of the member reference:::
Resolve#lookupMethod(Env, DiagnosticPosition, Symbol, MethodCheck, LookupHelper):::Main overload resolution routine:::resolveContext->new->MethodResolutionContext->return->lookupMethod
Resolve#resolveSelf(DiagnosticPosition, Env, TypeSymbol, Name):::Resolve `c.name' where name == this or name == super.:::env1->staticOnly->while->if->isStatic->if->sym->findFirst->if->if->new->StaticError->return->accessBase->if->flags->if->c->isInterface->isStatic->types->isDirectSuperInterface->foreach->pruneInterfaces->if->return->types->asSuper->new->VarSymbol->foreach->types->directSupertypes->if->isSubClass->log->Errors->Fragments->RedundantSupertype->IllegalDefaultSuperCall->error->return->Assert->error->log->Errors->NotEnclClass->error->return
Resolve#resolveSelfContaining(DiagnosticPosition, Env, Symbol, boolean):::Resolve `c.this' for an enclosing class c that contains the named member.:::sym->resolveSelfContainingInternal->if->log->Errors->EnclClassRequired->error->return->else->return->accessBase
Resolve#resolveImplicitThis(DiagnosticPosition, Env, Type):::Resolve an appropriate implicit this instance for t's container:::return->resolveImplicitThis
Resolve.ResolveError#access(Name, TypeSymbol):::Create an external representation for this erroneous symbol to be used during attribution - by default this returns the symbol of a brand new error type which stores the original type found during resolution.:::return->types->createErrorType
Resolve.ResolveError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List):::Create a diagnostic representing this resolution error.:::
Resolve.AmbiguityError#mergeAbstracts(Type):::If multiple applicable methods are found during overload and none of them is more specific than the others, attempt to merge their signatures.:::ambiguousInOrder->ambiguousSyms->reverse->return->types->mergeAbstracts->orElse
Resolve.MethodResolutionDiagHelper.Template#matches(Object):::Returns true if the regex matches the diagnostic key and if all diagnostic arguments are matches by corresponding sub-templates.:::d->args->d->getArgs->if->d->getCode->matches->d->getArgs->return->for->i->return
Resolve.MethodResolutionDiagHelper#rewrite(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic):::Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it, and rewrite it accordingly.:::foreach->rewriters->entrySet->if->_entry->getKey->matches->simpleDiag->_entry->getValue->rewriteDiagnostic->simpleDiag->setFlag->return->return
Todo#instance(Context):::Get the Todo instance for this context.:::instance->context->get->if->new->Todo->return
Todo#retainFiles(Collection):::Removes all unattributed classes except those belonging to the given collection of files.:::for->it->contents->iterator->it->hasNext
TransTypes#instance(Context):::Get the instance for this context.:::instance->context->get->if->new->TransTypes->return
TransTypes#cast(JCExpression, Type):::Construct an attributed tree for a cast of expression to target type,  unless it already has precisely that type.:::oldpos->make->at->if->types->isSameType->if->resolve->isAccessible->resolve->logAccessErrorInternal->make->make->Type->TypeCast->setType->return
TransTypes#coerce(Env, JCExpression, Type):::Construct an attributed tree to coerce an expression to some erased  target type, unless the expression is already assignable to that type:::prevEnv->try->return->coerce->catch->finally
TransTypes#retype(JCExpression, Type, Type):::Given an erased reference type, assume this type as the tree's type:::if->erasedType->isPrimitive->if->target->isPrimitive->erasure->if->return->coerce->return
TransTypes#translateArgs(List, List, Type):::Translate method argument list, casting each argument  to its corresponding type in a list of target types.:::if->parameters->isEmpty->return->args->while->nonEmpty->translate->parameter->Assert->args->length->check->if->while->args->nonEmpty->translate->else->translate->return
TransTypes#addBridge(DiagnosticPosition, MethodSymbol, MethodSymbol, ClassSymbol, ListBuffer):::Add a bridge definition and enter corresponding method symbol in  local scope of origin.:::make->at->implTypeErasure->erasure->bridgeType->meth->erasure->flags->impl->flags->origin->isInterface->bridge->new->MethodSymbol->createBridgeParams->bridge->setAttributes->md->make->MethodDef->receiver->make->origin->erasure->This->make->types->supertype->erasure->Super->calltype->implTypeErasure->getReturnType->call->make->make->Select->setType->make->Idents->implTypeErasure->getParameterTypes->translateArgs->Apply->setType->stat->implTypeErasure->getReturnType->hasTag->make->Exec->make->bridgeType->getReturnType->coerce->Return->make->List->of->Block->bridges->append->origin->members->enter
TransTypes#addBridgeIfNeeded(DiagnosticPosition, Symbol, ClassSymbol, ListBuffer):::Add bridge if given symbol is a non-private, non-static member  of the given class, which is either defined in the class or non-final  inherited, and one of the two following conditions holds:  1:::if->sym->flags->sym->flags->sym->isMemberOf->meth->bridge->meth->binaryImplementation->impl->meth->implementation->if->isSubClass->if->isBridgeNeeded->addBridge->else->if->impl->flags->meth->flags->origin->flags->flags->addBridge
TransTypes#addBridges(DiagnosticPosition, ClassSymbol, ListBuffer):::Add all necessary bridges to some class appending them to list buffer.:::st->types->supertype->while->st->hasTag->addBridges->types->supertype->for->l->types->interfaces->l->nonEmpty
TransTypes#translate(T, Type):::Visitor method: perform a type translation on tree.:::prevPt->try->return->translate->catch->finally
TransTypes#translate(List, Type):::Visitor method: perform a type translation on list of trees.:::prevPt->res->try->translate->catch->finally->return
TransTypes#visitTypeApply(JCTypeApply):::Visitor method for parameterized types.:::clazz->translate
TransTypes#translateTopLevelClass(JCTree, TreeMaker):::Translate a toplevel class definition.:::return->translate
TypeEnter#complete(Symbol):::Complete entering a class.:::if->Assert->sym->flags->check->return->try->annotate->blockAnnotations->queue->dependencies->push->try->completeClass->List->typeEnvs->get->of->completeEnvs->catch->finally->dependencies->pop->if->queue->isEmpty->seen->new->HashSet<>->foreach->if->contains->seen->add->finishImports->catch->finally->annotate->unblockAnnotations
TypeEnter#DefaultConstructor(TreeMaker, ClassSymbol, MethodSymbol, List, List, List, long, boolean):::Generate default constructor for given class:::result->if->c->flags->types->supertype->else->c->flags->if->isEmpty->if->mType->new->MethodType->initType->typarams->nonEmpty->new->ForAll->init->new->MethodSymbol->createDefaultConstructorParams->params->make->Params->stats->List->nil->if->stats->SuperCall->prepend->make->make->Block->MethodDef->return
TypeEnter#SuperCall(TreeMaker, List, List, boolean):::Generate call to superclass constructor:::meth->if->make->make->Ident->Select->else->make->Ident->typeargs->typarams->nonEmpty->make->Types->return->make->make->make->Idents->Apply->Exec
TypeEnter#markDeprecated(Symbol, List, Env):::Mark sym deprecated if annotations contain @Deprecated annotation.:::attr->attribAnnotationTypes->handleDeprecatedAnnotations
