Analyzer#instance(Context)::: analyzer instance:::instance->context->get->if->new->Analyzer->return
Analyzer.StatementAnalyzer#isEnabled():::Is this analyzer allowed to run?:::return->analyzerModes->contains
Analyzer.StatementAnalyzer#match(S):::Should this analyzer be rewriting the given tree?:::
Analyzer.StatementAnalyzer#rewrite(S):::Rewrite a given AST node into a new one(s):::
Analyzer.StatementAnalyzer#process(S, T, boolean):::Entry-point for comparing results and generating diagnostics.:::
Analyzer.DiamondInitializer#match(JCNewClass)::: diamond initializer match:::return->hasTag->TreeInfo->isDiamond
Analyzer.DiamondInitializer#rewrite(JCNewClass)::: diamond initializer rewrite:::if->hasTag->nc->copier->copy->List->nil->return->List->of->else->return->List->of
Analyzer.DiamondInitializer#process(JCNewClass, JCNewClass, boolean)::: diamond initializer process:::if->inferredArgs->explicitArgs->if->nonEmpty->get->getTypeArguments->getTypeArguments->nonEmpty->get->getTypeArguments->getTypeArguments->else->getTypeArguments->getTypeArguments->foreach->if->types->isSameType->return->log->warning
Analyzer.LambdaAnalyzer#match(JCNewClass)::: lambda analyzer match:::clazztype->return->clazztype->hasTag->types->isFunctionalInterface->decls->length
Analyzer.LambdaAnalyzer#decls(JCClassDecl)::: lambda analyzer decls:::decls->new->ListBuffer<>->foreach->if->t->hasTag->md->if->md->getModifiers->decls->add->else->decls->add->return->decls->toList
Analyzer.LambdaAnalyzer#rewrite(JCNewClass)::: lambda analyzer rewrite:::md->copier->decls->copy->params->body->newTree->make->at->Lambda->return->List->of
Analyzer.LambdaAnalyzer#process(JCNewClass, JCLambda, boolean)::: lambda analyzer process:::if->log->warning
Analyzer.RedundantTypeArgAnalyzer#match(JCMethodInvocation)::: redundant type arg analyzer match:::return->nonEmpty
Analyzer.RedundantTypeArgAnalyzer#rewrite(JCMethodInvocation)::: redundant type arg analyzer rewrite:::app->copier->copy->List->nil->return->List->of
Analyzer.RedundantTypeArgAnalyzer#process(JCMethodInvocation, JCMethodInvocation, boolean)::: redundant type arg analyzer process:::if->log->warning
Analyzer.RedundantLocalVarTypeAnalyzerBase#isImplicitlyTyped(JCVariableDecl)::: redundant local var type analyzer base is implicitly typed:::return
Analyzer.RedundantLocalVarTypeAnalyzerBase#rewriteVarType(JCVariableDecl):::Map a variable tree into a new declaration using implicit type.:::newTree->copier->copy->return
Analyzer.RedundantLocalVarTypeAnalyzerBase#processVar(JCVariableDecl, JCVariableDecl, boolean):::Analyze results of local variable inference.:::if->if->types->isSameType->log->warning
Analyzer.RedundantLocalVarTypeAnalyzer#match(JCVariableDecl)::: redundant local var type analyzer match:::return->isImplicitlyTyped->attr->canInferLocalVarType
Analyzer.RedundantLocalVarTypeAnalyzer#rewrite(JCVariableDecl)::: redundant local var type analyzer rewrite:::return->List->rewriteVarType->of
Analyzer.RedundantLocalVarTypeAnalyzer#process(JCVariableDecl, JCVariableDecl, boolean)::: redundant local var type analyzer process:::processVar
Analyzer.RedundantLocalVarTypeAnalyzerForEach#match(JCEnhancedForLoop)::: redundant local var type analyzer for each match:::return->isImplicitlyTyped
Analyzer.RedundantLocalVarTypeAnalyzerForEach#rewrite(JCEnhancedForLoop)::: redundant local var type analyzer for each rewrite:::newTree->copier->copy->rewriteVarType->make->at->List->nil->Block->return->List->of
Analyzer.RedundantLocalVarTypeAnalyzerForEach#process(JCEnhancedForLoop, JCEnhancedForLoop, boolean)::: redundant local var type analyzer for each process:::processVar
Analyzer#copyEnvIfNeeded(JCTree, Env):::Create a copy of Env if needed.:::if->analyzerModes->isEmpty->TreeInfo->isStatement->tree->hasTag->analyzeEnv->env->dupUnshared->dup->dup->attr->new->ResultInfo->return->else->return
Analyzer#analyzeIfNeeded(JCTree, Env):::Analyze an AST node if needed.:::if->stmt->analyze
Analyzer#analyze(JCStatement, Env):::Analyze an AST node; this involves collecting a list of all the nodes that needs rewriting, and speculatively type-check the rewritten code to compare results against previously attributed code.:::statementScanner->new->StatementScanner->statementScanner->scan->if->isEmpty->foreach->deferredAnalysisHelper->queue
Analyzer.DeferredAnalysisHelper#queue(RewritingContext):::Add a new analysis task to the queue.:::
Analyzer.DeferredAnalysisHelper#flush(Env):::Flush queue with given attribution env.:::
Analyzer#doAnalysis(RewritingContext)::: analyzer do analysis:::prevSource->log->currentSource->localCacheContext->argumentAttr->withLocalCacheContext->try->log->getSourceFile->useSource->treeToAnalyze->if->make->at->List->of->Block->deferredAttr->new->TreeRewriter->rewriting->diagHandler->argumentAttr->withLocalCacheContext->attribSpeculative->process->catch->Assert->error->finally->log->prevSource->getFile->useSource->localCacheContext->leave
Analyzer#flush(Env)::: analyzer flush:::deferredAnalysisHelper->flush
Analyzer.StatementScanner#scan()::: statement scanner scan:::scan
Analyzer.StatementScanner#scan(JCTree)::: statement scanner scan:::if->foreach->if->analyzer->isEnabled->tree->hasTag->analyzer->match->foreach->analyzer->rewrite->rewritings->new->RewritingContext->add->break->super->scan
Analyzer.StatementScanner#visitClassDef(JCClassDecl)::: statement scanner visit class def:::
Analyzer.StatementScanner#visitMethodDef(JCMethodDecl)::: statement scanner visit method def:::
Analyzer.StatementScanner#visitBlock(JCBlock)::: statement scanner visit block:::
Analyzer.StatementScanner#visitSwitch(JCSwitch)::: statement scanner visit switch:::tree->getExpression->scan
Analyzer.StatementScanner#visitForLoop(JCForLoop)::: statement scanner visit for loop:::tree->getCondition->scan->tree->getUpdate->scan
Analyzer.StatementScanner#visitTry(JCTry)::: statement scanner visit try:::tree->getBlock->scan->tree->getCatches->scan->tree->getFinallyBlock->scan
Analyzer.StatementScanner#visitForeachLoop(JCEnhancedForLoop)::: statement scanner visit foreach loop:::tree->getExpression->scan
Analyzer.StatementScanner#visitWhileLoop(JCWhileLoop)::: statement scanner visit while loop:::tree->getCondition->scan
Analyzer.StatementScanner#visitDoLoop(JCDoWhileLoop)::: statement scanner visit do loop:::tree->getCondition->scan
Analyzer.StatementScanner#visitIf(JCIf)::: statement scanner visit if:::tree->getCondition->scan
Analyzer.RewritingContext#diagHandler():::Simple deferred diagnostic handler which filters out all messages and keep track of errors.:::return->if->d->getType->return->new->Log.DeferredDiagnosticHandler
Analyzer.AnalyzerCopier#visitLambdaExpression(LambdaExpressionTree, Void)::: analyzer copier visit lambda expression:::oldLambda->newLambda->super->visitLambdaExpression->if->forEach->return
Analyzer.AnalyzerCopier#visitNewClass(NewClassTree, Void)::: analyzer copier visit new class:::oldNewClazz->newNewClazz->super->visitNewClass->if->isEmpty->hasTag->return
Analyzer.TreeRewriter#copy(Z, Void)::: tree rewriter copy:::newTree->super->copy->if->Assert->checkNonNull->return
Annotate#instance(Context)::: annotate instance:::instance->context->get->if->new->Annotate->return
Annotate#blockAnnotations():::Called when annotations processing needs to be postponed.:::
Annotate#unblockAnnotations():::Called when annotation processing can be resumed.:::if->flush
Annotate#unblockAnnotationsNoFlush():::Variant which allows for a delayed flush of annotations:::
Annotate#annotationsBlocked():::are we blocking annotation processing?:::return
Annotate#enterDone()::: annotate enter done:::unblockAnnotations
Annotate#fromAnnotations(List)::: annotate from annotations:::if->annotations->isEmpty->return->List->nil->buf->new->ListBuffer<>->foreach->Assert->checkNonNull->buf->append->return->buf->toList
Annotate#normal(Runnable):::Annotate (used for everything else):::q->append
Annotate#validate(Runnable):::Validate, triggers after 'normal':::validateQ->append
Annotate#flush():::Flush all annotation queues:::if->annotationsBlocked->return->if->isFlushing->return->startFlushing->try->while->q->nonEmpty->q->next->run->while->typesQ->nonEmpty->typesQ->next->run->while->afterTypesQ->nonEmpty->afterTypesQ->next->run->while->validateQ->nonEmpty->validateQ->next->run->catch->finally->doneFlushing
Annotate#isFlushing()::: annotate is flushing:::return
Annotate#startFlushing()::: annotate start flushing:::
Annotate#doneFlushing()::: annotate done flushing:::
Annotate#typeAnnotation(Runnable)::: annotate type annotation:::typesQ->append
Annotate#afterTypes(Runnable)::: annotate after types:::afterTypesQ->append
Annotate#annotateLater(List, Env, Symbol, DiagnosticPosition):::Queue annotations for later attribution and entering:::if->annotations->isEmpty->return->s->resetAnnotations->Assert->s->annotationsPendingCompletion->check->prev->log->useSource->prevLintPos->deferredLintHandler->setPos->deferredLintHandler->immediate->prevLint->chk->setLint->try->if->s->hasAnnotations->annotations->nonEmpty->log->Errors->Kinds->kindName->AlreadyAnnotated->error->Assert->checkNonNull->annotateNow->catch->finally->if->chk->setLint->deferredLintHandler->setPos->log->useSource->normal->prev->log->useSource->try->chk->validateAnnotations->catch->finally->log->useSource->validate
Annotate#annotateDefaultValueLater(JCExpression, Env, MethodSymbol, DiagnosticPosition):::Queue processing of an attribute default value.:::prev->log->useSource->prevLintPos->deferredLintHandler->setPos->try->enterDefaultValue->catch->finally->deferredLintHandler->setPos->log->useSource->normal->prev->log->useSource->try->chk->validateAnnotationTree->catch->finally->log->useSource->validate
Annotate#enterDefaultValue(JCExpression, Env, MethodSymbol):::Enter a default value for an annotation element.:::getReturnType->attributeAnnotationValue
Annotate#annotateNow(Symbol, List, Env, boolean, boolean):::Gather up annotations into a map from type symbols to lists of Compound attributes, then continue on with repeating annotations processing.:::annotated->new->LinkedHashMap<>->pos->new->HashMap<>->for->al->al->isEmpty->buf->List->nil->foreach->annotated->values->if->lb->size->buf->lb->first->prepend->else->ctx->new->AnnotationContext<>->res->lb->toList->makeContainerAnnotation->if->buf->prepend->if->attrs->buf->reverse->toAnnotate->appendUniqueTypeAttributes->else->attrs->buf->reverse->toAnnotate->resetAnnotations->toAnnotate->setDeclarationAttributes
Annotate#attributeAnnotation(JCAnnotation, Type, Env):::Attribute and store a semantic representation of the annotation tree tree into the tree.attribute field.:::if->return->elems->attributeAnnotationValues->ac->new->Attribute.Compound->return
Annotate#attributeTypeAnnotation(JCAnnotation, Type, Env):::Attribute and store a semantic representation of the type annotation tree tree into the tree.attribute field.:::if->elems->attributeAnnotationValues->tc->new->Attribute.TypeCompound->return->else->return
Annotate#attributeAnnotationValues(JCAnnotation, Type, Env)::: Attribute annotation elements creating a list of pairs of the Symbol representing that  element and the value of that element as an Attribute.:::at->attr->attribType->chk->pos->checkType->isError->isErroneous->if->isAnnotationType->log->pos->Errors->NotAnnotationType->error->args->elidedValue->if->args->length->hasTag->make->at->make->Ident->Assign->buf->new->ListBuffer<>->for->tl->tl->nonEmpty->return->buf->toList
Annotate#attributeAnnotationNameValuePair(JCExpression, Type, boolean, Env, boolean)::: annotate attribute annotation name value pair:::if->nameValuePair->hasTag->log->nameValuePair->pos->error->attributeAnnotationValue->return->assign->if->hasTag->log->nameValuePair->pos->error->attributeAnnotationValue->return->left->method->resolve->pos->left->pos->List->nil->resolveQualifiedMethod->if->log->left->pos->Errors->NoAnnotationMember->error->resultType->getReturnType->value->attributeAnnotationValue->return->isErroneous->new->Pair<>
Annotate#attributeAnnotationValue(Type, JCExpression, Env):::Attribute an annotation element value:::try->complete->catch->log->tree->pos->Errors->Kinds->kindName->getQualifiedName->CantResolve->error->finally->if->expectedElementType->hasTag->return->getAnnotationArrayValue->if->tree->hasTag->if->expectedElementType->isErroneous->log->tree->pos->error->na->if->log->pos->error->for->l->l->nonEmpty->return->new->Attribute.Error->if->isAnnotationType->if->tree->hasTag->return->attributeAnnotation->else->log->tree->pos->error->if->tree->hasTag->if->expectedElementType->isErroneous->log->tree->pos->Errors->AnnotationNotValidForType->error->attributeAnnotation->return->new->Attribute.Error->initTreeVisitor->new->MemberEnter.InitTreeVisitor->tree->accept->if->log->tree->pos->error->return->new->Attribute.Error->if->expectedElementType->isPrimitive->types->isSameType->expectedElementType->hasTag->return->getAnnotationPrimitiveValue->if->return->getAnnotationClassValue->if->expectedElementType->hasTag->flags->return->getAnnotationEnumValue->if->expectedElementType->isErroneous->log->tree->pos->error->return->attr->attribExpr->new->Attribute.Error
Annotate#getAnnotationEnumValue(Type, JCExpression, Env)::: annotate get annotation enum value:::result->attr->annotationValueInfo->attribTree->sym->TreeInfo->symbol->if->TreeInfo->nonstaticSelect->sym->flags->log->tree->pos->error->return->result->getOriginalType->new->Attribute.Error->enumerator->return->new->Attribute.Enum
Annotate#getAnnotationClassValue(Type, JCExpression, Env)::: annotate get annotation class value:::result->attr->annotationValueInfo->attribTree->if->result->isErroneous->if->TreeInfo->name->isErroneous->n->flatName->return->types->createErrorType->new->Attribute.UnresolvedClass->else->return->result->getOriginalType->new->Attribute.Error->if->TreeInfo->name->log->tree->pos->error->return->new->Attribute.Error->return->new->Attribute.Class
Annotate#getAnnotationPrimitiveValue(Type, JCExpression, Env)::: annotate get annotation primitive value:::result->attr->annotationValueInfo->attribTree->if->result->isErroneous->return->result->getOriginalType->new->Attribute.Error->if->result->constValue->log->tree->pos->error->return->new->Attribute.Error->cfolder->coerce->return->result->constValue->new->Attribute.Constant
Annotate#annotationValueInfo(Type)::: annotate annotation value info:::return->new->AnnotationValueContext->dup
Annotate.AnnotationValueContext#compatible(Type, Type, Warner)::: annotation value context compatible:::return->found->hasTag->super->compatible
Annotate#getAnnotationArrayValue(Type, JCExpression, Env)::: annotate get annotation array value:::if->tree->hasTag->make->at->List->nil->List->of->NewArray->na->if->log->pos->error->buf->new->ListBuffer<>->for->l->l->nonEmpty->return->buf->buf->length->new->AttributeArr->toArray->new->Attribute.Array
Annotate#processRepeatedAnnotations(List, AnnotationContext, Symbol, boolean)::: annotate process repeated annotations:::firstOccurrence->repeated->List->nil->origAnnoType->arrayOfOrigAnnoType->targetContainerType->containerValueSymbol->Assert->annotations->isEmpty->isEmpty->check->count->for->al->al->isEmpty->if->repeated->isEmpty->log->get->Errors->DuplicateAnnotationInvalidRepeated->error->return->if->repeated->isEmpty->repeated->reverse->pos->get->m->make->at->p->new->Attribute.Array->new->Pair<MethodSymbol,Attribute>->if->at->List->of->new->Attribute.TypeCompound->annoTree->m->TypeAnnotation->if->chk->validateAnnotationDeferErrors->log->annoTree->pos->Errors->DuplicateAnnotationInvalidRepeated->error->if->chk->isTypeAnnotation->log->Errors->InvalidRepeatableAnnotationNotApplicable->Errors->InvalidRepeatableAnnotationNotApplicableInContext->error->at->setSynthesized->x->return->else->c->List->of->new->Attribute.Compound->annoTree->m->Annotation->if->chk->annotationApplicable->log->annoTree->pos->Errors->InvalidRepeatableAnnotationNotApplicable->error->if->chk->validateAnnotationDeferErrors->log->annoTree->pos->Errors->DuplicateAnnotationInvalidRepeated->error->attributeAnnotation->c->setSynthesized->x->return->else->return
Annotate#getContainingType(Attribute.Compound, DiagnosticPosition, boolean):::Fetches the actual Type that should be the containing annotation.:::origAnnoType->origAnnoDecl->ca->origAnnoDecl->getAnnotationTypeMetadata->getRepeatable->if->if->log->Errors->DuplicateAnnotationMissingContainer->error->return->return->extractContainingType->filterSame
Annotate#filterSame(Type, Type)::: annotate filter same:::if->return->return->types->isSameType
Annotate#extractContainingType(Attribute.Compound, DiagnosticPosition, TypeSymbol):::Extract the actual Type to be used for a containing annotation.:::if->isEmpty->log->Errors->InvalidRepeatableAnnotation->error->return->p->name->if->log->Errors->InvalidRepeatableAnnotation->error->return->if->log->Errors->InvalidRepeatableAnnotation->error->return->return->getValue
Annotate#validateContainer(Type, Type, DiagnosticPosition)::: annotate validate container:::containerValueSymbol->fatalError->scope->members->nr_value_elems->error->foreach->scope->getSymbolsByName->if->else->if->log->Errors->InvalidRepeatableAnnotationMultipleValues->error->return->else->if->log->Errors->InvalidRepeatableAnnotationNoValue->error->return->if->log->Errors->InvalidRepeatableAnnotationInvalidValue->error->valueRetType->getReturnType->expectedType->types->makeArrayType->if->types->isArray->types->isSameType->log->Errors->InvalidRepeatableAnnotationValueReturn->error->return
Annotate#makeContainerAnnotation(List, AnnotationContext, Symbol, boolean)::: annotate make container annotation:::validRepeated->processRepeatedAnnotations->if->manualContainer->get->if->log->manualContainer->first->get->Errors->manualContainer->first->InvalidRepeatableAnnotationRepeatedAndContainerPresent->error->return
Annotate#enterTypeAnnotations(List, Env, Symbol, DiagnosticPosition, boolean):::Attribute the list of annotations and enter them onto s.:::Assert->checkNonNull->prev->log->useSource->prevLintPos->if->deferredLintHandler->setPos->try->annotateNow->catch->finally->if->deferredLintHandler->setPos->log->useSource
Annotate#queueScanTreeAndTypeAnnotate(JCTree, Env, Symbol, DiagnosticPosition):::Enqueue tree for scanning of type annotations, attaching to the Symbol sym.:::Assert->checkNonNull->tree->new->TypeAnnotate->accept->normal
Annotate#annotateTypeSecondStage(JCTree, List, Type):::Apply the annotations to the particular type.:::compounds->fromAnnotations->Assert->annotations->size->compounds->size->check->storeAt->getMetadataOfKind->new->TypeMetadata.Annotations->combine->typeAnnotation
Annotate#annotateTypeParameterSecondStage(JCTree, List):::Apply the annotations to the particular type.:::compounds->fromAnnotations->Assert->annotations->size->compounds->size->check->typeAnnotation
Annotate.TypeAnnotate#visitAnnotatedType(JCAnnotatedType)::: type annotate visit annotated type:::enterTypeAnnotations->scan
Annotate.TypeAnnotate#visitTypeParameter(JCTypeParameter)::: type annotate visit type parameter:::enterTypeAnnotations->scan
Annotate.TypeAnnotate#visitNewArray(JCNewArray)::: type annotate visit new array:::enterTypeAnnotations->foreach->enterTypeAnnotations->scan->scan
Annotate.TypeAnnotate#visitMethodDef(JCMethodDecl)::: type annotate visit method def:::scan->scan->scan->scan->scan->scan->scan
Annotate.TypeAnnotate#visitVarDef(JCVariableDecl)::: type annotate visit var def:::prevPos->tree->pos->try->if->scan->scan->scan->catch->finally
Annotate.TypeAnnotate#visitClassDef(JCClassDecl)::: type annotate visit class def:::
Annotate.TypeAnnotate#visitNewClass(JCNewClass)::: type annotate visit new class:::scan->scan->scan->scan
Annotate#annotationTypeSourceCompleter()::: annotate annotation type source completer:::return
Annotate#attributeAnnotationType(Env)::: annotate attribute annotation type:::Assert->isAnnotationType->check->prev->log->useSource->try->tree->v->new->AnnotationTypeVisitor->v->scanAnnotationType->getAnnotationTypeMetadata->setRepeatable->getAnnotationTypeMetadata->setTarget->catch->finally->log->useSource
Annotate#unfinishedDefaultValue()::: annotate unfinished default value:::return
Annotate.AnnotationTypeCompleter#complete(ClassSymbol)::: annotation type completer complete:::
Annotate.AnnotationTypeVisitor#getRepeatable()::: annotation type visitor get repeatable:::return
Annotate.AnnotationTypeVisitor#getTarget()::: annotation type visitor get target:::return
Annotate.AnnotationTypeVisitor#scanAnnotationType(JCClassDecl)::: annotation type visitor scan annotation type:::visitClassDef
Annotate.AnnotationTypeVisitor#visitClassDef(JCClassDecl)::: annotation type visitor visit class def:::prevEnv->typeEnvs->get->try->scan->catch->finally
Annotate.AnnotationTypeVisitor#visitAnnotation(JCAnnotation)::: annotation type visitor visit annotation:::t->if->attr->attribType->check->pos->checkType->if->Annotate.this->attributeAnnotation->else->if->Annotate.this->attributeAnnotation
Annotate.AnnotationTypeMetadata#init()::: annotation type metadata init:::while->metaDataFor->isCompleted->metaDataFor->complete->if->c->c->complete
Annotate.AnnotationTypeMetadata#complete()::: annotation type metadata complete:::init
Annotate.AnnotationTypeMetadata#getRepeatable()::: annotation type metadata get repeatable:::init->return
Annotate.AnnotationTypeMetadata#setRepeatable(Compound)::: annotation type metadata set repeatable:::Assert->checkNull
Annotate.AnnotationTypeMetadata#getTarget()::: annotation type metadata get target:::init->return
Annotate.AnnotationTypeMetadata#setTarget(Compound)::: annotation type metadata set target:::Assert->checkNull
Annotate.AnnotationTypeMetadata#getAnnotationElements()::: annotation type metadata get annotation elements:::init->members->new->LinkedHashSet<>->s->metaDataFor->members->ss->s->getSymbols->foreach->if->sym->flags->members->add->return
Annotate.AnnotationTypeMetadata#getAnnotationElementsWithDefault()::: annotation type metadata get annotation elements with default:::init->members->getAnnotationElements->res->new->LinkedHashSet<>->foreach->if->res->add->return
Annotate.AnnotationTypeMetadata#toString()::: annotation type metadata to string:::return
Annotate.AnnotationTypeMetadata#isMetadataForAnnotationType()::: annotation type metadata is metadata for annotation type:::return
Annotate.AnnotationTypeMetadata#notAnAnnotationType()::: annotation type metadata not an annotation type:::return
Annotate#newRound()::: annotate new round:::
ArgumentAttr#instance(Context)::: argument attr instance:::instance->context->get->if->new->ArgumentAttr->return
ArgumentAttr#setResult(JCExpression, Type):::Set the results of method attribution.:::if
ArgumentAttr#checkSpeculative(JCExpression, ResultInfo):::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.:::return->checkSpeculative
ArgumentAttr#checkSpeculative(DiagnosticPosition, Type, ResultInfo):::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.:::if->t->hasTag->return->check->else->return->resultInfo->check
ArgumentAttr#withLocalCacheContext():::Returns a local caching context in which argument types can safely be cached without the risk of polluting enclosing contexts:::return->new->LocalCacheContext
ArgumentAttr.LocalCacheContext#leave()::: local cache context leave:::
ArgumentAttr#attribArg(JCTree, Env):::Main entry point for attributing an argument with given tree and attribution environment.:::prevEnv->try->tree->accept->return->catch->finally
ArgumentAttr#visitTree(JCTree)::: argument attr visit tree:::that->accept
ArgumentAttr#processArg(T, Function):::Process a method argument; this method takes care of performing a speculative pass over the argument tree and calling a well-defined entry point to build the argument type associated with such tree.:::pos->new->UniquePos->speculativeTree->deferredAttr->attr->new->MethodAttrInfo->attribSpeculative->return->argumentTypeFactory->apply->processArg
ArgumentAttr#processArg(T, Supplier):::Process a method argument; this method allows the caller to specify a custom speculative attribution logic (this is used e.g:::pos->new->UniquePos->cached->argumentTypeCache->get->if->cached->dup->setResult->else->res->argumentTypeFactory->get->argumentTypeCache->put->setResult
ArgumentAttr#visitParens(JCParens)::: argument attr visit parens:::new->ParensType->processArg
ArgumentAttr#visitConditional(JCConditional)::: argument attr visit conditional:::new->ConditionalType->processArg
ArgumentAttr#visitReference(JCMemberReference)::: argument attr visit reference:::localEnv->env->dup->exprTree->deferredAttr->tree->getQualifierExpression->attr->memberReferenceQualifierResult->withLocalCacheContext->attribSpeculative->mref2->new->TreeCopier<Void>->copy->lhsSym->TreeInfo->symbol->res->getMemberReference->if->isResolutionError->if->isResolutionTargetError->tree->setOverloadKind->else->if->hasTag->res->flags->TreeInfo->isStaticSelector->isRaw->hasTag->tree->setOverloadKind->else->tree->setOverloadKind->deferredAttr->new->DeferredType->setResult
ArgumentAttr#visitLambda(JCLambda)::: argument attr visit lambda:::if->speculativeLambda->deferredAttr->attribSpeculativeLambda->return->new->ExplicitLambdaType->processArg->else->deferredAttr->new->DeferredType->setResult
ArgumentAttr#visitApply(JCMethodInvocation)::: argument attr visit apply:::if->that->getTypeArguments->isEmpty->new->ResolvedMethodType->processArg->else->attr->attribTree->setResult
ArgumentAttr#visitNewClass(JCNewClass)::: argument attr visit new class:::if->TreeInfo->isDiamond->new->ResolvedConstructorType->processArg->else->attr->attribTree->setResult
ArgumentAttr.ArgumentType#completer()::: argument type completer:::return
ArgumentAttr.ArgumentType#complete(DeferredType, ResultInfo, DeferredAttrContext)::: argument type complete:::Assert->check->if->t->complete->overloadCheck->speculativeTypes->put->return->else->if->argumentTypeCache->new->UniquePos->remove->return->complete
ArgumentAttr.ArgumentType#speculativeType(Symbol, MethodResolutionPhase)::: argument type speculative type:::if->notPertinentToApplicability->contains->return->super->speculativeType->else->foreach->speculativeTypes->entrySet->deferredAttrContext->_entry->getKey->deferredAttrContext->if->return->_entry->getValue->return
ArgumentAttr.ArgumentType#speculativeTree(DeferredAttrContext)::: argument type speculative tree:::return->notPertinentToApplicability->contains->super->speculativeTree
ArgumentAttr.ArgumentType#overloadCheck(ResultInfo, DeferredAttrContext):::Performs an overload check against a given target result.:::
ArgumentAttr.ArgumentType#dup(T, Env):::Creates a copy of this argument type with given tree and environment.:::
ArgumentAttr.ParensType#overloadCheck(ResultInfo, DeferredAttrContext)::: parens type overload check:::return->checkSpeculative
ArgumentAttr.ParensType#dup(JCParens, Env)::: parens type dup:::return->new->ParensType
ArgumentAttr.ConditionalType#overloadCheck(ResultInfo, DeferredAttrContext)::: conditional type overload check:::localInfo->resultInfo->attr->conditionalContext->dup->if->speculativeTree->isStandalone->return->localInfo->check->else->if->hasTag->fragment->report->return->createErrorType->else->checkSpeculative->checkSpeculative->return
ArgumentAttr.ConditionalType#dup(JCConditional, Env)::: conditional type dup:::return->new->ConditionalType
ArgumentAttr.ExplicitLambdaType#argtypes():::Compute argument types (if needed).:::return->argtypes->res->TreeInfo->types->Optional->of->return->orElseGet
ArgumentAttr.ExplicitLambdaType#returnExpressions():::Compute return expressions (if needed).:::return->returnExpressions->res->buf->new->ListBuffer<>->new->LambdaReturnScanner->scan->buf->toList->Optional->of->return->orElseGet
ArgumentAttr.ExplicitLambdaType#overloadCheck(ResultInfo, DeferredAttrContext)::: explicit lambda type overload check:::try->targetInfo->attr->argtypes->getTargetInfo->lambdaType->currentTarget->checkLambdaCompatible->return->catch->ex->getDiagnostic->report->return->finally
ArgumentAttr.ExplicitLambdaType#checkLambdaCompatible(Type, ResultInfo):::Check lambda against given target result:::checkContext->bodyResultInfo->attr->lambdaBodyResult->switch->speculativeTree->getBodyKind->checkSpeculative->break->foreach->returnExpressions->checkReturnInStatementLambda->break->attr->checkLambdaCompatible
ArgumentAttr.ExplicitLambdaType#checkReturnInStatementLambda(JCReturn, ResultInfo):::This is an inlined version of Attr#visitReturn(JCReturn).:::if->hasTag->speculativeTree->pos->diags->fragment->report->else->if->hasTag->if->speculativeTree->pos->diags->fragment->report->checkSpeculative
ArgumentAttr.ExplicitLambdaType#getReturnType(JCReturn):::Get the type associated with given return expression.:::if->return->else->return
ArgumentAttr.ExplicitLambdaType#dup(JCLambda, Env)::: explicit lambda type dup:::return->new->ExplicitLambdaType
ArgumentAttr.ResolvedMemberType#overloadCheck(ResultInfo, DeferredAttrContext)::: resolved member type overload check:::mtype->methodType->localInfo->resultInfo->t->if->mtype->hasTag->mtype->isPartial->check->else->localInfo->tree->pos->check->speculativeTypes->put->return
ArgumentAttr.ResolvedMemberType#resultInfo(ResultInfo):::Get the result info to be used for performing an overload check.:::
ArgumentAttr.ResolvedMemberType#methodType():::Get the method type to be used for performing an overload check.:::
ArgumentAttr.ResolvedMethodType#resultInfo(ResultInfo)::: resolved method type result info:::return
ArgumentAttr.ResolvedMethodType#methodType()::: resolved method type method type:::return
ArgumentAttr.ResolvedMethodType#dup(JCMethodInvocation, Env)::: resolved method type dup:::return->new->ResolvedMethodType
ArgumentAttr.ResolvedConstructorType#resultInfo(ResultInfo)::: resolved constructor type result info:::return->resultInfo->attr->diamondContext->dup
ArgumentAttr.ResolvedConstructorType#methodType()::: resolved constructor type method type:::return->baseType
ArgumentAttr.ResolvedConstructorType#dup(JCNewClass, Env)::: resolved constructor type dup:::return->new->ResolvedConstructorType
ArgumentAttr.UniquePos#hashCode()::: unique pos hash code:::return->source->hashCode
ArgumentAttr.UniquePos#equals(Object)::: unique pos equals:::if->that->return->else->return
ArgumentAttr.UniquePos#toString()::: unique pos to string:::return->source->getFile->getName->source->getLineNumber
Attr#instance(Context)::: attr instance:::instance->context->get->if->new->Attr->return
Attr#check(JCTree, Type, KindSelector, ResultInfo):::Check kind and type of given tree against protokind and prototype:::inferenceContext->inferenceContext->owntype->shouldCheck->found->hasTag->hasTag->hasTag->if->ownkind->subset->log->tree->pos->Errors->kindNames->ownkind->kindNames->UnexpectedType->error->types->createErrorType->else->if->inferenceContext->free->if->installPostInferenceHook->inferenceContext->List->of->pendingResult->resultInfo->inferenceContext->asInstType->dup->inferenceContext->asInstType->check->addFreeTypeListener->else->resultInfo->check->if->updateTreeType->return
Attr#isAssignableAsBlankFinal(VarSymbol, Env):::Is given blank final variable assignable, i.e:::owner->return->owner->flags->v->flags->Resolve->isStatic
Attr#checkAssignable(DiagnosticPosition, VarSymbol, JCTree, Env):::Check that variable can be assigned to.:::if->log->error->else->if->v->flags->v->flags->TreeInfo->isThisQualifier->isAssignableAsBlankFinal->if->v->isResourceVariable->log->Errors->TryResourceMayNotBeAssigned->error->else->log->Errors->CantAssignValToFinalVar->error
Attr#isStaticReference(JCTree):::Does tree represent a static reference to an identifier?  It is assumed that tree is either a SELECT or an IDENT:::if->tree->hasTag->lsym->TreeInfo->symbol->if->return->return
Attr#isType(Symbol):::Is this symbol a type?:::return
Attr#thisSym(DiagnosticPosition, Env):::The current `this' symbol.:::return->rs->resolveSelf
Attr#attribIdent(JCTree, JCCompilationUnit):::Attribute a parsed identifier.:::localEnv->enter->topLevelEnv->make->make->Modifiers->ClassDef->return->attribIdent
Attr#attribIdent(JCTree, Env):::Attribute a parsed identifier.:::return->tree->accept
Attr.IdentAttributer#visitMemberSelect(MemberSelectTree, Env)::: ident attributer visit member select:::site->node->getExpression->visit->if->return->name->node->getIdentifier->if->return->rs->findIdentInPackage->else->return->rs->site->asType->findMemberType
Attr.IdentAttributer#visitIdentifier(IdentifierTree, Env)::: ident attributer visit identifier:::return->rs->node->getName->findIdent
Attr#coerce(Type, Type)::: attr coerce:::return->cfolder->coerce
Attr#attribType(JCTree, TypeSymbol)::: attr attrib type:::env->typeEnvs->get->localEnv->env->dup->dup->return->attribTree
Attr#attribImportQualifier(JCImport, Env)::: attr attrib import qualifier:::s->return->new->ResultInfo->attribTree
Attr#attribExprToTree(JCTree, Env, JCTree)::: attr attrib expr to tree:::prev->log->useSource->try->attribExpr->catch->return->if->ae->getCause->return->ae->getCause->else->throw->finally->log->useSource->return
Attr#attribStatToTree(JCTree, Env, JCTree)::: attr attrib stat to tree:::prev->log->useSource->try->attribStat->catch->return->if->ae->getCause->return->ae->getCause->else->throw->finally->log->useSource->return
Attr.ResultInfo#needsArgumentAttr(JCTree):::Should Attr#attribTree use the  visitor instead of this one?:::return
Attr.ResultInfo#check(DiagnosticPosition, Type)::: result info check:::return->chk->checkType
Attr.ResultInfo#dup(Type)::: result info dup:::return->new->ResultInfo
Attr.ResultInfo#dup(CheckContext)::: result info dup:::return->new->ResultInfo
Attr.ResultInfo#dup(Type, CheckContext)::: result info dup:::return->new->ResultInfo
Attr.ResultInfo#dup(Type, CheckContext, CheckMode)::: result info dup:::return->new->ResultInfo
Attr.ResultInfo#dup(CheckMode)::: result info dup:::return->new->ResultInfo
Attr.ResultInfo#toString()::: result info to string:::if->return->pt->toString->else->return
Attr.MethodAttrInfo#needsArgumentAttr(JCTree)::: method attr info needs argument attr:::return
Attr.MethodAttrInfo#dup(Type)::: method attr info dup:::throw->new->IllegalStateException
Attr.MethodAttrInfo#dup(CheckContext)::: method attr info dup:::return->new->MethodAttrInfo
Attr.MethodAttrInfo#dup(Type, CheckContext)::: method attr info dup:::throw->new->IllegalStateException
Attr.MethodAttrInfo#dup(Type, CheckContext, CheckMode)::: method attr info dup:::throw->new->IllegalStateException
Attr.MethodAttrInfo#dup(CheckMode)::: method attr info dup:::throw->new->IllegalStateException
Attr#pt()::: attr pt:::return
Attr#pkind()::: attr pkind:::return
Attr#attribTree(JCTree, Env, ResultInfo):::Visitor method: attribute a tree, catching any completion failure  exceptions:::prevEnv->prevResult->try->if->resultInfo->needsArgumentAttr->argumentAttr->attribArg->else->tree->accept->if->deferredAttrContext->throw->copyEnv->new->BreakAttr->return->catch->return->chk->tree->pos->completionError->finally
Attr#copyEnv(Env)::: attr copy env:::newEnv->env->copyScope->dup->dup->if->copyEnv->return
Attr#copyScope(WriteableScope)::: attr copy scope:::newScope->WriteableScope->create->elemsList->List->nil->foreach->sc->getSymbols->elemsList->prepend->foreach->newScope->enter->return
Attr#attribExpr(JCTree, Env, Type):::Derived visitor method: attribute an expression tree.:::return->pt->hasTag->new->ResultInfo->attribTree
Attr#attribExpr(JCTree, Env):::Derived visitor method: attribute an expression tree with  no constraints on the computed type.:::return->attribTree
Attr#attribType(JCTree, Env):::Derived visitor method: attribute a type tree.:::result->attribType->return
Attr#attribType(JCTree, Env, Type):::Derived visitor method: attribute a type tree.:::result->new->ResultInfo->attribTree->return
Attr#attribStat(JCTree, Env):::Derived visitor method: attribute a statement or definition tree.:::analyzeEnv->analyzer->copyEnvIfNeeded->try->return->attribTree->catch->finally->analyzer->analyzeIfNeeded
Attr#attribExprs(List, Env, Type):::Attribute a list of expressions, returning a list of types.:::ts->new->ListBuffer<>->for->l->l->nonEmpty->return->ts->toList
Attr#attribStats(List, Env):::Attribute a list of statements, returning nothing.:::for->l->l->nonEmpty
Attr#attribArgs(KindSelector, List, Env, ListBuffer):::Attribute the arguments in a method call, returning the method kind.:::kind->foreach->argtype->chk->attribTree->checkNonVoid->if->argtype->hasTag->KindSelector->of->argtypes->append->return
Attr#attribAnyTypes(List, Env):::Attribute a type argument list, returning a list of types:::argtypes->new->ListBuffer<>->for->l->l->nonEmpty->return->argtypes->toList
Attr#attribTypes(List, Env):::Attribute a type argument list, returning a list of types:::types->attribAnyTypes->return->chk->checkRefTypes
Attr#attribTypeVariables(List, Env):::Attribute type variables (of generic classes or methods):::foreach->a->if->isEmpty->bounds->List->attribType->of->foreach->bounds->attribType->prepend->types->bounds->reverse->setBounds->else->types->List->of->setBounds->foreach->chk->tvar->pos->checkNonCyclic
Attr#attribAnnotationTypes(List, Env):::Attribute the type references in a list of annotations.:::for->al->al->nonEmpty
Attr#attribLazyConstantValue(Env, JCVariableDecl, Type):::Attribute a "lazy constant value".:::prevLintPos->deferredLintHandler->variable->pos->setPos->prevSource->log->useSource->try->itype->attribExpr->if->variable->isImplicitlyTyped->chk->itype->baseType->checkLocalVarType->if->itype->constValue->return->coerce->constValue->else->return->catch->finally->log->useSource->deferredLintHandler->setPos
Attr#attribBase(JCTree, Env, boolean, boolean, boolean):::Attribute type reference in an `extends' or `implements' clause:::t->attribType->return->checkBase
Attr#checkBase(Type, JCTree, Env, boolean, boolean, boolean)::: attr check base:::pos->tree->hasTag->pos->tree->pos->if->isAnonymous->log->error->return->types->createErrorType->if->t->isErroneous->return->if->t->hasTag->if->t->getUpperBound->log->error->return->types->createErrorType->else->chk->checkClassType->if->flags->log->error->return->types->createErrorType->else->if->flags->log->error->return->types->createErrorType->if->flags->log->Errors->CantInheritFromFinal->error->chk->checkNonCyclic->return
Attr#attribIdentAsEnumType(Env, JCIdent)::: attr attrib ident as enum type:::Assert->flags->check->enclClass->enclClass->return
Attr#visitClassDef(JCClassDecl)::: attr visit class def:::localCacheContext->Optional->argumentAttr->withLocalCacheContext->ofNullable->try->if->matches->enter->classEnter->else->if->hasTag->TreeInfo->isInAnnotation->enter->classEnter->c->if->else->c->complete->if->hasTag->tree->pos->attribClass->catch->finally->localCacheContext->LocalCacheContext->leave->ifPresent
Attr#visitMethodDef(JCMethodDecl)::: attr visit method def:::m->isDefaultMethod->m->flags->lint->augment->prevLint->chk->setLint->prevMethod->chk->setMethod->try->deferredLintHandler->tree->pos->flush->chk->tree->pos->checkDeprecatedAnnotation->localEnv->memberEnter->methodEnv->attribStats->if->m->isStatic->chk->tree->pos->checkHideClashes->else->chk->tree->pos->checkOverrideClashes->chk->checkOverride->if->types->m->enclClass->overridesObjectMethod->log->Errors->Kinds->m->location->kindName->m->location->DefaultOverridesObjectMember->error->for->l->l->nonEmpty->owner->if->owner->flags->nonEmpty->log->nonEmpty->pos->pos->error->for->l->l->nonEmpty->chk->checkVarargsMethodDecl->chk->validate->if->hasTag->chk->validate->if->newEnv->memberEnter->methodEnv->attribType->chk->validate->if->owner->flags->if->nonEmpty->log->pos->error->if->nonEmpty->log->pos->error->chk->validateAnnotationType->chk->tree->pos->validateAnnotationMethod->for->l->l->nonEmpty->if->if->if->owner->flags->log->tree->pos->error->if->flags->log->tree->pos->error->else->if->flags->if->owner->flags->log->pos->error->else->log->tree->pos->error->else->if->log->tree->pos->error->else->if->body->if->isEmpty->TreeInfo->isSelfCall->typeEnter->make->at->List->nil->List->nil->SuperCall->prepend->else->if->flags->TreeInfo->isSuperCall->log->pos->Errors->CallToSuperNotAllowedInEnumCtor->error->annotate->queueScanTreeAndTypeAnnotate->annotate->flush->attribStat->leave->catch->finally->chk->setLint->chk->setMethod
Attr#visitVarDef(JCVariableDecl)::: attr visit var def:::if->if->enter->else->if->tree->isImplicitlyTyped->tree->getModifiers->if->log->Errors->CantInferLocalVarType->error->make->Erroneous->else->msg->canInferLocalVarType->if->log->Errors->CantInferLocalVarType->error->make->Erroneous->try->annotate->blockAnnotations->memberEnter->memberEnter->catch->finally->annotate->unblockAnnotations->else->if->annotate->tree->pos->queueScanTreeAndTypeAnnotate->annotate->flush->v->lint->augment->prevLint->chk->setLint->isImplicitLambdaParameter->hasTag->flags->chk->tree->isImplicitlyTyped->validate->try->v->getConstValue->deferredLintHandler->tree->pos->flush->chk->tree->pos->checkDeprecatedAnnotation->if->if->memberEnter->needsLazyConstValue->initEnv->memberEnter->initEnv->attribExpr->if->tree->isImplicitlyTyped->chk->baseType->checkLocalVarType->if->tree->isImplicitlyTyped->setSyntheticVariableType->catch->finally->chk->setLint
Attr#canInferLocalVarType(JCVariableDecl)::: attr can infer local var type:::lis->new->LocalInitScanner->lis->scan->return
Attr.LocalInitScanner#visitNewArray(JCNewArray)::: local init scanner visit new array:::if
Attr.LocalInitScanner#visitLambda(JCLambda)::: local init scanner visit lambda:::if
Attr.LocalInitScanner#visitTypeCast(JCTypeCast)::: local init scanner visit type cast:::prevNeedsTarget->try->super->visitTypeCast->catch->finally
Attr.LocalInitScanner#visitReference(JCMemberReference)::: local init scanner visit reference:::if
Attr.LocalInitScanner#visitNewClass(JCNewClass)::: local init scanner visit new class:::prevNeedsTarget->try->super->visitNewClass->catch->finally
Attr.LocalInitScanner#visitApply(JCMethodInvocation)::: local init scanner visit apply:::prevNeedsTarget->try->super->visitApply->catch->finally
Attr#visitSkip(JCSkip)::: attr visit skip:::
Attr#visitBlock(JCBlock)::: attr visit block:::if->fakeOwner->flags->new->MethodSymbol->localEnv->env->dupUnshared->dup->dup->if->annotate->queueScanTreeAndTypeAnnotate->annotate->flush->attribStats->cs->tas->getRawTypeAttributes->if->cs->appendClassInitTypeAttributes->else->cs->appendInitTypeAttributes->else->localEnv->env->dup->dup->dup->try->attribStats->catch->finally->leave
Attr#visitDoLoop(JCDoWhileLoop)::: attr visit do loop:::env->dup->attribStat->attribExpr
Attr#visitWhileLoop(JCWhileLoop)::: attr visit while loop:::attribExpr->env->dup->attribStat
Attr#visitForLoop(JCForLoop)::: attr visit for loop:::loopEnv->env->dup->dup->dup->try->attribStats->if->attribExpr->attribStats->attribStat->catch->finally->leave
Attr#visitForeachLoop(JCEnhancedForLoop)::: attr visit foreach loop:::loopEnv->env->dup->dup->dup->try->exprType->types->attribExpr->cvarUpperBound->chk->tree->pos->checkNonVoid->elemtype->types->elemtype->if->base->types->asSuper->if->log->pos->Errors->ForeachNotApplicableToType->error->types->createErrorType->else->iterableParams->base->allparams->iterableParams->isEmpty->types->wildUpperBound->if->isImplicitlyTyped->inferredType->chk->checkLocalVarType->setSyntheticVariableType->attribStat->chk->pos->checkType->attribStat->catch->finally->leave
Attr#visitLabelled(JCLabeledStatement)::: attr visit labelled:::env1->while->hasTag->if->hasTag->log->tree->pos->Errors->LabelAlreadyInUse->error->break->env->dup->attribStat
Attr#visitSwitch(JCSwitch)::: attr visit switch:::seltype->attribExpr->switchEnv->env->dup->dup->dup->try->enumSwitch->flags->stringSwitch->types->isSameType->if->log->pos->error->error->if->chk->pos->checkType->labels->new->HashSet<>->hasDefault->for->l->l->nonEmpty->catch->finally->leave
Attr#addVars(List, WriteableScope):::Add any variables defined in stats to the switch scope.:::for->stats->nonEmpty
Attr#enumConstant(JCTree, Type):::Return the selected enumeration constant symbol, or null.:::if->tree->hasTag->ident->name->foreach->members->getSymbolsByName->if->s->getConstValue->return->return
Attr#visitSynchronized(JCSynchronized)::: attr visit synchronized:::chk->tree->pos->attribExpr->checkRefType->attribStat
Attr#visitTry(JCTry)::: attr visit try:::localEnv->env->dup->dup->dup->try->isTryWithResource->nonEmpty->tryEnv->env->dup->dup->dup->try->foreach->twrContext->new->Check.NestedCheckContext->twrResult->new->ResultInfo->if->resource->hasTag->attribStat->twrResult->check->resource->pos->checkAutoCloseable->var->var->setData->else->attribTree->attribStat->catch->finally->if->leave->for->l->l->nonEmpty->if->attribStat->catch->finally->leave
Attr#checkAutoCloseable(DiagnosticPosition, Env, Type)::: attr check auto closeable:::if->resource->isErroneous->types->asSuper->types->isSameType->close->discardHandler->new->Log.DiscardDiagnosticHandler->try->rs->types->skipTypeVars->List->nil->List->nil->resolveQualifiedMethod->catch->finally->log->popDiagnosticHandler->if->close->overrides->chk->types->memberType->getThrownTypes->isHandled->isEnabled->log->Warnings->TryResourceThrowsInterruptedExc->warning
Attr#visitConditional(JCConditional)::: attr visit conditional:::condtype->attribExpr->pt->hasTag->pt->pt->isBooleanOrNumeric->if->hasTag->diags->fragment->report->types->createErrorType->return->condInfo->resultInfo->conditionalContext->dup->truetype->attribTree->falsetype->attribTree->owntype->condType->pt->if->condtype->constValue->truetype->constValue->falsetype->constValue->owntype->hasTag->cfolder->condtype->isTrue->coerce->check
Attr#isBooleanOrNumeric(Env, JCExpression)::: attr is boolean or numeric:::switch->tree->getTag->return->isSubRangeOf->return->return->isBooleanOrNumeric->condTree->return->isBooleanOrNumeric->isBooleanOrNumeric->speculativeMethodTree->deferredAttr->argumentAttr->withLocalCacheContext->attribSpeculative->msym->TreeInfo->symbol->receiverType->hasTag->owntype->types->memberType->getReturnType->return->primitiveOrBoxed->className->removeClassParams->translate->speculativeNewClassTree->deferredAttr->argumentAttr->withLocalCacheContext->attribSpeculative->return->primitiveOrBoxed->speculativeType->deferredAttr->argumentAttr->withLocalCacheContext->attribSpeculative->return->primitiveOrBoxed
Attr#primitiveOrBoxed(Type)::: attr primitive or boxed:::return->t->hasTag->types->unboxedTypeOrType->isPrimitive
Attr#conditionalContext(CheckContext)::: attr conditional context:::return->new->Check.NestedCheckContext
Attr#condType(DiagnosticPosition, Type, Type):::Compute the type of a conditional expression, after  checking that it exists:::if->types->isSameType->return->thentype->baseType->thenUnboxed->thentype->isPrimitive->types->unboxedType->elseUnboxed->elsetype->isPrimitive->types->unboxedType->if->thenUnboxed->isPrimitive->elseUnboxed->isPrimitive->if->thenUnboxed->getTag->isStrictSubRangeOf->elseUnboxed->hasTag->types->isAssignable->return->thenUnboxed->baseType->if->elseUnboxed->getTag->isStrictSubRangeOf->thenUnboxed->hasTag->types->isAssignable->return->elseUnboxed->baseType->foreach->candidate->tag->ordinal->if->types->isSubtype->types->isSubtype->return->if->thentype->isPrimitive->types->boxedClass->if->elsetype->isPrimitive->types->boxedClass->if->types->isSubtype->return->elsetype->baseType->if->types->isSubtype->return->thentype->baseType->if->thentype->hasTag->elsetype->hasTag->log->Errors->NeitherConditionalSubtype->error->return->thentype->baseType->return->types->thentype->baseType->elsetype->baseType->lub
Attr#visitIf(JCIf)::: attr visit if:::attribExpr->attribStat->if->attribStat->chk->checkEmptyIf
Attr#visitExec(JCExpressionStatement)::: attr visit exec:::localEnv->env->dup->attribExpr
Attr#visitBreak(JCBreak)::: attr visit break:::tree->pos->tree->getTag->findJumpTarget
Attr#visitContinue(JCContinue)::: attr visit continue:::tree->pos->tree->getTag->findJumpTarget
Attr#findJumpTarget(DiagnosticPosition, JCTree.Tag, Name, Env):::Return the target of a break or continue statement, if it exists,  report an error if not:::env1->while->switch->getTag->labelled->if->if->if->hasTag->hasTag->hasTag->hasTag->log->Errors->NotLoopLabel->error->return->TreeInfo->referencedStatement->else->return->break->if->return->break->if->return->break->break->if->log->Errors->UndefLabel->error->else->if->log->error->else->log->error->return
Attr#visitReturn(JCReturn)::: attr visit return:::if->log->tree->pos->error->else->if->if->hasTag->pos->diags->fragment->report->attribTree->else->if->hasTag->hasTag->tree->pos->diags->Fragments->MissingRetVal->fragment->report
Attr#visitThrow(JCThrow)::: attr visit throw:::owntype->attribExpr->if->chk->checkType
Attr#visitAssert(JCAssert)::: attr visit assert:::attribExpr->if->chk->pos->attribExpr->checkNonVoid
Attr#visitApply(JCMethodInvocation):::Visitor method for method invocations:::localEnv->env->dup->dup->argtypes->typeargtypes->methName->TreeInfo->name->isConstructorCall->argtypesBuf->new->ListBuffer<>->if->if->checkFirstConstructorStat->kind->attribArgs->argtypesBuf->toList->attribTypes->site->if->if->log->pos->Errors->NoSuperclass->error->types->createErrorType->else->types->supertype->if->site->hasTag->encl->site->getEnclosingType->while->encl->hasTag->encl->getUpperBound->if->encl->hasTag->if->hasTag->qualifier->chk->qualifier->pos->attribExpr->checkRefType->else->if->rs->pos->resolveImplicitThis->else->if->hasTag->log->pos->Errors->IllegalQualNotIcls->error->if->argtypes->prepend->prepend->selectSuperPrev->sym->rs->pos->resolveConstructor->TreeInfo->setSymbol->mpt->newMethodTemplate->new->ResultInfo->checkId->else->kind->attribArgs->argtypesBuf->toList->attribAnyTypes->mpt->newMethodTemplate->mtype->new->ResultInfo->attribTree->restype->mtype->getReturnType->if->restype->hasTag->throw->new->AssertionError->qualifier->hasTag->msym->TreeInfo->symbol->adjustMethodReturnType->chk->checkRefTypes->capturedRes->inferenceContext->cachedCapture->check->chk->validate
Attr#adjustMethodReturnType(Symbol, Type, Name, List, Type)::: attr adjust method return type:::if->argtypes->isEmpty->return->restype->getEnclosingType->List->types->erasure->new->WildcardType->of->restype->getMetadata->new->ClassType->else->if->types->isArray->return->else->return
Attr#checkFirstConstructorStat(JCMethodInvocation, Env):::Check that given application node appears as first statement  in a constructor call.:::enclMethod->if->body->if->hasTag->return->log->tree->pos->Errors->TreeInfo->name->CallMustBeFirstStmtInCtor->error->return
Attr#newMethodTemplate(Type, List, List):::Obtain a method type with given argument types.:::mt->List->nil->new->MethodType->return->new->ForAll
Attr#visitNewClass(JCNewClass)::: attr visit new class:::owntype->types->createErrorType->localEnv->env->dup->dup->cdef->clazz->clazzid->annoclazzid->if->clazz->hasTag->if->clazzid->hasTag->else->if->clazz->hasTag->else->clazzid1->if->encltype->chk->pos->attribExpr->checkRefType->make->at->make->Type->Select->endPosTable->endPosTable->tree->getEndPosition->storeEnd->if->clazz->hasTag->annoType->annos->if->hasTag->make->at->TypeApply->make->at->AnnotatedType->else->if->clazz->hasTag->make->at->TypeApply->clazztype->try->TreeInfo->isEnumInit->attribIdentAsEnumType->attribType->catch->finally->chk->checkDiamond->chk->validate->if->TreeInfo->TreeInfo->symbol->setSymbol->if->if->clazztype->isErroneous->if->isInterface->log->pos->error->else->if->isStatic->log->pos->Errors->QualifiedNewOfStaticClass->error->else->if->isInterface->clazztype->getEnclosingType->hasTag->rs->tree->pos->resolveImplicitThis->argtypesBuf->new->ListBuffer<>->pkind->attribArgs->argtypes->argtypesBuf->toList->typeargtypes->attribTypes->if->clazztype->hasTag->clazztype->hasTag->if->hasTag->log->tree->pos->error->isSpeculativeDiamondInferenceRound->TreeInfo->isDiamond->deferredAttrContext->skipNonDiamondPath->if->flags->log->tree->pos->Errors->AbstractCantBeInstantiated->error->else->if->isInterface->if->argtypes->isEmpty->log->pos->error->if->typeargtypes->isEmpty->log->pos->error->List->nil->List->nil->if->TreeInfo->isDiamond->site->clazztype->getEnclosingType->getTypeArguments->clazztype->getMetadata->new->ClassType->diamondEnv->localEnv->dup->constructor->rs->tree->pos->resolveDiamond->constructor->baseSymbol->csym->diamondResult->newMethodTemplate->diamondContext->new->ResultInfo->constructorType->types->createErrorType->checkId->types->createErrorType->if->constructorType->isErroneous->constructorType->getReturnType->types->createMethodTypeWithReturn->chk->checkClassType->else->if->rsEnv->localEnv->dup->rs->tree->pos->resolveConstructor->if->newMethodTemplate->new->ResultInfo->checkId->if->lastResolveVarargs->Assert->isErroneous->check->if->visitAnonymousClassDefinition->return->if->check->inferenceContext->inferenceContext->if->inferenceContext->free->inferenceContext->List->of->instantiatedContext->asInstType->addFreeTypeListener->chk->validate
Attr#visitAnonymousClassDefinition(JCNewClass, JCExpression, Type, JCClassDecl, Env, List, List, KindSelector)::: attr visit anonymous class definition:::inferenceContext->inferenceContext->isDiamond->TreeInfo->isDiamond->if->inferenceContext->free->inferenceContext->free->resultInfoForClassDefinition->inferenceContext->List->of->instantiatedContext->asInstType->instantiatedContext->asInstType->prevResult->try->visitAnonymousClassDefinition->catch->finally->addFreeTypeListener->else->if->clazztype->hasTag->invalidDiamondArgs->chk->checkDiamondDenotable->if->clazztype->isErroneous->invalidDiamondArgs->nonEmpty->fragment->Diamond->log->pos->Errors->invalidDiamondArgs->size->DiamondInvalidArgs->DiamondInvalidArg->CantApplyDiamond1->error->foreach->clazztype->getTypeArguments->rs->checkAccessibleType->implementing->isInterface->clazztype->isErroneous->clazztype->getOriginalType->hasTag->clazztype->getOriginalType->isInterface->if->List->of->else->if->deferredAttrContext->isSerializable->attribStat->finalargtypes->if->isInterface->argtypes->prepend->else->if->pkind->contains->finalargtypes->map->clazztype->hasTag->types->createErrorType->sym->rs->tree->pos->resolveConstructor->Assert->isResolutionError->check->newMethodTemplate->new->ResultInfo->checkId->owntype->types->createErrorType->resultInfo->dup->check->chk->validate
Attr#diamondContext(JCNewClass, TypeSymbol, CheckContext)::: attr diamond context:::return->new->Check.NestedCheckContext
Attr#makeNullCheck(JCExpression):::Make an attributed null check tree.:::if->arg->getTag->return->name->TreeInfo->name->if->return->optag->tree->make->at->Unary->operators->resolveUnary->return
Attr#visitNewArray(JCNewArray)::: attr visit new array:::owntype->types->createErrorType->localEnv->env->dup->elemtype->if->attribType->chk->validate->for->l->l->nonEmpty->else->if->pt->hasTag->types->pt->elemtype->else->if->pt->hasTag->isErroneous->log->tree->pos->Errors->pt->IllegalInitializerForType->error->types->pt->createErrorType->if->attribExprs->new->ArrayType->if->types->isReifiable->log->tree->pos->error->check
Attr#visitLambda(JCLambda)::: attr visit lambda:::if->pt->isErroneous->pt->hasTag->pt->if->pt->hasTag->isErroneous->log->that->pos->error->types->pt->createErrorType->return->localEnv->lambdaEnv->needsRecovery->deferredAttrContext->try->if->pt->isSerializable->explicitParamTypes->if->attribStats->TreeInfo->types->targetInfo->getTargetInfo->currentTarget->lambdaType->if->currentTarget->isErroneous->return->pt->setFunctionalInfo->if->lambdaType->hasTag->msg->Fragments->kindName->InvalidGenericLambdaTarget->diags->fragment->report->types->pt->createErrorType->return->if->actuals->lambdaType->getParameterTypes->params->arityMismatch->while->params->nonEmpty->if->actuals->isEmpty->argType->if->isImplicitlyTyped->setSyntheticVariableType->actuals->isEmpty->attribStats->if->diags->fragment->report->types->createErrorType->return->bodyResultInfo->lambdaBodyResult->if->that->getBodyKind->that->getBody->attribTree->else->body->attribStats->check->isSpeculativeRound->deferredAttrContext->preFlow->flow->analyzeLambda->checkLambdaCompatible->if->if->inferenceContext->lambdaType->getThrownTypes->free->inferredThrownTypes->flow->analyzeLambdaThrownTypes->if->lambdaType->getThrownTypes->inferenceContext->checkExConstraints->log->Errors->lambdaType->getThrownTypes->IncompatibleThrownTypesInMref->error->inferenceContext->checkAccessibleTypes->check->catch->cause->ex->getDiagnostic->report->types->pt->createErrorType->return->throw->finally->leave->if->attribTree
Attr#getTargetInfo(JCPolyExpression, ResultInfo, List)::: attr get target info:::lambdaType->currentTarget->if->targetChecker->visit->if->currentTarget->isIntersection->if->infer->instantiateFunctionalInterface->types->removeWildcards->types->findDescriptorType->else->ict->components->new->ListBuffer<>->foreach->ict->getExplicitComponents->if->try->infer->instantiateFunctionalInterface->catch->finally->types->removeWildcards->components->add->types->components->toList->makeIntersectionType->types->findDescriptorType->else->fallbackDescriptorType->if->that->hasTag->lambdaType->hasTag->msg->Fragments->kindName->InvalidGenericLambdaTarget->diags->fragment->report->types->pt->createErrorType->return->new->TargetInfo
Attr#preFlow(JCLambda)::: attr pre flow:::new->PostAttrAnalyzer->scan
Attr#fallbackDescriptorType(JCExpression)::: attr fallback descriptor type:::switch->tree->getTag->lambda->argtypes->List->nil->foreach->argtypes->append->argtypes->append->return->List->of->new->MethodType->return->List->nil->List->of->new->MethodType->Assert->error->return
Attr#checkAccessibleTypes(DiagnosticPosition, Env, InferenceContext, Type...)::: attr check accessible types:::List->from->checkAccessibleTypes
Attr#checkAccessibleTypes(DiagnosticPosition, Env, InferenceContext, List)::: attr check accessible types:::if->inferenceContext->free->inferenceContext->solvedContext->asInstTypes->checkAccessibleTypes->addFreeTypeListener->else->foreach->rs->checkAccessibleType
Attr.FunctionalReturnContext#compatible(Type, Type, Warner)::: functional return context compatible:::return->inferenceContext->asUndetVar->inferenceContext->asUndetVar->compatible
Attr.FunctionalReturnContext#report(DiagnosticPosition, JCDiagnostic)::: functional return context report:::enclosingContext->diags->Fragments->IncompatibleRetTypeInLambda->fragment->report
Attr.ExpressionLambdaReturnContext#report(DiagnosticPosition, JCDiagnostic)::: expression lambda return context report:::if->enclosingContext->diags->fragment->report->else->super->report
Attr.ExpressionLambdaReturnContext#compatible(Type, Type, Warner)::: expression lambda return context compatible:::if->req->hasTag->return->TreeInfo->isExpressionStatement->else->return->super->compatible
Attr#lambdaBodyResult(JCLambda, Type, ResultInfo)::: attr lambda body result:::funcContext->that->getBodyKind->that->getBody->new->ExpressionLambdaReturnContext->new->FunctionalReturnContext->return->descriptor->getReturnType->descriptor->getReturnType->new->ResultInfo
Attr#checkLambdaCompatible(JCLambda, Type, CheckContext):::Lambda compatibility:::returnType->checkContext->inferenceContext->descriptor->getReturnType->asUndetVar->if->tree->getBodyKind->returnType->hasTag->msg->Fragments->Fragments->MissingRetVal->IncompatibleRetTypeInLambda->checkContext->diags->fragment->report->argTypes->checkContext->inferenceContext->descriptor->getParameterTypes->asUndetVars->if->types->TreeInfo->types->isSameTypes->checkContext->diags->fragment->report
Attr#removeClinit(ClassSymbol)::: attr remove clinit:::return->clinits->remove
Attr#lambdaEnv(JCLambda, Env)::: attr lambda env:::lambdaEnv->owner->if->enclClass->owner->enclClass->newScopeOwner->if->owner->flags->foreach->getSymbolsByName->break->else->clinit->clinits->get->if->clinitType->List->nil->List->nil->new->MethodType->new->MethodSymbol->List->nil->clinits->put->env->dupUnshared->dup->dup->else->env->dup->dup->dup->return
Attr#visitReference(JCMemberReference)::: attr visit reference:::if->pt->isErroneous->pt->hasTag->pt->if->pt->hasTag->isErroneous->log->that->pos->error->types->pt->createErrorType->return->localEnv->env->dup->try->exprType->memberReferenceQualifierResult->attribTree->if->that->getMode->chk->checkConstructorRefType->if->exprType->isErroneous->exprType->isRaw->log->pos->Errors->Kinds->that->getMode->kindName->InvalidMref->error->types->createErrorType->if->exprType->isErroneous->return->if->TreeInfo->isStaticSelector->chk->validate->else->lhsSym->TreeInfo->symbol->typeargtypes->List->nil->if->attribTypes->isTargetSerializable->deferredAttrContext->pt->isSerializable->targetInfo->getTargetInfo->currentTarget->desc->pt->setFunctionalInfo->argtypes->desc->getParameterTypes->referenceCheck->if->inferenceContext->free->rs->inferenceContext->new->MethodReferenceCheck->refResult->saved_undet->inferenceContext->save->try->rs->inferenceContext->resolveMemberReference->catch->finally->inferenceContext->rollback->refSym->lookupHelper->if->targetError->switch->break->break->Assert->error->detailsDiag->refSym->baseSymbol->getDiagnostic->diag->diags->log->currentSource->Fragments->Kinds->that->getMode->kindName->InvalidMref->Errors->Kinds->that->getMode->kindName->InvalidMref->create->if->return->else->if->report->else->log->report->types->createErrorType->return->refSym->isConstructor->refSym->baseSymbol->lookupHelper->referenceKind->rs->enclClass->isAccessible->if->desc->getReturnType->return->if->that->getMode->enclosingType->exprType->getEnclosingType->if->enclosingType->hasTag->rs->that->pos->resolveImplicitThis->if->deferredAttrContext->if->that->getMode->TreeInfo->isStaticSelector->isUnbound->isRaw->chk->checkRaw->if->isStatic->TreeInfo->isStaticSelector->exprType->getTypeArguments->nonEmpty->log->pos->Errors->Kinds->that->getMode->kindName->InvalidMref->error->types->createErrorType->return->if->refSym->isStatic->rs->that->pos->checkNonAbstract->if->chk->checkAccessFromSerializableElement->checkInfo->resultInfo->desc->getReturnType->hasTag->desc->getReturnType->isUnbound->newMethodTemplate->new->FunctionalReturnContext->dup->refType->checkId->if->isUnbound->inferenceContext->free->if->types->inferenceContext->asUndetVar->isSubtype->Assert->error->if->refType->isErroneous->types->getParameterTypes->refType->getReturnType->adjustMethodReturnType->createMethodTypeWithReturn->isSpeculativeRound->deferredAttrContext->checkReferenceCompatible->if->inferenceContext->checkAccessibleTypes->check->catch->cause->ex->getDiagnostic->report->types->pt->createErrorType->return->finally
Attr#memberReferenceQualifierResult(JCMemberReference)::: attr member reference qualifier result:::return->tree->getMode->new->ResultInfo
Attr#checkReferenceCompatible(JCMemberReference, Type, Type, CheckContext, boolean)::: attr check reference compatible:::inferenceContext->checkContext->inferenceContext->returnType->inferenceContext->descriptor->getReturnType->asUndetVar->resType->switch->tree->getMode->if->isRaw->break->refType->getReturnType->incompatibleReturnType->if->returnType->hasTag->if->returnType->hasTag->resType->hasTag->if->resType->isErroneous->new->FunctionalReturnContext->checkContext->checkWarner->compatible->if->msg->Fragments->Fragments->descriptor->getReturnType->InconvertibleTypes->IncompatibleRetTypeInMref->checkContext->diags->fragment->report->else->if->inferenceContext->free->inferenceContext->List->of->instantiatedContext->asInstType->addFreeTypeListener->else->if->if->refType->getThrownTypes->descriptor->getThrownTypes->checkExConstraints->log->Errors->refType->getThrownTypes->IncompatibleThrownTypesInMref->error
Attr#checkExConstraints(List, List, InferenceContext)::: attr check ex constraints:::nonProperList->thrownAtFuncType->stream->inferenceContext->free->filter->List->collector->collect->properList->thrownAtFuncType->diff->checkedList->thrownByFuncExpr->stream->chk->isChecked->filter->List->collector->collect->uncaughtByProperTypes->new->ListBuffer<>->foreach->isSubtype->foreach->if->types->isSubtype->break->if->uncaughtByProperTypes->add->if->nonProperList->isEmpty->uncaughtByProperTypes->isEmpty->return->nonProperAsUndet->inferenceContext->asUndetVars->uncaughtByProperTypes->nonProperAsUndet->types->isSubtype->forEach->forEach->nonProperAsUndet->stream->t->hasTag->filter->setThrow->forEach->return
Attr#setFunctionalInfo(Env, JCFunctionalExpression, Type, Type, Type, CheckContext):::Set functional type info on the underlying AST:::if->checkContext->inferenceContext->free->checkContext->inferenceContext->List->of->inferenceContext->asInstType->inferenceContext->asInstType->setFunctionalInfo->addFreeTypeListener->else->if->pt->hasTag->if->checkContext->deferredAttrContext->try->csym->types->makeFunctionalInterfaceClass->if->chk->checkImplementations->try->types->findDescriptorType->catch->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->report->finally->catch->cause->ex->getDiagnostic->report->finally
Attr#visitParens(JCParens)::: attr visit parens:::owntype->attribTree->pkind->check->sym->TreeInfo->symbol->if->matches->log->tree->pos->error
Attr#visitAssign(JCAssign)::: attr visit assign:::owntype->env->dup->attribTree->capturedType->capture->attribExpr->check
Attr#visitAssignop(JCAssignOp)::: attr visit assignop:::owntype->attribTree->operand->attribExpr->operator->operators->tree->getTag->noAssignOp->resolveBinary->if->owntype->isErroneous->operand->isErroneous->chk->pos->checkDivZero->chk->pos->getReturnType->checkCastable->check
Attr#visitUnary(JCUnary)::: attr visit unary:::argtype->tree->getTag->isIncOrDecUnaryOp->attribTree->chk->pos->attribExpr->checkNonVoid->operator->operators->tree->getTag->resolveUnary->owntype->types->createErrorType->if->argtype->isErroneous->tree->getTag->isIncOrDecUnaryOp->getReturnType->opc->if->argtype->constValue->ctype->cfolder->fold1->if->cfolder->coerce->check
Attr#visitBinary(JCBinary)::: attr visit binary:::left->chk->pos->attribExpr->checkNonVoid->right->chk->pos->attribExpr->checkNonVoid->operator->operators->tree->getTag->resolveBinary->owntype->types->createErrorType->if->left->isErroneous->right->isErroneous->getReturnType->opc->if->left->constValue->right->constValue->ctype->cfolder->fold2->if->cfolder->coerce->if->if->types->tree->pos->new->Warner->isCastable->log->tree->pos->Errors->IncomparableTypes->error->chk->pos->checkDivZero->check
Attr#visitTypeCast(JCTypeCast)::: attr visit type cast:::clazztype->attribType->chk->validate->localEnv->env->dup->castInfo->expr->TreeInfo->skipParens->isPoly->expr->hasTag->expr->hasTag->if->new->Check.NestedCheckContext->new->ResultInfo->else->exprtype->attribTree->owntype->chk->pos->checkCastable->if->exprtype->constValue->cfolder->coerce->capture->check->if->chk->checkRedundantCast
Attr#visitTypeTest(JCInstanceOf)::: attr visit type test:::exprtype->chk->pos->attribExpr->checkNullOrRefType->clazztype->attribType->if->clazztype->hasTag->chk->pos->checkClassOrArrayType->if->clazztype->isErroneous->types->isReifiable->log->pos->error->types->createErrorType->chk->validate->chk->pos->checkCastable->check
Attr#visitIndexed(JCArrayAccess)::: attr visit indexed:::owntype->types->createErrorType->atype->attribExpr->attribExpr->if->types->isArray->types->elemtype->else->if->atype->hasTag->log->tree->pos->Errors->ArrayReqButFound->error->if->pkind->contains->capture->check
Attr#visitIdent(JCIdent)::: attr visit ident:::sym->if->pt->hasTag->pt->hasTag->rs->tree->pos->pt->getParameterTypes->pt->getTypeArguments->resolveMethod->else->if->else->rs->tree->pos->pkind->resolveIdent->symEnv->noOuterThisPath->if->matches->while->sym->isMemberOf->if->flags->if->v->checkInit->if->pkind->subset->tree->pos->checkAssignable->if->matches->sym->flags->chk->tree->pos->tree->pos->thisSym->earlyRefError->env1->if->while->rs->isAccessible->if->chk->checkAccessFromSerializableElement->checkId
Attr#visitSelect(JCFieldAccess)::: attr visit select:::skind->if->else->if->pkind->contains->KindSelector->of->if->pkind->contains->KindSelector->of->if->pkind->contains->KindSelector->of->site->new->ResultInfo->attribTree->if->pkind->contains->capture->if->elt->while->elt->hasTag->if->elt->hasTag->log->tree->pos->error->types->createErrorType->return->sitesym->TreeInfo->symbol->selectSuperPrev->sym->selectSym->if->log->pos->Errors->NotEnclClass->error->if->sym->exists->isType->pkind->contains->capture->selectSym->varArgs->lastResolveVarargs->if->site->hasTag->isType->types->skipTypeVars->if->v->checkInit->if->pkind->subset->tree->pos->checkAssignable->if->isResourceVariable->equals->sym->overrides->isEnabled->log->warning->if->isType->matches->pt->toSelector->pt->new->ResultInfo->check->if->isType->if->if->chk->tree->pos->earlyRefError->else->if->sym->flags->rs->rs->new->StaticError->tree->pos->accessBase->if->sitesym->isInterface->sym->isStatic->log->tree->pos->error->error->else->if->sym->flags->chk->Warnings->kindName->StaticNotQualifiedByType->warnStatic->if->sym->flags->rs->tree->pos->checkNonAbstract->if->site->isRaw->site1->types->asSuper->if->if->chk->checkAccessFromSerializableElement->checkId
Attr#selectSym(JCFieldAccess, Symbol, Type, Env, ResultInfo):::Determine symbol referenced by a Select expression,:::pos->tree->pos->name->switch->site->getTag->return->rs->rs->findIdentInPackage->accessBase->if->hasTag->hasTag->return->rs->getParameterTypes->getTypeArguments->resolveQualifiedMethod->else->if->return->rs->resolveSelf->else->if->return->syms->getClassField->else->sym->rs->findIdentInType->rs->accessBase->return->throw->new->AssertionError->sym->site->getUpperBound->site->getUpperBound->capture->selectSym->if->log->error->return->else->sym2->sym->flags->rs->new->AccessError->rs->accessBase->return->return->types->createErrorType->if->return->syms->getClassField->else->log->Errors->CantDeref->error->return
Attr#checkId(JCTree, Type, Symbol, Env, ResultInfo):::Determine type of identifier or select expression and check that  (1) the referenced symbol is not deprecated  (2) the symbol's type is safe (@see checkSafe)  (3) if symbol is a variable, check that its type and kind are      compatible with the prototype and protokind:::return->hasTag->hasTag->checkMethodIdInternal->checkIdInternal
Attr#checkMethodIdInternal(JCTree, Type, Symbol, Env, ResultInfo)::: attr check method id internal:::if->contains->pt->deferredAttr->new->RecoveryDeferredTypeMap->map->owntype->checkIdInternal->deferredAttr->new->RecoveryDeferredTypeMap->map->return->else->return->checkIdInternal
Attr#checkIdInternal(JCTree, Type, Symbol, Type, Env, ResultInfo)::: attr check id internal:::if->pt->isErroneous->return->types->createErrorType->owntype->switch->if->owntype->hasTag->chk->tree->pos->checkForBadAuxiliaryClassAccess->ownOuter->owntype->getEnclosingType->if->getTypeArguments->nonEmpty->types->erasure->else->if->ownOuter->hasTag->normOuter->if->normOuter->hasTag->types->asEnclosingSuper->if->types->erasure->if->List->nil->owntype->getMetadata->new->ClassType->break->v->if->hasTag->log->TreeInfo->positionFor->Errors->CantInferLocalVarType->error->return->types->createErrorType->if->pkind->subset->v->flags->site->hasTag->site->hasTag->s->types->asOuterSuper->if->s->isRaw->types->v->erasure->isSameType->chk->tree->pos->Warnings->UncheckedAssignToVar->warnUnchecked->types->memberType->if->v->getConstValue->isStaticReference->owntype->v->getConstValue->constType->if->capture->break->getReturnType->new->ResultInfo->TreeInfo->args->getParameterTypes->getTypeArguments->checkMethod->break->break->throw->new->AssertionError->if->tree->hasTag->chk->tree->pos->checkDeprecated->chk->tree->pos->checkSunAPI->chk->tree->pos->checkProfile->return->toSelector->check
Attr#checkInit(JCTree, Env, VarSymbol, boolean):::Check that variable is initialized and evaluate the variable's  initializer, if not yet done:::initEnv->enclosingInitEnv->if->enclClass->v->flags->Resolve->isStatic->hasTag->TreeInfo->skipParens->if->isStaticEnumField->errkey->log->tree->pos->error->else->if->warnkey->Warnings->SelfRef->Warnings->ForwardRef->log->tree->pos->warning->v->getConstValue->checkEnumInitializer
Attr#enclosingInitEnv(Env):::Returns the enclosing init environment associated with this env (if any):::while->switch->getTag->vdecl->if->return->break->if->hasTag->return->break->return->Assert->checkNonNull
Attr#checkEnumInitializer(JCTree, Env, VarSymbol):::Check for illegal references to static members of enum:::if->isStaticEnumField->enclClass->enclClass->if->return->if->types->isSubtype->return->if->Resolve->isInitializer->return->log->tree->pos->error
Attr#isStaticEnumField(VarSymbol):::Is the given symbol a static, non-constant field of an Enum?  Note: enum literals should not be regarded as such:::return->Flags->isEnum->Flags->isStatic->Flags->isConstant
Attr#checkMethod(Type, Symbol, ResultInfo, Env, List, List, List):::Check that method arguments conform to its instantiation.:::if->sym->flags->site->hasTag->site->hasTag->s->types->asOuterSuper->if->s->isRaw->types->getParameterTypes->sym->erasure->getParameterTypes->isSameTypes->chk->pos->Warnings->UncheckedCallMbrOfRawType->warnUnchecked->if->foreach->types->interfaces->types->supertype->prepend->if->sym->enclClass->isSubClass->types->isSameType->continue->icand_sup->types->interfaceCandidates->if->icand_sup->nonEmpty->enclClass->overrides->log->pos->Errors->Fragments->OverriddenDefault->IllegalDefaultSuperCall->error->break->if->sym->isStatic->site->isInterface->hasTag->app->if->hasTag->TreeInfo->isStaticSelector->log->pos->Errors->IllegalStaticIntfMethCall->error->noteWarner->new->Warner->try->owntype->rs->checkMethod->checkDeferredMap->deferredAttr->new->DeferredTypeMap->argtypes->map->if->noteWarner->hasNonSilentLint->chk->pos->Warnings->kindName->rs->getParameterTypes->methodArguments->rs->argtypes->map->methodArguments->sym->location->kindName->sym->location->UncheckedMethInvocationApplied->warnUnchecked->if->owntype->hasTag->owntype->isPartial->owntype->getParameterTypes->types->owntype->getReturnType->erasure->types->owntype->getThrownTypes->erasure->new->MethodType->pkind->hasTag->getReturnType->containsAny->TreeInfo->setPolyKind->return->chk->lastResolveVarargs->inferenceContext->checkMethod->catch->pos->ex->getDiagnostic->report->return->types->createErrorType->diag->ex->getDiagnostic->errSym->rs->new->InapplicableSymbolError->argtypes2->argtypes->rs->new->ResolveDeferredRecoveryMap->map->errDiag->errSym->getDiagnostic->log->report->return->types->createErrorType->finally
Attr#visitLiteral(JCLiteral)::: attr visit literal:::litType->constType->check
Attr#litType(TypeTag):::Return the type of a literal with given type tag.:::return->tag->ordinal
Attr#visitTypeIdent(JCPrimitiveTypeTree)::: attr visit type ident:::ordinal->check
Attr#visitTypeArray(JCArrayTypeTree)::: attr visit type array:::etype->attribType->type->new->ArrayType->check
Attr#visitTypeApply(JCTypeApply):::Visitor method for parameterized types:::owntype->types->createErrorType->clazztype->chk->pos->attribType->checkClassType->actuals->attribTypes->if->clazztype->hasTag->formals->getTypeArguments->if->actuals->isEmpty->if->actuals->length->formals->length->a->f->while->a->nonEmpty->withTypeVar->clazzOuter->clazztype->getEnclosingType->if->clazzOuter->hasTag->site->clazz->TreeInfo->typeIn->if->clazz->hasTag->else->if->clazz->hasTag->else->throw->new->AssertionError->if->clazzOuter->hasTag->if->site->hasTag->types->asOuterSuper->if->types->erasure->clazztype->getMetadata->new->ClassType->else->if->formals->length->log->tree->pos->Errors->Integer->formals->length->toString->WrongNumberTypeArgs->error->else->log->tree->pos->Errors->TypeDoesntTakeParams->error->types->createErrorType->check
Attr#visitTypeUnion(JCTypeUnion)::: attr visit type union:::multicatchTypes->new->ListBuffer<>->all_multicatchTypes->foreach->ctype->attribType->chk->typeTree->pos->chk->typeTree->pos->checkClassType->checkType->if->ctype->isErroneous->if->chk->multicatchTypes->toList->intersects->foreach->sub->types->isSubtype->sup->types->isSubtype->if->a->b->log->typeTree->pos->Errors->MulticatchTypesMustBeDisjoint->error->multicatchTypes->append->if->all_multicatchTypes->append->else->if->new->ListBuffer<>->all_multicatchTypes->appendList->all_multicatchTypes->append->t->types->multicatchTypes->toList->lub->resultInfo->dup->check->if->t->hasTag->alternatives->toList->new->UnionClassType
Attr#visitTypeIntersection(JCTypeIntersection)::: attr visit type intersection:::attribTypes->checkIntersection
Attr#visitTypeParameter(JCTypeParameter)::: attr visit type parameter:::typeVar->if->nonEmpty->annotate->annotateTypeParameterSecondStage->if->isErroneous->checkIntersection
Attr#checkIntersection(JCTree, List)::: attr check intersection:::boundSet->new->HashSet<>->if->bounds->nonEmpty->checkBase->boundSet->types->erasure->add->if->isErroneous->return->else->if->hasTag->if->nonEmpty->log->pos->error->return->else->foreach->checkBase->if->isErroneous->List->of->else->if->hasTag->chk->bound->pos->types->erasure->checkNotRepeated->if->bounds->length->return->else->if->bounds->length->return->else->owntype->types->TreeInfo->types->makeIntersectionType->extending->implementing->if->isInterface->else->cd->make->at->make->Modifiers->List->nil->List->nil->ClassDef->c->Assert->c->flags->check->cenv->enter->classEnv->typeEnvs->put->attribClass->return
Attr#visitWildcard(JCWildcard)::: attr visit wildcard:::type->attribType->chk->tree->pos->checkRefType->new->WildcardType->check
Attr#visitAnnotation(JCAnnotation)::: attr visit annotation:::Assert->error
Attr#visitAnnotatedType(JCAnnotatedType)::: attr visit annotated type:::attribAnnotationTypes->underlyingType->attribType->annotatedType->underlyingType->annotatedType->if->annotate->annotateTypeSecondStage
Attr#visitErroneous(JCErroneous)::: attr visit erroneous:::if->foreach->pt->new->ResultInfo->attribTree
Attr#visitTree(JCTree):::Default visitor method for all other trees.:::throw->new->AssertionError
Attr#attrib(Env):::Attribute an env for either a top level tree or class or module declaration.:::switch->getTag->pos->attribModule->break->attribTopLevel->break->pos->attribPackage->break->pos->attribClass
Attr#attribTopLevel(Env):::Attribute a top level tree:::toplevel->try->annotate->flush->catch->chk->toplevel->pos->completionError->finally
Attr#attribPackage(DiagnosticPosition, PackageSymbol)::: attr attrib package:::try->annotate->flush->attribPackage->catch->chk->completionError->finally
Attr#attribPackage(PackageSymbol)::: attr attrib package:::env->typeEnvs->get->chk->pos->checkDeprecatedAnnotation
Attr#attribModule(DiagnosticPosition, ModuleSymbol)::: attr attrib module:::try->annotate->flush->attribModule->catch->chk->completionError->finally
Attr#attribModule(ModuleSymbol)::: attr attrib module:::env->get->attribStat
Attr#attribClass(DiagnosticPosition, ClassSymbol):::Main method: attribute class definition associated with given class symbol:::try->annotate->flush->attribClass->catch->chk->completionError->finally
Attr#attribClass(ClassSymbol):::Attribute class definition associated with given class symbol.:::if->hasTag->return->chk->checkNonCyclic->st->types->supertype->if->if->st->hasTag->attribClass->if->hasTag->attribClass->if->env->typeEnvs->get->lintEnv->while->augment->prevLint->chk->setLint->prev->log->useSource->prevReturnRes->try->deferredLintHandler->flush->if->log->pos->error->if->log->pos->error->if->isSerializable->attribClassBody->chk->pos->checkDeprecatedAnnotation->chk->pos->checkClassOverrideEqualsAndHashIfNeeded->chk->checkFunctionalInterface->chk->checkLeaksNotAccessible->catch->finally->log->useSource->chk->setLint
Attr#visitImport(JCImport)::: attr visit import:::
Attr#visitModuleDef(JCModuleDecl)::: attr visit module def:::completeUsesProvides->msym->lint->augment->prevLint->chk->setLint->chk->checkModuleName->chk->checkDeprecatedAnnotation->try->deferredLintHandler->tree->pos->flush->catch->finally->chk->setLint
Attr#attribClassBody(Env, ClassSymbol):::Finish the attribution of a class.:::tree->Assert->check->attribStats->if->c->isAnonymous->chk->validate->chk->validate->chk->validate->c->markAbstractIfNeeded->if->c->flags->chk->tree->pos->checkAllDefined->if->c->flags->if->nonEmpty->log->pos->error->if->nonEmpty->log->pos->Errors->IntfAnnotationCantHaveTypeParams->error->repeatable->c->getAnnotationTypeMetadata->getRepeatable->if->cbPos->getDiagnosticPosition->Assert->checkNonNull->chk->validateRepeatable->else->chk->tree->pos->checkCompatibleSupertypes->if->chk->tree->pos->checkDefaultMethodClashes->chk->tree->pos->checkClassBounds->for->l->l->nonEmpty->if->allparams->isEmpty->types->isSubtype->log->pos->error->chk->checkImplementations->tree->pos->checkAutoCloseable->for->l->l->nonEmpty->chk->checkCyclicConstructors->chk->checkNonCyclicElements->if->isEnabled->isSerializable->c->flags->c->isAnonymous->checkSerialVersionUID->if->typeAnnotations->organizeTypeAnnotationsBodies->validateTypeAnnotations
Attr#getDiagnosticPosition(JCClassDecl, Type):::get a diagnostic position for an attribute of Type t, or null if attribute missing:::for->al->al->isEmpty->return
Attr#isSerializable(Type):::check if a type is a subtype of Serializable, if that is available.:::try->complete->catch->return->finally->return->types->isSubtype
Attr#checkSerialVersionUID(JCClassDecl, ClassSymbol):::Check that an appropriate serialVersionUID member is defined.:::svuid->foreach->c->members->getSymbolsByName->if->break->if->log->tree->pos->Warnings->MissingSVUID->warning->return->if->svuid->flags->log->TreeInfo->diagnosticPositionFor->Warnings->ImproperSVUID->warning->else->if->hasTag->log->TreeInfo->diagnosticPositionFor->Warnings->LongSVUID->warning->else->if->svuid->getConstValue->log->TreeInfo->diagnosticPositionFor->Warnings->ConstantSVUID->warning
Attr#capture(Type)::: attr capture:::return->types->capture
Attr#setSyntheticVariableType(JCVariableDecl, Type)::: attr set synthetic variable type:::if->type->isErroneous->make->at->Erroneous->else->make->at->Type
Attr#validateTypeAnnotations(JCTree, boolean)::: attr validate type annotations:::tree->new->TypeAnnotationsValidator->accept
Attr.TypeAnnotationsValidator#visitAnnotation(JCAnnotation)::: type annotations validator visit annotation:::chk->validateTypeAnnotation->super->visitAnnotation
Attr.TypeAnnotationsValidator#visitAnnotatedType(JCAnnotatedType)::: type annotations validator visit annotated type:::if->isErroneous->super->visitAnnotatedType
Attr.TypeAnnotationsValidator#visitTypeParameter(JCTypeParameter)::: type annotations validator visit type parameter:::chk->validateTypeAnnotations->scan
Attr.TypeAnnotationsValidator#visitMethodDef(JCMethodDecl)::: type annotations validator visit method def:::if->isErroneous->checkForDeclarationAnnotations->if->validateAnnotatedType->if->scan->scan->scan->scan->scan->scan->else->scan->scan
Attr.TypeAnnotationsValidator#visitVarDef(JCVariableDecl)::: type annotations validator visit var def:::if->tree->isImplicitlyTyped->validateAnnotatedType->scan->scan->if->scan
Attr.TypeAnnotationsValidator#visitTypeCast(JCTypeCast)::: type annotations validator visit type cast:::if->validateAnnotatedType->super->visitTypeCast
Attr.TypeAnnotationsValidator#visitTypeTest(JCInstanceOf)::: type annotations validator visit type test:::if->validateAnnotatedType->super->visitTypeTest
Attr.TypeAnnotationsValidator#visitNewClass(JCNewClass)::: type annotations validator visit new class:::if->if->hasTag->checkForDeclarationAnnotations->if->checkForDeclarationAnnotations->validateAnnotatedType->super->visitNewClass
Attr.TypeAnnotationsValidator#visitNewArray(JCNewArray)::: type annotations validator visit new array:::if->if->hasTag->checkForDeclarationAnnotations->validateAnnotatedType->super->visitNewArray
Attr.TypeAnnotationsValidator#visitClassDef(JCClassDecl)::: type annotations validator visit class def:::if->scan->scan->scan->scan->foreach->if->member->hasTag->continue->scan
Attr.TypeAnnotationsValidator#visitBlock(JCBlock)::: type annotations validator visit block:::if->scan
Attr.TypeAnnotationsValidator#validateAnnotatedType(JCTree, Type)::: type annotations validator validate annotated type:::if->type->isPrimitiveOrVoid->return->enclTr->enclTy->repeat->while->if->enclTr->hasTag->tyargs->enclTy->getTypeArguments->trargs->getTypeArguments->if->trargs->length->if->tyargs->length->trargs->length->for->i->tyargs->length->if->enclTr->hasTag->getExpression->if->enclTy->hasTag->enclTy->getEnclosingType->else->if->enclTr->hasTag->at->if->enclTy->hasTag->if->at->getAnnotations->size->log->pos->Errors->at->getAnnotations->CantTypeAnnotateScoping1->error->else->comps->new->ListBuffer<>->foreach->at->getAnnotations->comps->add->log->pos->Errors->comps->toList->CantTypeAnnotateScoping->error->else->if->enclTr->hasTag->else->if->enclTr->hasTag->wc->if->wc->getKind->wc->getKind->wc->getBound->wc->getBound->validateAnnotatedType->else->else->if->enclTr->hasTag->art->art->getType->validateAnnotatedType->else->if->enclTr->hasTag->ut->foreach->ut->getTypeAlternatives->validateAnnotatedType->else->if->enclTr->hasTag->it->foreach->it->getBounds->validateAnnotatedType->else->if->enclTr->getKind->enclTr->getKind->else->Assert->enclTr->getKind->errtree->getKind->error
Attr.TypeAnnotationsValidator#checkForDeclarationAnnotations(List, Symbol)::: type annotations validator check for declaration annotations:::foreach->if->isErroneous->typeAnnotations->annotationTargetType->log->ai->pos->Errors->AnnotationTypeNotApplicableToType->error
Attr#postAttr(JCTree):::Handle missing types/symbols in an AST:::new->PostAttrAnalyzer->scan
Attr.PostAttrAnalyzer#initTypeIfNeeded(JCTree)::: post attr analyzer init type if needed:::if->if->that->hasTag->dummyMethodType->else
Attr.PostAttrAnalyzer#dummyMethodType(JCMethodDecl)::: post attr analyzer dummy method type:::restype->if->hasTag->prim->if->return->List->nil->List->nil->new->MethodType
Attr.PostAttrAnalyzer#dummyMethodType()::: post attr analyzer dummy method type:::return->dummyMethodType
Attr.PostAttrAnalyzer#scan(JCTree)::: post attr analyzer scan:::if->return->if->initTypeIfNeeded->super->scan
Attr.PostAttrAnalyzer#visitIdent(JCIdent)::: post attr analyzer visit ident:::if
Attr.PostAttrAnalyzer#visitSelect(JCFieldAccess)::: post attr analyzer visit select:::if->super->visitSelect
Attr.PostAttrAnalyzer#visitClassDef(JCClassDecl)::: post attr analyzer visit class def:::initTypeIfNeeded->if->new->ClassSymbol->super->visitClassDef
Attr.PostAttrAnalyzer#visitMethodDef(JCMethodDecl)::: post attr analyzer visit method def:::initTypeIfNeeded->if->new->MethodSymbol->super->visitMethodDef
Attr.PostAttrAnalyzer#visitVarDef(JCVariableDecl)::: post attr analyzer visit var def:::initTypeIfNeeded->if->new->VarSymbol->if->make->at->Erroneous->super->visitVarDef
Attr.PostAttrAnalyzer#visitNewClass(JCNewClass)::: post attr analyzer visit new class:::if->dummyMethodType->new->MethodSymbol->if->super->visitNewClass
Attr.PostAttrAnalyzer#visitAssignop(JCAssignOp)::: post attr analyzer visit assignop:::if->dummyMethodType->new->OperatorSymbol->super->visitAssignop
Attr.PostAttrAnalyzer#visitBinary(JCBinary)::: post attr analyzer visit binary:::if->dummyMethodType->new->OperatorSymbol->super->visitBinary
Attr.PostAttrAnalyzer#visitUnary(JCUnary)::: post attr analyzer visit unary:::if->dummyMethodType->new->OperatorSymbol->super->visitUnary
Attr.PostAttrAnalyzer#visitLambda(JCLambda)::: post attr analyzer visit lambda:::super->visitLambda->if
Attr.PostAttrAnalyzer#visitReference(JCMemberReference)::: post attr analyzer visit reference:::super->visitReference->if->dummyMethodType->new->MethodSymbol->if
Attr#setPackageSymbols(JCExpression, Symbol)::: attr set package symbols:::new->TreeScanner->scan
AttrContext#dup(WriteableScope):::Duplicate this context, replacing scope field and copying all others.:::info->new->AttrContext->return
AttrContext#dup():::Duplicate this context, copying all fields.:::return->dup
AttrContext#getLocalElements()::: attr context get local elements:::if->return->List->nil->return->scope->getSymbols
AttrContext#lastResolveVarargs()::: attr context last resolve varargs:::return->pendingResolutionPhase->isVarargsRequired
AttrContext#toString()::: attr context to string:::return->scope->toString
Check#instance(Context)::: check instance:::instance->context->get->if->new->Check->return
Check#setLint(Lint)::: check set lint:::prev->return
Check#setMethod(MethodSymbol)::: check set method:::prev->return
Check#warnDeprecated(DiagnosticPosition, Symbol):::Warn about deprecated symbol.:::if->sym->isDeprecatedForRemoval->if->lint->isSuppressed->if->removalHandler->Warnings->HasBeenDeprecatedForRemovalModule->report->else->removalHandler->Warnings->sym->location->HasBeenDeprecatedForRemoval->report->else->if->lint->isSuppressed->if->deprecationHandler->Warnings->HasBeenDeprecatedModule->report->else->deprecationHandler->Warnings->sym->location->HasBeenDeprecated->report
Check#warnUnchecked(DiagnosticPosition, Warning):::Warn about unchecked operation.:::if->lint->isSuppressed->uncheckedHandler->report
Check#warnUnsafeVararg(DiagnosticPosition, Warning):::Warn about unsafe vararg method decl.:::if->lint->isEnabled->allowedInSource->log->warning
Check#warnStatic(DiagnosticPosition, Warning)::: check warn static:::if->lint->isEnabled->log->warning
Check#warnDivZero(DiagnosticPosition):::Warn about division by integer constant zero.:::if->lint->isEnabled->log->warning
Check#reportDeferredDiagnostics():::Report any deferred diagnostics.:::deprecationHandler->reportDeferredDiagnostic->removalHandler->reportDeferredDiagnostic->uncheckedHandler->reportDeferredDiagnostic->sunApiHandler->reportDeferredDiagnostic
Check#completionError(DiagnosticPosition, CompletionFailure):::Report a failure to complete a class.:::log->Errors->ex->getDetailValue->CantAccess->error->return
Check#typeTagError(DiagnosticPosition, JCDiagnostic, Object):::Report an error that wrong type tag was found.:::if->hasTag->log->error->return->log->Errors->TypeFoundReq->error->return->types->createErrorType
Check#earlyRefError(DiagnosticPosition, Symbol):::Report an error that symbol cannot be referenced before super  has been called.:::log->Errors->CantRefBeforeCtorCalled->error
Check#duplicateError(DiagnosticPosition, Symbol):::Report duplicate declaration error.:::if->isErroneous->location->sym->location->if->isStaticOrInstanceInit->log->Errors->kindName->sym->location->kindName->sym->location->enclClass->kindName->sym->location->enclClass->AlreadyDefinedInClinit->error->else->log->Errors->kindName->sym->location->kindName->sym->location->AlreadyDefined->error
Check#varargsDuplicateError(DiagnosticPosition, Symbol, Symbol):::Report array/varargs duplicate declaration:::if->isErroneous->isErroneous->log->Errors->sym2->location->ArrayAndVarargs->error
Check#checkTransparentVar(DiagnosticPosition, VarSymbol, Scope):::Check that variable does not hide variable with same name in  immediately enclosing local scope.:::foreach->s->getSymbolsByName->if->break->if->matches->duplicateError->return
Check#checkTransparentClass(DiagnosticPosition, ClassSymbol, Scope):::Check that a class or interface does not hide a class or  interface with same name in immediately enclosing local scope.:::foreach->s->getSymbolsByName->if->break->if->hasTag->matches->duplicateError->return
Check#checkUniqueClassName(DiagnosticPosition, Name, Scope):::Check that class does not have the same name as one of  its enclosing classes, or as a class defined in its enclosing scope:::foreach->s->getSymbolsByName->if->duplicateError->return->for->sym->return
Check#localClassName(ClassSymbol):::Return name of local class:::enclFlatname->enclClass->enclFlatnameStr->enclFlatname->toString->key->new->Pair<>->index->localClassNameIndexes->get->for->i
Check#clearLocalClassNameIndexes(ClassSymbol)::: check clear local class name indexes:::if->localClassNameIndexes->enclClass->new->Pair<>->remove
Check#newRound()::: check new round:::compiled->clear->localClassNameIndexes->clear
Check#putCompiled(ClassSymbol)::: check put compiled:::compiled->Pair->csym->packge->of->put
Check#getCompiled(ClassSymbol)::: check get compiled:::return->compiled->Pair->csym->packge->of->get
Check#getCompiled(ModuleSymbol, Name)::: check get compiled:::return->compiled->Pair->of->get
Check#removeCompiled(ClassSymbol)::: check remove compiled:::compiled->Pair->csym->packge->of->remove
Check.CheckContext#compatible(Type, Type, Warner):::Is type 'found' compatible with type 'req' in given context:::
Check.CheckContext#report(DiagnosticPosition, JCDiagnostic):::Report a check error:::
Check.CheckContext#checkWarner(DiagnosticPosition, Type, Type):::Obtain a warner for this check context:::
Check.CheckContext#inferenceContext()::: check context inference context:::
Check.CheckContext#deferredAttrContext()::: check context deferred attr context:::
Check.NestedCheckContext#compatible(Type, Type, Warner)::: nested check context compatible:::return->enclosingContext->compatible
Check.NestedCheckContext#report(DiagnosticPosition, JCDiagnostic)::: nested check context report:::enclosingContext->report
Check.NestedCheckContext#checkWarner(DiagnosticPosition, Type, Type)::: nested check context check warner:::return->enclosingContext->checkWarner
Check.NestedCheckContext#inferenceContext()::: nested check context inference context:::return->enclosingContext->inferenceContext
Check.NestedCheckContext#deferredAttrContext()::: nested check context deferred attr context:::return->enclosingContext->deferredAttrContext
Check#checkType(DiagnosticPosition, Type, Type):::Check that a given type is assignable to a given proto-type:::return->checkType
Check#checkType(DiagnosticPosition, Type, Type, CheckContext)::: check check type:::inferenceContext->checkContext->inferenceContext->if->inferenceContext->free->inferenceContext->free->inferenceContext->List->of->solvedContext->asInstType->solvedContext->asInstType->checkType->addFreeTypeListener->if->req->hasTag->return->if->req->hasTag->return->if->checkContext->checkContext->checkWarner->compatible->return->else->if->found->isNumeric->req->isNumeric->checkContext->diags->Fragments->PossibleLossOfPrecision->fragment->report->return->types->createErrorType->checkContext->diags->Fragments->InconvertibleTypes->fragment->report->return->types->createErrorType
Check#checkCastable(DiagnosticPosition, Type, Type):::Check that a given type can be cast to a given target type:::return->checkCastable
Check#checkCastable(DiagnosticPosition, Type, Type, CheckContext)::: check check castable:::if->types->castWarner->isCastable->return->else->checkContext->diags->Fragments->InconvertibleTypes->fragment->report->return->types->createErrorType
Check#checkRedundantCast(Env, JCTypeCast):::Check for redundant casts (i.e:::if->isErroneous->types->isSameType->TreeInfo->containsTypeAnnotation->is292targetTypeCast->deferredLintHandler->if->lint->isEnabled->log->tree->pos->Warnings->RedundantCast->warning->report
Check#is292targetTypeCast(JCTypeCast)::: check is292target type cast:::is292targetTypeCast->expr->TreeInfo->skipParens->if->expr->hasTag->apply->sym->TreeInfo->symbol->sym->flags->return
Check#checkExtends(Type, Type):::Check that a type is within some bounds:::if->a->isUnbound->return->else->if->a->hasTag->types->cvarUpperBound->return->types->isSubtype->else->if->a->isExtendsBound->return->types->types->wildUpperBound->isCastable->else->if->a->isSuperBound->return->types->types->wildLowerBound->notSoftSubtype->return
Check#checkNonVoid(DiagnosticPosition, Type):::Check that type is different from 'void'.:::if->t->hasTag->log->error->return->types->createErrorType->else->return
Check#checkClassOrArrayType(DiagnosticPosition, Type)::: check check class or array type:::if->t->hasTag->t->hasTag->t->hasTag->return->diags->fragment->asTypeParam->typeTagError->else->return
Check#checkClassType(DiagnosticPosition, Type):::Check that type is a class or interface type.:::if->t->hasTag->t->hasTag->return->diags->fragment->asTypeParam->typeTagError->else->return
Check#asTypeParam(Type)::: check as type param:::return->t->hasTag->diags->Fragments->TypeParameter->fragment
Check#checkConstructorRefType(DiagnosticPosition, Type):::Check that type is a valid qualifier for a constructor reference expression:::checkClassOrArrayType->if->t->hasTag->if->flags->log->Errors->AbstractCantBeInstantiated->error->types->createErrorType->else->if->flags->log->error->types->createErrorType->else->checkClassType->else->if->t->hasTag->if->types->isReifiable->log->error->types->createErrorType->return
Check#checkClassType(DiagnosticPosition, Type, boolean):::Check that type is a class or interface type.:::checkClassType->if->t->isParameterized->args->t->getTypeArguments->while->args->nonEmpty->if->hasTag->return->diags->fragment->typeTagError->return
Check#checkRefType(DiagnosticPosition, Type):::Check that type is a reference type, i.e:::if->t->isReference->return->else->return->diags->fragment->typeTagError
Check#checkRefTypes(List, List):::Check that each type is a reference type, i.e:::tl->for->l->l->nonEmpty->return
Check#checkNullOrRefType(DiagnosticPosition, Type):::Check that type is a null or reference type.:::if->t->isReference->t->hasTag->return->else->return->diags->fragment->typeTagError
Check#checkDisjoint(DiagnosticPosition, long, long, long):::Check that flag set does not contain elements of two conflicting sets:::if->log->Errors->TreeInfo->firstFlag->asFlagSet->TreeInfo->firstFlag->asFlagSet->IllegalCombinationOfModifiers->error->return->else->return
Check#checkDiamond(JCNewClass, Type):::Check that usage of diamond operator is correct (i.e:::if->TreeInfo->isDiamond->t->isErroneous->return->pos->checkClassType->else->if->allowedInSource->log->pos->Errors->fragment->CantApplyDiamond1->error->if->getTypeArguments->isEmpty->log->pos->Errors->Fragments->DiamondNonGeneric->CantApplyDiamond1->error->return->types->createErrorType->else->if->nonEmpty->log->pos->Errors->Fragments->DiamondAndExplicitParams->CantApplyDiamond1->error->return->types->createErrorType->else->return
Check#checkDiamondDenotable(ClassType):::Check that the type inferred using the diamond operator does not contain  non-denotable types such as captured types or intersection types.:::buf->new->ListBuffer<>->foreach->t->allparams->if->checkDenotable->buf->append->return->buf->toList
Check#checkDenotable(Type)::: check check denotable:::return->denotableChecker->visit
Check#checkVarargsMethodDecl(Env, JCMethodDecl)::: check check varargs method decl:::m->if->allowedInSource->return->hasTrustMeAnno->m->attribute->varargElemType->if->m->isVarArgs->types->last->elemtype->if->isTrustMeAllowedOnMethod->if->msg->allowedInSource->diags->Fragments->VarargsTrustmeOnVirtualVarargs->fragment->diags->Fragments->VarargsTrustmeOnVirtualVarargsFinalOnly->fragment->log->Errors->VarargsInvalidTrustmeAnno->error->else->log->Errors->Fragments->VarargsTrustmeOnNonVarargsMeth->VarargsInvalidTrustmeAnno->error->else->if->types->isReifiable->Warnings->diags->Fragments->VarargsTrustmeOnReifiableVarargs->fragment->VarargsRedundantTrustmeAnno->warnUnsafeVararg->else->if->types->isReifiable->pos->Warnings->UncheckedVarargsNonReifiableType->warnUnchecked
Check#isTrustMeAllowedOnMethod(Symbol)::: check is trust me allowed on method:::return->s->flags->s->isConstructor->s->flags->allowedInSource
Check#checkLocalVarType(DiagnosticPosition, Type, Name)::: check check local var type:::if->t->hasTag->log->Errors->CantInferLocalVarType->error->return->types->createErrorType->else->if->t->hasTag->log->Errors->CantInferLocalVarType->error->return->types->createErrorType->return->types->types->captures->upward
Check#checkMethod(Type, Symbol, Env, List, List, boolean, InferenceContext)::: check check method:::if->inferenceContext->free->inferenceContext->List->of->solvedContext->asInstType->checkMethod->addFreeTypeListener->return->owntype->formals->owntype->getParameterTypes->nonInferred->getParameterTypes->if->nonInferred->length->formals->length->last->formals->last->if->if->sym->flags->args->if->while->arg->warn->arg->pos->convertWarner->assertConvertible->if->varArg->types->elemtype->while->arg->warn->arg->pos->convertWarner->assertConvertible->else->if->sym->flags->varParam->owntype->getParameterTypes->last->lastArg->argtypes->last->if->types->types->elemtype->isSubtypeUnchecked->types->types->erasure->types->erasure->isSameType->log->argtrees->last->pos->Warnings->types->elemtype->InexactNonVarargsCall->warning->if->argtype->owntype->getParameterTypes->last->if->types->isReifiable->allowedInSource->sym->baseSymbol->attribute->isTrustMeAllowedOnMethod->pos->Warnings->UncheckedGenericArrayCreation->warnUnchecked->TreeInfo->types->elemtype->setVarargsElement->if->sym->flags->target->hasMethodHandles->log->Errors->BadTargetSigpolyCall->error->return
Check#assertConvertible(JCTree, Type, Type, Warner)::: check assert convertible:::if->types->isConvertible->return->if->formal->isCompound->types->types->supertype->isSubtype->types->types->interfaces->isSubtypeUnchecked->return
Check#checkValidGenericType(Type):::Check that type 't' is a valid instantiation of a generic class (see JLS 4.5):::return->firstIncompatibleTypeArg
Check#firstIncompatibleTypeArg(Type)::: check first incompatible type arg:::formals->allparams->actuals->type->allparams->args->type->getTypeArguments->forms->getTypeArguments->bounds_buf->new->ListBuffer<>->while->args->nonEmpty->forms->nonEmpty->bounds_buf->types->getUpperBound->subst->append->type->getTypeArguments->tvars_cap->types->types->capture->allparams->substBounds->while->args->nonEmpty->tvars_cap->nonEmpty->withTypeVar->type->getTypeArguments->bounds->bounds_buf->toList->while->args->nonEmpty->bounds->nonEmpty->actual->if->isTypeArgErroneous->isErroneous->checkExtends->return->type->getTypeArguments->bounds_buf->toList->foreach->types->capture->getTypeArguments->if->arg->hasTag->arg->getUpperBound->isErroneous->isErroneous->isTypeArgErroneous->return->return
Check#isTypeArgErroneous(Type)::: check is type arg erroneous:::return->isTypeArgErroneous->visit
Check#checkFlags(DiagnosticPosition, long, Symbol, JCTree):::Check that given modifiers are legal for given symbol and  return modifiers together with any implicit modifiers for that symbol:::mask->implicit->switch->if->TreeInfo->isReceiverParam->else->if->else->if->else->break->if->if->else->else->if->if->else->if->if->else->else->if->break->if->sym->isLocal->if->log->error->else->if->if->else->if->log->error->if->else->if->if->implicitEnumFinalFlag->break->throw->new->AssertionError->illegal->if->if->log->error->else->log->Errors->asFlagSet->ModNotAllowedHere->error->else->if->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->checkDisjoint->return
Check#implicitEnumFinalFlag(JCTree):::Determine if this enum should be implicitly final:::if->tree->hasTag->return->sts->new->SpecialTreeVisitor->cdef->foreach->defs->accept->if->return->return
Check#validate(JCTree, Env):::Validate a type expression:::validate
Check#validate(JCTree, Env, boolean)::: check validate:::new->Validator->validateTree
Check#validate(List, Env):::Visitor method: Validate a list of type expressions.:::for->l->l->nonEmpty
Check.Validator#visitTypeArray(JCArrayTypeTree)::: validator visit type array:::validateTree
Check.Validator#visitTypeApply(JCTypeApply)::: validator visit type apply:::if->hasTag->args->forms->getTypeArguments->incompatibleArg->firstIncompatibleTypeArg->if->foreach->if->log->Errors->NotWithinBounds->error->getTypeArguments->is_java_lang_Class->flatName->while->args->nonEmpty->forms->nonEmpty->validateTree->if->getEnclosingType->isRaw->log->tree->pos->error->if->hasTag->visitSelectInternal
Check.Validator#visitTypeParameter(JCTypeParameter)::: validator visit type parameter:::validateTrees->tree->pos->checkClassBounds
Check.Validator#visitWildcard(JCWildcard)::: validator visit wildcard:::if->validateTree
Check.Validator#visitSelect(JCFieldAccess)::: validator visit select:::if->hasTag->visitSelectInternal->if->isParameterized->getTypeArguments->nonEmpty->log->tree->pos->error
Check.Validator#visitSelectInternal(JCFieldAccess)::: validator visit select internal:::if->isStatic->isParameterized->log->tree->pos->error->else->accept
Check.Validator#visitAnnotatedType(JCAnnotatedType)::: validator visit annotated type:::accept
Check.Validator#visitTypeIdent(JCPrimitiveTypeTree)::: validator visit type ident:::if->hasTag->log->that->pos->error->super->visitTypeIdent
Check.Validator#visitTree(JCTree):::Default visitor method: do nothing.:::
Check.Validator#validateTree(JCTree, boolean, boolean)::: validator validate tree:::if->prevCheckRaw->try->tree->accept->if->checkRaw->catch->tree->pos->completionError->finally
Check.Validator#validateTrees(List, boolean, boolean)::: validator validate trees:::for->l->l->nonEmpty
Check#checkRaw(JCTree, Env)::: check check raw:::if->lint->isEnabled->hasTag->TreeInfo->isDiamond->withinAnonConstr->isRaw->log->tree->pos->Warnings->RawClassUse->warning
Check#withinAnonConstr(Env)::: check within anon constr:::return->isEmpty
Check#subset(Type, List):::Is given type a subtype of some of the types in given list?:::for->l->l->nonEmpty->return
Check#intersects(Type, List):::Is given type a subtype or supertype of  some of the types in given list?:::for->l->l->nonEmpty->return
Check#incl(Type, List):::Add type set to given type list, unless it is a subclass of some class  in the list.:::return->subset->excl->prepend
Check#excl(Type, List):::Remove type set from type set list.:::if->ts->isEmpty->return->else->ts1->excl->if->types->isSubtype->return->else->if->return->else->return->ts1->prepend
Check#union(List, List):::Form the union of two type set lists.:::ts->for->l->l->nonEmpty->return
Check#diff(List, List):::Form the difference of two type lists.:::ts->for->l->l->nonEmpty->return
Check#intersect(List, List):::Form the intersection of two type lists.:::ts->List->nil->for->l->l->nonEmpty->for->l->l->nonEmpty->return
Check#isUnchecked(ClassSymbol):::Is exc an exception symbol that need not be declared?:::return->exc->isSubClass->exc->isSubClass
Check#isUnchecked(Type):::Is exc an exception type that need not be declared?:::return->exc->hasTag->types->supertype->isUnchecked->exc->hasTag->isUnchecked->exc->hasTag
Check#isChecked(Type)::: check is checked:::return->isUnchecked
Check#isUnchecked(DiagnosticPosition, Type):::Same, but handling completion failures.:::try->return->isUnchecked->catch->completionError->return->finally
Check#isHandled(Type, List):::Is exc handled by given exception list?:::return->isUnchecked->subset
Check#unhandled(List, List):::Return all exceptions in thrown list that are not in handled list.:::unhandled->List->nil->for->l->l->nonEmpty->return
Check#protection(long):::The level of access protection given by a flag set,  where PRIVATE is highest and PUBLIC is lowest.:::switch->return->return->return->return
Check#cannotOverride(MethodSymbol, MethodSymbol):::A customized "cannot override" error message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->CantOverride->else->if->flags->return->Fragments->CantImplement->else->return->Fragments->ClashesWith
Check#uncheckedOverrides(MethodSymbol, MethodSymbol):::A customized "override" warning message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->UncheckedOverride->else->if->flags->return->Fragments->UncheckedImplement->else->return->Fragments->UncheckedClashWith
Check#varargsOverrides(MethodSymbol, MethodSymbol):::A customized "override" warning message.:::mloc->m->location->oloc->other->location->if->flags->return->Fragments->VarargsOverride->else->if->flags->return->Fragments->VarargsImplement->else->return->Fragments->VarargsClashWith
Check#checkOverride(JCTree, MethodSymbol, MethodSymbol, ClassSymbol):::Check that this method conforms with overridden method 'other':::if->m->flags->other->flags->return->if->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideStatic->error->return->if->other->flags->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->other->flags->asFlagSet->OverrideMeth->error->return->if->flags->return->if->m->flags->protection->other->flags->protection->log->TreeInfo->diagnosticPositionFor->other->flags->Errors->cannotOverride->OverrideWeakerAccess->Errors->cannotOverride->other->flags->asFlagSet->OverrideWeakerAccess->error->return->mt->types->memberType->ot->types->memberType->mtvars->mt->getTypeArguments->otvars->ot->getTypeArguments->mtres->mt->getReturnType->otres->types->ot->getReturnType->subst->overrideWarner->clear->resultTypesOK->types->returnTypeSubstitutable->if->if->m->flags->other->flags->log->TreeInfo->diagnosticPositionFor->Errors->Fragments->m->location->other->location->CantHide->OverrideIncompatibleRet->error->else->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideIncompatibleRet->error->return->else->if->overrideWarner->hasNonSilentLint->TreeInfo->diagnosticPositionFor->Warnings->uncheckedOverrides->OverrideUncheckedRet->warnUnchecked->otthrown->types->ot->getThrownTypes->subst->unhandledErased->mt->getThrownTypes->types->erasure->unhandled->unhandledUnerased->mt->getThrownTypes->unhandled->if->unhandledErased->nonEmpty->log->TreeInfo->diagnosticPositionFor->Errors->cannotOverride->OverrideMethDoesntThrow->error->return->else->if->unhandledUnerased->nonEmpty->TreeInfo->diagnosticPositionFor->Warnings->cannotOverride->OverrideUncheckedThrown->warnUnchecked->return->if->m->flags->other->flags->lint->isEnabled->log->TreeInfo->diagnosticPositionFor->m->flags->Warnings->varargsOverrides->OverrideVarargsMissing->Warnings->varargsOverrides->OverrideVarargsExtra->warning->if->other->flags->log->TreeInfo->diagnosticPositionFor->Warnings->uncheckedOverrides->OverrideBridge->warning->if->isDeprecatedOverrideIgnorable->prevLint->lint->augment->setLint->try->TreeInfo->diagnosticPositionFor->checkDeprecated->catch->finally->setLint
Check#isDeprecatedOverrideIgnorable(MethodSymbol, ClassSymbol)::: check is deprecated override ignorable:::mc->m->enclClass->st->types->supertype->if->st->hasTag->return->stimpl->m->implementation->if->mc->flags->intfs->types->interfaces->return->intfs->contains->else->return
Check#checkCompatibleConcretes(DiagnosticPosition, Type):::Check that a class does not inherit two concrete methods  with the same signature.:::sup->types->supertype->if->sup->hasTag->return->for->t1->t1->hasTag->isParameterized->types->supertype
Check#checkCompatibleAbstracts(DiagnosticPosition, Type, Type, Type):::Check that classes (or interfaces) do not each define an abstract  method with same name and arguments but incompatible return types.:::if->flags->types->capture->types->capture->return->firstIncompatibility
Check#firstIncompatibility(DiagnosticPosition, Type, Type, Type):::Return the first method which is defined with same args  but different return types in two given interfaces, or null if none  exists.:::interfaces1->new->HashMap<>->closure->interfaces2->if->else->new->HashMap<>->closure->foreach->interfaces1->values->foreach->interfaces2->values->s->firstDirectIncompatibility->if->return->return
Check#closure(Type, Map):::Compute all the supertypes of t, indexed by type symbol.:::if->t->hasTag->return->if->typeMap->put->types->supertype->closure->foreach->types->interfaces->closure
Check#closure(Type, Map, Map):::Compute all the supertypes of t, indexed by type symbol (except thise in typesSkip).:::if->t->hasTag->return->if->typesSkip->get->return->if->typeMap->put->types->supertype->closure->foreach->types->interfaces->closure
Check#firstDirectIncompatibility(DiagnosticPosition, Type, Type, Type):::Return the first method in t2 that conflicts with a method from t1.:::foreach->members->getSymbols->st1->if->s1->isInheritedIn->s1->flags->continue->impl->implementation->if->impl->flags->continue->foreach->members->getSymbolsByName->if->continue->if->s2->isInheritedIn->s2->flags->continue->if->types->memberType->st2->types->memberType->if->types->overrideEquivalent->tvars1->st1->getTypeArguments->tvars2->st2->getTypeArguments->rt1->st1->getReturnType->rt2->types->st2->getReturnType->subst->compat->types->isSameType->rt1->isPrimitiveOrVoid->rt2->isPrimitiveOrVoid->types->covariantReturnType->types->covariantReturnType->checkCommonOverriderIn->if->log->Errors->Fragments->types->memberType->getParameterTypes->IncompatibleDiffRet->TypesIncompatible->error->return->else->if->checkNameClash->checkCommonOverriderIn->log->Errors->types->memberType->asMethodType->getParameterTypes->s1->location->types->memberType->asMethodType->getParameterTypes->s2->location->NameClashSameErasureNoOverride->error->return->return
Check#checkCommonOverriderIn(Symbol, Symbol, Type)::: check check common overrider in:::supertypes->new->HashMap<>->st1->types->memberType->st2->types->memberType->closure->foreach->supertypes->values->foreach->members->getSymbolsByName->if->s3->flags->continue->st3->types->memberType->if->types->overrideEquivalent->types->overrideEquivalent->types->returnTypeSubstitutable->types->returnTypeSubstitutable->return->return
Check#checkOverride(Env, JCMethodDecl, MethodSymbol):::Check that a given method conforms with any method it overrides.:::origin->if->origin->flags->equals->if->m->overrides->log->tree->pos->error->return->for->t->t->hasTag->types->supertype->explicitOverride->m->attribute->mustOverride->m->isConstructor->m->isPrivate->if->isOverrider->pos->tree->pos->foreach->tree->getModifiers->if->a->pos->break->log->m->isStatic->Errors->AnonymousDiamondMethodDoesNotOverrideSuperclass->error
Check#checkOverride(JCTree, Type, ClassSymbol, MethodSymbol)::: check check override:::c->foreach->c->members->getSymbolsByName->if->m->overrides->if->sym->flags->checkOverride
Check#checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition, ClassSymbol)::: check check class override equals and hash if needed:::if->someClass->isInterface->someClass->isEnum->someClass->flags->someClass->flags->return->if->someClass->isAnonymous->interfaces->types->interfaces->if->interfaces->isEmpty->return->checkClassOverrideEqualsAndHash
Check#checkClassOverrideEqualsAndHash(DiagnosticPosition, ClassSymbol)::: check check class override equals and hash:::if->lint->isEnabled->equalsAtObject->members->findFirst->hashCodeAtObject->members->findFirst->overridesEquals->types->implementation->overridesHashCode->types->implementation->if->log->Warnings->OverrideEqualsButNotHashcode->warning
Check#checkModuleName(JCModuleDecl)::: check check module name:::moduleName->Assert->checkNonNull->if->lint->isEnabled->qualId->while->componentName->pos->switch->qualId->getTag->selectNode->selectNode->pos->break->qualId->pos->break->throw->qualId->toString->new->AssertionError->if->moduleNameComponentString->componentName->toString->nameLength->moduleNameComponentString->length->if->Character->moduleNameComponentString->charAt->isDigit->log->Warnings->PoorChoiceForModuleName->warning
Check#checkNameClash(ClassSymbol, Symbol, Symbol)::: check check name clash:::cf->new->ClashFilter->return->cf->accepts->cf->accepts->types->s1->erasure->s2->erasure->hasSameArgs
Check#checkAllDefined(DiagnosticPosition, ClassSymbol):::Check that all abstract members of given class have definitions.:::undef->types->firstUnimplementedAbstract->if->undef1->undef->flags->types->memberType->new->MethodSymbol->log->Errors->undef1->location->DoesNotOverrideAbstract->error
Check#checkNonCyclicDecl(JCClassDecl)::: check check non cyclic decl:::cc->new->CycleChecker->cc->scan->if
Check.CycleChecker#checkSymbol(DiagnosticPosition, Symbol)::: cycle checker check symbol:::if->classEnv->enter->getEnv->if->prevSource->log->currentSource->try->log->useSource->scan->catch->finally->log->prevSource->getFile->useSource->else->if->List->nil->checkClass->else
Check.CycleChecker#visitSelect(JCFieldAccess)::: cycle checker visit select:::super->visitSelect->tree->pos->checkSymbol
Check.CycleChecker#visitIdent(JCIdent)::: cycle checker visit ident:::tree->pos->checkSymbol
Check.CycleChecker#visitTypeApply(JCTypeApply)::: cycle checker visit type apply:::scan
Check.CycleChecker#visitTypeArray(JCArrayTypeTree)::: cycle checker visit type array:::scan
Check.CycleChecker#visitClassDef(JCClassDecl)::: cycle checker visit class def:::supertypes->List->nil->if->tree->getExtendsClause->supertypes->tree->getExtendsClause->prepend->if->tree->getImplementsClause->foreach->tree->getImplementsClause->supertypes->prepend->tree->pos->checkClass
Check.CycleChecker#checkClass(DiagnosticPosition, Symbol, List)::: cycle checker check class:::if->return->if->seenClasses->contains->noteCyclic->else->if->isErroneous->try->seenClasses->prepend->if->hasTag->if->supertypes->nonEmpty->scan->else->ct->if->return->checkSymbol->foreach->checkSymbol->if->checkSymbol->catch->finally
Check#checkNonCyclic(DiagnosticPosition, Type):::Check for cyclic references:::checkNonCyclicInternal
Check#checkNonCyclic(DiagnosticPosition, TypeVar)::: check check non cyclic:::List->nil->checkNonCyclic1
Check#checkNonCyclic1(DiagnosticPosition, Type, List)::: check check non cyclic1:::tv->if->t->hasTag->flags->return->if->seen->contains->types->createErrorType->log->Errors->CyclicInheritance->error->else->if->t->hasTag->seen->prepend->foreach->types->getBounds->checkNonCyclic1
Check#checkNonCyclicInternal(DiagnosticPosition, Type):::Check for cyclic references:::complete->c->if->return->if->noteCyclic->else->if->isErroneous->try->if->hasTag->clazz->if->for->l->l->nonEmpty->if->st->if->st->hasTag->checkNonCyclicInternal->if->checkNonCyclicInternal->catch->finally->if->c->isCompleted->if->return
Check#noteCyclic(DiagnosticPosition, ClassSymbol):::Note that we found an inheritance cycle.:::log->Errors->CyclicInheritance->error->for->l->types->interfaces->l->nonEmpty->st->types->supertype->if->st->hasTag->types->createErrorType->types->createErrorType
Check#checkImplementations(JCClassDecl):::Check that all methods which implement some  method conform to the method they implement.:::checkImplementations
Check#checkImplementations(JCTree, ClassSymbol, ClassSymbol):::Check that all methods which implement some  method in `ic' conform to the method they implement.:::for->l->types->closure->l->nonEmpty
Check#checkCompatibleSupertypes(DiagnosticPosition, Type):::Check that all abstract methods implemented by a class are  mutually compatible.:::supertypes->types->interfaces->supertype->types->supertype->if->supertype->hasTag->flags->supertypes->prepend->for->l->l->nonEmpty->checkCompatibleConcretes
Check#checkOverrideClashes(DiagnosticPosition, Type, MethodSymbol):::Check that all non-override equivalent methods accessible from 'site'  are mutually compatible (JLS 8.4.8/9.4.1).:::cf->new->ClashFilter->potentiallyAmbiguousList->List->nil->overridesAny->foreach->types->membersClosure->getSymbolsByName->if->sym->overrides->if->continue->if->potentiallyAmbiguousList->prepend->continue->if->List->nil->foreach->types->membersClosure->getSymbolsByName->if->continue->if->types->types->memberType->allowedInSource->isSubSignature->types->m2->erasure->m1->erasure->hasSameArgs->if->log->Errors->types->memberType->asMethodType->getParameterTypes->m1->location->types->memberType->asMethodType->getParameterTypes->m2->location->NameClashSameErasureNoOverride->error->else->ct->kind->ct->isInterface->log->Errors->types->memberType->asMethodType->getParameterTypes->m1->location->types->memberType->asMethodType->getParameterTypes->m2->location->NameClashSameErasureNoOverride1->error->return->if->foreach->checkPotentiallyAmbiguousOverloads
Check#checkHideClashes(DiagnosticPosition, Type, MethodSymbol):::Check that all static methods accessible from 'site' are  mutually compatible (JLS 8.4.8).:::cf->new->ClashFilter->foreach->types->membersClosure->getSymbolsByName->if->types->types->memberType->allowedInSource->isSubSignature->if->types->s->erasure->sym->erasure->hasSameArgs->log->Errors->sym->location->s->location->NameClashSameErasureNoHide->error->return->else->checkPotentiallyAmbiguousOverloads
Check.ClashFilter#shouldSkip(Symbol)::: clash filter should skip:::return->s->flags
Check.ClashFilter#accepts(Symbol)::: clash filter accepts:::return->s->flags->shouldSkip->s->isInheritedIn->s->isConstructor
Check#checkDefaultMethodClashes(DiagnosticPosition, Type)::: check check default method clashes:::dcf->new->DefaultMethodClashFilter->foreach->types->membersClosure->getSymbols->Assert->check->prov->types->interfaceCandidates->if->prov->size->abstracts->new->ListBuffer<>->defaults->new->ListBuffer<>->foreach->if->provSym->flags->defaults->append->else->if->provSym->flags->abstracts->append->if->defaults->nonEmpty->defaults->size->abstracts->size->diagKey->s1->defaults->first->s2->if->defaults->size->defaults->toList->Fragments->Kinds->kindName->types->memberType->getParameterTypes->s1->location->s2->location->IncompatibleUnrelatedDefaults->else->abstracts->first->Fragments->Kinds->kindName->types->memberType->getParameterTypes->s1->location->s2->location->IncompatibleAbstractDefault->log->Errors->s1->location->s2->location->TypesIncompatible->error->break
Check.DefaultMethodClashFilter#accepts(Symbol)::: default method clash filter accepts:::return->s->flags->s->isInheritedIn->s->isConstructor
Check#checkPotentiallyAmbiguousOverloads(DiagnosticPosition, Type, MethodSymbol, MethodSymbol):::Report warnings for potentially ambiguous method declarations:::if->allowedInSource->lint->isEnabled->msym1->flags->msym2->flags->mt1->types->memberType->mt2->types->memberType->if->mt1->hasTag->mt2->hasTag->types->hasSameBounds->types->subst->maxLength->Math->mt1->getParameterTypes->length->mt2->getParameterTypes->length->max->args1->rs->mt1->getParameterTypes->adjustArgs->args2->rs->mt2->getParameterTypes->adjustArgs->if->args1->length->args2->length->return->potentiallyAmbiguous->while->args1->nonEmpty->args2->nonEmpty->s->t->if->types->isSubtype->types->isSubtype->if->types->isFunctionalInterface->types->isFunctionalInterface->types->findDescriptorType->getParameterTypes->length->types->findDescriptorType->getParameterTypes->length->types->findDescriptorType->getParameterTypes->length->else->break->if->log->Warnings->msym1->location->msym2->location->PotentiallyAmbiguousOverload->warning->return
Check#checkAccessFromSerializableElement(JCTree, boolean)::: check check access from serializable element:::if->lint->isEnabled->lint->isSuppressed->sym->TreeInfo->symbol->if->matches->return->if->if->sym->flags->sym->isLocal->return->if->types->isSubtype->isEffectivelyNonPublic->if->if->belongsToRestrictedPackage->log->tree->pos->Warnings->AccessToMemberFromSerializableLambda->warning->else->log->tree->pos->Warnings->AccessToMemberFromSerializableElement->warning
Check#isEffectivelyNonPublic(Symbol)::: check is effectively non public:::if->sym->packge->return->while->if->sym->flags->return->return
Check#belongsToRestrictedPackage(Symbol)::: check belongs to restricted package:::fullName->sym->packge->toString->return->fullName->startsWith->fullName->startsWith->fullName->startsWith->fullName->contains
Check#checkClassBounds(DiagnosticPosition, Type):::Check that class c does not implement directly or indirectly  the same parameterized interface with two different argument lists.:::new->HashMap<TypeSymbol,Type>->checkClassBounds
Check#checkClassBounds(DiagnosticPosition, Map, Type):::Enter all interfaces of type `type' into the hash table `seensofar'  with their class symbol as key and their type as value:::if->type->isErroneous->return->for->l->types->interfaces->l->nonEmpty->st->types->supertype->if->checkClassBounds
Check#checkNotRepeated(DiagnosticPosition, Type, Set):::Enter interface into into set:::if->its->contains->log->error->else->its->add
Check#validateAnnotationTree(JCTree):::Recursively validate annotations values:::tree->new->AnnotationValidator->accept
Check#validateAnnotationType(JCTree)::: {@literal  Annotation types are restricted to primitives, String, an  enum, an annotation, Class, Class<?>, Class<? extends  Anything>, arrays of the preceding:::if->restype->pos->validateAnnotationType
Check#validateAnnotationType(DiagnosticPosition, Type)::: check validate annotation type:::if->type->isPrimitive->return->if->types->isSameType->return->if->flags->return->if->flags->return->if->types->cvarLowerBound->return->if->types->isArray->types->types->elemtype->isArray->types->elemtype->validateAnnotationType->return->log->error
Check#validateAnnotationMethod(DiagnosticPosition, MethodSymbol):::"It is also a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any public or protected method declared in class Object or in the interface annotation.Annotation.":::for->sup->sup->hasTag->types->supertype
Check#validateAnnotations(List, Symbol):::Check the annotations of a symbol.:::foreach->validateAnnotation
Check#validateTypeAnnotations(List, boolean):::Check the type annotations.:::foreach->validateTypeAnnotation
Check#validateAnnotation(JCAnnotation, Symbol):::Check an annotation of a symbol.:::validateAnnotationTree->if->isAnnotationType->annotationApplicable->log->a->pos->error->if->if->log->a->pos->error->else->if->s->isInterface->s->flags->log->a->pos->Errors->Fragments->NotAFunctionalIntf->BadFunctionalIntfAnno1->error
Check#validateTypeAnnotation(JCAnnotation, boolean)::: check validate type annotation:::Assert->checkNonNull->validateAnnotationTree->if->a->hasTag->isErroneous->isTypeAnnotation->log->a->pos->Errors->AnnotationTypeNotApplicableToType->error
Check#validateRepeatable(TypeSymbol, Attribute.Compound, DiagnosticPosition):::Validate the proposed container 'repeatable' on the annotation type symbol 's':::Assert->types->isSameType->check->t->l->if->l->isEmpty->Assert->check->getValue->if->return->validateValue->validateRetention->validateDocumented->validateInherited->validateTarget->validateDefault
Check#validateValue(TypeSymbol, TypeSymbol, DiagnosticPosition)::: check validate value:::sym->container->members->findFirst->if->m->ret->m->getReturnType->if->ret->hasTag->types->isSameType->log->Errors->types->makeArrayType->InvalidRepeatableAnnotationValueReturn->error->else->log->Errors->InvalidRepeatableAnnotationNoValue->error
Check#validateRetention(TypeSymbol, TypeSymbol, DiagnosticPosition)::: check validate retention:::containerRetention->types->getRetention->containedRetention->types->getRetention->error->switch->if->break->if->if->log->Errors->containerRetention->name->containedRetention->name->InvalidRepeatableAnnotationRetention->error
Check#validateDocumented(Symbol, Symbol, DiagnosticPosition)::: check validate documented:::if->contained->attribute->if->container->attribute->log->Errors->InvalidRepeatableAnnotationNotDocumented->error
Check#validateInherited(Symbol, Symbol, DiagnosticPosition)::: check validate inherited:::if->contained->attribute->if->container->attribute->log->Errors->InvalidRepeatableAnnotationNotInherited->error
Check#validateTarget(TypeSymbol, TypeSymbol, DiagnosticPosition)::: check validate target:::containerTargets->containerTarget->getAttributeTargetAttribute->if->getDefaultTargetSet->else->new->HashSet<>->foreach->if->continue->e->containerTargets->add->containedTargets->containedTarget->getAttributeTargetAttribute->if->getDefaultTargetSet->else->new->HashSet<>->foreach->if->continue->e->containedTargets->add->if->isTargetSubsetOf->log->Errors->InvalidRepeatableAnnotationIncompatibleTarget->error
Check#getDefaultTargetSet()::: check get default target set:::if->targets->new->HashSet<>->targets->add->targets->add->targets->add->targets->add->targets->add->targets->add->targets->add->targets->add->unmodifiableSet->return
Check#isTargetSubsetOf(Set, Set):::Checks that s is a subset of t, with respect to ElementType semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE}, and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE, TYPE_PARAMETER}.:::foreach->currentElementOk->foreach->if->break->else->if->break->else->if->break->if->return->return
Check#validateDefault(Symbol, DiagnosticPosition)::: check validate default:::scope->container->members->foreach->scope->getSymbols->if->log->Errors->InvalidRepeatableAnnotationElemNondefault->error
Check#isOverrider(Symbol):::Is s a method symbol that overrides a method in a superclass?:::if->s->isStatic->return->m->owner->foreach->types->closure->if->continue->scope->members->foreach->scope->getSymbolsByName->if->sym->isStatic->m->overrides->return->return
Check#isTypeAnnotation(JCAnnotation, boolean):::Is the annotation applicable to types?:::targets->typeAnnotations->annotationTargets->return->targets->stream->isTypeAnnotation->anyMatch
Check#isTypeAnnotation(Attribute, boolean)::: check is type annotation:::e->return
Check#annotationApplicable(JCAnnotation, Symbol):::Is the annotation applicable to the symbol?:::arr->getAttributeTargetAttribute->targets->if->defaultTargetMetaInfo->else->new->NameArr->for->i->foreach->if->if->return->else->if->if->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->flags->return->else->if->if->return->else->if->if->hasTag->return->else->if->s->isConstructor->getReturnType->hasTag->s->isConstructor->return->else->if->if->hasTag->return->else->return->return
Check#getAttributeTargetAttribute(TypeSymbol)::: check get attribute target attribute:::atTarget->s->getAnnotationTypeMetadata->getTarget->if->return->atValue->atTarget->member->if->return->return
Check#defaultTargetMetaInfo(JCAnnotation, Symbol)::: check default target meta info:::return
Check#validateAnnotationDeferErrors(JCAnnotation):::Check an annotation value.:::res->diagHandler->new->Log.DiscardDiagnosticHandler->try->validateAnnotation->catch->finally->log->popDiagnosticHandler->return
Check#validateAnnotation(JCAnnotation)::: check validate annotation:::isValid->metadata->getAnnotationTypeMetadata->elements->metadata->getAnnotationElements->foreach->if->arg->hasTag->continue->assign->m->TreeInfo->symbol->if->isErroneous->continue->if->elements->remove->log->pos->Errors->DuplicateAnnotationMemberValue->error->missingDefaults->List->nil->membersWithDefault->metadata->getAnnotationElementsWithDefault->foreach->if->isErroneous->continue->if->membersWithDefault->contains->missingDefaults->append->missingDefaults->reverse->if->missingDefaults->nonEmpty->errorKey->missingDefaults->size->Errors->AnnotationMissingDefaultValue1->Errors->AnnotationMissingDefaultValue->log->a->pos->error->return->validateTargetAnnotationValue
Check#validateTargetAnnotationValue(JCAnnotation)::: check validate target annotation value:::if->return->isValid->if->hasTag->return->assign->m->TreeInfo->symbol->if->return->rhs->if->rhs->hasTag->return->na->targets->new->HashSet<>->foreach->if->targets->TreeInfo->symbol->add->log->elem->pos->error->return
Check#checkDeprecatedAnnotation(DiagnosticPosition, Symbol)::: check check deprecated annotation:::if->lint->isEnabled->s->isDeprecatableViaAnnotation->s->flags->isErroneous->s->attribute->log->warning->if->lint->isEnabled->s->isDeprecatableViaAnnotation->if->isErroneous->s->attribute->log->Warnings->Kinds->kindName->DeprecatedAnnotationHasNoEffect->warning
Check#checkDeprecated(DiagnosticPosition, Symbol, Symbol)::: check check deprecated:::if->s->isDeprecatedForRemoval->s->isDeprecated->other->isDeprecated->s->outermostClass->other->outermostClass->s->outermostClass->deferredLintHandler->warnDeprecated->report
Check#checkSunAPI(DiagnosticPosition, Symbol)::: check check sun i:::if->s->flags->deferredLintHandler->log->Warnings->SunProprietary->mandatoryWarning->report
Check#checkProfile(DiagnosticPosition, Symbol)::: check check profile:::if->s->flags->log->Errors->NotInProfile->error
Check#checkNonCyclicElements(JCClassDecl):::Check for cycles in the graph of annotation elements.:::if->return->Assert->check->try->foreach->if->def->hasTag->continue->meth->meth->pos->checkAnnotationResType->catch->finally
Check#checkNonCyclicElementsInternal(DiagnosticPosition, TypeSymbol)::: check check non cyclic elements internal:::if->return->if->log->Errors->CyclicAnnotationElement->error->return->try->foreach->tsym->members->getSymbols->if->continue->getReturnType->checkAnnotationResType->catch->finally
Check#checkAnnotationResType(DiagnosticPosition, Type)::: check check annotation res type:::switch->type->getTag->if->flags->checkNonCyclicElementsInternal->break->types->elemtype->checkAnnotationResType->break->break
Check#checkCyclicConstructors(JCClassDecl):::Check for cycles in the graph of constructors calling other  constructors.:::callMap->new->HashMap<>->for->l->l->nonEmpty->ctors->new->SymbolArr->callMap->keySet->toArray->foreach->checkCyclicConstructor
Check#checkCyclicConstructor(JCClassDecl, Symbol, Map):::Look in the map to see if the given constructor is part of a  call cycle.:::if->if->log->TreeInfo->diagnosticPositionFor->error->else->callMap->remove->checkCyclicConstructor
Check#checkDivZero(DiagnosticPosition, Symbol, Type)::: Check for division by integer constant zero:::if->operand->constValue->operand->getTag->isSubRangeOf->operand->constValue->longValue->opc->if->deferredLintHandler->warnDivZero->report
Check#checkEmptyIf(JCIf):::Check for empty statements after if:::if->hasTag->lint->isEnabled->log->pos->warning
Check#checkUnique(DiagnosticPosition, Symbol, Scope):::Check that symbol is unique in given scope.:::if->isErroneous->return->if->return->foreach->s->getSymbolsByName->if->byName->flags->types->hasSameArgs->types->types->erasure->types->erasure->hasSameArgs->if->sym->flags->byName->flags->varargsDuplicateError->return->else->if->types->hasSameArgs->duplicateErasureError->return->else->duplicateError->return->return
Check#duplicateErasureError(DiagnosticPosition, Symbol, Symbol):::Report duplicate declaration error.:::if->isErroneous->isErroneous->log->Errors->NameClashSameErasure->error
Check#checkImportsUnique(JCCompilationUnit):::Check that types imported through the ordinary imports don't clash with types imported by other (static or ordinary) imports:::ordinallyImportedSoFar->WriteableScope->create->staticallyImportedSoFar->WriteableScope->create->topLevelScope->foreach->if->def->hasTag->continue->imp->if->continue->foreach->getSymbols->if->imp->isStatic->imp->pos->checkUniqueImport->staticallyImportedSoFar->enter->else->imp->pos->checkUniqueImport->ordinallyImportedSoFar->enter
Check#checkUniqueImport(DiagnosticPosition, Scope, Scope, Scope, Symbol, boolean):::Check that single-type import is not already imported or top-level defined,  but make an exception for two single-type imports which denote the same type.:::duplicates->isErroneous->ordinaryClashing->ordinallyImportedSoFar->findFirst->staticClashing->if->staticallyImportedSoFar->findFirst->if->if->log->Errors->AlreadyDefinedSingleImport->error->else->log->Errors->AlreadyDefinedStaticSingleImport->error->return->clashing->topLevelScope->findFirst->if->log->Errors->AlreadyDefinedThisUnit->error->return->return
Check#checkCanonical(JCTree):::Check that a qualified name is in canonical form (for import decls).:::if->isCanonical->log->tree->pos->Errors->TreeInfo->symbol->ImportRequiresCanonical->error
Check#isCanonical(JCTree)::: check is canonical:::while->tree->hasTag->s->if->getQualifiedName->TreeInfo->symbol->getQualifiedName->return->return
Check#checkForBadAuxiliaryClassAccess(DiagnosticPosition, Env, ClassSymbol):::Check that an auxiliary class is not accessed from any other file than its own.:::if->lint->isEnabled->c->flags->rs->isAccessible->fileManager->isSameFile->log->Warnings->AuxiliaryClassAccessedFromOutsideOfItsSourceFile->warning
Check.ConversionWarner#warn(LintCategory)::: conversion warner warn:::warned->super->warn->if->return->switch->Check.this->pos->Warnings->diags->fragment->ProbFoundReq->warnUnchecked->break->if->method->attribute->isTrustMeAllowedOnMethod->types->getParameterTypes->last->isReifiable->Check.this->pos->Warnings->last->VarargsUnsafeUseVarargsParam->warnUnsafeVararg->break->throw->new->AssertionError
Check#castWarner(DiagnosticPosition, Type, Type)::: check cast warner:::return->new->ConversionWarner
Check#convertWarner(DiagnosticPosition, Type, Type)::: check convert warner:::return->new->ConversionWarner
Check#checkFunctionalInterface(JCClassDecl, ClassSymbol)::: check check functional interface:::functionalType->cs->attribute->if->try->types->findDescriptorSymbol->catch->pos->tree->pos->foreach->tree->getModifiers->if->a->pos->break->log->Errors->ex->getDiagnostic->BadFunctionalIntfAnno1->error->finally
Check#checkImportsResolvable(JCCompilationUnit)::: check check imports resolvable:::foreach->toplevel->getImports->if->hasTag->continue->select->origin->if->TreeInfo->symbol->continue->site->TreeInfo->symbol->if->new->HashSet<Symbol>->checkTypeContainsImportableElement->log->imp->pos->Errors->Fragments->kindName->Location->CantResolveLocation->error
Check#checkImportedPackagesObservable(JCCompilationUnit)::: check check imported packages observable:::foreach->toplevel->getImports->if->TreeInfo->name->tsym->if->tsym->members->isEmpty->allowedInSource->tsym->exists->log->Errors->DoesntExist->error
Check#checkTypeContainsImportableElement(TypeSymbol, TypeSymbol, PackageSymbol, Name, Set)::: check check type contains importable element:::if->processed->add->return->if->types->supertype->checkTypeContainsImportableElement->return->foreach->types->interfaces->if->checkTypeContainsImportableElement->return->foreach->tsym->members->getSymbolsByName->if->sym->isStatic->importAccessible->sym->isMemberOf->return->return
Check#importAccessible(Symbol, PackageSymbol)::: check import accessible:::try->flags->sym->flags->switch->return->return->return->sym->packge->catch->throw->return->finally
Check#checkLeaksNotAccessible(Env, JCClassDecl)::: check check leaks not accessible:::toplevel->if->flags->return->currentExport->findExport->if->return->new->TreeScanner->scan
Check#findExport(PackageSymbol)::: check find export:::foreach->if->return->return
Check#isAPISymbol(Symbol)::: check is symbol:::while->if->sym->flags->sym->flags->return->return
Check#checkVisible(DiagnosticPosition, Symbol, PackageSymbol, boolean)::: check check visible:::if->isAPISymbol->log->Warnings->kindName->what->packge->LeaksNotAccessible->warning->return->whatPackage->what->packge->whatExport->findExport->inExport->findExport->if->log->Warnings->kindName->what->packge->LeaksNotAccessibleUnexported->warning->return->if->if->containsAll->log->Warnings->kindName->what->packge->LeaksNotAccessibleUnexportedQualified->warning->if->todo->List->of->while->todo->nonEmpty->current->if->return->if->current->flags->continue->foreach->if->req->isTransitive->todo->prepend->log->Warnings->kindName->what->packge->LeaksNotAccessibleNotRequiredTransitive->warning
Check#checkModuleExists(DiagnosticPosition, ModuleSymbol)::: check check module exists:::if->deferredLintHandler->if->lint->isEnabled->log->Warnings->ModuleNotFound->warning->report
Check#checkPackageExistsForOpens(DiagnosticPosition, PackageSymbol)::: check check package exists for opens:::if->packge->members->isEmpty->packge->flags->deferredLintHandler->if->lint->isEnabled->log->Warnings->PackageEmptyOrNotFound->warning->report
Check#checkModuleRequires(DiagnosticPosition, RequiresDirective)::: check check module requires:::if->flags->deferredLintHandler->if->rd->isTransitive->lint->isEnabled->log->warning->else->if->lint->isEnabled->log->warning->report
CompileStates#instance(Context):::Get the CompileStates instance for this context.:::instance->context->get->if->new->CompileStates->return
CompileStates#isDone(Env, CompileState)::: compile states is done:::ecs->get->return->cs->isAfter
ConstFold#instance(Context)::: const fold instance:::instance->context->get->if->new->ConstFold->return
ConstFold#b2i(boolean):::Convert boolean to integer (true = 1, false = 0).:::return
ConstFold#intValue(Object)::: const fold int value:::return->intValue
ConstFold#longValue(Object)::: const fold long value:::return->longValue
ConstFold#floatValue(Object)::: const fold float value:::return->floatValue
ConstFold#doubleValue(Object)::: const fold double value:::return->doubleValue
ConstFold#fold1(int, Type):::Fold unary operation.:::try->od->operand->constValue->switch->return->return->intValue->constType->return->intValue->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->intValue->b2i->constType->return->Long->longValue->valueOf->constType->return->Long->longValue->valueOf->constType->return->Float->floatValue->valueOf->constType->return->Double->doubleValue->valueOf->constType->return->catch->return->finally
ConstFold#fold2(int, Type, Type):::Fold binary operation.:::try->if->t1->fold2->return->t1->constValue->fold1->else->l->left->constValue->r->right->constValue->switch->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->left->hasTag->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->intValue->intValue->b2i->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->longValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->return->Long->longValue->intValue->valueOf->constType->if->longValue->longValue->return->constType->else->if->longValue->longValue->return->constType->else->return->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->return->Float->floatValue->floatValue->valueOf->constType->if->floatValue->floatValue->return->constType->else->if->floatValue->floatValue->return->constType->else->if->floatValue->floatValue->return->constType->else->if->return->constType->else->return->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->return->Double->doubleValue->doubleValue->valueOf->constType->if->doubleValue->doubleValue->return->constType->else->if->doubleValue->doubleValue->return->constType->else->if->doubleValue->doubleValue->return->constType->else->if->return->constType->else->return->constType->return->l->equals->b2i->constType->return->l->equals->b2i->constType->return->left->stringValue->right->stringValue->constType->return->catch->return->finally
ConstFold#coerce(Type, Type):::Coerce constant type to target type.:::if->return->if->etype->isNumeric->n->etype->constValue->switch->ttype->getTag->return->intValue->constType->return->intValue->constType->return->intValue->constType->return->intValue->constType->return->longValue->constType->return->floatValue->constType->return->doubleValue->constType->return
DeferredAttr#instance(Context)::: deferred attr instance:::instance->context->get->if->new->DeferredAttr->return
DeferredAttr.DeferredType#cloneWithMetadata(TypeMetadata)::: deferred type clone with metadata:::throw->new->AssertionError
DeferredAttr.DeferredType#getTag()::: deferred type get tag:::return
DeferredAttr.DeferredType#toString()::: deferred type to string:::return
DeferredAttr.DeferredType.SpeculativeCache.Entry#matches(MethodResolutionPhase)::: entry matches:::return->deferredAttrContext
DeferredAttr.DeferredType.SpeculativeCache#get(Symbol, MethodResolutionPhase):::Retrieve a speculative cache entry corresponding to given symbol and resolution phase:::entries->cache->get->if->return->foreach->if->e->matches->return->return
DeferredAttr.DeferredType.SpeculativeCache#put(JCTree, ResultInfo):::Stores a speculative cache entry corresponding to given symbol and resolution phase:::msym->deferredAttrContext->entries->cache->get->if->List->nil->cache->entries->new->Entry->prepend->put
DeferredAttr.DeferredType#speculativeType(Symbol, MethodResolutionPhase):::Get the type that has been computed during a speculative attribution round:::e->speculativeCache->get->return
DeferredAttr.DeferredType#speculativeTree(DeferredAttrContext)::: deferred type speculative tree:::e->speculativeCache->get->return
DeferredAttr.DeferredType#completer()::: deferred type completer:::return
DeferredAttr.DeferredType#check(ResultInfo):::Check a deferred type against a potential target-type:::deferredStuckPolicy->if->hasTag->isErroneous->else->if->deferredAttrContext->deferredAttrContext->insideOverloadPhase->new->OverloadStuckPolicy->else->new->CheckStuckPolicy->return->completer->check
DeferredAttr.DeferredType#check(ResultInfo, DeferredStuckPolicy, DeferredTypeCompleter)::: deferred type check:::deferredAttrContext->deferredAttrContext->Assert->check->if->deferredStuckPolicy->isStuck->notPertinentToApplicability->add->deferredAttrContext->addDeferredAttrNode->return->else->try->return->deferredTypeCompleter->complete->catch->finally
DeferredAttr.DeferredTypeCompleter#complete(DeferredType, ResultInfo, DeferredAttrContext):::Entry point for type-checking a deferred type:::
DeferredAttr.DeferredStuckPolicy#isStuck():::Has the policy detected that a given expression should be considered stuck?:::
DeferredAttr.DeferredStuckPolicy#stuckVars():::Get the set of inference variables a given expression depends upon.:::
DeferredAttr.DeferredStuckPolicy#depVars():::Get the set of inference variables which might get new constraints if a given expression is being type-checked.:::
DeferredAttr#attribSpeculativeLambda(JCLambda, Env, ResultInfo):::Performs speculative attribution of a lambda body and returns the speculative lambda tree, in the absence of a target-type:::stats->new->ListBuffer<>->stats->addAll->if->that->getBodyKind->stats->make->Return->add->else->stats->add->lambdaBlock->make->at->stats->toList->Block->localEnv->attr->lambdaEnv->try->speculativeTree->attribSpeculative->args->speculativeTree->getStatements->stream->s->hasTag->filter->map->List->collector->collect->lambdaBody->speculativeTree->getStatements->last->if->lambdaBody->hasTag->speculativeLambda->make->Lambda->attr->preFlow->flow->analyzeLambda->return->catch->finally->leave
DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo):::Routine that performs speculative type-checking; the input AST node is cloned (to avoid side-effects cause by Attr) and compiler state is restored after type-checking:::return->new->DeferredAttrDiagHandler->attribSpeculative
DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo, LocalCacheContext)::: deferred attr attrib speculative:::return->new->DeferredAttrDiagHandler->attribSpeculative
DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo, TreeCopier, Function, LocalCacheContext)::: deferred attr attrib speculative:::newTree->deferredCopier->copy->speculativeEnv->env->dupUnshared->dup->dup->deferredDiagnosticHandler->diagHandlerCreator->apply->try->attr->attribTree->return->catch->finally->new->UnenterScanner->scan->log->popDiagnosticHandler->if->localCache->leave
DeferredAttr.UnenterScanner#visitClassDef(JCClassDecl)::: unenter scanner visit class def:::csym->if->return->typeEnvs->remove->chk->removeCompiled->chk->clearLocalClassNameIndexes->syms->removeClass->super->visitClassDef
DeferredAttr.DeferredAttrDiagHandler.PosScanner#scan(JCTree)::: pos scanner scan:::if->tree->pos->super->scan
DeferredAttr.DeferredAttrContext#addDeferredAttrNode(DeferredType, ResultInfo, DeferredStuckPolicy):::Adds a node to the list of deferred attribution nodes - used by Resolve.rawCheckArgumentsApplicable Nodes added this way act as 'roots' for the out-of-order method checking process.:::deferredAttrNodes->new->DeferredAttrNode->add
DeferredAttr.DeferredAttrContext#complete():::Incrementally process all nodes, by skipping 'stuck' nodes and attributing 'unstuck' ones:::while->deferredAttrNodes->isEmpty->progress->foreach->List->from->if->deferredAttrNode->process->deferredAttrNodes->remove->if->if->insideOverloadPhase->foreach->return->try->toUnstuck->pickDeferredNode->inferenceContext->List->stuckVars->from->solveAny->inferenceContext->notifyChange->catch->break->finally
DeferredAttr.DeferredAttrContext#insideOverloadPhase()::: deferred attr context inside overload phase:::dac->if->return->if->return->return->insideOverloadPhase
DeferredAttr.DeferredAttrContext#pickDeferredNode():::Pick the deferred node to be unstuck:::stuckGraph->buildStuckGraph->csn->GraphUtils->tarjan->get->return->csn->length->csn->get->deferredAttrNodes->get
DeferredAttr.DeferredAttrContext#buildStuckGraph()::: deferred attr context build stuck graph:::infer->doIncorporation->graph->infer->new->GraphSolver->new->InferenceGraph->nodes->deferredAttrNodes->stream->StuckNode->new->map->List->collector->collect->foreach->foreach->if->canInfluence->add->return
DeferredAttr.DeferredAttrContext#canInfluence(InferenceGraph, StuckNode, StuckNode)::: deferred attr context can influence:::outputVars->depVars->foreach->stuckVars->inputNode->graph->findNode->if->inputClosure->inputNode->closure->if->outputVars->stream->graph->findNode->map->inputClosure->contains->anyMatch->return->return
DeferredAttr.DeferredAttrContext.StuckNode#getSupportedDependencyKinds()::: stuck node get supported dependency kinds:::return->new->DependencyKindArr
DeferredAttr.DeferredAttrContext.StuckNode#getDependenciesByKind(DependencyKind)::: stuck node get dependencies by kind:::if->return->else->throw->new->IllegalStateException
DeferredAttr.DeferredAttrContext.StuckNode#getAllDependencies()::: stuck node get all dependencies:::return
DeferredAttr.DeferredAttrNode#process(DeferredAttrContext):::Process a deferred attribution node:::switch->if->deferredStuckPolicy->isStuck->dt->new->StructuralStuckChecker->check->return->else->Assert->error->if->deferredStuckPolicy->isStuck->if->Type->List->deferredStuckPolicy->stuckVars->from->containsAny->resultInfo->new->Check.NestedCheckContext->dup->addDeferredAttrNode->return->else->return->else->Assert->deferredAttrContext->insideOverloadPhase->check->instResultInfo->resultInfo->asInstType->dup->dt->check->return->throw->new->AssertionError
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#complete(DeferredType, ResultInfo, DeferredAttrContext)::: structural stuck checker complete:::accept->put->return
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitLambda(JCLambda)::: structural stuck checker visit lambda:::checkContext->pt->if->contains->descriptorType->try->types->findDescriptorType->catch->checkContext->ex->getDiagnostic->report->finally->if->descriptorType->getParameterTypes->length->length->checkContext->diags->fragment->report->currentReturnType->descriptorType->getReturnType->returnTypeIsVoid->currentReturnType->hasTag->if->tree->getBodyKind->isExpressionCompatible->TreeInfo->tree->getBody->isExpressionStatement->if->tree->pos->diags->Fragments->Fragments->MissingRetVal->IncompatibleRetTypeInLambda->fragment->report->else->lambdaBodyChecker->new->LambdaBodyStructChecker->accept->isVoidCompatible->if->if->tree->pos->diags->fragment->report->else->isValueCompatible->canLambdaBodyCompleteNormally->if->log->pos->error->if->tree->pos->diags->Fragments->Fragments->MissingRetVal->IncompatibleRetTypeInLambda->fragment->report
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#canLambdaBodyCompleteNormally(JCLambda)::: structural stuck checker can lambda body complete normally:::oldParams->localCacheContext->argumentAttr->withLocalCacheContext->try->stream->make->make->Erroneous->VarDef->map->List->collector->collect->return->attribSpeculativeLambda->catch->finally->localCacheContext->leave
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitNewClass(JCNewClass)::: structural stuck checker visit new class:::
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitApply(JCMethodInvocation)::: structural stuck checker visit apply:::
DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitReference(JCMemberReference)::: structural stuck checker visit reference:::Assert->tree->getOverloadKind->checkNonNull->checkContext->pt->if->contains->descriptor->try->types->findDescriptorType->catch->checkContext->ex->getDiagnostic->report->finally->localEnv->env->dup->exprTree->tree->getQualifierExpression->attr->memberReferenceQualifierResult->argumentAttr->withLocalCacheContext->attribSpeculative->argtypes->new->ListBuffer<>->foreach->descriptor->getParameterTypes->argtypes->append->mref2->new->TreeCopier<Void>->copy->lookupSym->rs->argtypes->toList->List->nil->resolveMemberReference->switch->checkContext->diags->fragment->report->break->checkContext->argtypes->toList->List->nil->getDiagnostic->report->break
DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitClassDef(JCClassDecl)::: lambda body struct checker visit class def:::
DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitLambda(JCLambda)::: lambda body struct checker visit lambda:::
DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitNewClass(JCNewClass)::: lambda body struct checker visit new class:::
DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitReturn(JCReturn)::: lambda body struct checker visit return:::if->else
DeferredAttr.DeferredTypeMap#visitType(Type, Void)::: deferred type map visit type:::if->t->hasTag->return->super->visitType->else->dt->return->typeOf
DeferredAttr.DeferredTypeMap#typeOf(DeferredType)::: deferred type map type of:::switch->return->return->dt->speculativeType->Assert->error->return
DeferredAttr.RecoveryDeferredTypeMap#typeOf(DeferredType)::: recovery deferred type map type of:::owntype->super->typeOf->return->recover
DeferredAttr.RecoveryDeferredTypeMap#recover(DeferredType):::Synthesize a type for a deferred type that hasn't been previously reduced to an ordinary type:::dt->attr->new->RecoveryInfo->check->return->super->visit
DeferredAttr.FilterScanner#scan(JCTree)::: filter scanner scan:::if->if->treeFilter->accepts->super->scan->else->skip
DeferredAttr.FilterScanner#skip(JCTree):::handler that is executed when a node has been discarded:::
DeferredAttr.CheckStuckPolicy#isStuck()::: check stuck policy is stuck:::return->stuckVars->isEmpty
DeferredAttr.CheckStuckPolicy#stuckVars()::: check stuck policy stuck vars:::return
DeferredAttr.CheckStuckPolicy#depVars()::: check stuck policy dep vars:::return
DeferredAttr.CheckStuckPolicy#typesInferred(InferenceContext)::: check stuck policy types inferred:::stuckVars->clear
DeferredAttr.CheckStuckPolicy#visitLambda(JCLambda)::: check stuck policy visit lambda:::if->inferenceContext->inferenceVars->contains->stuckVars->add->if->types->isFunctionalInterface->return->descType->types->findDescriptorType->freeArgVars->inferenceContext->descType->getParameterTypes->freeVarsIn->if->freeArgVars->nonEmpty->stuckVars->addAll->depVars->inferenceContext->descType->getReturnType->freeVarsIn->addAll->descType->getReturnType->scanLambdaBody
DeferredAttr.CheckStuckPolicy#visitReference(JCMemberReference)::: check stuck policy visit reference:::scan->if->inferenceContext->inferenceVars->contains->stuckVars->add->return->if->types->isFunctionalInterface->return->descType->types->findDescriptorType->freeArgVars->inferenceContext->descType->getParameterTypes->freeVarsIn->if->freeArgVars->nonEmpty->tree->getOverloadKind->stuckVars->addAll->depVars->inferenceContext->descType->getReturnType->freeVarsIn->addAll
DeferredAttr.CheckStuckPolicy#scanLambdaBody(JCLambda, Type)::: check stuck policy scan lambda body:::if->lambda->getBodyKind->prevPt->try->scan->catch->finally->else->lambdaScanner->new->LambdaReturnScanner->lambdaScanner->scan
DeferredAttr.OverloadStuckPolicy#isStuck()::: overload stuck policy is stuck:::return->super->isStuck
DeferredAttr.OverloadStuckPolicy#visitLambda(JCLambda)::: overload stuck policy visit lambda:::super->visitLambda->if
DeferredAttr.OverloadStuckPolicy#visitReference(JCMemberReference)::: overload stuck policy visit reference:::super->visitReference->if->tree->getOverloadKind
Enter#instance(Context)::: enter instance:::instance->context->get->if->new->Enter->return
Enter#getEnv(TypeSymbol):::Accessor for typeEnvs:::return->typeEnvs->get
Enter#getEnvs()::: enter get envs:::return->typeEnvs->values
Enter#getClassEnv(TypeSymbol)::: enter get class env:::localEnv->getEnv->if->return->lintEnv->while->augment->return
Enter#classEnv(JCClassDecl, Env):::Create a fresh environment for class bodies:::localEnv->env->WriteableScope->create->dup->dup->TreeInfo->isDiamond->return
Enter#topLevelEnv(JCCompilationUnit):::Create a fresh environment for toplevels.:::localEnv->new->AttrContext->new->Env<>->WriteableScope->create->new->NamedImportScope->new->StarImportScope->return
Enter#getTopLevelEnv(JCCompilationUnit)::: enter get top level env:::localEnv->new->AttrContext->new->Env<>->return
Enter#enterScope(Env):::The scope in which a member definition in environment env is to be entered  This is usually the environment's scope, except for class environments,  where the local scope is for type variables, and the this and super symbol  only, and members go into the class member scope.:::return->hasTag
Enter#moduleEnv(JCModuleDecl, Env):::Create a fresh environment for modules.:::Assert->checkNonNull->localEnv->env->WriteableScope->create->dup->dup->return
Enter#classEnter(JCTree, Env):::Visitor method: enter all classes in given tree, catching any  completion failure exceptions:::prevEnv->try->annotate->blockAnnotations->tree->accept->return->catch->return->chk->tree->pos->completionError->finally->annotate->unblockAnnotations
Enter#classEnter(List, Env):::Visitor method: enter classes of a list of trees, returning a list of types.:::ts->new->ListBuffer<>->for->l->l->nonEmpty->return->ts->toList
Enter#visitTopLevel(JCCompilationUnit)::: enter visit top level:::prev->log->useSource->addEnv->isPkgInfo->isNameCompatible->if->TreeInfo->isModuleInfo->pd->tree->getPackage->if->log->pd->pos->error->topEnv->topLevelEnv->classEnter->modules->getUsesProvidesCompleter->else->pd->tree->getPackage->if->syms->TreeInfo->fullName->enterPackage->if->nonEmpty->if->else->if->nonEmpty->log->pos->error->else->visiblePackages->dependencyWithPackage->syms->listPackageModules->stream->filter->visiblePackages->get->syms->getPackage->filter->findAny->if->dependencyWithPackage->isPresent->log->Errors->dependencyWithPackage->get->PackageInOtherModule->error->complete->topEnv->topLevelEnv->packageEnv->topEnv->dup->if->env0->typeEnvs->get->if->tree0->if->fileManager->isSameFile->log->pos->Warnings->PkgInfoAlreadySeen->warning->typeEnvs->put->for->q->name->c->syms->enterClass->names->fromString->WriteableScope->create->classEnter->if->todo->append->log->useSource
Enter#visitClassDef(JCClassDecl)::: enter visit class def:::owner->enclScope->enterScope->c->if->packge->for->q->syms->enterClass->packge->members->enterIfAbsent->if->classNameMatchesFileName->topElement->if->else->if->log->tree->pos->Errors->ClassPublicShouldBeInFile->error->else->if->isEmpty->chk->tree->pos->checkUniqueClassName->return->if->syms->enterClass->if->if->log->tree->pos->Errors->SameBinaryName->error->types->createErrorType->return->Assert->owner->toString->check->Assert->toString->check->cowner->if->remove->if->else->syms->defineClass->chk->localClassName->if->isEmpty->chk->tree->pos->checkTransparentClass->if->chk->getCompiled->tree->pos->duplicateClass->types->createErrorType->return->chk->putCompiled->enclScope->enter->localEnv->classEnv->typeEnvs->put->chk->tree->pos->checkFlags->WriteableScope->create->c->clearAnnotationMetadata->ct->if->owner1->while->matches->if->ct->setEnclosingType->classEnter->if->c->isLocal->uncompleted->append->classEnter
Enter#classNameMatchesFileName(ClassSymbol, Env):::Does class have the same name as the file it appears in?:::return->toString->isNameCompatible
Enter#duplicateClass(DiagnosticPosition, ClassSymbol):::Complain about a duplicate class.:::log->Errors->DuplicateClass->error
Enter#visitTypeParameter(JCTypeParameter):::Class enter visitor method for type parameters:::a->new->TypeVar->if->chk->tree->pos->checkUnique->enter
Enter#visitModuleDef(JCModuleDecl)::: enter visit module def:::moduleEnv->moduleEnv->typeEnvs->put->if->modules->isInModuleGraph->todo->append
Enter#visitTree(JCTree):::Default class enter visitor method: do nothing.:::
Enter#main(List):::Main method: enter all classes in a list of toplevel trees.:::complete
Enter#complete(List, ClassSymbol):::Main method: enter classes from the list of toplevel trees, possibly  skipping TypeEnter for all but 'c' by placing them on the uncompleted  list.:::annotate->blockAnnotations->prevUncompleted->if->new->ListBuffer<>->try->classEnter->if->while->uncompleted->nonEmpty->clazz->uncompleted->next->if->clazz->complete->else->prevUncompleted->append->if->modules->modulesInitialized->foreach->if->cut->getModuleDecl->unfinishedModules->append->else->typeEnter->List->of->ensureImportsChecked->else->typeEnter->unfinishedModules->toList->ensureImportsChecked->unfinishedModules->clear->typeEnter->ensureImportsChecked->catch->finally->annotate->unblockAnnotations
Enter#newRound()::: enter new round:::typeEnvs->clear
Env#dup(JCTree, A):::Duplicate this environment, updating with given tree and info,  and copying all other fields.:::return->new->Env<>->dupto
Env#dupto(Env):::Duplicate this environment into a given Environment,  using its tree and info, and copying all other fields.:::return
Env#dup(JCTree):::Duplicate this environment, updating with given tree,  and copying all other fields.:::return->dup
Env#enclosing(JCTree.Tag):::Return closest enclosing environment which points to a tree with given tag.:::env1->while->hasTag->return
Env#toString()::: env to string:::sb->new->StringBuilder->sb->append->append->if->sb->append->append->sb->append->return->sb->toString
Env#iterator()::: env iterator:::return->new->Iterator<Env<A>>
Flow#instance(Context)::: flow instance:::instance->context->get->if->new->Flow->return
Flow#analyzeTree(Env, TreeMaker)::: flow analyze tree:::new->AliveAnalyzer->analyzeTree->new->AssignAnalyzer->analyzeTree->new->FlowAnalyzer->analyzeTree->new->CaptureAnalyzer->analyzeTree
Flow#analyzeLambda(Env, JCLambda, TreeMaker, boolean)::: flow analyze lambda:::diagHandler->if->new->Log.DiscardDiagnosticHandler->try->new->LambdaAliveAnalyzer->analyzeTree->catch->finally->if->log->popDiagnosticHandler
Flow#analyzeLambdaThrownTypes(Env, JCLambda, TreeMaker)::: flow analyze lambda thrown types:::diagHandler->new->Log.DiscardDiagnosticHandler->try->new->LambdaAssignAnalyzer->analyzeTree->flowAnalyzer->new->LambdaFlowAnalyzer->flowAnalyzer->analyzeTree->return->catch->finally->log->popDiagnosticHandler
Flow.BaseAnalyzer.PendingExit#resolveJump()::: pending exit resolve jump:::
Flow.BaseAnalyzer#markDead()::: base analyzer mark dead:::
Flow.BaseAnalyzer#recordExit(P):::Record an outward transfer of control.:::pendingExits->append->markDead
Flow.BaseAnalyzer#resolveJump(JCTree, ListBuffer, JumpKind):::Resolve all jumps of this statement.:::resolved->exits->pendingExits->toList->for->exits->nonEmpty->return
Flow.BaseAnalyzer#resolveContinues(JCTree):::Resolve all continues of this statement.:::return->new->ListBuffer<P>->resolveJump
Flow.BaseAnalyzer#resolveBreaks(JCTree, ListBuffer):::Resolve all breaks of this statement.:::return->resolveJump
Flow.BaseAnalyzer#scan(JCTree)::: base analyzer scan:::if->super->scan
Flow.BaseAnalyzer#visitPackageDef(JCPackageDecl)::: base analyzer visit package def:::
Flow.AliveAnalyzer#markDead()::: alive analyzer mark dead:::
Flow.AliveAnalyzer#scanDef(JCTree):::Analyze a definition.:::scanStat->if->tree->hasTag->log->tree->pos->error
Flow.AliveAnalyzer#scanStat(JCTree):::Analyze a statement:::if->log->tree->pos->error->if->tree->hasTag->scan
Flow.AliveAnalyzer#scanStats(List):::Analyze list of statements.:::if->for->l->l->nonEmpty
Flow.AliveAnalyzer#visitClassDef(JCClassDecl)::: alive analyzer visit class def:::if->return->alivePrev->pendingExitsPrev->lintPrev->new->ListBuffer<>->lint->augment->try->for->l->l->nonEmpty->for->l->l->nonEmpty->for->l->l->nonEmpty->catch->finally
Flow.AliveAnalyzer#visitMethodDef(JCMethodDecl)::: alive analyzer visit method def:::if->return->lintPrev->lint->augment->Assert->pendingExits->isEmpty->check->try->scanStat->if->getReturnType->hasTag->log->TreeInfo->diagEndPos->error->exits->pendingExits->toList->new->ListBuffer<>->while->exits->nonEmpty->exit->Assert->hasTag->check->catch->finally
Flow.AliveAnalyzer#visitVarDef(JCVariableDecl)::: alive analyzer visit var def:::if->lintPrev->lint->augment->try->scan->catch->finally
Flow.AliveAnalyzer#visitBlock(JCBlock)::: alive analyzer visit block:::scanStats
Flow.AliveAnalyzer#visitDoLoop(JCDoWhileLoop)::: alive analyzer visit do loop:::prevPendingExits->new->ListBuffer<>->scanStat->resolveContinues->scan->isTrue->resolveBreaks
Flow.AliveAnalyzer#visitWhileLoop(JCWhileLoop)::: alive analyzer visit while loop:::prevPendingExits->new->ListBuffer<>->scan->isFalse->scanStat->resolveContinues->resolveBreaks->isTrue
Flow.AliveAnalyzer#visitForLoop(JCForLoop)::: alive analyzer visit for loop:::prevPendingExits->scanStats->new->ListBuffer<>->if->scan->isFalse->else->scanStat->resolveContinues->scan->resolveBreaks->isTrue
Flow.AliveAnalyzer#visitForeachLoop(JCEnhancedForLoop)::: alive analyzer visit foreach loop:::visitVarDef->prevPendingExits->scan->new->ListBuffer<>->scanStat->resolveContinues->resolveBreaks
Flow.AliveAnalyzer#visitLabelled(JCLabeledStatement)::: alive analyzer visit labelled:::prevPendingExits->new->ListBuffer<>->scanStat->resolveBreaks
Flow.AliveAnalyzer#visitSwitch(JCSwitch)::: alive analyzer visit switch:::prevPendingExits->new->ListBuffer<>->scan->hasDefault->for->l->l->nonEmpty->if->resolveBreaks
Flow.AliveAnalyzer#visitTry(JCTry)::: alive analyzer visit try:::prevPendingExits->new->ListBuffer<>->foreach->if->vdecl->visitVarDef->else->if->scan->else->throw->new->AssertionError->scanStat->aliveEnd->for->l->l->nonEmpty->if->exits->scanStat->if->if->lint->isEnabled->log->TreeInfo->diagEndPos->warning->else->while->exits->nonEmpty->pendingExits->exits->next->append->else->exits->while->exits->nonEmpty->pendingExits->exits->next->append
Flow.AliveAnalyzer#visitIf(JCIf)::: alive analyzer visit if:::scan->scanStat->if->aliveAfterThen->scanStat->else
Flow.AliveAnalyzer#visitBreak(JCBreak)::: alive analyzer visit break:::new->PendingExit->recordExit
Flow.AliveAnalyzer#visitContinue(JCContinue)::: alive analyzer visit continue:::new->PendingExit->recordExit
Flow.AliveAnalyzer#visitReturn(JCReturn)::: alive analyzer visit return:::scan->new->PendingExit->recordExit
Flow.AliveAnalyzer#visitThrow(JCThrow)::: alive analyzer visit throw:::scan->markDead
Flow.AliveAnalyzer#visitApply(JCMethodInvocation)::: alive analyzer visit apply:::scan->scan
Flow.AliveAnalyzer#visitNewClass(JCNewClass)::: alive analyzer visit new class:::scan->scan->if->scan
Flow.AliveAnalyzer#visitLambda(JCLambda)::: alive analyzer visit lambda:::if->isErroneous->return->prevPending->prevAlive->try->new->ListBuffer<>->scanStat->catch->finally
Flow.AliveAnalyzer#visitModuleDef(JCModuleDecl)::: alive analyzer visit module def:::
Flow.AliveAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.AliveAnalyzer#analyzeTree(Env, JCTree, TreeMaker)::: alive analyzer analyze tree:::try->new->ListBuffer<>->scan->catch->finally
Flow.FlowAnalyzer#markDead()::: flow analyzer mark dead:::
Flow.FlowAnalyzer#errorUncaught():::Complain that pending exceptions are not caught.:::for->exit->pendingExits->next->pendingExits->next
Flow.FlowAnalyzer#markThrown(JCTree, Type):::Record that exception is potentially thrown and check that it  is caught.:::if->chk->tree->pos->isUnchecked->if->chk->isHandled->pendingExits->new->FlowPendingExit->append->chk->incl
Flow.FlowAnalyzer#visitClassDef(JCClassDecl)::: flow analyzer visit class def:::if->return->classDefPrev->thrownPrev->caughtPrev->pendingExitsPrev->lintPrev->anonymousClass->new->ListBuffer<>->if->List->nil->List->nil->lint->augment->try->for->l->l->nonEmpty->if->firstConstructor->for->l->l->nonEmpty->for->l->l->nonEmpty->if->for->l->l->nonEmpty->chk->union->for->l->l->nonEmpty->catch->finally
Flow.FlowAnalyzer#visitMethodDef(JCMethodDecl)::: flow analyzer visit method def:::if->return->caughtPrev->mthrown->getThrownTypes->lintPrev->lint->augment->Assert->pendingExits->isEmpty->check->try->for->l->l->nonEmpty->if->TreeInfo->isInitialConstructor->chk->union->else->if->flags->scan->exits->pendingExits->toList->new->ListBuffer<>->while->exits->nonEmpty->exit->if->Assert->hasTag->check->else->pendingExits->append->catch->finally
Flow.FlowAnalyzer#visitVarDef(JCVariableDecl)::: flow analyzer visit var def:::if->lintPrev->lint->augment->try->scan->catch->finally
Flow.FlowAnalyzer#visitBlock(JCBlock)::: flow analyzer visit block:::scan
Flow.FlowAnalyzer#visitDoLoop(JCDoWhileLoop)::: flow analyzer visit do loop:::prevPendingExits->new->ListBuffer<>->scan->resolveContinues->scan->resolveBreaks
Flow.FlowAnalyzer#visitWhileLoop(JCWhileLoop)::: flow analyzer visit while loop:::prevPendingExits->new->ListBuffer<>->scan->scan->resolveContinues->resolveBreaks
Flow.FlowAnalyzer#visitForLoop(JCForLoop)::: flow analyzer visit for loop:::prevPendingExits->scan->new->ListBuffer<>->if->scan->scan->resolveContinues->scan->resolveBreaks
Flow.FlowAnalyzer#visitForeachLoop(JCEnhancedForLoop)::: flow analyzer visit foreach loop:::visitVarDef->prevPendingExits->scan->new->ListBuffer<>->scan->resolveContinues->resolveBreaks
Flow.FlowAnalyzer#visitLabelled(JCLabeledStatement)::: flow analyzer visit labelled:::prevPendingExits->new->ListBuffer<>->scan->resolveBreaks
Flow.FlowAnalyzer#visitSwitch(JCSwitch)::: flow analyzer visit switch:::prevPendingExits->new->ListBuffer<>->scan->for->l->l->nonEmpty->resolveBreaks
Flow.FlowAnalyzer#visitTry(JCTry)::: flow analyzer visit try:::caughtPrev->thrownPrev->List->nil->for->l->l->nonEmpty->prevPendingExits->new->ListBuffer<>->foreach->if->vdecl->visitVarDef->else->if->scan->else->throw->new->AssertionError->foreach->closeableSupertypes->isCompound->types->interfaces->types->supertype->prepend->List->of->foreach->if->types->asSuper->closeMethod->rs->types->skipTypeVars->List->nil->List->nil->resolveQualifiedMethod->mt->types->memberType->if->foreach->mt->getThrownTypes->markThrown->scan->thrownInTry->chk->List->of->union->caughtInTry->List->nil->for->l->l->nonEmpty->if->savedThrown->List->nil->exits->scan->if->chk->union->else->chk->chk->diff->union->chk->union->while->exits->nonEmpty->pendingExits->exits->next->append->else->chk->chk->diff->union->exits->while->exits->nonEmpty->pendingExits->exits->next->append
Flow.FlowAnalyzer#visitIf(JCIf)::: flow analyzer visit if:::scan->scan->if->scan
Flow.FlowAnalyzer#checkCaughtType(DiagnosticPosition, Type, List, List)::: flow analyzer check caught type:::if->chk->subset->log->Errors->ExceptAlreadyCaught->error->else->if->chk->isUnchecked->isExceptionOrThrowable->chk->intersects->log->Errors->ExceptNeverThrownInTry->error->else->if->catchableThrownTypes->chk->List->of->intersect->if->chk->diff->isEmpty->isExceptionOrThrowable->key->catchableThrownTypes->length->Warnings->UnreachableCatch->Warnings->UnreachableCatch1->log->warning
Flow.FlowAnalyzer#isExceptionOrThrowable(Type)::: flow analyzer is exception or throwable:::return
Flow.FlowAnalyzer#visitBreak(JCBreak)::: flow analyzer visit break:::new->FlowPendingExit->recordExit
Flow.FlowAnalyzer#visitContinue(JCContinue)::: flow analyzer visit continue:::new->FlowPendingExit->recordExit
Flow.FlowAnalyzer#visitReturn(JCReturn)::: flow analyzer visit return:::scan->new->FlowPendingExit->recordExit
Flow.FlowAnalyzer#visitThrow(JCThrow)::: flow analyzer visit throw:::scan->sym->TreeInfo->symbol->if->sym->flags->preciseRethrowTypes->get->foreach->preciseRethrowTypes->get->markThrown->else->markThrown->markDead
Flow.FlowAnalyzer#visitApply(JCMethodInvocation)::: flow analyzer visit apply:::scan->scan->for->l->getThrownTypes->l->nonEmpty
Flow.FlowAnalyzer#visitNewClass(JCNewClass)::: flow analyzer visit new class:::scan->scan->for->l->getThrownTypes->l->nonEmpty->caughtPrev->try->if->for->l->getThrownTypes->l->nonEmpty->scan->catch->finally
Flow.FlowAnalyzer#visitLambda(JCLambda)::: flow analyzer visit lambda:::if->isErroneous->return->prevCaught->prevThrown->prevPending->try->new->ListBuffer<>->tree->getDescriptorType->getThrownTypes->List->nil->scan->exits->pendingExits->toList->new->ListBuffer<>->while->exits->nonEmpty->exit->if->Assert->hasTag->check->else->pendingExits->append->errorUncaught->catch->finally
Flow.FlowAnalyzer#visitModuleDef(JCModuleDecl)::: flow analyzer visit module def:::
Flow.FlowAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.FlowAnalyzer#analyzeTree(Env, JCTree, TreeMaker)::: flow analyzer analyze tree:::try->new->ListBuffer<>->new->HashMap<>->scan->catch->finally
Flow.LambdaAliveAnalyzer#visitReturn(JCReturn)::: lambda alive analyzer visit return:::new->PendingExit->recordExit
Flow.LambdaAliveAnalyzer#visitLambda(JCLambda)::: lambda alive analyzer visit lambda:::if->tree->getBodyKind->return->try->super->visitLambda->catch->finally
Flow.LambdaAliveAnalyzer#visitClassDef(JCClassDecl)::: lambda alive analyzer visit class def:::
Flow.LambdaAssignAnalyzer#visitLambda(JCLambda)::: lambda assign analyzer visit lambda:::if->return->try->super->visitLambda->catch->finally
Flow.LambdaAssignAnalyzer#visitVarDef(JCVariableDecl)::: lambda assign analyzer visit var def:::enclosedSymbols->enter->super->visitVarDef
Flow.LambdaAssignAnalyzer#trackable(VarSymbol)::: lambda assign analyzer trackable:::return->enclosedSymbols->includes
Flow.LambdaAssignAnalyzer#visitClassDef(JCClassDecl)::: lambda assign analyzer visit class def:::
Flow.LambdaFlowAnalyzer#visitLambda(JCLambda)::: lambda flow analyzer visit lambda:::if->isErroneous->return->prevCaught->prevThrown->prevPending->try->new->ListBuffer<>->List->of->List->nil->scan->catch->finally
Flow.LambdaFlowAnalyzer#visitClassDef(JCClassDecl)::: lambda flow analyzer visit class def:::
Flow.AssignAnalyzer.AssignPendingExit#resolveJump()::: assign pending exit resolve jump:::inits->andSet->uninits->andSet
Flow.AssignAnalyzer#markDead()::: assign analyzer mark dead:::if->inits->inclRange->else->for->address->uninits->inclRange
Flow.AssignAnalyzer#trackable(VarSymbol):::Do we need to track init/uninit state of this symbol?  I.e:::return->isFinalUninitializedField
Flow.AssignAnalyzer#isFinalUninitializedField(VarSymbol)::: assign analyzer is final uninitialized field:::return->sym->flags->isEnclosedBy
Flow.AssignAnalyzer#isFinalUninitializedStaticField(VarSymbol)::: assign analyzer is final uninitialized static field:::return->isFinalUninitializedField->sym->isStatic
Flow.AssignAnalyzer#newVar(JCVariableDecl):::Initialize new trackable variable by setting its address field  to the next available sequence number and entering it under that  index into the vars array.:::sym->ArrayUtils->ensureCapacity->if->sym->flags->inits->excl->uninits->incl
Flow.AssignAnalyzer#letInit(DiagnosticPosition, VarSymbol):::Record an initialization of a trackable variable.:::if->trackable->if->sym->flags->if->uninits->isMember->else->uninit->else->if->sym->flags->if->sym->flags->if->sym->flags->log->Errors->MulticatchParameterMayNotBeAssigned->error->else->log->Errors->FinalParameterMayNotBeAssigned->error->else->if->uninits->isMember->log->diags->errorKey->error->else->uninit->inits->incl->else->if->sym->flags->log->Errors->VarMightAlreadyBeAssigned->error
Flow.AssignAnalyzer#uninit(VarSymbol)::: assign analyzer uninit:::if->inits->isMember->uninits->excl->uninitsTry->excl->else->uninits->excl
Flow.AssignAnalyzer#letInit(JCTree):::If tree is either a simple name or of the form this.name or  C.this.name, and tree represents a trackable variable,  record an initialization of the variable.:::TreeInfo->skipParens->if->tree->hasTag->tree->hasTag->sym->TreeInfo->symbol->if->tree->pos->letInit
Flow.AssignAnalyzer#checkInit(DiagnosticPosition, VarSymbol):::Check that trackable variable is initialized.:::Errors->VarMightNotHaveBeenInitialized->checkInit
Flow.AssignAnalyzer#checkInit(DiagnosticPosition, VarSymbol, Error)::: assign analyzer check init:::if->trackable->inits->isMember->log->error->inits->incl
Flow.AssignAnalyzer#resetBits(Bits...):::Utility method to reset several Bits instances.:::foreach->b->reset
Flow.AssignAnalyzer#split(boolean):::Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets:::initsWhenFalse->assign->uninitsWhenFalse->assign->initsWhenTrue->assign->uninitsWhenTrue->assign->if->resetBits
Flow.AssignAnalyzer#merge():::Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.:::inits->initsWhenFalse->andSet->assign->uninits->uninitsWhenFalse->andSet->assign
Flow.AssignAnalyzer#scanExpr(JCTree):::Analyze an expression:::if->scan->if->inits->isReset->merge
Flow.AssignAnalyzer#scanExprs(List):::Analyze a list of expressions.:::if->for->l->l->nonEmpty
Flow.AssignAnalyzer#scanCond(JCTree):::Analyze a condition:::if->isFalse->if->inits->isReset->merge->initsWhenTrue->assign->initsWhenTrue->inclRange->uninitsWhenTrue->assign->uninitsWhenTrue->inclRange->initsWhenFalse->assign->uninitsWhenFalse->assign->else->if->isTrue->if->inits->isReset->merge->initsWhenFalse->assign->initsWhenFalse->inclRange->uninitsWhenFalse->assign->uninitsWhenFalse->inclRange->initsWhenTrue->assign->uninitsWhenTrue->assign->else->scan->if->inits->isReset->split->if->resetBits
Flow.AssignAnalyzer#visitClassDef(JCClassDecl)::: assign analyzer visit class def:::if->return->lintPrev->lint->augment->try->if->return->classDefPrev->firstadrPrev->nextadrPrev->pendingExitsPrev->new->ListBuffer<>->if->try->for->l->l->nonEmpty->for->l->l->nonEmpty->for->l->l->nonEmpty->for->l->l->nonEmpty->for->l->l->nonEmpty->catch->finally->catch->finally
Flow.AssignAnalyzer#visitMethodDef(JCMethodDecl)::: assign analyzer visit method def:::if->return->if->flags->return->lintPrev->lint->augment->try->if->return->if->flags->return->initsPrev->new->Bits->uninitsPrev->new->Bits->nextadrPrev->firstadrPrev->returnadrPrev->Assert->pendingExits->isEmpty->check->lastInitialConstructor->try->TreeInfo->isInitialConstructor->if->for->l->l->nonEmpty->scan->if->isSynthesized->flags->for->i->exits->pendingExits->toList->new->ListBuffer<>->while->exits->nonEmpty->exit->Assert->hasTag->check->if->inits->assign->for->i->catch->finally->inits->assign->uninits->assign->catch->finally
Flow.AssignAnalyzer#initParam(JCVariableDecl)::: assign analyzer init param:::inits->incl->uninits->excl
Flow.AssignAnalyzer#visitVarDef(JCVariableDecl)::: assign analyzer visit var def:::lintPrev->lint->augment->try->track->trackable->if->newVar->if->scanExpr->if->tree->pos->letInit->catch->finally
Flow.AssignAnalyzer#visitBlock(JCBlock)::: assign analyzer visit block:::nextadrPrev->scan
Flow.AssignAnalyzer#visitDoLoop(JCDoWhileLoop)::: assign analyzer visit do loop:::prevPendingExits->prevFlowKind->initsSkip->new->Bits->uninitsSkip->new->Bits->new->ListBuffer<>->prevErrors->do->uninitsEntry->new->Bits->uninitsEntry->excludeFrom->scan->resolveContinues->scanCond->if->flowKind->isFinal->initsSkip->assign->uninitsSkip->assign->if->flowKind->isFinal->new->Bits->diffSet->nextBit->break->inits->assign->uninits->uninitsEntry->andSet->assign->while->inits->assign->uninits->assign->resolveBreaks
Flow.AssignAnalyzer#visitWhileLoop(JCWhileLoop)::: assign analyzer visit while loop:::prevPendingExits->prevFlowKind->initsSkip->new->Bits->uninitsSkip->new->Bits->new->ListBuffer<>->prevErrors->uninitsEntry->new->Bits->uninitsEntry->excludeFrom->do->scanCond->if->flowKind->isFinal->initsSkip->assign->uninitsSkip->assign->inits->assign->uninits->assign->scan->resolveContinues->if->flowKind->isFinal->new->Bits->diffSet->nextBit->break->uninits->uninitsEntry->andSet->assign->while->inits->assign->uninits->assign->resolveBreaks
Flow.AssignAnalyzer#visitForLoop(JCForLoop)::: assign analyzer visit for loop:::prevPendingExits->prevFlowKind->nextadrPrev->scan->initsSkip->new->Bits->uninitsSkip->new->Bits->new->ListBuffer<>->prevErrors->do->uninitsEntry->new->Bits->uninitsEntry->excludeFrom->if->scanCond->if->flowKind->isFinal->initsSkip->assign->uninitsSkip->assign->inits->assign->uninits->assign->else->if->flowKind->isFinal->initsSkip->assign->initsSkip->inclRange->uninitsSkip->assign->uninitsSkip->inclRange->scan->resolveContinues->scan->if->flowKind->isFinal->new->Bits->diffSet->nextBit->break->uninits->uninitsEntry->andSet->assign->while->inits->assign->uninits->assign->resolveBreaks
Flow.AssignAnalyzer#visitForeachLoop(JCEnhancedForLoop)::: assign analyzer visit foreach loop:::visitVarDef->prevPendingExits->prevFlowKind->nextadrPrev->scan->initsStart->new->Bits->uninitsStart->new->Bits->tree->pos->letInit->new->ListBuffer<>->prevErrors->do->uninitsEntry->new->Bits->uninitsEntry->excludeFrom->scan->resolveContinues->if->flowKind->isFinal->new->Bits->diffSet->nextBit->break->uninits->uninitsEntry->andSet->assign->while->inits->assign->uninits->uninitsStart->andSet->assign->resolveBreaks
Flow.AssignAnalyzer#visitLabelled(JCLabeledStatement)::: assign analyzer visit labelled:::prevPendingExits->new->ListBuffer<>->scan->resolveBreaks
Flow.AssignAnalyzer#visitSwitch(JCSwitch)::: assign analyzer visit switch:::prevPendingExits->new->ListBuffer<>->nextadrPrev->scanExpr->initsSwitch->new->Bits->uninitsSwitch->new->Bits->hasDefault->for->l->l->nonEmpty->if->inits->andSet->resolveBreaks
Flow.AssignAnalyzer#addVars(List, Bits, Bits):::Add any variables defined in stats to inits and uninits.:::for->stats->nonEmpty
Flow.AssignAnalyzer#visitTry(JCTry)::: assign analyzer visit try:::resourceVarDecls->new->ListBuffer<>->uninitsTryPrev->new->Bits->prevPendingExits->new->ListBuffer<>->initsTry->new->Bits->uninitsTry->assign->foreach->if->vdecl->visitVarDef->unrefdResources->enter->resourceVarDecls->append->else->if->scanExpr->else->throw->new->AssertionError->scan->uninitsTry->andSet->initsEnd->new->Bits->uninitsEnd->new->Bits->nextadrCatch->if->resourceVarDecls->isEmpty->lint->isEnabled->foreach->if->unrefdResources->includes->log->resVar->pos->Warnings->TryResourceNotReferenced->warning->unrefdResources->remove->initsCatchPrev->new->Bits->uninitsCatchPrev->new->Bits->for->l->l->nonEmpty->if->inits->assign->uninits->assign->exits->scan->if->else->uninits->andSet->while->exits->nonEmpty->exit->exits->next->if->orSet->andSet->pendingExits->append->inits->orSet->else->inits->assign->uninits->assign->exits->while->exits->nonEmpty->pendingExits->exits->next->append->uninitsTry->andSet->andSet
Flow.AssignAnalyzer#visitConditional(JCConditional)::: assign analyzer visit conditional:::scanCond->initsBeforeElse->new->Bits->uninitsBeforeElse->new->Bits->inits->assign->uninits->assign->if->hasTag->hasTag->scanCond->initsAfterThenWhenTrue->new->Bits->initsAfterThenWhenFalse->new->Bits->uninitsAfterThenWhenTrue->new->Bits->uninitsAfterThenWhenFalse->new->Bits->inits->assign->uninits->assign->scanCond->initsWhenTrue->andSet->initsWhenFalse->andSet->uninitsWhenTrue->andSet->uninitsWhenFalse->andSet->else->scanExpr->initsAfterThen->new->Bits->uninitsAfterThen->new->Bits->inits->assign->uninits->assign->scanExpr->inits->andSet->uninits->andSet
Flow.AssignAnalyzer#visitIf(JCIf)::: assign analyzer visit if:::scanCond->initsBeforeElse->new->Bits->uninitsBeforeElse->new->Bits->inits->assign->uninits->assign->scan->if->initsAfterThen->new->Bits->uninitsAfterThen->new->Bits->inits->assign->uninits->assign->scan->inits->andSet->uninits->andSet->else->inits->andSet->uninits->andSet
Flow.AssignAnalyzer#visitBreak(JCBreak)::: assign analyzer visit break:::new->AssignPendingExit->recordExit
Flow.AssignAnalyzer#visitContinue(JCContinue)::: assign analyzer visit continue:::new->AssignPendingExit->recordExit
Flow.AssignAnalyzer#visitReturn(JCReturn)::: assign analyzer visit return:::scanExpr->new->AssignPendingExit->recordExit
Flow.AssignAnalyzer#visitThrow(JCThrow)::: assign analyzer visit throw:::scanExpr->markDead
Flow.AssignAnalyzer#visitApply(JCMethodInvocation)::: assign analyzer visit apply:::scanExpr->scanExprs
Flow.AssignAnalyzer#visitNewClass(JCNewClass)::: assign analyzer visit new class:::scanExpr->scanExprs->scan
Flow.AssignAnalyzer#visitLambda(JCLambda)::: assign analyzer visit lambda:::prevUninits->new->Bits->prevInits->new->Bits->returnadrPrev->nextadrPrev->prevPending->try->new->ListBuffer<>->for->l->l->nonEmpty->if->tree->getBodyKind->scanExpr->else->scan->catch->finally->uninits->assign->inits->assign
Flow.AssignAnalyzer#visitNewArray(JCNewArray)::: assign analyzer visit new array:::scanExprs->scanExprs
Flow.AssignAnalyzer#visitAssert(JCAssert)::: assign analyzer visit assert:::initsExit->new->Bits->uninitsExit->new->Bits->scanCond->uninitsExit->andSet->if->inits->assign->uninits->assign->scanExpr->inits->assign->uninits->assign
Flow.AssignAnalyzer#visitAssign(JCAssign)::: assign analyzer visit assign:::if->TreeInfo->isIdentOrThisDotIdent->scanExpr->scanExpr->letInit
Flow.AssignAnalyzer#visitSelect(JCFieldAccess)::: assign analyzer visit select:::super->visitSelect->if->TreeInfo->isThisQualifier->tree->pos->checkInit
Flow.AssignAnalyzer#visitAssignop(JCAssignOp)::: assign analyzer visit assignop:::scanExpr->scanExpr->letInit
Flow.AssignAnalyzer#visitUnary(JCUnary)::: assign analyzer visit unary:::switch->tree->getTag->scanCond->t->new->Bits->initsWhenFalse->assign->initsWhenTrue->assign->t->assign->uninitsWhenFalse->assign->uninitsWhenTrue->assign->break->scanExpr->letInit->break->scanExpr
Flow.AssignAnalyzer#visitBinary(JCBinary)::: assign analyzer visit binary:::switch->tree->getTag->scanCond->initsWhenFalseLeft->new->Bits->uninitsWhenFalseLeft->new->Bits->inits->assign->uninits->assign->scanCond->initsWhenFalse->andSet->uninitsWhenFalse->andSet->break->scanCond->initsWhenTrueLeft->new->Bits->uninitsWhenTrueLeft->new->Bits->inits->assign->uninits->assign->scanCond->initsWhenTrue->andSet->uninitsWhenTrue->andSet->break->scanExpr->scanExpr
Flow.AssignAnalyzer#visitIdent(JCIdent)::: assign analyzer visit ident:::if->tree->pos->checkInit->referenced
Flow.AssignAnalyzer#referenced(Symbol)::: assign analyzer referenced:::unrefdResources->remove
Flow.AssignAnalyzer#visitAnnotatedType(JCAnnotatedType)::: assign analyzer visit annotated type:::accept
Flow.AssignAnalyzer#visitModuleDef(JCModuleDecl)::: assign analyzer visit module def:::
Flow.AssignAnalyzer#analyzeTree(Env):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.AssignAnalyzer#analyzeTree(Env, JCTree)::: assign analyzer analyze tree:::try->tree->pos->getStartPosition->if->new->JCVariableDeclArr->else->for->i->new->ListBuffer<>->WriteableScope->create->scan->catch->finally->resetBits->if->for->i
Flow.CaptureAnalyzer#markDead()::: capture analyzer mark dead:::
Flow.CaptureAnalyzer#checkEffectivelyFinal(DiagnosticPosition, VarSymbol)::: capture analyzer check effectively final:::if->currentTree->getStartPosition->switch->currentTree->getTag->if->if->sym->flags->reportInnerClsNeedsFinalError->break->if->sym->flags->reportEffectivelyFinalError
Flow.CaptureAnalyzer#letInit(JCTree)::: capture analyzer let init:::TreeInfo->skipParens->if->tree->hasTag->tree->hasTag->sym->TreeInfo->symbol->if->currentTree->getStartPosition->switch->currentTree->getTag->if->reportInnerClsNeedsFinalError->break->reportEffectivelyFinalError
Flow.CaptureAnalyzer#reportEffectivelyFinalError(DiagnosticPosition, Symbol)::: capture analyzer report effectively final error:::subKey->currentTree->hasTag->log->Errors->diags->fragment->CantRefNonEffectivelyFinalVar->error
Flow.CaptureAnalyzer#reportInnerClsNeedsFinalError(DiagnosticPosition, Symbol)::: capture analyzer report inner cls needs final error:::log->Errors->LocalVarAccessedFromIclsNeedsFinal->error
Flow.CaptureAnalyzer#visitClassDef(JCClassDecl)::: capture analyzer visit class def:::prevTree->try->isLocal->super->visitClassDef->catch->finally
Flow.CaptureAnalyzer#visitLambda(JCLambda)::: capture analyzer visit lambda:::prevTree->try->super->visitLambda->catch->finally
Flow.CaptureAnalyzer#visitIdent(JCIdent)::: capture analyzer visit ident:::if->checkEffectivelyFinal
Flow.CaptureAnalyzer#visitAssign(JCAssign)::: capture analyzer visit assign:::lhs->TreeInfo->skipParens->if->scan->scan->letInit
Flow.CaptureAnalyzer#visitAssignop(JCAssignOp)::: capture analyzer visit assignop:::scan->scan->letInit
Flow.CaptureAnalyzer#visitUnary(JCUnary)::: capture analyzer visit unary:::switch->tree->getTag->scan->letInit->break->scan
Flow.CaptureAnalyzer#visitTry(JCTry)::: capture analyzer visit try:::foreach->if->resource->hasTag->var->TreeInfo->symbol->if->var->flags->log->resource->pos->Errors->TryWithResourcesExprEffectivelyFinalVar->error->super->visitTry
Flow.CaptureAnalyzer#visitModuleDef(JCModuleDecl)::: capture analyzer visit module def:::
Flow.CaptureAnalyzer#analyzeTree(Env, TreeMaker):::Perform definite assignment/unassignment analysis on a tree.:::analyzeTree
Flow.CaptureAnalyzer#analyzeTree(Env, JCTree, TreeMaker)::: capture analyzer analyze tree:::try->new->ListBuffer<>->scan->catch->finally
Infer#instance(Context)::: infer instance:::instance->context->get->if->new->Infer->return
Infer.InferenceException#getDiagnostic()::: inference exception get diagnostic:::return
Infer#error(JCDiagnostic)::: infer error:::result->new->InferenceException->if->append->return
Infer#instantiateMethod(Env, List, MethodType, Attr.ResultInfo, MethodSymbol, List, boolean, boolean, Resolve.MethodResolutionContext, Warner):::Main inference entry point - instantiate a generic method type using given argument types and (possibly) an expected target-type.:::inferenceContext->new->InferenceContext->try->deferredAttrContext->resolveContext->deferredAttrContext->mt->getParameterTypes->argumentsAcceptable->if->doIncorporation->return->new->PartiallyInferredMethodType->else->if->doIncorporation->if->warn->hasNonSilentLint->shouldPropagate->mt->getReturnType->shouldPropagate->minContext->inferenceContext->roots->min->newRestype->generateReturnConstraints->types->createMethodTypeWithReturn->if->minContext->inferenceContext->dupTo->deferredAttrContext->complete->return->deferredAttrContext->complete->if->inferenceContext->solve->else->inferenceContext->solveLegacy->inferenceContext->asInstType->if->inferenceContext->restvars->nonEmpty->warn->hasNonSilentLint->generateReturnConstraints->inferenceContext->solveLegacy->inferenceContext->asInstType->if->contains->log->Notes->DeferredMethodInst->note->return->catch->finally->if->inferenceContext->notifyChange->else->inferenceContext->inferenceContext->boundedVars->notifyChange->if->clear->dumpGraphsIfNeeded
Infer#shouldPropagate(Type, Attr.ResultInfo, InferenceContext)::: infer should propagate:::return->inferenceContext->inferenceContext->free->contains->inferenceContext->asUndetVar->needsEagerInstantiation
Infer#roots(MethodType, DeferredAttrContext)::: infer roots:::if->roots->new->ListBuffer<>->roots->mt->getReturnType->add->foreach->roots->stuckVars->addAll->roots->depVars->addAll->thrownVars->stream->flags->filter->List->collector->collect->result->roots->toList->result->thrownVars->diff->appendList->return->else->return->List->mt->getReturnType->of
Infer.PartiallyInferredMethodType#isPartial()::: partially inferred method type is partial:::return
Infer.PartiallyInferredMethodType#check(Attr.ResultInfo):::Checks this type against a target; this means generating return type constraints, solve and then roll back the results (to avoid poolluting the context).:::noWarnings->new->Warner->saved_undet->try->inferenceContext->save->unchecked->warn->hasNonSilentLint->if->shouldPropagate->getReturnType->shouldPropagate->minContext->inferenceContext->asMethodType->roots->min->other->minContext->asMethodType->update->newRestype->generateReturnConstraints->if->minContext->inferenceContext->deferredAttrContext->insideOverloadPhase->dupTo->return->inferenceContext->solve->ret->inferenceContext->asInstType->getReturnType->if->types->erasure->return->resultInfo->check->catch->ex->getDiagnostic->report->Assert->error->return->finally->if->inferenceContext->rollback
Infer#dumpGraphsIfNeeded(DiagnosticPosition, Symbol, Resolve.MethodResolutionContext)::: infer dump graphs if needed:::round->try->foreach->pendingGraphs->reverse->Assert->checkNonNull->name->filename->String->pos->getStartPosition->rsContext->attrMode->format->dotFile->Paths->get->try->w->Files->newBufferedWriter->w->append->catch->finally->catch->Assert->ex->getMessage->error->finally->List->nil
Infer#generateReturnConstraints(JCTree, Attr.ResultInfo, MethodType, InferenceContext):::Generate constraints from the generic method's return type:::rsInfoInfContext->inferenceContext->from->mt->getReturnType->if->mt->getReturnType->containsAny->types->capture->foreach->from->getTypeArguments->if->t->hasTag->isCaptured->inferenceContext->addVar->qtype->inferenceContext->asUndetVar->to->if->qtype->hasTag->else->if->to->hasTag->from->isPrimitive->else->if->qtype->hasTag->if->needsEagerInstantiation->to->isPrimitive->generateReferenceToTargetConstraint->else->if->rsInfoInfContext->free->inferenceContext->rsInfoInfContext->updateTreeType->cachedCapture->asUndetVar->Assert->rsInfoInfContext->free->check->retWarn->new->Warner->if->rsInfoInfContext->asUndetVar->compatible->retWarn->hasLint->throw->diags->Fragments->inferenceContext->restvars->mt->getReturnType->InferNoConformingInstanceExists->fragment->error->return
Infer#needsEagerInstantiation(UndetVar, Type, InferenceContext)::: infer needs eager instantiation:::if->to->isPrimitive->foreach->from->InferenceBound->values->getBounds->boundAsPrimitive->types->unboxedType->if->boundAsPrimitive->hasTag->continue->return->return->captureOfTo->types->capture->if->foreach->from->getBounds->captureOfBound->types->capture->if->return->foreach->from->getBounds->foreach->from->getBounds->if->inferenceContext->free->inferenceContext->free->commonSuperWithDiffParameterization->return->if->to->isParameterized->foreach->from->getBounds->sup->types->asSuper->if->sup->isRaw->return->return
Infer#commonSuperWithDiffParameterization(Type, Type)::: infer common super with diff parameterization:::foreach->getParameterizedSupers->if->types->isSameType->return->return
Infer#generateReferenceToTargetConstraint(JCTree, UndetVar, Type, Attr.ResultInfo, InferenceContext)::: infer generate reference to target constraint:::inferenceContext->List->of->new->Warner->solve->inferenceContext->notifyChange->capturedType->inferenceContext->from->getInst->updateTreeType->cachedCapture->if->types->inferenceContext->asUndetVar->isConvertible->return->return
Infer#instantiateAsUninferredVars(List, InferenceContext):::Infer cyclic inference variables as described in 15.12.2.8.:::todo->new->ListBuffer<>->foreach->uv->inferenceContext->asUndetVar->upperBounds->uv->getBounds->if->Type->containsAny->fresh_tvar->new->TypeVariableSymbol->types->uv->getBounds->makeIntersectionType->new->TypeVar->todo->append->uv->setInst->else->if->upperBounds->nonEmpty->uv->types->glb->setInst->else->uv->setInst->formals->foreach->uv->ct->uv->getInst->types->inferenceContext->types->getBounds->asInstTypes->glb->if->isErroneous->reportBoundError
Infer#instantiatePolymorphicSignatureInstance(Env, MethodSymbol, Resolve.MethodResolutionContext, List):::Compute a synthetic method type corresponding to the requested polymorphic method signature:::restype->if->types->spMethod->getReturnType->isSameType->switch->getTag->castTree->TreeInfo->skipParens->break->execTree->TreeInfo->skipParens->break->else->spMethod->getReturnType->paramtypes->argtypes->new->ImplicitArgType->map->exType->spMethod->getThrownTypes->List->of->mtype->new->MethodType->return
Infer.ImplicitArgType#visitClassType(ClassType, Void)::: implicit arg type visit class type:::return->types->erasure
Infer.ImplicitArgType#visitType(Type, Void)::: implicit arg type visit type:::if->t->hasTag->return->super->visitType->visit->else->if->t->hasTag->types->boxedClass->return
Infer#instantiateFunctionalInterface(DiagnosticPosition, Type, List, Check.CheckContext):::This method is used to infer a suitable target SAM in case the original SAM type contains one or more wildcards:::if->types->capture->return->else->formalInterface->funcInterfaceContext->getTypeArguments->new->InferenceContext->Assert->check->descParameterTypes->types->findDescriptorType->getParameterTypes->if->descParameterTypes->size->paramTypes->size->checkContext->diags->fragment->report->return->types->createErrorType->foreach->if->types->funcInterfaceContext->asUndetVar->isSameType->checkContext->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->report->return->types->createErrorType->actualTypeargs->funcInterface->getTypeArguments->foreach->uv->inst->uv->getBounds->stream->b->formalInterface->getTypeArguments->containsAny->filter->findFirst->uv->inst->orElse->setInst->owntype->funcInterfaceContext->asInstType->if->chk->checkValidGenericType->checkContext->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->report->checkContext->compatible->return
Infer.IncorporationAction#dup(UndetVar)::: incorporation action dup:::
Infer.IncorporationAction#apply(InferenceContext, Warner):::Incorporation action entry-point:::
Infer.IncorporationAction#isSubtype(Type, Type, Warner):::Helper function: perform subtyping through incorporation cache.:::return->doIncorporationOp
Infer.IncorporationAction#isSameType(Type, Type):::Helper function: perform type-equivalence through incorporation cache.:::return->doIncorporationOp
Infer.IncorporationAction#toString()::: incorporation action to string:::return->String->getClass->getSimpleName->format
Infer.CheckBounds#dup(UndetVar)::: check bounds dup:::return->new->CheckBounds
Infer.CheckBounds#apply(InferenceContext, Warner)::: check bounds apply:::typeFunc->apply->if->optFilter->test->return->foreach->boundsToCheck->foreach->uv->getBounds->typeFunc->apply->if->optFilter->test->continue->success->checkBound->if->report
Infer.CheckBounds#boundsToCheck():::The list of bound kinds to be checked.:::return->EnumSet->allOf->EnumSet->EnumSet->of->complementOf
Infer.CheckBounds#checkBound(Type, Type, InferenceBound, InferenceBound, Warner):::Is source type 's' compatible with target type 't' given source and target bound kinds?:::if->ib_s->lessThan->return->isSubtype->else->if->ib_t->lessThan->return->isSubtype->else->return->isSameType
Infer.CheckBounds#report(InferenceBound, InferenceBound):::Report a bound check error.:::if->reportBoundError->else->if->reportBoundError->else->reportBoundError
Infer.CheckBounds#toString()::: check bounds to string:::return->String->getClass->getSimpleName->format
Infer.EqCheckLegacy#dup(UndetVar)::: eq check legacy dup:::return->new->EqCheckLegacy
Infer.EqCheckLegacy#boundsToCheck()::: eq check legacy bounds to check:::return->EnumSet->allOf->EnumSet->of
Infer.CheckInst#dup(UndetVar)::: check inst dup:::return->new->CheckInst
Infer.CheckInst#boundsToCheck()::: check inst bounds to check:::return
Infer.CheckInst#report(InferenceBound, InferenceBound)::: check inst report:::reportInstError
Infer.SubstBounds#dup(UndetVar)::: subst bounds dup:::return->new->SubstBounds
Infer.SubstBounds#apply(InferenceContext, Warner)::: subst bounds apply:::foreach->uv2->uv2->List->of->List->uv->getInst->of->substBounds->checkCompatibleUpperBounds->super->apply
Infer.SubstBounds#checkCompatibleUpperBounds(UndetVar, InferenceContext):::Make sure that the upper bounds we got so far lead to a solvable inference variable by making sure that a glb exists.:::hibounds->Type->uv->getBounds->new->BoundFilter->filter->hb->if->hibounds->isEmpty->else->if->isEmpty->else->types->glb->if->hb->isErroneous->reportBoundError
Infer.CheckUpperBounds#dup(UndetVar)::: check upper bounds dup:::return->new->CheckUpperBounds
Infer.CheckUpperBounds#apply(InferenceContext, Warner)::: check upper bounds apply:::boundList->uv->getBounds->stream->types->types->isSameType->closureCollector->collect->foreach->if->continue->if->t->hasTag->b2->hasTag->foreach->getParameterizedSupers->allParamsSuperBound1->allparams->allParamsSuperBound2->allparams->while->allParamsSuperBound1->nonEmpty->allParamsSuperBound2->nonEmpty->if->hasTag->hasTag->if->inferenceContext->asUndetVar->inferenceContext->asUndetVar->isSameType->reportBoundError->Assert->allParamsSuperBound1->isEmpty->allParamsSuperBound2->isEmpty->check
Infer.PropagateBounds#dup(UndetVar)::: propagate bounds dup:::return->new->PropagateBounds
Infer.PropagateBounds#apply(InferenceContext, Warner)::: propagate bounds apply:::undetT->inferenceContext->asUndetVar->if->undetT->hasTag->isCaptured->uv2->uv2->ib->complement->addBound->foreach->backwards->foreach->uv2->getBounds->uv->addBound->foreach->forward->foreach->uv->getBounds->undet->inferenceContext->asUndetVar->if->undet->hasTag->isCaptured->uv2->uv2->inferenceContext->asInstType->addBound
Infer.PropagateBounds#forward()::: propagate bounds forward:::return->EnumSet->of->EnumSet->EnumSet->of->complementOf
Infer.PropagateBounds#backwards()::: propagate bounds backwards:::return->EnumSet->allOf->EnumSet->of
Infer.PropagateBounds#toString()::: propagate bounds to string:::return->String->getClass->getSimpleName->format
Infer.AbstractIncorporationEngine#varInstantiated(UndetVar)::: abstract incorporation engine var instantiated:::new->SubstBounds->addFirst
Infer.AbstractIncorporationEngine#varBoundChanged(UndetVar, InferenceBound, Type, boolean)::: abstract incorporation engine var bound changed:::if->uv->isCaptured->return->getIncorporationActions->addAll
Infer.AbstractIncorporationEngine#getIncorporationActions(UndetVar, InferenceBound, Type, boolean)::: abstract incorporation engine get incorporation actions:::
Infer#incorporationEngine():::Get the incorporation engine to be used in this compilation.:::return
Infer#doIncorporation(InferenceContext, Warner):::Check bounds and perform incorporation.:::try->progress->round->while->foreach->uv->if->isEmpty->removeFirst->apply->catch->finally->incorporationCache->clear
Infer#getParameterizedSupers(Type, Type)::: infer get parameterized supers:::lubResult->types->lub->if->return->List->nil->supertypesToCheck->lubResult->isIntersection->getComponents->List->of->commonSupertypes->new->ListBuffer<>->foreach->if->sup->isParameterized->asSuperOfT->asSuper->asSuperOfS->asSuper->commonSupertypes->new->Pair<>->add->return->commonSupertypes->toList
Infer#asSuper(Type, Type)::: infer as super:::return->sup->hasTag->types->elemtype->types->elemtype->asSuper->new->ArrayType->types->asSuper
Infer#doIncorporationOp(IncorporationBinaryOpKind, Type, Type, Warner)::: infer do incorporation op:::newOp->new->IncorporationBinaryOp->res->incorporationCache->get->if->incorporationCache->newOp->apply->put->return
Infer.IncorporationBinaryOp#equals(Object)::: incorporation binary op equals:::if->return->else->that->return->types->isSameType->types->isSameType
Infer.IncorporationBinaryOp#hashCode()::: incorporation binary op hash code:::result->opKind->hashCode->types->hashCode->types->hashCode->return
Infer.IncorporationBinaryOp#apply(Warner)::: incorporation binary op apply:::return->opKind->apply
Infer.BoundFilter#accepts(Type)::: bound filter accepts:::return->t->isErroneous->inferenceContext->free->t->hasTag
Infer#reportInstError(UndetVar, InferenceBound):::Incorporation error: mismatch between inferred type and given bound.:::switch->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToEqBounds->fragment->error->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToLowerBounds->fragment->error->throw->diags->Fragments->uv->getInst->uv->getBounds->InferredDoNotConformToUpperBounds->fragment->error
Infer#reportBoundError(UndetVar, InferenceBound):::Incorporation error: mismatch between two (or more) bounds of same kind.:::switch->throw->diags->Fragments->uv->getBounds->IncompatibleEqBounds->fragment->error->throw->diags->Fragments->uv->getBounds->IncompatibleUpperBounds->fragment->error->throw->new->AssertionError
Infer#reportBoundError(UndetVar, InferenceBound, InferenceBound):::Incorporation error: mismatch between two (or more) bounds of different kinds.:::throw->diags->Fragments->uv->getBounds->getBoundFragment->uv->getBounds->getBoundFragment->IncompatibleBounds->fragment->error
Infer#getBoundFragment(InferenceBound, List)::: infer get bound fragment:::switch->return->Fragments->EqBounds->return->Fragments->LowerBounds->return->Fragments->UpperBounds->throw->new->AssertionError
Infer.GraphStrategy#pickNode(InferenceGraph):::Pick the next node (leaf) to solve in the graph:::
Infer.GraphStrategy#done():::Is this the last step?:::
Infer.LeafSolver#pickNode(InferenceGraph)::: leaf solver pick node:::if->isEmpty->throw->new->NodeNotFoundException->return->get
Infer.BestLeafSolver#computeTreeToLeafs(Node):::Computes a path that goes from a given node to the leafs in the graph:::cachedPath->treeCache->get->if->if->n->isLeaf->List->of->length->new->Pair<>->else->path->List->of->length->new->Pair<>->foreach->n->getAllDependencies->if->continue->subpath->computeTreeToLeafs->prependList->new->Pair<>->treeCache->put->return
Infer.BestLeafSolver#pickNode(InferenceGraph):::Pick the leaf that minimize cost:::treeCache->clear->bestPath->foreach->if->Collections->disjoint->path->computeTreeToLeafs->if->if->throw->new->NodeNotFoundException->return
Infer.GraphSolver#solve(GraphStrategy):::Solve variables in a given inference context:::doIncorporation->inferenceGraph->new->InferenceGraph->while->sstrategy->done->if->pendingGraphs->inferenceGraph->toDot->prepend->nodeToSolve->sstrategy->pickNode->varsToSolve->List->from->saved_undet->inferenceContext->save->try->while->Type->inferenceContext->restvars->containsAny->foreach->GraphInferenceSteps->values->if->inferenceContext->solveBasic->nonEmpty->doIncorporation->continue->throw->error->catch->inferenceContext->rollback->instantiateAsUninferredVars->doIncorporation->finally->inferenceGraph->deleteNode
Infer.GraphSolver.InferenceGraph.Node#getSupportedDependencyKinds()::: node get supported dependency kinds:::return->new->GraphUtils.DependencyKindArr
Infer.GraphSolver.InferenceGraph.Node#getAllDependencies()::: node get all dependencies:::return
Infer.GraphSolver.InferenceGraph.Node#getDependenciesByKind(GraphUtils.DependencyKind)::: node get dependencies by kind:::if->return->else->throw->new->IllegalStateException
Infer.GraphSolver.InferenceGraph.Node#addDependency(Node):::Adds dependency with given kind.:::deps->add
Infer.GraphSolver.InferenceGraph.Node#addDependencies(Set):::Add multiple dependencies of same given kind.:::foreach->addDependency
Infer.GraphSolver.InferenceGraph.Node#removeDependency(Node):::Remove a dependency, regardless of its kind.:::return->deps->remove
Infer.GraphSolver.InferenceGraph.Node#closure():::Compute closure of a give node, by recursively walking through all its dependencies.:::closure->new->HashSet<>->closureInternal->return
Infer.GraphSolver.InferenceGraph.Node#closureInternal(Set)::: node closure internal:::if->closure->add->foreach->n->closureInternal
Infer.GraphSolver.InferenceGraph.Node#isLeaf():::Is this node a leaf? This means either the node has no dependencies, or it just has self-dependencies.:::if->deps->isEmpty->return->foreach->if->return->return
Infer.GraphSolver.InferenceGraph.Node#mergeWith(List):::Merge this node with another node, acquiring its dependencies:::foreach->Assert->length->check->data->appendList->addDependencies->deps2->new->LinkedHashSet<>->foreach->if->data->first->contains->deps2->add->else->deps2->add
Infer.GraphSolver.InferenceGraph.Node#graphChanged(Node, Node):::Notify all nodes that something has changed in the graph topology.:::if->removeDependency->if->addDependency
Infer.GraphSolver.InferenceGraph.Node#nodeAttributes()::: node node attributes:::p->new->Properties->p->toString->put->return
Infer.GraphSolver.InferenceGraph.Node#dependencyAttributes(Node, GraphUtils.DependencyKind)::: node dependency attributes:::p->new->Properties->p->put->buf->new->StringBuilder->sep->foreach->uv->inferenceContext->asUndetVar->foreach->uv->InferenceBound->values->getBounds->if->bound->List->from->containsAny->buf->append->buf->append->p->buf->toString->put->return
Infer.GraphSolver.InferenceGraph#findNode(Type):::Basic lookup helper for retrieving a graph node given an inference variable type.:::foreach->if->contains->return->return
Infer.GraphSolver.InferenceGraph#deleteNode(Node):::Delete a node from the graph:::Assert->nodes->contains->check->nodes->remove->notifyUpdate
Infer.GraphSolver.InferenceGraph#notifyUpdate(Node, Node):::Notify all nodes of a change in the graph:::foreach->n->graphChanged
Infer.GraphSolver.InferenceGraph#initNodes():::Create the graph nodes:::new->ArrayList<>->foreach->inferenceContext->restvars->nodes->new->Node->add->foreach->i->first->foreach->j->first->if->uv_i->inferenceContext->asUndetVar->if->Type->uv_i->InferenceBound->values->getBounds->List->of->containsAny->n_i->addDependency->acyclicNodes->new->ArrayList<>->foreach->GraphUtils->tarjan->if->conSubGraph->length->root->root->mergeWith->foreach->notifyUpdate->acyclicNodes->add
Infer.GraphSolver.InferenceGraph#toDot():::Debugging: dot representation of this graph:::buf->new->StringBuilder->foreach->uv->buf->String->uv->getBounds->uv->getBounds->uv->getBounds->format->append->return->GraphUtils->hashCode->buf->toString->toDot
Infer.FreeTypeListener#typesInferred(InferenceContext)::: free type listener types inferred:::
InferenceContext#update(Type)::: inference context update:::return
InferenceContext#addVar(TypeVar):::add a new inference var to this inference context:::apply->prepend->prepend
InferenceContext#inferenceVars():::returns the list of free variables (as type-variables) in this inference context:::return
InferenceContext#undetVars():::returns the list of undetermined variables in this inference context:::return
InferenceContext#restvars():::returns the list of uninstantiated variables (as type-variables) in this inference context:::return->uv->getInst->filterVars
InferenceContext#instvars():::returns the list of instantiated variables (as type-variables) in this inference context:::return->uv->getInst->filterVars
InferenceContext#boundedVars():::Get list of bounded inference variables (where bound is other than declared bounds).:::return->uv->getBounds->uv->getDeclaredBounds->diff->uv->getBounds->appendList->nonEmpty->filterVars
InferenceContext#filterVars(Filter)::: inference context filter vars:::res->new->ListBuffer<>->foreach->uv->if->fu->accepts->res->append->return->res->toList
InferenceContext#free(Type):::is this type free?:::return->t->containsAny
InferenceContext#free(List)::: inference context free:::foreach->if->free->return->return
InferenceContext#freeVarsIn(Type):::Returns a list of free variables in a given type:::buf->new->ListBuffer<>->foreach->inferenceVars->if->t->contains->buf->add->return->buf->toList
InferenceContext#freeVarsIn(List)::: inference context free vars in:::buf->new->ListBuffer<>->foreach->buf->freeVarsIn->appendList->buf2->new->ListBuffer<>->foreach->if->buf2->contains->buf2->add->return->buf2->toList
InferenceContext#asUndetVar(Type):::Replace all free variables in a given type with corresponding undet vars (used ahead of subtyping/compatibility checks to allow propagation of inference constraints).:::return->types->subst
InferenceContext#asUndetVars(List)::: inference context as undet vars:::buf->new->ListBuffer<>->foreach->buf->asUndetVar->append->return->buf->toList
InferenceContext#instTypes()::: inference context inst types:::buf->new->ListBuffer<>->foreach->uv->buf->uv->getInst->uv->getInst->append->return->buf->toList
InferenceContext#asInstType(Type):::Replace all free variables in a given type with corresponding instantiated types - if one or more free variable has not been fully instantiated, it will still be available in the resulting type.:::return->types->instTypes->subst
InferenceContext#asInstTypes(List)::: inference context as inst types:::buf->new->ListBuffer<>->foreach->buf->asInstType->append->return->buf->toList
InferenceContext#addFreeTypeListener(List, FreeTypeListener):::Add custom hook for performing post-inference action:::freeTypeListeners->freeVarsIn->put
InferenceContext#notifyChange():::Mark the inference context as complete and trigger evaluation of all deferred checks.:::inferencevars->restvars->diff->notifyChange
InferenceContext#notifyChange(List)::: inference context notify change:::thrownEx->foreach->new->LinkedHashMap<>->entrySet->if->Type->entry->getValue->inferencevars->diff->containsAny->try->entry->getKey->typesInferred->freeTypeListeners->entry->getKey->remove->catch->if->finally->if->throw
InferenceContext#save():::Save the state of this inference context:::buf->new->ListBuffer<>->foreach->buf->dup->add->return->buf->toList
InferenceContext#rollback(List):::Restore the state of this inference context to the previous known checkpoint:::Assert->check->newUndetVars->new->ListBuffer<>->newInferenceVars->new->ListBuffer<>->while->saved_undet->nonEmpty->undetvars->nonEmpty->uv->uv_saved->if->uv_saved->dupTo->newUndetVars->add->newInferenceVars->add->else->newUndetVars->toList->newInferenceVars->toList
InferenceContext#dupTo(InferenceContext):::Copy variable in this inference context to the given context:::dupTo
InferenceContext#dupTo(InferenceContext, boolean)::: inference context dup to:::inferencevars->diff->appendList->undetsToPropagate->save->undetsToPropagate->diff->appendList->foreach->InferenceContext.this->notifyChange->List->of->put
InferenceContext#min(List, boolean, Warner)::: inference context min:::if->roots->length->inferencevars->length->return->rv->new->ReachabilityVisitor->rv->scan->if->size->inferencevars->length->return->minVars->List->from->redundantVars->inferencevars->diff->minUndetVars->new->ListBuffer<>->foreach->uv->asUndetVar->Assert->isEmpty->check->uv2->uv->dup->foreach->InferenceBound->values->newBounds->uv->getBounds->stream->redundantVars->contains->filter->List->collector->collect->uv2->setBounds->minUndetVars->add->minContext->minUndetVars->toList->new->InferenceContext->foreach->minContext->List->of->asUndetVar->inferenceContext->asInstType->setInst->infer->doIncorporation->List->get->from->solve->notifyChange->addFreeTypeListener->if->unreachableVars->redundantVars->List->from->diff->minContext->solve->notifyChange->addFreeTypeListener->return
InferenceContext.ReachabilityVisitor#scan(List)::: reachability visitor scan:::roots->stream->this->visit->forEach
InferenceContext.ReachabilityVisitor#visitType(Type, Void)::: reachability visitor visit type:::return
InferenceContext.ReachabilityVisitor#visitUndetVar(UndetVar, Void)::: reachability visitor visit undet var:::if->min->add->deps->minMap->Collections->singleton->new->HashSet<>->getOrDefault->foreach->InferenceBound->values->foreach->t->getBounds->undet->asUndetVar->if->undet->hasTag->visit->else->if->isEquiv->deps->add->equiv->add->else->visit->minMap->put->return
InferenceContext.ReachabilityVisitor#visitWildcardType(WildcardType, Void)::: reachability visitor visit wildcard type:::return->visit
InferenceContext.ReachabilityVisitor#visitTypeVar(TypeVar, Void)::: reachability visitor visit type var:::undet->asUndetVar->if->undet->hasTag->visitUndetVar->return
InferenceContext.ReachabilityVisitor#visitArrayType(ArrayType, Void)::: reachability visitor visit array type:::return->visit
InferenceContext.ReachabilityVisitor#visitClassType(ClassType, Void)::: reachability visitor visit class type:::t->getEnclosingType->visit->foreach->t->getTypeArguments->visit->return
InferenceContext.ReachabilityVisitor#isEquiv(UndetVar, Type, InferenceBound)::: reachability visitor is equiv:::uv->asUndetVar->foreach->InferenceBound->values->b1->from->getBounds->if->b1->List->of->diff->b2->uv->getBounds->if->boundKind->complement->b2->List->of->diff->if->b1->containsAll->b2->containsAll->return->return
InferenceContext#solve(GraphStrategy, Warner):::Solve with given graph strategy.:::s->infer->new->GraphSolver->s->solve
InferenceContext#solve(Warner):::Solve all variables in this context.:::infer->new->LeafSolver->solve
InferenceContext#solve(List, Warner):::Solve all variables in the given list.:::infer->new->BestLeafSolver->solve
InferenceContext#solveAny(List, Warner):::Solve at least one variable in given list.:::infer->varsToSolve->restvars->intersect->new->BestLeafSolver->solve
InferenceContext#solveBasic(EnumSet):::Apply a set of inference steps:::return->solveBasic
InferenceContext#solveBasic(List, EnumSet)::: inference context solve basic:::solvedVars->new->ListBuffer<>->foreach->varsToSolve->restvars->intersect->uv->asUndetVar->foreach->if->step->accepts->uv->step->solve->setInst->solvedVars->add->break->return->solvedVars->toList
InferenceContext#solveLegacy(boolean, Warner, EnumSet):::Instantiate inference variables in legacy mode (JLS 15.12.2.7, 15.12.2.8):::while->solvedVars->solveBasic->if->restvars->isEmpty->break->else->if->solvedVars->isEmpty->infer->restvars->instantiateAsUninferredVars->break->else->foreach->uv->uv->asInstTypes->substBounds->infer->doIncorporation
InferenceContext#toString()::: inference context to string:::return
InferenceContext#cachedCapture(JCTree, Type, boolean)::: inference context cached capture:::captured->captureTypeCache->get->if->return->result->types->capture->if->captureTypeCache->put->return
LambdaToMethod#instance(Context)::: lambda to method instance:::instance->context->get->if->new->LambdaToMethod->return
LambdaToMethod.DedupedLambda#hashCode()::: deduped lambda hash code:::hashCode->if->TreeHasher->symbol->params->hash->return
LambdaToMethod.DedupedLambda#equals(Object)::: deduped lambda equals:::if->return->that->return->types->symbol->asType->asType->isSameType->symbol->params->params->new->TreeDiffer->scan
LambdaToMethod.KlassInfo#addMethod(JCTree)::: klass info add method:::appendedMethodList->prepend
LambdaToMethod#translate(T)::: lambda to method translate:::newContext->contextMap->get->return->translate
LambdaToMethod#translate(T, TranslationContext)::: lambda to method translate:::prevContext->try->return->super->translate->catch->finally
LambdaToMethod#translate(List, TranslationContext)::: lambda to method translate:::buf->new->ListBuffer<>->foreach->buf->translate->append->return->buf->toList
LambdaToMethod#translateTopLevelClass(Env, JCTree, TreeMaker)::: lambda to method translate top level class:::new->HashMap<>->return->translate
LambdaToMethod#visitClassDef(JCClassDecl):::Visit a class:::if->analyzer->analyzeAndPreprocessClass->prevKlassInfo->try->new->KlassInfo->super->visitClassDef->if->isEmpty->prevPos->try->make->at->kInfo->makeDeserializeMethod->addMethod->catch->finally->make->at->newMethods->toList->appendList->foreach->members->enter->catch->finally
LambdaToMethod#visitLambda(JCLambda):::Translate a lambda into a method to be inserted into the class:::localContext->sym->lambdaType->owner->owner->getRawTypeAttributes->owner->setTypeAttributes->sym->setTypeAttributes->apportionTypeAnnotations->init->if->owner->getInitTypeAttributes->owner->getClassInitTypeAttributes->owner->setInitTypeAttributes->owner->setClassInitTypeAttributes->sym->appendUniqueTypeAttributes->apportionTypeAnnotations->if->getKind->owner->getRawTypeAttributes->owner->setTypeAttributes->sym->appendUniqueTypeAttributes->apportionTypeAnnotations->lambdaDecl->make->make->Modifiers->make->lambdaType->getReturnType->QualIdent->List->nil->lambdaType->getThrownTypes->List->nil->make->lambdaType->getThrownTypes->Types->MethodDef->makeLambdaBody->translate->dedupe->if->localContext->isSerializable->dedupedLambda->new->DedupedLambda->existing->putIfAbsent->if->if->log->Notes->VerboseL2mDeduplicate->note->if->kInfo->addMethod->syntheticInits->new->ListBuffer<>->if->syntheticInits->append->else->if->sym->isStatic->syntheticInits->enclClass->asType->enclClass->makeThis->append->foreach->localContext->getSymbolMap->keySet->if->captured_local->make->Ident->setType->syntheticInits->append->foreach->localContext->getSymbolMap->keySet->captured_local->make->QualThis->syntheticInits->append->indy_args->syntheticInits->toList->translate->refKind->referenceKind->makeMetafactoryIndyCall
LambdaToMethod#apportionTypeAnnotations(JCLambda, Supplier>, Consumer>, Consumer>)::: lambda to method apportion type annotations:::ownerTypeAnnos->new->ListBuffer<>->lambdaTypeAnnos->new->ListBuffer<>->foreach->source->get->if->lambdaTypeAnnos->append->else->ownerTypeAnnos->append->if->lambdaTypeAnnos->nonEmpty->owner->ownerTypeAnnos->toList->accept->lambda->lambdaTypeAnnos->toList->accept
LambdaToMethod#makeThis(Type, Symbol)::: lambda to method make this:::_this->new->VarSymbol->return->make->Ident
LambdaToMethod#visitReference(JCMemberReference):::Translate a method reference into an invokedynamic call to the meta-factory.:::localContext->refSym->init->switch->enclClass->asType->enclClass->makeThis->break->tree->getQualifierExpression->attr->makeNullCheck->break->break->throw->new->InternalError->indy_args->List->nil->List->of->translate->localContext->referenceKind->makeMetafactoryIndyCall
LambdaToMethod#visitIdent(JCIdent):::Translate identifiers within a lambda to the mapped identifier:::if->analyzer->lambdaIdentSymbolFilter->super->visitIdent->else->prevPos->try->make->at->lambdaContext->ltree->lambdaContext->translate->if->else->super->visitIdent->catch->finally->make->at
LambdaToMethod#visitSelect(JCFieldAccess):::Translate qualified `this' references within a lambda to the mapped identifier:::if->analyzer->lambdaFieldAccessFilter->super->visitSelect->else->prevPos->try->make->at->lambdaContext->ltree->lambdaContext->translate->if->else->super->visitSelect->catch->finally->make->at
LambdaToMethod#visitNewClass(JCNewClass):::Translate instance creation expressions with implicit enclosing instances:::if->analyzer->lambdaNewClassFilter->super->visitNewClass->else->prevPos->try->make->at->lambdaContext->lambdaContext->translate->super->visitNewClass->catch->finally->make->at
LambdaToMethod#visitVarDef(JCVariableDecl)::: lambda to method visit var def:::lambdaContext->if->lambdaContext->getSymbolMap->containsKey->translate->lambdaContext->getSymbolMap->get->else->if->lambdaContext->getSymbolMap->containsKey->init->translate->xsym->lambdaContext->getSymbolMap->get->prevPos->try->make->at->VarDef->catch->finally->make->at->sc->members->if->sc->remove->sc->enter->else->super->visitVarDef
LambdaToMethod#makeLambdaBody(JCLambda, JCMethodDecl)::: lambda to method make lambda body:::return->tree->getBodyKind->makeLambdaExpressionBody->makeLambdaStatementBody
LambdaToMethod#makeLambdaExpressionBody(JCExpression, JCMethodDecl)::: lambda to method make lambda expression body:::restype->getReturnType->isLambda_void->hasTag->isTarget_void->restype->hasTag->isTarget_Void->types->types->boxedClass->isSameType->prevPos->try->if->stat->make->at->Exec->return->make->List->of->Block->else->if->stats->new->ListBuffer<>->stats->make->at->Exec->append->stats->make->make->Literal->setType->Return->append->return->make->stats->toList->Block->else->return->make->at->List->make->Return->of->Block->catch->finally->make->at
LambdaToMethod#makeLambdaStatementBody(JCBlock, JCMethodDecl, boolean)::: lambda to method make lambda statement body:::restype->getReturnType->isTarget_void->restype->hasTag->isTarget_Void->types->types->boxedClass->isSameType->trans_block->new->LambdaBodyTranslator->translate->if->make->make->Literal->setType->Return->append->return
LambdaToMethod#makeDeserializeMethod(Symbol)::: lambda to method make deserialize method:::cases->new->ListBuffer<>->breaks->new->ListBuffer<>->foreach->entrySet->br->make->Break->breaks->add->stmts->entry->getValue->append->toList->cases->make->make->entry->getKey->Literal->Case->add->sw->make->deserGetter->cases->toList->Switch->foreach->body->make->List->make->List->make->Literal->of->makeNewClass->Throw->of->Block->deser->make->make->flags->Modifiers->make->getReturnType->QualIdent->List->nil->List->make->VarDef->of->List->nil->MethodDef->return
LambdaToMethod#makeNewClass(Type, List, Symbol):::Make an attributed class instance creation expression.:::tree->make->make->QualIdent->NewClass->return
LambdaToMethod#makeNewClass(Type, List):::Make an attributed class instance creation expression.:::return->rs->TreeInfo->types->List->nil->resolveConstructor->makeNewClass
LambdaToMethod#addDeserializationCase(int, Symbol, Type, MethodSymbol, DiagnosticPosition, List, MethodType)::: lambda to method add deserialization case:::functionalInterfaceClass->classSig->functionalInterfaceMethodName->samSym->getSimpleName->toString->functionalInterfaceMethodSignature->types->erasure->typeSig->implClass->types->erasure->classSig->implMethodName->refSym->getQualifiedName->toString->implMethodSignature->types->erasure->typeSig->kindTest->deserGetter->make->Literal->eqTest->serArgs->new->ListBuffer<>->i->foreach->indyType->getParameterTypes->indexAsArg->new->ListBuffer<JCExpression>->make->Literal->append->toList->argTypes->new->ListBuffer<Type>->append->toList->serArgs->make->types->erasure->deserGetter->TypeCast->add->stmt->make->deserTest->deserTest->deserTest->deserTest->deserTest->make->serArgs->toList->makeIndyCall->Return->If->stmts->get->if->new->ListBuffer<>->put->stmts->append
LambdaToMethod#eqTest(Type, JCExpression, JCExpression)::: lambda to method eq test:::testExpr->make->Binary->operators->resolveBinary->testExpr->setType->return
LambdaToMethod#deserTest(JCExpression, String, String)::: lambda to method deser test:::eqmt->List->of->List->nil->new->MethodType->eqsym->rs->List->of->List->nil->resolveQualifiedMethod->eqtest->make->List->nil->make->deserGetter->Select->setType->List->make->Literal->of->Apply->eqtest->setType->compound->make->Binary->operators->resolveBinary->compound->setType->return
LambdaToMethod#deserGetter(String, Type)::: lambda to method deser getter:::return->List->nil->List->nil->deserGetter
LambdaToMethod#deserGetter(String, Type, List, List)::: lambda to method deser getter:::getmt->List->nil->new->MethodType->getsym->rs->names->fromString->List->nil->resolveQualifiedMethod->return->make->List->nil->make->make->Ident->setType->Select->setType->Apply->setType
LambdaToMethod#makePrivateSyntheticMethod(long, Name, Type, Symbol):::Create new synthetic method with given flags, name, type, owner:::return->new->MethodSymbol
LambdaToMethod#makeSyntheticVar(long, Name, Type, Symbol):::Create new synthetic variable with given flags, name, type, owner:::return->new->VarSymbol
LambdaToMethod#setVarargsIfNeeded(JCTree, Type):::Set varargsElement field on a given tree (must be either a new class tree or a method call tree):::if->switch->tree->getTag->break->break->setVarargsIfNeeded->break->throw->new->AssertionError
LambdaToMethod#convertArgs(Symbol, List, Type):::Convert method/constructor arguments by inserting appropriate cast as required by type-erasure - this is needed when bridging a lambda/method reference, as the bridged signature might require downcast to be compatible with the generated signature.:::Assert->check->formals->types->erasure->getParameterTypes->if->Assert->meth->flags->check->return->transTypes->translateArgs
LambdaToMethod.MemberReferenceToLambda#lambda()::: member reference to lambda lambda:::prevPos->try->make->at->rcvr->addParametersReturnReceiver->expr->tree->getMode->expressionInvoke->expressionNew->slam->make->params->toList->Lambda->return->catch->finally->make->at
LambdaToMethod.MemberReferenceToLambda#addParametersReturnReceiver():::Generate the parameter list for the converted member reference.:::samDesc->localContext->bridgedRefSig->samPTypes->samDesc->getParameterTypes->descPTypes->tree->getDescriptorType->getParameterTypes->rcvr->switch->tree->getQualifierExpression->addParameter->attr->tree->getQualifierExpression->makeNullCheck->break->samDesc->getParameterTypes->addParameter->break->break->implPTypes->getParameterTypes->implSize->implPTypes->size->samSize->samPTypes->size->last->localContext->needsVarArgsConversion->checkForIntersection->descPTypes->size->for->i->implPTypes->nonEmpty->for->i->return
LambdaToMethod.MemberReferenceToLambda#getReceiverExpression()::: member reference to lambda get receiver expression:::return
LambdaToMethod.MemberReferenceToLambda#makeReceiver(VarSymbol)::: member reference to lambda make receiver:::if->return->rcvrExpr->make->Ident->rcvrType->enclClass->if->tree->getQualifierExpression->if->isSubClass->make->make->Type->TypeCast->setType->return
LambdaToMethod.MemberReferenceToLambda#expressionInvoke(VarSymbol):::determine the receiver of the method call - the receiver can be a type qualifier, the synthetic receiver parameter or 'super'.:::qualifier->makeReceiver->tree->getQualifierExpression->select->make->Select->erasure->apply->make->List->nil->args->toList->convertArgs->Apply->erasure->getReturnType->setType->transTypes->types->getReturnType->erasure->coerce->setVarargsIfNeeded->return
LambdaToMethod.MemberReferenceToLambda#expressionNew():::Lambda body to use for a 'new'.:::if->newArr->make->make->types->tree->getQualifierExpression->elemtype->Type->List->make->params->first->Ident->of->NewArray->tree->getQualifierExpression->return->else->newClass->make->List->nil->make->tree->getQualifierExpression->Type->args->toList->convertArgs->NewClass->erasure->tree->getQualifierExpression->setVarargsIfNeeded->return
LambdaToMethod.MemberReferenceToLambda#addParameter(String, Type, boolean)::: member reference to lambda add parameter:::vsym->names->fromString->new->VarSymbol->params->make->VarDef->append->if->args->make->Ident->append->return
LambdaToMethod#typeToMethodType(Type)::: lambda to method type to method type:::type->types->erasure->return->type->getParameterTypes->type->getReturnType->type->getThrownTypes->new->MethodType
LambdaToMethod#makeMetafactoryIndyCall(TranslationContext, int, Symbol, List):::Generate an indy method call to the meta factory:::tree->samSym->types->findDescriptorSymbol->staticArgs->List->typeToMethodType->new->Pool.MethodHandle->tree->getDescriptorType->typeToMethodType->of->indy_args_types->new->ListBuffer<>->foreach->indy_args_types->append->indyType->indy_args_types->toList->List->nil->new->MethodType->metafactoryName->context->needsAltMetafactory->if->context->needsAltMetafactory->markers->new->ListBuffer<>->targets->isIntersection->types->directSupertypes->List->nil->foreach->types->erasure->if->markers->append->flags->context->isSerializable->hasMarkers->markers->nonEmpty->hasBridges->nonEmpty->if->if->staticArgs->append->if->staticArgs->markers->length->append->staticArgs->markers->toList->appendList->if->staticArgs->length->append->foreach->s_erasure->s->erasure->if->types->samSym->erasure->isSameType->staticArgs->s->erasure->append->if->context->isSerializable->prevPos->try->make->at->addDeserializationCase->catch->finally->make->at->return->makeIndyCall
LambdaToMethod#makeIndyCall(DiagnosticPosition, Type, Name, List, MethodType, List, Name):::Generate an indy method call with given name, type and static bootstrap arguments types:::prevPos->try->make->at->bsm_staticArgs->List->of->bsmStaticArgToTypes->appendList->bsm->rs->List->nil->resolveInternalMethod->dynSym->bsm->isStatic->staticArgs->toArray->new->DynamicMethodSymbol->qualifier->make->make->QualIdent->Select->existing->new->DynamicMethod->putIfAbsent->indyType->getReturnType->proxyCall->make->List->nil->Apply->indyType->getReturnType->return->catch->finally->make->at
LambdaToMethod#bsmStaticArgToTypes(List)::: lambda to method bsm static arg to types:::argtypes->new->ListBuffer<>->foreach->argtypes->bsmStaticArgToType->append->return->argtypes->toList
LambdaToMethod#bsmStaticArgToType(Object)::: lambda to method bsm static arg to type:::Assert->checkNonNull->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->Assert->arg->getClass->error->return
LambdaToMethod#referenceKind(Symbol):::Get the opcode associated with this method reference:::if->refSym->isConstructor->return->else->if->refSym->isStatic->return->else->if->refSym->flags->return->else->if->refSym->enclClass->isInterface->return->else->return
LambdaToMethod.LambdaAnalyzerPreprocessor.SyntheticMethodNameCounter#getIndex(StringBuilder)::: synthetic method name counter get index:::temp->buf->toString->count->map->get->if->map->put->return
LambdaToMethod.LambdaAnalyzerPreprocessor#analyzeAndPreprocessClass(JCClassDecl)::: lambda analyzer preprocessor analyze and preprocess class:::List->nil->List->nil->new->HashMap<>->return->translate
LambdaToMethod.LambdaAnalyzerPreprocessor#visitApply(JCMethodInvocation)::: lambda analyzer preprocessor visit apply:::previousNascentTypes->try->methName->TreeInfo->name->if->typesUnderConstruction->currentClass->prepend->super->visitApply->catch->finally
LambdaToMethod.LambdaAnalyzerPreprocessor#currentClass()::: lambda analyzer preprocessor current class:::foreach->if->hasTag->cdef->return->return
LambdaToMethod.LambdaAnalyzerPreprocessor#visitBlock(JCBlock)::: lambda analyzer preprocessor visit block:::prevStack->try->if->frameStack->nonEmpty->hasTag->frameStack->new->Frame->prepend->super->visitBlock->catch->finally
LambdaToMethod.LambdaAnalyzerPreprocessor#visitClassDef(JCClassDecl)::: lambda analyzer preprocessor visit class def:::prevStack->prevLambdaCount->prevSyntheticMethodNameCounts->prevClinits->prevSource->log->currentSource->try->log->useSource->new->SyntheticMethodNameCounter->new->HashMap<>->if->localClassDefs->put->if->directlyEnclosingLambda->owner->if->hasOuterInstance->localContext->context->outerInstanceSymbol->getEnclosingType->while->isStatic->if->hasTag->block->capturedDecl->if->break->addSymbol->frameStack->new->Frame->prepend->super->visitClassDef->catch->finally->log->prevSource->getFile->useSource
LambdaToMethod.LambdaAnalyzerPreprocessor#visitIdent(JCIdent)::: lambda analyzer preprocessor visit ident:::if->context->lambdaIdentSymbolFilter->if->constValue->localContext->context->while->if->getTag->block->capturedDecl->if->break->addSymbol->else->if->localContext->context->while->isStatic->if->hasTag->block->capturedDecl->if->break->switch->block->getTag->cdecl->addSymbol->break->Assert->error->super->visitIdent
LambdaToMethod.LambdaAnalyzerPreprocessor#visitLambda(JCLambda)::: lambda analyzer preprocessor visit lambda:::analyzeLambda
LambdaToMethod.LambdaAnalyzerPreprocessor#analyzeLambda(JCLambda, JCExpression)::: lambda analyzer preprocessor analyze lambda:::rcvr->translate->context->analyzeLambda->if
LambdaToMethod.LambdaAnalyzerPreprocessor#analyzeLambda(JCLambda, String)::: lambda analyzer preprocessor analyze lambda:::prevStack->try->context->new->LambdaTranslationContext->frameStack->new->Frame->prepend->foreach->context->addSymbol->addLocal->contextMap->put->super->visitLambda->context->complete->if->log->diags->context->needsAltMetafactory->noteKey->note->return->catch->finally
LambdaToMethod.LambdaAnalyzerPreprocessor#visitMethodDef(JCMethodDecl)::: lambda analyzer preprocessor visit method def:::prevStack->try->frameStack->new->Frame->prepend->super->visitMethodDef->catch->finally
LambdaToMethod.LambdaAnalyzerPreprocessor#visitNewClass(JCNewClass)::: lambda analyzer preprocessor visit new class:::def->inReferencedClass->currentlyInClass->isLocal->def->isLocal->if->context->lambdaNewClassFilter->localContext->context->outerInstanceSymbol->getEnclosingType->while->isStatic->if->hasTag->if->block->capturedDecl->if->break->addSymbol->if->context->lambdaContext->context->captureLocalClassDefs->super->visitNewClass
LambdaToMethod.LambdaAnalyzerPreprocessor#captureLocalClassDefs(Symbol, LambdaTranslationContext)::: lambda analyzer preprocessor capture local class defs:::localCDef->localClassDefs->get->if->add->fvc->lower->new->BasicFreeVarCollector->fvc->scan
LambdaToMethod.LambdaAnalyzerPreprocessor#currentlyInClass(Symbol)::: lambda analyzer preprocessor currently in class:::foreach->if->hasTag->cdef->if->return->return
LambdaToMethod.LambdaAnalyzerPreprocessor#visitReference(JCMemberReference):::Method references to local class constructors, may, if the local class references local variables, have implicit constructor parameters added in Lower; As a result, the invokedynamic bootstrap information added in the LambdaToMethod pass will have the wrong signature:::rcontext->new->ReferenceTranslationContext->contextMap->put->if->rcontext->needsConversionToLambda->conv->owner->new->MemberReferenceToLambda->conv->lambda->conv->getReceiverExpression->analyzeLambda->else->super->visitReference->if->log->Notes->rcontext->needsAltMetafactory->MrefStat->note
LambdaToMethod.LambdaAnalyzerPreprocessor#visitSelect(JCFieldAccess)::: lambda analyzer preprocessor visit select:::if->context->localContext->context->while->isStatic->if->hasTag->clazz->capturedDecl->if->break->addSymbol->super->visitSelect
LambdaToMethod.LambdaAnalyzerPreprocessor#visitVarDef(JCVariableDecl)::: lambda analyzer preprocessor visit var def:::context->context->ltc->if->if->hasTag->ltc->addSymbol->type->asType->if->inClassWithinLambda->types->types->erasure->isSameType->ltc->addSymbol->prevStack->try->if->addLocal->frameStack->new->Frame->prepend->super->visitVarDef->catch->finally
LambdaToMethod.LambdaAnalyzerPreprocessor#owner():::Return a valid owner given the current declaration stack (required to skip synthetic lambda symbols):::return->owner
LambdaToMethod.LambdaAnalyzerPreprocessor#owner(boolean)::: lambda analyzer preprocessor owner:::frameStack2->while->frameStack2->nonEmpty->switch->getTag->if->isLocal->break->cdecl->return->flags->initSym->cdecl2->return->initSym->return->return->if->return->contextMap->get->Assert->error->return
LambdaToMethod.LambdaAnalyzerPreprocessor#initSym(ClassSymbol, long)::: lambda analyzer preprocessor init sym:::isStatic->if->clinit->attr->removeClinit->if->clinits->put->return->clinits->get->if->List->nil->List->nil->new->MethodType->makePrivateSyntheticMethod->clinits->put->return->else->foreach->getSymbolsByName->return->Assert->error->return
LambdaToMethod.LambdaAnalyzerPreprocessor#directlyEnclosingLambda()::: lambda analyzer preprocessor directly enclosing lambda:::if->frameStack->isEmpty->return->frameStack2->while->frameStack2->nonEmpty->switch->getTag->return->return->Assert->error->return
LambdaToMethod.LambdaAnalyzerPreprocessor#inClassWithinLambda()::: lambda analyzer preprocessor in class within lambda:::if->frameStack->isEmpty->return->frameStack2->classFound->while->frameStack2->nonEmpty->switch->getTag->return->break->return
LambdaToMethod.LambdaAnalyzerPreprocessor#capturedDecl(int, Symbol):::Return the declaration corresponding to a symbol in the enclosing scope; the depth parameter is used to filter out symbols defined in nested scopes (which do not need to undergo capture).:::currentDepth->frameStack->size->foreach->switch->getTag->clazz->if->clazz->isSubClass->sym->isMemberOf->return->break->if->return->break->if->contains->return->break->Assert->getTag->error->return
LambdaToMethod.LambdaAnalyzerPreprocessor#context()::: lambda analyzer preprocessor context:::foreach->context->contextMap->get->if->return->return
LambdaToMethod.LambdaAnalyzerPreprocessor#lambdaIdentSymbolFilter(Symbol)::: This is used to filter out those identifiers that needs to be adjusted  when translating away lambda expressions:::return->sym->isStatic
LambdaToMethod.LambdaAnalyzerPreprocessor#lambdaFieldAccessFilter(JCFieldAccess)::: This is used to filter out those select nodes that need to be adjusted  when translating away lambda expressions - at the moment, this is the  set of nodes that select `this' (qualified this):::lambdaContext->return->isStatic->get->isEmpty
LambdaToMethod.LambdaAnalyzerPreprocessor#lambdaNewClassFilter(TranslationContext, JCNewClass):::This is used to filter out those new class expressions that need to be qualified with an enclosing tree:::if->getEnclosingType->hasTag->encl->getEnclosingType->current->enclClass->while->current->hasTag->if->isSubClass->return->current->getEnclosingType->return->else->return
LambdaToMethod.LambdaAnalyzerPreprocessor.Frame#addLocal(Symbol)::: frame add local:::if->List->nil->locals->prepend
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#needsAltMetafactory():::does this functional expression need to be created using alternate metafactory?:::return->isIntersection->isSerializable->bridges->length
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#isSerializable():::does this functional expression require serialization support?:::if->return->return->types->asSuper
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#enclosingMethodName()::: translation context enclosing method name:::return->syntheticMethodNameComponent
LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#syntheticMethodNameComponent(Name)::: translation context synthetic method name component:::if->return->methodName->name->toString->if->methodName->equals->else->if->methodName->equals->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#serializedLambdaDisambiguation():::For a serializable lambda, generate a disambiguating string which maximizes stability across deserialization.:::buf->new->StringBuilder->Assert->directlyEnclosingLambda->check->if->buf->typeSig->append->buf->append->buf->types->findDescriptorSymbol->flatName->append->buf->append->if->buf->assignedTo->flatName->append->buf->append->foreach->getSymbolMap->keySet->if->buf->typeSig->append->buf->append->buf->fv->flatName->append->buf->append->return->buf->toString
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#lambdaName():::For a non-serializable lambda, generate a simple method.:::return->names->enclosingMethodName->fromString->append
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#serializedLambdaName():::For a serializable lambda, generate a method name which maximizes name stability across deserialization.:::buf->new->StringBuilder->buf->append->buf->enclosingMethodName->append->buf->append->disam->serializedLambdaDisambiguation->buf->Integer->disam->hashCode->toHexString->append->buf->append->buf->syntheticMethodNameCounts->getIndex->append->result->buf->toString->return->names->fromString
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(Symbol, LambdaSymbolKind):::Translate a symbol of a given kind into something suitable for the synthetic lambda body:::ret->switch->break->sym->flags->types->erasure->new->VarSymbol->break->types->erasure->new->VarSymbol->break->name->names->sym->flatName->toString->replace->new->String->fromString->types->erasure->new->VarSymbol->break->sym->flags->new->VarSymbol->break->sym->flags->types->erasure->new->VarSymbol->break->Assert->skind->name->error->throw->new->AssertionError->if->skind->propagateAnnotations->ret->sym->getRawAttributes->setDeclarationAttributes->ret->sym->getRawTypeAttributes->setTypeAttributes->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#addSymbol(Symbol, LambdaSymbolKind)::: lambda translation context add symbol:::if->typesUnderConstruction->isEmpty->currentClass->currentClass->if->typesUnderConstruction->contains->Assert->check->transMap->getSymbolMap->if->transMap->containsKey->transMap->translate->put
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#getSymbolMap(LambdaSymbolKind)::: lambda translation context get symbol map:::m->translatedSymbols->get->Assert->checkNonNull->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCIdent)::: lambda translation context translate:::foreach->LambdaSymbolKind->values->m->getSymbolMap->switch->if->m->containsKey->tSym->m->get->t->make->Ident->setType->return->break->proxy->m->keySet->stream->isMemberOf->filter->a->isEnclosedBy->reduce->if->proxy->isPresent->tSym->m->proxy->get->get->t->make->Ident->setType->make->Select->t->setType->TreeInfo->setSymbol->return->break->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCFieldAccess)::: lambda translation context translate:::Assert->check->m->translatedSymbols->get->if->m->containsKey->tSym->m->get->t->make->Ident->setType->return->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCNewClass)::: lambda translation context translate:::Assert->hasOuterInstance->check->m->translatedSymbols->get->enclosingType->getEnclosingType->if->m->containsKey->tSym->m->get->encl->make->Ident->setType->return
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#complete():::The translatedSym is not complete/accurate until the analysis is finished:::if->return->inInterface->isInterface->thisReferenced->getSymbolMap->isEmpty->params->new->ListBuffer<>->parameterSymbols->new->ListBuffer<>->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->foreach->getSymbolMap->values->params->make->VarDef->append->parameterSymbols->append->params->toList->parameterSymbols->toList->isSerializable->serializedLambdaName->lambdaName->types->generatedLambdaSig->TreeInfo->types->createMethodTypeWithParameters
LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#generatedLambdaSig()::: lambda translation context generated lambda sig:::return->types->tree->getDescriptorType->erasure
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#referenceKind():::Get the opcode associated with this method reference:::return->LambdaToMethod.this->referenceKind
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#needsVarArgsConversion()::: reference translation context needs var args conversion:::return
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isArrayOp()::: reference translation context is array op:::return
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#receiverAccessible()::: reference translation context receiver accessible:::return
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isPrivateInOtherClass():::The VM does not support access across nested classes (8010319):::return->flags->types->types->enclClass->asType->erasure->types->owner->enclClass->asType->erasure->isSameType
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isProtectedInSuperClassOfEnclosingClassInOtherPackage()::: reference translation context is protected in super class of enclosing class in other package:::return->flags->packge->owner->packge->owner->enclClass->isSubClass
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#interfaceParameterIsIntersectionOrUnionType():::Erasure destroys the implementation parameter subtype relationship for intersection types:::tl->tree->getDescriptorType->getParameterTypes->for->tl->nonEmpty->return
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#needsConversionToLambda():::Does this reference need to be converted to a lambda (i.e:::return->interfaceParameterIsIntersectionOrUnionType->needsVarArgsConversion->isArrayOp->isPrivateInOtherClass->isProtectedInSuperClassOfEnclosingClassInOtherPackage->receiverAccessible->tree->getMode->isLocal->isInner
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#generatedRefSig()::: reference translation context generated ref sig:::return->types->erasure
LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#bridgedRefSig()::: reference translation context bridged ref sig:::return->types->types->findDescriptorSymbol->erasure
LambdaToMethod#typeSig(Type)::: lambda to method type sig:::sg->new->L2MSignatureGenerator->sg->assembleSig->return->sg->toString
LambdaToMethod#classSig(Type)::: lambda to method class sig:::sg->new->L2MSignatureGenerator->sg->assembleClassSig->return->sg->toString
LambdaToMethod.L2MSignatureGenerator#append(char)::: l2 signature generator append:::sb->append
LambdaToMethod.L2MSignatureGenerator#append(byte[])::: l2 signature generator append:::sb->new->String->append
LambdaToMethod.L2MSignatureGenerator#append(Name)::: l2 signature generator append:::sb->name->toString->append
LambdaToMethod.L2MSignatureGenerator#toString()::: l2 signature generator to string:::return->sb->toString
Lower#instance(Context)::: lower instance:::instance->context->get->if->new->Lower->return
Lower.ClassMap#visitClassDef(JCClassDecl):::All encountered class defs are entered into classdefs table.:::classdefs->put->super->visitClassDef
Lower#classDef(ClassSymbol):::Map a class symbol to its definition.:::def->classdefs->get->if->classMap->scan->classdefs->get->if->classMap->scan->classdefs->get->return
Lower.BasicFreeVarCollector#addFreeVars(ClassSymbol):::Add all free variables of class c to fvs list  unless they are already there.:::
Lower.BasicFreeVarCollector#visitIdent(JCIdent):::If tree refers to a variable in owner of local class, add it to  free variables list.:::visitSymbol
Lower.BasicFreeVarCollector#visitSymbol(Symbol)::: basic free var collector visit symbol:::
Lower.BasicFreeVarCollector#visitNewClass(JCNewClass):::If tree refers to a class instance creation expression  add all free variables of the freshly created class.:::c->addFreeVars->super->visitNewClass
Lower.BasicFreeVarCollector#visitApply(JCMethodInvocation):::If tree refers to a superclass constructor call,  add all free variables of the superclass.:::if->TreeInfo->name->TreeInfo->symbol->addFreeVars->super->visitApply
Lower.FreeVarCollector#addFreeVar(VarSymbol):::Add free variable to fvs list unless it is already there.:::for->l->l->nonEmpty->fvs->prepend
Lower.FreeVarCollector#addFreeVars(ClassSymbol)::: free var collector add free vars:::fvs->freevarCache->get->if->for->l->l->nonEmpty
Lower.FreeVarCollector#visitSymbol(Symbol)::: free var collector visit symbol:::sym->if->if->proxies->get->if->v->if->v->getConstValue->addFreeVar->else->if->visitSymbol
Lower.FreeVarCollector#visitNewClass(JCNewClass):::If tree refers to a class instance creation expression  add all free variables of the freshly created class.:::c->if->c->hasOuterInstance->visitSymbol->super->visitNewClass
Lower.FreeVarCollector#visitSelect(JCFieldAccess):::If tree refers to a qualified this or super expression  for anything but the current class, add the outer this  stack as a free variable.:::if->visitSymbol->super->visitSelect
Lower.FreeVarCollector#visitApply(JCMethodInvocation):::If tree refers to a superclass constructor call,  add all free variables of the superclass.:::if->TreeInfo->name->constructor->TreeInfo->symbol->c->if->c->hasOuterInstance->hasTag->visitSymbol->super->visitApply
Lower#ownerToCopyFreeVarsFrom(ClassSymbol)::: lower owner to copy free vars from:::if->c->isLocal->return->currentOwner->while->matches->currentOwner->isLocal->if->matches->c->isSubClass->return->return
Lower#freevars(ClassSymbol):::Return the variables accessed from within a local class, which  are declared in the local class' owner:::fvs->freevarCache->get->if->return->if->matches->collector->new->FreeVarCollector->collector->classDef->scan->freevarCache->put->return->else->owner->ownerToCopyFreeVarsFrom->if->freevarCache->get->freevarCache->put->return->else->return->List->nil
Lower#mapForEnum(DiagnosticPosition, TypeSymbol)::: lower map for enum:::map->enumSwitchMap->get->if->enumSwitchMap->new->EnumMapping->put->return
Lower.EnumMapping#forConstant(VarSymbol)::: enum mapping for constant:::result->values->get->if->values->put->return->make->Literal
Lower.EnumMapping#translate()::: enum mapping translate:::make->pos->getStartPosition->at->owner->classDef->valuesMethod->List->nil->lookupMethod->size->make->make->make->QualIdent->App->Select->mapVarInit->make->make->Type->List->of->NewArray->new->ArrayType->setType->stmts->new->ListBuffer<>->ordinalMethod->List->nil->lookupMethod->catcher->List->nil->make->make->new->VarSymbol->VarDef->make->List->nil->Block->Catch->prepend->foreach->values->entrySet->enumerator->e->getKey->mappedValue->e->getValue->assign->make->make->make->make->make->QualIdent->Select->App->Indexed->make->Literal->Assign->setType->exec->make->Exec->_try->make->make->List->of->Block->Try->stmts->append->make->stmts->toList->Block->prepend->make->VarDef->prepend
Lower#make_at(DiagnosticPosition):::Equivalent to make.at(pos.getStartPosition()) with side effect of caching  pos as make_pos, for use in diagnostics.:::return->make->at
Lower#makeLit(Type, Object):::Make an attributed tree representing a literal:::return->make->type->getTag->Literal->type->constType->setType
Lower#makeNull():::Make an attributed tree representing null.:::return->makeLit
Lower#makeNewClass(Type, List):::Make an attributed class instance creation expression.:::tree->make->make->QualIdent->NewClass->rs->TreeInfo->types->List->nil->resolveConstructor->return
Lower#makeUnary(JCTree.Tag, JCExpression):::Make an attributed unary expression.:::tree->make->Unary->operators->resolveUnary->getReturnType->return
Lower#makeBinary(JCTree.Tag, JCExpression, JCExpression):::Make an attributed binary expression.:::tree->make->Binary->operators->resolveBinary->getReturnType->return
Lower#makeAssignop(JCTree.Tag, JCTree, JCTree):::Make an attributed assignop expression.:::tree->make->Assignop->operators->tree->getTag->noAssignOp->resolveBinary->return
Lower#makeString(JCExpression):::Convert tree into string object, unless it has already a  reference type..:::if->isPrimitiveOrVoid->return->else->valueOfSym->tree->pos->List->of->lookupMethod->return->make->make->QualIdent->List->of->App
Lower#makeEmptyClass(long, ClassSymbol):::Create an empty anonymous class definition and enter and complete  its symbol:::return->makeEmptyClass
Lower#makeEmptyClass(long, ClassSymbol, Name, boolean)::: lower make empty class:::c->syms->defineClass->if->else->chk->localClassName->WriteableScope->create->ctype->List->nil->odef->classDef->odef->pos->owner->members->enterSynthetic->chk->putCompiled->cdef->make->make->Modifiers->List->nil->List->nil->List->nil->ClassDef->if->prepend->return
Lower#enterSynthetic(DiagnosticPosition, Symbol, WriteableScope):::Enter a synthetic symbol in a given scope, but complain if there was already one there.:::s->enter
Lower#makeSyntheticName(Name, Scope):::Create a fresh synthetic name within a given scope - the unique name is  obtained by appending '$' chars at the end of the name until no match  is found.:::do->name->target->syntheticNameChar->append->while->lookupSynthetic->return
Lower#checkConflicts(List):::Check whether synthetic symbols generated during lowering conflict  with user-defined symbols.:::foreach->t->accept
Lower#lookupSynthetic(Name, Scope):::Look up a synthetic name in a given scope.:::sym->s->findFirst->return->sym->flags
Lower#lookupMethod(DiagnosticPosition, Name, Type, List):::Look up a method in a given scope.:::return->rs->List->nil->resolveInternalMethod
Lower#checkAccessConstructorTags():::Anon inner classes are used as access constructor tags:::for->l->l->nonEmpty
Lower#isTranslatedClassAvailable(ClassSymbol)::: lower is translated class available:::foreach->if->tree->hasTag->return->return
Lower#swapAccessConstructorTag(ClassSymbol, ClassSymbol)::: lower swap access constructor tag:::foreach->accessConstrs->values->Assert->hasTag->check->oldMethodType->if->types->oldMethodType->getParameterTypes->newCTag->erasure->prepend->createMethodTypeWithParameters
Lower#accessCode(JCTree, JCTree):::return access code for identifier,:::if->return->else->if->enclOp->hasTag->TreeInfo->skipParens->return->else->if->enclOp->getTag->isIncOrDecUnaryOp->enclOp->getTag->isAssignop->TreeInfo->getOperand->skipParens->return->enclOp->getTag->getAccessCode->else->return
Lower#binaryAccessOperator(int, Tag):::Return binary operator that corresponds to given access code.:::return->operators->op->getAccessCode->lookupBinaryOp
Lower#treeTag(OperatorSymbol):::Return tree tag for assignment operation corresponding  to given binary operator.:::switch->return->return->return->return->return->return->return->return->return->return->return->throw->new->AssertionError
Lower#accessName(int, int):::The name of the access method with number `anum' and access code `acode'.:::return->names->target->syntheticNameChar->fromString
Lower#accessSymbol(Symbol, JCTree, JCTree, boolean, boolean):::Return access symbol for a private or protected symbol from an inner class.:::accOwner->accessClass->vsym->if->sym->clone->actualSymbols->put->anum->accessNums->get->if->accessed->length->accessNums->put->accessSyms->new->MethodSymbolArr->put->accessed->append->acode->argtypes->restype->thrown->switch->accessCode->if->operator->enclOp->getTag->binaryAccessOperator->if->List->of->else->getParameterTypes->else->if->List->vsym->erasure->of->else->List->nil->vsym->erasure->List->nil->break->vsym->erasure->getParameterTypes->vsym->erasure->getReturnType->getThrownTypes->break->throw->new->AssertionError->if->if->vsym->flags->argtypes->erasure->prepend->accessors->accessSyms->get->accessor->if->accOwner->isInterface->anum->intValue->accessName->new->MethodType->new->MethodSymbol->tree->pos->accOwner->members->enterSynthetic->return
Lower#accessBase(DiagnosticPosition, Symbol):::The qualifier to be used for accessing a symbol in an outer class:::return->sym->flags->make->pos->getStartPosition->at->QualIdent->access->makeOwnerThis
Lower#needsPrivateAccess(Symbol):::Do we need an access method to reference private symbol?:::if->target->hasNestmateAccess->return->if->sym->flags->return->else->if->isLocal->return->else->return
Lower#needsProtectedAccess(Symbol, JCTree):::Do we need an access method to reference symbol in other package?:::if->return->if->sym->flags->sym->packge->currentClass->packge->return->if->currentClass->isSubClass->return->if->sym->flags->tree->hasTag->TreeInfo->name->return->return->isSubClass
Lower#accessClass(Symbol, boolean, JCTree):::The class in which an access method for given symbol goes.:::if->qualifier->c->if->tree->hasTag->sym->flags->while->qualifier->isSubClass->enclClass->return->else->while->c->isSubClass->enclClass->return->else->return->enclClass
Lower#addPrunedInfo(JCTree)::: lower add pruned info:::infoList->prunedTree->get->List->of->infoList->prepend->prunedTree->put
Lower#access(Symbol, JCExpression, JCExpression, boolean):::Ensure that identifier is accessible, return tree accessing the identifier.:::while->enclClass->cv->getConstValue->if->make->at->return->makeLit->proxies->get->Assert->check->make->at->Ident->base->tree->hasTag->switch->if->flatname->Convert->sym->flatName->shortName->while->TreeInfo->symbol->TreeInfo->symbol->base->hasTag->if->tree->hasTag->else->if->make->at->Ident->else->break->if->protAccess->needsPrivateAccess->needsProtectedAccess->accReq->needsPrivateAccess->baseReq->sym->isMemberOf->if->make->at->if->cv->getConstValue->if->addPrunedInfo->return->makeLit->if->args->List->nil->if->sym->flags->if->tree->pos->makeOwnerThis->args->prepend->access->accessSymbol->receiver->make->make->QualIdent->Select->return->make->App->else->if->return->make->at->tree->pos->accessBase->Select->setType->else->if->translatedSym->lambdaTranslationMap->get->if->make->at->Ident->return
Lower#access(JCExpression):::Ensure that identifier is accessible, return tree accessing the identifier.:::sym->TreeInfo->symbol->return->access
Lower#accessConstructor(DiagnosticPosition, Symbol):::Return access constructor for a private constructor,  or the constructor itself, if no access constructor is needed.:::if->needsPrivateAccess->accOwner->enclClass->aconstr->accessConstrs->get->if->argtypes->getParameterTypes->if->argtypes->prepend->prepend->argtypes->accessConstructorTag->erasure->append->getReturnType->getThrownTypes->new->MethodType->new->MethodSymbol->accOwner->members->enterSynthetic->accessConstrs->put->accessed->append->return->else->return
Lower#accessConstructorTag():::Return an anonymous class nested in this toplevel class.:::topClass->currentClass->outermostClass->topModle->topClass->packge->for->i
Lower#makeAccessible(Symbol):::Add all required access methods for a private symbol to enclosing class.:::cdef->enclClass->classDef->if->Assert->error->if->accessConstrs->get->accessConstructorDef->prepend->else->accessors->accessSyms->get->for->i
Lower#accessDef(int, Symbol, MethodSymbol, int):::Construct definition of an access method.:::enclClass->make->at->md->make->MethodDef->sym->actualSymbols->get->if->ref->args->if->sym->flags->make->Ident->make->Idents->else->site->make->Ident->if->site->types->types->enclClass->supertype->erasure->setType->make->Select->make->Idents->stat->if->acode1->expr->aCode->AccessCode->getFromCode->switch->break->make->Assign->break->makeUnary->break->make->binaryAccessOperator->treeTag->Assignop->binaryAccessOperator->make->expr->setType->Return->else->make->make->App->Call->make->List->of->Block->for->l->l->nonEmpty->access->for->l->l->nonEmpty->return
Lower#accessConstructorDef(int, Symbol, MethodSymbol):::Construct definition of an access constructor.:::make->at->md->make->accessor->externalType->MethodDef->callee->make->Ident->make->List->make->make->make->reverse->reverse->Idents->App->Call->of->Block->return
Lower#proxyName(Name, int):::The name of a free variable proxy.:::proxyName->names->target->syntheticNameChar->fromString->if->proxyName->names->target->syntheticNameChar->fromString->append->return
Lower#freevarDefs(int, List, Symbol):::Proxy definitions for all free variables in given list, in reverse order.:::return->freevarDefs
Lower#freevarDefs(int, List, Symbol, long)::: lower freevar defs:::flags->defs->List->nil->proxyNames->new->HashSet<>->for->l->l->nonEmpty->return
Lower#outerThisName(Type, Symbol):::The name of a this$n field:::t->type->getEnclosingType->nestingLevel->while->t->hasTag->t->getEnclosingType->result->names->target->syntheticNameChar->fromString->while->members->findFirst->names->result->toString->target->syntheticNameChar->fromString->return
Lower#makeOuterThisVarSymbol(Symbol, long)::: lower make outer this var symbol:::target->types->owner->enclClass->getEnclosingType->erasure->outerThis->outerThisName->new->VarSymbol->outerThisStack->prepend->return
Lower#makeOuterThisVarDecl(int, VarSymbol)::: lower make outer this var decl:::vd->make->at->VarDef->access->return
Lower#outerThisDef(int, MethodSymbol):::Definition for this$n field.:::c->owner->enclClass->isMandated->owner->isConstructor->owner->isAnonymous->owner->isConstructor->c->isInner->c->isPrivate->c->isStatic->flags->outerThis->makeOuterThisVarSymbol->prepend->return->makeOuterThisVarDecl
Lower#outerThisDef(int, ClassSymbol):::Definition for this$n field.:::outerThis->makeOuterThisVarSymbol->return->makeOuterThisVarDecl
Lower#loadFreevars(DiagnosticPosition, List):::Return a list of trees that load the free variables in given list,  in reverse order.:::args->List->nil->for->l->l->nonEmpty->return
Lower#loadFreevar(DiagnosticPosition, VarSymbol)::: lower load freevar:::return->make->at->Ident->access
Lower#makeThis(DiagnosticPosition, TypeSymbol):::Construct a tree simulating the expression C.this.:::if->return->make->at->c->erasure->This->else->return->makeOuterThis
Lower#makeTwrTry(JCTry):::Optionally replace a try statement with the desugaring of a try-with-resources statement:::tree->pos->make_at->twrVars->dup->twrBlock->makeTwrBlock->if->isEmpty->translate->else->make->Try->translate->twrVars->leave->return
Lower#makeTwrBlock(List, JCBlock, int)::: lower make twr block:::if->resources->isEmpty->return->stats->new->ListBuffer<>->resource->resourceUse->resourceNonNull->if->var->make->Ident->setType->TreeInfo->skipParens->hasTag->stats->add->else->Assert->check->syntheticTwrVar->names->fromString->makeSyntheticName->hasTag->new->VarSymbol->twrVars->enter->syntheticTwrVarDecl->make->VarDef->make->Ident->stats->add->oldPos->make->TreeInfo->endPos->at->bodyCloseStatement->makeResourceCloseInvocation->if->make->makeNonNullCheck->If->finallyClause->make->List->of->Block->make->at->primaryException->names->target->syntheticNameChar->fromString->new->VarSymbol->primaryExceptionDecl->make->VarDef->suppressedException->make->paramName->new->VarSymbol->addSuppressedStatement->make->make->Ident->List->make->Ident->of->makeCall->Exec->closeResourceTryBlock->make->List->makeResourceCloseInvocation->of->Block->catchSuppressedDecl->make->VarDef->catchSuppressedBlock->make->List->of->Block->catchSuppressedClauses->List->make->Catch->of->closeResourceTry->make->Try->exceptionalCloseStatement->if->make->makeNonNullCheck->If->exceptionalRethrow->make->make->Ident->Throw->exceptionalCloseBlock->make->List->of->Block->exceptionalCatchClause->make->Catch->outerTry->make->makeTwrBlock->List->of->Try->stats->add->newBlock->make->stats->toList->Block->return
Lower#makeResourceCloseInvocation(JCExpression)::: lower make resource close invocation:::if->types->asSuper->convert->resourceClose->List->nil->makeCall->return->make->Exec
Lower#makeNonNullCheck(JCExpression)::: lower make non null check:::return->makeNull->makeBinary
Lower#makeOuterThis(DiagnosticPosition, TypeSymbol):::Construct a tree that represents the outer instance  C.this:::ots->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->makeNull->ot->tree->make->at->Ident->access->otc->while->do->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->while->if->otc->hasOuterInstance->chk->earlyRefError->Assert->error->return->makeNull->make->at->Select->access->return
Lower#makeOwnerThis(DiagnosticPosition, Symbol, boolean):::Construct a tree that represents the closest outer instance  C.this such that the given symbol is a member of C.:::c->if->sym->isMemberOf->currentClass->isSubClass->return->make->at->c->erasure->This->else->return->makeOwnerThisN
Lower#makeOwnerThisN(DiagnosticPosition, Symbol, boolean):::Similar to makeOwnerThis but will never pick "this".:::c->ots->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->makeNull->ot->tree->make->at->Ident->access->otc->while->sym->isMemberOf->otc->isSubClass->do->if->ots->isEmpty->log->Errors->NoEnclInstanceOfTypeInScope->error->Assert->error->return->while->make->at->Select->access->return
Lower#initField(int, Symbol, Symbol):::Return tree simulating the assignment this.name = name, where  name is the name of a free variable.:::Assert->check->Assert->check->make->at->return->make->make->make->make->erasure->This->Select->make->Ident->Assign->lhs->erasure->setType->Exec
Lower#initOuterThis(int):::Return tree simulating the assignment this.this$n = this$n.:::rhs->Assert->check->lhs->Assert->check->make->at->return->make->make->make->make->erasure->This->Select->make->Ident->Assign->lhs->erasure->setType->Exec
Lower#outerCacheClass():::Return the symbol of a class to contain a cache of  compiler-generated statics such as class$ and the  $assertionsDisabled flag:::clazz->s->clazz->members->foreach->s->getSymbols->if->sym->flags->return->return->makeEmptyClass
Lower#makeCall(JCExpression, Name, List):::Create an attributed tree of the form left.name().:::Assert->checkNonNull->funcsym->TreeInfo->types->lookupMethod->return->make->make->Select->App
Lower#classOf(JCTree):::The tree simulating a T.class expression.:::return->clazz->pos->classOfType
Lower#classOfType(Type, DiagnosticPosition)::: lower class of type:::switch->type->getTag->c->types->boxedClass->typeSym->rs->rs->findIdentInType->accessBase->if->getConstValue->return->make->QualIdent->sym->new->VarSymbol->return->make_at->make->Type->Select->throw->new->AssertionError
Lower#assertionsDisabledClass():::Used to create an auxiliary class to hold $assertionsDisabled for interfaces.:::if->return->makeEmptyClass->return
Lower#assertFlagTest(DiagnosticPosition)::: lower assert flag test:::outermostClass->container->currentClass->isInterface->assertionsDisabledClass->assertDisabledSym->container->members->lookupSynthetic->if->new->VarSymbol->container->members->enterSynthetic->desiredAssertionStatusSym->types->erasure->List->nil->lookupMethod->containerDef->classDef->containerDef->pos->make_at->notStatus->make->make->types->erasure->containerDef->pos->classOfType->Select->App->makeUnary->assertDisabledDef->make->VarDef->prepend->if->currentClass->isInterface->currentClassDef->classDef->currentClassDef->pos->make_at->dummy->make->make->QualIdent->make->Skip->If->clinit->make->List->of->Block->prepend->make_at->return->make->Ident->makeUnary
Lower.TreeBuilder#build(JCExpression)::: tree builder build:::
Lower#abstractRval(JCExpression, Type, TreeBuilder):::Construct an expression using the builder, with the given rval  expression as an argument to the builder:::TreeInfo->skipParens->switch->rval->getTag->return->builder->build->id->if->flags->return->builder->build->name->TreeInfo->name->if->return->builder->build->var->names->target->syntheticNameChar->rval->hashCode->fromString->new->VarSymbol->convert->def->make->VarDef->built->builder->make->Ident->build->res->make->LetExpr->return
Lower#abstractRval(JCExpression, TreeBuilder)::: lower abstract rval:::return->abstractRval
Lower#abstractLval(JCExpression, TreeBuilder)::: lower abstract lval:::TreeInfo->skipParens->switch->lval->getTag->return->builder->build->s->lid->TreeInfo->symbol->if->return->builder->build->return->builder->make->Select->build->abstractRval->i->return->newLval->make->Indexed->newLval->setType->return->builder->build->abstractRval->abstractRval->return->abstractLval->throw->new->AssertionError
Lower#makeComma(JCExpression, JCExpression)::: lower make comma:::return->abstractRval
Lower#translate(T):::Visitor method: Translate a single node:::if->return->else->tree->pos->make_at->result->super->translate->if->endPosTable->replaceTree->return
Lower#translate(T, Type):::Visitor method: Translate a single node, boxing or unboxing if needed.:::return->translate->boxIfNeeded
Lower#translate(T, JCExpression):::Visitor method: Translate tree.:::prevEnclOp->res->translate->return
Lower#translate(List, Type):::Visitor method: Translate list of trees.:::if->return->for->l->l->nonEmpty->return
Lower#visitPackageDef(JCPackageDecl)::: lower visit package def:::if->needPackageInfoClass->return->flags->c->c->setAttributes->ctype->List->nil->createInfoClass
Lower#needPackageInfoClass(JCPackageDecl)::: lower need package info class:::switch->return->return->pd->getAnnotations->nonEmpty->foreach->getDeclarationAttributes->p->types->getRetention->if->return->return->throw->new->AssertionError
Lower#visitModuleDef(JCModuleDecl)::: lower visit module def:::msym->c->c->setAttributes->List->nil->createInfoClass
Lower#createInfoClass(List, ClassSymbol)::: lower create info class:::flags->infoClass->make->make->Modifiers->List->nil->List->nil->List->nil->ClassDef->translated->append
Lower#visitClassDef(JCClassDecl)::: lower visit class def:::prevEnv->currentClassPrev->currentMethodSymPrev->typeEnvs->remove->if->classdefs->put->prevProxies->new->HashMap<>->prevOuterThisStack->if->types->supertype->flags->visitEnumDef->otdef->if->currentClass->hasOuterInstance->outerThisDef->fvdefs->freevars->freevarDefs->translate->translate->if->currentClass->isLocal->encl->enclClass->if->List->nil->prepend->seen->List->nil->while->unseen->for->l->l->nonEmpty->if->Convert->currentClass->flatName->shortName->for->l->l->nonEmpty->if->currentClass->hasOuterInstance->prepend->tree->pos->currentClass->members->enterSynthetic->translated->append->tree->pos->make_at->List->nil->Block
Lower#visitEnumDef(JCClassDecl):::Translate an enum class.:::tree->pos->make_at->if->make->types->supertype->Type->e_class->tree->pos->classOfType->types->erasure->setType->nextOrdinal->values->new->ListBuffer<>->enumDefs->new->ListBuffer<>->otherDefs->new->ListBuffer<>->for->defs->defs->nonEmpty->valuesName->names->target->syntheticNameChar->fromString->while->members->findFirst->names->target->syntheticNameChar->fromString->arrayType->types->erasure->new->ArrayType->valuesVar->new->VarSymbol->newArray->make->make->types->erasure->Type->List->nil->values->toList->NewArray->enumDefs->make->VarDef->append->members->enter->valuesSym->tree->pos->List->nil->lookupMethod->valuesBody->if->useClone->valuesResult->make->getReturnType->make->make->make->Ident->Select->App->TypeCast->List->make->Return->of->else->resultName->names->target->syntheticNameChar->fromString->while->members->findFirst->names->target->syntheticNameChar->fromString->resultVar->new->VarSymbol->resultArray->make->make->types->erasure->Type->List->make->make->Ident->Select->of->NewArray->decl->make->VarDef->if->names->fromString->List->of->List->nil->new->MethodType->new->MethodSymbol->copy->make->make->make->make->Ident->Select->List->make->Ident->make->Literal->make->Ident->make->Literal->make->make->Ident->Select->of->App->Exec->ret->make->make->Ident->Return->List->of->valuesDef->make->make->Block->MethodDef->enumDefs->append->if->println->valueOfSym->tree->pos->List->of->lookupMethod->Assert->valueOfSym->flags->check->nameArgSym->nameVal->make->Ident->enum_ValueOf->make->make->make->Ident->List->of->makeCall->TypeCast->Return->valueOf->make->make->List->of->Block->MethodDef->if->println->enumDefs->append->enumDefs->otherDefs->toList->appendList->enumDefs->toList
Lower#useClone()::: lower use clone:::try->return->members->findFirst->catch->return->finally
Lower#visitEnumConstantDef(JCVariableDecl, int):::Translate an enumeration constant and its initializer.:::varDef->makeLit->prepend->toString->makeLit->prepend
Lower#visitMethodDef(JCMethodDecl)::: lower visit method def:::if->nameParam->tree->pos->make_at->names->target->syntheticNameChar->target->syntheticNameChar->fromString->Param->ordParam->make->names->target->syntheticNameChar->target->syntheticNameChar->fromString->Param->m->prepend->prepend->prepend->prepend->olderasure->m->erasure->olderasure->getParameterTypes->prepend->prepend->olderasure->getReturnType->olderasure->getThrownTypes->new->MethodType->prevMethodDef->prevMethodSym->try->visitMethodDefInternal->catch->finally
Lower#visitMethodDefInternal(JCMethodDecl)::: lower visit method def internal:::if->currentClass->isInner->currentClass->isLocal->m->prevProxies->new->HashMap<>->prevOuterThisStack->fvs->freevars->otdef->if->currentClass->hasOuterInstance->outerThisDef->fvdefs->freevarDefs->translate->translateVarDefs->translate->if->return->appendList->if->currentClass->hasOuterInstance->prepend->selfCall->translate->added->List->nil->if->fvs->nonEmpty->addedargtypes->List->nil->for->l->l->nonEmpty->olderasure->m->erasure->olderasure->getParameterTypes->appendList->olderasure->getReturnType->olderasure->getThrownTypes->new->MethodType->if->currentClass->hasOuterInstance->TreeInfo->isInitialConstructor->added->initOuterThis->prepend->stats->translate->stats->prepend->prependList->else->prevLambdaTranslationMap->try->flags->startsWith->makeTranslationMap->super->visitMethodDef->catch->finally
Lower#makeTranslationMap(JCMethodDecl)::: lower make translation map:::translationMap->new->HashMap<>->foreach->p->if->p->baseSymbol->translationMap->p->baseSymbol->put->return
Lower#visitTypeCast(JCTypeCast)::: lower visit type cast:::translate->if->isPrimitive->isPrimitive->translate->else->translate
Lower#visitNewClass(JCNewClass)::: lower visit new class:::c->isEnum->flags->argTypes->getParameterTypes->if->argTypes->prepend->prepend->boxArgs->if->c->isLocal->tree->pos->freevars->loadFreevars->appendList->constructor->tree->pos->accessConstructor->if->makeNull->append->if->c->hasOuterInstance->thisArg->if->attr->translate->makeNullCheck->else->if->c->isLocal->tree->pos->getEnclosingType->makeThis->else->tree->pos->makeOwnerThis->prepend->if->translate->pos->make_at->Ident->access->else->access
Lower#isTrue(JCTree)::: lower is true:::if->isTrue->return->b->expValue->return
Lower#isFalse(JCTree)::: lower is false:::if->isFalse->return->b->expValue->return
Lower#expValue(JCTree)::: lower exp value:::while->exp->hasTag->eq->switch->exp->getTag->break->break->return->b->if->hasTag->return->expValueIsNull->if->hasTag->return->expValueIsNull->return
Lower#expValueIsNull(boolean, JCTree)::: lower exp value is null:::if->hasTag->return->Boolean->valueOf->if->t->hasTag->return->Boolean->valueOf->return
Lower#visitConditional(JCConditional):::Visitor method for conditional expressions.:::cond->translate->if->isTrue->translate->convert->addPrunedInfo->else->if->isFalse->translate->convert->addPrunedInfo->else->translate->translate
Lower#convert(JCExpression, Type)::: lower convert:::if->hasTag->return->result->tree->pos->make_at->make->Type->TypeCast->constValue->cfolder->coerce->return
Lower#visitIf(JCIf):::Visitor method for if statements.:::cond->translate->if->isTrue->translate->addPrunedInfo->else->if->isFalse->if->translate->else->make->Skip->addPrunedInfo->else->translate->translate
Lower#visitAssert(JCAssert):::Visitor method for assert statements:::translate->if->isTrue->cond->tree->pos->assertFlagTest->exnArgs->List->nil->List->translate->of->if->isFalse->makeUnary->makeBinary->make->make_at->makeNewClass->Throw->If->else->make->Skip
Lower#visitApply(JCMethodInvocation)::: lower visit apply:::meth->TreeInfo->symbol->argtypes->getParameterTypes->if->boxArgs->methName->TreeInfo->name->if->constructor->tree->pos->accessConstructor->if->makeNull->append->TreeInfo->setSymbol->c->if->c->isLocal->tree->pos->freevars->loadFreevars->appendList->if->c->getQualifiedName->params->if->hasOuterInstance->tree->pos->make_at->Ident->prepend->make->Ident->prepend->if->c->hasOuterInstance->thisArg->if->hasTag->attr->translate->makeNullCheck->make->Ident->else->if->c->isLocal->pos->getEnclosingType->makeThis->else->pos->makeOwnerThisN->prepend->else->translate->if->hasTag->app->prependList->return
Lower#boxArgs(List, List, Type)::: lower box args:::args->if->parameters->isEmpty->return->anyChanges->result->new->ListBuffer<>->while->nonEmpty->arg->translate->result->append->parameter->if->elems->new->ListBuffer<>->while->args->nonEmpty->arg->translate->elems->append->boxedArgs->make->make->Type->List->nil->elems->toList->NewArray->new->ArrayType->result->append->else->if->args->length->throw->new->AssertionError->arg->translate->result->append->if->return->return->result->toList
Lower#boxIfNeeded(T, Type):::Expand a boxing or unboxing conversion if needed.:::havePrimitive->isPrimitive->if->type->isPrimitive->return->if->unboxedTarget->types->unboxedType->if->unboxedTarget->hasTag->if->types->isSubtype->unboxedTarget->constValue->constType->return->types->erasure->boxPrimitive->else->boxPrimitive->else->unbox->return
Lower#boxPrimitive(JCExpression):::Box up a single primitive expression.:::return->types->boxedClass->boxPrimitive
Lower#boxPrimitive(JCExpression, Type):::Box up a single primitive expression.:::tree->pos->make_at->valueOfSym->tree->pos->List->nil->prepend->lookupMethod->return->make->make->QualIdent->List->of->App
Lower#unbox(JCExpression, Type):::Unbox an object to a primitive value.:::unboxedType->types->unboxedType->if->unboxedType->hasTag->if->unboxedType->isPrimitive->throw->new->AssertionError->tree->pos->make_at->make->types->boxedClass->TypeCast->else->if->types->isSubtype->throw->new->AssertionError->tree->pos->make_at->valueSym->tree->pos->append->List->nil->lookupMethod->return->make->make->Select->App
Lower#visitParens(JCParens):::Visitor method for parenthesized expressions:::expr->translate
Lower#visitIndexed(JCArrayAccess)::: lower visit indexed:::translate->translate
Lower#visitAssign(JCAssign)::: lower visit assign:::translate->translate->if->hasTag->app->List->of->prependList->else
Lower#visitAssignop(JCAssignOp)::: lower visit assignop:::boxingReq->isPrimitive->getReturnType->isPrimitive->depScanner->new->AssignopDependencyScanner->depScanner->scan->if->newTree->newTag->tree->getTag->noAssignOp->newOperator->operators->resolveBinary->expr->lhs->clone->if->make->TypeCast->opResult->make->Binary->getReturnType->newRhs->make->types->unboxedType->TypeCast->return->make->Assign->setType->abstractLval->translate->return->translate->getParameterTypes->translate->if->hasTag->app->rhs->makeString->List->of->prependList->else
Lower.AssignopDependencyScanner#scan(JCTree)::: assignop dependency scanner scan:::if->tree->accept
Lower.AssignopDependencyScanner#visitAssignop(JCAssignOp)::: assignop dependency scanner visit assignop:::if->TreeInfo->symbol->return->super->visitAssignop
Lower.AssignopDependencyScanner#visitUnary(JCUnary)::: assignop dependency scanner visit unary:::if->TreeInfo->symbol->return->super->visitUnary
Lower#lowerBoxedPostop(JCUnary):::Lower a tree of the form e++ or e-- where e is an object type:::cast->TreeInfo->skipParens->hasTag->return->opcode->tree->hasTag->lhs->tmp1->clone->make->TypeCast->update->make->Literal->makeAssignop->return->makeComma->abstractRval->abstractLval
Lower#visitUnary(JCUnary)::: lower visit unary:::isUpdateOperator->tree->getTag->isIncOrDecUnaryOp->if->isPrimitive->switch->tree->getTag->opcode->tree->hasTag->newTree->make->Literal->makeAssignop->translate->return->lowerBoxedPostop->translate->return->throw->new->AssertionError->translate->boxIfNeeded->if->tree->hasTag->constValue->cfolder->fold1->if->hasTag->else
Lower#visitBinary(JCBinary)::: lower visit binary:::formals->getParameterTypes->lhs->translate->switch->tree->getTag->if->isTrue->return->if->isFalse->translate->return->break->if->isFalse->return->if->isTrue->translate->return->break->translate
Lower#visitIdent(JCIdent)::: lower visit ident:::access
Lower#visitForeachLoop(JCEnhancedForLoop):::Translate away the foreach loop.:::if->types->elemtype->visitIterableForeachLoop->else->visitArrayForeachLoop
Lower#visitArrayForeachLoop(JCEnhancedForLoop):::A statement of the form       for ( T v : arrayexpr ) stmt;   (where arrayexpr is of an array type) gets translated to  for ( { arraytype #arr = arrayexpr;             int #len = array.length;             int #i = 0; ;           #i < #len; i$++ ) {         T v = arr$[#i];         stmt;     } }  where #arr, #len, and #i are freshly named synthetic local variables.:::pos->make_at->arraycache->names->target->syntheticNameChar->fromString->new->VarSymbol->arraycachedef->make->VarDef->lencache->names->target->syntheticNameChar->fromString->new->VarSymbol->lencachedef->make->make->make->Ident->Select->VarDef->index->names->target->syntheticNameChar->fromString->new->VarSymbol->indexdef->make->make->Literal->VarDef->constType->loopinit->List->of->cond->make->Ident->make->Ident->makeBinary->step->make->make->Ident->makeUnary->Exec->elemtype->types->elemtype->loopvarinit->make->make->Ident->make->Ident->Indexed->setType->loopvardef->make->VarDef->setType->body->make->List->of->Block->make->List->of->ForLoop->translate->patchTargets
Lower#patchTargets(JCTree, JCTree, JCTree):::Patch up break and continue targets.:::new->Patcher->scan
Lower#visitIterableForeachLoop(JCEnhancedForLoop):::A statement of the form       for ( T v : coll ) stmt ;   (where coll implements Iterable<? extends T>) gets translated to  for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); ) {         T v = (T) #i.next();         stmt;      }  where #i is a freshly named synthetic local variable.:::pos->make_at->iteratorTarget->iterableType->types->types->cvarUpperBound->asSuper->if->iterableType->getTypeArguments->nonEmpty->types->iterableType->getTypeArguments->erasure->eType->types->skipTypeVars->types->erasure->if->eType->isCompound->make->types->erasure->TypeCast->iterator->pos->List->nil->lookupMethod->itvar->names->target->syntheticNameChar->fromString->types->types->getReturnType->asSuper->erasure->new->VarSymbol->init->make->make->make->Select->types->erasure->setType->App->VarDef->hasNext->pos->List->nil->lookupMethod->cond->make->make->make->Ident->Select->App->next->pos->List->nil->lookupMethod->vardefinit->make->make->make->Ident->Select->App->if->isPrimitive->make->types->cvarUpperBound->TypeCast->else->make->TypeCast->indexDef->make->VarDef->setType->body->make->List->of->Block->TreeInfo->endPos->make->List->of->List->nil->ForLoop->translate->patchTargets
Lower#visitVarDef(JCVariableDecl)::: lower visit var def:::oldMethodSym->translate->translate->if->new->MethodSymbol->if->translate
Lower#visitBlock(JCBlock)::: lower visit block:::oldMethodSym->if->new->MethodSymbol->super->visitBlock
Lower#visitDoLoop(JCDoWhileLoop)::: lower visit do loop:::translate->translate
Lower#visitWhileLoop(JCWhileLoop)::: lower visit while loop:::translate->translate
Lower#visitForLoop(JCForLoop)::: lower visit for loop:::translate->if->translate->translate->translate
Lower#visitReturn(JCReturn)::: lower visit return:::if->types->erasure->translate
Lower#visitSwitch(JCSwitch)::: lower visit switch:::selsuper->types->supertype->enumSwitch->flags->stringSwitch->types->isSameType->target->translate->translateCases->if->visitEnumSwitch->else->if->visitStringSwitch->else
Lower#visitEnumSwitch(JCSwitch)::: lower visit enum switch:::enumSym->map->tree->pos->mapForEnum->tree->pos->make_at->ordinalMethod->tree->pos->List->nil->lookupMethod->selector->make->make->make->Select->App->Indexed->cases->new->ListBuffer<>->foreach->if->label->TreeInfo->symbol->pat->map->forConstant->cases->make->Case->append->else->cases->append->enumSwitch->make->cases->toList->Switch->patchTargets->return
Lower#visitStringSwitch(JCSwitch)::: lower visit string switch:::caseList->tree->getCases->alternatives->caseList->size->if->return->make->tree->pos->at->attr->tree->getExpression->makeNullCheck->Exec->else->stmtList->new->ListBuffer<>->caseLabelToPosition->new->LinkedHashMap<>->hashToString->new->LinkedHashMap<>->casePosition->foreach->expression->oneCase->getExpression->if->labelExpr->constValue->mapping->caseLabelToPosition->put->Assert->checkNull->hashCode->labelExpr->hashCode->stringSet->hashToString->get->if->new->LinkedHashSet<>->stringSet->add->hashToString->put->else->added->stringSet->add->Assert->check->dollar_s->names->target->syntheticNameChar->fromString->new->VarSymbol->stmtList->make->tree->pos->at->tree->getExpression->VarDef->setType->append->dollar_tmp->names->target->syntheticNameChar->fromString->new->VarSymbol->dollar_tmp_def->make->make->Literal->VarDef->setType->stmtList->append->caseBuffer->new->ListBuffer<>->hashCodeCall->make->Ident->List->nil->makeCall->setType->switch1->make->caseBuffer->toList->Switch->foreach->hashToString->entrySet->hashCode->entry->getKey->stringsWithHashCode->entry->getValue->Assert->stringsWithHashCode->size->check->elsepart->foreach->stringEqualsCall->make->Ident->List->make->Literal->of->makeCall->make->make->make->make->Ident->make->caseLabelToPosition->get->Literal->Assign->setType->Exec->If->lb->new->ListBuffer<>->breakStmt->make->Break->lb->append->append->caseBuffer->make->make->Literal->lb->toList->Case->append->caseBuffer->toList->stmtList->append->lb->new->ListBuffer<>->switch2->make->make->Ident->lb->toList->Switch->foreach->patchTargets->isDefault->oneCase->getExpression->caseExpr->if->else->make->caseLabelToPosition->TreeInfo->oneCase->getExpression->skipParens->constValue->get->Literal->lb->make->oneCase->getStatements->Case->append->lb->toList->stmtList->append->return->make->stmtList->toList->Block
Lower#visitNewArray(JCNewArray)::: lower visit new array:::translate->for->t->types->elemtype->translate
Lower#visitSelect(JCFieldAccess)::: lower visit select:::qualifiedSuperAccess->hasTag->TreeInfo->name->types->isDirectSuperInterface->translate->if->classOf->else->if->types->isDirectSuperInterface->supSym->Assert->types->asSuper->checkNonNull->else->if->tree->pos->makeThis->else->access
Lower#visitLetExpr(LetExpr)::: lower visit let expr:::translateVarDefs->translate
Lower#visitAnnotation(JCAnnotation)::: lower visit annotation:::
Lower#visitTry(JCTry)::: lower visit try:::if->nonEmpty->makeTwrTry->return->hasBody->getStatements->nonEmpty->hasCatchers->nonEmpty->hasFinally->getStatements->nonEmpty->if->translate->return->if->if->translate->else->translate->return->super->visitTry
Lower#translateTopLevelClass(Env, JCTree, TreeMaker):::Translate a toplevel class and return a list consisting of  the translated class and translated versions of all inner classes.:::translated->try->cdef->hasTag->new->ListBuffer<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->WriteableScope->create->List->nil->new->HashMap<>->new->HashMap<>->new->HashMap<>->List->nil->new->ListBuffer<>->translate->for->l->accessed->toList->l->nonEmpty->foreach->enumSwitchMap->values->map->translate->toList->checkConflicts->checkAccessConstructorTags->catch->finally->enumSwitchMap->clear->return->translated->toList
MemberEnter#instance(Context)::: member enter instance:::instance->context->get->if->new->MemberEnter->return
MemberEnter#signature(MethodSymbol, List, List, JCTree, JCVariableDecl, List, Env):::Construct method type from method signature.:::tvars->enter->classEnter->attr->attribTypeVariables->argbuf->new->ListBuffer<>->for->l->l->nonEmpty->restype->attr->attribType->recvtype->if->memberEnter->else->thrownbuf->new->ListBuffer<>->for->l->l->nonEmpty->mtype->argbuf->toList->thrownbuf->toList->new->MethodType->return->tvars->isEmpty->new->ForAll
MemberEnter#memberEnter(JCTree, Env):::Enter field and method definitions and process import  clauses, catching any completion failure exceptions.:::prevEnv->try->tree->accept->catch->chk->tree->pos->completionError->finally
MemberEnter#memberEnter(List, Env):::Enter members from a list of trees.:::for->l->l->nonEmpty
MemberEnter#visitMethodDef(JCMethodDecl)::: member enter visit method def:::enclScope->enter->enterScope->m->new->MethodSymbol->chk->tree->pos->checkFlags->if->m->enclClass->localEnv->methodEnv->prevLintPos->deferredLintHandler->tree->pos->setPos->try->signature->catch->finally->deferredLintHandler->setPos->if->types->isSignaturePolymorphic->params->new->ListBuffer<>->lastParam->for->l->l->nonEmpty->params->toList->if->leave->if->chk->tree->pos->checkUnique->enclScope->enter->annotate->tree->pos->annotateLater->annotate->tree->pos->queueScanTreeAndTypeAnnotate->if->annotate->unfinishedDefaultValue->annotate->tree->pos->annotateDefaultValueLater
MemberEnter#methodEnv(JCMethodDecl, Env):::Create a fresh environment for method bodies.:::localEnv->env->dupUnshared->dup->dup->if->attr->getReturnType->new->ResultInfo->if->return
MemberEnter#visitVarDef(JCVariableDecl)::: member enter visit var def:::localEnv->if->flags->env->dup->dup->prevLintPos->deferredLintHandler->tree->pos->setPos->try->if->TreeInfo->isEnumInit->attr->attribIdentAsEnumType->else->if->tree->isImplicitlyTyped->attr->attribType->if->TreeInfo->isReceiverParam->checkReceiver->catch->finally->deferredLintHandler->setPos->if->atype->atype->makeVarargs->enclScope->enter->enterScope->vartype->tree->isImplicitlyTyped->v->new->VarSymbol->chk->tree->pos->checkFlags->if->if->needsLazyConstValue->initEnv->getInitEnv->v->initEnv->setLazyConstValue->if->chk->tree->pos->checkUnique->chk->tree->pos->checkTransparentVar->enclScope->enter->annotate->tree->pos->annotateLater->if->tree->isImplicitlyTyped->annotate->tree->pos->queueScanTreeAndTypeAnnotate
MemberEnter#checkType(JCTree, Type, Error)::: member enter check type:::if->isErroneous->types->isSameType->log->error
MemberEnter#checkReceiver(JCVariableDecl, Env)::: member enter check receiver:::attr->attribExpr->m->if->m->isConstructor->outertype->if->outertype->hasTag->if->outertype->hasTag->Errors->IncorrectConstructorReceiverType->checkType->Errors->IncorrectConstructorReceiverName->checkType->else->log->error->else->Errors->IncorrectReceiverType->checkType->Errors->IncorrectReceiverName->checkType
MemberEnter#needsLazyConstValue(JCTree)::: member enter needs lazy const value:::initTreeVisitor->new->InitTreeVisitor->tree->accept->return
MemberEnter.InitTreeVisitor#visitTree(JCTree)::: init tree visitor visit tree:::
MemberEnter.InitTreeVisitor#visitLiteral(JCLiteral)::: init tree visitor visit literal:::
MemberEnter.InitTreeVisitor#visitTypeCast(JCTypeCast)::: init tree visitor visit type cast:::accept
MemberEnter.InitTreeVisitor#visitUnary(JCUnary)::: init tree visitor visit unary:::if->ALLOWED_OPERATORS->that->getTag->contains->return->accept
MemberEnter.InitTreeVisitor#visitBinary(JCBinary)::: init tree visitor visit binary:::if->ALLOWED_OPERATORS->that->getTag->contains->return->accept->accept
MemberEnter.InitTreeVisitor#visitConditional(JCConditional)::: init tree visitor visit conditional:::accept->accept->accept
MemberEnter.InitTreeVisitor#visitParens(JCParens)::: init tree visitor visit parens:::accept
MemberEnter.InitTreeVisitor#visitIdent(JCIdent)::: init tree visitor visit ident:::
MemberEnter.InitTreeVisitor#visitSelect(JCFieldAccess)::: init tree visitor visit select:::accept
MemberEnter#initEnv(JCVariableDecl, Env):::Create a fresh environment for a variable's initializer:::localEnv->env->dup->new->AttrContextEnv->dupto->if->dupUnshared->if->flags->return
MemberEnter#visitTree(JCTree):::Default member enter visitor method: do nothing:::
MemberEnter#visitErroneous(JCErroneous)::: member enter visit erroneous:::if->memberEnter
MemberEnter#getMethodEnv(JCMethodDecl, Env)::: member enter get method env:::mEnv->methodEnv->augment->for->l->l->nonEmpty->for->l->l->nonEmpty->return
MemberEnter#getInitEnv(JCVariableDecl, Env)::: member enter get init env:::iEnv->initEnv->return
Modules#instance(Context)::: modules instance:::instance->context->get->if->new->Modules->return
Modules#addExtraAddModules(String...)::: modules add extra add modules:::extraAddMods->Arrays->asList->addAll
Modules#initModules(List)::: modules init modules:::Assert->check->try->Assert->checkNull->Assert->checkNull->Assert->checkNull->setupAllModules->Assert->checkNonNull->enter->catch->finally
Modules#enter(List, ClassSymbol)::: modules enter:::Assert->check->return->enter
Modules#enter(List, Consumer>, ClassSymbol)::: modules enter:::if->foreach->return->startErrors->try->roots->enterModules->setCompilationUnitModules->init->accept->foreach->msym->complete->catch->chk->completionError->finally->return
Modules#getCompleter()::: modules get completer:::return
Modules#getDefaultModule()::: modules get default module:::return
Modules#modulesInitialized()::: modules modules initialized:::return
Modules#enterModules(List, ClassSymbol)::: modules enter modules:::modules->new->LinkedHashSet<>->foreach->prev->log->useSource->try->enterModule->catch->finally->log->useSource->return
Modules#enterModule(JCCompilationUnit, ClassSymbol, Set)::: modules enter module:::isModuleInfo->isNameCompatible->isModuleDecl->toplevel->getModuleDecl->if->decl->toplevel->getModuleDecl->if->log->decl->pos->error->name->TreeInfo->fullName->sym->if->Assert->checkNonNull->treeName->TreeInfo->fullName->if->log->decl->pos->Errors->ModuleNameMismatch->error->else->syms->enterModule->if->log->decl->pos->Errors->DuplicateModule->error->return->getSourceCompleter->if->modules->isEmpty->modules->add->else->log->toplevel->pos->error->provisionalEnv->new->Env<>->typeEnvs->put->else->if->if->tree->isEmpty->log->tree->pos->error
Modules#setCompilationUnitModules(List, Set, ClassSymbol)::: modules set compilation unit modules:::if->checkNoAllModulePath->foreach->if->isEmpty->continue->prev->log->useSource->try->msplocn->getModuleLocation->plocn->fileManager->hasLocation->fileManager->getLocationForModule->if->name->names->fileManager->inferModuleName->fromString->msym->moduleFinder->findModule->rootModules->add->if->mspname->names->fileManager->inferModuleName->fromString->if->log->tree->pos->Errors->FilePatchedAndMsp->error->else->if->if->tree->getModuleDecl->canonical->fileManager->getJavaFileForInput->if->fileManager->isSameFile->log->tree->pos->error->name->names->fileManager->inferModuleName->fromString->msym->decl->tree->getModuleDecl->if->if->log->Errors->ModuleNameMismatch->error->else->if->tree->getPackage->log->tree->pos->error->syms->enterModule->if->if->fileManager->hasLocation->fileManager->toString->getLocationForModule->if->fileManager->hasLocation->outputLocn->fileManager->toString->getLocationForModule->if->else->rootModules->add->else->if->c->packge->else->if->tree->getModuleDecl->log->tree->pos->error->else->log->tree->pos->error->catch->throw->new->Error->finally->log->useSource->if->getUnnamedModuleCompleter->else->module->if->moduleOverride->singleModuleOverride->switch->rootModules->size->moduleFinder->findSingleModule->if->if->checkNoAllModulePath->moduleFinder->names->fromString->findModule->else->getUnnamedModuleCompleter->else->checkNoAllModulePath->defaultModule->complete->completeModule->rootModules->add->break->checkNoAllModulePath->rootModules->iterator->next->if->fileManager->hasLocation->try->fileManager->toString->getLocationForModule->catch->throw->new->Error->finally->if->else->break->Assert->error->else->if->rootModules->size->rootModules->iterator->next->module->complete->completeModule->else->Assert->rootModules->isEmpty->check->moduleOverride->singleModuleOverride->if->moduleFinder->names->fromString->findModule->else->rootModules->add->if->getUnnamedModuleCompleter->if->foreach->if->fileManager->hasLocation->checkSourceLocation
Modules#checkSourceLocation(JCCompilationUnit, ModuleSymbol)::: modules check source location:::try->fo->if->fileManager->contains->return->if->fileManager->contains->return->if->fileManager->hasLocation->if->fileManager->contains->return->else->if->fileManager->contains->return->catch->throw->new->Error->finally->prev->log->useSource->try->log->tree->pos->error->catch->finally->log->useSource
Modules#singleModuleOverride(List)::: modules single module override:::if->fileManager->hasLocation->return->override->new->LinkedHashSet<>->foreach->fo->try->loc->fileManager->getLocationForModule->if->override->fileManager->inferModuleName->add->catch->throw->new->Error->finally->switch->override->size->return->return->override->iterator->next->log->Errors->TooManyPatchedModules->error->return
Modules#getModuleLocation(JCCompilationUnit):::Determine the location for the module on the module source path or source output directory which contains a given CompilationUnit:::fo->loc->fileManager->getLocationForModule->if->sourceOutput->fileManager->hasLocation->fileManager->getLocationForModule->return
Modules#checkNoAllModulePath()::: modules check no all module path:::if->Arrays->addModsOpt->split->asList->contains->log->error
Modules#setupAutomaticModule(ModuleSymbol)::: modules setup automatic module:::try->directives->new->ListBuffer<>->exports->new->ListBuffer<>->seenPackages->new->HashSet<>->foreach->fileManager->EnumSet->of->list->binName->fileManager->inferBinaryName->pack->binName->lastIndexOf->binName->binName->lastIndexOf->substring->if->seenPackages->add->d->syms->names->fromString->enterPackage->new->ExportsDirective->directives->add->exports->add->exports->toList->List->nil->List->nil->List->nil->directives->toList->catch->throw->new->IllegalStateException->finally
Modules#completeAutomaticModule(ModuleSymbol)::: modules complete automatic module:::directives->new->ListBuffer<>->directives->addAll->requires->new->ListBuffer<>->foreach->allModules->if->continue->flags->EnumSet->of->EnumSet->noneOf->d->new->RequiresDirective->directives->add->requires->add->requiresUnnamed->new->RequiresDirective->directives->add->requires->add->requires->toList->directives->toList
Modules#getSourceCompleter(JCCompilationUnit)::: modules get source completer:::return->new->Completer
Modules#isRootModule(ModuleSymbol)::: modules is root module:::Assert->checkNonNull->return->rootModules->contains
Modules#getRootModules()::: modules get root modules:::Assert->checkNonNull->return
Modules.ModuleVisitor#visitModuleDef(JCModuleDecl)::: module visitor visit module def:::Assert->checkNonNull->if->tree->getModuleType->add->List->nil->List->nil->List->nil->t->accept->forEach->reverse->reverse->reverse->ensureJavaBase
Modules.ModuleVisitor#visitRequires(JCRequires)::: module visitor visit requires:::msym->lookupModule->if->log->pos->Errors->ModuleNotFound->error->warnedMissing->add->else->if->allRequires->contains->log->pos->Errors->DuplicateRequires->error->else->allRequires->add->flags->EnumSet->noneOf->if->if->source->compareTo->log->tree->pos->Errors->ModifierNotAllowedHere->error->else->flags->add->if->if->source->compareTo->log->tree->pos->Errors->EnumSet->of->ModNotAllowedHere->error->else->flags->add->d->new->RequiresDirective->prepend
Modules.ModuleVisitor#visitExports(JCExports)::: module visitor visit exports:::name->TreeInfo->fullName->packge->syms->enterPackage->attr->setPackageSymbols->exportsForPackage->allExports->List->nil->computeIfAbsent->foreach->reportExportsConflict->toModules->if->to->new->LinkedHashSet<>->foreach->msym->lookupModule->chk->n->pos->checkModuleExists->foreach->checkDuplicateExportsToModule->if->to->add->reportExportsConflictToModule->List->from->if->toModules->isEmpty->flags->EnumSet->noneOf->d->new->ExportsDirective->prepend->allExports->exportsForPackage->prepend->put
Modules.ModuleVisitor#reportExportsConflict(JCExports, PackageSymbol)::: module visitor report exports conflict:::log->pos->Errors->ConflictingExports->error
Modules.ModuleVisitor#checkDuplicateExportsToModule(JCExpression, ModuleSymbol, ExportsDirective)::: module visitor check duplicate exports to module:::if->foreach->if->reportExportsConflictToModule
Modules.ModuleVisitor#reportExportsConflictToModule(JCExpression, ModuleSymbol)::: module visitor report exports conflict to module:::log->name->pos->Errors->ConflictingExportsToModule->error
Modules.ModuleVisitor#visitOpens(JCOpens)::: module visitor visit opens:::name->TreeInfo->fullName->packge->syms->enterPackage->attr->setPackageSymbols->if->contains->log->tree->pos->error->opensForPackage->allOpens->List->nil->computeIfAbsent->foreach->reportOpensConflict->toModules->if->to->new->LinkedHashSet<>->foreach->msym->lookupModule->chk->n->pos->checkModuleExists->foreach->checkDuplicateOpensToModule->if->to->add->reportOpensConflictToModule->List->from->if->toModules->isEmpty->flags->EnumSet->noneOf->d->new->OpensDirective->prepend->allOpens->opensForPackage->prepend->put
Modules.ModuleVisitor#reportOpensConflict(JCOpens, PackageSymbol)::: module visitor report opens conflict:::log->pos->Errors->ConflictingOpens->error
Modules.ModuleVisitor#checkDuplicateOpensToModule(JCExpression, ModuleSymbol, OpensDirective)::: module visitor check duplicate opens to module:::if->foreach->if->reportOpensConflictToModule
Modules.ModuleVisitor#reportOpensConflictToModule(JCExpression, ModuleSymbol)::: module visitor report opens conflict to module:::log->name->pos->Errors->ConflictingOpensToModule->error
Modules.ModuleVisitor#visitProvides(JCProvides)::: module visitor visit provides:::
Modules.ModuleVisitor#visitUses(JCUses)::: module visitor visit uses:::
Modules.ModuleVisitor#ensureJavaBase()::: module visitor ensure java base:::if->return->foreach->if->return->java_base->syms->enterModule->d->EnumSet->of->new->Directive.RequiresDirective->prepend
Modules.ModuleVisitor#lookupModule(JCExpression)::: module visitor lookup module:::name->TreeInfo->fullName->msym->moduleFinder->findModule->TreeInfo->setSymbol->return
Modules#getUsesProvidesCompleter()::: modules get uses provides completer:::return->msym->msym->complete->env->typeEnvs->get->v->new->UsesProvidesVisitor->prev->log->useSource->decl->getModuleDecl->prevLintPos->deferredLintHandler->decl->pos->setPos->try->decl->accept->catch->finally->log->useSource->deferredLintHandler->setPos
Modules.UsesProvidesVisitor#visitModuleDef(JCModuleDecl)::: uses provides visitor visit module def:::List->nil->List->nil->List->nil->t->accept->forEach->reverse->reverse->reverse->if->nonEmpty->contains->prepend->List->addReads->Collections->emptySet->getOrDefault->from->appendList->checkForCorrectness
Modules.UsesProvidesVisitor#visitExports(JCExports)::: uses provides visitor visit exports:::packageContent->members->getSymbols->filesToCheck->List->nil->packageNotEmpty->foreach->if->continue->csym->if->isTerminal->getKind->List->nil->break->if->getKind->filesToCheck->prepend->foreach->if->findPackageInFile->findPackageNameOf->break->if->log->pos->Errors->PackageEmptyOrNotFound->error->prepend
Modules.UsesProvidesVisitor#visitOpens(JCOpens)::: uses provides visitor visit opens:::chk->checkPackageExistsForOpens->prepend
Modules.UsesProvidesVisitor#noArgsConstructor(ClassSymbol)::: uses provides visitor no args constructor:::foreach->tsym->members->getSymbolsByName->mSym->if->mSym->params->isEmpty->return->return
Modules.UsesProvidesVisitor#factoryMethod(ClassSymbol)::: uses provides visitor factory method:::foreach->tsym->members->getSymbolsByName->mSym->if->mSym->isStatic->mSym->flags->mSym->params->isEmpty->return->return
Modules.UsesProvidesVisitor#visitProvides(JCProvides)::: uses provides visitor visit provides:::st->attr->attribType->service->if->allProvides->containsKey->log->pos->Errors->RepeatedProvidesForService->error->impls->new->ListBuffer<>->foreach->it->prevVisitingServiceImplementation->try->attr->attribType->catch->finally->impl->if->log->implName->pos->Errors->impl->location->NotDefPublic->error->factory->factoryMethod->if->returnType->getReturnType->if->types->isSubtype->log->implName->pos->error->else->if->types->isSubtype->log->implName->pos->error->else->if->impl->flags->log->implName->pos->Errors->ServiceImplementationIsAbstract->error->else->if->impl->isInner->log->implName->pos->Errors->ServiceImplementationIsInner->error->else->constr->noArgsConstructor->if->log->implName->pos->Errors->ServiceImplementationDoesntHaveANoArgsConstructor->error->else->if->constr->flags->log->implName->pos->Errors->ServiceImplementationNoArgsConstructorNotPublic->error->if->it->hasTag->if->allProvides->new->HashSet<>->computeIfAbsent->add->impls->append->else->log->implName->pos->Errors->DuplicateProvides->error->if->st->hasTag->impls->isEmpty->d->impls->toList->new->Directive.ProvidesDirective->prepend->prepend->directiveToTreeMap->put
Modules.UsesProvidesVisitor#visitRequires(JCRequires)::: uses provides visitor visit requires:::if->allModules->contains->chk->pos->checkDeprecated->chk->pos->checkModuleRequires->prepend
Modules.UsesProvidesVisitor#visitUses(JCUses)::: uses provides visitor visit uses:::st->attr->attribType->sym->TreeInfo->symbol->if->sym->flags->log->pos->Errors->ServiceDefinitionIsEnum->error->else->if->st->hasTag->service->if->allUses->add->d->new->Directive.UsesDirective->prepend->prepend->else->log->tree->pos->Errors->DuplicateUses->error
Modules.UsesProvidesVisitor#checkForCorrectness()::: uses provides visitor check for correctness:::foreach->tree->directiveToTreeMap->get->foreach->implementationDefiningPackage->impl->packge->if->log->tree->pos->Errors->ServiceImplementationNotInRightModule->error->interfaceDeclaringPackage->packge->isInterfaceDeclaredInCurrentModule->isInterfaceExportedFromAReadableModule->get->if->warn->foreach->if->break->if->foreach->if->break->if->log->tree->pos->Warnings->ServiceProvidedButNotExportedOrUsed->warning
Modules#allModules()::: modules all modules:::Assert->checkNonNull->return
Modules#setupAllModules()::: modules setup all modules:::Assert->checkNonNull->Assert->checkNull->observable->if->extraLimitMods->isEmpty->else->limitMods->new->HashSet<>->if->foreach->limitModsOpt->split->if->isValidName->continue->limitMods->syms->names->fromString->enterModule->add->foreach->limitMods->syms->names->fromString->enterModule->add->computeTransitiveClosure->observable->addAll->if->foreach->if->observable->contains->log->Warnings->ModuleForOptionNotFound->warning->observablePred->moduleFinder->findModule->observable->contains->systemModulePred->sym->flags->enabledRoot->new->LinkedHashSet<>->if->rootModules->contains->jdkModulePred->if->target->allApiModulesAreRoots->sym->complete->return->stream->anyMatch->else->javaSE->syms->getModule->if->observable->contains->sym->complete->return->startsWith->stream->anyMatch->enabledRoot->add->else->noIncubatorPred->sym->complete->return->contains->foreach->syms->getAllModules->new->HashSet<>->try->if->systemModulePred->test->observablePred->test->jdkModulePred->test->noIncubatorPred->test->enabledRoot->add->catch->chk->completionError->finally->enabledRoot->addAll->if->extraAddMods->isEmpty->fullAddMods->new->HashSet<>->fullAddMods->addAll->if->fullAddMods->Arrays->addModsOpt->split->asList->addAll->foreach->modules->switch->syms->getAllModules->new->HashSet<>->stream->systemModulePred->and->filter->break->syms->getAllModules->new->HashSet<>->stream->systemModulePred->negate->and->filter->break->if->isValidName->continue->Stream->syms->names->fromString->enterModule->of->break->modules->enabledRoot->add->if->observable->add->forEach->result->computeTransitiveClosure->result->add->hasAutomatic->result->stream->anyMatch->if->syms->getAllModules->stream->filter->result->add->forEach->incubatingModules->result->stream->contains->filter->toString->map->Collectors->joining->collect->if->incubatingModules->isEmpty->log->Warnings->IncubatingModules->warning->if->version->names->fromString->rootModules->forEach
Modules#isInModuleGraph(ModuleSymbol)::: modules is in module graph:::return->allModules->contains
Modules#computeTransitiveClosure(Set, Set, Set)::: modules compute transitive closure:::primaryTodo->List->nil->secondaryTodo->List->nil->foreach->if->rootModules->contains->primaryTodo->prepend->else->secondaryTodo->prepend->result->new->LinkedHashSet<>->result->add->while->primaryTodo->nonEmpty->secondaryTodo->nonEmpty->try->current->isPrimaryTodo->if->primaryTodo->nonEmpty->else->if->observable->contains->continue->if->result->add->continue->current->complete->if->base->contains->warnedMissing->add->log->Errors->ModuleNotFound->error->foreach->if->continue->if->rd->isTransitive->rootModules->contains->primaryTodo->prepend->else->secondaryTodo->prepend->catch->chk->completionError->finally->return
Modules#getObservableModule(Name)::: modules get observable module:::mod->syms->getModule->if->allModules->contains->return->return
Modules#getUnnamedModuleCompleter()::: modules get unnamed module completer:::moduleFinder->findAllModules->return->new->Symbol.Completer
Modules#completeModule(ModuleSymbol)::: modules complete module:::if->completeModule->return->if->completeAutomaticModule->Assert->checkNonNull->initAddReads->List->addReads->Collections->emptySet->getOrDefault->from->appendList->requires->while->requires->nonEmpty->if->allModules->contains->env->typeEnvs->get->if->origSource->log->useSource->try->log->Errors->ModuleNotFound->error->catch->finally->log->useSource->else->Assert->msym->flags->check->List->filter->readable->new->LinkedHashSet<>->requiresTransitive->new->HashSet<>->foreach->complete->readable->add->s->retrieveRequiresTransitive->Assert->checkNonNull->readable->addAll->if->contains->requiresTransitive->add->requiresTransitive->addAll->requiresTransitiveCache->put->initVisiblePackages->foreach->if
Modules#retrieveRequiresTransitive(ModuleSymbol)::: modules retrieve requires transitive:::requiresTransitive->requiresTransitiveCache->get->if->new->HashSet<>->seen->new->HashSet<>->todo->List->of->while->todo->nonEmpty->current->if->seen->add->continue->requiresTransitive->add->current->complete->requires->if->Assert->checkNonNull->foreach->if->rd->isTransitive->todo->prepend->else->foreach->allModules->todo->prepend->requiresTransitive->remove->return
Modules#initVisiblePackages(ModuleSymbol, Collection)::: modules init visible packages:::initAddExports->new->LinkedHashMap<>->new->HashSet<>->seen->new->HashMap<>->foreach->if->continue->addVisiblePackages->addExports->if->contains->addVisiblePackages->forEach
Modules#addVisiblePackages(ModuleSymbol, Map, ModuleSymbol, Collection)::: modules add visible packages:::foreach->if->contains->packageName->previousModule->seenPackages->get->if->env->typeEnvs->get->origSource->log->useSource->pos->pos->try->if->msym->isUnnamed->log->Errors->PackageClashFromRequiresInUnnamed->error->else->log->Errors->PackageClashFromRequires->error->catch->finally->if->log->useSource->continue->seenPackages->put->put
Modules#initAddExports()::: modules init add exports:::if->return->new->LinkedHashMap<>->unknownModules->new->HashSet<>->if->return->ep->Pattern->compile->foreach->addExportsOpt->split->if->s->isEmpty->continue->em->ep->matcher->if->em->matches->continue->moduleName->em->group->packageName->em->group->targetNames->em->group->if->isValidName->continue->msym->syms->names->fromString->enterModule->if->isKnownModule->continue->if->isValidName->continue->if->msym->flags->log->Errors->AddExportsWithRelease->error->continue->p->syms->names->fromString->enterPackage->targetModules->List->nil->foreach->targetNames->split->m->if->toModule->equals->else->if->isValidName->continue->syms->names->fromString->enterModule->if->isKnownModule->continue->targetModules->prepend->extra->addExports->new->LinkedHashSet<>->computeIfAbsent->d->new->ExportsDirective->extra->add
Modules#isKnownModule(ModuleSymbol, Set)::: modules is known module:::if->allModules->contains->return->if->unknownModules->contains->if->log->Warnings->ModuleForOptionNotFound->warning->unknownModules->add->return
Modules#initAddReads()::: modules init add reads:::if->return->new->LinkedHashMap<>->if->return->rp->Pattern->compile->foreach->addReadsOpt->split->if->s->isEmpty->continue->rm->rp->matcher->if->rm->matches->continue->sourceName->rm->group->targetNames->rm->group->if->isValidName->continue->msym->syms->names->fromString->enterModule->if->allModules->contains->if->log->Warnings->ModuleForOptionNotFound->warning->continue->if->msym->flags->log->Errors->AddReadsWithRelease->error->continue->foreach->targetNames->split->targetModule->if->targetName->equals->else->if->isValidName->continue->syms->names->fromString->enterModule->if->allModules->contains->if->log->Warnings->ModuleForOptionNotFound->warning->continue->addReads->new->HashSet<>->computeIfAbsent->EnumSet->of->new->RequiresDirective->add
Modules#checkCyclicDependencies(JCModuleDecl)::: modules check cyclic dependencies:::foreach->rd->if->d->hasTag->continue->nonSyntheticDeps->new->HashSet<>->queue->List->of->while->queue->nonEmpty->current->if->nonSyntheticDeps->add->continue->current->complete->if->current->flags->continue->Assert->current->toString->checkNonNull->foreach->if->contains->queue->prepend->if->nonSyntheticDeps->contains->log->pos->Errors->CyclicRequires->error
Modules#isValidName(CharSequence)::: modules is valid name:::return->SourceVersion->Source->toSourceVersion->isName
Modules#toString(ModuleSymbol)::: modules to string:::return->toString->toString->toString->toString
Modules#toString(Location)::: modules to string:::return->locn->getName
Modules#toString(JavaFileObject)::: modules to string:::return->fo->getName
Modules#newRound()::: modules new round:::warnedMissing->clear
Modules.PackageNameFinder#findPackageNameOf(JavaFileObject)::: package name finder find package name of:::
Operators#instance(Context)::: operators instance:::instance->context->get->if->new->Operators->return
Operators#unaryPromotion(Type):::Perform unary promotion of a type; this routine implements JLS 5.6.1:::unboxed->types->unboxedTypeOrType->switch->unboxed->getTag->return->return
Operators#binaryPromotion(Type, Type):::Perform binary promotion of a pair of types; this routine implements JLS 5.6.2:::unboxedT1->types->unboxedTypeOrType->unboxedT2->types->unboxedTypeOrType->if->unboxedT1->isNumeric->unboxedT2->isNumeric->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->if->unboxedT1->hasTag->unboxedT2->hasTag->return->else->return->else->if->types->isSameType->return->else->return
Operators#resolveUnary(DiagnosticPosition, JCTree.Tag, Type):::Entry point for resolving a unary operator given an operator tag and an argument type.:::return->unop->test->unop->resolve->reportErrorIfNeeded->resolve
Operators#resolveBinary(DiagnosticPosition, JCTree.Tag, Type, Type):::Entry point for resolving a binary operator given an operator tag and a pair of argument types.:::return->binop->test->binop->resolve->reportErrorIfNeeded->resolve
Operators#resolve(Tag, Map>, Predicate, Function, Supplier):::Main operator lookup routine; lookup an operator (either unary or binary) in its corresponding map:::return->opMap->operatorName->get->stream->filter->map->findFirst->orElseGet
Operators#makeOperator(Name, List, OperatorType, int...):::Creates an operator symbol.:::opType->formals->stream->o->asType->map->List->collector->collect->res->asType->List->nil->new->MethodType->return->mergeOpcodes->new->OperatorSymbol
Operators#mergeOpcodes(int...):::Fold two opcodes in a single int value (if required).:::opcodesLen->Assert->check->return
Operators#reportErrorIfNeeded(DiagnosticPosition, Tag, Type...):::Report an operator lookup error.:::if->Stream->of->Type->isErroneous->noneMatch->opName->operatorName->opError->Errors->OperatorCantBeApplied->Errors->OperatorCantBeApplied1->log->error->return
Operators#operatorName(JCTree.Tag):::Return name of operator with given tree tag.:::return->tag->operatorIndex
Operators.OperatorHelper#doLookup(Predicate):::This routine implements the main operator lookup process:::return->Stream->alternatives->this->initOperators->orElseGet->of->filter->findFirst->orElse
Operators.OperatorHelper#initOperators():::This routine performs lazy instantiation of the operator symbols supported by this helper:::operators->operatorSuppliers->stream->Supplier->get->map->OperatorSymbol[]->new->toArray->Optional->of->return
Operators.UnaryOperatorHelper#doLookup(Type):::This routine implements the unary operator lookup process:::return->isUnaryOperatorApplicable->doLookup
Operators.UnaryOperatorHelper#isUnaryOperatorApplicable(OperatorSymbol, Type):::Unary operator applicability test - is the input type the same as the expected operand type?:::return->types->getParameterTypes->isSameType
Operators.UnaryOperatorHelper#addUnaryOperator(OperatorType, OperatorType, int...):::Adds a unary operator symbol.:::operatorSuppliers->List->of->makeOperator->prepend->return
Operators.UnaryOperatorHelper#resolve(Type):::This method will be overridden by unary operator helpers to provide custom resolution logic.:::
Operators.BinaryOperatorHelper#doLookup(Type, Type):::This routine implements the binary operator lookup process:::return->isBinaryOperatorApplicable->doLookup
Operators.BinaryOperatorHelper#isBinaryOperatorApplicable(OperatorSymbol, Type, Type):::Binary operator applicability test - are the input types the same as the expected operand types?:::formals->getParameterTypes->return->types->isSameType->types->isSameType
Operators.BinaryOperatorHelper#addBinaryOperator(OperatorType, OperatorType, OperatorType, int...):::Adds a binary operator symbol.:::operatorSuppliers->List->of->makeOperator->prepend->return
Operators.BinaryOperatorHelper#resolve(Type, Type):::This method will be overridden by binary operator helpers to provide custom resolution logic.:::
Operators.UnaryReferenceOperator#test(Type)::: unary reference operator test:::return->type->isNullOrReference
Operators.UnaryReferenceOperator#resolve(Type)::: unary reference operator resolve:::return->doLookup
Operators.UnaryNumericOperator#test(Type)::: unary numeric operator test:::return->numericTest->unaryPromotion->test
Operators.UnaryNumericOperator#resolve(Type)::: unary numeric operator resolve:::return->unaryPromotion->doLookup
Operators.UnaryBooleanOperator#test(Type)::: unary boolean operator test:::return->types->unboxedTypeOrType->hasTag
Operators.UnaryBooleanOperator#resolve(Type)::: unary boolean operator resolve:::return->doLookup
Operators.UnaryPrefixPostfixOperator#resolve(Type)::: unary prefix postfix operator resolve:::return->types->unboxedTypeOrType->doLookup
Operators.BinaryNumericOperator#resolve(Type, Type)::: binary numeric operator resolve:::t->binaryPromotion->return->doLookup
Operators.BinaryNumericOperator#test(Type, Type)::: binary numeric operator test:::return->numericTest->unaryPromotion->test->numericTest->unaryPromotion->test
Operators.BinaryBooleanOperator#resolve(Type, Type)::: binary boolean operator resolve:::return->doLookup
Operators.BinaryBooleanOperator#test(Type, Type)::: binary boolean operator test:::return->types->unboxedTypeOrType->hasTag->types->unboxedTypeOrType->hasTag
Operators.BinaryStringOperator#resolve(Type, Type)::: binary string operator resolve:::return->stringPromotion->stringPromotion->doLookup
Operators.BinaryStringOperator#test(Type, Type)::: binary string operator test:::hasStringOp->types->isSameType->types->isSameType->hasVoidOp->arg1->hasTag->arg2->hasTag->return
Operators.BinaryStringOperator#stringPromotion(Type):::This routine applies following mappings: - if input type is primitive, apply numeric promotion - if input type is either 'void', 'null' or 'String' leave it untouched - otherwise return 'Object':::if->t->isPrimitive->return->unaryPromotion->else->if->t->hasTag->t->hasTag->types->isSameType->return->else->if->t->hasTag->return->t->getUpperBound->stringPromotion->else->return
Operators.BinaryShiftOperator#resolve(Type, Type)::: binary shift operator resolve:::return->unaryPromotion->unaryPromotion->doLookup
Operators.BinaryShiftOperator#test(Type, Type)::: binary shift operator test:::op1->unaryPromotion->getTag->op2->unaryPromotion->getTag->return
Operators.BinaryEqualityOperator#test(Type, Type)::: binary equality operator test:::return->getKind
Operators.BinaryEqualityOperator#resolve(Type, Type)::: binary equality operator resolve:::kind->getKind->t->binaryPromotion->return->doLookup
Operators.BinaryEqualityOperator#getKind(Type, Type):::Retrieve the comparison kind associated with the given argument type pair.:::arg1Primitive->arg1->isPrimitive->arg2Primitive->arg2->isPrimitive->if->return->else->if->return->unaryPromotion->isPrimitive->else->if->return->unaryPromotion->isPrimitive->else->return->arg1->isNullOrReference->arg2->isNullOrReference
Operators#initUnaryOperators():::Initialize all unary operators.:::new->UnaryNumericOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->new->UnaryNumericOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->Type->isIntegral->new->UnaryNumericOperator->addUnaryOperator->addUnaryOperator->new->UnaryPrefixPostfixOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->new->UnaryPrefixPostfixOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->addUnaryOperator->new->UnaryBooleanOperator->addUnaryOperator->new->UnaryReferenceOperator->addUnaryOperator->initOperators
Operators#initBinaryOperators():::Initialize all binary operators.:::new->BinaryStringOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryBooleanOperator->addBinaryOperator->Type->isIntegral->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->new->BinaryBooleanOperator->addBinaryOperator->Type->isIntegral->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->new->BinaryBooleanOperator->addBinaryOperator->Type->isIntegral->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->new->BinaryShiftOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryShiftOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryShiftOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryNumericOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryEqualityOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryEqualityOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->addBinaryOperator->new->BinaryBooleanOperator->addBinaryOperator->new->BinaryBooleanOperator->addBinaryOperator->initOperators
Operators#lookupBinaryOp(Predicate)::: operators lookup binary op:::return->binaryOperators->values->stream->List->stream->flatMap->helper->doLookup->map->distinct->filter->findFirst->get
Operators#initOperators(Map>, O...):::Complete the initialization of an operator helper by storing it into the corresponding operator map.:::foreach->opName->helpers->opsMap->List->nil->getOrDefault->opsMap->helpers->prepend->put
Operators#initOperatorNames():::Initialize operator name array.:::setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName->setOperatorName
Operators#setOperatorName(Tag, String)::: operators set operator name:::names->fromString->setOperatorName
Operators#setOperatorName(Tag, Name)::: operators set operator name:::tag->operatorIndex
Resolve#instance(Context)::: resolve instance:::instance->context->get->if->new->Resolve->return
Resolve#bestOf(Symbol, Symbol)::: resolve best of:::return->betterThan
Resolve#reportVerboseResolutionDiagnostic(DiagnosticPosition, Name, Type, List, List, Symbol)::: resolve report verbose resolution diagnostic:::success->isResolutionError->if->verboseResolutionMode->contains->return->else->if->verboseResolutionMode->contains->return->if->verboseResolutionMode->contains->return->else->if->verboseResolutionMode->contains->return->else->if->verboseResolutionMode->contains->return->pos->mostSpecificPos->subDiags->new->ListBuffer<>->foreach->if->c->isApplicable->verboseResolutionMode->contains->c->isApplicable->verboseResolutionMode->contains->continue->else->subDiags->c->isApplicable->getVerboseApplicableCandidateDiag->getVerboseInapplicableCandidateDiag->append->if->key->argtypes2->argtypes->deferredAttr->new->RecoveryDeferredTypeMap->map->main->diags->log->currentSource->methodArguments->methodArguments->note->d->subDiags->toList->new->JCDiagnostic.MultilineDiagnostic->log->report
Resolve#getVerboseApplicableCandidateDiag(int, Symbol, Type)::: resolve get verbose applicable candidate diag:::subDiag->if->hasTag->diags->Fragments->PartialInstSig->fragment->key->return->diags->fragment
Resolve#getVerboseInapplicableCandidateDiag(int, Symbol, JCDiagnostic)::: resolve get verbose inapplicable candidate diag:::return->diags->Fragments->NotApplicableMethodFound->fragment
Resolve#isStatic(Env):::An environment is "static" if its static level is greater than  the one of its outer environment:::return
Resolve#isInitializer(Env):::An environment is an "initializer" if it is a constructor or  an instance initializer.:::owner->return->owner->isConstructor->owner->flags->owner->flags
Resolve#isAccessible(Env, TypeSymbol):::Is class accessible in given evironment?:::return->isAccessible
Resolve#isAccessible(Env, TypeSymbol, boolean)::: resolve is accessible:::if->return->if->c->packge->return->isAccessible->switch->c->flags->outermostClass->outermostClass->break->c->packge->break->break->if->currModule->currModule->complete->p->c->packge->get->contains->else->break->c->packge->isInnerSubClass->break->return->getEnclosingType->getEnclosingType->isAccessible
Resolve#isInnerSubClass(ClassSymbol, Symbol):::Is given class a subclass of given base class, or an inner class  of a subclass?  Return null if no such class exists.:::while->c->isSubClass->enclClass->return
Resolve#isAccessible(Env, Type)::: resolve is accessible:::return->isAccessible
Resolve#isAccessible(Env, Type, boolean)::: resolve is accessible:::return->t->hasTag->types->types->elemtype->cvarUpperBound->isAccessible->isAccessible
Resolve#isAccessible(Env, Type, Symbol):::Is symbol accessible as a member of given type in given environment?:::return->isAccessible
Resolve#isAccessible(Env, Type, Symbol, boolean)::: resolve is accessible:::if->return->if->return->if->sym->packge->return->switch->sym->flags->return->outermostClass->outermostClass->sym->isInheritedIn->return->sym->packge->isAccessible->sym->isInheritedIn->notOverriddenIn->return->sym->packge->isProtectedAccessible->sym->flags->isAccessible->notOverriddenIn->return->isAccessible->notOverriddenIn
Resolve#notOverriddenIn(Type, Symbol)::: resolve not overridden in:::if->sym->isConstructor->sym->isStatic->return->else->s2->implementation->return->types->types->memberType->types->memberType->isSubSignature
Resolve#isProtectedAccessible(Symbol, ClassSymbol, Type):::Is given protected symbol accessible if it is selected from given site  and the selection takes place in given class?:::newSite->site->hasTag->site->getUpperBound->while->c->isSubClass->c->flags->sym->flags->isSubClass->enclClass->return
Resolve#checkAccessibleType(Env, Type):::Performs a recursive scan of a type looking for accessibility problems from current attribution environment:::accessibilityChecker->visit
Resolve#rawInstantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner):::Try to instantiate the type of a method so that it fits  given type arguments and argument types:::mt->types->memberType->tvars->List->nil->if->List->nil->if->mt->hasTag->typeargtypes->nonEmpty->else->if->mt->hasTag->typeargtypes->nonEmpty->pmt->if->typeargtypes->length->length->throw->diags->Fragments->Integer->length->toString->WrongNumberTypeArgs->fragment->new->InapplicableMethodException->formals->actuals->while->formals->nonEmpty->actuals->nonEmpty->bounds->types->types->getBounds->subst->for->bounds->nonEmpty->types->subst->else->if->mt->hasTag->pmt->tvars1->types->newInstances->tvars->appendList->types->subst->instNeeded->for->l->if->return->infer->instantiateMethod->dc->currentResolutionContext->deferredAttrContext->mt->getParameterTypes->argumentsAcceptable->dc->complete->return
Resolve#checkMethod(Env, Type, Symbol, ResultInfo, List, List, Warner)::: resolve check method:::prevContext->try->new->MethodResolutionContext->if->hasTag->inferenceContext->new->MethodReferenceCheck->step->return->step->isBoxingRequired->step->isVarargsRequired->rawInstantiate->catch->finally
Resolve#instantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner):::Same but returns null instead throwing a NoInstanceException:::try->return->rawInstantiate->catch->return->finally
Resolve.MethodCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner):::Main method check routine:::
Resolve.MethodCheck#mostSpecificCheck(List):::Retrieve the method check object that will be used during a most specific check.:::
Resolve.AbstractMethodCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner)::: abstract method check arguments acceptable:::useVarargs->isVarargsRequired->callTree->treeForDiagnostics->trees->TreeInfo->args->inferenceContext->varargsFormal->formals->last->if->argtypes->size->formals->size->reportMC->while->argtypes->nonEmpty->pos->checkArg->if->reportMC->if->elt->types->elemtype->while->argtypes->nonEmpty->pos->checkArg
Resolve.AbstractMethodCheck#treeForDiagnostics(Env)::: abstract method check tree for diagnostics:::return
Resolve.AbstractMethodCheck#checkArg(DiagnosticPosition, boolean, Type, Type, DeferredAttrContext, Warner):::Does the actual argument conforms to the corresponding formal?:::
Resolve.AbstractMethodCheck#reportMC(DiagnosticPosition, MethodCheckDiag, InferenceContext, Object...)::: abstract method check report c:::inferDiag->if->equals->args2->new->ObjectArr->System->arraycopy->inferenceContext->inferenceVars->key->throw->infer->diags->log->currentSource->create->error->methodCheckFailure->diags->log->currentSource->create->setMessage
Resolve.AbstractMethodCheck.SharedInapplicableMethodException#setMessage(JCDiagnostic)::: shared inapplicable method exception set message:::return
Resolve.AbstractMethodCheck#mostSpecificCheck(List)::: abstract method check most specific check:::return
Resolve.MethodReferenceCheck#checkArg(DiagnosticPosition, boolean, Type, Type, DeferredAttrContext, Warner)::: method reference check check arg:::mresult->methodCheckResult->mresult->check
Resolve.MethodReferenceCheck#methodCheckResult(boolean, Type, DeferredAttr.DeferredAttrContext, Warner)::: method reference check method check result:::checkContext->isBoxingRequired->new->MethodCheckContext->return->new->MethodResultInfo
Resolve.MethodReferenceCheck#mostSpecificCheck(List)::: method reference check most specific check:::return->new->MostSpecificCheck
Resolve.MethodReferenceCheck#toString()::: method reference check to string:::return
Resolve.MethodCheckContext#compatible(Type, Type, Warner)::: method check context compatible:::inferenceContext->return->types->inferenceContext->asUndetVar->inferenceContext->asUndetVar->isSubtypeUnchecked->types->inferenceContext->asUndetVar->inferenceContext->asUndetVar->isConvertible
Resolve.MethodCheckContext#report(DiagnosticPosition, JCDiagnostic)::: method check context report:::throw->new->InapplicableMethodException
Resolve.MethodCheckContext#checkWarner(DiagnosticPosition, Type, Type)::: method check context check warner:::return
Resolve.MethodCheckContext#inferenceContext()::: method check context inference context:::return
Resolve.MethodCheckContext#deferredAttrContext()::: method check context deferred attr context:::return
Resolve.MethodCheckContext#toString()::: method check context to string:::return
Resolve.MethodResultInfo#check(DiagnosticPosition, Type)::: method result info check:::if->found->hasTag->dt->return->dt->check->else->uResult->U->capturedType->pos->getTree->types->capture->checkContext->inferenceContext->pos->getTree->cachedCapture->return->super->chk->checkNonVoid->check
Resolve.MethodResultInfo#U(Type):::javac has a long-standing 'simplification' (see 6391995): given an actual argument type, the method check is performed on its upper bound:::return->types->cvarUpperBound
Resolve.MethodResultInfo#dup(Type)::: method result info dup:::return->new->MethodResultInfo
Resolve.MethodResultInfo#dup(CheckContext)::: method result info dup:::return->new->MethodResultInfo
Resolve.MethodResultInfo#dup(Type, CheckContext)::: method result info dup:::return->new->MethodResultInfo
Resolve.MostSpecificCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner)::: most specific check arguments acceptable:::formals1->length->isVarargsRequired->adjustArgs->while->formals2->nonEmpty->mresult->methodCheckResult->mresult->check->actuals->isEmpty
Resolve.MostSpecificCheck#methodCheckResult(Type, DeferredAttr.DeferredAttrContext, Warner, Type):::Create a method check context to be used during the most specific applicability check:::return->attr->new->MostSpecificCheckContext->new->ResultInfo
Resolve.MostSpecificCheck.MostSpecificCheckContext#compatible(Type, Type, Warner)::: most specific check context compatible:::if->unrelatedFunctionalInterfaces->actual->getTag->dt->speculativeTree->dt->speculativeTree->if->return->functionalInterfaceMostSpecific->return->compatibleBySubtyping
Resolve.MostSpecificCheck.MostSpecificCheckContext#compatibleBySubtyping(Type, Type)::: most specific check context compatible by subtyping:::if->found->isPrimitive->req->isPrimitive->found->isPrimitive->types->boxedClass->types->unboxedType->return->types->asUndetVar->isSubtypeNoCapture
Resolve.MostSpecificCheck.MostSpecificCheckContext#unrelatedFunctionalInterfaces(Type, Type):::Whether t and s are unrelated functional interface types.:::return->types->isFunctionalInterface->types->isFunctionalInterface->unrelatedInterfaces
Resolve.MostSpecificCheck.MostSpecificCheckContext#unrelatedInterfaces(Type, Type):::Whether t and s are unrelated interface types; recurs on intersections:::if->t->isCompound->foreach->types->interfaces->if->unrelatedInterfaces->return->return->else->if->s->isCompound->foreach->types->interfaces->if->unrelatedInterfaces->return->return->else->return->types->asSuper->types->asSuper
Resolve.MostSpecificCheck.MostSpecificCheckContext#functionalInterfaceMostSpecific(Type, Type, JCTree):::Parameters t and s are unrelated functional interface types.:::tDesc->types->types->capture->findDescriptorType->tDescNoCapture->types->findDescriptorType->sDesc->types->findDescriptorType->tTypeParams->tDesc->getTypeArguments->tTypeParamsNoCapture->tDescNoCapture->getTypeArguments->sTypeParams->sDesc->getTypeArguments->if->tDesc->hasTag->types->hasSameBounds->return->tIter->sIter->while->tIter->nonEmpty->sIter->nonEmpty->tBound->getUpperBound->sBound->types->getUpperBound->subst->if->tBound->containsAny->inferenceContext->free->return->if->types->inferenceContext->asUndetVar->isSameType->return->if->tIter->isEmpty->sIter->isEmpty->return->tParams->tDesc->getParameterTypes->tParamsNoCapture->tDescNoCapture->getParameterTypes->sParams->sDesc->getParameterTypes->while->tParams->nonEmpty->tParamsNoCapture->nonEmpty->sParams->nonEmpty->tParam->tParamNoCapture->types->subst->sParam->types->subst->if->tParam->containsAny->inferenceContext->free->return->if->types->inferenceContext->asUndetVar->isSubtype->return->if->types->inferenceContext->asUndetVar->isSameType->return->if->tParams->isEmpty->tParamsNoCapture->isEmpty->sParams->isEmpty->return->tRet->tDesc->getReturnType->sRet->types->sDesc->getReturnType->subst->if->tRet->containsAny->inferenceContext->free->return->msc->new->MostSpecificFunctionReturnChecker->msc->scan->return
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#skip(JCTree)::: most specific function return checker skip:::
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitConditional(JCConditional)::: most specific function return checker visit conditional:::asExpr->scan->asExpr->scan
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitReference(JCMemberReference)::: most specific function return checker visit reference:::if->sRet->hasTag->else->if->tRet->hasTag->else->if->tRet->isPrimitive->sRet->isPrimitive->retValIsPrimitive->getReturnType->isPrimitive->tRet->isPrimitive->sRet->isPrimitive->else->compatibleBySubtyping
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitParens(JCParens)::: most specific function return checker visit parens:::asExpr->scan
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitLambda(JCLambda)::: most specific function return checker visit lambda:::if->sRet->hasTag->else->if->tRet->hasTag->else->lambdaResults->lambdaResults->if->lambdaResults->isEmpty->unrelatedFunctionalInterfaces->foreach->functionalInterfaceMostSpecific->else->if->lambdaResults->isEmpty->tRet->isPrimitive->sRet->isPrimitive->foreach->retValIsPrimitive->expr->isStandalone->isPrimitive->tRet->isPrimitive->sRet->isPrimitive->else->compatibleBySubtyping
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#lambdaResults(JCLambda)::: most specific function return checker lambda results:::if->lambda->getBodyKind->return->List->asExpr->of->else->buffer->new->ListBuffer<>->lambdaScanner->new->DeferredAttr.LambdaReturnScanner->lambdaScanner->scan->return->buffer->toList
Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#asExpr(JCExpression)::: most specific function return checker as expr:::if->hasTag->speculativeTree->speculativeTree->if->return
Resolve.MostSpecificCheck#mostSpecificCheck(List)::: most specific check most specific check:::Assert->error->return
Resolve.InapplicableMethodException#getDiagnostic()::: inapplicable method exception get diagnostic:::return
Resolve#findField(Env, Type, Name, TypeSymbol):::Find field:::while->hasTag->getUpperBound->bestSoFar->sym->foreach->c->members->getSymbolsByName->if->return->isAccessible->new->AccessError->st->types->supertype->if->st->hasTag->st->hasTag->findField->bestOf->for->l->types->interfaces->l->nonEmpty->return
Resolve#resolveInternalField(DiagnosticPosition, Env, Type, Name):::Resolve a field identifier, throw a fatal error if not found.:::sym->findField->if->return->else->throw->diags->Fragments->FatalErrCantLocateField->fragment->new->FatalError
Resolve#findVar(Env, Name):::Find unqualified variable or field with given name:::bestSoFar->env1->staticOnly->while->sym->if->isStatic->foreach->getSymbolsByName->if->break->if->findField->if->sym->exists->if->sym->flags->return->new->StaticError->else->return->else->bestOf->if->flags->sym->findField->if->sym->exists->return->if->bestSoFar->exists->return->origin->foreach->new->ScopeArr->foreach->sc->getSymbolsByName->if->continue->if->isResolutionError->return->new->AmbiguityError->else->if->betterThan->sc->getOrigin->isAccessible->new->AccessError->if->bestSoFar->exists->break->if->return->bestSoFar->clone->else->return
Resolve#selectBest(Env, Type, List, List, Symbol, Symbol, boolean, boolean):::Select the best method for a call site among two choices.:::if->sym->isInheritedIn->notOverriddenIn->return->else->if->sym->flags->return->isResolutionError->bestSoFar->baseSymbol->new->BadVarargsMethod->Assert->isResolutionError->check->try->clear->mt->rawInstantiate->currentResolutionContext->addApplicableCandidate->catch->currentResolutionContext->ex->getDiagnostic->addInapplicableCandidate->switch->return->new->InapplicableSymbolError->new->InapplicableSymbolsError->return->finally->if->isAccessible->return->new->AccessError->return->isResolutionError->mostSpecific
Resolve#mostSpecific(List, Symbol, Symbol, Env, Type, boolean)::: resolve most specific:::switch->if->return->m1SignatureMoreSpecific->signatureMoreSpecific->m2SignatureMoreSpecific->signatureMoreSpecific->if->mt1->types->memberType->mt2->types->memberType->if->types->overrideEquivalent->return->ambiguityError->if->m1->flags->m2->flags->return->m1->flags->if->m1->baseSymbol->m2->baseSymbol->return->m1Owner->m2Owner->if->if->types->asSuper->m1->overrides->return->if->types->asSuper->m2->overrides->return->m1Abstract->m1->flags->m2Abstract->m2->flags->if->return->if->return->return->ambiguityError->if->return->if->return->return->ambiguityError->e->m2->baseSymbol->m1MoreSpecificThanAnyAmbiguous->allAmbiguousMoreSpecificThanM1->foreach->moreSpecific->mostSpecific->if->return->if->e->addAmbiguousSymbol->return->throw->new->AssertionError
Resolve#signatureMoreSpecific(List, Env, Type, Symbol, Symbol, boolean)::: resolve signature more specific:::noteWarner->clear->maxLength->Math->Math->getParameterTypes->length->actuals->length->max->getParameterTypes->length->max->prevResolutionContext->try->new->MethodResolutionContext->mostSpecificCheck->mst->types->types->memberType->getParameterTypes->cvarLowerBounds->adjustArgs->instantiate->return->noteWarner->hasLint->catch->finally
Resolve#adjustArgs(List, Symbol, int, boolean)::: resolve adjust args:::if->msym->flags->varargsElem->types->args->last->elemtype->if->Assert->args->last->error->newArgs->args->reverse->prepend->reverse->while->newArgs->length->newArgs->newArgs->last->append->return->else->return
Resolve#ambiguityError(Symbol, Symbol)::: resolve ambiguity error:::if->m1->flags->m2->flags->return->m1->flags->else->return->new->AmbiguityError
Resolve#findMethodInScope(Env, Type, Name, List, List, Scope, Symbol, boolean, boolean, boolean)::: resolve find method in scope:::foreach->sc->new->LookupFilter->getSymbolsByName->selectBest->return
Resolve.LookupFilter#accepts(Symbol)::: lookup filter accepts:::flags->s->flags->return
Resolve#findMethod(Env, Type, Name, List, List, boolean, boolean):::Find best qualified method matching given name, type and value  arguments.:::bestSoFar->findMethod->return
Resolve#findMethod(Env, Type, Name, List, List, Type, Symbol, boolean, boolean)::: resolve find method:::itypes->new->ListArr->List->nil->List->nil->iphase->foreach->superclasses->s->members->findMethodInScope->if->return->iphase->update->if->foreach->types->interfaces->types->types->closure->iphase->ordinal->union->iphase->ordinal->concrete->isValid->bestSoFar->flags->foreach->InterfaceLookupPhase->values->foreach->iphase2->ordinal->if->itype->isInterface->continue->if->flags->continue->members->findMethodInScope->if->isValid->isValid->types->isSubSignature->return
Resolve#superclasses(Type):::Return an Iterable object to scan the superclasses of a given type:::return->new->Iterator<TypeSymbol>
Resolve#findFun(Env, Name, List, List, boolean, boolean):::Find unqualified method matching given name, type and value arguments.:::bestSoFar->env1->staticOnly->while->if->isStatic->Assert->check->try->sym->findMethod->if->sym->exists->if->sym->flags->return->new->StaticError->else->return->else->bestOf->catch->finally->if->flags->sym->findMethod->if->sym->exists->return->foreach->getSymbolsByName->origin->getOrigin->if->if->currentSym->clone->if->isAccessible->new->AccessError->selectBest->if->bestSoFar->exists->return->foreach->getSymbolsByName->origin->getOrigin->if->if->currentSym->clone->if->isAccessible->new->AccessError->selectBest->return
Resolve#loadClass(Env, Name, RecoveryLoadClass):::Load toplevel or member class with given fully qualified name and  verify that it is accessible.:::try->c->finder->loadClass->return->isAccessible->new->AccessError->catch->return->new->BadClassFileError->candidate->recoveryLoadClass->loadClass->if->return->return->finally
Resolve.RecoveryLoadClass#loadClass(Env, Name)::: recovery load class load class:::
Resolve#lookupPackage(Env, Name)::: resolve lookup package:::pack->syms->lookupPackage->if->isImportOnDemand->if->pack->members->isEmpty->return->syms->getPackagesForName->syms->enterPackage->sym->complete->return->sym->members->isEmpty->lookupInvisibleSymbol->return
Resolve#isImportOnDemand(Env, Name)::: resolve is import on demand:::if->hasTag->return->qualid->if->qualid->hasTag->return->if->TreeInfo->name->return->return->TreeInfo->fullName
Resolve#lookupInvisibleSymbol(Env, Name, Function>, BiFunction, Predicate, Symbol)::: resolve lookup invisible symbol:::candidates->get->apply->foreach->if->validate->test->return->createInvisibleSymbolError->recoverableModules->syms->getAllModules->new->HashSet<>->recoverableModules->add->recoverableModules->remove->foreach->if->if->moduleFinder->findModule->if->sym->load->apply->if->validate->test->return->createInvisibleSymbolError->return
Resolve#createInvisibleSymbolError(Env, Symbol)::: resolve create invisible symbol error:::if->symbolPackageVisible->return->new->AccessError->else->return->new->InvisibleSymbolError
Resolve#symbolPackageVisible(Env, Symbol)::: resolve symbol package visible:::envMod->symPack->sym->packge->return->containsKey
Resolve#findImmediateMemberType(Env, Type, Name, TypeSymbol):::Find a type declared in a scope (not inherited):::foreach->c->members->getSymbolsByName->if->return->isAccessible->new->AccessError->return
Resolve#findInheritedMemberType(Env, Type, Name, TypeSymbol):::Find a member type inherited from a superclass or interface.:::bestSoFar->sym->st->types->supertype->if->st->hasTag->findMemberType->bestOf->for->l->types->interfaces->l->nonEmpty->return
Resolve#findMemberType(Env, Type, Name, TypeSymbol):::Find qualified member type.:::sym->findImmediateMemberType->if->return->return->findInheritedMemberType
Resolve#findGlobalType(Env, Scope, Name, RecoveryLoadClass):::Find a global type in given scope and load corresponding class.:::bestSoFar->foreach->scope->getSymbolsByName->sym->s->flatName->loadClass->if->return->new->AmbiguityError->else->bestOf->return
Resolve#findTypeVar(Env, Name, boolean)::: resolve find type var:::foreach->getSymbolsByName->if->if->hasTag->return->new->StaticError->return->return
Resolve#findType(Env, Name):::Find an unqualified type symbol.:::if->return->bestSoFar->sym->staticOnly->for->env1->if->hasTag->findGlobalType->if->sym->exists->return->else->bestOf->findGlobalType->if->sym->exists->return->else->bestOf->members->findGlobalType->if->sym->exists->return->else->bestOf->findGlobalType->if->sym->exists->return->else->bestOf->return
Resolve#findIdent(Env, Name, KindSelector):::Find an unqualified identifier which matches a specified kind set.:::return->findIdentInternal->checkVarType
Resolve#findIdentInternal(Env, Name, KindSelector)::: resolve find ident internal:::bestSoFar->sym->if->kind->contains->findVar->if->sym->exists->return->else->bestOf->if->kind->contains->findType->if->sym->exists->return->else->bestOf->if->kind->contains->return->lookupPackage->else->return
Resolve#findIdentInPackage(Env, TypeSymbol, Name, KindSelector):::Find an identifier in a package which matches a specified kind set.:::return->findIdentInPackageInternal->checkVarType
Resolve#findIdentInPackageInternal(Env, TypeSymbol, Name, KindSelector)::: resolve find ident in package internal:::fullname->TypeSymbol->formFullName->bestSoFar->if->kind->contains->recoveryLoadClass->kind->contains->pck->exists->sym->loadClass->if->sym->exists->if->return->else->bestOf->if->kind->contains->return->lookupPackage->return
Resolve#findIdentInType(Env, Type, Name, KindSelector):::Find an identifier among the members of a given type `site'.:::return->findIdentInTypeInternal->checkVarType
Resolve#findIdentInTypeInternal(Env, Type, Name, KindSelector)::: resolve find ident in type internal:::bestSoFar->sym->if->kind->contains->findField->if->sym->exists->return->else->bestOf->if->kind->contains->findMemberType->if->sym->exists->return->else->bestOf->return
Resolve#checkVarType(Symbol, Name)::: resolve check var type:::if->name->equals->new->BadVarTypeError->return
Resolve#accessInternal(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List, LogResolveHelper):::If `sym' is a bad symbol: report error and return errSymbol  else pass through unchanged,  additional arguments duplicate what has been used in trying to find the  symbol (--> flyweight pattern):::if->isResolutionError->errSym->sym->baseSymbol->errSym->access->logResolveHelper->getArgumentTypes->if->logResolveHelper->resolveDiagnosticNeeded->logResolveError->return
Resolve#accessMethod(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List):::Variant of the generalized access routine, to be used for generating method resolution diagnostics:::return->accessInternal
Resolve#accessMethod(Symbol, DiagnosticPosition, Type, Name, boolean, List, List):::Same as original accessMethod(), but without location.:::return->accessMethod
Resolve#accessBase(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean):::Variant of the generalized access routine, to be used for generating variable, type resolution diagnostics:::return->List->nil->accessInternal
Resolve#accessBase(Symbol, DiagnosticPosition, Type, Name, boolean):::Same as original accessBase(), but without location.:::return->accessBase
Resolve.LogResolveHelper#resolveDiagnosticNeeded(Type, List, List)::: log resolve helper resolve diagnostic needed:::
Resolve.LogResolveHelper#getArgumentTypes(ResolveError, Symbol, Name, List)::: log resolve helper get argument types:::
Resolve.ResolveDeferredRecoveryMap#typeOf(DeferredType)::: resolve deferred recovery map type of:::res->super->typeOf->if->res->isErroneous->switch->TreeInfo->skipParens->getTag->return->return->return
Resolve#checkNonAbstract(DiagnosticPosition, Symbol):::Check that sym is not an abstract method.:::if->sym->flags->sym->flags->log->Errors->kindName->sym->location->AbstractCantBeAccessedDirectly->error
Resolve#resolveIdent(DiagnosticPosition, Env, Name, KindSelector):::Resolve an unqualified (non-method) identifier.:::return->findIdent->accessBase
Resolve#resolveMethod(DiagnosticPosition, Env, Name, List, List):::Resolve an unqualified method identifier.:::return->new->BasicLookupHelper->lookupMethod
Resolve#resolveQualifiedMethod(DiagnosticPosition, Env, Type, Name, List, List):::Resolve a qualified method identifier:::return->resolveQualifiedMethod
Resolve#resolveQualifiedMethod(DiagnosticPosition, Env, Symbol, Type, Name, List, List)::: resolve resolve qualified method:::return->new->MethodResolutionContext->resolveQualifiedMethod
Resolve#resolveQualifiedMethod(MethodResolutionContext, DiagnosticPosition, Env, Symbol, Type, Name, List, List)::: resolve resolve qualified method:::return->new->BasicLookupHelper->lookupMethod
Resolve#findPolymorphicSignatureInstance(Env, Symbol, List):::Find or create an implicit method of exactly the given type (after erasure):::mtype->infer->instantiatePolymorphicSignatureInstance->return->findPolymorphicSignatureInstance
Resolve#findPolymorphicSignatureInstance(Symbol, Type)::: resolve find polymorphic signature instance:::foreach->polymorphicSignatureScope->getSymbolsByName->if->types->isSameType->return->flags->spMethod->flags->msym->new->MethodSymbol->if->mtype->isErroneous->polymorphicSignatureScope->enter->return
Resolve#resolveInternalMethod(DiagnosticPosition, Env, Type, Name, List, List):::Resolve a qualified method identifier, throw a fatal error if not  found.:::resolveContext->new->MethodResolutionContext->sym->resolveQualifiedMethod->if->return->else->throw->diags->Fragments->FatalErrCantLocateMeth->fragment->new->FatalError
Resolve#resolveConstructor(DiagnosticPosition, Env, Type, List, List):::Resolve constructor.:::return->new->MethodResolutionContext->resolveConstructor
Resolve#resolveConstructor(MethodResolutionContext, DiagnosticPosition, Env, Type, List, List)::: resolve resolve constructor:::return->new->BasicLookupHelper->lookupMethod
Resolve#resolveInternalConstructor(DiagnosticPosition, Env, Type, List, List):::Resolve a constructor, throw a fatal error if not found.:::resolveContext->new->MethodResolutionContext->sym->resolveConstructor->if->return->else->throw->diags->Fragments->FatalErrCantLocateCtor->fragment->new->FatalError
Resolve#findConstructor(DiagnosticPosition, Env, Type, List, List, boolean, boolean)::: resolve find constructor:::sym->findMethod->chk->checkDeprecated->return
Resolve#resolveDiamond(DiagnosticPosition, Env, Type, List, List):::Resolve constructor using diamond inference.:::return->new->BasicLookupHelper->lookupMethod
Resolve#findDiamond(Env, Type, List, List, boolean, boolean):::This method scans all the constructor symbol in a given class scope -  assuming that the original scope contains a constructor of the kind:  Foo(X x, Y y), where X,Y are class type-variables declared in Foo,  a method check is executed against the modified constructor type:  <X,Y>Foo<X,Y>(X x, Y y):::bestSoFar->tsym->isInterface->foreach->tsym->members->getSymbolsByName->if->oldParams->hasTag->List->nil->constrType->getTypeArguments->appendList->types->asMethodType->createMethodTypeWithReturn->new->ForAll->newConstr->sym->flags->new->MethodSymbol->selectBest->return
Resolve#getMemberReference(DiagnosticPosition, Env, JCMemberReference, Type, Name)::: resolve get member reference:::types->capture->lookupHelper->List->nil->makeReferenceLookupHelper->newEnv->env->dup->dup->sym->pos->lookupMethod->return
Resolve#makeReferenceLookupHelper(JCMemberReference, Type, Name, List, List, MethodResolutionPhase)::: resolve make reference lookup helper:::if->name->equals->return->new->MethodReferenceLookupHelper->else->if->site->hasTag->return->new->ArrayConstructorReferenceLookupHelper->else->return->new->ConstructorReferenceLookupHelper
Resolve#resolveMemberReference(Env, JCMemberReference, Type, Name, List, List, Type, MethodCheck, InferenceContext, ReferenceChooser):::Resolution of member references is typically done as a single overload resolution step, where the argument types A are inferred from the target functional descriptor:::boundLookupHelper->makeReferenceLookupHelper->boundEnv->env->dup->dup->boundSearchResolveContext->new->MethodResolutionContext->boundSym->pos->lookupMethod->boundRes->new->ReferenceLookupResult->unboundSym->unboundEnv->env->dup->dup->unboundLookupHelper->boundLookupHelper->unboundLookup->unboundRes->if->unboundSearchResolveContext->new->MethodResolutionContext->pos->lookupMethod->new->ReferenceLookupResult->res->bestRes->referenceChooser->result->new->Pair<>->if->isResolutionError->msym->if->msym->flags->findPolymorphicSignatureInstance->new->Pair<>->return
Resolve.ReferenceLookupResult#staticKind(Symbol, MethodResolutionContext)::: reference lookup result static kind:::switch->return->stream->c->isApplicable->filter->StaticKind->from->map->StaticKind->reduce->reduce->orElse->return
Resolve.ReferenceLookupResult#isSuccess():::Does this result corresponds to a successful lookup (i.e:::return
Resolve.ReferenceLookupResult#hasKind(StaticKind):::Does this result have given static kind?:::return
Resolve.ReferenceLookupResult#canIgnore():::Error recovery helper: can this lookup result be ignored (for the purpose of returning some 'better' result) ?:::switch->return->errSym->sym->baseSymbol->return->regex->new->Template->errSym->errCandidate->matches->errSyms->sym->baseSymbol->return->errSyms->errSyms->mapCandidates->filterCandidates->isEmpty->return
Resolve.ReferenceLookupResult#error(Symbol)::: reference lookup result error:::return->new->ReferenceLookupResult
Resolve.ReferenceChooser#result(ReferenceLookupResult, ReferenceLookupResult):::Generate a result from a pair of lookup result objects:::return->unboundResult->boundResult
Resolve.ReferenceChooser#boundResult(ReferenceLookupResult):::Generate a symbol from a given bound lookup result.:::
Resolve.ReferenceChooser#unboundResult(ReferenceLookupResult, ReferenceLookupResult):::Generate a symbol from a pair of bound/unbound lookup results.:::
Resolve.LookupHelper#shouldStop(Symbol, MethodResolutionPhase):::Should lookup stop at given phase with given result:::return->phase->ordinal->maxPhase->ordinal->isResolutionError
Resolve.LookupHelper#lookup(Env, MethodResolutionPhase):::Search for a symbol under a given overload resolution phase - this method is usually called several times, once per each overload resolution phase:::
Resolve.LookupHelper#debug(DiagnosticPosition, Symbol):::Dump overload resolution info:::
Resolve.LookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol):::Validate the result of the lookup:::
Resolve.BasicLookupHelper#lookup(Env, MethodResolutionPhase)::: basic lookup helper lookup:::sym->doLookup->if->a_err->sym->baseSymbol->a_err->mergeAbstracts->return
Resolve.BasicLookupHelper#doLookup(Env, MethodResolutionPhase)::: basic lookup helper do lookup:::
Resolve.BasicLookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol)::: basic lookup helper access:::if->isResolutionError->accessMethod->return
Resolve.BasicLookupHelper#debug(DiagnosticPosition, Symbol)::: basic lookup helper debug:::reportVerboseResolutionDiagnostic
Resolve.ReferenceLookupHelper#unboundLookup(InferenceContext):::Returns an unbound version of this lookup helper:::return
Resolve.ReferenceLookupHelper#referenceKind(Symbol):::Get the kind of the member reference:::
Resolve.ReferenceLookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol)::: reference lookup helper access:::if->a_err->sym->baseSymbol->a_err->mergeAbstracts->return
Resolve.MethodReferenceLookupHelper#lookup(Env, MethodResolutionPhase)::: method reference lookup helper lookup:::return->phase->isBoxingRequired->phase->isVarargsRequired->findMethod
Resolve.MethodReferenceLookupHelper#unboundLookup(InferenceContext)::: method reference lookup helper unbound lookup:::if->TreeInfo->isStaticSelector->if->argtypes->nonEmpty->hasTag->types->inferenceContext->asUndetVar->isSubtypeUnchecked->return->new->UnboundMethodReferenceLookupHelper->else->return->new->ReferenceLookupHelper->else->return->super->unboundLookup
Resolve.MethodReferenceLookupHelper#referenceKind(Symbol)::: method reference lookup helper reference kind:::if->sym->isStatic->return->else->selName->TreeInfo->referenceTree->getQualifierExpression->name->return
Resolve.UnboundMethodReferenceLookupHelper#unboundLookup(InferenceContext)::: unbound method reference lookup helper unbound lookup:::return
Resolve.UnboundMethodReferenceLookupHelper#referenceKind(Symbol)::: unbound method reference lookup helper reference kind:::return
Resolve.ArrayConstructorReferenceLookupHelper#lookup(Env, MethodResolutionPhase)::: array constructor reference lookup helper lookup:::sc->WriteableScope->create->arrayConstr->new->MethodSymbol->List->of->List->nil->new->MethodType->sc->enter->return->phase->isBoxingRequired->phase->isVarargsRequired->findMethodInScope
Resolve.ArrayConstructorReferenceLookupHelper#referenceKind(Symbol)::: array constructor reference lookup helper reference kind:::return
Resolve.ConstructorReferenceLookupHelper#lookup(Env, MethodResolutionPhase)::: constructor reference lookup helper lookup:::sym->phase->isBoxingRequired->phase->isVarargsRequired->findDiamond->phase->isBoxingRequired->phase->isVarargsRequired->findMethod->return->enclosingInstanceMissing->new->BadConstructorReferenceError
Resolve.ConstructorReferenceLookupHelper#referenceKind(Symbol)::: constructor reference lookup helper reference kind:::return->site->getEnclosingType->hasTag
Resolve#lookupMethod(Env, DiagnosticPosition, Symbol, MethodCheck, LookupHelper):::Main overload resolution routine:::resolveContext->new->MethodResolutionContext->return->lookupMethod
Resolve#lookupMethod(Env, DiagnosticPosition, Symbol, MethodResolutionContext, LookupHelper)::: resolve lookup method:::prevResolutionContext->try->bestSoFar->foreach->if->lookupHelper->shouldStop->break->prevPhase->prevBest->sym->lookupHelper->lookup->lookupHelper->debug->phase->mergeResults->return->lookupHelper->access->catch->finally
Resolve#resolveSelf(DiagnosticPosition, Env, TypeSymbol, Name):::Resolve `c.name' where name == this or name == super.:::env1->staticOnly->while->if->isStatic->if->sym->findFirst->if->if->new->StaticError->return->accessBase->if->flags->if->c->isInterface->isStatic->types->isDirectSuperInterface->foreach->pruneInterfaces->if->return->types->asSuper->new->VarSymbol->foreach->types->directSupertypes->if->isSubClass->log->Errors->Fragments->RedundantSupertype->IllegalDefaultSuperCall->error->return->Assert->error->log->Errors->NotEnclClass->error->return
Resolve#pruneInterfaces(Type)::: resolve prune interfaces:::result->new->ListBuffer<>->foreach->types->interfaces->shouldAdd->foreach->types->directSupertypes->if->types->isSubtypeNoCapture->if->result->append->return->result->toList
Resolve#resolveSelfContaining(DiagnosticPosition, Env, Symbol, boolean):::Resolve `c.this' for an enclosing class c that contains the named member.:::sym->resolveSelfContainingInternal->if->log->Errors->EnclClassRequired->error->return->else->return->accessBase
Resolve#enclosingInstanceMissing(Env, Type)::: resolve enclosing instance missing:::if->type->hasTag->type->getEnclosingType->hasTag->encl->resolveSelfContainingInternal->return->isResolutionError->return
Resolve#resolveSelfContainingInternal(Env, Symbol, boolean)::: resolve resolve self containing internal:::name->env1->staticOnly->if->while->if->isStatic->if->enclClass->isSubClass->sym->findFirst->if->if->new->StaticError->return->if->flags->return
Resolve#resolveImplicitThis(DiagnosticPosition, Env, Type):::Resolve an appropriate implicit this instance for t's container:::return->resolveImplicitThis
Resolve#resolveImplicitThis(DiagnosticPosition, Env, Type, boolean)::: resolve resolve implicit this:::thisType->matches->t->getEnclosingType->resolveSelf->resolveSelfContaining->if->log->Errors->CantRefBeforeCtorCalled->error->return
Resolve#logAccessErrorInternal(Env, JCTree, Type)::: resolve log access error internal:::error->new->AccessError->tree->pos->logResolveError
Resolve#logResolveError(ResolveError, DiagnosticPosition, Symbol, Type, Name, List, List)::: resolve log resolve error:::d->error->getDiagnostic->if->d->setFlag->log->report
Resolve#methodArguments(List)::: resolve method arguments:::if->argtypes->isEmpty->return->else->diagArgs->new->ListBuffer<>->foreach->if->t->hasTag->diagArgs->append->else->diagArgs->append->return
Resolve.ResolveError#accept(ElementVisitor, P)::: resolve error accept:::throw->new->AssertionError
Resolve.ResolveError#toString()::: resolve error to string:::return
Resolve.ResolveError#exists()::: resolve error exists:::return
Resolve.ResolveError#isStatic()::: resolve error is static:::return
Resolve.ResolveError#access(Name, TypeSymbol):::Create an external representation for this erroneous symbol to be used during attribution - by default this returns the symbol of a brand new error type which stores the original type found during resolution.:::return->types->createErrorType
Resolve.ResolveError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List):::Create a diagnostic representing this resolution error.:::
Resolve.InvalidSymbolError#exists()::: invalid symbol error exists:::return
Resolve.InvalidSymbolError#toString()::: invalid symbol error to string:::return->super->toString
Resolve.InvalidSymbolError#access(Name, TypeSymbol)::: invalid symbol error access:::if->isResolutionError->matches->return->types->createErrorType->else->return
Resolve.BadVarTypeError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: bad var type error get diagnostic:::return->diags->log->currentSource->create
Resolve.SymbolNotFoundError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: symbol not found error get diagnostic:::List->nil->List->nil->if->return->hasLocation->if->if->isEmpty->if->exists->return->diags->log->currentSource->create->equals->equals->isConstructor->kindname->kind->absentKind->idname->errKey->typeargtypes->nonEmpty->getErrorKey->if->return->diags->log->currentSource->args->getLocationDiag->create->else->return->diags->log->currentSource->args->create
Resolve.SymbolNotFoundError#args(List)::: symbol not found error args:::return->args->isEmpty->methodArguments
Resolve.SymbolNotFoundError#getErrorKey(KindName, boolean, boolean)::: symbol not found error get error key:::key->suffix->switch->return
Resolve.SymbolNotFoundError#getLocationDiag(Symbol, Type)::: symbol not found error get location diag:::if->return->diags->Fragments->kindName->Location1->fragment->else->return->diags->Fragments->typeKindName->Location->fragment
Resolve.InapplicableSymbolError#toString()::: inapplicable symbol error to string:::return->super->toString
Resolve.InapplicableSymbolError#exists()::: inapplicable symbol error exists:::return
Resolve.InapplicableSymbolError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: inapplicable symbol error get diagnostic:::if->return->c->errCandidate->if->simpleDiag->MethodResolutionDiagHelper->log->currentSource->rewrite->if->return->ws->asMemberOf->return->diags->log->currentSource->kindName->getParameterTypes->methodArguments->methodArguments->kindName->create
Resolve.InapplicableSymbolError#access(Name, TypeSymbol)::: inapplicable symbol error access:::return->types->createErrorType
Resolve.InapplicableSymbolError#errCandidate()::: inapplicable symbol error err candidate:::bestSoFar->foreach->if->c->isApplicable->continue->Assert->checkNonNull->return->new->Pair<>
Resolve.InapplicableSymbolsError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: inapplicable symbols error get diagnostic:::candidatesMap->mapCandidates->filteredCandidates->filterCandidates->mapCandidates->if->filteredCandidates->isEmpty->truncatedDiag->candidatesMap->size->filteredCandidates->size->if->filteredCandidates->size->err->diags->EnumSet->of->EnumSet->noneOf->log->currentSource->kind->absentKind->methodArguments->create->return->candidateDetails->new->JCDiagnostic.MultilineDiagnostic->else->if->filteredCandidates->size->_e->filteredCandidates->entrySet->iterator->next->p->_e->getKey->_e->getValue->new->Pair<>->d->new->InapplicableSymbolError->getDiagnostic->if->d->setFlag->return->else->return->new->SymbolNotFoundError->getDiagnostic
Resolve.InapplicableSymbolsError#mapCandidates()::: inapplicable symbols error map candidates:::candidates->new->MostSpecificMap->foreach->if->c->isApplicable->continue->candidates->put->return
Resolve.InapplicableSymbolsError.MostSpecificMap#put(Candidate)::: most specific map put:::overridden->new->ListBuffer<>->foreach->keySet->if->continue->if->overrides->overridden->add->else->if->s->overrides->return->foreach->remove->put
Resolve.InapplicableSymbolsError#filterCandidates(Map)::: inapplicable symbols error filter candidates:::candidates->new->LinkedHashMap<>->foreach->candidatesMap->entrySet->d->_entry->getValue->if->regex->new->Template->matches->candidates->_entry->getKey->put->return
Resolve.InapplicableSymbolsError#candidateDetails(Map, Type)::: inapplicable symbols error candidate details:::details->List->nil->foreach->candidatesMap->entrySet->sym->_entry->getKey->detailDiag->diags->Fragments->Kinds->kindName->sym->location->sym->asMemberOf->_entry->getValue->InapplicableMethod->fragment->details->prepend->return
Resolve.DiamondError#getDetails()::: diamond error get details:::return->sym->baseSymbol->errCandidate
Resolve.DiamondError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: diamond error get diagnostic:::details->getDetails->if->simpleDiag->MethodResolutionDiagHelper->log->currentSource->rewrite->if->return->key->return->diags->log->currentSource->Fragments->Diamond->create
Resolve.AccessError#exists()::: access error exists:::return
Resolve.AccessError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: access error get diagnostic:::if->return->new->SymbolNotFoundError->getDiagnostic->else->if->sym->flags->isAccessible->if->return->diags->log->currentSource->sym->location->sym->packge->inaccessiblePackageReason->create->else->if->sym->packge->symbolPackageVisible->return->diags->log->currentSource->sym->location->sym->location->packge->sym->packge->inaccessiblePackageReason->create->else->return->diags->log->currentSource->sym->location->create->else->if->sym->flags->return->diags->log->currentSource->sym->flags->asFlagSet->sym->location->create->else->return->diags->log->currentSource->sym->location->create
Resolve.AccessError#toString(Type)::: access error to string:::sb->new->StringBuilder->sb->append->if->sb->append->append->if->sb->append->packge->append->sb->append->return->sb->toString
Resolve.InvisibleSymbolError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: invisible symbol error get diagnostic:::if->return->if->details->sym->packge->inaccessiblePackageReason->return->diags->log->currentSource->create->details->sym->packge->inaccessiblePackageReason->if->pos->getTree->o->tree->pos->getTree->while->tree->hasTag->if->tree->pos->return->diags->log->currentSource->create->return->diags->log->currentSource->sym->packge->create
Resolve#inaccessiblePackageReason(Env, PackageSymbol)::: resolve inaccessible package reason:::if->contains->if->if->return->diags->Fragments->NotDefAccessDoesNotRead->fragment->else->return->diags->Fragments->NotDefAccessDoesNotReadFromUnnamed->fragment->else->return->diags->Fragments->NotDefAccessDoesNotReadUnnamed->fragment->else->if->sym->packge->stream->anyMatch->if->return->diags->Fragments->NotDefAccessNotExportedToModule->fragment->else->return->diags->Fragments->NotDefAccessNotExportedToModuleFromUnnamed->fragment->else->if->return->diags->Fragments->NotDefAccessNotExported->fragment->else->return->diags->Fragments->NotDefAccessNotExportedFromUnnamed->fragment
Resolve.StaticError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: static error get diagnostic:::errSym->hasTag->types->erasure->return->diags->log->currentSource->kindName->create
Resolve.AmbiguityError#exists()::: ambiguity error exists:::return
Resolve.AmbiguityError#flatten(Symbol)::: ambiguity error flatten:::if->return->sym->baseSymbol->else->return->List->of
Resolve.AmbiguityError#addAmbiguousSymbol(Symbol)::: ambiguity error add ambiguous symbol:::ambiguousSyms->prepend->return
Resolve.AmbiguityError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: ambiguity error get diagnostic:::diagSyms->ambiguousSyms->reverse->s1->s2->sname->if->return->diags->log->currentSource->kindName->s1->location->kindName->s2->location->create
Resolve.AmbiguityError#mergeAbstracts(Type):::If multiple applicable methods are found during overload and none of them is more specific than the others, attempt to merge their signatures.:::ambiguousInOrder->ambiguousSyms->reverse->return->types->mergeAbstracts->orElse
Resolve.AmbiguityError#access(Name, TypeSymbol)::: ambiguity error access:::firstAmbiguity->ambiguousSyms->last->return->types->createErrorType
Resolve.BadVarargsMethod#baseSymbol()::: bad varargs method base symbol:::return->delegatedError->baseSymbol
Resolve.BadVarargsMethod#access(Name, TypeSymbol)::: bad varargs method access:::return->delegatedError->access
Resolve.BadVarargsMethod#exists()::: bad varargs method exists:::return
Resolve.BadVarargsMethod#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: bad varargs method get diagnostic:::return->delegatedError->getDiagnostic
Resolve.BadMethodReferenceError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: bad method reference error get diagnostic:::key->if->else->if->sym->isStatic->else->return->isResolutionError->getDiagnostic->diags->log->currentSource->Kinds->kindName->create
Resolve.BadConstructorReferenceError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: bad constructor reference error get diagnostic:::return->diags->log->currentSource->site->getEnclosingType->create
Resolve.BadClassFileError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)::: bad class file error get diagnostic:::d->diags->log->currentSource->ex->getDetailValue->create->d->setFlag->return
Resolve.MethodResolutionDiagHelper.DiagnosticRewriter#rewriteDiagnostic(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic)::: diagnostic rewriter rewrite diagnostic:::
Resolve.MethodResolutionDiagHelper.Template#matches(Object):::Returns true if the regex matches the diagnostic key and if all diagnostic arguments are matches by corresponding sub-templates.:::d->args->d->getArgs->if->d->getCode->matches->d->getArgs->return->for->i->return
Resolve.MethodResolutionDiagHelper.ArgMismatchRewriter#rewriteDiagnostic(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic)::: arg mismatch rewriter rewrite diagnostic:::cause->d->getArgs->pos->d->getDiagnosticPosition->if->return->diags->create
Resolve.MethodResolutionDiagHelper#rewrite(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic):::Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it, and rewrite it accordingly.:::foreach->rewriters->entrySet->if->_entry->getKey->matches->simpleDiag->_entry->getValue->rewriteDiagnostic->simpleDiag->setFlag->return->return
Resolve.MethodResolutionContext#addInapplicableCandidate(Symbol, JCDiagnostic)::: method resolution context add inapplicable candidate:::c->new->Candidate->candidates->append
Resolve.MethodResolutionContext#addApplicableCandidate(Symbol, Type)::: method resolution context add applicable candidate:::c->new->Candidate->candidates->append
Resolve.MethodResolutionContext#deferredAttrContext(Symbol, InferenceContext, ResultInfo, Warner)::: method resolution context deferred attr context:::parent->deferredAttrContext->return->deferredAttr->new->DeferredAttrContext
Resolve.MethodResolutionContext.Candidate#isApplicable()::: candidate is applicable:::return
Resolve.MethodResolutionContext#attrMode()::: method resolution context attr mode:::return
Resolve.MethodResolutionContext#internal()::: method resolution context internal:::return
Todo#instance(Context):::Get the Todo instance for this context.:::instance->context->get->if->new->Todo->return
Todo#append(Env)::: todo append:::add
Todo#iterator()::: todo iterator:::return->contents->iterator
Todo#size()::: todo size:::return->contents->size
Todo#offer(Env)::: todo offer:::if->contents->add->if->addByFile->return->else->return
Todo#retainFiles(Collection):::Removes all unattributed classes except those belonging to the given collection of files.:::for->it->contents->iterator->it->hasNext
Todo#poll()::: todo poll:::if->size->return->env->contents->remove->if->removeByFile->return
Todo#peek()::: todo peek:::return->size->contents->get
Todo#groupByFile()::: todo group by file:::if->new->LinkedList<>->foreach->addByFile->return
Todo#addByFile(Env)::: todo add by file:::file->if->new->HashMap<>->fq->fileMap->get->if->new->FileQueue->fileMap->put->contentsByFile->add->add
Todo#removeByFile(Env)::: todo remove by file:::file->fq->fileMap->get->if->return->if->remove->if->fq->isEmpty->fileMap->remove->contentsByFile->remove
Todo.FileQueue#iterator()::: file queue iterator:::return->fileContents->iterator
Todo.FileQueue#size()::: file queue size:::return->fileContents->size
Todo.FileQueue#offer(Env)::: file queue offer:::if->fileContents->offer->contents->add->return->return
Todo.FileQueue#poll()::: file queue poll:::if->fileContents->size->return->env->fileContents->remove->contents->remove->return
Todo.FileQueue#peek()::: file queue peek:::return->fileContents->size->fileContents->get
TransTypes#instance(Context):::Get the instance for this context.:::instance->context->get->if->new->TransTypes->return
TransTypes#cast(JCExpression, Type):::Construct an attributed tree for a cast of expression to target type,  unless it already has precisely that type.:::oldpos->make->at->if->types->isSameType->if->resolve->isAccessible->resolve->logAccessErrorInternal->make->make->Type->TypeCast->setType->return
TransTypes#coerce(Env, JCExpression, Type):::Construct an attributed tree to coerce an expression to some erased  target type, unless the expression is already assignable to that type:::prevEnv->try->return->coerce->catch->finally
TransTypes#coerce(JCExpression, Type)::: trans types coerce:::btarget->target->baseType->if->isPrimitive->target->isPrimitive->return->types->isAssignable->cast->return
TransTypes#retype(JCExpression, Type, Type):::Given an erased reference type, assume this type as the tree's type:::if->erasedType->isPrimitive->if->target->isPrimitive->erasure->if->return->coerce->return
TransTypes#translateArgs(List, List, Type):::Translate method argument list, casting each argument  to its corresponding type in a list of target types.:::if->parameters->isEmpty->return->args->while->nonEmpty->translate->parameter->Assert->args->length->check->if->while->args->nonEmpty->translate->else->translate->return
TransTypes#translateArgs(List, List, Type, Env)::: trans types translate args:::prevEnv->try->return->translateArgs->catch->finally
TransTypes#addBridge(DiagnosticPosition, MethodSymbol, MethodSymbol, ClassSymbol, ListBuffer):::Add a bridge definition and enter corresponding method symbol in  local scope of origin.:::make->at->implTypeErasure->erasure->bridgeType->meth->erasure->flags->impl->flags->origin->isInterface->bridge->new->MethodSymbol->createBridgeParams->bridge->setAttributes->md->make->MethodDef->receiver->make->origin->erasure->This->make->types->supertype->erasure->Super->calltype->implTypeErasure->getReturnType->call->make->make->Select->setType->make->Idents->implTypeErasure->getParameterTypes->translateArgs->Apply->setType->stat->implTypeErasure->getReturnType->hasTag->make->Exec->make->bridgeType->getReturnType->coerce->Return->make->List->of->Block->bridges->append->origin->members->enter
TransTypes#createBridgeParams(MethodSymbol, MethodSymbol, Type)::: trans types create bridge params:::bridgeParams->if->List->nil->implParams->mType->argTypes->while->implParams->nonEmpty->argTypes->nonEmpty->param->flags->new->VarSymbol->param->setAttributes->bridgeParams->append->return
TransTypes#addBridgeIfNeeded(DiagnosticPosition, Symbol, ClassSymbol, ListBuffer):::Add bridge if given symbol is a non-private, non-static member  of the given class, which is either defined in the class or non-final  inherited, and one of the two following conditions holds:  1:::if->sym->flags->sym->flags->sym->isMemberOf->meth->bridge->meth->binaryImplementation->impl->meth->implementation->if->isSubClass->if->isBridgeNeeded->addBridge->else->if->impl->flags->meth->flags->origin->flags->flags->addBridge
TransTypes#isBridgeNeeded(MethodSymbol, MethodSymbol, Type)::: trans types is bridge needed:::if->method_erasure->method->erasure->if->isSameMemberWhenErased->return->impl_erasure->impl->erasure->if->isSameMemberWhenErased->return->return->types->isSameType->else->if->method->flags->return->return->method->erasure->isSameMemberWhenErased
TransTypes#isSameMemberWhenErased(Type, MethodSymbol, Type):::Lookup the method as a member of the type:::return->types->types->memberType->erasure->isSameType
TransTypes#addBridges(DiagnosticPosition, TypeSymbol, ClassSymbol, ListBuffer)::: trans types add bridges:::foreach->i->members->getSymbols->addBridgeIfNeeded->for->l->types->interfaces->l->nonEmpty
TransTypes#addBridges(DiagnosticPosition, ClassSymbol, ListBuffer):::Add all necessary bridges to some class appending them to list buffer.:::st->types->supertype->while->st->hasTag->addBridges->types->supertype->for->l->types->interfaces->l->nonEmpty
TransTypes#translate(T, Type):::Visitor method: perform a type translation on tree.:::prevPt->try->return->translate->catch->finally
TransTypes#translate(List, Type):::Visitor method: perform a type translation on list of trees.:::prevPt->res->try->translate->catch->finally->return
TransTypes#visitClassDef(JCClassDecl)::: trans types visit class def:::translateClass
TransTypes#visitMethodDef(JCMethodDecl)::: trans types visit method def:::prevRetType->try->erasure->getReturnType->translate->List->nil->translateVarDefs->translate->translate->erasure->getReturnType->translate->erasure->catch->finally
TransTypes#visitVarDef(JCVariableDecl)::: trans types visit var def:::translate->erasure->translate->erasure
TransTypes#visitDoLoop(JCDoWhileLoop)::: trans types visit do loop:::translate->translate
TransTypes#visitWhileLoop(JCWhileLoop)::: trans types visit while loop:::translate->translate
TransTypes#visitForLoop(JCForLoop)::: trans types visit for loop:::translate->if->translate->translate->translate
TransTypes#visitForeachLoop(JCEnhancedForLoop)::: trans types visit foreach loop:::translate->iterableType->erasure->translate->if->types->elemtype->translate
TransTypes#visitLambda(JCLambda)::: trans types visit lambda:::prevRetType->try->tree->getDescriptorType->erasure->getReturnType->translate->returnType->hasTag->translate->if->isIntersection->erasure->else->types->types->findDescriptorSymbol->erasure->catch->finally
TransTypes#visitSwitch(JCSwitch)::: trans types visit switch:::selsuper->types->supertype->enumSwitch->target->erasure->translate->translateCases
TransTypes#visitCase(JCCase)::: trans types visit case:::translate->translate
TransTypes#visitSynchronized(JCSynchronized)::: trans types visit synchronized:::erasure->translate->translate
TransTypes#visitTry(JCTry)::: trans types visit try:::translate->translate->translateCatchers->translate
TransTypes#visitConditional(JCConditional)::: trans types visit conditional:::translate->erasure->translate->erasure->translate->erasure->retype
TransTypes#visitIf(JCIf)::: trans types visit if:::translate->translate->translate
TransTypes#visitExec(JCExpressionStatement)::: trans types visit exec:::translate
TransTypes#visitReturn(JCReturn)::: trans types visit return:::if->returnType->hasTag->translate
TransTypes#visitThrow(JCThrow)::: trans types visit throw:::erasure->translate
TransTypes#visitAssert(JCAssert)::: trans types visit assert:::translate->if->erasure->translate
TransTypes#visitApply(JCMethodInvocation)::: trans types visit apply:::translate->meth->TreeInfo->symbol->mt->meth->erasure->useInstantiatedPtArgs->types->meth->baseSymbol->isSignaturePolymorphic->argtypes->getParameterTypes->mt->getParameterTypes->if->if->types->erasure->else->if->length->argtypes->length->Assert->String->length->argtypes->length->format->error->translateArgs->types->erasure->mt->getReturnType->retype
TransTypes#visitNewClass(JCNewClass)::: trans types visit new class:::if->if->erasure->translate->else->attr->makeNullCheck->prepend->erasedConstructorType->erasure->argtypes->erasedConstructorType->getParameterTypes->erasure->getParameterTypes->translate->if->types->erasure->translateArgs->translate->if->erasure
TransTypes#visitNewArray(JCNewArray)::: trans types visit new array:::translate->translate->if->types->elemtype->erasure->translate->erasure->else->translate
TransTypes#visitParens(JCParens)::: trans types visit parens:::translate->erasure
TransTypes#visitAssign(JCAssign)::: trans types visit assign:::translate->erasure->translate->erasure->retype
TransTypes#visitAssignop(JCAssignOp)::: trans types visit assignop:::translate->getParameterTypes->translate->erasure
TransTypes#visitUnary(JCUnary)::: trans types visit unary:::tree->getTag->getParameterTypes->translate
TransTypes#visitBinary(JCBinary)::: trans types visit binary:::getParameterTypes->translate->getParameterTypes->translate
TransTypes#visitAnnotatedType(JCAnnotatedType)::: trans types visit annotated type:::mirrors->annotate->fromAnnotations->translate->annotatedType
TransTypes#visitTypeCast(JCTypeCast)::: trans types visit type cast:::translate->originalTarget->erasure->newExpression->translate->if->typeCast->newExpression->hasTag->types->isSameType->if->originalTarget->isIntersection->ict->foreach->ict->getExplicitComponents->ec->erasure->if->types->isSameType->coerce
TransTypes#visitTypeTest(JCInstanceOf)::: trans types visit type test:::translate->translate
TransTypes#visitIndexed(JCArrayAccess)::: trans types visit indexed:::erasure->translate->translate->types->elemtype->retype
TransTypes#visitAnnotation(JCAnnotation)::: trans types visit annotation:::
TransTypes#visitIdent(JCIdent)::: trans types visit ident:::et->erasure->if->hasTag->make->at->Type->else->if->constValue->else->if->retype->else->erasure
TransTypes#visitSelect(JCFieldAccess)::: trans types visit select:::t->types->skipTypeVars->if->t->isCompound->erasure->translate->erasure->coerce->else->erasure->translate->if->constValue->else->if->erasure->retype->else->erasure
TransTypes#visitReference(JCMemberReference)::: trans types visit reference:::t->types->skipTypeVars->receiverTarget->t->isCompound->erasure->erasure->if->make->Type->else->translate->if->isIntersection->erasure->else->types->types->findDescriptorSymbol->erasure->if->erasure
TransTypes#visitTypeArray(JCArrayTypeTree)::: trans types visit type array:::translate->erasure
TransTypes#visitTypeApply(JCTypeApply):::Visitor method for parameterized types.:::clazz->translate
TransTypes#visitTypeIntersection(JCTypeIntersection)::: trans types visit type intersection:::translate->erasure
TransTypes#erasure(Type)::: trans types erasure:::return->types->erasure
TransTypes#translateClass(ClassSymbol)::: trans types translate class:::st->types->supertype->if->st->hasTag->translateClass->myEnv->enter->getEnv->if->return->envHasCompState->compileStates->get->if->c->outermostClass->Assert->error->if->compileStates->get->isAfter->Assert->String->compileStates->get->format->error->oldEnv->try->savedMake->savedPt->make->forToplevel->try->tree->List->nil->super->visitClassDef->make->at->bridges->new->ListBuffer<>->if->flags->tree->pos->addBridges->bridges->toList->prependList->erasure->catch->finally->catch->finally
TransTypes#translateTopLevelClass(JCTree, TreeMaker):::Translate a toplevel class definition.:::return->translate
TreeDiffer#equiv(Collection, Collection)::: tree differ equiv:::result->new->HashMap<>->it->otherSymbols->iterator->foreach->if->it->hasNext->break->result->it->next->put->return
TreeDiffer#scan(JCTree, JCTree)::: tree differ scan:::if->return->TreeInfo->skipParens->TreeInfo->skipParens->if->constValue->constValue->return->Objects->constValue->constValue->equals->if->tree->getTag->parameter->getTag->return->prevParameter->prevResult->try->tree->accept->return->catch->finally
TreeDiffer#scan(Iterable, Iterable)::: tree differ scan:::if->return->x->xs->iterator->y->ys->iterator->while->x->hasNext->y->hasNext->if->x->next->y->next->scan->return->return->x->hasNext->y->hasNext
TreeDiffer#scanDimAnnotations(List>, List>)::: tree differ scan dim annotations:::if->return->x->xs->iterator->y->ys->iterator->while->x->hasNext->y->hasNext->if->x->next->y->next->scan->return->return->x->hasNext->y->hasNext
TreeDiffer#visitIdent(JCIdent)::: tree differ visit ident:::that->symbol->otherSymbol->if->if->Objects->equiv->get->equals->return
TreeDiffer#visitSelect(JCFieldAccess)::: tree differ visit select:::that->scan
TreeDiffer#visitAnnotatedType(JCAnnotatedType)::: tree differ visit annotated type:::that->scan->scan
TreeDiffer#visitAnnotation(JCAnnotation)::: tree differ visit annotation:::that->scan->scan
TreeDiffer#visitApply(JCMethodInvocation)::: tree differ visit apply:::that->scan->scan->scan
TreeDiffer#visitAssert(JCAssert)::: tree differ visit assert:::that->scan->scan
TreeDiffer#visitAssign(JCAssign)::: tree differ visit assign:::that->scan->scan
TreeDiffer#visitAssignop(JCAssignOp)::: tree differ visit assignop:::that->scan->scan
TreeDiffer#visitBinary(JCBinary)::: tree differ visit binary:::that->scan->scan
TreeDiffer#visitBlock(JCBlock)::: tree differ visit block:::that->scan
TreeDiffer#visitBreak(JCBreak)::: tree differ visit break:::that
TreeDiffer#visitCase(JCCase)::: tree differ visit case:::that->scan->scan
TreeDiffer#visitCatch(JCCatch)::: tree differ visit catch:::that->scan->scan
TreeDiffer#visitClassDef(JCClassDecl)::: tree differ visit class def:::that->scan->scan->scan->scan->scan
TreeDiffer#visitConditional(JCConditional)::: tree differ visit conditional:::that->scan->scan->scan
TreeDiffer#visitContinue(JCContinue)::: tree differ visit continue:::that
TreeDiffer#visitDoLoop(JCDoWhileLoop)::: tree differ visit do loop:::that->scan->scan
TreeDiffer#visitErroneous(JCErroneous)::: tree differ visit erroneous:::that->scan
TreeDiffer#visitExec(JCExpressionStatement)::: tree differ visit exec:::that->scan
TreeDiffer#visitExports(JCExports)::: tree differ visit exports:::that->scan->scan
TreeDiffer#visitForLoop(JCForLoop)::: tree differ visit for loop:::that->scan->scan->scan->scan
TreeDiffer#visitForeachLoop(JCEnhancedForLoop)::: tree differ visit foreach loop:::that->scan->scan->scan
TreeDiffer#visitIf(JCIf)::: tree differ visit if:::that->scan->scan->scan
TreeDiffer#visitImport(JCImport)::: tree differ visit import:::that->scan
TreeDiffer#visitIndexed(JCArrayAccess)::: tree differ visit indexed:::that->scan->scan
TreeDiffer#visitLabelled(JCLabeledStatement)::: tree differ visit labelled:::that->scan
TreeDiffer#visitLambda(JCLambda)::: tree differ visit lambda:::that->scan->scan
TreeDiffer#visitLetExpr(LetExpr)::: tree differ visit let expr:::that->scan->scan
TreeDiffer#visitLiteral(JCLiteral)::: tree differ visit literal:::that->Objects->equals
TreeDiffer#visitMethodDef(JCMethodDecl)::: tree differ visit method def:::that->scan->scan->scan->scan->scan->scan->scan->scan
TreeDiffer#visitModifiers(JCModifiers)::: tree differ visit modifiers:::that->scan
TreeDiffer#visitModuleDef(JCModuleDecl)::: tree differ visit module def:::that->scan->scan->scan
TreeDiffer#visitNewArray(JCNewArray)::: tree differ visit new array:::that->scan->scan->scan->scanDimAnnotations->scan
TreeDiffer#visitNewClass(JCNewClass)::: tree differ visit new class:::that->scan->scan->scan->scan->scan
TreeDiffer#visitOpens(JCOpens)::: tree differ visit opens:::that->scan->scan
TreeDiffer#visitPackageDef(JCPackageDecl)::: tree differ visit package def:::that->scan->scan
TreeDiffer#visitProvides(JCProvides)::: tree differ visit provides:::that->scan->scan
TreeDiffer#visitReference(JCMemberReference)::: tree differ visit reference:::that->scan->scan
TreeDiffer#visitRequires(JCRequires)::: tree differ visit requires:::that->scan
TreeDiffer#visitReturn(JCReturn)::: tree differ visit return:::that->scan
TreeDiffer#visitSwitch(JCSwitch)::: tree differ visit switch:::that->scan->scan
TreeDiffer#visitSynchronized(JCSynchronized)::: tree differ visit synchronized:::that->scan->scan
TreeDiffer#visitThrow(JCThrow)::: tree differ visit throw:::that->scan
TreeDiffer#visitTopLevel(JCCompilationUnit)::: tree differ visit top level:::that->scan
TreeDiffer#visitTry(JCTry)::: tree differ visit try:::that->scan->scan->scan->scan
TreeDiffer#visitTypeApply(JCTypeApply)::: tree differ visit type apply:::that->scan->scan
TreeDiffer#visitTypeArray(JCArrayTypeTree)::: tree differ visit type array:::that->scan
TreeDiffer#visitTypeBoundKind(TypeBoundKind)::: tree differ visit type bound kind:::that
TreeDiffer#visitTypeCast(JCTypeCast)::: tree differ visit type cast:::that->scan->scan
TreeDiffer#visitTypeIdent(JCPrimitiveTypeTree)::: tree differ visit type ident:::that
TreeDiffer#visitTypeIntersection(JCTypeIntersection)::: tree differ visit type intersection:::that->scan
TreeDiffer#visitTypeParameter(JCTypeParameter)::: tree differ visit type parameter:::that->scan->scan
TreeDiffer#visitTypeTest(JCInstanceOf)::: tree differ visit type test:::that->scan->scan
TreeDiffer#visitTypeUnion(JCTypeUnion)::: tree differ visit type union:::that->scan
TreeDiffer#visitUnary(JCUnary)::: tree differ visit unary:::that->scan
TreeDiffer#visitUses(JCUses)::: tree differ visit uses:::that->scan
TreeDiffer#visitVarDef(JCVariableDecl)::: tree differ visit var def:::that->scan->scan->scan->scan->if->return->equiv->put
TreeDiffer#visitWhileLoop(JCWhileLoop)::: tree differ visit while loop:::that->scan->scan
TreeDiffer#visitWildcard(JCWildcard)::: tree differ visit wildcard:::that->scan->scan
TreeHasher#hash(JCTree, Collection)::: tree hasher hash:::if->return->symbolHashes->new->HashMap<>->symbols->symbolHashes->symbolHashes->size->put->forEach->hasher->new->TreeHasher->tree->accept->return
TreeHasher#hash(Object)::: tree hasher hash:::Objects->hashCode
TreeHasher#scan(JCTree)::: tree hasher scan:::if->return->TreeInfo->skipParens->if->value->constValue->if->hash->return->tree->getTag->hash->tree->accept
TreeHasher#visitLiteral(JCLiteral)::: tree hasher visit literal:::hash->super->visitLiteral
TreeHasher#visitIdent(JCIdent)::: tree hasher visit ident:::sym->if->hash->symbolHashes->get->if->hash->return->hash
TreeHasher#visitSelect(JCFieldAccess)::: tree hasher visit select:::hash->super->visitSelect
TreeHasher#visitVarDef(JCVariableDecl)::: tree hasher visit var def:::symbolHashes->symbolHashes->size->computeIfAbsent->super->visitVarDef
TypeEnter#instance(Context)::: type enter instance:::instance->context->get->if->new->TypeEnter->return
TypeEnter#ensureImportsChecked(List)::: type enter ensure imports checked:::foreach->if->isFilled->topEnv->enter->topLevelEnv->completeClass->resolveImports->finishImports
TypeEnter#complete(Symbol):::Complete entering a class.:::if->Assert->sym->flags->check->return->try->annotate->blockAnnotations->queue->dependencies->push->try->completeClass->List->typeEnvs->get->of->completeEnvs->catch->finally->dependencies->pop->if->queue->isEmpty->seen->new->HashSet<>->foreach->if->contains->seen->add->finishImports->catch->finally->annotate->unblockAnnotations
TypeEnter#finishImports(JCCompilationUnit, Runnable)::: type enter finish imports:::prev->log->useSource->try->resolve->run->chk->checkImportsUnique->chk->checkImportsResolvable->chk->checkImportedPackagesObservable->finalizeScope->finalizeScope->catch->chk->toplevel->pos->completionError->finally->log->useSource
TypeEnter.Phase#completeEnvs(List>)::: phase complete envs:::firstToComplete->queue->isEmpty->prevTopLevelPhase->success->try->doCompleteEnvs->catch->finally->if->queue->clear->if->out->queue->toList->queue->clear->return->next->completeEnvs->else->return->List->nil
TypeEnter.Phase#doCompleteEnvs(List>)::: phase do complete envs:::foreach->tree->queue->add->prev->log->useSource->prevLintPos->deferredLintHandler->tree->pos->setPos->try->dependencies->push->runPhase->catch->chk->tree->pos->completionError->finally->dependencies->pop->deferredLintHandler->setPos->log->useSource
TypeEnter.Phase#runPhase(Env)::: phase run phase:::
TypeEnter.ImportsPhase#runPhase(Env)::: imports phase run phase:::tree->sym->if->env->enclosing->resolveImports->todo->append->if->complete
TypeEnter.ImportsPhase#resolveImports(JCCompilationUnit, Env)::: imports phase resolve imports:::if->isFilled->return->prevStaticImportFilter->prevTypeImportFilter->prevLintPos->deferredLintHandler->immediate->prevLint->chk->setLint->prevEnv->try->packge->sym->isStatic->chk->importAccessible->sym->isMemberOf->chk->importAccessible->javaLang->syms->enterPackage->if->javaLang->members->isEmpty->javaLang->exists->throw->diags->fragment->new->FatalError->make->tree->pos->at->make->QualIdent->Import->importAll->decl->tree->getModuleDecl->if->tree->getPackage->tree->getPackage->checkClassPackageClash->foreach->tree->getImports->doImport->if->markDeprecated->annotate->annotateLater->catch->finally->chk->setLint->deferredLintHandler->setPos
TypeEnter.ImportsPhase#checkClassPackageClash(JCPackageDecl)::: imports phase check class package clash:::if->p->while->complete->pack->syms->getQualifiedName->lookupPackage->if->syms->p->getQualifiedName->getClass->log->Errors->PkgClashesWithClassOfSameName->error->annotate->annotateLater
TypeEnter.ImportsPhase#doImport(JCImport)::: imports phase do import:::imp->name->TreeInfo->name->localEnv->env->dup->p->attr->attribImportQualifier->if->chk->checkCanonical->if->importStaticAll->else->importAll->else->if->importNamedStatic->chk->checkCanonical->else->importedType->attribImportType->originalType->importedType->getOriginalType->c->originalType->hasTag->chk->checkCanonical->tree->pos->importNamed
TypeEnter.ImportsPhase#attribImportType(JCTree, Env)::: imports phase attrib import type:::Assert->check->prevLint->chk->lint->suppress->setLint->try->return->attr->attribType->catch->finally->chk->setLint
TypeEnter.ImportsPhase#importAll(JCImport, TypeSymbol, Env):::Import all classes of a class or package on demand.:::tsym->members->importAll
TypeEnter.ImportsPhase#importStaticAll(JCImport, TypeSymbol, Env):::Import all static members of a class or package on demand.:::toScope->origin->toScope->origin->members->importAll
TypeEnter.ImportsPhase#importNamedStatic(JCImport, TypeSymbol, Name, Env):::Import statics types of a given name:::if->log->imp->pos->error->return->toScope->originMembers->tsym->members->toScope->importByName
TypeEnter.ImportsPhase#importNamed(DiagnosticPosition, Symbol, Env, JCImport):::Import given class.:::if->members->members->importType
TypeEnter.AbstractHeaderPhase#baseEnv(JCClassDecl, Env)::: abstract header phase base env:::baseScope->WriteableScope->create->foreach->getSymbols->if->sym->isLocal->baseScope->enter->if->for->typarams->typarams->nonEmpty->outer->localEnv->outer->dup->dup->return
TypeEnter.AbstractHeaderPhase#enumBase(int, ClassSymbol):::Generate a base clause for an enum type.:::result->make->at->make->QualIdent->List->make->Type->of->TypeApply->return
TypeEnter.AbstractHeaderPhase#modelMissingTypes(Env, Type, JCExpression, boolean)::: abstract header phase model missing types:::if->t->hasTag->return->return->t->getOriginalType->new->ErrorType
TypeEnter.AbstractHeaderPhase.Synthesizer#visit(JCTree)::: synthesizer visit:::tree->accept->return
TypeEnter.AbstractHeaderPhase.Synthesizer#visit(List)::: synthesizer visit:::lb->new->ListBuffer<>->foreach->lb->visit->append->return->lb->toList
TypeEnter.AbstractHeaderPhase.Synthesizer#visitTree(JCTree)::: synthesizer visit tree:::
TypeEnter.AbstractHeaderPhase.Synthesizer#visitIdent(JCIdent)::: synthesizer visit ident:::if->hasTag->else->synthesizeClass
TypeEnter.AbstractHeaderPhase.Synthesizer#visitSelect(JCFieldAccess)::: synthesizer visit select:::if->hasTag->else->selectedType->prev->try->visit->catch->finally->c->synthesizeClass
TypeEnter.AbstractHeaderPhase.Synthesizer#visitTypeApply(JCTypeApply)::: synthesizer visit type apply:::if->hasTag->else->clazzType->visit->if->synthesizedSymbols->contains->size->synthesizeTyparams->actuals->visit->new->ErrorType
TypeEnter.AbstractHeaderPhase.Synthesizer#synthesizeClass(Name, Symbol)::: synthesizer synthesize class:::flags->c->new->ClassSymbol->new->Scope.ErrorScope->new->ErrorType->synthesizedSymbols->prepend->return
TypeEnter.AbstractHeaderPhase.Synthesizer#synthesizeTyparams(ClassSymbol, int)::: synthesizer synthesize typarams:::ct->Assert->isEmpty->check->if->v->names->fromString->new->TypeVar->prepend->else->for->i
TypeEnter.AbstractHeaderPhase#attribSuperTypes(Env, Env)::: abstract header phase attrib super types:::tree->sym->ct->supertype->extending->if->clearTypeParams->attr->attribBase->else->attr->enumBase->attribBase->modelMissingTypes->interfaces->new->ListBuffer<>->all_interfaces->interfaceTrees->foreach->clearTypeParams->it->attr->attribBase->if->it->hasTag->interfaces->append->if->all_interfaces->append->else->if->new->ListBuffer<Type>->appendList->all_interfaces->modelMissingTypes->append->if->List->of->else->interfaces->toList->all_interfaces->toList
TypeEnter.AbstractHeaderPhase#clearTypeParams(JCExpression)::: abstract header phase clear type params:::return
TypeEnter.HierarchyPhase#doCompleteEnvs(List>)::: hierarchy phase do complete envs:::foreach->foreach->complete
TypeEnter.HierarchyPhase#runPhase(Env)::: hierarchy phase run phase:::tree->sym->ct->baseEnv->baseEnv->attribSuperTypes->if->if->chk->pos->checkNonCyclic->else->if->nonEmpty->chk->pos->checkNonCyclic->List->nil->markDeprecated->chk->checkNonCyclicDecl
TypeEnter.HierarchyPhase#clearTypeParams(JCExpression)::: hierarchy phase clear type params:::switch->superType->getTag->return->return
TypeEnter.HierarchyPhase#complete(Symbol)::: hierarchy phase complete:::Assert->check->if->return->env->typeEnvs->get->super->List->of->doCompleteEnvs
TypeEnter.HeaderPhase#runPhase(Env)::: header phase run phase:::tree->sym->ct->baseEnv->baseEnv->if->annotate->tree->pos->queueScanTreeAndTypeAnnotate->foreach->annotate->tree->pos->queueScanTreeAndTypeAnnotate->annotate->flush->attribSuperTypes->interfaceSet->new->HashSet<>->foreach->it->if->it->hasTag->chk->iface->pos->types->erasure->checkNotRepeated->annotate->tree->pos->annotateLater->attr->attribTypeVariables->foreach->annotate->tree->pos->queueScanTreeAndTypeAnnotate->if->syms->packageExists->log->Errors->Kinds->kindName->ClashWithPkgOfSameName->error->if->toString->isNameCompatible
TypeEnter.MembersPhase#doCompleteEnvs(List>)::: members phase do complete envs:::todo->prependList->if->return->prevCompleting->try->while->todo->nonEmpty->head->super->List->of->doCompleteEnvs->catch->finally
TypeEnter.MembersPhase#runPhase(Env)::: members phase run phase:::tree->sym->ct->if->sym->flags->TreeInfo->hasConstructors->argtypes->List->nil->typarams->List->nil->thrown->List->nil->ctorFlags->based->addConstructor->nc->if->isEmpty->if->superConstrType->types->memberType->superConstrType->getParameterTypes->superConstrType->getTypeArguments->flags->if->argtypes->prepend->superConstrType->getThrownTypes->if->basedConstructor->constrDef->make->at->DefaultConstructor->prepend->thisSym->new->VarSymbol->enter->if->hasTag->superSym->new->VarSymbol->enter->finishClass->if->typeAnnotations->organizeTypeAnnotationsSignatures->typeAnnotations->validateTypeAnnotationsSignatures
TypeEnter.MembersPhase#finishClass(JCClassDecl, Env):::Enter members for a class.:::if->hasTag->types->supertype->flags->addEnumMembers->memberEnter->memberEnter->if->isAnnotationType->Assert->isCompleted->check->annotate->annotationTypeSourceCompleter->new->AnnotationTypeMetadata->setAnnotationTypeMetadata
TypeEnter.MembersPhase#addEnumMembers(JCClassDecl, Env):::Add the implicit members for an enum type  to the symbol table.:::valuesType->make->new->ArrayType->Type->values->make->make->Modifiers->List->nil->List->nil->List->nil->MethodDef->memberEnter->memberEnter->valueOf->make->make->Modifiers->make->Type->List->nil->List->make->make->Modifiers->names->fromString->make->Type->VarDef->of->List->nil->MethodDef->memberEnter->memberEnter
TypeEnter#DefaultConstructor(TreeMaker, ClassSymbol, MethodSymbol, List, List, List, long, boolean):::Generate default constructor for given class:::result->if->c->flags->types->supertype->else->c->flags->if->isEmpty->if->mType->new->MethodType->initType->typarams->nonEmpty->new->ForAll->init->new->MethodSymbol->createDefaultConstructorParams->params->make->Params->stats->List->nil->if->stats->SuperCall->prepend->make->make->Block->MethodDef->return
TypeEnter#createDefaultConstructorParams(TreeMaker, MethodSymbol, MethodSymbol, List, boolean)::: type enter create default constructor params:::initParams->argTypesList->if->List->nil->param->make->paramName->new->VarSymbol->initParams->append->if->nonEmpty->argTypesList->nonEmpty->List->nil->baseInitParams->while->baseInitParams->nonEmpty->argTypesList->nonEmpty->param->flags->new->VarSymbol->initParams->append->return
TypeEnter#SuperCall(TreeMaker, List, List, boolean):::Generate call to superclass constructor:::meth->if->make->make->Ident->Select->else->make->Ident->typeargs->typarams->nonEmpty->make->Types->return->make->make->make->Idents->Apply->Exec
TypeEnter#markDeprecated(Symbol, List, Env):::Mark sym deprecated if annotations contain @Deprecated annotation.:::attr->attribAnnotationTypes->handleDeprecatedAnnotations
TypeEnter#handleDeprecatedAnnotations(List, Symbol):::If a list of annotations contains a reference to java.lang.Deprecated, set the DEPRECATED flag:::for->al->al->isEmpty
TypeEnvs#instance(Context)::: type envs instance:::instance->context->get->if->new->TypeEnvs->return
TypeEnvs#get(TypeSymbol)::: type envs get:::return->map->get
TypeEnvs#put(TypeSymbol, Env)::: type envs put:::return->map->put
TypeEnvs#remove(TypeSymbol)::: type envs remove:::return->map->remove
TypeEnvs#values()::: type envs values:::return->map->values
TypeEnvs#clear()::: type envs clear:::map->clear
