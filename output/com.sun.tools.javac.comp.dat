com.sun.tools.javac.comp.Analyzer#instance(Context)->Analyzer::: analyzer instance
com.sun.tools.javac.comp.Analyzer.StatementAnalyzer#isEnabled()->boolean:::Is this analyzer allowed to run?
com.sun.tools.javac.comp.Analyzer.StatementAnalyzer#match(S)->boolean:::Should this analyzer be rewriting the given tree?
com.sun.tools.javac.comp.Analyzer.StatementAnalyzer#rewrite(S)->List:::Rewrite a given AST node into a new one(s)
com.sun.tools.javac.comp.Analyzer.StatementAnalyzer#process(S, T, boolean)->void:::Entry-point for comparing results and generating diagnostics.
com.sun.tools.javac.comp.Analyzer.DiamondInitializer#match(JCNewClass)->boolean::: diamond initializer match
com.sun.tools.javac.comp.Analyzer.DiamondInitializer#rewrite(JCNewClass)->List::: diamond initializer rewrite
com.sun.tools.javac.comp.Analyzer.DiamondInitializer#process(JCNewClass, JCNewClass, boolean)->void::: diamond initializer process
com.sun.tools.javac.comp.Analyzer.LambdaAnalyzer#match(JCNewClass)->boolean::: lambda analyzer match
com.sun.tools.javac.comp.Analyzer.LambdaAnalyzer#rewrite(JCNewClass)->List::: lambda analyzer rewrite
com.sun.tools.javac.comp.Analyzer.LambdaAnalyzer#process(JCNewClass, JCLambda, boolean)->void::: lambda analyzer process
com.sun.tools.javac.comp.Analyzer.RedundantTypeArgAnalyzer#match(JCMethodInvocation)->boolean::: redundant type arg analyzer match
com.sun.tools.javac.comp.Analyzer.RedundantTypeArgAnalyzer#rewrite(JCMethodInvocation)->List::: redundant type arg analyzer rewrite
com.sun.tools.javac.comp.Analyzer.RedundantTypeArgAnalyzer#process(JCMethodInvocation, JCMethodInvocation, boolean)->void::: redundant type arg analyzer process
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerBase#isImplicitlyTyped(JCVariableDecl)->boolean::: redundant local var type analyzer base is implicitly typed
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerBase#rewriteVarType(JCVariableDecl)->JCVariableDecl:::Map a variable tree into a new declaration using implicit type.
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerBase#processVar(JCVariableDecl, JCVariableDecl, boolean)->void:::Analyze results of local variable inference.
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzer#match(JCVariableDecl)->boolean::: redundant local var type analyzer match
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzer#rewrite(JCVariableDecl)->List::: redundant local var type analyzer rewrite
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzer#process(JCVariableDecl, JCVariableDecl, boolean)->void::: redundant local var type analyzer process
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerForEach#match(JCEnhancedForLoop)->boolean::: redundant local var type analyzer for each match
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerForEach#rewrite(JCEnhancedForLoop)->List::: redundant local var type analyzer for each rewrite
com.sun.tools.javac.comp.Analyzer.RedundantLocalVarTypeAnalyzerForEach#process(JCEnhancedForLoop, JCEnhancedForLoop, boolean)->void::: redundant local var type analyzer for each process
com.sun.tools.javac.comp.Analyzer#copyEnvIfNeeded(JCTree, Env)->Env:::Create a copy of Env if needed.
com.sun.tools.javac.comp.Analyzer#analyzeIfNeeded(JCTree, Env)->void:::Analyze an AST node if needed.
com.sun.tools.javac.comp.Analyzer#analyze(JCStatement, Env)->void:::Analyze an AST node; this involves collecting a list of all the nodes that needs rewriting, and speculatively type-check the rewritten code to compare results against previously attributed code.
com.sun.tools.javac.comp.Analyzer.DeferredAnalysisHelper#queue(RewritingContext)->void:::Add a new analysis task to the queue.
com.sun.tools.javac.comp.Analyzer.DeferredAnalysisHelper#flush(Env)->void:::Flush queue with given attribution env.
com.sun.tools.javac.comp.Analyzer#doAnalysis(RewritingContext)->void::: analyzer do analysis
com.sun.tools.javac.comp.Analyzer#flush(Env)->void::: analyzer flush
com.sun.tools.javac.comp.Analyzer.StatementScanner#scan()->void::: statement scanner scan
com.sun.tools.javac.comp.Analyzer.StatementScanner#scan(JCTree)->void::: statement scanner scan
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitClassDef(JCClassDecl)->void::: statement scanner visit class def
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitMethodDef(JCMethodDecl)->void::: statement scanner visit method def
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitBlock(JCBlock)->void::: statement scanner visit block
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitSwitch(JCSwitch)->void::: statement scanner visit switch
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitForLoop(JCForLoop)->void::: statement scanner visit for loop
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitTry(JCTry)->void::: statement scanner visit try
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitForeachLoop(JCEnhancedForLoop)->void::: statement scanner visit foreach loop
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitWhileLoop(JCWhileLoop)->void::: statement scanner visit while loop
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitDoLoop(JCDoWhileLoop)->void::: statement scanner visit do loop
com.sun.tools.javac.comp.Analyzer.StatementScanner#visitIf(JCIf)->void::: statement scanner visit if
com.sun.tools.javac.comp.Analyzer.RewritingContext#diagHandler()->Log.DeferredDiagnosticHandler:::Simple deferred diagnostic handler which filters out all messages and keep track of errors.
com.sun.tools.javac.comp.Analyzer.AnalyzerCopier#visitLambdaExpression(LambdaExpressionTree, Void)->JCTree::: analyzer copier visit lambda expression
com.sun.tools.javac.comp.Analyzer.AnalyzerCopier#visitNewClass(NewClassTree, Void)->JCTree::: analyzer copier visit new class
com.sun.tools.javac.comp.Analyzer.TreeRewriter#copy(Z, Void)->Z::: tree rewriter copy
com.sun.tools.javac.comp.Annotate#instance(Context)->Annotate::: annotate instance
com.sun.tools.javac.comp.Annotate#blockAnnotations()->void:::Called when annotations processing needs to be postponed.
com.sun.tools.javac.comp.Annotate#unblockAnnotations()->void:::Called when annotation processing can be resumed.
com.sun.tools.javac.comp.Annotate#unblockAnnotationsNoFlush()->void:::Variant which allows for a delayed flush of annotations
com.sun.tools.javac.comp.Annotate#annotationsBlocked()->boolean:::are we blocking annotation processing?
com.sun.tools.javac.comp.Annotate#enterDone()->void::: annotate enter done
com.sun.tools.javac.comp.Annotate#fromAnnotations(List)->List::: annotate from annotations
com.sun.tools.javac.comp.Annotate#normal(Runnable)->void:::Annotate (used for everything else)
com.sun.tools.javac.comp.Annotate#validate(Runnable)->void:::Validate, triggers after 'normal'
com.sun.tools.javac.comp.Annotate#flush()->void:::Flush all annotation queues
com.sun.tools.javac.comp.Annotate#typeAnnotation(Runnable)->void::: annotate type annotation
com.sun.tools.javac.comp.Annotate#afterTypes(Runnable)->void::: annotate after types
com.sun.tools.javac.comp.Annotate#annotateLater(List, Env, Symbol, DiagnosticPosition)->void:::Queue annotations for later attribution and entering
com.sun.tools.javac.comp.Annotate#annotateDefaultValueLater(JCExpression, Env, MethodSymbol, DiagnosticPosition)->void:::Queue processing of an attribute default value.
com.sun.tools.javac.comp.Annotate#attributeAnnotation(JCAnnotation, Type, Env)->Attribute.Compound:::Attribute and store a semantic representation of the annotation tree tree into the tree.attribute field.
com.sun.tools.javac.comp.Annotate#attributeTypeAnnotation(JCAnnotation, Type, Env)->Attribute.TypeCompound:::Attribute and store a semantic representation of the type annotation tree tree into the tree.attribute field.
com.sun.tools.javac.comp.Annotate.AnnotationValueContext#compatible(Type, Type, Warner)->boolean::: annotation value context compatible
com.sun.tools.javac.comp.Annotate#enterTypeAnnotations(List, Env, Symbol, DiagnosticPosition, boolean)->void:::Attribute the list of annotations and enter them onto s.
com.sun.tools.javac.comp.Annotate#queueScanTreeAndTypeAnnotate(JCTree, Env, Symbol, DiagnosticPosition)->void:::Enqueue tree for scanning of type annotations, attaching to the Symbol sym.
com.sun.tools.javac.comp.Annotate#annotateTypeSecondStage(JCTree, List, Type)->void:::Apply the annotations to the particular type.
com.sun.tools.javac.comp.Annotate#annotateTypeParameterSecondStage(JCTree, List)->void:::Apply the annotations to the particular type.
com.sun.tools.javac.comp.Annotate#annotationTypeSourceCompleter()->AnnotationTypeCompleter::: annotate annotation type source completer
com.sun.tools.javac.comp.Annotate#unfinishedDefaultValue()->Attribute::: annotate unfinished default value
com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter#complete(ClassSymbol)->void::: annotation type completer complete
com.sun.tools.javac.comp.Annotate.AnnotationTypeVisitor#getRepeatable()->Compound::: annotation type visitor get repeatable
com.sun.tools.javac.comp.Annotate.AnnotationTypeVisitor#getTarget()->Compound::: annotation type visitor get target
com.sun.tools.javac.comp.Annotate.AnnotationTypeVisitor#scanAnnotationType(JCClassDecl)->void::: annotation type visitor scan annotation type
com.sun.tools.javac.comp.Annotate.AnnotationTypeVisitor#visitClassDef(JCClassDecl)->void::: annotation type visitor visit class def
com.sun.tools.javac.comp.Annotate.AnnotationTypeVisitor#visitAnnotation(JCAnnotation)->void::: annotation type visitor visit annotation
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#complete()->void::: annotation type metadata complete
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#getRepeatable()->Compound::: annotation type metadata get repeatable
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#setRepeatable(Compound)->void::: annotation type metadata set repeatable
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#getTarget()->Compound::: annotation type metadata get target
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#setTarget(Compound)->void::: annotation type metadata set target
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#getAnnotationElements()->Set::: annotation type metadata get annotation elements
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#getAnnotationElementsWithDefault()->Set::: annotation type metadata get annotation elements with default
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#toString()->String::: annotation type metadata to string
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#isMetadataForAnnotationType()->boolean::: annotation type metadata is metadata for annotation type
com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata#notAnAnnotationType()->AnnotationTypeMetadata::: annotation type metadata not an annotation type
com.sun.tools.javac.comp.Annotate#newRound()->void::: annotate new round
com.sun.tools.javac.comp.ArgumentAttr#instance(Context)->ArgumentAttr::: argument attr instance
com.sun.tools.javac.comp.ArgumentAttr#setResult(JCExpression, Type)->void:::Set the results of method attribution.
com.sun.tools.javac.comp.ArgumentAttr#checkSpeculative(JCExpression, ResultInfo)->Type:::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.
com.sun.tools.javac.comp.ArgumentAttr#checkSpeculative(DiagnosticPosition, Type, ResultInfo)->Type:::Checks a type in the speculative tree against a given result; the type can be either a plain type or an argument type,in which case a more complex check is required.
com.sun.tools.javac.comp.ArgumentAttr#withLocalCacheContext()->LocalCacheContext:::Returns a local caching context in which argument types can safely be cached without the risk of polluting enclosing contexts
com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext#leave()->void::: local cache context leave
com.sun.tools.javac.comp.ArgumentAttr#attribArg(JCTree, Env)->Type:::Main entry point for attributing an argument with given tree and attribution environment.
com.sun.tools.javac.comp.ArgumentAttr#visitTree(JCTree)->void::: argument attr visit tree
com.sun.tools.javac.comp.ArgumentAttr#processArg(T, Function)->void:::Process a method argument; this method takes care of performing a speculative pass over the argument tree and calling a well-defined entry point to build the argument type associated with such tree.
com.sun.tools.javac.comp.ArgumentAttr#processArg(T, Supplier)->void:::Process a method argument; this method allows the caller to specify a custom speculative attribution logic (this is used e.g
com.sun.tools.javac.comp.ArgumentAttr#visitParens(JCParens)->void::: argument attr visit parens
com.sun.tools.javac.comp.ArgumentAttr#visitConditional(JCConditional)->void::: argument attr visit conditional
com.sun.tools.javac.comp.ArgumentAttr#visitReference(JCMemberReference)->void::: argument attr visit reference
com.sun.tools.javac.comp.ArgumentAttr#visitLambda(JCLambda)->void::: argument attr visit lambda
com.sun.tools.javac.comp.ArgumentAttr#visitApply(JCMethodInvocation)->void::: argument attr visit apply
com.sun.tools.javac.comp.ArgumentAttr#visitNewClass(JCNewClass)->void::: argument attr visit new class
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#completer()->DeferredTypeCompleter::: argument type completer
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#complete(DeferredType, ResultInfo, DeferredAttrContext)->Type::: argument type complete
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#speculativeType(Symbol, MethodResolutionPhase)->Type::: argument type speculative type
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#speculativeTree(DeferredAttrContext)->JCTree::: argument type speculative tree
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#overloadCheck(ResultInfo, DeferredAttrContext)->Type:::Performs an overload check against a given target result.
com.sun.tools.javac.comp.ArgumentAttr.ArgumentType#dup(T, Env)->ArgumentType:::Creates a copy of this argument type with given tree and environment.
com.sun.tools.javac.comp.ArgumentAttr.ParensType#overloadCheck(ResultInfo, DeferredAttrContext)->Type::: parens type overload check
com.sun.tools.javac.comp.ArgumentAttr.ParensType#dup(JCParens, Env)->ArgumentType::: parens type dup
com.sun.tools.javac.comp.ArgumentAttr.ConditionalType#overloadCheck(ResultInfo, DeferredAttrContext)->Type::: conditional type overload check
com.sun.tools.javac.comp.ArgumentAttr.ConditionalType#dup(JCConditional, Env)->ArgumentType::: conditional type dup
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#argtypes()->List:::Compute argument types (if needed).
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#returnExpressions()->List:::Compute return expressions (if needed).
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#overloadCheck(ResultInfo, DeferredAttrContext)->Type::: explicit lambda type overload check
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#checkReturnInStatementLambda(JCReturn, ResultInfo)->void:::This is an inlined version of Attr#visitReturn(JCReturn).
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#getReturnType(JCReturn)->Type:::Get the type associated with given return expression.
com.sun.tools.javac.comp.ArgumentAttr.ExplicitLambdaType#dup(JCLambda, Env)->ArgumentType::: explicit lambda type dup
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMemberType#overloadCheck(ResultInfo, DeferredAttrContext)->Type::: resolved member type overload check
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMemberType#resultInfo(ResultInfo)->ResultInfo:::Get the result info to be used for performing an overload check.
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMemberType#methodType()->Type:::Get the method type to be used for performing an overload check.
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMethodType#resultInfo(ResultInfo)->ResultInfo::: resolved method type result info
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMethodType#methodType()->Type::: resolved method type method type
com.sun.tools.javac.comp.ArgumentAttr.ResolvedMethodType#dup(JCMethodInvocation, Env)->ArgumentType::: resolved method type dup
com.sun.tools.javac.comp.ArgumentAttr.ResolvedConstructorType#resultInfo(ResultInfo)->ResultInfo::: resolved constructor type result info
com.sun.tools.javac.comp.ArgumentAttr.ResolvedConstructorType#methodType()->Type::: resolved constructor type method type
com.sun.tools.javac.comp.ArgumentAttr.ResolvedConstructorType#dup(JCNewClass, Env)->ArgumentType::: resolved constructor type dup
com.sun.tools.javac.comp.ArgumentAttr.UniquePos#hashCode()->int::: unique pos hash code
com.sun.tools.javac.comp.ArgumentAttr.UniquePos#equals(Object)->boolean::: unique pos equals
com.sun.tools.javac.comp.ArgumentAttr.UniquePos#toString()->String::: unique pos to string
com.sun.tools.javac.comp.Attr#instance(Context)->Attr::: attr instance
com.sun.tools.javac.comp.Attr#check(JCTree, Type, KindSelector, ResultInfo)->Type:::Check kind and type of given tree against protokind and prototype
com.sun.tools.javac.comp.Attr#isAssignableAsBlankFinal(VarSymbol, Env)->boolean:::Is given blank final variable assignable, i.e
com.sun.tools.javac.comp.Attr#checkAssignable(DiagnosticPosition, VarSymbol, JCTree, Env)->void:::Check that variable can be assigned to.
com.sun.tools.javac.comp.Attr#isStaticReference(JCTree)->boolean:::Does tree represent a static reference to an identifier?  It is assumed that tree is either a SELECT or an IDENT
com.sun.tools.javac.comp.Attr#isType(Symbol)->boolean:::Is this symbol a type?
com.sun.tools.javac.comp.Attr#thisSym(DiagnosticPosition, Env)->Symbol:::The current `this' symbol.
com.sun.tools.javac.comp.Attr#attribIdent(JCTree, JCCompilationUnit)->Symbol:::Attribute a parsed identifier.
com.sun.tools.javac.comp.Attr#attribIdent(JCTree, Env)->Symbol:::Attribute a parsed identifier.
com.sun.tools.javac.comp.Attr#coerce(Type, Type)->Type::: attr coerce
com.sun.tools.javac.comp.Attr#attribType(JCTree, TypeSymbol)->Type::: attr attrib type
com.sun.tools.javac.comp.Attr#attribImportQualifier(JCImport, Env)->Type::: attr attrib import qualifier
com.sun.tools.javac.comp.Attr#attribExprToTree(JCTree, Env, JCTree)->Env::: attr attrib expr to tree
com.sun.tools.javac.comp.Attr#attribStatToTree(JCTree, Env, JCTree)->Env::: attr attrib stat to tree
com.sun.tools.javac.comp.Attr.ResultInfo#needsArgumentAttr(JCTree)->boolean:::Should Attr#attribTree use the  visitor instead of this one?
com.sun.tools.javac.comp.Attr.ResultInfo#check(DiagnosticPosition, Type)->Type::: result info check
com.sun.tools.javac.comp.Attr.ResultInfo#dup(Type)->ResultInfo::: result info dup
com.sun.tools.javac.comp.Attr.ResultInfo#dup(CheckContext)->ResultInfo::: result info dup
com.sun.tools.javac.comp.Attr.ResultInfo#dup(Type, CheckContext)->ResultInfo::: result info dup
com.sun.tools.javac.comp.Attr.ResultInfo#dup(Type, CheckContext, CheckMode)->ResultInfo::: result info dup
com.sun.tools.javac.comp.Attr.ResultInfo#dup(CheckMode)->ResultInfo::: result info dup
com.sun.tools.javac.comp.Attr.ResultInfo#toString()->String::: result info to string
com.sun.tools.javac.comp.Attr.MethodAttrInfo#needsArgumentAttr(JCTree)->boolean::: method attr info needs argument attr
com.sun.tools.javac.comp.Attr.MethodAttrInfo#dup(Type)->ResultInfo::: method attr info dup
com.sun.tools.javac.comp.Attr.MethodAttrInfo#dup(CheckContext)->ResultInfo::: method attr info dup
com.sun.tools.javac.comp.Attr.MethodAttrInfo#dup(Type, CheckContext)->ResultInfo::: method attr info dup
com.sun.tools.javac.comp.Attr.MethodAttrInfo#dup(Type, CheckContext, CheckMode)->ResultInfo::: method attr info dup
com.sun.tools.javac.comp.Attr.MethodAttrInfo#dup(CheckMode)->ResultInfo::: method attr info dup
com.sun.tools.javac.comp.Attr#pt()->Type::: attr pt
com.sun.tools.javac.comp.Attr#pkind()->KindSelector::: attr pkind
com.sun.tools.javac.comp.Attr#attribTree(JCTree, Env, ResultInfo)->Type:::Visitor method: attribute a tree, catching any completion failure  exceptions
com.sun.tools.javac.comp.Attr#copyEnv(Env)->Env::: attr copy env
com.sun.tools.javac.comp.Attr#copyScope(WriteableScope)->WriteableScope::: attr copy scope
com.sun.tools.javac.comp.Attr#attribExpr(JCTree, Env, Type)->Type:::Derived visitor method: attribute an expression tree.
com.sun.tools.javac.comp.Attr#attribExpr(JCTree, Env)->Type:::Derived visitor method: attribute an expression tree with  no constraints on the computed type.
com.sun.tools.javac.comp.Attr#attribType(JCTree, Env)->Type:::Derived visitor method: attribute a type tree.
com.sun.tools.javac.comp.Attr#attribType(JCTree, Env, Type)->Type:::Derived visitor method: attribute a type tree.
com.sun.tools.javac.comp.Attr#attribStat(JCTree, Env)->Type:::Derived visitor method: attribute a statement or definition tree.
com.sun.tools.javac.comp.Attr#attribExprs(List, Env, Type)->List:::Attribute a list of expressions, returning a list of types.
com.sun.tools.javac.comp.Attr#attribStats(List, Env)->void:::Attribute a list of statements, returning nothing.
com.sun.tools.javac.comp.Attr#attribArgs(KindSelector, List, Env, ListBuffer)->KindSelector:::Attribute the arguments in a method call, returning the method kind.
com.sun.tools.javac.comp.Attr#attribAnyTypes(List, Env)->List:::Attribute a type argument list, returning a list of types
com.sun.tools.javac.comp.Attr#attribTypes(List, Env)->List:::Attribute a type argument list, returning a list of types
com.sun.tools.javac.comp.Attr#attribTypeVariables(List, Env)->void:::Attribute type variables (of generic classes or methods)
com.sun.tools.javac.comp.Attr#attribAnnotationTypes(List, Env)->void:::Attribute the type references in a list of annotations.
com.sun.tools.javac.comp.Attr#attribLazyConstantValue(Env, JCVariableDecl, Type)->Object:::Attribute a "lazy constant value".
com.sun.tools.javac.comp.Attr#attribBase(JCTree, Env, boolean, boolean, boolean)->Type:::Attribute type reference in an `extends' or `implements' clause
com.sun.tools.javac.comp.Attr#checkBase(Type, JCTree, Env, boolean, boolean, boolean)->Type::: attr check base
com.sun.tools.javac.comp.Attr#attribIdentAsEnumType(Env, JCIdent)->Type::: attr attrib ident as enum type
com.sun.tools.javac.comp.Attr#visitClassDef(JCClassDecl)->void::: attr visit class def
com.sun.tools.javac.comp.Attr#visitMethodDef(JCMethodDecl)->void::: attr visit method def
com.sun.tools.javac.comp.Attr#visitVarDef(JCVariableDecl)->void::: attr visit var def
com.sun.tools.javac.comp.Attr#canInferLocalVarType(JCVariableDecl)->Fragment::: attr can infer local var type
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitNewArray(JCNewArray)->void::: local init scanner visit new array
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitLambda(JCLambda)->void::: local init scanner visit lambda
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitTypeCast(JCTypeCast)->void::: local init scanner visit type cast
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitReference(JCMemberReference)->void::: local init scanner visit reference
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitNewClass(JCNewClass)->void::: local init scanner visit new class
com.sun.tools.javac.comp.Attr.LocalInitScanner#visitApply(JCMethodInvocation)->void::: local init scanner visit apply
com.sun.tools.javac.comp.Attr#visitSkip(JCSkip)->void::: attr visit skip
com.sun.tools.javac.comp.Attr#visitBlock(JCBlock)->void::: attr visit block
com.sun.tools.javac.comp.Attr#visitDoLoop(JCDoWhileLoop)->void::: attr visit do loop
com.sun.tools.javac.comp.Attr#visitWhileLoop(JCWhileLoop)->void::: attr visit while loop
com.sun.tools.javac.comp.Attr#visitForLoop(JCForLoop)->void::: attr visit for loop
com.sun.tools.javac.comp.Attr#visitForeachLoop(JCEnhancedForLoop)->void::: attr visit foreach loop
com.sun.tools.javac.comp.Attr#visitLabelled(JCLabeledStatement)->void::: attr visit labelled
com.sun.tools.javac.comp.Attr#visitSwitch(JCSwitch)->void::: attr visit switch
com.sun.tools.javac.comp.Attr#visitSynchronized(JCSynchronized)->void::: attr visit synchronized
com.sun.tools.javac.comp.Attr#visitTry(JCTry)->void::: attr visit try
com.sun.tools.javac.comp.Attr#checkAutoCloseable(DiagnosticPosition, Env, Type)->void::: attr check auto closeable
com.sun.tools.javac.comp.Attr#visitConditional(JCConditional)->void::: attr visit conditional
com.sun.tools.javac.comp.Attr#primitiveOrBoxed(Type)->boolean::: attr primitive or boxed
com.sun.tools.javac.comp.Attr#conditionalContext(CheckContext)->CheckContext::: attr conditional context
com.sun.tools.javac.comp.Attr#condType(DiagnosticPosition, Type, Type)->Type:::Compute the type of a conditional expression, after  checking that it exists
com.sun.tools.javac.comp.Attr#visitIf(JCIf)->void::: attr visit if
com.sun.tools.javac.comp.Attr#visitExec(JCExpressionStatement)->void::: attr visit exec
com.sun.tools.javac.comp.Attr#visitBreak(JCBreak)->void::: attr visit break
com.sun.tools.javac.comp.Attr#visitContinue(JCContinue)->void::: attr visit continue
com.sun.tools.javac.comp.Attr#visitReturn(JCReturn)->void::: attr visit return
com.sun.tools.javac.comp.Attr#visitThrow(JCThrow)->void::: attr visit throw
com.sun.tools.javac.comp.Attr#visitAssert(JCAssert)->void::: attr visit assert
com.sun.tools.javac.comp.Attr#visitApply(JCMethodInvocation)->void:::Visitor method for method invocations
com.sun.tools.javac.comp.Attr#adjustMethodReturnType(Symbol, Type, Name, List, Type)->Type::: attr adjust method return type
com.sun.tools.javac.comp.Attr#checkFirstConstructorStat(JCMethodInvocation, Env)->boolean:::Check that given application node appears as first statement  in a constructor call.
com.sun.tools.javac.comp.Attr#newMethodTemplate(Type, List, List)->Type:::Obtain a method type with given argument types.
com.sun.tools.javac.comp.Attr#visitNewClass(JCNewClass)->void::: attr visit new class
com.sun.tools.javac.comp.Attr#diamondContext(JCNewClass, TypeSymbol, CheckContext)->CheckContext::: attr diamond context
com.sun.tools.javac.comp.Attr#makeNullCheck(JCExpression)->JCExpression:::Make an attributed null check tree.
com.sun.tools.javac.comp.Attr#visitNewArray(JCNewArray)->void::: attr visit new array
com.sun.tools.javac.comp.Attr#visitLambda(JCLambda)->void::: attr visit lambda
com.sun.tools.javac.comp.Attr#getTargetInfo(JCPolyExpression, ResultInfo, List)->TargetInfo::: attr get target info
com.sun.tools.javac.comp.Attr#preFlow(JCLambda)->void::: attr pre flow
com.sun.tools.javac.comp.Attr.FunctionalReturnContext#compatible(Type, Type, Warner)->boolean::: functional return context compatible
com.sun.tools.javac.comp.Attr.FunctionalReturnContext#report(DiagnosticPosition, JCDiagnostic)->void::: functional return context report
com.sun.tools.javac.comp.Attr.ExpressionLambdaReturnContext#report(DiagnosticPosition, JCDiagnostic)->void::: expression lambda return context report
com.sun.tools.javac.comp.Attr.ExpressionLambdaReturnContext#compatible(Type, Type, Warner)->boolean::: expression lambda return context compatible
com.sun.tools.javac.comp.Attr#lambdaBodyResult(JCLambda, Type, ResultInfo)->ResultInfo::: attr lambda body result
com.sun.tools.javac.comp.Attr#checkLambdaCompatible(JCLambda, Type, CheckContext)->void:::Lambda compatibility
com.sun.tools.javac.comp.Attr#removeClinit(ClassSymbol)->MethodSymbol::: attr remove clinit
com.sun.tools.javac.comp.Attr#lambdaEnv(JCLambda, Env)->Env::: attr lambda env
com.sun.tools.javac.comp.Attr#visitReference(JCMemberReference)->void::: attr visit reference
com.sun.tools.javac.comp.Attr#memberReferenceQualifierResult(JCMemberReference)->ResultInfo::: attr member reference qualifier result
com.sun.tools.javac.comp.Attr#checkReferenceCompatible(JCMemberReference, Type, Type, CheckContext, boolean)->void::: attr check reference compatible
com.sun.tools.javac.comp.Attr#checkExConstraints(List, List, InferenceContext)->boolean::: attr check ex constraints
com.sun.tools.javac.comp.Attr#visitParens(JCParens)->void::: attr visit parens
com.sun.tools.javac.comp.Attr#visitAssign(JCAssign)->void::: attr visit assign
com.sun.tools.javac.comp.Attr#visitAssignop(JCAssignOp)->void::: attr visit assignop
com.sun.tools.javac.comp.Attr#visitUnary(JCUnary)->void::: attr visit unary
com.sun.tools.javac.comp.Attr#visitBinary(JCBinary)->void::: attr visit binary
com.sun.tools.javac.comp.Attr#visitTypeCast(JCTypeCast)->void::: attr visit type cast
com.sun.tools.javac.comp.Attr#visitTypeTest(JCInstanceOf)->void::: attr visit type test
com.sun.tools.javac.comp.Attr#visitIndexed(JCArrayAccess)->void::: attr visit indexed
com.sun.tools.javac.comp.Attr#visitIdent(JCIdent)->void::: attr visit ident
com.sun.tools.javac.comp.Attr#visitSelect(JCFieldAccess)->void::: attr visit select
com.sun.tools.javac.comp.Attr#checkId(JCTree, Type, Symbol, Env, ResultInfo)->Type:::Determine type of identifier or select expression and check that  (1) the referenced symbol is not deprecated  (2) the symbol's type is safe (@see checkSafe)  (3) if symbol is a variable, check that its type and kind are      compatible with the prototype and protokind
com.sun.tools.javac.comp.Attr#checkMethodIdInternal(JCTree, Type, Symbol, Env, ResultInfo)->Type::: attr check method id internal
com.sun.tools.javac.comp.Attr#checkIdInternal(JCTree, Type, Symbol, Type, Env, ResultInfo)->Type::: attr check id internal
com.sun.tools.javac.comp.Attr#enclosingInitEnv(Env)->Env:::Returns the enclosing init environment associated with this env (if any)
com.sun.tools.javac.comp.Attr#checkMethod(Type, Symbol, ResultInfo, Env, List, List, List)->Type:::Check that method arguments conform to its instantiation.
com.sun.tools.javac.comp.Attr#visitLiteral(JCLiteral)->void::: attr visit literal
com.sun.tools.javac.comp.Attr#litType(TypeTag)->Type:::Return the type of a literal with given type tag.
com.sun.tools.javac.comp.Attr#visitTypeIdent(JCPrimitiveTypeTree)->void::: attr visit type ident
com.sun.tools.javac.comp.Attr#visitTypeArray(JCArrayTypeTree)->void::: attr visit type array
com.sun.tools.javac.comp.Attr#visitTypeApply(JCTypeApply)->void:::Visitor method for parameterized types
com.sun.tools.javac.comp.Attr#visitTypeUnion(JCTypeUnion)->void::: attr visit type union
com.sun.tools.javac.comp.Attr#visitTypeIntersection(JCTypeIntersection)->void::: attr visit type intersection
com.sun.tools.javac.comp.Attr#visitTypeParameter(JCTypeParameter)->void::: attr visit type parameter
com.sun.tools.javac.comp.Attr#checkIntersection(JCTree, List)->Type::: attr check intersection
com.sun.tools.javac.comp.Attr#visitWildcard(JCWildcard)->void::: attr visit wildcard
com.sun.tools.javac.comp.Attr#visitAnnotation(JCAnnotation)->void::: attr visit annotation
com.sun.tools.javac.comp.Attr#visitAnnotatedType(JCAnnotatedType)->void::: attr visit annotated type
com.sun.tools.javac.comp.Attr#visitErroneous(JCErroneous)->void::: attr visit erroneous
com.sun.tools.javac.comp.Attr#visitTree(JCTree)->void:::Default visitor method for all other trees.
com.sun.tools.javac.comp.Attr#attrib(Env)->void:::Attribute an env for either a top level tree or class or module declaration.
com.sun.tools.javac.comp.Attr#attribTopLevel(Env)->void:::Attribute a top level tree
com.sun.tools.javac.comp.Attr#attribPackage(DiagnosticPosition, PackageSymbol)->void::: attr attrib package
com.sun.tools.javac.comp.Attr#attribPackage(PackageSymbol)->void::: attr attrib package
com.sun.tools.javac.comp.Attr#attribModule(DiagnosticPosition, ModuleSymbol)->void::: attr attrib module
com.sun.tools.javac.comp.Attr#attribModule(ModuleSymbol)->void::: attr attrib module
com.sun.tools.javac.comp.Attr#attribClass(DiagnosticPosition, ClassSymbol)->void:::Main method: attribute class definition associated with given class symbol
com.sun.tools.javac.comp.Attr#attribClass(ClassSymbol)->void:::Attribute class definition associated with given class symbol.
com.sun.tools.javac.comp.Attr#visitImport(JCImport)->void::: attr visit import
com.sun.tools.javac.comp.Attr#visitModuleDef(JCModuleDecl)->void::: attr visit module def
com.sun.tools.javac.comp.Attr#isSerializable(Type)->boolean:::check if a type is a subtype of Serializable, if that is available.
com.sun.tools.javac.comp.Attr#validateTypeAnnotations(JCTree, boolean)->void::: attr validate type annotations
com.sun.tools.javac.comp.Attr#postAttr(JCTree)->void:::Handle missing types/symbols in an AST
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#scan(JCTree)->void::: post attr analyzer scan
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitIdent(JCIdent)->void::: post attr analyzer visit ident
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitSelect(JCFieldAccess)->void::: post attr analyzer visit select
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitClassDef(JCClassDecl)->void::: post attr analyzer visit class def
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitMethodDef(JCMethodDecl)->void::: post attr analyzer visit method def
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitVarDef(JCVariableDecl)->void::: post attr analyzer visit var def
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitNewClass(JCNewClass)->void::: post attr analyzer visit new class
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitAssignop(JCAssignOp)->void::: post attr analyzer visit assignop
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitBinary(JCBinary)->void::: post attr analyzer visit binary
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitUnary(JCUnary)->void::: post attr analyzer visit unary
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitLambda(JCLambda)->void::: post attr analyzer visit lambda
com.sun.tools.javac.comp.Attr.PostAttrAnalyzer#visitReference(JCMemberReference)->void::: post attr analyzer visit reference
com.sun.tools.javac.comp.Attr#setPackageSymbols(JCExpression, Symbol)->void::: attr set package symbols
com.sun.tools.javac.comp.AttrContext#dup(WriteableScope)->AttrContext:::Duplicate this context, replacing scope field and copying all others.
com.sun.tools.javac.comp.AttrContext#dup()->AttrContext:::Duplicate this context, copying all fields.
com.sun.tools.javac.comp.AttrContext#getLocalElements()->Iterable::: attr context get local elements
com.sun.tools.javac.comp.AttrContext#lastResolveVarargs()->boolean::: attr context last resolve varargs
com.sun.tools.javac.comp.AttrContext#toString()->String::: attr context to string
com.sun.tools.javac.comp.Check#instance(Context)->Check::: check instance
com.sun.tools.javac.comp.Check#setLint(Lint)->Lint::: check set lint
com.sun.tools.javac.comp.Check#setMethod(MethodSymbol)->MethodSymbol::: check set method
com.sun.tools.javac.comp.Check#warnDeprecated(DiagnosticPosition, Symbol)->void:::Warn about deprecated symbol.
com.sun.tools.javac.comp.Check#warnUnchecked(DiagnosticPosition, Warning)->void:::Warn about unchecked operation.
com.sun.tools.javac.comp.Check#warnUnsafeVararg(DiagnosticPosition, Warning)->void:::Warn about unsafe vararg method decl.
com.sun.tools.javac.comp.Check#warnStatic(DiagnosticPosition, Warning)->void::: check warn static
com.sun.tools.javac.comp.Check#warnDivZero(DiagnosticPosition)->void:::Warn about division by integer constant zero.
com.sun.tools.javac.comp.Check#reportDeferredDiagnostics()->void:::Report any deferred diagnostics.
com.sun.tools.javac.comp.Check#completionError(DiagnosticPosition, CompletionFailure)->Type:::Report a failure to complete a class.
com.sun.tools.javac.comp.Check#typeTagError(DiagnosticPosition, JCDiagnostic, Object)->Type:::Report an error that wrong type tag was found.
com.sun.tools.javac.comp.Check#earlyRefError(DiagnosticPosition, Symbol)->void:::Report an error that symbol cannot be referenced before super  has been called.
com.sun.tools.javac.comp.Check#duplicateError(DiagnosticPosition, Symbol)->void:::Report duplicate declaration error.
com.sun.tools.javac.comp.Check#varargsDuplicateError(DiagnosticPosition, Symbol, Symbol)->void:::Report array/varargs duplicate declaration
com.sun.tools.javac.comp.Check#checkTransparentVar(DiagnosticPosition, VarSymbol, Scope)->void:::Check that variable does not hide variable with same name in  immediately enclosing local scope.
com.sun.tools.javac.comp.Check#checkTransparentClass(DiagnosticPosition, ClassSymbol, Scope)->void:::Check that a class or interface does not hide a class or  interface with same name in immediately enclosing local scope.
com.sun.tools.javac.comp.Check#checkUniqueClassName(DiagnosticPosition, Name, Scope)->boolean:::Check that class does not have the same name as one of  its enclosing classes, or as a class defined in its enclosing scope
com.sun.tools.javac.comp.Check#localClassName(ClassSymbol)->Name:::Return name of local class
com.sun.tools.javac.comp.Check#clearLocalClassNameIndexes(ClassSymbol)->void::: check clear local class name indexes
com.sun.tools.javac.comp.Check#newRound()->void::: check new round
com.sun.tools.javac.comp.Check#putCompiled(ClassSymbol)->void::: check put compiled
com.sun.tools.javac.comp.Check#getCompiled(ClassSymbol)->ClassSymbol::: check get compiled
com.sun.tools.javac.comp.Check#getCompiled(ModuleSymbol, Name)->ClassSymbol::: check get compiled
com.sun.tools.javac.comp.Check#removeCompiled(ClassSymbol)->void::: check remove compiled
com.sun.tools.javac.comp.Check.CheckContext#compatible(Type, Type, Warner)->boolean:::Is type 'found' compatible with type 'req' in given context
com.sun.tools.javac.comp.Check.CheckContext#report(DiagnosticPosition, JCDiagnostic)->void:::Report a check error
com.sun.tools.javac.comp.Check.CheckContext#checkWarner(DiagnosticPosition, Type, Type)->Warner:::Obtain a warner for this check context
com.sun.tools.javac.comp.Check.CheckContext#inferenceContext()->InferenceContext::: check context inference context
com.sun.tools.javac.comp.Check.CheckContext#deferredAttrContext()->DeferredAttr.DeferredAttrContext::: check context deferred attr context
com.sun.tools.javac.comp.Check.NestedCheckContext#compatible(Type, Type, Warner)->boolean::: nested check context compatible
com.sun.tools.javac.comp.Check.NestedCheckContext#report(DiagnosticPosition, JCDiagnostic)->void::: nested check context report
com.sun.tools.javac.comp.Check.NestedCheckContext#checkWarner(DiagnosticPosition, Type, Type)->Warner::: nested check context check warner
com.sun.tools.javac.comp.Check.NestedCheckContext#inferenceContext()->InferenceContext::: nested check context inference context
com.sun.tools.javac.comp.Check.NestedCheckContext#deferredAttrContext()->DeferredAttrContext::: nested check context deferred attr context
com.sun.tools.javac.comp.Check#checkType(DiagnosticPosition, Type, Type)->Type:::Check that a given type is assignable to a given proto-type
com.sun.tools.javac.comp.Check#checkType(DiagnosticPosition, Type, Type, CheckContext)->Type::: check check type
com.sun.tools.javac.comp.Check#checkCastable(DiagnosticPosition, Type, Type)->Type:::Check that a given type can be cast to a given target type
com.sun.tools.javac.comp.Check#checkCastable(DiagnosticPosition, Type, Type, CheckContext)->Type::: check check castable
com.sun.tools.javac.comp.Check#checkRedundantCast(Env, JCTypeCast)->void:::Check for redundant casts (i.e
com.sun.tools.javac.comp.Check#checkNonVoid(DiagnosticPosition, Type)->Type:::Check that type is different from 'void'.
com.sun.tools.javac.comp.Check#checkClassOrArrayType(DiagnosticPosition, Type)->Type::: check check class or array type
com.sun.tools.javac.comp.Check#checkClassType(DiagnosticPosition, Type)->Type:::Check that type is a class or interface type.
com.sun.tools.javac.comp.Check#checkConstructorRefType(DiagnosticPosition, Type)->Type:::Check that type is a valid qualifier for a constructor reference expression
com.sun.tools.javac.comp.Check#checkClassType(DiagnosticPosition, Type, boolean)->Type:::Check that type is a class or interface type.
com.sun.tools.javac.comp.Check#checkRefType(DiagnosticPosition, Type)->Type:::Check that type is a reference type, i.e
com.sun.tools.javac.comp.Check#checkRefTypes(List, List)->List:::Check that each type is a reference type, i.e
com.sun.tools.javac.comp.Check#checkNullOrRefType(DiagnosticPosition, Type)->Type:::Check that type is a null or reference type.
com.sun.tools.javac.comp.Check#checkDisjoint(DiagnosticPosition, long, long, long)->boolean:::Check that flag set does not contain elements of two conflicting sets
com.sun.tools.javac.comp.Check#checkDiamond(JCNewClass, Type)->Type:::Check that usage of diamond operator is correct (i.e
com.sun.tools.javac.comp.Check#checkDiamondDenotable(ClassType)->List:::Check that the type inferred using the diamond operator does not contain  non-denotable types such as captured types or intersection types.
com.sun.tools.javac.comp.Check#checkDenotable(Type)->boolean::: check check denotable
com.sun.tools.javac.comp.Check#checkVarargsMethodDecl(Env, JCMethodDecl)->void::: check check varargs method decl
com.sun.tools.javac.comp.Check#checkLocalVarType(DiagnosticPosition, Type, Name)->Type::: check check local var type
com.sun.tools.javac.comp.Check#checkMethod(Type, Symbol, Env, List, List, boolean, InferenceContext)->Type::: check check method
com.sun.tools.javac.comp.Check#checkValidGenericType(Type)->boolean:::Check that type 't' is a valid instantiation of a generic class (see JLS 4.5)
com.sun.tools.javac.comp.Check#isTypeArgErroneous(Type)->boolean::: check is type arg erroneous
com.sun.tools.javac.comp.Check#checkFlags(DiagnosticPosition, long, Symbol, JCTree)->long:::Check that given modifiers are legal for given symbol and  return modifiers together with any implicit modifiers for that symbol
com.sun.tools.javac.comp.Check#validate(JCTree, Env)->void:::Validate a type expression
com.sun.tools.javac.comp.Check#validate(JCTree, Env, boolean)->void::: check validate
com.sun.tools.javac.comp.Check#validate(List, Env)->void:::Visitor method: Validate a list of type expressions.
com.sun.tools.javac.comp.Check.Validator#visitTypeArray(JCArrayTypeTree)->void::: validator visit type array
com.sun.tools.javac.comp.Check.Validator#visitTypeApply(JCTypeApply)->void::: validator visit type apply
com.sun.tools.javac.comp.Check.Validator#visitTypeParameter(JCTypeParameter)->void::: validator visit type parameter
com.sun.tools.javac.comp.Check.Validator#visitWildcard(JCWildcard)->void::: validator visit wildcard
com.sun.tools.javac.comp.Check.Validator#visitSelect(JCFieldAccess)->void::: validator visit select
com.sun.tools.javac.comp.Check.Validator#visitSelectInternal(JCFieldAccess)->void::: validator visit select internal
com.sun.tools.javac.comp.Check.Validator#visitAnnotatedType(JCAnnotatedType)->void::: validator visit annotated type
com.sun.tools.javac.comp.Check.Validator#visitTypeIdent(JCPrimitiveTypeTree)->void::: validator visit type ident
com.sun.tools.javac.comp.Check.Validator#visitTree(JCTree)->void:::Default visitor method: do nothing.
com.sun.tools.javac.comp.Check.Validator#validateTree(JCTree, boolean, boolean)->void::: validator validate tree
com.sun.tools.javac.comp.Check.Validator#validateTrees(List, boolean, boolean)->void::: validator validate trees
com.sun.tools.javac.comp.Check#checkRaw(JCTree, Env)->void::: check check raw
com.sun.tools.javac.comp.Check#subset(Type, List)->boolean:::Is given type a subtype of some of the types in given list?
com.sun.tools.javac.comp.Check#intersects(Type, List)->boolean:::Is given type a subtype or supertype of  some of the types in given list?
com.sun.tools.javac.comp.Check#incl(Type, List)->List:::Add type set to given type list, unless it is a subclass of some class  in the list.
com.sun.tools.javac.comp.Check#excl(Type, List)->List:::Remove type set from type set list.
com.sun.tools.javac.comp.Check#union(List, List)->List:::Form the union of two type set lists.
com.sun.tools.javac.comp.Check#diff(List, List)->List:::Form the difference of two type lists.
com.sun.tools.javac.comp.Check#intersect(List, List)->List:::Form the intersection of two type lists.
com.sun.tools.javac.comp.Check#isUnchecked(ClassSymbol)->boolean:::Is exc an exception symbol that need not be declared?
com.sun.tools.javac.comp.Check#isUnchecked(Type)->boolean:::Is exc an exception type that need not be declared?
com.sun.tools.javac.comp.Check#isChecked(Type)->boolean::: check is checked
com.sun.tools.javac.comp.Check#isUnchecked(DiagnosticPosition, Type)->boolean:::Same, but handling completion failures.
com.sun.tools.javac.comp.Check#isHandled(Type, List)->boolean:::Is exc handled by given exception list?
com.sun.tools.javac.comp.Check#unhandled(List, List)->List:::Return all exceptions in thrown list that are not in handled list.
com.sun.tools.javac.comp.Check#protection(long)->int:::The level of access protection given by a flag set,  where PRIVATE is highest and PUBLIC is lowest.
com.sun.tools.javac.comp.Check#cannotOverride(MethodSymbol, MethodSymbol)->Fragment:::A customized "cannot override" error message.
com.sun.tools.javac.comp.Check#uncheckedOverrides(MethodSymbol, MethodSymbol)->Fragment:::A customized "override" warning message.
com.sun.tools.javac.comp.Check#varargsOverrides(MethodSymbol, MethodSymbol)->Fragment:::A customized "override" warning message.
com.sun.tools.javac.comp.Check#checkOverride(JCTree, MethodSymbol, MethodSymbol, ClassSymbol)->void:::Check that this method conforms with overridden method 'other'
com.sun.tools.javac.comp.Check#checkCompatibleConcretes(DiagnosticPosition, Type)->void:::Check that a class does not inherit two concrete methods  with the same signature.
com.sun.tools.javac.comp.Check#checkCompatibleAbstracts(DiagnosticPosition, Type, Type, Type)->boolean:::Check that classes (or interfaces) do not each define an abstract  method with same name and arguments but incompatible return types.
com.sun.tools.javac.comp.Check#checkCommonOverriderIn(Symbol, Symbol, Type)->boolean::: check check common overrider in
com.sun.tools.javac.comp.Check#checkOverride(Env, JCMethodDecl, MethodSymbol)->void:::Check that a given method conforms with any method it overrides.
com.sun.tools.javac.comp.Check#checkOverride(JCTree, Type, ClassSymbol, MethodSymbol)->void::: check check override
com.sun.tools.javac.comp.Check#checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition, ClassSymbol)->void::: check check class override equals and hash if needed
com.sun.tools.javac.comp.Check#checkModuleName(JCModuleDecl)->void::: check check module name
com.sun.tools.javac.comp.Check#checkAllDefined(DiagnosticPosition, ClassSymbol)->void:::Check that all abstract members of given class have definitions.
com.sun.tools.javac.comp.Check#checkNonCyclicDecl(JCClassDecl)->void::: check check non cyclic decl
com.sun.tools.javac.comp.Check.CycleChecker#visitSelect(JCFieldAccess)->void::: cycle checker visit select
com.sun.tools.javac.comp.Check.CycleChecker#visitIdent(JCIdent)->void::: cycle checker visit ident
com.sun.tools.javac.comp.Check.CycleChecker#visitTypeApply(JCTypeApply)->void::: cycle checker visit type apply
com.sun.tools.javac.comp.Check.CycleChecker#visitTypeArray(JCArrayTypeTree)->void::: cycle checker visit type array
com.sun.tools.javac.comp.Check.CycleChecker#visitClassDef(JCClassDecl)->void::: cycle checker visit class def
com.sun.tools.javac.comp.Check.CycleChecker#checkClass(DiagnosticPosition, Symbol, List)->void::: cycle checker check class
com.sun.tools.javac.comp.Check#checkNonCyclic(DiagnosticPosition, Type)->void:::Check for cyclic references
com.sun.tools.javac.comp.Check#checkNonCyclic(DiagnosticPosition, TypeVar)->void::: check check non cyclic
com.sun.tools.javac.comp.Check#checkImplementations(JCClassDecl)->void:::Check that all methods which implement some  method conform to the method they implement.
com.sun.tools.javac.comp.Check#checkImplementations(JCTree, ClassSymbol, ClassSymbol)->void:::Check that all methods which implement some  method in `ic' conform to the method they implement.
com.sun.tools.javac.comp.Check#checkCompatibleSupertypes(DiagnosticPosition, Type)->void:::Check that all abstract methods implemented by a class are  mutually compatible.
com.sun.tools.javac.comp.Check#checkOverrideClashes(DiagnosticPosition, Type, MethodSymbol)->void:::Check that all non-override equivalent methods accessible from 'site'  are mutually compatible (JLS 8.4.8/9.4.1).
com.sun.tools.javac.comp.Check#checkHideClashes(DiagnosticPosition, Type, MethodSymbol)->void:::Check that all static methods accessible from 'site' are  mutually compatible (JLS 8.4.8).
com.sun.tools.javac.comp.Check#checkDefaultMethodClashes(DiagnosticPosition, Type)->void::: check check default method clashes
com.sun.tools.javac.comp.Check#checkPotentiallyAmbiguousOverloads(DiagnosticPosition, Type, MethodSymbol, MethodSymbol)->void:::Report warnings for potentially ambiguous method declarations
com.sun.tools.javac.comp.Check#checkAccessFromSerializableElement(JCTree, boolean)->void::: check check access from serializable element
com.sun.tools.javac.comp.Check#checkClassBounds(DiagnosticPosition, Type)->void:::Check that class c does not implement directly or indirectly  the same parameterized interface with two different argument lists.
com.sun.tools.javac.comp.Check#checkClassBounds(DiagnosticPosition, Map, Type)->void:::Enter all interfaces of type `type' into the hash table `seensofar'  with their class symbol as key and their type as value
com.sun.tools.javac.comp.Check#checkNotRepeated(DiagnosticPosition, Type, Set)->void:::Enter interface into into set
com.sun.tools.javac.comp.Check#validateAnnotationTree(JCTree)->void:::Recursively validate annotations values
com.sun.tools.javac.comp.Check#validateAnnotationType(JCTree)->void::: {@literal  Annotation types are restricted to primitives, String, an  enum, an annotation, Class, Class<?>, Class<? extends  Anything>, arrays of the preceding
com.sun.tools.javac.comp.Check#validateAnnotationType(DiagnosticPosition, Type)->void::: check validate annotation type
com.sun.tools.javac.comp.Check#validateAnnotationMethod(DiagnosticPosition, MethodSymbol)->void:::"It is also a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any public or protected method declared in class Object or in the interface annotation.Annotation."
com.sun.tools.javac.comp.Check#validateAnnotations(List, Symbol)->void:::Check the annotations of a symbol.
com.sun.tools.javac.comp.Check#validateTypeAnnotations(List, boolean)->void:::Check the type annotations.
com.sun.tools.javac.comp.Check#validateTypeAnnotation(JCAnnotation, boolean)->void::: check validate type annotation
com.sun.tools.javac.comp.Check#validateRepeatable(TypeSymbol, Attribute.Compound, DiagnosticPosition)->void:::Validate the proposed container 'repeatable' on the annotation type symbol 's'
com.sun.tools.javac.comp.Check#isOverrider(Symbol)->boolean:::Is s a method symbol that overrides a method in a superclass?
com.sun.tools.javac.comp.Check#isTypeAnnotation(JCAnnotation, boolean)->boolean:::Is the annotation applicable to types?
com.sun.tools.javac.comp.Check#isTypeAnnotation(Attribute, boolean)->boolean::: check is type annotation
com.sun.tools.javac.comp.Check#annotationApplicable(JCAnnotation, Symbol)->boolean:::Is the annotation applicable to the symbol?
com.sun.tools.javac.comp.Check#getAttributeTargetAttribute(TypeSymbol)->Attribute.Array::: check get attribute target attribute
com.sun.tools.javac.comp.Check#validateAnnotationDeferErrors(JCAnnotation)->boolean:::Check an annotation value.
com.sun.tools.javac.comp.Check#validateTargetAnnotationValue(JCAnnotation)->boolean::: check validate target annotation value
com.sun.tools.javac.comp.Check#checkDeprecatedAnnotation(DiagnosticPosition, Symbol)->void::: check check deprecated annotation
com.sun.tools.javac.comp.Check#checkDeprecated(DiagnosticPosition, Symbol, Symbol)->void::: check check deprecated
com.sun.tools.javac.comp.Check#checkSunAPI(DiagnosticPosition, Symbol)->void::: check check sun i
com.sun.tools.javac.comp.Check#checkProfile(DiagnosticPosition, Symbol)->void::: check check profile
com.sun.tools.javac.comp.Check#checkNonCyclicElements(JCClassDecl)->void:::Check for cycles in the graph of annotation elements.
com.sun.tools.javac.comp.Check#checkNonCyclicElementsInternal(DiagnosticPosition, TypeSymbol)->void::: check check non cyclic elements internal
com.sun.tools.javac.comp.Check#checkAnnotationResType(DiagnosticPosition, Type)->void::: check check annotation res type
com.sun.tools.javac.comp.Check#checkCyclicConstructors(JCClassDecl)->void:::Check for cycles in the graph of constructors calling other  constructors.
com.sun.tools.javac.comp.Check#checkDivZero(DiagnosticPosition, Symbol, Type)->void::: Check for division by integer constant zero
com.sun.tools.javac.comp.Check#checkEmptyIf(JCIf)->void:::Check for empty statements after if
com.sun.tools.javac.comp.Check#checkUnique(DiagnosticPosition, Symbol, Scope)->boolean:::Check that symbol is unique in given scope.
com.sun.tools.javac.comp.Check#duplicateErasureError(DiagnosticPosition, Symbol, Symbol)->void:::Report duplicate declaration error.
com.sun.tools.javac.comp.Check#checkImportsUnique(JCCompilationUnit)->void:::Check that types imported through the ordinary imports don't clash with types imported by other (static or ordinary) imports
com.sun.tools.javac.comp.Check#checkCanonical(JCTree)->void:::Check that a qualified name is in canonical form (for import decls).
com.sun.tools.javac.comp.Check#checkForBadAuxiliaryClassAccess(DiagnosticPosition, Env, ClassSymbol)->void:::Check that an auxiliary class is not accessed from any other file than its own.
com.sun.tools.javac.comp.Check#castWarner(DiagnosticPosition, Type, Type)->Warner::: check cast warner
com.sun.tools.javac.comp.Check#convertWarner(DiagnosticPosition, Type, Type)->Warner::: check convert warner
com.sun.tools.javac.comp.Check#checkFunctionalInterface(JCClassDecl, ClassSymbol)->void::: check check functional interface
com.sun.tools.javac.comp.Check#checkImportsResolvable(JCCompilationUnit)->void::: check check imports resolvable
com.sun.tools.javac.comp.Check#checkImportedPackagesObservable(JCCompilationUnit)->void::: check check imported packages observable
com.sun.tools.javac.comp.Check#importAccessible(Symbol, PackageSymbol)->boolean::: check import accessible
com.sun.tools.javac.comp.Check#checkLeaksNotAccessible(Env, JCClassDecl)->void::: check check leaks not accessible
com.sun.tools.javac.comp.Check#checkModuleExists(DiagnosticPosition, ModuleSymbol)->void::: check check module exists
com.sun.tools.javac.comp.Check#checkPackageExistsForOpens(DiagnosticPosition, PackageSymbol)->void::: check check package exists for opens
com.sun.tools.javac.comp.Check#checkModuleRequires(DiagnosticPosition, RequiresDirective)->void::: check check module requires
com.sun.tools.javac.comp.CompileStates#instance(Context)->CompileStates:::Get the CompileStates instance for this context.
com.sun.tools.javac.comp.CompileStates#isDone(Env, CompileState)->boolean::: compile states is done
com.sun.tools.javac.comp.ConstFold#instance(Context)->ConstFold::: const fold instance
com.sun.tools.javac.comp.ConstFold#fold1(int, Type)->Type:::Fold unary operation.
com.sun.tools.javac.comp.ConstFold#fold2(int, Type, Type)->Type:::Fold binary operation.
com.sun.tools.javac.comp.ConstFold#coerce(Type, Type)->Type:::Coerce constant type to target type.
com.sun.tools.javac.comp.DeferredAttr#instance(Context)->DeferredAttr::: deferred attr instance
com.sun.tools.javac.comp.DeferredAttr.DeferredType#cloneWithMetadata(TypeMetadata)->DeferredType::: deferred type clone with metadata
com.sun.tools.javac.comp.DeferredAttr.DeferredType#getTag()->TypeTag::: deferred type get tag
com.sun.tools.javac.comp.DeferredAttr.DeferredType#toString()->String::: deferred type to string
com.sun.tools.javac.comp.DeferredAttr.DeferredType.SpeculativeCache.Entry#matches(MethodResolutionPhase)->boolean::: entry matches
com.sun.tools.javac.comp.DeferredAttr.DeferredType.SpeculativeCache#get(Symbol, MethodResolutionPhase)->Entry:::Retrieve a speculative cache entry corresponding to given symbol and resolution phase
com.sun.tools.javac.comp.DeferredAttr.DeferredType.SpeculativeCache#put(JCTree, ResultInfo)->void:::Stores a speculative cache entry corresponding to given symbol and resolution phase
com.sun.tools.javac.comp.DeferredAttr.DeferredType#speculativeType(Symbol, MethodResolutionPhase)->Type:::Get the type that has been computed during a speculative attribution round
com.sun.tools.javac.comp.DeferredAttr.DeferredType#speculativeTree(DeferredAttrContext)->JCTree::: deferred type speculative tree
com.sun.tools.javac.comp.DeferredAttr.DeferredType#completer()->DeferredTypeCompleter::: deferred type completer
com.sun.tools.javac.comp.DeferredAttr.DeferredType#check(ResultInfo)->Type:::Check a deferred type against a potential target-type
com.sun.tools.javac.comp.DeferredAttr.DeferredTypeCompleter#complete(DeferredType, ResultInfo, DeferredAttrContext)->Type:::Entry point for type-checking a deferred type
com.sun.tools.javac.comp.DeferredAttr.DeferredStuckPolicy#isStuck()->boolean:::Has the policy detected that a given expression should be considered stuck?
com.sun.tools.javac.comp.DeferredAttr.DeferredStuckPolicy#stuckVars()->Set:::Get the set of inference variables a given expression depends upon.
com.sun.tools.javac.comp.DeferredAttr.DeferredStuckPolicy#depVars()->Set:::Get the set of inference variables which might get new constraints if a given expression is being type-checked.
com.sun.tools.javac.comp.DeferredAttr#attribSpeculativeLambda(JCLambda, Env, ResultInfo)->JCLambda:::Performs speculative attribution of a lambda body and returns the speculative lambda tree, in the absence of a target-type
com.sun.tools.javac.comp.DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo)->JCTree:::Routine that performs speculative type-checking; the input AST node is cloned (to avoid side-effects cause by Attr) and compiler state is restored after type-checking
com.sun.tools.javac.comp.DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo, LocalCacheContext)->JCTree::: deferred attr attrib speculative
com.sun.tools.javac.comp.DeferredAttr#attribSpeculative(JCTree, Env, ResultInfo, TreeCopier, Function, LocalCacheContext)->JCTree::: deferred attr attrib speculative
com.sun.tools.javac.comp.DeferredAttr.UnenterScanner#visitClassDef(JCClassDecl)->void::: unenter scanner visit class def
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrDiagHandler.PosScanner#scan(JCTree)->void::: pos scanner scan
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#addDeferredAttrNode(DeferredType, ResultInfo, DeferredStuckPolicy)->void:::Adds a node to the list of deferred attribution nodes - used by Resolve.rawCheckArgumentsApplicable Nodes added this way act as 'roots' for the out-of-order method checking process.
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#complete()->void:::Incrementally process all nodes, by skipping 'stuck' nodes and attributing 'unstuck' ones
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#insideOverloadPhase()->boolean::: deferred attr context inside overload phase
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#pickDeferredNode()->DeferredAttrNode:::Pick the deferred node to be unstuck
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#buildStuckGraph()->List::: deferred attr context build stuck graph
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext#canInfluence(InferenceGraph, StuckNode, StuckNode)->boolean::: deferred attr context can influence
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext.StuckNode#getSupportedDependencyKinds()->DependencyKind[]::: stuck node get supported dependency kinds
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext.StuckNode#getDependenciesByKind(DependencyKind)->Collection::: stuck node get dependencies by kind
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext.StuckNode#getAllDependencies()->Iterable::: stuck node get all dependencies
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode#process(DeferredAttrContext)->boolean:::Process a deferred attribution node
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#complete(DeferredType, ResultInfo, DeferredAttrContext)->Type::: structural stuck checker complete
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitLambda(JCLambda)->void::: structural stuck checker visit lambda
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#canLambdaBodyCompleteNormally(JCLambda)->boolean::: structural stuck checker can lambda body complete normally
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitNewClass(JCNewClass)->void::: structural stuck checker visit new class
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitApply(JCMethodInvocation)->void::: structural stuck checker visit apply
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.StructuralStuckChecker#visitReference(JCMemberReference)->void::: structural stuck checker visit reference
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitClassDef(JCClassDecl)->void::: lambda body struct checker visit class def
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitLambda(JCLambda)->void::: lambda body struct checker visit lambda
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitNewClass(JCNewClass)->void::: lambda body struct checker visit new class
com.sun.tools.javac.comp.DeferredAttr.DeferredAttrNode.LambdaBodyStructChecker#visitReturn(JCReturn)->void::: lambda body struct checker visit return
com.sun.tools.javac.comp.DeferredAttr.DeferredTypeMap#visitType(Type, Void)->Type::: deferred type map visit type
com.sun.tools.javac.comp.DeferredAttr.DeferredTypeMap#typeOf(DeferredType)->Type::: deferred type map type of
com.sun.tools.javac.comp.DeferredAttr.RecoveryDeferredTypeMap#typeOf(DeferredType)->Type::: recovery deferred type map type of
com.sun.tools.javac.comp.DeferredAttr.FilterScanner#scan(JCTree)->void::: filter scanner scan
com.sun.tools.javac.comp.DeferredAttr.FilterScanner#skip(JCTree)->void:::handler that is executed when a node has been discarded
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#isStuck()->boolean::: check stuck policy is stuck
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#stuckVars()->Set::: check stuck policy stuck vars
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#depVars()->Set::: check stuck policy dep vars
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#typesInferred(InferenceContext)->void::: check stuck policy types inferred
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#visitLambda(JCLambda)->void::: check stuck policy visit lambda
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#visitReference(JCMemberReference)->void::: check stuck policy visit reference
com.sun.tools.javac.comp.DeferredAttr.CheckStuckPolicy#scanLambdaBody(JCLambda, Type)->void::: check stuck policy scan lambda body
com.sun.tools.javac.comp.DeferredAttr.OverloadStuckPolicy#isStuck()->boolean::: overload stuck policy is stuck
com.sun.tools.javac.comp.DeferredAttr.OverloadStuckPolicy#visitLambda(JCLambda)->void::: overload stuck policy visit lambda
com.sun.tools.javac.comp.DeferredAttr.OverloadStuckPolicy#visitReference(JCMemberReference)->void::: overload stuck policy visit reference
com.sun.tools.javac.comp.Enter#instance(Context)->Enter::: enter instance
com.sun.tools.javac.comp.Enter#getEnv(TypeSymbol)->Env:::Accessor for typeEnvs
com.sun.tools.javac.comp.Enter#getEnvs()->Iterable>::: enter get envs
com.sun.tools.javac.comp.Enter#getClassEnv(TypeSymbol)->Env::: enter get class env
com.sun.tools.javac.comp.Enter#classEnv(JCClassDecl, Env)->Env:::Create a fresh environment for class bodies
com.sun.tools.javac.comp.Enter#topLevelEnv(JCCompilationUnit)->Env:::Create a fresh environment for toplevels.
com.sun.tools.javac.comp.Enter#getTopLevelEnv(JCCompilationUnit)->Env::: enter get top level env
com.sun.tools.javac.comp.Enter#enterScope(Env)->WriteableScope:::The scope in which a member definition in environment env is to be entered  This is usually the environment's scope, except for class environments,  where the local scope is for type variables, and the this and super symbol  only, and members go into the class member scope.
com.sun.tools.javac.comp.Enter#moduleEnv(JCModuleDecl, Env)->Env:::Create a fresh environment for modules.
com.sun.tools.javac.comp.Enter#classEnter(JCTree, Env)->Type:::Visitor method: enter all classes in given tree, catching any  completion failure exceptions
com.sun.tools.javac.comp.Enter#classEnter(List, Env)->List:::Visitor method: enter classes of a list of trees, returning a list of types.
com.sun.tools.javac.comp.Enter#visitTopLevel(JCCompilationUnit)->void::: enter visit top level
com.sun.tools.javac.comp.Enter#visitClassDef(JCClassDecl)->void::: enter visit class def
com.sun.tools.javac.comp.Enter#duplicateClass(DiagnosticPosition, ClassSymbol)->void:::Complain about a duplicate class.
com.sun.tools.javac.comp.Enter#visitTypeParameter(JCTypeParameter)->void:::Class enter visitor method for type parameters
com.sun.tools.javac.comp.Enter#visitModuleDef(JCModuleDecl)->void::: enter visit module def
com.sun.tools.javac.comp.Enter#visitTree(JCTree)->void:::Default class enter visitor method: do nothing.
com.sun.tools.javac.comp.Enter#main(List)->void:::Main method: enter all classes in a list of toplevel trees.
com.sun.tools.javac.comp.Enter#complete(List, ClassSymbol)->void:::Main method: enter classes from the list of toplevel trees, possibly  skipping TypeEnter for all but 'c' by placing them on the uncompleted  list.
com.sun.tools.javac.comp.Enter#newRound()->void::: enter new round
com.sun.tools.javac.comp.Env#dup(JCTree, A)->Env:::Duplicate this environment, updating with given tree and info,  and copying all other fields.
com.sun.tools.javac.comp.Env#dupto(Env)->Env:::Duplicate this environment into a given Environment,  using its tree and info, and copying all other fields.
com.sun.tools.javac.comp.Env#dup(JCTree)->Env:::Duplicate this environment, updating with given tree,  and copying all other fields.
com.sun.tools.javac.comp.Env#enclosing(JCTree.Tag)->Env:::Return closest enclosing environment which points to a tree with given tag.
com.sun.tools.javac.comp.Env#toString()->String::: env to string
com.sun.tools.javac.comp.Env#iterator()->Iterator>::: env iterator
com.sun.tools.javac.comp.Flow#instance(Context)->Flow::: flow instance
com.sun.tools.javac.comp.Flow#analyzeTree(Env, TreeMaker)->void::: flow analyze tree
com.sun.tools.javac.comp.Flow#analyzeLambda(Env, JCLambda, TreeMaker, boolean)->void::: flow analyze lambda
com.sun.tools.javac.comp.Flow#analyzeLambdaThrownTypes(Env, JCLambda, TreeMaker)->List::: flow analyze lambda thrown types
com.sun.tools.javac.comp.Flow.BaseAnalyzer.PendingExit#resolveJump()->void::: pending exit resolve jump
com.sun.tools.javac.comp.Flow.BaseAnalyzer#markDead()->void::: base analyzer mark dead
com.sun.tools.javac.comp.Flow.BaseAnalyzer#recordExit(P)->void:::Record an outward transfer of control.
com.sun.tools.javac.comp.Flow.BaseAnalyzer#resolveContinues(JCTree)->boolean:::Resolve all continues of this statement.
com.sun.tools.javac.comp.Flow.BaseAnalyzer#resolveBreaks(JCTree, ListBuffer)->boolean:::Resolve all breaks of this statement.
com.sun.tools.javac.comp.Flow.BaseAnalyzer#scan(JCTree)->void::: base analyzer scan
com.sun.tools.javac.comp.Flow.BaseAnalyzer#visitPackageDef(JCPackageDecl)->void::: base analyzer visit package def
com.sun.tools.javac.comp.Flow.AliveAnalyzer#markDead()->void::: alive analyzer mark dead
com.sun.tools.javac.comp.Flow.AliveAnalyzer#scanDef(JCTree)->void:::Analyze a definition.
com.sun.tools.javac.comp.Flow.AliveAnalyzer#scanStat(JCTree)->void:::Analyze a statement
com.sun.tools.javac.comp.Flow.AliveAnalyzer#scanStats(List)->void:::Analyze list of statements.
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitClassDef(JCClassDecl)->void::: alive analyzer visit class def
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitMethodDef(JCMethodDecl)->void::: alive analyzer visit method def
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitVarDef(JCVariableDecl)->void::: alive analyzer visit var def
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitBlock(JCBlock)->void::: alive analyzer visit block
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitDoLoop(JCDoWhileLoop)->void::: alive analyzer visit do loop
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitWhileLoop(JCWhileLoop)->void::: alive analyzer visit while loop
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitForLoop(JCForLoop)->void::: alive analyzer visit for loop
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitForeachLoop(JCEnhancedForLoop)->void::: alive analyzer visit foreach loop
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitLabelled(JCLabeledStatement)->void::: alive analyzer visit labelled
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitSwitch(JCSwitch)->void::: alive analyzer visit switch
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitTry(JCTry)->void::: alive analyzer visit try
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitIf(JCIf)->void::: alive analyzer visit if
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitBreak(JCBreak)->void::: alive analyzer visit break
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitContinue(JCContinue)->void::: alive analyzer visit continue
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitReturn(JCReturn)->void::: alive analyzer visit return
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitThrow(JCThrow)->void::: alive analyzer visit throw
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitApply(JCMethodInvocation)->void::: alive analyzer visit apply
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitNewClass(JCNewClass)->void::: alive analyzer visit new class
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitLambda(JCLambda)->void::: alive analyzer visit lambda
com.sun.tools.javac.comp.Flow.AliveAnalyzer#visitModuleDef(JCModuleDecl)->void::: alive analyzer visit module def
com.sun.tools.javac.comp.Flow.AliveAnalyzer#analyzeTree(Env, TreeMaker)->void:::Perform definite assignment/unassignment analysis on a tree.
com.sun.tools.javac.comp.Flow.AliveAnalyzer#analyzeTree(Env, JCTree, TreeMaker)->void::: alive analyzer analyze tree
com.sun.tools.javac.comp.Flow.FlowAnalyzer#markDead()->void::: flow analyzer mark dead
com.sun.tools.javac.comp.Flow.FlowAnalyzer#errorUncaught()->void:::Complain that pending exceptions are not caught.
com.sun.tools.javac.comp.Flow.FlowAnalyzer#markThrown(JCTree, Type)->void:::Record that exception is potentially thrown and check that it  is caught.
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitClassDef(JCClassDecl)->void::: flow analyzer visit class def
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitMethodDef(JCMethodDecl)->void::: flow analyzer visit method def
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitVarDef(JCVariableDecl)->void::: flow analyzer visit var def
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitBlock(JCBlock)->void::: flow analyzer visit block
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitDoLoop(JCDoWhileLoop)->void::: flow analyzer visit do loop
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitWhileLoop(JCWhileLoop)->void::: flow analyzer visit while loop
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitForLoop(JCForLoop)->void::: flow analyzer visit for loop
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitForeachLoop(JCEnhancedForLoop)->void::: flow analyzer visit foreach loop
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitLabelled(JCLabeledStatement)->void::: flow analyzer visit labelled
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitSwitch(JCSwitch)->void::: flow analyzer visit switch
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitTry(JCTry)->void::: flow analyzer visit try
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitIf(JCIf)->void::: flow analyzer visit if
com.sun.tools.javac.comp.Flow.FlowAnalyzer#checkCaughtType(DiagnosticPosition, Type, List, List)->void::: flow analyzer check caught type
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitBreak(JCBreak)->void::: flow analyzer visit break
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitContinue(JCContinue)->void::: flow analyzer visit continue
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitReturn(JCReturn)->void::: flow analyzer visit return
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitThrow(JCThrow)->void::: flow analyzer visit throw
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitApply(JCMethodInvocation)->void::: flow analyzer visit apply
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitNewClass(JCNewClass)->void::: flow analyzer visit new class
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitLambda(JCLambda)->void::: flow analyzer visit lambda
com.sun.tools.javac.comp.Flow.FlowAnalyzer#visitModuleDef(JCModuleDecl)->void::: flow analyzer visit module def
com.sun.tools.javac.comp.Flow.FlowAnalyzer#analyzeTree(Env, TreeMaker)->void:::Perform definite assignment/unassignment analysis on a tree.
com.sun.tools.javac.comp.Flow.FlowAnalyzer#analyzeTree(Env, JCTree, TreeMaker)->void::: flow analyzer analyze tree
com.sun.tools.javac.comp.Flow.LambdaAliveAnalyzer#visitReturn(JCReturn)->void::: lambda alive analyzer visit return
com.sun.tools.javac.comp.Flow.LambdaAliveAnalyzer#visitLambda(JCLambda)->void::: lambda alive analyzer visit lambda
com.sun.tools.javac.comp.Flow.LambdaAliveAnalyzer#visitClassDef(JCClassDecl)->void::: lambda alive analyzer visit class def
com.sun.tools.javac.comp.Flow.LambdaAssignAnalyzer#visitLambda(JCLambda)->void::: lambda assign analyzer visit lambda
com.sun.tools.javac.comp.Flow.LambdaAssignAnalyzer#visitVarDef(JCVariableDecl)->void::: lambda assign analyzer visit var def
com.sun.tools.javac.comp.Flow.LambdaAssignAnalyzer#trackable(VarSymbol)->boolean::: lambda assign analyzer trackable
com.sun.tools.javac.comp.Flow.LambdaAssignAnalyzer#visitClassDef(JCClassDecl)->void::: lambda assign analyzer visit class def
com.sun.tools.javac.comp.Flow.LambdaFlowAnalyzer#visitLambda(JCLambda)->void::: lambda flow analyzer visit lambda
com.sun.tools.javac.comp.Flow.LambdaFlowAnalyzer#visitClassDef(JCClassDecl)->void::: lambda flow analyzer visit class def
com.sun.tools.javac.comp.Flow.AssignAnalyzer.AssignPendingExit#resolveJump()->void::: assign pending exit resolve jump
com.sun.tools.javac.comp.Flow.AssignAnalyzer#markDead()->void::: assign analyzer mark dead
com.sun.tools.javac.comp.Flow.AssignAnalyzer#trackable(VarSymbol)->boolean:::Do we need to track init/uninit state of this symbol?  I.e
com.sun.tools.javac.comp.Flow.AssignAnalyzer#isFinalUninitializedField(VarSymbol)->boolean::: assign analyzer is final uninitialized field
com.sun.tools.javac.comp.Flow.AssignAnalyzer#isFinalUninitializedStaticField(VarSymbol)->boolean::: assign analyzer is final uninitialized static field
com.sun.tools.javac.comp.Flow.AssignAnalyzer#newVar(JCVariableDecl)->void:::Initialize new trackable variable by setting its address field  to the next available sequence number and entering it under that  index into the vars array.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#letInit(DiagnosticPosition, VarSymbol)->void:::Record an initialization of a trackable variable.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#uninit(VarSymbol)->void::: assign analyzer uninit
com.sun.tools.javac.comp.Flow.AssignAnalyzer#letInit(JCTree)->void:::If tree is either a simple name or of the form this.name or  C.this.name, and tree represents a trackable variable,  record an initialization of the variable.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#checkInit(DiagnosticPosition, VarSymbol)->void:::Check that trackable variable is initialized.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#checkInit(DiagnosticPosition, VarSymbol, Error)->void::: assign analyzer check init
com.sun.tools.javac.comp.Flow.AssignAnalyzer#split(boolean)->void:::Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
com.sun.tools.javac.comp.Flow.AssignAnalyzer#merge()->void:::Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#scanExpr(JCTree)->void:::Analyze an expression
com.sun.tools.javac.comp.Flow.AssignAnalyzer#scanExprs(List)->void:::Analyze a list of expressions.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#scanCond(JCTree)->void:::Analyze a condition
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitClassDef(JCClassDecl)->void::: assign analyzer visit class def
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitMethodDef(JCMethodDecl)->void::: assign analyzer visit method def
com.sun.tools.javac.comp.Flow.AssignAnalyzer#initParam(JCVariableDecl)->void::: assign analyzer init param
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitVarDef(JCVariableDecl)->void::: assign analyzer visit var def
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitBlock(JCBlock)->void::: assign analyzer visit block
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitDoLoop(JCDoWhileLoop)->void::: assign analyzer visit do loop
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitWhileLoop(JCWhileLoop)->void::: assign analyzer visit while loop
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitForLoop(JCForLoop)->void::: assign analyzer visit for loop
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitForeachLoop(JCEnhancedForLoop)->void::: assign analyzer visit foreach loop
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitLabelled(JCLabeledStatement)->void::: assign analyzer visit labelled
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitSwitch(JCSwitch)->void::: assign analyzer visit switch
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitTry(JCTry)->void::: assign analyzer visit try
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitConditional(JCConditional)->void::: assign analyzer visit conditional
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitIf(JCIf)->void::: assign analyzer visit if
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitBreak(JCBreak)->void::: assign analyzer visit break
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitContinue(JCContinue)->void::: assign analyzer visit continue
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitReturn(JCReturn)->void::: assign analyzer visit return
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitThrow(JCThrow)->void::: assign analyzer visit throw
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitApply(JCMethodInvocation)->void::: assign analyzer visit apply
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitNewClass(JCNewClass)->void::: assign analyzer visit new class
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitLambda(JCLambda)->void::: assign analyzer visit lambda
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitNewArray(JCNewArray)->void::: assign analyzer visit new array
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitAssert(JCAssert)->void::: assign analyzer visit assert
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitAssign(JCAssign)->void::: assign analyzer visit assign
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitSelect(JCFieldAccess)->void::: assign analyzer visit select
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitAssignop(JCAssignOp)->void::: assign analyzer visit assignop
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitUnary(JCUnary)->void::: assign analyzer visit unary
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitBinary(JCBinary)->void::: assign analyzer visit binary
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitIdent(JCIdent)->void::: assign analyzer visit ident
com.sun.tools.javac.comp.Flow.AssignAnalyzer#referenced(Symbol)->void::: assign analyzer referenced
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitAnnotatedType(JCAnnotatedType)->void::: assign analyzer visit annotated type
com.sun.tools.javac.comp.Flow.AssignAnalyzer#visitModuleDef(JCModuleDecl)->void::: assign analyzer visit module def
com.sun.tools.javac.comp.Flow.AssignAnalyzer#analyzeTree(Env)->void:::Perform definite assignment/unassignment analysis on a tree.
com.sun.tools.javac.comp.Flow.AssignAnalyzer#analyzeTree(Env, JCTree)->void::: assign analyzer analyze tree
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#markDead()->void::: capture analyzer mark dead
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#checkEffectivelyFinal(DiagnosticPosition, VarSymbol)->void::: capture analyzer check effectively final
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#letInit(JCTree)->void::: capture analyzer let init
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#reportEffectivelyFinalError(DiagnosticPosition, Symbol)->void::: capture analyzer report effectively final error
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#reportInnerClsNeedsFinalError(DiagnosticPosition, Symbol)->void::: capture analyzer report inner cls needs final error
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitClassDef(JCClassDecl)->void::: capture analyzer visit class def
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitLambda(JCLambda)->void::: capture analyzer visit lambda
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitIdent(JCIdent)->void::: capture analyzer visit ident
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitAssign(JCAssign)->void::: capture analyzer visit assign
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitAssignop(JCAssignOp)->void::: capture analyzer visit assignop
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitUnary(JCUnary)->void::: capture analyzer visit unary
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitTry(JCTry)->void::: capture analyzer visit try
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#visitModuleDef(JCModuleDecl)->void::: capture analyzer visit module def
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#analyzeTree(Env, TreeMaker)->void:::Perform definite assignment/unassignment analysis on a tree.
com.sun.tools.javac.comp.Flow.CaptureAnalyzer#analyzeTree(Env, JCTree, TreeMaker)->void::: capture analyzer analyze tree
com.sun.tools.javac.comp.Infer#instance(Context)->Infer::: infer instance
com.sun.tools.javac.comp.Infer.InferenceException#getDiagnostic()->JCDiagnostic::: inference exception get diagnostic
com.sun.tools.javac.comp.Infer#error(JCDiagnostic)->InferenceException::: infer error
com.sun.tools.javac.comp.Infer#instantiateMethod(Env, List, MethodType, Attr.ResultInfo, MethodSymbol, List, boolean, boolean, Resolve.MethodResolutionContext, Warner)->Type:::Main inference entry point - instantiate a generic method type using given argument types and (possibly) an expected target-type.
com.sun.tools.javac.comp.Infer.PartiallyInferredMethodType#isPartial()->boolean::: partially inferred method type is partial
com.sun.tools.javac.comp.Infer.PartiallyInferredMethodType#check(Attr.ResultInfo)->Type:::Checks this type against a target; this means generating return type constraints, solve and then roll back the results (to avoid poolluting the context).
com.sun.tools.javac.comp.Infer#generateReturnConstraints(JCTree, Attr.ResultInfo, MethodType, InferenceContext)->Type:::Generate constraints from the generic method's return type
com.sun.tools.javac.comp.Infer#instantiateAsUninferredVars(List, InferenceContext)->void:::Infer cyclic inference variables as described in 15.12.2.8.
com.sun.tools.javac.comp.Infer#instantiatePolymorphicSignatureInstance(Env, MethodSymbol, Resolve.MethodResolutionContext, List)->Type:::Compute a synthetic method type corresponding to the requested polymorphic method signature
com.sun.tools.javac.comp.Infer.ImplicitArgType#visitClassType(ClassType, Void)->Type::: implicit arg type visit class type
com.sun.tools.javac.comp.Infer.ImplicitArgType#visitType(Type, Void)->Type::: implicit arg type visit type
com.sun.tools.javac.comp.Infer#instantiateFunctionalInterface(DiagnosticPosition, Type, List, Check.CheckContext)->Type:::This method is used to infer a suitable target SAM in case the original SAM type contains one or more wildcards
com.sun.tools.javac.comp.Infer.IncorporationAction#dup(UndetVar)->IncorporationAction::: incorporation action dup
com.sun.tools.javac.comp.Infer.IncorporationAction#apply(InferenceContext, Warner)->void:::Incorporation action entry-point
com.sun.tools.javac.comp.Infer.IncorporationAction#isSubtype(Type, Type, Warner)->boolean:::Helper function: perform subtyping through incorporation cache.
com.sun.tools.javac.comp.Infer.IncorporationAction#isSameType(Type, Type)->boolean:::Helper function: perform type-equivalence through incorporation cache.
com.sun.tools.javac.comp.Infer.IncorporationAction#toString()->String::: incorporation action to string
com.sun.tools.javac.comp.Infer.CheckBounds#dup(UndetVar)->IncorporationAction::: check bounds dup
com.sun.tools.javac.comp.Infer.CheckBounds#apply(InferenceContext, Warner)->void::: check bounds apply
com.sun.tools.javac.comp.Infer.CheckBounds#boundsToCheck()->EnumSet:::The list of bound kinds to be checked.
com.sun.tools.javac.comp.Infer.CheckBounds#checkBound(Type, Type, InferenceBound, InferenceBound, Warner)->boolean:::Is source type 's' compatible with target type 't' given source and target bound kinds?
com.sun.tools.javac.comp.Infer.CheckBounds#report(InferenceBound, InferenceBound)->void:::Report a bound check error.
com.sun.tools.javac.comp.Infer.CheckBounds#toString()->String::: check bounds to string
com.sun.tools.javac.comp.Infer.EqCheckLegacy#dup(UndetVar)->IncorporationAction::: eq check legacy dup
com.sun.tools.javac.comp.Infer.EqCheckLegacy#boundsToCheck()->EnumSet::: eq check legacy bounds to check
com.sun.tools.javac.comp.Infer.CheckInst#dup(UndetVar)->IncorporationAction::: check inst dup
com.sun.tools.javac.comp.Infer.CheckInst#boundsToCheck()->EnumSet::: check inst bounds to check
com.sun.tools.javac.comp.Infer.CheckInst#report(InferenceBound, InferenceBound)->void::: check inst report
com.sun.tools.javac.comp.Infer.SubstBounds#dup(UndetVar)->IncorporationAction::: subst bounds dup
com.sun.tools.javac.comp.Infer.SubstBounds#apply(InferenceContext, Warner)->void::: subst bounds apply
com.sun.tools.javac.comp.Infer.SubstBounds#checkCompatibleUpperBounds(UndetVar, InferenceContext)->void:::Make sure that the upper bounds we got so far lead to a solvable inference variable by making sure that a glb exists.
com.sun.tools.javac.comp.Infer.CheckUpperBounds#dup(UndetVar)->IncorporationAction::: check upper bounds dup
com.sun.tools.javac.comp.Infer.CheckUpperBounds#apply(InferenceContext, Warner)->void::: check upper bounds apply
com.sun.tools.javac.comp.Infer.PropagateBounds#dup(UndetVar)->IncorporationAction::: propagate bounds dup
com.sun.tools.javac.comp.Infer.PropagateBounds#apply(InferenceContext, Warner)->void::: propagate bounds apply
com.sun.tools.javac.comp.Infer.PropagateBounds#forward()->EnumSet::: propagate bounds forward
com.sun.tools.javac.comp.Infer.PropagateBounds#backwards()->EnumSet::: propagate bounds backwards
com.sun.tools.javac.comp.Infer.PropagateBounds#toString()->String::: propagate bounds to string
com.sun.tools.javac.comp.Infer.AbstractIncorporationEngine#varInstantiated(UndetVar)->void::: abstract incorporation engine var instantiated
com.sun.tools.javac.comp.Infer.AbstractIncorporationEngine#varBoundChanged(UndetVar, InferenceBound, Type, boolean)->void::: abstract incorporation engine var bound changed
com.sun.tools.javac.comp.Infer.AbstractIncorporationEngine#getIncorporationActions(UndetVar, InferenceBound, Type, boolean)->List::: abstract incorporation engine get incorporation actions
com.sun.tools.javac.comp.Infer#incorporationEngine()->AbstractIncorporationEngine:::Get the incorporation engine to be used in this compilation.
com.sun.tools.javac.comp.Infer#doIncorporation(InferenceContext, Warner)->void:::Check bounds and perform incorporation.
com.sun.tools.javac.comp.Infer#doIncorporationOp(IncorporationBinaryOpKind, Type, Type, Warner)->boolean::: infer do incorporation op
com.sun.tools.javac.comp.Infer.IncorporationBinaryOp#equals(Object)->boolean::: incorporation binary op equals
com.sun.tools.javac.comp.Infer.IncorporationBinaryOp#hashCode()->int::: incorporation binary op hash code
com.sun.tools.javac.comp.Infer.IncorporationBinaryOp#apply(Warner)->boolean::: incorporation binary op apply
com.sun.tools.javac.comp.Infer.BoundFilter#accepts(Type)->boolean::: bound filter accepts
com.sun.tools.javac.comp.Infer#reportInstError(UndetVar, InferenceBound)->void:::Incorporation error: mismatch between inferred type and given bound.
com.sun.tools.javac.comp.Infer#reportBoundError(UndetVar, InferenceBound)->void:::Incorporation error: mismatch between two (or more) bounds of same kind.
com.sun.tools.javac.comp.Infer#reportBoundError(UndetVar, InferenceBound, InferenceBound)->void:::Incorporation error: mismatch between two (or more) bounds of different kinds.
com.sun.tools.javac.comp.Infer#getBoundFragment(InferenceBound, List)->Fragment::: infer get bound fragment
com.sun.tools.javac.comp.Infer.GraphStrategy#pickNode(InferenceGraph)->Node:::Pick the next node (leaf) to solve in the graph
com.sun.tools.javac.comp.Infer.GraphStrategy#done()->boolean:::Is this the last step?
com.sun.tools.javac.comp.Infer.LeafSolver#pickNode(InferenceGraph)->Node::: leaf solver pick node
com.sun.tools.javac.comp.Infer.BestLeafSolver#computeTreeToLeafs(Node)->Pair, Integer>:::Computes a path that goes from a given node to the leafs in the graph
com.sun.tools.javac.comp.Infer.BestLeafSolver#pickNode(InferenceGraph)->Node:::Pick the leaf that minimize cost
com.sun.tools.javac.comp.Infer.GraphSolver#solve(GraphStrategy)->void:::Solve variables in a given inference context
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#getSupportedDependencyKinds()->GraphUtils.DependencyKind[]::: node get supported dependency kinds
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#getAllDependencies()->Iterable::: node get all dependencies
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#getDependenciesByKind(GraphUtils.DependencyKind)->Collection::: node get dependencies by kind
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#addDependency(Node)->void:::Adds dependency with given kind.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#addDependencies(Set)->void:::Add multiple dependencies of same given kind.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#removeDependency(Node)->boolean:::Remove a dependency, regardless of its kind.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#closure()->Set:::Compute closure of a give node, by recursively walking through all its dependencies.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#isLeaf()->boolean:::Is this node a leaf? This means either the node has no dependencies, or it just has self-dependencies.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#mergeWith(List)->void:::Merge this node with another node, acquiring its dependencies
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#nodeAttributes()->Properties::: node node attributes
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph.Node#dependencyAttributes(Node, GraphUtils.DependencyKind)->Properties::: node dependency attributes
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph#findNode(Type)->Node:::Basic lookup helper for retrieving a graph node given an inference variable type.
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph#deleteNode(Node)->void:::Delete a node from the graph
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph#notifyUpdate(Node, Node)->void:::Notify all nodes of a change in the graph
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph#initNodes()->void:::Create the graph nodes
com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph#toDot()->String:::Debugging: dot representation of this graph
com.sun.tools.javac.comp.Infer.FreeTypeListener#typesInferred(InferenceContext)->void::: free type listener types inferred
com.sun.tools.javac.comp.InferenceContext#update(Type)->Type::: inference context update
com.sun.tools.javac.comp.InferenceContext#addVar(TypeVar)->void:::add a new inference var to this inference context
com.sun.tools.javac.comp.InferenceContext#inferenceVars()->List:::returns the list of free variables (as type-variables) in this inference context
com.sun.tools.javac.comp.InferenceContext#undetVars()->List:::returns the list of undetermined variables in this inference context
com.sun.tools.javac.comp.InferenceContext#restvars()->List:::returns the list of uninstantiated variables (as type-variables) in this inference context
com.sun.tools.javac.comp.InferenceContext#instvars()->List:::returns the list of instantiated variables (as type-variables) in this inference context
com.sun.tools.javac.comp.InferenceContext#boundedVars()->List:::Get list of bounded inference variables (where bound is other than declared bounds).
com.sun.tools.javac.comp.InferenceContext#free(Type)->boolean:::is this type free?
com.sun.tools.javac.comp.InferenceContext#free(List)->boolean::: inference context free
com.sun.tools.javac.comp.InferenceContext#freeVarsIn(Type)->List:::Returns a list of free variables in a given type
com.sun.tools.javac.comp.InferenceContext#freeVarsIn(List)->List::: inference context free vars in
com.sun.tools.javac.comp.InferenceContext#asUndetVar(Type)->Type:::Replace all free variables in a given type with corresponding undet vars (used ahead of subtyping/compatibility checks to allow propagation of inference constraints).
com.sun.tools.javac.comp.InferenceContext#asUndetVars(List)->List::: inference context as undet vars
com.sun.tools.javac.comp.InferenceContext#instTypes()->List::: inference context inst types
com.sun.tools.javac.comp.InferenceContext#asInstType(Type)->Type:::Replace all free variables in a given type with corresponding instantiated types - if one or more free variable has not been fully instantiated, it will still be available in the resulting type.
com.sun.tools.javac.comp.InferenceContext#asInstTypes(List)->List::: inference context as inst types
com.sun.tools.javac.comp.InferenceContext#addFreeTypeListener(List, FreeTypeListener)->void:::Add custom hook for performing post-inference action
com.sun.tools.javac.comp.InferenceContext#notifyChange()->void:::Mark the inference context as complete and trigger evaluation of all deferred checks.
com.sun.tools.javac.comp.InferenceContext#notifyChange(List)->void::: inference context notify change
com.sun.tools.javac.comp.InferenceContext#save()->List:::Save the state of this inference context
com.sun.tools.javac.comp.InferenceContext#rollback(List)->void:::Restore the state of this inference context to the previous known checkpoint
com.sun.tools.javac.comp.InferenceContext#dupTo(InferenceContext)->void:::Copy variable in this inference context to the given context
com.sun.tools.javac.comp.InferenceContext#dupTo(InferenceContext, boolean)->void::: inference context dup to
com.sun.tools.javac.comp.InferenceContext#min(List, boolean, Warner)->InferenceContext::: inference context min
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#scan(List)->void::: reachability visitor scan
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitType(Type, Void)->Void::: reachability visitor visit type
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitUndetVar(UndetVar, Void)->Void::: reachability visitor visit undet var
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitWildcardType(WildcardType, Void)->Void::: reachability visitor visit wildcard type
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitTypeVar(TypeVar, Void)->Void::: reachability visitor visit type var
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitArrayType(ArrayType, Void)->Void::: reachability visitor visit array type
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#visitClassType(ClassType, Void)->Void::: reachability visitor visit class type
com.sun.tools.javac.comp.InferenceContext.ReachabilityVisitor#isEquiv(UndetVar, Type, InferenceBound)->boolean::: reachability visitor is equiv
com.sun.tools.javac.comp.InferenceContext#solve(Warner)->void:::Solve all variables in this context.
com.sun.tools.javac.comp.InferenceContext#solve(List, Warner)->void:::Solve all variables in the given list.
com.sun.tools.javac.comp.InferenceContext#solveAny(List, Warner)->void:::Solve at least one variable in given list.
com.sun.tools.javac.comp.InferenceContext#solveBasic(List, EnumSet)->List::: inference context solve basic
com.sun.tools.javac.comp.InferenceContext#solveLegacy(boolean, Warner, EnumSet)->void:::Instantiate inference variables in legacy mode (JLS 15.12.2.7, 15.12.2.8)
com.sun.tools.javac.comp.InferenceContext#toString()->String::: inference context to string
com.sun.tools.javac.comp.InferenceContext#cachedCapture(JCTree, Type, boolean)->Type::: inference context cached capture
com.sun.tools.javac.comp.LambdaToMethod#instance(Context)->LambdaToMethod::: lambda to method instance
com.sun.tools.javac.comp.LambdaToMethod.DedupedLambda#hashCode()->int::: deduped lambda hash code
com.sun.tools.javac.comp.LambdaToMethod.DedupedLambda#equals(Object)->boolean::: deduped lambda equals
com.sun.tools.javac.comp.LambdaToMethod#translate(T)->T::: lambda to method translate
com.sun.tools.javac.comp.LambdaToMethod#translate(T, TranslationContext)->T::: lambda to method translate
com.sun.tools.javac.comp.LambdaToMethod#translate(List, TranslationContext)->List::: lambda to method translate
com.sun.tools.javac.comp.LambdaToMethod#translateTopLevelClass(Env, JCTree, TreeMaker)->JCTree::: lambda to method translate top level class
com.sun.tools.javac.comp.LambdaToMethod#visitClassDef(JCClassDecl)->void:::Visit a class
com.sun.tools.javac.comp.LambdaToMethod#visitLambda(JCLambda)->void:::Translate a lambda into a method to be inserted into the class
com.sun.tools.javac.comp.LambdaToMethod#visitReference(JCMemberReference)->void:::Translate a method reference into an invokedynamic call to the meta-factory.
com.sun.tools.javac.comp.LambdaToMethod#visitIdent(JCIdent)->void:::Translate identifiers within a lambda to the mapped identifier
com.sun.tools.javac.comp.LambdaToMethod#visitSelect(JCFieldAccess)->void:::Translate qualified `this' references within a lambda to the mapped identifier
com.sun.tools.javac.comp.LambdaToMethod#visitNewClass(JCNewClass)->void:::Translate instance creation expressions with implicit enclosing instances
com.sun.tools.javac.comp.LambdaToMethod#visitVarDef(JCVariableDecl)->void::: lambda to method visit var def
com.sun.tools.javac.comp.LambdaToMethod#makeNewClass(Type, List, Symbol)->JCNewClass:::Make an attributed class instance creation expression.
com.sun.tools.javac.comp.LambdaToMethod#makeNewClass(Type, List)->JCNewClass:::Make an attributed class instance creation expression.
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitApply(JCMethodInvocation)->void::: lambda analyzer preprocessor visit apply
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitBlock(JCBlock)->void::: lambda analyzer preprocessor visit block
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitClassDef(JCClassDecl)->void::: lambda analyzer preprocessor visit class def
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitIdent(JCIdent)->void::: lambda analyzer preprocessor visit ident
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitLambda(JCLambda)->void::: lambda analyzer preprocessor visit lambda
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitMethodDef(JCMethodDecl)->void::: lambda analyzer preprocessor visit method def
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitNewClass(JCNewClass)->void::: lambda analyzer preprocessor visit new class
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#captureLocalClassDefs(Symbol, LambdaTranslationContext)->void::: lambda analyzer preprocessor capture local class defs
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#currentlyInClass(Symbol)->boolean::: lambda analyzer preprocessor currently in class
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitReference(JCMemberReference)->void:::Method references to local class constructors, may, if the local class references local variables, have implicit constructor parameters added in Lower; As a result, the invokedynamic bootstrap information added in the LambdaToMethod pass will have the wrong signature
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitSelect(JCFieldAccess)->void::: lambda analyzer preprocessor visit select
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor#visitVarDef(JCVariableDecl)->void::: lambda analyzer preprocessor visit var def
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#needsAltMetafactory()->boolean:::does this functional expression need to be created using alternate metafactory?
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#isSerializable()->boolean:::does this functional expression require serialization support?
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#enclosingMethodName()->String::: translation context enclosing method name
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.TranslationContext#syntheticMethodNameComponent(Name)->String::: translation context synthetic method name component
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(Symbol, LambdaSymbolKind)->Symbol:::Translate a symbol of a given kind into something suitable for the synthetic lambda body
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#addSymbol(Symbol, LambdaSymbolKind)->void::: lambda translation context add symbol
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#getSymbolMap(LambdaSymbolKind)->Map::: lambda translation context get symbol map
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCIdent)->JCTree::: lambda translation context translate
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCFieldAccess)->JCTree::: lambda translation context translate
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#translate(JCNewClass)->JCNewClass::: lambda translation context translate
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#complete()->void:::The translatedSym is not complete/accurate until the analysis is finished
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.LambdaTranslationContext#generatedLambdaSig()->Type::: lambda translation context generated lambda sig
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#referenceKind()->int:::Get the opcode associated with this method reference
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#needsVarArgsConversion()->boolean::: reference translation context needs var args conversion
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isArrayOp()->boolean::: reference translation context is array op
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#receiverAccessible()->boolean::: reference translation context receiver accessible
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isPrivateInOtherClass()->boolean:::The VM does not support access across nested classes (8010319)
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#isProtectedInSuperClassOfEnclosingClassInOtherPackage()->boolean::: reference translation context is protected in super class of enclosing class in other package
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#interfaceParameterIsIntersectionOrUnionType()->boolean:::Erasure destroys the implementation parameter subtype relationship for intersection types
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#needsConversionToLambda()->boolean:::Does this reference need to be converted to a lambda (i.e
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#generatedRefSig()->Type::: reference translation context generated ref sig
com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.ReferenceTranslationContext#bridgedRefSig()->Type::: reference translation context bridged ref sig
com.sun.tools.javac.comp.Lower#instance(Context)->Lower::: lower instance
com.sun.tools.javac.comp.Lower.ClassMap#visitClassDef(JCClassDecl)->void:::All encountered class defs are entered into classdefs table.
com.sun.tools.javac.comp.Lower#classDef(ClassSymbol)->JCClassDecl:::Map a class symbol to its definition.
com.sun.tools.javac.comp.Lower.BasicFreeVarCollector#addFreeVars(ClassSymbol)->void:::Add all free variables of class c to fvs list  unless they are already there.
com.sun.tools.javac.comp.Lower.BasicFreeVarCollector#visitIdent(JCIdent)->void:::If tree refers to a variable in owner of local class, add it to  free variables list.
com.sun.tools.javac.comp.Lower.BasicFreeVarCollector#visitSymbol(Symbol)->void::: basic free var collector visit symbol
com.sun.tools.javac.comp.Lower.BasicFreeVarCollector#visitNewClass(JCNewClass)->void:::If tree refers to a class instance creation expression  add all free variables of the freshly created class.
com.sun.tools.javac.comp.Lower.BasicFreeVarCollector#visitApply(JCMethodInvocation)->void:::If tree refers to a superclass constructor call,  add all free variables of the superclass.
com.sun.tools.javac.comp.Lower.FreeVarCollector#addFreeVars(ClassSymbol)->void::: free var collector add free vars
com.sun.tools.javac.comp.Lower.FreeVarCollector#visitSymbol(Symbol)->void::: free var collector visit symbol
com.sun.tools.javac.comp.Lower.FreeVarCollector#visitNewClass(JCNewClass)->void:::If tree refers to a class instance creation expression  add all free variables of the freshly created class.
com.sun.tools.javac.comp.Lower.FreeVarCollector#visitSelect(JCFieldAccess)->void:::If tree refers to a qualified this or super expression  for anything but the current class, add the outer this  stack as a free variable.
com.sun.tools.javac.comp.Lower.FreeVarCollector#visitApply(JCMethodInvocation)->void:::If tree refers to a superclass constructor call,  add all free variables of the superclass.
com.sun.tools.javac.comp.Lower#ownerToCopyFreeVarsFrom(ClassSymbol)->ClassSymbol::: lower owner to copy free vars from
com.sun.tools.javac.comp.Lower#freevars(ClassSymbol)->List:::Return the variables accessed from within a local class, which  are declared in the local class' owner
com.sun.tools.javac.comp.Lower#mapForEnum(DiagnosticPosition, TypeSymbol)->EnumMapping::: lower map for enum
com.sun.tools.javac.comp.Lower.EnumMapping#forConstant(VarSymbol)->JCLiteral::: enum mapping for constant
com.sun.tools.javac.comp.Lower.EnumMapping#translate()->void::: enum mapping translate
com.sun.tools.javac.comp.Lower#make_at(DiagnosticPosition)->TreeMaker:::Equivalent to make.at(pos.getStartPosition()) with side effect of caching  pos as make_pos, for use in diagnostics.
com.sun.tools.javac.comp.Lower#makeLit(Type, Object)->JCExpression:::Make an attributed tree representing a literal
com.sun.tools.javac.comp.Lower#makeNull()->JCExpression:::Make an attributed tree representing null.
com.sun.tools.javac.comp.Lower#makeNewClass(Type, List)->JCNewClass:::Make an attributed class instance creation expression.
com.sun.tools.javac.comp.Lower#makeUnary(JCTree.Tag, JCExpression)->JCUnary:::Make an attributed unary expression.
com.sun.tools.javac.comp.Lower#makeBinary(JCTree.Tag, JCExpression, JCExpression)->JCBinary:::Make an attributed binary expression.
com.sun.tools.javac.comp.Lower#makeAssignop(JCTree.Tag, JCTree, JCTree)->JCAssignOp:::Make an attributed assignop expression.
com.sun.tools.javac.comp.Lower#makeString(JCExpression)->JCExpression:::Convert tree into string object, unless it has already a  reference type..
com.sun.tools.javac.comp.Lower#makeEmptyClass(long, ClassSymbol)->JCClassDecl:::Create an empty anonymous class definition and enter and complete  its symbol
com.sun.tools.javac.comp.Lower#makeEmptyClass(long, ClassSymbol, Name, boolean)->JCClassDecl::: lower make empty class
com.sun.tools.javac.comp.Lower#checkConflicts(List)->void:::Check whether synthetic symbols generated during lowering conflict  with user-defined symbols.
com.sun.tools.javac.comp.Lower#swapAccessConstructorTag(ClassSymbol, ClassSymbol)->void::: lower swap access constructor tag
com.sun.tools.javac.comp.Lower#accessName(int, int)->Name:::The name of the access method with number `anum' and access code `acode'.
com.sun.tools.javac.comp.Lower#accessSymbol(Symbol, JCTree, JCTree, boolean, boolean)->MethodSymbol:::Return access symbol for a private or protected symbol from an inner class.
com.sun.tools.javac.comp.Lower#accessBase(DiagnosticPosition, Symbol)->JCExpression:::The qualifier to be used for accessing a symbol in an outer class
com.sun.tools.javac.comp.Lower#needsPrivateAccess(Symbol)->boolean:::Do we need an access method to reference private symbol?
com.sun.tools.javac.comp.Lower#needsProtectedAccess(Symbol, JCTree)->boolean:::Do we need an access method to reference symbol in other package?
com.sun.tools.javac.comp.Lower#accessClass(Symbol, boolean, JCTree)->ClassSymbol:::The class in which an access method for given symbol goes.
com.sun.tools.javac.comp.Lower#access(Symbol, JCExpression, JCExpression, boolean)->JCExpression:::Ensure that identifier is accessible, return tree accessing the identifier.
com.sun.tools.javac.comp.Lower#access(JCExpression)->JCExpression:::Ensure that identifier is accessible, return tree accessing the identifier.
com.sun.tools.javac.comp.Lower#accessConstructor(DiagnosticPosition, Symbol)->Symbol:::Return access constructor for a private constructor,  or the constructor itself, if no access constructor is needed.
com.sun.tools.javac.comp.Lower#accessConstructorTag()->ClassSymbol:::Return an anonymous class nested in this toplevel class.
com.sun.tools.javac.comp.Lower#makeAccessible(Symbol)->void:::Add all required access methods for a private symbol to enclosing class.
com.sun.tools.javac.comp.Lower#accessDef(int, Symbol, MethodSymbol, int)->JCTree:::Construct definition of an access method.
com.sun.tools.javac.comp.Lower#accessConstructorDef(int, Symbol, MethodSymbol)->JCTree:::Construct definition of an access constructor.
com.sun.tools.javac.comp.Lower#proxyName(Name, int)->Name:::The name of a free variable proxy.
com.sun.tools.javac.comp.Lower#freevarDefs(int, List, Symbol)->List:::Proxy definitions for all free variables in given list, in reverse order.
com.sun.tools.javac.comp.Lower#freevarDefs(int, List, Symbol, long)->List::: lower freevar defs
com.sun.tools.javac.comp.Lower#outerThisName(Type, Symbol)->Name:::The name of a this$n field
com.sun.tools.javac.comp.Lower#outerThisDef(int, MethodSymbol)->JCVariableDecl:::Definition for this$n field.
com.sun.tools.javac.comp.Lower#outerThisDef(int, ClassSymbol)->JCVariableDecl:::Definition for this$n field.
com.sun.tools.javac.comp.Lower#loadFreevars(DiagnosticPosition, List)->List:::Return a list of trees that load the free variables in given list,  in reverse order.
com.sun.tools.javac.comp.Lower#loadFreevar(DiagnosticPosition, VarSymbol)->JCExpression::: lower load freevar
com.sun.tools.javac.comp.Lower#makeThis(DiagnosticPosition, TypeSymbol)->JCExpression:::Construct a tree simulating the expression C.this.
com.sun.tools.javac.comp.Lower#makeTwrTry(JCTry)->JCTree:::Optionally replace a try statement with the desugaring of a try-with-resources statement
com.sun.tools.javac.comp.Lower#makeOuterThis(DiagnosticPosition, TypeSymbol)->JCExpression:::Construct a tree that represents the outer instance  C.this
com.sun.tools.javac.comp.Lower#makeOwnerThis(DiagnosticPosition, Symbol, boolean)->JCExpression:::Construct a tree that represents the closest outer instance  C.this such that the given symbol is a member of C.
com.sun.tools.javac.comp.Lower#makeOwnerThisN(DiagnosticPosition, Symbol, boolean)->JCExpression:::Similar to makeOwnerThis but will never pick "this".
com.sun.tools.javac.comp.Lower#initField(int, Symbol, Symbol)->JCStatement:::Return tree simulating the assignment this.name = name, where  name is the name of a free variable.
com.sun.tools.javac.comp.Lower#initOuterThis(int)->JCStatement:::Return tree simulating the assignment this.this$n = this$n.
com.sun.tools.javac.comp.Lower.TreeBuilder#build(JCExpression)->JCExpression::: tree builder build
com.sun.tools.javac.comp.Lower#abstractRval(JCExpression, Type, TreeBuilder)->JCExpression:::Construct an expression using the builder, with the given rval  expression as an argument to the builder
com.sun.tools.javac.comp.Lower#abstractRval(JCExpression, TreeBuilder)->JCExpression::: lower abstract rval
com.sun.tools.javac.comp.Lower#abstractLval(JCExpression, TreeBuilder)->JCExpression::: lower abstract lval
com.sun.tools.javac.comp.Lower#makeComma(JCExpression, JCExpression)->JCExpression::: lower make comma
com.sun.tools.javac.comp.Lower#translate(T)->T:::Visitor method: Translate a single node
com.sun.tools.javac.comp.Lower#translate(T, Type)->T:::Visitor method: Translate a single node, boxing or unboxing if needed.
com.sun.tools.javac.comp.Lower#translate(T, JCExpression)->T:::Visitor method: Translate tree.
com.sun.tools.javac.comp.Lower#translate(List, Type)->List:::Visitor method: Translate list of trees.
com.sun.tools.javac.comp.Lower#visitPackageDef(JCPackageDecl)->void::: lower visit package def
com.sun.tools.javac.comp.Lower#visitModuleDef(JCModuleDecl)->void::: lower visit module def
com.sun.tools.javac.comp.Lower#visitClassDef(JCClassDecl)->void::: lower visit class def
com.sun.tools.javac.comp.Lower#visitMethodDef(JCMethodDecl)->void::: lower visit method def
com.sun.tools.javac.comp.Lower#visitTypeCast(JCTypeCast)->void::: lower visit type cast
com.sun.tools.javac.comp.Lower#visitNewClass(JCNewClass)->void::: lower visit new class
com.sun.tools.javac.comp.Lower#visitConditional(JCConditional)->void:::Visitor method for conditional expressions.
com.sun.tools.javac.comp.Lower#visitIf(JCIf)->void:::Visitor method for if statements.
com.sun.tools.javac.comp.Lower#visitAssert(JCAssert)->void:::Visitor method for assert statements
com.sun.tools.javac.comp.Lower#visitApply(JCMethodInvocation)->void::: lower visit apply
com.sun.tools.javac.comp.Lower#boxArgs(List, List, Type)->List::: lower box args
com.sun.tools.javac.comp.Lower#boxIfNeeded(T, Type)->T:::Expand a boxing or unboxing conversion if needed.
com.sun.tools.javac.comp.Lower#boxPrimitive(JCExpression)->JCExpression:::Box up a single primitive expression.
com.sun.tools.javac.comp.Lower#boxPrimitive(JCExpression, Type)->JCExpression:::Box up a single primitive expression.
com.sun.tools.javac.comp.Lower#unbox(JCExpression, Type)->JCExpression:::Unbox an object to a primitive value.
com.sun.tools.javac.comp.Lower#visitParens(JCParens)->void:::Visitor method for parenthesized expressions
com.sun.tools.javac.comp.Lower#visitIndexed(JCArrayAccess)->void::: lower visit indexed
com.sun.tools.javac.comp.Lower#visitAssign(JCAssign)->void::: lower visit assign
com.sun.tools.javac.comp.Lower#visitAssignop(JCAssignOp)->void::: lower visit assignop
com.sun.tools.javac.comp.Lower.AssignopDependencyScanner#scan(JCTree)->void::: assignop dependency scanner scan
com.sun.tools.javac.comp.Lower.AssignopDependencyScanner#visitAssignop(JCAssignOp)->void::: assignop dependency scanner visit assignop
com.sun.tools.javac.comp.Lower.AssignopDependencyScanner#visitUnary(JCUnary)->void::: assignop dependency scanner visit unary
com.sun.tools.javac.comp.Lower#lowerBoxedPostop(JCUnary)->JCExpression:::Lower a tree of the form e++ or e-- where e is an object type
com.sun.tools.javac.comp.Lower#visitUnary(JCUnary)->void::: lower visit unary
com.sun.tools.javac.comp.Lower#visitBinary(JCBinary)->void::: lower visit binary
com.sun.tools.javac.comp.Lower#visitIdent(JCIdent)->void::: lower visit ident
com.sun.tools.javac.comp.Lower#visitForeachLoop(JCEnhancedForLoop)->void:::Translate away the foreach loop.
com.sun.tools.javac.comp.Lower#visitVarDef(JCVariableDecl)->void::: lower visit var def
com.sun.tools.javac.comp.Lower#visitBlock(JCBlock)->void::: lower visit block
com.sun.tools.javac.comp.Lower#visitDoLoop(JCDoWhileLoop)->void::: lower visit do loop
com.sun.tools.javac.comp.Lower#visitWhileLoop(JCWhileLoop)->void::: lower visit while loop
com.sun.tools.javac.comp.Lower#visitForLoop(JCForLoop)->void::: lower visit for loop
com.sun.tools.javac.comp.Lower#visitReturn(JCReturn)->void::: lower visit return
com.sun.tools.javac.comp.Lower#visitSwitch(JCSwitch)->void::: lower visit switch
com.sun.tools.javac.comp.Lower#visitEnumSwitch(JCSwitch)->JCTree::: lower visit enum switch
com.sun.tools.javac.comp.Lower#visitStringSwitch(JCSwitch)->JCTree::: lower visit string switch
com.sun.tools.javac.comp.Lower#visitNewArray(JCNewArray)->void::: lower visit new array
com.sun.tools.javac.comp.Lower#visitSelect(JCFieldAccess)->void::: lower visit select
com.sun.tools.javac.comp.Lower#visitLetExpr(LetExpr)->void::: lower visit let expr
com.sun.tools.javac.comp.Lower#visitAnnotation(JCAnnotation)->void::: lower visit annotation
com.sun.tools.javac.comp.Lower#visitTry(JCTry)->void::: lower visit try
com.sun.tools.javac.comp.Lower#translateTopLevelClass(Env, JCTree, TreeMaker)->List:::Translate a toplevel class and return a list consisting of  the translated class and translated versions of all inner classes.
com.sun.tools.javac.comp.MemberEnter#instance(Context)->MemberEnter::: member enter instance
com.sun.tools.javac.comp.MemberEnter#signature(MethodSymbol, List, List, JCTree, JCVariableDecl, List, Env)->Type:::Construct method type from method signature.
com.sun.tools.javac.comp.MemberEnter#memberEnter(JCTree, Env)->void:::Enter field and method definitions and process import  clauses, catching any completion failure exceptions.
com.sun.tools.javac.comp.MemberEnter#memberEnter(List, Env)->void:::Enter members from a list of trees.
com.sun.tools.javac.comp.MemberEnter#visitMethodDef(JCMethodDecl)->void::: member enter visit method def
com.sun.tools.javac.comp.MemberEnter#methodEnv(JCMethodDecl, Env)->Env:::Create a fresh environment for method bodies.
com.sun.tools.javac.comp.MemberEnter#visitVarDef(JCVariableDecl)->void::: member enter visit var def
com.sun.tools.javac.comp.MemberEnter#checkType(JCTree, Type, Error)->void::: member enter check type
com.sun.tools.javac.comp.MemberEnter#checkReceiver(JCVariableDecl, Env)->void::: member enter check receiver
com.sun.tools.javac.comp.MemberEnter#needsLazyConstValue(JCTree)->boolean::: member enter needs lazy const value
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitTree(JCTree)->void::: init tree visitor visit tree
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitLiteral(JCLiteral)->void::: init tree visitor visit literal
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitTypeCast(JCTypeCast)->void::: init tree visitor visit type cast
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitUnary(JCUnary)->void::: init tree visitor visit unary
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitBinary(JCBinary)->void::: init tree visitor visit binary
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitConditional(JCConditional)->void::: init tree visitor visit conditional
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitParens(JCParens)->void::: init tree visitor visit parens
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitIdent(JCIdent)->void::: init tree visitor visit ident
com.sun.tools.javac.comp.MemberEnter.InitTreeVisitor#visitSelect(JCFieldAccess)->void::: init tree visitor visit select
com.sun.tools.javac.comp.MemberEnter#initEnv(JCVariableDecl, Env)->Env:::Create a fresh environment for a variable's initializer
com.sun.tools.javac.comp.MemberEnter#visitTree(JCTree)->void:::Default member enter visitor method: do nothing
com.sun.tools.javac.comp.MemberEnter#visitErroneous(JCErroneous)->void::: member enter visit erroneous
com.sun.tools.javac.comp.MemberEnter#getMethodEnv(JCMethodDecl, Env)->Env::: member enter get method env
com.sun.tools.javac.comp.MemberEnter#getInitEnv(JCVariableDecl, Env)->Env::: member enter get init env
com.sun.tools.javac.comp.Modules#instance(Context)->Modules::: modules instance
com.sun.tools.javac.comp.Modules#addExtraAddModules(String...)->void::: modules add extra add modules
com.sun.tools.javac.comp.Modules#initModules(List)->void::: modules init modules
com.sun.tools.javac.comp.Modules#enter(List, ClassSymbol)->boolean::: modules enter
com.sun.tools.javac.comp.Modules#getCompleter()->Completer::: modules get completer
com.sun.tools.javac.comp.Modules#getDefaultModule()->ModuleSymbol::: modules get default module
com.sun.tools.javac.comp.Modules#modulesInitialized()->boolean::: modules modules initialized
com.sun.tools.javac.comp.Modules#isRootModule(ModuleSymbol)->boolean::: modules is root module
com.sun.tools.javac.comp.Modules#getRootModules()->Set::: modules get root modules
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitModuleDef(JCModuleDecl)->void::: module visitor visit module def
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitRequires(JCRequires)->void::: module visitor visit requires
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitExports(JCExports)->void::: module visitor visit exports
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitOpens(JCOpens)->void::: module visitor visit opens
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitProvides(JCProvides)->void::: module visitor visit provides
com.sun.tools.javac.comp.Modules.ModuleVisitor#visitUses(JCUses)->void::: module visitor visit uses
com.sun.tools.javac.comp.Modules#getUsesProvidesCompleter()->Completer::: modules get uses provides completer
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitModuleDef(JCModuleDecl)->void::: uses provides visitor visit module def
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitExports(JCExports)->void::: uses provides visitor visit exports
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitOpens(JCOpens)->void::: uses provides visitor visit opens
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#noArgsConstructor(ClassSymbol)->MethodSymbol::: uses provides visitor no args constructor
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#factoryMethod(ClassSymbol)->MethodSymbol::: uses provides visitor factory method
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitProvides(JCProvides)->void::: uses provides visitor visit provides
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitRequires(JCRequires)->void::: uses provides visitor visit requires
com.sun.tools.javac.comp.Modules.UsesProvidesVisitor#visitUses(JCUses)->void::: uses provides visitor visit uses
com.sun.tools.javac.comp.Modules#allModules()->Set::: modules all modules
com.sun.tools.javac.comp.Modules#isInModuleGraph(ModuleSymbol)->boolean::: modules is in module graph
com.sun.tools.javac.comp.Modules#getObservableModule(Name)->ModuleSymbol::: modules get observable module
com.sun.tools.javac.comp.Modules#toString(Location)->String::: modules to string
com.sun.tools.javac.comp.Modules#toString(JavaFileObject)->String::: modules to string
com.sun.tools.javac.comp.Modules#newRound()->void::: modules new round
com.sun.tools.javac.comp.Modules.PackageNameFinder#findPackageNameOf(JavaFileObject)->Name::: package name finder find package name of
com.sun.tools.javac.comp.Operators#instance(Context)->Operators::: operators instance
com.sun.tools.javac.comp.Operators#unaryPromotion(Type)->Type:::Perform unary promotion of a type; this routine implements JLS 5.6.1
com.sun.tools.javac.comp.Operators#binaryPromotion(Type, Type)->Type:::Perform binary promotion of a pair of types; this routine implements JLS 5.6.2
com.sun.tools.javac.comp.Operators#resolveUnary(DiagnosticPosition, JCTree.Tag, Type)->OperatorSymbol:::Entry point for resolving a unary operator given an operator tag and an argument type.
com.sun.tools.javac.comp.Operators#resolveBinary(DiagnosticPosition, JCTree.Tag, Type, Type)->OperatorSymbol:::Entry point for resolving a binary operator given an operator tag and a pair of argument types.
com.sun.tools.javac.comp.Operators#operatorName(JCTree.Tag)->Name:::Return name of operator with given tree tag.
com.sun.tools.javac.comp.Operators.OperatorHelper#doLookup(Predicate)->OperatorSymbol:::This routine implements the main operator lookup process
com.sun.tools.javac.comp.Operators.UnaryOperatorHelper#doLookup(Type)->OperatorSymbol:::This routine implements the unary operator lookup process
com.sun.tools.javac.comp.Operators.UnaryOperatorHelper#isUnaryOperatorApplicable(OperatorSymbol, Type)->boolean:::Unary operator applicability test - is the input type the same as the expected operand type?
com.sun.tools.javac.comp.Operators.UnaryOperatorHelper#addUnaryOperator(OperatorType, OperatorType, int...)->UnaryOperatorHelper:::Adds a unary operator symbol.
com.sun.tools.javac.comp.Operators.UnaryOperatorHelper#resolve(Type)->OperatorSymbol:::This method will be overridden by unary operator helpers to provide custom resolution logic.
com.sun.tools.javac.comp.Operators.BinaryOperatorHelper#doLookup(Type, Type)->OperatorSymbol:::This routine implements the binary operator lookup process
com.sun.tools.javac.comp.Operators.BinaryOperatorHelper#isBinaryOperatorApplicable(OperatorSymbol, Type, Type)->boolean:::Binary operator applicability test - are the input types the same as the expected operand types?
com.sun.tools.javac.comp.Operators.BinaryOperatorHelper#addBinaryOperator(OperatorType, OperatorType, OperatorType, int...)->BinaryOperatorHelper:::Adds a binary operator symbol.
com.sun.tools.javac.comp.Operators.BinaryOperatorHelper#resolve(Type, Type)->OperatorSymbol:::This method will be overridden by binary operator helpers to provide custom resolution logic.
com.sun.tools.javac.comp.Operators.UnaryReferenceOperator#test(Type)->boolean::: unary reference operator test
com.sun.tools.javac.comp.Operators.UnaryReferenceOperator#resolve(Type)->OperatorSymbol::: unary reference operator resolve
com.sun.tools.javac.comp.Operators.UnaryNumericOperator#test(Type)->boolean::: unary numeric operator test
com.sun.tools.javac.comp.Operators.UnaryNumericOperator#resolve(Type)->OperatorSymbol::: unary numeric operator resolve
com.sun.tools.javac.comp.Operators.UnaryBooleanOperator#test(Type)->boolean::: unary boolean operator test
com.sun.tools.javac.comp.Operators.UnaryBooleanOperator#resolve(Type)->OperatorSymbol::: unary boolean operator resolve
com.sun.tools.javac.comp.Operators.UnaryPrefixPostfixOperator#resolve(Type)->OperatorSymbol::: unary prefix postfix operator resolve
com.sun.tools.javac.comp.Operators.BinaryNumericOperator#resolve(Type, Type)->OperatorSymbol::: binary numeric operator resolve
com.sun.tools.javac.comp.Operators.BinaryNumericOperator#test(Type, Type)->boolean::: binary numeric operator test
com.sun.tools.javac.comp.Operators.BinaryBooleanOperator#resolve(Type, Type)->OperatorSymbol::: binary boolean operator resolve
com.sun.tools.javac.comp.Operators.BinaryBooleanOperator#test(Type, Type)->boolean::: binary boolean operator test
com.sun.tools.javac.comp.Operators.BinaryStringOperator#resolve(Type, Type)->OperatorSymbol::: binary string operator resolve
com.sun.tools.javac.comp.Operators.BinaryStringOperator#test(Type, Type)->boolean::: binary string operator test
com.sun.tools.javac.comp.Operators.BinaryShiftOperator#resolve(Type, Type)->OperatorSymbol::: binary shift operator resolve
com.sun.tools.javac.comp.Operators.BinaryShiftOperator#test(Type, Type)->boolean::: binary shift operator test
com.sun.tools.javac.comp.Operators.BinaryEqualityOperator#test(Type, Type)->boolean::: binary equality operator test
com.sun.tools.javac.comp.Operators.BinaryEqualityOperator#resolve(Type, Type)->OperatorSymbol::: binary equality operator resolve
com.sun.tools.javac.comp.Operators#lookupBinaryOp(Predicate)->OperatorSymbol::: operators lookup binary op
com.sun.tools.javac.comp.Resolve#instance(Context)->Resolve::: resolve instance
com.sun.tools.javac.comp.Resolve#reportVerboseResolutionDiagnostic(DiagnosticPosition, Name, Type, List, List, Symbol)->void::: resolve report verbose resolution diagnostic
com.sun.tools.javac.comp.Resolve#getVerboseApplicableCandidateDiag(int, Symbol, Type)->JCDiagnostic::: resolve get verbose applicable candidate diag
com.sun.tools.javac.comp.Resolve#getVerboseInapplicableCandidateDiag(int, Symbol, JCDiagnostic)->JCDiagnostic::: resolve get verbose inapplicable candidate diag
com.sun.tools.javac.comp.Resolve#isStatic(Env)->boolean:::An environment is "static" if its static level is greater than  the one of its outer environment
com.sun.tools.javac.comp.Resolve#isInitializer(Env)->boolean:::An environment is an "initializer" if it is a constructor or  an instance initializer.
com.sun.tools.javac.comp.Resolve#isAccessible(Env, TypeSymbol)->boolean:::Is class accessible in given evironment?
com.sun.tools.javac.comp.Resolve#isAccessible(Env, TypeSymbol, boolean)->boolean::: resolve is accessible
com.sun.tools.javac.comp.Resolve#isAccessible(Env, Type)->boolean::: resolve is accessible
com.sun.tools.javac.comp.Resolve#isAccessible(Env, Type, boolean)->boolean::: resolve is accessible
com.sun.tools.javac.comp.Resolve#isAccessible(Env, Type, Symbol)->boolean:::Is symbol accessible as a member of given type in given environment?
com.sun.tools.javac.comp.Resolve#isAccessible(Env, Type, Symbol, boolean)->boolean::: resolve is accessible
com.sun.tools.javac.comp.Resolve#checkAccessibleType(Env, Type)->void:::Performs a recursive scan of a type looking for accessibility problems from current attribution environment
com.sun.tools.javac.comp.Resolve#rawInstantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner)->Type:::Try to instantiate the type of a method so that it fits  given type arguments and argument types
com.sun.tools.javac.comp.Resolve#checkMethod(Env, Type, Symbol, ResultInfo, List, List, Warner)->Type::: resolve check method
com.sun.tools.javac.comp.Resolve#instantiate(Env, Type, Symbol, ResultInfo, List, List, boolean, boolean, Warner)->Type:::Same but returns null instead throwing a NoInstanceException
com.sun.tools.javac.comp.Resolve.MethodCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner)->void:::Main method check routine
com.sun.tools.javac.comp.Resolve.MethodCheck#mostSpecificCheck(List)->MethodCheck:::Retrieve the method check object that will be used during a most specific check.
com.sun.tools.javac.comp.Resolve.AbstractMethodCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner)->void::: abstract method check arguments acceptable
com.sun.tools.javac.comp.Resolve.AbstractMethodCheck#checkArg(DiagnosticPosition, boolean, Type, Type, DeferredAttrContext, Warner)->void:::Does the actual argument conforms to the corresponding formal?
com.sun.tools.javac.comp.Resolve.AbstractMethodCheck#reportMC(DiagnosticPosition, MethodCheckDiag, InferenceContext, Object...)->void::: abstract method check report c
com.sun.tools.javac.comp.Resolve.AbstractMethodCheck.SharedInapplicableMethodException#setMessage(JCDiagnostic)->SharedInapplicableMethodException::: shared inapplicable method exception set message
com.sun.tools.javac.comp.Resolve.AbstractMethodCheck#mostSpecificCheck(List)->MethodCheck::: abstract method check most specific check
com.sun.tools.javac.comp.Resolve.MethodReferenceCheck#checkArg(DiagnosticPosition, boolean, Type, Type, DeferredAttrContext, Warner)->void::: method reference check check arg
com.sun.tools.javac.comp.Resolve.MethodReferenceCheck#mostSpecificCheck(List)->MethodCheck::: method reference check most specific check
com.sun.tools.javac.comp.Resolve.MethodReferenceCheck#toString()->String::: method reference check to string
com.sun.tools.javac.comp.Resolve.MethodCheckContext#compatible(Type, Type, Warner)->boolean::: method check context compatible
com.sun.tools.javac.comp.Resolve.MethodCheckContext#report(DiagnosticPosition, JCDiagnostic)->void::: method check context report
com.sun.tools.javac.comp.Resolve.MethodCheckContext#checkWarner(DiagnosticPosition, Type, Type)->Warner::: method check context check warner
com.sun.tools.javac.comp.Resolve.MethodCheckContext#inferenceContext()->InferenceContext::: method check context inference context
com.sun.tools.javac.comp.Resolve.MethodCheckContext#deferredAttrContext()->DeferredAttrContext::: method check context deferred attr context
com.sun.tools.javac.comp.Resolve.MethodCheckContext#toString()->String::: method check context to string
com.sun.tools.javac.comp.Resolve.MethodResultInfo#check(DiagnosticPosition, Type)->Type::: method result info check
com.sun.tools.javac.comp.Resolve.MethodResultInfo#dup(Type)->MethodResultInfo::: method result info dup
com.sun.tools.javac.comp.Resolve.MethodResultInfo#dup(CheckContext)->ResultInfo::: method result info dup
com.sun.tools.javac.comp.Resolve.MethodResultInfo#dup(Type, CheckContext)->ResultInfo::: method result info dup
com.sun.tools.javac.comp.Resolve.MostSpecificCheck#argumentsAcceptable(Env, DeferredAttrContext, List, List, Warner)->void::: most specific check arguments acceptable
com.sun.tools.javac.comp.Resolve.MostSpecificCheck#methodCheckResult(Type, DeferredAttr.DeferredAttrContext, Warner, Type)->ResultInfo:::Create a method check context to be used during the most specific applicability check
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext#compatible(Type, Type, Warner)->boolean::: most specific check context compatible
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#skip(JCTree)->void::: most specific function return checker skip
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitConditional(JCConditional)->void::: most specific function return checker visit conditional
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitReference(JCMemberReference)->void::: most specific function return checker visit reference
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitParens(JCParens)->void::: most specific function return checker visit parens
com.sun.tools.javac.comp.Resolve.MostSpecificCheck.MostSpecificCheckContext.MostSpecificFunctionReturnChecker#visitLambda(JCLambda)->void::: most specific function return checker visit lambda
com.sun.tools.javac.comp.Resolve.MostSpecificCheck#mostSpecificCheck(List)->MethodCheck::: most specific check most specific check
com.sun.tools.javac.comp.Resolve.InapplicableMethodException#getDiagnostic()->JCDiagnostic::: inapplicable method exception get diagnostic
com.sun.tools.javac.comp.Resolve#findField(Env, Type, Name, TypeSymbol)->Symbol:::Find field
com.sun.tools.javac.comp.Resolve#resolveInternalField(DiagnosticPosition, Env, Type, Name)->VarSymbol:::Resolve a field identifier, throw a fatal error if not found.
com.sun.tools.javac.comp.Resolve#findVar(Env, Name)->Symbol:::Find unqualified variable or field with given name
com.sun.tools.javac.comp.Resolve#selectBest(Env, Type, List, List, Symbol, Symbol, boolean, boolean)->Symbol:::Select the best method for a call site among two choices.
com.sun.tools.javac.comp.Resolve#mostSpecific(List, Symbol, Symbol, Env, Type, boolean)->Symbol::: resolve most specific
com.sun.tools.javac.comp.Resolve#adjustArgs(List, Symbol, int, boolean)->List::: resolve adjust args
com.sun.tools.javac.comp.Resolve#ambiguityError(Symbol, Symbol)->Symbol::: resolve ambiguity error
com.sun.tools.javac.comp.Resolve#findMethodInScope(Env, Type, Name, List, List, Scope, Symbol, boolean, boolean, boolean)->Symbol::: resolve find method in scope
com.sun.tools.javac.comp.Resolve.LookupFilter#accepts(Symbol)->boolean::: lookup filter accepts
com.sun.tools.javac.comp.Resolve#findMethod(Env, Type, Name, List, List, boolean, boolean)->Symbol:::Find best qualified method matching given name, type and value  arguments.
com.sun.tools.javac.comp.Resolve#superclasses(Type)->Iterable:::Return an Iterable object to scan the superclasses of a given type
com.sun.tools.javac.comp.Resolve#findFun(Env, Name, List, List, boolean, boolean)->Symbol:::Find unqualified method matching given name, type and value arguments.
com.sun.tools.javac.comp.Resolve#loadClass(Env, Name, RecoveryLoadClass)->Symbol:::Load toplevel or member class with given fully qualified name and  verify that it is accessible.
com.sun.tools.javac.comp.Resolve.RecoveryLoadClass#loadClass(Env, Name)->Symbol::: recovery load class load class
com.sun.tools.javac.comp.Resolve#lookupPackage(Env, Name)->Symbol::: resolve lookup package
com.sun.tools.javac.comp.Resolve#findImmediateMemberType(Env, Type, Name, TypeSymbol)->Symbol:::Find a type declared in a scope (not inherited)
com.sun.tools.javac.comp.Resolve#findInheritedMemberType(Env, Type, Name, TypeSymbol)->Symbol:::Find a member type inherited from a superclass or interface.
com.sun.tools.javac.comp.Resolve#findMemberType(Env, Type, Name, TypeSymbol)->Symbol:::Find qualified member type.
com.sun.tools.javac.comp.Resolve#findGlobalType(Env, Scope, Name, RecoveryLoadClass)->Symbol:::Find a global type in given scope and load corresponding class.
com.sun.tools.javac.comp.Resolve#findTypeVar(Env, Name, boolean)->Symbol::: resolve find type var
com.sun.tools.javac.comp.Resolve#findType(Env, Name)->Symbol:::Find an unqualified type symbol.
com.sun.tools.javac.comp.Resolve#findIdent(Env, Name, KindSelector)->Symbol:::Find an unqualified identifier which matches a specified kind set.
com.sun.tools.javac.comp.Resolve#findIdentInternal(Env, Name, KindSelector)->Symbol::: resolve find ident internal
com.sun.tools.javac.comp.Resolve#findIdentInPackage(Env, TypeSymbol, Name, KindSelector)->Symbol:::Find an identifier in a package which matches a specified kind set.
com.sun.tools.javac.comp.Resolve#findIdentInPackageInternal(Env, TypeSymbol, Name, KindSelector)->Symbol::: resolve find ident in package internal
com.sun.tools.javac.comp.Resolve#findIdentInType(Env, Type, Name, KindSelector)->Symbol:::Find an identifier among the members of a given type `site'.
com.sun.tools.javac.comp.Resolve#findIdentInTypeInternal(Env, Type, Name, KindSelector)->Symbol::: resolve find ident in type internal
com.sun.tools.javac.comp.Resolve#accessInternal(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List, LogResolveHelper)->Symbol:::If `sym' is a bad symbol: report error and return errSymbol  else pass through unchanged,  additional arguments duplicate what has been used in trying to find the  symbol (--> flyweight pattern)
com.sun.tools.javac.comp.Resolve#accessMethod(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean, List, List)->Symbol:::Variant of the generalized access routine, to be used for generating method resolution diagnostics
com.sun.tools.javac.comp.Resolve#accessMethod(Symbol, DiagnosticPosition, Type, Name, boolean, List, List)->Symbol:::Same as original accessMethod(), but without location.
com.sun.tools.javac.comp.Resolve#accessBase(Symbol, DiagnosticPosition, Symbol, Type, Name, boolean)->Symbol:::Variant of the generalized access routine, to be used for generating variable, type resolution diagnostics
com.sun.tools.javac.comp.Resolve#accessBase(Symbol, DiagnosticPosition, Type, Name, boolean)->Symbol:::Same as original accessBase(), but without location.
com.sun.tools.javac.comp.Resolve.LogResolveHelper#resolveDiagnosticNeeded(Type, List, List)->boolean::: log resolve helper resolve diagnostic needed
com.sun.tools.javac.comp.Resolve.LogResolveHelper#getArgumentTypes(ResolveError, Symbol, Name, List)->List::: log resolve helper get argument types
com.sun.tools.javac.comp.Resolve.ResolveDeferredRecoveryMap#typeOf(DeferredType)->Type::: resolve deferred recovery map type of
com.sun.tools.javac.comp.Resolve#checkNonAbstract(DiagnosticPosition, Symbol)->void:::Check that sym is not an abstract method.
com.sun.tools.javac.comp.Resolve#resolveIdent(DiagnosticPosition, Env, Name, KindSelector)->Symbol:::Resolve an unqualified (non-method) identifier.
com.sun.tools.javac.comp.Resolve#resolveMethod(DiagnosticPosition, Env, Name, List, List)->Symbol:::Resolve an unqualified method identifier.
com.sun.tools.javac.comp.Resolve#resolveQualifiedMethod(DiagnosticPosition, Env, Type, Name, List, List)->Symbol:::Resolve a qualified method identifier
com.sun.tools.javac.comp.Resolve#resolveQualifiedMethod(DiagnosticPosition, Env, Symbol, Type, Name, List, List)->Symbol::: resolve resolve qualified method
com.sun.tools.javac.comp.Resolve#findPolymorphicSignatureInstance(Env, Symbol, List)->Symbol:::Find or create an implicit method of exactly the given type (after erasure)
com.sun.tools.javac.comp.Resolve#findPolymorphicSignatureInstance(Symbol, Type)->Symbol::: resolve find polymorphic signature instance
com.sun.tools.javac.comp.Resolve#resolveInternalMethod(DiagnosticPosition, Env, Type, Name, List, List)->MethodSymbol:::Resolve a qualified method identifier, throw a fatal error if not  found.
com.sun.tools.javac.comp.Resolve#resolveConstructor(DiagnosticPosition, Env, Type, List, List)->Symbol:::Resolve constructor.
com.sun.tools.javac.comp.Resolve#resolveInternalConstructor(DiagnosticPosition, Env, Type, List, List)->MethodSymbol:::Resolve a constructor, throw a fatal error if not found.
com.sun.tools.javac.comp.Resolve#findConstructor(DiagnosticPosition, Env, Type, List, List, boolean, boolean)->Symbol::: resolve find constructor
com.sun.tools.javac.comp.Resolve#resolveDiamond(DiagnosticPosition, Env, Type, List, List)->Symbol:::Resolve constructor using diamond inference.
com.sun.tools.javac.comp.Resolve#getMemberReference(DiagnosticPosition, Env, JCMemberReference, Type, Name)->Symbol::: resolve get member reference
com.sun.tools.javac.comp.Resolve#makeReferenceLookupHelper(JCMemberReference, Type, Name, List, List, MethodResolutionPhase)->ReferenceLookupHelper::: resolve make reference lookup helper
com.sun.tools.javac.comp.Resolve#resolveMemberReference(Env, JCMemberReference, Type, Name, List, List, Type, MethodCheck, InferenceContext, ReferenceChooser)->Pair:::Resolution of member references is typically done as a single overload resolution step, where the argument types A are inferred from the target functional descriptor
com.sun.tools.javac.comp.Resolve.ReferenceLookupResult#isSuccess()->boolean:::Does this result corresponds to a successful lookup (i.e
com.sun.tools.javac.comp.Resolve.ReferenceLookupResult#hasKind(StaticKind)->boolean:::Does this result have given static kind?
com.sun.tools.javac.comp.Resolve.ReferenceLookupResult#canIgnore()->boolean:::Error recovery helper: can this lookup result be ignored (for the purpose of returning some 'better' result) ?
com.sun.tools.javac.comp.Resolve.ReferenceLookupResult#error(Symbol)->ReferenceLookupResult::: reference lookup result error
com.sun.tools.javac.comp.Resolve.ReferenceChooser#result(ReferenceLookupResult, ReferenceLookupResult)->ReferenceLookupResult:::Generate a result from a pair of lookup result objects
com.sun.tools.javac.comp.Resolve.ReferenceChooser#boundResult(ReferenceLookupResult)->ReferenceLookupResult:::Generate a symbol from a given bound lookup result.
com.sun.tools.javac.comp.Resolve.ReferenceChooser#unboundResult(ReferenceLookupResult, ReferenceLookupResult)->ReferenceLookupResult:::Generate a symbol from a pair of bound/unbound lookup results.
com.sun.tools.javac.comp.Resolve.LookupHelper#shouldStop(Symbol, MethodResolutionPhase)->boolean:::Should lookup stop at given phase with given result
com.sun.tools.javac.comp.Resolve.LookupHelper#lookup(Env, MethodResolutionPhase)->Symbol:::Search for a symbol under a given overload resolution phase - this method is usually called several times, once per each overload resolution phase
com.sun.tools.javac.comp.Resolve.LookupHelper#debug(DiagnosticPosition, Symbol)->void:::Dump overload resolution info
com.sun.tools.javac.comp.Resolve.LookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol)->Symbol:::Validate the result of the lookup
com.sun.tools.javac.comp.Resolve.BasicLookupHelper#lookup(Env, MethodResolutionPhase)->Symbol::: basic lookup helper lookup
com.sun.tools.javac.comp.Resolve.BasicLookupHelper#doLookup(Env, MethodResolutionPhase)->Symbol::: basic lookup helper do lookup
com.sun.tools.javac.comp.Resolve.BasicLookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol)->Symbol::: basic lookup helper access
com.sun.tools.javac.comp.Resolve.BasicLookupHelper#debug(DiagnosticPosition, Symbol)->void::: basic lookup helper debug
com.sun.tools.javac.comp.Resolve.ReferenceLookupHelper#unboundLookup(InferenceContext)->ReferenceLookupHelper:::Returns an unbound version of this lookup helper
com.sun.tools.javac.comp.Resolve.ReferenceLookupHelper#referenceKind(Symbol)->JCMemberReference.ReferenceKind:::Get the kind of the member reference
com.sun.tools.javac.comp.Resolve.ReferenceLookupHelper#access(Env, DiagnosticPosition, Symbol, Symbol)->Symbol::: reference lookup helper access
com.sun.tools.javac.comp.Resolve.MethodReferenceLookupHelper#lookup(Env, MethodResolutionPhase)->Symbol::: method reference lookup helper lookup
com.sun.tools.javac.comp.Resolve.MethodReferenceLookupHelper#unboundLookup(InferenceContext)->ReferenceLookupHelper::: method reference lookup helper unbound lookup
com.sun.tools.javac.comp.Resolve.MethodReferenceLookupHelper#referenceKind(Symbol)->ReferenceKind::: method reference lookup helper reference kind
com.sun.tools.javac.comp.Resolve.UnboundMethodReferenceLookupHelper#unboundLookup(InferenceContext)->ReferenceLookupHelper::: unbound method reference lookup helper unbound lookup
com.sun.tools.javac.comp.Resolve.UnboundMethodReferenceLookupHelper#referenceKind(Symbol)->ReferenceKind::: unbound method reference lookup helper reference kind
com.sun.tools.javac.comp.Resolve.ArrayConstructorReferenceLookupHelper#lookup(Env, MethodResolutionPhase)->Symbol::: array constructor reference lookup helper lookup
com.sun.tools.javac.comp.Resolve.ArrayConstructorReferenceLookupHelper#referenceKind(Symbol)->ReferenceKind::: array constructor reference lookup helper reference kind
com.sun.tools.javac.comp.Resolve.ConstructorReferenceLookupHelper#lookup(Env, MethodResolutionPhase)->Symbol::: constructor reference lookup helper lookup
com.sun.tools.javac.comp.Resolve.ConstructorReferenceLookupHelper#referenceKind(Symbol)->ReferenceKind::: constructor reference lookup helper reference kind
com.sun.tools.javac.comp.Resolve#lookupMethod(Env, DiagnosticPosition, Symbol, MethodCheck, LookupHelper)->Symbol:::Main overload resolution routine
com.sun.tools.javac.comp.Resolve#lookupMethod(Env, DiagnosticPosition, Symbol, MethodResolutionContext, LookupHelper)->Symbol::: resolve lookup method
com.sun.tools.javac.comp.Resolve#resolveSelf(DiagnosticPosition, Env, TypeSymbol, Name)->Symbol:::Resolve `c.name' where name == this or name == super.
com.sun.tools.javac.comp.Resolve#resolveSelfContaining(DiagnosticPosition, Env, Symbol, boolean)->Symbol:::Resolve `c.this' for an enclosing class c that contains the named member.
com.sun.tools.javac.comp.Resolve#enclosingInstanceMissing(Env, Type)->boolean::: resolve enclosing instance missing
com.sun.tools.javac.comp.Resolve#resolveImplicitThis(DiagnosticPosition, Env, Type)->Type:::Resolve an appropriate implicit this instance for t's container
com.sun.tools.javac.comp.Resolve#resolveImplicitThis(DiagnosticPosition, Env, Type, boolean)->Type::: resolve resolve implicit this
com.sun.tools.javac.comp.Resolve#logAccessErrorInternal(Env, JCTree, Type)->void::: resolve log access error internal
com.sun.tools.javac.comp.Resolve#methodArguments(List)->Object::: resolve method arguments
com.sun.tools.javac.comp.Resolve.ResolveError#accept(ElementVisitor, P)->R::: resolve error accept
com.sun.tools.javac.comp.Resolve.ResolveError#toString()->String::: resolve error to string
com.sun.tools.javac.comp.Resolve.ResolveError#exists()->boolean::: resolve error exists
com.sun.tools.javac.comp.Resolve.ResolveError#isStatic()->boolean::: resolve error is static
com.sun.tools.javac.comp.Resolve.ResolveError#access(Name, TypeSymbol)->Symbol:::Create an external representation for this erroneous symbol to be used during attribution - by default this returns the symbol of a brand new error type which stores the original type found during resolution.
com.sun.tools.javac.comp.Resolve.ResolveError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic:::Create a diagnostic representing this resolution error.
com.sun.tools.javac.comp.Resolve.InvalidSymbolError#exists()->boolean::: invalid symbol error exists
com.sun.tools.javac.comp.Resolve.InvalidSymbolError#toString()->String::: invalid symbol error to string
com.sun.tools.javac.comp.Resolve.InvalidSymbolError#access(Name, TypeSymbol)->Symbol::: invalid symbol error access
com.sun.tools.javac.comp.Resolve.BadVarTypeError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: bad var type error get diagnostic
com.sun.tools.javac.comp.Resolve.SymbolNotFoundError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: symbol not found error get diagnostic
com.sun.tools.javac.comp.Resolve.InapplicableSymbolError#toString()->String::: inapplicable symbol error to string
com.sun.tools.javac.comp.Resolve.InapplicableSymbolError#exists()->boolean::: inapplicable symbol error exists
com.sun.tools.javac.comp.Resolve.InapplicableSymbolError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: inapplicable symbol error get diagnostic
com.sun.tools.javac.comp.Resolve.InapplicableSymbolError#access(Name, TypeSymbol)->Symbol::: inapplicable symbol error access
com.sun.tools.javac.comp.Resolve.InapplicableSymbolError#errCandidate()->Pair::: inapplicable symbol error err candidate
com.sun.tools.javac.comp.Resolve.InapplicableSymbolsError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: inapplicable symbols error get diagnostic
com.sun.tools.javac.comp.Resolve.InapplicableSymbolsError#filterCandidates(Map)->Map::: inapplicable symbols error filter candidates
com.sun.tools.javac.comp.Resolve.DiamondError#getDetails()->JCDiagnostic::: diamond error get details
com.sun.tools.javac.comp.Resolve.DiamondError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: diamond error get diagnostic
com.sun.tools.javac.comp.Resolve.AccessError#exists()->boolean::: access error exists
com.sun.tools.javac.comp.Resolve.AccessError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: access error get diagnostic
com.sun.tools.javac.comp.Resolve.InvisibleSymbolError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: invisible symbol error get diagnostic
com.sun.tools.javac.comp.Resolve#inaccessiblePackageReason(Env, PackageSymbol)->JCDiagnostic::: resolve inaccessible package reason
com.sun.tools.javac.comp.Resolve.StaticError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: static error get diagnostic
com.sun.tools.javac.comp.Resolve.AmbiguityError#exists()->boolean::: ambiguity error exists
com.sun.tools.javac.comp.Resolve.AmbiguityError#addAmbiguousSymbol(Symbol)->AmbiguityError::: ambiguity error add ambiguous symbol
com.sun.tools.javac.comp.Resolve.AmbiguityError#getDiagnostic(JCDiagnostic.DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: ambiguity error get diagnostic
com.sun.tools.javac.comp.Resolve.AmbiguityError#mergeAbstracts(Type)->Symbol:::If multiple applicable methods are found during overload and none of them is more specific than the others, attempt to merge their signatures.
com.sun.tools.javac.comp.Resolve.AmbiguityError#access(Name, TypeSymbol)->Symbol::: ambiguity error access
com.sun.tools.javac.comp.Resolve.BadVarargsMethod#baseSymbol()->Symbol::: bad varargs method base symbol
com.sun.tools.javac.comp.Resolve.BadVarargsMethod#access(Name, TypeSymbol)->Symbol::: bad varargs method access
com.sun.tools.javac.comp.Resolve.BadVarargsMethod#exists()->boolean::: bad varargs method exists
com.sun.tools.javac.comp.Resolve.BadVarargsMethod#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: bad varargs method get diagnostic
com.sun.tools.javac.comp.Resolve.BadMethodReferenceError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: bad method reference error get diagnostic
com.sun.tools.javac.comp.Resolve.BadConstructorReferenceError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: bad constructor reference error get diagnostic
com.sun.tools.javac.comp.Resolve.BadClassFileError#getDiagnostic(DiagnosticType, DiagnosticPosition, Symbol, Type, Name, List, List)->JCDiagnostic::: bad class file error get diagnostic
com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.DiagnosticRewriter#rewriteDiagnostic(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic)->JCDiagnostic::: diagnostic rewriter rewrite diagnostic
com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template#matches(Object)->boolean:::Returns true if the regex matches the diagnostic key and if all diagnostic arguments are matches by corresponding sub-templates.
com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.ArgMismatchRewriter#rewriteDiagnostic(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic)->JCDiagnostic::: arg mismatch rewriter rewrite diagnostic
com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper#rewrite(JCDiagnostic.Factory, DiagnosticPosition, DiagnosticSource, DiagnosticType, JCDiagnostic)->JCDiagnostic:::Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it, and rewrite it accordingly.
com.sun.tools.javac.comp.Resolve.MethodResolutionContext#addInapplicableCandidate(Symbol, JCDiagnostic)->void::: method resolution context add inapplicable candidate
com.sun.tools.javac.comp.Resolve.MethodResolutionContext#addApplicableCandidate(Symbol, Type)->void::: method resolution context add applicable candidate
com.sun.tools.javac.comp.Resolve.MethodResolutionContext#deferredAttrContext(Symbol, InferenceContext, ResultInfo, Warner)->DeferredAttrContext::: method resolution context deferred attr context
com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate#isApplicable()->boolean::: candidate is applicable
com.sun.tools.javac.comp.Resolve.MethodResolutionContext#attrMode()->DeferredAttr.AttrMode::: method resolution context attr mode
com.sun.tools.javac.comp.Resolve.MethodResolutionContext#internal()->boolean::: method resolution context internal
com.sun.tools.javac.comp.Todo#instance(Context)->Todo:::Get the Todo instance for this context.
com.sun.tools.javac.comp.Todo#append(Env)->void::: todo append
com.sun.tools.javac.comp.Todo#iterator()->Iterator>::: todo iterator
com.sun.tools.javac.comp.Todo#size()->int::: todo size
com.sun.tools.javac.comp.Todo#offer(Env)->boolean::: todo offer
com.sun.tools.javac.comp.Todo#retainFiles(Collection)->void:::Removes all unattributed classes except those belonging to the given collection of files.
com.sun.tools.javac.comp.Todo#poll()->Env::: todo poll
com.sun.tools.javac.comp.Todo#peek()->Env::: todo peek
com.sun.tools.javac.comp.Todo#groupByFile()->Queue>>::: todo group by file
com.sun.tools.javac.comp.Todo.FileQueue#iterator()->Iterator>::: file queue iterator
com.sun.tools.javac.comp.Todo.FileQueue#size()->int::: file queue size
com.sun.tools.javac.comp.Todo.FileQueue#offer(Env)->boolean::: file queue offer
com.sun.tools.javac.comp.Todo.FileQueue#poll()->Env::: file queue poll
com.sun.tools.javac.comp.Todo.FileQueue#peek()->Env::: file queue peek
com.sun.tools.javac.comp.TransTypes#instance(Context)->TransTypes:::Get the instance for this context.
com.sun.tools.javac.comp.TransTypes#cast(JCExpression, Type)->JCExpression:::Construct an attributed tree for a cast of expression to target type,  unless it already has precisely that type.
com.sun.tools.javac.comp.TransTypes#coerce(Env, JCExpression, Type)->JCExpression:::Construct an attributed tree to coerce an expression to some erased  target type, unless the expression is already assignable to that type
com.sun.tools.javac.comp.TransTypes#coerce(JCExpression, Type)->JCExpression::: trans types coerce
com.sun.tools.javac.comp.TransTypes#retype(JCExpression, Type, Type)->JCExpression:::Given an erased reference type, assume this type as the tree's type
com.sun.tools.javac.comp.TransTypes#translateArgs(List, List, Type)->List:::Translate method argument list, casting each argument  to its corresponding type in a list of target types.
com.sun.tools.javac.comp.TransTypes#translateArgs(List, List, Type, Env)->List::: trans types translate args
com.sun.tools.javac.comp.TransTypes#addBridge(DiagnosticPosition, MethodSymbol, MethodSymbol, ClassSymbol, ListBuffer)->void:::Add a bridge definition and enter corresponding method symbol in  local scope of origin.
com.sun.tools.javac.comp.TransTypes#addBridgeIfNeeded(DiagnosticPosition, Symbol, ClassSymbol, ListBuffer)->void:::Add bridge if given symbol is a non-private, non-static member  of the given class, which is either defined in the class or non-final  inherited, and one of the two following conditions holds:  1
com.sun.tools.javac.comp.TransTypes#addBridges(DiagnosticPosition, TypeSymbol, ClassSymbol, ListBuffer)->void::: trans types add bridges
com.sun.tools.javac.comp.TransTypes#addBridges(DiagnosticPosition, ClassSymbol, ListBuffer)->void:::Add all necessary bridges to some class appending them to list buffer.
com.sun.tools.javac.comp.TransTypes#translate(T, Type)->T:::Visitor method: perform a type translation on tree.
com.sun.tools.javac.comp.TransTypes#translate(List, Type)->List:::Visitor method: perform a type translation on list of trees.
com.sun.tools.javac.comp.TransTypes#visitClassDef(JCClassDecl)->void::: trans types visit class def
com.sun.tools.javac.comp.TransTypes#visitMethodDef(JCMethodDecl)->void::: trans types visit method def
com.sun.tools.javac.comp.TransTypes#visitVarDef(JCVariableDecl)->void::: trans types visit var def
com.sun.tools.javac.comp.TransTypes#visitDoLoop(JCDoWhileLoop)->void::: trans types visit do loop
com.sun.tools.javac.comp.TransTypes#visitWhileLoop(JCWhileLoop)->void::: trans types visit while loop
com.sun.tools.javac.comp.TransTypes#visitForLoop(JCForLoop)->void::: trans types visit for loop
com.sun.tools.javac.comp.TransTypes#visitForeachLoop(JCEnhancedForLoop)->void::: trans types visit foreach loop
com.sun.tools.javac.comp.TransTypes#visitLambda(JCLambda)->void::: trans types visit lambda
com.sun.tools.javac.comp.TransTypes#visitSwitch(JCSwitch)->void::: trans types visit switch
com.sun.tools.javac.comp.TransTypes#visitCase(JCCase)->void::: trans types visit case
com.sun.tools.javac.comp.TransTypes#visitSynchronized(JCSynchronized)->void::: trans types visit synchronized
com.sun.tools.javac.comp.TransTypes#visitTry(JCTry)->void::: trans types visit try
com.sun.tools.javac.comp.TransTypes#visitConditional(JCConditional)->void::: trans types visit conditional
com.sun.tools.javac.comp.TransTypes#visitIf(JCIf)->void::: trans types visit if
com.sun.tools.javac.comp.TransTypes#visitExec(JCExpressionStatement)->void::: trans types visit exec
com.sun.tools.javac.comp.TransTypes#visitReturn(JCReturn)->void::: trans types visit return
com.sun.tools.javac.comp.TransTypes#visitThrow(JCThrow)->void::: trans types visit throw
com.sun.tools.javac.comp.TransTypes#visitAssert(JCAssert)->void::: trans types visit assert
com.sun.tools.javac.comp.TransTypes#visitApply(JCMethodInvocation)->void::: trans types visit apply
com.sun.tools.javac.comp.TransTypes#visitNewClass(JCNewClass)->void::: trans types visit new class
com.sun.tools.javac.comp.TransTypes#visitNewArray(JCNewArray)->void::: trans types visit new array
com.sun.tools.javac.comp.TransTypes#visitParens(JCParens)->void::: trans types visit parens
com.sun.tools.javac.comp.TransTypes#visitAssign(JCAssign)->void::: trans types visit assign
com.sun.tools.javac.comp.TransTypes#visitAssignop(JCAssignOp)->void::: trans types visit assignop
com.sun.tools.javac.comp.TransTypes#visitUnary(JCUnary)->void::: trans types visit unary
com.sun.tools.javac.comp.TransTypes#visitBinary(JCBinary)->void::: trans types visit binary
com.sun.tools.javac.comp.TransTypes#visitAnnotatedType(JCAnnotatedType)->void::: trans types visit annotated type
com.sun.tools.javac.comp.TransTypes#visitTypeCast(JCTypeCast)->void::: trans types visit type cast
com.sun.tools.javac.comp.TransTypes#visitTypeTest(JCInstanceOf)->void::: trans types visit type test
com.sun.tools.javac.comp.TransTypes#visitIndexed(JCArrayAccess)->void::: trans types visit indexed
com.sun.tools.javac.comp.TransTypes#visitAnnotation(JCAnnotation)->void::: trans types visit annotation
com.sun.tools.javac.comp.TransTypes#visitIdent(JCIdent)->void::: trans types visit ident
com.sun.tools.javac.comp.TransTypes#visitSelect(JCFieldAccess)->void::: trans types visit select
com.sun.tools.javac.comp.TransTypes#visitReference(JCMemberReference)->void::: trans types visit reference
com.sun.tools.javac.comp.TransTypes#visitTypeArray(JCArrayTypeTree)->void::: trans types visit type array
com.sun.tools.javac.comp.TransTypes#visitTypeApply(JCTypeApply)->void:::Visitor method for parameterized types.
com.sun.tools.javac.comp.TransTypes#visitTypeIntersection(JCTypeIntersection)->void::: trans types visit type intersection
com.sun.tools.javac.comp.TransTypes#translateClass(ClassSymbol)->void::: trans types translate class
com.sun.tools.javac.comp.TransTypes#translateTopLevelClass(JCTree, TreeMaker)->JCTree:::Translate a toplevel class definition.
com.sun.tools.javac.comp.TreeDiffer#scan(JCTree, JCTree)->boolean::: tree differ scan
com.sun.tools.javac.comp.TreeDiffer#visitIdent(JCIdent)->void::: tree differ visit ident
com.sun.tools.javac.comp.TreeDiffer#visitSelect(JCFieldAccess)->void::: tree differ visit select
com.sun.tools.javac.comp.TreeDiffer#visitAnnotatedType(JCAnnotatedType)->void::: tree differ visit annotated type
com.sun.tools.javac.comp.TreeDiffer#visitAnnotation(JCAnnotation)->void::: tree differ visit annotation
com.sun.tools.javac.comp.TreeDiffer#visitApply(JCMethodInvocation)->void::: tree differ visit apply
com.sun.tools.javac.comp.TreeDiffer#visitAssert(JCAssert)->void::: tree differ visit assert
com.sun.tools.javac.comp.TreeDiffer#visitAssign(JCAssign)->void::: tree differ visit assign
com.sun.tools.javac.comp.TreeDiffer#visitAssignop(JCAssignOp)->void::: tree differ visit assignop
com.sun.tools.javac.comp.TreeDiffer#visitBinary(JCBinary)->void::: tree differ visit binary
com.sun.tools.javac.comp.TreeDiffer#visitBlock(JCBlock)->void::: tree differ visit block
com.sun.tools.javac.comp.TreeDiffer#visitBreak(JCBreak)->void::: tree differ visit break
com.sun.tools.javac.comp.TreeDiffer#visitCase(JCCase)->void::: tree differ visit case
com.sun.tools.javac.comp.TreeDiffer#visitCatch(JCCatch)->void::: tree differ visit catch
com.sun.tools.javac.comp.TreeDiffer#visitClassDef(JCClassDecl)->void::: tree differ visit class def
com.sun.tools.javac.comp.TreeDiffer#visitConditional(JCConditional)->void::: tree differ visit conditional
com.sun.tools.javac.comp.TreeDiffer#visitContinue(JCContinue)->void::: tree differ visit continue
com.sun.tools.javac.comp.TreeDiffer#visitDoLoop(JCDoWhileLoop)->void::: tree differ visit do loop
com.sun.tools.javac.comp.TreeDiffer#visitErroneous(JCErroneous)->void::: tree differ visit erroneous
com.sun.tools.javac.comp.TreeDiffer#visitExec(JCExpressionStatement)->void::: tree differ visit exec
com.sun.tools.javac.comp.TreeDiffer#visitExports(JCExports)->void::: tree differ visit exports
com.sun.tools.javac.comp.TreeDiffer#visitForLoop(JCForLoop)->void::: tree differ visit for loop
com.sun.tools.javac.comp.TreeDiffer#visitForeachLoop(JCEnhancedForLoop)->void::: tree differ visit foreach loop
com.sun.tools.javac.comp.TreeDiffer#visitIf(JCIf)->void::: tree differ visit if
com.sun.tools.javac.comp.TreeDiffer#visitImport(JCImport)->void::: tree differ visit import
com.sun.tools.javac.comp.TreeDiffer#visitIndexed(JCArrayAccess)->void::: tree differ visit indexed
com.sun.tools.javac.comp.TreeDiffer#visitLabelled(JCLabeledStatement)->void::: tree differ visit labelled
com.sun.tools.javac.comp.TreeDiffer#visitLambda(JCLambda)->void::: tree differ visit lambda
com.sun.tools.javac.comp.TreeDiffer#visitLetExpr(LetExpr)->void::: tree differ visit let expr
com.sun.tools.javac.comp.TreeDiffer#visitLiteral(JCLiteral)->void::: tree differ visit literal
com.sun.tools.javac.comp.TreeDiffer#visitMethodDef(JCMethodDecl)->void::: tree differ visit method def
com.sun.tools.javac.comp.TreeDiffer#visitModifiers(JCModifiers)->void::: tree differ visit modifiers
com.sun.tools.javac.comp.TreeDiffer#visitModuleDef(JCModuleDecl)->void::: tree differ visit module def
com.sun.tools.javac.comp.TreeDiffer#visitNewArray(JCNewArray)->void::: tree differ visit new array
com.sun.tools.javac.comp.TreeDiffer#visitNewClass(JCNewClass)->void::: tree differ visit new class
com.sun.tools.javac.comp.TreeDiffer#visitOpens(JCOpens)->void::: tree differ visit opens
com.sun.tools.javac.comp.TreeDiffer#visitPackageDef(JCPackageDecl)->void::: tree differ visit package def
com.sun.tools.javac.comp.TreeDiffer#visitProvides(JCProvides)->void::: tree differ visit provides
com.sun.tools.javac.comp.TreeDiffer#visitReference(JCMemberReference)->void::: tree differ visit reference
com.sun.tools.javac.comp.TreeDiffer#visitRequires(JCRequires)->void::: tree differ visit requires
com.sun.tools.javac.comp.TreeDiffer#visitReturn(JCReturn)->void::: tree differ visit return
com.sun.tools.javac.comp.TreeDiffer#visitSwitch(JCSwitch)->void::: tree differ visit switch
com.sun.tools.javac.comp.TreeDiffer#visitSynchronized(JCSynchronized)->void::: tree differ visit synchronized
com.sun.tools.javac.comp.TreeDiffer#visitThrow(JCThrow)->void::: tree differ visit throw
com.sun.tools.javac.comp.TreeDiffer#visitTopLevel(JCCompilationUnit)->void::: tree differ visit top level
com.sun.tools.javac.comp.TreeDiffer#visitTry(JCTry)->void::: tree differ visit try
com.sun.tools.javac.comp.TreeDiffer#visitTypeApply(JCTypeApply)->void::: tree differ visit type apply
com.sun.tools.javac.comp.TreeDiffer#visitTypeArray(JCArrayTypeTree)->void::: tree differ visit type array
com.sun.tools.javac.comp.TreeDiffer#visitTypeBoundKind(TypeBoundKind)->void::: tree differ visit type bound kind
com.sun.tools.javac.comp.TreeDiffer#visitTypeCast(JCTypeCast)->void::: tree differ visit type cast
com.sun.tools.javac.comp.TreeDiffer#visitTypeIdent(JCPrimitiveTypeTree)->void::: tree differ visit type ident
com.sun.tools.javac.comp.TreeDiffer#visitTypeIntersection(JCTypeIntersection)->void::: tree differ visit type intersection
com.sun.tools.javac.comp.TreeDiffer#visitTypeParameter(JCTypeParameter)->void::: tree differ visit type parameter
com.sun.tools.javac.comp.TreeDiffer#visitTypeTest(JCInstanceOf)->void::: tree differ visit type test
com.sun.tools.javac.comp.TreeDiffer#visitTypeUnion(JCTypeUnion)->void::: tree differ visit type union
com.sun.tools.javac.comp.TreeDiffer#visitUnary(JCUnary)->void::: tree differ visit unary
com.sun.tools.javac.comp.TreeDiffer#visitUses(JCUses)->void::: tree differ visit uses
com.sun.tools.javac.comp.TreeDiffer#visitVarDef(JCVariableDecl)->void::: tree differ visit var def
com.sun.tools.javac.comp.TreeDiffer#visitWhileLoop(JCWhileLoop)->void::: tree differ visit while loop
com.sun.tools.javac.comp.TreeDiffer#visitWildcard(JCWildcard)->void::: tree differ visit wildcard
com.sun.tools.javac.comp.TreeHasher#hash(JCTree, Collection)->int::: tree hasher hash
com.sun.tools.javac.comp.TreeHasher#scan(JCTree)->void::: tree hasher scan
com.sun.tools.javac.comp.TreeHasher#visitLiteral(JCLiteral)->void::: tree hasher visit literal
com.sun.tools.javac.comp.TreeHasher#visitIdent(JCIdent)->void::: tree hasher visit ident
com.sun.tools.javac.comp.TreeHasher#visitSelect(JCFieldAccess)->void::: tree hasher visit select
com.sun.tools.javac.comp.TreeHasher#visitVarDef(JCVariableDecl)->void::: tree hasher visit var def
com.sun.tools.javac.comp.TypeEnter#instance(Context)->TypeEnter::: type enter instance
com.sun.tools.javac.comp.TypeEnter#ensureImportsChecked(List)->void::: type enter ensure imports checked
com.sun.tools.javac.comp.TypeEnter#complete(Symbol)->void:::Complete entering a class.
com.sun.tools.javac.comp.TypeEnter#finishImports(JCCompilationUnit, Runnable)->void::: type enter finish imports
com.sun.tools.javac.comp.TypeEnter.Phase#completeEnvs(List>)->List>::: phase complete envs
com.sun.tools.javac.comp.TypeEnter.Phase#doCompleteEnvs(List>)->void::: phase do complete envs
com.sun.tools.javac.comp.TypeEnter.Phase#runPhase(Env)->void::: phase run phase
com.sun.tools.javac.comp.TypeEnter#DefaultConstructor(TreeMaker, ClassSymbol, MethodSymbol, List, List, List, long, boolean)->JCTree:::Generate default constructor for given class
com.sun.tools.javac.comp.TypeEnter#SuperCall(TreeMaker, List, List, boolean)->JCExpressionStatement:::Generate call to superclass constructor
com.sun.tools.javac.comp.TypeEnter#markDeprecated(Symbol, List, Env)->void:::Mark sym deprecated if annotations contain @Deprecated annotation.
com.sun.tools.javac.comp.TypeEnvs#instance(Context)->TypeEnvs::: type envs instance
com.sun.tools.javac.comp.TypeEnvs#get(TypeSymbol)->Env::: type envs get
com.sun.tools.javac.comp.TypeEnvs#put(TypeSymbol, Env)->Env::: type envs put
com.sun.tools.javac.comp.TypeEnvs#remove(TypeSymbol)->Env::: type envs remove
com.sun.tools.javac.comp.TypeEnvs#values()->Collection>::: type envs values
com.sun.tools.javac.comp.TypeEnvs#clear()->void::: type envs clear
