com.sun.tools.javac.parser.DocCommentParser#parse()->DCDocComment::: doc comment parser parse
com.sun.tools.javac.parser.DocCommentParser#nextChar()->void::: doc comment parser next char
com.sun.tools.javac.parser.DocCommentParser#blockContent()->List::: doc comment parser block content
com.sun.tools.javac.parser.DocCommentParser#blockContent(Phase)->List:::Read block content, consisting of text, html and inline tags
com.sun.tools.javac.parser.DocCommentParser#blockTags()->List:::Read a series of block tags, including their content
com.sun.tools.javac.parser.DocCommentParser#blockTag()->DCTree:::Read a single block tag, including its content
com.sun.tools.javac.parser.DocCommentParser#inlineTag(ListBuffer)->void::: doc comment parser inline tag
com.sun.tools.javac.parser.DocCommentParser#inlineTag()->DCTree:::Read a single inline tag, including its content
com.sun.tools.javac.parser.DocCommentParser#reference(boolean)->DCReference::: doc comment parser reference
com.sun.tools.javac.parser.DocCommentParser#parseType(String)->JCTree::: doc comment parser parse type
com.sun.tools.javac.parser.DocCommentParser#parseMember(String)->Name::: doc comment parser parse member
com.sun.tools.javac.parser.DocCommentParser#parseParams(String)->List::: doc comment parser parse params
com.sun.tools.javac.parser.DocCommentParser#identifier()->DCIdentifier:::Read Java identifier Matching pairs of { } are skipped; the text is terminated by the first unmatched }
com.sun.tools.javac.parser.DocCommentParser#quotedString()->DCText:::Read a quoted string
com.sun.tools.javac.parser.DocCommentParser#inlineWord()->DCText:::Read a term ie
com.sun.tools.javac.parser.DocCommentParser#entity(ListBuffer)->void::: doc comment parser entity
com.sun.tools.javac.parser.DocCommentParser#entity()->DCTree:::Read an HTML entity
com.sun.tools.javac.parser.DocCommentParser#peek(String)->boolean::: doc comment parser peek
com.sun.tools.javac.parser.DocCommentParser#htmlAttrs()->List:::Read a series of HTML attributes, terminated by > 
com.sun.tools.javac.parser.DocCommentParser#attrValueChar(ListBuffer)->void::: doc comment parser attr value char
com.sun.tools.javac.parser.DocCommentParser#addPendingText(ListBuffer, int)->void::: doc comment parser add pending text
com.sun.tools.javac.parser.DocCommentParser#erroneous(String, int)->DCErroneous::: doc comment parser erroneous
com.sun.tools.javac.parser.DocCommentParser#isIdentifierStart(char)->boolean::: doc comment parser is identifier start
com.sun.tools.javac.parser.DocCommentParser#readIdentifier()->Name::: doc comment parser read identifier
com.sun.tools.javac.parser.DocCommentParser#readAttributeName()->Name::: doc comment parser read attribute name
com.sun.tools.javac.parser.DocCommentParser#readTagName()->Name::: doc comment parser read tag name
com.sun.tools.javac.parser.DocCommentParser#isJavaIdentifierStart(char)->boolean::: doc comment parser is java identifier start
com.sun.tools.javac.parser.DocCommentParser#readJavaIdentifier()->Name::: doc comment parser read java identifier
com.sun.tools.javac.parser.DocCommentParser#isDecimalDigit(char)->boolean::: doc comment parser is decimal digit
com.sun.tools.javac.parser.DocCommentParser#isHexDigit(char)->boolean::: doc comment parser is hex digit
com.sun.tools.javac.parser.DocCommentParser#isUnquotedAttrValueTerminator(char)->boolean::: doc comment parser is unquoted attr value terminator
com.sun.tools.javac.parser.DocCommentParser#isWhitespace(char)->boolean::: doc comment parser is whitespace
com.sun.tools.javac.parser.DocCommentParser#skipWhitespace()->void::: doc comment parser skip whitespace
com.sun.tools.javac.parser.DocCommentParser#newString(int, int)->String::: doc comment parser new string
com.sun.tools.javac.parser.DocCommentParser.TagParser#getKind()->Kind::: tag parser get kind
com.sun.tools.javac.parser.DocCommentParser.TagParser#getTreeKind()->DCTree.Kind::: tag parser get tree kind
com.sun.tools.javac.parser.DocCommentParser.TagParser#parse(int)->DCTree::: tag parser parse
com.sun.tools.javac.parser.JavacParser.ErrorRecoveryAction#doRecover(JavacParser)->JCTree::: error recovery action do recover
com.sun.tools.javac.parser.JavacParser#newEndPosTable(boolean)->AbstractEndPosTable::: javac parser new end pos table
com.sun.tools.javac.parser.JavacParser#newDocCommentTable(boolean, ParserFactory)->DocCommentTable::: javac parser new doc comment table
com.sun.tools.javac.parser.JavacParser#token()->Token::: javac parser token
com.sun.tools.javac.parser.JavacParser#nextToken()->void::: javac parser next token
com.sun.tools.javac.parser.JavacParser#peekToken(Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(int, Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(Filter, Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(int, Filter, Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(Filter, Filter, Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(int, Filter, Filter, Filter)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(Filter...)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#peekToken(int, Filter...)->boolean::: javac parser peek token
com.sun.tools.javac.parser.JavacParser#skip(boolean, boolean, boolean, boolean)->void:::Skip forward until a suitable stop token is found.
com.sun.tools.javac.parser.JavacParser#syntaxError(int, Error)->JCErroneous::: javac parser syntax error
com.sun.tools.javac.parser.JavacParser#syntaxError(int, List, Error)->JCErroneous::: javac parser syntax error
com.sun.tools.javac.parser.JavacParser#reportSyntaxError(int, Error)->void:::Report a syntax using the given the position parameter and arguments, unless one was already reported at the same position.
com.sun.tools.javac.parser.JavacParser#reportSyntaxError(JCDiagnostic.DiagnosticPosition, Error)->void:::Report a syntax error using the given DiagnosticPosition object and arguments, unless one was already reported at the same position.
com.sun.tools.javac.parser.JavacParser#accept(TokenKind)->void:::If next input token matches given token, skip it, otherwise report  an error.
com.sun.tools.javac.parser.JavacParser#illegal(int)->JCExpression:::Report an illegal start of expression/type error at given position.
com.sun.tools.javac.parser.JavacParser#illegal()->JCExpression:::Report an illegal start of expression/type error at current position.
com.sun.tools.javac.parser.JavacParser#checkNoMods(long)->void:::Diagnose a modifier flag from the set, if any.
com.sun.tools.javac.parser.JavacParser#attach(JCTree, Comment)->void:::Make an entry into docComments hashtable,  provided flag keepDocComments is set and given doc comment is non-null.
com.sun.tools.javac.parser.JavacParser#setErrorEndPos(int)->void::: javac parser set error end pos
com.sun.tools.javac.parser.JavacParser#storeEnd(JCTree, int)->void::: javac parser store end
com.sun.tools.javac.parser.JavacParser#to(T)->T::: javac parser to
com.sun.tools.javac.parser.JavacParser#toP(T)->T::: javac parser to p
com.sun.tools.javac.parser.JavacParser#getStartPos(JCTree)->int:::Get the start position for a tree node
com.sun.tools.javac.parser.JavacParser#getEndPos(JCTree)->int:::Get the end position for a tree node
com.sun.tools.javac.parser.JavacParser#ident()->Name:::Ident = IDENTIFIER
com.sun.tools.javac.parser.JavacParser#ident(boolean)->Name::: javac parser ident
com.sun.tools.javac.parser.JavacParser#qualident(boolean)->JCExpression:::Qualident = Ident { DOT [Annotations] Ident }
com.sun.tools.javac.parser.JavacParser#literal(Name)->JCExpression::: javac parser literal
com.sun.tools.javac.parser.JavacParser#literal(Name, int)->JCExpression:::Literal =     INTLITERAL   | LONGLITERAL   | FLOATLITERAL   | DOUBLELITERAL   | CHARLITERAL   | STRINGLITERAL   | TRUE   | FALSE   | NULL
com.sun.tools.javac.parser.JavacParser#isZero(String)->boolean::: javac parser is zero
com.sun.tools.javac.parser.JavacParser#strval(Name)->String::: javac parser strval
com.sun.tools.javac.parser.JavacParser#parseExpression()->JCExpression:::terms can be either expressions or types.
com.sun.tools.javac.parser.JavacParser#parseType()->JCExpression:::parses (optional) type annotations followed by a type
com.sun.tools.javac.parser.JavacParser#parseType(boolean)->JCExpression::: javac parser parse type
com.sun.tools.javac.parser.JavacParser#parseType(boolean, List)->JCExpression::: javac parser parse type
com.sun.tools.javac.parser.JavacParser#unannotatedType(boolean)->JCExpression::: javac parser unannotated type
com.sun.tools.javac.parser.JavacParser#term(int)->JCExpression::: javac parser term
com.sun.tools.javac.parser.JavacParser#term()->JCExpression::: Expression = Expression1 [ExpressionRest]  ExpressionRest = [AssignmentOperator Expression1]  AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" |                       "&=" | "|=" | "^=" |                       "%=" | "<<=" | ">>=" | ">>>="  Type = Type1  TypeNoParams = TypeNoParams1  StatementExpression = Expression  ConstantExpression = Expression  
com.sun.tools.javac.parser.JavacParser#termRest(JCExpression)->JCExpression::: javac parser term rest
com.sun.tools.javac.parser.JavacParser#term1()->JCExpression:::Expression1   = Expression2 [Expression1Rest]  Type1         = Type2  TypeNoParams1 = TypeNoParams2
com.sun.tools.javac.parser.JavacParser#term1Rest(JCExpression)->JCExpression:::Expression1Rest = ["?" Expression ":" Expression1]
com.sun.tools.javac.parser.JavacParser#term2()->JCExpression:::Expression2   = Expression3 [Expression2Rest]  Type2         = Type3  TypeNoParams2 = TypeNoParams3
com.sun.tools.javac.parser.JavacParser#term2Rest(JCExpression, int)->JCExpression::: javac parser term2 rest
com.sun.tools.javac.parser.JavacParser#foldStrings(JCExpression)->JCExpression:::If tree is a concatenation of string literals, replace it  by a single literal representing the concatenated string.
com.sun.tools.javac.parser.JavacParser#merge(ListBuffer, ListBuffer)->boolean::: javac parser merge
com.sun.tools.javac.parser.JavacParser#term3()->JCExpression::: Expression3    = PrefixOp Expression3                 | "(" Expr | TypeNoParams ")" Expression3                 | Primary {Selector} {PostfixOp}   Primary        = "(" Expression ")"                 | Literal                 | [TypeArguments] THIS [Arguments]                 | [TypeArguments] SUPER SuperSuffix                 | NEW [TypeArguments] Creator                 | "(" Arguments ")" "->" ( Expression | Block )                 | Ident "->" ( Expression | Block )                 | [Annotations] Ident { "." [Annotations] Ident                  | Expression3 MemberReferenceSuffix                   [ [Annotations] "[" ( "]" BracketsOpt "." CLASS | Expression "]" )                   | Arguments                   | "." ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )                   ]                 | BasicType BracketsOpt "." CLASS  }   PrefixOp       = "++" | "--" | "!" | "~" | "+" | "-"  PostfixOp      = "++" | "--"  Type3          = Ident { "." Ident } [TypeArguments] {TypeSelector} BracketsOpt                 | BasicType  TypeNoParams3  = Ident { "." Ident } BracketsOpt  Selector       = "." [TypeArguments] Ident [Arguments]                 | "." THIS                 | "." [TypeArguments] SUPER SuperSuffix                 | "." NEW [TypeArguments] InnerCreator                 | "[" Expression "]"  TypeSelector   = "." Ident [TypeArguments]  SuperSuffix    = Arguments | "." Ident [Arguments]
com.sun.tools.javac.parser.JavacParser#term3Rest(JCExpression, List)->JCExpression::: javac parser term3 rest
com.sun.tools.javac.parser.JavacParser#isUnboundMemberRef()->boolean:::If we see an identifier followed by a '&lt;' it could be an unbound method reference or a binary expression
com.sun.tools.javac.parser.JavacParser#analyzeParens()->ParensResult:::If we see an identifier followed by a '&lt;' it could be an unbound method reference or a binary expression
com.sun.tools.javac.parser.JavacParser#lambdaExpressionOrStatement(boolean, boolean, int)->JCExpression::: javac parser lambda expression or statement
com.sun.tools.javac.parser.JavacParser.LambdaClassifier#addParameter(JCVariableDecl)->void::: lambda classifier add parameter
com.sun.tools.javac.parser.JavacParser.LambdaClassifier#result()->LambdaParameterKind::: lambda classifier result
com.sun.tools.javac.parser.JavacParser#lambdaExpressionOrStatementRest(List, int)->JCExpression::: javac parser lambda expression or statement rest
com.sun.tools.javac.parser.JavacParser#lambdaStatement(List, int, int)->JCExpression::: javac parser lambda statement
com.sun.tools.javac.parser.JavacParser#lambdaExpression(List, int)->JCExpression::: javac parser lambda expression
com.sun.tools.javac.parser.JavacParser#superSuffix(List, JCExpression)->JCExpression:::SuperSuffix = Arguments | "." [TypeArguments] Ident [Arguments]
com.sun.tools.javac.parser.JavacParser#basicType()->JCPrimitiveTypeTree:::BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
com.sun.tools.javac.parser.JavacParser#argumentsOpt(List, JCExpression)->JCExpression:::ArgumentsOpt = [ Arguments ]
com.sun.tools.javac.parser.JavacParser#arguments()->List:::Arguments = "(" [Expression { COMMA Expression }] ")"
com.sun.tools.javac.parser.JavacParser#arguments(List, JCExpression)->JCMethodInvocation::: javac parser arguments
com.sun.tools.javac.parser.JavacParser#typeArgumentsOpt(JCExpression)->JCExpression::: TypeArgumentsOpt = [ TypeArguments ]
com.sun.tools.javac.parser.JavacParser#typeArgumentsOpt()->List::: javac parser type arguments opt
com.sun.tools.javac.parser.JavacParser#typeArgumentsOpt(int)->List::: javac parser type arguments opt
com.sun.tools.javac.parser.JavacParser#typeArguments(boolean)->List::: TypeArguments  = "<" TypeArgument {"," TypeArgument ">"  }
com.sun.tools.javac.parser.JavacParser#typeArgument()->JCExpression::: TypeArgument = Type               | [Annotations] "?"               | [Annotations] "?" EXTENDS Type {"&" Type               | [Annotations] "?" SUPER Type  }
com.sun.tools.javac.parser.JavacParser#typeArguments(JCExpression, boolean)->JCTypeApply::: javac parser type arguments
com.sun.tools.javac.parser.JavacParser#bracketsSuffix(JCExpression)->JCExpression:::BracketsSuffixExpr = "." CLASS  BracketsSuffixType =
com.sun.tools.javac.parser.JavacParser#memberReferenceSuffix(JCExpression)->JCExpression:::MemberReferenceSuffix = "::" [TypeArguments] Ident                       | "::" [TypeArguments] "new"
com.sun.tools.javac.parser.JavacParser#memberReferenceSuffix(int, JCExpression)->JCExpression::: javac parser member reference suffix
com.sun.tools.javac.parser.JavacParser#creator(int, List)->JCExpression:::Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
com.sun.tools.javac.parser.JavacParser#innerCreator(int, List, JCExpression)->JCExpression:::InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
com.sun.tools.javac.parser.JavacParser#arrayCreatorRest(int, JCExpression)->JCExpression:::ArrayCreatorRest = [Annotations] "[" ( "]" BracketsOpt ArrayInitializer                         | Expression "]" {[Annotations]  "[" Expression "]"} BracketsOpt )
com.sun.tools.javac.parser.JavacParser#classCreatorRest(int, JCExpression, List, JCExpression)->JCNewClass:::ClassCreatorRest = Arguments [ClassBody]
com.sun.tools.javac.parser.JavacParser#arrayInitializer(int, JCExpression)->JCExpression:::ArrayInitializer = "{" [VariableInitializer {"," VariableInitializer}] [","] "}"
com.sun.tools.javac.parser.JavacParser#arrayInitializerElements(int, JCExpression)->List::: javac parser array initializer elements
com.sun.tools.javac.parser.JavacParser#variableInitializer()->JCExpression:::VariableInitializer = ArrayInitializer | Expression
com.sun.tools.javac.parser.JavacParser#parExpression()->JCExpression:::ParExpression = "(" Expression ")"
com.sun.tools.javac.parser.JavacParser#block(int, long)->JCBlock:::Block = "{" BlockStatements "}"
com.sun.tools.javac.parser.JavacParser#block()->JCBlock::: javac parser block
com.sun.tools.javac.parser.JavacParser#blockStatements()->List:::BlockStatements = { BlockStatement }  BlockStatement  = LocalVariableDeclarationStatement                  | ClassOrInterfaceOrEnumDeclaration                  | [Ident ":"] Statement  LocalVariableDeclarationStatement                  = { FINAL | '@' Annotation } Type VariableDeclarators ";"
com.sun.tools.javac.parser.JavacParser#parseStatementAsBlock()->JCStatement::: javac parser parse statement as block
com.sun.tools.javac.parser.JavacParser#blockStatement()->List:::This method parses a statement appearing inside a block.
com.sun.tools.javac.parser.JavacParser#parseSimpleStatement()->JCStatement:::Statement =       Block     | IF ParExpression Statement [ELSE Statement]     | FOR "(" ForInitOpt ";" [Expression] ";" ForUpdateOpt ")" Statement     | FOR "(" FormalParameter : Expression ")" Statement     | WHILE ParExpression Statement     | DO Statement WHILE ParExpression ";"     | TRY Block ( Catches | [Catches] FinallyPart )     | TRY "(" ResourceSpecification ";"opt ")" Block [Catches] [FinallyPart]     | SWITCH ParExpression "{" SwitchBlockStatementGroups "}"     | SYNCHRONIZED ParExpression Block     | RETURN [Expression] ";"     | THROW Expression ";"     | BREAK [Ident] ";"     | CONTINUE [Ident] ";"     | ASSERT Expression [ ":" Expression ] ";"     | ";"
com.sun.tools.javac.parser.JavacParser#parseStatement()->JCStatement::: javac parser parse statement
com.sun.tools.javac.parser.JavacParser#catchClause()->JCCatch:::CatchClause     = CATCH "(" FormalParameter ")" Block TODO: the "FormalParameter" is not correct, it uses the special "catchTypes" rule below.
com.sun.tools.javac.parser.JavacParser#catchTypes()->List::: javac parser catch types
com.sun.tools.javac.parser.JavacParser#switchBlockStatementGroups()->List:::SwitchBlockStatementGroups = { SwitchBlockStatementGroup }  SwitchBlockStatementGroup = SwitchLabel BlockStatements  SwitchLabel = CASE ConstantExpression ":" | DEFAULT ":"
com.sun.tools.javac.parser.JavacParser#switchBlockStatementGroup()->JCCase::: javac parser switch block statement group
com.sun.tools.javac.parser.JavacParser#moreStatementExpressions(int, JCExpression, T)->T:::MoreStatementExpressions = { COMMA StatementExpression }
com.sun.tools.javac.parser.JavacParser#forInit()->List:::ForInit = StatementExpression MoreStatementExpressions           |  { FINAL | '@' Annotation } Type VariableDeclarators
com.sun.tools.javac.parser.JavacParser#forUpdate()->List:::ForUpdate = StatementExpression MoreStatementExpressions
com.sun.tools.javac.parser.JavacParser#annotationsOpt(Tag)->List:::AnnotationsOpt = { '@' Annotation }
com.sun.tools.javac.parser.JavacParser#typeAnnotationsOpt()->List::: javac parser type annotations opt
com.sun.tools.javac.parser.JavacParser#modifiersOpt()->JCModifiers:::ModifiersOpt = { Modifier }  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | "@"           | "@" Annotation
com.sun.tools.javac.parser.JavacParser#modifiersOpt(JCModifiers)->JCModifiers::: javac parser modifiers opt
com.sun.tools.javac.parser.JavacParser#annotation(int, Tag)->JCAnnotation:::Annotation              = "@" Qualident [ "(" AnnotationFieldValues ")" ]
com.sun.tools.javac.parser.JavacParser#annotationFieldValuesOpt()->List::: javac parser annotation field values opt
com.sun.tools.javac.parser.JavacParser#annotationFieldValues()->List:::AnnotationFieldValues   = "(" [ AnnotationFieldValue { "," AnnotationFieldValue } ] ")"
com.sun.tools.javac.parser.JavacParser#annotationFieldValue()->JCExpression:::AnnotationFieldValue    = AnnotationValue                          | Identifier "=" AnnotationValue
com.sun.tools.javac.parser.JavacParser#annotationValue()->JCExpression::: javac parser annotation value
com.sun.tools.javac.parser.JavacParser#variableDeclarators(JCModifiers, JCExpression, T, boolean)->T:::VariableDeclarators = VariableDeclarator { "," VariableDeclarator }
com.sun.tools.javac.parser.JavacParser#variableDeclaratorsRest(int, JCModifiers, JCExpression, Name, boolean, Comment, T, boolean)->T:::VariableDeclaratorsRest = VariableDeclaratorRest { "," VariableDeclarator }  ConstantDeclaratorsRest = ConstantDeclaratorRest { "," ConstantDeclarator }
com.sun.tools.javac.parser.JavacParser#variableDeclarator(JCModifiers, JCExpression, boolean, Comment, boolean)->JCVariableDecl:::VariableDeclarator = Ident VariableDeclaratorRest  ConstantDeclarator = Ident ConstantDeclaratorRest
com.sun.tools.javac.parser.JavacParser#variableDeclaratorRest(int, JCModifiers, JCExpression, Name, boolean, Comment, boolean, boolean)->JCVariableDecl:::VariableDeclaratorRest = BracketsOpt ["=" VariableInitializer]  ConstantDeclaratorRest = BracketsOpt "=" VariableInitializer
com.sun.tools.javac.parser.JavacParser#isRestrictedLocalVarTypeName(JCExpression, boolean)->boolean::: javac parser is restricted local var type name
com.sun.tools.javac.parser.JavacParser#isRestrictedLocalVarTypeName(Name, int, boolean)->boolean::: javac parser is restricted local var type name
com.sun.tools.javac.parser.JavacParser#variableDeclaratorId(JCModifiers, JCExpression)->JCVariableDecl:::VariableDeclaratorId = Ident BracketsOpt
com.sun.tools.javac.parser.JavacParser#variableDeclaratorId(JCModifiers, JCExpression, boolean)->JCVariableDecl::: javac parser variable declarator id
com.sun.tools.javac.parser.JavacParser#resources()->List:::Resources = Resource { ";" Resources }
com.sun.tools.javac.parser.JavacParser#resource()->JCTree:::Resource = VariableModifiersOpt Type VariableDeclaratorId "=" Expression           | Expression
com.sun.tools.javac.parser.JavacParser#parseCompilationUnit()->JCTree.JCCompilationUnit:::CompilationUnit = [ { "@" Annotation } PACKAGE Qualident ";"] {ImportDeclaration} {TypeDeclaration}
com.sun.tools.javac.parser.JavacParser#moduleDecl(JCModifiers, ModuleKind, Comment)->JCModuleDecl::: javac parser module decl
com.sun.tools.javac.parser.JavacParser#moduleDirectiveList()->List::: javac parser module directive list
com.sun.tools.javac.parser.JavacParser#importDeclaration()->JCTree:::ImportDeclaration = IMPORT [ STATIC ] Ident { "." Ident } [ "." "*" ] ";"
com.sun.tools.javac.parser.JavacParser#typeDeclaration(JCModifiers, Comment)->JCTree:::TypeDeclaration = ClassOrInterfaceOrEnumDeclaration                  | ";"
com.sun.tools.javac.parser.JavacParser#classOrInterfaceOrEnumDeclaration(JCModifiers, Comment)->JCStatement:::ClassOrInterfaceOrEnumDeclaration = ModifiersOpt           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
com.sun.tools.javac.parser.JavacParser#classDeclaration(JCModifiers, Comment)->JCClassDecl:::ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]                     [IMPLEMENTS TypeList] ClassBody
com.sun.tools.javac.parser.JavacParser#typeName()->Name::: javac parser type name
com.sun.tools.javac.parser.JavacParser#interfaceDeclaration(JCModifiers, Comment)->JCClassDecl:::InterfaceDeclaration = INTERFACE Ident TypeParametersOpt                         [EXTENDS TypeList] InterfaceBody
com.sun.tools.javac.parser.JavacParser#enumDeclaration(JCModifiers, Comment)->JCClassDecl:::EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
com.sun.tools.javac.parser.JavacParser#enumBody(Name)->List:::EnumBody = "{" { EnumeratorDeclarationList } [","]                  [ ";" {ClassBodyDeclaration} ] "}"
com.sun.tools.javac.parser.JavacParser#enumeratorDeclaration(Name)->JCTree:::EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ "{" ClassBody "}" ]
com.sun.tools.javac.parser.JavacParser#typeList()->List:::TypeList = Type {"," Type}
com.sun.tools.javac.parser.JavacParser#classOrInterfaceBody(Name, boolean)->List:::ClassBody     = "{" {ClassBodyDeclaration} "}"  InterfaceBody = "{" {InterfaceBodyDeclaration} "}"
com.sun.tools.javac.parser.JavacParser#classOrInterfaceBodyDeclaration(Name, boolean)->List:::ClassBodyDeclaration =      ";"    | [STATIC] Block    | ModifiersOpt      ( Type Ident        ( VariableDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident VoidMethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | Ident ConstructorDeclaratorRest      | TypeParameters Ident ConstructorDeclaratorRest      | ClassOrInterfaceOrEnumDeclaration      )  InterfaceBodyDeclaration =      ";"    | ModifiersOpt      ( Type Ident        ( ConstantDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident MethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | ClassOrInterfaceOrEnumDeclaration      )
com.sun.tools.javac.parser.JavacParser#methodDeclaratorRest(int, JCModifiers, JCExpression, Name, List, boolean, boolean, Comment)->JCTree:::MethodDeclaratorRest =      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] ";")  VoidMethodDeclaratorRest =      FormalParameters [THROWS TypeList] ( MethodBody | ";")  ConstructorDeclaratorRest =      "(" FormalParameterListOpt ")" [THROWS TypeList] MethodBody
com.sun.tools.javac.parser.JavacParser#qualidentList(boolean)->List:::QualidentList = [Annotations] Qualident {"," [Annotations] Qualident}
com.sun.tools.javac.parser.JavacParser#typeParametersOpt()->List::: TypeParametersOpt = ["<" TypeParameter {"," TypeParameter ">"]  }
com.sun.tools.javac.parser.JavacParser#typeParameter()->JCTypeParameter::: TypeParameter = [Annotations] TypeVariable [TypeParameterBound]  TypeParameterBound = EXTENDS Type {"&" Type  TypeVariable = Ident  }
com.sun.tools.javac.parser.JavacParser#formalParameters()->List:::FormalParameters = "(" [ FormalParameterList ] ")"  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
com.sun.tools.javac.parser.JavacParser#formalParameters(boolean)->List::: javac parser formal parameters
com.sun.tools.javac.parser.JavacParser#implicitParameters(boolean)->List::: javac parser implicit parameters
com.sun.tools.javac.parser.JavacParser#optFinal(long)->JCModifiers::: javac parser opt final
com.sun.tools.javac.parser.JavacParser#formalParameter()->JCVariableDecl:::FormalParameter = { FINAL | '@' Annotation } Type VariableDeclaratorId  LastFormalParameter = { FINAL | '@' Annotation } Type '...' Ident | FormalParameter
com.sun.tools.javac.parser.JavacParser#formalParameter(boolean)->JCVariableDecl::: javac parser formal parameter
com.sun.tools.javac.parser.JavacParser#implicitParameter()->JCVariableDecl::: javac parser implicit parameter
com.sun.tools.javac.parser.JavacParser#checkExprStat(JCExpression)->JCExpression:::Check that given tree is a legal expression statement.
com.sun.tools.javac.parser.JavacParser#prec(TokenKind)->int:::Return precedence of operator represented by token,  -1 if token is not a binary operator
com.sun.tools.javac.parser.JavacParser#earlier(int, int)->int:::Return the lesser of two positions, making allowance for either one being unset.
com.sun.tools.javac.parser.JavacParser#optag(TokenKind)->JCTree.Tag:::Return operation tag of binary operator represented by token,  No_TAG if token is not a binary operator.
com.sun.tools.javac.parser.JavacParser#unoptag(TokenKind)->JCTree.Tag:::Return operation tag of unary operator represented by token,  No_TAG if token is not a binary operator.
com.sun.tools.javac.parser.JavacParser#typetag(TokenKind)->TypeTag:::Return type tag of basic type represented by token,  NONE if token is not a basic type identifier.
com.sun.tools.javac.parser.JavacParser#checkSourceLevel(Feature)->void::: javac parser check source level
com.sun.tools.javac.parser.JavacParser#checkSourceLevel(int, Feature)->void::: javac parser check source level
com.sun.tools.javac.parser.JavacParser.SimpleEndPosTable#storeEnd(JCTree, int)->void::: simple end pos table store end
com.sun.tools.javac.parser.JavacParser.SimpleEndPosTable#to(T)->T::: simple end pos table to
com.sun.tools.javac.parser.JavacParser.SimpleEndPosTable#toP(T)->T::: simple end pos table to p
com.sun.tools.javac.parser.JavacParser.SimpleEndPosTable#getEndPos(JCTree)->int::: simple end pos table get end pos
com.sun.tools.javac.parser.JavacParser.SimpleEndPosTable#replaceTree(JCTree, JCTree)->int::: simple end pos table replace tree
com.sun.tools.javac.parser.JavacParser.EmptyEndPosTable#storeEnd(JCTree, int)->void::: empty end pos table store end
com.sun.tools.javac.parser.JavacParser.EmptyEndPosTable#to(T)->T::: empty end pos table to
com.sun.tools.javac.parser.JavacParser.EmptyEndPosTable#toP(T)->T::: empty end pos table to p
com.sun.tools.javac.parser.JavacParser.EmptyEndPosTable#getEndPos(JCTree)->int::: empty end pos table get end pos
com.sun.tools.javac.parser.JavacParser.EmptyEndPosTable#replaceTree(JCTree, JCTree)->int::: empty end pos table replace tree
com.sun.tools.javac.parser.JavacParser.AbstractEndPosTable#to(T)->T:::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the current token.
com.sun.tools.javac.parser.JavacParser.AbstractEndPosTable#toP(T)->T:::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the previous token.
com.sun.tools.javac.parser.JavacParser.AbstractEndPosTable#setErrorEndPos(int)->void:::Set the error position during the parsing phases, the value of which will be set only if it is greater than the last stored error position.
com.sun.tools.javac.parser.JavacParser.AbstractEndPosTable#setParser(JavacParser)->void::: abstract end pos table set parser
com.sun.tools.javac.parser.JavadocTokenizer#processComment(int, int, CommentStyle)->Comment::: javadoc tokenizer process comment
com.sun.tools.javac.parser.JavadocTokenizer.DocReader#convertUnicode()->void::: doc reader convert unicode
com.sun.tools.javac.parser.JavadocTokenizer.DocReader#scanCommentChar()->void::: doc reader scan comment char
com.sun.tools.javac.parser.JavadocTokenizer.DocReader#scanChar()->void::: doc reader scan char
com.sun.tools.javac.parser.JavadocTokenizer.DocReader#putChar(char, boolean)->void::: doc reader put char
com.sun.tools.javac.parser.JavadocTokenizer.DocReader#isDoubleBackslash()->boolean:::Whether the ch represents a sequence of two backslashes.
com.sun.tools.javac.parser.JavadocTokenizer.JavadocComment#getText()->String::: javadoc comment get text
com.sun.tools.javac.parser.JavadocTokenizer.JavadocComment#getSourcePos(int)->int::: javadoc comment get source pos
com.sun.tools.javac.parser.JavadocTokenizer.JavadocComment#scanDocComment()->void::: javadoc comment scan doc comment
com.sun.tools.javac.parser.JavadocTokenizer#getLineMap()->Position.LineMap::: javadoc tokenizer get line map
com.sun.tools.javac.parser.JavaTokenizer#checkSourceLevel(int, Feature)->void::: java tokenizer check source level
com.sun.tools.javac.parser.JavaTokenizer#lexError(int, JCDiagnostic.Error)->void:::Report an error at the given position using the provided arguments.
com.sun.tools.javac.parser.JavaTokenizer#lexError(DiagnosticFlag, int, JCDiagnostic.Error)->void::: java tokenizer lex error
com.sun.tools.javac.parser.JavaTokenizer#readToken()->Token:::Read token.
com.sun.tools.javac.parser.JavaTokenizer#addComment(List, Comment)->List::: java tokenizer add comment
com.sun.tools.javac.parser.JavaTokenizer#errPos()->int:::Return the position where a lexical error occurred;
com.sun.tools.javac.parser.JavaTokenizer#errPos(int)->void:::Set the position where a lexical error occurred;
com.sun.tools.javac.parser.JavaTokenizer#processComment(int, int, CommentStyle)->Tokens.Comment:::Called when a complete comment has been scanned
com.sun.tools.javac.parser.JavaTokenizer#processWhiteSpace(int, int)->void:::Called when a complete whitespace run has been scanned
com.sun.tools.javac.parser.JavaTokenizer#processLineTerminator(int, int)->void:::Called when a line terminator has been processed.
com.sun.tools.javac.parser.JavaTokenizer#getLineMap()->Position.LineMap:::Build a map for translating between line numbers and positions in the input.
com.sun.tools.javac.parser.JavaTokenizer.BasicComment#getText()->String::: basic comment get text
com.sun.tools.javac.parser.JavaTokenizer.BasicComment#getSourcePos(int)->int::: basic comment get source pos
com.sun.tools.javac.parser.JavaTokenizer.BasicComment#getStyle()->CommentStyle::: basic comment get style
com.sun.tools.javac.parser.JavaTokenizer.BasicComment#isDeprecated()->boolean::: basic comment is deprecated
com.sun.tools.javac.parser.JavaTokenizer.BasicComment#scanDocComment()->void::: basic comment scan doc comment
com.sun.tools.javac.parser.LazyDocCommentTable#hasComment(JCTree)->boolean::: lazy doc comment table has comment
com.sun.tools.javac.parser.LazyDocCommentTable#getComment(JCTree)->Comment::: lazy doc comment table get comment
com.sun.tools.javac.parser.LazyDocCommentTable#getCommentText(JCTree)->String::: lazy doc comment table get comment text
com.sun.tools.javac.parser.LazyDocCommentTable#getCommentTree(JCTree)->DCDocComment::: lazy doc comment table get comment tree
com.sun.tools.javac.parser.LazyDocCommentTable#putComment(JCTree, Comment)->void::: lazy doc comment table put comment
com.sun.tools.javac.parser.Lexer#nextToken()->void:::Consume the next token.
com.sun.tools.javac.parser.Lexer#token()->Token:::Return current token.
com.sun.tools.javac.parser.Lexer#token(int)->Token:::Return token with given lookahead.
com.sun.tools.javac.parser.Lexer#prevToken()->Token:::Return the last character position of the previous token.
com.sun.tools.javac.parser.Lexer#split()->Token:::Splits the current token in two and return the first (splitted) token
com.sun.tools.javac.parser.Lexer#errPos()->int:::Return the position where a lexical error occurred;
com.sun.tools.javac.parser.Lexer#errPos(int)->void:::Set the position where a lexical error occurred;
com.sun.tools.javac.parser.Lexer#getLineMap()->LineMap:::Build a map for translating between line numbers and positions in the input.
com.sun.tools.javac.parser.Parser#parseCompilationUnit()->JCCompilationUnit:::Parse a compilation unit.
com.sun.tools.javac.parser.Parser#parseExpression()->JCExpression:::Parse an expression.
com.sun.tools.javac.parser.Parser#parseStatement()->JCStatement:::Parse a statement.
com.sun.tools.javac.parser.Parser#parseType()->JCExpression:::Parse a type.
com.sun.tools.javac.parser.ParserFactory#instance(Context)->ParserFactory::: parser factory instance
com.sun.tools.javac.parser.ParserFactory#newParser(CharSequence, boolean, boolean, boolean)->JavacParser::: parser factory new parser
com.sun.tools.javac.parser.ParserFactory#newParser(CharSequence, boolean, boolean, boolean, boolean)->JavacParser::: parser factory new parser
com.sun.tools.javac.parser.ReferenceParser#parse(String)->Reference:::Parse a reference to an API element as may be found in doc comment.
com.sun.tools.javac.parser.Scanner#token()->Token::: scanner token
com.sun.tools.javac.parser.Scanner#token(int)->Token::: scanner token
com.sun.tools.javac.parser.Scanner#prevToken()->Token::: scanner prev token
com.sun.tools.javac.parser.Scanner#nextToken()->void::: scanner next token
com.sun.tools.javac.parser.Scanner#split()->Token::: scanner split
com.sun.tools.javac.parser.Scanner#getLineMap()->LineMap::: scanner get line map
com.sun.tools.javac.parser.Scanner#errPos()->int::: scanner err pos
com.sun.tools.javac.parser.Scanner#errPos(int)->void::: scanner err pos
com.sun.tools.javac.parser.ScannerFactory#instance(Context)->ScannerFactory:::Get the Factory instance for this context.
com.sun.tools.javac.parser.ScannerFactory#newScanner(CharSequence, boolean)->Scanner::: scanner factory new scanner
com.sun.tools.javac.parser.ScannerFactory#newScanner(char[], int, boolean)->Scanner::: scanner factory new scanner
com.sun.tools.javac.parser.Tokens#instance(Context)->Tokens::: tokens instance
com.sun.tools.javac.parser.Tokens#lookupKind(Name)->TokenKind:::Create a new token given a name; if the name corresponds to a token name, a new token of the corresponding kind is returned; otherwise, an identifier token is returned.
com.sun.tools.javac.parser.Tokens#lookupKind(String)->TokenKind::: tokens lookup kind
com.sun.tools.javac.parser.Tokens.Comment#getText()->String::: comment get text
com.sun.tools.javac.parser.Tokens.Comment#getSourcePos(int)->int::: comment get source pos
com.sun.tools.javac.parser.Tokens.Comment#getStyle()->CommentStyle::: comment get style
com.sun.tools.javac.parser.Tokens.Comment#isDeprecated()->boolean::: comment is deprecated
com.sun.tools.javac.parser.Tokens.Token#split(Tokens)->Token[]::: token split
com.sun.tools.javac.parser.Tokens.Token#checkKind()->void::: token check kind
com.sun.tools.javac.parser.Tokens.Token#name()->Name::: token name
com.sun.tools.javac.parser.Tokens.Token#stringVal()->String::: token string val
com.sun.tools.javac.parser.Tokens.Token#radix()->int::: token radix
com.sun.tools.javac.parser.Tokens.Token#comment(Comment.CommentStyle)->Comment:::Preserve classic semantics - if multiple javadocs are found on the token the last one is returned
com.sun.tools.javac.parser.Tokens.Token#deprecatedFlag()->boolean:::Preserve classic semantics - deprecated should be set if at least one javadoc comment attached to this token contains the '@deprecated' string
com.sun.tools.javac.parser.Tokens.NamedToken#checkKind()->void::: named token check kind
com.sun.tools.javac.parser.Tokens.NamedToken#name()->Name::: named token name
com.sun.tools.javac.parser.Tokens.StringToken#checkKind()->void::: string token check kind
com.sun.tools.javac.parser.Tokens.StringToken#stringVal()->String::: string token string val
com.sun.tools.javac.parser.Tokens.NumericToken#checkKind()->void::: numeric token check kind
com.sun.tools.javac.parser.Tokens.NumericToken#radix()->int::: numeric token radix
com.sun.tools.javac.parser.UnicodeReader#scanChar()->void:::Read next character.
com.sun.tools.javac.parser.UnicodeReader#scanCommentChar()->void:::Read next character in comment, skipping over double '\' characters.
com.sun.tools.javac.parser.UnicodeReader#putChar(char, boolean)->void:::Append a character to sbuf.
com.sun.tools.javac.parser.UnicodeReader#putChar(char)->void::: unicode reader put char
com.sun.tools.javac.parser.UnicodeReader#putChar(boolean)->void::: unicode reader put char
com.sun.tools.javac.parser.UnicodeReader#name()->Name::: unicode reader name
com.sun.tools.javac.parser.UnicodeReader#chars()->String::: unicode reader chars
com.sun.tools.javac.parser.UnicodeReader#convertUnicode()->void:::Convert unicode escape; bp points to initial '\' character  (Spec 3.3).
com.sun.tools.javac.parser.UnicodeReader#peekSurrogates()->int:::Scan surrogate pairs
com.sun.tools.javac.parser.UnicodeReader#digit(int, int)->int:::Convert an ASCII digit from its base (8, 10, or 16)  to its value.
com.sun.tools.javac.parser.UnicodeReader#isUnicode()->boolean::: unicode reader is unicode
com.sun.tools.javac.parser.UnicodeReader#skipChar()->void::: unicode reader skip char
com.sun.tools.javac.parser.UnicodeReader#peekChar()->char::: unicode reader peek char
com.sun.tools.javac.parser.UnicodeReader#getRawCharacters()->char[]:::Returns a copy of the input buffer, up to its inputLength
com.sun.tools.javac.parser.UnicodeReader#getRawCharacters(int, int)->char[]:::Returns a copy of a character array subset of the input buffer
