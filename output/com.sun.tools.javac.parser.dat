DocCommentParser#parse()::: doc comment parser parse:::c->comment->getText->c->length->new->charArr->c->c->length->getChars->nextChar->preamble->blockContent->List->nil->body->blockContent->tags->blockTags->postamble->blockContent->List->nil->pos->if->preamble->isEmpty->else->if->body->isEmpty->else->if->tags->isEmpty->else->if->postamble->isEmpty->dc->m->at->newDocCommentTree->return
DocCommentParser#nextChar()::: doc comment parser next char:::switch
DocCommentParser#blockContent()::: doc comment parser block content:::return->blockContent
DocCommentParser#blockContent(Phase):::Read block content, consisting of text, html and inline tags:::trees->new->ListBuffer<>->while->switch->nextChar->break->entity->break->if->switch->if->peek->trees->html->add->if->break->break->if->peek->addPendingText->break->break->addPendingText->trees->html->add->if->break->if->break->addPendingText->trees->m->at->newString->newErroneousTree->add->nextChar->if->break->inlineTag->break->if->addPendingText->break->if->nextChar->if->addPendingText->return->trees->toList
DocCommentParser#blockTags():::Read a series of block tags, including their content:::tags->new->ListBuffer<>->while->tags->blockTag->add->return->tags->toList
DocCommentParser#blockTag():::Read a single block tag, including its content:::p->try->nextChar->if->isIdentifierStart->name->readTagName->tp->tagParsers->get->if->content->blockContent->return->m->at->newUnknownBlockTagTree->else->switch->tp->getKind->return->tp->parse->return->erroneous->blockContent->return->erroneous->catch->blockContent->return->e->getMessage->erroneous->finally
DocCommentParser#inlineTag(ListBuffer)::: doc comment parser inline tag:::nextChar->if->addPendingText->list->inlineTag->add->else->if
DocCommentParser#inlineTag():::Read a single inline tag, including its content:::p->try->nextChar->if->isIdentifierStart->name->readTagName->tp->tagParsers->get->if->skipWhitespace->text->inlineText->if->nextChar->return->m->at->List->of->newUnknownInlineTagTree->setEndPos->else->if->skipWhitespace->if->tp->getKind->tree->tp->parse->if->return->tree->setEndPos->else->inlineText->nextChar->return->erroneous->catch->return->e->getMessage->erroneous->finally
DocCommentParser#inlineText(WhitespaceRetentionPolicy):::Read plain text content of an inline tag:::switch->skipWhitespace->break->if->nextChar->break->break->pos->depth->while->switch->break->break->break->if->return->m->at->newString->newTextTree->break->if->break->break->break->nextChar->throw->new->ParseException
DocCommentParser#reference(boolean)::: doc comment parser reference:::pos->depth->while->switch->if->break->break->break->break->if->return->break->if->break->nextChar->if->throw->new->ParseException->sig->newString->qualExpr->member->paramTypes->deferredDiagnosticHandler->new->Log.DeferredDiagnosticHandler->try->hash->sig->indexOf->lparen->sig->indexOf->if->if->parseType->else->sig->substring->parseMember->else->sig->substring->parseType->if->sig->substring->parseMember->else->sig->substring->parseMember->if->else->rparen->sig->indexOf->if->sig->length->throw->new->ParseException->sig->substring->parseParams->if->deferredDiagnosticHandler->getDiagnostics->isEmpty->throw->new->ParseException->catch->finally->popDiagnosticHandler->return->m->at->newReferenceTree->setEndPos
DocCommentParser#parseType(String)::: doc comment parser parse type:::p->fac->newParser->tree->p->parseType->if->p->token->throw->new->ParseException->return
DocCommentParser#parseMember(String)::: doc comment parser parse member:::p->fac->newParser->name->p->ident->if->p->token->throw->new->ParseException->return
DocCommentParser#parseParams(String)::: doc comment parser parse params:::if->s->trim->isEmpty->return->List->nil->p->fac->s->replace->newParser->paramTypes->new->ListBuffer<>->paramTypes->p->parseType->add->if->p->token->p->nextToken->while->p->token->p->nextToken->paramTypes->p->parseType->add->if->p->token->p->nextToken->if->p->token->throw->new->ParseException->return->paramTypes->toList
DocCommentParser#identifier():::Read Java identifier Matching pairs of { } are skipped; the text is terminated by the first unmatched }:::skipWhitespace->pos->if->isJavaIdentifierStart->name->readJavaIdentifier->return->m->at->newIdentifierTree->throw->new->ParseException
DocCommentParser#quotedString():::Read a quoted string:::pos->nextChar->while->switch->break->break->nextChar->return->m->at->newString->newTextTree->if->break->nextChar->return
DocCommentParser#inlineWord():::Read a term ie:::pos->depth->while->switch->return->m->at->newString->newTextTree->if->break->break->if->return->m->at->newString->newTextTree->break->nextChar->return
DocCommentParser#inlineContent():::Read general text content of an inline tag, including HTML entities and elements:::trees->new->ListBuffer<>->skipWhitespace->pos->depth->while->switch->nextChar->break->entity->break->addPendingText->trees->html->add->break->if->nextChar->break->if->addPendingText->nextChar->return->trees->toList->nextChar->break->if->break->if->nextChar->break->return->List->erroneous->of
DocCommentParser#entity(ListBuffer)::: doc comment parser entity:::addPendingText->list->entity->add->if
DocCommentParser#entity():::Read an HTML entity:::p->nextChar->name->if->namep->nextChar->if->isDecimalDigit->nextChar->while->isDecimalDigit->nextChar->names->fromChars->else->if->nextChar->if->isHexDigit->nextChar->while->isHexDigit->nextChar->names->fromChars->else->if->isIdentifierStart->readIdentifier->if->return->erroneous->else->if->return->erroneous->nextChar->return->m->at->newEntityTree
DocCommentParser#peek(String)::: doc comment parser peek:::savedpos->try->if->nextChar->if->if->s->charAt->return->else->s->s->length->substring->nextChar->if->isIdentifierStart->name->readIdentifier->return->StringUtils->name->toString->toLowerCase->equals->return->catch->finally
DocCommentParser#html():::Read the start or end of an HTML tag, or an HTML comment <identifier attrs>  or </identifier> :::p->nextChar->if->isIdentifierStart->name->readIdentifier->attrs->htmlAttrs->if->selfClosing->if->nextChar->if->nextChar->dctree->m->at->newStartElementTree->setEndPos->return->else->if->nextChar->if->isIdentifierStart->name->readIdentifier->skipWhitespace->if->nextChar->return->m->at->newEndElementTree->else->if->nextChar->if->nextChar->if->nextChar->while->dash->while->nextChar->if->nextChar->return->m->at->newString->newCommentTree->nextChar->else->if->isIdentifierStart->peek->readIdentifier->nextChar->skipWhitespace->d->while->if->mark->nextChar->return->m->at->newString->newDocTypeTree->nextChar->return->erroneous
DocCommentParser#htmlAttrs():::Read a series of HTML attributes, terminated by > :::attrs->new->ListBuffer<>->skipWhitespace->while->isIdentifierStart->namePos->name->readAttributeName->skipWhitespace->value->vkind->if->v->new->ListBuffer<>->nextChar->skipWhitespace->if->quote->nextChar->while->if->attrs->erroneous->add->break->attrValueChar->addPendingText->nextChar->else->while->isUnquotedAttrValueTerminator->attrValueChar->addPendingText->skipWhitespace->v->toList->attr->m->at->newAttributeTree->attrs->add->return->attrs->toList
DocCommentParser#attrValueChar(ListBuffer)::: doc comment parser attr value char:::switch->entity->break->inlineTag->break->nextChar
DocCommentParser#addPendingText(ListBuffer, int)::: doc comment parser add pending text:::if->if->list->m->at->newString->newTextTree->add
DocCommentParser#erroneous(String, int)::: doc comment parser erroneous:::i->while->switch->break->break->break->return->m->at->newString->newErroneousTree
DocCommentParser#isIdentifierStart(char)::: doc comment parser is identifier start:::return->Character->isUnicodeIdentifierStart
DocCommentParser#readIdentifier()::: doc comment parser read identifier:::start->nextChar->while->Character->isUnicodeIdentifierPart->nextChar->return->names->fromChars
DocCommentParser#readAttributeName()::: doc comment parser read attribute name:::start->nextChar->while->Character->isUnicodeIdentifierPart->nextChar->return->names->fromChars
DocCommentParser#readTagName()::: doc comment parser read tag name:::start->nextChar->while->Character->isUnicodeIdentifierPart->nextChar->return->names->fromChars
DocCommentParser#isJavaIdentifierStart(char)::: doc comment parser is java identifier start:::return->Character->isJavaIdentifierStart
DocCommentParser#readJavaIdentifier()::: doc comment parser read java identifier:::start->nextChar->while->Character->isJavaIdentifierPart->nextChar->return->names->fromChars
DocCommentParser#isDecimalDigit(char)::: doc comment parser is decimal digit:::return
DocCommentParser#isHexDigit(char)::: doc comment parser is hex digit:::return
DocCommentParser#isUnquotedAttrValueTerminator(char)::: doc comment parser is unquoted attr value terminator:::switch->return->return
DocCommentParser#isWhitespace(char)::: doc comment parser is whitespace:::return->Character->isWhitespace
DocCommentParser#skipWhitespace()::: doc comment parser skip whitespace:::while->isWhitespace->nextChar
DocCommentParser#newString(int, int)::: doc comment parser new string:::return->new->String
DocCommentParser.TagParser#getKind()::: tag parser get kind:::return
DocCommentParser.TagParser#getTreeKind()::: tag parser get tree kind:::return
DocCommentParser.TagParser#parse(int)::: tag parser parse:::
DocCommentParser#initTagParsers()::: doc comment parser init tag parsers:::parsers->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->TagParser->new->HashMap<>->foreach->tagParsers->names->p->getTreeKind->fromString->put
JavacParser.ErrorRecoveryAction#doRecover(JavacParser)::: error recovery action do recover:::
JavacParser#newEndPosTable(boolean)::: javac parser new end pos table:::return->new->SimpleEndPosTable->new->EmptyEndPosTable
JavacParser#newDocCommentTable(boolean, ParserFactory)::: javac parser new doc comment table:::return->new->LazyDocCommentTable
JavacParser#token()::: javac parser token:::return
JavacParser#nextToken()::: javac parser next token:::S->nextToken->S->token
JavacParser#peekToken(Filter)::: javac parser peek token:::return->peekToken
JavacParser#peekToken(int, Filter)::: javac parser peek token:::return->tk->S->token->accepts
JavacParser#peekToken(Filter, Filter)::: javac parser peek token:::return->peekToken
JavacParser#peekToken(int, Filter, Filter)::: javac parser peek token:::return->tk1->S->token->accepts->tk2->S->token->accepts
JavacParser#peekToken(Filter, Filter, Filter)::: javac parser peek token:::return->peekToken
JavacParser#peekToken(int, Filter, Filter, Filter)::: javac parser peek token:::return->tk1->S->token->accepts->tk2->S->token->accepts->tk3->S->token->accepts
JavacParser#peekToken(Filter...)::: javac parser peek token:::return->peekToken
JavacParser#peekToken(int, Filter...)::: javac parser peek token:::for->return
JavacParser#skip(boolean, boolean, boolean, boolean):::Skip forward until a suitable stop token is found.:::while->switch->nextToken->return->return->if->return->break->if->return->break->if->return->break->if->return->break->if->return->break->nextToken
JavacParser#syntaxError(int, Error)::: javac parser syntax error:::return->List->nil->syntaxError
JavacParser#syntaxError(int, List, Error)::: javac parser syntax error:::setErrorEndPos->err->F->at->Erroneous->reportSyntaxError->if->last->errs->last->if->storeEnd->return->toP
JavacParser#reportSyntaxError(int, Error):::Report a syntax using the given the position parameter and arguments, unless one was already reported at the same position.:::diag->new->JCDiagnostic.SimpleDiagnosticPosition->reportSyntaxError
JavacParser#reportSyntaxError(JCDiagnostic.DiagnosticPosition, Error):::Report a syntax error using the given DiagnosticPosition object and arguments, unless one was already reported at the same position.:::pos->diagPos->getPreferredPosition->if->S->errPos->if->log->error->else->log->error->S->errPos->if->Assert->check->else
JavacParser#accept(TokenKind):::If next input token matches given token, skip it, otherwise report  an error.:::if->nextToken->else->setErrorEndPos->S->prevToken->Errors->Expected->reportSyntaxError
JavacParser#illegal(int):::Report an illegal start of expression/type error at given position.:::setErrorEndPos->if->return->syntaxError->else->return->syntaxError
JavacParser#illegal():::Report an illegal start of expression/type error at current position.:::return->illegal
JavacParser#checkNoMods(long):::Diagnose a modifier flag from the set, if any.:::if->lowestMod->log->Errors->Flags->asFlagSet->ModNotAllowedHere->error
JavacParser#attach(JCTree, Comment):::Make an entry into docComments hashtable,  provided flag keepDocComments is set and given doc comment is non-null.:::if->docComments->putComment
JavacParser#setErrorEndPos(int)::: javac parser set error end pos:::endPosTable->setErrorEndPos
JavacParser#storeEnd(JCTree, int)::: javac parser store end:::endPosTable->storeEnd
JavacParser#to(T)::: javac parser to:::return->endPosTable->to
JavacParser#toP(T)::: javac parser to p:::return->endPosTable->toP
JavacParser#getStartPos(JCTree):::Get the start position for a tree node:::return->TreeInfo->getStartPos
JavacParser#getEndPos(JCTree):::Get the end position for a tree node:::return->endPosTable->getEndPos
JavacParser#ident():::Ident = IDENTIFIER:::return->ident
JavacParser#ident(boolean)::: javac parser ident:::if->name->token->name->nextToken->return->else->if->log->error->nextToken->return->else->if->log->error->nextToken->return->else->if->if->checkSourceLevel->name->token->name->nextToken->return->else->log->error->nextToken->return->else->if->if->allowedInSource->log->warning->else->log->error->name->token->name->nextToken->return->else->accept->if->nextToken->return
JavacParser#qualident(boolean):::Qualident = Ident { DOT [Annotations] Ident }:::t->F->at->ident->Ident->toP->while->pos->nextToken->tyannos->if->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->return
JavacParser#literal(Name)::: javac parser literal:::return->literal
JavacParser#literal(Name, int):::Literal =     INTLITERAL   | LONGLITERAL   | FLOATLITERAL   | DOUBLELITERAL   | CHARLITERAL   | STRINGLITERAL   | TRUE   | FALSE   | NULL:::t->switch->try->F->at->Convert->strval->token->radix->string2int->Literal->catch->log->Errors->strval->IntNumberTooLarge->error->finally->break->try->F->at->Long->Convert->strval->token->radix->string2long->valueOf->Literal->catch->log->Errors->strval->IntNumberTooLarge->error->finally->break->proper->token->radix->token->stringVal->token->stringVal->n->try->Float->valueOf->catch->finally->if->n->floatValue->isZero->log->error->else->if->n->floatValue->log->error->else->F->at->Literal->break->proper->token->radix->token->stringVal->token->stringVal->n->try->Double->valueOf->catch->finally->if->n->doubleValue->isZero->log->error->else->if->n->doubleValue->log->error->else->F->at->Literal->break->F->at->token->stringVal->charAt->Literal->break->F->at->token->stringVal->Literal->break->F->at->Literal->break->F->at->Literal->break->Assert->error->if->F->at->Erroneous->storeEnd->nextToken->return
JavacParser#isZero(String)::: javac parser is zero:::cs->s->toCharArray->base->Character->toLowerCase->i->while->return->Character->digit
JavacParser#strval(Name)::: javac parser strval:::s->token->stringVal->return->prefix->isEmpty
JavacParser#parseExpression():::terms can be either expressions or types.:::return->term
JavacParser#parseType():::parses (optional) type annotations followed by a type:::return->parseType
JavacParser#parseType(boolean)::: javac parser parse type:::annotations->typeAnnotationsOpt->return->parseType
JavacParser#parseType(boolean, List)::: javac parser parse type:::result->unannotatedType->if->annotations->nonEmpty->insertAnnotationsToMostInner->return
JavacParser#unannotatedType(boolean)::: javac parser unannotated type:::result->term->if->isRestrictedLocalVarTypeName->syntaxError->return
JavacParser#term(int)::: javac parser term:::prevmode->t->term->return
JavacParser#term()::: Expression = Expression1 [ExpressionRest]  ExpressionRest = [AssignmentOperator Expression1]  AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" |                       "&=" | "|=" | "^=" |                       "%=" | "<<=" | ">>=" | ">>>="  Type = Type1  TypeNoParams = TypeNoParams1  StatementExpression = Expression  ConstantExpression = Expression  :::t->term1->if->PLUSEQ->compareTo->compareTo->return->termRest->else->return
JavacParser#termRest(JCExpression)::: javac parser term rest:::switch->pos->nextToken->t1->term->return->F->at->Assign->toP->pos->tk->nextToken->t1->term->return->F->at->optag->Assignop->return
JavacParser#term1():::Expression1   = Expression2 [Expression1Rest]  Type1         = Type2  TypeNoParams1 = TypeNoParams2:::t->term2->if->return->term1Rest->else->return
JavacParser#term1Rest(JCExpression):::Expression1Rest = ["?" Expression ":" Expression1]:::if->pos->nextToken->t1->term->accept->t2->term1->return->F->at->Conditional->else->return
JavacParser#term2():::Expression2   = Expression3 [Expression2Rest]  Type2         = Type3  TypeNoParams2 = TypeNoParams3:::t->term3->if->prec->return->term2Rest->else->return
JavacParser#term2Rest(JCExpression, int)::: javac parser term2 rest:::odStack->newOdStack->opStack->newOpStack->top->startPos->topOp->while->prec->nextToken->parseType->term3->while->prec->prec->makeOp->Assert->check->if->t->hasTag->foldStrings->odStackSupply->add->opStackSupply->add->return
JavacParser#makeOp(int, TokenKind, JCExpression, JCExpression):::Construct a binary or type test node.:::if->return->F->at->TypeTest->else->return->F->at->optag->Binary
JavacParser#foldStrings(JCExpression):::If tree is a concatenation of string literals, replace it  by a single literal representing the concatenated string.:::if->return->opStack->new->ListBuffer<>->litBuf->new->ListBuffer<>->needsFolding->curr->while->if->curr->hasTag->op->foldIfNeeded->else->foldIfNeeded->break->if->ops->opStack->toList->res->foreach->F->op->getStartPosition->at->optag->Binary->getEndPos->storeEnd->return->else->return
JavacParser#foldIfNeeded(JCExpression, ListBuffer, ListBuffer, boolean)::: javac parser fold if needed:::str->stringLiteral->if->litBuf->prepend->return->merge->else->res->merge->litBuf->clear->opStack->prepend->return
JavacParser#merge(ListBuffer, ListBuffer)::: javac parser merge:::if->litBuf->isEmpty->return->else->if->litBuf->size->opStack->litBuf->first->prepend->return->else->t->F->litBuf->first->getStartPosition->at->litBuf->stream->lit->getValue->map->Collectors->joining->collect->Literal->litBuf->last->getEndPosition->storeEnd->opStack->prepend->return
JavacParser#stringLiteral(JCTree)::: javac parser string literal:::if->tree->hasTag->lit->if->return->return
JavacParser#newOdStack()::: javac parser new od stack:::if->odStackSupply->isEmpty->return->new->JCExpressionArr->return->odStackSupply->odStackSupply->size->remove
JavacParser#newOpStack()::: javac parser new op stack:::if->opStackSupply->isEmpty->return->new->TokenArr->return->opStackSupply->opStackSupply->size->remove
JavacParser#term3()::: Expression3    = PrefixOp Expression3                 | "(" Expr | TypeNoParams ")" Expression3                 | Primary {Selector} {PostfixOp}   Primary        = "(" Expression ")"                 | Literal                 | [TypeArguments] THIS [Arguments]                 | [TypeArguments] SUPER SuperSuffix                 | NEW [TypeArguments] Creator                 | "(" Arguments ")" "->" ( Expression | Block )                 | Ident "->" ( Expression | Block )                 | [Annotations] Ident { "." [Annotations] Ident                  | Expression3 MemberReferenceSuffix                   [ [Annotations] "[" ( "]" BracketsOpt "." CLASS | Expression "]" )                   | Arguments                   | "." ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )                   ]                 | BasicType BracketsOpt "." CLASS  }   PrefixOp       = "++" | "--" | "!" | "~" | "+" | "-"  PostfixOp      = "++" | "--"  Type3          = Ident { "." Ident } [TypeArguments] {TypeSelector} BracketsOpt                 | BasicType  TypeNoParams3  = Ident { "." Ident } BracketsOpt  Selector       = "." [TypeArguments] Ident [Arguments]                 | "." THIS                 | "." [TypeArguments] SUPER SuperSuffix                 | "." NEW [TypeArguments] InnerCreator                 | "[" Expression "]"  TypeSelector   = "." Ident [TypeArguments]  SuperSuffix    = Arguments | "." Ident [Arguments]:::pos->t->typeArgs->typeArgumentsOpt->switch->if->return->typeArgument->else->return->illegal->if->tk->nextToken->if->token->radix->literal->else->term3->return->F->at->unoptag->Unary->else->return->illegal->break->if->pres->analyzeParens->switch->accept->pos1->targets->List->parseType->of->while->checkSourceLevel->accept->targets->parseType->prepend->if->targets->length->F->at->targets->reverse->TypeIntersection->toP->accept->t1->term3->return->F->at->TypeCast->lambdaExpressionOrStatement->break->accept->term3->term2Rest->term1Rest->termRest->accept->F->at->Parens->toP->break->else->return->illegal->break->if->F->at->Ident->to->nextToken->if->argumentsOpt->else->arguments->else->return->illegal->break->if->F->at->Ident->to->superSuffix->else->return->illegal->break->if->literal->else->return->illegal->break->if->return->illegal->if->nextToken->if->typeArguments->creator->else->return->illegal->break->typeAnnos->typeAnnotationsOpt->if->typeAnnos->isEmpty->throw->new->AssertionError->expr->term3->if->switch->expr->getTag->mref->F->at->AnnotatedType->toP->break->sel->if->return->illegal->else->log->error->return->return->illegal->else->insertAnnotationsToMostInner->break->if->return->illegal->if->peekToken->lambdaExpressionOrStatement->else->F->at->ident->Ident->toP->while->annos->typeAnnotationsOpt->if->annos->isEmpty->return->illegal->switch->nextToken->if->nextToken->bracketsOpt->F->at->TypeArray->toP->if->annos->nonEmpty->F->at->AnnotatedType->toP->bracketsSuffix->else->if->t1->term->if->annos->isEmpty->illegal->F->at->Indexed->to->accept->break->if->arguments->if->annos->isEmpty->illegal->break->nextToken->if->return->illegal->oldmode->typeArgumentsOpt->if->switch->if->return->illegal->F->at->Select->to->nextToken->break->if->return->illegal->F->at->Select->to->nextToken->break->F->at->Select->to->superSuffix->break->if->return->illegal->pos1->nextToken->if->typeArguments->innerCreator->break->tyannos->if->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->break->if->else->if->annos->nonEmpty->illegal->break->if->isUnboundMemberRef->pos1->accept->args->new->ListBuffer<>->args->typeArgument->append->while->nextToken->args->typeArgument->append->accept->F->at->args->toList->TypeApply->toP->while->nextToken->F->at->ident->Select->toP->typeArgumentsOpt->bracketsOpt->if->illegal->return->term3Rest->break->break->if->illegal->typeArgumentsOpt->break->if->illegal->basicType->bracketsOpt->bracketsSuffix->break->if->illegal->if->nextToken->if->ti->F->at->TypeIdent->toP->bracketsSuffix->else->return->illegal->else->ti->F->at->TypeIdent->to->nextToken->return->break->return->illegal->return->term3Rest
JavacParser#term3Rest(JCExpression, List)::: javac parser term3 rest:::if->illegal->while->pos1->annos->typeAnnotationsOpt->if->nextToken->if->oldmode->if->nextToken->bracketsOpt->F->at->TypeArray->toP->if->continue->if->annos->nonEmpty->F->at->AnnotatedType->toP->return->if->t1->term->F->at->Indexed->to->accept->else->if->nextToken->typeArgumentsOpt->if->F->at->Select->to->nextToken->arguments->else->if->if->return->illegal->pos2->nextToken->if->typeArguments->innerCreator->else->tyannos->if->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->typeArgumentsOpt->argumentsOpt->else->if->if->return->illegal->accept->memberReferenceSuffix->else->if->annos->isEmpty->if->else->return->illegal->break->while->F->at->Unary->to->nextToken->return->toP
JavacParser#isUnboundMemberRef():::If we see an identifier followed by a '<' it could be an unbound method reference or a binary expression:::pos->depth->for->t->S->token->S->token
JavacParser#analyzeParens():::If we see an identifier followed by a '<' it could be an unbound method reference or a binary expression:::depth->type->for->lookahead
JavacParser#lambdaExpressionOrStatement(boolean, boolean, int)::: javac parser lambda expression or statement:::params->formalParameters->implicitParameters->if->lambdaClassifier->new->LambdaClassifier->foreach->if->isRestrictedLocalVarTypeName->hasTag->log->error->lambdaClassifier->addParameter->if->lambdaClassifier->result->break->if->log->Errors->InvalidLambdaParameterDeclaration->error->foreach->if->isRestrictedLocalVarTypeName->TreeInfo->getStartPos->return->lambdaExpressionOrStatementRest
JavacParser.LambdaClassifier#addParameter(JCVariableDecl)::: lambda classifier add parameter:::if->if->isRestrictedLocalVarTypeName->reduce->else->reduce->if->reduce
JavacParser.LambdaClassifier#reduce(LambdaParameterKind)::: lambda classifier reduce:::if->else->if->currentKind
JavacParser.LambdaClassifier#result()::: lambda classifier result:::return
JavacParser#lambdaExpressionOrStatementRest(List, int)::: javac parser lambda expression or statement rest:::checkSourceLevel->accept->return->lambdaStatement->lambdaExpression
JavacParser#lambdaStatement(List, int, int)::: javac parser lambda statement:::block->block->return->F->at->Lambda->toP
JavacParser#lambdaExpression(List, int)::: javac parser lambda expression:::expr->parseExpression->return->F->at->Lambda->toP
JavacParser#superSuffix(List, JCExpression):::SuperSuffix = Arguments | "." [TypeArguments] Ident [Arguments]:::nextToken->if->arguments->else->if->if->return->illegal->memberReferenceSuffix->else->pos->accept->typeArguments->F->at->ident->Select->toP->argumentsOpt->return
JavacParser#basicType():::BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN:::t->F->at->typetag->TypeIdent->to->nextToken->return
JavacParser#argumentsOpt(List, JCExpression):::ArgumentsOpt = [ Arguments ]:::if->return->arguments->else->return
JavacParser#arguments():::Arguments = "(" [Expression { COMMA Expression }] ")":::args->new->ListBuffer<>->if->nextToken->if->args->parseExpression->append->while->nextToken->args->parseExpression->append->accept->else->Errors->Expected->syntaxError->return->args->toList
JavacParser#arguments(List, JCExpression)::: javac parser arguments:::pos->args->arguments->return->F->at->Apply->toP
JavacParser#typeArgumentsOpt(JCExpression)::: TypeArgumentsOpt = [ TypeArguments ]:::if->return->typeArguments->else->return
JavacParser#typeArgumentsOpt()::: javac parser type arguments opt:::return->typeArgumentsOpt
JavacParser#typeArgumentsOpt(int)::: javac parser type arguments opt:::if->if->illegal->return->typeArguments->return
JavacParser#typeArguments(boolean)::: TypeArguments  = "<" TypeArgument {"," TypeArgument ">"  }:::if->nextToken->if->checkSourceLevel->nextToken->return->List->nil->else->args->new->ListBuffer<>->args->typeArgument->parseType->append->while->nextToken->args->typeArgument->parseType->append->switch->S->split->break->nextToken->break->args->Errors->Expected->syntaxError->append->break->return->args->toList->else->return->List->Errors->Expected->syntaxError->of
JavacParser#typeArgument()::: TypeArgument = Type               | [Annotations] "?"               | [Annotations] "?" EXTENDS Type {"&" Type               | [Annotations] "?" SUPER Type  }:::annotations->typeAnnotationsOpt->if->return->parseType->pos->nextToken->result->if->t->F->at->TypeBoundKind->to->nextToken->bound->parseType->F->at->Wildcard->else->if->t->F->at->TypeBoundKind->to->nextToken->bound->parseType->F->at->Wildcard->else->if->LAX_IDENTIFIER->accepts->t->F->at->TypeBoundKind->wc->F->at->Wildcard->toP->id->F->at->ident->Ident->toP->err->F->at->List->of->Erroneous->Errors->Expected3->reportSyntaxError->else->t->F->at->TypeBoundKind->toP->F->at->Wildcard->toP->if->annotations->isEmpty->F->at->AnnotatedType->toP->return
JavacParser#typeArguments(JCExpression, boolean)::: javac parser type arguments:::pos->args->typeArguments->return->F->at->TypeApply->toP
JavacParser#bracketsOpt(JCExpression, List):::BracketsOpt = { [Annotations] "[" "]" }*    annotations is the list of annotations targeting the expression t.:::nextLevelAnnotations->typeAnnotationsOpt->if->pos->nextToken->bracketsOptCont->else->if->nextLevelAnnotations->isEmpty->if->else->return->illegal->if->annotations->isEmpty->F->at->AnnotatedType->toP->return
JavacParser#bracketsOpt(JCExpression):::BracketsOpt = [ "[" "]" { [Annotations] "[" "]"} ]:::return->List->nil->bracketsOpt
JavacParser#bracketsOptCont(JCExpression, int, List)::: javac parser brackets opt cont:::accept->bracketsOpt->F->at->TypeArray->toP->if->annotations->nonEmpty->F->at->AnnotatedType->toP->return
JavacParser#bracketsSuffix(JCExpression):::BracketsSuffixExpr = "." CLASS  BracketsSuffixType =:::if->pos->nextToken->accept->if->name->if->LAX_IDENTIFIER->accepts->token->name->nextToken->else->F->at->List->F->at->Select->toP->of->Erroneous->else->tag->t->getTag->if->TreeInfo->containsTypeAnnotation->syntaxError->F->at->Select->toP->else->if->if->else->if->syntaxError->return
JavacParser#memberReferenceSuffix(JCExpression):::MemberReferenceSuffix = "::" [TypeArguments] Ident                       | "::" [TypeArguments] "new":::pos1->accept->return->memberReferenceSuffix
JavacParser#memberReferenceSuffix(int, JCExpression)::: javac parser member reference suffix:::checkSourceLevel->typeArgs->if->typeArguments->refName->refMode->if->nextToken->else->ident->return->F->t->getStartPosition->at->Reference->toP
JavacParser#creator(int, List):::Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest ):::newAnnotations->typeAnnotationsOpt->switch->if->if->newAnnotations->isEmpty->return->basicType->arrayCreatorRest->else->return->F->at->basicType->AnnotatedType->toP->arrayCreatorRest->break->t->qualident->oldmode->diamondFound->lastTypeargsPos->if->typeArguments->while->if->illegal->pos->nextToken->tyannos->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->if->typeArguments->if->if->newAnnotations->nonEmpty->insertAnnotationsToMostInner->e->arrayCreatorRest->if->reportSyntaxError->return->F->at->List->of->Erroneous->toP->else->if->pos->if->typeArgs->isEmpty->S->prevToken->setErrorEndPos->err->F->at->typeArgs->prepend->Erroneous->reportSyntaxError->return->toP->return->else->if->newClass->classCreatorRest->if->if->newAnnotations->nonEmpty->earlier->else->if->newAnnotations->nonEmpty->insertAnnotationsToMostInner->return->else->setErrorEndPos->Errors->Expected2->reportSyntaxError->F->at->List->nil->NewClass->toP->return->F->at->List->of->Erroneous->toP
JavacParser#innerCreator(int, List, JCExpression):::InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest:::newAnnotations->typeAnnotationsOpt->t->F->at->ident->Ident->toP->if->newAnnotations->nonEmpty->F->at->AnnotatedType->toP->if->oldmode->typeArguments->return->classCreatorRest
JavacParser#arrayCreatorRest(int, JCExpression):::ArrayCreatorRest = [Annotations] "[" ( "]" BracketsOpt ArrayInitializer                         | Expression "]" {[Annotations]  "[" Expression "]"} BracketsOpt ):::annos->typeAnnotationsOpt->accept->if->accept->bracketsOpt->if->na->arrayInitializer->if->annos->nonEmpty->annotated->return->else->t->F->at->List->nil->NewArray->toP->return->List->of->syntaxError->else->dims->new->ListBuffer<>->dimAnnotations->new->ListBuffer<>->dimAnnotations->append->dims->parseExpression->append->accept->while->maybeDimAnnos->typeAnnotationsOpt->pos->nextToken->if->bracketsOptCont->else->if->bracketsOptCont->else->dimAnnotations->append->dims->parseExpression->append->accept->elems->errpos->if->arrayInitializerElements->na->F->at->dims->toList->NewArray->toP->dimAnnotations->toList->if->return->List->of->syntaxError->return
JavacParser#classCreatorRest(int, JCExpression, List, JCExpression):::ClassCreatorRest = Arguments [ClassBody]:::args->arguments->body->if->pos->defs->classOrInterfaceBody->mods->F->at->Modifiers->F->at->AnonymousClassDef->toP->return->F->at->NewClass->toP
JavacParser#arrayInitializer(int, JCExpression):::ArrayInitializer = "{" [VariableInitializer {"," VariableInitializer}] [","] "}":::elems->arrayInitializerElements->return->F->at->List->nil->NewArray->toP
JavacParser#arrayInitializerElements(int, JCExpression)::: javac parser array initializer elements:::accept->elems->new->ListBuffer<>->if->nextToken->else->if->elems->variableInitializer->append->while->nextToken->if->break->elems->variableInitializer->append->accept->return->elems->toList
JavacParser#variableInitializer():::VariableInitializer = ArrayInitializer | Expression:::return->arrayInitializer->parseExpression
JavacParser#parExpression():::ParExpression = "(" Expression ")":::pos->accept->t->parseExpression->accept->return->F->at->Parens->toP
JavacParser#block(int, long):::Block = "{" BlockStatements "}":::accept->stats->blockStatements->t->F->at->Block->while->Errors->Orphaned->syntaxError->switchBlockStatementGroups->accept->return->toP
JavacParser#block()::: javac parser block:::return->block
JavacParser#blockStatements():::BlockStatements = { BlockStatement }  BlockStatement  = LocalVariableDeclarationStatement                  | ClassOrInterfaceOrEnumDeclaration                  | [Ident ":"] Statement  LocalVariableDeclarationStatement                  = { FINAL | '@' Annotation } Type VariableDeclarators ";":::lastErrPos->stats->new->ListBuffer<>->while->stat->blockStatement->if->stat->isEmpty->return->stats->toList->else->if->return->stats->toList->if->skip->stats->addAll
JavacParser#parseStatementAsBlock()::: javac parser parse statement as block:::pos->stats->blockStatement->if->stats->isEmpty->e->syntaxError->return->F->at->Exec->toP->else->first->error->switch->first->getTag->break->break->if->log->error->blist->List->F->at->Block->of->return->F->at->F->at->Erroneous->Exec->toP->return
JavacParser#blockStatement():::This method parses a statement appearing inside a block.:::pos->switch->return->List->nil->return->List->parseSimpleStatement->of->dc->token->comment->mods->modifiersOpt->if->return->List->classOrInterfaceOrEnumDeclaration->of->else->t->parseType->return->localVariableDeclarations->dc->token->comment->mods->modifiersOpt->return->List->classOrInterfaceOrEnumDeclaration->of->dc->token->comment->return->List->modifiersOpt->classOrInterfaceOrEnumDeclaration->of->log->error->token->comment->return->List->modifiersOpt->classOrInterfaceOrEnumDeclaration->of->prevToken->t->term->if->t->hasTag->nextToken->stat->parseStatementAsBlock->return->List->F->at->prevToken->name->Labelled->of->else->if->LAX_IDENTIFIER->accepts->mods->F->at->Modifiers->F->at->return->localVariableDeclarations->else->checkExprStat->accept->expr->F->at->Exec->toP->return->List->of
JavacParser#localVariableDeclarations(JCModifiers, JCExpression)::: javac parser local variable declarations:::stats->new->ListBuffer<>->variableDeclarators->accept->stats->last->S->prevToken->storeEnd->return->stats->toList
JavacParser#parseSimpleStatement():::Statement =       Block     | IF ParExpression Statement [ELSE Statement]     | FOR "(" ForInitOpt ";" [Expression] ";" ForUpdateOpt ")" Statement     | FOR "(" FormalParameter : Expression ")" Statement     | WHILE ParExpression Statement     | DO Statement WHILE ParExpression ";"     | TRY Block ( Catches | [Catches] FinallyPart )     | TRY "(" ResourceSpecification ";"opt ")" Block [Catches] [FinallyPart]     | SWITCH ParExpression "{" SwitchBlockStatementGroups "}"     | SYNCHRONIZED ParExpression Block     | RETURN [Expression] ";"     | THROW Expression ";"     | BREAK [Ident] ";"     | CONTINUE [Ident] ";"     | ASSERT Expression [ ":" Expression ] ";"     | ";":::pos->switch->return->block->nextToken->cond->parExpression->thenpart->parseStatementAsBlock->elsepart->if->nextToken->parseStatementAsBlock->return->F->at->If->nextToken->accept->inits->List->nil->forInit->if->inits->length->hasTag->var->accept->expr->parseExpression->accept->body->parseStatementAsBlock->return->F->at->ForeachLoop->else->accept->cond->parseExpression->accept->steps->List->nil->forUpdate->accept->body->parseStatementAsBlock->return->F->at->ForLoop->nextToken->cond->parExpression->body->parseStatementAsBlock->return->F->at->WhileLoop->nextToken->body->parseStatementAsBlock->accept->cond->parExpression->accept->t->F->at->DoLoop->toP->return->nextToken->resources->List->nil->if->checkSourceLevel->nextToken->resources->accept->body->block->catchers->new->ListBuffer<>->finalizer->if->while->catchers->catchClause->append->if->nextToken->block->else->if->resources->isEmpty->if->allowedInSource->log->error->else->log->error->return->F->at->catchers->toList->Try->nextToken->selector->parExpression->accept->cases->switchBlockStatementGroups->t->F->at->Switch->to->accept->return->nextToken->lock->parExpression->body->block->return->F->at->Synchronized->nextToken->result->parseExpression->accept->t->F->at->Return->toP->return->nextToken->exc->parseExpression->accept->t->F->at->Throw->toP->return->nextToken->label->LAX_IDENTIFIER->accepts->ident->accept->t->F->at->Break->toP->return->nextToken->label->LAX_IDENTIFIER->accepts->ident->accept->t->F->at->Continue->toP->return->nextToken->return->F->at->Skip->toP->elsePos->nextToken->return->doRecover->finallyPos->nextToken->return->doRecover->return->doRecover->nextToken->assertion->parseExpression->message->if->nextToken->parseExpression->accept->t->F->at->Assert->toP->return->Assert->error->return
JavacParser#parseStatement()::: javac parser parse statement:::return->parseStatementAsBlock
JavacParser#doRecover(int, ErrorRecoveryAction, Error)::: javac parser do recover:::errPos->S->errPos->stm->action->doRecover->S->errPos->return->F->List->of->syntaxError->Exec->toP
JavacParser#catchClause():::CatchClause     = CATCH "(" FormalParameter ")" Block TODO: the "FormalParameter" is not correct, it uses the special "catchTypes" rule below.:::pos->accept->accept->mods->optFinal->catchTypes->catchTypes->paramType->catchTypes->size->F->getStartPosition->at->TypeUnion->toP->formal->variableDeclaratorId->accept->body->block->return->F->at->Catch
JavacParser#catchTypes()::: javac parser catch types:::catchTypes->new->ListBuffer<>->catchTypes->parseType->add->while->checkSourceLevel->nextToken->catchTypes->parseType->add->return->catchTypes->toList
JavacParser#switchBlockStatementGroups():::SwitchBlockStatementGroups = { SwitchBlockStatementGroup }  SwitchBlockStatementGroup = SwitchLabel BlockStatements  SwitchLabel = CASE ConstantExpression ":" | DEFAULT ":":::cases->new->ListBuffer<>->while->pos->switch->cases->switchBlockStatementGroup->append->break->return->cases->toList->nextToken->Errors->Expected3->syntaxError
JavacParser#switchBlockStatementGroup()::: javac parser switch block statement group:::pos->stats->c->switch->nextToken->pat->parseExpression->accept->blockStatements->F->at->Case->if->stats->isEmpty->S->prevToken->storeEnd->return->nextToken->accept->blockStatements->F->at->Case->if->stats->isEmpty->S->prevToken->storeEnd->return->throw->new->AssertionError
JavacParser#moreStatementExpressions(int, JCExpression, T):::MoreStatementExpressions = { COMMA StatementExpression }:::stats->F->at->checkExprStat->Exec->toP->append->while->nextToken->t->parseExpression->stats->F->at->checkExprStat->Exec->toP->append->return
JavacParser#forInit():::ForInit = StatementExpression MoreStatementExpressions           |  { FINAL | '@' Annotation } Type VariableDeclarators:::stats->new->ListBuffer<>->pos->if->return->optFinal->parseType->variableDeclarators->toList->else->t->term->if->LAX_IDENTIFIER->accepts->return->modifiersOpt->variableDeclarators->toList->else->if->log->Errors->BadInitializer->error->return->List->F->at->modifiersOpt->VarDef->of->else->return->moreStatementExpressions->toList
JavacParser#forUpdate():::ForUpdate = StatementExpression MoreStatementExpressions:::return->parseExpression->new->ListBuffer<JCExpressionStatement>->moreStatementExpressions->toList
JavacParser#annotationsOpt(Tag):::AnnotationsOpt = { '@' Annotation }:::if->return->List->nil->buf->new->ListBuffer<>->prevmode->while->pos->nextToken->buf->annotation->append->annotations->buf->toList->return
JavacParser#typeAnnotationsOpt()::: javac parser type annotations opt:::annotations->annotationsOpt->return
JavacParser#modifiersOpt():::ModifiersOpt = { Modifier }  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | "@"           | "@" Annotation:::return->modifiersOpt
JavacParser#modifiersOpt(JCModifiers)::: javac parser modifiers opt:::flags->annotations->new->ListBuffer<>->pos->if->else->annotations->appendList->if->token->deprecatedFlag->lastPos->while->flag->switch->break->break->break->break->break->break->break->break->break->break->break->break->checkSourceLevel->break->nextToken->break->break->if->log->error->nextToken->if->if->ann->annotation->if->annotations->isEmpty->annotations->append->switch->break->break->break->if->annotations->isEmpty->mods->F->at->annotations->toList->Modifiers->if->S->prevToken->storeEnd->return
JavacParser#annotation(int, Tag):::Annotation              = "@" Qualident [ "(" AnnotationFieldValues ")" ]:::if->checkSourceLevel->ident->qualident->fieldValues->annotationFieldValuesOpt->ann->if->F->at->Annotation->else->if->F->at->TypeAnnotation->else->throw->new->AssertionError->S->prevToken->storeEnd->return
JavacParser#annotationFieldValuesOpt()::: javac parser annotation field values opt:::return->annotationFieldValues->List->nil
JavacParser#annotationFieldValues():::AnnotationFieldValues   = "(" [ AnnotationFieldValue { "," AnnotationFieldValue } ] ")":::accept->buf->new->ListBuffer<>->if->buf->annotationFieldValue->append->while->nextToken->buf->annotationFieldValue->append->accept->return->buf->toList
JavacParser#annotationFieldValue():::AnnotationFieldValue    = AnnotationValue                          | Identifier "=" AnnotationValue:::if->LAX_IDENTIFIER->accepts->t1->term1->if->t1->hasTag->pos->accept->v->annotationValue->return->F->at->Assign->toP->else->return->return->annotationValue
JavacParser#annotationValue()::: javac parser annotation value:::pos->switch->nextToken->return->annotation->accept->buf->new->ListBuffer<>->if->nextToken->else->if->buf->annotationValue->append->while->nextToken->if->break->buf->annotationValue->append->accept->return->F->at->List->nil->buf->toList->NewArray->toP->return->term1
JavacParser#variableDeclarators(JCModifiers, JCExpression, T, boolean):::VariableDeclarators = VariableDeclarator { "," VariableDeclarator }:::return->ident->variableDeclaratorsRest
JavacParser#variableDeclaratorsRest(int, JCModifiers, JCExpression, Name, boolean, Comment, T, boolean):::VariableDeclaratorsRest = VariableDeclaratorRest { "," VariableDeclarator }  ConstantDeclaratorsRest = ConstantDeclaratorRest { "," ConstantDeclarator }:::head->variableDeclaratorRest->vdefs->append->while->vdefs->last->storeEnd->nextToken->vdefs->variableDeclarator->append->return
JavacParser#variableDeclarator(JCModifiers, JCExpression, boolean, Comment, boolean):::VariableDeclarator = Ident VariableDeclaratorRest  ConstantDeclarator = Ident ConstantDeclaratorRest:::return->ident->variableDeclaratorRest
JavacParser#variableDeclaratorRest(int, JCModifiers, JCExpression, Name, boolean, Comment, boolean, boolean):::VariableDeclaratorRest = BracketsOpt ["=" VariableInitializer]  ConstantDeclaratorRest = BracketsOpt "=" VariableInitializer:::bracketsOpt->init->if->nextToken->variableInitializer->else->if->Errors->Expected->syntaxError->elemType->TreeInfo->innermostType->startPos->if->elemType->hasTag->typeName->if->isRestrictedLocalVarTypeName->if->reportSyntaxError->else->if->type->hasTag->reportSyntaxError->else->TreeInfo->getStartPos->if->TreeInfo->getStartPos->result->F->at->VarDef->toP->attach->return
JavacParser#isRestrictedLocalVarTypeName(JCExpression, boolean)::: javac parser is restricted local var type name:::switch->e->getTag->return->isRestrictedLocalVarTypeName->return->isRestrictedLocalVarTypeName->return
JavacParser#isRestrictedLocalVarTypeName(Name, int, boolean)::: javac parser is restricted local var type name:::if->if->allowedInSource->return->else->if->log->warning->return
JavacParser#variableDeclaratorId(JCModifiers, JCExpression):::VariableDeclaratorId = Ident BracketsOpt:::return->variableDeclaratorId
JavacParser#variableDeclaratorId(JCModifiers, JCExpression, boolean)::: javac parser variable declarator id:::pos->name->if->log->error->token->name->nextToken->else->if->LAX_IDENTIFIER->accepts->nonEmpty->pn->qualident->if->pn->hasTag->else->if->if->log->error->if->log->error->if->pn->hasTag->log->error->return->F->at->ReceiverVarDef->toP->else->if->log->error->bracketsOpt->return->F->at->VarDef->toP
JavacParser#resources():::Resources = Resource { ";" Resources }:::defs->new->ListBuffer<>->defs->resource->append->while->defs->last->storeEnd->semiColonPos->nextToken->if->break->defs->resource->append->return->defs->toList
JavacParser#resource():::Resource = VariableModifiersOpt Type VariableDeclaratorId "=" Expression           | Expression:::startPos->if->mods->optFinal->t->parseType->return->ident->variableDeclaratorRest->t->term->if->LAX_IDENTIFIER->accepts->mods->F->at->Modifiers->toP->return->ident->variableDeclaratorRest->else->checkSourceLevel->if->t->hasTag->t->hasTag->log->t->pos->error->return
JavacParser#parseCompilationUnit():::CompilationUnit = [ { "@" Annotation } PACKAGE Qualident ";"] {ImportDeclaration} {TypeDeclaration}:::firstToken->mods->consumedToplevelDoc->seenImport->seenPackage->defs->new->ListBuffer<>->if->modifiersOpt->if->packagePos->annotations->List->nil->if->checkNoMods->nextToken->pid->qualident->accept->pd->F->at->PackageDecl->toP->firstToken->comment->attach->defs->append->checkForImports->firstTypeDecl->while->if->skip->if->break->if->defs->importDeclaration->append->else->docComment->token->comment->if->firstToken->comment->if->modifiersOpt->if->kind->if->token->name->nextToken->if->token->name->if->checkNoMods->defs->moduleDecl->append->break->else->if->reportSyntaxError->def->typeDeclaration->if->defs->append->if->toplevel->F->at->defs->toList->TopLevel->if->firstToken->comment->attach->if->defs->isEmpty->S->prevToken->storeEnd->if->if->S->getLineMap->setParser->return
JavacParser#moduleDecl(JCModifiers, ModuleKind, Comment)::: javac parser module decl:::pos->checkSourceLevel->nextToken->name->qualident->directives->accept->moduleDirectiveList->accept->accept->result->F->at->ModuleDef->toP->attach->return
JavacParser#moduleDirectiveList()::: javac parser module directive list:::defs->new->ListBuffer<>->while->pos->if->token->name->nextToken->isTransitive->isStaticPhase->while->switch->if->token->name->t1->S->token->if->break->break->else->break->if->log->error->break->break->nextToken->moduleName->qualident->accept->defs->F->at->Requires->toP->append->else->if->token->name->token->name->exports->token->name->nextToken->pkgName->qualident->moduleNames->if->token->name->nextToken->qualidentList->accept->d->if->F->at->Exports->else->F->at->Opens->defs->toP->append->else->if->token->name->nextToken->serviceName->qualident->if->token->name->nextToken->implNames->qualidentList->accept->defs->F->at->Provides->toP->append->else->log->Errors->ExpectedStr->error->skip->else->if->token->name->nextToken->service->qualident->accept->defs->F->at->Uses->toP->append->else->setErrorEndPos->reportSyntaxError->break->return->defs->toList
JavacParser#importDeclaration():::ImportDeclaration = IMPORT [ STATIC ] Ident { "." Ident } [ "." "*" ] ";":::pos->nextToken->importStatic->if->nextToken->pid->F->at->ident->Ident->toP->do->pos1->accept->if->F->at->Select->to->nextToken->break->else->F->at->ident->Select->toP->while->accept->return->F->at->Import->toP
JavacParser#typeDeclaration(JCModifiers, Comment):::TypeDeclaration = ClassOrInterfaceOrEnumDeclaration                  | ";":::pos->if->nextToken->return->F->at->Skip->toP->else->return->modifiersOpt->classOrInterfaceOrEnumDeclaration
JavacParser#classOrInterfaceOrEnumDeclaration(JCModifiers, Comment):::ClassOrInterfaceOrEnumDeclaration = ModifiersOpt           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration):::if->return->classDeclaration->else->if->return->interfaceDeclaration->else->if->return->enumDeclaration->else->pos->errs->if->LAX_IDENTIFIER->accepts->List->F->at->ident->Ident->toP->of->setErrorEndPos->else->List->of->erroneousTree->if->syntaxError->else->Errors->Expected3->syntaxError->return->F->Exec->toP
JavacParser#classDeclaration(JCModifiers, Comment):::ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]                     [IMPLEMENTS TypeList] ClassBody:::pos->accept->name->typeName->typarams->typeParametersOpt->extending->if->nextToken->parseType->implementing->List->nil->if->nextToken->typeList->defs->classOrInterfaceBody->result->F->at->ClassDef->toP->attach->return
JavacParser#typeName()::: javac parser type name:::pos->name->ident->if->isRestrictedLocalVarTypeName->reportSyntaxError->return
JavacParser#interfaceDeclaration(JCModifiers, Comment):::InterfaceDeclaration = INTERFACE Ident TypeParametersOpt                         [EXTENDS TypeList] InterfaceBody:::pos->accept->name->typeName->typarams->typeParametersOpt->extending->List->nil->if->nextToken->typeList->defs->classOrInterfaceBody->result->F->at->ClassDef->toP->attach->return
JavacParser#enumDeclaration(JCModifiers, Comment):::EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody:::pos->accept->name->typeName->implementing->List->nil->if->nextToken->typeList->defs->enumBody->result->F->at->List->nil->ClassDef->toP->attach->return
JavacParser#enumBody(Name):::EnumBody = "{" { EnumeratorDeclarationList } [","]                  [ ";" {ClassBodyDeclaration} ] "}":::accept->defs->new->ListBuffer<>->if->nextToken->else->if->defs->enumeratorDeclaration->append->while->nextToken->if->break->defs->enumeratorDeclaration->append->if->defs->Errors->Expected3->syntaxError->append->nextToken->if->nextToken->while->defs->classOrInterfaceBodyDeclaration->appendList->if->skip->accept->return->defs->toList
JavacParser#enumeratorDeclaration(Name):::EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ "{" ClassBody "}" ]:::dc->token->comment->flags->if->token->deprecatedFlag->pos->annotations->annotationsOpt->mods->F->annotations->isEmpty->at->Modifiers->typeArgs->typeArgumentsOpt->identPos->name->ident->createPos->args->arguments->List->nil->body->if->mods1->F->at->Modifiers->defs->classOrInterfaceBody->F->at->AnonymousClassDef->toP->if->args->isEmpty->ident->F->at->Ident->create->F->at->NewClass->if->S->prevToken->storeEnd->F->at->Ident->result->F->at->VarDef->toP->attach->return
JavacParser#typeList():::TypeList = Type {"," Type}:::ts->new->ListBuffer<>->ts->parseType->append->while->nextToken->ts->parseType->append->return->ts->toList
JavacParser#classOrInterfaceBody(Name, boolean):::ClassBody     = "{" {ClassBodyDeclaration} "}"  InterfaceBody = "{" {InterfaceBodyDeclaration} "}":::accept->if->skip->if->nextToken->defs->new->ListBuffer<>->while->defs->classOrInterfaceBodyDeclaration->appendList->if->skip->accept->return->defs->toList
JavacParser#classOrInterfaceBodyDeclaration(Name, boolean):::ClassBodyDeclaration =      ";"    | [STATIC] Block    | ModifiersOpt      ( Type Ident        ( VariableDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident VoidMethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | Ident ConstructorDeclaratorRest      | TypeParameters Ident ConstructorDeclaratorRest      | ClassOrInterfaceOrEnumDeclaration      )  InterfaceBodyDeclaration =      ";"    | ModifiersOpt      ( Type Ident        ( ConstantDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident MethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | ClassOrInterfaceOrEnumDeclaration      ):::if->nextToken->return->List->nil->else->dc->token->comment->pos->mods->modifiersOpt->if->return->List->classOrInterfaceOrEnumDeclaration->of->else->if->isEmpty->if->log->error->return->List->block->of->else->typarams->typeParametersOpt->if->typarams->nonEmpty->storeEnd->annosAfterParams->annotationsOpt->if->annosAfterParams->nonEmpty->checkSourceLevel->appendList->if->tk->type->isVoid->if->F->at->TypeIdent->to->nextToken->else->unannotatedType->if->type->hasTag->if->tk->name->log->error->else->if->annosAfterParams->nonEmpty->illegal->return->List->methodDeclaratorRest->of->else->name->ident->if->return->List->methodDeclaratorRest->of->else->if->typarams->isEmpty->defs->new->ListBuffer<JCTree>->variableDeclaratorsRest->toList->accept->defs->last->S->prevToken->storeEnd->return->else->err->List->F->at->List->nil->List->nil->MethodDef->toP->of->return->List->Errors->Expected->syntaxError->of
JavacParser#methodDeclaratorRest(int, JCModifiers, JCExpression, Name, List, boolean, boolean, Comment):::MethodDeclaratorRest =      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] ";")  VoidMethodDeclaratorRest =      FormalParameters [THROWS TypeList] ( MethodBody | ";")  ConstructorDeclaratorRest =      "(" FormalParameterListOpt ")" [THROWS TypeList] MethodBody:::if->if->checkSourceLevel->if->checkSourceLevel->prevReceiverParam->try->params->formalParameters->if->bracketsOpt->thrown->List->nil->if->nextToken->qualidentList->body->defaultValue->if->block->else->if->accept->annotationValue->else->accept->if->skip->if->block->result->F->at->MethodDef->toP->attach->return->catch->finally
JavacParser#qualidentList(boolean):::QualidentList = [Annotations] Qualident {"," [Annotations] Qualident}:::ts->new->ListBuffer<>->typeAnnos->typeAnnotationsOpt->List->nil->qi->qualident->if->typeAnnos->isEmpty->at->insertAnnotationsToMostInner->ts->append->else->ts->append->while->nextToken->typeAnnotationsOpt->List->nil->qualident->if->typeAnnos->isEmpty->at->insertAnnotationsToMostInner->ts->append->else->ts->append->return->ts->toList
JavacParser#typeParametersOpt()::: TypeParametersOpt = ["<" TypeParameter {"," TypeParameter ">"]  }:::if->typarams->new->ListBuffer<>->nextToken->typarams->typeParameter->append->while->nextToken->typarams->typeParameter->append->accept->return->typarams->toList->else->return->List->nil
JavacParser#typeParameter()::: TypeParameter = [Annotations] TypeVariable [TypeParameterBound]  TypeParameterBound = EXTENDS Type {"&" Type  TypeVariable = Ident  }:::pos->annos->typeAnnotationsOpt->name->typeName->bounds->new->ListBuffer<>->if->nextToken->bounds->parseType->append->while->nextToken->bounds->parseType->append->return->F->at->bounds->toList->TypeParameter->toP
JavacParser#formalParameters():::FormalParameters = "(" [ FormalParameterList ] ")"  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter:::return->formalParameters
JavacParser#formalParameters(boolean)::: javac parser formal parameters:::params->new->ListBuffer<>->lastParam->accept->if->formalParameter->if->else->params->append->while->if->log->error->nextToken->params->formalParameter->append->if->nextToken->else->setErrorEndPos->S->prevToken->Errors->Expected3->reportSyntaxError->return->params->toList
JavacParser#implicitParameters(boolean)::: javac parser implicit parameters:::if->accept->params->new->ListBuffer<>->if->params->implicitParameter->append->while->nextToken->params->implicitParameter->append->if->accept->return->params->toList
JavacParser#optFinal(long)::: javac parser opt final:::mods->modifiersOpt->checkNoMods->return
JavacParser#insertAnnotationsToMostInner(JCExpression, List, boolean):::Inserts the annotations (and possibly a new array level) to the left-most type in an array or nested type:::origEndPos->getEndPos->mostInnerType->mostInnerArrayType->while->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->if->F->at->TypeArray->to->mostInnerTypeToReturn->if->annos->nonEmpty->lastToModify->while->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->hasTag->while->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->getExpression->while->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->F->at->AnnotatedType->if->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->else->if->TreeInfo->typeIn->hasTag->TreeInfo->typeIn->else->if->return->else->storeEnd->return
JavacParser#formalParameter():::FormalParameter = { FINAL | '@' Annotation } Type VariableDeclaratorId  LastFormalParameter = { FINAL | '@' Annotation } Type '...' Ident | FormalParameter:::return->formalParameter
JavacParser#formalParameter(boolean)::: javac parser formal parameter:::mods->optFinal->type->parseType->if->varargsAnnos->List->nil->insertAnnotationsToMostInner->nextToken->else->if->typeAnnotationsPushedBack->nonEmpty->reportSyntaxError->List->nil->return->variableDeclaratorId
JavacParser#implicitParameter()::: javac parser implicit parameter:::mods->F->at->Modifiers->return->variableDeclaratorId
JavacParser#checkExprStat(JCExpression):::Check that given tree is a legal expression statement.:::if->TreeInfo->isExpressionStatement->ret->F->at->List->of->Erroneous->log->error->return->else->return
JavacParser#prec(TokenKind):::Return precedence of operator represented by token,  -1 if token is not a binary operator:::oc->optag->return->TreeInfo->opPrec
JavacParser#earlier(int, int):::Return the lesser of two positions, making allowance for either one being unset.:::if->return->if->return->return
JavacParser#optag(TokenKind):::Return operation tag of binary operator represented by token,  No_TAG if token is not a binary operator.:::switch->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return
JavacParser#unoptag(TokenKind):::Return operation tag of unary operator represented by token,  No_TAG if token is not a binary operator.:::switch->return->return->return->return->return->return->return
JavacParser#typetag(TokenKind):::Return type tag of basic type represented by token,  NONE if token is not a basic type identifier.:::switch->return->return->return->return->return->return->return->return->return
JavacParser#checkSourceLevel(Feature)::: javac parser check source level:::checkSourceLevel
JavacParser#checkSourceLevel(int, Feature)::: javac parser check source level:::if->preview->isPreview->preview->isEnabled->log->preview->disabledError->error->else->if->feature->allowedInSource->log->feature->error->error->else->if->preview->isPreview->preview->warnPreview
JavacParser.SimpleEndPosTable#storeEnd(JCTree, int)::: simple end pos table store end:::endPosMap->endPosMap->lookup->putAtIndex
JavacParser.SimpleEndPosTable#to(T)::: simple end pos table to:::storeEnd->return
JavacParser.SimpleEndPosTable#toP(T)::: simple end pos table to p:::prevToken->storeEnd->return
JavacParser.SimpleEndPosTable#getEndPos(JCTree)::: simple end pos table get end pos:::value->endPosMap->endPosMap->lookup->getFromIndex->return
JavacParser.SimpleEndPosTable#replaceTree(JCTree, JCTree)::: simple end pos table replace tree:::pos->endPosMap->remove->if->storeEnd->return->return
JavacParser.EmptyEndPosTable#storeEnd(JCTree, int)::: empty end pos table store end:::
JavacParser.EmptyEndPosTable#to(T)::: empty end pos table to:::return
JavacParser.EmptyEndPosTable#toP(T)::: empty end pos table to p:::return
JavacParser.EmptyEndPosTable#getEndPos(JCTree)::: empty end pos table get end pos:::return
JavacParser.EmptyEndPosTable#replaceTree(JCTree, JCTree)::: empty end pos table replace tree:::return
JavacParser.AbstractEndPosTable#to(T):::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the current token.:::
JavacParser.AbstractEndPosTable#toP(T):::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the previous token.:::
JavacParser.AbstractEndPosTable#setErrorEndPos(int):::Set the error position during the parsing phases, the value of which will be set only if it is greater than the last stored error position.:::if
JavacParser.AbstractEndPosTable#setParser(JavacParser)::: abstract end pos table set parser:::
JavadocTokenizer#processComment(int, int, CommentStyle)::: javadoc tokenizer process comment:::buf->reader->getRawCharacters->return->new->DocReader->new->JavadocComment
JavadocTokenizer.DocReader#convertUnicode()::: doc reader convert unicode:::if->if->do->while->limit->if->d->digit->code->while->digit->if->return->else
JavadocTokenizer.DocReader#scanCommentChar()::: doc reader scan comment char:::scanChar->if->if->peekChar->isUnicode->else->convertUnicode
JavadocTokenizer.DocReader#scanChar()::: doc reader scan char:::switch->break->if->break->break->convertUnicode->break->break
JavadocTokenizer.DocReader#putChar(char, boolean)::: doc reader put char:::if->if->new_pbuf->new->intArr->System->arraycopy->super->putChar
JavadocTokenizer.DocReader#isDoubleBackslash():::Whether the ch represents a sequence of two backslashes.:::return
JavadocTokenizer.JavadocComment#getText()::: javadoc comment get text:::if->scanDocComment->return
JavadocTokenizer.JavadocComment#getSourcePos(int)::: javadoc comment get source pos:::if->return->if->docComment->length->throw->String->valueOf->new->StringIndexOutOfBoundsException->if->return->start->end->while->index->if->else->if->return->else->return
JavadocTokenizer.JavadocComment#scanDocComment()::: javadoc comment scan doc comment:::try->firstLine->comment_reader->scanCommentChar->comment_reader->scanCommentChar->while->comment_reader->scanCommentChar->if->return->if->if->comment_reader->scanCommentChar->else->if->comment_reader->scanCommentChar->if->comment_reader->scanCommentChar->while->begin_bp->begin_ch->while->switch->comment_reader->scanCommentChar->break->comment_reader->scanCommentChar->break->comment_reader->scanCommentChar->break->break->if->do->comment_reader->scanCommentChar->while->if->break->else->if->while->switch->comment_reader->scanCommentChar->if->break->comment_reader->putChar->break->comment_reader->putChar->if->comment_reader->isDoubleBackslash->comment_reader->putChar->comment_reader->scanCommentChar->break->comment_reader->putChar->comment_reader->scanCommentChar->break->comment_reader->scanCommentChar->break->comment_reader->scanCommentChar->if->comment_reader->putChar->break->comment_reader->putChar->comment_reader->scanCommentChar->break->comment_reader->putChar->comment_reader->scanCommentChar->if->i->while->switch->break->break->comment_reader->chars->new->intArr->System->arraycopy->else->catch->finally->if->DEPRECATED_PATTERN->matcher->matches
JavadocTokenizer#getLineMap()::: javadoc tokenizer get line map:::buf->reader->getRawCharacters->return->Position->makeLineMap
JavaTokenizer#hexFloatsWork()::: java tokenizer hex floats work:::try->Float->valueOf->return->catch->return->finally
JavaTokenizer#checkSourceLevel(int, Feature)::: java tokenizer check source level:::if->preview->isPreview->preview->isEnabled->preview->disabledError->lexError->else->if->feature->allowedInSource->feature->error->lexError->else->if->preview->isPreview->preview->warnPreview
JavaTokenizer#lexError(int, JCDiagnostic.Error):::Report an error at the given position using the provided arguments.:::log->error
JavaTokenizer#lexError(DiagnosticFlag, int, JCDiagnostic.Error)::: java tokenizer lex error:::log->error
JavaTokenizer#scanLitChar(int):::Read next character in character or string literal and copy into sbuf.:::if->if->reader->peekChar->reader->isUnicode->reader->skipChar->reader->putChar->else->reader->scanChar->switch->leadch->oct->reader->digit->reader->scanChar->if->reader->digit->reader->scanChar->if->reader->digit->reader->scanChar->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->reader->putChar->break->lexError->else->if->reader->putChar
JavaTokenizer#scanDigits(int, int)::: java tokenizer scan digits:::saveCh->savePos->do->if->reader->putChar->else->checkSourceLevel->reader->scanChar->while->reader->digit->if->lexError
JavaTokenizer#scanHexExponentAndSuffix(int):::Read fractional part of hexadecimal floating point number.:::if->reader->putChar->skipIllegalUnderscores->if->reader->putChar->skipIllegalUnderscores->if->reader->digit->scanDigits->if->lexError->else->lexError->else->lexError->if->reader->putChar->else->if->reader->putChar
JavaTokenizer#scanFraction(int):::Read fractional part of floating point number.:::skipIllegalUnderscores->if->reader->digit->scanDigits->sp1->if->reader->putChar->skipIllegalUnderscores->if->reader->putChar->skipIllegalUnderscores->if->reader->digit->scanDigits->return->lexError
JavaTokenizer#scanFractionAndSuffix(int):::Read fractional part and 'd' or 'f' suffix of floating point number.:::scanFraction->if->reader->putChar->else->if->reader->putChar
JavaTokenizer#scanHexFractionAndSuffix(int, boolean):::Read fractional part and 'd' or 'f' suffix of floating point number.:::Assert->check->reader->putChar->skipIllegalUnderscores->if->reader->digit->scanDigits->if->lexError->else->scanHexExponentAndSuffix
JavaTokenizer#skipIllegalUnderscores()::: java tokenizer skip illegal underscores:::if->lexError->while->reader->scanChar
JavaTokenizer#scanNumber(int, int):::Read a number.:::digitRadix->firstDigit->reader->Math->max->digit->seendigit->seenValidDigit->if->scanDigits->if->scanHexFractionAndSuffix->else->if->scanHexExponentAndSuffix->else->if->reader->putChar->scanFractionAndSuffix->else->if->scanFractionAndSuffix->else->if->switch->lexError->break->lexError->break->if->reader->scanChar->else
JavaTokenizer#scanIdent():::Read an identifier.:::isJavaIdentifierPart->high->reader->putChar->do->switch->break->reader->scanChar->continue->if->reader->name->tokens->lookupKind->return->reader->scanChar->continue->if->else->if->Character->isIdentifierIgnorable->reader->scanChar->continue->else->codePoint->reader->peekSurrogates->if->if->Character->isJavaIdentifierPart->reader->putChar->else->Character->isJavaIdentifierPart->if->reader->name->tokens->lookupKind->return->reader->putChar->while
JavaTokenizer#isSpecial(char):::Return true if reader.ch can be part of an operator.:::switch->return->return
JavaTokenizer#scanOperator():::Read longest possible sequence of special characters and convert  to token.:::while->reader->putChar->newname->reader->name->tk1->tokens->lookupKind->if->break->reader->scanChar->if->isSpecial->break
JavaTokenizer#readToken():::Read token.:::pos->endPos->comments->try->while->switch->do->reader->scanChar->while->processWhiteSpace->break->reader->scanChar->processLineTerminator->break->reader->scanChar->if->reader->scanChar->processLineTerminator->break->scanIdent->break->reader->scanChar->if->reader->scanChar->skipIllegalUnderscores->scanNumber->else->if->checkSourceLevel->reader->scanChar->skipIllegalUnderscores->scanNumber->else->reader->putChar->if->savePos->do->reader->scanChar->while->if->reader->digit->lexError->scanNumber->break->scanNumber->break->reader->scanChar->if->reader->digit->reader->putChar->scanFractionAndSuffix->else->if->savePos->reader->putChar->reader->putChar->if->reader->scanChar->reader->putChar->else->lexError->else->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->if->do->reader->scanCommentChar->while->if->processComment->addComment->break->else->if->isEmpty->reader->scanChar->style->if->reader->scanCommentChar->if->else->while->if->reader->scanChar->if->break->else->reader->scanCommentChar->if->reader->scanChar->processComment->addComment->break->else->lexError->break->else->if->reader->scanChar->else->break->reader->scanChar->if->lexError->reader->scanChar->else->if->lexError->scanLitChar->if->reader->scanChar->else->lexError->break->reader->scanChar->while->scanLitChar->if->reader->scanChar->else->lexError->break->if->isSpecial->scanOperator->else->isJavaIdentifierStart->codePoint->if->else->reader->peekSurrogates->if->if->Character->isJavaIdentifierStart->reader->putChar->else->Character->isJavaIdentifierStart->if->scanIdent->else->if->reader->digit->scanNumber->else->if->else->arg->if->high->reader->scanChar->String->format->else->String->format->String->format->Errors->IllegalChar->lexError->reader->scanChar->break->switch->return->new->Token->return->new->NamedToken->return->reader->chars->new->StringToken->return->reader->chars->new->NumericToken->throw->new->AssertionError->catch->finally->if->reader->getRawCharacters->new->String->println
JavaTokenizer#addComment(List, Comment)::: java tokenizer add comment:::return->List->of->comments->prepend
JavaTokenizer#errPos():::Return the position where a lexical error occurred;:::return
JavaTokenizer#errPos(int):::Set the position where a lexical error occurred;:::
JavaTokenizer#processComment(int, int, CommentStyle):::Called when a complete comment has been scanned:::if->reader->getRawCharacters->new->String->println->buf->reader->getRawCharacters->return->new->UnicodeReader->new->BasicComment<>
JavaTokenizer#processWhiteSpace(int, int):::Called when a complete whitespace run has been scanned:::if->reader->getRawCharacters->new->String->println
JavaTokenizer#processLineTerminator(int, int):::Called when a line terminator has been processed.:::if->reader->getRawCharacters->new->String->println
JavaTokenizer#getLineMap():::Build a map for translating between line numbers and positions in the input.:::return->Position->reader->getRawCharacters->makeLineMap
JavaTokenizer.BasicComment#getText()::: basic comment get text:::return
JavaTokenizer.BasicComment#getSourcePos(int)::: basic comment get source pos:::return
JavaTokenizer.BasicComment#getStyle()::: basic comment get style:::return
JavaTokenizer.BasicComment#isDeprecated()::: basic comment is deprecated:::if->scanDocComment->return
JavaTokenizer.BasicComment#scanDocComment()::: basic comment scan doc comment:::try->deprecatedPrefix->while->while->comment_reader->scanCommentChar->while->comment_reader->scanCommentChar->if->return->while->comment_reader->scanCommentChar->if->deprecated->i->while->deprecated->charAt->comment_reader->scanCommentChar->if->deprecated->length->break->if->if->Character->isWhitespace->else->if->comment_reader->scanCommentChar->if->return->while->switch->comment_reader->scanCommentChar->if->return->break->comment_reader->scanCommentChar->if->continue->comment_reader->scanCommentChar->continue->comment_reader->scanCommentChar->return->catch->finally
LazyDocCommentTable#hasComment(JCTree)::: lazy doc comment table has comment:::return->table->containsKey
LazyDocCommentTable#getComment(JCTree)::: lazy doc comment table get comment:::e->table->get->return
LazyDocCommentTable#getCommentText(JCTree)::: lazy doc comment table get comment text:::c->getComment->return->c->getText
LazyDocCommentTable#getCommentTree(JCTree)::: lazy doc comment table get comment tree:::e->table->get->if->return->if->new->DocCommentParser->parse->return
LazyDocCommentTable#putComment(JCTree, Comment)::: lazy doc comment table put comment:::table->new->Entry->put
Lexer#nextToken():::Consume the next token.:::
Lexer#token():::Return current token.:::
Lexer#token(int):::Return token with given lookahead.:::
Lexer#prevToken():::Return the last character position of the previous token.:::
Lexer#split():::Splits the current token in two and return the first (splitted) token:::
Lexer#errPos():::Return the position where a lexical error occurred;:::
Lexer#errPos(int):::Set the position where a lexical error occurred;:::
Lexer#getLineMap():::Build a map for translating between line numbers and positions in the input.:::
Parser#parseCompilationUnit():::Parse a compilation unit.:::
Parser#parseExpression():::Parse an expression.:::
Parser#parseStatement():::Parse a statement.:::
Parser#parseType():::Parse a type.:::
ParserFactory#instance(Context)::: parser factory instance:::instance->context->get->if->new->ParserFactory->return
ParserFactory#newParser(CharSequence, boolean, boolean, boolean)::: parser factory new parser:::return->newParser
ParserFactory#newParser(CharSequence, boolean, boolean, boolean, boolean)::: parser factory new parser:::lexer->scannerFactory->newScanner->return->new->JavacParser
ReferenceParser#parse(String):::Parse a reference to an API element as may be found in doc comment.:::qualExpr->member->paramTypes->deferredDiagnosticHandler->new->Log.DeferredDiagnosticHandler->try->hash->sig->indexOf->lparen->sig->indexOf->if->if->parseType->else->sig->substring->parseMember->else->sig->substring->parseType->if->sig->substring->parseMember->else->sig->substring->parseMember->if->else->rparen->sig->indexOf->if->sig->length->throw->new->ParseException->sig->substring->parseParams->if->deferredDiagnosticHandler->getDiagnostics->isEmpty->throw->new->ParseException->catch->finally->popDiagnosticHandler->return->new->Reference
ReferenceParser#parseType(String)::: reference parser parse type:::p->fac->newParser->tree->p->parseType->if->p->token->throw->new->ParseException->return
ReferenceParser#parseMember(String)::: reference parser parse member:::p->fac->newParser->name->p->ident->if->p->token->throw->new->ParseException->return
ReferenceParser#parseParams(String)::: reference parser parse params:::if->s->trim->isEmpty->return->List->nil->p->fac->s->replace->newParser->paramTypes->new->ListBuffer<>->paramTypes->p->parseType->add->if->p->token->p->nextToken->while->p->token->p->nextToken->paramTypes->p->parseType->add->if->p->token->p->nextToken->if->p->token->throw->new->ParseException->return->paramTypes->toList
Scanner#token()::: scanner token:::return->token
Scanner#token(int)::: scanner token:::if->return->else->ensureLookahead->return->savedTokens->get
Scanner#ensureLookahead(int)::: scanner ensure lookahead:::for->i->savedTokens->size
Scanner#prevToken()::: scanner prev token:::return
Scanner#nextToken()::: scanner next token:::if->savedTokens->isEmpty->savedTokens->remove->else->tokenizer->readToken
Scanner#split()::: scanner split:::splitTokens->token->split->return
Scanner#getLineMap()::: scanner get line map:::return->tokenizer->getLineMap
Scanner#errPos()::: scanner err pos:::return->tokenizer->errPos
Scanner#errPos(int)::: scanner err pos:::tokenizer->errPos
ScannerFactory#instance(Context):::Get the Factory instance for this context.:::instance->context->get->if->new->ScannerFactory->return
ScannerFactory#newScanner(CharSequence, boolean)::: scanner factory new scanner:::if->buf->if->return->new->JavadocTokenizer->new->Scanner->else->return->new->Scanner->else->array->input->toString->toCharArray->return->newScanner
ScannerFactory#newScanner(char[], int, boolean)::: scanner factory new scanner:::if->return->new->JavadocTokenizer->new->Scanner->else->return->new->Scanner
Tokens#instance(Context)::: tokens instance:::instance->context->get->if->new->Tokens->return
Tokens#enterKeyword(String, TokenKind)::: tokens enter keyword:::n->names->fromString->token->ordinal->if->n->getIndex->n->getIndex
Tokens#lookupKind(Name):::Create a new token given a name; if the name corresponds to a token name, a new token of the corresponding kind is returned; otherwise, an identifier token is returned.:::return->name->getIndex->name->getIndex
Tokens#lookupKind(String)::: tokens lookup kind:::return->names->fromString->lookupKind
Tokens.Comment#getText()::: comment get text:::
Tokens.Comment#getSourcePos(int)::: comment get source pos:::
Tokens.Comment#getStyle()::: comment get style:::
Tokens.Comment#isDeprecated()::: comment is deprecated:::
Tokens.Token#split(Tokens)::: token split:::if->length->throw->new->AssertionError->t1->tokens->substring->lookupKind->t2->tokens->substring->lookupKind->if->throw->new->AssertionError->return->new->TokenArr->length->new->Token->length->new->Token
Tokens.Token#checkKind()::: token check kind:::if->throw->new->AssertionError
Tokens.Token#name()::: token name:::throw->new->UnsupportedOperationException
Tokens.Token#stringVal()::: token string val:::throw->new->UnsupportedOperationException
Tokens.Token#radix()::: token radix:::throw->new->UnsupportedOperationException
Tokens.Token#comment(Comment.CommentStyle):::Preserve classic semantics - if multiple javadocs are found on the token the last one is returned:::comments->getComments->return->comments->isEmpty
Tokens.Token#deprecatedFlag():::Preserve classic semantics - deprecated should be set if at least one javadoc comment attached to this token contains the '@deprecated' string:::foreach->getComments->if->c->isDeprecated->return->return
Tokens.Token#getComments(Comment.CommentStyle)::: token get comments:::if->return->List->nil->else->buf->new->ListBuffer<>->foreach->if->c->getStyle->buf->add->return->buf->toList
Tokens.NamedToken#checkKind()::: named token check kind:::if->throw->new->AssertionError
Tokens.NamedToken#name()::: named token name:::return
Tokens.StringToken#checkKind()::: string token check kind:::if->throw->new->AssertionError
Tokens.StringToken#stringVal()::: string token string val:::return
Tokens.NumericToken#checkKind()::: numeric token check kind:::if->throw->new->AssertionError
Tokens.NumericToken#radix()::: numeric token radix:::return
UnicodeReader#scanChar():::Read next character.:::if->if->convertUnicode
UnicodeReader#scanCommentChar():::Read next character in comment, skipping over double '\' characters.:::scanChar->if->if->peekChar->isUnicode->skipChar->else->convertUnicode
UnicodeReader#putChar(char, boolean):::Append a character to sbuf.:::ArrayUtils->ensureCapacity->if->scanChar
UnicodeReader#putChar(char)::: unicode reader put char:::putChar
UnicodeReader#putChar(boolean)::: unicode reader put char:::putChar
UnicodeReader#name()::: unicode reader name:::return->names->fromChars
UnicodeReader#chars()::: unicode reader chars:::return->new->String
UnicodeReader#convertUnicode():::Convert unicode escape; bp points to initial '\' character  (Spec 3.3).:::if->if->do->while->limit->if->d->digit->code->while->digit->if->return->log->error->else
UnicodeReader#surrogatesSupported()::: unicode reader surrogates supported:::try->Character->isHighSurrogate->return->catch->return->finally
UnicodeReader#peekSurrogates():::Scan surrogate pairs:::if->Character->isHighSurrogate->high->prevBP->scanChar->low->if->Character->isLowSurrogate->return->Character->toCodePoint->return
UnicodeReader#digit(int, int):::Convert an ASCII digit from its base (8, 10, or 16)  to its value.:::c->if->return->Character->digit->codePoint->peekSurrogates->result->Character->digit->Character->digit->if->log->error->if->scanChar->charAt->return
UnicodeReader#isUnicode()::: unicode reader is unicode:::return
UnicodeReader#skipChar()::: unicode reader skip char:::
UnicodeReader#peekChar()::: unicode reader peek char:::return
UnicodeReader#getRawCharacters():::Returns a copy of the input buffer, up to its inputLength:::chars->new->charArr->System->arraycopy->return
UnicodeReader#getRawCharacters(int, int):::Returns a copy of a character array subset of the input buffer:::length->chars->new->charArr->System->arraycopy->return
