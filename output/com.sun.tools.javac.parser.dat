DocCommentParser#blockContent(Phase):::Read block content, consisting of text, html and inline tags:::trees->new->ListBuffer<>->while->switch->nextChar->break->entity->break->if->switch->if->peek->trees->html->add->if->break->break->if->peek->addPendingText->break->break->addPendingText->trees->html->add->if->break->if->break->addPendingText->trees->m->at->newString->newErroneousTree->add->nextChar->if->break->inlineTag->break->if->addPendingText->break->if->nextChar->if->addPendingText->return->trees->toList
DocCommentParser#blockTags():::Read a series of block tags, including their content:::tags->new->ListBuffer<>->while->tags->blockTag->add->return->tags->toList
DocCommentParser#blockTag():::Read a single block tag, including its content:::p->try->nextChar->if->isIdentifierStart->name->readTagName->tp->tagParsers->get->if->content->blockContent->return->m->at->newUnknownBlockTagTree->else->switch->tp->getKind->return->tp->parse->return->erroneous->blockContent->return->erroneous->catch->blockContent->return->e->getMessage->erroneous->finally
DocCommentParser#inlineTag():::Read a single inline tag, including its content:::p->try->nextChar->if->isIdentifierStart->name->readTagName->tp->tagParsers->get->if->skipWhitespace->text->inlineText->if->nextChar->return->m->at->List->of->newUnknownInlineTagTree->setEndPos->else->if->skipWhitespace->if->tp->getKind->tree->tp->parse->if->return->tree->setEndPos->else->inlineText->nextChar->return->erroneous->catch->return->e->getMessage->erroneous->finally
DocCommentParser#identifier():::Read Java identifier Matching pairs of { } are skipped; the text is terminated by the first unmatched }:::skipWhitespace->pos->if->isJavaIdentifierStart->name->readJavaIdentifier->return->m->at->newIdentifierTree->throw->new->ParseException
DocCommentParser#quotedString():::Read a quoted string:::pos->nextChar->while->switch->break->break->nextChar->return->m->at->newString->newTextTree->if->break->nextChar->return
DocCommentParser#inlineWord():::Read a term ie:::pos->depth->while->switch->return->m->at->newString->newTextTree->if->break->break->if->return->m->at->newString->newTextTree->break->nextChar->return
DocCommentParser#entity():::Read an HTML entity:::p->nextChar->name->if->namep->nextChar->if->isDecimalDigit->nextChar->while->isDecimalDigit->nextChar->names->fromChars->else->if->nextChar->if->isHexDigit->nextChar->while->isHexDigit->nextChar->names->fromChars->else->if->isIdentifierStart->readIdentifier->if->return->erroneous->else->if->return->erroneous->nextChar->return->m->at->newEntityTree
DocCommentParser#htmlAttrs():::Read a series of HTML attributes, terminated by > :::attrs->new->ListBuffer<>->skipWhitespace->while->isIdentifierStart->namePos->name->readAttributeName->skipWhitespace->value->vkind->if->v->new->ListBuffer<>->nextChar->skipWhitespace->if->quote->nextChar->while->if->attrs->erroneous->add->break->attrValueChar->addPendingText->nextChar->else->while->isUnquotedAttrValueTerminator->attrValueChar->addPendingText->skipWhitespace->v->toList->attr->m->at->newAttributeTree->attrs->add->return->attrs->toList
JavacParser#skip(boolean, boolean, boolean, boolean):::Skip forward until a suitable stop token is found.:::while->switch->nextToken->return->return->if->return->break->if->return->break->if->return->break->if->return->break->if->return->break->nextToken
JavacParser#reportSyntaxError(int, Error):::Report a syntax using the given the position parameter and arguments, unless one was already reported at the same position.:::diag->new->JCDiagnostic.SimpleDiagnosticPosition->reportSyntaxError
JavacParser#reportSyntaxError(JCDiagnostic.DiagnosticPosition, Error):::Report a syntax error using the given DiagnosticPosition object and arguments, unless one was already reported at the same position.:::pos->diagPos->getPreferredPosition->if->S->errPos->if->log->error->else->log->error->S->errPos->if->Assert->check->else
JavacParser#accept(TokenKind):::If next input token matches given token, skip it, otherwise report  an error.:::if->nextToken->else->setErrorEndPos->S->prevToken->Errors->Expected->reportSyntaxError
JavacParser#illegal(int):::Report an illegal start of expression/type error at given position.:::setErrorEndPos->if->return->syntaxError->else->return->syntaxError
JavacParser#illegal():::Report an illegal start of expression/type error at current position.:::return->illegal
JavacParser#checkNoMods(long):::Diagnose a modifier flag from the set, if any.:::if->lowestMod->log->Errors->Flags->asFlagSet->ModNotAllowedHere->error
JavacParser#attach(JCTree, Comment):::Make an entry into docComments hashtable,  provided flag keepDocComments is set and given doc comment is non-null.:::if->docComments->putComment
JavacParser#getStartPos(JCTree):::Get the start position for a tree node:::return->TreeInfo->getStartPos
JavacParser#getEndPos(JCTree):::Get the end position for a tree node:::return->endPosTable->getEndPos
JavacParser#ident():::Ident = IDENTIFIER:::return->ident
JavacParser#qualident(boolean):::Qualident = Ident { DOT [Annotations] Ident }:::t->F->at->ident->Ident->toP->while->pos->nextToken->tyannos->if->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->return
JavacParser#literal(Name, int):::Literal =     INTLITERAL   | LONGLITERAL   | FLOATLITERAL   | DOUBLELITERAL   | CHARLITERAL   | STRINGLITERAL   | TRUE   | FALSE   | NULL:::t->switch->try->F->at->Convert->strval->token->radix->string2int->Literal->catch->log->Errors->strval->IntNumberTooLarge->error->finally->break->try->F->at->Long->Convert->strval->token->radix->string2long->valueOf->Literal->catch->log->Errors->strval->IntNumberTooLarge->error->finally->break->proper->token->radix->token->stringVal->token->stringVal->n->try->Float->valueOf->catch->finally->if->n->floatValue->isZero->log->error->else->if->n->floatValue->log->error->else->F->at->Literal->break->proper->token->radix->token->stringVal->token->stringVal->n->try->Double->valueOf->catch->finally->if->n->doubleValue->isZero->log->error->else->if->n->doubleValue->log->error->else->F->at->Literal->break->F->at->token->stringVal->charAt->Literal->break->F->at->token->stringVal->Literal->break->F->at->Literal->break->F->at->Literal->break->Assert->error->if->F->at->Erroneous->storeEnd->nextToken->return
JavacParser#parseExpression():::terms can be either expressions or types.:::return->term
JavacParser#parseType():::parses (optional) type annotations followed by a type:::return->parseType
JavacParser#term()::: Expression = Expression1 [ExpressionRest]  ExpressionRest = [AssignmentOperator Expression1]  AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" |                       "&=" | "|=" | "^=" |                       "%=" | "<<=" | ">>=" | ">>>="  Type = Type1  TypeNoParams = TypeNoParams1  StatementExpression = Expression  ConstantExpression = Expression  :::t->term1->if->PLUSEQ->compareTo->compareTo->return->termRest->else->return
JavacParser#term1():::Expression1   = Expression2 [Expression1Rest]  Type1         = Type2  TypeNoParams1 = TypeNoParams2:::t->term2->if->return->term1Rest->else->return
JavacParser#term1Rest(JCExpression):::Expression1Rest = ["?" Expression ":" Expression1]:::if->pos->nextToken->t1->term->accept->t2->term1->return->F->at->Conditional->else->return
JavacParser#term2():::Expression2   = Expression3 [Expression2Rest]  Type2         = Type3  TypeNoParams2 = TypeNoParams3:::t->term3->if->prec->return->term2Rest->else->return
JavacParser#foldStrings(JCExpression):::If tree is a concatenation of string literals, replace it  by a single literal representing the concatenated string.:::if->return->opStack->new->ListBuffer<>->litBuf->new->ListBuffer<>->needsFolding->curr->while->if->curr->hasTag->op->foldIfNeeded->else->foldIfNeeded->break->if->ops->opStack->toList->res->foreach->F->op->getStartPosition->at->optag->Binary->getEndPos->storeEnd->return->else->return
JavacParser#term3()::: Expression3    = PrefixOp Expression3                 | "(" Expr | TypeNoParams ")" Expression3                 | Primary {Selector} {PostfixOp}   Primary        = "(" Expression ")"                 | Literal                 | [TypeArguments] THIS [Arguments]                 | [TypeArguments] SUPER SuperSuffix                 | NEW [TypeArguments] Creator                 | "(" Arguments ")" "->" ( Expression | Block )                 | Ident "->" ( Expression | Block )                 | [Annotations] Ident { "." [Annotations] Ident                  | Expression3 MemberReferenceSuffix                   [ [Annotations] "[" ( "]" BracketsOpt "." CLASS | Expression "]" )                   | Arguments                   | "." ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )                   ]                 | BasicType BracketsOpt "." CLASS  }   PrefixOp       = "++" | "--" | "!" | "~" | "+" | "-"  PostfixOp      = "++" | "--"  Type3          = Ident { "." Ident } [TypeArguments] {TypeSelector} BracketsOpt                 | BasicType  TypeNoParams3  = Ident { "." Ident } BracketsOpt  Selector       = "." [TypeArguments] Ident [Arguments]                 | "." THIS                 | "." [TypeArguments] SUPER SuperSuffix                 | "." NEW [TypeArguments] InnerCreator                 | "[" Expression "]"  TypeSelector   = "." Ident [TypeArguments]  SuperSuffix    = Arguments | "." Ident [Arguments]:::pos->t->typeArgs->typeArgumentsOpt->switch->if->return->typeArgument->else->return->illegal->if->tk->nextToken->if->token->radix->literal->else->term3->return->F->at->unoptag->Unary->else->return->illegal->break->if->pres->analyzeParens->switch->accept->pos1->targets->List->parseType->of->while->checkSourceLevel->accept->targets->parseType->prepend->if->targets->length->F->at->targets->reverse->TypeIntersection->toP->accept->t1->term3->return->F->at->TypeCast->lambdaExpressionOrStatement->break->accept->term3->term2Rest->term1Rest->termRest->accept->F->at->Parens->toP->break->else->return->illegal->break->if->F->at->Ident->to->nextToken->if->argumentsOpt->else->arguments->else->return->illegal->break->if->F->at->Ident->to->superSuffix->else->return->illegal->break->if->literal->else->return->illegal->break->if->return->illegal->if->nextToken->if->typeArguments->creator->else->return->illegal->break->typeAnnos->typeAnnotationsOpt->if->typeAnnos->isEmpty->throw->new->AssertionError->expr->term3->if->switch->expr->getTag->mref->F->at->AnnotatedType->toP->break->sel->if->return->illegal->else->log->error->return->return->illegal->else->insertAnnotationsToMostInner->break->if->return->illegal->if->peekToken->lambdaExpressionOrStatement->else->F->at->ident->Ident->toP->while->annos->typeAnnotationsOpt->if->annos->isEmpty->return->illegal->switch->nextToken->if->nextToken->bracketsOpt->F->at->TypeArray->toP->if->annos->nonEmpty->F->at->AnnotatedType->toP->bracketsSuffix->else->if->t1->term->if->annos->isEmpty->illegal->F->at->Indexed->to->accept->break->if->arguments->if->annos->isEmpty->illegal->break->nextToken->if->return->illegal->oldmode->typeArgumentsOpt->if->switch->if->return->illegal->F->at->Select->to->nextToken->break->if->return->illegal->F->at->Select->to->nextToken->break->F->at->Select->to->superSuffix->break->if->return->illegal->pos1->nextToken->if->typeArguments->innerCreator->break->tyannos->if->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->break->if->else->if->annos->nonEmpty->illegal->break->if->isUnboundMemberRef->pos1->accept->args->new->ListBuffer<>->args->typeArgument->append->while->nextToken->args->typeArgument->append->accept->F->at->args->toList->TypeApply->toP->while->nextToken->F->at->ident->Select->toP->typeArgumentsOpt->bracketsOpt->if->illegal->return->term3Rest->break->break->if->illegal->typeArgumentsOpt->break->if->illegal->basicType->bracketsOpt->bracketsSuffix->break->if->illegal->if->nextToken->if->ti->F->at->TypeIdent->toP->bracketsSuffix->else->return->illegal->else->ti->F->at->TypeIdent->to->nextToken->return->break->return->illegal->return->term3Rest
JavacParser#isUnboundMemberRef():::If we see an identifier followed by a '&lt;' it could be an unbound method reference or a binary expression:::pos->depth->for->t->S->token->S->token
JavacParser#analyzeParens():::If we see an identifier followed by a '&lt;' it could be an unbound method reference or a binary expression:::depth->type->for->lookahead
JavacParser#superSuffix(List, JCExpression):::SuperSuffix = Arguments | "." [TypeArguments] Ident [Arguments]:::nextToken->if->arguments->else->if->if->return->illegal->memberReferenceSuffix->else->pos->accept->typeArguments->F->at->ident->Select->toP->argumentsOpt->return
JavacParser#basicType():::BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN:::t->F->at->typetag->TypeIdent->to->nextToken->return
JavacParser#argumentsOpt(List, JCExpression):::ArgumentsOpt = [ Arguments ]:::if->return->arguments->else->return
JavacParser#arguments():::Arguments = "(" [Expression { COMMA Expression }] ")":::args->new->ListBuffer<>->if->nextToken->if->args->parseExpression->append->while->nextToken->args->parseExpression->append->accept->else->Errors->Expected->syntaxError->return->args->toList
JavacParser#typeArgumentsOpt(JCExpression)::: TypeArgumentsOpt = [ TypeArguments ]:::if->return->typeArguments->else->return
JavacParser#typeArguments(boolean)::: TypeArguments  = "<" TypeArgument {"," TypeArgument ">"  }:::if->nextToken->if->checkSourceLevel->nextToken->return->List->nil->else->args->new->ListBuffer<>->args->typeArgument->parseType->append->while->nextToken->args->typeArgument->parseType->append->switch->S->split->break->nextToken->break->args->Errors->Expected->syntaxError->append->break->return->args->toList->else->return->List->Errors->Expected->syntaxError->of
JavacParser#typeArgument()::: TypeArgument = Type               | [Annotations] "?"               | [Annotations] "?" EXTENDS Type {"&" Type               | [Annotations] "?" SUPER Type  }:::annotations->typeAnnotationsOpt->if->return->parseType->pos->nextToken->result->if->t->F->at->TypeBoundKind->to->nextToken->bound->parseType->F->at->Wildcard->else->if->t->F->at->TypeBoundKind->to->nextToken->bound->parseType->F->at->Wildcard->else->if->LAX_IDENTIFIER->accepts->t->F->at->TypeBoundKind->wc->F->at->Wildcard->toP->id->F->at->ident->Ident->toP->err->F->at->List->of->Erroneous->Errors->Expected3->reportSyntaxError->else->t->F->at->TypeBoundKind->toP->F->at->Wildcard->toP->if->annotations->isEmpty->F->at->AnnotatedType->toP->return
JavacParser#bracketsSuffix(JCExpression):::BracketsSuffixExpr = "." CLASS  BracketsSuffixType =:::if->pos->nextToken->accept->if->name->if->LAX_IDENTIFIER->accepts->token->name->nextToken->else->F->at->List->F->at->Select->toP->of->Erroneous->else->tag->t->getTag->if->TreeInfo->containsTypeAnnotation->syntaxError->F->at->Select->toP->else->if->if->else->if->syntaxError->return
JavacParser#memberReferenceSuffix(JCExpression):::MemberReferenceSuffix = "::" [TypeArguments] Ident                       | "::" [TypeArguments] "new":::pos1->accept->return->memberReferenceSuffix
JavacParser#creator(int, List):::Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest ):::newAnnotations->typeAnnotationsOpt->switch->if->if->newAnnotations->isEmpty->return->basicType->arrayCreatorRest->else->return->F->at->basicType->AnnotatedType->toP->arrayCreatorRest->break->t->qualident->oldmode->diamondFound->lastTypeargsPos->if->typeArguments->while->if->illegal->pos->nextToken->tyannos->typeAnnotationsOpt->F->at->ident->Select->toP->if->tyannos->nonEmpty->F->at->AnnotatedType->toP->if->typeArguments->if->if->newAnnotations->nonEmpty->insertAnnotationsToMostInner->e->arrayCreatorRest->if->reportSyntaxError->return->F->at->List->of->Erroneous->toP->else->if->pos->if->typeArgs->isEmpty->S->prevToken->setErrorEndPos->err->F->at->typeArgs->prepend->Erroneous->reportSyntaxError->return->toP->return->else->if->newClass->classCreatorRest->if->if->newAnnotations->nonEmpty->earlier->else->if->newAnnotations->nonEmpty->insertAnnotationsToMostInner->return->else->setErrorEndPos->Errors->Expected2->reportSyntaxError->F->at->List->nil->NewClass->toP->return->F->at->List->of->Erroneous->toP
JavacParser#innerCreator(int, List, JCExpression):::InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest:::newAnnotations->typeAnnotationsOpt->t->F->at->ident->Ident->toP->if->newAnnotations->nonEmpty->F->at->AnnotatedType->toP->if->oldmode->typeArguments->return->classCreatorRest
JavacParser#arrayCreatorRest(int, JCExpression):::ArrayCreatorRest = [Annotations] "[" ( "]" BracketsOpt ArrayInitializer                         | Expression "]" {[Annotations]  "[" Expression "]"} BracketsOpt ):::annos->typeAnnotationsOpt->accept->if->accept->bracketsOpt->if->na->arrayInitializer->if->annos->nonEmpty->annotated->return->else->t->F->at->List->nil->NewArray->toP->return->List->of->syntaxError->else->dims->new->ListBuffer<>->dimAnnotations->new->ListBuffer<>->dimAnnotations->append->dims->parseExpression->append->accept->while->maybeDimAnnos->typeAnnotationsOpt->pos->nextToken->if->bracketsOptCont->else->if->bracketsOptCont->else->dimAnnotations->append->dims->parseExpression->append->accept->elems->errpos->if->arrayInitializerElements->na->F->at->dims->toList->NewArray->toP->dimAnnotations->toList->if->return->List->of->syntaxError->return
JavacParser#classCreatorRest(int, JCExpression, List, JCExpression):::ClassCreatorRest = Arguments [ClassBody]:::args->arguments->body->if->pos->defs->classOrInterfaceBody->mods->F->at->Modifiers->F->at->AnonymousClassDef->toP->return->F->at->NewClass->toP
JavacParser#arrayInitializer(int, JCExpression):::ArrayInitializer = "{" [VariableInitializer {"," VariableInitializer}] [","] "}":::elems->arrayInitializerElements->return->F->at->List->nil->NewArray->toP
JavacParser#variableInitializer():::VariableInitializer = ArrayInitializer | Expression:::return->arrayInitializer->parseExpression
JavacParser#parExpression():::ParExpression = "(" Expression ")":::pos->accept->t->parseExpression->accept->return->F->at->Parens->toP
JavacParser#block(int, long):::Block = "{" BlockStatements "}":::accept->stats->blockStatements->t->F->at->Block->while->Errors->Orphaned->syntaxError->switchBlockStatementGroups->accept->return->toP
JavacParser#blockStatements():::BlockStatements = { BlockStatement }  BlockStatement  = LocalVariableDeclarationStatement                  | ClassOrInterfaceOrEnumDeclaration                  | [Ident ":"] Statement  LocalVariableDeclarationStatement                  = { FINAL | '@' Annotation } Type VariableDeclarators ";":::lastErrPos->stats->new->ListBuffer<>->while->stat->blockStatement->if->stat->isEmpty->return->stats->toList->else->if->return->stats->toList->if->skip->stats->addAll
JavacParser#blockStatement():::This method parses a statement appearing inside a block.:::pos->switch->return->List->nil->return->List->parseSimpleStatement->of->dc->token->comment->mods->modifiersOpt->if->return->List->classOrInterfaceOrEnumDeclaration->of->else->t->parseType->return->localVariableDeclarations->dc->token->comment->mods->modifiersOpt->return->List->classOrInterfaceOrEnumDeclaration->of->dc->token->comment->return->List->modifiersOpt->classOrInterfaceOrEnumDeclaration->of->log->error->token->comment->return->List->modifiersOpt->classOrInterfaceOrEnumDeclaration->of->prevToken->t->term->if->t->hasTag->nextToken->stat->parseStatementAsBlock->return->List->F->at->prevToken->name->Labelled->of->else->if->LAX_IDENTIFIER->accepts->mods->F->at->Modifiers->F->at->return->localVariableDeclarations->else->checkExprStat->accept->expr->F->at->Exec->toP->return->List->of
JavacParser#parseSimpleStatement():::Statement =       Block     | IF ParExpression Statement [ELSE Statement]     | FOR "(" ForInitOpt ";" [Expression] ";" ForUpdateOpt ")" Statement     | FOR "(" FormalParameter : Expression ")" Statement     | WHILE ParExpression Statement     | DO Statement WHILE ParExpression ";"     | TRY Block ( Catches | [Catches] FinallyPart )     | TRY "(" ResourceSpecification ";"opt ")" Block [Catches] [FinallyPart]     | SWITCH ParExpression "{" SwitchBlockStatementGroups "}"     | SYNCHRONIZED ParExpression Block     | RETURN [Expression] ";"     | THROW Expression ";"     | BREAK [Ident] ";"     | CONTINUE [Ident] ";"     | ASSERT Expression [ ":" Expression ] ";"     | ";":::pos->switch->return->block->nextToken->cond->parExpression->thenpart->parseStatementAsBlock->elsepart->if->nextToken->parseStatementAsBlock->return->F->at->If->nextToken->accept->inits->List->nil->forInit->if->inits->length->hasTag->var->accept->expr->parseExpression->accept->body->parseStatementAsBlock->return->F->at->ForeachLoop->else->accept->cond->parseExpression->accept->steps->List->nil->forUpdate->accept->body->parseStatementAsBlock->return->F->at->ForLoop->nextToken->cond->parExpression->body->parseStatementAsBlock->return->F->at->WhileLoop->nextToken->body->parseStatementAsBlock->accept->cond->parExpression->accept->t->F->at->DoLoop->toP->return->nextToken->resources->List->nil->if->checkSourceLevel->nextToken->resources->accept->body->block->catchers->new->ListBuffer<>->finalizer->if->while->catchers->catchClause->append->if->nextToken->block->else->if->resources->isEmpty->if->allowedInSource->log->error->else->log->error->return->F->at->catchers->toList->Try->nextToken->selector->parExpression->accept->cases->switchBlockStatementGroups->t->F->at->Switch->to->accept->return->nextToken->lock->parExpression->body->block->return->F->at->Synchronized->nextToken->result->parseExpression->accept->t->F->at->Return->toP->return->nextToken->exc->parseExpression->accept->t->F->at->Throw->toP->return->nextToken->label->LAX_IDENTIFIER->accepts->ident->accept->t->F->at->Break->toP->return->nextToken->label->LAX_IDENTIFIER->accepts->ident->accept->t->F->at->Continue->toP->return->nextToken->return->F->at->Skip->toP->elsePos->nextToken->return->doRecover->finallyPos->nextToken->return->doRecover->return->doRecover->nextToken->assertion->parseExpression->message->if->nextToken->parseExpression->accept->t->F->at->Assert->toP->return->Assert->error->return
JavacParser#catchClause():::CatchClause     = CATCH "(" FormalParameter ")" Block TODO: the "FormalParameter" is not correct, it uses the special "catchTypes" rule below.:::pos->accept->accept->mods->optFinal->catchTypes->catchTypes->paramType->catchTypes->size->F->getStartPosition->at->TypeUnion->toP->formal->variableDeclaratorId->accept->body->block->return->F->at->Catch
JavacParser#switchBlockStatementGroups():::SwitchBlockStatementGroups = { SwitchBlockStatementGroup }  SwitchBlockStatementGroup = SwitchLabel BlockStatements  SwitchLabel = CASE ConstantExpression ":" | DEFAULT ":":::cases->new->ListBuffer<>->while->pos->switch->cases->switchBlockStatementGroup->append->break->return->cases->toList->nextToken->Errors->Expected3->syntaxError
JavacParser#moreStatementExpressions(int, JCExpression, T):::MoreStatementExpressions = { COMMA StatementExpression }:::stats->F->at->checkExprStat->Exec->toP->append->while->nextToken->t->parseExpression->stats->F->at->checkExprStat->Exec->toP->append->return
JavacParser#forInit():::ForInit = StatementExpression MoreStatementExpressions           |  { FINAL | '@' Annotation } Type VariableDeclarators:::stats->new->ListBuffer<>->pos->if->return->optFinal->parseType->variableDeclarators->toList->else->t->term->if->LAX_IDENTIFIER->accepts->return->modifiersOpt->variableDeclarators->toList->else->if->log->Errors->BadInitializer->error->return->List->F->at->modifiersOpt->VarDef->of->else->return->moreStatementExpressions->toList
JavacParser#forUpdate():::ForUpdate = StatementExpression MoreStatementExpressions:::return->parseExpression->new->ListBuffer<JCExpressionStatement>->moreStatementExpressions->toList
JavacParser#annotationsOpt(Tag):::AnnotationsOpt = { '@' Annotation }:::if->return->List->nil->buf->new->ListBuffer<>->prevmode->while->pos->nextToken->buf->annotation->append->annotations->buf->toList->return
JavacParser#modifiersOpt():::ModifiersOpt = { Modifier }  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | "@"           | "@" Annotation:::return->modifiersOpt
JavacParser#annotation(int, Tag):::Annotation              = "@" Qualident [ "(" AnnotationFieldValues ")" ]:::if->checkSourceLevel->ident->qualident->fieldValues->annotationFieldValuesOpt->ann->if->F->at->Annotation->else->if->F->at->TypeAnnotation->else->throw->new->AssertionError->S->prevToken->storeEnd->return
JavacParser#annotationFieldValues():::AnnotationFieldValues   = "(" [ AnnotationFieldValue { "," AnnotationFieldValue } ] ")":::accept->buf->new->ListBuffer<>->if->buf->annotationFieldValue->append->while->nextToken->buf->annotationFieldValue->append->accept->return->buf->toList
JavacParser#annotationFieldValue():::AnnotationFieldValue    = AnnotationValue                          | Identifier "=" AnnotationValue:::if->LAX_IDENTIFIER->accepts->t1->term1->if->t1->hasTag->pos->accept->v->annotationValue->return->F->at->Assign->toP->else->return->return->annotationValue
JavacParser#variableDeclarators(JCModifiers, JCExpression, T, boolean):::VariableDeclarators = VariableDeclarator { "," VariableDeclarator }:::return->ident->variableDeclaratorsRest
JavacParser#variableDeclaratorsRest(int, JCModifiers, JCExpression, Name, boolean, Comment, T, boolean):::VariableDeclaratorsRest = VariableDeclaratorRest { "," VariableDeclarator }  ConstantDeclaratorsRest = ConstantDeclaratorRest { "," ConstantDeclarator }:::head->variableDeclaratorRest->vdefs->append->while->vdefs->last->storeEnd->nextToken->vdefs->variableDeclarator->append->return
JavacParser#variableDeclarator(JCModifiers, JCExpression, boolean, Comment, boolean):::VariableDeclarator = Ident VariableDeclaratorRest  ConstantDeclarator = Ident ConstantDeclaratorRest:::return->ident->variableDeclaratorRest
JavacParser#variableDeclaratorRest(int, JCModifiers, JCExpression, Name, boolean, Comment, boolean, boolean):::VariableDeclaratorRest = BracketsOpt ["=" VariableInitializer]  ConstantDeclaratorRest = BracketsOpt "=" VariableInitializer:::bracketsOpt->init->if->nextToken->variableInitializer->else->if->Errors->Expected->syntaxError->elemType->TreeInfo->innermostType->startPos->if->elemType->hasTag->typeName->if->isRestrictedLocalVarTypeName->if->reportSyntaxError->else->if->type->hasTag->reportSyntaxError->else->TreeInfo->getStartPos->if->TreeInfo->getStartPos->result->F->at->VarDef->toP->attach->return
JavacParser#variableDeclaratorId(JCModifiers, JCExpression):::VariableDeclaratorId = Ident BracketsOpt:::return->variableDeclaratorId
JavacParser#resources():::Resources = Resource { ";" Resources }:::defs->new->ListBuffer<>->defs->resource->append->while->defs->last->storeEnd->semiColonPos->nextToken->if->break->defs->resource->append->return->defs->toList
JavacParser#resource():::Resource = VariableModifiersOpt Type VariableDeclaratorId "=" Expression           | Expression:::startPos->if->mods->optFinal->t->parseType->return->ident->variableDeclaratorRest->t->term->if->LAX_IDENTIFIER->accepts->mods->F->at->Modifiers->toP->return->ident->variableDeclaratorRest->else->checkSourceLevel->if->t->hasTag->t->hasTag->log->t->pos->error->return
JavacParser#parseCompilationUnit():::CompilationUnit = [ { "@" Annotation } PACKAGE Qualident ";"] {ImportDeclaration} {TypeDeclaration}:::firstToken->mods->consumedToplevelDoc->seenImport->seenPackage->defs->new->ListBuffer<>->if->modifiersOpt->if->packagePos->annotations->List->nil->if->checkNoMods->nextToken->pid->qualident->accept->pd->F->at->PackageDecl->toP->firstToken->comment->attach->defs->append->checkForImports->firstTypeDecl->while->if->skip->if->break->if->defs->importDeclaration->append->else->docComment->token->comment->if->firstToken->comment->if->modifiersOpt->if->kind->if->token->name->nextToken->if->token->name->if->checkNoMods->defs->moduleDecl->append->break->else->if->reportSyntaxError->def->typeDeclaration->if->defs->append->if->toplevel->F->at->defs->toList->TopLevel->if->firstToken->comment->attach->if->defs->isEmpty->S->prevToken->storeEnd->if->if->S->getLineMap->setParser->return
JavacParser#importDeclaration():::ImportDeclaration = IMPORT [ STATIC ] Ident { "." Ident } [ "." "*" ] ";":::pos->nextToken->importStatic->if->nextToken->pid->F->at->ident->Ident->toP->do->pos1->accept->if->F->at->Select->to->nextToken->break->else->F->at->ident->Select->toP->while->accept->return->F->at->Import->toP
JavacParser#typeDeclaration(JCModifiers, Comment):::TypeDeclaration = ClassOrInterfaceOrEnumDeclaration                  | ";":::pos->if->nextToken->return->F->at->Skip->toP->else->return->modifiersOpt->classOrInterfaceOrEnumDeclaration
JavacParser#classOrInterfaceOrEnumDeclaration(JCModifiers, Comment):::ClassOrInterfaceOrEnumDeclaration = ModifiersOpt           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration):::if->return->classDeclaration->else->if->return->interfaceDeclaration->else->if->return->enumDeclaration->else->pos->errs->if->LAX_IDENTIFIER->accepts->List->F->at->ident->Ident->toP->of->setErrorEndPos->else->List->of->erroneousTree->if->syntaxError->else->Errors->Expected3->syntaxError->return->F->Exec->toP
JavacParser#classDeclaration(JCModifiers, Comment):::ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]                     [IMPLEMENTS TypeList] ClassBody:::pos->accept->name->typeName->typarams->typeParametersOpt->extending->if->nextToken->parseType->implementing->List->nil->if->nextToken->typeList->defs->classOrInterfaceBody->result->F->at->ClassDef->toP->attach->return
JavacParser#interfaceDeclaration(JCModifiers, Comment):::InterfaceDeclaration = INTERFACE Ident TypeParametersOpt                         [EXTENDS TypeList] InterfaceBody:::pos->accept->name->typeName->typarams->typeParametersOpt->extending->List->nil->if->nextToken->typeList->defs->classOrInterfaceBody->result->F->at->ClassDef->toP->attach->return
JavacParser#enumDeclaration(JCModifiers, Comment):::EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody:::pos->accept->name->typeName->implementing->List->nil->if->nextToken->typeList->defs->enumBody->result->F->at->List->nil->ClassDef->toP->attach->return
JavacParser#enumBody(Name):::EnumBody = "{" { EnumeratorDeclarationList } [","]                  [ ";" {ClassBodyDeclaration} ] "}":::accept->defs->new->ListBuffer<>->if->nextToken->else->if->defs->enumeratorDeclaration->append->while->nextToken->if->break->defs->enumeratorDeclaration->append->if->defs->Errors->Expected3->syntaxError->append->nextToken->if->nextToken->while->defs->classOrInterfaceBodyDeclaration->appendList->if->skip->accept->return->defs->toList
JavacParser#enumeratorDeclaration(Name):::EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ "{" ClassBody "}" ]:::dc->token->comment->flags->if->token->deprecatedFlag->pos->annotations->annotationsOpt->mods->F->annotations->isEmpty->at->Modifiers->typeArgs->typeArgumentsOpt->identPos->name->ident->createPos->args->arguments->List->nil->body->if->mods1->F->at->Modifiers->defs->classOrInterfaceBody->F->at->AnonymousClassDef->toP->if->args->isEmpty->ident->F->at->Ident->create->F->at->NewClass->if->S->prevToken->storeEnd->F->at->Ident->result->F->at->VarDef->toP->attach->return
JavacParser#typeList():::TypeList = Type {"," Type}:::ts->new->ListBuffer<>->ts->parseType->append->while->nextToken->ts->parseType->append->return->ts->toList
JavacParser#classOrInterfaceBody(Name, boolean):::ClassBody     = "{" {ClassBodyDeclaration} "}"  InterfaceBody = "{" {InterfaceBodyDeclaration} "}":::accept->if->skip->if->nextToken->defs->new->ListBuffer<>->while->defs->classOrInterfaceBodyDeclaration->appendList->if->skip->accept->return->defs->toList
JavacParser#classOrInterfaceBodyDeclaration(Name, boolean):::ClassBodyDeclaration =      ";"    | [STATIC] Block    | ModifiersOpt      ( Type Ident        ( VariableDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident VoidMethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | Ident ConstructorDeclaratorRest      | TypeParameters Ident ConstructorDeclaratorRest      | ClassOrInterfaceOrEnumDeclaration      )  InterfaceBodyDeclaration =      ";"    | ModifiersOpt      ( Type Ident        ( ConstantDeclaratorsRest ";" | MethodDeclaratorRest )      | VOID Ident MethodDeclaratorRest      | TypeParameters [Annotations]        ( Type Ident MethodDeclaratorRest        | VOID Ident VoidMethodDeclaratorRest        )      | ClassOrInterfaceOrEnumDeclaration      ):::if->nextToken->return->List->nil->else->dc->token->comment->pos->mods->modifiersOpt->if->return->List->classOrInterfaceOrEnumDeclaration->of->else->if->isEmpty->if->log->error->return->List->block->of->else->typarams->typeParametersOpt->if->typarams->nonEmpty->storeEnd->annosAfterParams->annotationsOpt->if->annosAfterParams->nonEmpty->checkSourceLevel->appendList->if->tk->type->isVoid->if->F->at->TypeIdent->to->nextToken->else->unannotatedType->if->type->hasTag->if->tk->name->log->error->else->if->annosAfterParams->nonEmpty->illegal->return->List->methodDeclaratorRest->of->else->name->ident->if->return->List->methodDeclaratorRest->of->else->if->typarams->isEmpty->defs->new->ListBuffer<JCTree>->variableDeclaratorsRest->toList->accept->defs->last->S->prevToken->storeEnd->return->else->err->List->F->at->List->nil->List->nil->MethodDef->toP->of->return->List->Errors->Expected->syntaxError->of
JavacParser#methodDeclaratorRest(int, JCModifiers, JCExpression, Name, List, boolean, boolean, Comment):::MethodDeclaratorRest =      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] ";")  VoidMethodDeclaratorRest =      FormalParameters [THROWS TypeList] ( MethodBody | ";")  ConstructorDeclaratorRest =      "(" FormalParameterListOpt ")" [THROWS TypeList] MethodBody:::if->if->checkSourceLevel->if->checkSourceLevel->prevReceiverParam->try->params->formalParameters->if->bracketsOpt->thrown->List->nil->if->nextToken->qualidentList->body->defaultValue->if->block->else->if->accept->annotationValue->else->accept->if->skip->if->block->result->F->at->MethodDef->toP->attach->return->catch->finally
JavacParser#qualidentList(boolean):::QualidentList = [Annotations] Qualident {"," [Annotations] Qualident}:::ts->new->ListBuffer<>->typeAnnos->typeAnnotationsOpt->List->nil->qi->qualident->if->typeAnnos->isEmpty->at->insertAnnotationsToMostInner->ts->append->else->ts->append->while->nextToken->typeAnnotationsOpt->List->nil->qualident->if->typeAnnos->isEmpty->at->insertAnnotationsToMostInner->ts->append->else->ts->append->return->ts->toList
JavacParser#typeParametersOpt()::: TypeParametersOpt = ["<" TypeParameter {"," TypeParameter ">"]  }:::if->typarams->new->ListBuffer<>->nextToken->typarams->typeParameter->append->while->nextToken->typarams->typeParameter->append->accept->return->typarams->toList->else->return->List->nil
JavacParser#typeParameter()::: TypeParameter = [Annotations] TypeVariable [TypeParameterBound]  TypeParameterBound = EXTENDS Type {"&" Type  TypeVariable = Ident  }:::pos->annos->typeAnnotationsOpt->name->typeName->bounds->new->ListBuffer<>->if->nextToken->bounds->parseType->append->while->nextToken->bounds->parseType->append->return->F->at->bounds->toList->TypeParameter->toP
JavacParser#formalParameters():::FormalParameters = "(" [ FormalParameterList ] ")"  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter:::return->formalParameters
JavacParser#formalParameter():::FormalParameter = { FINAL | '@' Annotation } Type VariableDeclaratorId  LastFormalParameter = { FINAL | '@' Annotation } Type '...' Ident | FormalParameter:::return->formalParameter
JavacParser#checkExprStat(JCExpression):::Check that given tree is a legal expression statement.:::if->TreeInfo->isExpressionStatement->ret->F->at->List->of->Erroneous->log->error->return->else->return
JavacParser#prec(TokenKind):::Return precedence of operator represented by token,  -1 if token is not a binary operator:::oc->optag->return->TreeInfo->opPrec
JavacParser#earlier(int, int):::Return the lesser of two positions, making allowance for either one being unset.:::if->return->if->return->return
JavacParser#optag(TokenKind):::Return operation tag of binary operator represented by token,  No_TAG if token is not a binary operator.:::switch->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return
JavacParser#unoptag(TokenKind):::Return operation tag of unary operator represented by token,  No_TAG if token is not a binary operator.:::switch->return->return->return->return->return->return->return
JavacParser#typetag(TokenKind):::Return type tag of basic type represented by token,  NONE if token is not a basic type identifier.:::switch->return->return->return->return->return->return->return->return->return
JavacParser.AbstractEndPosTable#to(T):::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the current token.:::
JavacParser.AbstractEndPosTable#toP(T):::Store current token's ending position for a tree, the value of which will be the greater of last error position and the ending position of the previous token.:::
JavacParser.AbstractEndPosTable#setErrorEndPos(int):::Set the error position during the parsing phases, the value of which will be set only if it is greater than the last stored error position.:::if
JavadocTokenizer.DocReader#isDoubleBackslash():::Whether the ch represents a sequence of two backslashes.:::return
JavaTokenizer#lexError(int, JCDiagnostic.Error):::Report an error at the given position using the provided arguments.:::log->error
JavaTokenizer#readToken():::Read token.:::pos->endPos->comments->try->while->switch->do->reader->scanChar->while->processWhiteSpace->break->reader->scanChar->processLineTerminator->break->reader->scanChar->if->reader->scanChar->processLineTerminator->break->scanIdent->break->reader->scanChar->if->reader->scanChar->skipIllegalUnderscores->scanNumber->else->if->checkSourceLevel->reader->scanChar->skipIllegalUnderscores->scanNumber->else->reader->putChar->if->savePos->do->reader->scanChar->while->if->reader->digit->lexError->scanNumber->break->scanNumber->break->reader->scanChar->if->reader->digit->reader->putChar->scanFractionAndSuffix->else->if->savePos->reader->putChar->reader->putChar->if->reader->scanChar->reader->putChar->else->lexError->else->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->break->reader->scanChar->if->do->reader->scanCommentChar->while->if->processComment->addComment->break->else->if->isEmpty->reader->scanChar->style->if->reader->scanCommentChar->if->else->while->if->reader->scanChar->if->break->else->reader->scanCommentChar->if->reader->scanChar->processComment->addComment->break->else->lexError->break->else->if->reader->scanChar->else->break->reader->scanChar->if->lexError->reader->scanChar->else->if->lexError->scanLitChar->if->reader->scanChar->else->lexError->break->reader->scanChar->while->scanLitChar->if->reader->scanChar->else->lexError->break->if->isSpecial->scanOperator->else->isJavaIdentifierStart->codePoint->if->else->reader->peekSurrogates->if->if->Character->isJavaIdentifierStart->reader->putChar->else->Character->isJavaIdentifierStart->if->scanIdent->else->if->reader->digit->scanNumber->else->if->else->arg->if->high->reader->scanChar->String->format->else->String->format->String->format->Errors->IllegalChar->lexError->reader->scanChar->break->switch->return->new->Token->return->new->NamedToken->return->reader->chars->new->StringToken->return->reader->chars->new->NumericToken->throw->new->AssertionError->catch->finally->if->reader->getRawCharacters->new->String->println
JavaTokenizer#errPos():::Return the position where a lexical error occurred;:::return
JavaTokenizer#errPos(int):::Set the position where a lexical error occurred;:::
JavaTokenizer#processComment(int, int, CommentStyle):::Called when a complete comment has been scanned:::if->reader->getRawCharacters->new->String->println->buf->reader->getRawCharacters->return->new->UnicodeReader->new->BasicComment<>
JavaTokenizer#processWhiteSpace(int, int):::Called when a complete whitespace run has been scanned:::if->reader->getRawCharacters->new->String->println
JavaTokenizer#processLineTerminator(int, int):::Called when a line terminator has been processed.:::if->reader->getRawCharacters->new->String->println
JavaTokenizer#getLineMap():::Build a map for translating between line numbers and positions in the input.:::return->Position->reader->getRawCharacters->makeLineMap
Lexer#nextToken():::Consume the next token.:::
Lexer#token():::Return current token.:::
Lexer#token(int):::Return token with given lookahead.:::
Lexer#prevToken():::Return the last character position of the previous token.:::
Lexer#split():::Splits the current token in two and return the first (splitted) token:::
Lexer#errPos():::Return the position where a lexical error occurred;:::
Lexer#errPos(int):::Set the position where a lexical error occurred;:::
Lexer#getLineMap():::Build a map for translating between line numbers and positions in the input.:::
Parser#parseCompilationUnit():::Parse a compilation unit.:::
Parser#parseExpression():::Parse an expression.:::
Parser#parseStatement():::Parse a statement.:::
Parser#parseType():::Parse a type.:::
ReferenceParser#parse(String):::Parse a reference to an API element as may be found in doc comment.:::qualExpr->member->paramTypes->deferredDiagnosticHandler->new->Log.DeferredDiagnosticHandler->try->hash->sig->indexOf->lparen->sig->indexOf->if->if->parseType->else->sig->substring->parseMember->else->sig->substring->parseType->if->sig->substring->parseMember->else->sig->substring->parseMember->if->else->rparen->sig->indexOf->if->sig->length->throw->new->ParseException->sig->substring->parseParams->if->deferredDiagnosticHandler->getDiagnostics->isEmpty->throw->new->ParseException->catch->finally->popDiagnosticHandler->return->new->Reference
ScannerFactory#instance(Context):::Get the Factory instance for this context.:::instance->context->get->if->new->ScannerFactory->return
Tokens#lookupKind(Name):::Create a new token given a name; if the name corresponds to a token name, a new token of the corresponding kind is returned; otherwise, an identifier token is returned.:::return->name->getIndex->name->getIndex
Tokens.Token#comment(Comment.CommentStyle):::Preserve classic semantics - if multiple javadocs are found on the token the last one is returned:::comments->getComments->return->comments->isEmpty
Tokens.Token#deprecatedFlag():::Preserve classic semantics - deprecated should be set if at least one javadoc comment attached to this token contains the '@deprecated' string:::foreach->getComments->if->c->isDeprecated->return->return
UnicodeReader#scanChar():::Read next character.:::if->if->convertUnicode
UnicodeReader#scanCommentChar():::Read next character in comment, skipping over double '\' characters.:::scanChar->if->if->peekChar->isUnicode->skipChar->else->convertUnicode
UnicodeReader#putChar(char, boolean):::Append a character to sbuf.:::ArrayUtils->ensureCapacity->if->scanChar
UnicodeReader#convertUnicode():::Convert unicode escape; bp points to initial '\' character  (Spec 3.3).:::if->if->do->while->limit->if->d->digit->code->while->digit->if->return->log->error->else
UnicodeReader#peekSurrogates():::Scan surrogate pairs:::if->Character->isHighSurrogate->high->prevBP->scanChar->low->if->Character->isLowSurrogate->return->Character->toCodePoint->return
UnicodeReader#digit(int, int):::Convert an ASCII digit from its base (8, 10, or 16)  to its value.:::c->if->return->Character->digit->codePoint->peekSurrogates->result->Character->digit->Character->digit->if->log->error->if->scanChar->charAt->return
UnicodeReader#getRawCharacters():::Returns a copy of the input buffer, up to its inputLength:::chars->new->charArr->System->arraycopy->return
UnicodeReader#getRawCharacters(int, int):::Returns a copy of a character array subset of the input buffer:::length->chars->new->charArr->System->arraycopy->return
