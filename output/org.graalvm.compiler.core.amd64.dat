AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_resetLowestSetBit#match(NodeMatchRules, Object...)::: match generator_reset lowest set bit match:::return->resetLowestSetBit
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_resetLowestSetBit#getName()::: match generator_reset lowest set bit get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareValueCas#match(NodeMatchRules, Object...)::: match generator_if compare value cas match:::return->ifCompareValueCas
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareValueCas#getName()::: match generator_if compare value cas get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_writeNarrow#match(NodeMatchRules, Object...)::: match generator_write narrow match:::return->writeNarrow
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_writeNarrow#getName()::: match generator_write narrow get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateRightVariable#match(NodeMatchRules, Object...)::: match generator_rotate right variable match:::return->rotateRightVariable
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateRightVariable#getName()::: match generator_rotate right variable get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareMemory#match(NodeMatchRules, Object...)::: match generator_if compare memory match:::return->ifCompareMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareMemory#getName()::: match generator_if compare memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_zeroExtend#match(NodeMatchRules, Object...)::: match generator_zero extend match:::return->zeroExtend
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_zeroExtend#getName()::: match generator_zero extend get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_getMaskUpToLowestSetBit#match(NodeMatchRules, Object...)::: match generator_get mask up to lowest set bit match:::return->getMaskUpToLowestSetBit
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_getMaskUpToLowestSetBit#getName()::: match generator_get mask up to lowest set bit get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateLeftConstant#match(NodeMatchRules, Object...)::: match generator_rotate left constant match:::return->rotateLeftConstant
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateLeftConstant#getName()::: match generator_rotate left constant get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_subMemory#match(NodeMatchRules, Object...)::: match generator_sub memory match:::return->subMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_subMemory#getName()::: match generator_sub memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_signExtend#match(NodeMatchRules, Object...)::: match generator_sign extend match:::return->signExtend
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_signExtend#getName()::: match generator_sign extend get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_orMemory#match(NodeMatchRules, Object...)::: match generator_or memory match:::return->orMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_orMemory#getName()::: match generator_or memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_lowestSetIsolatedBit#match(NodeMatchRules, Object...)::: match generator_lowest set isolated bit match:::return->lowestSetIsolatedBit
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_lowestSetIsolatedBit#getName()::: match generator_lowest set isolated bit get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_xorMemory#match(NodeMatchRules, Object...)::: match generator_xor memory match:::return->xorMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_xorMemory#getName()::: match generator_xor memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_integerTestBranchMemory#match(NodeMatchRules, Object...)::: match generator_integer test branch memory match:::return->integerTestBranchMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_integerTestBranchMemory#getName()::: match generator_integer test branch memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareLogicCas#match(NodeMatchRules, Object...)::: match generator_if compare logic cas match:::return->ifCompareLogicCas
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareLogicCas#getName()::: match generator_if compare logic cas get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifLogicCas#match(NodeMatchRules, Object...)::: match generator_if logic cas match:::return->ifLogicCas
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_ifLogicCas#getName()::: match generator_if logic cas get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_logicalAndNot#match(NodeMatchRules, Object...)::: match generator_logical and not match:::return->logicalAndNot
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_logicalAndNot#getName()::: match generator_logical and not get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_signExtendNarrowRead#match(NodeMatchRules, Object...)::: match generator_sign extend narrow read match:::return->signExtendNarrowRead
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_signExtendNarrowRead#getName()::: match generator_sign extend narrow read get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_mulMemory#match(NodeMatchRules, Object...)::: match generator_mul memory match:::return->mulMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_mulMemory#getName()::: match generator_mul memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_reinterpret#match(NodeMatchRules, Object...)::: match generator_reinterpret match:::return->reinterpret
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_reinterpret#getName()::: match generator_reinterpret get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_floatConvert#match(NodeMatchRules, Object...)::: match generator_float convert match:::return->floatConvert
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_floatConvert#getName()::: match generator_float convert get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_narrowRead#match(NodeMatchRules, Object...)::: match generator_narrow read match:::return->narrowRead
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_narrowRead#getName()::: match generator_narrow read get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateLeftVariable#match(NodeMatchRules, Object...)::: match generator_rotate left variable match:::return->rotateLeftVariable
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_rotateLeftVariable#getName()::: match generator_rotate left variable get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_addMemory#match(NodeMatchRules, Object...)::: match generator_add memory match:::return->addMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_addMemory#getName()::: match generator_add memory get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_writeReinterpret#match(NodeMatchRules, Object...)::: match generator_write reinterpret match:::return->writeReinterpret
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_writeReinterpret#getName()::: match generator_write reinterpret get name:::return
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_andMemory#match(NodeMatchRules, Object...)::: match generator_and memory match:::return->andMemory
AMD64NodeMatchRules_MatchStatementSet.MatchGenerator_andMemory#getName()::: match generator_and memory get name:::return
AMD64NodeMatchRules_MatchStatementSet#forClass()::: d64 node match rules_ match statement set for class:::return
AMD64NodeMatchRules_MatchStatementSet#statements()::: d64 node match rules_ match statement set statements:::NegateNode_positions->MatchRuleRegistry->new->StringArr->findPositions->MulNode_positions->MatchRuleRegistry->new->StringArr->findPositions->FloatEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->FloatLessThanNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->SignExtendNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerTestNode_positions->MatchRuleRegistry->new->StringArr->findPositions->SubNode_positions->MatchRuleRegistry->new->StringArr->findPositions->NotNode_positions->MatchRuleRegistry->new->StringArr->findPositions->OrNode_positions->MatchRuleRegistry->new->StringArr->findPositions->ZeroExtendNode_positions->MatchRuleRegistry->new->StringArr->findPositions->PointerEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IfNode_positions->MatchRuleRegistry->new->StringArr->findPositions->AndNode_positions->MatchRuleRegistry->new->StringArr->findPositions->AddNode_positions->MatchRuleRegistry->new->StringArr->findPositions->ReinterpretNode_positions->MatchRuleRegistry->new->StringArr->findPositions->LeftShiftNode_positions->MatchRuleRegistry->new->StringArr->findPositions->WriteNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerLessThanNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerBelowNode_positions->MatchRuleRegistry->new->StringArr->findPositions->FloatConvertNode_positions->MatchRuleRegistry->new->StringArr->findPositions->ObjectEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->UnsignedRightShiftNode_positions->MatchRuleRegistry->new->StringArr->findPositions->NarrowNode_positions->MatchRuleRegistry->new->StringArr->findPositions->XorNode_positions->MatchRuleRegistry->new->StringArr->findPositions->statements->Collections->Arrays->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->asList->unmodifiableList->return
AMD64AddressLowering#lower(ValueNode, ValueNode)::: d64 address lowering lower:::ret->new->AMD64AddressNode->graph->base->graph->changed->do->base->getDebug->improve->while->return->graph->unique
AMD64AddressLowering#checkAddressBitWidth(ValueNode)::: d64 address lowering check address bit width:::return->value->stamp->IntegerStamp->value->stamp->getBits
AMD64AddressLowering#improve(StructuredGraph, DebugContext, AMD64AddressNode, boolean, boolean):::Tries to optimize addresses so that they match the AMD64-specific addressing mode better (base + index * scale + displacement).:::newBase->ret->getBase->improveInput->if->ret->getBase->ret->setBase->return->newIdx->ret->getIndex->ret->getScale->improveInput->if->ret->getIndex->ret->setIndex->return->if->ret->getIndex->shift->ret->getIndex->if->shift->getY->isConstant->amount->ret->getScale->shift->getY->asJavaConstant->asInt->scale->Scale->fromShift->if->ret->shift->getX->setIndex->ret->setScale->return->if->ret->getScale->if->ret->getIndex->ret->getBase->add->ret->getBase->ret->add->getX->setBase->ret->add->getY->considerNegation->setIndex->return->if->ret->getBase->ret->getIndex->add->ret->getIndex->ret->add->getX->considerNegation->setBase->ret->add->getY->setIndex->return->if->ret->getBase->ret->getIndex->tmp->ret->getBase->ret->ret->getIndex->considerNegation->setBase->ret->considerNegation->setIndex->return->return->improveNegation
AMD64AddressLowering#improveNegation(StructuredGraph, DebugContext, AMD64AddressNode, boolean, boolean)::: d64 address lowering improve negation:::baseNegated->indexNegated->originalBase->ret->getBase->originalIndex->ret->getIndex->if->ret->getBase->negate->ret->getBase->ret->negate->getValue->setBase->if->ret->getIndex->negate->ret->getIndex->ret->negate->getValue->setIndex->if->base->ret->getBase->index->ret->getIndex->improved->improve->if->if->ret->getBase->ret->setBase->else->if->ret->getBase->ret->graph->NegateNode->ret->getBase->create->maybeAddOrUnique->setBase->if->if->ret->getIndex->ret->setIndex->else->if->ret->getIndex->ret->graph->NegateNode->ret->getIndex->create->maybeAddOrUnique->setIndex->return->else->return
AMD64AddressLowering#considerNegation(StructuredGraph, ValueNode, boolean)::: d64 address lowering consider negation:::if->return->graph->NegateNode->create->maybeAddOrUnique->return
AMD64AddressLowering#improveInput(AMD64AddressNode, ValueNode, int, boolean)::: d64 address lowering improve input:::if->return->c->node->asJavaConstant->if->return->improveConstDisp->else->if->node->stamp->if->add->if->add->getX->isConstant->return->add->getX->asJavaConstant->add->getY->improveConstDisp->else->if->add->getY->isConstant->return->add->getY->asJavaConstant->add->getX->improveConstDisp->return
AMD64AddressLowering#improveConstDisp(AMD64AddressNode, ValueNode, JavaConstant, ValueNode, int, boolean)::: d64 address lowering improve const disp:::if->c->getJavaKind->isNumericInteger->delta->c->asLong->if->updateDisplacement->return->return
AMD64AddressLowering#updateDisplacement(AMD64AddressNode, long, boolean)::: d64 address lowering update displacement:::sign->disp->address->getDisplacement->if->NumUtil->isInt->address->setDisplacement->return->return
AMD64AddressNode#canonicalizeIndex(SimplifierTool)::: d64 address node canonicalize index:::if->index->stamp->getBits->add->valX->add->getX->if->phi->if->phi->merge->loopNode->phi->merge->if->loopNode->isSimpleLoop->valY->add->getY->if->addBy->valY->asJavaConstant->asInt->replaceFirstInput->tool->addToWorkList
AMD64AddressNode#generate(NodeLIRBuilderTool)::: d64 address node generate:::tool->gen->getLIRGeneratorTool->baseValue->tool->gen->operand->asAllocatable->indexValue->tool->gen->operand->asAllocatable->baseReference->LIRKind->derivedBaseFromValue->indexReference->if->else->if->scale->equals->LIRKind->derivedBaseFromValue->else->if->LIRKind->isValue->else->kind->LIRKind->tool->stamp->getLIRKind->combineDerived->gen->new->AMD64AddressValue->setResult
AMD64AddressNode#getBase()::: d64 address node get base:::return
AMD64AddressNode#setBase(ValueNode)::: d64 address node set base:::if->isAlive->updateUsages
AMD64AddressNode#getIndex()::: d64 address node get index:::return
AMD64AddressNode#setIndex(ValueNode)::: d64 address node set index:::if->isAlive->updateUsages
AMD64AddressNode#getScale()::: d64 address node get scale:::return
AMD64AddressNode#setScale(Scale)::: d64 address node set scale:::
AMD64AddressNode#getDisplacement()::: d64 address node get displacement:::return
AMD64AddressNode#setDisplacement(int)::: d64 address node set displacement:::
AMD64AddressNode#getMaxConstantDisplacement()::: d64 address node get max constant displacement:::return
AMD64AddressNode#simplify(SimplifierTool)::: d64 address node simplify:::canonicalizeIndex
AMD64ArithmeticLIRGenerator#emitNegate(Value)::: d64 arithmetic generator emit negate:::input->asAllocatable->result->getLIRGen->LIRKind->combine->newVariable->isAvx->supportAVX->switch->input->getPlatformKind->getLIRGen->new->AMD64Unary.MOp->append->break->getLIRGen->new->AMD64Unary.MOp->append->break->floatMask->JavaConstant->Float->intBitsToFloat->forFloat->if->getLIRGen->getRegisterSize->asAllocatable->getLIRGen->emitJavaConstant->asAllocatable->new->AVXBinaryOp->append->else->getLIRGen->new->AMD64Binary.DataTwoOp->append->break->doubleMask->JavaConstant->Double->longBitsToDouble->forDouble->if->getLIRGen->getRegisterSize->asAllocatable->getLIRGen->emitJavaConstant->asAllocatable->new->AVXBinaryOp->append->else->getLIRGen->new->AMD64Binary.DataTwoOp->append->break->throw->GraalError->input->getPlatformKind->toString->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitNot(Value)::: d64 arithmetic generator emit not:::input->asAllocatable->result->getLIRGen->LIRKind->combine->newVariable->switch->input->getPlatformKind->getLIRGen->new->AMD64Unary.MOp->append->break->getLIRGen->new->AMD64Unary.MOp->append->break->throw->GraalError->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitBinary(LIRKind, AMD64BinaryArithmetic, OperandSize, boolean, Value, Value, boolean)::: d64 arithmetic generator emit binary:::if->isJavaConstant->return->asAllocatable->asConstantValue->emitBinaryConst->else->if->isJavaConstant->return->asAllocatable->asConstantValue->emitBinaryConst->else->return->op->getRMOpcode->asAllocatable->asAllocatable->emitBinaryVar
AMD64ArithmeticLIRGenerator#emitBinary(LIRKind, AMD64RMOp, OperandSize, boolean, Value, Value)::: d64 arithmetic generator emit binary:::if->isJavaConstant->return->asAllocatable->asJavaConstant->emitBinaryConst->else->if->isJavaConstant->return->asAllocatable->asJavaConstant->emitBinaryConst->else->return->asAllocatable->asAllocatable->emitBinaryVar
AMD64ArithmeticLIRGenerator#emitBinaryConst(LIRKind, AMD64BinaryArithmetic, OperandSize, boolean, AllocatableValue, ConstantValue, boolean)::: d64 arithmetic generator emit binary const:::value->b->getJavaConstant->asLong->if->NumUtil->isInt->result->getLIRGen->newVariable->constant->if->mop->getMOp->if->getLIRGen->new->AMD64Unary.MOp->append->return->getLIRGen->new->AMD64Binary.ConstOp->append->return->else->return->op->getRMOpcode->asAllocatable->emitBinaryVar
AMD64ArithmeticLIRGenerator#getMOp(AMD64BinaryArithmetic, int)::: d64 arithmetic generator get op:::if->if->op->equals->return->if->op->equals->return->else->if->if->op->equals->return->if->op->equals->return->return
AMD64ArithmeticLIRGenerator#emitBinaryConst(LIRKind, AMD64RMOp, OperandSize, AllocatableValue, JavaConstant)::: d64 arithmetic generator emit binary const:::result->getLIRGen->newVariable->getLIRGen->new->AMD64Binary.DataTwoOp->append->return
AMD64ArithmeticLIRGenerator#emitBinaryVar(LIRKind, AMD64RMOp, OperandSize, boolean, AllocatableValue, AllocatableValue)::: d64 arithmetic generator emit binary var:::result->getLIRGen->newVariable->if->getLIRGen->new->AMD64Binary.CommutativeTwoOp->append->else->getLIRGen->new->AMD64Binary.TwoOp->append->return
AMD64ArithmeticLIRGenerator#isNumericInteger(PlatformKind)::: d64 arithmetic generator is numeric integer:::return->isInteger
AMD64ArithmeticLIRGenerator#emitBaseOffsetLea(LIRKind, Value, int, OperandSize)::: d64 arithmetic generator emit base offset lea:::result->getLIRGen->newVariable->address->asAllocatable->new->AMD64AddressValue->getLIRGen->new->AMD64Move.LeaOp->append->return
AMD64ArithmeticLIRGenerator#emitAdd(LIRKind, Value, Value, boolean)::: d64 arithmetic generator emit add:::isAvx->supportAVX->switch->a->getPlatformKind->if->isJavaConstant->displacement->asJavaConstant->asLong->if->NumUtil->isInt->return->emitBaseOffsetLea->return->emitBinary->if->isJavaConstant->displacement->asJavaConstant->asLong->if->NumUtil->isInt->return->emitBaseOffsetLea->return->emitBinary->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitSub(LIRKind, Value, Value, boolean)::: d64 arithmetic generator emit sub:::isAvx->supportAVX->switch->a->getPlatformKind->return->emitBinary->return->emitBinary->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitIMULConst(OperandSize, AllocatableValue, ConstantValue)::: d64 arithmetic generator emit const:::value->b->getJavaConstant->asLong->if->NumUtil->isInt->imm->op->if->NumUtil->isByte->else->ret->getLIRGen->LIRKind->combine->newVariable->getLIRGen->new->AMD64Binary.RMIOp->append->return->else->return->LIRKind->combine->asAllocatable->emitBinaryVar
AMD64ArithmeticLIRGenerator#emitIMUL(OperandSize, Value, Value)::: d64 arithmetic generator emit l:::if->isJavaConstant->return->asAllocatable->asConstantValue->emitIMULConst->else->if->isJavaConstant->return->asAllocatable->asConstantValue->emitIMULConst->else->return->LIRKind->combine->asAllocatable->asAllocatable->emitBinaryVar
AMD64ArithmeticLIRGenerator#emitMul(Value, Value, boolean)::: d64 arithmetic generator emit mul:::isAvx->supportAVX->resultKind->LIRKind->combine->switch->a->getPlatformKind->return->emitIMUL->return->emitIMUL->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#moveToReg(Register, Value)::: d64 arithmetic generator move to reg:::ret->reg->v->getValueKind->asValue->getLIRGen->emitMove->return
AMD64ArithmeticLIRGenerator#emitMulHigh(AMD64MOp, OperandSize, Value, Value)::: d64 arithmetic generator emit mul high:::mulHigh->getLIRGen->LIRKind->combine->moveToReg->asAllocatable->new->AMD64MulDivOp->append->return->getLIRGen->mulHigh->getHighResult->emitMove
AMD64ArithmeticLIRGenerator#emitMulHigh(Value, Value)::: d64 arithmetic generator emit mul high:::switch->a->getPlatformKind->return->emitMulHigh->return->emitMulHigh->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitUMulHigh(Value, Value)::: d64 arithmetic generator emit mul high:::switch->a->getPlatformKind->return->emitMulHigh->return->emitMulHigh->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitBinaryMemory(VexRVMOp, OperandSize, AllocatableValue, AMD64AddressValue, LIRFrameState)::: d64 arithmetic generator emit binary memory:::result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->getRegisterSize->new->AMD64VectorBinary.AVXBinaryMemoryOp->append->return
AMD64ArithmeticLIRGenerator#emitBinaryMemory(AMD64RMOp, OperandSize, AllocatableValue, AMD64AddressValue, LIRFrameState)::: d64 arithmetic generator emit binary memory:::result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->new->AMD64Binary.MemoryTwoOp->append->return
AMD64ArithmeticLIRGenerator#emitConvertMemoryOp(PlatformKind, AMD64RMOp, OperandSize, AMD64AddressValue, LIRFrameState)::: d64 arithmetic generator emit convert memory op:::result->getLIRGen->LIRKind->value->newVariable->getLIRGen->new->AMD64Unary.MemoryOp->append->return
AMD64ArithmeticLIRGenerator#emitZeroExtendMemory(AMD64Kind, int, AMD64AddressValue, LIRFrameState)::: d64 arithmetic generator emit zero extend memory:::result->getLIRGen->LIRKind->value->newVariable->switch->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->throw->GraalError->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitIDIV(OperandSize, Value, Value, LIRFrameState)::: d64 arithmetic generator emit v:::kind->LIRKind->combine->sx->getLIRGen->moveToReg->new->AMD64SignExtendOp->append->return->getLIRGen->sx->getHighResult->sx->getLowResult->asAllocatable->new->AMD64MulDivOp->append
AMD64ArithmeticLIRGenerator#emitDIV(OperandSize, Value, Value, LIRFrameState)::: d64 arithmetic generator emit v:::kind->LIRKind->combine->rax->moveToReg->rdx->asValue->getLIRGen->new->AMD64ClearRegisterOp->append->return->getLIRGen->asAllocatable->new->AMD64MulDivOp->append
AMD64ArithmeticLIRGenerator#emitSignedDivRem(Value, Value, LIRFrameState)::: d64 arithmetic generator emit signed div rem:::op->switch->a->getPlatformKind->emitIDIV->break->emitIDIV->break->throw->GraalError->shouldNotReachHere->return->new->ValueArr->getLIRGen->op->getQuotient->emitMove->getLIRGen->op->getRemainder->emitMove
AMD64ArithmeticLIRGenerator#emitUnsignedDivRem(Value, Value, LIRFrameState)::: d64 arithmetic generator emit unsigned div rem:::op->switch->a->getPlatformKind->emitDIV->break->emitDIV->break->throw->GraalError->shouldNotReachHere->return->new->ValueArr->getLIRGen->op->getQuotient->emitMove->getLIRGen->op->getRemainder->emitMove
AMD64ArithmeticLIRGenerator#emitDiv(Value, Value, LIRFrameState)::: d64 arithmetic generator emit div:::isAvx->supportAVX->resultKind->LIRKind->combine->switch->a->getPlatformKind->op->emitIDIV->return->getLIRGen->op->getQuotient->emitMove->lop->emitIDIV->return->getLIRGen->lop->getQuotient->emitMove->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitRem(Value, Value, LIRFrameState)::: d64 arithmetic generator emit rem:::switch->a->getPlatformKind->op->emitIDIV->return->getLIRGen->op->getRemainder->emitMove->lop->emitIDIV->return->getLIRGen->lop->getRemainder->emitMove->result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->getLIRGen->load->getLIRGen->load->new->FPDivRemOp->append->return->result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->getLIRGen->load->getLIRGen->load->new->FPDivRemOp->append->return->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitUDiv(Value, Value, LIRFrameState)::: d64 arithmetic generator emit div:::op->switch->a->getPlatformKind->emitDIV->break->emitDIV->break->throw->GraalError->shouldNotReachHere->return->getLIRGen->op->getQuotient->emitMove
AMD64ArithmeticLIRGenerator#emitURem(Value, Value, LIRFrameState)::: d64 arithmetic generator emit rem:::op->switch->a->getPlatformKind->emitDIV->break->emitDIV->break->throw->GraalError->shouldNotReachHere->return->getLIRGen->op->getRemainder->emitMove
AMD64ArithmeticLIRGenerator#emitAnd(Value, Value)::: d64 arithmetic generator emit and:::resultKind->LIRKind->combine->switch->a->getPlatformKind->return->emitBinary->return->emitBinary->return->emitBinary->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitOr(Value, Value)::: d64 arithmetic generator emit or:::isAvx->supportAVX->resultKind->LIRKind->combine->switch->a->getPlatformKind->return->emitBinary->return->emitBinary->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitXor(Value, Value)::: d64 arithmetic generator emit xor:::isAvx->supportAVX->resultKind->LIRKind->combine->switch->a->getPlatformKind->return->emitBinary->return->emitBinary->if->return->emitBinary->else->return->emitBinary->if->return->emitBinary->else->return->emitBinary->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitShift(AMD64Shift, OperandSize, Value, Value)::: d64 arithmetic generator emit shift:::result->getLIRGen->LIRKind->combine->a->getPlatformKind->changeType->newVariable->input->asAllocatable->if->isJavaConstant->c->asJavaConstant->if->c->asLong->getLIRGen->new->AMD64Unary.MOp->append->else->getLIRGen->c->asLong->new->AMD64Binary.ConstOp->append->else->getLIRGen->emitMove->getLIRGen->new->AMD64ShiftOp->append->return
AMD64ArithmeticLIRGenerator#emitShl(Value, Value)::: d64 arithmetic generator emit shl:::switch->a->getPlatformKind->return->emitShift->return->emitShift->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitShr(Value, Value)::: d64 arithmetic generator emit shr:::switch->a->getPlatformKind->return->emitShift->return->emitShift->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitUShr(Value, Value)::: d64 arithmetic generator emit shr:::switch->a->getPlatformKind->return->emitShift->return->emitShift->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitRol(Value, Value)::: d64 arithmetic generator emit rol:::switch->a->getPlatformKind->return->emitShift->return->emitShift->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitRor(Value, Value)::: d64 arithmetic generator emit ror:::switch->a->getPlatformKind->return->emitShift->return->emitShift->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitConvertOp(LIRKind, AMD64RMOp, OperandSize, Value)::: d64 arithmetic generator emit convert op:::result->getLIRGen->newVariable->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitConvertOp(LIRKind, AMD64MROp, OperandSize, Value)::: d64 arithmetic generator emit convert op:::result->getLIRGen->newVariable->getLIRGen->asAllocatable->new->AMD64Unary.MROp->append->return
AMD64ArithmeticLIRGenerator#emitReinterpret(LIRKind, Value)::: d64 arithmetic generator emit reinterpret:::from->inputVal->getValueKind->if->to->equals->return->input->asAllocatable->fromKind->from->getPlatformKind->switch->to->getPlatformKind->switch->return->emitConvertOp->break->switch->return->emitConvertOp->break->switch->return->emitConvertOp->break->switch->return->emitConvertOp->break->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitFloatConvert(FloatConvert, Value)::: d64 arithmetic generator emit float convert:::switch->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitNarrow(Value, int)::: d64 arithmetic generator emit narrow:::if->inputVal->getPlatformKind->return->LIRKind->combine->changeType->emitConvertOp->else->return
AMD64ArithmeticLIRGenerator#emitSignExtend(Value, int, int)::: d64 arithmetic generator emit sign extend:::if->return->else->if->switch->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->throw->GraalError->unimplemented->else->switch->return->LIRKind->combine->changeType->emitConvertOp->return->LIRKind->combine->changeType->emitConvertOp->return->throw->GraalError->unimplemented
AMD64ArithmeticLIRGenerator#emitZeroExtend(Value, int, int)::: d64 arithmetic generator emit zero extend:::if->return->else->if->result->getLIRGen->LIRKind->combine->newVariable->mask->CodeUtil->mask->getLIRGen->AND->getRMOpcode->asAllocatable->JavaConstant->forLong->new->AMD64Binary.DataTwoOp->append->return->else->resultKind->LIRKind->combine->if->resultKind->changeType->else->resultKind->changeType->switch->return->emitConvertOp->return->emitConvertOp->return->emitConvertOp->result->getLIRGen->newVariable->mask->if->JavaConstant->CodeUtil->mask->forLong->else->JavaConstant->CodeUtil->mask->forInt->getLIRGen->AND->getRMOpcode->asAllocatable->new->AMD64Binary.DataTwoOp->append->return
AMD64ArithmeticLIRGenerator#emitBitCount(Value)::: d64 arithmetic generator emit bit count:::result->getLIRGen->LIRKind->combine->changeType->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->else->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitBitScanForward(Value)::: d64 arithmetic generator emit bit scan forward:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitBitScanReverse(Value)::: d64 arithmetic generator emit bit scan reverse:::result->getLIRGen->LIRKind->combine->changeType->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->else->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitFusedMultiplyAdd(Value, Value, Value)::: d64 arithmetic generator emit fused multiply add:::result->getLIRGen->LIRKind->combine->newVariable->if->a->getPlatformKind->getLIRGen->asAllocatable->asAllocatable->asAllocatable->new->AMD64Ternary.ThreeOp->append->else->getLIRGen->asAllocatable->asAllocatable->asAllocatable->new->AMD64Ternary.ThreeOp->append->return
AMD64ArithmeticLIRGenerator#emitCountLeadingZeros(Value)::: d64 arithmetic generator emit count leading zeros:::result->getLIRGen->LIRKind->combine->changeType->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->else->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitCountTrailingZeros(Value)::: d64 arithmetic generator emit count trailing zeros:::result->getLIRGen->LIRKind->combine->changeType->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->else->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->return
AMD64ArithmeticLIRGenerator#emitLogicalAndNot(Value, Value)::: d64 arithmetic generator emit logical and not:::result->getLIRGen->LIRKind->combine->newVariable->if->value1->getPlatformKind->getLIRGen->asAllocatable->asAllocatable->new->AMD64VectorBinary.AVXBinaryOp->append->else->getLIRGen->asAllocatable->asAllocatable->new->AMD64VectorBinary.AVXBinaryOp->append->return
AMD64ArithmeticLIRGenerator#emitLowestSetIsolatedBit(Value)::: d64 arithmetic generator emit lowest set isolated bit:::result->getLIRGen->LIRKind->combine->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->else->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->return
AMD64ArithmeticLIRGenerator#emitGetMaskUpToLowestSetBit(Value)::: d64 arithmetic generator emit get mask up to lowest set bit:::result->getLIRGen->LIRKind->combine->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->else->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->return
AMD64ArithmeticLIRGenerator#emitResetLowestSetBit(Value)::: d64 arithmetic generator emit reset lowest set bit:::result->getLIRGen->LIRKind->combine->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->else->getLIRGen->asAllocatable->new->AMD64VectorUnary.AVXUnaryOp->append->return
AMD64ArithmeticLIRGenerator#emitMathAbs(Value)::: d64 arithmetic generator emit math abs:::result->getLIRGen->LIRKind->combine->newVariable->switch->input->getPlatformKind->getLIRGen->asAllocatable->JavaConstant->Float->intBitsToFloat->forFloat->new->AMD64Binary.DataTwoOp->append->break->getLIRGen->asAllocatable->JavaConstant->Double->longBitsToDouble->forDouble->new->AMD64Binary.DataTwoOp->append->break->throw->GraalError->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitMathSqrt(Value)::: d64 arithmetic generator emit math sqrt:::result->getLIRGen->LIRKind->combine->newVariable->switch->input->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->break->getLIRGen->asAllocatable->new->AMD64Unary.RMOp->append->break->throw->GraalError->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitMathLog(Value, boolean)::: d64 arithmetic generator emit math log:::if->return->new->AMD64MathLog10Op->getLIRGen->emitLIRWrapper->else->return->new->AMD64MathLogOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitMathCos(Value)::: d64 arithmetic generator emit math cos:::return->new->AMD64MathCosOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitMathSin(Value)::: d64 arithmetic generator emit math sin:::return->new->AMD64MathSinOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitMathTan(Value)::: d64 arithmetic generator emit math tan:::return->new->AMD64MathTanOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitMathExp(Value)::: d64 arithmetic generator emit math exp:::return->new->AMD64MathExpOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitMathPow(Value, Value)::: d64 arithmetic generator emit math pow:::return->new->AMD64MathPowOp->getLIRGen->emitLIRWrapper
AMD64ArithmeticLIRGenerator#emitZeroMemory(Value, Value)::: d64 arithmetic generator emit zero memory:::lengthReg->moveToReg->getLIRGen->getAMD64LIRGen->asAddressValue->new->AMD64ZeroMemoryOp->append
AMD64ArithmeticLIRGenerator#getAMD64LIRGen()::: d64 arithmetic generator get d64 gen:::return->getLIRGen
AMD64ArithmeticLIRGenerator#emitLoad(LIRKind, Value, LIRFrameState)::: d64 arithmetic generator emit load:::loadAddress->getAMD64LIRGen->asAddressValue->result->getLIRGen->getLIRGen->toRegisterKind->newVariable->switch->kind->getPlatformKind->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->getLIRGen->new->AMD64Unary.MemoryOp->append->break->throw->GraalError->shouldNotReachHere->return
AMD64ArithmeticLIRGenerator#emitStoreConst(AMD64Kind, AMD64AddressValue, ConstantValue, LIRFrameState)::: d64 arithmetic generator emit store const:::c->value->getConstant->if->JavaConstant->isNull->size->getLIRGen->new->AMD64BinaryConsumer.MemoryConstOp->append->return->else->if->if->if->getLIRGen->target->getLIRGen->new->AMD64BinaryConsumer.MemoryVMConstOp->append->return->else->jc->op->size->imm->switch->jc->asInt->break->jc->asInt->break->jc->asInt->break->jc->asLong->break->Float->jc->asFloat->floatToRawIntBits->break->Double->jc->asDouble->doubleToRawLongBits->break->throw->GraalError->shouldNotReachHere->if->NumUtil->isInt->getLIRGen->new->AMD64BinaryConsumer.MemoryConstOp->append->return->asAllocatable->emitStore
AMD64ArithmeticLIRGenerator#emitStore(AMD64Kind, AMD64AddressValue, AllocatableValue, LIRFrameState)::: d64 arithmetic generator emit store:::switch->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->getLIRGen->new->AMD64BinaryConsumer.MemoryMROp->append->break->throw->GraalError->shouldNotReachHere
AMD64ArithmeticLIRGenerator#emitStore(ValueKind, Value, Value, LIRFrameState)::: d64 arithmetic generator emit store:::storeAddress->getAMD64LIRGen->asAddressValue->kind->lirKind->getPlatformKind->if->isConstantValue->asConstantValue->emitStoreConst->else->asAllocatable->emitStore
AMD64ArithmeticLIRGenerator#mustReplaceNullWithNullRegister(Constant)::: d64 arithmetic generator must replace null with null register:::return->equals
AMD64ArithmeticLIRGenerator#emitCompareOp(AMD64Kind, Variable, Value)::: d64 arithmetic generator emit compare op:::size->switch->break->break->break->break->getLIRGen->asAllocatable->new->AMD64BinaryConsumer.Op->append->return->getLIRGen->asAllocatable->new->AMD64BinaryConsumer.Op->append->return->throw->GraalError->shouldNotReachHere->if->isConstantValue->c->LIRValueUtil->asConstant->if->JavaConstant->isNull->if->mustReplaceNullWithNullRegister->getLIRGen->new->AMD64BinaryConsumer.Op->append->else->getLIRGen->new->AMD64BinaryConsumer.Op->append->return->else->if->vc->if->GeneratePIC->getOptions->getValue->getLIRGen->CMP->getMIOpcode->new->AMD64BinaryConsumer.VMConstOp->append->else->getLIRGen->CMP->getRMOpcode->new->AMD64BinaryConsumer.DataOp->append->return->else->if->jc->if->jc->isDefaultForKind->op->getLIRGen->new->AMD64BinaryConsumer.Op->append->return->else->if->NumUtil->jc->asLong->is32bit->getLIRGen->jc->asLong->new->AMD64BinaryConsumer.ConstOp->append->return->getLIRGen->CMP->getRMOpcode->asAllocatable->new->AMD64BinaryConsumer.Op->append
AMD64ArithmeticLIRGenerator#emitRound(Value, RoundingMode)::: d64 arithmetic generator emit round:::result->getLIRGen->LIRKind->combine->newVariable->if->value->getPlatformKind->getLIRGen->asAllocatable->new->AMD64Binary.RMIOp->append->else->getLIRGen->asAllocatable->new->AMD64Binary.RMIOp->append->return
AMD64ArithmeticLIRGenerator#supportAVX()::: d64 arithmetic generator support x:::target->getLIRGen->target->return->getFeatures->contains
AMD64ArithmeticLIRGenerator#getRegisterSize(Value)::: d64 arithmetic generator get register size:::kind->a->getPlatformKind->if->kind->isXMM->return->AVXKind->getRegisterSize->else->return
AMD64ArithmeticLIRGenerator#emitBinary(LIRKind, VexRVMOp, Value, Value)::: d64 arithmetic generator emit binary:::result->getLIRGen->newVariable->if->b->getPlatformKind->b->getPlatformKind->getLIRGen->getRegisterSize->asAllocatable->new->AVXBinaryConstFloatOp->append->else->getLIRGen->getRegisterSize->asAllocatable->asAllocatable->new->AVXBinaryOp->append->return
AMD64CompressAddressLowering#improve(StructuredGraph, DebugContext, AMD64AddressNode, boolean, boolean)::: d64 compress address lowering improve:::if->super->improve->return->if->addr->getScale->base->addr->getBase->index->addr->getIndex->if->tryToImproveUncompression->tryToImproveUncompression->counterFoldedUncompressDuringAddressLowering->increment->return->return
AMD64CompressAddressLowering#tryToImproveUncompression(AMD64AddressNode, ValueNode, ValueNode)::: d64 compress address lowering try to improve uncompression:::if->compression->if->compression->getOp->improveUncompression->return->return
AMD64CompressAddressLowering#improveUncompression(AMD64AddressNode, CompressionNode, ValueNode)::: d64 compress address lowering improve uncompression:::
AMD64CompressAddressLowering.HeapBaseNode#generate(NodeLIRBuilderTool)::: heap base node generate:::kind->generator->getLIRGeneratorTool->stamp->getLIRKind->generator->heapBaseRegister->asValue->setResult
AMD64LIRGenerator#canStoreConstant(JavaConstant):::Checks whether the supplied constant can be used without loading it into a register for store operations, i.e., on the right hand side of a memory access.:::switch->c->getJavaKind->return->NumUtil->c->asLong->isInt->return->return->c->isNull->return
AMD64LIRGenerator#zapValueForKind(PlatformKind)::: d64 generator zap value for kind:::dead->switch->return->JavaConstant->forByte->return->JavaConstant->forShort->return->JavaConstant->forInt->return->JavaConstant->forLong->return->JavaConstant->Float->intBitsToFloat->forFloat->return->JavaConstant->Double->longBitsToDouble->forDouble
AMD64LIRGenerator#asAddressValue(Value)::: d64 generator as address value:::if->return->else->if->displacement->asLong->if->NumUtil->isInt->return->address->getValueKind->new->AMD64AddressValue->return->address->getValueKind->asAllocatable->new->AMD64AddressValue
AMD64LIRGenerator#emitAddress(AllocatableValue)::: d64 generator emit address:::result->LIRKind->target->getWordKind->value->newVariable->new->StackLeaOp->append->return
AMD64LIRGenerator#toRegisterKind(K):::The AMD64 backend only uses DWORD and QWORD values in registers because of a performance penalty when accessing WORD or BYTE registers:::switch->kind->getPlatformKind->return->kind->changeType->return
AMD64LIRGenerator#asAllocatable(Value, ValueKind)::: d64 generator as allocatable:::if->value->getValueKind->equals->return->asAllocatable->else->if->isRegister->return->asRegister->asValue->else->if->isConstantValue->return->asConstant->emitLoadConstant->else->variable->newVariable->emitMove->return
AMD64LIRGenerator#emitCompareAndSwap(boolean, LIRKind, Value, Value, Value, Value, Value)::: d64 generator emit compare and swap:::kind->newValue->getValueKind->addressValue->asAddressValue->integralAccessKind->reinterpretedExpectedValue->reinterpretedNewValue->isXmm->accessKind->getPlatformKind->isXMM->if->if->accessKind->getPlatformKind->equals->LIRKind->target->fromJavaKind->else->LIRKind->target->fromJavaKind->arithmeticLIRGen->emitReinterpret->arithmeticLIRGen->emitReinterpret->memKind->integralAccessKind->getPlatformKind->aRes->asValue->allocatableNewValue->asAllocatable->emitMove->new->CompareAndSwapOp->append->if->result->trueValue->getValueKind->newVariable->asAllocatable->new->CondMoveOp->append->return->else->if->return->arithmeticLIRGen->emitReinterpret->else->result->newVariable->emitMove->return
AMD64LIRGenerator#emitLogicCompareAndSwap(LIRKind, Value, Value, Value, Value, Value)::: d64 generator emit logic compare and swap:::return->emitCompareAndSwap
AMD64LIRGenerator#emitValueCompareAndSwap(LIRKind, Value, Value, Value)::: d64 generator emit value compare and swap:::return->emitCompareAndSwap
AMD64LIRGenerator#emitCompareAndSwapBranch(ValueKind, AMD64AddressValue, Value, Value, Condition, LabelRef, LabelRef, double)::: d64 generator emit compare and swap branch:::memKind->kind->getPlatformKind->raxValue->asValue->emitMove->asAllocatable->new->CompareAndSwapOp->append->new->BranchOp->append
AMD64LIRGenerator#emitAtomicReadAndAdd(Value, ValueKind, Value)::: d64 generator emit atomic read and add:::result->newVariable->addressValue->asAddressValue->kind->getPlatformKind->asAllocatable->new->AMD64Move.AtomicReadAndAddOp->append->return
AMD64LIRGenerator#emitAtomicReadAndWrite(Value, ValueKind, Value)::: d64 generator emit atomic read and write:::result->newVariable->addressValue->asAddressValue->kind->getPlatformKind->asAllocatable->new->AMD64Move.AtomicReadAndWriteOp->append->return
AMD64LIRGenerator#emitNullCheck(Value, LIRFrameState)::: d64 generator emit null check:::asAddressValue->new->AMD64Move.NullCheckOp->append
AMD64LIRGenerator#emitJump(LabelRef)::: d64 generator emit jump:::new->JumpOp->append
AMD64LIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)::: d64 generator emit compare branch:::finalCondition->emitCompare->if->new->FloatBranchOp->append->else->new->BranchOp->append
AMD64LIRGenerator#emitCompareBranchMemory(AMD64Kind, Value, AMD64AddressValue, LIRFrameState, Condition, boolean, LabelRef, LabelRef, double)::: d64 generator emit compare branch memory:::mirrored->emitCompareMemory->finalCondition->cond->mirror->if->cmpKind->isXMM->new->FloatBranchOp->append->else->new->BranchOp->append
AMD64LIRGenerator#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)::: d64 generator emit overflow check branch:::new->BranchOp->append
AMD64LIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double)::: d64 generator emit integer test branch:::emitIntegerTest->new->BranchOp->append
AMD64LIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value)::: d64 generator emit conditional move:::isFloatComparison->finalCondition->finalTrueValue->finalFalseValue->if->finalLeft->finalRight->if->AMD64ControlFlow->trueOnUnordered->if->AMD64ControlFlow->finalCondition->mirror->trueOnUnordered->finalCondition->mirror->else->if->finalCondition->negate->emitRawCompare->else->emitCompare->isParityCheckNecessary->AMD64ControlFlow->trueOnUnordered->result->finalTrueValue->getValueKind->newVariable->if->isIntConstant->isIntConstant->if->new->FloatCondSetOp->append->else->new->CondSetOp->append->else->if->isIntConstant->isIntConstant->if->if->AMD64ControlFlow->finalCondition->negate->trueOnUnordered->finalCondition->negate->new->FloatCondSetOp->append->else->new->FloatCondSetOp->append->negatedResult->result->getValueKind->newVariable->OperandSize->result->getPlatformKind->get->new->AMD64Binary.ConstOp->append->else->finalCondition->negate->new->CondSetOp->append->else->if->load->load->new->FloatCondMoveOp->append->else->load->loadNonConst->new->CondMoveOp->append->return
AMD64LIRGenerator#emitIntegerTestMove(Value, Value, Value, Value)::: d64 generator emit integer test move:::emitIntegerTest->result->trueValue->getValueKind->newVariable->load->loadNonConst->new->CondMoveOp->append->return
AMD64LIRGenerator#emitIntegerTest(Value, Value)::: d64 generator emit integer test:::size->a->getPlatformKind->if->isJavaConstant->NumUtil->asJavaConstant->asLong->is32bit->asAllocatable->asJavaConstant->asLong->new->AMD64BinaryConsumer.ConstOp->append->else->if->isJavaConstant->NumUtil->asJavaConstant->asLong->is32bit->asAllocatable->asJavaConstant->asLong->new->AMD64BinaryConsumer.ConstOp->append->else->if->isAllocatableValue->asAllocatable->asAllocatable->new->AMD64BinaryConsumer.Op->append->else->asAllocatable->asAllocatable->new->AMD64BinaryConsumer.Op->append
AMD64LIRGenerator#emitCompareMemory(AMD64Kind, Value, AMD64AddressValue, LIRFrameState):::This method emits the compare against memory instruction, and may reorder the operands:::size->switch->break->break->break->break->asAllocatable->new->AMD64BinaryConsumer.MemoryRMOp->append->return->asAllocatable->new->AMD64BinaryConsumer.MemoryRMOp->append->return->throw->GraalError->shouldNotReachHere->if->isConstantValue->return->asConstantValue->emitCompareMemoryConOp->else->return->asAllocatable->emitCompareRegMemoryOp
AMD64LIRGenerator#emitCompareMemoryConOp(OperandSize, ConstantValue, AMD64AddressValue, LIRFrameState)::: d64 generator emit compare memory con op:::if->JavaConstant->a->getConstant->isNull->new->AMD64BinaryConsumer.MemoryConstOp->append->return->else->if->a->getConstant->vc->a->getConstant->CMP->getMIOpcode->new->AMD64BinaryConsumer.MemoryVMConstOp->append->return->else->value->a->getJavaConstant->asLong->if->NumUtil->is32bit->new->AMD64BinaryConsumer.MemoryConstOp->append->return->else->return->asAllocatable->emitCompareRegMemoryOp
AMD64LIRGenerator#emitCompareRegMemoryOp(OperandSize, AllocatableValue, AMD64AddressValue, LIRFrameState)::: d64 generator emit compare reg memory op:::op->CMP->getRMOpcode->new->AMD64BinaryConsumer.MemoryRMOp->append->return
AMD64LIRGenerator#emitCompare(PlatformKind, Value, Value, Condition):::This method emits the compare instruction, and may reorder the operands:::if->LIRValueUtil->isVariable->emitRawCompare->return->cond->mirror->else->emitRawCompare->return
AMD64LIRGenerator#emitRawCompare(PlatformKind, Value, Value)::: d64 generator emit raw compare:::load->loadNonConst->emitCompareOp
AMD64LIRGenerator#emitMembar(int)::: d64 generator emit membar:::necessaryBarriers->target->requiredBarriers->if->target->new->MembarOp->append
AMD64LIRGenerator#emitCCall(long, CallingConvention, Value[], int)::: d64 generator emit call:::
AMD64LIRGenerator#emitForeignCallOp(ForeignCallLinkage, Value, Value[], Value[], LIRFrameState)::: d64 generator emit foreign call op:::maxOffset->linkage->getMaxCallTargetOffset->if->GeneratePIC->getResult->getLIR->getOptions->getValue->new->AMD64Call.DirectFarForeignCallOp->append->else->new->AMD64Call.DirectNearForeignCallOp->append
AMD64LIRGenerator#emitByteSwap(Value)::: d64 generator emit byte swap:::result->LIRKind->combine->newVariable->new->AMD64ByteSwapOp->append->return
AMD64LIRGenerator#emitArrayCompareTo(JavaKind, JavaKind, Value, Value, Value, Value)::: d64 generator emit array compare to:::resultKind->LIRKind->value->raxRes->asValue->cnt1->length1->getValueKind->asValue->cnt2->length2->getValueKind->asValue->emitMove->emitMove->new->AMD64ArrayCompareToOp->append->result->newVariable->emitMove->return
AMD64LIRGenerator#emitArrayEquals(JavaKind, Value, Value, Value, int, boolean)::: d64 generator emit array equals:::result->LIRKind->value->newVariable->asAllocatable->getMaxVectorSize->new->AMD64ArrayEqualsOp->append->return
AMD64LIRGenerator#emitArrayEquals(JavaKind, JavaKind, Value, Value, Value, int, boolean)::: d64 generator emit array equals:::result->LIRKind->value->newVariable->asAllocatable->getMaxVectorSize->new->AMD64ArrayEqualsOp->append->return
AMD64LIRGenerator#getVMPageSize():::Return a conservative estimate of the page size for use by the String.indexOf intrinsic.:::return
AMD64LIRGenerator#getMaxVectorSize():::Return the maximum size of vector registers used in SSE/AVX instructions.:::return
AMD64LIRGenerator#emitArrayIndexOf(JavaKind, JavaKind, boolean, Value, Value, Value, Value...)::: d64 generator emit array index of:::result->LIRKind->value->newVariable->getMaxVectorSize->asAllocatable->asAllocatable->asAllocatable->new->AMD64ArrayIndexOfOp->append->return
AMD64LIRGenerator#emitStringLatin1Inflate(Value, Value, Value)::: d64 generator emit string latin1 inflate:::rsrc->src->getValueKind->asValue->rdst->dst->getValueKind->asValue->rlen->len->getValueKind->asValue->emitMove->emitMove->emitMove->new->AMD64StringLatin1InflateOp->append
AMD64LIRGenerator#emitStringUTF16Compress(Value, Value, Value)::: d64 generator emit string f16 compress:::rsrc->src->getValueKind->asValue->rdst->dst->getValueKind->asValue->rlen->len->getValueKind->asValue->emitMove->emitMove->emitMove->reskind->LIRKind->value->rres->asValue->new->AMD64StringUTF16CompressOp->append->res->newVariable->emitMove->return
AMD64LIRGenerator#emitReturn(JavaKind, Value)::: d64 generator emit return:::operand->if->input->getValueKind->resultOperandFor->emitMove->new->ReturnOp->append
AMD64LIRGenerator#createStrategySwitchOp(SwitchStrategy, LabelRef[], LabelRef, Variable, AllocatableValue)::: d64 generator create strategy switch op:::return->new->StrategySwitchOp
AMD64LIRGenerator#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)::: d64 generator emit strategy switch:::needsTemp->LIRKind->isValue->key->getValueKind->newVariable->createStrategySwitchOp->append
AMD64LIRGenerator#emitTableSwitch(int, LabelRef, LabelRef[], Value)::: d64 generator emit table switch:::LIRKind->target->getWordKind->value->newVariable->key->getValueKind->newVariable->new->TableSwitchOp->append
AMD64LIRGenerator#hasherFor(JavaConstant[], double)::: d64 generator hasher for:::return->Hasher->forKeys
AMD64LIRGenerator#emitHashTableSwitch(Hasher, JavaConstant[], LabelRef, LabelRef[], Value)::: d64 generator emit hash table switch:::index->hasher->hash->scratch->LIRKind->target->getWordKind->value->newVariable->entryScratch->LIRKind->target->getWordKind->value->newVariable->new->HashTableSwitchOp->append
AMD64LIRGenerator#emitPause()::: d64 generator emit pause:::new->AMD64PauseOp->append
AMD64LIRGenerator#createZapRegisters(Register[], JavaConstant[])::: d64 generator create zap registers:::return->new->AMD64ZapRegistersOp
AMD64LIRGenerator#createZapArgumentSpace(StackSlot[], JavaConstant[])::: d64 generator create zap argument space:::return->new->AMD64ZapStackOp
AMD64LIRGenerator#emitSpeculationFence()::: d64 generator emit speculation fence:::new->AMD64LFenceOp->append
AMD64LIRKindTool#getIntegerKind(int)::: d64 kind tool get integer kind:::if->return->LIRKind->value->else->if->return->LIRKind->value->else->if->return->LIRKind->value->else->return->LIRKind->value
AMD64LIRKindTool#getFloatingKind(int)::: d64 kind tool get floating kind:::switch->return->LIRKind->value->return->LIRKind->value->throw->GraalError->shouldNotReachHere
AMD64LIRKindTool#getObjectKind()::: d64 kind tool get object kind:::return->LIRKind->reference
AMD64LIRKindTool#getWordKind()::: d64 kind tool get word kind:::return->LIRKind->value
AMD64LIRKindTool#getNarrowOopKind()::: d64 kind tool get narrow oop kind:::
AMD64LIRKindTool#getNarrowPointerKind()::: d64 kind tool get narrow pointer kind:::
AMD64LoweringProviderMixin#smallestCompareWidth()::: d64 lowering provider mixin smallest compare width:::return
AMD64LoweringProviderMixin#supportBulkZeroing()::: d64 lowering provider mixin support bulk zeroing:::return
AMD64MoveFactory#canInlineConstant(Constant)::: d64 move factory can inline constant:::if->c->switch->c->getJavaKind->return->NumUtil->c->asLong->isInt->return->return->c->isNull->return->return
AMD64MoveFactory#mayEmbedConstantLoad(Constant)::: d64 move factory may embed constant load:::return->getJavaKind->isNumericFloat
AMD64MoveFactory#allowConstantToStackMove(Constant)::: d64 move factory allow constant to stack move:::if->return->if->AMD64Move->canMoveConst2Stack->return->return
AMD64MoveFactory#createMove(AllocatableValue, Value)::: d64 move factory create move:::if->return->new->LeaOp->else->if->isConstantValue->return->asConstant->createLoad->else->if->isRegister->isStackSlotValue->return->dst->getPlatformKind->new->MoveFromRegOp->else->return->dst->getPlatformKind->new->MoveToRegOp
AMD64MoveFactory#createStackMove(AllocatableValue, AllocatableValue, Register, AllocatableValue)::: d64 move factory create stack move:::return->new->AMD64StackMove
AMD64MoveFactory#createLoad(AllocatableValue, Constant)::: d64 move factory create load:::if->return->new->MoveFromConstOp->else->if->return->new->LeaDataOp->else->throw->GraalError->String->format->shouldNotReachHere
AMD64MoveFactory#createStackLoad(AllocatableValue, Constant)::: d64 move factory create stack load:::if->return->new->MoveFromConstOp->else->throw->GraalError->String->format->shouldNotReachHere
AMD64MoveFactoryBase.BackupSlotProvider#getScratchRegister(PlatformKind)::: backup slot provider get scratch register:::key->kind->getKey->if->EconomicMap->create->else->if->categorized->containsKey->return->categorized->get->registerConfig->frameMapBuilder->getRegisterConfig->availableRegister->registerConfig->registerConfig->getAllocatableRegisters->filterAllocatableRegisters->scratchRegister->availableRegister->get->arch->frameMapBuilder->getCodeCache->getTarget->largestKind->LIRKind->arch->scratchRegister->getRegisterCategory->getLargestStorableKind->value->backupSlot->frameMapBuilder->allocateSpillSlot->value->new->RegisterBackupPair->categorized->put->return
AMD64MoveFactoryBase#createStackMove(AllocatableValue, AllocatableValue)::: d64 move factory base create stack move:::kind->result->getPlatformKind->switch->kind->getSizeInBytes->return->new->AMD64PushPopStackMove->return->new->AMD64PushPopStackMove->backup->backupSlotProvider->input->getPlatformKind->getScratchRegister->scratchRegister->backupSlot->return->createStackMove
AMD64MoveFactoryBase#createStackMove(AllocatableValue, AllocatableValue, Register, AllocatableValue)::: d64 move factory base create stack move:::
AMD64NodeLIRBuilder#emitIndirectCall(IndirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: d64 node builder emit indirect call:::targetAddressSrc->callTarget->computedAddress->operand->targetAddress->targetAddressSrc->getValueKind->asValue->gen->emitMove->callTarget->targetMethod->new->AMD64Call.IndirectCallOp->append
AMD64NodeLIRBuilder#peephole(ValueNode)::: d64 node builder peephole:::if->arithmeticGen->gen->getArithmetic->divRem->node->divRem->next->while->if->ifNode->probability->ifNode->getTrueSuccessorProbability->if->ifNode->trueSuccessor->else->if->ifNode->falseSuccessor->else->break->else->if->break->fixedWithNextNode->if->otherDivRem->if->divRem->getOp->otherDivRem->getOp->divRem->getType->otherDivRem->getType->if->otherDivRem->getX->divRem->getX->otherDivRem->getY->divRem->getY->hasOperand->results->switch->divRem->getType->arithmeticGen->divRem->getX->operand->divRem->getY->operand->state->emitSignedDivRem->break->arithmeticGen->divRem->getX->operand->divRem->getY->operand->state->emitUnsignedDivRem->break->throw->GraalError->shouldNotReachHere->switch->divRem->getOp->setResult->setResult->break->setResult->setResult->break->throw->GraalError->shouldNotReachHere->return->fixedWithNextNode->next->return
AMD64NodeLIRBuilder#getLIRGeneratorTool()::: d64 node builder get generator tool:::return
AMD64NodeMatchRules#getState(Access)::: d64 node match rules get state:::if->return->state->return
AMD64NodeMatchRules#getMemoryKind(LIRLowerableAccess)::: d64 node match rules get memory kind:::return->getLirKind->getPlatformKind
AMD64NodeMatchRules#getLirKind(LIRLowerableAccess)::: d64 node match rules get lir kind:::return->gen->access->getAccessStamp->getLIRKind
AMD64NodeMatchRules#getMemorySize(LIRLowerableAccess)::: d64 node match rules get memory size:::switch->getMemoryKind->return->return->return->return->return->return->throw->GraalError->getMemoryKind->shouldNotReachHere
AMD64NodeMatchRules#emitCompareBranchMemory(IfNode, CompareNode, ValueNode, LIRLowerableAccess)::: d64 node match rules emit compare branch memory:::cond->compare->condition->asCondition->kind->getMemoryKind->matchedAsConstant->if->value->isConstant->constant->value->asJavaConstant->if->if->constant->getJavaKind->isObject->NumUtil->constant->asLong->isInt->return->constant->getJavaKind->isObject->NumUtil->constant->asLong->isInt->if->if->kind->isXMM->ifNode->getDebug->log->return->matchedAsConstantFinal->finalCondition->GraphUtil->compare->getX->unproxify->cond->mirror->return->new->ComplexMatchResult
AMD64NodeMatchRules#emitIntegerTestBranchMemory(IfNode, ValueNode, LIRLowerableAccess)::: d64 node match rules emit integer test branch memory:::trueLabel->x->trueSuccessor->getLIRBlock->falseLabel->x->falseSuccessor->getLIRBlock->trueLabelProbability->x->x->trueSuccessor->probability->kind->getMemoryKind->size->if->value->isConstant->constant->value->asJavaConstant->if->NumUtil->constant->asLong->isInt->return->return->address->access->getAddress->operand->gen->constant->asLong->getState->new->AMD64BinaryConsumer.MemoryConstOp->append->gen->new->BranchOp->append->return->else->return->address->access->getAddress->operand->gen->gen->operand->asAllocatable->getState->new->AMD64BinaryConsumer.MemoryRMOp->append->gen->new->BranchOp->append->return
AMD64NodeMatchRules#emitConvertMemoryOp(PlatformKind, AMD64RMOp, OperandSize, Access, ValueKind)::: d64 node match rules emit convert memory op:::return->address->access->getAddress->operand->state->getState->if->address->withKind->return->getArithmeticLIRGenerator->emitConvertMemoryOp
AMD64NodeMatchRules#emitConvertMemoryOp(PlatformKind, AMD64RMOp, OperandSize, Access)::: d64 node match rules emit convert memory op:::return->emitConvertMemoryOp
AMD64NodeMatchRules#emitSignExtendMemory(Access, int, int, ValueKind)::: d64 node match rules emit sign extend memory:::kind->op->size->if->return->else->if->switch->break->break->break->throw->GraalError->unimplemented->else->switch->break->break->return->throw->GraalError->unimplemented->if->return->emitConvertMemoryOp->return
AMD64NodeMatchRules#emitReinterpretMemory(LIRKind, Access)::: d64 node match rules emit reinterpret memory:::address->access->getAddress->operand->state->getState->return->getArithmeticLIRGenerator->emitLoad
AMD64NodeMatchRules#supports(CPUFeature)::: d64 node match rules supports:::return->getLIRGeneratorTool->target->getFeatures->contains
AMD64NodeMatchRules#logicalAndNot(ValueNode, ValueNode)::: d64 node match rules logical and not:::if->supports->return->return->getArithmeticLIRGenerator->operand->operand->emitLogicalAndNot
AMD64NodeMatchRules#lowestSetIsolatedBit(ValueNode)::: d64 node match rules lowest set isolated bit:::if->supports->return->return->getArithmeticLIRGenerator->operand->emitLowestSetIsolatedBit
AMD64NodeMatchRules#getMaskUpToLowestSetBit(ValueNode, ValueNode)::: d64 node match rules get mask up to lowest set bit:::if->supports->return->if->b->isJavaConstant->return->bCst->b->asJavaConstant->bValue->if->bCst->getJavaKind->bCst->asInt->else->if->bCst->getJavaKind->bCst->asLong->else->return->if->return->getArithmeticLIRGenerator->operand->emitGetMaskUpToLowestSetBit->else->return
AMD64NodeMatchRules#resetLowestSetBit(ValueNode, ValueNode)::: d64 node match rules reset lowest set bit:::if->supports->return->if->b->isJavaConstant->return->bCst->b->asJavaConstant->bValue->if->bCst->getJavaKind->bCst->asInt->else->if->bCst->getJavaKind->bCst->asLong->else->return->if->return->getArithmeticLIRGenerator->operand->emitResetLowestSetBit->else->return
AMD64NodeMatchRules#integerTestBranchMemory(IfNode, LIRLowerableAccess, ValueNode)::: d64 node match rules integer test branch memory:::return->emitIntegerTestBranchMemory
AMD64NodeMatchRules#ifCompareMemory(IfNode, CompareNode, ValueNode, LIRLowerableAccess)::: d64 node match rules if compare memory:::return->emitCompareBranchMemory
AMD64NodeMatchRules#ifCompareValueCas(IfNode, CompareNode, ValueNode, ValueCompareAndSwapNode)::: d64 node match rules if compare value cas:::if->cas->getExpectedValue->cas->hasExactlyOneUsage->return->kind->getLirKind->trueLabel->root->trueSuccessor->getLIRBlock->falseLabel->root->falseSuccessor->getLIRBlock->trueLabelProbability->root->root->trueSuccessor->probability->expectedValue->cas->getExpectedValue->operand->newValue->cas->getNewValue->operand->address->cas->getAddress->operand->getLIRGeneratorTool->emitCompareAndSwapBranch->return->return
AMD64NodeMatchRules#ifCompareLogicCas(IfNode, CompareNode, ValueNode, LogicCompareAndSwapNode)::: d64 node match rules if compare logic cas:::constant->value->asJavaConstant->if->cas->hasExactlyOneUsage->constantValue->constant->asLong->successIsTrue->if->else->if->else->return->return->kind->getLirKind->trueLabel->root->trueSuccessor->getLIRBlock->falseLabel->root->falseSuccessor->getLIRBlock->trueLabelProbability->root->root->trueSuccessor->probability->expectedValue->cas->getExpectedValue->operand->newValue->cas->getNewValue->operand->address->cas->getAddress->operand->condition->getLIRGeneratorTool->emitCompareAndSwapBranch->return->return
AMD64NodeMatchRules#ifLogicCas(IfNode, CompareNode, ValueNode, LIRLowerableAccess)::: d64 node match rules if logic cas:::return->emitCompareBranchMemory
AMD64NodeMatchRules#rotateLeftConstant(LeftShiftNode, UnsignedRightShiftNode)::: d64 node match rules rotate left constant:::if->lshift->getShiftAmountMask->lshift->getY->asJavaConstant->asInt->rshift->getY->asJavaConstant->asInt->return->getArithmeticLIRGenerator->lshift->getX->operand->lshift->getY->operand->emitRol->return
AMD64NodeMatchRules#rotateRightVariable(ValueNode, ConstantNode, ValueNode)::: d64 node match rules rotate right variable:::if->delta->asJavaConstant->asLong->delta->asJavaConstant->asLong->return->getArithmeticLIRGenerator->operand->operand->emitRor->return
AMD64NodeMatchRules#rotateLeftVariable(ValueNode, ValueNode, ConstantNode)::: d64 node match rules rotate left variable:::if->delta->asJavaConstant->asLong->delta->asJavaConstant->asLong->return->getArithmeticLIRGenerator->operand->operand->emitRol->return
AMD64NodeMatchRules#binaryRead(AMD64RMOp, OperandSize, ValueNode, LIRLowerableAccess)::: d64 node match rules binary read:::return->getArithmeticLIRGenerator->getLIRGeneratorTool->operand->asAllocatable->access->getAddress->operand->getState->emitBinaryMemory
AMD64NodeMatchRules#binaryRead(AMD64Assembler.VexRVMOp, OperandSize, ValueNode, LIRLowerableAccess)::: d64 node match rules binary read:::return->getArithmeticLIRGenerator->getLIRGeneratorTool->operand->asAllocatable->access->getAddress->operand->getState->emitBinaryMemory
AMD64NodeMatchRules#addMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules add memory:::size->getMemorySize->if->size->isXmmType->if->getArithmeticLIRGenerator->supportAVX->return->binaryRead->else->return->binaryRead->else->return->ADD->getRMOpcode->binaryRead
AMD64NodeMatchRules#subMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules sub memory:::size->getMemorySize->if->size->isXmmType->if->getArithmeticLIRGenerator->supportAVX->return->binaryRead->else->return->binaryRead->else->return->SUB->getRMOpcode->binaryRead
AMD64NodeMatchRules#mulMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules mul memory:::size->getMemorySize->if->size->isXmmType->if->getArithmeticLIRGenerator->supportAVX->return->binaryRead->else->return->binaryRead->else->return->binaryRead
AMD64NodeMatchRules#andMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules and memory:::size->getMemorySize->if->size->isXmmType->return->else->return->AND->getRMOpcode->binaryRead
AMD64NodeMatchRules#orMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules or memory:::size->getMemorySize->if->size->isXmmType->return->else->return->OR->getRMOpcode->binaryRead
AMD64NodeMatchRules#xorMemory(ValueNode, LIRLowerableAccess)::: d64 node match rules xor memory:::size->getMemorySize->if->size->isXmmType->return->else->return->XOR->getRMOpcode->binaryRead
AMD64NodeMatchRules#writeNarrow(WriteNode, NarrowNode)::: d64 node match rules write narrow:::return->writeKind->getLIRGeneratorTool->root->value->stamp->getLIRKind->getArithmeticLIRGenerator->root->getAddress->operand->narrow->getValue->operand->state->emitStore->return
AMD64NodeMatchRules#signExtend(SignExtendNode, LIRLowerableAccess)::: d64 node match rules sign extend:::return->root->getInputBits->root->getResultBits->emitSignExtendMemory
AMD64NodeMatchRules#zeroExtend(ZeroExtendNode, LIRLowerableAccess)::: d64 node match rules zero extend:::memoryKind->getMemoryKind->return->getArithmeticLIRGenerator->root->getResultBits->access->getAddress->operand->getState->emitZeroExtendMemory
AMD64NodeMatchRules#narrowRead(NarrowNode, LIRLowerableAccess)::: d64 node match rules narrow read:::return->new->ComplexMatchResult
AMD64NodeMatchRules#signExtendNarrowRead(SignExtendNode, NarrowNode, LIRLowerableAccess)::: d64 node match rules sign extend narrow read:::kind->getLIRGeneratorTool->narrow->stamp->getLIRKind->return->narrow->getResultBits->root->getResultBits->emitSignExtendMemory
AMD64NodeMatchRules#floatConvert(FloatConvertNode, LIRLowerableAccess)::: d64 node match rules float convert:::switch->root->getFloatConvert->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->return->emitConvertMemoryOp->throw->GraalError->shouldNotReachHere
AMD64NodeMatchRules#reinterpret(ReinterpretNode, LIRLowerableAccess)::: d64 node match rules reinterpret:::return->kind->getLIRGeneratorTool->root->stamp->getLIRKind->return->emitReinterpretMemory
AMD64NodeMatchRules#writeReinterpret(WriteNode, ReinterpretNode)::: d64 node match rules write reinterpret:::return->kind->getLIRGeneratorTool->reinterpret->getValue->stamp->getLIRKind->value->getLIRGeneratorTool->reinterpret->getValue->operand->asAllocatable->address->root->getAddress->operand->getArithmeticLIRGenerator->kind->getPlatformKind->getState->emitStore->return
AMD64NodeMatchRules#getLIRGeneratorTool()::: d64 node match rules get generator tool:::return
AMD64NodeMatchRules#getArithmeticLIRGenerator()::: d64 node match rules get arithmetic generator:::return->getLIRGeneratorTool->getArithmetic
AMD64SuitesCreator#createLIRSuites(OptionValues)::: d64 suites creator create suites:::lirSuites->super->createLIRSuites->if->getValue->lirSuites->getPostAllocationOptimizationStage->new->StackMoveOptimizationPhase->appendPhase->return
