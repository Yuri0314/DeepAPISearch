Attribute.Compound#toString():::Returns a string representation of this annotation:::buf->new->StringBuilder->buf->append->buf->append->len->values->length->if->buf->append->first->foreach->if->buf->append->name->if->buf->append->buf->append->buf->append->buf->append->return->buf->toString
ClassFinder#instance(Context):::Get the ClassFinder instance for this invocation.:::instance->context->get->if->new->ClassFinder->return
ClassFinder#getSupplementaryFlags(ClassSymbol):::Returns any extra flags for a class symbol:::if->jrtIndex->isInJRT->return->if->new->HashMap<>->flags->supplementaryFlags->c->packge->get->if->newFlags->try->ctSym->jrtIndex->c->packge->flatName->getCtSym->minProfile->if->if->Profile->lookup->if->catch->finally->supplementaryFlags->c->packge->put->return
ClassFinder#fillIn(ClassSymbol):::Fill in definition of class `c' from corresponding class or  source file.:::if->msg->diagFactory->fragment->throw->new->CompletionFailure->classfile->if->previousClassFile->prevOwner->prevName->try->if->Assert->classfile->toUri->error->if->log->currentClassFile->getName->printVerbose->if->classfile->getKind->reader->readClassFile->getSupplementaryFlags->else->if->sourceCompleter->isTerminal->sourceCompleter->complete->else->throw->classfile->toUri->new->IllegalStateException->catch->getSymbols->csym->sym->packge->members->enter->sym->flatName->Convert->sym->flatName->shortName->csym->reset->forEach->Convert->shortName->c->reset->throw->finally->else->throw->classFileNotFound
ClassFinder#loadClass(ModuleSymbol, Name):::Load a toplevel class with given fully qualified name  The class is entered into `classes' only if load was successful.:::Assert->checkNonNull->packageName->Convert->packagePart->ps->syms->lookupPackage->Assert->checkNonNull->absent->syms->getClass->c->syms->enterClass->if->try->c->complete->catch->if->syms->removeClass->classSymbolRemoved->throw->finally->return
ClassFinder#includeClassFile(PackageSymbol, JavaFileObject):::Include class corresponding to given class file in package,  unless (1) we already have one the same kind (.class or .java), or         (2) we have one of the other kind, and the given class file             is older.:::if->for->q->kind->file->getKind->seen->if->else->binaryName->fileManager->inferBinaryName->lastDot->binaryName->lastIndexOf->classname->names->binaryName->substring->fromString->isPkgInfo->c->findFirst->if->syms->enterClass->if->if->else->if->enter->else->if->if->preferredFileObject
ClassFinder#preferredFileObject(JavaFileObject, JavaFileObject):::Implement policy to choose to derive information from a source  file or a class file when both are present:::if->return->a->getKind->else->adate->a->getLastModified->bdate->b->getLastModified->return
ClassFinder#extraFileActions(PackageSymbol, JavaFileObject):::this is used to support javadoc:::
DeferredLintHandler#report(LintLogger):::Associate the given logger with the current position as set by #setPos(DiagnosticPosition) :::if->logger->report->else->loggers->loggersQueue->get->if->loggersQueue->new->ListBuffer<>->put->loggers->append
DeferredLintHandler#flush(DiagnosticPosition):::Invoke all LintLoggers that were associated with the provided pos.:::loggers->loggersQueue->get->if->foreach->lintLogger->report->loggersQueue->remove
DeferredLintHandler#setPos(DiagnosticPosition):::Sets the current position to the provided currentPos:::prevPosition->return
DeferredLintHandler#immediate():::LintLoggers passed to subsequent invocations of #report(LintLogger)  will be invoked immediately.:::return->setPos
Kinds.KindSelector#kindNames():::A set of KindName(s) representing a set of symbol's kinds.:::kinds->EnumSet->noneOf->if->if->kinds->add->else->kinds->add->if->kinds->add->if->kinds->add->if->kinds->add->if->kinds->add->return
Kinds#kindName(Symbol):::A KindName representing a given symbol:::switch->sym->getKind->return->return->return->return->return->return->return->return->return->return->throw->sym->getKind->new->AssertionError
Kinds#typeKindName(Type):::A KindName representing the kind of a given class/interface type.:::if->t->hasTag->t->hasTag->flags->return->else->if->t->hasTag->return->else->if->return->else->if->return->else->return
Lint#instance(Context):::Get the root Lint instance.:::instance->context->get->if->new->Lint->return
Lint#augment(Attribute.Compound):::Returns the result of combining the values in this object with the given annotation.:::return->augmentor->augment
Lint#augment(Symbol):::Returns the result of combining the values in this object with the metadata on the given symbol.:::l->augmentor->sym->getDeclarationAttributes->augment->if->sym->isDeprecated->if->new->Lint->remove->add->return
Lint#suppress(LintCategory...):::Returns a new Lint that has the given LintCategorys suppressed.:::l->new->Lint->Arrays->asList->removeAll->Arrays->asList->addAll->return
Lint#isEnabled(LintCategory):::Checks if a warning category is enabled:::return->values->contains
Lint#isSuppressed(LintCategory):::Checks is a warning category has been specifically suppressed, by means of the SuppressWarnings annotation, or, in the case of the deprecated category, whether it has been implicitly suppressed by virtue of the current entity being itself deprecated.:::return->suppressedValues->contains
ModuleFinder#instance(Context):::Get the ModuleFinder instance for this invocation.:::instance->context->get->if->new->ModuleFinder->return
Preview#warnPreview(int, Feature):::Report usage of a preview feature:::new->SimpleDiagnosticPosition->warnPreview
Preview#warnPreview(DiagnosticPosition, Feature):::Report usage of a preview feature:::Assert->isEnabled->check->Assert->isPreview->check->if->lint->isSuppressed->previewHandler->feature->isPlural->Warnings->feature->nameFragment->PreviewFeatureUsePlural->Warnings->feature->nameFragment->PreviewFeatureUse->report
Preview#warnPreview(JavaFileObject, int):::Report usage of a preview feature in classfile.:::Assert->isEnabled->check->if->lint->isSuppressed->previewHandler->Warnings->majorVersionToSource->get->PreviewFeatureUseClassfile->report
Preview#isEnabled():::Are preview features enabled?:::return
Preview#isPreview(Feature):::Is given feature a preview feature?:::return
Preview#disabledError(Feature):::Generate an error key which captures the fact that a given preview feature could not be used due to the preview feature support being disabled.:::Assert->isEnabled->check->return->feature->isPlural->Errors->feature->nameFragment->PreviewFeatureDisabledPlural->Errors->feature->nameFragment->PreviewFeatureDisabled
Preview#disabledError(JavaFileObject, int):::Generate an error key which captures the fact that a preview classfile cannot be loaded due to the preview feature support being disabled.:::Assert->isEnabled->check->return->Errors->majorVersionToSource->get->PreviewFeatureDisabledClassfile
Preview#reportDeferredDiagnostics():::Report any deferred diagnostics.:::previewHandler->reportDeferredDiagnostic
Printer#localize(Locale, String, Object...):::This method should be overriden in order to provide proper i18n support.:::
Printer#capturedVarId(CapturedType, Locale):::Maps a captured type into an unique identifier.:::
Printer#createStandardPrinter(Messages):::Create a printer with default i18n support provided by Messages:::return->new->Printer
Printer#visitTypes(List, Locale):::Get a localized string representation for all the types in the input list.:::sbuf->new->ListBuffer<>->foreach->sbuf->visit->append->return->sbuf->toList->toString
Printer#visitSymbols(List, Locale):::* Get a localized string representation for all the symbols in the input list.:::sbuf->new->ListBuffer<>->foreach->sbuf->visit->append->return->sbuf->toList->toString
Printer#visit(Type, Locale):::Get a localized string representation for a given type.:::return->t->accept
Printer#visit(Symbol, Locale):::Get a localized string representation for a given symbol.:::return->s->accept
Printer#className(ClassType, boolean, Locale):::Converts a class name into a (possibly localized) string:::sym->if->length->sym->flags->s->visit->new->StringBuilder->for->is->is->nonEmpty->return->s->toString->else->if->length->s->norm->if->localize->else->if->nonEmpty->visit->localize->else->visit->localize->return->else->if->return->sym->getQualifiedName->toString->else->return->toString
Printer#printMethodArgs(List, boolean, Locale):::Converts a set of method argument types into their corresponding localized string representation.:::if->return->visitTypes->else->buf->new->StringBuilder->while->nonEmpty->buf->visit->append->buf->append->if->hasTag->buf->visit->append->if->getAnnotationMirrors->nonEmpty->buf->append->buf->getAnnotationMirrors->append->buf->append->buf->append->else->buf->visit->append->return->buf->toString
Scope#getSymbols():::Returns all Symbols in this Scope:::return->getSymbols
Scope#getSymbols(Filter):::Returns Symbols that match the given filter:::return->getSymbols
Scope#getSymbols(LookupKind):::Returns all Symbols in this Scope:::return->getSymbols
Scope#getSymbols(Filter, LookupKind):::Returns Symbols that match the given filter:::
Scope#getSymbolsByName(Name):::Returns Symbols with the given name:::return->getSymbolsByName
Scope#getSymbolsByName(Name, Filter):::Returns Symbols with the given name that match the given filter:::return->getSymbolsByName
Scope#getSymbolsByName(Name, LookupKind):::Returns Symbols with the given name:::return->getSymbolsByName
Scope#getSymbolsByName(Name, Filter, LookupKind):::Returns Symbols with the given name that match the given filter:::
Scope#findFirst(Name):::Return the first Symbol from this or outward scopes with the given name:::return->findFirst
Scope#findFirst(Name, Filter):::Return the first Symbol from this or outward scopes with the given name that matches the  given filter:::it->getSymbolsByName->iterator->return->it->hasNext->it->next
Scope#anyMatch(Filter):::Returns true iff there are is at least one Symbol in this scope matching the given filter:::return->getSymbols->iterator->hasNext
Scope#includes(Symbol):::Returns true iff the given Symbol is in this scope or any outward scope.:::return->includes
Scope#includes(Symbol, LookupKind):::Returns true iff the given Symbol is in this scope, optionally checking outward scopes.:::return->getSymbolsByName->iterator->hasNext
Scope#isEmpty():::Returns true iff this scope does not contain any Symbol:::return->getSymbols->iterator->hasNext
Scope#getOrigin(Symbol):::Returns the Scope from which the givins Symbol originates in this scope.:::
Scope#isStaticallyImported(Symbol):::Returns true iff the given Symbol is part of this scope due to a static import.:::
Scope.WriteableScope#enter(Symbol):::Enter the given Symbol into this scope.:::
Scope.WriteableScope#enterIfAbsent(Symbol):::Enter symbol sym in this scope if not already there.:::
Scope.WriteableScope#dup():::Construct a fresh scope within this scope, with same owner:::return->dup
Scope.WriteableScope#dup(Symbol):::Construct a fresh scope within this scope, with new owner:::
Scope.WriteableScope#leave():::Must be called on dup-ed scopes to be able to work with the outward scope again.:::
Scope.WriteableScope#dupUnshared():::Construct a fresh scope within this scope, with same owner:::return->dupUnshared
Scope.WriteableScope#dupUnshared(Symbol):::Construct a fresh scope within this scope, with new owner:::
Scope.WriteableScope#create(Symbol):::Create a new WriteableScope.:::return->new->ScopeImpl
Scope.ImportScope#finalizeScope():::Finalize the content of the ImportScope to speed-up future lookups:::for->scopes->toList->scopes->nonEmpty
Symbol#flags():::An accessor method for the flags of this symbol:::return
Symbol#getRawAttributes():::An accessor method for the attributes of this symbol:::return->List->nil->metadata->getDeclarationAttributes
Symbol#getRawTypeAttributes():::An accessor method for the type attributes of this symbol:::return->List->nil->metadata->getTypeAttributes
Symbol#attribute(Symbol):::Fetch a particular annotation from a symbol.:::foreach->getRawAttributes->if->return->return
Symbol#getMetadata():::This method is intended for debugging only.:::return
Symbol#clone(Symbol):::Clone this symbol with new owner:::throw->new->AssertionError
Symbol#toString():::The Java source which this symbol represents:::return->name->toString
Symbol#location():::A Java source description of the location of this symbol; used for  error reporting.:::if->isEmpty->owner->flags->return->return
Symbol#erasure(Types):::The symbol's erased type.:::if->types->erasure->return
Symbol#externalType(Types):::The external type of a symbol:::t->erasure->if->owner->hasOuterInstance->outerThisType->types->getEnclosingType->erasure->return->t->getParameterTypes->prepend->t->getReturnType->t->getThrownTypes->new->MethodType->else->return
Symbol#isLocal():::Is this symbol declared (directly or indirectly) local  to a method or variable initializer?  Also includes fields of inner classes which are in  turn local to a method or variable initializer.:::return->matches->owner->isLocal
Symbol#isAnonymous():::Has this symbol an empty name? This includes anonymous  inner classes.:::return->name->isEmpty
Symbol#isConstructor():::Is this symbol a constructor?:::return
Symbol#getQualifiedName():::The fully qualified name of this symbol:::return
Symbol#flatName():::The fully qualified name of this symbol after converting to flat  representation:::return->getQualifiedName
Symbol#members():::If this is a class or package, its members, otherwise null.:::return
Symbol#isInner():::A class is an inner class if it it has an enclosing instance class.:::return->type->getEnclosingType->hasTag
Symbol#hasOuterInstance():::An inner class has an outer instance if it is not an interface  it has an enclosing instance class which might be referenced from the class:::return->type->getEnclosingType->hasTag->flags
Symbol#enclClass():::The closest enclosing class of this symbol's declaration:::c->while->matches->hasTag->return
Symbol#outermostClass():::The outermost class which indirectly owns this symbol.:::sym->prev->while->return
Symbol#packge():::The package which indirectly owns this symbol.:::sym->while->return
Symbol#isSubClass(Symbol, Types):::Is this symbol a subclass of `base'? Only defined for ClassSymbols.:::throw->new->AssertionError
Symbol#isMemberOf(TypeSymbol, Types):::Fully check membership: hierarchy, protection, and hiding:::return->clazz->isSubClass->isInheritedIn->hiddenIn
Symbol#isEnclosedBy(ClassSymbol):::Is this symbol the same as or enclosed by the given class?:::for->sym->return
Symbol#isAccessibleIn(Symbol, Types):::Is this symbol accessible in a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       the given class.:::switch->return->return->return->clazz->flags->thisPackage->this->packge->for->sup->types->supertype->return->clazz->flags
Symbol#isInheritedIn(Symbol, Types):::Is this symbol inherited into a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       of the given class.:::return->isAccessibleIn
Symbol#asMemberOf(Type, Types):::The (variable or method) symbol seen as a member of given  class type`site' (this might change the symbol's type):::throw->new->AssertionError
Symbol#overrides(Symbol, TypeSymbol, Types, boolean):::Does this method symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::return
Symbol#complete():::Complete the elaboration of this symbol's definition.:::if->c->c->complete
Symbol#exists():::True if the symbol represents an entity that exists.:::return
Symbol#getAnnotationMirrors():::This is the implementation for javax.lang.model.element.Element.getAnnotationMirrors().:::apiComplete->return->getRawAttributes
Symbol.TypeSymbol#formFullName(Name, Symbol):::form a fully qualified name from a name and an owner:::if->return->if->matches->hasTag->return->prefix->owner->getQualifiedName->if->return->else->return->prefix->append
Symbol.TypeSymbol#formFlatName(Name, Symbol):::form a fully qualified name from a name and an owner, after  converting to flat representation:::if->matches->hasTag->return->sep->prefix->owner->flatName->if->return->else->return->prefix->append
Symbol.TypeSymbol#precedes(TypeSymbol, Types):::A partial ordering between type symbols that refines the class inheritance graph:::if->return->if->type->getTag->hasTag->if->type->hasTag->return->types->rank->types->rank->types->rank->types->rank->that->getQualifiedName->this->getQualifiedName->compareTo->else->if->type->hasTag->return->types->isSubtype->return->type->hasTag
Symbol.ModuleSymbol#create(Name, Name):::Create a ModuleSymbol with an associated module-info ClassSymbol.:::msym->new->ModuleSymbol->info->new->ClassSymbol->formFullName->WriteableScope->create->return
Symbol.PackageSymbol#exists():::A package "exists" if a type or package that exists has  been seen within it.:::return
Symbol.PackageSymbol#reset():::Resets the Symbol into the state good for next round of annotation processing.:::
Symbol.ClassSymbol#toString():::The Java source which this symbol represents.:::return->className
Symbol.ClassSymbol#complete():::Complete the elaboration of this symbol's definition.:::origCompleter->try->super->complete->catch->classSymbolCompleteFailed->new->ErrorType->throw->finally
Symbol.ClassSymbol#reset():::Resets the Symbol into the state good for next round of annotation processing.:::if->t->t->setEnclosingType->clearAnnotationMetadata
Symbol.VarSymbol#clone(Symbol):::Clone this symbol with new owner.:::v->new->VarSymbol->return
Symbol.MethodSymbol#clone(Symbol):::Clone this symbol with new owner.:::m->new->MethodSymbol->return
Symbol.MethodSymbol#toString():::The Java source which this symbol represents.:::if->flags->return->toString->else->s->toString->name->toString->if->if->type->hasTag->getTypeArguments->type->flags->argtypes->return
Symbol.MethodSymbol#implemented(TypeSymbol, Types):::find a symbol that this (proxy method) symbol implements.:::impl->for->is->types->interfaces->is->nonEmpty->return
Symbol.MethodSymbol#binaryOverrides(Symbol, TypeSymbol, Types):::Will the erasure of this method be considered by the VM to  override the erasure of the other when seen from class `origin'?:::if->isConstructor->return->if->return->other->if->other->isOverridableIn->types->asSuper->types->erasure->other->erasure->isSameType->return->return->flags->other->isOverridableIn->this->isMemberOf->types->erasure->other->erasure->isSameType
Symbol.MethodSymbol#binaryImplementation(ClassSymbol, Types):::The implementation of this (abstract) symbol in class origin,  from the VM's point of view, null if method does not have an  implementation in class.:::for->c->types->supertype->return
Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean):::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::return->overrides
Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean, boolean):::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::if->isConstructor->return->if->return->other->if->other->isOverridableIn->types->asSuper->mt->types->memberType->ot->types->memberType->if->types->isSubSignature->if->return->if->types->returnTypeSubstitutable->return->if->flags->other->flags->other->flags->other->isOverridableIn->this->isMemberOf->return->mt->types->memberType->ot->types->memberType->return->types->isSubSignature->types->resultSubtype
Symbol.MethodSymbol#implementation(TypeSymbol, Types, boolean):::The implementation of this (abstract) symbol in class origin;  null if none exists:::return->implementation
Symbol.Completer#isTerminal():::Returns true if this completer is terminal:::return
Symtab#instance(Context):::Get the symbol table instance.:::instance->context->get->if->new->Symtab->return
Symtab#defineClass(Name, Symbol):::Define a new class given its name and owner.:::c->new->ClassSymbol->return
Symtab#enterClass(ModuleSymbol, Name, TypeSymbol):::Create a new toplevel or member class symbol with given name  and owner and enter in `classes' unless already there.:::Assert->checkNonNull->flatname->TypeSymbol->formFlatName->c->getClass->if->defineClass->doEnterClass->else->if->members->remove->ClassSymbol->formFullName->return
Symtab#enterClass(ModuleSymbol, Name):::Create a new member or toplevel class symbol with given flat name  and enter in `classes' unless already there.:::Assert->checkNonNull->ps->Convert->packagePart->lookupPackage->Assert->checkNonNull->Assert->checkNonNull->c->getClass->if->Convert->shortName->defineClass->doEnterClass->return->else->return
Symtab#packageExists(ModuleSymbol, Name):::Check to see if a package exists, given its fully qualified name.:::Assert->checkNonNull->return->lookupPackage->exists
Symtab#enterPackage(ModuleSymbol, Name):::Make a package, given its fully qualified name.:::Assert->checkNonNull->p->getPackage->if->Assert->fullname->isEmpty->check->Convert->shortName->Convert->packagePart->enterPackage->new->PackageSymbol->doEnterPackage->return
Type#hasTag(TypeTag):::Checks if the current type tag is equal to the given tag.:::return->getTag
Type#getTag():::Returns the current type tag.:::
Type#constValue():::The constant value of this type, null if this type does not have a constant value attribute:::return
Type#isFalse():::Is this a constant type whose value is false?:::return
Type#isTrue():::Is this a constant type whose value is true?:::return
Type#getModelType():::Get the representation of this type used for modelling purposes:::return
Type#getOriginalType():::For ErrorType, returns the original type, otherwise returns the type itself.:::return
Type#map(TypeMapping, Z):::map a type function over all immediate descendants of this type:::return->mapping->visit
Type#map(TypeMapping):::map a type function over all immediate descendants of this type (no arg version):::return->mapping->visit
Type#constType(Object):::Define a constant type, of the same kind as this type  and with given constant value:::throw->new->AssertionError
Type#baseType():::If this is a constant type, return its underlying type:::return
Type#typeNoMetadata():::Returns the original version of this type, before metadata were added:::return->baseType
Type#cloneWithMetadata(TypeMetadata):::Create a new copy of this type but with the specified TypeMetadata.:::
Type#needsStripping():::Does this type require annotation stripping for API clients?:::return
Type#stripMetadataIfNeeded():::Strip all metadata associated with this type - this could return a new clone of the type:::return->needsStripping->accept
Type#baseTypes(List):::Return the base types of a list of types.:::if->ts->nonEmpty->t->baseType->baseTypes->baseTypes->if->return->baseTypes->prepend->return
Type#toString():::The Java source which this type represents.:::sb->new->StringBuilder->appendAnnotationsString->if->sb->append->else->sb->append->if->hasTag->sb->hashCode->append->return->sb->toString
Type#toString(List):::The Java source which this type list represents:::if->ts->isEmpty->return->else->buf->new->StringBuilder->buf->toString->append->for->l->l->nonEmpty->return->buf->toString
Type#stringValue():::The constant value of this type, converted to String:::cv->Assert->constValue->checkNonNull->return->cv->toString
Type#equals(Object):::Override this method with care:::return
Type#getTypeArguments():::Access methods.:::return->List->nil
Type#allparams():::Return all parameters of this type and all its outer types in order  outer (first) to inner (last).:::return->List->nil
Type#isErroneous():::Does this type contain "error" elements?:::return
Type#isParameterized():::Is this type parameterized?  A class type is parameterized if it has some parameters:::return
Type#isRaw():::Is this type a raw type?  A class type is a raw type if it misses some of its parameters:::return
Type#isCompound():::A compound type is a special class type whose supertypes are used to store a list of component types:::return
Type#contains(Type):::Does this type contain occurrences of type t?:::return->t->equalsIgnoreMetadata
Type#containsAny(List):::Does this type contain an occurrence of some type in 'ts'?:::foreach->if->this->contains->return->return
Type#asMethodType():::The underlying method type of this type.:::throw->new->AssertionError
Type#complete():::Complete loading all classes in this type.:::
Type.JCPrimitiveType#constType(Object):::Define a constant type, of the same kind as this type  and with given constant value:::value->return->new->JCPrimitiveType
Type.JCPrimitiveType#stringValue():::The constant value of this type, converted to String:::cv->Assert->constValue->checkNonNull->if->return->intValue->else->if->return->String->intValue->valueOf->else->return->cv->toString
Type.JCPrimitiveType#isFalse():::Is this a constant type whose value is false?:::return->constValue->constValue->intValue
Type.JCPrimitiveType#isTrue():::Is this a constant type whose value is true?:::return->constValue->constValue->intValue
Type.ClassType#toString():::The Java source which this type represents.:::buf->new->StringBuilder->if->getEnclosingType->hasTag->buf->getEnclosingType->toString->append->buf->append->appendAnnotationsString->buf->className->append->else->appendAnnotationsString->buf->className->append->if->getTypeArguments->nonEmpty->buf->append->buf->getTypeArguments->toString->append->buf->append->return->buf->toString
Type.ClassType#isRaw():::A class type is raw if it misses some  of its type parameter sections:::return->allparams->nonEmpty->allparams->isEmpty
Type.MethodType#toString():::The Java source which this type represents:::sb->new->StringBuilder->appendAnnotationsString->sb->append->sb->append->sb->append->sb->append->return->sb->toString
Type.UndetVar.UndetVarListener#varBoundChanged(UndetVar, InferenceBound, Type, boolean):::called when some inference variable bounds (of given kinds ibs) change:::
Type.UndetVar.UndetVarListener#varInstantiated(UndetVar):::called when the inferred type is set on some inference variable:::Assert->error
Type.UndetVar#dup(Types):::Returns a new copy of this undet var.:::uv2->new->UndetVar->dupTo->return
Type.UndetVar#dupTo(UndetVar, Types):::Dumps the contents of this undet var on another undet var.:::clear->foreach->InferenceBound->values->List->nil->put->foreach->getBounds->uv2->addBound->new->ArrayDeque<>->foreach->action->dup->add
Type.UndetVar#getBounds(InferenceBound...):::get all bounds of a given kind:::buf->new->ListBuffer<>->foreach->buf->bounds->get->appendList->return->buf->toList
Type.UndetVar#getDeclaredBounds():::get the list of declared (upper) bounds:::buf->new->ListBuffer<>->count->foreach->getBounds->if->break->buf->append->return->buf->toList
Type.UndetVar#setBounds(InferenceBound, List):::internal method used to override an undetvar bounds:::bounds->put
Type.UndetVar#addBound(InferenceBound, Type, Types):::add a bound of a given kind - this might trigger listener notification:::if->switch->types->cvarUpperBound->break->altBound->types->cvarLowerBound->if->altBound->hasTag->break->addBound
Type.UndetVar#substBounds(List, List, Types):::replace types in all bounds - this might trigger listener notification:::boundsChanged->new->ListBuffer<>->prevListener->try->Assert->check->boundsChanged->new->Pair<>->add->foreach->bounds->entrySet->ib->_entry->getKey->prevBounds->_entry->getValue->newBounds->new->ListBuffer<>->deps->new->ListBuffer<>->foreach->if->t->containsAny->newBounds->append->else->deps->append->bounds->newBounds->toList->put->foreach->types->subst->addBound->catch->finally->foreach->notifyBoundChange
TypeAnnotationPosition#emitToClassfile():::Indicates whether the target tree of the annotation has been optimized away from classfile or not.:::return->type->isLocal
TypeAnnotationPosition#getTypePathFromBinary(java.util.List):::Decode the binary representation for a type path and set the location field.:::loc->new->ListBuffer<>->iter->list->iterator->while->iter->hasNext->fst->iter->next->Assert->iter->hasNext->check->snd->iter->next->loc->TypePathEntry->fromBinary->append->return->loc->toList
TypeAnnotationPosition#methodReturn(List, JCLambda, int):::Create a TypeAnnotationPosition for a method return.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodReturn(List):::Create a TypeAnnotationPosition for a method return.:::return->methodReturn
TypeAnnotationPosition#methodReturn(int):::Create a TypeAnnotationPosition for a method return.:::return->methodReturn
TypeAnnotationPosition#methodReceiver(List, JCLambda, int):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodReceiver(List):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->methodReceiver
TypeAnnotationPosition#methodReceiver(int):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->methodReceiver
TypeAnnotationPosition#methodParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodParameter(JCLambda, int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodParameter(int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodParameter(List, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodRef(List, JCLambda, int):::Create a TypeAnnotationPosition for a method reference.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodRef(List):::Create a TypeAnnotationPosition for a method reference.:::return->methodRef
TypeAnnotationPosition#constructorRef(List, JCLambda, int):::Create a TypeAnnotationPosition for a constructor reference.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorRef(List):::Create a TypeAnnotationPosition for a constructor reference.:::return->constructorRef
TypeAnnotationPosition#field(List, JCLambda, int):::Create a TypeAnnotationPosition for a field.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#field(List):::Create a TypeAnnotationPosition for a field.:::return->field
TypeAnnotationPosition#field(int):::Create a TypeAnnotationPosition for a field.:::return->field
TypeAnnotationPosition#localVariable(List, JCLambda, int):::Create a TypeAnnotationPosition for a local variable.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#localVariable(JCLambda, int):::Create a TypeAnnotationPosition for a local variable.:::return->localVariable
TypeAnnotationPosition#localVariable(List):::Create a TypeAnnotationPosition for a local variable.:::return->localVariable
TypeAnnotationPosition#exceptionParameter(List, JCLambda, int):::Create a TypeAnnotationPosition for an exception parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#exceptionParameter(JCLambda, int):::Create a TypeAnnotationPosition for an exception parameter.:::return->exceptionParameter
TypeAnnotationPosition#exceptionParameter(List):::Create a TypeAnnotationPosition for an exception parameter.:::return->exceptionParameter
TypeAnnotationPosition#resourceVariable(List, JCLambda, int):::Create a TypeAnnotationPosition for a resource variable.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#resourceVariable(JCLambda, int):::Create a TypeAnnotationPosition for a resource variable.:::return->resourceVariable
TypeAnnotationPosition#resourceVariable(List):::Create a TypeAnnotationPosition for a resource variable.:::return->resourceVariable
TypeAnnotationPosition#newObj(List, JCLambda, int):::Create a TypeAnnotationPosition for a new.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#newObj(int):::Create a TypeAnnotationPosition for a new.:::return->newObj
TypeAnnotationPosition#newObj(List):::Create a TypeAnnotationPosition for a new.:::return->newObj
TypeAnnotationPosition#classExtends(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a class extension.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#classExtends(List, JCLambda, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(List, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(int, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#instanceOf(List, JCLambda, int):::Create a TypeAnnotationPosition for an instanceof.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#instanceOf(List):::Create a TypeAnnotationPosition for an instanceof.:::return->instanceOf
TypeAnnotationPosition#typeCast(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a type cast.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeCast(List, int):::Create a TypeAnnotationPosition for a type cast.:::return->typeCast
TypeAnnotationPosition#methodInvocationTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method invocation type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodInvocationTypeArg(List, int):::Create a TypeAnnotationPosition for a method invocation type argument.:::return->methodInvocationTypeArg
TypeAnnotationPosition#constructorInvocationTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a constructor invocation type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorInvocationTypeArg(List, int):::Create a TypeAnnotationPosition for a constructor invocation type argument.:::return->constructorInvocationTypeArg
TypeAnnotationPosition#typeParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a type parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeParameter(List, int):::Create a TypeAnnotationPosition for a type parameter.:::return->typeParameter
TypeAnnotationPosition#methodTypeParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method type parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodTypeParameter(List, int):::Create a TypeAnnotationPosition for a method type parameter.:::return->methodTypeParameter
TypeAnnotationPosition#methodThrows(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a throws clause.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodThrows(List, int):::Create a TypeAnnotationPosition for a throws clause.:::return->methodThrows
TypeAnnotationPosition#methodRefTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method reference type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodRefTypeArg(List, int):::Create a TypeAnnotationPosition for a method reference type argument.:::return->methodRefTypeArg
TypeAnnotationPosition#constructorRefTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a constructor reference type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorRefTypeArg(List, int):::Create a TypeAnnotationPosition for a constructor reference type argument.:::return->constructorRefTypeArg
TypeAnnotationPosition#typeParameterBound(List, JCLambda, int, int, int):::Create a TypeAnnotationPosition for a type parameter bound.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeParameterBound(List, int, int):::Create a TypeAnnotationPosition for a type parameter bound.:::return->typeParameterBound
TypeAnnotationPosition#methodTypeParameterBound(List, JCLambda, int, int, int):::Create a TypeAnnotationPosition for a method type parameter bound.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodTypeParameterBound(List, int, int):::Create a TypeAnnotationPosition for a method type parameter bound.:::return->methodTypeParameterBound
TypeAnnotations#organizeTypeAnnotationsSignatures(Env, JCClassDecl):::Separate type annotations from declaration annotations and determine the correct positions for type annotations:::annotate->oldSource->log->useSource->try->new->TypeAnnotationPositions->scan->catch->finally->log->useSource->afterTypes
TypeAnnotations#organizeTypeAnnotationsBodies(JCClassDecl):::This version only visits types in bodies, that is, field initializers, top-level blocks, and method bodies, and should be called from Attr.:::new->TypeAnnotationPositions->scan
TypeAnnotations#annotationTargetType(Attribute.Compound, Symbol):::Determine whether an annotation is a declaration annotation, a type annotation, or both.:::targets->annotationTargets->return->targets->stream->targetToAnnotationType->map->this->combineAnnotationType->reduce
TypeMetadata#combine(Entry):::Return a copy of this TypeMetadata with the metadata entry for elem.kind() combined with elem.:::Assert->checkNonNull->out->new->TypeMetadata->key->elem->kind->if->contents->containsKey->out->get->combine->add->else->out->add->return
TypeMetadata#combineAll(TypeMetadata):::Return a copy of this TypeMetadata with the metadata entry for all kinds from other combined with the same kind from this.:::Assert->checkNonNull->out->new->TypeMetadata->keys->contents->keySet->new->HashSet<>->keys->keySet->addAll->foreach->if->contents->containsKey->if->containsKey->out->contents->get->get->combine->add->else->out->contents->get->add->else->if->containsKey->out->get->add->return
TypeMetadata#without(Entry.Kind):::Return a TypeMetadata with the metadata entry for kind removed:::if->contents->get->return->out->new->TypeMetadata->remove->return->isEmpty
TypeMetadata.Entry#kind():::Get the kind of metadata this object represents:::
TypeMetadata.Entry#combine(Entry):::Combine this type metadata with another metadata of the same kind.:::
TypeMetadata.Annotations#getAnnotations():::Get the type annotations contained in this metadata.:::return
Types#wildUpperBound(Type):::Get a wildcard's upper bound, returning non-wildcards unchanged.:::if->t->hasTag->w->if->w->isSuperBound->return->else->return->wildUpperBound->else->return
Types#cvarUpperBound(Type):::Get a capture variable's upper bound, returning other types unchanged.:::if->t->hasTag->v->return->v->isCaptured->cvarUpperBound->else->return
Types#wildLowerBound(Type):::Get a wildcard's lower bound, returning non-wildcards unchanged.:::if->t->hasTag->w->return->w->isExtendsBound->wildLowerBound->else->return
Types#cvarLowerBound(Type):::Get a capture variable's lower bound, returning other types unchanged.:::if->t->hasTag->isCaptured->return->t->getLowerBound->cvarLowerBound->else->return
Types#skipTypeVars(Type, boolean):::Recursively skip type-variables until a class/array type is found; capture conversion is then (optionally) applied to the resulting type:::while->site->hasTag->site->getUpperBound->return->capture
Types#upward(Type, List):::Computes an upward projection of given type, and vars:::return->t->new->TypeProjection->map
Types#captures(Type):::Computes the set of captured variables mentioned in a given type:::cs->new->CaptureScanner->captures->new->HashSet<>->cs->visit->return->List->from
Types#isUnbounded(Type):::Checks that all the arguments to a class are unbounded wildcards or something else that doesn't make any restrictions on the arguments:::return->isUnbounded->visit
Types#asSub(Type, Symbol):::Return the least specific subtype of t that starts with symbol sym:::return->asSub->visit
Types#isConvertible(Type, Type, Warner):::Is t a subtype of or convertible via boxing/unboxing conversion to s?:::if->t->hasTag->return->tPrimitive->t->isPrimitive->sPrimitive->s->isPrimitive->if->return->isSubtypeUnchecked->tUndet->t->hasTag->sUndet->s->hasTag->if->return->boxedTypeOrType->isSubtype->boxedTypeOrType->isSubtype->return->boxedClass->isSubtype->unboxedType->isSubtype
Types#isConvertible(Type, Type):::Is t a subtype of or convertible via boxing/unboxing conversions to s?:::return->isConvertible
Types.DescriptorCache#findDescriptorInternal(TypeSymbol, CompoundScope):::Compute the function descriptor associated with a given functional interface:::if->origin->isInterface->origin->flags->throw->failure->abstracts->new->ListBuffer<>->foreach->membersCache->new->DescriptorFilter->getSymbols->mtype->memberType->if->abstracts->isEmpty->abstracts->append->else->if->abstracts->first->abstracts->first->memberType->overrideEquivalent->if->abstracts->stream->sym->enclClass->isSubClass->filter->memberType->map->isSubSignature->anyMatch->abstracts->append->else->throw->diags->Fragments->Kinds->kindName->IncompatibleAbstracts->fragment->failure->if->abstracts->isEmpty->throw->diags->Fragments->Kinds->kindName->NoAbstracts->fragment->failure->else->if->abstracts->size->return->abstracts->first->new->FunctionDescriptor->else->descRes->abstracts->toList->mergeDescriptors->if->descriptors->new->ListBuffer<>->foreach->key->getThrownTypes->nonEmpty->descriptors->diags->getParameterTypes->getReturnType->getThrownTypes->fragment->append->msg->diags->Fragments->Kinds->kindName->IncompatibleDescsInFunctionalIntf->fragment->incompatibleDescriptors->descriptors->toList->new->JCDiagnostic.MultilineDiagnostic->throw->failure->return
Types#findDescriptorSymbol(TypeSymbol):::Find the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.:::return->descCache->get->getSymbol
Types#findDescriptorType(Type):::Find the type of the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.:::return->descCache->get->getType
Types#isFunctionalInterface(TypeSymbol):::Is given type a functional interface?:::try->findDescriptorSymbol->return->catch->return->finally
Types#makeFunctionalInterfaceClass(Env, Name, Type, long):::Create a symbol for a class that implements a given functional interface and overrides its functional descriptor:::if->return->descSym->findDescriptorSymbol->descType->findDescriptorType->csym->outermostClass->new->ClassSymbol->WriteableScope->create->instDescSym->descSym->flags->new->MethodSymbol->enter->ctype->List->nil->new->Type.ClassType->target->isIntersection->directSupertypes->List->of->return
Types#functionalInterfaceBridges(TypeSymbol):::Find the minimal set of methods that are overridden by the functional descriptor in 'origin':::Assert->isFunctionalInterface->check->descSym->findDescriptorSymbol->members->membersClosure->overridden->new->ListBuffer<>->foreach->members->getSymbolsByName->if->continue->else->if->descSym->overrides->foreach->if->m3->erasure->m2->erasure->isSameType->m3->overrides->m3->enclClass->pendingBridges->binaryImplementation->continue->overridden->add->return->overridden->toList
Types#isSubtypeUnchecked(Type, Type):::Is t an unchecked subtype of s?:::return->isSubtypeUnchecked
Types#isSubtypeUnchecked(Type, Type, Warner):::Is t an unchecked subtype of s?:::result->isSubtypeUncheckedInternal->if->checkUnsafeVarargsConversion->return
Types#isSubtype(Type, Type):::Is t a subtype of s?<br> (not defined for Method and ForAll types):::return->isSubtype
Types#isSubtypeUnchecked(Type, List, Warner):::Is t a subtype of every type in given list `ts'?<br> (not defined for Method and ForAll types)<br> Allows unchecked conversions.:::for->l->l->nonEmpty->return
Types#isSubtypes(List, List):::Are corresponding elements of ts subtypes of ss?  If lists are of different length, return false.:::while->isSubtype->return
Types#isSubtypesUnchecked(List, List, Warner):::Are corresponding elements of ts subtypes of ss, allowing unchecked conversions?  If lists are of different length, return false.:::while->isSubtypeUnchecked->return
Types#isSuperType(Type, Type):::Is t a supertype of s?:::switch->t->getTag->return->undet->if->s->hasTag->s->hasTag->return->undet->addBound->return->return->isSubtype
Types#isSameTypes(List, List):::Are corresponding elements of the lists the same type?  If lists are of different length, return false.:::while->isSameType->return
Types#isSignaturePolymorphic(MethodSymbol):::A polymorphic signature method (JLS 15.12.3) is a method that   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;  (ii) takes a single variable arity parameter; (iii) whose declared type is Object[];  (iv) has any return type, Object signifying a polymorphic return type; and   (v) is native.:::argtypes->getParameterTypes->return->argtypes->length->hasTag
Types#isSameType(Type, Type):::Is t the same type as s?:::return->isSameTypeVisitor->visit
Types#containsType(Type, Type):::Check if t contains s:::return->containsType->visit
Types#isCastable(Type, Type, Warner):::Is t is castable to s?<br> s is assumed to be an erased type.<br> (not defined for Method and ForAll types).:::if->return->if->t->isPrimitive->s->isPrimitive->skipTypeVars->return->isConvertible->s->isPrimitive->boxedClass->isSubtype->if->try->warnStack->prepend->checkUnsafeVarargsConversion->return->isCastable->visit->catch->finally->else->return->isCastable->visit
Types#disjointType(Type, Type):::Two types or wildcards are considered disjoint if it can be proven that no type can be contained in both:::return->disjointType->visit
Types#notSoftSubtype(Type, Type):::This relation answers the question: is impossible that something of type `t' can be a subtype of `s'? This is different from the question "is `t' not a subtype of `s'?" when type variables are involved: Integer is not a subtype of T where <T extends Number> but it is not true that Integer cannot possibly be a subtype of T.:::if->return->if->t->hasTag->tv->return->relaxBound->isCastable->if->s->hasTag->cvarUpperBound->return->relaxBound->isSubtype
Types#elemtype(Type):::The element type of an array.:::switch->t->getTag->return->wildUpperBound->elemtype->return->return->elemtype->return->return
Types#dimensions(Type):::The number of dimensions of an array type.:::result->while->t->hasTag->elemtype->return
Types#makeArrayType(Type):::Returns an ArrayType with the component type t:::if->t->hasTag->t->hasTag->Assert->t->toString->error->return->new->ArrayType
Types#asSuper(Type, Symbol):::Return the (most specific) base type of t that starts with the given symbol:::if->return->return->asSuper->visit
Types#asOuterSuper(Type, Symbol):::Return the base type of t or any of its outer types that starts with the given symbol:::switch->t->getTag->do->s->asSuper->if->return->t->getEnclosingType->while->t->hasTag->return->return->isSubtype->return->asSuper->return->return
Types#asEnclosingSuper(Type, Symbol):::Return the base type of t or any of its enclosing types that starts with the given symbol:::switch->t->getTag->do->s->asSuper->if->return->outer->t->getEnclosingType->outer->hasTag->enclClass->enclClass->while->t->hasTag->return->return->isSubtype->return->asSuper->return->return
Types#memberType(Type, Symbol):::The type of given symbol, seen as a member of t.:::return->sym->flags->memberType->visit
Types#isAssignable(Type, Type, Warner):::Is t assignable to s?<br> Equivalent to subtype except for constant values and raw types.<br> (not defined for Method and ForAll types):::if->t->hasTag->return->if->t->getTag->isSubRangeOf->t->constValue->value->t->constValue->intValue->switch->s->getTag->if->s->getTag->checkRange->return->break->switch->unboxedType->getTag->return->unboxedType->isAssignable->break->return->isConvertible
Types#erasure(Type):::The erasure of t |t| -- the type that results when all type parameters in t are deleted.:::return->eraseNotNeeded->erasure
Types#makeIntersectionType(List):::Make an intersection type from non-empty list of types:::return->isInterface->makeIntersectionType
Types#makeIntersectionType(List, boolean):::Make an intersection type from non-empty list of types:::Assert->bounds->nonEmpty->check->firstExplicitBound->if->bounds->prepend->bc->names->bounds->toString->fromString->new->ClassSymbol->intersectionType->new->IntersectionClassType->hasTag->erasure->WriteableScope->create->return
Types#interfaces(Type):::Return the interfaces implemented by this class.:::return->interfaces->visit
Types#setBounds(TypeVar, List):::Same as Types#setBounds(TypeVar, List, boolean), except that third parameter is computed directly, as follows: if all all bounds are interface types, the computed supertype is Object,otherwise the supertype is simply left null (in this case, the supertype is assumed to be the head of the bound list passed as second argument):::isInterface->setBounds
Types#setBounds(TypeVar, List, boolean):::Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds:::isEmpty->makeIntersectionType
Types#getBounds(TypeVar):::Return list of bounds of the given type variable.:::if->hasTag->return->List->nil->else->if->isErroneous->isCompound->return->List->of->else->if->erasure->flags->return->interfaces->supertype->prepend->else->return->interfaces
Types#classBound(Type):::If the given type is a (possibly selected) type variable, return the bounding class of this type, otherwise return the type itself.:::return->classBound->visit
Types#isSubSignature(Type, Type):::Returns true iff the first signature is a sub signature of the other:::return->isSubSignature
Types#overrideEquivalent(Type, Type):::Returns true iff these signatures are related by override equivalence:::return->hasSameArgs->erasure->hasSameArgs->erasure->hasSameArgs
Types#mergeAbstracts(List, Type, boolean):::Merge multiple abstract methods:::shouldErase->erasedParams->erasure->getParameterTypes->foreach->if->s->flags->s->erasure->getParameterTypes->isSameTypes->return->Optional->empty->else->if->hasTag->foreach->MostSpecificReturnCheck->values->foreach->mt->memberType->allThrown->mt->getThrownTypes->foreach->if->mt2->memberType->if->isSubSignature->mostSpecificReturnCheck->test->continue->else->thrownTypes2->mt2->getThrownTypes->if->mt->hasTag->erasure->else->if->mt->hasTag->Assert->mt2->hasTag->check->mt2->getTypeArguments->mt->getTypeArguments->subst->chk->intersect->return->mt->getThrownTypes->Optional->of->Optional->s->flags->createMethodTypeWithThrown->new->MethodSymbol->of->return->Optional->empty
Types#firstUnimplementedAbstract(ClassSymbol):::Return first abstract member of class `sym'.:::try->return->firstUnimplementedAbstractImpl->catch->chk->enter->getEnv->pos->completionError->return->finally
Types#hasSameArgs(Type, Type):::Does t have the same arguments as s?  It is assumed that both types are (possibly polymorphic) method types:::return->hasSameArgs
Types#subst(Type, List, List):::Substitute all occurrences of a type in `from' with the corresponding type in `to' in 't':::return->t->new->Subst->map
Types#hasSameBounds(ForAll, ForAll):::Does t have the same bounds for quantified variables as s?:::l1->l2->while->l1->nonEmpty->l2->nonEmpty->getUpperBound->getUpperBound->subst->isSameType->return->l1->isEmpty->l2->isEmpty
Types#newInstances(List):::Create new vector of type variables from list of variables  changing all recursive bounds from old to new list.:::tvars1->tvars->map->for->l->l->nonEmpty->return
Types#rank(Type):::The rank of a class is the length of the longest path between the class and java.lang.Object in the class inheritance graph:::switch->t->getTag->cls->if->fullname->getQualifiedName->if->else->r->supertype->rank->for->l->interfaces->l->nonEmpty->return->tvar->if->r->supertype->rank->for->l->interfaces->l->nonEmpty->return->return->throw->new->AssertionError
Types#toString(Type, Locale):::Helper method for generating a string representation of a given type accordingly to a given locale:::return->Printer->createStandardPrinter->visit
Types#toString(Symbol, Locale):::Helper method for generating a string representation of a given type accordingly to a given locale:::return->Printer->createStandardPrinter->visit
Types#toString(Type):::This toString is slightly more descriptive than the one on Type.:::if->t->hasTag->forAll->return->typaramsString->return
Types#closure(Type):::Returns the closure of a class or interface type.:::cl->closureCache->get->if->st->supertype->if->t->isCompound->if->st->hasTag->closure->insert->else->if->st->hasTag->closure->prepend->else->List->of->else->supertype->closure->for->l->interfaces->l->nonEmpty->closureCache->put->return
Types#closureCollector(boolean, BiPredicate):::Collect types into a new closure (using a @code{ClosureHolder}):::return->Collector->new->ClosureHolder->ClosureHolder->add->ClosureHolder->merge->ClosureHolder->closure->of
Types#insert(List, Type, BiPredicate):::Insert a type in a closure:::if->cl->isEmpty->return->cl->prepend->else->if->shouldSkip->test->return->else->if->precedes->return->cl->prepend->else->return->insert->prepend
Types#union(List, List, BiPredicate):::Form the union of two closures:::if->cl1->isEmpty->return->else->if->cl2->isEmpty->return->else->if->shouldSkip->test->return->union->prepend->else->if->precedes->return->union->prepend->else->if->precedes->return->union->prepend->else->return->union->prepend
Types#intersect(List, List):::Intersect two closures:::if->return->if->cl1->isEmpty->cl2->isEmpty->return->List->nil->if->precedes->return->intersect->if->precedes->return->intersect->if->isSameType->return->intersect->prepend->if->hasTag->hasTag->if->isParameterized->isParameterized->merge->merge->return->intersect->prepend->if->isRaw->isRaw->return->intersect->erasure->prepend->return->intersect
Types#lub(List):::Return the least upper bound of list of types:::return->ts->ts->length->new->TypeArr->toArray->lub
Types#lub(Type...):::Return the least upper bound (lub) of set of types:::UNKNOWN_BOUND->ARRAY_BOUND->CLASS_BOUND->kinds->new->intArr->boundkind->for->i->switch->return->elements->new->TypeArr->for->i->return->lub->new->ArrayType->startIdx->for->i->Assert->check->cl->erasedSupertypes->for->i->mec->closureMin->candidates->List->nil->foreach->lci->List->asSuper->of->for->i->candidates->appendList->return->compoundMin->classes->List->arraySuperType->of->for->i->return->lub
Types#hashCode(Type):::Compute a hash code on a type.:::return->hashCode
Types#resultSubtype(Type, Type, Warner):::Does t have a result that is a subtype of the result type of s, suitable for covariant returns?  It is assumed that both types are (possibly polymorphic) method types:::tvars->t->getTypeArguments->svars->s->getTypeArguments->tres->t->getReturnType->sres->s->getReturnType->subst->return->covariantReturnType
Types#returnTypeSubstitutable(Type, Type):::Return-Type-Substitutable.:::if->hasSameArgs->return->resultSubtype->else->return->r1->getReturnType->r2->getReturnType->erasure->covariantReturnType
Types#covariantReturnType(Type, Type, Warner):::Is t an appropriate return type in an overrider for a method that returns s?:::return->isSameType->t->isPrimitive->s->isPrimitive->isAssignable
Types#boxedClass(Type):::Return the class that boxes the given primitive.:::return->syms->t->getTag->ordinal->enterClass
Types#boxedTypeOrType(Type):::Return the boxed type if 't' is primitive, otherwise return 't' itself.:::return->t->isPrimitive->boxedClass
Types#unboxedType(Type):::Return the primitive type corresponding to a boxed type.:::for->i->return
Types#unboxedTypeOrType(Type):::Return the unboxed type if 't' is a boxed class, otherwise return 't' itself.:::unboxedType->unboxedType->return->unboxedType->hasTag
Types#adapt(Type, Type, ListBuffer, ListBuffer):::Adapt a type by computing a substitution which maps a source type to a target type.:::new->Adapter->adapt
Types.SignatureGenerator#assembleSig(Type):::Assemble signature of given type in string buffer.:::switch->type->getTag->append->break->append->break->append->break->append->break->append->break->append->break->append->break->append->break->append->break->if->type->isCompound->throw->new->InvalidSignatureException->append->assembleClassSig->append->break->at->append->assembleSig->break->mt->append->assembleSig->append->assembleSig->if->hasTypeVar->for->l->l->nonEmpty->break->ta->switch->append->assembleSig->break->append->assembleSig->break->append->break->throw->new->AssertionError->break->if->isCaptured->throw->new->InvalidSignatureException->append->append->append->break->ft->assembleParamsSig->assembleSig->break->throw->type->getTag->new->AssertionError
