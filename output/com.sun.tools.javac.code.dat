AnnoConstruct#getAnnotationMirrors()::: anno construct get annotation mirrors:::
AnnoConstruct#getAttribute(Class)::: anno construct get attribute:::name->annoType->getName->foreach->getAnnotationMirrors->if->name->flatName->toString->equals->return->return
AnnoConstruct#getInheritedAnnotations(Class)::: anno construct get inherited annotations:::return->newInstance
AnnoConstruct#getAnnotationsByType(Class)::: anno construct get annotations by type:::if->annoType->isAnnotation->throw->new->IllegalArgumentException->containerType->getContainer->if->res->getAnnotation->size->arr->newInstance->if->return->annoTypeName->annoType->getName->containerTypeName->containerType->getName->directIndex->containerIndex->direct->container->index->foreach->getAnnotationMirrors->if->flatName->contentEquals->else->if->flatName->contentEquals->if->annoType->isAnnotationPresent->return->getInheritedAnnotations->contained->unpackContained->if->annoType->isAnnotationPresent->return->getInheritedAnnotations->size->arr->newInstance->insert->length->if->if->AnnotationProxyMaker->generateAnnotation->else->AnnotationProxyMaker->generateAnnotation->else->if->AnnotationProxyMaker->generateAnnotation->return->else->for->i->return
AnnoConstruct#unpackContained(Attribute.Compound)::: anno construct unpack contained:::contained0->if->unpackAttributes->compounds->new->ListBuffer<>->if->foreach->if->compounds->append->return->compounds->compounds->size->new->Attribute.CompoundArr->toArray
AnnoConstruct#getAnnotation(Class)::: anno construct get annotation:::if->annoType->isAnnotation->throw->new->IllegalArgumentException->c->getAttribute->return->AnnotationProxyMaker->generateAnnotation
AnnoConstruct#getContainer(Class)::: anno construct get container:::repeatable->annoType->getAnnotation->return->repeatable->value
AnnoConstruct#unpackAttributes(Attribute.Compound)::: anno construct unpack attributes:::return->container->member
Attribute#accept(Visitor)::: attribute accept:::
Attribute#getValue()::: attribute get value:::throw->new->UnsupportedOperationException
Attribute#accept(AnnotationValueVisitor, P)::: attribute accept:::throw->new->UnsupportedOperationException
Attribute#isSynthesized()::: attribute is synthesized:::return
Attribute#getPosition()::: attribute get position:::return
Attribute.Constant#accept(Visitor)::: constant accept:::v->visitConstant
Attribute.Constant#toString()::: constant to string:::return->Constants->format
Attribute.Constant#getValue()::: constant get value:::return->Constants->decode
Attribute.Constant#accept(AnnotationValueVisitor, P)::: constant accept:::if->return->v->visitString->if->i->switch->type->getTag->return->v->visitBoolean->return->v->visitChar->return->v->visitByte->return->v->visitShort->return->v->visitInt->switch->type->getTag->return->v->visitLong->return->v->visitFloat->return->v->visitDouble->throw->new->AssertionError
Attribute.Class#accept(Visitor)::: class accept:::v->visitClass
Attribute.Class#makeClassType(Types, Type)::: class make class type:::arg->type->isPrimitive->types->boxedClass->types->erasure->return->getEnclosingType->List->of->new->Type.ClassType
Attribute.Class#toString()::: class to string:::return
Attribute.Class#getValue()::: class get value:::return
Attribute.Class#accept(AnnotationValueVisitor, P)::: class accept:::return->v->visitType
Attribute.Compound#isSynthesized()::: compound is synthesized:::return
Attribute.Compound#setSynthesized(boolean)::: compound set synthesized:::
Attribute.Compound#getPosition()::: compound get position:::if->hasUnknownPosition->if->values->size->valueName->res->getElemPair->getPosition->return
Attribute.Compound#isContainerTypeCompound()::: compound is container type compound:::if->isSynthesized->values->size->return->getFirstEmbeddedTC->return
Attribute.Compound#getFirstEmbeddedTC()::: compound get first embedded c:::if->values->size->val->values->get->if->getSimpleName->contentEquals->arr->if->return->return
Attribute.Compound#tryFixPosition()::: compound try fix position:::if->isContainerTypeCompound->return->from->getFirstEmbeddedTC->if->return->return
Attribute.Compound#hasUnknownPosition()::: compound has unknown position:::return
Attribute.Compound#accept(Visitor)::: compound accept:::v->visitCompound
Attribute.Compound#toString():::Returns a string representation of this annotation:::buf->new->StringBuilder->buf->append->buf->append->len->values->length->if->buf->append->first->foreach->if->buf->append->name->if->buf->append->buf->append->buf->append->buf->append->return->buf->toString
Attribute.Compound#member(Name)::: compound member:::res->getElemPair->return
Attribute.Compound#getElemPair(Name)::: compound get elem pair:::foreach->if->return->return
Attribute.Compound#getValue()::: compound get value:::return
Attribute.Compound#accept(AnnotationValueVisitor, P)::: compound accept:::return->v->visitAnnotation
Attribute.Compound#getAnnotationType()::: compound get annotation type:::return
Attribute.Compound#getElementValues()::: compound get element values:::valmap->new->LinkedHashMap<>->foreach->valmap->put->return
Attribute.Array#accept(Visitor)::: array accept:::v->visitArray
Attribute.Array#toString()::: array to string:::buf->new->StringBuilder->buf->append->first->foreach->if->buf->append->buf->append->buf->append->return->buf->toString
Attribute.Array#getValue()::: array get value:::return->List->from
Attribute.Array#accept(AnnotationValueVisitor, P)::: array accept:::return->v->getValue->visitArray
Attribute.Array#getPosition()::: array get position:::if->return->getPosition->else->return
Attribute.Enum#accept(Visitor)::: enum accept:::v->visitEnum
Attribute.Enum#toString()::: enum to string:::return->value->enclClass
Attribute.Enum#getValue()::: enum get value:::return
Attribute.Enum#accept(AnnotationValueVisitor, P)::: enum accept:::return->v->visitEnumConstant
Attribute.Error#accept(Visitor)::: error accept:::v->visitError
Attribute.Error#toString()::: error to string:::return
Attribute.Error#getValue()::: error get value:::return->toString
Attribute.Error#accept(AnnotationValueVisitor, P)::: error accept:::return->v->toString->visitString
Attribute.Visitor#visitConstant(Attribute.Constant)::: visitor visit constant:::
Attribute.Visitor#visitClass(Attribute.Class)::: visitor visit class:::
Attribute.Visitor#visitCompound(Attribute.Compound)::: visitor visit compound:::
Attribute.Visitor#visitArray(Attribute.Array)::: visitor visit array:::
Attribute.Visitor#visitEnum(Attribute.Enum)::: visitor visit enum:::
Attribute.Visitor#visitError(Attribute.Error)::: visitor visit error:::
ClassFinder#getCompleter()::: class finder get completer:::return
ClassFinder#instance(Context):::Get the ClassFinder instance for this invocation.:::instance->context->get->if->new->ClassFinder->return
ClassFinder#getSupplementaryFlags(ClassSymbol):::Returns any extra flags for a class symbol:::if->jrtIndex->isInJRT->return->if->new->HashMap<>->flags->supplementaryFlags->c->packge->get->if->newFlags->try->ctSym->jrtIndex->c->packge->flatName->getCtSym->minProfile->if->if->Profile->lookup->if->catch->finally->supplementaryFlags->c->packge->put->return
ClassFinder#complete(Symbol):::Completion for classes to be loaded:::if->try->c->dependencies->push->annotate->blockAnnotations->new->Scope.ErrorScope->completeOwners->completeEnclosing->fillIn->catch->finally->annotate->unblockAnnotationsNoFlush->dependencies->pop->else->if->p->try->fillIn->catch->msg->diagFactory->Fragments->ex->getLocalizedMessage->ExceptionMessage->fragment->throw->new->CompletionFailure->initCause->finally->if->annotate->flush
ClassFinder#completeOwners(Symbol):::complete up through the enclosing package.:::if->completeOwners->o->complete
ClassFinder#completeEnclosing(ClassSymbol):::Tries to complete lexically enclosing classes if c looks like a nested class:::if->owner->foreach->Convert->Convert->shortName->enclosingCandidates->encl->owner->members->findFirst->if->syms->c->packge->TypeSymbol->formFlatName->getClass->if->encl->complete
ClassFinder#fillIn(ClassSymbol):::Fill in definition of class `c' from corresponding class or  source file.:::if->msg->diagFactory->fragment->throw->new->CompletionFailure->classfile->if->previousClassFile->prevOwner->prevName->try->if->Assert->classfile->toUri->error->if->log->currentClassFile->getName->printVerbose->if->classfile->getKind->reader->readClassFile->getSupplementaryFlags->else->if->sourceCompleter->isTerminal->sourceCompleter->complete->else->throw->classfile->toUri->new->IllegalStateException->catch->getSymbols->csym->sym->packge->members->enter->sym->flatName->Convert->sym->flatName->shortName->csym->reset->forEach->Convert->shortName->c->reset->throw->finally->else->throw->classFileNotFound
ClassFinder#classFileNotFound(ClassSymbol)::: class finder class file not found:::diag->diagFactory->Fragments->ClassFileNotFound->fragment->return->newCompletionFailure
ClassFinder#newCompletionFailure(TypeSymbol, JCDiagnostic):::Static factory for CompletionFailure objects:::if->return->new->CompletionFailure->else->result->return
ClassFinder#loadClass(ModuleSymbol, Name):::Load a toplevel class with given fully qualified name  The class is entered into `classes' only if load was successful.:::Assert->checkNonNull->packageName->Convert->packagePart->ps->syms->lookupPackage->Assert->checkNonNull->absent->syms->getClass->c->syms->enterClass->if->try->c->complete->catch->if->syms->removeClass->classSymbolRemoved->throw->finally->return
ClassFinder#includeClassFile(PackageSymbol, JavaFileObject):::Include class corresponding to given class file in package,  unless (1) we already have one the same kind (.class or .java), or         (2) we have one of the other kind, and the given class file             is older.:::if->for->q->kind->file->getKind->seen->if->else->binaryName->fileManager->inferBinaryName->lastDot->binaryName->lastIndexOf->classname->names->binaryName->substring->fromString->isPkgInfo->c->findFirst->if->syms->enterClass->if->if->else->if->enter->else->if->if->preferredFileObject
ClassFinder#preferredFileObject(JavaFileObject, JavaFileObject):::Implement policy to choose to derive information from a source  file or a class file when both are present:::if->return->a->getKind->else->adate->a->getLastModified->bdate->b->getLastModified->return
ClassFinder#getPackageFileKinds()::: class finder get package file kinds:::return->EnumSet->of
ClassFinder#extraFileActions(PackageSymbol, JavaFileObject):::this is used to support javadoc:::
ClassFinder#fillIn(PackageSymbol):::Load directory of package into members scope.:::if->WriteableScope->create->msym->Assert->p->toString->checkNonNull->msym->complete->if->if->scanUserPaths->scanPlatformPath->else->scanPlatformPath->scanUserPaths->else->if->scanUserPaths->else->scanModulePaths
ClassFinder#scanModulePaths(PackageSymbol, ModuleSymbol)::: class finder scan module paths:::kinds->getPackageFileKinds->classKinds->EnumSet->copyOf->classKinds->remove->wantClassFiles->classKinds->isEmpty->sourceKinds->EnumSet->copyOf->sourceKinds->remove->wantSourceFiles->sourceKinds->isEmpty->packageName->toString->classLocn->sourceLocn->patchLocn->patchOutLocn->prevPreferCurrent->try->if->list->fillIn->if->combined->EnumSet->noneOf->combined->addAll->combined->addAll->list->fillIn->if->list->fillIn->if->list->fillIn->catch->finally
ClassFinder#scanUserPaths(PackageSymbol, boolean):::Scans class path and source path for files in given package.:::kinds->getPackageFileKinds->classKinds->EnumSet->copyOf->classKinds->remove->wantClassFiles->classKinds->isEmpty->sourceKinds->EnumSet->copyOf->sourceKinds->remove->wantSourceFiles->sourceKinds->isEmpty->haveSourcePath->fileManager->hasLocation->if->if->fm->if->path->List->nil->foreach->fm->getLocationAsPaths->path->prepend->log->path->reverse->toString->printVerbose->else->if->path->List->nil->foreach->fm->getLocationAsPaths->path->prepend->log->path->reverse->toString->printVerbose->if->path->List->nil->foreach->fm->getLocationAsPaths->path->prepend->foreach->fm->getLocationAsPaths->path->prepend->log->path->reverse->toString->printVerbose->packageName->toString->if->list->fillIn->else->if->list->fillIn->if->list->fillIn
ClassFinder#scanPlatformPath(PackageSymbol):::Scans platform class path for files in given package.:::toString->EnumSet->of->list->fillIn
ClassFinder#fillIn(PackageSymbol, Location, Iterable)::: class finder fill in:::foreach->switch->fo->getKind->extraFileActions->break->binaryName->fileManager->inferBinaryName->simpleName->binaryName->binaryName->lastIndexOf->substring->if->SourceVersion->isIdentifier->simpleName->equals->includeClassFile->break->extraFileActions->break
ClassFinder#list(Location, PackageSymbol, String, Set)::: class finder list:::listed->fileManager->EnumSet->allOf->list->return->new->Iterator<JavaFileObject>
ClassFinder.BadClassFile#createBadClassFileDiagnostic(JavaFileObject, JCDiagnostic, JCDiagnostic.Factory)::: bad class file create bad class file diagnostic:::key->file->getKind->return->diagFactory->fragment
DeferredCompletionFailureHandler#instance(Context)::: deferred completion failure handler instance:::instance->context->get->if->new->DeferredCompletionFailureHandler->return
DeferredCompletionFailureHandler#setHandler(Handler)::: deferred completion failure handler set handler:::if->return->handler->uninstall->prev->handler->install->return
DeferredCompletionFailureHandler#handleAPICompletionFailure(CompletionFailure)::: deferred completion failure handler handle completion failure:::handler->handleAPICompletionFailure
DeferredCompletionFailureHandler#classSymbolCompleteFailed(ClassSymbol, Completer)::: deferred completion failure handler class symbol complete failed:::handler->classSymbolCompleteFailed
DeferredCompletionFailureHandler#classSymbolRemoved(ClassSymbol)::: deferred completion failure handler class symbol removed:::handler->classSymbolRemoved
DeferredCompletionFailureHandler#isDeferredCompleter(Completer)::: deferred completion failure handler is deferred completer:::return
DeferredCompletionFailureHandler.Handler#install()::: handler install:::
DeferredCompletionFailureHandler.Handler#handleAPICompletionFailure(CompletionFailure)::: handler handle completion failure:::
DeferredCompletionFailureHandler.Handler#classSymbolCompleteFailed(ClassSymbol, Completer)::: handler class symbol complete failed:::
DeferredCompletionFailureHandler.Handler#classSymbolRemoved(ClassSymbol)::: handler class symbol removed:::
DeferredCompletionFailureHandler.Handler#uninstall()::: handler uninstall:::
DeferredCompletionFailureHandler.DeferredCompleter#complete(Symbol)::: deferred completer complete:::origCompleter->complete
DeferredCompletionFailureHandler.FlipSymbolDescription#flip()::: flip symbol description flip:::prevType->prevKind->prevCompleter->prevMembers
DeferredLintHandler#instance(Context)::: deferred lint handler instance:::instance->context->get->if->new->DeferredLintHandler->return
DeferredLintHandler.LintLogger#report()::: lint logger report:::
DeferredLintHandler#report(LintLogger):::Associate the given logger with the current position as set by #setPos(DiagnosticPosition) :::if->logger->report->else->loggers->loggersQueue->get->if->loggersQueue->new->ListBuffer<>->put->loggers->append
DeferredLintHandler#flush(DiagnosticPosition):::Invoke all LintLoggers that were associated with the provided pos.:::loggers->loggersQueue->get->if->foreach->lintLogger->report->loggersQueue->remove
DeferredLintHandler#setPos(DiagnosticPosition):::Sets the current position to the provided currentPos:::prevPosition->return
DeferredLintHandler#immediate():::LintLoggers passed to subsequent invocations of #report(LintLogger)  will be invoked immediately.:::return->setPos
Directive.ExportsDirective#getKind()::: exports directive get kind:::return
Directive.ExportsDirective#getPackage()::: exports directive get package:::return
Directive.ExportsDirective#getTargetModules()::: exports directive get target modules:::return->Collections->unmodifiableList
Directive.ExportsDirective#toString()::: exports directive to string:::if->return->else->return
Directive.ExportsDirective#accept(DirectiveVisitor, P)::: exports directive accept:::return->v->visitExports
Directive.OpensDirective#getKind()::: opens directive get kind:::return
Directive.OpensDirective#getPackage()::: opens directive get package:::return
Directive.OpensDirective#getTargetModules()::: opens directive get target modules:::return->Collections->unmodifiableList
Directive.OpensDirective#toString()::: opens directive to string:::if->return->else->return
Directive.OpensDirective#accept(DirectiveVisitor, P)::: opens directive accept:::return->v->visitOpens
Directive.ProvidesDirective#getKind()::: provides directive get kind:::return
Directive.ProvidesDirective#getService()::: provides directive get service:::return
Directive.ProvidesDirective#getImplementations()::: provides directive get implementations:::return
Directive.ProvidesDirective#toString()::: provides directive to string:::return
Directive.ProvidesDirective#accept(DirectiveVisitor, P)::: provides directive accept:::return->v->visitProvides
Directive.ProvidesDirective#equals(Object)::: provides directive equals:::if->return->other->return->impls->equals
Directive.ProvidesDirective#hashCode()::: provides directive hash code:::return->service->hashCode->impls->hashCode
Directive.RequiresDirective#getKind()::: requires directive get kind:::return
Directive.RequiresDirective#isStatic()::: requires directive is static:::return->flags->contains
Directive.RequiresDirective#isTransitive()::: requires directive is transitive:::return->flags->contains
Directive.RequiresDirective#getDependency()::: requires directive get dependency:::return
Directive.RequiresDirective#toString()::: requires directive to string:::return
Directive.RequiresDirective#accept(DirectiveVisitor, P)::: requires directive accept:::return->v->visitRequires
Directive.UsesDirective#getKind()::: uses directive get kind:::return
Directive.UsesDirective#getService()::: uses directive get service:::return
Directive.UsesDirective#toString()::: uses directive to string:::return
Directive.UsesDirective#accept(DirectiveVisitor, P)::: uses directive accept:::return->v->visitUses
Directive.UsesDirective#equals(Object)::: uses directive equals:::if->return->other->return
Directive.UsesDirective#hashCode()::: uses directive hash code:::return->service->hashCode
Flags#toString(long)::: flags to string:::buf->new->StringBuilder->sep->foreach->asFlagSet->buf->append->buf->append->return->buf->toString
Flags#asFlagSet(long)::: flags as flag set:::flagSet->EnumSet->noneOf->foreach->Flag->values->if->flagSet->add->Assert->check->return
Flags#asModifierSet(long)::: flags as modifier set:::modifiers->modifierSets->get->if->noneOf->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->if->modifiers->add->Collections->unmodifiableSet->modifierSets->put->return
Flags#isStatic(Symbol)::: flags is static:::return->symbol->flags
Flags#isEnum(Symbol)::: flags is enum:::return->symbol->flags
Flags#isConstant(Symbol.VarSymbol)::: flags is constant:::return->symbol->getConstValue
Kinds.KindSelector#of(KindSelector...)::: kind selector of:::newData->foreach->return->new->KindSelector
Kinds.KindSelector#subset(KindSelector)::: kind selector subset:::return
Kinds.KindSelector#contains(KindSelector)::: kind selector contains:::return
Kinds.KindSelector#kindNames():::A set of KindName(s) representing a set of symbol's kinds.:::kinds->EnumSet->noneOf->if->if->kinds->add->else->kinds->add->if->kinds->add->if->kinds->add->if->kinds->add->if->kinds->add->return
Kinds#kindName(MemberReferenceTree.ReferenceMode)::: kinds kind name:::switch->return->return->throw->new->AssertionError
Kinds#kindName(Symbol):::A KindName representing a given symbol:::switch->sym->getKind->return->return->return->return->return->return->return->return->return->return->throw->sym->getKind->new->AssertionError
Kinds#typeKindName(Type):::A KindName representing the kind of a given class/interface type.:::if->t->hasTag->t->hasTag->flags->return->else->if->t->hasTag->return->else->if->return->else->if->return->else->return
Lint#instance(Context):::Get the root Lint instance.:::instance->context->get->if->new->Lint->return
Lint#augment(Attribute.Compound):::Returns the result of combining the values in this object with the given annotation.:::return->augmentor->augment
Lint#augment(Symbol):::Returns the result of combining the values in this object with the metadata on the given symbol.:::l->augmentor->sym->getDeclarationAttributes->augment->if->sym->isDeprecated->if->new->Lint->remove->add->return
Lint#suppress(LintCategory...):::Returns a new Lint that has the given LintCategorys suppressed.:::l->new->Lint->Arrays->asList->removeAll->Arrays->asList->addAll->return
Lint#toString()::: lint to string:::return
Lint#isEnabled(LintCategory):::Checks if a warning category is enabled:::return->values->contains
Lint#isSuppressed(LintCategory):::Checks is a warning category has been specifically suppressed, by means of the SuppressWarnings annotation, or, in the case of the deprecated category, whether it has been implicitly suppressed by virtue of the current entity being itself deprecated.:::return->suppressedValues->contains
Lint.AugmentVisitor#augment(Lint, Attribute.Compound)::: augment visitor augment:::initSyms->attr->accept->return
Lint.AugmentVisitor#augment(Lint, List)::: augment visitor augment:::initSyms->foreach->a->accept->return
Lint.AugmentVisitor#initSyms()::: augment visitor init syms:::if->Symtab->instance
Lint.AugmentVisitor#suppress(LintCategory)::: augment visitor suppress:::if->new->Lint->add->remove
Lint.AugmentVisitor#visitConstant(Attribute.Constant)::: augment visitor visit constant:::if->lc->LintCategory->get->if->suppress
Lint.AugmentVisitor#visitClass(Attribute.Class)::: augment visitor visit class:::
Lint.AugmentVisitor#visitCompound(Attribute.Compound)::: augment visitor visit compound:::if->for->v->v->nonEmpty
Lint.AugmentVisitor#visitArray(Attribute.Array)::: augment visitor visit array:::foreach->value->accept
Lint.AugmentVisitor#visitEnum(Attribute.Enum)::: augment visitor visit enum:::
Lint.AugmentVisitor#visitError(Attribute.Error)::: augment visitor visit error:::
ModuleFinder#instance(Context):::Get the ModuleFinder instance for this invocation.:::instance->context->get->if->new->ModuleFinder->return
ModuleFinder.ModuleLocationIterator#hasNext()::: module location iterator has next:::while->while->innerIter->hasNext->if->outerIter->hasNext->outerIter->next->try->fileManager->listLocationsForModules->iterator->catch->println->finally->else->return->if->innerIter->hasNext->innerIter->next->return
ModuleFinder.ModuleLocationIterator#next()::: module location iterator next:::hasNext->if->result->return->throw->new->NoSuchElementException
ModuleFinder#findModule(Name)::: module finder find module:::return->syms->enterModule->findModule
ModuleFinder#findModule(ModuleSymbol)::: module finder find module:::if->list->scanModulePath->if->list->isEmpty->if->findModuleInfo->return
ModuleFinder#findAllModules()::: module finder find all modules:::list->scanModulePath->foreach->if->findModuleInfo->return
ModuleFinder#findSingleModule()::: module finder find single module:::try->src_fo->getModuleInfoFromLocation->class_fo->getModuleInfoFromLocation->fo->classFinder->preferredFileObject->msym->if->else->readModule->if->else->return->catch->throw->new->Error->finally
ModuleFinder#readModule(JavaFileObject)::: module finder read module:::name->switch->fo->getKind->moduleNameFromSourceReader->readModuleName->if->diag->diags->fragment->errModuleInfo->syms->defineClass->throw->new->ClassFinder.BadClassFile->break->try->names->readModuleName->fromString->catch->finally->break->Assert->error->break->msym->syms->enterModule->if->fileManager->hasLocation->fileManager->name->toString->getLocationForModule->if->patchFO->getModuleInfoFromLocation->getModuleInfoFromLocation->preferredFileObject->getModuleInfoFromLocation->preferredFileObject->if->classFinder->fillIn->return
ModuleFinder#readModuleName(JavaFileObject)::: module finder read module name:::if->new->ModuleNameReader->return->moduleNameReader->readModuleName
ModuleFinder#getModuleInfoFromLocation(Location, Kind)::: module finder get module info from location:::if->fileManager->hasLocation->return->return->fileManager->toString->getJavaFileForInput
ModuleFinder#scanModulePath(ModuleSymbol)::: module finder scan module path:::results->new->ListBuffer<>->namesInSet->new->HashMap<>->multiModuleMode->fileManager->hasLocation->while->moduleLocationIterator->hasNext->locns->moduleLocationIterator->next->namesInSet->clear->foreach->try->n->names->fileManager->inferModuleName->fromString->if->namesInSet->put->msym->syms->enterModule->if->continue->if->fileManager->hasLocation->fileManager->toString->getLocationForModule->if->fileManager->hasLocation->fileManager->toString->getLocationForModule->if->if->fileManager->hasLocation->fileManager->toString->getLocationForModule->else->if->if->results->add->else->log->Errors->getDescription->DuplicateModuleOnPath->error->catch->finally->if->results->nonEmpty->return->results->toList->return->results->toList
ModuleFinder#findModuleInfo(ModuleSymbol)::: module finder find module info:::try->fo->getModuleInfoFromLocation->getModuleInfoFromLocation->preferredFileObject->getModuleInfoFromLocation->preferredFileObject->if->getModuleInfoFromLocation->getModuleInfoFromLocation->preferredFileObject->if->moduleName->fileManager->inferModuleName->if->else->else->new->Symbol.Completer->catch->finally
ModuleFinder#preferredFileObject(JavaFileObject, JavaFileObject)::: module finder preferred file object:::if->return->if->return->return->classFinder->preferredFileObject
ModuleFinder#getDescription(StandardLocation)::: module finder get description:::switch->return->return->return->return->throw->new->AssertionError
ModuleFinder.ModuleNameFromSourceReader#readModuleName(JavaFileObject)::: module name from source reader read module name:::
Preview#instance(Context)::: preview instance:::instance->context->get->if->new->Preview->return
Preview#initMajorVersionToSourceMap()::: preview init major version to source map:::majorVersionToSource->new->HashMap<>->foreach->Target->values->major->source->Source->lookup->if->majorVersionToSource->put->return
Preview#warnPreview(int, Feature):::Report usage of a preview feature:::new->SimpleDiagnosticPosition->warnPreview
Preview#warnPreview(DiagnosticPosition, Feature):::Report usage of a preview feature:::Assert->isEnabled->check->Assert->isPreview->check->if->lint->isSuppressed->previewHandler->feature->isPlural->Warnings->feature->nameFragment->PreviewFeatureUsePlural->Warnings->feature->nameFragment->PreviewFeatureUse->report
Preview#warnPreview(JavaFileObject, int):::Report usage of a preview feature in classfile.:::Assert->isEnabled->check->if->lint->isSuppressed->previewHandler->Warnings->majorVersionToSource->get->PreviewFeatureUseClassfile->report
Preview#isEnabled():::Are preview features enabled?:::return
Preview#isPreview(Feature):::Is given feature a preview feature?:::return
Preview#disabledError(Feature):::Generate an error key which captures the fact that a given preview feature could not be used due to the preview feature support being disabled.:::Assert->isEnabled->check->return->feature->isPlural->Errors->feature->nameFragment->PreviewFeatureDisabledPlural->Errors->feature->nameFragment->PreviewFeatureDisabled
Preview#disabledError(JavaFileObject, int):::Generate an error key which captures the fact that a preview classfile cannot be loaded due to the preview feature support being disabled.:::Assert->isEnabled->check->return->Errors->majorVersionToSource->get->PreviewFeatureDisabledClassfile
Preview#reportDeferredDiagnostics():::Report any deferred diagnostics.:::previewHandler->reportDeferredDiagnostic
Printer#localize(Locale, String, Object...):::This method should be overriden in order to provide proper i18n support.:::
Printer#capturedVarId(CapturedType, Locale):::Maps a captured type into an unique identifier.:::
Printer#createStandardPrinter(Messages):::Create a printer with default i18n support provided by Messages:::return->new->Printer
Printer#visitTypes(List, Locale):::Get a localized string representation for all the types in the input list.:::sbuf->new->ListBuffer<>->foreach->sbuf->visit->append->return->sbuf->toList->toString
Printer#visitSymbols(List, Locale):::* Get a localized string representation for all the symbols in the input list.:::sbuf->new->ListBuffer<>->foreach->sbuf->visit->append->return->sbuf->toList->toString
Printer#visit(Type, Locale):::Get a localized string representation for a given type.:::return->t->accept
Printer#visit(Symbol, Locale):::Get a localized string representation for a given symbol.:::return->s->accept
Printer#visitCapturedType(CapturedType, Locale)::: printer visit captured type:::if->seenCaptured->contains->return->printAnnotations->capturedVarId->localize->else->try->seenCaptured->prepend->return->printAnnotations->capturedVarId->visit->localize->catch->finally
Printer#visitForAll(ForAll, Locale)::: printer visit for all:::return->printAnnotations->visitTypes->visit
Printer#visitUndetVar(UndetVar, Locale)::: printer visit undet var:::if->t->getInst->return->printAnnotations->t->getInst->visit->else->return->printAnnotations->visit
Printer#visitArrayType(ArrayType, Locale)::: printer visit array type:::res->new->StringBuilder->printBaseElementType->printBrackets->return->res->toString
Printer#printAnnotations(Type)::: printer print annotations:::return->printAnnotations
Printer#printAnnotations(Type, boolean)::: printer print annotations:::sb->new->StringBuilder->annos->t->getAnnotationMirrors->if->annos->isEmpty->if->sb->append->sb->append->sb->append->return->sb->toString
Printer#printBaseElementType(Type, StringBuilder, Locale)::: printer print base element type:::arrel->while->arrel->hasTag->sb->visit->append
Printer#printBrackets(Type, StringBuilder, Locale)::: printer print brackets:::arrel->while->arrel->hasTag->sb->printAnnotations->append->sb->append
Printer#visitClassType(ClassType, Locale)::: printer visit class type:::buf->new->StringBuilder->if->t->getEnclosingType->hasTag->buf->t->getEnclosingType->visit->append->buf->append->buf->printAnnotations->append->buf->className->append->else->buf->printAnnotations->append->buf->className->append->if->t->getTypeArguments->nonEmpty->buf->append->buf->t->getTypeArguments->visitTypes->append->buf->append->return->buf->toString
Printer#visitMethodType(MethodType, Locale)::: printer visit method type:::return->printMethodArgs->visit
Printer#visitPackageType(PackageType, Locale)::: printer visit package type:::return->getQualifiedName->toString
Printer#visitWildcardType(WildcardType, Locale)::: printer visit wildcard type:::s->new->StringBuilder->s->append->if->s->printAnnotations->append->s->visit->append->return->s->toString
Printer#visitErrorType(ErrorType, Locale)::: printer visit error type:::return->visitType
Printer#visitTypeVar(TypeVar, Locale)::: printer visit type var:::return->visitType
Printer#visitModuleType(ModuleType, Locale)::: printer visit module type:::return->visitType
Printer#visitType(Type, Locale)::: printer visit type:::s->localize->toString->return
Printer#className(ClassType, boolean, Locale):::Converts a class name into a (possibly localized) string:::sym->if->length->sym->flags->s->visit->new->StringBuilder->for->is->is->nonEmpty->return->s->toString->else->if->length->s->norm->if->localize->else->if->nonEmpty->visit->localize->else->visit->localize->return->else->if->return->sym->getQualifiedName->toString->else->return->toString
Printer#printMethodArgs(List, boolean, Locale):::Converts a set of method argument types into their corresponding localized string representation.:::if->return->visitTypes->else->buf->new->StringBuilder->while->nonEmpty->buf->visit->append->buf->append->if->hasTag->buf->visit->append->if->getAnnotationMirrors->nonEmpty->buf->append->buf->getAnnotationMirrors->append->buf->append->buf->append->else->buf->visit->append->return->buf->toString
Printer#visitClassSymbol(ClassSymbol, Locale)::: printer visit class symbol:::return->isEmpty->localize->toString
Printer#visitMethodSymbol(MethodSymbol, Locale)::: printer visit method symbol:::if->s->isStaticOrInstanceInit->return->toString->else->ms->toString->toString->if->if->hasTag->getTypeArguments->visitTypes->getParameterTypes->s->flags->printMethodArgs->return
Printer#visitOperatorSymbol(OperatorSymbol, Locale)::: printer visit operator symbol:::return->visitMethodSymbol
Printer#visitPackageSymbol(PackageSymbol, Locale)::: printer visit package symbol:::return->s->isUnnamed->localize->toString
Printer#visitTypeSymbol(TypeSymbol, Locale)::: printer visit type symbol:::return->visitSymbol
Printer#visitVarSymbol(VarSymbol, Locale)::: printer visit var symbol:::return->visitSymbol
Printer#visitSymbol(Symbol, Locale)::: printer visit symbol:::return->toString
Scope#getSymbols():::Returns all Symbols in this Scope:::return->getSymbols
Scope#getSymbols(Filter):::Returns Symbols that match the given filter:::return->getSymbols
Scope#getSymbols(LookupKind):::Returns all Symbols in this Scope:::return->getSymbols
Scope#getSymbols(Filter, LookupKind):::Returns Symbols that match the given filter:::
Scope#getSymbolsByName(Name):::Returns Symbols with the given name:::return->getSymbolsByName
Scope#getSymbolsByName(Name, Filter):::Returns Symbols with the given name that match the given filter:::return->getSymbolsByName
Scope#getSymbolsByName(Name, LookupKind):::Returns Symbols with the given name:::return->getSymbolsByName
Scope#getSymbolsByName(Name, Filter, LookupKind):::Returns Symbols with the given name that match the given filter:::
Scope#findFirst(Name):::Return the first Symbol from this or outward scopes with the given name:::return->findFirst
Scope#findFirst(Name, Filter):::Return the first Symbol from this or outward scopes with the given name that matches the  given filter:::it->getSymbolsByName->iterator->return->it->hasNext->it->next
Scope#anyMatch(Filter):::Returns true iff there are is at least one Symbol in this scope matching the given filter:::return->getSymbols->iterator->hasNext
Scope#includes(Symbol):::Returns true iff the given Symbol is in this scope or any outward scope.:::return->includes
Scope#includes(Symbol, LookupKind):::Returns true iff the given Symbol is in this scope, optionally checking outward scopes.:::return->getSymbolsByName->iterator->hasNext
Scope#isEmpty():::Returns true iff this scope does not contain any Symbol:::return->getSymbols->iterator->hasNext
Scope#getOrigin(Symbol):::Returns the Scope from which the givins Symbol originates in this scope.:::
Scope#isStaticallyImported(Symbol):::Returns true iff the given Symbol is part of this scope due to a static import.:::
Scope.ScopeListener#symbolAdded(Symbol, Scope)::: scope listener symbol added:::
Scope.ScopeListener#symbolRemoved(Symbol, Scope)::: scope listener symbol removed:::
Scope.ScopeListenerList#add(ScopeListener)::: scope listener list add:::listeners->new->WeakReference<>->prepend
Scope.ScopeListenerList#symbolAdded(Symbol, Scope)::: scope listener list symbol added:::walkReferences
Scope.ScopeListenerList#symbolRemoved(Symbol, Scope)::: scope listener list symbol removed:::walkReferences
Scope.ScopeListenerList#walkReferences(Symbol, Scope, boolean)::: scope listener list walk references:::newListeners->new->ListBuffer<>->foreach->sl->wsl->get->if->if->sl->symbolRemoved->else->sl->symbolAdded->newListeners->add->newListeners->toList
Scope.WriteableScope#enter(Symbol):::Enter the given Symbol into this scope.:::
Scope.WriteableScope#enterIfAbsent(Symbol):::Enter symbol sym in this scope if not already there.:::
Scope.WriteableScope#remove(Symbol)::: writeable scope remove:::
Scope.WriteableScope#dup():::Construct a fresh scope within this scope, with same owner:::return->dup
Scope.WriteableScope#dup(Symbol):::Construct a fresh scope within this scope, with new owner:::
Scope.WriteableScope#leave():::Must be called on dup-ed scopes to be able to work with the outward scope again.:::
Scope.WriteableScope#dupUnshared():::Construct a fresh scope within this scope, with same owner:::return->dupUnshared
Scope.WriteableScope#dupUnshared(Symbol):::Construct a fresh scope within this scope, with new owner:::
Scope.WriteableScope#create(Symbol):::Create a new WriteableScope.:::return->new->ScopeImpl
Scope.ScopeImpl#dup(Symbol):::Construct a fresh scope within this scope, with new owner,  which shares its table with the outer scope:::result->new->ScopeImpl->return
Scope.ScopeImpl#dupUnshared(Symbol):::Construct a fresh scope within this scope, with new owner,  with a new hash table, whose contents initially are those of  the table of its outer scope.:::if->acceptScopes->Collections->new->IdentityHashMap<>->newSetFromMap->c->while->acceptScopes->add->n->oldTable->newTable->new->EntryArr->for->i->return->new->ScopeImpl->else->return->clone->new->ScopeImpl
Scope.ScopeImpl#leave():::Remove all entries of this scope from its table, if shared  with next.:::Assert->check->if->return->while->hash->getIndex->e->Assert->check->Assert->check->return
Scope.ScopeImpl#dble():::Double size of hash table.:::Assert->check->oldtable->newtable->new->EntryArr->for->s->n->for->i
Scope.ScopeImpl#enter(Symbol):::Enter symbol sym in this scope.:::Assert->check->if->dble->hash->getIndex->old->if->e->new->Entry->listeners->symbolAdded
Scope.ScopeImpl#remove(Symbol):::Remove symbol from this scope.:::Assert->check->e->lookup->if->return->i->getIndex->te->if->else->while->if->break->if->else->while->if->break->listeners->symbolRemoved
Scope.ScopeImpl#enterIfAbsent(Symbol):::Enter symbol sym in this scope if not already there.:::Assert->check->e->lookup->while->e->next->if->enter
Scope.ScopeImpl#includes(Symbol):::Given a class, is there already a class with same fully  qualified name in this (import) scope?:::for->e->lookup->e->next->return
Scope.ScopeImpl#lookup(Name):::Return the entry associated with given name, starting in  this scope and proceeding outwards:::return->lookup
Scope.ScopeImpl#lookup(Name, Filter)::: scope impl lookup:::e->getIndex->if->return->while->sf->accepts->return
Scope.ScopeImpl#findFirst(Name, Filter)::: scope impl find first:::return->lookup
Scope.ScopeImpl#getIndex(Name):::Look for slot in the table:::h->name->hashCode->i->x->d->for
Scope.ScopeImpl#anyMatch(Filter)::: scope impl any match:::return->getSymbols->iterator->hasNext
Scope.ScopeImpl#getSymbols(Filter, LookupKind)::: scope impl get symbols:::return->new->Iterator<Symbol>
Scope.ScopeImpl#getSymbolsByName(Name, Filter, LookupKind)::: scope impl get symbols by name:::return->new->Iterator<Symbol>
Scope.ScopeImpl#getOrigin(Symbol)::: scope impl get origin:::for->e->lookup->e->next->return
Scope.ScopeImpl#isStaticallyImported(Symbol)::: scope impl is statically imported:::return
Scope.ScopeImpl#toString()::: scope impl to string:::result->new->StringBuilder->result->append->for->s->result->append->return->result->toString
Scope.Entry#next():::Return next entry with the same name as this entry, proceeding  outwards if not found in this scope.:::return
Scope.Entry#next(Filter)::: entry next:::if->sf->accepts->return->else->return->shadowed->next
Scope.ImportScope#finalizeScope():::Finalize the content of the ImportScope to speed-up future lookups:::for->scopes->toList->scopes->nonEmpty
Scope.ImportScope#finalizeSingleScope(Scope)::: import scope finalize single scope:::if->isStaticallyImported->finalized->WriteableScope->create->foreach->impScope->getSymbols->finalized->enter->new->ScopeListener->add->return->return
Scope.NamedImportScope#importByName(Types, Scope, Name, ImportFilter, JCImport, BiConsumer)::: named import scope import by name:::return->new->FilterImportScope->appendScope
Scope.NamedImportScope#importType(Scope, Scope, Symbol)::: named import scope import type:::return->new->SingleEntryScope->appendScope
Scope.NamedImportScope#appendScope(Scope, Name)::: named import scope append scope:::appendSubScope->existing->name2Scopes->get->if->Arrays->copyOf->else->new->ScopeArr->name2Scopes->put->return
Scope.NamedImportScope#getSymbolsByName(Name, Filter, LookupKind)::: named import scope get symbols by name:::scopes->name2Scopes->get->if->return->Collections->emptyList->return->Iterators->Arrays->asList->scope->getSymbolsByName->iterator->createCompoundIterator
Scope.NamedImportScope#finalizeScope()::: named import scope finalize scope:::super->finalizeScope->foreach->name2Scopes->values->for->i
Scope.NamedImportScope.SingleEntryScope#getSymbols(Filter, LookupKind)::: single entry scope get symbols:::return->sf->accepts->Collections->emptyList
Scope.NamedImportScope.SingleEntryScope#getSymbolsByName(Name, Filter, LookupKind)::: single entry scope get symbols by name:::return->sf->accepts->Collections->emptyList
Scope.NamedImportScope.SingleEntryScope#getOrigin(Symbol)::: single entry scope get origin:::return
Scope.NamedImportScope.SingleEntryScope#isStaticallyImported(Symbol)::: single entry scope is statically imported:::return
Scope.StarImportScope#importAll(Types, Scope, ImportFilter, JCImport, BiConsumer)::: star import scope import all:::foreach->Assert->check->fis->if->return->new->FilterImportScope->prependSubScope
Scope.StarImportScope#isFilled()::: star import scope is filled:::return->subScopes->nonEmpty
Scope.ImportFilter#accepts(Scope, Symbol)::: import filter accepts:::
Scope.FilterImportScope#getSymbols(Filter, LookupKind)::: filter import scope get symbols:::if->return->getSymbolsByName->try->si->new->SymbolImporter->results->si->List->nil->importFrom->return->Iterable->iterator->createCompoundIterator->filter->accepts->createFilterIterator->catch->cfHandler->accept->return->Collections->emptyList->finally
Scope.FilterImportScope#getSymbolsByName(Name, Filter, LookupKind)::: filter import scope get symbols by name:::if->return->Collections->emptyList->try->si->new->SymbolImporter->results->si->List->nil->importFrom->return->Iterable->iterator->createCompoundIterator->filter->accepts->createFilterIterator->catch->cfHandler->accept->return->Collections->emptyList->finally
Scope.FilterImportScope#getOrigin(Symbol)::: filter import scope get origin:::return
Scope.FilterImportScope#isStaticallyImported(Symbol)::: filter import scope is statically imported:::return->isStaticallyImported
Scope.FilterImportScope#isStaticallyImported()::: filter import scope is statically imported:::return
Scope.FilterImportScope.SymbolImporter#importFrom(TypeSymbol, List>)::: symbol importer import from:::if->processed->add->return->if->types->supertype->importFrom->foreach->types->interfaces->importFrom->return->results->doLookup->prepend
Scope.FilterImportScope.SymbolImporter#doLookup(TypeSymbol)::: symbol importer do lookup:::
Scope.CompoundScope#prependSubScope(Scope)::: compound scope prepend sub scope:::if->subScopes->prepend->add->listeners->symbolAdded
Scope.CompoundScope#appendSubScope(Scope)::: compound scope append sub scope:::if->subScopes->append->add->listeners->symbolAdded
Scope.CompoundScope#symbolAdded(Symbol, Scope)::: compound scope symbol added:::listeners->symbolAdded
Scope.CompoundScope#symbolRemoved(Symbol, Scope)::: compound scope symbol removed:::listeners->symbolRemoved
Scope.CompoundScope#getMark()::: compound scope get mark:::return
Scope.CompoundScope#toString()::: compound scope to string:::buf->new->StringBuilder->buf->append->sep->foreach->buf->append->buf->append->buf->append->return->buf->toString
Scope.CompoundScope#getSymbols(Filter, LookupKind)::: compound scope get symbols:::return->Iterators->scope->getSymbols->iterator->createCompoundIterator
Scope.CompoundScope#getSymbolsByName(Name, Filter, LookupKind)::: compound scope get symbols by name:::return->Iterators->scope->getSymbolsByName->iterator->createCompoundIterator
Scope.CompoundScope#getOrigin(Symbol)::: compound scope get origin:::foreach->if->delegate->includes->return->delegate->getOrigin->return
Scope.CompoundScope#isStaticallyImported(Symbol)::: compound scope is statically imported:::foreach->if->delegate->includes->return->delegate->isStaticallyImported->return
Scope.ErrorScope#dup(Symbol)::: error scope dup:::return->new->ErrorScope
Scope.ErrorScope#dupUnshared(Symbol)::: error scope dup unshared:::return->table->clone->new->ErrorScope
Scope.ErrorScope#lookup(Name)::: error scope lookup:::e->super->lookup->if->return->new->Entry->else->return
Symbol#flags():::An accessor method for the flags of this symbol:::return
Symbol#getRawAttributes():::An accessor method for the attributes of this symbol:::return->List->nil->metadata->getDeclarationAttributes
Symbol#getRawTypeAttributes():::An accessor method for the type attributes of this symbol:::return->List->nil->metadata->getTypeAttributes
Symbol#attribute(Symbol):::Fetch a particular annotation from a symbol.:::foreach->getRawAttributes->if->return->return
Symbol#annotationsPendingCompletion()::: symbol annotations pending completion:::return->metadata->pendingCompletion
Symbol#appendAttributes(List)::: symbol append attributes:::if->l->nonEmpty->initedMetadata->append
Symbol#appendClassInitTypeAttributes(List)::: symbol append class init type attributes:::if->l->nonEmpty->initedMetadata->appendClassInitTypeAttributes
Symbol#appendInitTypeAttributes(List)::: symbol append init type attributes:::if->l->nonEmpty->initedMetadata->appendInitTypeAttributes
Symbol#appendUniqueTypeAttributes(List)::: symbol append unique type attributes:::if->l->nonEmpty->initedMetadata->appendUniqueTypes
Symbol#getClassInitTypeAttributes()::: symbol get class init type attributes:::return->List->nil->metadata->getClassInitTypeAttributes
Symbol#getInitTypeAttributes()::: symbol get init type attributes:::return->List->nil->metadata->getInitTypeAttributes
Symbol#setInitTypeAttributes(List)::: symbol set init type attributes:::initedMetadata->setInitTypeAttributes
Symbol#setClassInitTypeAttributes(List)::: symbol set class init type attributes:::initedMetadata->setClassInitTypeAttributes
Symbol#getDeclarationAttributes()::: symbol get declaration attributes:::return->List->nil->metadata->getDeclarationAttributes
Symbol#hasAnnotations()::: symbol has annotations:::return->metadata->isEmpty
Symbol#hasTypeAnnotations()::: symbol has type annotations:::return->metadata->isTypesEmpty
Symbol#isCompleted()::: symbol is completed:::return->completer->isTerminal
Symbol#prependAttributes(List)::: symbol prepend attributes:::if->l->nonEmpty->initedMetadata->prepend
Symbol#resetAnnotations()::: symbol reset annotations:::initedMetadata->reset
Symbol#setAttributes(Symbol)::: symbol set attributes:::if->initedMetadata->setAttributes
Symbol#setDeclarationAttributes(List)::: symbol set declaration attributes:::if->a->nonEmpty->initedMetadata->setDeclarationAttributes
Symbol#setTypeAttributes(List)::: symbol set type attributes:::if->a->nonEmpty->if->new->SymbolMetadata->metadata->setTypeAttributes
Symbol#initedMetadata()::: symbol inited metadata:::if->new->SymbolMetadata->return
Symbol#getMetadata():::This method is intended for debugging only.:::return
Symbol#clone(Symbol):::Clone this symbol with new owner:::throw->new->AssertionError
Symbol#accept(Symbol.Visitor, P)::: symbol accept:::return->v->visitSymbol
Symbol#toString():::The Java source which this symbol represents:::return->name->toString
Symbol#location():::A Java source description of the location of this symbol; used for  error reporting.:::if->isEmpty->owner->flags->return->return
Symbol#location(Type, Types)::: symbol location:::if->isEmpty->return->location->if->hasTag->ownertype->types->asOuterSuper->if->return->return
Symbol#baseSymbol()::: symbol base symbol:::return
Symbol#erasure(Types):::The symbol's erased type.:::if->types->erasure->return
Symbol#externalType(Types):::The external type of a symbol:::t->erasure->if->owner->hasOuterInstance->outerThisType->types->getEnclosingType->erasure->return->t->getParameterTypes->prepend->t->getReturnType->t->getThrownTypes->new->MethodType->else->return
Symbol#isDeprecated()::: symbol is deprecated:::return
Symbol#hasDeprecatedAnnotation()::: symbol has deprecated annotation:::return
Symbol#isDeprecatedForRemoval()::: symbol is deprecated for removal:::return
Symbol#isDeprecatableViaAnnotation()::: symbol is deprecatable via annotation:::switch->getKind->return->return
Symbol#isStatic()::: symbol is static:::return->flags->owner->flags
Symbol#isInterface()::: symbol is interface:::return->flags
Symbol#isPrivate()::: symbol is private:::return
Symbol#isEnum()::: symbol is enum:::return->flags
Symbol#isLocal():::Is this symbol declared (directly or indirectly) local  to a method or variable initializer?  Also includes fields of inner classes which are in  turn local to a method or variable initializer.:::return->matches->owner->isLocal
Symbol#isAnonymous():::Has this symbol an empty name? This includes anonymous  inner classes.:::return->name->isEmpty
Symbol#isConstructor():::Is this symbol a constructor?:::return
Symbol#getQualifiedName():::The fully qualified name of this symbol:::return
Symbol#flatName():::The fully qualified name of this symbol after converting to flat  representation:::return->getQualifiedName
Symbol#members():::If this is a class or package, its members, otherwise null.:::return
Symbol#isInner():::A class is an inner class if it it has an enclosing instance class.:::return->type->getEnclosingType->hasTag
Symbol#hasOuterInstance():::An inner class has an outer instance if it is not an interface  it has an enclosing instance class which might be referenced from the class:::return->type->getEnclosingType->hasTag->flags
Symbol#enclClass():::The closest enclosing class of this symbol's declaration:::c->while->matches->hasTag->return
Symbol#outermostClass():::The outermost class which indirectly owns this symbol.:::sym->prev->while->return
Symbol#packge():::The package which indirectly owns this symbol.:::sym->while->return
Symbol#isSubClass(Symbol, Types):::Is this symbol a subclass of `base'? Only defined for ClassSymbols.:::throw->new->AssertionError
Symbol#isMemberOf(TypeSymbol, Types):::Fully check membership: hierarchy, protection, and hiding:::return->clazz->isSubClass->isInheritedIn->hiddenIn
Symbol#isEnclosedBy(ClassSymbol):::Is this symbol the same as or enclosed by the given class?:::for->sym->return
Symbol#hiddenIn(ClassSymbol, Types)::: symbol hidden in:::sym->hiddenInInternal->Assert->check->return
Symbol#hiddenInInternal(ClassSymbol, Types):::This method looks in the supertypes graph that has the current class as the initial node, till it finds the current symbol or another symbol that hides it:::if->return->foreach->currentClass->members->getSymbolsByName->if->sym->flags->types->isSubSignature->return->hiddenSym->foreach->types->interfaces->types->supertype->prepend->if->st->hasTag->sym->hiddenInInternal->if->return->else->if->return
Symbol#isAccessibleIn(Symbol, Types):::Is this symbol accessible in a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       the given class.:::switch->return->return->return->clazz->flags->thisPackage->this->packge->for->sup->types->supertype->return->clazz->flags
Symbol#isInheritedIn(Symbol, Types):::Is this symbol inherited into a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       of the given class.:::return->isAccessibleIn
Symbol#asMemberOf(Type, Types):::The (variable or method) symbol seen as a member of given  class type`site' (this might change the symbol's type):::throw->new->AssertionError
Symbol#overrides(Symbol, TypeSymbol, Types, boolean):::Does this method symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::return
Symbol#complete():::Complete the elaboration of this symbol's definition.:::if->c->c->complete
Symbol#apiComplete()::: symbol api complete:::try->complete->catch->handleAPICompletionFailure->finally
Symbol#exists():::True if the symbol represents an entity that exists.:::return
Symbol#asType()::: symbol as type:::return
Symbol#getEnclosingElement()::: symbol get enclosing element:::return
Symbol#getKind()::: symbol get kind:::return
Symbol#getModifiers()::: symbol get modifiers:::apiComplete->return->Flags->flags->asModifierSet
Symbol#getSimpleName()::: symbol get simple name:::return
Symbol#getAnnotationMirrors():::This is the implementation for javax.lang.model.element.Element.getAnnotationMirrors().:::apiComplete->return->getRawAttributes
Symbol#getEnclosedElements()::: symbol get enclosed elements:::return->List->nil
Symbol#getTypeParameters()::: symbol get type parameters:::l->new->ListBuffer<>->foreach->type->getTypeArguments->Assert->getKind->check->l->append->return->l->toList
Symbol.DelegatedSymbol#toString()::: delegated symbol to string:::return->other->toString
Symbol.DelegatedSymbol#location()::: delegated symbol location:::return->other->location
Symbol.DelegatedSymbol#location(Type, Types)::: delegated symbol location:::return->other->location
Symbol.DelegatedSymbol#baseSymbol()::: delegated symbol base symbol:::return
Symbol.DelegatedSymbol#erasure(Types)::: delegated symbol erasure:::return->other->erasure
Symbol.DelegatedSymbol#externalType(Types)::: delegated symbol external type:::return->other->externalType
Symbol.DelegatedSymbol#isLocal()::: delegated symbol is local:::return->other->isLocal
Symbol.DelegatedSymbol#isConstructor()::: delegated symbol is constructor:::return->other->isConstructor
Symbol.DelegatedSymbol#getQualifiedName()::: delegated symbol get qualified name:::return->other->getQualifiedName
Symbol.DelegatedSymbol#flatName()::: delegated symbol flat name:::return->other->flatName
Symbol.DelegatedSymbol#members()::: delegated symbol members:::return->other->members
Symbol.DelegatedSymbol#isInner()::: delegated symbol is inner:::return->other->isInner
Symbol.DelegatedSymbol#hasOuterInstance()::: delegated symbol has outer instance:::return->other->hasOuterInstance
Symbol.DelegatedSymbol#enclClass()::: delegated symbol encl class:::return->other->enclClass
Symbol.DelegatedSymbol#outermostClass()::: delegated symbol outermost class:::return->other->outermostClass
Symbol.DelegatedSymbol#packge()::: delegated symbol packge:::return->other->packge
Symbol.DelegatedSymbol#isSubClass(Symbol, Types)::: delegated symbol is sub class:::return->other->isSubClass
Symbol.DelegatedSymbol#isMemberOf(TypeSymbol, Types)::: delegated symbol is member of:::return->other->isMemberOf
Symbol.DelegatedSymbol#isEnclosedBy(ClassSymbol)::: delegated symbol is enclosed by:::return->other->isEnclosedBy
Symbol.DelegatedSymbol#isInheritedIn(Symbol, Types)::: delegated symbol is inherited in:::return->other->isInheritedIn
Symbol.DelegatedSymbol#asMemberOf(Type, Types)::: delegated symbol as member of:::return->other->asMemberOf
Symbol.DelegatedSymbol#complete()::: delegated symbol complete:::other->complete
Symbol.DelegatedSymbol#accept(ElementVisitor, P)::: delegated symbol accept:::return->other->accept
Symbol.DelegatedSymbol#accept(Symbol.Visitor, P)::: delegated symbol accept:::return->v->visitSymbol
Symbol.DelegatedSymbol#getUnderlyingSymbol()::: delegated symbol get underlying symbol:::return
Symbol.TypeSymbol#formFullName(Name, Symbol):::form a fully qualified name from a name and an owner:::if->return->if->matches->hasTag->return->prefix->owner->getQualifiedName->if->return->else->return->prefix->append
Symbol.TypeSymbol#formFlatName(Name, Symbol):::form a fully qualified name from a name and an owner, after  converting to flat representation:::if->matches->hasTag->return->sep->prefix->owner->flatName->if->return->else->return->prefix->append
Symbol.TypeSymbol#precedes(TypeSymbol, Types):::A partial ordering between type symbols that refines the class inheritance graph:::if->return->if->type->getTag->hasTag->if->type->hasTag->return->types->rank->types->rank->types->rank->types->rank->that->getQualifiedName->this->getQualifiedName->compareTo->else->if->type->hasTag->return->types->isSubtype->return->type->hasTag
Symbol.TypeSymbol#getEnclosedElements()::: type symbol get enclosed elements:::list->List->nil->if->type->hasTag->return->apiComplete->foreach->members->getSymbols->sym->apiComplete->if->sym->flags->list->prepend->return
Symbol.TypeSymbol#getAnnotationTypeMetadata()::: type symbol get annotation type metadata:::Assert->error->return
Symbol.TypeSymbol#isAnnotationType()::: type symbol is annotation type:::return
Symbol.TypeSymbol#accept(Symbol.Visitor, P)::: type symbol accept:::return->v->visitTypeSymbol
Symbol.TypeVariableSymbol#getKind()::: type variable symbol get kind:::return
Symbol.TypeVariableSymbol#getGenericElement()::: type variable symbol get generic element:::return
Symbol.TypeVariableSymbol#getBounds()::: type variable symbol get bounds:::t->bound->t->getUpperBound->if->bound->isCompound->return->List->of->ct->if->isInterface->return->prepend->else->return
Symbol.TypeVariableSymbol#getAnnotationMirrors()::: type variable symbol get annotation mirrors:::candidates->owner->getRawTypeAttributes->index->owner->getTypeParameters->indexOf->res->List->nil->foreach->if->isCurrentSymbolsAnnotation->res->prepend->return->res->reverse
Symbol.TypeVariableSymbol#getAttribute(Class)::: type variable symbol get attribute:::name->annoType->getName->candidates->owner->getRawTypeAttributes->index->owner->getTypeParameters->indexOf->foreach->if->isCurrentSymbolsAnnotation->name->flatName->contentEquals->return->return
Symbol.TypeVariableSymbol#isCurrentSymbolsAnnotation(Attribute.TypeCompound, int)::: type variable symbol is current symbols annotation:::return
Symbol.TypeVariableSymbol#accept(ElementVisitor, P)::: type variable symbol accept:::return->v->visitTypeParameter
Symbol.ModuleSymbol#create(Name, Name):::Create a ModuleSymbol with an associated module-info ClassSymbol.:::msym->new->ModuleSymbol->info->new->ClassSymbol->formFullName->WriteableScope->create->return
Symbol.ModuleSymbol#getSimpleName()::: module symbol get simple name:::return->Convert->shortName
Symbol.ModuleSymbol#isOpen()::: module symbol is open:::return->flags->contains
Symbol.ModuleSymbol#isUnnamed()::: module symbol is unnamed:::return->name->isEmpty
Symbol.ModuleSymbol#isDeprecated()::: module symbol is deprecated:::return->hasDeprecatedAnnotation
Symbol.ModuleSymbol#isNoModule()::: module symbol is no module:::return
Symbol.ModuleSymbol#getKind()::: module symbol get kind:::return
Symbol.ModuleSymbol#getDirectives()::: module symbol get directives:::apiComplete->completeUsesProvides->return->Collections->unmodifiableList
Symbol.ModuleSymbol#completeUsesProvides()::: module symbol complete uses provides:::if->c->c->complete
Symbol.ModuleSymbol#outermostClass()::: module symbol outermost class:::return
Symbol.ModuleSymbol#toString()::: module symbol to string:::n->name->isEmpty->String->valueOf->return
Symbol.ModuleSymbol#accept(ElementVisitor, P)::: module symbol accept:::return->v->visitModule
Symbol.ModuleSymbol#getEnclosedElements()::: module symbol get enclosed elements:::list->List->nil->foreach->if->sym->members->anyMatch->list->prepend->return
Symbol.ModuleSymbol#reset()::: module symbol reset:::
Symbol.PackageSymbol#toString()::: package symbol to string:::return->fullname->toString
Symbol.PackageSymbol#getQualifiedName()::: package symbol get qualified name:::return
Symbol.PackageSymbol#isUnnamed()::: package symbol is unnamed:::return->name->isEmpty
Symbol.PackageSymbol#members()::: package symbol members:::complete->return
Symbol.PackageSymbol#flags()::: package symbol flags:::complete->return
Symbol.PackageSymbol#getRawAttributes()::: package symbol get raw attributes:::complete->if->package_info->complete->mergeAttributes->return->super->getRawAttributes
Symbol.PackageSymbol#mergeAttributes()::: package symbol merge attributes:::if->new->SymbolMetadata->metadata->setAttributes
Symbol.PackageSymbol#exists():::A package "exists" if a type or package that exists has  been seen within it.:::return
Symbol.PackageSymbol#getKind()::: package symbol get kind:::return
Symbol.PackageSymbol#getEnclosingElement()::: package symbol get enclosing element:::return->modle->isNoModule
Symbol.PackageSymbol#accept(ElementVisitor, P)::: package symbol accept:::return->v->visitPackage
Symbol.PackageSymbol#accept(Symbol.Visitor, P)::: package symbol accept:::return->v->visitPackageSymbol
Symbol.PackageSymbol#reset():::Resets the Symbol into the state good for next round of annotation processing.:::
Symbol.ClassSymbol#toString():::The Java source which this symbol represents.:::return->className
Symbol.ClassSymbol#flags()::: class symbol flags:::complete->return
Symbol.ClassSymbol#members()::: class symbol members:::complete->return
Symbol.ClassSymbol#getRawAttributes()::: class symbol get raw attributes:::complete->return->super->getRawAttributes
Symbol.ClassSymbol#getRawTypeAttributes()::: class symbol get raw type attributes:::complete->return->super->getRawTypeAttributes
Symbol.ClassSymbol#erasure(Types)::: class symbol erasure:::if->types->type->getEnclosingType->erasure->List->nil->type->getMetadata->new->ClassType->return
Symbol.ClassSymbol#className()::: class symbol class name:::if->name->isEmpty->return->Log->getLocalizedString->else->return->fullname->toString
Symbol.ClassSymbol#getQualifiedName()::: class symbol get qualified name:::return
Symbol.ClassSymbol#flatName()::: class symbol flat name:::return
Symbol.ClassSymbol#isSubClass(Symbol, Types)::: class symbol is sub class:::if->return->else->if->base->flags->for->t->t->hasTag->types->supertype->else->for->t->t->hasTag->types->supertype->return
Symbol.ClassSymbol#complete():::Complete the elaboration of this symbol's definition.:::origCompleter->try->super->complete->catch->classSymbolCompleteFailed->new->ErrorType->throw->finally
Symbol.ClassSymbol#getInterfaces()::: class symbol get interfaces:::apiComplete->if->t->if->List->nil->if->return->Type->getModelTypes->return->else->return->List->nil
Symbol.ClassSymbol#getSuperclass()::: class symbol get superclass:::apiComplete->if->t->if->return->t->isInterface->getModelType->else->return
Symbol.ClassSymbol#getSuperClassToSearchForAnnotations():::Returns the next class to search for inherited annotations or null if the next class can't be found.:::sup->getSuperclass->if->sup->hasTag->sup->isErroneous->return->return
Symbol.ClassSymbol#getInheritedAnnotations(Class)::: class symbol get inherited annotations:::sup->getSuperClassToSearchForAnnotations->return->super->getInheritedAnnotations->sup->getAnnotationsByType
Symbol.ClassSymbol#getKind()::: class symbol get kind:::apiComplete->flags->flags->if->return->else->if->return->else->if->return->else->return
Symbol.ClassSymbol#getModifiers()::: class symbol get modifiers:::apiComplete->flags->flags->return->Flags->asModifierSet
Symbol.ClassSymbol#getNestingKind()::: class symbol get nesting kind:::apiComplete->if->return->else->if->name->isEmpty->return->else->if->return->else->return
Symbol.ClassSymbol#getAttribute(Class)::: class symbol get attribute:::attrib->super->getAttribute->inherited->annoType->isAnnotationPresent->if->return->superType->getSuperClassToSearchForAnnotations->return->superType->getAttribute
Symbol.ClassSymbol#accept(ElementVisitor, P)::: class symbol accept:::return->v->visitType
Symbol.ClassSymbol#accept(Symbol.Visitor, P)::: class symbol accept:::return->v->visitClassSymbol
Symbol.ClassSymbol#markAbstractIfNeeded(Types)::: class symbol mark abstract if needed:::if->getEnv->flags->types->supertype->flags->if->types->firstUnimplementedAbstract
Symbol.ClassSymbol#reset():::Resets the Symbol into the state good for next round of annotation processing.:::if->t->t->setEnclosingType->clearAnnotationMetadata
Symbol.ClassSymbol#clearAnnotationMetadata()::: class symbol clear annotation metadata:::AnnotationTypeMetadata->notAnAnnotationType
Symbol.ClassSymbol#getAnnotationTypeMetadata()::: class symbol get annotation type metadata:::return
Symbol.ClassSymbol#isAnnotationType()::: class symbol is annotation type:::return
Symbol.ClassSymbol#setAnnotationTypeMetadata(AnnotationTypeMetadata)::: class symbol set annotation type metadata:::Assert->checkNonNull->Assert->annotationTypeMetadata->isMetadataForAnnotationType->check
Symbol.VarSymbol#clone(Symbol):::Clone this symbol with new owner.:::v->new->VarSymbol->return
Symbol.VarSymbol#toString()::: var symbol to string:::return->name->toString
Symbol.VarSymbol#asMemberOf(Type, Types)::: var symbol as member of:::return->types->memberType->new->VarSymbol
Symbol.VarSymbol#getKind()::: var symbol get kind:::flags->flags->if->if->isExceptionParameter->return->else->return->else->if->return->else->if->return->else->if->isResourceVariable->return->else->return
Symbol.VarSymbol#accept(ElementVisitor, P)::: var symbol accept:::return->v->visitVariable
Symbol.VarSymbol#getConstantValue()::: var symbol get constant value:::return->Constants->getConstValue->decode
Symbol.VarSymbol#setLazyConstValue(Env, Attr, JCVariableDecl)::: var symbol set lazy const value:::attr->attribLazyConstantValue->setData
Symbol.VarSymbol#isExceptionParameter()::: var symbol is exception parameter:::return
Symbol.VarSymbol#isResourceVariable()::: var symbol is resource variable:::return
Symbol.VarSymbol#getConstValue()::: var symbol get const value:::if->return->else->if->eval->try->eval->call->catch->throw->new->AssertionError->finally->return
Symbol.VarSymbol#setData(Object)::: var symbol set data:::Assert->check
Symbol.VarSymbol#accept(Symbol.Visitor, P)::: var symbol accept:::return->v->visitVarSymbol
Symbol.MethodSymbol#clone(Symbol):::Clone this symbol with new owner.:::m->new->MethodSymbol->return
Symbol.MethodSymbol#getModifiers()::: method symbol get modifiers:::flags->flags->return->Flags->asModifierSet
Symbol.MethodSymbol#toString():::The Java source which this symbol represents.:::if->flags->return->toString->else->s->toString->name->toString->if->if->type->hasTag->getTypeArguments->type->flags->argtypes->return
Symbol.MethodSymbol#isDynamic()::: method symbol is dynamic:::return
Symbol.MethodSymbol#implemented(TypeSymbol, Types):::find a symbol that this (proxy method) symbol implements.:::impl->for->is->types->interfaces->is->nonEmpty->return
Symbol.MethodSymbol#implementedIn(TypeSymbol, Types)::: method symbol implemented in:::impl->foreach->c->members->getSymbolsByName->if->this->overrides->types->type->getReturnType->types->memberType->getReturnType->isSameType->return
Symbol.MethodSymbol#binaryOverrides(Symbol, TypeSymbol, Types):::Will the erasure of this method be considered by the VM to  override the erasure of the other when seen from class `origin'?:::if->isConstructor->return->if->return->other->if->other->isOverridableIn->types->asSuper->types->erasure->other->erasure->isSameType->return->return->flags->other->isOverridableIn->this->isMemberOf->types->erasure->other->erasure->isSameType
Symbol.MethodSymbol#binaryImplementation(ClassSymbol, Types):::The implementation of this (abstract) symbol in class origin,  from the VM's point of view, null if method does not have an  implementation in class.:::for->c->types->supertype->return
Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean):::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::return->overrides
Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean, boolean):::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin:::if->isConstructor->return->if->return->other->if->other->isOverridableIn->types->asSuper->mt->types->memberType->ot->types->memberType->if->types->isSubSignature->if->return->if->types->returnTypeSubstitutable->return->if->flags->other->flags->other->flags->other->isOverridableIn->this->isMemberOf->return->mt->types->memberType->ot->types->memberType->return->types->isSubSignature->types->resultSubtype
Symbol.MethodSymbol#isOverridableIn(TypeSymbol)::: method symbol is overridable in:::switch->return->return->isInterface->return->origin->flags->return->this->packge->origin->packge->origin->flags->return
Symbol.MethodSymbol#isInheritedIn(Symbol, Types)::: method symbol is inherited in:::switch->return->isInterface->return->super->isInheritedIn
Symbol.MethodSymbol#isLambdaMethod()::: method symbol is lambda method:::return->flags
Symbol.MethodSymbol#implementation(TypeSymbol, Types, boolean):::The implementation of this (abstract) symbol in class origin;  null if none exists:::return->implementation
Symbol.MethodSymbol#implementation(TypeSymbol, Types, boolean, Filter)::: method symbol implementation:::res->types->implementation->if->return->if->types->isDerivedRaw->origin->isInterface->return->types->supertype->implementation->else->return
Symbol.MethodSymbol#params()::: method symbol params:::owner->complete->if->newParams->new->ListBuffer<>->i->foreach->type->getParameterTypes->paramName->fromString->param->new->VarSymbol->newParams->append->newParams->toList->Assert->checkNonNull->return
Symbol.MethodSymbol#asMemberOf(Type, Types)::: method symbol as member of:::return->types->memberType->new->MethodSymbol
Symbol.MethodSymbol#getKind()::: method symbol get kind:::if->return->else->if->return->else->if->flags->return->isStatic->else->return
Symbol.MethodSymbol#isStaticOrInstanceInit()::: method symbol is static or instance init:::return->getKind->getKind
Symbol.MethodSymbol#getDefaultValue()::: method symbol get default value:::return
Symbol.MethodSymbol#getParameters()::: method symbol get parameters:::return->params
Symbol.MethodSymbol#isVarArgs()::: method symbol is var args:::return->flags
Symbol.MethodSymbol#isDefault()::: method symbol is default:::return->flags
Symbol.MethodSymbol#accept(ElementVisitor, P)::: method symbol accept:::return->v->visitExecutable
Symbol.MethodSymbol#accept(Symbol.Visitor, P)::: method symbol accept:::return->v->visitMethodSymbol
Symbol.MethodSymbol#getReceiverType()::: method symbol get receiver type:::return->asType->getReceiverType
Symbol.MethodSymbol#getReturnType()::: method symbol get return type:::return->asType->getReturnType
Symbol.MethodSymbol#getThrownTypes()::: method symbol get thrown types:::return->asType->getThrownTypes
Symbol.DynamicMethodSymbol#isDynamic()::: dynamic method symbol is dynamic:::return
Symbol.OperatorSymbol#accept(Symbol.Visitor, P)::: operator symbol accept:::return->v->visitOperatorSymbol
Symbol.OperatorSymbol#getAccessCode(Tag)::: operator symbol get access code:::if->tag->isIncOrDecUnaryOp->return->AccessCode->from->return
Symbol.Completer#complete(Symbol)::: completer complete:::
Symbol.Completer#isTerminal():::Returns true if this completer is terminal:::return
Symbol.CompletionFailure#getDiagnostic()::: completion failure get diagnostic:::return
Symbol.CompletionFailure#getMessage()::: completion failure get message:::return->diag->getMessage
Symbol.CompletionFailure#getDetailValue()::: completion failure get detail value:::return
Symbol.CompletionFailure#initCause(Throwable)::: completion failure init cause:::super->initCause->return
Symbol.Visitor#visitClassSymbol(ClassSymbol, P)::: visitor visit class symbol:::
Symbol.Visitor#visitMethodSymbol(MethodSymbol, P)::: visitor visit method symbol:::
Symbol.Visitor#visitPackageSymbol(PackageSymbol, P)::: visitor visit package symbol:::
Symbol.Visitor#visitOperatorSymbol(OperatorSymbol, P)::: visitor visit operator symbol:::
Symbol.Visitor#visitVarSymbol(VarSymbol, P)::: visitor visit var symbol:::
Symbol.Visitor#visitTypeSymbol(TypeSymbol, P)::: visitor visit type symbol:::
Symbol.Visitor#visitSymbol(Symbol, P)::: visitor visit symbol:::
SymbolMetadata#getDeclarationAttributes()::: symbol metadata get declaration attributes:::return->filterDeclSentinels
SymbolMetadata#getTypeAttributes()::: symbol metadata get type attributes:::return
SymbolMetadata#getInitTypeAttributes()::: symbol metadata get init type attributes:::return
SymbolMetadata#getClassInitTypeAttributes()::: symbol metadata get class init type attributes:::return
SymbolMetadata#setDeclarationAttributes(List)::: symbol metadata set declaration attributes:::Assert->pendingCompletion->isStarted->check->if->throw->new->NullPointerException
SymbolMetadata#setTypeAttributes(List)::: symbol metadata set type attributes:::if->throw->new->NullPointerException
SymbolMetadata#setInitTypeAttributes(List)::: symbol metadata set init type attributes:::if->throw->new->NullPointerException
SymbolMetadata#setClassInitTypeAttributes(List)::: symbol metadata set class init type attributes:::if->throw->new->NullPointerException
SymbolMetadata#setAttributes(SymbolMetadata)::: symbol metadata set attributes:::if->throw->new->NullPointerException->other->getDeclarationAttributes->setDeclarationAttributes->if->sym->flags->Assert->check->typeAttributes->new->ListBuffer<>->foreach->other->getTypeAttributes->if->isLocal->typeAttributes->append->typeAttributes->toList->setTypeAttributes->else->other->getTypeAttributes->setTypeAttributes->if->other->getInitTypeAttributes->setInitTypeAttributes->other->getClassInitTypeAttributes->setClassInitTypeAttributes
SymbolMetadata#reset()::: symbol metadata reset:::return
SymbolMetadata#isEmpty()::: symbol metadata is empty:::return->isStarted->pendingCompletion->attributes->isEmpty
SymbolMetadata#isTypesEmpty()::: symbol metadata is types empty:::return->type_attributes->isEmpty
SymbolMetadata#pendingCompletion()::: symbol metadata pending completion:::return
SymbolMetadata#append(List)::: symbol metadata append:::filterDeclSentinels->if->l->isEmpty->else->if->attributes->isEmpty->else->attributes->appendList->return
SymbolMetadata#appendUniqueTypes(List)::: symbol metadata append unique types:::if->l->isEmpty->else->if->type_attributes->isEmpty->else->foreach->if->type_attributes->contains->type_attributes->append->return
SymbolMetadata#appendInitTypeAttributes(List)::: symbol metadata append init type attributes:::if->l->isEmpty->else->if->init_type_attributes->isEmpty->else->init_type_attributes->appendList->return
SymbolMetadata#appendClassInitTypeAttributes(List)::: symbol metadata append class init type attributes:::if->l->isEmpty->else->if->clinit_type_attributes->isEmpty->else->clinit_type_attributes->appendList->return
SymbolMetadata#prepend(List)::: symbol metadata prepend:::filterDeclSentinels->if->l->isEmpty->else->if->attributes->isEmpty->else->attributes->prependList->return
SymbolMetadata#filterDeclSentinels(List)::: symbol metadata filter decl sentinels:::return->List->nil
SymbolMetadata#isStarted()::: symbol metadata is started:::return
Symtab#instance(Context):::Get the symbol table instance.:::instance->context->get->if->new->Symtab->return
Symtab#getClassField(Type, Types)::: symtab get class field:::return->classFields->new->UniqueType->arg->if->type->getTag->type->getTag->types->erasure->else->if->type->isPrimitiveOrVoid->types->boxedClass->else->throw->new->AssertionError->t->classType->getEnclosingType->List->of->new->ClassType->return->new->VarSymbol->computeIfAbsent
Symtab#initType(Type, ClassSymbol)::: symtab init type:::type->getTag->ordinal
Symtab#initType(Type, String)::: symtab init type:::names->fromString->new->ClassSymbol->initType
Symtab#initType(Type, String, String)::: symtab init type:::initType->names->fromString->type->getTag->ordinal
Symtab#enterClass(String):::Enter a class into symbol table.:::return->names->fromString->enterClass
Symtab#synthesizeEmptyInterfaceIfMissing(Type)::: symtab synthesize empty interface if missing:::completer->new->Completer
Symtab#synthesizeBoxTypeIfMissing(Type)::: symtab synthesize box type if missing:::sym->type->getTag->ordinal->enterClass->completer->new->Completer
Symtab#enterSyntheticAnnotation(String)::: symtab enter synthetic annotation:::type->names->fromString->enterClass->sym->WriteableScope->create->List->nil->List->nil->List->nil->return
Symtab#defineClass(Name, Symbol):::Define a new class given its name and owner.:::c->new->ClassSymbol->return
Symtab#enterClass(ModuleSymbol, Name, TypeSymbol):::Create a new toplevel or member class symbol with given name  and owner and enter in `classes' unless already there.:::Assert->checkNonNull->flatname->TypeSymbol->formFlatName->c->getClass->if->defineClass->doEnterClass->else->if->members->remove->ClassSymbol->formFullName->return
Symtab#getClass(ModuleSymbol, Name)::: symtab get class:::Assert->flatName->toString->checkNonNull->return->classes->Collections->emptyMap->getOrDefault->get
Symtab#lookupPackage(ModuleSymbol, Name)::: symtab lookup package:::Assert->checkNonNull->if->flatName->isEmpty->return->if->return->enterPackage->msym->complete->pack->get->if->return->getPackage->if->pack->exists->return->dependsOnUnnamed->stream->map->anyMatch->if->unnamedPack->getPackage->if->unnamedPack->exists->put->return->enterPackage->pack->complete->if->pack->exists->return->enterPackage->unnamedPack->complete->if->unnamedPack->exists->put->return->return->return->enterPackage
Symtab#removeClass(ModuleSymbol, Name)::: symtab remove class:::classes->getOrDefault->remove
Symtab#getAllClasses()::: symtab get all classes:::return->Iterators->classes->values->v->values->iterator->createCompoundIterator
Symtab#doEnterClass(ModuleSymbol, ClassSymbol)::: symtab do enter class:::classes->new->HashMap<>->computeIfAbsent->put
Symtab#enterClass(ModuleSymbol, Name):::Create a new member or toplevel class symbol with given flat name  and enter in `classes' unless already there.:::Assert->checkNonNull->ps->Convert->packagePart->lookupPackage->Assert->checkNonNull->Assert->checkNonNull->c->getClass->if->Convert->shortName->defineClass->doEnterClass->return->else->return
Symtab#packageExists(ModuleSymbol, Name):::Check to see if a package exists, given its fully qualified name.:::Assert->checkNonNull->return->lookupPackage->exists
Symtab#enterPackage(ModuleSymbol, Name):::Make a package, given its fully qualified name.:::Assert->checkNonNull->p->getPackage->if->Assert->fullname->isEmpty->check->Convert->shortName->Convert->packagePart->enterPackage->new->PackageSymbol->doEnterPackage->return
Symtab#doEnterPackage(ModuleSymbol, PackageSymbol)::: symtab do enter package:::packages->new->HashMap<>->computeIfAbsent->put->prepend
Symtab#addRootPackageFor(ModuleSymbol)::: symtab add root package for:::doEnterPackage->unnamedPackage->new->PackageSymbol->initialCompleter->complete
Symtab#getPackage(ModuleSymbol, Name)::: symtab get package:::return->packages->Collections->emptyMap->getOrDefault->get
Symtab#enterModule(Name)::: symtab enter module:::msym->modules->get->if->ModuleSymbol->create->addRootPackageFor->moduleCompleter->complete->modules->put->return
Symtab#getModule(Name)::: symtab get module:::return->modules->get
Symtab#inferModule(Name)::: symtab infer module:::if->packageName->isEmpty->return->msym->map->packages->get->if->return->foreach->map->entrySet->if->e->getValue->members->isEmpty->if->e->getKey->else->return->return
Symtab#listPackageModules(Name)::: symtab list package modules:::if->packageName->isEmpty->return->List->nil->result->List->nil->map->packages->get->if->foreach->map->entrySet->if->e->getValue->members->isEmpty->result->e->getKey->prepend->return
Symtab#getAllModules()::: symtab get all modules:::return->modules->values
Symtab#getClassesForName(Name)::: symtab get classes for name:::return->classes->Collections->emptyMap->getOrDefault->values
Symtab#getPackagesForName(Name)::: symtab get packages for name:::return->packages->Collections->emptyMap->getOrDefault->values
Type#getMetadata()::: type get metadata:::return
Type#getMetadataOfKind(Entry.Kind)::: type get metadata of kind:::return->metadata->get
Type#hasTag(TypeTag):::Checks if the current type tag is equal to the given tag.:::return->getTag
Type#getTag():::Returns the current type tag.:::
Type#isNumeric()::: type is numeric:::return
Type#isIntegral()::: type is integral:::return
Type#isPrimitive()::: type is primitive:::return
Type#isPrimitiveOrVoid()::: type is primitive or void:::return
Type#isReference()::: type is reference:::return
Type#isNullOrReference()::: type is null or reference:::return
Type#isPartial()::: type is partial:::return
Type#constValue():::The constant value of this type, null if this type does not have a constant value attribute:::return
Type#isFalse():::Is this a constant type whose value is false?:::return
Type#isTrue():::Is this a constant type whose value is true?:::return
Type#getModelType():::Get the representation of this type used for modelling purposes:::return
Type#getModelTypes(List)::: type get model types:::lb->new->ListBuffer<>->foreach->lb->t->getModelType->append->return->lb->toList
Type#getOriginalType():::For ErrorType, returns the original type, otherwise returns the type itself.:::return
Type#accept(Type.Visitor, S)::: type accept:::return->v->visitType
Type.StructuralTypeMapping#visitClassType(ClassType, S)::: structural type mapping visit class type:::outer->t->getEnclosingType->outer1->visit->typarams->t->getTypeArguments->typarams1->visit->if->return->else->return->new->ClassType
Type.StructuralTypeMapping#visitWildcardType(WildcardType, S)::: structural type mapping visit wildcard type:::t->if->visit->if->return->else->return->new->WildcardType
Type.StructuralTypeMapping#visitArrayType(ArrayType, S)::: structural type mapping visit array type:::elemtype->elemtype1->visit->if->return->else->return->new->ArrayType
Type.StructuralTypeMapping#visitMethodType(MethodType, S)::: structural type mapping visit method type:::argtypes->restype->thrown->argtypes1->visit->restype1->visit->thrown1->visit->if->return->else->return->new->MethodType
Type.StructuralTypeMapping#visitForAll(ForAll, S)::: structural type mapping visit for all:::return->visit
Type#map(TypeMapping, Z):::map a type function over all immediate descendants of this type:::return->mapping->visit
Type#map(TypeMapping):::map a type function over all immediate descendants of this type (no arg version):::return->mapping->visit
Type#constType(Object):::Define a constant type, of the same kind as this type  and with given constant value:::throw->new->AssertionError
Type#baseType():::If this is a constant type, return its underlying type:::return
Type#typeNoMetadata():::Returns the original version of this type, before metadata were added:::return->baseType
Type#cloneWithMetadata(TypeMetadata):::Create a new copy of this type but with the specified TypeMetadata.:::
Type#needsStripping():::Does this type require annotation stripping for API clients?:::return
Type#stripMetadataIfNeeded():::Strip all metadata associated with this type - this could return a new clone of the type:::return->needsStripping->accept
Type#stripMetadata()::: type strip metadata:::return->accept
Type#annotatedType(List)::: type annotated type:::annoMetadata->new->TypeMetadata.Annotations->return->metadata->combine->cloneWithMetadata
Type#isAnnotated()::: type is annotated:::metadata->getMetadataOfKind->return->metadata->getAnnotations->isEmpty
Type#getAnnotationMirrors()::: type get annotation mirrors:::metadata->getMetadataOfKind->return->List->nil->metadata->getAnnotations
Type#getAnnotation(Class)::: type get annotation:::return
Type#getAnnotationsByType(Class)::: type get annotations by type:::tmp->newInstance->return
Type#baseTypes(List):::Return the base types of a list of types.:::if->ts->nonEmpty->t->baseType->baseTypes->baseTypes->if->return->baseTypes->prepend->return
Type#appendAnnotationsString(StringBuilder, boolean)::: type append annotations string:::if->isAnnotated->if->sb->append->sb->getAnnotationMirrors->append->sb->append
Type#appendAnnotationsString(StringBuilder)::: type append annotations string:::appendAnnotationsString
Type#toString():::The Java source which this type represents.:::sb->new->StringBuilder->appendAnnotationsString->if->sb->append->else->sb->append->if->hasTag->sb->hashCode->append->return->sb->toString
Type#toString(List):::The Java source which this type list represents:::if->ts->isEmpty->return->else->buf->new->StringBuilder->buf->toString->append->for->l->l->nonEmpty->return->buf->toString
Type#stringValue():::The constant value of this type, converted to String:::cv->Assert->constValue->checkNonNull->return->cv->toString
Type#equals(Object):::Override this method with care:::return
Type#equalsIgnoreMetadata(Type)::: type equals ignore metadata:::return->typeNoMetadata->t->typeNoMetadata->equals
Type#hashCode()::: type hash code:::return->super->hashCode
Type#argtypes(boolean)::: type argtypes:::args->getParameterTypes->if->return->args->toString->buf->new->StringBuilder->while->nonEmpty->buf->append->buf->append->if->hasTag->buf->append->if->getAnnotationMirrors->nonEmpty->buf->getAnnotationMirrors->append->buf->append->else->buf->append->return->buf->toString
Type#getTypeArguments():::Access methods.:::return->List->nil
Type#getEnclosingType()::: type get enclosing type:::return
Type#getParameterTypes()::: type get parameter types:::return->List->nil
Type#getReturnType()::: type get return type:::return
Type#getReceiverType()::: type get receiver type:::return
Type#getThrownTypes()::: type get thrown types:::return->List->nil
Type#getUpperBound()::: type get upper bound:::return
Type#getLowerBound()::: type get lower bound:::return
Type#allparams():::Return all parameters of this type and all its outer types in order  outer (first) to inner (last).:::return->List->nil
Type#isErroneous():::Does this type contain "error" elements?:::return
Type#isErroneous(List)::: type is erroneous:::for->l->l->nonEmpty->return
Type#isParameterized():::Is this type parameterized?  A class type is parameterized if it has some parameters:::return
Type#isRaw():::Is this type a raw type?  A class type is a raw type if it misses some of its parameters:::return
Type#isCompound():::A compound type is a special class type whose supertypes are used to store a list of component types:::return
Type#isIntersection()::: type is intersection:::return
Type#isUnion()::: type is union:::return
Type#isInterface()::: type is interface:::return->tsym->flags
Type#isFinal()::: type is final:::return->tsym->flags
Type#contains(Type):::Does this type contain occurrences of type t?:::return->t->equalsIgnoreMetadata
Type#contains(List, Type)::: type contains:::for->l->return
Type#containsAny(List):::Does this type contain an occurrence of some type in 'ts'?:::foreach->if->this->contains->return->return
Type#containsAny(List, List)::: type contains any:::foreach->if->t->containsAny->return->return
Type#filter(List, Filter)::: type filter:::buf->new->ListBuffer<>->foreach->if->tf->accepts->buf->append->return->buf->toList
Type#isSuperBound()::: type is super bound:::return
Type#isExtendsBound()::: type is extends bound:::return
Type#isUnbound()::: type is unbound:::return
Type#withTypeVar(Type)::: type with type var:::return
Type#asMethodType():::The underlying method type of this type.:::throw->new->AssertionError
Type#complete():::Complete loading all classes in this type.:::
Type#asElement()::: type as element:::return
Type#getKind()::: type get kind:::return
Type#accept(TypeVisitor, P)::: type accept:::throw->new->AssertionError
Type.JCPrimitiveType#cloneWithMetadata(TypeMetadata)::: primitive type clone with metadata:::return->new->JCPrimitiveType
Type.JCPrimitiveType#isNumeric()::: primitive type is numeric:::return
Type.JCPrimitiveType#isIntegral()::: primitive type is integral:::switch->return->return
Type.JCPrimitiveType#isPrimitive()::: primitive type is primitive:::return
Type.JCPrimitiveType#getTag()::: primitive type get tag:::return
Type.JCPrimitiveType#isPrimitiveOrVoid()::: primitive type is primitive or void:::return
Type.JCPrimitiveType#constType(Object):::Define a constant type, of the same kind as this type  and with given constant value:::value->return->new->JCPrimitiveType
Type.JCPrimitiveType#stringValue():::The constant value of this type, converted to String:::cv->Assert->constValue->checkNonNull->if->return->intValue->else->if->return->String->intValue->valueOf->else->return->cv->toString
Type.JCPrimitiveType#isFalse():::Is this a constant type whose value is false?:::return->constValue->constValue->intValue
Type.JCPrimitiveType#isTrue():::Is this a constant type whose value is true?:::return->constValue->constValue->intValue
Type.JCPrimitiveType#accept(TypeVisitor, P)::: primitive type accept:::return->v->visitPrimitive
Type.JCPrimitiveType#getKind()::: primitive type get kind:::switch->return->return->return->return->return->return->return->return->throw->new->AssertionError
Type.WildcardType#accept(Type.Visitor, S)::: wildcard type accept:::return->v->visitWildcardType
Type.WildcardType#cloneWithMetadata(TypeMetadata)::: wildcard type clone with metadata:::return->new->WildcardType
Type.WildcardType#getTag()::: wildcard type get tag:::return
Type.WildcardType#contains(Type)::: wildcard type contains:::return->type->contains
Type.WildcardType#isSuperBound()::: wildcard type is super bound:::return
Type.WildcardType#isExtendsBound()::: wildcard type is extends bound:::return
Type.WildcardType#isUnbound()::: wildcard type is unbound:::return
Type.WildcardType#isReference()::: wildcard type is reference:::return
Type.WildcardType#isNullOrReference()::: wildcard type is null or reference:::return
Type.WildcardType#withTypeVar(Type)::: wildcard type with type var:::if->return->return
Type.WildcardType#toString()::: wildcard type to string:::s->new->StringBuilder->appendAnnotationsString->s->kind->toString->append->if->s->append->if->try->s->append->append->append->catch->finally->return->s->toString
Type.WildcardType#getExtendsBound()::: wildcard type get extends bound:::if->return->else->return
Type.WildcardType#getSuperBound()::: wildcard type get super bound:::if->return->else->return
Type.WildcardType#getKind()::: wildcard type get kind:::return
Type.WildcardType#accept(TypeVisitor, P)::: wildcard type accept:::return->v->visitWildcard
Type.ClassType#cloneWithMetadata(TypeMetadata)::: class type clone with metadata:::return->new->ClassType
Type.ClassType#getTag()::: class type get tag:::return
Type.ClassType#accept(Type.Visitor, S)::: class type accept:::return->v->visitClassType
Type.ClassType#constType(Object)::: class type const type:::value->return->getEnclosingType->new->ClassType
Type.ClassType#toString():::The Java source which this type represents.:::buf->new->StringBuilder->if->getEnclosingType->hasTag->buf->getEnclosingType->toString->append->buf->append->appendAnnotationsString->buf->className->append->else->appendAnnotationsString->buf->className->append->if->getTypeArguments->nonEmpty->buf->append->buf->getTypeArguments->toString->append->buf->append->return->buf->toString
Type.ClassType#className(Symbol, boolean)::: class type class name:::if->isEmpty->sym->flags->s->supertype_field->toString->new->StringBuilder->for->is->is->nonEmpty->return->s->toString->else->if->isEmpty->s->norm->if->Log->getLocalizedString->else->if->nonEmpty->Log->getLocalizedString->else->Log->getLocalizedString->if->String->sym->hashCode->valueOf->return->else->if->return->sym->getQualifiedName->toString->else->return->toString
Type.ClassType#getTypeArguments()::: class type get type arguments:::if->complete->if->List->nil->return
Type.ClassType#hasErasedSupertypes()::: class type has erased supertypes:::return->isRaw
Type.ClassType#getEnclosingType()::: class type get enclosing type:::return
Type.ClassType#setEnclosingType(Type)::: class type set enclosing type:::
Type.ClassType#allparams()::: class type allparams:::if->getTypeArguments->getEnclosingType->allparams->prependList->return
Type.ClassType#isErroneous()::: class type is erroneous:::return->getEnclosingType->isErroneous->getTypeArguments->isErroneous->isErroneous
Type.ClassType#isParameterized()::: class type is parameterized:::return->allparams
Type.ClassType#isReference()::: class type is reference:::return
Type.ClassType#isNullOrReference()::: class type is null or reference:::return
Type.ClassType#isRaw():::A class type is raw if it misses some  of its type parameter sections:::return->allparams->nonEmpty->allparams->isEmpty
Type.ClassType#contains(Type)::: class type contains:::return->elem->equalsIgnoreMetadata->isParameterized->getEnclosingType->contains->getTypeArguments->contains->isCompound->supertype_field->contains->contains
Type.ClassType#complete()::: class type complete:::tsym->complete
Type.ClassType#getKind()::: class type get kind:::tsym->apiComplete->return
Type.ClassType#accept(TypeVisitor, P)::: class type accept:::return->v->visitDeclared
Type.ErasedClassType#hasErasedSupertypes()::: erased class type has erased supertypes:::return
Type.UnionClassType#cloneWithMetadata(TypeMetadata)::: union class type clone with metadata:::throw->new->AssertionError
Type.UnionClassType#getLub()::: union class type get lub:::return
Type.UnionClassType#getAlternatives()::: union class type get alternatives:::return->Collections->unmodifiableList
Type.UnionClassType#isUnion()::: union class type is union:::return
Type.UnionClassType#isCompound()::: union class type is compound:::return->getLub->isCompound
Type.UnionClassType#getKind()::: union class type get kind:::return
Type.UnionClassType#accept(TypeVisitor, P)::: union class type accept:::return->v->visitUnion
Type.UnionClassType#getAlternativeTypes()::: union class type get alternative types:::return
Type.IntersectionClassType#cloneWithMetadata(TypeMetadata)::: intersection class type clone with metadata:::throw->new->AssertionError
Type.IntersectionClassType#getBounds()::: intersection class type get bounds:::return->Collections->getExplicitComponents->unmodifiableList
Type.IntersectionClassType#isCompound()::: intersection class type is compound:::return
Type.IntersectionClassType#getComponents()::: intersection class type get components:::return->interfaces_field->prepend
Type.IntersectionClassType#isIntersection()::: intersection class type is intersection:::return
Type.IntersectionClassType#getExplicitComponents()::: intersection class type get explicit components:::return->getComponents
Type.IntersectionClassType#getKind()::: intersection class type get kind:::return
Type.IntersectionClassType#accept(TypeVisitor, P)::: intersection class type accept:::return->v->visitIntersection
Type.ArrayType#cloneWithMetadata(TypeMetadata)::: array type clone with metadata:::return->new->ArrayType
Type.ArrayType#getTag()::: array type get tag:::return
Type.ArrayType#accept(Type.Visitor, S)::: array type accept:::return->v->visitArrayType
Type.ArrayType#toString()::: array type to string:::sb->new->StringBuilder->t->while->t->getKind->getComponentType->sb->append->do->t->appendAnnotationsString->sb->append->getComponentType->while->t->getKind->return->sb->toString
Type.ArrayType#equals(Object)::: array type equals:::if->that->return->elemtype->equals->return
Type.ArrayType#hashCode()::: array type hash code:::return->ARRAY->ordinal->elemtype->hashCode
Type.ArrayType#isVarargs()::: array type is varargs:::return
Type.ArrayType#allparams()::: array type allparams:::return->elemtype->allparams
Type.ArrayType#isErroneous()::: array type is erroneous:::return->elemtype->isErroneous
Type.ArrayType#isParameterized()::: array type is parameterized:::return->elemtype->isParameterized
Type.ArrayType#isReference()::: array type is reference:::return
Type.ArrayType#isNullOrReference()::: array type is null or reference:::return
Type.ArrayType#isRaw()::: array type is raw:::return->elemtype->isRaw
Type.ArrayType#makeVarargs()::: array type make varargs:::return->new->ArrayType
Type.ArrayType#contains(Type)::: array type contains:::return->elem->equalsIgnoreMetadata->elemtype->contains
Type.ArrayType#complete()::: array type complete:::elemtype->complete
Type.ArrayType#getComponentType()::: array type get component type:::return
Type.ArrayType#getKind()::: array type get kind:::return
Type.ArrayType#accept(TypeVisitor, P)::: array type accept:::return->v->visitArray
Type.MethodType#cloneWithMetadata(TypeMetadata)::: method type clone with metadata:::throw->new->AssertionError
Type.MethodType#getTag()::: method type get tag:::return
Type.MethodType#accept(Type.Visitor, S)::: method type accept:::return->v->visitMethodType
Type.MethodType#toString():::The Java source which this type represents:::sb->new->StringBuilder->appendAnnotationsString->sb->append->sb->append->sb->append->sb->append->return->sb->toString
Type.MethodType#getParameterTypes()::: method type get parameter types:::return
Type.MethodType#getReturnType()::: method type get return type:::return
Type.MethodType#getReceiverType()::: method type get receiver type:::return
Type.MethodType#getThrownTypes()::: method type get thrown types:::return
Type.MethodType#isErroneous()::: method type is erroneous:::return->isErroneous->restype->isErroneous
Type.MethodType#contains(Type)::: method type contains:::return->elem->equalsIgnoreMetadata->contains->restype->contains->contains
Type.MethodType#asMethodType()::: method type as method type:::return
Type.MethodType#complete()::: method type complete:::for->l->l->nonEmpty->restype->complete->recvtype->complete->for->l->l->nonEmpty
Type.MethodType#getTypeVariables()::: method type get type variables:::return->List->nil
Type.MethodType#asElement()::: method type as element:::return
Type.MethodType#getKind()::: method type get kind:::return
Type.MethodType#accept(TypeVisitor, P)::: method type accept:::return->v->visitExecutable
Type.PackageType#cloneWithMetadata(TypeMetadata)::: package type clone with metadata:::throw->new->AssertionError
Type.PackageType#getTag()::: package type get tag:::return
Type.PackageType#accept(Type.Visitor, S)::: package type accept:::return->v->visitPackageType
Type.PackageType#toString()::: package type to string:::return->tsym->getQualifiedName->toString
Type.PackageType#getKind()::: package type get kind:::return
Type.PackageType#accept(TypeVisitor, P)::: package type accept:::return->v->visitNoType
Type.ModuleType#cloneWithMetadata(TypeMetadata)::: module type clone with metadata:::throw->new->AssertionError
Type.ModuleType#annotatedType(List)::: module type annotated type:::throw->new->AssertionError
Type.ModuleType#getTag()::: module type get tag:::return
Type.ModuleType#accept(Type.Visitor, S)::: module type accept:::return->v->visitModuleType
Type.ModuleType#toString()::: module type to string:::return->tsym->getQualifiedName->toString
Type.ModuleType#getKind()::: module type get kind:::return
Type.ModuleType#accept(TypeVisitor, P)::: module type accept:::return->v->visitNoType
Type.TypeVar#cloneWithMetadata(TypeMetadata)::: type var clone with metadata:::return->new->TypeVar
Type.TypeVar#getTag()::: type var get tag:::return
Type.TypeVar#accept(Type.Visitor, S)::: type var accept:::return->v->visitTypeVar
Type.TypeVar#getUpperBound()::: type var get upper bound:::if->bound->hasTag->getUpperBound->return
Type.TypeVar#getLowerBound()::: type var get lower bound:::return
Type.TypeVar#getKind()::: type var get kind:::return
Type.TypeVar#isCaptured()::: type var is captured:::return
Type.TypeVar#isReference()::: type var is reference:::return
Type.TypeVar#isNullOrReference()::: type var is null or reference:::return
Type.TypeVar#accept(TypeVisitor, P)::: type var accept:::return->v->visitTypeVariable
Type.CapturedType#cloneWithMetadata(TypeMetadata)::: captured type clone with metadata:::return->new->CapturedType
Type.CapturedType#accept(Type.Visitor, S)::: captured type accept:::return->v->visitCapturedType
Type.CapturedType#isCaptured()::: captured type is captured:::return
Type.CapturedType#toString()::: captured type to string:::sb->new->StringBuilder->appendAnnotationsString->sb->append->sb->hashCode->append->sb->append->sb->append->return->sb->toString
Type.DelegatedType#getTag()::: delegated type get tag:::return
Type.DelegatedType#toString()::: delegated type to string:::return->qtype->toString
Type.DelegatedType#getTypeArguments()::: delegated type get type arguments:::return->qtype->getTypeArguments
Type.DelegatedType#getEnclosingType()::: delegated type get enclosing type:::return->qtype->getEnclosingType
Type.DelegatedType#getParameterTypes()::: delegated type get parameter types:::return->qtype->getParameterTypes
Type.DelegatedType#getReturnType()::: delegated type get return type:::return->qtype->getReturnType
Type.DelegatedType#getReceiverType()::: delegated type get receiver type:::return->qtype->getReceiverType
Type.DelegatedType#getThrownTypes()::: delegated type get thrown types:::return->qtype->getThrownTypes
Type.DelegatedType#allparams()::: delegated type allparams:::return->qtype->allparams
Type.DelegatedType#getUpperBound()::: delegated type get upper bound:::return->qtype->getUpperBound
Type.DelegatedType#isErroneous()::: delegated type is erroneous:::return->qtype->isErroneous
Type.ForAll#cloneWithMetadata(TypeMetadata)::: for all clone with metadata:::throw->new->AssertionError
Type.ForAll#accept(Type.Visitor, S)::: for all accept:::return->v->visitForAll
Type.ForAll#toString()::: for all to string:::sb->new->StringBuilder->appendAnnotationsString->sb->append->sb->append->sb->append->sb->append->return->sb->toString
Type.ForAll#getTypeArguments()::: for all get type arguments:::return
Type.ForAll#isErroneous()::: for all is erroneous:::return->qtype->isErroneous
Type.ForAll#contains(Type)::: for all contains:::return->qtype->contains
Type.ForAll#asMethodType()::: for all as method type:::return
Type.ForAll#complete()::: for all complete:::for->l->l->nonEmpty->qtype->complete
Type.ForAll#getTypeVariables()::: for all get type variables:::return->List->getTypeArguments->convert
Type.ForAll#getKind()::: for all get kind:::return
Type.ForAll#accept(TypeVisitor, P)::: for all accept:::return->v->visitExecutable
Type.UndetVar.UndetVarListener#varBoundChanged(UndetVar, InferenceBound, Type, boolean):::called when some inference variable bounds (of given kinds ibs) change:::
Type.UndetVar.UndetVarListener#varInstantiated(UndetVar):::called when the inferred type is set on some inference variable:::Assert->error
Type.UndetVar#accept(Type.Visitor, S)::: undet var accept:::return->v->visitUndetVar
Type.UndetVar#toString()::: undet var to string:::sb->new->StringBuilder->appendAnnotationsString->if->sb->append->sb->append->else->sb->append->return->sb->toString
Type.UndetVar#debugString()::: undet var debug string:::result->if->foreach->InferenceBound->values->aboundList->bounds->get->if->aboundList->size->return
Type.UndetVar#setThrow()::: undet var set throw:::if->throw->new->IllegalStateException
Type.UndetVar#dup(Types):::Returns a new copy of this undet var.:::uv2->new->UndetVar->dupTo->return
Type.UndetVar#dupTo(UndetVar, Types):::Dumps the contents of this undet var on another undet var.:::clear->foreach->InferenceBound->values->List->nil->put->foreach->getBounds->uv2->addBound->new->ArrayDeque<>->foreach->action->dup->add
Type.UndetVar#cloneWithMetadata(TypeMetadata)::: undet var clone with metadata:::throw->new->AssertionError
Type.UndetVar#isPartial()::: undet var is partial:::return
Type.UndetVar#baseType()::: undet var base type:::return->inst->baseType
Type.UndetVar#getInst()::: undet var get inst:::return
Type.UndetVar#setInst(Type)::: undet var set inst:::if->listener->varInstantiated
Type.UndetVar#getBounds(InferenceBound...):::get all bounds of a given kind:::buf->new->ListBuffer<>->foreach->buf->bounds->get->appendList->return->buf->toList
Type.UndetVar#getDeclaredBounds():::get the list of declared (upper) bounds:::buf->new->ListBuffer<>->count->foreach->getBounds->if->break->buf->append->return->buf->toList
Type.UndetVar#setBounds(InferenceBound, List):::internal method used to override an undetvar bounds:::bounds->put
Type.UndetVar#addBound(InferenceBound, Type, Types):::add a bound of a given kind - this might trigger listener notification:::if->switch->types->cvarUpperBound->break->altBound->types->cvarLowerBound->if->altBound->hasTag->break->addBound
Type.UndetVar#addBound(InferenceBound, Type, Types, boolean)::: undet var add bound:::if->if->bound->hasTag->isCaptured->ib->complement->addBound->else->bound2->bound->map->baseType->prevBounds->bounds->get->if->return->foreach->if->types->isSameType->return->bounds->prevBounds->prepend->put->notifyBoundChange
Type.UndetVar#substBounds(List, List, Types):::replace types in all bounds - this might trigger listener notification:::boundsChanged->new->ListBuffer<>->prevListener->try->Assert->check->boundsChanged->new->Pair<>->add->foreach->bounds->entrySet->ib->_entry->getKey->prevBounds->_entry->getValue->newBounds->new->ListBuffer<>->deps->new->ListBuffer<>->foreach->if->t->containsAny->newBounds->append->else->deps->append->bounds->newBounds->toList->put->foreach->types->subst->addBound->catch->finally->foreach->notifyBoundChange
Type.UndetVar#notifyBoundChange(InferenceBound, Type, boolean)::: undet var notify bound change:::if->listener->varBoundChanged
Type.UndetVar#isCaptured()::: undet var is captured:::return
Type.UndetVar#isThrows()::: undet var is throws:::return
Type.JCNoType#cloneWithMetadata(TypeMetadata)::: no type clone with metadata:::throw->new->AssertionError
Type.JCNoType#getTag()::: no type get tag:::return
Type.JCNoType#getKind()::: no type get kind:::return
Type.JCNoType#accept(TypeVisitor, P)::: no type accept:::return->v->visitNoType
Type.JCNoType#isCompound()::: no type is compound:::return
Type.JCVoidType#cloneWithMetadata(TypeMetadata)::: void type clone with metadata:::throw->new->AssertionError
Type.JCVoidType#getTag()::: void type get tag:::return
Type.JCVoidType#getKind()::: void type get kind:::return
Type.JCVoidType#isCompound()::: void type is compound:::return
Type.JCVoidType#accept(TypeVisitor, P)::: void type accept:::return->v->visitNoType
Type.JCVoidType#isPrimitiveOrVoid()::: void type is primitive or void:::return
Type.BottomType#cloneWithMetadata(TypeMetadata)::: bottom type clone with metadata:::throw->new->AssertionError
Type.BottomType#getTag()::: bottom type get tag:::return
Type.BottomType#getKind()::: bottom type get kind:::return
Type.BottomType#isCompound()::: bottom type is compound:::return
Type.BottomType#accept(TypeVisitor, P)::: bottom type accept:::return->v->visitNull
Type.BottomType#constType(Object)::: bottom type const type:::return
Type.BottomType#stringValue()::: bottom type string value:::return
Type.BottomType#isNullOrReference()::: bottom type is null or reference:::return
Type.ErrorType#cloneWithMetadata(TypeMetadata)::: error type clone with metadata:::return->new->ErrorType
Type.ErrorType#getTag()::: error type get tag:::return
Type.ErrorType#isPartial()::: error type is partial:::return
Type.ErrorType#isReference()::: error type is reference:::return
Type.ErrorType#isNullOrReference()::: error type is null or reference:::return
Type.ErrorType#accept(Type.Visitor, S)::: error type accept:::return->v->visitErrorType
Type.ErrorType#constType(Object)::: error type const type:::return
Type.ErrorType#getEnclosingType()::: error type get enclosing type:::return
Type.ErrorType#getReturnType()::: error type get return type:::return
Type.ErrorType#asSub(Symbol)::: error type as sub:::return
Type.ErrorType#isGenType(Type)::: error type is gen type:::return
Type.ErrorType#isErroneous()::: error type is erroneous:::return
Type.ErrorType#isCompound()::: error type is compound:::return
Type.ErrorType#isInterface()::: error type is interface:::return
Type.ErrorType#allparams()::: error type allparams:::return->List->nil
Type.ErrorType#getTypeArguments()::: error type get type arguments:::return->List->nil
Type.ErrorType#getKind()::: error type get kind:::return
Type.ErrorType#getOriginalType()::: error type get original type:::return
Type.ErrorType#accept(TypeVisitor, P)::: error type accept:::return->v->visitError
Type.UnknownType#cloneWithMetadata(TypeMetadata)::: unknown type clone with metadata:::throw->new->AssertionError
Type.UnknownType#getTag()::: unknown type get tag:::return
Type.UnknownType#accept(TypeVisitor, P)::: unknown type accept:::return->v->visitUnknown
Type.UnknownType#isPartial()::: unknown type is partial:::return
Type.Visitor#visitClassType(ClassType, S)::: visitor visit class type:::
Type.Visitor#visitWildcardType(WildcardType, S)::: visitor visit wildcard type:::
Type.Visitor#visitArrayType(ArrayType, S)::: visitor visit array type:::
Type.Visitor#visitMethodType(MethodType, S)::: visitor visit method type:::
Type.Visitor#visitPackageType(PackageType, S)::: visitor visit package type:::
Type.Visitor#visitModuleType(ModuleType, S)::: visitor visit module type:::
Type.Visitor#visitTypeVar(TypeVar, S)::: visitor visit type var:::
Type.Visitor#visitCapturedType(CapturedType, S)::: visitor visit captured type:::
Type.Visitor#visitForAll(ForAll, S)::: visitor visit for all:::
Type.Visitor#visitUndetVar(UndetVar, S)::: visitor visit undet var:::
Type.Visitor#visitErrorType(ErrorType, S)::: visitor visit error type:::
Type.Visitor#visitType(Type, S)::: visitor visit type:::
TypeAnnotationPosition.TypePathEntry#fromBinary(int, int)::: type path entry from binary:::Assert->check->switch->return->return->return->return->new->TypePathEntry->Assert->error->return
TypeAnnotationPosition.TypePathEntry#toString()::: type path entry to string:::return->tag->toString
TypeAnnotationPosition.TypePathEntry#equals(Object)::: type path entry equals:::if->return->tpe->return
TypeAnnotationPosition.TypePathEntry#hashCode()::: type path entry hash code:::return->hashCode
TypeAnnotationPosition#toString()::: type annotation position to string:::sb->new->StringBuilder->sb->append->sb->append->switch->sb->append->sb->append->break->if->sb->append->break->sb->append->for->i->sb->append->break->break->sb->append->sb->append->break->sb->append->sb->append->sb->append->sb->append->break->sb->append->sb->append->break->sb->append->sb->append->break->sb->append->sb->append->break->sb->append->sb->append->break->sb->append->sb->append->sb->append->sb->append->break->break->sb->append->break->Assert->error->if->location->isEmpty->sb->append->sb->append->sb->append->sb->append->sb->append->if->sb->append->sb->onLambda->hashCode->append->sb->append->return->sb->toString
TypeAnnotationPosition#emitToClassfile():::Indicates whether the target tree of the annotation has been optimized away from classfile or not.:::return->type->isLocal
TypeAnnotationPosition#matchesPos(int)::: type annotation position matches pos:::return
TypeAnnotationPosition#updatePosOffset(int)::: type annotation position update pos offset:::new->intArr
TypeAnnotationPosition#hasExceptionIndex()::: type annotation position has exception index:::return
TypeAnnotationPosition#getExceptionIndex()::: type annotation position get exception index:::Assert->check->return
TypeAnnotationPosition#setExceptionIndex(int)::: type annotation position set exception index:::Assert->hasExceptionIndex->check->Assert->check
TypeAnnotationPosition#hasCatchType()::: type annotation position has catch type:::return
TypeAnnotationPosition#getCatchType()::: type annotation position get catch type:::Assert->hasCatchType->check->return
TypeAnnotationPosition#getStartPos()::: type annotation position get start pos:::Assert->hasCatchType->check->return
TypeAnnotationPosition#setCatchInfo(int, int)::: type annotation position set catch info:::Assert->hasExceptionIndex->check->Assert->check
TypeAnnotationPosition#getTypePathFromBinary(java.util.List):::Decode the binary representation for a type path and set the location field.:::loc->new->ListBuffer<>->iter->list->iterator->while->iter->hasNext->fst->iter->next->Assert->iter->hasNext->check->snd->iter->next->loc->TypePathEntry->fromBinary->append->return->loc->toList
TypeAnnotationPosition#getBinaryFromTypePath(java.util.List)::: type annotation position get binary from type path:::loc->new->ListBuffer<>->foreach->loc->append->loc->append->return->loc->toList
TypeAnnotationPosition#methodReturn(List, JCLambda, int):::Create a TypeAnnotationPosition for a method return.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodReturn(List):::Create a TypeAnnotationPosition for a method return.:::return->methodReturn
TypeAnnotationPosition#methodReturn(int):::Create a TypeAnnotationPosition for a method return.:::return->methodReturn
TypeAnnotationPosition#methodReceiver(List, JCLambda, int):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodReceiver(List):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->methodReceiver
TypeAnnotationPosition#methodReceiver(int):::Create a TypeAnnotationPosition for a method receiver parameter.:::return->methodReceiver
TypeAnnotationPosition#methodParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodParameter(JCLambda, int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodParameter(int, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodParameter(List, int):::Create a TypeAnnotationPosition for a method formal parameter.:::return->methodParameter
TypeAnnotationPosition#methodRef(List, JCLambda, int):::Create a TypeAnnotationPosition for a method reference.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodRef(List):::Create a TypeAnnotationPosition for a method reference.:::return->methodRef
TypeAnnotationPosition#constructorRef(List, JCLambda, int):::Create a TypeAnnotationPosition for a constructor reference.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorRef(List):::Create a TypeAnnotationPosition for a constructor reference.:::return->constructorRef
TypeAnnotationPosition#field(List, JCLambda, int):::Create a TypeAnnotationPosition for a field.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#field(List):::Create a TypeAnnotationPosition for a field.:::return->field
TypeAnnotationPosition#field(int):::Create a TypeAnnotationPosition for a field.:::return->field
TypeAnnotationPosition#localVariable(List, JCLambda, int):::Create a TypeAnnotationPosition for a local variable.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#localVariable(JCLambda, int):::Create a TypeAnnotationPosition for a local variable.:::return->localVariable
TypeAnnotationPosition#localVariable(List):::Create a TypeAnnotationPosition for a local variable.:::return->localVariable
TypeAnnotationPosition#exceptionParameter(List, JCLambda, int):::Create a TypeAnnotationPosition for an exception parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#exceptionParameter(JCLambda, int):::Create a TypeAnnotationPosition for an exception parameter.:::return->exceptionParameter
TypeAnnotationPosition#exceptionParameter(List):::Create a TypeAnnotationPosition for an exception parameter.:::return->exceptionParameter
TypeAnnotationPosition#resourceVariable(List, JCLambda, int):::Create a TypeAnnotationPosition for a resource variable.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#resourceVariable(JCLambda, int):::Create a TypeAnnotationPosition for a resource variable.:::return->resourceVariable
TypeAnnotationPosition#resourceVariable(List):::Create a TypeAnnotationPosition for a resource variable.:::return->resourceVariable
TypeAnnotationPosition#newObj(List, JCLambda, int):::Create a TypeAnnotationPosition for a new.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#newObj(int):::Create a TypeAnnotationPosition for a new.:::return->newObj
TypeAnnotationPosition#newObj(List):::Create a TypeAnnotationPosition for a new.:::return->newObj
TypeAnnotationPosition#classExtends(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a class extension.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#classExtends(List, JCLambda, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(List, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(int, int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#classExtends(int):::Create a TypeAnnotationPosition for a class extension.:::return->classExtends
TypeAnnotationPosition#instanceOf(List, JCLambda, int):::Create a TypeAnnotationPosition for an instanceof.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#instanceOf(List):::Create a TypeAnnotationPosition for an instanceof.:::return->instanceOf
TypeAnnotationPosition#typeCast(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a type cast.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeCast(List, int):::Create a TypeAnnotationPosition for a type cast.:::return->typeCast
TypeAnnotationPosition#methodInvocationTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method invocation type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodInvocationTypeArg(List, int):::Create a TypeAnnotationPosition for a method invocation type argument.:::return->methodInvocationTypeArg
TypeAnnotationPosition#constructorInvocationTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a constructor invocation type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorInvocationTypeArg(List, int):::Create a TypeAnnotationPosition for a constructor invocation type argument.:::return->constructorInvocationTypeArg
TypeAnnotationPosition#typeParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a type parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeParameter(List, int):::Create a TypeAnnotationPosition for a type parameter.:::return->typeParameter
TypeAnnotationPosition#methodTypeParameter(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method type parameter.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodTypeParameter(List, int):::Create a TypeAnnotationPosition for a method type parameter.:::return->methodTypeParameter
TypeAnnotationPosition#methodThrows(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a throws clause.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodThrows(List, int):::Create a TypeAnnotationPosition for a throws clause.:::return->methodThrows
TypeAnnotationPosition#methodRefTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a method reference type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodRefTypeArg(List, int):::Create a TypeAnnotationPosition for a method reference type argument.:::return->methodRefTypeArg
TypeAnnotationPosition#constructorRefTypeArg(List, JCLambda, int, int):::Create a TypeAnnotationPosition for a constructor reference type argument.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#constructorRefTypeArg(List, int):::Create a TypeAnnotationPosition for a constructor reference type argument.:::return->constructorRefTypeArg
TypeAnnotationPosition#typeParameterBound(List, JCLambda, int, int, int):::Create a TypeAnnotationPosition for a type parameter bound.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#typeParameterBound(List, int, int):::Create a TypeAnnotationPosition for a type parameter bound.:::return->typeParameterBound
TypeAnnotationPosition#methodTypeParameterBound(List, JCLambda, int, int, int):::Create a TypeAnnotationPosition for a method type parameter bound.:::return->new->TypeAnnotationPosition
TypeAnnotationPosition#methodTypeParameterBound(List, int, int):::Create a TypeAnnotationPosition for a method type parameter bound.:::return->methodTypeParameterBound
TypeAnnotations#instance(Context)::: type annotations instance:::instance->context->get->if->new->TypeAnnotations->return
TypeAnnotations#organizeTypeAnnotationsSignatures(Env, JCClassDecl):::Separate type annotations from declaration annotations and determine the correct positions for type annotations:::annotate->oldSource->log->useSource->try->new->TypeAnnotationPositions->scan->catch->finally->log->useSource->afterTypes
TypeAnnotations#validateTypeAnnotationsSignatures(Env, JCClassDecl)::: type annotations validate type annotations signatures:::annotate->oldSource->log->useSource->try->attr->validateTypeAnnotations->catch->finally->log->useSource->validate
TypeAnnotations#organizeTypeAnnotationsBodies(JCClassDecl):::This version only visits types in bodies, that is, field initializers, top-level blocks, and method bodies, and should be called from Attr.:::new->TypeAnnotationPositions->scan
TypeAnnotations#annotationTargets(TypeSymbol)::: type annotations annotation targets:::atTarget->tsym->getAnnotationTypeMetadata->getTarget->if->return->atValue->atTarget->member->if->return->targets->getValue->if->targets->stream->anyMatch->return->return
TypeAnnotations#annotationTargetType(Attribute.Compound, Symbol):::Determine whether an annotation is a declaration annotation, a type annotation, or both.:::targets->annotationTargets->return->targets->stream->targetToAnnotationType->map->this->combineAnnotationType->reduce
TypeAnnotations#combineAnnotationType(AnnotationType, AnnotationType)::: type annotations combine annotation type:::if->return->else->if->return->else->if->return->else->return
TypeAnnotations#targetToAnnotationType(Attribute, Symbol)::: type annotations target to annotation type:::e->if->if->return->else->if->if->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->isConstructor->return->else->if->if->s->flags->return->else->if->if->s->flags->return->else->if->if->return->else->if->if->s->isConstructor->getReturnType->hasTag->s->isConstructor->return->else->if->else->if->if->return->else->Assert->getClass->error->return->return
TypeAnnotations.TypeAnnotationPositions#push(JCTree)::: type annotation positions push:::frames->prepend
TypeAnnotations.TypeAnnotationPositions#pop()::: type annotation positions pop:::t->return
TypeAnnotations.TypeAnnotationPositions#peek2()::: type annotation positions peek2:::return
TypeAnnotations.TypeAnnotationPositions#scan(JCTree)::: type annotation positions scan:::push->try->super->scan->catch->finally->pop
TypeAnnotations.TypeAnnotationPositions#separateAnnotationsKinds(JCTree, Type, Symbol, TypeAnnotationPosition):::Separates type annotations from declaration annotations:::allAnnotations->sym->getRawAttributes->declAnnos->new->ListBuffer<>->typeAnnos->new->ListBuffer<>->onlyTypeAnnos->new->ListBuffer<>->foreach->switch->annotationTargetType->declAnnos->append->break->declAnnos->append->ta->toTypeCompound->typeAnnos->append->break->ta->toTypeCompound->typeAnnos->append->onlyTypeAnnos->append->break->if->typeAnnos->isEmpty->return->sym->resetAnnotations->sym->declAnnos->toList->setDeclarationAttributes->typeAnnotations->typeAnnos->toList->if->sym->getEnclosingElement->asType->typeWithAnnotations->sym->appendUniqueTypeAttributes->return->onlyTypeAnnos->toList->typeWithAnnotations->if->sym->getKind->asMethodType->else->if->sym->getKind->if->sym->getQualifiedName->equals->asMethodType->else->methType->asMethodType->params->oldArgs->newArgs->new->ListBuffer<>->while->params->nonEmpty->if->newArgs->add->else->newArgs->add->newArgs->toList->else->sym->appendUniqueTypeAttributes->if->sym->getKind->sym->getKind->sym->getKind->sym->getKind->ownerFlags->flags->if->cs->if->cs->appendClassInitTypeAttributes->else->cs->appendInitTypeAttributes->else->sym->getRawTypeAttributes->appendUniqueTypeAttributes
TypeAnnotations.TypeAnnotationPositions#typeWithAnnotations(JCTree, Type, List, List, TypeAnnotationPosition)::: type annotation positions type with annotations:::if->annotations->isEmpty->return->if->type->hasTag->return->rewriteArrayType->if->type->hasTag->return->type->annotatedType->else->if->type->getKind->tutree->fst->get->res->typeWithAnnotations->return->else->enclTy->enclEl->type->asElement->enclTr->while->enclEl->getKind->enclTy->getKind->enclTy->getKind->enclTr->getKind->enclTr->getKind->enclTr->getKind->if->enclTr->getKind->enclTy->getEnclosingType->enclEl->getEnclosingElement->getExpression->else->if->enclTr->getKind->getType->else->getUnderlyingType->if->enclTy->hasTag->switch->onlyTypeAnnotations->size->break->log->typetree->pos->Errors->CantTypeAnnotateScoping1->error->break->log->typetree->pos->Errors->CantTypeAnnotateScoping->error->return->depth->new->ListBuffer<>->topTy->while->enclEl->getKind->topTy->getKind->topTy->getKind->topTy->getEnclosingType->enclEl->getEnclosingElement->if->topTy->getKind->depth->append->if->depth->nonEmpty->a->annotations->get->p->depth->toList->appendList->ret->typeWithAnnotations->return
TypeAnnotations.TypeAnnotationPositions#rewriteArrayType(ArrayType, List, TypeAnnotationPosition):::Create a copy of the Type type with the help of the Tree for a type JCTree typetree inserting all type annotations in annotations to the innermost array component type:::tomodify->new->ArrayType->res->loc->List->nil->tmpType->loc->prepend->while->tmpType->hasTag->arr->tmp->new->ArrayType->loc->prepend->elemType->if->tmpType->getMetadata->tcs->if->tmpType->getAnnotationMirrors->isEmpty->else->annotations->tmpType->getAnnotationMirrors->appendList->tmpType->tmpType->getMetadata->without->new->TypeMetadata.Annotations->combine->cloneWithMetadata->else->tmpType->new->TypeMetadata.Annotations->new->TypeMetadata->cloneWithMetadata->foreach->if->return
TypeAnnotations.TypeAnnotationPositions#typeWithAnnotations(Type, Type, List):::Return a copy of the first type that only differs by inserting the annotations to the left-most/inner-most type or the type given by stopAt:::visitor->new->Type.Visitor<Type,List<Attribute.TypeCompound>>->return->type->accept
TypeAnnotations.TypeAnnotationPositions#toTypeCompound(Attribute.Compound, TypeAnnotationPosition)::: type annotation positions to type compound:::return->new->Attribute.TypeCompound
TypeAnnotations.TypeAnnotationPositions#resolveFrame(JCTree, JCTree, List, JCLambda, int, ListBuffer)::: type annotation positions resolve frame:::switch->frame->getKind->return->TypeAnnotationPosition->location->toList->typeCast->return->TypeAnnotationPosition->location->toList->instanceOf->frameNewClass->if->frameClassDecl->if->contains->type_index->indexOf->return->TypeAnnotationPosition->location->toList->classExtends->else->return->TypeAnnotationPosition->location->toList->classExtends->else->if->contains->type_index->indexOf->return->TypeAnnotationPosition->location->toList->constructorInvocationTypeArg->else->return->TypeAnnotationPosition->location->toList->newObj->return->TypeAnnotationPosition->location->toList->newObj->if->return->TypeAnnotationPosition->location->toList->classExtends->else->if->contains->type_index->indexOf->return->TypeAnnotationPosition->location->toList->classExtends->else->if->contains->parameter_index->indexOf->return->TypeAnnotationPosition->location->toList->typeParameter->else->throw->new->AssertionError->frameMethod->if->contains->type_index->indexOf->return->TypeAnnotationPosition->location->toList->methodThrows->else->if->return->TypeAnnotationPosition->location->toList->methodReturn->else->if->contains->parameter_index->indexOf->return->TypeAnnotationPosition->location->toList->methodTypeParameter->else->throw->new->AssertionError->newPath->if->else->if->contains->taframe->arg->indexOf->location->new->TypePathEntry->prepend->typeToUse->if->hasTag->else->locateNestedTypes->else->throw->new->AssertionError->return->resolveFrame->mrframe->if->switch->return->TypeAnnotationPosition->location->toList->methodRef->return->TypeAnnotationPosition->location->toList->constructorRef->throw->new->AssertionError->else->if->contains->type_index->indexOf->switch->return->TypeAnnotationPosition->location->toList->methodRefTypeArg->return->TypeAnnotationPosition->location->toList->constructorRefTypeArg->throw->new->AssertionError->else->throw->new->AssertionError->location->prepend->newPath->while->npHead->if->npHead->hasTag->location->prepend->else->if->npHead->hasTag->else->break->return->resolveFrame->if->hasTag->clazz->parameter_index->indexOf->bound_index->get->isInterface->indexOf->indexOf->return->TypeAnnotationPosition->location->toList->typeParameterBound->else->if->hasTag->method->parameter_index->indexOf->bound_index->get->isInterface->indexOf->indexOf->return->TypeAnnotationPosition->location->toList->methodTypeParameterBound->else->throw->new->AssertionError->v->if->v->getKind->v->getRawTypeAttributes->appendUniqueTypeAttributes->switch->v->getKind->return->TypeAnnotationPosition->location->toList->localVariable->return->TypeAnnotationPosition->location->toList->field->if->v->getQualifiedName->equals->return->TypeAnnotationPosition->location->toList->methodReceiver->else->parameter_index->methodParamIndex->return->TypeAnnotationPosition->location->toList->methodParameter->return->TypeAnnotationPosition->location->toList->exceptionParameter->return->TypeAnnotationPosition->location->toList->resourceVariable->throw->v->getKind->new->AssertionError->if->atypetree->utype->Assert->checkNonNull->tsym->if->tsym->getKind->equals->utype->getKind->equals->utype->getKind->equals->else->locateNestedTypes->newPath->return->resolveFrame->newPath->return->resolveFrame->isect->newPath->return->indexOf->resolveFrame->invocation->if->contains->return->exsym->TreeInfo->invocation->getMethodSelect->symbol->type_index->indexOf->if->throw->new->AssertionError->else->if->exsym->isConstructor->return->TypeAnnotationPosition->location->toList->constructorInvocationTypeArg->else->return->TypeAnnotationPosition->location->toList->methodInvocationTypeArg->newPath->return->location->prepend->resolveFrame->newPath->return->resolveFrame->throw->frame->getKind->new->AssertionError
TypeAnnotations.TypeAnnotationPositions#locateNestedTypes(Type, ListBuffer)::: type annotation positions locate nested types:::encl->type->getEnclosingType->while->encl->getKind->encl->getKind->depth->prepend->encl->getEnclosingType->return
TypeAnnotations.TypeAnnotationPositions#methodParamIndex(List, JCTree)::: type annotation positions method param index:::curr->while->getTag->getTag->if->getTag->method->return->indexOf->else->if->getTag->lambda->return->indexOf->else->Assert->error->return
TypeAnnotations.TypeAnnotationPositions#visitClassDef(JCClassDecl)::: type annotation positions visit class def:::if->return->if->scan->scan->scan->scan->scan
TypeAnnotations.TypeAnnotationPositions#visitMethodDef(JCMethodDecl):::Resolve declaration vs:::if->Assert->error->if->if->isEmpty->if->isConstructor->pos->TypeAnnotationPosition->methodReturn->separateAnnotationsKinds->else->pos->TypeAnnotationPosition->methodReturn->getReturnType->separateAnnotationsKinds->if->isEmpty->pos->TypeAnnotationPosition->methodReceiver->push->try->separateAnnotationsKinds->catch->finally->pop->i->foreach->if->isEmpty->pos->TypeAnnotationPosition->methodParameter->push->try->separateAnnotationsKinds->catch->finally->pop->if->scan->scan->scan->scan->scan->scan->else->scan->scan
TypeAnnotations.TypeAnnotationPositions#visitLambda(JCLambda)::: type annotation positions visit lambda:::prevLambda->try->i->foreach->if->isEmpty->pos->TypeAnnotationPosition->methodParameter->push->try->separateAnnotationsKinds->catch->finally->pop->scan->scan->catch->finally
TypeAnnotations.TypeAnnotationPositions#visitVarDef(JCVariableDecl):::Resolve declaration vs:::if->isEmpty->else->if->Assert->error->else->if->getKind->else->if->getKind->if->pos->TypeAnnotationPosition->field->separateAnnotationsKinds->else->if->getKind->pos->TypeAnnotationPosition->localVariable->if->tree->isImplicitlyTyped->separateAnnotationsKinds->else->if->getKind->pos->TypeAnnotationPosition->exceptionParameter->separateAnnotationsKinds->else->if->getKind->pos->TypeAnnotationPosition->resourceVariable->separateAnnotationsKinds->else->if->getKind->else->Assert->error->scan->scan->if->scan
TypeAnnotations.TypeAnnotationPositions#visitBlock(JCBlock)::: type annotation positions visit block:::if->scan
TypeAnnotations.TypeAnnotationPositions#visitAnnotatedType(JCAnnotatedType)::: type annotation positions visit annotated type:::push->findPosition->pop->super->visitAnnotatedType
TypeAnnotations.TypeAnnotationPositions#visitTypeParameter(JCTypeParameter)::: type annotation positions visit type parameter:::peek2->findPosition->super->visitTypeParameter
TypeAnnotations.TypeAnnotationPositions#copyNewClassAnnotationsToOwner(JCNewClass)::: type annotation positions copy new class annotations to owner:::sym->pos->TypeAnnotationPosition->newObj->newattrs->new->ListBuffer<>->foreach->sym->getRawTypeAttributes->newattrs->new->Attribute.TypeCompound->append->newattrs->toList->appendUniqueTypeAttributes
TypeAnnotations.TypeAnnotationPositions#visitNewClass(JCNewClass)::: type annotation positions visit new class:::if->isEmpty->classdecl->pos->if->TypeAnnotationPosition->classExtends->else->if->contains->index->indexOf->TypeAnnotationPosition->classExtends->else->throw->new->AssertionError->before->separateAnnotationsKinds->copyNewClassAnnotationsToOwner->scan->scan->if->scan->scan
TypeAnnotations.TypeAnnotationPositions#visitNewArray(JCNewArray)::: type annotation positions visit new array:::findPosition->dimAnnosCount->size->depth->new->ListBuffer<>->for->i->elemType->depth->append->while->if->elemType->hasTag->at->locationbuf->new->ListBuffer<TypePathEntry>->locateNestedTypes->location->locationbuf->toList->depth->toList->prependList->p->TypeAnnotationPosition->newObj->setTypeAnnotationPos->else->if->elemType->hasTag->depth->append->else->if->elemType->hasTag->else->break->scan
TypeAnnotations.TypeAnnotationPositions#findTypeCompoundPosition(JCTree, JCTree, List)::: type annotation positions find type compound position:::if->annotations->isEmpty->p->new->ListBuffer<>->resolveFrame->foreach
TypeAnnotations.TypeAnnotationPositions#findPosition(JCTree, JCTree, List)::: type annotation positions find position:::if->annotations->isEmpty->p->new->ListBuffer<>->resolveFrame->setTypeAnnotationPos
TypeAnnotations.TypeAnnotationPositions#setTypeAnnotationPos(List, TypeAnnotationPosition)::: type annotation positions set type annotation pos:::foreach->if
TypeAnnotations.TypeAnnotationPositions#toString()::: type annotation positions to string:::return->super->toString
TypeMetadata#combine(Entry):::Return a copy of this TypeMetadata with the metadata entry for elem.kind() combined with elem.:::Assert->checkNonNull->out->new->TypeMetadata->key->elem->kind->if->contents->containsKey->out->get->combine->add->else->out->add->return
TypeMetadata#combineAll(TypeMetadata):::Return a copy of this TypeMetadata with the metadata entry for all kinds from other combined with the same kind from this.:::Assert->checkNonNull->out->new->TypeMetadata->keys->contents->keySet->new->HashSet<>->keys->keySet->addAll->foreach->if->contents->containsKey->if->containsKey->out->contents->get->get->combine->add->else->out->contents->get->add->else->if->containsKey->out->get->add->return
TypeMetadata#without(Entry.Kind):::Return a TypeMetadata with the metadata entry for kind removed:::if->contents->get->return->out->new->TypeMetadata->remove->return->isEmpty
TypeMetadata#get(Entry.Kind)::: type metadata get:::return->contents->get
TypeMetadata#add(Entry.Kind, Entry)::: type metadata add:::contents->put
TypeMetadata.Entry#kind():::Get the kind of metadata this object represents:::
TypeMetadata.Entry#combine(Entry):::Combine this type metadata with another metadata of the same kind.:::
TypeMetadata.Annotations#getAnnotations():::Get the type annotations contained in this metadata.:::return
TypeMetadata.Annotations#combine(Entry)::: annotations combine:::Assert->check->return
TypeMetadata.Annotations#kind()::: annotations kind:::return
TypeMetadata.Annotations#toString()::: annotations to string:::return
Types#instance(Context)::: types instance:::instance->context->get->if->new->Types->return
Types#wildUpperBound(Type):::Get a wildcard's upper bound, returning non-wildcards unchanged.:::if->t->hasTag->w->if->w->isSuperBound->return->else->return->wildUpperBound->else->return
Types#cvarUpperBound(Type):::Get a capture variable's upper bound, returning other types unchanged.:::if->t->hasTag->v->return->v->isCaptured->cvarUpperBound->else->return
Types#wildLowerBound(Type):::Get a wildcard's lower bound, returning non-wildcards unchanged.:::if->t->hasTag->w->return->w->isExtendsBound->wildLowerBound->else->return
Types#cvarLowerBound(Type):::Get a capture variable's lower bound, returning other types unchanged.:::if->t->hasTag->isCaptured->return->t->getLowerBound->cvarLowerBound->else->return
Types#skipTypeVars(Type, boolean):::Recursively skip type-variables until a class/array type is found; capture conversion is then (optionally) applied to the resulting type:::while->site->hasTag->site->getUpperBound->return->capture
Types.TypeProjection#visitClassType(ClassType, ProjectionKind)::: type projection visit class type:::if->t->isCompound->components->directSupertypes->components1->components->c->map->map->if->return->else->return->makeIntersectionType->else->outer->t->getEnclosingType->outer1->visit->typarams->t->getTypeArguments->formals->getTypeArguments->typarams1->new->ListBuffer<>->changed->foreach->t2->getUpperBound->mapTypeArgument->if->t2->hasTag->return->typarams1->add->if->return->else->return->typarams1->toList->t->getMetadata->new->ClassType
Types.TypeProjection#visitArrayType(ArrayType, ProjectionKind)::: type projection visit array type:::elemtype->elemtype1->visit->if->return->else->if->elemtype1->hasTag->return->else->return->new->ArrayType
Types.TypeProjection#visitTypeVar(TypeVar, ProjectionKind)::: type projection visit type var:::if->vars->contains->if->seen->add->try->bound->switch->t->getUpperBound->break->t->getLowerBound->t->getLowerBound->break->Assert->error->return->return->bound->map->catch->finally->seen->remove->else->return->else->return
Types.TypeProjection#mapTypeArgument(Type, Type, Type, ProjectionKind)::: type projection map type argument:::return->t->containsAny->t->new->TypeArgumentProjection->map
Types.TypeProjection.TypeArgumentProjection#visitType(Type, ProjectionKind)::: type argument projection visit type:::if->return->upper->t->map->lower->t->map->formals->getTypeArguments->bk->bound->if->isSameType->declaredBound->containsAny->isSubtype->else->if->lower->hasTag->else->return->makeWildcard
Types.TypeProjection.TypeArgumentProjection#visitWildcardType(WildcardType, ProjectionKind)::: type argument projection visit wildcard type:::bound->bk->switch->map->if->bound->hasTag->return->break->pkind->complement->map->if->bound->hasTag->break->return->makeWildcard
Types.TypeProjection.TypeArgumentProjection#makeWildcard(Type, BoundKind)::: type argument projection make wildcard:::return->new->WildcardType
Types#upward(Type, List):::Computes an upward projection of given type, and vars:::return->t->new->TypeProjection->map
Types#captures(Type):::Computes the set of captured variables mentioned in a given type:::cs->new->CaptureScanner->captures->new->HashSet<>->cs->visit->return->List->from
Types.CaptureScanner#visitType(Type, Set)::: capture scanner visit type:::return
Types.CaptureScanner#visitClassType(ClassType, Set)::: capture scanner visit class type:::if->t->isCompound->directSupertypes->visit->forEach->else->t->allparams->visit->forEach->return
Types.CaptureScanner#visitArrayType(ArrayType, Set)::: capture scanner visit array type:::return->visit
Types.CaptureScanner#visitWildcardType(WildcardType, Set)::: capture scanner visit wildcard type:::visit->return
Types.CaptureScanner#visitTypeVar(TypeVar, Set)::: capture scanner visit type var:::if->flags->seen->add->t->getUpperBound->visit->return
Types.CaptureScanner#visitCapturedType(CapturedType, Set)::: capture scanner visit captured type:::if->seen->add->t->getUpperBound->visit->t->getLowerBound->visit->return
Types#isUnbounded(Type):::Checks that all the arguments to a class are unbounded wildcards or something else that doesn't make any restrictions on the arguments:::return->isUnbounded->visit
Types#asSub(Type, Symbol):::Return the least specific subtype of t that starts with symbol sym:::return->asSub->visit
Types#isConvertible(Type, Type, Warner):::Is t a subtype of or convertible via boxing/unboxing conversion to s?:::if->t->hasTag->return->tPrimitive->t->isPrimitive->sPrimitive->s->isPrimitive->if->return->isSubtypeUnchecked->tUndet->t->hasTag->sUndet->s->hasTag->if->return->boxedTypeOrType->isSubtype->boxedTypeOrType->isSubtype->return->boxedClass->isSubtype->unboxedType->isSubtype
Types#isConvertible(Type, Type):::Is t a subtype of or convertible via boxing/unboxing conversions to s?:::return->isConvertible
Types.FunctionDescriptorLookupError#setMessage(JCDiagnostic)::: function descriptor lookup error set message:::return
Types.FunctionDescriptorLookupError#getDiagnostic()::: function descriptor lookup error get diagnostic:::return
Types.DescriptorCache.FunctionDescriptor#getSymbol()::: function descriptor get symbol:::return
Types.DescriptorCache.FunctionDescriptor#getType(Type)::: function descriptor get type:::removeWildcards->if->site->isIntersection->ict->foreach->ict->getExplicitComponents->if->chk->checkValidGenericType->throw->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->failure->else->if->chk->checkValidGenericType->throw->diags->Fragments->NoSuitableFunctionalIntfInst->fragment->failure->return->memberType
Types.DescriptorCache.Entry#matches(int)::: entry matches:::return
Types.DescriptorCache#get(TypeSymbol)::: descriptor cache get:::e->_map->get->members->membersClosure->if->e->members->getMark->matches->descRes->findDescriptorInternal->_map->members->getMark->new->Entry->put->return->else->return
Types.DescriptorCache#findDescriptorInternal(TypeSymbol, CompoundScope):::Compute the function descriptor associated with a given functional interface:::if->origin->isInterface->origin->flags->throw->failure->abstracts->new->ListBuffer<>->foreach->membersCache->new->DescriptorFilter->getSymbols->mtype->memberType->if->abstracts->isEmpty->abstracts->append->else->if->abstracts->first->abstracts->first->memberType->overrideEquivalent->if->abstracts->stream->sym->enclClass->isSubClass->filter->memberType->map->isSubSignature->anyMatch->abstracts->append->else->throw->diags->Fragments->Kinds->kindName->IncompatibleAbstracts->fragment->failure->if->abstracts->isEmpty->throw->diags->Fragments->Kinds->kindName->NoAbstracts->fragment->failure->else->if->abstracts->size->return->abstracts->first->new->FunctionDescriptor->else->descRes->abstracts->toList->mergeDescriptors->if->descriptors->new->ListBuffer<>->foreach->key->getThrownTypes->nonEmpty->descriptors->diags->getParameterTypes->getReturnType->getThrownTypes->fragment->append->msg->diags->Fragments->Kinds->kindName->IncompatibleDescsInFunctionalIntf->fragment->incompatibleDescriptors->descriptors->toList->new->JCDiagnostic.MultilineDiagnostic->throw->failure->return
Types.DescriptorCache#mergeDescriptors(TypeSymbol, List):::Compute a synthetic type for the target descriptor given a list of override-equivalent methods in the functional interface type:::return->mergeAbstracts->bestSoFar->baseSymbol->new->FunctionDescriptor->map->orElse
Types.DescriptorCache#failure(String, Object...)::: descriptor cache failure:::return->diags->fragment->failure
Types.DescriptorCache#failure(JCDiagnostic)::: descriptor cache failure:::return->new->FunctionDescriptorLookupError->setMessage
Types#findDescriptorSymbol(TypeSymbol):::Find the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.:::return->descCache->get->getSymbol
Types#findDescriptorType(Type):::Find the type of the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.:::return->descCache->get->getType
Types#isFunctionalInterface(TypeSymbol):::Is given type a functional interface?:::try->findDescriptorSymbol->return->catch->return->finally
Types#isFunctionalInterface(Type)::: types is functional interface:::try->findDescriptorType->return->catch->return->finally
Types#removeWildcards(Type)::: types remove wildcards:::if->site->getTypeArguments->stream->t->hasTag->anyMatch->actuals->site->getTypeArguments->formals->getTypeArguments->targs->new->ListBuffer<>->foreach->actual->bound->formal->getUpperBound->if->hasTag->wt->if->bound->containsAny->targs->add->else->switch->targs->add->break->targs->glb->add->break->targs->add->break->Assert->error->else->targs->add->return->targs->toList->subst->else->return
Types#makeFunctionalInterfaceClass(Env, Name, Type, long):::Create a symbol for a class that implements a given functional interface and overrides its functional descriptor:::if->return->descSym->findDescriptorSymbol->descType->findDescriptorType->csym->outermostClass->new->ClassSymbol->WriteableScope->create->instDescSym->descSym->flags->new->MethodSymbol->enter->ctype->List->nil->new->Type.ClassType->target->isIntersection->directSupertypes->List->of->return
Types#functionalInterfaceBridges(TypeSymbol):::Find the minimal set of methods that are overridden by the functional descriptor in 'origin':::Assert->isFunctionalInterface->check->descSym->findDescriptorSymbol->members->membersClosure->overridden->new->ListBuffer<>->foreach->members->getSymbolsByName->if->continue->else->if->descSym->overrides->foreach->if->m3->erasure->m2->erasure->isSameType->m3->overrides->m3->enclClass->pendingBridges->binaryImplementation->continue->overridden->add->return->overridden->toList
Types#pendingBridges(ClassSymbol, TypeSymbol)::: types pending bridges:::if->getKind->enter->getEnv->return->if->return->foreach->interfaces->if->pendingBridges->return->return
Types.DescriptorFilter#accepts(Symbol)::: descriptor filter accepts:::return->sym->flags->overridesObjectMethod->interfaceCandidates->flags
Types#isSubtypeUnchecked(Type, Type):::Is t an unchecked subtype of s?:::return->isSubtypeUnchecked
Types#isSubtypeUnchecked(Type, Type, Warner):::Is t an unchecked subtype of s?:::result->isSubtypeUncheckedInternal->if->checkUnsafeVarargsConversion->return
Types#isSubtypeUncheckedInternal(Type, Type, boolean, Warner)::: types is subtype unchecked internal:::if->t->hasTag->s->hasTag->if->isPrimitive->return->elemtype->elemtype->isSameType->else->return->elemtype->elemtype->isSubtypeUncheckedInternal->else->if->isSubtype->return->else->if->t->hasTag->return->t->getUpperBound->isSubtypeUncheckedInternal->else->if->s->isRaw->t2->asSuper->if->t2->isRaw->if->isReifiable->warn->silentWarn->else->warn->warn->return->return
Types#checkUnsafeVarargsConversion(Type, Type, Warner)::: types check unsafe varargs conversion:::if->t->hasTag->isReifiable->return->from->shouldWarn->switch->s->getTag->to->from->isVarargs->to->isVarargs->isReifiable->break->from->isVarargs->break->if->warn->warn
Types#isSubtype(Type, Type):::Is t a subtype of s?<br> (not defined for Method and ForAll types):::return->isSubtype
Types#isSubtypeNoCapture(Type, Type)::: types is subtype no capture:::return->isSubtype
Types#isSubtype(Type, Type, boolean)::: types is subtype:::if->t->equalsIgnoreMetadata->return->if->s->isPartial->return->isSuperType->if->s->isCompound->foreach->interfaces->supertype->prepend->if->isSubtype->return->return->if->t->hasTag->t->isCompound->lower->wildLowerBound->cvarLowerBound->if->lower->hasTag->return->capture->isSubtype->return->isSubtype->capture->visit
Types#isSubtypeUnchecked(Type, List, Warner):::Is t a subtype of every type in given list `ts'?<br> (not defined for Method and ForAll types)<br> Allows unchecked conversions.:::for->l->l->nonEmpty->return
Types#isSubtypes(List, List):::Are corresponding elements of ts subtypes of ss?  If lists are of different length, return false.:::while->isSubtype->return
Types#isSubtypesUnchecked(List, List, Warner):::Are corresponding elements of ts subtypes of ss, allowing unchecked conversions?  If lists are of different length, return false.:::while->isSubtypeUnchecked->return
Types#isSuperType(Type, Type):::Is t a supertype of s?:::switch->t->getTag->return->undet->if->s->hasTag->s->hasTag->return->undet->addBound->return->return->isSubtype
Types#isSameTypes(List, List):::Are corresponding elements of the lists the same type?  If lists are of different length, return false.:::while->isSameType->return
Types#isSignaturePolymorphic(MethodSymbol):::A polymorphic signature method (JLS 15.12.3) is a method that   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;  (ii) takes a single variable arity parameter; (iii) whose declared type is Object[];  (iv) has any return type, Object signifying a polymorphic return type; and   (v) is native.:::argtypes->getParameterTypes->return->argtypes->length->hasTag
Types#isSameType(Type, Type):::Is t the same type as s?:::return->isSameTypeVisitor->visit
Types#containedBy(Type, Type)::: types contained by:::switch->t->getTag->if->s->hasTag->undetvar->wt->switch->break->bound->wildUpperBound->undetvar->addBound->break->bound->wildLowerBound->undetvar->addBound->break->return->else->return->isSameType->return->return->containsType
Types#containsType(List, List)::: types contains type:::while->ts->nonEmpty->ss->nonEmpty->containsType->return->ts->isEmpty->ss->isEmpty
Types#containsType(Type, Type):::Check if t contains s:::return->containsType->visit
Types#isCaptureOf(Type, WildcardType)::: types is capture of:::if->s->hasTag->isCaptured->return->return->isSameWildcard
Types#isSameWildcard(WildcardType, Type)::: types is same wildcard:::if->s->hasTag->return->w->return
Types#containsTypeEquivalent(List, List)::: types contains type equivalent:::while->ts->nonEmpty->ss->nonEmpty->containsTypeEquivalent->return->ts->isEmpty->ss->isEmpty
Types#isCastable(Type, Type)::: types is castable:::return->isCastable
Types#isCastable(Type, Type, Warner):::Is t is castable to s?<br> s is assumed to be an erased type.<br> (not defined for Method and ForAll types).:::if->return->if->t->isPrimitive->s->isPrimitive->skipTypeVars->return->isConvertible->s->isPrimitive->boxedClass->isSubtype->if->try->warnStack->prepend->checkUnsafeVarargsConversion->return->isCastable->visit->catch->finally->else->return->isCastable->visit
Types#disjointTypes(List, List)::: types disjoint types:::while->if->disjointType->return->return
Types#disjointType(Type, Type):::Two types or wildcards are considered disjoint if it can be proven that no type can be contained in both:::return->disjointType->visit
Types#cvarLowerBounds(List)::: types cvar lower bounds:::return->ts->map
Types#notSoftSubtype(Type, Type):::This relation answers the question: is impossible that something of type `t' can be a subtype of `s'? This is different from the question "is `t' not a subtype of `s'?" when type variables are involved: Integer is not a subtype of T where <T extends Number> but it is not true that Integer cannot possibly be a subtype of T.:::if->return->if->t->hasTag->tv->return->relaxBound->isCastable->if->s->hasTag->cvarUpperBound->return->relaxBound->isSubtype
Types#relaxBound(Type)::: types relax bound:::return->t->hasTag->skipTypeVars->rewriteQuantifiers
Types#isReifiable(Type)::: types is reifiable:::return->isReifiable->visit
Types#isArray(Type)::: types is array:::while->t->hasTag->wildUpperBound->return->t->hasTag
Types#elemtype(Type):::The element type of an array.:::switch->t->getTag->return->wildUpperBound->elemtype->return->return->elemtype->return->return
Types#elemtypeOrType(Type)::: types elemtype or type:::elemtype->elemtype->return
Types#dimensions(Type):::The number of dimensions of an array type.:::result->while->t->hasTag->elemtype->return
Types#makeArrayType(Type):::Returns an ArrayType with the component type t:::if->t->hasTag->t->hasTag->Assert->t->toString->error->return->new->ArrayType
Types#asSuper(Type, Symbol):::Return the (most specific) base type of t that starts with the given symbol:::if->return->return->asSuper->visit
Types#asOuterSuper(Type, Symbol):::Return the base type of t or any of its outer types that starts with the given symbol:::switch->t->getTag->do->s->asSuper->if->return->t->getEnclosingType->while->t->hasTag->return->return->isSubtype->return->asSuper->return->return
Types#asEnclosingSuper(Type, Symbol):::Return the base type of t or any of its enclosing types that starts with the given symbol:::switch->t->getTag->do->s->asSuper->if->return->outer->t->getEnclosingType->outer->hasTag->enclClass->enclClass->while->t->hasTag->return->return->isSubtype->return->asSuper->return->return
Types#memberType(Type, Symbol):::The type of given symbol, seen as a member of t.:::return->sym->flags->memberType->visit
Types#isAssignable(Type, Type)::: types is assignable:::return->isAssignable
Types#isAssignable(Type, Type, Warner):::Is t assignable to s?<br> Equivalent to subtype except for constant values and raw types.<br> (not defined for Method and ForAll types):::if->t->hasTag->return->if->t->getTag->isSubRangeOf->t->constValue->value->t->constValue->intValue->switch->s->getTag->if->s->getTag->checkRange->return->break->switch->unboxedType->getTag->return->unboxedType->isAssignable->break->return->isConvertible
Types#erasure(Type):::The erasure of t |t| -- the type that results when all type parameters in t are deleted.:::return->eraseNotNeeded->erasure
Types#eraseNotNeeded(Type)::: types erase not needed:::return->t->isPrimitive
Types#erasure(Type, boolean)::: types erasure:::if->t->isPrimitive->return->else->out->erasure->visit->return
Types#erasure(List)::: types erasure:::return->erasure->visit
Types#erasureRecursive(Type)::: types erasure recursive:::return->erasure
Types#erasureRecursive(List)::: types erasure recursive:::return->erasure->visit
Types#makeIntersectionType(List):::Make an intersection type from non-empty list of types:::return->isInterface->makeIntersectionType
Types#makeIntersectionType(List, boolean):::Make an intersection type from non-empty list of types:::Assert->bounds->nonEmpty->check->firstExplicitBound->if->bounds->prepend->bc->names->bounds->toString->fromString->new->ClassSymbol->intersectionType->new->IntersectionClassType->hasTag->erasure->WriteableScope->create->return
Types#supertype(Type)::: types supertype:::return->supertype->visit
Types#interfaces(Type):::Return the interfaces implemented by this class.:::return->interfaces->visit
Types#directSupertypes(Type)::: types direct supertypes:::return->directSupertypes->visit
Types#isDirectSuperInterface(TypeSymbol, TypeSymbol)::: types is direct super interface:::foreach->interfaces->if->return->return
Types#isDerivedRaw(Type)::: types is derived raw:::result->isDerivedRawCache->get->if->isDerivedRawInternal->isDerivedRawCache->put->return
Types#isDerivedRawInternal(Type)::: types is derived raw internal:::if->t->isErroneous->return->return->t->isRaw->supertype->supertype->isDerivedRaw->interfaces->isDerivedRaw
Types#isDerivedRaw(List)::: types is derived raw:::l->while->l->nonEmpty->isDerivedRaw->return->l->nonEmpty
Types#setBounds(TypeVar, List):::Same as Types#setBounds(TypeVar, List, boolean), except that third parameter is computed directly, as follows: if all all bounds are interface types, the computed supertype is Object,otherwise the supertype is simply left null (in this case, the supertype is assumed to be the head of the bound list passed as second argument):::isInterface->setBounds
Types#setBounds(TypeVar, List, boolean):::Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds:::isEmpty->makeIntersectionType
Types#getBounds(TypeVar):::Return list of bounds of the given type variable.:::if->hasTag->return->List->nil->else->if->isErroneous->isCompound->return->List->of->else->if->erasure->flags->return->interfaces->supertype->prepend->else->return->interfaces
Types#classBound(Type):::If the given type is a (possibly selected) type variable, return the bounding class of this type, otherwise return the type itself.:::return->classBound->visit
Types#isSubSignature(Type, Type):::Returns true iff the first signature is a sub signature of the other:::return->isSubSignature
Types#isSubSignature(Type, Type, boolean)::: types is sub signature:::return->hasSameArgs->erasure->hasSameArgs
Types#overrideEquivalent(Type, Type):::Returns true iff these signatures are related by override equivalence:::return->hasSameArgs->erasure->hasSameArgs->erasure->hasSameArgs
Types#overridesObjectMethod(TypeSymbol, Symbol)::: types overrides object method:::foreach->members->getSymbolsByName->if->msym->overrides->return->return
Types#mergeAbstracts(List, Type, boolean):::Merge multiple abstract methods:::shouldErase->erasedParams->erasure->getParameterTypes->foreach->if->s->flags->s->erasure->getParameterTypes->isSameTypes->return->Optional->empty->else->if->hasTag->foreach->MostSpecificReturnCheck->values->foreach->mt->memberType->allThrown->mt->getThrownTypes->foreach->if->mt2->memberType->if->isSubSignature->mostSpecificReturnCheck->test->continue->else->thrownTypes2->mt2->getThrownTypes->if->mt->hasTag->erasure->else->if->mt->hasTag->Assert->mt2->hasTag->check->mt2->getTypeArguments->mt->getTypeArguments->subst->chk->intersect->return->mt->getThrownTypes->Optional->of->Optional->s->flags->createMethodTypeWithThrown->new->MethodSymbol->of->return->Optional->empty
Types.ImplementationCache.Entry#matches(Filter, boolean, int)::: entry matches:::return
Types.ImplementationCache#get(MethodSymbol, TypeSymbol, boolean, Filter)::: implementation cache get:::ref_cache->_map->get->cache->ref_cache->get->if->new->HashMap<>->_map->new->SoftReference<>->put->e->cache->get->members->membersClosure->if->e->members->getMark->matches->impl->implementationInternal->cache->members->getMark->new->Entry->put->return->else->return
Types.ImplementationCache#implementationInternal(MethodSymbol, TypeSymbol, boolean, Filter)::: implementation cache implementation internal:::for->t->t->hasTag->t->hasTag->supertype->return
Types#implementation(MethodSymbol, TypeSymbol, boolean, Filter)::: types implementation:::return->implCache->get
Types.MembersClosureCache.MembersScope#combine(Filter)::: members scope combine:::return->isInterface->sf->accepts
Types.MembersClosureCache.MembersScope#getSymbols(Filter, LookupKind)::: members scope get symbols:::return->scope->combine->getSymbols
Types.MembersClosureCache.MembersScope#getSymbolsByName(Name, Filter, LookupKind)::: members scope get symbols by name:::return->scope->combine->getSymbolsByName
Types.MembersClosureCache.MembersScope#getMark()::: members scope get mark:::return->scope->getMark
Types.MembersClosureCache#visitType(Type, Void)::: members closure cache visit type:::if->new->CompoundScope->return
Types.MembersClosureCache#visitClassType(ClassType, Void)::: members closure cache visit class type:::if->seenTypes->add->return->new->CompoundScope->try->seenTypes->add->csym->membersClosure->_map->get->if->new->CompoundScope->foreach->interfaces->membersClosure->visit->prependSubScope->membersClosure->supertype->visit->prependSubScope->membersClosure->csym->members->prependSubScope->_map->put->return->catch->finally->seenTypes->remove
Types.MembersClosureCache#visitTypeVar(TypeVar, Void)::: members closure cache visit type var:::return->t->getUpperBound->visit
Types#membersClosure(Type, boolean)::: types members closure:::cs->membersCache->visit->Assert->checkNonNull->return->membersCache->new->MembersScope
Types#firstUnimplementedAbstract(ClassSymbol):::Return first abstract member of class `sym'.:::try->return->firstUnimplementedAbstractImpl->catch->chk->enter->getEnv->pos->completionError->return->finally
Types#firstUnimplementedAbstractImpl(ClassSymbol, ClassSymbol)::: types first unimplemented abstract impl:::undef->if->c->flags->s->c->members->foreach->s->getSymbols->if->sym->flags->absmeth->implmeth->absmeth->implementation->if->if->prov->interfaceCandidates->if->prov->overrides->if->break->if->st->supertype->if->st->hasTag->firstUnimplementedAbstractImpl->for->l->interfaces->l->nonEmpty->return
Types.CandidatesCache.Entry#equals(Object)::: entry equals:::if->e->return->isSameType->else->return
Types.CandidatesCache.Entry#hashCode()::: entry hash code:::return->Types.this->hashCode->msym->hashCode
Types.CandidatesCache#get(Entry)::: candidates cache get:::return->cache->get
Types.CandidatesCache#put(Entry, List)::: candidates cache put:::cache->put
Types#interfaceCandidates(Type, MethodSymbol)::: types interface candidates:::e->candidatesCache->new->Entry->candidates->candidatesCache->get->if->filter->new->MethodFilter->candidates2->List->nil->foreach->membersClosure->getSymbols->if->isInterface->isInterface->return->List->of->else->if->candidates2->contains->candidates2->prepend->prune->candidatesCache->put->return
Types#prune(List)::: types prune:::methodsMin->new->ListBuffer<>->foreach->isMin_m1->foreach->if->continue->if->asSuper->break->if->methodsMin->append->return->methodsMin->toList
Types.MethodFilter#accepts(Symbol)::: method filter accepts:::return->s->flags->s->isInheritedIn->memberType->memberType->overrideEquivalent
Types#hasSameArgs(Type, Type):::Does t have the same arguments as s?  It is assumed that both types are (possibly polymorphic) method types:::return->hasSameArgs
Types#hasSameArgs(Type, Type, boolean)::: types has same args:::return->hasSameArgs
Types#hasSameArgs(Type, Type, TypeRelation)::: types has same args:::return->hasSameArgs->visit
Types.HasSameArgs#visitType(Type, Type)::: has same args visit type:::throw->new->AssertionError
Types.HasSameArgs#visitMethodType(MethodType, Type)::: has same args visit method type:::return->s->hasTag->s->getParameterTypes->containsTypeEquivalent
Types.HasSameArgs#visitForAll(ForAll, Type)::: has same args visit for all:::if->s->hasTag->return->t->asMethodType->visitMethodType->forAll->return->hasSameBounds->subst->visit
Types.HasSameArgs#visitErrorType(ErrorType, Type)::: has same args visit error type:::return
Types#subst(List, List, List)::: types subst:::return->ts->new->Subst->map
Types#subst(Type, List, List):::Substitute all occurrences of a type in `from' with the corresponding type in `to' in 't':::return->t->new->Subst->map
Types.Subst#visitTypeVar(TypeVar, Void)::: subst visit type var:::for->from->to->from->nonEmpty->return
Types.Subst#visitClassType(ClassType, Void)::: subst visit class type:::if->t->isCompound->return->super->visitClassType->else->st->supertype->visit->is->interfaces->visit->if->supertype->interfaces->return->else->return->is->prepend->makeIntersectionType
Types.Subst#visitWildcardType(WildcardType, Void)::: subst visit wildcard type:::t2->super->visitWildcardType->if->t->isExtendsBound->isExtendsBound->wildUpperBound->return
Types.Subst#visitForAll(ForAll, Void)::: subst visit for all:::if->Type->containsAny->freevars->newInstances->Types.this->subst->new->ForAll->tvars1->substBounds->qtype1->visit->if->return->else->if->return->new->ForAll->else->return->Types.this->subst->new->ForAll
Types#substBounds(List, List, List)::: types subst bounds:::if->tvars->isEmpty->return->newBoundsBuf->new->ListBuffer<>->changed->foreach->tv->bound->subst->if->newBoundsBuf->append->if->return->newTvars->new->ListBuffer<>->foreach->newTvars->t->getMetadata->new->TypeVar->append->newBounds->newBoundsBuf->toList->newTvars->toList->for->newBounds->isEmpty->newBoundsBuf->toList->foreach->newTvars->toList->tv->return->newTvars->toList
Types#substBound(TypeVar, List, List)::: types subst bound:::bound1->subst->if->return->else->tv->t->getMetadata->new->TypeVar->List->of->List->of->subst->return
Types#hasSameBounds(ForAll, ForAll):::Does t have the same bounds for quantified variables as s?:::l1->l2->while->l1->nonEmpty->l2->nonEmpty->getUpperBound->getUpperBound->subst->isSameType->return->l1->isEmpty->l2->isEmpty
Types#newInstances(List):::Create new vector of type variables from list of variables  changing all recursive bounds from old to new list.:::tvars1->tvars->map->for->l->l->nonEmpty->return
Types#createMethodTypeWithParameters(Type, List)::: types create method type with parameters:::return->original->accept
Types#createMethodTypeWithThrown(Type, List)::: types create method type with thrown:::return->original->accept
Types#createMethodTypeWithReturn(Type, Type)::: types create method type with return:::return->original->accept
Types#createErrorType(Type)::: types create error type:::return->new->ErrorType
Types#createErrorType(ClassSymbol, Type)::: types create error type:::return->new->ErrorType
Types#createErrorType(Name, TypeSymbol, Type)::: types create error type:::return->new->ErrorType
Types#rank(Type):::The rank of a class is the length of the longest path between the class and java.lang.Object in the class inheritance graph:::switch->t->getTag->cls->if->fullname->getQualifiedName->if->else->r->supertype->rank->for->l->interfaces->l->nonEmpty->return->tvar->if->r->supertype->rank->for->l->interfaces->l->nonEmpty->return->return->throw->new->AssertionError
Types#toString(Type, Locale):::Helper method for generating a string representation of a given type accordingly to a given locale:::return->Printer->createStandardPrinter->visit
Types#toString(Symbol, Locale):::Helper method for generating a string representation of a given type accordingly to a given locale:::return->Printer->createStandardPrinter->visit
Types#toString(Type):::This toString is slightly more descriptive than the one on Type.:::if->t->hasTag->forAll->return->typaramsString->return
Types#typaramsString(List)::: types typarams string:::s->new->StringBuilder->s->append->first->foreach->if->s->append->appendTyparamString->s->append->return->s->toString
Types#appendTyparamString(TypeVar, StringBuilder)::: types append typaram string:::buf->append->if->getQualifiedName->return->buf->append->bound->if->bound->isCompound->buf->append->else->if->erasure->flags->buf->supertype->append->foreach->interfaces->buf->append->buf->append->else->first->foreach->interfaces->if->buf->append->buf->append
Types#closure(Type):::Returns the closure of a class or interface type.:::cl->closureCache->get->if->st->supertype->if->t->isCompound->if->st->hasTag->closure->insert->else->if->st->hasTag->closure->prepend->else->List->of->else->supertype->closure->for->l->interfaces->l->nonEmpty->closureCache->put->return
Types#closureCollector(boolean, BiPredicate):::Collect types into a new closure (using a @code{ClosureHolder}):::return->Collector->new->ClosureHolder->ClosureHolder->add->ClosureHolder->merge->ClosureHolder->closure->of
Types.ClosureHolder#add(Type)::: closure holder add:::insert
Types.ClosureHolder#merge(ClosureHolder)::: closure holder merge:::union->return
Types.ClosureHolder#closure()::: closure holder closure:::return->closureMin
Types#insert(List, Type, BiPredicate):::Insert a type in a closure:::if->cl->isEmpty->return->cl->prepend->else->if->shouldSkip->test->return->else->if->precedes->return->cl->prepend->else->return->insert->prepend
Types#insert(List, Type)::: types insert:::return->insert
Types#union(List, List, BiPredicate):::Form the union of two closures:::if->cl1->isEmpty->return->else->if->cl2->isEmpty->return->else->if->shouldSkip->test->return->union->prepend->else->if->precedes->return->union->prepend->else->if->precedes->return->union->prepend->else->return->union->prepend
Types#union(List, List)::: types union:::return->union
Types#intersect(List, List):::Intersect two closures:::if->return->if->cl1->isEmpty->cl2->isEmpty->return->List->nil->if->precedes->return->intersect->if->precedes->return->intersect->if->isSameType->return->intersect->prepend->if->hasTag->hasTag->if->isParameterized->isParameterized->merge->merge->return->intersect->prepend->if->isRaw->isRaw->return->intersect->erasure->prepend->return->intersect
Types.TypePair#hashCode()::: type pair hash code:::return->Types.this->hashCode->Types.this->hashCode
Types.TypePair#equals(Object)::: type pair equals:::if->return->typePair->return->isSameType->isSameType
Types#merge(Type, Type)::: types merge:::class1->act1->class1->getTypeArguments->class2->act2->class2->getTypeArguments->merged->new->ListBuffer<>->typarams->getTypeArguments->while->act1->nonEmpty->act2->nonEmpty->typarams->nonEmpty->if->containsType->merged->append->else->if->containsType->merged->append->else->pair->new->TypePair->m->if->mergeCache->add->wildUpperBound->wildUpperBound->lub->new->WildcardType->mergeCache->remove->else->new->WildcardType->merged->m->withTypeVar->append->Assert->act1->isEmpty->act2->isEmpty->typarams->isEmpty->check->return->class1->getEnclosingType->merged->toList->new->ClassType
Types#compoundMin(List):::Return the minimum type of a closure, a compound type if no unique minimum exists.:::if->cl->isEmpty->return->compound->closureMin->if->compound->isEmpty->return->else->if->isEmpty->return->else->return->makeIntersectionType
Types#closureMin(List):::Return the minimum types of a closure, suitable for computing compoundMin or glb.:::classes->new->ListBuffer<>->interfaces->new->ListBuffer<>->toSkip->new->HashSet<>->while->cl->isEmpty->current->keep->toSkip->contains->if->current->hasTag->foreach->if->isSubtypeNoCapture->break->if->if->current->isInterface->interfaces->append->else->classes->append->foreach->if->isSubtypeNoCapture->toSkip->add->return->classes->appendList->toList
Types#lub(List):::Return the least upper bound of list of types:::return->ts->ts->length->new->TypeArr->toArray->lub
Types#lub(Type...):::Return the least upper bound (lub) of set of types:::UNKNOWN_BOUND->ARRAY_BOUND->CLASS_BOUND->kinds->new->intArr->boundkind->for->i->switch->return->elements->new->TypeArr->for->i->return->lub->new->ArrayType->startIdx->for->i->Assert->check->cl->erasedSupertypes->for->i->mec->closureMin->candidates->List->nil->foreach->lci->List->asSuper->of->for->i->candidates->appendList->return->compoundMin->classes->List->arraySuperType->of->for->i->return->lub
Types#erasedSupertypes(Type)::: types erased supertypes:::buf->new->ListBuffer<>->foreach->closure->if->sup->hasTag->buf->append->else->buf->erasure->append->return->buf->toList
Types#arraySuperType()::: types array super type:::if->synchronized->if->List->of->makeIntersectionType->return
Types#glb(List)::: types glb:::t1->foreach->if->t1->isErroneous->return->glb->return
Types#glb(Type, Type)::: types glb:::if->return->else->if->t->isPrimitive->s->isPrimitive->return->else->if->isSubtypeNoCapture->return->else->if->isSubtypeNoCapture->return->closure->closure->closure->union->return->glbFlattened
Types#glbFlattened(List, Type):::Perform glb for a list of non-primitive, non-error, non-compound types; redundant elements are removed:::bounds->closureMin->if->bounds->isEmpty->return->else->if->isEmpty->return->else->classCount->cvars->List->nil->lowers->List->nil->foreach->if->bound->isInterface->lower->cvarLowerBound->if->lower->hasTag->cvars->append->lowers->append->if->if->lowers->isEmpty->return->createErrorType->else->newBounds->bounds->diff->appendList->return->glb->return->makeIntersectionType
Types#hashCode(Type):::Compute a hash code on a type.:::return->hashCode
Types#hashCode(Type, boolean)::: types hash code:::return->hashCodeStrictVisitor->visit->hashCodeVisitor->visit
Types.HashCodeVisitor#visitType(Type, Void)::: hash code visitor visit type:::return->t->getTag->ordinal
Types.HashCodeVisitor#visitClassType(ClassType, Void)::: hash code visitor visit class type:::result->t->getEnclosingType->visit->flatName->hashCode->foreach->t->getTypeArguments->visit->return
Types.HashCodeVisitor#visitMethodType(MethodType, Void)::: hash code visitor visit method type:::h->METHOD->ordinal->for->thisargs->return->visit
Types.HashCodeVisitor#visitWildcardType(WildcardType, Void)::: hash code visitor visit wildcard type:::result->hashCode->if->visit->return
Types.HashCodeVisitor#visitArrayType(ArrayType, Void)::: hash code visitor visit array type:::return->visit
Types.HashCodeVisitor#visitTypeVar(TypeVar, Void)::: hash code visitor visit type var:::return->System->identityHashCode
Types.HashCodeVisitor#visitUndetVar(UndetVar, Void)::: hash code visitor visit undet var:::return->System->identityHashCode
Types.HashCodeVisitor#visitErrorType(ErrorType, Void)::: hash code visitor visit error type:::return
Types#resultSubtype(Type, Type, Warner):::Does t have a result that is a subtype of the result type of s, suitable for covariant returns?  It is assumed that both types are (possibly polymorphic) method types:::tvars->t->getTypeArguments->svars->s->getTypeArguments->tres->t->getReturnType->sres->s->getReturnType->subst->return->covariantReturnType
Types#returnTypeSubstitutable(Type, Type):::Return-Type-Substitutable.:::if->hasSameArgs->return->resultSubtype->else->return->r1->getReturnType->r2->getReturnType->erasure->covariantReturnType
Types#returnTypeSubstitutable(Type, Type, Type, Warner)::: types return type substitutable:::if->r1->getReturnType->isSameType->return->if->r1->getReturnType->isPrimitive->r2res->isPrimitive->return->if->hasSameArgs->return->r1->getReturnType->covariantReturnType->if->r1->getReturnType->isSubtypeUnchecked->return->if->r1->getReturnType->erasure->isSubtype->return->warner->warn->return
Types#covariantReturnType(Type, Type, Warner):::Is t an appropriate return type in an overrider for a method that returns s?:::return->isSameType->t->isPrimitive->s->isPrimitive->isAssignable
Types#boxedClass(Type):::Return the class that boxes the given primitive.:::return->syms->t->getTag->ordinal->enterClass
Types#boxedTypeOrType(Type):::Return the boxed type if 't' is primitive, otherwise return 't' itself.:::return->t->isPrimitive->boxedClass
Types#unboxedType(Type):::Return the primitive type corresponding to a boxed type.:::for->i->return
Types#unboxedTypeOrType(Type):::Return the unboxed type if 't' is a boxed class, otherwise return 't' itself.:::unboxedType->unboxedType->return->unboxedType->hasTag
Types#capture(List)::: types capture:::buf->List->nil->foreach->buf->capture->prepend->return->buf->reverse
Types#capture(Type)::: types capture:::if->t->hasTag->return->if->t->getEnclosingType->capturedEncl->t->getEnclosingType->capture->if->t->getEnclosingType->type1->memberType->getTypeArguments->t->getTypeArguments->subst->cls->if->cls->isRaw->cls->isParameterized->return->G->cls->asElement->asType->A->G->getTypeArguments->T->cls->getTypeArguments->S->freshTypeVariables->currentA->currentT->currentS->captured->while->currentA->isEmpty->currentT->isEmpty->currentS->isEmpty->if->Ti->Ui->getUpperBound->Si->if->switch->subst->break->Ti->getExtendsBound->subst->glb->break->subst->Ti->getSuperBound->break->tmpBound->hasTag->tmpLower->hasTag->if->hasTag->hasTag->isSameType->if->currentA->isEmpty->currentT->isEmpty->currentS->isEmpty->return->erasure->if->return->cls->getEnclosingType->cls->getMetadata->new->ClassType->else->return
Types#freshTypeVariables(List)::: types fresh type variables:::result->new->ListBuffer<>->foreach->if->t->hasTag->bound->getExtendsBound->if->result->new->CapturedType->append->else->result->append->return->result->toList
Types#sideCast(Type, Type, Warner)::: types side cast:::reverse->target->if->flags->Assert->flags->check->commonSupers->erasure->superClosure->giveWarning->commonSupers->isEmpty->while->commonSupers->nonEmpty->t1->asSuper->t2->if->t1->getTypeArguments->t2->getTypeArguments->disjointTypes->return->giveWarning->giveWarning->if->isReifiable->warn->warn->return
Types#sideCastFinal(Type, Type, Warner)::: types side cast final:::reverse->target->if->flags->Assert->flags->check->Assert->flags->check->t1->asSuper->if->return->t2->if->t1->getTypeArguments->t2->getTypeArguments->disjointTypes->return->if->isReifiable->giveWarning->giveWarning->warn->warn->return
Types#giveWarning(Type, Type)::: types give warning:::bounds->to->isCompound->directSupertypes->List->of->foreach->subFrom->asSub->if->b->isParameterized->isUnbounded->isSubtype->b->allparams->subFrom->allparams->containsType->return->return
Types#superClosure(Type, Type)::: types super closure:::cl->List->nil->for->l->interfaces->l->nonEmpty->return
Types#containsTypeEquivalent(Type, Type)::: types contains type equivalent:::return->isSameType->containsType->containsType
Types#adapt(Type, Type, ListBuffer, ListBuffer):::Adapt a type by computing a substitution which maps a source type to a target type.:::new->Adapter->adapt
Types.Adapter#adapt(Type, Type)::: adapter adapt:::visit->fromList->from->toList->toList->to->toList->while->fromList->isEmpty->val->mapping->get->if
Types.Adapter#visitClassType(ClassType, Type)::: adapter visit class type:::if->target->hasTag->source->allparams->target->allparams->adaptRecursive->return
Types.Adapter#visitArrayType(ArrayType, Type)::: adapter visit array type:::if->target->hasTag->elemtype->elemtype->adaptRecursive->return
Types.Adapter#visitWildcardType(WildcardType, Type)::: adapter visit wildcard type:::if->source->isExtendsBound->wildUpperBound->wildUpperBound->adaptRecursive->else->if->source->isSuperBound->wildLowerBound->wildLowerBound->adaptRecursive->return
Types.Adapter#visitTypeVar(TypeVar, Type)::: adapter visit type var:::val->mapping->get->if->if->val->isSuperBound->target->isSuperBound->wildLowerBound->wildLowerBound->isSubtype->else->if->val->isExtendsBound->target->isExtendsBound->wildUpperBound->wildUpperBound->isSubtype->else->if->isSameType->throw->new->AdaptFailure->else->from->append->to->append->mapping->put->return
Types.Adapter#visitType(Type, Type)::: adapter visit type:::return
Types.Adapter#adaptRecursive(Type, Type)::: adapter adapt recursive:::pair->new->TypePair->if->cache->add->try->visit->catch->finally->cache->remove
Types.Adapter#adaptRecursive(List, List)::: adapter adapt recursive:::if->source->length->target->length->while->source->nonEmpty->adaptRecursive
Types#adaptSelf(Type, ListBuffer, ListBuffer)::: types adapt self:::try->adapt->catch->throw->new->AssertionError->finally
Types#rewriteQuantifiers(Type, boolean, boolean):::Rewrite all type variables (universal quantifiers) in the given type to wildcards (existential quantifiers):::return->new->Rewriter->visit
Types.Rewriter#visitClassType(ClassType, Void)::: rewriter visit class type:::rewritten->new->ListBuffer<>->changed->foreach->t->allparams->bound->visit->if->rewritten->append->if->return->allparams->rewritten->toList->subst->else->return
Types.Rewriter#visitType(Type, Void)::: rewriter visit type:::return
Types.Rewriter#visitCapturedType(CapturedType, Void)::: rewriter visit captured type:::w_bound->bound->w_bound->contains->erasure->visit->return->visit->rewriteAsWildcardType
Types.Rewriter#visitTypeVar(TypeVar, Void)::: rewriter visit type var:::if->bound->contains->erasure->visit->return->rewriteAsWildcardType->else->return
Types.Rewriter#visitWildcardType(WildcardType, Void)::: rewriter visit wildcard type:::bound2->visit->return->rewriteAsWildcardType
Types.Rewriter#rewriteAsWildcardType(Type, TypeVar, BoundKind)::: rewriter rewrite as wildcard type:::switch->return->B->makeExtendsWildcard->makeExtendsWildcard->return->makeSuperWildcard->B->makeSuperWildcard->return->makeExtendsWildcard->Assert->error->return
Types.Rewriter#B(Type)::: rewriter  b:::while->t->hasTag->w->w->getExtendsBound->w->getSuperBound->if->return
Types#makeExtendsWildcard(Type, TypeVar):::Create a wildcard with the given upper (extends) bound; create an unbounded wildcard if bound is Object.:::if->return->new->WildcardType->else->return->new->WildcardType
Types#makeSuperWildcard(Type, TypeVar):::Create a wildcard with the given lower (super) bound; create an unbounded wildcard if bound is bottom (type of null).:::if->bound->hasTag->return->new->WildcardType->else->return->new->WildcardType
Types.UniqueType#hashCode()::: unique type hash code:::return->types->hashCode
Types.UniqueType#equals(Object)::: unique type equals:::return->types->isSameType
Types.UniqueType#toString()::: unique type to string:::return->type->toString
Types.DefaultTypeVisitor#visit(Type, S)::: default type visitor visit:::return->t->accept
Types.DefaultTypeVisitor#visitClassType(ClassType, S)::: default type visitor visit class type:::return->visitType
Types.DefaultTypeVisitor#visitWildcardType(WildcardType, S)::: default type visitor visit wildcard type:::return->visitType
Types.DefaultTypeVisitor#visitArrayType(ArrayType, S)::: default type visitor visit array type:::return->visitType
Types.DefaultTypeVisitor#visitMethodType(MethodType, S)::: default type visitor visit method type:::return->visitType
Types.DefaultTypeVisitor#visitPackageType(PackageType, S)::: default type visitor visit package type:::return->visitType
Types.DefaultTypeVisitor#visitModuleType(ModuleType, S)::: default type visitor visit module type:::return->visitType
Types.DefaultTypeVisitor#visitTypeVar(TypeVar, S)::: default type visitor visit type var:::return->visitType
Types.DefaultTypeVisitor#visitCapturedType(CapturedType, S)::: default type visitor visit captured type:::return->visitType
Types.DefaultTypeVisitor#visitForAll(ForAll, S)::: default type visitor visit for all:::return->visitType
Types.DefaultTypeVisitor#visitUndetVar(UndetVar, S)::: default type visitor visit undet var:::return->visitType
Types.DefaultTypeVisitor#visitErrorType(ErrorType, S)::: default type visitor visit error type:::return->visitType
Types.DefaultSymbolVisitor#visit(Symbol, S)::: default symbol visitor visit:::return->s->accept
Types.DefaultSymbolVisitor#visitClassSymbol(ClassSymbol, S)::: default symbol visitor visit class symbol:::return->visitSymbol
Types.DefaultSymbolVisitor#visitMethodSymbol(MethodSymbol, S)::: default symbol visitor visit method symbol:::return->visitSymbol
Types.DefaultSymbolVisitor#visitOperatorSymbol(OperatorSymbol, S)::: default symbol visitor visit operator symbol:::return->visitSymbol
Types.DefaultSymbolVisitor#visitPackageSymbol(PackageSymbol, S)::: default symbol visitor visit package symbol:::return->visitSymbol
Types.DefaultSymbolVisitor#visitTypeSymbol(TypeSymbol, S)::: default symbol visitor visit type symbol:::return->visitSymbol
Types.DefaultSymbolVisitor#visitVarSymbol(VarSymbol, S)::: default symbol visitor visit var symbol:::return->visitSymbol
Types.SimpleVisitor#visitCapturedType(CapturedType, S)::: simple visitor visit captured type:::return->visitTypeVar
Types.SimpleVisitor#visitForAll(ForAll, S)::: simple visitor visit for all:::return->visit
Types.SimpleVisitor#visitUndetVar(UndetVar, S)::: simple visitor visit undet var:::return->visit
Types.UnaryVisitor#visit(Type)::: unary visitor visit:::return->t->accept
Types.MapVisitor#visit(Type)::: map visitor visit:::return->t->accept
Types.MapVisitor#visitType(Type, S)::: map visitor visit type:::return
Types.TypeMapping#apply(Type)::: type mapping apply:::return->visit
Types.TypeMapping#visit(List, S)::: type mapping visit:::return->ts->visit->map
Types.TypeMapping#visitCapturedType(CapturedType, S)::: type mapping visit captured type:::return->visitTypeVar
Types#getRetention(Attribute.Compound)::: types get retention:::return->getRetention
Types#getRetention(TypeSymbol)::: types get retention:::vis->c->sym->attribute->if->value->c->member->if->levelName->if->else->if->else->if->else->return
Types.SignatureGenerator.InvalidSignatureException#type()::: invalid signature exception type:::return
Types.SignatureGenerator#append(char)::: signature generator append:::
Types.SignatureGenerator#append(byte[])::: signature generator append:::
Types.SignatureGenerator#append(Name)::: signature generator append:::
Types.SignatureGenerator#classReference(ClassSymbol)::: signature generator class reference:::
Types.SignatureGenerator#assembleSig(Type):::Assemble signature of given type in string buffer.:::switch->type->getTag->append->break->append->break->append->break->append->break->append->break->append->break->append->break->append->break->append->break->if->type->isCompound->throw->new->InvalidSignatureException->append->assembleClassSig->append->break->at->append->assembleSig->break->mt->append->assembleSig->append->assembleSig->if->hasTypeVar->for->l->l->nonEmpty->break->ta->switch->append->assembleSig->break->append->assembleSig->break->append->break->throw->new->AssertionError->break->if->isCaptured->throw->new->InvalidSignatureException->append->append->append->break->ft->assembleParamsSig->assembleSig->break->throw->type->getTag->new->AssertionError
Types.SignatureGenerator#hasTypeVar(List)::: signature generator has type var:::while->l->nonEmpty->if->hasTag->return->return
Types.SignatureGenerator#assembleClassSig(Type)::: signature generator assemble class sig:::ct->c->classReference->outer->ct->getEnclosingType->if->outer->allparams->nonEmpty->rawOuter->types->erasure->assembleClassSig->append->Assert->enclClass->startsWith->check->enclClass->getByteLength->getByteLength->subName->append->else->externalize->append->if->ct->getTypeArguments->nonEmpty->append->ct->getTypeArguments->assembleSig->append
Types.SignatureGenerator#assembleParamsSig(List)::: signature generator assemble params sig:::append->for->ts->ts->nonEmpty->append
Types.SignatureGenerator#assembleSig(List)::: signature generator assemble sig:::for->ts->ts->nonEmpty
Types#newRound()::: types new round:::clear->isDerivedRawCache->clear->clear->clear->closureCache->clear
