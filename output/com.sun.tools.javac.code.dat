com.sun.tools.javac.code.AnnoConstruct#getAnnotationMirrors()->List::: anno construct get annotation mirrors
com.sun.tools.javac.code.AnnoConstruct#getAttribute(Class)->Attribute.Compound::: anno construct get attribute
com.sun.tools.javac.code.AnnoConstruct#getInheritedAnnotations(Class)->A[]::: anno construct get inherited annotations
com.sun.tools.javac.code.AnnoConstruct#getAnnotationsByType(Class)->A[]::: anno construct get annotations by type
com.sun.tools.javac.code.AnnoConstruct#getAnnotation(Class)->A::: anno construct get annotation
com.sun.tools.javac.code.Attribute#accept(Visitor)->void::: attribute accept
com.sun.tools.javac.code.Attribute#getValue()->Object::: attribute get value
com.sun.tools.javac.code.Attribute#accept(AnnotationValueVisitor, P)->R::: attribute accept
com.sun.tools.javac.code.Attribute#isSynthesized()->boolean::: attribute is synthesized
com.sun.tools.javac.code.Attribute#getPosition()->TypeAnnotationPosition::: attribute get position
com.sun.tools.javac.code.Attribute.Constant#accept(Visitor)->void::: constant accept
com.sun.tools.javac.code.Attribute.Constant#toString()->String::: constant to string
com.sun.tools.javac.code.Attribute.Constant#getValue()->Object::: constant get value
com.sun.tools.javac.code.Attribute.Constant#accept(AnnotationValueVisitor, P)->R::: constant accept
com.sun.tools.javac.code.Attribute.Class#accept(Visitor)->void::: class accept
com.sun.tools.javac.code.Attribute.Class#makeClassType(Types, Type)->Type::: class make class type
com.sun.tools.javac.code.Attribute.Class#toString()->String::: class to string
com.sun.tools.javac.code.Attribute.Class#getValue()->Type::: class get value
com.sun.tools.javac.code.Attribute.Class#accept(AnnotationValueVisitor, P)->R::: class accept
com.sun.tools.javac.code.Attribute.Compound#isSynthesized()->boolean::: compound is synthesized
com.sun.tools.javac.code.Attribute.Compound#setSynthesized(boolean)->void::: compound set synthesized
com.sun.tools.javac.code.Attribute.Compound#getPosition()->TypeAnnotationPosition::: compound get position
com.sun.tools.javac.code.Attribute.Compound#isContainerTypeCompound()->boolean::: compound is container type compound
com.sun.tools.javac.code.Attribute.Compound#tryFixPosition()->boolean::: compound try fix position
com.sun.tools.javac.code.Attribute.Compound#hasUnknownPosition()->boolean::: compound has unknown position
com.sun.tools.javac.code.Attribute.Compound#accept(Visitor)->void::: compound accept
com.sun.tools.javac.code.Attribute.Compound#toString()->String:::Returns a string representation of this annotation
com.sun.tools.javac.code.Attribute.Compound#member(Name)->Attribute::: compound member
com.sun.tools.javac.code.Attribute.Compound#getValue()->Attribute.Compound::: compound get value
com.sun.tools.javac.code.Attribute.Compound#accept(AnnotationValueVisitor, P)->R::: compound accept
com.sun.tools.javac.code.Attribute.Compound#getAnnotationType()->DeclaredType::: compound get annotation type
com.sun.tools.javac.code.Attribute.Compound#getElementValues()->Map::: compound get element values
com.sun.tools.javac.code.Attribute.Array#accept(Visitor)->void::: array accept
com.sun.tools.javac.code.Attribute.Array#toString()->String::: array to string
com.sun.tools.javac.code.Attribute.Array#getValue()->List::: array get value
com.sun.tools.javac.code.Attribute.Array#accept(AnnotationValueVisitor, P)->R::: array accept
com.sun.tools.javac.code.Attribute.Array#getPosition()->TypeAnnotationPosition::: array get position
com.sun.tools.javac.code.Attribute.Enum#accept(Visitor)->void::: enum accept
com.sun.tools.javac.code.Attribute.Enum#toString()->String::: enum to string
com.sun.tools.javac.code.Attribute.Enum#getValue()->VarSymbol::: enum get value
com.sun.tools.javac.code.Attribute.Enum#accept(AnnotationValueVisitor, P)->R::: enum accept
com.sun.tools.javac.code.Attribute.Error#accept(Visitor)->void::: error accept
com.sun.tools.javac.code.Attribute.Error#toString()->String::: error to string
com.sun.tools.javac.code.Attribute.Error#getValue()->String::: error get value
com.sun.tools.javac.code.Attribute.Error#accept(AnnotationValueVisitor, P)->R::: error accept
com.sun.tools.javac.code.Attribute.Visitor#visitConstant(Attribute.Constant)->void::: visitor visit constant
com.sun.tools.javac.code.Attribute.Visitor#visitClass(Attribute.Class)->void::: visitor visit class
com.sun.tools.javac.code.Attribute.Visitor#visitCompound(Attribute.Compound)->void::: visitor visit compound
com.sun.tools.javac.code.Attribute.Visitor#visitArray(Attribute.Array)->void::: visitor visit array
com.sun.tools.javac.code.Attribute.Visitor#visitEnum(Attribute.Enum)->void::: visitor visit enum
com.sun.tools.javac.code.Attribute.Visitor#visitError(Attribute.Error)->void::: visitor visit error
com.sun.tools.javac.code.ClassFinder#getCompleter()->Completer::: class finder get completer
com.sun.tools.javac.code.ClassFinder#instance(Context)->ClassFinder:::Get the ClassFinder instance for this invocation.
com.sun.tools.javac.code.ClassFinder#getSupplementaryFlags(ClassSymbol)->long:::Returns any extra flags for a class symbol
com.sun.tools.javac.code.ClassFinder#fillIn(ClassSymbol)->void:::Fill in definition of class `c' from corresponding class or  source file.
com.sun.tools.javac.code.ClassFinder#loadClass(ModuleSymbol, Name)->ClassSymbol:::Load a toplevel class with given fully qualified name  The class is entered into `classes' only if load was successful.
com.sun.tools.javac.code.ClassFinder#includeClassFile(PackageSymbol, JavaFileObject)->void:::Include class corresponding to given class file in package,  unless (1) we already have one the same kind (.class or .java), or         (2) we have one of the other kind, and the given class file             is older.
com.sun.tools.javac.code.ClassFinder#preferredFileObject(JavaFileObject, JavaFileObject)->JavaFileObject:::Implement policy to choose to derive information from a source  file or a class file when both are present
com.sun.tools.javac.code.ClassFinder#getPackageFileKinds()->EnumSet::: class finder get package file kinds
com.sun.tools.javac.code.ClassFinder#extraFileActions(PackageSymbol, JavaFileObject)->void:::this is used to support javadoc
com.sun.tools.javac.code.ClassFinder#list(Location, PackageSymbol, String, Set)->Iterable::: class finder list
com.sun.tools.javac.code.DeferredCompletionFailureHandler#instance(Context)->DeferredCompletionFailureHandler::: deferred completion failure handler instance
com.sun.tools.javac.code.DeferredCompletionFailureHandler#setHandler(Handler)->Handler::: deferred completion failure handler set handler
com.sun.tools.javac.code.DeferredCompletionFailureHandler#handleAPICompletionFailure(CompletionFailure)->void::: deferred completion failure handler handle completion failure
com.sun.tools.javac.code.DeferredCompletionFailureHandler#classSymbolCompleteFailed(ClassSymbol, Completer)->void::: deferred completion failure handler class symbol complete failed
com.sun.tools.javac.code.DeferredCompletionFailureHandler#classSymbolRemoved(ClassSymbol)->void::: deferred completion failure handler class symbol removed
com.sun.tools.javac.code.DeferredCompletionFailureHandler#isDeferredCompleter(Completer)->boolean::: deferred completion failure handler is deferred completer
com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler#install()->void::: handler install
com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler#handleAPICompletionFailure(CompletionFailure)->void::: handler handle completion failure
com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler#classSymbolCompleteFailed(ClassSymbol, Completer)->void::: handler class symbol complete failed
com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler#classSymbolRemoved(ClassSymbol)->void::: handler class symbol removed
com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler#uninstall()->void::: handler uninstall
com.sun.tools.javac.code.DeferredLintHandler#instance(Context)->DeferredLintHandler::: deferred lint handler instance
com.sun.tools.javac.code.DeferredLintHandler.LintLogger#report()->void::: lint logger report
com.sun.tools.javac.code.DeferredLintHandler#report(LintLogger)->void:::Associate the given logger with the current position as set by #setPos(DiagnosticPosition) 
com.sun.tools.javac.code.DeferredLintHandler#flush(DiagnosticPosition)->void:::Invoke all LintLoggers that were associated with the provided pos.
com.sun.tools.javac.code.DeferredLintHandler#setPos(DiagnosticPosition)->DiagnosticPosition:::Sets the current position to the provided currentPos
com.sun.tools.javac.code.DeferredLintHandler#immediate()->DiagnosticPosition:::LintLoggers passed to subsequent invocations of #report(LintLogger)  will be invoked immediately.
com.sun.tools.javac.code.Directive.ExportsDirective#getKind()->ModuleElement.DirectiveKind::: exports directive get kind
com.sun.tools.javac.code.Directive.ExportsDirective#getPackage()->PackageSymbol::: exports directive get package
com.sun.tools.javac.code.Directive.ExportsDirective#getTargetModules()->java.util.List::: exports directive get target modules
com.sun.tools.javac.code.Directive.ExportsDirective#toString()->String::: exports directive to string
com.sun.tools.javac.code.Directive.ExportsDirective#accept(DirectiveVisitor, P)->R::: exports directive accept
com.sun.tools.javac.code.Directive.OpensDirective#getKind()->ModuleElement.DirectiveKind::: opens directive get kind
com.sun.tools.javac.code.Directive.OpensDirective#getPackage()->PackageSymbol::: opens directive get package
com.sun.tools.javac.code.Directive.OpensDirective#getTargetModules()->java.util.List::: opens directive get target modules
com.sun.tools.javac.code.Directive.OpensDirective#toString()->String::: opens directive to string
com.sun.tools.javac.code.Directive.OpensDirective#accept(DirectiveVisitor, P)->R::: opens directive accept
com.sun.tools.javac.code.Directive.ProvidesDirective#getKind()->ModuleElement.DirectiveKind::: provides directive get kind
com.sun.tools.javac.code.Directive.ProvidesDirective#getService()->ClassSymbol::: provides directive get service
com.sun.tools.javac.code.Directive.ProvidesDirective#getImplementations()->List::: provides directive get implementations
com.sun.tools.javac.code.Directive.ProvidesDirective#toString()->String::: provides directive to string
com.sun.tools.javac.code.Directive.ProvidesDirective#accept(DirectiveVisitor, P)->R::: provides directive accept
com.sun.tools.javac.code.Directive.ProvidesDirective#equals(Object)->boolean::: provides directive equals
com.sun.tools.javac.code.Directive.ProvidesDirective#hashCode()->int::: provides directive hash code
com.sun.tools.javac.code.Directive.RequiresDirective#getKind()->ModuleElement.DirectiveKind::: requires directive get kind
com.sun.tools.javac.code.Directive.RequiresDirective#isStatic()->boolean::: requires directive is static
com.sun.tools.javac.code.Directive.RequiresDirective#isTransitive()->boolean::: requires directive is transitive
com.sun.tools.javac.code.Directive.RequiresDirective#getDependency()->ModuleSymbol::: requires directive get dependency
com.sun.tools.javac.code.Directive.RequiresDirective#toString()->String::: requires directive to string
com.sun.tools.javac.code.Directive.RequiresDirective#accept(DirectiveVisitor, P)->R::: requires directive accept
com.sun.tools.javac.code.Directive.UsesDirective#getKind()->ModuleElement.DirectiveKind::: uses directive get kind
com.sun.tools.javac.code.Directive.UsesDirective#getService()->ClassSymbol::: uses directive get service
com.sun.tools.javac.code.Directive.UsesDirective#toString()->String::: uses directive to string
com.sun.tools.javac.code.Directive.UsesDirective#accept(DirectiveVisitor, P)->R::: uses directive accept
com.sun.tools.javac.code.Directive.UsesDirective#equals(Object)->boolean::: uses directive equals
com.sun.tools.javac.code.Directive.UsesDirective#hashCode()->int::: uses directive hash code
com.sun.tools.javac.code.Flags#toString(long)->String::: flags to string
com.sun.tools.javac.code.Flags#asFlagSet(long)->EnumSet::: flags as flag set
com.sun.tools.javac.code.Flags#asModifierSet(long)->Set::: flags as modifier set
com.sun.tools.javac.code.Flags#isStatic(Symbol)->boolean::: flags is static
com.sun.tools.javac.code.Flags#isEnum(Symbol)->boolean::: flags is enum
com.sun.tools.javac.code.Flags#isConstant(Symbol.VarSymbol)->boolean::: flags is constant
com.sun.tools.javac.code.Kinds.KindSelector#of(KindSelector...)->KindSelector::: kind selector of
com.sun.tools.javac.code.Kinds.KindSelector#subset(KindSelector)->boolean::: kind selector subset
com.sun.tools.javac.code.Kinds.KindSelector#contains(KindSelector)->boolean::: kind selector contains
com.sun.tools.javac.code.Kinds.KindSelector#kindNames()->Set:::A set of KindName(s) representing a set of symbol's kinds.
com.sun.tools.javac.code.Kinds#kindName(MemberReferenceTree.ReferenceMode)->KindName::: kinds kind name
com.sun.tools.javac.code.Kinds#kindName(Symbol)->KindName:::A KindName representing a given symbol
com.sun.tools.javac.code.Kinds#typeKindName(Type)->KindName:::A KindName representing the kind of a given class/interface type.
com.sun.tools.javac.code.Lint#instance(Context)->Lint:::Get the root Lint instance.
com.sun.tools.javac.code.Lint#augment(Attribute.Compound)->Lint:::Returns the result of combining the values in this object with the given annotation.
com.sun.tools.javac.code.Lint#augment(Symbol)->Lint:::Returns the result of combining the values in this object with the metadata on the given symbol.
com.sun.tools.javac.code.Lint#suppress(LintCategory...)->Lint:::Returns a new Lint that has the given LintCategorys suppressed.
com.sun.tools.javac.code.Lint#toString()->String::: lint to string
com.sun.tools.javac.code.Lint#isEnabled(LintCategory)->boolean:::Checks if a warning category is enabled
com.sun.tools.javac.code.Lint#isSuppressed(LintCategory)->boolean:::Checks is a warning category has been specifically suppressed, by means of the SuppressWarnings annotation, or, in the case of the deprecated category, whether it has been implicitly suppressed by virtue of the current entity being itself deprecated.
com.sun.tools.javac.code.Lint.AugmentVisitor#augment(Lint, Attribute.Compound)->Lint::: augment visitor augment
com.sun.tools.javac.code.Lint.AugmentVisitor#augment(Lint, List)->Lint::: augment visitor augment
com.sun.tools.javac.code.Lint.AugmentVisitor#visitConstant(Attribute.Constant)->void::: augment visitor visit constant
com.sun.tools.javac.code.Lint.AugmentVisitor#visitClass(Attribute.Class)->void::: augment visitor visit class
com.sun.tools.javac.code.Lint.AugmentVisitor#visitCompound(Attribute.Compound)->void::: augment visitor visit compound
com.sun.tools.javac.code.Lint.AugmentVisitor#visitArray(Attribute.Array)->void::: augment visitor visit array
com.sun.tools.javac.code.Lint.AugmentVisitor#visitEnum(Attribute.Enum)->void::: augment visitor visit enum
com.sun.tools.javac.code.Lint.AugmentVisitor#visitError(Attribute.Error)->void::: augment visitor visit error
com.sun.tools.javac.code.ModuleFinder#instance(Context)->ModuleFinder:::Get the ModuleFinder instance for this invocation.
com.sun.tools.javac.code.ModuleFinder.ModuleLocationIterator#hasNext()->boolean::: module location iterator has next
com.sun.tools.javac.code.ModuleFinder.ModuleLocationIterator#next()->Set::: module location iterator next
com.sun.tools.javac.code.ModuleFinder#findModule(Name)->ModuleSymbol::: module finder find module
com.sun.tools.javac.code.ModuleFinder#findModule(ModuleSymbol)->ModuleSymbol::: module finder find module
com.sun.tools.javac.code.ModuleFinder#findAllModules()->List::: module finder find all modules
com.sun.tools.javac.code.ModuleFinder#findSingleModule()->ModuleSymbol::: module finder find single module
com.sun.tools.javac.code.ModuleFinder#getDescription(StandardLocation)->Fragment::: module finder get description
com.sun.tools.javac.code.ModuleFinder.ModuleNameFromSourceReader#readModuleName(JavaFileObject)->Name::: module name from source reader read module name
com.sun.tools.javac.code.Preview#instance(Context)->Preview::: preview instance
com.sun.tools.javac.code.Preview#warnPreview(int, Feature)->void:::Report usage of a preview feature
com.sun.tools.javac.code.Preview#warnPreview(DiagnosticPosition, Feature)->void:::Report usage of a preview feature
com.sun.tools.javac.code.Preview#warnPreview(JavaFileObject, int)->void:::Report usage of a preview feature in classfile.
com.sun.tools.javac.code.Preview#isEnabled()->boolean:::Are preview features enabled?
com.sun.tools.javac.code.Preview#isPreview(Feature)->boolean:::Is given feature a preview feature?
com.sun.tools.javac.code.Preview#disabledError(Feature)->Error:::Generate an error key which captures the fact that a given preview feature could not be used due to the preview feature support being disabled.
com.sun.tools.javac.code.Preview#disabledError(JavaFileObject, int)->Error:::Generate an error key which captures the fact that a preview classfile cannot be loaded due to the preview feature support being disabled.
com.sun.tools.javac.code.Preview#reportDeferredDiagnostics()->void:::Report any deferred diagnostics.
com.sun.tools.javac.code.Printer#localize(Locale, String, Object...)->String:::This method should be overriden in order to provide proper i18n support.
com.sun.tools.javac.code.Printer#capturedVarId(CapturedType, Locale)->String:::Maps a captured type into an unique identifier.
com.sun.tools.javac.code.Printer#createStandardPrinter(Messages)->Printer:::Create a printer with default i18n support provided by Messages
com.sun.tools.javac.code.Printer#visitTypes(List, Locale)->String:::Get a localized string representation for all the types in the input list.
com.sun.tools.javac.code.Printer#visitSymbols(List, Locale)->String:::* Get a localized string representation for all the symbols in the input list.
com.sun.tools.javac.code.Printer#visit(Type, Locale)->String:::Get a localized string representation for a given type.
com.sun.tools.javac.code.Printer#visit(Symbol, Locale)->String:::Get a localized string representation for a given symbol.
com.sun.tools.javac.code.Printer#visitCapturedType(CapturedType, Locale)->String::: printer visit captured type
com.sun.tools.javac.code.Printer#visitForAll(ForAll, Locale)->String::: printer visit for all
com.sun.tools.javac.code.Printer#visitUndetVar(UndetVar, Locale)->String::: printer visit undet var
com.sun.tools.javac.code.Printer#visitArrayType(ArrayType, Locale)->String::: printer visit array type
com.sun.tools.javac.code.Printer#visitClassType(ClassType, Locale)->String::: printer visit class type
com.sun.tools.javac.code.Printer#visitMethodType(MethodType, Locale)->String::: printer visit method type
com.sun.tools.javac.code.Printer#visitPackageType(PackageType, Locale)->String::: printer visit package type
com.sun.tools.javac.code.Printer#visitWildcardType(WildcardType, Locale)->String::: printer visit wildcard type
com.sun.tools.javac.code.Printer#visitErrorType(ErrorType, Locale)->String::: printer visit error type
com.sun.tools.javac.code.Printer#visitTypeVar(TypeVar, Locale)->String::: printer visit type var
com.sun.tools.javac.code.Printer#visitModuleType(ModuleType, Locale)->String::: printer visit module type
com.sun.tools.javac.code.Printer#visitType(Type, Locale)->String::: printer visit type
com.sun.tools.javac.code.Printer#className(ClassType, boolean, Locale)->String:::Converts a class name into a (possibly localized) string
com.sun.tools.javac.code.Printer#printMethodArgs(List, boolean, Locale)->String:::Converts a set of method argument types into their corresponding localized string representation.
com.sun.tools.javac.code.Printer#visitClassSymbol(ClassSymbol, Locale)->String::: printer visit class symbol
com.sun.tools.javac.code.Printer#visitMethodSymbol(MethodSymbol, Locale)->String::: printer visit method symbol
com.sun.tools.javac.code.Printer#visitOperatorSymbol(OperatorSymbol, Locale)->String::: printer visit operator symbol
com.sun.tools.javac.code.Printer#visitPackageSymbol(PackageSymbol, Locale)->String::: printer visit package symbol
com.sun.tools.javac.code.Printer#visitTypeSymbol(TypeSymbol, Locale)->String::: printer visit type symbol
com.sun.tools.javac.code.Printer#visitVarSymbol(VarSymbol, Locale)->String::: printer visit var symbol
com.sun.tools.javac.code.Printer#visitSymbol(Symbol, Locale)->String::: printer visit symbol
com.sun.tools.javac.code.Scope#getSymbols()->Iterable:::Returns all Symbols in this Scope
com.sun.tools.javac.code.Scope#getSymbols(Filter)->Iterable:::Returns Symbols that match the given filter
com.sun.tools.javac.code.Scope#getSymbols(LookupKind)->Iterable:::Returns all Symbols in this Scope
com.sun.tools.javac.code.Scope#getSymbols(Filter, LookupKind)->Iterable:::Returns Symbols that match the given filter
com.sun.tools.javac.code.Scope#getSymbolsByName(Name)->Iterable:::Returns Symbols with the given name
com.sun.tools.javac.code.Scope#getSymbolsByName(Name, Filter)->Iterable:::Returns Symbols with the given name that match the given filter
com.sun.tools.javac.code.Scope#getSymbolsByName(Name, LookupKind)->Iterable:::Returns Symbols with the given name
com.sun.tools.javac.code.Scope#getSymbolsByName(Name, Filter, LookupKind)->Iterable:::Returns Symbols with the given name that match the given filter
com.sun.tools.javac.code.Scope#findFirst(Name)->Symbol:::Return the first Symbol from this or outward scopes with the given name
com.sun.tools.javac.code.Scope#findFirst(Name, Filter)->Symbol:::Return the first Symbol from this or outward scopes with the given name that matches the  given filter
com.sun.tools.javac.code.Scope#anyMatch(Filter)->boolean:::Returns true iff there are is at least one Symbol in this scope matching the given filter
com.sun.tools.javac.code.Scope#includes(Symbol)->boolean:::Returns true iff the given Symbol is in this scope or any outward scope.
com.sun.tools.javac.code.Scope#includes(Symbol, LookupKind)->boolean:::Returns true iff the given Symbol is in this scope, optionally checking outward scopes.
com.sun.tools.javac.code.Scope#isEmpty()->boolean:::Returns true iff this scope does not contain any Symbol
com.sun.tools.javac.code.Scope#getOrigin(Symbol)->Scope:::Returns the Scope from which the givins Symbol originates in this scope.
com.sun.tools.javac.code.Scope#isStaticallyImported(Symbol)->boolean:::Returns true iff the given Symbol is part of this scope due to a static import.
com.sun.tools.javac.code.Scope.ScopeListener#symbolAdded(Symbol, Scope)->void::: scope listener symbol added
com.sun.tools.javac.code.Scope.ScopeListener#symbolRemoved(Symbol, Scope)->void::: scope listener symbol removed
com.sun.tools.javac.code.Scope.ScopeListenerList#add(ScopeListener)->void::: scope listener list add
com.sun.tools.javac.code.Scope.ScopeListenerList#symbolAdded(Symbol, Scope)->void::: scope listener list symbol added
com.sun.tools.javac.code.Scope.ScopeListenerList#symbolRemoved(Symbol, Scope)->void::: scope listener list symbol removed
com.sun.tools.javac.code.Scope.WriteableScope#enter(Symbol)->void:::Enter the given Symbol into this scope.
com.sun.tools.javac.code.Scope.WriteableScope#enterIfAbsent(Symbol)->void:::Enter symbol sym in this scope if not already there.
com.sun.tools.javac.code.Scope.WriteableScope#remove(Symbol)->void::: writeable scope remove
com.sun.tools.javac.code.Scope.WriteableScope#dup()->WriteableScope:::Construct a fresh scope within this scope, with same owner
com.sun.tools.javac.code.Scope.WriteableScope#dup(Symbol)->WriteableScope:::Construct a fresh scope within this scope, with new owner
com.sun.tools.javac.code.Scope.WriteableScope#leave()->WriteableScope:::Must be called on dup-ed scopes to be able to work with the outward scope again.
com.sun.tools.javac.code.Scope.WriteableScope#dupUnshared()->WriteableScope:::Construct a fresh scope within this scope, with same owner
com.sun.tools.javac.code.Scope.WriteableScope#dupUnshared(Symbol)->WriteableScope:::Construct a fresh scope within this scope, with new owner
com.sun.tools.javac.code.Scope.WriteableScope#create(Symbol)->WriteableScope:::Create a new WriteableScope.
com.sun.tools.javac.code.Scope.ImportScope#finalizeScope()->void:::Finalize the content of the ImportScope to speed-up future lookups
com.sun.tools.javac.code.Scope.ImportScope#finalizeSingleScope(Scope)->Scope::: import scope finalize single scope
com.sun.tools.javac.code.Scope.NamedImportScope#importByName(Types, Scope, Name, ImportFilter, JCImport, BiConsumer)->Scope::: named import scope import by name
com.sun.tools.javac.code.Scope.NamedImportScope#importType(Scope, Scope, Symbol)->Scope::: named import scope import type
com.sun.tools.javac.code.Scope.NamedImportScope#getSymbolsByName(Name, Filter, LookupKind)->Iterable::: named import scope get symbols by name
com.sun.tools.javac.code.Scope.NamedImportScope#finalizeScope()->void::: named import scope finalize scope
com.sun.tools.javac.code.Scope.StarImportScope#importAll(Types, Scope, ImportFilter, JCImport, BiConsumer)->void::: star import scope import all
com.sun.tools.javac.code.Scope.StarImportScope#isFilled()->boolean::: star import scope is filled
com.sun.tools.javac.code.Scope.ImportFilter#accepts(Scope, Symbol)->boolean::: import filter accepts
com.sun.tools.javac.code.Scope.CompoundScope#prependSubScope(Scope)->void::: compound scope prepend sub scope
com.sun.tools.javac.code.Scope.CompoundScope#appendSubScope(Scope)->void::: compound scope append sub scope
com.sun.tools.javac.code.Scope.CompoundScope#symbolAdded(Symbol, Scope)->void::: compound scope symbol added
com.sun.tools.javac.code.Scope.CompoundScope#symbolRemoved(Symbol, Scope)->void::: compound scope symbol removed
com.sun.tools.javac.code.Scope.CompoundScope#getMark()->int::: compound scope get mark
com.sun.tools.javac.code.Scope.CompoundScope#toString()->String::: compound scope to string
com.sun.tools.javac.code.Scope.CompoundScope#getSymbols(Filter, LookupKind)->Iterable::: compound scope get symbols
com.sun.tools.javac.code.Scope.CompoundScope#getSymbolsByName(Name, Filter, LookupKind)->Iterable::: compound scope get symbols by name
com.sun.tools.javac.code.Scope.CompoundScope#getOrigin(Symbol)->Scope::: compound scope get origin
com.sun.tools.javac.code.Scope.CompoundScope#isStaticallyImported(Symbol)->boolean::: compound scope is statically imported
com.sun.tools.javac.code.Scope.ErrorScope#dup(Symbol)->WriteableScope::: error scope dup
com.sun.tools.javac.code.Scope.ErrorScope#dupUnshared(Symbol)->WriteableScope::: error scope dup unshared
com.sun.tools.javac.code.Scope.ErrorScope#lookup(Name)->Entry::: error scope lookup
com.sun.tools.javac.code.Symbol#flags()->long:::An accessor method for the flags of this symbol
com.sun.tools.javac.code.Symbol#getRawAttributes()->List:::An accessor method for the attributes of this symbol
com.sun.tools.javac.code.Symbol#getRawTypeAttributes()->List:::An accessor method for the type attributes of this symbol
com.sun.tools.javac.code.Symbol#attribute(Symbol)->Attribute.Compound:::Fetch a particular annotation from a symbol.
com.sun.tools.javac.code.Symbol#annotationsPendingCompletion()->boolean::: symbol annotations pending completion
com.sun.tools.javac.code.Symbol#appendAttributes(List)->void::: symbol append attributes
com.sun.tools.javac.code.Symbol#appendClassInitTypeAttributes(List)->void::: symbol append class init type attributes
com.sun.tools.javac.code.Symbol#appendInitTypeAttributes(List)->void::: symbol append init type attributes
com.sun.tools.javac.code.Symbol#appendUniqueTypeAttributes(List)->void::: symbol append unique type attributes
com.sun.tools.javac.code.Symbol#getClassInitTypeAttributes()->List::: symbol get class init type attributes
com.sun.tools.javac.code.Symbol#getInitTypeAttributes()->List::: symbol get init type attributes
com.sun.tools.javac.code.Symbol#setInitTypeAttributes(List)->void::: symbol set init type attributes
com.sun.tools.javac.code.Symbol#setClassInitTypeAttributes(List)->void::: symbol set class init type attributes
com.sun.tools.javac.code.Symbol#getDeclarationAttributes()->List::: symbol get declaration attributes
com.sun.tools.javac.code.Symbol#hasAnnotations()->boolean::: symbol has annotations
com.sun.tools.javac.code.Symbol#hasTypeAnnotations()->boolean::: symbol has type annotations
com.sun.tools.javac.code.Symbol#isCompleted()->boolean::: symbol is completed
com.sun.tools.javac.code.Symbol#prependAttributes(List)->void::: symbol prepend attributes
com.sun.tools.javac.code.Symbol#resetAnnotations()->void::: symbol reset annotations
com.sun.tools.javac.code.Symbol#setAttributes(Symbol)->void::: symbol set attributes
com.sun.tools.javac.code.Symbol#setDeclarationAttributes(List)->void::: symbol set declaration attributes
com.sun.tools.javac.code.Symbol#setTypeAttributes(List)->void::: symbol set type attributes
com.sun.tools.javac.code.Symbol#getMetadata()->SymbolMetadata:::This method is intended for debugging only.
com.sun.tools.javac.code.Symbol#clone(Symbol)->Symbol:::Clone this symbol with new owner
com.sun.tools.javac.code.Symbol#accept(Symbol.Visitor, P)->R::: symbol accept
com.sun.tools.javac.code.Symbol#toString()->String:::The Java source which this symbol represents
com.sun.tools.javac.code.Symbol#location()->Symbol:::A Java source description of the location of this symbol; used for  error reporting.
com.sun.tools.javac.code.Symbol#location(Type, Types)->Symbol::: symbol location
com.sun.tools.javac.code.Symbol#baseSymbol()->Symbol::: symbol base symbol
com.sun.tools.javac.code.Symbol#erasure(Types)->Type:::The symbol's erased type.
com.sun.tools.javac.code.Symbol#externalType(Types)->Type:::The external type of a symbol
com.sun.tools.javac.code.Symbol#isDeprecated()->boolean::: symbol is deprecated
com.sun.tools.javac.code.Symbol#hasDeprecatedAnnotation()->boolean::: symbol has deprecated annotation
com.sun.tools.javac.code.Symbol#isDeprecatedForRemoval()->boolean::: symbol is deprecated for removal
com.sun.tools.javac.code.Symbol#isDeprecatableViaAnnotation()->boolean::: symbol is deprecatable via annotation
com.sun.tools.javac.code.Symbol#isStatic()->boolean::: symbol is static
com.sun.tools.javac.code.Symbol#isInterface()->boolean::: symbol is interface
com.sun.tools.javac.code.Symbol#isPrivate()->boolean::: symbol is private
com.sun.tools.javac.code.Symbol#isEnum()->boolean::: symbol is enum
com.sun.tools.javac.code.Symbol#isLocal()->boolean:::Is this symbol declared (directly or indirectly) local  to a method or variable initializer?  Also includes fields of inner classes which are in  turn local to a method or variable initializer.
com.sun.tools.javac.code.Symbol#isAnonymous()->boolean:::Has this symbol an empty name? This includes anonymous  inner classes.
com.sun.tools.javac.code.Symbol#isConstructor()->boolean:::Is this symbol a constructor?
com.sun.tools.javac.code.Symbol#getQualifiedName()->Name:::The fully qualified name of this symbol
com.sun.tools.javac.code.Symbol#flatName()->Name:::The fully qualified name of this symbol after converting to flat  representation
com.sun.tools.javac.code.Symbol#members()->WriteableScope:::If this is a class or package, its members, otherwise null.
com.sun.tools.javac.code.Symbol#isInner()->boolean:::A class is an inner class if it it has an enclosing instance class.
com.sun.tools.javac.code.Symbol#hasOuterInstance()->boolean:::An inner class has an outer instance if it is not an interface  it has an enclosing instance class which might be referenced from the class
com.sun.tools.javac.code.Symbol#enclClass()->ClassSymbol:::The closest enclosing class of this symbol's declaration
com.sun.tools.javac.code.Symbol#outermostClass()->ClassSymbol:::The outermost class which indirectly owns this symbol.
com.sun.tools.javac.code.Symbol#packge()->PackageSymbol:::The package which indirectly owns this symbol.
com.sun.tools.javac.code.Symbol#isSubClass(Symbol, Types)->boolean:::Is this symbol a subclass of `base'? Only defined for ClassSymbols.
com.sun.tools.javac.code.Symbol#isMemberOf(TypeSymbol, Types)->boolean:::Fully check membership: hierarchy, protection, and hiding
com.sun.tools.javac.code.Symbol#isEnclosedBy(ClassSymbol)->boolean:::Is this symbol the same as or enclosed by the given class?
com.sun.tools.javac.code.Symbol#isAccessibleIn(Symbol, Types)->boolean:::Is this symbol accessible in a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       the given class.
com.sun.tools.javac.code.Symbol#isInheritedIn(Symbol, Types)->boolean:::Is this symbol inherited into a given class?  PRE: If symbol's owner is a interface,       it is already assumed that the interface is a superinterface       of the given class.
com.sun.tools.javac.code.Symbol#asMemberOf(Type, Types)->Symbol:::The (variable or method) symbol seen as a member of given  class type`site' (this might change the symbol's type)
com.sun.tools.javac.code.Symbol#overrides(Symbol, TypeSymbol, Types, boolean)->boolean:::Does this method symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin
com.sun.tools.javac.code.Symbol#complete()->void:::Complete the elaboration of this symbol's definition.
com.sun.tools.javac.code.Symbol#apiComplete()->void::: symbol api complete
com.sun.tools.javac.code.Symbol#exists()->boolean:::True if the symbol represents an entity that exists.
com.sun.tools.javac.code.Symbol#asType()->Type::: symbol as type
com.sun.tools.javac.code.Symbol#getEnclosingElement()->Symbol::: symbol get enclosing element
com.sun.tools.javac.code.Symbol#getKind()->ElementKind::: symbol get kind
com.sun.tools.javac.code.Symbol#getModifiers()->Set::: symbol get modifiers
com.sun.tools.javac.code.Symbol#getSimpleName()->Name::: symbol get simple name
com.sun.tools.javac.code.Symbol#getAnnotationMirrors()->List:::This is the implementation for javax.lang.model.element.Element.getAnnotationMirrors().
com.sun.tools.javac.code.Symbol#getEnclosedElements()->java.util.List::: symbol get enclosed elements
com.sun.tools.javac.code.Symbol#getTypeParameters()->List::: symbol get type parameters
com.sun.tools.javac.code.Symbol.DelegatedSymbol#toString()->String::: delegated symbol to string
com.sun.tools.javac.code.Symbol.DelegatedSymbol#location()->Symbol::: delegated symbol location
com.sun.tools.javac.code.Symbol.DelegatedSymbol#location(Type, Types)->Symbol::: delegated symbol location
com.sun.tools.javac.code.Symbol.DelegatedSymbol#baseSymbol()->Symbol::: delegated symbol base symbol
com.sun.tools.javac.code.Symbol.DelegatedSymbol#erasure(Types)->Type::: delegated symbol erasure
com.sun.tools.javac.code.Symbol.DelegatedSymbol#externalType(Types)->Type::: delegated symbol external type
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isLocal()->boolean::: delegated symbol is local
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isConstructor()->boolean::: delegated symbol is constructor
com.sun.tools.javac.code.Symbol.DelegatedSymbol#getQualifiedName()->Name::: delegated symbol get qualified name
com.sun.tools.javac.code.Symbol.DelegatedSymbol#flatName()->Name::: delegated symbol flat name
com.sun.tools.javac.code.Symbol.DelegatedSymbol#members()->WriteableScope::: delegated symbol members
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isInner()->boolean::: delegated symbol is inner
com.sun.tools.javac.code.Symbol.DelegatedSymbol#hasOuterInstance()->boolean::: delegated symbol has outer instance
com.sun.tools.javac.code.Symbol.DelegatedSymbol#enclClass()->ClassSymbol::: delegated symbol encl class
com.sun.tools.javac.code.Symbol.DelegatedSymbol#outermostClass()->ClassSymbol::: delegated symbol outermost class
com.sun.tools.javac.code.Symbol.DelegatedSymbol#packge()->PackageSymbol::: delegated symbol packge
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isSubClass(Symbol, Types)->boolean::: delegated symbol is sub class
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isMemberOf(TypeSymbol, Types)->boolean::: delegated symbol is member of
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isEnclosedBy(ClassSymbol)->boolean::: delegated symbol is enclosed by
com.sun.tools.javac.code.Symbol.DelegatedSymbol#isInheritedIn(Symbol, Types)->boolean::: delegated symbol is inherited in
com.sun.tools.javac.code.Symbol.DelegatedSymbol#asMemberOf(Type, Types)->Symbol::: delegated symbol as member of
com.sun.tools.javac.code.Symbol.DelegatedSymbol#complete()->void::: delegated symbol complete
com.sun.tools.javac.code.Symbol.DelegatedSymbol#accept(ElementVisitor, P)->R::: delegated symbol accept
com.sun.tools.javac.code.Symbol.DelegatedSymbol#accept(Symbol.Visitor, P)->R::: delegated symbol accept
com.sun.tools.javac.code.Symbol.DelegatedSymbol#getUnderlyingSymbol()->T::: delegated symbol get underlying symbol
com.sun.tools.javac.code.Symbol.TypeSymbol#formFullName(Name, Symbol)->Name:::form a fully qualified name from a name and an owner
com.sun.tools.javac.code.Symbol.TypeSymbol#formFlatName(Name, Symbol)->Name:::form a fully qualified name from a name and an owner, after  converting to flat representation
com.sun.tools.javac.code.Symbol.TypeSymbol#precedes(TypeSymbol, Types)->boolean:::A partial ordering between type symbols that refines the class inheritance graph
com.sun.tools.javac.code.Symbol.TypeSymbol#getEnclosedElements()->java.util.List::: type symbol get enclosed elements
com.sun.tools.javac.code.Symbol.TypeSymbol#getAnnotationTypeMetadata()->AnnotationTypeMetadata::: type symbol get annotation type metadata
com.sun.tools.javac.code.Symbol.TypeSymbol#isAnnotationType()->boolean::: type symbol is annotation type
com.sun.tools.javac.code.Symbol.TypeSymbol#accept(Symbol.Visitor, P)->R::: type symbol accept
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#getKind()->ElementKind::: type variable symbol get kind
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#getGenericElement()->Symbol::: type variable symbol get generic element
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#getBounds()->List::: type variable symbol get bounds
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#getAnnotationMirrors()->List::: type variable symbol get annotation mirrors
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#getAttribute(Class)->Attribute.Compound::: type variable symbol get attribute
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#isCurrentSymbolsAnnotation(Attribute.TypeCompound, int)->boolean::: type variable symbol is current symbols annotation
com.sun.tools.javac.code.Symbol.TypeVariableSymbol#accept(ElementVisitor, P)->R::: type variable symbol accept
com.sun.tools.javac.code.Symbol.ModuleSymbol#create(Name, Name)->ModuleSymbol:::Create a ModuleSymbol with an associated module-info ClassSymbol.
com.sun.tools.javac.code.Symbol.ModuleSymbol#getSimpleName()->Name::: module symbol get simple name
com.sun.tools.javac.code.Symbol.ModuleSymbol#isOpen()->boolean::: module symbol is open
com.sun.tools.javac.code.Symbol.ModuleSymbol#isUnnamed()->boolean::: module symbol is unnamed
com.sun.tools.javac.code.Symbol.ModuleSymbol#isDeprecated()->boolean::: module symbol is deprecated
com.sun.tools.javac.code.Symbol.ModuleSymbol#isNoModule()->boolean::: module symbol is no module
com.sun.tools.javac.code.Symbol.ModuleSymbol#getKind()->ElementKind::: module symbol get kind
com.sun.tools.javac.code.Symbol.ModuleSymbol#getDirectives()->java.util.List::: module symbol get directives
com.sun.tools.javac.code.Symbol.ModuleSymbol#completeUsesProvides()->void::: module symbol complete uses provides
com.sun.tools.javac.code.Symbol.ModuleSymbol#outermostClass()->ClassSymbol::: module symbol outermost class
com.sun.tools.javac.code.Symbol.ModuleSymbol#toString()->String::: module symbol to string
com.sun.tools.javac.code.Symbol.ModuleSymbol#accept(ElementVisitor, P)->R::: module symbol accept
com.sun.tools.javac.code.Symbol.ModuleSymbol#getEnclosedElements()->List::: module symbol get enclosed elements
com.sun.tools.javac.code.Symbol.ModuleSymbol#reset()->void::: module symbol reset
com.sun.tools.javac.code.Symbol.PackageSymbol#toString()->String::: package symbol to string
com.sun.tools.javac.code.Symbol.PackageSymbol#getQualifiedName()->Name::: package symbol get qualified name
com.sun.tools.javac.code.Symbol.PackageSymbol#isUnnamed()->boolean::: package symbol is unnamed
com.sun.tools.javac.code.Symbol.PackageSymbol#members()->WriteableScope::: package symbol members
com.sun.tools.javac.code.Symbol.PackageSymbol#flags()->long::: package symbol flags
com.sun.tools.javac.code.Symbol.PackageSymbol#getRawAttributes()->List::: package symbol get raw attributes
com.sun.tools.javac.code.Symbol.PackageSymbol#exists()->boolean:::A package "exists" if a type or package that exists has  been seen within it.
com.sun.tools.javac.code.Symbol.PackageSymbol#getKind()->ElementKind::: package symbol get kind
com.sun.tools.javac.code.Symbol.PackageSymbol#getEnclosingElement()->Symbol::: package symbol get enclosing element
com.sun.tools.javac.code.Symbol.PackageSymbol#accept(ElementVisitor, P)->R::: package symbol accept
com.sun.tools.javac.code.Symbol.PackageSymbol#accept(Symbol.Visitor, P)->R::: package symbol accept
com.sun.tools.javac.code.Symbol.PackageSymbol#reset()->void:::Resets the Symbol into the state good for next round of annotation processing.
com.sun.tools.javac.code.Symbol.ClassSymbol#toString()->String:::The Java source which this symbol represents.
com.sun.tools.javac.code.Symbol.ClassSymbol#flags()->long::: class symbol flags
com.sun.tools.javac.code.Symbol.ClassSymbol#members()->WriteableScope::: class symbol members
com.sun.tools.javac.code.Symbol.ClassSymbol#getRawAttributes()->List::: class symbol get raw attributes
com.sun.tools.javac.code.Symbol.ClassSymbol#getRawTypeAttributes()->List::: class symbol get raw type attributes
com.sun.tools.javac.code.Symbol.ClassSymbol#erasure(Types)->Type::: class symbol erasure
com.sun.tools.javac.code.Symbol.ClassSymbol#className()->String::: class symbol class name
com.sun.tools.javac.code.Symbol.ClassSymbol#getQualifiedName()->Name::: class symbol get qualified name
com.sun.tools.javac.code.Symbol.ClassSymbol#flatName()->Name::: class symbol flat name
com.sun.tools.javac.code.Symbol.ClassSymbol#isSubClass(Symbol, Types)->boolean::: class symbol is sub class
com.sun.tools.javac.code.Symbol.ClassSymbol#complete()->void:::Complete the elaboration of this symbol's definition.
com.sun.tools.javac.code.Symbol.ClassSymbol#getInterfaces()->List::: class symbol get interfaces
com.sun.tools.javac.code.Symbol.ClassSymbol#getSuperclass()->Type::: class symbol get superclass
com.sun.tools.javac.code.Symbol.ClassSymbol#getInheritedAnnotations(Class)->A[]::: class symbol get inherited annotations
com.sun.tools.javac.code.Symbol.ClassSymbol#getKind()->ElementKind::: class symbol get kind
com.sun.tools.javac.code.Symbol.ClassSymbol#getModifiers()->Set::: class symbol get modifiers
com.sun.tools.javac.code.Symbol.ClassSymbol#getNestingKind()->NestingKind::: class symbol get nesting kind
com.sun.tools.javac.code.Symbol.ClassSymbol#getAttribute(Class)->Attribute.Compound::: class symbol get attribute
com.sun.tools.javac.code.Symbol.ClassSymbol#accept(ElementVisitor, P)->R::: class symbol accept
com.sun.tools.javac.code.Symbol.ClassSymbol#accept(Symbol.Visitor, P)->R::: class symbol accept
com.sun.tools.javac.code.Symbol.ClassSymbol#markAbstractIfNeeded(Types)->void::: class symbol mark abstract if needed
com.sun.tools.javac.code.Symbol.ClassSymbol#reset()->void:::Resets the Symbol into the state good for next round of annotation processing.
com.sun.tools.javac.code.Symbol.ClassSymbol#clearAnnotationMetadata()->void::: class symbol clear annotation metadata
com.sun.tools.javac.code.Symbol.ClassSymbol#getAnnotationTypeMetadata()->AnnotationTypeMetadata::: class symbol get annotation type metadata
com.sun.tools.javac.code.Symbol.ClassSymbol#isAnnotationType()->boolean::: class symbol is annotation type
com.sun.tools.javac.code.Symbol.ClassSymbol#setAnnotationTypeMetadata(AnnotationTypeMetadata)->void::: class symbol set annotation type metadata
com.sun.tools.javac.code.Symbol.VarSymbol#clone(Symbol)->VarSymbol:::Clone this symbol with new owner.
com.sun.tools.javac.code.Symbol.VarSymbol#toString()->String::: var symbol to string
com.sun.tools.javac.code.Symbol.VarSymbol#asMemberOf(Type, Types)->Symbol::: var symbol as member of
com.sun.tools.javac.code.Symbol.VarSymbol#getKind()->ElementKind::: var symbol get kind
com.sun.tools.javac.code.Symbol.VarSymbol#accept(ElementVisitor, P)->R::: var symbol accept
com.sun.tools.javac.code.Symbol.VarSymbol#getConstantValue()->Object::: var symbol get constant value
com.sun.tools.javac.code.Symbol.VarSymbol#setLazyConstValue(Env, Attr, JCVariableDecl)->void::: var symbol set lazy const value
com.sun.tools.javac.code.Symbol.VarSymbol#isExceptionParameter()->boolean::: var symbol is exception parameter
com.sun.tools.javac.code.Symbol.VarSymbol#isResourceVariable()->boolean::: var symbol is resource variable
com.sun.tools.javac.code.Symbol.VarSymbol#getConstValue()->Object::: var symbol get const value
com.sun.tools.javac.code.Symbol.VarSymbol#setData(Object)->void::: var symbol set data
com.sun.tools.javac.code.Symbol.VarSymbol#accept(Symbol.Visitor, P)->R::: var symbol accept
com.sun.tools.javac.code.Symbol.MethodSymbol#clone(Symbol)->MethodSymbol:::Clone this symbol with new owner.
com.sun.tools.javac.code.Symbol.MethodSymbol#getModifiers()->Set::: method symbol get modifiers
com.sun.tools.javac.code.Symbol.MethodSymbol#toString()->String:::The Java source which this symbol represents.
com.sun.tools.javac.code.Symbol.MethodSymbol#isDynamic()->boolean::: method symbol is dynamic
com.sun.tools.javac.code.Symbol.MethodSymbol#implemented(TypeSymbol, Types)->Symbol:::find a symbol that this (proxy method) symbol implements.
com.sun.tools.javac.code.Symbol.MethodSymbol#implementedIn(TypeSymbol, Types)->Symbol::: method symbol implemented in
com.sun.tools.javac.code.Symbol.MethodSymbol#binaryOverrides(Symbol, TypeSymbol, Types)->boolean:::Will the erasure of this method be considered by the VM to  override the erasure of the other when seen from class `origin'?
com.sun.tools.javac.code.Symbol.MethodSymbol#binaryImplementation(ClassSymbol, Types)->MethodSymbol:::The implementation of this (abstract) symbol in class origin,  from the VM's point of view, null if method does not have an  implementation in class.
com.sun.tools.javac.code.Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean)->boolean:::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin
com.sun.tools.javac.code.Symbol.MethodSymbol#overrides(Symbol, TypeSymbol, Types, boolean, boolean)->boolean:::Does this symbol override `other' symbol, when both are seen as  members of class `origin'?  It is assumed that _other is a member  of origin
com.sun.tools.javac.code.Symbol.MethodSymbol#isInheritedIn(Symbol, Types)->boolean::: method symbol is inherited in
com.sun.tools.javac.code.Symbol.MethodSymbol#isLambdaMethod()->boolean::: method symbol is lambda method
com.sun.tools.javac.code.Symbol.MethodSymbol#implementation(TypeSymbol, Types, boolean)->MethodSymbol:::The implementation of this (abstract) symbol in class origin;  null if none exists
com.sun.tools.javac.code.Symbol.MethodSymbol#implementation(TypeSymbol, Types, boolean, Filter)->MethodSymbol::: method symbol implementation
com.sun.tools.javac.code.Symbol.MethodSymbol#params()->List::: method symbol params
com.sun.tools.javac.code.Symbol.MethodSymbol#asMemberOf(Type, Types)->Symbol::: method symbol as member of
com.sun.tools.javac.code.Symbol.MethodSymbol#getKind()->ElementKind::: method symbol get kind
com.sun.tools.javac.code.Symbol.MethodSymbol#isStaticOrInstanceInit()->boolean::: method symbol is static or instance init
com.sun.tools.javac.code.Symbol.MethodSymbol#getDefaultValue()->Attribute::: method symbol get default value
com.sun.tools.javac.code.Symbol.MethodSymbol#getParameters()->List::: method symbol get parameters
com.sun.tools.javac.code.Symbol.MethodSymbol#isVarArgs()->boolean::: method symbol is var args
com.sun.tools.javac.code.Symbol.MethodSymbol#isDefault()->boolean::: method symbol is default
com.sun.tools.javac.code.Symbol.MethodSymbol#accept(ElementVisitor, P)->R::: method symbol accept
com.sun.tools.javac.code.Symbol.MethodSymbol#accept(Symbol.Visitor, P)->R::: method symbol accept
com.sun.tools.javac.code.Symbol.MethodSymbol#getReceiverType()->Type::: method symbol get receiver type
com.sun.tools.javac.code.Symbol.MethodSymbol#getReturnType()->Type::: method symbol get return type
com.sun.tools.javac.code.Symbol.MethodSymbol#getThrownTypes()->List::: method symbol get thrown types
com.sun.tools.javac.code.Symbol.DynamicMethodSymbol#isDynamic()->boolean::: dynamic method symbol is dynamic
com.sun.tools.javac.code.Symbol.OperatorSymbol#accept(Symbol.Visitor, P)->R::: operator symbol accept
com.sun.tools.javac.code.Symbol.OperatorSymbol#getAccessCode(Tag)->int::: operator symbol get access code
com.sun.tools.javac.code.Symbol.Completer#complete(Symbol)->void::: completer complete
com.sun.tools.javac.code.Symbol.Completer#isTerminal()->boolean:::Returns true if this completer is terminal
com.sun.tools.javac.code.Symbol.CompletionFailure#getDiagnostic()->JCDiagnostic::: completion failure get diagnostic
com.sun.tools.javac.code.Symbol.CompletionFailure#getMessage()->String::: completion failure get message
com.sun.tools.javac.code.Symbol.CompletionFailure#getDetailValue()->JCDiagnostic::: completion failure get detail value
com.sun.tools.javac.code.Symbol.CompletionFailure#initCause(Throwable)->CompletionFailure::: completion failure init cause
com.sun.tools.javac.code.Symbol.Visitor#visitClassSymbol(ClassSymbol, P)->R::: visitor visit class symbol
com.sun.tools.javac.code.Symbol.Visitor#visitMethodSymbol(MethodSymbol, P)->R::: visitor visit method symbol
com.sun.tools.javac.code.Symbol.Visitor#visitPackageSymbol(PackageSymbol, P)->R::: visitor visit package symbol
com.sun.tools.javac.code.Symbol.Visitor#visitOperatorSymbol(OperatorSymbol, P)->R::: visitor visit operator symbol
com.sun.tools.javac.code.Symbol.Visitor#visitVarSymbol(VarSymbol, P)->R::: visitor visit var symbol
com.sun.tools.javac.code.Symbol.Visitor#visitTypeSymbol(TypeSymbol, P)->R::: visitor visit type symbol
com.sun.tools.javac.code.Symbol.Visitor#visitSymbol(Symbol, P)->R::: visitor visit symbol
com.sun.tools.javac.code.SymbolMetadata#getDeclarationAttributes()->List::: symbol metadata get declaration attributes
com.sun.tools.javac.code.SymbolMetadata#getTypeAttributes()->List::: symbol metadata get type attributes
com.sun.tools.javac.code.SymbolMetadata#getInitTypeAttributes()->List::: symbol metadata get init type attributes
com.sun.tools.javac.code.SymbolMetadata#getClassInitTypeAttributes()->List::: symbol metadata get class init type attributes
com.sun.tools.javac.code.SymbolMetadata#setDeclarationAttributes(List)->void::: symbol metadata set declaration attributes
com.sun.tools.javac.code.SymbolMetadata#setTypeAttributes(List)->void::: symbol metadata set type attributes
com.sun.tools.javac.code.SymbolMetadata#setInitTypeAttributes(List)->void::: symbol metadata set init type attributes
com.sun.tools.javac.code.SymbolMetadata#setClassInitTypeAttributes(List)->void::: symbol metadata set class init type attributes
com.sun.tools.javac.code.SymbolMetadata#setAttributes(SymbolMetadata)->void::: symbol metadata set attributes
com.sun.tools.javac.code.SymbolMetadata#reset()->SymbolMetadata::: symbol metadata reset
com.sun.tools.javac.code.SymbolMetadata#isEmpty()->boolean::: symbol metadata is empty
com.sun.tools.javac.code.SymbolMetadata#isTypesEmpty()->boolean::: symbol metadata is types empty
com.sun.tools.javac.code.SymbolMetadata#pendingCompletion()->boolean::: symbol metadata pending completion
com.sun.tools.javac.code.SymbolMetadata#append(List)->SymbolMetadata::: symbol metadata append
com.sun.tools.javac.code.SymbolMetadata#appendUniqueTypes(List)->SymbolMetadata::: symbol metadata append unique types
com.sun.tools.javac.code.SymbolMetadata#appendInitTypeAttributes(List)->SymbolMetadata::: symbol metadata append init type attributes
com.sun.tools.javac.code.SymbolMetadata#appendClassInitTypeAttributes(List)->SymbolMetadata::: symbol metadata append class init type attributes
com.sun.tools.javac.code.SymbolMetadata#prepend(List)->SymbolMetadata::: symbol metadata prepend
com.sun.tools.javac.code.Symtab#instance(Context)->Symtab:::Get the symbol table instance.
com.sun.tools.javac.code.Symtab#getClassField(Type, Types)->VarSymbol::: symtab get class field
com.sun.tools.javac.code.Symtab#initType(Type, ClassSymbol)->void::: symtab init type
com.sun.tools.javac.code.Symtab#initType(Type, String)->void::: symtab init type
com.sun.tools.javac.code.Symtab#initType(Type, String, String)->void::: symtab init type
com.sun.tools.javac.code.Symtab#synthesizeEmptyInterfaceIfMissing(Type)->void::: symtab synthesize empty interface if missing
com.sun.tools.javac.code.Symtab#synthesizeBoxTypeIfMissing(Type)->void::: symtab synthesize box type if missing
com.sun.tools.javac.code.Symtab#defineClass(Name, Symbol)->ClassSymbol:::Define a new class given its name and owner.
com.sun.tools.javac.code.Symtab#enterClass(ModuleSymbol, Name, TypeSymbol)->ClassSymbol:::Create a new toplevel or member class symbol with given name  and owner and enter in `classes' unless already there.
com.sun.tools.javac.code.Symtab#getClass(ModuleSymbol, Name)->ClassSymbol::: symtab get class
com.sun.tools.javac.code.Symtab#lookupPackage(ModuleSymbol, Name)->PackageSymbol::: symtab lookup package
com.sun.tools.javac.code.Symtab#removeClass(ModuleSymbol, Name)->void::: symtab remove class
com.sun.tools.javac.code.Symtab#getAllClasses()->Iterable::: symtab get all classes
com.sun.tools.javac.code.Symtab#enterClass(ModuleSymbol, Name)->ClassSymbol:::Create a new member or toplevel class symbol with given flat name  and enter in `classes' unless already there.
com.sun.tools.javac.code.Symtab#packageExists(ModuleSymbol, Name)->boolean:::Check to see if a package exists, given its fully qualified name.
com.sun.tools.javac.code.Symtab#enterPackage(ModuleSymbol, Name)->PackageSymbol:::Make a package, given its fully qualified name.
com.sun.tools.javac.code.Symtab#getPackage(ModuleSymbol, Name)->PackageSymbol::: symtab get package
com.sun.tools.javac.code.Symtab#enterModule(Name)->ModuleSymbol::: symtab enter module
com.sun.tools.javac.code.Symtab#getModule(Name)->ModuleSymbol::: symtab get module
com.sun.tools.javac.code.Symtab#inferModule(Name)->ModuleSymbol::: symtab infer module
com.sun.tools.javac.code.Symtab#listPackageModules(Name)->List::: symtab list package modules
com.sun.tools.javac.code.Symtab#getAllModules()->Collection::: symtab get all modules
com.sun.tools.javac.code.Symtab#getClassesForName(Name)->Iterable::: symtab get classes for name
com.sun.tools.javac.code.Symtab#getPackagesForName(Name)->Iterable::: symtab get packages for name
com.sun.tools.javac.code.Type#getMetadata()->TypeMetadata::: type get metadata
com.sun.tools.javac.code.Type#getMetadataOfKind(Entry.Kind)->Entry::: type get metadata of kind
com.sun.tools.javac.code.Type#hasTag(TypeTag)->boolean:::Checks if the current type tag is equal to the given tag.
com.sun.tools.javac.code.Type#getTag()->TypeTag:::Returns the current type tag.
com.sun.tools.javac.code.Type#isNumeric()->boolean::: type is numeric
com.sun.tools.javac.code.Type#isIntegral()->boolean::: type is integral
com.sun.tools.javac.code.Type#isPrimitive()->boolean::: type is primitive
com.sun.tools.javac.code.Type#isPrimitiveOrVoid()->boolean::: type is primitive or void
com.sun.tools.javac.code.Type#isReference()->boolean::: type is reference
com.sun.tools.javac.code.Type#isNullOrReference()->boolean::: type is null or reference
com.sun.tools.javac.code.Type#isPartial()->boolean::: type is partial
com.sun.tools.javac.code.Type#constValue()->Object:::The constant value of this type, null if this type does not have a constant value attribute
com.sun.tools.javac.code.Type#isFalse()->boolean:::Is this a constant type whose value is false?
com.sun.tools.javac.code.Type#isTrue()->boolean:::Is this a constant type whose value is true?
com.sun.tools.javac.code.Type#getModelType()->Type:::Get the representation of this type used for modelling purposes
com.sun.tools.javac.code.Type#getModelTypes(List)->List::: type get model types
com.sun.tools.javac.code.Type#getOriginalType()->Type:::For ErrorType, returns the original type, otherwise returns the type itself.
com.sun.tools.javac.code.Type#accept(Type.Visitor, S)->R::: type accept
com.sun.tools.javac.code.Type.StructuralTypeMapping#visitClassType(ClassType, S)->Type::: structural type mapping visit class type
com.sun.tools.javac.code.Type.StructuralTypeMapping#visitWildcardType(WildcardType, S)->Type::: structural type mapping visit wildcard type
com.sun.tools.javac.code.Type.StructuralTypeMapping#visitArrayType(ArrayType, S)->Type::: structural type mapping visit array type
com.sun.tools.javac.code.Type.StructuralTypeMapping#visitMethodType(MethodType, S)->Type::: structural type mapping visit method type
com.sun.tools.javac.code.Type.StructuralTypeMapping#visitForAll(ForAll, S)->Type::: structural type mapping visit for all
com.sun.tools.javac.code.Type#map(TypeMapping, Z)->Type:::map a type function over all immediate descendants of this type
com.sun.tools.javac.code.Type#map(TypeMapping)->Type:::map a type function over all immediate descendants of this type (no arg version)
com.sun.tools.javac.code.Type#constType(Object)->Type:::Define a constant type, of the same kind as this type  and with given constant value
com.sun.tools.javac.code.Type#baseType()->Type:::If this is a constant type, return its underlying type
com.sun.tools.javac.code.Type#typeNoMetadata()->Type:::Returns the original version of this type, before metadata were added
com.sun.tools.javac.code.Type#cloneWithMetadata(TypeMetadata)->Type:::Create a new copy of this type but with the specified TypeMetadata.
com.sun.tools.javac.code.Type#needsStripping()->boolean:::Does this type require annotation stripping for API clients?
com.sun.tools.javac.code.Type#stripMetadataIfNeeded()->Type:::Strip all metadata associated with this type - this could return a new clone of the type
com.sun.tools.javac.code.Type#stripMetadata()->Type::: type strip metadata
com.sun.tools.javac.code.Type#annotatedType(List)->Type::: type annotated type
com.sun.tools.javac.code.Type#isAnnotated()->boolean::: type is annotated
com.sun.tools.javac.code.Type#getAnnotationMirrors()->List::: type get annotation mirrors
com.sun.tools.javac.code.Type#getAnnotation(Class)->A::: type get annotation
com.sun.tools.javac.code.Type#getAnnotationsByType(Class)->A[]::: type get annotations by type
com.sun.tools.javac.code.Type#baseTypes(List)->List:::Return the base types of a list of types.
com.sun.tools.javac.code.Type#appendAnnotationsString(StringBuilder, boolean)->void::: type append annotations string
com.sun.tools.javac.code.Type#appendAnnotationsString(StringBuilder)->void::: type append annotations string
com.sun.tools.javac.code.Type#toString()->String:::The Java source which this type represents.
com.sun.tools.javac.code.Type#toString(List)->String:::The Java source which this type list represents
com.sun.tools.javac.code.Type#stringValue()->String:::The constant value of this type, converted to String
com.sun.tools.javac.code.Type#equals(Object)->boolean:::Override this method with care
com.sun.tools.javac.code.Type#equalsIgnoreMetadata(Type)->boolean::: type equals ignore metadata
com.sun.tools.javac.code.Type#hashCode()->int::: type hash code
com.sun.tools.javac.code.Type#argtypes(boolean)->String::: type argtypes
com.sun.tools.javac.code.Type#getTypeArguments()->List:::Access methods.
com.sun.tools.javac.code.Type#getEnclosingType()->Type::: type get enclosing type
com.sun.tools.javac.code.Type#getParameterTypes()->List::: type get parameter types
com.sun.tools.javac.code.Type#getReturnType()->Type::: type get return type
com.sun.tools.javac.code.Type#getReceiverType()->Type::: type get receiver type
com.sun.tools.javac.code.Type#getThrownTypes()->List::: type get thrown types
com.sun.tools.javac.code.Type#getUpperBound()->Type::: type get upper bound
com.sun.tools.javac.code.Type#getLowerBound()->Type::: type get lower bound
com.sun.tools.javac.code.Type#allparams()->List:::Return all parameters of this type and all its outer types in order  outer (first) to inner (last).
com.sun.tools.javac.code.Type#isErroneous()->boolean:::Does this type contain "error" elements?
com.sun.tools.javac.code.Type#isErroneous(List)->boolean::: type is erroneous
com.sun.tools.javac.code.Type#isParameterized()->boolean:::Is this type parameterized?  A class type is parameterized if it has some parameters
com.sun.tools.javac.code.Type#isRaw()->boolean:::Is this type a raw type?  A class type is a raw type if it misses some of its parameters
com.sun.tools.javac.code.Type#isCompound()->boolean:::A compound type is a special class type whose supertypes are used to store a list of component types
com.sun.tools.javac.code.Type#isIntersection()->boolean::: type is intersection
com.sun.tools.javac.code.Type#isUnion()->boolean::: type is union
com.sun.tools.javac.code.Type#isInterface()->boolean::: type is interface
com.sun.tools.javac.code.Type#isFinal()->boolean::: type is final
com.sun.tools.javac.code.Type#contains(Type)->boolean:::Does this type contain occurrences of type t?
com.sun.tools.javac.code.Type#contains(List, Type)->boolean::: type contains
com.sun.tools.javac.code.Type#containsAny(List)->boolean:::Does this type contain an occurrence of some type in 'ts'?
com.sun.tools.javac.code.Type#containsAny(List, List)->boolean::: type contains any
com.sun.tools.javac.code.Type#filter(List, Filter)->List::: type filter
com.sun.tools.javac.code.Type#isSuperBound()->boolean::: type is super bound
com.sun.tools.javac.code.Type#isExtendsBound()->boolean::: type is extends bound
com.sun.tools.javac.code.Type#isUnbound()->boolean::: type is unbound
com.sun.tools.javac.code.Type#withTypeVar(Type)->Type::: type with type var
com.sun.tools.javac.code.Type#asMethodType()->MethodType:::The underlying method type of this type.
com.sun.tools.javac.code.Type#complete()->void:::Complete loading all classes in this type.
com.sun.tools.javac.code.Type#asElement()->TypeSymbol::: type as element
com.sun.tools.javac.code.Type#getKind()->TypeKind::: type get kind
com.sun.tools.javac.code.Type#accept(TypeVisitor, P)->R::: type accept
com.sun.tools.javac.code.Type.JCPrimitiveType#cloneWithMetadata(TypeMetadata)->JCPrimitiveType::: primitive type clone with metadata
com.sun.tools.javac.code.Type.JCPrimitiveType#isNumeric()->boolean::: primitive type is numeric
com.sun.tools.javac.code.Type.JCPrimitiveType#isIntegral()->boolean::: primitive type is integral
com.sun.tools.javac.code.Type.JCPrimitiveType#isPrimitive()->boolean::: primitive type is primitive
com.sun.tools.javac.code.Type.JCPrimitiveType#getTag()->TypeTag::: primitive type get tag
com.sun.tools.javac.code.Type.JCPrimitiveType#isPrimitiveOrVoid()->boolean::: primitive type is primitive or void
com.sun.tools.javac.code.Type.JCPrimitiveType#constType(Object)->Type:::Define a constant type, of the same kind as this type  and with given constant value
com.sun.tools.javac.code.Type.JCPrimitiveType#stringValue()->String:::The constant value of this type, converted to String
com.sun.tools.javac.code.Type.JCPrimitiveType#isFalse()->boolean:::Is this a constant type whose value is false?
com.sun.tools.javac.code.Type.JCPrimitiveType#isTrue()->boolean:::Is this a constant type whose value is true?
com.sun.tools.javac.code.Type.JCPrimitiveType#accept(TypeVisitor, P)->R::: primitive type accept
com.sun.tools.javac.code.Type.JCPrimitiveType#getKind()->TypeKind::: primitive type get kind
com.sun.tools.javac.code.Type.WildcardType#accept(Type.Visitor, S)->R::: wildcard type accept
com.sun.tools.javac.code.Type.WildcardType#cloneWithMetadata(TypeMetadata)->WildcardType::: wildcard type clone with metadata
com.sun.tools.javac.code.Type.WildcardType#getTag()->TypeTag::: wildcard type get tag
com.sun.tools.javac.code.Type.WildcardType#contains(Type)->boolean::: wildcard type contains
com.sun.tools.javac.code.Type.WildcardType#isSuperBound()->boolean::: wildcard type is super bound
com.sun.tools.javac.code.Type.WildcardType#isExtendsBound()->boolean::: wildcard type is extends bound
com.sun.tools.javac.code.Type.WildcardType#isUnbound()->boolean::: wildcard type is unbound
com.sun.tools.javac.code.Type.WildcardType#isReference()->boolean::: wildcard type is reference
com.sun.tools.javac.code.Type.WildcardType#isNullOrReference()->boolean::: wildcard type is null or reference
com.sun.tools.javac.code.Type.WildcardType#withTypeVar(Type)->Type::: wildcard type with type var
com.sun.tools.javac.code.Type.WildcardType#toString()->String::: wildcard type to string
com.sun.tools.javac.code.Type.WildcardType#getExtendsBound()->Type::: wildcard type get extends bound
com.sun.tools.javac.code.Type.WildcardType#getSuperBound()->Type::: wildcard type get super bound
com.sun.tools.javac.code.Type.WildcardType#getKind()->TypeKind::: wildcard type get kind
com.sun.tools.javac.code.Type.WildcardType#accept(TypeVisitor, P)->R::: wildcard type accept
com.sun.tools.javac.code.Type.ClassType#cloneWithMetadata(TypeMetadata)->ClassType::: class type clone with metadata
com.sun.tools.javac.code.Type.ClassType#getTag()->TypeTag::: class type get tag
com.sun.tools.javac.code.Type.ClassType#accept(Type.Visitor, S)->R::: class type accept
com.sun.tools.javac.code.Type.ClassType#constType(Object)->Type::: class type const type
com.sun.tools.javac.code.Type.ClassType#toString()->String:::The Java source which this type represents.
com.sun.tools.javac.code.Type.ClassType#getTypeArguments()->List::: class type get type arguments
com.sun.tools.javac.code.Type.ClassType#hasErasedSupertypes()->boolean::: class type has erased supertypes
com.sun.tools.javac.code.Type.ClassType#getEnclosingType()->Type::: class type get enclosing type
com.sun.tools.javac.code.Type.ClassType#setEnclosingType(Type)->void::: class type set enclosing type
com.sun.tools.javac.code.Type.ClassType#allparams()->List::: class type allparams
com.sun.tools.javac.code.Type.ClassType#isErroneous()->boolean::: class type is erroneous
com.sun.tools.javac.code.Type.ClassType#isParameterized()->boolean::: class type is parameterized
com.sun.tools.javac.code.Type.ClassType#isReference()->boolean::: class type is reference
com.sun.tools.javac.code.Type.ClassType#isNullOrReference()->boolean::: class type is null or reference
com.sun.tools.javac.code.Type.ClassType#isRaw()->boolean:::A class type is raw if it misses some  of its type parameter sections
com.sun.tools.javac.code.Type.ClassType#contains(Type)->boolean::: class type contains
com.sun.tools.javac.code.Type.ClassType#complete()->void::: class type complete
com.sun.tools.javac.code.Type.ClassType#getKind()->TypeKind::: class type get kind
com.sun.tools.javac.code.Type.ClassType#accept(TypeVisitor, P)->R::: class type accept
com.sun.tools.javac.code.Type.ErasedClassType#hasErasedSupertypes()->boolean::: erased class type has erased supertypes
com.sun.tools.javac.code.Type.UnionClassType#cloneWithMetadata(TypeMetadata)->UnionClassType::: union class type clone with metadata
com.sun.tools.javac.code.Type.UnionClassType#getLub()->Type::: union class type get lub
com.sun.tools.javac.code.Type.UnionClassType#getAlternatives()->java.util.List::: union class type get alternatives
com.sun.tools.javac.code.Type.UnionClassType#isUnion()->boolean::: union class type is union
com.sun.tools.javac.code.Type.UnionClassType#isCompound()->boolean::: union class type is compound
com.sun.tools.javac.code.Type.UnionClassType#getKind()->TypeKind::: union class type get kind
com.sun.tools.javac.code.Type.UnionClassType#accept(TypeVisitor, P)->R::: union class type accept
com.sun.tools.javac.code.Type.UnionClassType#getAlternativeTypes()->Iterable::: union class type get alternative types
com.sun.tools.javac.code.Type.IntersectionClassType#cloneWithMetadata(TypeMetadata)->IntersectionClassType::: intersection class type clone with metadata
com.sun.tools.javac.code.Type.IntersectionClassType#getBounds()->java.util.List::: intersection class type get bounds
com.sun.tools.javac.code.Type.IntersectionClassType#isCompound()->boolean::: intersection class type is compound
com.sun.tools.javac.code.Type.IntersectionClassType#getComponents()->List::: intersection class type get components
com.sun.tools.javac.code.Type.IntersectionClassType#isIntersection()->boolean::: intersection class type is intersection
com.sun.tools.javac.code.Type.IntersectionClassType#getExplicitComponents()->List::: intersection class type get explicit components
com.sun.tools.javac.code.Type.IntersectionClassType#getKind()->TypeKind::: intersection class type get kind
com.sun.tools.javac.code.Type.IntersectionClassType#accept(TypeVisitor, P)->R::: intersection class type accept
com.sun.tools.javac.code.Type.ArrayType#cloneWithMetadata(TypeMetadata)->ArrayType::: array type clone with metadata
com.sun.tools.javac.code.Type.ArrayType#getTag()->TypeTag::: array type get tag
com.sun.tools.javac.code.Type.ArrayType#accept(Type.Visitor, S)->R::: array type accept
com.sun.tools.javac.code.Type.ArrayType#toString()->String::: array type to string
com.sun.tools.javac.code.Type.ArrayType#equals(Object)->boolean::: array type equals
com.sun.tools.javac.code.Type.ArrayType#hashCode()->int::: array type hash code
com.sun.tools.javac.code.Type.ArrayType#isVarargs()->boolean::: array type is varargs
com.sun.tools.javac.code.Type.ArrayType#allparams()->List::: array type allparams
com.sun.tools.javac.code.Type.ArrayType#isErroneous()->boolean::: array type is erroneous
com.sun.tools.javac.code.Type.ArrayType#isParameterized()->boolean::: array type is parameterized
com.sun.tools.javac.code.Type.ArrayType#isReference()->boolean::: array type is reference
com.sun.tools.javac.code.Type.ArrayType#isNullOrReference()->boolean::: array type is null or reference
com.sun.tools.javac.code.Type.ArrayType#isRaw()->boolean::: array type is raw
com.sun.tools.javac.code.Type.ArrayType#makeVarargs()->ArrayType::: array type make varargs
com.sun.tools.javac.code.Type.ArrayType#contains(Type)->boolean::: array type contains
com.sun.tools.javac.code.Type.ArrayType#complete()->void::: array type complete
com.sun.tools.javac.code.Type.ArrayType#getComponentType()->Type::: array type get component type
com.sun.tools.javac.code.Type.ArrayType#getKind()->TypeKind::: array type get kind
com.sun.tools.javac.code.Type.ArrayType#accept(TypeVisitor, P)->R::: array type accept
com.sun.tools.javac.code.Type.MethodType#cloneWithMetadata(TypeMetadata)->MethodType::: method type clone with metadata
com.sun.tools.javac.code.Type.MethodType#getTag()->TypeTag::: method type get tag
com.sun.tools.javac.code.Type.MethodType#accept(Type.Visitor, S)->R::: method type accept
com.sun.tools.javac.code.Type.MethodType#toString()->String:::The Java source which this type represents
com.sun.tools.javac.code.Type.MethodType#getParameterTypes()->List::: method type get parameter types
com.sun.tools.javac.code.Type.MethodType#getReturnType()->Type::: method type get return type
com.sun.tools.javac.code.Type.MethodType#getReceiverType()->Type::: method type get receiver type
com.sun.tools.javac.code.Type.MethodType#getThrownTypes()->List::: method type get thrown types
com.sun.tools.javac.code.Type.MethodType#isErroneous()->boolean::: method type is erroneous
com.sun.tools.javac.code.Type.MethodType#contains(Type)->boolean::: method type contains
com.sun.tools.javac.code.Type.MethodType#asMethodType()->MethodType::: method type as method type
com.sun.tools.javac.code.Type.MethodType#complete()->void::: method type complete
com.sun.tools.javac.code.Type.MethodType#getTypeVariables()->List::: method type get type variables
com.sun.tools.javac.code.Type.MethodType#asElement()->TypeSymbol::: method type as element
com.sun.tools.javac.code.Type.MethodType#getKind()->TypeKind::: method type get kind
com.sun.tools.javac.code.Type.MethodType#accept(TypeVisitor, P)->R::: method type accept
com.sun.tools.javac.code.Type.PackageType#cloneWithMetadata(TypeMetadata)->PackageType::: package type clone with metadata
com.sun.tools.javac.code.Type.PackageType#getTag()->TypeTag::: package type get tag
com.sun.tools.javac.code.Type.PackageType#accept(Type.Visitor, S)->R::: package type accept
com.sun.tools.javac.code.Type.PackageType#toString()->String::: package type to string
com.sun.tools.javac.code.Type.PackageType#getKind()->TypeKind::: package type get kind
com.sun.tools.javac.code.Type.PackageType#accept(TypeVisitor, P)->R::: package type accept
com.sun.tools.javac.code.Type.ModuleType#cloneWithMetadata(TypeMetadata)->ModuleType::: module type clone with metadata
com.sun.tools.javac.code.Type.ModuleType#annotatedType(List)->ModuleType::: module type annotated type
com.sun.tools.javac.code.Type.ModuleType#getTag()->TypeTag::: module type get tag
com.sun.tools.javac.code.Type.ModuleType#accept(Type.Visitor, S)->R::: module type accept
com.sun.tools.javac.code.Type.ModuleType#toString()->String::: module type to string
com.sun.tools.javac.code.Type.ModuleType#getKind()->TypeKind::: module type get kind
com.sun.tools.javac.code.Type.ModuleType#accept(TypeVisitor, P)->R::: module type accept
com.sun.tools.javac.code.Type.TypeVar#cloneWithMetadata(TypeMetadata)->TypeVar::: type var clone with metadata
com.sun.tools.javac.code.Type.TypeVar#getTag()->TypeTag::: type var get tag
com.sun.tools.javac.code.Type.TypeVar#accept(Type.Visitor, S)->R::: type var accept
com.sun.tools.javac.code.Type.TypeVar#getUpperBound()->Type::: type var get upper bound
com.sun.tools.javac.code.Type.TypeVar#getLowerBound()->Type::: type var get lower bound
com.sun.tools.javac.code.Type.TypeVar#getKind()->TypeKind::: type var get kind
com.sun.tools.javac.code.Type.TypeVar#isCaptured()->boolean::: type var is captured
com.sun.tools.javac.code.Type.TypeVar#isReference()->boolean::: type var is reference
com.sun.tools.javac.code.Type.TypeVar#isNullOrReference()->boolean::: type var is null or reference
com.sun.tools.javac.code.Type.TypeVar#accept(TypeVisitor, P)->R::: type var accept
com.sun.tools.javac.code.Type.CapturedType#cloneWithMetadata(TypeMetadata)->CapturedType::: captured type clone with metadata
com.sun.tools.javac.code.Type.CapturedType#accept(Type.Visitor, S)->R::: captured type accept
com.sun.tools.javac.code.Type.CapturedType#isCaptured()->boolean::: captured type is captured
com.sun.tools.javac.code.Type.CapturedType#toString()->String::: captured type to string
com.sun.tools.javac.code.Type.DelegatedType#getTag()->TypeTag::: delegated type get tag
com.sun.tools.javac.code.Type.DelegatedType#toString()->String::: delegated type to string
com.sun.tools.javac.code.Type.DelegatedType#getTypeArguments()->List::: delegated type get type arguments
com.sun.tools.javac.code.Type.DelegatedType#getEnclosingType()->Type::: delegated type get enclosing type
com.sun.tools.javac.code.Type.DelegatedType#getParameterTypes()->List::: delegated type get parameter types
com.sun.tools.javac.code.Type.DelegatedType#getReturnType()->Type::: delegated type get return type
com.sun.tools.javac.code.Type.DelegatedType#getReceiverType()->Type::: delegated type get receiver type
com.sun.tools.javac.code.Type.DelegatedType#getThrownTypes()->List::: delegated type get thrown types
com.sun.tools.javac.code.Type.DelegatedType#allparams()->List::: delegated type allparams
com.sun.tools.javac.code.Type.DelegatedType#getUpperBound()->Type::: delegated type get upper bound
com.sun.tools.javac.code.Type.DelegatedType#isErroneous()->boolean::: delegated type is erroneous
com.sun.tools.javac.code.Type.ForAll#cloneWithMetadata(TypeMetadata)->ForAll::: for all clone with metadata
com.sun.tools.javac.code.Type.ForAll#accept(Type.Visitor, S)->R::: for all accept
com.sun.tools.javac.code.Type.ForAll#toString()->String::: for all to string
com.sun.tools.javac.code.Type.ForAll#getTypeArguments()->List::: for all get type arguments
com.sun.tools.javac.code.Type.ForAll#isErroneous()->boolean::: for all is erroneous
com.sun.tools.javac.code.Type.ForAll#contains(Type)->boolean::: for all contains
com.sun.tools.javac.code.Type.ForAll#asMethodType()->MethodType::: for all as method type
com.sun.tools.javac.code.Type.ForAll#complete()->void::: for all complete
com.sun.tools.javac.code.Type.ForAll#getTypeVariables()->List::: for all get type variables
com.sun.tools.javac.code.Type.ForAll#getKind()->TypeKind::: for all get kind
com.sun.tools.javac.code.Type.ForAll#accept(TypeVisitor, P)->R::: for all accept
com.sun.tools.javac.code.Type.UndetVar.UndetVarListener#varBoundChanged(UndetVar, InferenceBound, Type, boolean)->void:::called when some inference variable bounds (of given kinds ibs) change
com.sun.tools.javac.code.Type.UndetVar.UndetVarListener#varInstantiated(UndetVar)->void:::called when the inferred type is set on some inference variable
com.sun.tools.javac.code.Type.UndetVar#accept(Type.Visitor, S)->R::: undet var accept
com.sun.tools.javac.code.Type.UndetVar#toString()->String::: undet var to string
com.sun.tools.javac.code.Type.UndetVar#debugString()->String::: undet var debug string
com.sun.tools.javac.code.Type.UndetVar#setThrow()->void::: undet var set throw
com.sun.tools.javac.code.Type.UndetVar#dup(Types)->UndetVar:::Returns a new copy of this undet var.
com.sun.tools.javac.code.Type.UndetVar#dupTo(UndetVar, Types)->void:::Dumps the contents of this undet var on another undet var.
com.sun.tools.javac.code.Type.UndetVar#cloneWithMetadata(TypeMetadata)->UndetVar::: undet var clone with metadata
com.sun.tools.javac.code.Type.UndetVar#isPartial()->boolean::: undet var is partial
com.sun.tools.javac.code.Type.UndetVar#baseType()->Type::: undet var base type
com.sun.tools.javac.code.Type.UndetVar#getInst()->Type::: undet var get inst
com.sun.tools.javac.code.Type.UndetVar#setInst(Type)->void::: undet var set inst
com.sun.tools.javac.code.Type.UndetVar#getBounds(InferenceBound...)->List:::get all bounds of a given kind
com.sun.tools.javac.code.Type.UndetVar#getDeclaredBounds()->List:::get the list of declared (upper) bounds
com.sun.tools.javac.code.Type.UndetVar#setBounds(InferenceBound, List)->void:::internal method used to override an undetvar bounds
com.sun.tools.javac.code.Type.UndetVar#addBound(InferenceBound, Type, Types)->void:::add a bound of a given kind - this might trigger listener notification
com.sun.tools.javac.code.Type.UndetVar#substBounds(List, List, Types)->void:::replace types in all bounds - this might trigger listener notification
com.sun.tools.javac.code.Type.UndetVar#isCaptured()->boolean::: undet var is captured
com.sun.tools.javac.code.Type.UndetVar#isThrows()->boolean::: undet var is throws
com.sun.tools.javac.code.Type.JCNoType#cloneWithMetadata(TypeMetadata)->JCNoType::: no type clone with metadata
com.sun.tools.javac.code.Type.JCNoType#getTag()->TypeTag::: no type get tag
com.sun.tools.javac.code.Type.JCNoType#getKind()->TypeKind::: no type get kind
com.sun.tools.javac.code.Type.JCNoType#accept(TypeVisitor, P)->R::: no type accept
com.sun.tools.javac.code.Type.JCNoType#isCompound()->boolean::: no type is compound
com.sun.tools.javac.code.Type.JCVoidType#cloneWithMetadata(TypeMetadata)->JCVoidType::: void type clone with metadata
com.sun.tools.javac.code.Type.JCVoidType#getTag()->TypeTag::: void type get tag
com.sun.tools.javac.code.Type.JCVoidType#getKind()->TypeKind::: void type get kind
com.sun.tools.javac.code.Type.JCVoidType#isCompound()->boolean::: void type is compound
com.sun.tools.javac.code.Type.JCVoidType#accept(TypeVisitor, P)->R::: void type accept
com.sun.tools.javac.code.Type.JCVoidType#isPrimitiveOrVoid()->boolean::: void type is primitive or void
com.sun.tools.javac.code.Type.BottomType#cloneWithMetadata(TypeMetadata)->BottomType::: bottom type clone with metadata
com.sun.tools.javac.code.Type.BottomType#getTag()->TypeTag::: bottom type get tag
com.sun.tools.javac.code.Type.BottomType#getKind()->TypeKind::: bottom type get kind
com.sun.tools.javac.code.Type.BottomType#isCompound()->boolean::: bottom type is compound
com.sun.tools.javac.code.Type.BottomType#accept(TypeVisitor, P)->R::: bottom type accept
com.sun.tools.javac.code.Type.BottomType#constType(Object)->Type::: bottom type const type
com.sun.tools.javac.code.Type.BottomType#stringValue()->String::: bottom type string value
com.sun.tools.javac.code.Type.BottomType#isNullOrReference()->boolean::: bottom type is null or reference
com.sun.tools.javac.code.Type.ErrorType#cloneWithMetadata(TypeMetadata)->ErrorType::: error type clone with metadata
com.sun.tools.javac.code.Type.ErrorType#getTag()->TypeTag::: error type get tag
com.sun.tools.javac.code.Type.ErrorType#isPartial()->boolean::: error type is partial
com.sun.tools.javac.code.Type.ErrorType#isReference()->boolean::: error type is reference
com.sun.tools.javac.code.Type.ErrorType#isNullOrReference()->boolean::: error type is null or reference
com.sun.tools.javac.code.Type.ErrorType#accept(Type.Visitor, S)->R::: error type accept
com.sun.tools.javac.code.Type.ErrorType#constType(Object)->Type::: error type const type
com.sun.tools.javac.code.Type.ErrorType#getEnclosingType()->Type::: error type get enclosing type
com.sun.tools.javac.code.Type.ErrorType#getReturnType()->Type::: error type get return type
com.sun.tools.javac.code.Type.ErrorType#asSub(Symbol)->Type::: error type as sub
com.sun.tools.javac.code.Type.ErrorType#isGenType(Type)->boolean::: error type is gen type
com.sun.tools.javac.code.Type.ErrorType#isErroneous()->boolean::: error type is erroneous
com.sun.tools.javac.code.Type.ErrorType#isCompound()->boolean::: error type is compound
com.sun.tools.javac.code.Type.ErrorType#isInterface()->boolean::: error type is interface
com.sun.tools.javac.code.Type.ErrorType#allparams()->List::: error type allparams
com.sun.tools.javac.code.Type.ErrorType#getTypeArguments()->List::: error type get type arguments
com.sun.tools.javac.code.Type.ErrorType#getKind()->TypeKind::: error type get kind
com.sun.tools.javac.code.Type.ErrorType#getOriginalType()->Type::: error type get original type
com.sun.tools.javac.code.Type.ErrorType#accept(TypeVisitor, P)->R::: error type accept
com.sun.tools.javac.code.Type.UnknownType#cloneWithMetadata(TypeMetadata)->UnknownType::: unknown type clone with metadata
com.sun.tools.javac.code.Type.UnknownType#getTag()->TypeTag::: unknown type get tag
com.sun.tools.javac.code.Type.UnknownType#accept(TypeVisitor, P)->R::: unknown type accept
com.sun.tools.javac.code.Type.UnknownType#isPartial()->boolean::: unknown type is partial
com.sun.tools.javac.code.Type.Visitor#visitClassType(ClassType, S)->R::: visitor visit class type
com.sun.tools.javac.code.Type.Visitor#visitWildcardType(WildcardType, S)->R::: visitor visit wildcard type
com.sun.tools.javac.code.Type.Visitor#visitArrayType(ArrayType, S)->R::: visitor visit array type
com.sun.tools.javac.code.Type.Visitor#visitMethodType(MethodType, S)->R::: visitor visit method type
com.sun.tools.javac.code.Type.Visitor#visitPackageType(PackageType, S)->R::: visitor visit package type
com.sun.tools.javac.code.Type.Visitor#visitModuleType(ModuleType, S)->R::: visitor visit module type
com.sun.tools.javac.code.Type.Visitor#visitTypeVar(TypeVar, S)->R::: visitor visit type var
com.sun.tools.javac.code.Type.Visitor#visitCapturedType(CapturedType, S)->R::: visitor visit captured type
com.sun.tools.javac.code.Type.Visitor#visitForAll(ForAll, S)->R::: visitor visit for all
com.sun.tools.javac.code.Type.Visitor#visitUndetVar(UndetVar, S)->R::: visitor visit undet var
com.sun.tools.javac.code.Type.Visitor#visitErrorType(ErrorType, S)->R::: visitor visit error type
com.sun.tools.javac.code.Type.Visitor#visitType(Type, S)->R::: visitor visit type
com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry#fromBinary(int, int)->TypePathEntry::: type path entry from binary
com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry#toString()->String::: type path entry to string
com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry#equals(Object)->boolean::: type path entry equals
com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry#hashCode()->int::: type path entry hash code
com.sun.tools.javac.code.TypeAnnotationPosition#toString()->String::: type annotation position to string
com.sun.tools.javac.code.TypeAnnotationPosition#emitToClassfile()->boolean:::Indicates whether the target tree of the annotation has been optimized away from classfile or not.
com.sun.tools.javac.code.TypeAnnotationPosition#matchesPos(int)->boolean::: type annotation position matches pos
com.sun.tools.javac.code.TypeAnnotationPosition#updatePosOffset(int)->void::: type annotation position update pos offset
com.sun.tools.javac.code.TypeAnnotationPosition#hasExceptionIndex()->boolean::: type annotation position has exception index
com.sun.tools.javac.code.TypeAnnotationPosition#getExceptionIndex()->int::: type annotation position get exception index
com.sun.tools.javac.code.TypeAnnotationPosition#setExceptionIndex(int)->void::: type annotation position set exception index
com.sun.tools.javac.code.TypeAnnotationPosition#hasCatchType()->boolean::: type annotation position has catch type
com.sun.tools.javac.code.TypeAnnotationPosition#getCatchType()->int::: type annotation position get catch type
com.sun.tools.javac.code.TypeAnnotationPosition#getStartPos()->int::: type annotation position get start pos
com.sun.tools.javac.code.TypeAnnotationPosition#setCatchInfo(int, int)->void::: type annotation position set catch info
com.sun.tools.javac.code.TypeAnnotationPosition#getTypePathFromBinary(java.util.List)->List:::Decode the binary representation for a type path and set the location field.
com.sun.tools.javac.code.TypeAnnotationPosition#getBinaryFromTypePath(java.util.List)->List::: type annotation position get binary from type path
com.sun.tools.javac.code.TypeAnnotationPosition#methodReturn(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method return.
com.sun.tools.javac.code.TypeAnnotationPosition#methodReturn(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method return.
com.sun.tools.javac.code.TypeAnnotationPosition#methodReturn(int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method return.
com.sun.tools.javac.code.TypeAnnotationPosition#methodReceiver(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method receiver parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodReceiver(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method receiver parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodReceiver(int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method receiver parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodParameter(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method formal parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodParameter(JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method formal parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodParameter(int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method formal parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodParameter(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method formal parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodRef(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method reference.
com.sun.tools.javac.code.TypeAnnotationPosition#methodRef(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method reference.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorRef(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor reference.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorRef(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor reference.
com.sun.tools.javac.code.TypeAnnotationPosition#field(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a field.
com.sun.tools.javac.code.TypeAnnotationPosition#field(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a field.
com.sun.tools.javac.code.TypeAnnotationPosition#field(int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a field.
com.sun.tools.javac.code.TypeAnnotationPosition#localVariable(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a local variable.
com.sun.tools.javac.code.TypeAnnotationPosition#localVariable(JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a local variable.
com.sun.tools.javac.code.TypeAnnotationPosition#localVariable(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a local variable.
com.sun.tools.javac.code.TypeAnnotationPosition#exceptionParameter(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for an exception parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#exceptionParameter(JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for an exception parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#exceptionParameter(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for an exception parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#resourceVariable(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a resource variable.
com.sun.tools.javac.code.TypeAnnotationPosition#resourceVariable(JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a resource variable.
com.sun.tools.javac.code.TypeAnnotationPosition#resourceVariable(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a resource variable.
com.sun.tools.javac.code.TypeAnnotationPosition#newObj(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a new.
com.sun.tools.javac.code.TypeAnnotationPosition#newObj(int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a new.
com.sun.tools.javac.code.TypeAnnotationPosition#newObj(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a new.
com.sun.tools.javac.code.TypeAnnotationPosition#classExtends(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a class extension.
com.sun.tools.javac.code.TypeAnnotationPosition#classExtends(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a class extension.
com.sun.tools.javac.code.TypeAnnotationPosition#classExtends(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a class extension.
com.sun.tools.javac.code.TypeAnnotationPosition#classExtends(int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a class extension.
com.sun.tools.javac.code.TypeAnnotationPosition#classExtends(int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a class extension.
com.sun.tools.javac.code.TypeAnnotationPosition#instanceOf(List, JCLambda, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for an instanceof.
com.sun.tools.javac.code.TypeAnnotationPosition#instanceOf(List)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for an instanceof.
com.sun.tools.javac.code.TypeAnnotationPosition#typeCast(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type cast.
com.sun.tools.javac.code.TypeAnnotationPosition#typeCast(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type cast.
com.sun.tools.javac.code.TypeAnnotationPosition#methodInvocationTypeArg(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method invocation type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#methodInvocationTypeArg(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method invocation type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorInvocationTypeArg(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor invocation type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorInvocationTypeArg(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor invocation type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#typeParameter(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#typeParameter(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodTypeParameter(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method type parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodTypeParameter(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method type parameter.
com.sun.tools.javac.code.TypeAnnotationPosition#methodThrows(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a throws clause.
com.sun.tools.javac.code.TypeAnnotationPosition#methodThrows(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a throws clause.
com.sun.tools.javac.code.TypeAnnotationPosition#methodRefTypeArg(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method reference type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#methodRefTypeArg(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method reference type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorRefTypeArg(List, JCLambda, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor reference type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#constructorRefTypeArg(List, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a constructor reference type argument.
com.sun.tools.javac.code.TypeAnnotationPosition#typeParameterBound(List, JCLambda, int, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type parameter bound.
com.sun.tools.javac.code.TypeAnnotationPosition#typeParameterBound(List, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a type parameter bound.
com.sun.tools.javac.code.TypeAnnotationPosition#methodTypeParameterBound(List, JCLambda, int, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method type parameter bound.
com.sun.tools.javac.code.TypeAnnotationPosition#methodTypeParameterBound(List, int, int)->TypeAnnotationPosition:::Create a TypeAnnotationPosition for a method type parameter bound.
com.sun.tools.javac.code.TypeAnnotations#instance(Context)->TypeAnnotations::: type annotations instance
com.sun.tools.javac.code.TypeAnnotations#organizeTypeAnnotationsSignatures(Env, JCClassDecl)->void:::Separate type annotations from declaration annotations and determine the correct positions for type annotations
com.sun.tools.javac.code.TypeAnnotations#validateTypeAnnotationsSignatures(Env, JCClassDecl)->void::: type annotations validate type annotations signatures
com.sun.tools.javac.code.TypeAnnotations#organizeTypeAnnotationsBodies(JCClassDecl)->void:::This version only visits types in bodies, that is, field initializers, top-level blocks, and method bodies, and should be called from Attr.
com.sun.tools.javac.code.TypeAnnotations#annotationTargets(TypeSymbol)->List::: type annotations annotation targets
com.sun.tools.javac.code.TypeAnnotations#annotationTargetType(Attribute.Compound, Symbol)->AnnotationType:::Determine whether an annotation is a declaration annotation, a type annotation, or both.
com.sun.tools.javac.code.TypeMetadata#combine(Entry)->TypeMetadata:::Return a copy of this TypeMetadata with the metadata entry for elem.kind() combined with elem.
com.sun.tools.javac.code.TypeMetadata#combineAll(TypeMetadata)->TypeMetadata:::Return a copy of this TypeMetadata with the metadata entry for all kinds from other combined with the same kind from this.
com.sun.tools.javac.code.TypeMetadata#without(Entry.Kind)->TypeMetadata:::Return a TypeMetadata with the metadata entry for kind removed
com.sun.tools.javac.code.TypeMetadata#get(Entry.Kind)->Entry::: type metadata get
com.sun.tools.javac.code.TypeMetadata.Entry#kind()->Kind:::Get the kind of metadata this object represents
com.sun.tools.javac.code.TypeMetadata.Entry#combine(Entry)->Entry:::Combine this type metadata with another metadata of the same kind.
com.sun.tools.javac.code.TypeMetadata.Annotations#getAnnotations()->List:::Get the type annotations contained in this metadata.
com.sun.tools.javac.code.TypeMetadata.Annotations#combine(Entry)->Annotations::: annotations combine
com.sun.tools.javac.code.TypeMetadata.Annotations#kind()->Kind::: annotations kind
com.sun.tools.javac.code.TypeMetadata.Annotations#toString()->String::: annotations to string
com.sun.tools.javac.code.Types#instance(Context)->Types::: types instance
com.sun.tools.javac.code.Types#wildUpperBound(Type)->Type:::Get a wildcard's upper bound, returning non-wildcards unchanged.
com.sun.tools.javac.code.Types#cvarUpperBound(Type)->Type:::Get a capture variable's upper bound, returning other types unchanged.
com.sun.tools.javac.code.Types#wildLowerBound(Type)->Type:::Get a wildcard's lower bound, returning non-wildcards unchanged.
com.sun.tools.javac.code.Types#cvarLowerBound(Type)->Type:::Get a capture variable's lower bound, returning other types unchanged.
com.sun.tools.javac.code.Types#skipTypeVars(Type, boolean)->Type:::Recursively skip type-variables until a class/array type is found; capture conversion is then (optionally) applied to the resulting type
com.sun.tools.javac.code.Types.TypeProjection#visitClassType(ClassType, ProjectionKind)->Type::: type projection visit class type
com.sun.tools.javac.code.Types.TypeProjection#visitArrayType(ArrayType, ProjectionKind)->Type::: type projection visit array type
com.sun.tools.javac.code.Types.TypeProjection#visitTypeVar(TypeVar, ProjectionKind)->Type::: type projection visit type var
com.sun.tools.javac.code.Types.TypeProjection.TypeArgumentProjection#visitType(Type, ProjectionKind)->Type::: type argument projection visit type
com.sun.tools.javac.code.Types.TypeProjection.TypeArgumentProjection#visitWildcardType(WildcardType, ProjectionKind)->Type::: type argument projection visit wildcard type
com.sun.tools.javac.code.Types#upward(Type, List)->Type:::Computes an upward projection of given type, and vars
com.sun.tools.javac.code.Types#captures(Type)->List:::Computes the set of captured variables mentioned in a given type
com.sun.tools.javac.code.Types.CaptureScanner#visitType(Type, Set)->Void::: capture scanner visit type
com.sun.tools.javac.code.Types.CaptureScanner#visitClassType(ClassType, Set)->Void::: capture scanner visit class type
com.sun.tools.javac.code.Types.CaptureScanner#visitArrayType(ArrayType, Set)->Void::: capture scanner visit array type
com.sun.tools.javac.code.Types.CaptureScanner#visitWildcardType(WildcardType, Set)->Void::: capture scanner visit wildcard type
com.sun.tools.javac.code.Types.CaptureScanner#visitTypeVar(TypeVar, Set)->Void::: capture scanner visit type var
com.sun.tools.javac.code.Types.CaptureScanner#visitCapturedType(CapturedType, Set)->Void::: capture scanner visit captured type
com.sun.tools.javac.code.Types#isUnbounded(Type)->boolean:::Checks that all the arguments to a class are unbounded wildcards or something else that doesn't make any restrictions on the arguments
com.sun.tools.javac.code.Types#asSub(Type, Symbol)->Type:::Return the least specific subtype of t that starts with symbol sym
com.sun.tools.javac.code.Types#isConvertible(Type, Type, Warner)->boolean:::Is t a subtype of or convertible via boxing/unboxing conversion to s?
com.sun.tools.javac.code.Types#isConvertible(Type, Type)->boolean:::Is t a subtype of or convertible via boxing/unboxing conversions to s?
com.sun.tools.javac.code.Types.FunctionDescriptorLookupError#setMessage(JCDiagnostic)->FunctionDescriptorLookupError::: function descriptor lookup error set message
com.sun.tools.javac.code.Types.FunctionDescriptorLookupError#getDiagnostic()->JCDiagnostic::: function descriptor lookup error get diagnostic
com.sun.tools.javac.code.Types.DescriptorCache.FunctionDescriptor#getSymbol()->Symbol::: function descriptor get symbol
com.sun.tools.javac.code.Types.DescriptorCache.FunctionDescriptor#getType(Type)->Type::: function descriptor get type
com.sun.tools.javac.code.Types.DescriptorCache.Entry#matches(int)->boolean::: entry matches
com.sun.tools.javac.code.Types.DescriptorCache#get(TypeSymbol)->FunctionDescriptor::: descriptor cache get
com.sun.tools.javac.code.Types.DescriptorCache#findDescriptorInternal(TypeSymbol, CompoundScope)->FunctionDescriptor:::Compute the function descriptor associated with a given functional interface
com.sun.tools.javac.code.Types.DescriptorCache#failure(String, Object...)->FunctionDescriptorLookupError::: descriptor cache failure
com.sun.tools.javac.code.Types.DescriptorCache#failure(JCDiagnostic)->FunctionDescriptorLookupError::: descriptor cache failure
com.sun.tools.javac.code.Types#findDescriptorSymbol(TypeSymbol)->Symbol:::Find the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.
com.sun.tools.javac.code.Types#findDescriptorType(Type)->Type:::Find the type of the method descriptor associated to this class symbol - if the symbol 'origin' is not a functional interface, an exception is thrown.
com.sun.tools.javac.code.Types#isFunctionalInterface(TypeSymbol)->boolean:::Is given type a functional interface?
com.sun.tools.javac.code.Types#isFunctionalInterface(Type)->boolean::: types is functional interface
com.sun.tools.javac.code.Types#removeWildcards(Type)->Type::: types remove wildcards
com.sun.tools.javac.code.Types#makeFunctionalInterfaceClass(Env, Name, Type, long)->ClassSymbol:::Create a symbol for a class that implements a given functional interface and overrides its functional descriptor
com.sun.tools.javac.code.Types#functionalInterfaceBridges(TypeSymbol)->List:::Find the minimal set of methods that are overridden by the functional descriptor in 'origin'
com.sun.tools.javac.code.Types.DescriptorFilter#accepts(Symbol)->boolean::: descriptor filter accepts
com.sun.tools.javac.code.Types#isSubtypeUnchecked(Type, Type)->boolean:::Is t an unchecked subtype of s?
com.sun.tools.javac.code.Types#isSubtypeUnchecked(Type, Type, Warner)->boolean:::Is t an unchecked subtype of s?
com.sun.tools.javac.code.Types#isSubtype(Type, Type)->boolean:::Is t a subtype of s?<br> (not defined for Method and ForAll types)
com.sun.tools.javac.code.Types#isSubtypeNoCapture(Type, Type)->boolean::: types is subtype no capture
com.sun.tools.javac.code.Types#isSubtype(Type, Type, boolean)->boolean::: types is subtype
com.sun.tools.javac.code.Types#isSubtypeUnchecked(Type, List, Warner)->boolean:::Is t a subtype of every type in given list `ts'?<br> (not defined for Method and ForAll types)<br> Allows unchecked conversions.
com.sun.tools.javac.code.Types#isSubtypes(List, List)->boolean:::Are corresponding elements of ts subtypes of ss?  If lists are of different length, return false.
com.sun.tools.javac.code.Types#isSubtypesUnchecked(List, List, Warner)->boolean:::Are corresponding elements of ts subtypes of ss, allowing unchecked conversions?  If lists are of different length, return false.
com.sun.tools.javac.code.Types#isSuperType(Type, Type)->boolean:::Is t a supertype of s?
com.sun.tools.javac.code.Types#isSameTypes(List, List)->boolean:::Are corresponding elements of the lists the same type?  If lists are of different length, return false.
com.sun.tools.javac.code.Types#isSignaturePolymorphic(MethodSymbol)->boolean:::A polymorphic signature method (JLS 15.12.3) is a method that   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;  (ii) takes a single variable arity parameter; (iii) whose declared type is Object[];  (iv) has any return type, Object signifying a polymorphic return type; and   (v) is native.
com.sun.tools.javac.code.Types#isSameType(Type, Type)->boolean:::Is t the same type as s?
com.sun.tools.javac.code.Types#containedBy(Type, Type)->boolean::: types contained by
com.sun.tools.javac.code.Types#containsType(List, List)->boolean::: types contains type
com.sun.tools.javac.code.Types#containsType(Type, Type)->boolean:::Check if t contains s
com.sun.tools.javac.code.Types#isCaptureOf(Type, WildcardType)->boolean::: types is capture of
com.sun.tools.javac.code.Types#isSameWildcard(WildcardType, Type)->boolean::: types is same wildcard
com.sun.tools.javac.code.Types#containsTypeEquivalent(List, List)->boolean::: types contains type equivalent
com.sun.tools.javac.code.Types#isCastable(Type, Type)->boolean::: types is castable
com.sun.tools.javac.code.Types#isCastable(Type, Type, Warner)->boolean:::Is t is castable to s?<br> s is assumed to be an erased type.<br> (not defined for Method and ForAll types).
com.sun.tools.javac.code.Types#disjointTypes(List, List)->boolean::: types disjoint types
com.sun.tools.javac.code.Types#disjointType(Type, Type)->boolean:::Two types or wildcards are considered disjoint if it can be proven that no type can be contained in both
com.sun.tools.javac.code.Types#cvarLowerBounds(List)->List::: types cvar lower bounds
com.sun.tools.javac.code.Types#notSoftSubtype(Type, Type)->boolean:::This relation answers the question: is impossible that something of type `t' can be a subtype of `s'? This is different from the question "is `t' not a subtype of `s'?" when type variables are involved: Integer is not a subtype of T where <T extends Number> but it is not true that Integer cannot possibly be a subtype of T.
com.sun.tools.javac.code.Types#isReifiable(Type)->boolean::: types is reifiable
com.sun.tools.javac.code.Types#isArray(Type)->boolean::: types is array
com.sun.tools.javac.code.Types#elemtype(Type)->Type:::The element type of an array.
com.sun.tools.javac.code.Types#elemtypeOrType(Type)->Type::: types elemtype or type
com.sun.tools.javac.code.Types#dimensions(Type)->int:::The number of dimensions of an array type.
com.sun.tools.javac.code.Types#makeArrayType(Type)->ArrayType:::Returns an ArrayType with the component type t
com.sun.tools.javac.code.Types#asSuper(Type, Symbol)->Type:::Return the (most specific) base type of t that starts with the given symbol
com.sun.tools.javac.code.Types#asOuterSuper(Type, Symbol)->Type:::Return the base type of t or any of its outer types that starts with the given symbol
com.sun.tools.javac.code.Types#asEnclosingSuper(Type, Symbol)->Type:::Return the base type of t or any of its enclosing types that starts with the given symbol
com.sun.tools.javac.code.Types#memberType(Type, Symbol)->Type:::The type of given symbol, seen as a member of t.
com.sun.tools.javac.code.Types#isAssignable(Type, Type)->boolean::: types is assignable
com.sun.tools.javac.code.Types#isAssignable(Type, Type, Warner)->boolean:::Is t assignable to s?<br> Equivalent to subtype except for constant values and raw types.<br> (not defined for Method and ForAll types)
com.sun.tools.javac.code.Types#erasure(Type)->Type:::The erasure of t |t| -- the type that results when all type parameters in t are deleted.
com.sun.tools.javac.code.Types#erasure(List)->List::: types erasure
com.sun.tools.javac.code.Types#erasureRecursive(Type)->Type::: types erasure recursive
com.sun.tools.javac.code.Types#erasureRecursive(List)->List::: types erasure recursive
com.sun.tools.javac.code.Types#makeIntersectionType(List)->IntersectionClassType:::Make an intersection type from non-empty list of types
com.sun.tools.javac.code.Types#makeIntersectionType(List, boolean)->IntersectionClassType:::Make an intersection type from non-empty list of types
com.sun.tools.javac.code.Types#supertype(Type)->Type::: types supertype
com.sun.tools.javac.code.Types#interfaces(Type)->List:::Return the interfaces implemented by this class.
com.sun.tools.javac.code.Types#directSupertypes(Type)->List::: types direct supertypes
com.sun.tools.javac.code.Types#isDirectSuperInterface(TypeSymbol, TypeSymbol)->boolean::: types is direct super interface
com.sun.tools.javac.code.Types#isDerivedRaw(Type)->boolean::: types is derived raw
com.sun.tools.javac.code.Types#isDerivedRawInternal(Type)->boolean::: types is derived raw internal
com.sun.tools.javac.code.Types#isDerivedRaw(List)->boolean::: types is derived raw
com.sun.tools.javac.code.Types#setBounds(TypeVar, List)->void:::Same as Types#setBounds(TypeVar, List, boolean), except that third parameter is computed directly, as follows: if all all bounds are interface types, the computed supertype is Object,otherwise the supertype is simply left null (in this case, the supertype is assumed to be the head of the bound list passed as second argument)
com.sun.tools.javac.code.Types#setBounds(TypeVar, List, boolean)->void:::Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds
com.sun.tools.javac.code.Types#getBounds(TypeVar)->List:::Return list of bounds of the given type variable.
com.sun.tools.javac.code.Types#classBound(Type)->Type:::If the given type is a (possibly selected) type variable, return the bounding class of this type, otherwise return the type itself.
com.sun.tools.javac.code.Types#isSubSignature(Type, Type)->boolean:::Returns true iff the first signature is a sub signature of the other
com.sun.tools.javac.code.Types#isSubSignature(Type, Type, boolean)->boolean::: types is sub signature
com.sun.tools.javac.code.Types#overrideEquivalent(Type, Type)->boolean:::Returns true iff these signatures are related by override equivalence
com.sun.tools.javac.code.Types#overridesObjectMethod(TypeSymbol, Symbol)->boolean::: types overrides object method
com.sun.tools.javac.code.Types#mergeAbstracts(List, Type, boolean)->Optional:::Merge multiple abstract methods
com.sun.tools.javac.code.Types.ImplementationCache.Entry#matches(Filter, boolean, int)->boolean::: entry matches
com.sun.tools.javac.code.Types.ImplementationCache#get(MethodSymbol, TypeSymbol, boolean, Filter)->MethodSymbol::: implementation cache get
com.sun.tools.javac.code.Types#implementation(MethodSymbol, TypeSymbol, boolean, Filter)->MethodSymbol::: types implementation
com.sun.tools.javac.code.Types.MembersClosureCache.MembersScope#combine(Filter)->Filter::: members scope combine
com.sun.tools.javac.code.Types.MembersClosureCache.MembersScope#getSymbols(Filter, LookupKind)->Iterable::: members scope get symbols
com.sun.tools.javac.code.Types.MembersClosureCache.MembersScope#getSymbolsByName(Name, Filter, LookupKind)->Iterable::: members scope get symbols by name
com.sun.tools.javac.code.Types.MembersClosureCache.MembersScope#getMark()->int::: members scope get mark
com.sun.tools.javac.code.Types.MembersClosureCache#visitType(Type, Void)->CompoundScope::: members closure cache visit type
com.sun.tools.javac.code.Types.MembersClosureCache#visitClassType(ClassType, Void)->CompoundScope::: members closure cache visit class type
com.sun.tools.javac.code.Types.MembersClosureCache#visitTypeVar(TypeVar, Void)->CompoundScope::: members closure cache visit type var
com.sun.tools.javac.code.Types#membersClosure(Type, boolean)->CompoundScope::: types members closure
com.sun.tools.javac.code.Types#firstUnimplementedAbstract(ClassSymbol)->MethodSymbol:::Return first abstract member of class `sym'.
com.sun.tools.javac.code.Types.CandidatesCache.Entry#equals(Object)->boolean::: entry equals
com.sun.tools.javac.code.Types.CandidatesCache.Entry#hashCode()->int::: entry hash code
com.sun.tools.javac.code.Types.CandidatesCache#get(Entry)->List::: candidates cache get
com.sun.tools.javac.code.Types.CandidatesCache#put(Entry, List)->void::: candidates cache put
com.sun.tools.javac.code.Types#interfaceCandidates(Type, MethodSymbol)->List::: types interface candidates
com.sun.tools.javac.code.Types#prune(List)->List::: types prune
com.sun.tools.javac.code.Types#hasSameArgs(Type, Type)->boolean:::Does t have the same arguments as s?  It is assumed that both types are (possibly polymorphic) method types
com.sun.tools.javac.code.Types#hasSameArgs(Type, Type, boolean)->boolean::: types has same args
com.sun.tools.javac.code.Types#subst(List, List, List)->List::: types subst
com.sun.tools.javac.code.Types#subst(Type, List, List)->Type:::Substitute all occurrences of a type in `from' with the corresponding type in `to' in 't'
com.sun.tools.javac.code.Types#substBounds(List, List, List)->List::: types subst bounds
com.sun.tools.javac.code.Types#substBound(TypeVar, List, List)->TypeVar::: types subst bound
com.sun.tools.javac.code.Types#hasSameBounds(ForAll, ForAll)->boolean:::Does t have the same bounds for quantified variables as s?
com.sun.tools.javac.code.Types#newInstances(List)->List:::Create new vector of type variables from list of variables  changing all recursive bounds from old to new list.
com.sun.tools.javac.code.Types#createMethodTypeWithParameters(Type, List)->Type::: types create method type with parameters
com.sun.tools.javac.code.Types#createMethodTypeWithThrown(Type, List)->Type::: types create method type with thrown
com.sun.tools.javac.code.Types#createMethodTypeWithReturn(Type, Type)->Type::: types create method type with return
com.sun.tools.javac.code.Types#createErrorType(Type)->Type::: types create error type
com.sun.tools.javac.code.Types#createErrorType(ClassSymbol, Type)->Type::: types create error type
com.sun.tools.javac.code.Types#createErrorType(Name, TypeSymbol, Type)->Type::: types create error type
com.sun.tools.javac.code.Types#rank(Type)->int:::The rank of a class is the length of the longest path between the class and java.lang.Object in the class inheritance graph
com.sun.tools.javac.code.Types#toString(Type, Locale)->String:::Helper method for generating a string representation of a given type accordingly to a given locale
com.sun.tools.javac.code.Types#toString(Symbol, Locale)->String:::Helper method for generating a string representation of a given type accordingly to a given locale
com.sun.tools.javac.code.Types#toString(Type)->String:::This toString is slightly more descriptive than the one on Type.
com.sun.tools.javac.code.Types#closure(Type)->List:::Returns the closure of a class or interface type.
com.sun.tools.javac.code.Types#closureCollector(boolean, BiPredicate)->Collector>:::Collect types into a new closure (using a @code{ClosureHolder})
com.sun.tools.javac.code.Types.ClosureHolder#add(Type)->void::: closure holder add
com.sun.tools.javac.code.Types.ClosureHolder#merge(ClosureHolder)->ClosureHolder::: closure holder merge
com.sun.tools.javac.code.Types.ClosureHolder#closure()->List::: closure holder closure
com.sun.tools.javac.code.Types#insert(List, Type, BiPredicate)->List:::Insert a type in a closure
com.sun.tools.javac.code.Types#insert(List, Type)->List::: types insert
com.sun.tools.javac.code.Types#union(List, List, BiPredicate)->List:::Form the union of two closures
com.sun.tools.javac.code.Types#union(List, List)->List::: types union
com.sun.tools.javac.code.Types#intersect(List, List)->List:::Intersect two closures
com.sun.tools.javac.code.Types.TypePair#hashCode()->int::: type pair hash code
com.sun.tools.javac.code.Types.TypePair#equals(Object)->boolean::: type pair equals
com.sun.tools.javac.code.Types#lub(List)->Type:::Return the least upper bound of list of types
com.sun.tools.javac.code.Types#lub(Type...)->Type:::Return the least upper bound (lub) of set of types
com.sun.tools.javac.code.Types#erasedSupertypes(Type)->List::: types erased supertypes
com.sun.tools.javac.code.Types#glb(List)->Type::: types glb
com.sun.tools.javac.code.Types#glb(Type, Type)->Type::: types glb
com.sun.tools.javac.code.Types#hashCode(Type)->int:::Compute a hash code on a type.
com.sun.tools.javac.code.Types#hashCode(Type, boolean)->int::: types hash code
com.sun.tools.javac.code.Types#resultSubtype(Type, Type, Warner)->boolean:::Does t have a result that is a subtype of the result type of s, suitable for covariant returns?  It is assumed that both types are (possibly polymorphic) method types
com.sun.tools.javac.code.Types#returnTypeSubstitutable(Type, Type)->boolean:::Return-Type-Substitutable.
com.sun.tools.javac.code.Types#returnTypeSubstitutable(Type, Type, Type, Warner)->boolean::: types return type substitutable
com.sun.tools.javac.code.Types#covariantReturnType(Type, Type, Warner)->boolean:::Is t an appropriate return type in an overrider for a method that returns s?
com.sun.tools.javac.code.Types#boxedClass(Type)->ClassSymbol:::Return the class that boxes the given primitive.
com.sun.tools.javac.code.Types#boxedTypeOrType(Type)->Type:::Return the boxed type if 't' is primitive, otherwise return 't' itself.
com.sun.tools.javac.code.Types#unboxedType(Type)->Type:::Return the primitive type corresponding to a boxed type.
com.sun.tools.javac.code.Types#unboxedTypeOrType(Type)->Type:::Return the unboxed type if 't' is a boxed class, otherwise return 't' itself.
com.sun.tools.javac.code.Types#capture(List)->List::: types capture
com.sun.tools.javac.code.Types#capture(Type)->Type::: types capture
com.sun.tools.javac.code.Types#freshTypeVariables(List)->List::: types fresh type variables
com.sun.tools.javac.code.Types#adapt(Type, Type, ListBuffer, ListBuffer)->void:::Adapt a type by computing a substitution which maps a source type to a target type.
com.sun.tools.javac.code.Types.Adapter#adapt(Type, Type)->void::: adapter adapt
com.sun.tools.javac.code.Types.Adapter#visitClassType(ClassType, Type)->Void::: adapter visit class type
com.sun.tools.javac.code.Types.Adapter#visitArrayType(ArrayType, Type)->Void::: adapter visit array type
com.sun.tools.javac.code.Types.Adapter#visitWildcardType(WildcardType, Type)->Void::: adapter visit wildcard type
com.sun.tools.javac.code.Types.Adapter#visitTypeVar(TypeVar, Type)->Void::: adapter visit type var
com.sun.tools.javac.code.Types.Adapter#visitType(Type, Type)->Void::: adapter visit type
com.sun.tools.javac.code.Types.Rewriter#visitClassType(ClassType, Void)->Type::: rewriter visit class type
com.sun.tools.javac.code.Types.Rewriter#visitType(Type, Void)->Type::: rewriter visit type
com.sun.tools.javac.code.Types.Rewriter#visitCapturedType(CapturedType, Void)->Type::: rewriter visit captured type
com.sun.tools.javac.code.Types.Rewriter#visitTypeVar(TypeVar, Void)->Type::: rewriter visit type var
com.sun.tools.javac.code.Types.Rewriter#visitWildcardType(WildcardType, Void)->Type::: rewriter visit wildcard type
com.sun.tools.javac.code.Types.Rewriter#B(Type)->Type::: rewriter  b
com.sun.tools.javac.code.Types.UniqueType#hashCode()->int::: unique type hash code
com.sun.tools.javac.code.Types.UniqueType#equals(Object)->boolean::: unique type equals
com.sun.tools.javac.code.Types.UniqueType#toString()->String::: unique type to string
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visit(Type, S)->R::: default type visitor visit
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitClassType(ClassType, S)->R::: default type visitor visit class type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitWildcardType(WildcardType, S)->R::: default type visitor visit wildcard type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitArrayType(ArrayType, S)->R::: default type visitor visit array type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitMethodType(MethodType, S)->R::: default type visitor visit method type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitPackageType(PackageType, S)->R::: default type visitor visit package type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitModuleType(ModuleType, S)->R::: default type visitor visit module type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitTypeVar(TypeVar, S)->R::: default type visitor visit type var
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitCapturedType(CapturedType, S)->R::: default type visitor visit captured type
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitForAll(ForAll, S)->R::: default type visitor visit for all
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitUndetVar(UndetVar, S)->R::: default type visitor visit undet var
com.sun.tools.javac.code.Types.DefaultTypeVisitor#visitErrorType(ErrorType, S)->R::: default type visitor visit error type
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visit(Symbol, S)->R::: default symbol visitor visit
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitClassSymbol(ClassSymbol, S)->R::: default symbol visitor visit class symbol
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitMethodSymbol(MethodSymbol, S)->R::: default symbol visitor visit method symbol
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitOperatorSymbol(OperatorSymbol, S)->R::: default symbol visitor visit operator symbol
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitPackageSymbol(PackageSymbol, S)->R::: default symbol visitor visit package symbol
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitTypeSymbol(TypeSymbol, S)->R::: default symbol visitor visit type symbol
com.sun.tools.javac.code.Types.DefaultSymbolVisitor#visitVarSymbol(VarSymbol, S)->R::: default symbol visitor visit var symbol
com.sun.tools.javac.code.Types.SimpleVisitor#visitCapturedType(CapturedType, S)->R::: simple visitor visit captured type
com.sun.tools.javac.code.Types.SimpleVisitor#visitForAll(ForAll, S)->R::: simple visitor visit for all
com.sun.tools.javac.code.Types.SimpleVisitor#visitUndetVar(UndetVar, S)->R::: simple visitor visit undet var
com.sun.tools.javac.code.Types.UnaryVisitor#visit(Type)->R::: unary visitor visit
com.sun.tools.javac.code.Types.MapVisitor#visit(Type)->Type::: map visitor visit
com.sun.tools.javac.code.Types.MapVisitor#visitType(Type, S)->Type::: map visitor visit type
com.sun.tools.javac.code.Types.TypeMapping#apply(Type)->Type::: type mapping apply
com.sun.tools.javac.code.Types.TypeMapping#visit(List, S)->List::: type mapping visit
com.sun.tools.javac.code.Types.TypeMapping#visitCapturedType(CapturedType, S)->Type::: type mapping visit captured type
com.sun.tools.javac.code.Types#getRetention(Attribute.Compound)->RetentionPolicy::: types get retention
com.sun.tools.javac.code.Types#getRetention(TypeSymbol)->RetentionPolicy::: types get retention
com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException#type()->Type::: invalid signature exception type
com.sun.tools.javac.code.Types.SignatureGenerator#append(char)->void::: signature generator append
com.sun.tools.javac.code.Types.SignatureGenerator#append(byte[])->void::: signature generator append
com.sun.tools.javac.code.Types.SignatureGenerator#append(Name)->void::: signature generator append
com.sun.tools.javac.code.Types.SignatureGenerator#classReference(ClassSymbol)->void::: signature generator class reference
com.sun.tools.javac.code.Types.SignatureGenerator#assembleSig(Type)->void:::Assemble signature of given type in string buffer.
com.sun.tools.javac.code.Types.SignatureGenerator#hasTypeVar(List)->boolean::: signature generator has type var
com.sun.tools.javac.code.Types.SignatureGenerator#assembleClassSig(Type)->void::: signature generator assemble class sig
com.sun.tools.javac.code.Types.SignatureGenerator#assembleParamsSig(List)->void::: signature generator assemble params sig
com.sun.tools.javac.code.Types#newRound()->void::: types new round
