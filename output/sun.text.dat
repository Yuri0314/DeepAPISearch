BreakDictionary#getNextStateFromCharacter(int, int):::Uses the column map to map the character to a column number, then passes the row and column number to getNextState():::col->if->columnMap->elementAt->else->supplementaryCharColumnMap->getValue->return->getNextState
BreakDictionary#getNextState(int, int):::Returns the value in the cell with the specified (logical) row and column numbers:::if->cellIsPopulated->return->internalAt->else->return
CompactByteArray#elementAt(char):::Get the mapped value of a Unicode character.:::return
CompactByteArray#setElementAt(char, byte):::Set a new value for a Unicode character:::if->expand->touchBlock
CompactByteArray#setElementAt(char, char, byte):::Set new values for a range of Unicode character.:::i->if->expand->for
CompactByteArray#compact():::Compact the array.:::if->limitCompacted->iBlockStart->iUntouched->for->i->newSize->result->new->byteArr->System->arraycopy
CompactByteArray#arrayRegionMatches(byte[], int, byte[], int, int):::Convenience utility to compare two arrays of doubles.:::sourceEnd->delta->for->i->return
CompactByteArray#getIndexArray():::For internal use only:::return
CompactByteArray#getStringArray():::For internal use only:::return
CompactByteArray#clone():::Overrides Cloneable:::try->other->super->clone->values->clone->indices->clone->if->hashes->clone->return->catch->throw->new->InternalError->finally
CompactByteArray#equals(Object):::Compares the equality of two compact array objects.:::if->return->if->return->if->getClass->obj->getClass->return->other->for->i->return
ComposedCharIter#next():::Returns the next precomposed Unicode character:::if->return->return
ComposedCharIter#decomposition():::Returns the Unicode decomposition of the current character:::return
DictionaryBasedBreakIterator#first():::Sets the current iteration position to the beginning of the text:::return->super->first
DictionaryBasedBreakIterator#last():::Sets the current iteration position to the end of the text:::return->super->last
DictionaryBasedBreakIterator#previous():::Advances the iterator one step backwards.:::text->getText->if->text->setIndex->return->else->result->super->previous->if->return
DictionaryBasedBreakIterator#preceding(int):::Sets the current iteration position to the last boundary position before the specified position.:::text->getText->checkOffset->if->return->super->preceding->else->while->text->setIndex->return->text->getIndex
DictionaryBasedBreakIterator#following(int):::Sets the current iteration position to the first boundary position after the specified position.:::text->getText->checkOffset->if->return->super->following->else->while->text->setIndex->return->text->getIndex
DictionaryBasedBreakIterator#handleNext():::This is the implementation function for next().:::text->getText->if->startPos->text->getIndex->result->super->handleNext->if->divideUpDictionaryRange->else->return->if->text->setIndex->return->return
DictionaryBasedBreakIterator#lookupCategory(int):::Looks up a character category for a character.:::result->super->lookupCategory->if->return
Normalizer#normalize(CharSequence, java.text.Normalizer.Form, int):::Normalize a sequence of char values:::return->NormalizerBase->src->toString->normalize
Normalizer#isNormalized(CharSequence, java.text.Normalizer.Form, int):::Determines if the given sequence of char values is normalized.:::return->NormalizerBase->src->toString->isNormalized
Normalizer#getCombiningClass(int):::Returns the combining class of the given character:::return->UCharacter->getCombiningClass
RuleBasedBreakIterator#validateRuleData(String, ByteBuffer):::Validates the magic number, version, and the length of the given data.:::for->i->version->bb->get->if->throw->new->MissingResourceException->len->bb->getInt->if->bb->position->bb->limit->throw->new->MissingResourceException
RuleBasedBreakIterator#clone():::Clones this iterator.:::result->super->clone->if->text->clone->return
RuleBasedBreakIterator#equals(Object):::Returns true if both BreakIterators are of the same class, have the same rules, and iterate over the same text.:::try->if->return->other->if->return->if->return->else->return->text->equals->catch->return->finally
RuleBasedBreakIterator#toString():::Returns text:::return->Long->toHexString
RuleBasedBreakIterator#hashCode():::Compute a hashcode for this BreakIterator:::return
RuleBasedBreakIterator#first():::Sets the current iteration position to the beginning of the text:::t->getText->t->first->return->t->getIndex
RuleBasedBreakIterator#last():::Sets the current iteration position to the end of the text:::t->getText->t->t->getEndIndex->setIndex->return->t->getIndex
RuleBasedBreakIterator#next(int):::Advances the iterator either forward or backward the specified number of steps:::result->current->while->handleNext->while->previous->return
RuleBasedBreakIterator#next():::Advances the iterator to the next boundary position.:::return->handleNext
RuleBasedBreakIterator#previous():::Advances the iterator backwards, to the last boundary preceding this one.:::text->getText->if->current->text->getBeginIndex->return->start->current->lastResult->if->getPrevious->handlePrevious->else->text->setIndex->result->while->handleNext->text->setIndex->return
RuleBasedBreakIterator#getCurrent():::Returns current character:::c1->text->current->if->Character->isHighSurrogate->text->getIndex->text->getEndIndex->c2->text->next->text->previous->if->Character->isLowSurrogate->return->Character->toCodePoint->return
RuleBasedBreakIterator#getNext():::Returns next character:::index->text->getIndex->endIndex->text->getEndIndex->if->getCurrentCodePointCount->return->text->setIndex->return->getCurrent
RuleBasedBreakIterator#checkOffset(int, CharacterIterator):::Throw IllegalArgumentException unless begin <= offset < end.:::if->text->getBeginIndex->text->getEndIndex->throw->new->IllegalArgumentException
RuleBasedBreakIterator#following(int):::Sets the iterator to refer to the first boundary position following the specified position.:::text->getText->checkOffset->text->setIndex->if->text->getBeginIndex->handleNext->return->result->if->handlePrevious->else->text->setIndex->while->handleNext->return
RuleBasedBreakIterator#preceding(int):::Sets the iterator to refer to the last boundary position before the specified position.:::text->getText->checkOffset->text->setIndex->return->previous
RuleBasedBreakIterator#isBoundary(int):::Returns true if the specified position is a boundary position:::text->getText->checkOffset->if->text->getBeginIndex->return->else->return->following
RuleBasedBreakIterator#current():::Returns the current iteration position.:::return->getText->getIndex
RuleBasedBreakIterator#getText():::Return a CharacterIterator over the text being analyzed:::if->new->StringCharacterIterator->return
RuleBasedBreakIterator#setText(CharacterIterator):::Set the iterator to analyze a new piece of text:::end->newText->getEndIndex->goodIterator->try->newText->setIndex->newText->getIndex->catch->finally->if->else->new->SafeCharIterator->text->first
RuleBasedBreakIterator#handleNext():::This method is the actual implementation of the next() method:::text->getText->if->text->getIndex->text->getEndIndex->return->result->getNextIndex->lookaheadResult->state->category->c->getCurrent->while->lookupCategory->if->lookupState->if->if->else->getNextIndex->else->if->getNextIndex->getNext->if->text->getEndIndex->text->setIndex->return
RuleBasedBreakIterator#handlePrevious():::This method backs the iterator back up to a "safe position" in the text:::text->getText->state->category->lastCategory->c->getCurrent->while->lookupCategory->if->lookupBackwardState->getPrevious->if->if->getNext->getNext->else->getNext->return->text->getIndex
RuleBasedBreakIterator#lookupCategory(int):::Looks up a character's category (i.e., its category for breaking purposes, not its Unicode category):::if->return->charCategoryTable->elementAt->else->return->supplementaryCharCategoryTable->getValue
RuleBasedBreakIterator#lookupState(int, int):::Given a current state and a character category, looks up the next state to transition to in the state table.:::return
RuleBasedBreakIterator#lookupBackwardState(int, int):::Given a current state and a character category, looks up the next state to transition to in the backwards state table.:::return
SupplementaryCharacterData#getValue(int):::Returns a corresponding value for the given supplementary code-point.:::i->j->k->for
SupplementaryCharacterData#getArray():::Returns the data array.:::return
UCompactIntArray#elementAt(int):::Get the mapped value of a Unicode character.:::plane->if->return->return
UCompactIntArray#setElementAt(int, int):::Set a new value for a Unicode character:::if->expand->plane->if->initPlane
UCompactIntArray#compact():::Compact the array.:::if->return->for->plane
