PartialEscapePhase_OptionDescriptors#get(String)::: partial escape phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
PartialEscapePhase_OptionDescriptors#iterator()::: partial escape phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
EarlyReadEliminationPhase#run(StructuredGraph, CoreProviders)::: early read elimination phase run:::if->VirtualUtil->EscapeAnalyzeOnly->graph->getOptions->getValue->matches->runAnalysis
EarlyReadEliminationPhase#createEffectsClosure(CoreProviders, ScheduleResult, ControlFlowGraph)::: early read elimination phase create effects closure:::return->new->ReadEliminationClosure
EarlyReadEliminationPhase#codeSizeIncrease()::: early read elimination phase code size increase:::return
EffectList.Effect#isVisible()::: effect is visible:::return
EffectList.Effect#isCfgKill()::: effect is cfg kill:::return
EffectList.Effect#apply(StructuredGraph, ArrayList)::: effect apply:::
EffectList.SimpleEffect#apply(StructuredGraph, ArrayList)::: simple effect apply:::apply
EffectList.SimpleEffect#apply(StructuredGraph)::: simple effect apply:::
EffectList#enlarge(int)::: effect list enlarge:::length->if->while->Math->max->Arrays->copyOf->if->debug->isLogEnabled->Arrays->copyOf
EffectList#add(String, SimpleEffect)::: effect list add:::add
EffectList#add(String, Effect)::: effect list add:::enlarge->if->debug->isLogEnabled
EffectList#addAll(EffectList)::: effect list add all:::enlarge->System->arraycopy->if->debug->isLogEnabled->System->arraycopy
EffectList#insertAll(EffectList, int)::: effect list insert all:::enlarge->System->arraycopy->System->arraycopy->if->debug->isLogEnabled->System->arraycopy->System->arraycopy
EffectList#checkpoint()::: effect list checkpoint:::return
EffectList#size()::: effect list size:::return
EffectList#backtrack(int)::: effect list backtrack:::
EffectList#iterator()::: effect list iterator:::return->new->Iterator<Effect>
EffectList#get(int)::: effect list get:::if->throw->new->IndexOutOfBoundsException->return
EffectList#clear()::: effect list clear:::
EffectList#isEmpty()::: effect list is empty:::return
EffectList#apply(StructuredGraph, ArrayList, boolean)::: effect list apply:::message->for->i->size
EffectList#toString(StringBuilder, int)::: effect list to string:::effect->str->getName->append->append->first->foreach->effect->getClass->getDeclaredFields->try->field->setAccessible->object->field->get->if->continue->str->append->field->getName->append->append->format->append->catch->throw->new->RuntimeException->finally->str->append
EffectList#format(Object)::: effect list format:::if->object->getClass->isAssignableFrom->return->Arrays->toString->return
EffectList#toString()::: effect list to string:::str->new->StringBuilder->for->i->size->return->str->toString
EffectList#getName(int)::: effect list get name:::if->debug->isLogEnabled->return->else->return
EffectsBlockState#toString()::: effects block state to string:::return
EffectsBlockState#equivalentTo(T)::: effects block state equivalent to:::
EffectsBlockState#isDead()::: effects block state is dead:::return
EffectsBlockState#markAsDead()::: effects block state mark as dead:::
EffectsBlockState#isSubMapOf(EconomicMap, EconomicMap):::Returns true if every value in subMap is also present in the superMap (according to "equals" semantics).:::if->return->cursor->subMap->getEntries->while->cursor->advance->key->cursor->getKey->value->cursor->getValue->otherValue->superMap->get->if->value->equals->return->return
EffectsBlockState#meetMaps(Map, Map):::Modifies target so that only entries that have corresponding entries in source remain.:::iter->target->entrySet->iterator->while->iter->hasNext->entry->iter->next->if->source->entry->getKey->containsKey->else->iter->remove
EffectsClosure#hasChanged()::: effects closure has changed:::return
EffectsClosure#needsApplyEffects()::: effects closure needs apply effects:::return
EffectsClosure#applyEffects()::: effects closure apply effects:::graph->obsoleteNodes->new->ArrayList<>->effectList->new->ArrayList<>->closure->new->BlockIteratorClosure<Void>->ReentrantBlockIterator->cfg->getStartBlock->apply->foreach->effects->apply->foreach->effects->apply->debug->dump->foreach->if->node->isAlive->node->hasNoUsages->if->node->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs
EffectsClosure#processBlock(Block, BlockT)::: effects closure process block:::if->state->isDead->effects->blockEffects->get->if->block->getBeginNode->predecessor->ifNode->block->getBeginNode->predecessor->condition->ifNode->condition->alias->getScalarAlias->if->constant->isTrueSuccessor->block->getBeginNode->ifNode->trueSuccessor->if->constant->getValue->state->markAsDead->effects->constant->getValue->killIfBranch->return->options->block->getBeginNode->getOptions->VirtualUtil->block->getPredecessors->block->getSuccessors->trace->lastFixedNode->nodes->schedule->getBlockToNodesMap->get->block->getNodes->foreach->aliases->set->if->loopExit->foreach->loopExit->proxies->aliases->set->processNode->isSignificantNode->loopEntryStates->loopExit->loopBegin->get->blockEffects->get->processLoopExit->processNode->isSignificantNode->if->if->state->isDead->break->VirtualUtil->trace->return
EffectsClosure#isSignificantNode(Node):::Changes to CommitAllocationNodes, AllocatedObjectNodes and BoxNodes are not considered to be "important":::return
EffectsClosure#processNode(Node, BlockT, GraphEffectList, FixedWithNextNode):::Collects the effects of virtualizing the given node.:::
EffectsClosure#merge(Block, List)::: effects closure merge:::processor->createMergeProcessor->doMergeWithoutDead->blockEffects->get->addAll->blockEffects->get->addAll->return
EffectsClosure#processLoop(Loop, BlockT)::: effects closure process loop:::if->initialState->isDead->states->new->ArrayList<>->for->i->loop->getLoopExits->size->return->initialStateRemovedKilledLocations->cloneState->stripKilledLoopLocations->loopEntryState->lastMergedState->cloneState->processInitialLoopState->mergeProcessor->loop->getHeader->createMergeProcessor->for->iteration->throw->new->GraalError
EffectsClosure#stripKilledLoopLocations(Loop, BlockT)::: effects closure strip killed loop locations:::return
EffectsClosure#processKilledLoopLocations(Loop, BlockT, BlockT)::: effects closure process killed loop locations:::
EffectsClosure#processInitialLoopState(Loop, BlockT)::: effects closure process initial loop state:::
EffectsClosure#doMergeWithoutDead(MergeProcessor, List)::: effects closure do merge without dead:::alive->foreach->if->state->isDead->if->mergeProcessor->states->get->setNewState->else->if->states->size->stateIndexes->states->size->new->intArr->for->i->mergeProcessor->setStateIndexes->mergeProcessor->getInitialState->setNewState->mergeProcessor->merge->else->aliveStates->new->ArrayList<>->stateIndexes->new->intArr->for->i->states->size->mergeProcessor->setStateIndexes->mergeProcessor->getInitialState->setNewState->mergeProcessor->merge
EffectsClosure#assertExitStatesNonEmpty(Loop, LoopInfo)::: effects closure assert exit states non empty:::for->i->loop->getLoopExits->size->return
EffectsClosure#processLoopExit(LoopExitNode, BlockT, BlockT, GraphEffectList)::: effects closure process loop exit:::
EffectsClosure#createMergeProcessor(Block)::: effects closure create merge processor:::
EffectsClosure.MergeProcessor#merge(List)::: merge processor merge:::
EffectsClosure.MergeProcessor#setNewState(BlockT)::: merge processor set new state:::mergeEffects->clear->afterMergeEffects->clear
EffectsClosure.MergeProcessor#setStateIndexes(int[])::: merge processor set state indexes:::
EffectsClosure.MergeProcessor#getPredecessor(int)::: merge processor get predecessor:::return->mergeBlock->getPredecessors
EffectsClosure.MergeProcessor#getPhis()::: merge processor get phis:::return->merge->phis
EffectsClosure.MergeProcessor#getPhiValueAt(PhiNode, int)::: merge processor get phi value at:::return->phi->valueAt
EffectsClosure.MergeProcessor#createValuePhi(Stamp)::: merge processor create value phi:::return->mergeBlock->getPredecessorCount->new->ValueNodeArr->new->ValuePhiNode
EffectsClosure.MergeProcessor#setPhiInput(PhiNode, int, ValueNode)::: merge processor set phi input:::afterMergeEffects->initializePhiInput
EffectsClosure.MergeProcessor#graph()::: merge processor graph:::return->merge->graph
EffectsClosure.MergeProcessor#toString()::: merge processor to string:::return
EffectsClosure#addScalarAlias(ValueNode, ValueNode)::: effects closure add scalar alias:::aliases->set->foreach->node->usages->if->hasScalarReplacedInputs->isNew->hasScalarReplacedInputs->mark
EffectsClosure#hasScalarReplacedInputs(Node)::: effects closure has scalar replaced inputs:::return->hasScalarReplacedInputs->isMarked
EffectsClosure#getScalarAlias(ValueNode)::: effects closure get scalar alias:::if->node->isAlive->aliases->isNew->return->result->aliases->get->return
EffectsClosure.LoopKillCache#visited()::: loop kill cache visited:::
EffectsClosure.LoopKillCache#visits()::: loop kill cache visits:::return
EffectsClosure.LoopKillCache#setKillsAll()::: loop kill cache set kills all:::
EffectsClosure.LoopKillCache#containsLocation(LocationIdentity)::: loop kill cache contains location:::if->return->if->return->if->firstLocation->equals->return->killedLocations->contains->return
EffectsClosure.LoopKillCache#rememberLoopKilledLocation(LocationIdentity)::: loop kill cache remember loop killed location:::if->return->if->firstLocation->equals->else->if->EconomicSet->create->killedLocations->add
EffectsClosure.LoopKillCache#loopKillsLocations()::: loop kill cache loop kills locations:::if->return->return
EffectsPhase.Closure#hasChanged()::: closure has changed:::
EffectsPhase.Closure#needsApplyEffects()::: closure needs apply effects:::
EffectsPhase.Closure#applyEffects()::: closure apply effects:::
EffectsPhase#run(StructuredGraph, CoreProvidersT)::: effects phase run:::runAnalysis
EffectsPhase#runAnalysis(StructuredGraph, CoreProvidersT)::: effects phase run analysis:::changed->compilationAlarm->CompilationAlarm->current->debug->graph->getDebug->for->iteration->compilationAlarm->hasExpired->return
EffectsPhase#postIteration(StructuredGraph, CoreProvidersT, EconomicSet)::: effects phase post iteration:::if->canonicalizer->applyIncremental
EffectsPhase#createEffectsClosure(CoreProvidersT, ScheduleResult, ControlFlowGraph)::: effects phase create effects closure:::
GraphEffectList#clear()::: graph effect list clear:::super->clear
GraphEffectList#addCounterBefore(String, String, int, boolean, FixedNode)::: graph effect list add counter before:::DynamicCounterNode->addCounterBefore->add
GraphEffectList#addCounterAfter(String, String, int, boolean, FixedWithNextNode)::: graph effect list add counter after:::nextPosition->position->next->DynamicCounterNode->addCounterBefore->add
GraphEffectList#addWeakCounterCounterBefore(String, String, int, boolean, ValueNode, FixedNode)::: graph effect list add weak counter counter before:::WeakCounterNode->addCounterBefore->add
GraphEffectList#addFixedNodeBefore(FixedWithNextNode, FixedNode):::Adds the given fixed node to the graph's control flow, before position (so that the original predecessor of position will then be node's predecessor).:::graph->graph->add->addBeforeFixed->add
GraphEffectList#ensureAdded(ValueNode, FixedNode)::: graph effect list ensure added:::if->node->isAlive->graph->addOrUniqueWithInputs->if->graph->addBeforeFixed->add
GraphEffectList#addVirtualizationDelta(int)::: graph effect list add virtualization delta:::
GraphEffectList#getVirtualizationDelta()::: graph effect list get virtualization delta:::return
GraphEffectList#addFloatingNode(ValueNode, String):::Add the given floating node to the graph.:::graph->addWithoutUniqueWithInputs->add
GraphEffectList#initializePhiInput(PhiNode, int, ValueNode):::Sets the phi node's input at the given index to the given value, adding new phi inputs as needed.:::node->graph->addOrUniqueWithInputs->initializeValueAt->add
GraphEffectList#addVirtualMapping(FrameState, EscapeObjectState):::Adds a virtual object's state to the given frame state:::new->Effect->add
GraphEffectList#deleteNode(Node):::Removes the given fixed node from the control flow and deletes it.:::if->GraphUtil->unlinkFixedNode->obsoleteNodes->add->add
GraphEffectList#killIfBranch(IfNode, boolean)::: graph effect list kill if branch:::new->Effect->add
GraphEffectList#replaceWithSink(FixedWithNextNode, ControlSinkNode)::: graph effect list replace with sink:::new->Effect->add
GraphEffectList#replaceAtUsages(ValueNode, ValueNode, FixedNode):::Replaces the given node at its usages without deleting it:::try->position->graph->withNodeSourcePosition->replacementNode->graph->addOrUniqueWithInputs->if->next->graph->addBeforeFixed->if->node->hasUsages->node->stamp->replacementNode->stamp->equals->graph->node->stamp->new->PiNode->unique->node->replaceAtUsages->if->GraphUtil->unlinkFixedNode->obsoleteNodes->add->catch->finally->add
GraphEffectList#replaceFirstInput(Node, Node, Node):::Replaces the first occurrence of oldInput in node with newInput.:::new->Effect->add
ObjectState#cloneState()::: object state clone state:::return->new->ObjectState
ObjectState#checkIllegalValues(ValueNode[]):::Ensure that if an JavaConstant#forIllegal() illegal value is seen that the previous value is a double word value.:::if->for->v->return
ObjectState#checkIllegalValue(ValueNode[], int):::Ensure that if an JavaConstant#forIllegal() illegal value is seen that the previous value is a double word value.:::if->isConstant->asConstant->JavaConstant->forIllegal->equals->return
ObjectState#createEscapeObjectState(DebugContext, VirtualObjectNode)::: object state create escape object state:::GET_ESCAPED_OBJECT_STATE->increment->if->CREATE_ESCAPED_OBJECT_STATE->increment->if->isVirtual->newEntries->entries->clone->for->i->new->VirtualObjectState->else->new->MaterializedObjectState->return
ObjectState#isVirtual()::: object state is virtual:::return
ObjectState#getEntries():::Users of this method are not allowed to change the entries of the returned array.:::return
ObjectState#getEntry(int)::: object state get entry:::return
ObjectState#getMaterializedValue()::: object state get materialized value:::return
ObjectState#setEntry(int, ValueNode)::: object state set entry:::
ObjectState#escape(ValueNode)::: object state escape:::
ObjectState#updateMaterializedValue(ValueNode)::: object state update materialized value:::
ObjectState#addLock(MonitorIdNode)::: object state add lock:::new->LockState
ObjectState#removeLock()::: object state remove lock:::try->return->catch->finally
ObjectState#getLocks()::: object state get locks:::return
ObjectState#hasLocks()::: object state has locks:::return
ObjectState#locksEqual(ObjectState)::: object state locks equal:::a->b->while->return
ObjectState#setEnsureVirtualized(boolean)::: object state set ensure virtualized:::
ObjectState#getEnsureVirtualized()::: object state get ensure virtualized:::return
ObjectState#toString()::: object state to string:::str->new->StringBuilder->append->if->str->append->append->append->if->for->i->if->str->append->append->return->str->append->toString
ObjectState#hashCode()::: object state hash code:::prime->result->Arrays->hashCode->getLockDepth->materializedValue->hashCode->return
ObjectState#equals(Object)::: object state equals:::if->return->if->getClass->obj->getClass->return->other->if->Arrays->equals->return->if->locksEqual->return->if->if->return->else->if->materializedValue->equals->return->return
ObjectState#share()::: object state share:::return
PartialEscapeBlockState#contains(VirtualObjectNode)::: partial escape block state contains:::foreach->if->state->isVirtual->state->getEntries->foreach->state->getEntries->if->return->return
PartialEscapeBlockState#getObjectState(int)::: partial escape block state get object state:::state->return
PartialEscapeBlockState#getObjectStateOptional(int)::: partial escape block state get object state optional:::return
PartialEscapeBlockState#getObjectState(VirtualObjectNode):::Asserts that the given virtual object is available/reachable in the current state.:::state->object->getObjectId->return
PartialEscapeBlockState#getObjectStateOptional(VirtualObjectNode)::: partial escape block state get object state optional:::id->object->getObjectId->return
PartialEscapeBlockState#getObjectStateArrayForModification()::: partial escape block state get object state array for modification:::if->objectStates->clone->new->RefCount->return
PartialEscapeBlockState#getObjectStateForModification(int)::: partial escape block state get object state for modification:::array->getObjectStateArrayForModification->objectState->if->objectState->cloneState->return
PartialEscapeBlockState#setEntry(int, int, ValueNode)::: partial escape block state set entry:::if->getEntry->getObjectStateForModification->setEntry
PartialEscapeBlockState#escape(int, ValueNode)::: partial escape block state escape:::getObjectStateForModification->escape
PartialEscapeBlockState#addLock(int, MonitorIdNode)::: partial escape block state add lock:::getObjectStateForModification->addLock
PartialEscapeBlockState#removeLock(int)::: partial escape block state remove lock:::return->getObjectStateForModification->removeLock
PartialEscapeBlockState#setEnsureVirtualized(int, boolean)::: partial escape block state set ensure virtualized:::if->getEnsureVirtualized->getObjectStateForModification->setEnsureVirtualized
PartialEscapeBlockState#updateMaterializedValue(int, ValueNode)::: partial escape block state update materialized value:::if->getMaterializedValue->getObjectStateForModification->updateMaterializedValue
PartialEscapeBlockState#materializeBefore(FixedNode, VirtualObjectNode, GraphEffectList):::Materializes the given virtual object and produces the necessary effects in the effects list:::fixed->getDebug->increment->objects->new->ArrayList<>->values->new->ArrayList<>->locks->new->ArrayList<>->otherAllocations->new->ArrayList<>->ensureVirtual->new->ArrayList<>->materializeWithCommit->materializeEffects->objects->size->otherAllocations->size->addVirtualizationDelta->materializeEffects->new->Effect->add
PartialEscapeBlockState#materializeWithCommit(FixedNode, VirtualObjectNode, List, List>, List, List, List)::: partial escape block state materialize with commit:::obj->getObjectState->entries->obj->getEntries->representation->virtual->obj->getLocks->getMaterializedRepresentation->virtual->getObjectId->escape->getObjectState->PartialEscapeClosure->obj->getMaterializedValue->updateStatesForMaterialized->if->objects->add->locks->LockState->obj->getLocks->asList->add->ensureVirtual->obj->getEnsureVirtualized->add->pos->values->size->while->values->size->values->add->for->i->values->subList->objectMaterialized->else->VirtualUtil->trace->otherAllocations->add
PartialEscapeBlockState#objectMaterialized(VirtualObjectNode, AllocatedObjectNode, List)::: partial escape block state object materialized:::VirtualUtil->trace
PartialEscapeBlockState#addObject(int, ObjectState)::: partial escape block state add object:::ensureSize
PartialEscapeBlockState#ensureSize(int)::: partial escape block state ensure size:::if->Arrays->Math->max->copyOf->new->RefCount->return->else->return->getObjectStateArrayForModification
PartialEscapeBlockState#getStateCount()::: partial escape block state get state count:::return
PartialEscapeBlockState#toString()::: partial escape block state to string:::return->super->toString->Arrays->toString
PartialEscapeBlockState#equivalentTo(T)::: partial escape block state equivalent to:::length->Math->other->getStateCount->max->for->i->return
PartialEscapeBlockState#resetObjectStates(int)::: partial escape block state reset object states:::new->ObjectStateArr
PartialEscapeBlockState#identicalObjectStates(PartialEscapeBlockState[])::: partial escape block state identical object states:::for->i->return
PartialEscapeBlockState#identicalObjectStates(PartialEscapeBlockState[], int)::: partial escape block state identical object states:::for->i->return
PartialEscapeBlockState#adoptAddObjectStates(PartialEscapeBlockState)::: partial escape block state adopt add object states:::if->if->foreach->if->state->share
PartialEscapeClosure#needsApplyEffects()::: partial escape closure needs apply effects:::if->hasChanged->return->foreach->cfg->getBlocks->effects->blockEffects->get->if->if->effects->getVirtualizationDelta->return->return
PartialEscapeClosure.CollectVirtualObjectsClosure#apply(Node, ValueNode)::: collect virtual objects closure apply:::if->object->if->object->getObjectId->state->getObjectStateOptional->virtual->add->else->alias->getAlias->if->object->virtual->add->effects->replaceFirstInput
PartialEscapeClosure.Final#getInitialState()::: final get initial state:::return->tool->getOptions->tool->getDebug->new->PartialEscapeBlockState.Final
PartialEscapeClosure.Final#cloneState(PartialEscapeBlockState.Final)::: final clone state:::return->new->PartialEscapeBlockState.Final
PartialEscapeClosure#processNode(Node, BlockT, GraphEffectList, FixedWithNextNode)::: partial escape closure process node:::if->return->else->if->callTarget->processNodeInternal->return->processNodeInternal
PartialEscapeClosure#processNodeInternal(Node, BlockT, GraphEffectList, FixedWithNextNode)::: partial escape closure process node internal:::nextFixedNode->lastFixedNode->next->VirtualUtil->node->getOptions->trace->if->requiresProcessing->if->processVirtualizable->return->if->tool->isDeleted->VirtualUtil->node->getOptions->trace->return->if->hasVirtualInputs->isMarked->if->if->processVirtualizable->return->if->tool->isDeleted->VirtualUtil->node->getOptions->trace->return->processNodeInputs->if->hasScalarReplacedInputs->if->processNodeWithScalarReplacedInputs->return->return
PartialEscapeClosure#requiresProcessing(Node)::: partial escape closure requires processing:::return
PartialEscapeClosure#processVirtualizable(ValueNode, FixedNode, BlockT, GraphEffectList)::: partial escape closure process virtualizable:::tool->reset->return->virtualize
PartialEscapeClosure#virtualize(ValueNode, VirtualizerTool)::: partial escape closure virtualize:::virtualize->return
PartialEscapeClosure#processNodeWithScalarReplacedInputs(ValueNode, FixedNode, BlockT, GraphEffectList):::This tries to canonicalize the node based on improved (replaced) inputs.:::canonicalizedValue->if->canonicalizable->valueObj->canonicalizable->getValue->getObjectState->valueAlias->valueObj->getMaterializedValue->canonicalizable->getValue->getScalarAlias->if->canonicalizable->getValue->canonicalizable->canonical->else->if->canonicalizable->xObj->canonicalizable->getX->getObjectState->xAlias->xObj->getMaterializedValue->canonicalizable->getX->getScalarAlias->yObj->canonicalizable->getY->getObjectState->yAlias->yObj->getMaterializedValue->canonicalizable->getY->getScalarAlias->if->canonicalizable->getX->canonicalizable->getY->canonicalizable->canonical->else->return->if->if->canonicalizedValue->isAlive->alias->getAliasAndResolve->if->addVirtualAlias->effects->deleteNode->else->effects->replaceAtUsages->addScalarAlias->else->if->prepareCanonicalNode->VirtualUtil->node->getOptions->trace->return->if->effects->replaceWithSink->state->markAsDead->else->effects->replaceAtUsages->addScalarAlias->VirtualUtil->node->getOptions->trace->return->return
PartialEscapeClosure#prepareCanonicalNode(ValueNode, BlockT, GraphEffectList):::Nodes created during canonicalizations need to be scanned for values that were replaced.:::foreach->node->inputPositions->input->pos->get->if->if->input->isAlive->if->obj->getObjectState->if->if->obj->isVirtual->return->else->pos->obj->getMaterializedValue->initialize->else->pos->getScalarAlias->initialize->else->if->prepareCanonicalNode->return->return
PartialEscapeClosure#processNodeInputs(ValueNode, FixedNode, BlockT, GraphEffectList):::This replaces all inputs that point to virtual or materialized values with the actual value, materializing if necessary:::VirtualUtil->node->getOptions->trace->foreach->node->inputs->if->alias->getAlias->if->id->getObjectId->ensureMaterialized->effects->state->getObjectState->getMaterializedValue->replaceFirstInput->VirtualUtil->node->getOptions->trace->if->processNodeWithState
PartialEscapeClosure#processNodeWithState(NodeWithState, BlockT, GraphEffectList)::: partial escape closure process node with state:::foreach->nodeWithState->states->frameState->getUniqueFramestate->virtual->EconomicSet->create->frameState->new->CollectVirtualObjectsClosure->applyToNonVirtual->collectLockedVirtualObjects->collectReferencedVirtualObjects->addVirtualMappings
PartialEscapeClosure#getUniqueFramestate(NodeWithState, FrameState)::: partial escape closure get unique framestate:::if->frameState->hasMoreThanOneUsage->copy->frameState->copyWithInputs->nodeWithState->asNode->replaceFirstInput->return->return
PartialEscapeClosure#addVirtualMappings(FrameState, EconomicSet, BlockT, GraphEffectList)::: partial escape closure add virtual mappings:::foreach->effects->state->getObjectState->createEscapeObjectState->addVirtualMapping
PartialEscapeClosure#collectReferencedVirtualObjects(BlockT, EconomicSet)::: partial escape closure collect referenced virtual objects:::iterator->virtual->iterator->while->iterator->hasNext->object->iterator->next->id->object->getObjectId->if->objState->state->getObjectStateOptional->if->objState->isVirtual->foreach->objState->getEntries->if->entryVirtual->if->virtual->contains->virtual->add
PartialEscapeClosure#collectLockedVirtualObjects(BlockT, EconomicSet)::: partial escape closure collect locked virtual objects:::for->i->state->getStateCount
PartialEscapeClosure#ensureMaterialized(PartialEscapeBlockState, int, FixedNode, GraphEffectList, CounterKey)::: partial escape closure ensure materialized:::if->state->getObjectState->isVirtual->counter->increment->virtual->virtualObjects->get->state->materializeBefore->return->else->return
PartialEscapeClosure#updateStatesForMaterialized(PartialEscapeBlockState, VirtualObjectNode, ValueNode)::: partial escape closure update states for materialized:::change->for->i->state->getStateCount->return
PartialEscapeClosure#stripKilledLoopLocations(Loop, BlockT)::: partial escape closure strip killed loop locations:::initialState->super->stripKilledLoopLocations->if->loop->getDepth->getOptions->getValue->loopBegin->loop->getHeader->getBeginNode->end->loopBegin->forwardEnd->loopPredecessor->loop->getHeader->getFirstPredecessor->length->initialState->getStateCount->change->ensureVirtualized->new->BitSet->for->i->do->for->i->while->for->i->return
PartialEscapeClosure#processInitialLoopState(Loop, BlockT)::: partial escape closure process initial loop state:::foreach->loop->getHeader->getBeginNode->phis->if->phi->valueAt->alias->phi->valueAt->getAliasAndResolve->if->virtual->addVirtualAlias->else->aliases->set
PartialEscapeClosure#processLoopExit(LoopExitNode, BlockT, BlockT, GraphEffectList)::: partial escape closure process loop exit:::if->exitNode->graph->hasValueProxies->proxies->EconomicMap->create->foreach->exitNode->proxies->alias->proxy->value->getAlias->if->virtual->proxies->virtual->getObjectId->put->for->i->exitState->getStateCount
PartialEscapeClosure#processMaterializedAtLoopExit(LoopExitNode, GraphEffectList, EconomicMap, int, ObjectState, ObjectState, PartialEscapeBlockState)::: partial escape closure process materialized at loop exit:::if->initialObjState->isVirtual->proxy->proxies->get->if->exitObjState->getMaterializedValue->new->ValueProxyNode->effects->addFloatingNode->else->effects->proxy->value->exitObjState->getMaterializedValue->replaceFirstInput->exitState->updateMaterializedValue->else->if->initialObjState->getMaterializedValue->exitObjState->getMaterializedValue->exitNode->getDebug->initialObjState->getMaterializedValue->exitObjState->getMaterializedValue->log
PartialEscapeClosure#processVirtualAtLoopExit(LoopExitNode, GraphEffectList, int, ObjectState, ObjectState, PartialEscapeBlockState)::: partial escape closure process virtual at loop exit:::for->i->exitObjState->getEntries
PartialEscapeClosure#createMergeProcessor(Block)::: partial escape closure create merge processor:::return->new->MergeProcessor
PartialEscapeClosure.MergeProcessor#getPhi(T, Stamp)::: merge processor get phi:::if->return->getPhiCached->else->return->createValuePhi
PartialEscapeClosure.MergeProcessor#getPhiCached(T, Stamp)::: merge processor get phi cached:::if->EconomicMap->create->result->materializedPhis->get->if->createValuePhi->materializedPhis->put->return
PartialEscapeClosure.MergeProcessor#getValuePhis(ValueNode, int)::: merge processor get value phis:::if->return->getValuePhisCached->else->return->new->ValuePhiNodeArr
PartialEscapeClosure.MergeProcessor#getValuePhisCached(ValueNode, int)::: merge processor get value phis cached:::if->EconomicMap->create->result->valuePhis->get->if->new->ValuePhiNodeArr->valuePhis->put->return
PartialEscapeClosure.MergeProcessor#getValueObjectVirtual(ValuePhiNode, VirtualObjectNode)::: merge processor get value object virtual:::if->return->getValueObjectVirtualCached->else->duplicate->virtual->duplicate->duplicate->virtual->getNodeSourcePosition->setNodeSourcePosition->return
PartialEscapeClosure.MergeProcessor#getValueObjectVirtualCached(ValuePhiNode, VirtualObjectNode)::: merge processor get value object virtual cached:::if->EconomicMap->create->result->valueObjectVirtuals->get->if->virtual->duplicate->result->virtual->getNodeSourcePosition->setNodeSourcePosition->valueObjectVirtuals->put->return
PartialEscapeClosure.MergeProcessor#merge(List):::Merge all predecessor block states into one block state:::states->statesList->size->new->PartialEscapeBlockState<?>Arr->for->i->statesList->size->virtualObjTemp->intersectVirtualObjects->forceMaterialization->forcedMaterializationValue->frameState->merge->stateAfter->if->frameState->isExceptionHandlingBCI->if->frameState->stackSize->merge->next->unwind->merge->next->if->unwind->exception->frameState->stackAt->nullLocals->for->i->frameState->localsSize->if->unwind->exception->materialized->do->if->PartialEscapeBlockState->identicalObjectStates->newState->adoptAddObjectStates->else->foreach->if->PartialEscapeBlockState->identicalObjectStates->newState->getObjectState->share->addObject->continue->virtualCount->startObj->getObjectState->locksMatch->ensureVirtual->uniqueMaterializedValue->startObj->isVirtual->startObj->getMaterializedValue->for->i->if->mergeObjectStates->else->if->newState->new->ObjectState->addObject->else->materializedValuePhi->StampFactory->forKind->getPhi->mergeEffects->addFloatingNode->for->i->newState->new->ObjectState->addObject->foreach->getPhis->aliases->set->if->hasVirtualInputs->isMarked->processPhi->if->newState->virtualObjects->size->resetObjectStates->mergeEffects->clear->afterMergeEffects->clear->while
PartialEscapeClosure.MergeProcessor#intersectVirtualObjects(PartialEscapeBlockState[])::: merge processor intersect virtual objects:::length->getStateCount->for->i->count->for->objectIndex->index->resultInts->new->intArr->for->objectIndex->return
PartialEscapeClosure.MergeProcessor#intersectObjectState(PartialEscapeBlockState[], int)::: merge processor intersect object state:::for->i->return
PartialEscapeClosure.MergeProcessor#mergeObjectStates(int, int[], PartialEscapeBlockState[]):::Try to merge multiple virtual object states into a single object state:::compatible->ensureVirtual->getObject->virtual->virtualObjects->get->entryCount->virtual->entryCount->twoSlotKinds->for->i->if->for->valueIndex->if->values->getObject->applyAsInt->getObjectState->getEntries->clone->phis->virtual->entryCount->getValuePhis->valueIndex->while->for->i->if->stamp->stamp->isCompatible->stamp->unrestricted->createValuePhi->if->ConstantNode->JavaConstant->forIllegal->tool->getMetaAccess->graph->forConstant->materialized->for->i->newState->getObject->applyAsInt->getObjectState->getLocks->new->ObjectState->addObject->return->else->materializedValuePhi->StampFactory->forKind->getPhi->for->i->newState->new->ObjectState->addObject->return
PartialEscapeClosure.MergeProcessor#mergeObjectEntry(IntUnaryOperator, PartialEscapeBlockState[], PhiNode, int):::Fill the inputs of the PhiNode corresponding to one JavaKind#Object entry in the virtual object.:::materialized->for->i->return
PartialEscapeClosure.MergeProcessor#processPhi(ValuePhiNode, PartialEscapeBlockState[]):::Examine a PhiNode and try to replace it with merging of virtual objects if all its inputs refer to virtual object states:::virtualInputs->uniqueVirtualObject->ensureVirtual->virtualObjs->new->VirtualObjectNodeArr->for->i->if->if->addVirtualAlias->mergeEffects->deleteNode->return->else->compatible->firstVirtual->for->i->if->for->i->if->virtual->getValueObjectVirtual->mergeEffects->addFloatingNode->mergeEffects->deleteNode->if->virtual->getObjectId->id->virtualObjects->size->virtualObjects->add->virtual->setObjectId->virtualObjectIds->new->intArr->for->i->materialized->virtual->getObjectId->mergeObjectStates->addVirtualAlias->addVirtualAlias->return->materialized->if->for->i->for->i->return
PartialEscapeClosure.MergeProcessor#isSingleUsageAllocation(ValueNode, VirtualObjectNode[], PartialEscapeBlockState)::: merge processor is single usage allocation:::if->value->hasExactlyOneUsage->return->singleVirtual->for->v->return
PartialEscapeClosure#getObjectState(PartialEscapeBlockState, ValueNode)::: partial escape closure get object state:::if->return->if->value->isAlive->aliases->isNew->object->aliases->get->return->state->getObjectStateOptional->else->if->return->state->getObjectStateOptional->return
PartialEscapeClosure#getAlias(ValueNode)::: partial escape closure get alias:::if->if->value->isAlive->aliases->isNew->result->aliases->get->if->return->return
PartialEscapeClosure#getAliasAndResolve(PartialEscapeBlockState, ValueNode)::: partial escape closure get alias and resolve:::result->getAlias->if->id->getObjectId->if->state->getObjectState->isVirtual->state->getObjectState->getMaterializedValue->return
PartialEscapeClosure#addVirtualAlias(VirtualObjectNode, ValueNode)::: partial escape closure add virtual alias:::if->node->isAlive->aliases->set->foreach->node->usages->markVirtualUsages
PartialEscapeClosure#markVirtualUsages(Node)::: partial escape closure mark virtual usages:::if->hasVirtualInputs->isNew->hasVirtualInputs->isMarked->hasVirtualInputs->mark->if->foreach->node->usages->markVirtualUsages
PartialEscapePhase#postIteration(StructuredGraph, CoreProviders, EconomicSet)::: partial escape phase post iteration:::super->postIteration->if->cleanupPhase->apply
PartialEscapePhase#run(StructuredGraph, CoreProviders)::: partial escape phase run:::if->VirtualUtil->EscapeAnalyzeOnly->graph->getOptions->getValue->matches->if->graph->hasVirtualizableAllocation->runAnalysis
PartialEscapePhase#createEffectsClosure(CoreProviders, ScheduleResult, ControlFlowGraph)::: partial escape phase create effects closure:::foreach->getNodes->virtual->resetObjectId->if->return->context->getMetaAccess->context->getConstantReflection->context->getConstantFieldProvider->context->getLowerer->new->PEReadEliminationClosure->else->return->context->getMetaAccess->context->getConstantReflection->context->getConstantFieldProvider->context->getLowerer->new->PartialEscapeClosure.Final
PartialEscapePhase#checkContract()::: partial escape phase check contract:::return
PEReadEliminationBlockState.ReadCacheEntry#hashCode()::: read cache entry hash code:::result->identity->hashCode->System->identityHashCode->kind->ordinal->return
PEReadEliminationBlockState.ReadCacheEntry#equals(Object)::: read cache entry equals:::if->return->other->return->identity->equals
PEReadEliminationBlockState.ReadCacheEntry#toString()::: read cache entry to string:::return
PEReadEliminationBlockState#toString()::: read elimination block state to string:::return->super->toString
PEReadEliminationBlockState#stampToJavaKind(Stamp)::: read elimination block state stamp to java kind:::if->switch->getBits->return->return->return->isPositive->return->return->throw->new->IllegalArgumentException->else->return->stamp->getStackKind
PEReadEliminationBlockState#objectMaterialized(VirtualObjectNode, AllocatedObjectNode, List)::: read elimination block state object materialized:::if->instance->for->i->instance->entryCount
PEReadEliminationBlockState#equivalentTo(PEReadEliminationBlockState)::: read elimination block state equivalent to:::if->isSubMapOf->return->return->super->equivalentTo
PEReadEliminationBlockState#addReadCache(ValueNode, LocationIdentity, int, JavaKind, boolean, ValueNode, PartialEscapeClosure)::: read elimination block state add read cache:::cacheObject->obj->closure->getObjectState->if->obj->getMaterializedValue->else->readCache->new->ReadCacheEntry->put
PEReadEliminationBlockState#getReadCache(ValueNode, LocationIdentity, int, JavaKind, PartialEscapeClosure)::: read elimination block state get read cache:::cacheObject->obj->closure->getObjectState->if->obj->getMaterializedValue->else->cacheValue->readCache->new->ReadCacheEntry->get->closure->getObjectState->if->obj->getMaterializedValue->else->closure->getScalarAlias->return
PEReadEliminationBlockState#killReadCache()::: read elimination block state kill read cache:::readCache->clear
PEReadEliminationBlockState#killReadCache(LocationIdentity, int)::: read elimination block state kill read cache:::iter->readCache->getKeys->iterator->while->iter->hasNext->entry->iter->next->if->equals->iter->remove
PEReadEliminationBlockState#getReadCache()::: read elimination block state get read cache:::return
PEReadEliminationClosure#getInitialState()::: read elimination closure get initial state:::return->tool->getOptions->tool->getDebug->new->PEReadEliminationBlockState
PEReadEliminationClosure#processNode(Node, PEReadEliminationBlockState, GraphEffectList, FixedWithNextNode)::: read elimination closure process node:::if->super->processNode->return->if->return->processLoadField->else->if->return->processStoreField->else->if->return->processLoadIndexed->else->if->return->processStoreIndexed->else->if->return->processArrayLength->else->if->return->processUnbox->else->if->return->processUnsafeLoad->else->if->return->processUnsafeStore->else->if->COUNTER_MEMORYCHECKPOINT->node->getDebug->increment->identity->getLocationIdentity->processIdentity->else->if->COUNTER_MEMORYCHECKPOINT->node->getDebug->increment->foreach->getLocationIdentities->processIdentity->return
PEReadEliminationClosure#processStore(FixedNode, ValueNode, LocationIdentity, int, JavaKind, boolean, ValueNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process store:::unproxiedObject->GraphUtil->unproxify->cachedValue->state->getReadCache->finalValue->getScalarAlias->result->if->GraphUtil->unproxify->GraphUtil->unproxify->effects->deleteNode->state->killReadCache->state->addReadCache->return
PEReadEliminationClosure#processLoad(FixedNode, ValueNode, LocationIdentity, int, JavaKind, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process load:::unproxiedObject->GraphUtil->unproxify->cachedValue->state->getReadCache->if->effects->replaceAtUsages->addScalarAlias->return->else->state->addReadCache->return
PEReadEliminationClosure#isOverflowAccess(JavaKind, JavaKind)::: read elimination closure is overflow access:::if->return->if->switch->return->return->return->declaredKind->isPrimitive->accessKind->getBitCount->declaredKind->getBitCount
PEReadEliminationClosure#processUnsafeLoad(RawLoadNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process unsafe load:::if->load->offset->isConstant->type->StampTool->load->object->typeOrNull->if->type->isArray->accessKind->load->accessKind->componentKind->type->getComponentType->getJavaKind->offset->load->offset->asJavaConstant->asLong->index->VirtualArrayNode->tool->getMetaAccess->type->getComponentType->entryIndexForOffset->if->object->GraphUtil->load->object->unproxify->location->NamedLocationIdentity->getArrayLocation->cachedValue->state->getReadCache->if->effects->replaceAtUsages->addScalarAlias->return->else->state->isOverflowAccess->addReadCache->return
PEReadEliminationClosure#processUnsafeStore(RawStoreNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process unsafe store:::type->StampTool->store->object->typeOrNull->if->type->isArray->accessKind->store->accessKind->componentKind->type->getComponentType->getJavaKind->location->NamedLocationIdentity->getArrayLocation->if->store->offset->isConstant->offset->store->offset->asJavaConstant->asLong->overflowAccess->isOverflowAccess->index->VirtualArrayNode->tool->getMetaAccess->type->getComponentType->entryIndexForOffset->if->return->store->object->store->value->processStore->else->state->killReadCache->else->processIdentity->else->state->killReadCache->return
PEReadEliminationClosure#processArrayLength(ArrayLengthNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process array length:::return->length->array->processLoad
PEReadEliminationClosure#processStoreField(StoreFieldNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process store field:::if->store->isVolatile->state->killReadCache->return->kind->store->field->getJavaKind->return->store->object->store->field->new->FieldLocationIdentity->store->value->processStore
PEReadEliminationClosure#processLoadField(LoadFieldNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process load field:::if->load->isVolatile->state->killReadCache->return->return->load->object->load->field->new->FieldLocationIdentity->load->field->getJavaKind->processLoad
PEReadEliminationClosure#processStoreIndexed(StoreIndexedNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process store indexed:::index->store->index->isConstant->store->index->asConstant->asInt->elementKind->store->elementKind->arrayLocation->NamedLocationIdentity->getArrayLocation->if->return->store->array->store->value->processStore->else->state->killReadCache->return
PEReadEliminationClosure#processLoadIndexed(LoadIndexedNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process load indexed:::if->load->index->isConstant->index->load->index->asConstant->asInt->elementKind->load->elementKind->arrayLocation->NamedLocationIdentity->getArrayLocation->return->load->array->processLoad->return
PEReadEliminationClosure#processUnbox(UnboxNode, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process unbox:::return->unbox->getValue->UNBOX_LOCATIONS->unbox->getBoxingKind->get->unbox->getBoxingKind->processLoad
PEReadEliminationClosure#processIdentity(PEReadEliminationBlockState, LocationIdentity)::: read elimination closure process identity:::if->identity->isAny->state->killReadCache->else->state->killReadCache
PEReadEliminationClosure#processInitialLoopState(Loop, PEReadEliminationBlockState)::: read elimination closure process initial loop state:::super->processInitialLoopState->if->initialState->getReadCache->isEmpty->firstValueSet->foreach->loop->getHeader->getBeginNode->phis->firstValue->phi->valueAt->if->phi->getStackKind->isObject->unproxified->GraphUtil->unproxify->if->EconomicMap->create->pair->Pair->firstValueSet->get->create->firstValueSet->put->if->entries->initialState->getReadCache->size->new->ReadCacheEntryArr->z->foreach->initialState->getReadCache->getKeys->foreach->object->if->pair->firstValueSet->get->while->initialState->pair->getLeft->initialState->getReadCache->get->addReadCache->pair->getRight
PEReadEliminationClosure#processLoopExit(LoopExitNode, PEReadEliminationBlockState, PEReadEliminationBlockState, GraphEffectList)::: read elimination closure process loop exit:::super->processLoopExit->if->exitNode->graph->hasValueProxies->entry->exitState->getReadCache->getEntries->while->entry->advance->if->initialState->getReadCache->entry->getKey->get->entry->getValue->value->exitState->entry->getKey->entry->getKey->entry->getKey->entry->getKey->getReadCache->if->proxyPoint->proxy->new->ValueProxyNode->effects->addFloatingNode->exitState->getReadCache->entry->getKey->put
PEReadEliminationClosure#cloneState(PEReadEliminationBlockState)::: read elimination closure clone state:::return->new->PEReadEliminationBlockState
PEReadEliminationClosure#createMergeProcessor(Block)::: read elimination closure create merge processor:::return->new->ReadEliminationMergeProcessor
PEReadEliminationClosure.ReadEliminationMergeProcessor#merge(List)::: read elimination merge processor merge:::super->merge->mergeReadCache
PEReadEliminationClosure.ReadEliminationMergeProcessor#mergeReadCache(List)::: read elimination merge processor merge read cache:::cursor->states->get->getEntries->while->cursor->advance->key->cursor->getKey->value->cursor->getValue->phi->for->i->states->size->if->phiNode->value->stamp->unrestricted->getPhi->mergeEffects->addFloatingNode->for->i->states->size->put->else->if->put->foreach->getPhis->if->phi->getStackKind->foreach->states->get->getKeys->if->getPhiValueAt->mergeReadCachePhi
PEReadEliminationClosure.ReadEliminationMergeProcessor#mergeReadCachePhi(PhiNode, LocationIdentity, int, JavaKind, boolean, List)::: read elimination merge processor merge read cache phi:::values->states->size->new->ValueNodeArr->states->get->getPhiValueAt->getReadCache->if->for->i->states->size->phiNode->new->ReadCacheEntry->stamp->unrestricted->getPhi->mergeEffects->addFloatingNode->for->i->new->ReadCacheEntry->put
PEReadEliminationClosure#processKilledLoopLocations(Loop, PEReadEliminationBlockState, PEReadEliminationBlockState)::: read elimination closure process killed loop locations:::if->size->loopKilledLocations->loopLocationKillCache->get->if->new->LoopKillCache->loopLocationKillCache->put->else->beginNode->loop->getHeader->getBeginNode->options->beginNode->getOptions->if->loopKilledLocations->visits->ReadEliminationMaxLoopVisits->getValue->loopKilledLocations->setKillsAll->else->forwardEndLiveLocations->EconomicSet->create->foreach->getKeys->forwardEndLiveLocations->add->foreach->getKeys->forwardEndLiveLocations->remove->foreach->loopKilledLocations->rememberLoopKilledLocation->if->debug->isLogEnabled->debug->log->loopKilledLocations->visited
PEReadEliminationClosure#stripKilledLoopLocations(Loop, PEReadEliminationBlockState)::: read elimination closure strip killed loop locations:::initialState->super->stripKilledLoopLocations->loopKilledLocations->loopLocationKillCache->get->if->loopKilledLocations->loopKillsLocations->it->getKeys->iterator->while->it->hasNext->entry->it->next->if->loopKilledLocations->containsLocation->it->remove->return
ReadEliminationBlockState.CacheEntry#duplicateWithObject(ValueNode)::: cache entry duplicate with object:::
ReadEliminationBlockState.CacheEntry#hashCode()::: cache entry hash code:::result->identity->hashCode->return->object->hashCode
ReadEliminationBlockState.CacheEntry#equals(Object)::: cache entry equals:::if->return->other->return->identity->equals
ReadEliminationBlockState.CacheEntry#toString()::: cache entry to string:::return
ReadEliminationBlockState.CacheEntry#conflicts(LocationIdentity)::: cache entry conflicts:::
ReadEliminationBlockState.CacheEntry#getIdentity()::: cache entry get identity:::
ReadEliminationBlockState.LoadCacheEntry#duplicateWithObject(ValueNode)::: load cache entry duplicate with object:::return->new->LoadCacheEntry
ReadEliminationBlockState.LoadCacheEntry#conflicts(LocationIdentity)::: load cache entry conflicts:::return->identity->equals
ReadEliminationBlockState.LoadCacheEntry#getIdentity()::: load cache entry get identity:::return
ReadEliminationBlockState.UnsafeLoadCacheEntry#duplicateWithObject(ValueNode)::: unsafe load cache entry duplicate with object:::return->new->UnsafeLoadCacheEntry
ReadEliminationBlockState.UnsafeLoadCacheEntry#conflicts(LocationIdentity)::: unsafe load cache entry conflicts:::return->locationIdentity->equals
ReadEliminationBlockState.UnsafeLoadCacheEntry#hashCode()::: unsafe load cache entry hash code:::return->super->hashCode->locationIdentity->hashCode
ReadEliminationBlockState.UnsafeLoadCacheEntry#equals(Object)::: unsafe load cache entry equals:::if->other->return->super->equals->locationIdentity->equals->return
ReadEliminationBlockState.UnsafeLoadCacheEntry#getIdentity()::: unsafe load cache entry get identity:::return
ReadEliminationBlockState.UnsafeLoadCacheEntry#toString()::: unsafe load cache entry to string:::return->super->toString
ReadEliminationBlockState#toString()::: read elimination block state to string:::return->super->toString
ReadEliminationBlockState#equivalentTo(ReadEliminationBlockState)::: read elimination block state equivalent to:::return->isSubMapOf
ReadEliminationBlockState#addCacheEntry(CacheEntry, ValueNode)::: read elimination block state add cache entry:::readCache->put
ReadEliminationBlockState#getCacheEntry(CacheEntry)::: read elimination block state get cache entry:::return->readCache->get
ReadEliminationBlockState#killReadCache()::: read elimination block state kill read cache:::readCache->clear
ReadEliminationBlockState#killReadCache(LocationIdentity)::: read elimination block state kill read cache:::iterator->readCache->getKeys->iterator->while->iterator->hasNext->entry->iterator->next->if->entry->conflicts->iterator->remove
ReadEliminationBlockState#getReadCache()::: read elimination block state get read cache:::return
ReadEliminationClosure#getInitialState()::: read elimination closure get initial state:::return->new->ReadEliminationBlockState
ReadEliminationClosure#processNode(Node, ReadEliminationBlockState, GraphEffectList, FixedWithNextNode)::: read elimination closure process node:::deleted->if->access->if->access->isVolatile->any->processIdentity->else->object->GraphUtil->access->object->unproxify->identifier->access->field->new->FieldLocationIdentity->new->LoadCacheEntry->cachedValue->state->getCacheEntry->if->if->access->stamp->cachedValue->stamp->isCompatible->effects->replaceAtUsages->addScalarAlias->else->state->addCacheEntry->else->store->value->store->value->getScalarAlias->if->GraphUtil->unproxify->GraphUtil->unproxify->effects->deleteNode->state->killReadCache->state->addCacheEntry->else->if->read->if->read->getLocationIdentity->isSingle->object->GraphUtil->read->getAddress->unproxify->identifier->read->getLocationIdentity->new->LoadCacheEntry->cachedValue->state->getCacheEntry->if->areValuesReplaceable->effects->replaceAtUsages->addScalarAlias->else->state->addCacheEntry->else->if->write->if->write->getLocationIdentity->isSingle->object->GraphUtil->write->getAddress->unproxify->identifier->write->getLocationIdentity->new->LoadCacheEntry->cachedValue->state->getCacheEntry->value->write->value->getScalarAlias->if->GraphUtil->unproxify->GraphUtil->unproxify->effects->deleteNode->write->getLocationIdentity->processIdentity->state->addCacheEntry->else->write->getLocationIdentity->processIdentity->else->if->type->StampTool->object->typeOrNull->if->type->isArray->if->load->if->load->getLocationIdentity->isSingle->object->GraphUtil->load->object->unproxify->identifier->load->offset->load->getLocationIdentity->new->UnsafeLoadCacheEntry->cachedValue->state->getCacheEntry->if->areValuesReplaceable->effects->replaceAtUsages->addScalarAlias->else->state->addCacheEntry->else->write->if->write->getLocationIdentity->isSingle->object->GraphUtil->write->object->unproxify->identifier->write->offset->write->getLocationIdentity->new->UnsafeLoadCacheEntry->cachedValue->state->getCacheEntry->value->write->value->getScalarAlias->if->GraphUtil->unproxify->GraphUtil->unproxify->effects->deleteNode->write->getLocationIdentity->processIdentity->state->addCacheEntry->else->write->getLocationIdentity->processIdentity->else->if->identity->getLocationIdentity->processIdentity->else->if->foreach->getLocationIdentities->processIdentity->return
ReadEliminationClosure#areValuesReplaceable(ValueNode, ValueNode, boolean)::: read elimination closure are values replaceable:::return->originalValue->stamp->replacementValue->stamp->isCompatible->getGuard->getGuard->getGuard
ReadEliminationClosure#getGuard(ValueNode)::: read elimination closure get guard:::if->guardedNode->return->guardedNode->getGuard->return
ReadEliminationClosure#processIdentity(ReadEliminationBlockState, LocationIdentity)::: read elimination closure process identity:::if->identity->isAny->state->killReadCache->return->state->killReadCache
ReadEliminationClosure#processLoopExit(LoopExitNode, ReadEliminationBlockState, ReadEliminationBlockState, GraphEffectList)::: read elimination closure process loop exit:::if->exitNode->graph->hasValueProxies->entry->exitState->getReadCache->getEntries->while->entry->advance->if->initialState->getReadCache->entry->getKey->get->entry->getValue->proxy->exitState->entry->getKey->getCacheEntry->new->ValueProxyNode->effects->addFloatingNode->exitState->getReadCache->entry->getKey->put
ReadEliminationClosure#cloneState(ReadEliminationBlockState)::: read elimination closure clone state:::return->new->ReadEliminationBlockState
ReadEliminationClosure#createMergeProcessor(Block)::: read elimination closure create merge processor:::return->new->ReadEliminationMergeProcessor
ReadEliminationClosure.ReadEliminationMergeProcessor#getCachedPhi(CacheEntry, Stamp)::: read elimination merge processor get cached phi:::result->materializedPhis->get->if->createValuePhi->materializedPhis->put->return
ReadEliminationClosure.ReadEliminationMergeProcessor#merge(List)::: read elimination merge processor merge:::cursor->states->get->getEntries->while->cursor->advance->key->cursor->getKey->value->cursor->getValue->phi->for->i->states->size->if->phiNode->value->stamp->unrestricted->getCachedPhi->mergeEffects->addFloatingNode->for->i->states->size->newState->addCacheEntry->else->if->newState->addCacheEntry->foreach->getPhis->if->phi->getStackKind->foreach->states->get->getKeys->if->getPhiValueAt->mergeReadCachePhi
ReadEliminationClosure.ReadEliminationMergeProcessor#mergeReadCachePhi(PhiNode, CacheEntry, List)::: read elimination merge processor merge read cache phi:::values->states->size->new->ValueNodeArr->states->get->identifier->getPhiValueAt->duplicateWithObject->getCacheEntry->if->for->i->states->size->newIdentifier->identifier->duplicateWithObject->phiNode->stamp->unrestricted->getCachedPhi->mergeEffects->addFloatingNode->for->i->newState->addCacheEntry
ReadEliminationClosure#processKilledLoopLocations(Loop, ReadEliminationBlockState, ReadEliminationBlockState)::: read elimination closure process killed loop locations:::if->size->loopKilledLocations->loopLocationKillCache->get->if->new->LoopKillCache->loopLocationKillCache->put->else->options->loop->getHeader->getBeginNode->getOptions->if->loopKilledLocations->visits->ReadEliminationMaxLoopVisits->getValue->loopKilledLocations->setKillsAll->else->forwardEndLiveLocations->EconomicSet->create->foreach->getKeys->forwardEndLiveLocations->entry->getIdentity->add->foreach->getKeys->forwardEndLiveLocations->entry->getIdentity->remove->foreach->loopKilledLocations->rememberLoopKilledLocation->if->debug->isLogEnabled->debug->loop->getHeader->getBeginNode->log->loopKilledLocations->visited
ReadEliminationClosure#stripKilledLoopLocations(Loop, ReadEliminationBlockState)::: read elimination closure strip killed loop locations:::initialState->super->stripKilledLoopLocations->loopKilledLocations->loopLocationKillCache->get->if->loopKilledLocations->loopKillsLocations->it->getKeys->iterator->while->it->hasNext->entry->it->next->if->loopKilledLocations->entry->getIdentity->containsLocation->it->remove->return
VirtualizerToolImpl#getOptions()::: virtualizer tool impl get options:::return
VirtualizerToolImpl#getDebug()::: virtualizer tool impl get debug:::return
VirtualizerToolImpl#getConstantFieldProvider()::: virtualizer tool impl get constant field provider:::return
VirtualizerToolImpl#reset(PartialEscapeBlockState, ValueNode, FixedNode, GraphEffectList)::: virtualizer tool impl reset:::
VirtualizerToolImpl#isDeleted()::: virtualizer tool impl is deleted:::return
VirtualizerToolImpl#getAlias(ValueNode)::: virtualizer tool impl get alias:::return->closure->getAliasAndResolve
VirtualizerToolImpl#getEntry(VirtualObjectNode, int)::: virtualizer tool impl get entry:::return->state->getObjectState->getEntry
VirtualizerToolImpl#setVirtualEntry(VirtualObjectNode, int, ValueNode, JavaKind, long)::: virtualizer tool impl set virtual entry:::obj->state->getObjectState->entryKind->virtual->entryKind->accessKind->newValue->closure->getAliasAndResolve->getDebug->virtual->getObjectId->state->virtual->getObjectId->getObjectState->log->oldValue->getEntry->canVirtualize->accessKind->getStackKind->if->if->oldValue->getStackKind->newValue->getStackKind->oldValue->getStackKind->isPrimitive->getDebug->oldValue->getStackKind->log->else->if->nextIndex->virtual->getMetaAccess->entryIndexForOffset->if->getDebug->log->if->getDebug->log->state->virtual->getObjectId->setEntry->if->if->accessKind->needsTwoSlots->state->virtual->getObjectId->getIllegalConstant->setEntry->else->if->oldValue->getStackKind->oldValue->getStackKind->getDebug->log->secondHalf->UnpackEndianHalfNode->create->addNode->state->virtual->getObjectId->setEntry->if->oldValue->isConstant->oldValue->asConstant->JavaConstant->forIllegal->equals->previous->getEntry->getDebug->log->firstHalf->UnpackEndianHalfNode->create->addNode->state->virtual->getObjectId->setEntry->return->return
VirtualizerToolImpl#getIllegalConstant()::: virtualizer tool impl get illegal constant:::if->ConstantNode->JavaConstant->forIllegal->getMetaAccess->forConstant->addNode->return
VirtualizerToolImpl#setEnsureVirtualized(VirtualObjectNode, boolean)::: virtualizer tool impl set ensure virtualized:::id->virtualObject->getObjectId->state->setEnsureVirtualized
VirtualizerToolImpl#getEnsureVirtualized(VirtualObjectNode)::: virtualizer tool impl get ensure virtualized:::return->state->getObjectState->getEnsureVirtualized
VirtualizerToolImpl#replaceWithVirtual(VirtualObjectNode)::: virtualizer tool impl replace with virtual:::closure->addVirtualAlias->effects->deleteNode
VirtualizerToolImpl#replaceWithValue(ValueNode)::: virtualizer tool impl replace with value:::effects->closure->getScalarAlias->replaceAtUsages->closure->addScalarAlias
VirtualizerToolImpl#delete()::: virtualizer tool impl delete:::effects->deleteNode
VirtualizerToolImpl#replaceFirstInput(Node, Node)::: virtualizer tool impl replace first input:::effects->replaceFirstInput
VirtualizerToolImpl#addNode(ValueNode)::: virtualizer tool impl add node:::if->effects->addFloatingNode->else->effects->addFixedNodeBefore
VirtualizerToolImpl#createVirtualObject(VirtualObjectNode, ValueNode[], List, boolean)::: virtualizer tool impl create virtual object:::VirtualUtil->trace->if->virtualObject->isAlive->effects->addFloatingNode->for->i->id->virtualObject->getObjectId->if->size->add->virtualObject->setObjectId->state->new->ObjectState->addObject->closure->addVirtualAlias->increment->effects->addVirtualizationDelta
VirtualizerToolImpl#getMaximumEntryCount()::: virtualizer tool impl get maximum entry count:::return->MaximumEscapeAnalysisArrayLength->current->getOptions->getValue
VirtualizerToolImpl#replaceWith(ValueNode)::: virtualizer tool impl replace with:::if->replaceWithVirtual->else->replaceWithValue
VirtualizerToolImpl#ensureMaterialized(VirtualObjectNode)::: virtualizer tool impl ensure materialized:::return->closure->virtualObject->getObjectId->ensureMaterialized
VirtualizerToolImpl#addLock(VirtualObjectNode, MonitorIdNode)::: virtualizer tool impl add lock:::id->virtualObject->getObjectId->state->addLock
VirtualizerToolImpl#removeLock(VirtualObjectNode)::: virtualizer tool impl remove lock:::id->virtualObject->getObjectId->return->state->removeLock
VirtualizerToolImpl#getMetaAccess()::: virtualizer tool impl get meta access:::return
VirtualizerToolImpl#getConstantReflection()::: virtualizer tool impl get constant reflection:::return
VirtualizerToolImpl#canonicalizeReads()::: virtualizer tool impl canonicalize reads:::return
VirtualizerToolImpl#allUsagesAvailable()::: virtualizer tool impl all usages available:::return
VirtualizerToolImpl#getAssumptions()::: virtualizer tool impl get assumptions:::return
VirtualizerToolImpl#smallestCompareWidth()::: virtualizer tool impl smallest compare width:::if->return->loweringProvider->smallestCompareWidth->else->return
VirtualUtil#assertNonReachable(StructuredGraph, List)::: virtual util assert non reachable:::debug->graph->getDebug->flood->graph->createNodeFlood->path->EconomicMap->create->flood->graph->start->add->foreach->if->end->flood->end->merge->add->if->path->end->merge->containsKey->path->end->merge->put->else->foreach->current->successors->flood->add->if->path->containsKey->path->put->foreach->if->node->isDeleted->foreach->graph->getNodes->if->flood->isMarked->foreach->node->inputs->flood->add->if->path->containsKey->path->put->foreach->foreach->current->inputs->flood->add->if->path->containsKey->path->put->success->foreach->if->node->isDeleted->flood->isMarked->node->getNodeClass->valueNumberable->TTY->println->current->TTY->current->toString->print->while->path->get->if->TTY->current->toString->print->if->obsoleteNodes->contains->break->if->TTY->println->debug->forceDump->return
VirtualUtil#trace(OptionValues, DebugContext, String)::: virtual util trace:::if->debug->areScopesEnabled->TraceEscapeAnalysis->getValue->debug->isLogEnabled->debug->log
VirtualUtil#trace(OptionValues, DebugContext, String, Object)::: virtual util trace:::if->debug->areScopesEnabled->TraceEscapeAnalysis->getValue->debug->isLogEnabled->debug->logv
VirtualUtil#trace(OptionValues, DebugContext, String, Object, Object)::: virtual util trace:::if->debug->areScopesEnabled->TraceEscapeAnalysis->getValue->debug->isLogEnabled->debug->logv
VirtualUtil#trace(OptionValues, DebugContext, String, Object, Object, Object)::: virtual util trace:::if->debug->areScopesEnabled->TraceEscapeAnalysis->getValue->debug->isLogEnabled->debug->logv
VirtualUtil#trace(OptionValues, DebugContext, String, Object, Object, Object, Object)::: virtual util trace:::if->debug->areScopesEnabled->TraceEscapeAnalysis->getValue->debug->isLogEnabled->debug->logv
VirtualUtil#matches(StructuredGraph, String)::: virtual util matches:::if->return->matchesHelper->return
VirtualUtil#matchesHelper(StructuredGraph, String)::: virtual util matches helper:::if->filter->startsWith->method->graph->method->return->method->format->filter->substring->contains->else->method->graph->method->return->method->format->contains
