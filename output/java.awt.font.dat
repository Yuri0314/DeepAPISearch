CharArrayIterator#first():::Sets the position to getBeginIndex() and returns the character at that position.:::return->current
CharArrayIterator#last():::Sets the position to getEndIndex()-1 (getEndIndex() if the text is empty) and returns the character at that position.:::if->else->return->current
CharArrayIterator#current():::Gets the character at the current position (as returned by getIndex()).:::if->return->else->return
CharArrayIterator#next():::Increments the iterator's index by one and returns the character at the new index:::if->return->else->return
CharArrayIterator#previous():::Decrements the iterator's index by one and returns the character at the new index:::if->return->else->return
CharArrayIterator#setIndex(int):::Sets the position to the specified position in the text and returns that character.:::if->throw->new->IllegalArgumentException->return->current
CharArrayIterator#getBeginIndex():::Returns the start index of the text.:::return
CharArrayIterator#getEndIndex():::Returns the end index of the text:::return
CharArrayIterator#getIndex():::Returns the current index.:::return
CharArrayIterator#clone():::Create a copy of this iterator:::c->new->CharArrayIterator->return
CharArrayIterator#reset(char[])::: char array iterator reset:::reset
CharArrayIterator#reset(char[], int)::: char array iterator reset:::
FontRenderContext#isTransformed():::Indicates whether or not this FontRenderContext object measures text in a transformed render context.:::if->return->else->return->getTransform->isIdentity
FontRenderContext#getTransformType():::Returns the integer type of the affine transform for this FontRenderContext as specified by java.awt.geom.AffineTransform#getType():::if->if->return->else->return->tx->getType->else->return->getTransform->getType
FontRenderContext#getTransform():::  Gets the transform that is used to scale typographical points   to pixels in this FontRenderContext.:::return->new->AffineTransform->new->AffineTransform
FontRenderContext#isAntiAliased():::Returns a boolean which indicates whether or not some form of antialiasing is specified by this FontRenderContext:::return
FontRenderContext#usesFractionalMetrics():::Returns a boolean which whether text fractional metrics mode is used in this FontRenderContext:::return
FontRenderContext#getAntiAliasingHint():::Return the text anti-aliasing rendering mode hint used in this FontRenderContext:::if->if->isAntiAliased->return->else->return->return
FontRenderContext#getFractionalMetricsHint():::Return the text fractional metrics rendering mode hint used in this FontRenderContext:::if->if->usesFractionalMetrics->return->else->return->return
FontRenderContext#equals(Object):::Return true if obj is an instance of FontRenderContext and has the same transform, antialiasing, and fractional metrics values as this.:::try->return->equals->catch->return->finally
FontRenderContext#equals(FontRenderContext):::Return true if rhs has the same transform, antialiasing, and fractional metrics values as this.:::if->return->if->return->if->if->return->tx->equals->return->else->return->rhs->getAntiAliasingHint->getAntiAliasingHint->rhs->getFractionalMetricsHint->getFractionalMetricsHint->rhs->getTransform->getTransform->equals
FontRenderContext#hashCode():::Return a hashcode for this FontRenderContext.:::hash->tx->hashCode->if->getAntiAliasingHint->hashCode->getFractionalMetricsHint->hashCode->else->aaHintValue->hashCode->fmHintValue->hashCode->return
GlyphJustificationInfo#priorityIsValid(int)::: glyph justification info priority is valid:::return
GlyphMetrics#getAdvance():::Returns the advance of the glyph along the baseline (either horizontal or vertical).:::return
GlyphMetrics#getAdvanceX():::Returns the x-component of the advance of the glyph.:::return
GlyphMetrics#getAdvanceY():::Returns the y-component of the advance of the glyph.:::return
GlyphMetrics#getBounds2D():::Returns the bounds of the glyph:::return->new->Rectangle2D.Float
GlyphMetrics#getLSB():::Returns the left (top) side bearing of the glyph:::return
GlyphMetrics#getRSB():::Returns the right (bottom) side bearing of the glyph:::return
GlyphMetrics#getType():::Returns the raw glyph type code.:::return
GlyphMetrics#isStandard():::Returns true if this is a standard glyph.:::return
GlyphMetrics#isLigature():::Returns true if this is a ligature glyph.:::return
GlyphMetrics#isCombining():::Returns true if this is a combining glyph.:::return
GlyphMetrics#isComponent():::Returns true if this is a component glyph.:::return
GlyphMetrics#isWhitespace():::Returns true if this is a whitespace glyph.:::return
GlyphVector#getFont():::Returns the Font associated with this GlyphVector.:::
GlyphVector#getFontRenderContext():::Returns the FontRenderContext associated with this GlyphVector.:::
GlyphVector#performDefaultLayout():::Assigns default positions to each glyph in this GlyphVector:::
GlyphVector#getNumGlyphs():::Returns the number of glyphs in this GlyphVector.:::
GlyphVector#getGlyphCode(int):::Returns the glyphcode of the specified glyph:::
GlyphVector#getGlyphCodes(int, int, int[]):::Returns an array of glyphcodes for the specified glyphs:::
GlyphVector#getGlyphCharIndex(int):::Returns the character index of the specified glyph:::return
GlyphVector#getGlyphCharIndices(int, int, int[]):::Returns the character indices of the specified glyphs:::if->new->intArr->for->i->j->return
GlyphVector#getLogicalBounds():::Returns the logical bounds of this GlyphVector:::
GlyphVector#getVisualBounds():::Returns the visual bounds of this GlyphVector The visual bounds is the bounding box of the outline of this GlyphVector:::
GlyphVector#getPixelBounds(FontRenderContext, float, float):::Returns the pixel bounds of this GlyphVector when rendered in a graphics with the given FontRenderContext at the given location:::rect->getVisualBounds->l->Math->rect->getX->floor->t->Math->rect->getY->floor->r->Math->rect->getMaxX->ceil->b->Math->rect->getMaxY->ceil->return->new->Rectangle
GlyphVector#getOutline():::Returns a Shape whose interior corresponds to the visual representation of this GlyphVector.:::
GlyphVector#getOutline(float, float):::Returns a Shape whose interior corresponds to the visual representation of this GlyphVector when rendered at x,&nbsp;y.:::
GlyphVector#getGlyphOutline(int):::Returns a Shape whose interior corresponds to the visual representation of the specified glyph within this GlyphVector:::
GlyphVector#getGlyphOutline(int, float, float):::Returns a Shape whose interior corresponds to the visual representation of the specified glyph within this GlyphVector, offset to x,&nbsp;y:::s->getGlyphOutline->at->AffineTransform->getTranslateInstance->return->at->createTransformedShape
GlyphVector#getGlyphPosition(int):::Returns the position of the specified glyph relative to the origin of this GlyphVector:::
GlyphVector#setGlyphPosition(int, Point2D):::Sets the position of the specified glyph within this GlyphVector:::
GlyphVector#getGlyphTransform(int):::Returns the transform of the specified glyph within this GlyphVector:::
GlyphVector#setGlyphTransform(int, AffineTransform):::Sets the transform of the specified glyph within this GlyphVector:::
GlyphVector#getLayoutFlags():::Returns flags describing the global state of the GlyphVector:::return
GlyphVector#getGlyphPositions(int, int, float[]):::Returns an array of glyph positions for the specified glyphs:::
GlyphVector#getGlyphLogicalBounds(int):::Returns the logical bounds of the specified glyph within this GlyphVector:::
GlyphVector#getGlyphVisualBounds(int):::Returns the visual bounds of the specified glyph within the GlyphVector:::
GlyphVector#getGlyphPixelBounds(int, FontRenderContext, float, float):::Returns the pixel bounds of the glyph at index when this GlyphVector is rendered in a Graphics with the given FontRenderContext at the given location:::rect->getGlyphVisualBounds->getBounds2D->l->Math->rect->getX->floor->t->Math->rect->getY->floor->r->Math->rect->getMaxX->ceil->b->Math->rect->getMaxY->ceil->return->new->Rectangle
GlyphVector#getGlyphMetrics(int):::Returns the metrics of the glyph at the specified index into this GlyphVector.:::
GlyphVector#getGlyphJustificationInfo(int):::Returns the justification information for the glyph at the specified index into this GlyphVector.:::
GlyphVector#equals(GlyphVector):::Tests if the specified GlyphVector exactly equals this GlyphVector.:::
GraphicAttribute#getAscent():::Returns the ascent of this GraphicAttribute:::
GraphicAttribute#getDescent():::Returns the descent of this GraphicAttribute:::
GraphicAttribute#getAdvance():::Returns the advance of this GraphicAttribute:::
GraphicAttribute#getBounds():::Returns a Rectangle2D that encloses all of the bits drawn by this GraphicAttribute relative to the rendering position:::ascent->getAscent->return->getAdvance->getDescent->new->Rectangle2D.Float
GraphicAttribute#getOutline(AffineTransform):::Return a java.awt.Shape that represents the region that this GraphicAttribute renders:::b->getBounds->if->tx->createTransformedShape->return
GraphicAttribute#draw(Graphics2D, float, float):::Renders this GraphicAttribute at the specified location.:::
GraphicAttribute#getAlignment():::Returns the alignment of this GraphicAttribute:::return
GraphicAttribute#getJustificationInfo():::Returns the justification information for this GraphicAttribute:::advance->getAdvance->return->new->GlyphJustificationInfo
ImageGraphicAttribute#getAscent():::Returns the ascent of this ImageGraphicAttribute:::return->Math->max
ImageGraphicAttribute#getDescent():::Returns the descent of this ImageGraphicAttribute:::return->Math->max
ImageGraphicAttribute#getAdvance():::Returns the advance of this ImageGraphicAttribute:::return->Math->max
ImageGraphicAttribute#getBounds():::Returns a Rectangle2D that encloses all of the bits rendered by this ImageGraphicAttribute, relative to the rendering position:::return->new->Rectangle2D.Float
ImageGraphicAttribute#draw(Graphics2D, float, float)::: image graphic attribute draw:::graphics->drawImage
ImageGraphicAttribute#hashCode():::Returns a hashcode for this ImageGraphicAttribute.:::return->fImage->hashCode
ImageGraphicAttribute#equals(Object):::Compares this ImageGraphicAttribute to the specified Object.:::try->return->equals->catch->return->finally
ImageGraphicAttribute#equals(ImageGraphicAttribute):::Compares this ImageGraphicAttribute to the specified ImageGraphicAttribute.:::if->return->if->return->if->return->if->getAlignment->rhs->getAlignment->return->if->fImage->equals->return->return
JavaAWTFontAccessImpl#getTextAttributeConstant(String)::: java font access impl get text attribute constant:::switch->return->return->return->return->throw->new->AssertionError
JavaAWTFontAccessImpl#shape(Object, char[], int, int)::: java font access impl shape:::shape
LayoutPath#pointToPath(Point2D, Point2D):::Convert a point in user space to a location relative to the path:::
LayoutPath#pathToPoint(Point2D, boolean, Point2D):::Convert a location relative to the path to a point in user coordinates:::
LineBreakMeasurer#nextOffset(float):::Returns the position at the end of the next layout:::return->nextOffset
LineBreakMeasurer#nextOffset(float, int, boolean):::Returns the position at the end of the next layout:::nextOffset->if->if->throw->new->IllegalArgumentException->charAtMaxAdvance->measurer->getLineBreakIndex->if->else->if->Character->measurer->getChars->isWhitespace->breakIter->following->else->testPos->if->breakIter->last->breakIter->previous->else->breakIter->preceding->if->if->else->Math->max->if->return
LineBreakMeasurer#nextLayout(float):::Returns the next layout, and updates the current position.:::return->nextLayout
LineBreakMeasurer#nextLayout(float, int, boolean):::Returns the next layout, and updates the current position.:::if->layoutLimit->nextOffset->if->return->result->measurer->getLayout->return->else->return
LineBreakMeasurer#getPosition():::Returns the current position of this LineBreakMeasurer.:::return
LineBreakMeasurer#setPosition(int):::Sets the current position of this LineBreakMeasurer.:::if->throw->new->IllegalArgumentException
LineBreakMeasurer#insertChar(AttributedCharacterIterator, int):::Updates this LineBreakMeasurer after a single character is inserted into the text, and sets the current position to the beginning of the paragraph.:::measurer->insertChar->newParagraph->getEndIndex->newParagraph->getBeginIndex->charIter->measurer->getChars->newParagraph->getBeginIndex->reset->breakIter->setText
LineBreakMeasurer#deleteChar(AttributedCharacterIterator, int):::Updates this LineBreakMeasurer after a single character is deleted from the text, and sets the current position to the beginning of the paragraph.:::measurer->deleteChar->newParagraph->getEndIndex->newParagraph->getBeginIndex->charIter->measurer->getChars->reset->breakIter->setText
LineMetrics#getNumChars():::Returns the number of characters (char values) in the text whose metrics are encapsulated by this LineMetrics object.:::
LineMetrics#getAscent():::Returns the ascent of the text:::
LineMetrics#getDescent():::Returns the descent of the text:::
LineMetrics#getLeading():::Returns the leading of the text:::
LineMetrics#getHeight():::Returns the height of the text:::
LineMetrics#getBaselineIndex():::Returns the baseline index of the text:::
LineMetrics#getBaselineOffsets():::Returns the baseline offsets of the text, relative to the baseline of the text:::
LineMetrics#getStrikethroughOffset():::Returns the position of the strike-through line relative to the baseline.:::
LineMetrics#getStrikethroughThickness():::Returns the thickness of the strike-through line.:::
LineMetrics#getUnderlineOffset():::Returns the position of the underline relative to the baseline.:::
LineMetrics#getUnderlineThickness():::Returns the thickness of the underline.:::
MultipleMaster#getNumDesignAxes():::Returns the number of multiple master design controls:::
MultipleMaster#getDesignAxisRanges():::Returns an array of design limits interleaved in the form [from&rarr;to] for each axis:::
MultipleMaster#getDesignAxisDefaults():::Returns an array of default design values for each axis:::
MultipleMaster#getDesignAxisNames():::Returns the name for each design axis:::
MultipleMaster#deriveMMFont(float[]):::Creates a new instance of a multiple master font based on the design axis values contained in the specified array:::
MultipleMaster#deriveMMFont(float[], float, float, float, float):::Creates a new instance of a multiple master font based on detailed metric information:::
NumericShaper#getContextKey(char)::: numeric shaper get context key:::if->while->else->if->while->return
NumericShaper#rangeForCodePoint(int)::: numeric shaper range for code point:::if->currentRange->inRange->return->ranges->if->lo->hi->while->mid->range->if->else->if->else->return->else->for->i->return
NumericShaper#isStrongDirectional(char)::: numeric shaper is strong directional:::cachedIndex->if->search->else->if->search->val->return
NumericShaper#getKeyFromMask(int)::: numeric shaper get key from mask:::key->while->if->throw->Integer->toHexString->new->IllegalArgumentException->return
NumericShaper#getShaper(int):::Returns a shaper for the provided unicode range:::key->getKeyFromMask->return->new->NumericShaper
NumericShaper#getShaper(Range):::Returns a shaper for the provided Unicode range:::return->EnumSet->of->new->NumericShaper
NumericShaper#getContextualShaper(int):::Returns a contextual shaper for the provided unicode range(s):::return->new->NumericShaper
NumericShaper#getContextualShaper(Set):::Returns a contextual shaper for the provided Unicode range(s):::shaper->new->NumericShaper->return
NumericShaper#getContextualShaper(int, int):::Returns a contextual shaper for the provided unicode range(s):::key->getKeyFromMask->return->new->NumericShaper
NumericShaper#getContextualShaper(Set, Range):::Returns a contextual shaper for the provided Unicode range(s):::if->throw->new->NullPointerException->shaper->new->NumericShaper->return
NumericShaper#shape(char[], int, int):::Converts the digits in the text that occur between start and start + count.:::checkParams->if->isContextual->if->shapeContextually->else->shapeContextually->else->shapeNonContextually
NumericShaper#shape(char[], int, int, int):::Converts the digits in the text that occur between start and start + count, using the provided context:::checkParams->if->isContextual->ctxKey->getKeyFromMask->if->shapeContextually->else->Range->values->shapeContextually->else->shapeNonContextually
NumericShaper#shape(char[], int, int, Range):::Converts the digits in the text that occur between start and start + count, using the provided context:::checkParams->if->throw->new->NullPointerException->if->isContextual->if->shapeContextually->else->key->Range->toRangeIndex->if->shapeContextually->else->shapeContextually->else->shapeNonContextually
NumericShaper#checkParams(char[], int, int)::: numeric shaper check params:::if->throw->new->NullPointerException->if->throw->new->IndexOutOfBoundsException
NumericShaper#isContextual():::Returns a boolean indicating whether or not this shaper shapes contextually.:::return
NumericShaper#getRanges():::Returns an int that ORs together the values for all the ranges that will be shaped:::return
NumericShaper#getRangeSet():::Returns a Set representing all the Unicode ranges in this NumericShaper that will be shaped.:::if->return->EnumSet->copyOf->return->Range->maskToRangeSet
NumericShaper#shapeNonContextually(char[], int, int):::Perform non-contextual shaping.:::base->minDigit->if->shapingRange->getDigitBase->shapingRange->getNumericBase->else->if->for->i->e
NumericShaper#shapeContextually(char[], int, int, int):::Perform contextual shaping:::if->lastkey->base->minDigit->synchronized->for->i->e
NumericShaper#shapeContextually(char[], int, int, Range)::: numeric shaper shape contextually:::if->rangeSet->contains->lastKey->base->ctxKey->getDigitBase->minDigit->ctxKey->getNumericBase->end->for->i
NumericShaper#hashCode():::Returns a hash code for this shaper.:::hash->if->rangeSet->hashCode->return
NumericShaper#equals(Object):::Returns true if the specified object is an instance of NumericShaper and shapes identically to this one, regardless of the range representations, the bit mask or the enum:::if->try->rhs->if->if->return->isContextual->rhs->isContextual->rangeSet->equals->return->isContextual->rhs->isContextual->rangeSet->Range->maskToRangeSet->equals->Range->indexToRange->else->if->rset->Range->maskToRangeSet->srange->Range->indexToRange->return->isContextual->rhs->isContextual->rset->equals->return->catch->finally->return
NumericShaper#toString():::Returns a String that describes this shaper:::buf->super->toString->new->StringBuilder->buf->append->isContextual->append->keyNames->if->isContextual->buf->append->buf->Range->values->append->if->buf->append->first->for->i->else->buf->append->append->buf->append->return->buf->toString
NumericShaper#getHighBit(int):::Returns the index of the high bit in value (assuming le, actually power of 2 >= value):::if->return->bit->if->if->if->if->if->return
NumericShaper#search(int, int[], int, int):::fast binary search over subrange of array.:::power->getHighBit->extra->probe->index->if->while->if->return
NumericShaper#writeObject(ObjectOutputStream):::Converts the NumericShaper.Range enum-based parameters, if any, to the bit mask-based counterparts and writes this object to the stream:::if->index->Range->toRangeIndex->if->if->Range->toRangeMask->stream->defaultWriteObject
OpenType#getVersion():::Returns the version of the OpenType font:::
OpenType#getFontTable(int):::Returns the table as an array of bytes for a specified tag:::
OpenType#getFontTable(String):::Returns the table as an array of bytes for a specified tag:::
OpenType#getFontTable(int, int, int):::Returns a subset of the table as an array of bytes for a specified tag:::
OpenType#getFontTable(String, int, int):::Returns a subset of the table as an array of bytes for a specified tag:::
OpenType#getFontTableSize(int):::Returns the size of the table for a specified tag:::
OpenType#getFontTableSize(String):::Returns the size of the table for a specified tag:::
ShapeGraphicAttribute#getAscent():::Returns the ascent of this ShapeGraphicAttribute:::return->Math->fShapeBounds->getMinY->max
ShapeGraphicAttribute#getDescent():::Returns the descent of this ShapeGraphicAttribute:::return->Math->fShapeBounds->getMaxY->max
ShapeGraphicAttribute#getAdvance():::Returns the advance of this ShapeGraphicAttribute:::return->Math->fShapeBounds->getMaxX->max
ShapeGraphicAttribute#draw(Graphics2D, float, float)::: shape graphic attribute draw:::graphics->translate->try->if->graphics->draw->else->graphics->fill->catch->finally->graphics->translate
ShapeGraphicAttribute#getBounds():::Returns a Rectangle2D that encloses all of the bits drawn by this ShapeGraphicAttribute relative to the rendering position:::bounds->new->Rectangle2D.Float->bounds->setRect->if->return
ShapeGraphicAttribute#getOutline(AffineTransform):::Return a java.awt.Shape that represents the region that this ShapeGraphicAttribute renders:::return->tx->createTransformedShape
ShapeGraphicAttribute#hashCode():::Returns a hashcode for this ShapeGraphicAttribute.:::return->fShape->hashCode
ShapeGraphicAttribute#equals(Object):::Compares this ShapeGraphicAttribute to the specified Object.:::try->return->equals->catch->return->finally
ShapeGraphicAttribute#equals(ShapeGraphicAttribute):::Compares this ShapeGraphicAttribute to the specified ShapeGraphicAttribute.:::if->return->if->return->if->return->if->getAlignment->rhs->getAlignment->return->if->fShape->equals->return->return
StyledParagraph#insertInto(int, int[], int):::Adjust indices in starts to reflect an insertion after pos:::while
StyledParagraph#insertChar(AttributedCharacterIterator, char[], int, StyledParagraph):::Return a StyledParagraph reflecting the insertion of a single character into the text:::ch->aci->setIndex->relativePos->Math->aci->getBeginIndex->max->attributes->aci->getAttributes->addInputMethodAttrs->d->Decoration->getDecoration->if->oldParagraph->getDecorationAt->equals->return->new->StyledParagraph->f->getGraphicOrFont->if->resolver->FontResolver->getInstance->fontIndex->resolver->getFontIndex->resolver->getFont->if->oldParagraph->getFontOrGraphicAt->equals->return->new->StyledParagraph->if->size->insertInto->if->size->insertInto->return
StyledParagraph#deleteFrom(int, int[], int):::Adjust indices in starts to reflect a deletion after deleteAt:::while
StyledParagraph#deleteChar(AttributedCharacterIterator, char[], int, StyledParagraph):::Return a StyledParagraph reflecting the insertion of a single character into the text:::aci->getBeginIndex->if->return->if->oldParagraph->getRunLimit->if->oldParagraph->getRunLimit->return->new->StyledParagraph->if->size->deleteFrom->if->size->deleteFrom->return
StyledParagraph#getRunLimit(int):::Return the index at which there is a different Font, GraphicAttribute, or Decoration than at the given index.:::if->throw->new->IllegalArgumentException->limit1->if->run->findRunContaining->limit2->if->run->findRunContaining->return->Math->min
StyledParagraph#getDecorationAt(int):::Return the Decoration in effect at the given index.:::if->throw->new->IllegalArgumentException->if->return->run->findRunContaining->return->decorations->elementAt
StyledParagraph#getFontOrGraphicAt(int):::Return the Font or GraphicAttribute in effect at the given index:::if->throw->new->IllegalArgumentException->if->return->run->findRunContaining->return->fonts->elementAt
StyledParagraph#findRunContaining(int, int[]):::Return i such that starts[i] &lt;= index &lt; starts[i+1]:::for->i
StyledParagraph#addToVector(Object, int, Vector, int[]):::Append the given Object to the given Vector:::if->v->lastElement->equals->v->addElement->count->v->size->if->temp->new->intArr->System->arraycopy->return
StyledParagraph#addDecoration(Decoration, int):::Add a new Decoration run with the given Decoration at the given index.:::if->addToVector->else->if->else->if->decoration->equals->new->Vector<Decoration>->decorations->addElement->decorations->addElement->new->intArr
StyledParagraph#addFont(Object, int):::Add a new Font/GraphicAttribute run with the given object at the given index.:::if->addToVector->else->if->else->if->font->equals->new->Vector<Object>->fonts->addElement->fonts->addElement->new->intArr
StyledParagraph#addFonts(char[], Map, int, int):::Resolve the given chars into Fonts using FontResolver, then add font runs for each.:::resolver->FontResolver->getInstance->iter->CodePointIterator->create->for->runStart->iter->charIndex->iter->charIndex
StyledParagraph#addInputMethodAttrs(Map):::Return a Map with entries from oldStyles, as well as input method entries, if any.:::value->oldStyles->get->try->if->if->getValue->hl->imStyles->try->hl->getStyle->catch->finally->if->tk->Toolkit->getDefaultToolkit->tk->mapInputMethodHighlight->if->newStyles->new->HashMap<>->newStyles->putAll->newStyles->putAll->return->catch->finally->return
StyledParagraph#getGraphicOrFont(Map):::Extract a GraphicAttribute or Font from the given attributes:::value->attributes->get->if->return->attributes->get->if->return->if->attributes->get->return->Font->getFont->else->return
TextAttribute#readResolve():::Resolves instances being deserialized to the predefined constants.:::if->this->getClass->throw->new->InvalidObjectException->instance->instanceMap->getName->get->if->return->else->throw->new->InvalidObjectException
TextHitInfo#getCharIndex():::Returns the index of the character hit.:::return
TextHitInfo#isLeadingEdge():::Returns true if the leading edge of the character was hit.:::return
TextHitInfo#getInsertionIndex():::Returns the insertion index:::return
TextHitInfo#hashCode():::Returns the hash code.:::return
TextHitInfo#equals(Object):::Returns true if the specified Object is a TextHitInfo and equals this TextHitInfo.:::return->equals
TextHitInfo#equals(TextHitInfo):::Returns true if the specified TextHitInfo has the same charIndex and isLeadingEdge as this TextHitInfo:::return
TextHitInfo#toString():::Returns a String representing the hit for debugging use only.:::return
TextHitInfo#leading(int):::Creates a TextHitInfo on the leading edge of the character at the specified charIndex.:::return->new->TextHitInfo
TextHitInfo#trailing(int):::Creates a hit on the trailing edge of the character at the specified charIndex.:::return->new->TextHitInfo
TextHitInfo#beforeOffset(int):::Creates a TextHitInfo at the specified offset, associated with the character before the offset.:::return->new->TextHitInfo
TextHitInfo#afterOffset(int):::Creates a TextHitInfo at the specified offset, associated with the character after the offset.:::return->new->TextHitInfo
TextHitInfo#getOtherHit():::Creates a TextHitInfo on the other side of the insertion point:::if->return->trailing->else->return->leading
TextHitInfo#getOffsetHit(int):::Creates a TextHitInfo whose character index is offset by delta from the charIndex of this TextHitInfo:::return->new->TextHitInfo
TextJustifier#justify(float):::Return an array of deltas twice as long as the original info array, indicating the amount by which each side of each glyph should grow or shrink:::deltas->new->floatArr->grow->if->println->fallbackPriority->for->p->if->total->for->i->println->println->return
TextLayout.CaretPolicy#getStrongCaret(TextHitInfo, TextHitInfo, TextLayout):::Chooses one of the specified TextHitInfo instances as a strong caret in the specified TextLayout.:::return->layout->getStrongHit
TextLayout#singleFont(char[], int, int, Map)::: text layout single font:::if->attributes->get->return->font->try->attributes->get->catch->finally->if->if->attributes->get->Font->getFont->if->font->canDisplayUpTo->return->else->resolver->FontResolver->getInstance->iter->CodePointIterator->create->fontIndex->resolver->nextFontRunIndex->if->iter->charIndex->resolver->getFont->if->sameBaselineUpTo->return->return
TextLayout#paragraphInit(byte, CoreMetrics, Map, char[]):::Initialize the paragraph-specific data.:::TextLine->getNormalizedOffsets->AttributeValues->getJustification->shaper->AttributeValues->getNumericShaping->if->shaper->shape
TextLayout#fastInit(char[], Font, Map, FontRenderContext)::: text layout fast init:::lm->font->getLineMetrics->cm->CoreMetrics->get->glyphBaseline->if->else->paragraphInit->TextLine->fastCreateTextLine
TextLayout#standardInit(AttributedCharacterIterator, char[], FontRenderContext)::: text layout standard init:::paragraphAttrs->text->getAttributes->haveFont->TextLine->advanceToFirstFont->if->defaultFont->TextLine->getFontAtCurrentPos->charsStart->text->getIndex->text->getBeginIndex->lm->defaultFont->getLineMetrics->cm->CoreMetrics->get->paragraphInit->else->graphic->paragraphAttrs->get->defaultBaseline->getBaselineFromGraphic->cm->GraphicComponent->createCoreMetrics->paragraphInit->TextLine->standardCreateTextLine
TextLayout#ensureCache()::: text layout ensure cache:::if->buildCache
TextLayout#buildCache()::: text layout build cache:::textLine->getMetrics->if->textLine->isDirectionLTR->lastNonSpace->while->logIndex->textLine->visualToLogical->if->textLine->isCharSpace->break->else->if->else->if->else->logIndex->textLine->visualToLogical->textLine->getCharLinePosition->textLine->getCharAdvance->else->leftmostNonSpace->while->logIndex->textLine->visualToLogical->if->textLine->isCharSpace->break->else->if->else->if->else->logIndex->textLine->visualToLogical->pos->textLine->getCharLinePosition
TextLayout#getNaturalBounds():::The 'natural bounds' encloses all the carets the layout can draw.:::ensureCache->if->textLine->getItalicBounds->return
TextLayout#clone():::Creates a copy of this TextLayout.:::try->return->super->clone->catch->throw->new->InternalError->finally
TextLayout#checkTextHit(TextHitInfo)::: text layout check text hit:::if->throw->new->IllegalArgumentException->if->hit->getInsertionIndex->hit->getInsertionIndex->throw->new->IllegalArgumentException
TextLayout#getJustifiedLayout(float):::Creates a copy of this TextLayout justified to the specified width:::if->throw->new->IllegalArgumentException->if->throw->new->Error->ensureCache->limit->while->textLine->isCharWhitespace->newLine->textLine->getJustifiedLine->if->return->new->TextLayout->return
TextLayout#handleJustify(float):::Justify this layout:::
TextLayout#getBaseline():::Returns the baseline for this TextLayout:::return
TextLayout#getBaselineOffsets():::Returns the offsets array for the baselines used for this TextLayout:::offsets->new->floatArr->System->arraycopy->return
TextLayout#getAdvance():::Returns the advance of this TextLayout:::ensureCache->return
TextLayout#getVisibleAdvance():::Returns the advance of this TextLayout, minus trailing whitespace:::ensureCache->return
TextLayout#getAscent():::Returns the ascent of this TextLayout:::ensureCache->return
TextLayout#getDescent():::Returns the descent of this TextLayout:::ensureCache->return
TextLayout#getLeading():::Returns the leading of the TextLayout:::ensureCache->return
TextLayout#getBounds():::Returns the bounds of this TextLayout:::ensureCache->if->vb->textLine->getVisualBounds->if->vb->vb->getX->vb->getY->vb->getWidth->vb->getHeight->setRect->bounds->new->Rectangle2D.Float->bounds->setRect->return
TextLayout#getPixelBounds(FontRenderContext, float, float):::Returns the pixel bounds of this TextLayout when rendered in a graphics with the given FontRenderContext at the given location:::return->textLine->getPixelBounds
TextLayout#isLeftToRight():::Returns true if this TextLayout has a left-to-right base direction or false if it has a right-to-left base direction:::return->textLine->isDirectionLTR
TextLayout#isVertical():::Returns true if this TextLayout is vertical.:::return
TextLayout#getCharacterCount():::Returns the number of characters represented by this TextLayout.:::return
TextLayout#getCaretInfo(int, Rectangle2D, float[])::: text layout get caret info:::top1X->top2X->bottom1X->bottom2X->if->pos->logIndex->if->textLine->visualToLogical->textLine->getCharLinePosition->textLine->getCharAdvance->else->textLine->visualToLogical->textLine->getCharLinePosition->angle->textLine->getCharAngle->shift->textLine->getCharShift->textLine->getCharAscent->textLine->getCharDescent->else->logIndex->textLine->visualToLogical->angle1->textLine->getCharAngle->pos1->textLine->getCharLinePosition->textLine->getCharAdvance->if->textLine->getCharShift->textLine->getCharAscent->textLine->getCharDescent->else->logIndex->textLine->visualToLogical->angle2->textLine->getCharAngle->pos2->textLine->getCharLinePosition->if->textLine->getCharShift->textLine->getCharAscent->textLine->getCharDescent->else->topX->bottomX->if->new->floatArr->if->bounds->getWidth->bounds->getX->else->bounds->getHeight->bounds->getMaxY->return
TextLayout#getCaretInfo(TextHitInfo, Rectangle2D):::Returns information about the caret corresponding to hit:::ensureCache->checkTextHit->return->getCaretInfoTestInternal
TextLayout#getCaretInfoTestInternal(TextHitInfo, Rectangle2D)::: text layout get caret info test internal:::ensureCache->checkTextHit->info->new->floatArr->hitToCaret->getCaretInfo->iangle->ixbase->p1x->p1y->p2x->p2y->charix->hit->getCharIndex->lead->hit->isLeadingEdge->ltr->textLine->isDirectionLTR->horiz->isVertical->if->m->textLine->getMetrics->low->if->else->else->thiscm->textLine->getCoreMetricsAt->textLine->getCharLinePosition->if->m->textLine->getMetrics->if->if->else->else->else->bo->if->else->return
TextLayout#getCaretInfo(TextHitInfo):::Returns information about the caret corresponding to hit:::return->getNaturalBounds->getCaretInfo
TextLayout#hitToCaret(TextHitInfo):::Returns a caret index corresponding to hit:::hitIndex->hit->getCharIndex->if->return->textLine->isDirectionLTR->else->if->return->textLine->isDirectionLTR->visIndex->textLine->logicalToVisual->if->hit->isLeadingEdge->textLine->isCharLTR->return
TextLayout#caretToHit(int):::Given a caret index, return a hit whose caret is at the index:::if->if->textLine->isDirectionLTR->return->TextHitInfo->leading->else->return->TextHitInfo->trailing->else->charIndex->textLine->visualToLogical->leading->textLine->isCharLTR->return->TextHitInfo->leading->TextHitInfo->trailing
TextLayout#caretIsValid(int)::: text layout caret is valid:::if->return->offset->textLine->visualToLogical->if->textLine->isCharLTR->textLine->visualToLogical->if->textLine->isCharLTR->return->return->textLine->caretAtOffsetIsValid
TextLayout#getNextRightHit(TextHitInfo):::Returns the hit for the next caret to the right (bottom); if there is no such hit, returns null:::ensureCache->checkTextHit->caret->hitToCaret->if->return->do->while->caretIsValid->return->caretToHit
TextLayout#getNextRightHit(int, CaretPolicy):::Returns the hit for the next caret to the right (bottom); if no such hit, returns null:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->hit1->TextHitInfo->afterOffset->hit2->hit1->getOtherHit->nextHit->policy->getStrongCaret->getNextRightHit->if->otherHit->getVisualOtherHit->return->policy->getStrongCaret->else->return
TextLayout#getNextRightHit(int):::Returns the hit for the next caret to the right (bottom); if no such hit, returns null:::return->getNextRightHit
TextLayout#getNextLeftHit(TextHitInfo):::Returns the hit for the next caret to the left (top); if no such hit, returns null:::ensureCache->checkTextHit->caret->hitToCaret->if->return->do->while->caretIsValid->return->caretToHit
TextLayout#getNextLeftHit(int, CaretPolicy):::Returns the hit for the next caret to the left (top); if no such hit, returns null:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->hit1->TextHitInfo->afterOffset->hit2->hit1->getOtherHit->nextHit->policy->getStrongCaret->getNextLeftHit->if->otherHit->getVisualOtherHit->return->policy->getStrongCaret->else->return
TextLayout#getNextLeftHit(int):::Returns the hit for the next caret to the left (top); if no such hit, returns null:::return->getNextLeftHit
TextLayout#getVisualOtherHit(TextHitInfo):::Returns the hit on the opposite side of the specified hit's caret.:::ensureCache->checkTextHit->hitCharIndex->hit->getCharIndex->charIndex->leading->if->visIndex->if->textLine->isDirectionLTR->else->textLine->visualToLogical->if->textLine->isDirectionLTR->textLine->isCharLTR->else->textLine->isCharLTR->else->visIndex->textLine->logicalToVisual->movedToRight->if->textLine->isCharLTR->hit->isLeadingEdge->else->if->textLine->visualToLogical->textLine->isCharLTR->else->textLine->isDirectionLTR->return->TextHitInfo->leading->TextHitInfo->trailing
TextLayout#getCaretPath(TextHitInfo, Rectangle2D)::: text layout get caret path:::info->getCaretInfo->return->new->doubleArr
TextLayout#getCaretPath(int, Rectangle2D, boolean):::Return an array of four floats corresponding the endpoints of the caret x0, y0, x1, y1:::info->getCaretInfo->pos->slope->x0->y0->x1->y1->x2->y2->left->bounds->getX->right->bounds->getWidth->top->bounds->getY->bottom->bounds->getHeight->threePoints->if->if->else->if->if->if->else->if->else->if->if->else->else->if->else->if->if->if->else->if->else->if->if->else->return->new->doubleArr->new->doubleArr
TextLayout#pathToShape(double[], boolean, LayoutPathImpl)::: text layout path to shape:::result->new->GeneralPath->result->moveTo->for->i->if->result->closePath->if->lp->mapShape->return
TextLayout#getCaretShape(TextHitInfo, Rectangle2D):::Returns a Shape representing the caret at the specified hit inside the specified bounds.:::ensureCache->checkTextHit->if->throw->new->IllegalArgumentException->return->getCaretPath->textLine->getLayoutPath->pathToShape
TextLayout#getCaretShape(TextHitInfo):::Returns a Shape representing the caret at the specified hit inside the natural bounds of this TextLayout.:::return->getNaturalBounds->getCaretShape
TextLayout#getStrongHit(TextHitInfo, TextHitInfo):::Return the "stronger" of the TextHitInfos:::hit1Level->hit1->getCharIndex->getCharacterLevel->hit2Level->hit2->getCharIndex->getCharacterLevel->if->if->hit2->isLeadingEdge->hit1->isLeadingEdge->return->else->return->else->return
TextLayout#getCharacterLevel(int):::Returns the level of the character at index:::if->throw->new->IllegalArgumentException->ensureCache->if->return->textLine->isDirectionLTR->return->textLine->getCharLevel
TextLayout#getCaretShapes(int, Rectangle2D, CaretPolicy):::Returns two paths corresponding to the strong and weak caret.:::ensureCache->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->result->new->ShapeArr->hit->TextHitInfo->afterOffset->hitCaret->hitToCaret->lp->textLine->getLayoutPath->hitShape->getCaretPath->pathToShape->otherHit->hit->getOtherHit->otherCaret->hitToCaret->if->else->otherShape->getCaretPath->pathToShape->strongHit->policy->getStrongCaret->hitIsStrong->strongHit->equals->if->else->return
TextLayout#getCaretShapes(int, Rectangle2D):::Returns two paths corresponding to the strong and weak caret:::return->getCaretShapes
TextLayout#getCaretShapes(int):::Returns two paths corresponding to the strong and weak caret:::return->getNaturalBounds->getCaretShapes
TextLayout#boundingShape(double[], double[])::: text layout bounding shape:::result->pathToShape->sameDirection->if->else->start->limit->increment->if->else->for->i->result->closePath->return
TextLayout#caretBoundingShape(int, int, Rectangle2D)::: text layout caret bounding shape:::if->temp->return->getCaretPath->getCaretPath->boundingShape
TextLayout#leftShape(Rectangle2D)::: text layout left shape:::path0->if->new->doubleArr->bounds->getX->bounds->getY->bounds->getX->bounds->getWidth->bounds->getY->else->new->doubleArr->bounds->getX->bounds->getY->bounds->getHeight->bounds->getX->bounds->getY->path1->getCaretPath->return->boundingShape
TextLayout#rightShape(Rectangle2D)::: text layout right shape:::path1->if->new->doubleArr->bounds->getX->bounds->getY->bounds->getHeight->bounds->getX->bounds->getWidth->bounds->getY->bounds->getHeight->else->new->doubleArr->bounds->getX->bounds->getWidth->bounds->getY->bounds->getHeight->bounds->getX->bounds->getWidth->bounds->getY->path0->getCaretPath->return->boundingShape
TextLayout#getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo):::Returns the logical ranges of text corresponding to a visual selection.:::ensureCache->checkTextHit->checkTextHit->included->new->booleanArr->startIndex->hitToCaret->limitIndex->hitToCaret->if->t->if->visIndex->while->textLine->visualToLogical->count->inrun->for->i->ranges->new->intArr->for->i->if->return
TextLayout#getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D):::Returns a path enclosing the visual selection in the specified range, extended to bounds:::ensureCache->checkTextHit->checkTextHit->if->throw->new->IllegalArgumentException->result->new->GeneralPath->firstCaret->hitToCaret->secondCaret->hitToCaret->result->caretBoundingShape->append->if->ls->leftShape->if->ls->getBounds->isEmpty->result->append->if->rs->rightShape->if->rs->getBounds->isEmpty->result->append->lp->textLine->getLayoutPath->if->lp->mapShape->return
TextLayout#getVisualHighlightShape(TextHitInfo, TextHitInfo):::Returns a Shape enclosing the visual selection in the specified range, extended to the bounds:::return->getNaturalBounds->getVisualHighlightShape
TextLayout#getLogicalHighlightShape(int, int, Rectangle2D):::Returns a Shape enclosing the logical selection in the specified range, extended to the specified bounds:::if->throw->new->IllegalArgumentException->ensureCache->if->t->if->throw->new->IllegalArgumentException->result->new->GeneralPath->carets->new->intArr->count->if->logIndex->do->TextHitInfo->leading->hitToCaret->ltr->textLine->isCharLTR->do->while->textLine->isCharLTR->hitCh->TextHitInfo->trailing->hitToCaret->if->temp->new->intArr->System->arraycopy->while->else->TextHitInfo->leading->hitToCaret->for->i->if->if->textLine->isDirectionLTR->textLine->isDirectionLTR->ls->leftShape->if->ls->getBounds->isEmpty->result->append->if->textLine->isDirectionLTR->textLine->isDirectionLTR->rs->rightShape->if->rs->getBounds->isEmpty->result->append->lp->textLine->getLayoutPath->if->lp->mapShape->return
TextLayout#getLogicalHighlightShape(int, int):::Returns a Shape enclosing the logical selection in the specified range, extended to the natural bounds of this TextLayout:::return->getNaturalBounds->getLogicalHighlightShape
TextLayout#getBlackBoxBounds(int, int):::Returns the black box bounds of the characters in the specified range:::ensureCache->if->t->if->throw->new->IllegalArgumentException->result->new->GeneralPath->if->for->logIndex->if->tx->AffineTransform->getTranslateInstance->tx->createTransformedShape->lp->textLine->getLayoutPath->if->lp->mapShape->return
TextLayout#caretToPointDistance(float[], float, float):::Returns the distance from the point (x,&nbsp;y) to the caret along the line direction defined in caretInfo:::lineDistance->distanceOffBaseline->return
TextLayout#hitTestChar(float, float, Rectangle2D):::Returns a TextHitInfo corresponding to the specified point:::lp->textLine->getLayoutPath->prev->if->pt->new->Point2D.Float->lp->pointToPath->if->isVertical->if->bounds->getMinY->return->TextHitInfo->leading->else->if->bounds->getMaxY->return->TextHitInfo->trailing->else->if->bounds->getMinX->return->isLeftToRight->TextHitInfo->leading->TextHitInfo->trailing->else->if->bounds->getMaxX->return->isLeftToRight->TextHitInfo->trailing->TextHitInfo->leading->distance->index->trail->lcm->icx->icy->ia->cy->dya->ydsq->for->i->left->leading->textLine->isCharLTR->if->result->TextHitInfo->leading->TextHitInfo->trailing->return
TextLayout#hitTestChar(float, float):::Returns a TextHitInfo corresponding to the specified point:::return->getNaturalBounds->hitTestChar
TextLayout#equals(TextLayout):::Returns true if the two layouts are equal:::return->equals
TextLayout#toString():::Returns debugging information for this TextLayout.:::ensureCache->return->textLine->toString
TextLayout#draw(Graphics2D, float, float):::Renders this TextLayout at the specified location in the specified java.awt.Graphics2D Graphics2D context:::if->throw->new->IllegalArgumentException->textLine->draw
TextLayout#getTextLineForTesting():::Package-only method for testing ONLY:::return
TextLayout#sameBaselineUpTo(Font, char[], int, int):::Return the index of the first character with a different baseline from the character at start, or limit if all characters between start and limit have the same baseline.:::return
TextLayout#getBaselineFromGraphic(GraphicAttribute)::: text layout get baseline from graphic:::alignment->graphic->getAlignment->if->return->else->return
TextLayout#getOutline(AffineTransform):::Returns a Shape representing the outline of this TextLayout.:::ensureCache->result->textLine->getOutline->lp->textLine->getLayoutPath->if->lp->mapShape->return
TextLayout#getLayoutPath():::Return the LayoutPath, or null if the layout path is the default path (x maps to advance, y maps to offset).:::return->textLine->getLayoutPath
TextLayout#hitToPoint(TextHitInfo, Point2D):::Convert a hit to a point in standard coordinates:::if->throw->new->NullPointerException->ensureCache->checkTextHit->adv->off->ix->hit->getCharIndex->leading->hit->isLeadingEdge->ltr->if->textLine->characterCount->textLine->isDirectionLTR->else->textLine->isCharLTR->textLine->getCharLinePosition->textLine->getCharYPosition->point->setLocation->lp->textLine->getLayoutPath->if->lp->pathToPoint
TextLine#checkCtorArgs()::: text line check ctor args:::checkCharCount->for->i->if->this->characterCount->throw->new->IllegalArgumentException
TextLine#init()::: text line init:::ascent->descent->leading->advance->maxGraphicHeight->maxGraphicHeightWithLeading->tlc->fitTopAndBottomGraphics->for->i->if->if->if->if->new->floatArr->x->y->pcm->needPath->new->floatArr->for->i->n->if->pb->pcm->effectiveBaselineOffset->pa->pd->d->if->else->new->TextLineMetrics->if->pt->new->Point2D.Double->tx->ty->builder->new->SegmentPathBuilder->builder->moveTo->for->i->n->builder->complete->if->getComponentLogicalIndex->at->tlc->getBaselineTransform->if->new->EmptyPath
TextLine#getPixelBounds(FontRenderContext, float, float)::: text line get pixel bounds:::result->if->frc->equals->ix->Math->floor->iy->Math->floor->rx->ry->canCache->if->new->Rectangle->return->if->for->i->n->if->new->Rectangle->else->MARGIN->r2d->getVisualBounds->if->lp->mapShape->getBounds->bounds->r2d->getBounds->im->new->BufferedImage->g2d->im->createGraphics->g2d->setColor->g2d->im->getWidth->im->getHeight->fillRect->g2d->setColor->draw->computePixelBounds->if->new->Rectangle->return
TextLine#computePixelBounds(BufferedImage)::: text line compute pixel bounds:::w->im->getWidth->h->im->getHeight->l->t->r->b->buf->new->intArr->while->im->getRGB->for->i->buf->new->intArr->while->im->getRGB->for->i->while->for->i->while->for->i->return->new->Rectangle
TextLine.Function#computeFunction(TextLine, int, int)::: function compute function:::
TextLine#characterCount()::: text line character count:::return
TextLine#isDirectionLTR()::: text line is direction r:::return
TextLine#getMetrics()::: text line get metrics:::return
TextLine#visualToLogical(int)::: text line visual to logical:::if->return->if->BidiUtils->createInverseMap->return
TextLine#logicalToVisual(int)::: text line logical to visual:::return
TextLine#getCharLevel(int)::: text line get char level:::return
TextLine#isCharLTR(int)::: text line is char r:::return->getCharLevel
TextLine#getCharType(int)::: text line get char type:::return->Character->getType
TextLine#isCharSpace(int)::: text line is char space:::return->Character->isSpaceChar
TextLine#isCharWhitespace(int)::: text line is char whitespace:::return->Character->isWhitespace
TextLine#getCharAngle(int)::: text line get char angle:::return->getCoreMetricsAt
TextLine#getCoreMetricsAt(int)::: text line get core metrics at:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->currentTlc->tlcStart->tlcLimit->do->getNumCharacters->if->break->while->return->getCoreMetrics
TextLine#getCharAscent(int)::: text line get char ascent:::return->getCoreMetricsAt
TextLine#getCharDescent(int)::: text line get char descent:::return->getCoreMetricsAt
TextLine#getCharShift(int)::: text line get char shift:::return->getCoreMetricsAt
TextLine#applyFunctionAtIndex(int, Function)::: text line apply function at index:::if->throw->new->IllegalArgumentException->tlcStart->for->i->throw->new->IllegalArgumentException
TextLine#getCharAdvance(int)::: text line get char advance:::return->applyFunctionAtIndex
TextLine#getCharXPosition(int)::: text line get char position:::return->applyFunctionAtIndex
TextLine#getCharYPosition(int)::: text line get char position:::return->applyFunctionAtIndex
TextLine#getCharLinePosition(int)::: text line get char line position:::return->getCharXPosition
TextLine#getCharLinePosition(int, boolean)::: text line get char line position:::f->isCharLTR->return->applyFunctionAtIndex
TextLine#caretAtOffsetIsValid(int)::: text line caret at offset is valid:::if->throw->new->IllegalArgumentException->tlcStart->for->i->throw->new->IllegalArgumentException
TextLine#getComponentLogicalIndex(int):::map a component visual index to the logical index.:::if->return->return
TextLine#getComponentVisualIndex(int):::map a component logical index to the visual index.:::if->return->for->i->throw->new->IndexOutOfBoundsException
TextLine#getCharBounds(int)::: text line get char bounds:::if->throw->new->IllegalArgumentException->tlcStart->for->i->throw->new->IllegalArgumentException
TextLine#getComponentShift(int)::: text line get component shift:::cm->getCoreMetrics->return->cm->effectiveBaselineOffset
TextLine#draw(Graphics2D, float, float)::: text line draw:::if->for->i->n->else->oldTx->g2->getTransform->pt->new->Point2D.Float->for->i->n
TextLine#getVisualBounds():::Return the union of the visual bounds of all the components:::result->for->i->n->if->new->Rectangle2D.Float->return
TextLine#getItalicBounds()::: text line get italic bounds:::left->right->top->bottom->for->i->n->return->new->Rectangle2D.Float
TextLine#getOutline(AffineTransform)::: text line get outline:::dstShape->new->GeneralPath->for->i->n->if->dstShape->transform->return
TextLine#toString()::: text line to string:::buf->new->StringBuilder->for->i->return->buf->toString
TextLine#fastCreateTextLine(FontRenderContext, char[], Font, CoreMetrics, Map):::Create a TextLine from the text:::isDirectionLTR->levels->charsLtoV->bidi->characterCount->requiresBidi->embs->values->if->AttributeValues->fromMap->if->values->getRunDirection->values->getRunDirection->if->values->getBidiEmbedding->level->values->getBidiEmbedding->new->byteArr->for->i->if->Bidi->requiresBidi->if->bidiflags->values->getRunDirection->new->Bidi->if->bidi->isLeftToRight->BidiUtils->getLevels->charsVtoL->BidiUtils->createVisualToLogicalMap->BidiUtils->createInverseMap->bidi->baseIsLeftToRight->decorator->Decoration->getDecoration->layoutFlags->factory->new->TextLabelFactory->components->new->TextLineComponentArr->createComponentsOnRun->numComponents->while->if->temp->new->TextLineComponentArr->System->arraycopy->return->new->TextLine
TextLine#expandArray(TextLineComponent[])::: text line expand array:::newComponents->new->TextLineComponentArr->System->arraycopy->return
TextLine#createComponentsOnRun(int, int, char[], int[], byte[], TextLabelFactory, Font, CoreMetrics, FontRenderContext, Decoration, TextLineComponent[], int):::Returns an array in logical order of the TextLineComponents on the text in the given range, with the given attributes.:::pos->do->chunkLimit->firstVisualChunk->do->startPos->lmCount->if->lineMetrics->font->getLineMetrics->CoreMetrics->get->lineMetrics->getNumChars->else->nextComponent->factory->createExtended->if->expandArray->while->while->return
TextLine#getComponents(StyledParagraph, char[], int, int, int[], byte[], TextLabelFactory):::Returns an array (in logical order) of the TextLineComponents representing the text:::frc->factory->getFontRenderContext->numComponents->tempComponents->new->TextLineComponentArr->pos->do->runLimit->Math->styledParagraph->getRunLimit->min->decorator->styledParagraph->getDecorationAt->graphicOrFont->styledParagraph->getFontOrGraphicAt->if->baseRot->graphicAttribute->do->chunkLimit->firstVisualChunk->nextGraphic->new->GraphicComponent->if->expandArray->while->else->font->createComponentsOnRun->while->while->components->if->else->new->TextLineComponentArr->System->arraycopy->return
TextLine#createLineFromText(char[], StyledParagraph, TextLabelFactory, boolean, float[]):::Create a TextLine from the Font and character data over the range:::factory->setLineContext->lineBidi->factory->getLineBidi->charsLtoV->levels->if->BidiUtils->getLevels->charsVtoL->BidiUtils->createVisualToLogicalMap->BidiUtils->createInverseMap->components->getComponents->return->factory->getFontRenderContext->new->TextLine
TextLine#computeComponentOrder(TextLineComponent[], int[]):::Compute the components order from the given components array and logical-to-visual character mapping:::componentOrder->if->new->intArr->gStart->for->i->BidiUtils->createContiguousOrder->BidiUtils->createInverseMap->return
TextLine#standardCreateTextLine(FontRenderContext, AttributedCharacterIterator, char[], float[]):::Create a TextLine from the text:::styledParagraph->new->StyledParagraph->bidi->new->Bidi->if->bidi->isLeftToRight->layoutFlags->factory->new->TextLabelFactory->isDirectionLTR->if->bidi->baseIsLeftToRight->return->createLineFromText
TextLine#advanceToFirstFont(AttributedCharacterIterator):::When this returns, the ACI's current position will be at the start of the first run which does NOT contain a GraphicAttribute:::for->ch->aci->first->aci->aci->getRunLimit->setIndex->return
TextLine#getNormalizedOffsets(float[], byte)::: text line get normalized offsets:::if->base->temp->new->floatArr->for->i->return
TextLine#getFontAtCurrentPos(AttributedCharacterIterator)::: text line get font at current pos:::value->aci->getAttribute->if->return->if->aci->getAttribute->return->Font->aci->getAttributes->getFont->ch->CodePointIterator->create->next->if->resolver->FontResolver->getInstance->return->resolver->resolver->getFontIndex->aci->getAttributes->getFont->return
TextLine#firstVisualChunk(int[], byte[], int, int)::: text line first visual chunk:::if->dir->while->return->return
TextLine#getJustifiedLine(float, float, int, int)::: text line get justified line:::newComponents->new->TextLineComponentArr->System->arraycopy->leftHang->adv->justifyDelta->rejustify->do->characterCount->getAdvanceBetween->justifyAdvance->getAdvanceBetween->infoPositions->new->intArr->infoCount->for->visIndex->infos->new->GlyphJustificationInfoArr->compStart->for->i->infoStart->infoLimit->while->while->justifier->new->TextJustifier->deltas->justifier->justify->canRejustify->wantRejustify->flags->new->booleanArr->for->i->while->return->new->TextLine
TextLine#getAdvanceBetween(TextLineComponent[], int, int)::: text line get advance between:::advance->tlcStart->for->i->return
TextLine#getLayoutPath()::: text line get layout path:::return
TextMeasurer#clone()::: text measurer clone:::other->try->super->clone->catch->throw->new->Error->finally->if->fComponents->clone->return
TextMeasurer#invalidateComponents()::: text measurer invalidate components:::
TextMeasurer#initAll(AttributedCharacterIterator):::Initialize state, including fChars array, direction, and fBidi.:::text->getBeginIndex->text->getEndIndex->new->charArr->n->for->c->text->first->text->next->text->first->new->Bidi->if->fBidi->isLeftToRight->text->first->paragraphAttrs->text->getAttributes->shaper->AttributeValues->getNumericShaping->if->shaper->shape->new->StyledParagraph->AttributeValues->getJustification->haveFont->TextLine->advanceToFirstFont->if->defaultFont->TextLine->getFontAtCurrentPos->charsStart->text->getIndex->text->getBeginIndex->lm->defaultFont->getLineMetrics->lm->getBaselineIndex->lm->getBaselineOffsets->else->graphic->paragraphAttrs->get->TextLayout->getBaselineFromGraphic->fmap->new->Hashtable<>->dummyFont->new->Font->lm->dummyFont->getLineMetrics->lm->getBaselineOffsets->TextLine->getNormalizedOffsets->invalidateComponents
TextMeasurer#generateComponents(int, int):::Generate components for the paragraph:::if->layoutFlags->factory->new->TextLabelFactory->charsLtoV->if->BidiUtils->getLevels->charsVtoL->BidiUtils->createVisualToLogicalMap->BidiUtils->createInverseMap->fBidi->baseIsLeftToRight->else->try->TextLine->getComponents->catch->println->println->throw->finally
TextMeasurer#calcLineBreak(int, float)::: text measurer calc line break:::startPos->width->tlcIndex->tlcStart->for->for->if->generateComponents->return->calcLineBreak->return
TextMeasurer#trailingCdWhitespaceStart(int, int):::According to the Unicode Bidirectional Behavior specification (Unicode Standard 2.0, section 3.11), whitespace at the ends of lines which would naturally flow against the base direction must be made to flow with the line direction, and moved to the end of the line:::if->baseLevel->for->cdWsStart->return
TextMeasurer#makeComponentsOnRange(int, int)::: text measurer make components on range:::cdWsStart->trailingCdWhitespaceStart->tlcIndex->tlcStart->for->componentCount->split->compStart->lim->for->cont->if->components->new->TextLineComponentArr->newCompIndex->linePos->breakPt->subsetFlag->if->else->while->compLength->getNumCharacters->tlcLimit->start->Math->max->limit->Math->min->getSubset->if->if->return
TextMeasurer#makeTextLineOnRange(int, int)::: text measurer make text line on range:::charsLtoV->charLevels->if->lineBidi->fBidi->createLineBidi->BidiUtils->getLevels->charsVtoL->BidiUtils->createVisualToLogicalMap->BidiUtils->createInverseMap->components->makeComponentsOnRange->return->new->TextLine
TextMeasurer#ensureComponents(int, int)::: text measurer ensure components:::if->generateComponents
TextMeasurer#makeLayoutWindow(int)::: text measurer make layout window:::compStart->compLimit->if->avgLineLength->Math->max->Math->min->if->if->new->CharArrayIterator->else->charIter->reset->if->BreakIterator->getLineInstance->fLineBreak->setText->if->if->fLineBreak->isBoundary->fLineBreak->preceding->if->if->fLineBreak->isBoundary->fLineBreak->following->ensureComponents
TextMeasurer#getLineBreakIndex(int, float):::Returns the index of the first character which will not fit on on a line beginning at start and possible measuring up to maxAdvance in graphical width.:::localStart->if->makeLayoutWindow->return->calcLineBreak
TextMeasurer#getAdvanceBetween(int, int):::Returns the graphical width of a line beginning at start and including characters up to limit:::localStart->localLimit->ensureComponents->line->makeTextLineOnRange->return->line->getMetrics
TextMeasurer#getLayout(int, int):::Returns a TextLayout on the given character range.:::localStart->localLimit->ensureComponents->textLine->makeTextLineOnRange->if->return->new->TextLayout
TextMeasurer#printStats()::: text measurer print stats:::println
TextMeasurer#insertChar(AttributedCharacterIterator, int):::Updates the TextMeasurer after a single character has been inserted into the paragraph currently represented by this TextMeasurer:::if->printStats->if->newParagraph->getBeginIndex->end->newParagraph->getEndIndex->if->initAll->newChars->new->charArr->newCharIndex->System->arraycopy->newChar->newParagraph->setIndex->System->arraycopy->if->Bidi->requiresBidi->newParagraph->getAttribute->new->Bidi->if->fBidi->isLeftToRight->StyledParagraph->insertChar->invalidateComponents
TextMeasurer#deleteChar(AttributedCharacterIterator, int):::Updates the TextMeasurer after a single character has been deleted from the paragraph currently represented by this TextMeasurer:::newParagraph->getBeginIndex->end->newParagraph->getEndIndex->if->initAll->newChars->new->charArr->changedIndex->System->arraycopy->System->arraycopy->if->new->Bidi->if->fBidi->isLeftToRight->StyledParagraph->deleteChar->invalidateComponents
TextMeasurer#getChars():::NOTE:  This method is only for LineBreakMeasurer's use:::return
TransformAttribute#getTransform():::Returns a copy of the wrapped transform.:::at->return->new->AffineTransform->new->AffineTransform
TransformAttribute#isIdentity():::Returns true if the wrapped transform is an identity transform.:::return
TransformAttribute#writeObject(java.io.ObjectOutputStream)::: transform attribute write object:::if->new->AffineTransform->s->defaultWriteObject
TransformAttribute#readResolve()::: transform attribute read resolve:::if->transform->isIdentity->return->return
TransformAttribute#hashCode()::: transform attribute hash code:::return->transform->hashCode
TransformAttribute#equals(Object):::Returns true if rhs is a TransformAttribute whose transform is equal to this TransformAttribute's transform.:::if->try->that->if->return->return->transform->equals->catch->finally->return
