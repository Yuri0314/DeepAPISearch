java.util.stream.AbstractPipeline#evaluate(TerminalOp<E_OUT, R>)->R:::Evaluate the pipeline with a terminal operation to produce a result.
java.util.stream.AbstractPipeline#evaluateToArrayNode(IntFunction<E_OUT[]>)->Node<E_OUT>:::Collect the elements output from the pipeline stage.
java.util.stream.AbstractPipeline#sourceStageSpliterator()->Spliterator<E_OUT>:::Gets the source stage spliterator if this pipeline stage is the source  stage
java.util.stream.AbstractPipeline#sequential()->S:::
java.util.stream.AbstractPipeline#parallel()->S:::
java.util.stream.AbstractPipeline#close()->void:::
java.util.stream.AbstractPipeline#onClose(Runnable)->S:::
java.util.stream.AbstractPipeline#spliterator()->Spliterator<E_OUT>:::
java.util.stream.AbstractPipeline#isParallel()->boolean:::
java.util.stream.AbstractPipeline#getStreamFlags()->int:::Returns the composition of stream flags of the stream source and all  intermediate operations.
java.util.stream.AbstractPipeline#getSourceShape()->StreamShape:::
java.util.stream.AbstractPipeline#exactOutputSizeIfKnown(Spliterator<P_IN>)->long:::
java.util.stream.AbstractPipeline#wrapAndCopyInto(S, Spliterator<P_IN>)->S:::
java.util.stream.AbstractPipeline#copyInto(Sink<P_IN>, Spliterator<P_IN>)->void:::
java.util.stream.AbstractPipeline#copyIntoWithCancel(Sink<P_IN>, Spliterator<P_IN>)->boolean:::
java.util.stream.AbstractPipeline#getStreamAndOpFlags()->int:::
java.util.stream.AbstractPipeline#isOrdered()->boolean:::
java.util.stream.AbstractPipeline#wrapSink(Sink<E_OUT>)->Sink<P_IN>:::
java.util.stream.AbstractPipeline#wrapSpliterator(Spliterator<P_IN>)->Spliterator<E_OUT>:::
java.util.stream.AbstractPipeline#evaluate(Spliterator<P_IN>, boolean, IntFunction<E_OUT[]>)->Node<E_OUT>:::
java.util.stream.AbstractPipeline#getOutputShape()->StreamShape:::Get the output shape of the pipeline
java.util.stream.AbstractPipeline#evaluateToNode(PipelineHelper<E_OUT>, Spliterator<P_IN>, boolean, IntFunction<E_OUT[]>)->Node<E_OUT>:::Collect elements output from a pipeline into a Node that holds elements  of this shape.
java.util.stream.AbstractPipeline#wrap(PipelineHelper<E_OUT>, Supplier<Spliterator<P_IN>>, boolean)->Spliterator<E_OUT>:::Create a spliterator that wraps a source spliterator, compatible with  this stream shape, and operations associated with a {@link  PipelineHelper}.
java.util.stream.AbstractPipeline#lazySpliterator(Supplier<? extends Spliterator<E_OUT>>)->Spliterator<E_OUT>:::Create a lazy spliterator that wraps and obtains the supplied the  spliterator when a method is invoked on the lazy spliterator.
java.util.stream.AbstractPipeline#forEachWithCancel(Spliterator<E_OUT>, Sink<E_OUT>)->boolean:::Traverse the elements of a spliterator compatible with this stream shape,  pushing those elements into a sink
java.util.stream.AbstractPipeline#makeNodeBuilder(long, IntFunction<E_OUT[]>)->Node.Builder<E_OUT>:::Make a node builder compatible with this stream shape.
java.util.stream.AbstractPipeline#opIsStateful()->boolean:::Returns whether this operation is stateful or not
java.util.stream.AbstractPipeline#opWrapSink(int, Sink<E_OUT>)->Sink<E_IN>:::Accepts a {@code Sink} which will receive the results of this operation,  and return a {@code Sink} which accepts elements of the input type of  this operation and which performs the operation, passing the results to  the provided {@code Sink}.
java.util.stream.AbstractPipeline#opEvaluateParallel(PipelineHelper<E_OUT>, Spliterator<P_IN>, IntFunction<E_OUT[]>)->Node<E_OUT>:::Performs a parallel evaluation of the operation using the specified  {@code PipelineHelper} which describes the upstream intermediate  operations
java.util.stream.AbstractPipeline#opEvaluateParallelLazy(PipelineHelper<E_OUT>, Spliterator<P_IN>)->Spliterator<E_OUT>:::Returns a {@code Spliterator} describing a parallel evaluation of the  operation, using the specified {@code PipelineHelper} which describes the  upstream intermediate operations
java.util.stream.AbstractShortCircuitTask#getEmptyResult()->R:::Returns the value indicating the computation completed with no task  finding a short-circuitable result
java.util.stream.AbstractShortCircuitTask#compute()->void:::Overrides AbstractTask version to include checks for early  exits while splitting or computing.
java.util.stream.AbstractShortCircuitTask#shortCircuit(R)->void:::Declares that a globally valid result has been found
java.util.stream.AbstractShortCircuitTask#setLocalResult(R)->void:::Sets a local result for this task
java.util.stream.AbstractShortCircuitTask#getRawResult()->R:::Retrieves the local result for this task
java.util.stream.AbstractShortCircuitTask#getLocalResult()->R:::Retrieves the local result for this task
java.util.stream.AbstractShortCircuitTask#cancel()->void:::Mark this task as canceled
java.util.stream.AbstractShortCircuitTask#taskCanceled()->boolean:::Queries whether this task is canceled
java.util.stream.AbstractShortCircuitTask#cancelLaterNodes()->void:::Cancels all tasks which succeed this one in the encounter order
java.util.stream.AbstractSpinedBuffer#isEmpty()->boolean:::Is the buffer currently empty?
java.util.stream.AbstractSpinedBuffer#count()->long:::How many elements are currently in the buffer?
java.util.stream.AbstractSpinedBuffer#chunkSize(int)->int:::How big should the nth chunk be?
java.util.stream.AbstractSpinedBuffer#clear()->void:::Remove all data from the buffer
java.util.stream.AbstractTask#getLeafTarget()->int:::Default target of leaf tasks for parallel decomposition
java.util.stream.AbstractTask#makeChild(Spliterator<P_IN>)->K:::Constructs a new node of type T whose parent is the receiver; must call  the AbstractTask(T, Spliterator) constructor with the receiver and the  provided Spliterator.
java.util.stream.AbstractTask#doLeaf()->R:::Computes the result associated with a leaf node
java.util.stream.AbstractTask#suggestTargetSize(long)->long:::Returns a suggested target leaf size based on the initial size estimate.
java.util.stream.AbstractTask#getTargetSize(long)->long:::Returns the targetSize, initializing it via the supplied  size estimate if not already initialized.
java.util.stream.AbstractTask#getRawResult()->R:::Returns the local result, if any
java.util.stream.AbstractTask#setRawResult(R)->void:::Does nothing; instead, subclasses should use  {@link #setLocalResult(Object)}} to manage results.
java.util.stream.AbstractTask#getLocalResult()->R:::Retrieves a result previously stored with {@link #setLocalResult}
java.util.stream.AbstractTask#setLocalResult(R)->void:::Associates the result with the task, can be retrieved with  {@link #getLocalResult}
java.util.stream.AbstractTask#isLeaf()->boolean:::Indicates whether this task is a leaf node
java.util.stream.AbstractTask#isRoot()->boolean:::Indicates whether this task is the root node
java.util.stream.AbstractTask#getParent()->K:::Returns the parent of this task, or null if this task is the root
java.util.stream.AbstractTask#compute()->void:::Decides whether or not to split a task further or compute it  directly
java.util.stream.AbstractTask#onCompletion(CountedCompleter<?>)->void:::{@inheritDoc}
java.util.stream.AbstractTask#isLeftmostNode()->boolean:::Returns whether this node is a "leftmost" node -- whether the path from  the root to this node involves only traversing leftmost child links
java.util.stream.BaseStream#iterator()->Iterator<T>:::Returns an iterator for the elements of this stream
java.util.stream.BaseStream#spliterator()->Spliterator<T>:::Returns a spliterator for the elements of this stream
java.util.stream.BaseStream#isParallel()->boolean:::Returns whether this stream, if a terminal operation were to be executed,  would execute in parallel
java.util.stream.BaseStream#sequential()->S:::Returns an equivalent stream that is sequential
java.util.stream.BaseStream#parallel()->S:::Returns an equivalent stream that is parallel
java.util.stream.BaseStream#unordered()->S:::Returns an equivalent stream that is  <a href="package-summary.html#Ordering">unordered</a>
java.util.stream.BaseStream#onClose(Runnable)->S:::Returns an equivalent stream with an additional close handler
java.util.stream.BaseStream#close()->void:::Closes this stream, causing all close handlers for this stream pipeline  to be called.
java.util.stream.Collector#supplier()->Supplier<A>:::A function that creates and returns a new mutable result container.
java.util.stream.Collector#T> accumulator()->BiConsumer<A,:::A function that folds a value into a mutable result container.
java.util.stream.Collector#combiner()->BinaryOperator<A>:::A function that accepts two partial results and merges them
java.util.stream.Collector#R> finisher()->Function<A,:::Perform the final transformation from the intermediate accumulation type  {@code A} to the final result type {@code R}
java.util.stream.Collector#characteristics()->Set<Characteristics>:::Returns a {@code Set} of {@code Collector.Characteristics} indicating  the characteristics of this Collector
java.util.stream.Collector#R, R> of(Supplier<R>, BiConsumer<R, T>, BinaryOperator<R>, Characteristics...)->Collector<T,:::Returns a new {@code Collector} described by the given {@code supplier},  {@code accumulator}, and {@code combiner} functions
java.util.stream.Collector#A, R> of(Supplier<A>, BiConsumer<A, T>, BinaryOperator<A>, Function<A, R>, Characteristics...)->Collector<T,:::Returns a new {@code Collector} described by the given {@code supplier},  {@code accumulator}, {@code combiner}, and {@code finisher} functions.
java.util.stream.Collectors.CollectorImpl#T> accumulator()->BiConsumer<A,:::
java.util.stream.Collectors.CollectorImpl#supplier()->Supplier<A>:::
java.util.stream.Collectors.CollectorImpl#combiner()->BinaryOperator<A>:::
java.util.stream.Collectors.CollectorImpl#R> finisher()->Function<A,:::
java.util.stream.Collectors.CollectorImpl#characteristics()->Set<Characteristics>:::
java.util.stream.Collectors#?, C> toCollection(Supplier<C>)->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into a  new {@code Collection}, in encounter order
java.util.stream.Collectors#?, List<T>> toList()->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into a  new {@code List}
java.util.stream.Collectors#?, List<T>> toUnmodifiableList()->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into an  <a href="../List.html#unmodifiable">unmodifiable List</a> in encounter  order
java.util.stream.Collectors#?, Set<T>> toSet()->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into a  new {@code Set}
java.util.stream.Collectors#?, Set<T>> toUnmodifiableSet()->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into an  <a href="../Set.html#unmodifiable">unmodifiable Set</a>
java.util.stream.Collectors#?, String> joining()->Collector<CharSequence,:::Returns a {@code Collector} that concatenates the input elements into a  {@code String}, in encounter order.
java.util.stream.Collectors#?, String> joining(CharSequence)->Collector<CharSequence,:::Returns a {@code Collector} that concatenates the input elements,  separated by the specified delimiter, in encounter order.
java.util.stream.Collectors#?, String> joining(CharSequence, CharSequence, CharSequence)->Collector<CharSequence,:::Returns a {@code Collector} that concatenates the input elements,  separated by the specified delimiter, with the specified prefix and  suffix, in encounter order.
java.util.stream.Collectors#?, R> mapping(Function<? super T, ? extends U>, Collector<? super U, A, R>)->Collector<T,:::Adapts a {@code Collector} accepting elements of type {@code U} to one  accepting elements of type {@code T} by applying a mapping function to  each input element before accumulation.
java.util.stream.Collectors#?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>>, Collector<? super U, A, R>)->Collector<T,:::Adapts a {@code Collector} accepting elements of type {@code U} to one  accepting elements of type {@code T} by applying a flat mapping function  to each input element before accumulation
java.util.stream.Collectors#?, R> filtering(Predicate<? super T>, Collector<? super T, A, R>)->Collector<T,:::Adapts a {@code Collector} to one accepting elements of the same type  {@code T} by applying the predicate to each input element and only  accumulating if the predicate returns {@code true}.
java.util.stream.Collectors#A, RR> collectingAndThen(Collector<T, A, R>, Function<R, RR>)->Collector<T,:::Adapts a {@code Collector} to perform an additional finishing  transformation
java.util.stream.Collectors#?, Long> counting()->Collector<T,:::Returns a {@code Collector} accepting elements of type {@code T} that  counts the number of input elements
java.util.stream.Collectors#?, Optional<T>> minBy(Comparator<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the minimal element according  to a given {@code Comparator}, described as an {@code Optional<T>}.
java.util.stream.Collectors#?, Optional<T>> maxBy(Comparator<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the maximal element according  to a given {@code Comparator}, described as an {@code Optional<T>}.
java.util.stream.Collectors#?, Integer> summingInt(ToIntFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the sum of a integer-valued  function applied to the input elements
java.util.stream.Collectors#?, Long> summingLong(ToLongFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the sum of a long-valued  function applied to the input elements
java.util.stream.Collectors#?, Double> summingDouble(ToDoubleFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the sum of a double-valued  function applied to the input elements
java.util.stream.Collectors#sumWithCompensation(double[], double)->double[]:::Incorporate a new double value using Kahan summation /  compensation summation
java.util.stream.Collectors#computeFinalSum(double[])->double:::If the compensated sum is spuriously NaN from accumulating one  or more same-signed infinite values, return the  correctly-signed infinity stored in the simple sum.
java.util.stream.Collectors#?, Double> averagingInt(ToIntFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the arithmetic mean of an integer-valued  function applied to the input elements
java.util.stream.Collectors#?, Double> averagingLong(ToLongFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the arithmetic mean of a long-valued  function applied to the input elements
java.util.stream.Collectors#?, Double> averagingDouble(ToDoubleFunction<? super T>)->Collector<T,:::Returns a {@code Collector} that produces the arithmetic mean of a double-valued  function applied to the input elements
java.util.stream.Collectors#?, T> reducing(T, BinaryOperator<T>)->Collector<T,:::Returns a {@code Collector} which performs a reduction of its  input elements under a specified {@code BinaryOperator} using the  provided identity.
java.util.stream.Collectors#?, Optional<T>> reducing(BinaryOperator<T>)->Collector<T,:::Returns a {@code Collector} which performs a reduction of its  input elements under a specified {@code BinaryOperator}
java.util.stream.Collectors#?, U> reducing(U, Function<? super T, ? extends U>, BinaryOperator<U>)->Collector<T,:::Returns a {@code Collector} which performs a reduction of its  input elements under a specified mapping function and  {@code BinaryOperator}
java.util.stream.Collectors#?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K>)->Collector<T,:::Returns a {@code Collector} implementing a "group by" operation on  input elements of type {@code T}, grouping elements according to a  classification function, and returning the results in a {@code Map}
java.util.stream.Collectors#?, Map<K, D>> groupingBy(Function<? super T, ? extends K>, Collector<? super T, A, D>)->Collector<T,:::Returns a {@code Collector} implementing a cascaded "group by" operation  on input elements of type {@code T}, grouping elements according to a  classification function, and then performing a reduction operation on  the values associated with a given key using the specified downstream  {@code Collector}
java.util.stream.Collectors#?, M> groupingBy(Function<? super T, ? extends K>, Supplier<M>, Collector<? super T, A, D>)->Collector<T,:::Returns a {@code Collector} implementing a cascaded "group by" operation  on input elements of type {@code T}, grouping elements according to a  classification function, and then performing a reduction operation on  the values associated with a given key using the specified downstream  {@code Collector}
java.util.stream.Collectors#?, ConcurrentMap<K, List<T>>> groupingByConcurrent(Function<? super T, ? extends K>)->Collector<T,:::Returns a concurrent {@code Collector} implementing a "group by"  operation on input elements of type {@code T}, grouping elements  according to a classification function
java.util.stream.Collectors#?, ConcurrentMap<K, D>> groupingByConcurrent(Function<? super T, ? extends K>, Collector<? super T, A, D>)->Collector<T,:::Returns a concurrent {@code Collector} implementing a cascaded "group by"  operation on input elements of type {@code T}, grouping elements  according to a classification function, and then performing a reduction  operation on the values associated with a given key using the specified  downstream {@code Collector}
java.util.stream.Collectors#?, M> groupingByConcurrent(Function<? super T, ? extends K>, Supplier<M>, Collector<? super T, A, D>)->Collector<T,:::Returns a concurrent {@code Collector} implementing a cascaded "group by"  operation on input elements of type {@code T}, grouping elements  according to a classification function, and then performing a reduction  operation on the values associated with a given key using the specified  downstream {@code Collector}
java.util.stream.Collectors#?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T>)->Collector<T,:::Returns a {@code Collector} which partitions the input elements according  to a {@code Predicate}, and organizes them into a  {@code Map<Boolean, List<T>>}
java.util.stream.Collectors#?, Map<Boolean, D>> partitioningBy(Predicate<? super T>, Collector<? super T, A, D>)->Collector<T,:::Returns a {@code Collector} which partitions the input elements according  to a {@code Predicate}, reduces the values in each partition according to  another {@code Collector}, and organizes them into a  {@code Map<Boolean, D>} whose values are the result of the downstream  reduction
java.util.stream.Collectors#?, Map<K, U>> toMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>)->Collector<T,:::Returns a {@code Collector} that accumulates elements into a  {@code Map} whose keys and values are the result of applying the provided  mapping functions to the input elements
java.util.stream.Collectors#?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>)->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into an  <a href="../Map.html#unmodifiable">unmodifiable Map</a>,  whose keys and values are the result of applying the provided  mapping functions to the input elements
java.util.stream.Collectors#?, Map<K, U>> toMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>, BinaryOperator<U>)->Collector<T,:::Returns a {@code Collector} that accumulates elements into a  {@code Map} whose keys and values are the result of applying the provided  mapping functions to the input elements
java.util.stream.Collectors#?, Map<K, U>> toUnmodifiableMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>, BinaryOperator<U>)->Collector<T,:::Returns a {@code Collector} that accumulates the input elements into an  <a href="../Map.html#unmodifiable">unmodifiable Map</a>,  whose keys and values are the result of applying the provided  mapping functions to the input elements
java.util.stream.Collectors#?, M> toMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>, BinaryOperator<U>, Supplier<M>)->Collector<T,:::Returns a {@code Collector} that accumulates elements into a  {@code Map} whose keys and values are the result of applying the provided  mapping functions to the input elements
java.util.stream.Collectors#?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>)->Collector<T,:::Returns a concurrent {@code Collector} that accumulates elements into a  {@code ConcurrentMap} whose keys and values are the result of applying  the provided mapping functions to the input elements
java.util.stream.Collectors#?, ConcurrentMap<K, U>> toConcurrentMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>, BinaryOperator<U>)->Collector<T,:::Returns a concurrent {@code Collector} that accumulates elements into a  {@code ConcurrentMap} whose keys and values are the result of applying  the provided mapping functions to the input elements
java.util.stream.Collectors#?, M> toConcurrentMap(Function<? super T, ? extends K>, Function<? super T, ? extends U>, BinaryOperator<U>, Supplier<M>)->Collector<T,:::Returns a concurrent {@code Collector} that accumulates elements into a  {@code ConcurrentMap} whose keys and values are the result of applying  the provided mapping functions to the input elements
java.util.stream.Collectors#?, IntSummaryStatistics> summarizingInt(ToIntFunction<? super T>)->Collector<T,:::Returns a {@code Collector} which applies an {@code int}-producing  mapping function to each input element, and returns summary statistics  for the resulting values.
java.util.stream.Collectors#?, LongSummaryStatistics> summarizingLong(ToLongFunction<? super T>)->Collector<T,:::Returns a {@code Collector} which applies an {@code long}-producing  mapping function to each input element, and returns summary statistics  for the resulting values.
java.util.stream.Collectors#?, DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T>)->Collector<T,:::Returns a {@code Collector} which applies an {@code double}-producing  mapping function to each input element, and returns summary statistics  for the resulting values.
java.util.stream.Collectors.Partition#T>> entrySet()->Set<Map.Entry<Boolean,:::
java.util.stream.DistinctOps#T> makeRef(AbstractPipeline<?, T, ?>)->ReferencePipeline<T,:::Appends a "distinct" operation to the provided stream, and returns the  new stream.
java.util.stream.DoublePipeline#getOutputShape()->StreamShape:::
java.util.stream.DoublePipeline#evaluateToNode(PipelineHelper<Double>, Spliterator<P_IN>, boolean, IntFunction<Double[]>)->Node<Double>:::
java.util.stream.DoublePipeline#wrap(PipelineHelper<Double>, Supplier<Spliterator<P_IN>>, boolean)->Spliterator<Double>:::
java.util.stream.DoublePipeline#lazySpliterator(Supplier<? extends Spliterator<Double>>)->Spliterator.OfDouble:::
java.util.stream.DoublePipeline#forEachWithCancel(Spliterator<Double>, Sink<Double>)->boolean:::
java.util.stream.DoublePipeline#makeNodeBuilder(long, IntFunction<Double[]>)->Node.Builder<Double>:::
java.util.stream.DoublePipeline#iterator()->PrimitiveIterator.OfDouble:::
java.util.stream.DoublePipeline#spliterator()->Spliterator.OfDouble:::
java.util.stream.DoublePipeline#boxed()->Stream<Double>:::
java.util.stream.DoublePipeline#map(DoubleUnaryOperator)->DoubleStream:::
java.util.stream.DoublePipeline#mapToObj(DoubleFunction<? extends U>)->Stream<U>:::
java.util.stream.DoublePipeline#mapToInt(DoubleToIntFunction)->IntStream:::
java.util.stream.DoublePipeline#mapToLong(DoubleToLongFunction)->LongStream:::
java.util.stream.DoublePipeline#flatMap(DoubleFunction<? extends DoubleStream>)->DoubleStream:::
java.util.stream.DoublePipeline#unordered()->DoubleStream:::
java.util.stream.DoublePipeline#filter(DoublePredicate)->DoubleStream:::
java.util.stream.DoublePipeline#peek(DoubleConsumer)->DoubleStream:::
java.util.stream.DoublePipeline#limit(long)->DoubleStream:::
java.util.stream.DoublePipeline#skip(long)->DoubleStream:::
java.util.stream.DoublePipeline#takeWhile(DoublePredicate)->DoubleStream:::
java.util.stream.DoublePipeline#dropWhile(DoublePredicate)->DoubleStream:::
java.util.stream.DoublePipeline#sorted()->DoubleStream:::
java.util.stream.DoublePipeline#distinct()->DoubleStream:::
java.util.stream.DoublePipeline#forEach(DoubleConsumer)->void:::
java.util.stream.DoublePipeline#forEachOrdered(DoubleConsumer)->void:::
java.util.stream.DoublePipeline#sum()->double:::
java.util.stream.DoublePipeline#min()->OptionalDouble:::
java.util.stream.DoublePipeline#max()->OptionalDouble:::
java.util.stream.DoublePipeline#average()->OptionalDouble:::{@inheritDoc}
java.util.stream.DoublePipeline#count()->long:::
java.util.stream.DoublePipeline#summaryStatistics()->DoubleSummaryStatistics:::
java.util.stream.DoublePipeline#reduce(double, DoubleBinaryOperator)->double:::
java.util.stream.DoublePipeline#reduce(DoubleBinaryOperator)->OptionalDouble:::
java.util.stream.DoublePipeline#collect(Supplier<R>, ObjDoubleConsumer<R>, BiConsumer<R, R>)->R:::
java.util.stream.DoublePipeline#anyMatch(DoublePredicate)->boolean:::
java.util.stream.DoublePipeline#allMatch(DoublePredicate)->boolean:::
java.util.stream.DoublePipeline#noneMatch(DoublePredicate)->boolean:::
java.util.stream.DoublePipeline#findFirst()->OptionalDouble:::
java.util.stream.DoublePipeline#findAny()->OptionalDouble:::
java.util.stream.DoublePipeline#toArray()->double[]:::
java.util.stream.DoublePipeline.Head#opIsStateful()->boolean:::
java.util.stream.DoublePipeline.Head#opWrapSink(int, Sink<Double>)->Sink<E_IN>:::
java.util.stream.DoublePipeline.Head#forEach(DoubleConsumer)->void:::
java.util.stream.DoublePipeline.Head#forEachOrdered(DoubleConsumer)->void:::
java.util.stream.DoublePipeline.StatelessOp#opIsStateful()->boolean:::
java.util.stream.DoublePipeline.StatefulOp#opIsStateful()->boolean:::
java.util.stream.DoublePipeline.StatefulOp#opEvaluateParallel(PipelineHelper<Double>, Spliterator<P_IN>, IntFunction<Double[]>)->Node<Double>:::
java.util.stream.DoubleStream#filter(DoublePredicate)->DoubleStream:::Returns a stream consisting of the elements of this stream that match  the given predicate
java.util.stream.DoubleStream#map(DoubleUnaryOperator)->DoubleStream:::Returns a stream consisting of the results of applying the given  function to the elements of this stream
java.util.stream.DoubleStream#mapToObj(DoubleFunction<? extends U>)->Stream<U>:::Returns an object-valued {@code Stream} consisting of the results of  applying the given function to the elements of this stream
java.util.stream.DoubleStream#mapToInt(DoubleToIntFunction)->IntStream:::Returns an {@code IntStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.DoubleStream#mapToLong(DoubleToLongFunction)->LongStream:::Returns a {@code LongStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.DoubleStream#flatMap(DoubleFunction<? extends DoubleStream>)->DoubleStream:::Returns a stream consisting of the results of replacing each element of  this stream with the contents of a mapped stream produced by applying  the provided mapping function to each element
java.util.stream.DoubleStream#distinct()->DoubleStream:::Returns a stream consisting of the distinct elements of this stream
java.util.stream.DoubleStream#sorted()->DoubleStream:::Returns a stream consisting of the elements of this stream in sorted  order
java.util.stream.DoubleStream#peek(DoubleConsumer)->DoubleStream:::Returns a stream consisting of the elements of this stream, additionally  performing the provided action on each element as elements are consumed  from the resulting stream
java.util.stream.DoubleStream#limit(long)->DoubleStream:::Returns a stream consisting of the elements of this stream, truncated  to be no longer than {@code maxSize} in length
java.util.stream.DoubleStream#skip(long)->DoubleStream:::Returns a stream consisting of the remaining elements of this stream  after discarding the first {@code n} elements of the stream
java.util.stream.DoubleStream#takeWhile(DoublePredicate)->DoubleStream:::Returns, if this stream is ordered, a stream consisting of the longest  prefix of elements taken from this stream that match the given predicate
java.util.stream.DoubleStream#dropWhile(DoublePredicate)->DoubleStream:::Returns, if this stream is ordered, a stream consisting of the remaining  elements of this stream after dropping the longest prefix of elements  that match the given predicate
java.util.stream.DoubleStream#forEach(DoubleConsumer)->void:::Performs an action for each element of this stream
java.util.stream.DoubleStream#forEachOrdered(DoubleConsumer)->void:::Performs an action for each element of this stream, guaranteeing that  each element is processed in encounter order for streams that have a  defined encounter order
java.util.stream.DoubleStream#toArray()->double[]:::Returns an array containing the elements of this stream
java.util.stream.DoubleStream#reduce(double, DoubleBinaryOperator)->double:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using the provided identity value and an  <a href="package-summary.html#Associativity">associative</a>  accumulation function, and returns the reduced value
java.util.stream.DoubleStream#reduce(DoubleBinaryOperator)->OptionalDouble:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using an  <a href="package-summary.html#Associativity">associative</a> accumulation  function, and returns an {@code OptionalDouble} describing the reduced  value, if any
java.util.stream.DoubleStream#collect(Supplier<R>, ObjDoubleConsumer<R>, BiConsumer<R, R>)->R:::Performs a <a href="package-summary.html#MutableReduction">mutable  reduction</a> operation on the elements of this stream
java.util.stream.DoubleStream#sum()->double:::Returns the sum of elements in this stream
java.util.stream.DoubleStream#min()->OptionalDouble:::Returns an {@code OptionalDouble} describing the minimum element of this  stream, or an empty OptionalDouble if this stream is empty
java.util.stream.DoubleStream#max()->OptionalDouble:::Returns an {@code OptionalDouble} describing the maximum element of this  stream, or an empty OptionalDouble if this stream is empty
java.util.stream.DoubleStream#count()->long:::Returns the count of elements in this stream
java.util.stream.DoubleStream#average()->OptionalDouble:::Returns an {@code OptionalDouble} describing the arithmetic  mean of elements of this stream, or an empty optional if this  stream is empty
java.util.stream.DoubleStream#summaryStatistics()->DoubleSummaryStatistics:::Returns a {@code DoubleSummaryStatistics} describing various summary data  about the elements of this stream
java.util.stream.DoubleStream#anyMatch(DoublePredicate)->boolean:::Returns whether any elements of this stream match the provided  predicate
java.util.stream.DoubleStream#allMatch(DoublePredicate)->boolean:::Returns whether all elements of this stream match the provided predicate
java.util.stream.DoubleStream#noneMatch(DoublePredicate)->boolean:::Returns whether no elements of this stream match the provided predicate
java.util.stream.DoubleStream#findFirst()->OptionalDouble:::Returns an {@link OptionalDouble} describing the first element of this  stream, or an empty {@code OptionalDouble} if the stream is empty
java.util.stream.DoubleStream#findAny()->OptionalDouble:::Returns an {@link OptionalDouble} describing some element of the stream,  or an empty {@code OptionalDouble} if the stream is empty
java.util.stream.DoubleStream#boxed()->Stream<Double>:::Returns a {@code Stream} consisting of the elements of this stream,  boxed to {@code Double}
java.util.stream.DoubleStream#sequential()->DoubleStream:::
java.util.stream.DoubleStream#parallel()->DoubleStream:::
java.util.stream.DoubleStream#iterator()->PrimitiveIterator.OfDouble:::
java.util.stream.DoubleStream#spliterator()->Spliterator.OfDouble:::
java.util.stream.DoubleStream#builder()->Builder:::Returns a builder for a {@code DoubleStream}.
java.util.stream.DoubleStream#empty()->DoubleStream:::Returns an empty sequential {@code DoubleStream}.
java.util.stream.DoubleStream#of(double)->DoubleStream:::Returns a sequential {@code DoubleStream} containing a single element.
java.util.stream.DoubleStream#of(double...)->DoubleStream:::Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.DoubleStream#iterate(double, DoubleUnaryOperator)->DoubleStream:::Returns an infinite sequential ordered {@code DoubleStream} produced by iterative  application of a function {@code f} to an initial element {@code seed},  producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},  {@code f(f(seed))}, etc
java.util.stream.DoubleStream#iterate(double, DoublePredicate, DoubleUnaryOperator)->DoubleStream:::Returns a sequential ordered {@code DoubleStream} produced by iterative  application of the given {@code next} function to an initial element,  conditioned on satisfying the given {@code hasNext} predicate
java.util.stream.DoubleStream#generate(DoubleSupplier)->DoubleStream:::Returns an infinite sequential unordered stream where each element is  generated by the provided {@code DoubleSupplier}
java.util.stream.DoubleStream#concat(DoubleStream, DoubleStream)->DoubleStream:::Creates a lazily concatenated stream whose elements are all the  elements of the first stream followed by all the elements of the  second stream
java.util.stream.DoubleStream.Builder#accept(double)->void:::Adds an element to the stream being built.
java.util.stream.DoubleStream.Builder#add(double)->Builder:::Adds an element to the stream being built.
java.util.stream.DoubleStream.Builder#build()->DoubleStream:::Builds the stream, transitioning this builder to the built state
java.util.stream.FindOps#Optional<T>> makeRef(boolean)->TerminalOp<T,:::Constructs a {@code TerminalOp} for streams of objects.
java.util.stream.FindOps#OptionalInt> makeInt(boolean)->TerminalOp<Integer,:::Constructs a {@code TerminalOp} for streams of ints.
java.util.stream.FindOps#OptionalLong> makeLong(boolean)->TerminalOp<Long,:::Constructs a {@code TerminalOp} for streams of longs.
java.util.stream.FindOps#OptionalDouble> makeDouble(boolean)->TerminalOp<Double,:::Constructs a {@code FindOp} for streams of doubles.
java.util.stream.FindOps.FindOp#getOpFlags()->int:::
java.util.stream.FindOps.FindOp#inputShape()->StreamShape:::
java.util.stream.FindOps.FindOp#evaluateSequential(PipelineHelper<T>, Spliterator<S>)->O:::
java.util.stream.FindOps.FindOp#evaluateParallel(PipelineHelper<T>, Spliterator<P_IN>)->O:::
java.util.stream.FindOps.FindSink#accept(T)->void:::
java.util.stream.FindOps.FindSink#cancellationRequested()->boolean:::
java.util.stream.FindOps.FindSink.OfRef#get()->Optional<T>:::
java.util.stream.FindOps.FindSink.OfInt#accept(int)->void:::
java.util.stream.FindOps.FindSink.OfInt#get()->OptionalInt:::
java.util.stream.FindOps.FindSink.OfLong#accept(long)->void:::
java.util.stream.FindOps.FindSink.OfLong#get()->OptionalLong:::
java.util.stream.FindOps.FindSink.OfDouble#accept(double)->void:::
java.util.stream.FindOps.FindSink.OfDouble#get()->OptionalDouble:::
java.util.stream.FindOps.FindTask#P_OUT, O> makeChild(Spliterator<P_IN>)->FindTask<P_IN,:::
java.util.stream.FindOps.FindTask#getEmptyResult()->O:::
java.util.stream.FindOps.FindTask#doLeaf()->O:::
java.util.stream.FindOps.FindTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.ForEachOps#Void> makeRef(Consumer<? super T>, boolean)->TerminalOp<T,:::Constructs a {@code TerminalOp} that perform an action for every element  of a stream.
java.util.stream.ForEachOps#Void> makeInt(IntConsumer, boolean)->TerminalOp<Integer,:::Constructs a {@code TerminalOp} that perform an action for every element  of an {@code IntStream}.
java.util.stream.ForEachOps#Void> makeLong(LongConsumer, boolean)->TerminalOp<Long,:::Constructs a {@code TerminalOp} that perform an action for every element  of a {@code LongStream}.
java.util.stream.ForEachOps#Void> makeDouble(DoubleConsumer, boolean)->TerminalOp<Double,:::Constructs a {@code TerminalOp} that perform an action for every element  of a {@code DoubleStream}.
java.util.stream.ForEachOps.ForEachOp#getOpFlags()->int:::
java.util.stream.ForEachOps.ForEachOp#evaluateSequential(PipelineHelper<T>, Spliterator<S>)->Void:::
java.util.stream.ForEachOps.ForEachOp#evaluateParallel(PipelineHelper<T>, Spliterator<S>)->Void:::
java.util.stream.ForEachOps.ForEachOp#get()->Void:::
java.util.stream.ForEachOps.ForEachOp.OfRef#accept(T)->void:::
java.util.stream.ForEachOps.ForEachOp.OfInt#inputShape()->StreamShape:::
java.util.stream.ForEachOps.ForEachOp.OfInt#accept(int)->void:::
java.util.stream.ForEachOps.ForEachOp.OfLong#inputShape()->StreamShape:::
java.util.stream.ForEachOps.ForEachOp.OfLong#accept(long)->void:::
java.util.stream.ForEachOps.ForEachOp.OfDouble#inputShape()->StreamShape:::
java.util.stream.ForEachOps.ForEachOp.OfDouble#accept(double)->void:::
java.util.stream.ForEachOps.ForEachTask#compute()->void:::
java.util.stream.ForEachOps.ForEachOrderedTask#compute()->void:::
java.util.stream.ForEachOps.ForEachOrderedTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.IntPipeline#getOutputShape()->StreamShape:::
java.util.stream.IntPipeline#evaluateToNode(PipelineHelper<Integer>, Spliterator<P_IN>, boolean, IntFunction<Integer[]>)->Node<Integer>:::
java.util.stream.IntPipeline#wrap(PipelineHelper<Integer>, Supplier<Spliterator<P_IN>>, boolean)->Spliterator<Integer>:::
java.util.stream.IntPipeline#lazySpliterator(Supplier<? extends Spliterator<Integer>>)->Spliterator.OfInt:::
java.util.stream.IntPipeline#forEachWithCancel(Spliterator<Integer>, Sink<Integer>)->boolean:::
java.util.stream.IntPipeline#makeNodeBuilder(long, IntFunction<Integer[]>)->Node.Builder<Integer>:::
java.util.stream.IntPipeline#iterator()->PrimitiveIterator.OfInt:::
java.util.stream.IntPipeline#spliterator()->Spliterator.OfInt:::
java.util.stream.IntPipeline#asLongStream()->LongStream:::
java.util.stream.IntPipeline#asDoubleStream()->DoubleStream:::
java.util.stream.IntPipeline#boxed()->Stream<Integer>:::
java.util.stream.IntPipeline#map(IntUnaryOperator)->IntStream:::
java.util.stream.IntPipeline#mapToObj(IntFunction<? extends U>)->Stream<U>:::
java.util.stream.IntPipeline#mapToLong(IntToLongFunction)->LongStream:::
java.util.stream.IntPipeline#mapToDouble(IntToDoubleFunction)->DoubleStream:::
java.util.stream.IntPipeline#flatMap(IntFunction<? extends IntStream>)->IntStream:::
java.util.stream.IntPipeline#unordered()->IntStream:::
java.util.stream.IntPipeline#filter(IntPredicate)->IntStream:::
java.util.stream.IntPipeline#peek(IntConsumer)->IntStream:::
java.util.stream.IntPipeline#limit(long)->IntStream:::
java.util.stream.IntPipeline#skip(long)->IntStream:::
java.util.stream.IntPipeline#takeWhile(IntPredicate)->IntStream:::
java.util.stream.IntPipeline#dropWhile(IntPredicate)->IntStream:::
java.util.stream.IntPipeline#sorted()->IntStream:::
java.util.stream.IntPipeline#distinct()->IntStream:::
java.util.stream.IntPipeline#forEach(IntConsumer)->void:::
java.util.stream.IntPipeline#forEachOrdered(IntConsumer)->void:::
java.util.stream.IntPipeline#sum()->int:::
java.util.stream.IntPipeline#min()->OptionalInt:::
java.util.stream.IntPipeline#max()->OptionalInt:::
java.util.stream.IntPipeline#count()->long:::
java.util.stream.IntPipeline#average()->OptionalDouble:::
java.util.stream.IntPipeline#summaryStatistics()->IntSummaryStatistics:::
java.util.stream.IntPipeline#reduce(int, IntBinaryOperator)->int:::
java.util.stream.IntPipeline#reduce(IntBinaryOperator)->OptionalInt:::
java.util.stream.IntPipeline#collect(Supplier<R>, ObjIntConsumer<R>, BiConsumer<R, R>)->R:::
java.util.stream.IntPipeline#anyMatch(IntPredicate)->boolean:::
java.util.stream.IntPipeline#allMatch(IntPredicate)->boolean:::
java.util.stream.IntPipeline#noneMatch(IntPredicate)->boolean:::
java.util.stream.IntPipeline#findFirst()->OptionalInt:::
java.util.stream.IntPipeline#findAny()->OptionalInt:::
java.util.stream.IntPipeline#toArray()->int[]:::
java.util.stream.IntPipeline.Head#opIsStateful()->boolean:::
java.util.stream.IntPipeline.Head#opWrapSink(int, Sink<Integer>)->Sink<E_IN>:::
java.util.stream.IntPipeline.Head#forEach(IntConsumer)->void:::
java.util.stream.IntPipeline.Head#forEachOrdered(IntConsumer)->void:::
java.util.stream.IntPipeline.StatelessOp#opIsStateful()->boolean:::
java.util.stream.IntPipeline.StatefulOp#opIsStateful()->boolean:::
java.util.stream.IntPipeline.StatefulOp#opEvaluateParallel(PipelineHelper<Integer>, Spliterator<P_IN>, IntFunction<Integer[]>)->Node<Integer>:::
java.util.stream.IntStream#filter(IntPredicate)->IntStream:::Returns a stream consisting of the elements of this stream that match  the given predicate
java.util.stream.IntStream#map(IntUnaryOperator)->IntStream:::Returns a stream consisting of the results of applying the given  function to the elements of this stream
java.util.stream.IntStream#mapToObj(IntFunction<? extends U>)->Stream<U>:::Returns an object-valued {@code Stream} consisting of the results of  applying the given function to the elements of this stream
java.util.stream.IntStream#mapToLong(IntToLongFunction)->LongStream:::Returns a {@code LongStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.IntStream#mapToDouble(IntToDoubleFunction)->DoubleStream:::Returns a {@code DoubleStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.IntStream#flatMap(IntFunction<? extends IntStream>)->IntStream:::Returns a stream consisting of the results of replacing each element of  this stream with the contents of a mapped stream produced by applying  the provided mapping function to each element
java.util.stream.IntStream#distinct()->IntStream:::Returns a stream consisting of the distinct elements of this stream
java.util.stream.IntStream#sorted()->IntStream:::Returns a stream consisting of the elements of this stream in sorted  order
java.util.stream.IntStream#peek(IntConsumer)->IntStream:::Returns a stream consisting of the elements of this stream, additionally  performing the provided action on each element as elements are consumed  from the resulting stream
java.util.stream.IntStream#limit(long)->IntStream:::Returns a stream consisting of the elements of this stream, truncated  to be no longer than {@code maxSize} in length
java.util.stream.IntStream#skip(long)->IntStream:::Returns a stream consisting of the remaining elements of this stream  after discarding the first {@code n} elements of the stream
java.util.stream.IntStream#takeWhile(IntPredicate)->IntStream:::Returns, if this stream is ordered, a stream consisting of the longest  prefix of elements taken from this stream that match the given predicate
java.util.stream.IntStream#dropWhile(IntPredicate)->IntStream:::Returns, if this stream is ordered, a stream consisting of the remaining  elements of this stream after dropping the longest prefix of elements  that match the given predicate
java.util.stream.IntStream#forEach(IntConsumer)->void:::Performs an action for each element of this stream
java.util.stream.IntStream#forEachOrdered(IntConsumer)->void:::Performs an action for each element of this stream, guaranteeing that  each element is processed in encounter order for streams that have a  defined encounter order
java.util.stream.IntStream#toArray()->int[]:::Returns an array containing the elements of this stream
java.util.stream.IntStream#reduce(int, IntBinaryOperator)->int:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using the provided identity value and an  <a href="package-summary.html#Associativity">associative</a>  accumulation function, and returns the reduced value
java.util.stream.IntStream#reduce(IntBinaryOperator)->OptionalInt:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using an  <a href="package-summary.html#Associativity">associative</a> accumulation  function, and returns an {@code OptionalInt} describing the reduced value,  if any
java.util.stream.IntStream#collect(Supplier<R>, ObjIntConsumer<R>, BiConsumer<R, R>)->R:::Performs a <a href="package-summary.html#MutableReduction">mutable  reduction</a> operation on the elements of this stream
java.util.stream.IntStream#sum()->int:::Returns the sum of elements in this stream
java.util.stream.IntStream#min()->OptionalInt:::Returns an {@code OptionalInt} describing the minimum element of this  stream, or an empty optional if this stream is empty
java.util.stream.IntStream#max()->OptionalInt:::Returns an {@code OptionalInt} describing the maximum element of this  stream, or an empty optional if this stream is empty
java.util.stream.IntStream#count()->long:::Returns the count of elements in this stream
java.util.stream.IntStream#average()->OptionalDouble:::Returns an {@code OptionalDouble} describing the arithmetic mean of elements of  this stream, or an empty optional if this stream is empty
java.util.stream.IntStream#summaryStatistics()->IntSummaryStatistics:::Returns an {@code IntSummaryStatistics} describing various  summary data about the elements of this stream
java.util.stream.IntStream#anyMatch(IntPredicate)->boolean:::Returns whether any elements of this stream match the provided  predicate
java.util.stream.IntStream#allMatch(IntPredicate)->boolean:::Returns whether all elements of this stream match the provided predicate
java.util.stream.IntStream#noneMatch(IntPredicate)->boolean:::Returns whether no elements of this stream match the provided predicate
java.util.stream.IntStream#findFirst()->OptionalInt:::Returns an {@link OptionalInt} describing the first element of this  stream, or an empty {@code OptionalInt} if the stream is empty
java.util.stream.IntStream#findAny()->OptionalInt:::Returns an {@link OptionalInt} describing some element of the stream, or  an empty {@code OptionalInt} if the stream is empty
java.util.stream.IntStream#asLongStream()->LongStream:::Returns a {@code LongStream} consisting of the elements of this stream,  converted to {@code long}
java.util.stream.IntStream#asDoubleStream()->DoubleStream:::Returns a {@code DoubleStream} consisting of the elements of this stream,  converted to {@code double}
java.util.stream.IntStream#boxed()->Stream<Integer>:::Returns a {@code Stream} consisting of the elements of this stream,  each boxed to an {@code Integer}
java.util.stream.IntStream#sequential()->IntStream:::
java.util.stream.IntStream#parallel()->IntStream:::
java.util.stream.IntStream#iterator()->PrimitiveIterator.OfInt:::
java.util.stream.IntStream#spliterator()->Spliterator.OfInt:::
java.util.stream.IntStream#builder()->Builder:::Returns a builder for an {@code IntStream}.
java.util.stream.IntStream#empty()->IntStream:::Returns an empty sequential {@code IntStream}.
java.util.stream.IntStream#of(int)->IntStream:::Returns a sequential {@code IntStream} containing a single element.
java.util.stream.IntStream#of(int...)->IntStream:::Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.IntStream#iterate(int, IntUnaryOperator)->IntStream:::Returns an infinite sequential ordered {@code IntStream} produced by iterative  application of a function {@code f} to an initial element {@code seed},  producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},  {@code f(f(seed))}, etc
java.util.stream.IntStream#iterate(int, IntPredicate, IntUnaryOperator)->IntStream:::Returns a sequential ordered {@code IntStream} produced by iterative  application of the given {@code next} function to an initial element,  conditioned on satisfying the given {@code hasNext} predicate
java.util.stream.IntStream#generate(IntSupplier)->IntStream:::Returns an infinite sequential unordered stream where each element is  generated by the provided {@code IntSupplier}
java.util.stream.IntStream#range(int, int)->IntStream:::Returns a sequential ordered {@code IntStream} from {@code startInclusive}  (inclusive) to {@code endExclusive} (exclusive) by an incremental step of  {@code 1}.
java.util.stream.IntStream#rangeClosed(int, int)->IntStream:::Returns a sequential ordered {@code IntStream} from {@code startInclusive}  (inclusive) to {@code endInclusive} (inclusive) by an incremental step of  {@code 1}.
java.util.stream.IntStream#concat(IntStream, IntStream)->IntStream:::Creates a lazily concatenated stream whose elements are all the  elements of the first stream followed by all the elements of the  second stream
java.util.stream.IntStream.Builder#accept(int)->void:::Adds an element to the stream being built.
java.util.stream.IntStream.Builder#add(int)->Builder:::Adds an element to the stream being built.
java.util.stream.IntStream.Builder#build()->IntStream:::Builds the stream, transitioning this builder to the built state
java.util.stream.LongPipeline#getOutputShape()->StreamShape:::
java.util.stream.LongPipeline#evaluateToNode(PipelineHelper<Long>, Spliterator<P_IN>, boolean, IntFunction<Long[]>)->Node<Long>:::
java.util.stream.LongPipeline#wrap(PipelineHelper<Long>, Supplier<Spliterator<P_IN>>, boolean)->Spliterator<Long>:::
java.util.stream.LongPipeline#lazySpliterator(Supplier<? extends Spliterator<Long>>)->Spliterator.OfLong:::
java.util.stream.LongPipeline#forEachWithCancel(Spliterator<Long>, Sink<Long>)->boolean:::
java.util.stream.LongPipeline#makeNodeBuilder(long, IntFunction<Long[]>)->Node.Builder<Long>:::
java.util.stream.LongPipeline#iterator()->PrimitiveIterator.OfLong:::
java.util.stream.LongPipeline#spliterator()->Spliterator.OfLong:::
java.util.stream.LongPipeline#asDoubleStream()->DoubleStream:::
java.util.stream.LongPipeline#boxed()->Stream<Long>:::
java.util.stream.LongPipeline#map(LongUnaryOperator)->LongStream:::
java.util.stream.LongPipeline#mapToObj(LongFunction<? extends U>)->Stream<U>:::
java.util.stream.LongPipeline#mapToInt(LongToIntFunction)->IntStream:::
java.util.stream.LongPipeline#mapToDouble(LongToDoubleFunction)->DoubleStream:::
java.util.stream.LongPipeline#flatMap(LongFunction<? extends LongStream>)->LongStream:::
java.util.stream.LongPipeline#unordered()->LongStream:::
java.util.stream.LongPipeline#filter(LongPredicate)->LongStream:::
java.util.stream.LongPipeline#peek(LongConsumer)->LongStream:::
java.util.stream.LongPipeline#limit(long)->LongStream:::
java.util.stream.LongPipeline#skip(long)->LongStream:::
java.util.stream.LongPipeline#takeWhile(LongPredicate)->LongStream:::
java.util.stream.LongPipeline#dropWhile(LongPredicate)->LongStream:::
java.util.stream.LongPipeline#sorted()->LongStream:::
java.util.stream.LongPipeline#distinct()->LongStream:::
java.util.stream.LongPipeline#forEach(LongConsumer)->void:::
java.util.stream.LongPipeline#forEachOrdered(LongConsumer)->void:::
java.util.stream.LongPipeline#sum()->long:::
java.util.stream.LongPipeline#min()->OptionalLong:::
java.util.stream.LongPipeline#max()->OptionalLong:::
java.util.stream.LongPipeline#average()->OptionalDouble:::
java.util.stream.LongPipeline#count()->long:::
java.util.stream.LongPipeline#summaryStatistics()->LongSummaryStatistics:::
java.util.stream.LongPipeline#reduce(long, LongBinaryOperator)->long:::
java.util.stream.LongPipeline#reduce(LongBinaryOperator)->OptionalLong:::
java.util.stream.LongPipeline#collect(Supplier<R>, ObjLongConsumer<R>, BiConsumer<R, R>)->R:::
java.util.stream.LongPipeline#anyMatch(LongPredicate)->boolean:::
java.util.stream.LongPipeline#allMatch(LongPredicate)->boolean:::
java.util.stream.LongPipeline#noneMatch(LongPredicate)->boolean:::
java.util.stream.LongPipeline#findFirst()->OptionalLong:::
java.util.stream.LongPipeline#findAny()->OptionalLong:::
java.util.stream.LongPipeline#toArray()->long[]:::
java.util.stream.LongPipeline.Head#opIsStateful()->boolean:::
java.util.stream.LongPipeline.Head#opWrapSink(int, Sink<Long>)->Sink<E_IN>:::
java.util.stream.LongPipeline.Head#forEach(LongConsumer)->void:::
java.util.stream.LongPipeline.Head#forEachOrdered(LongConsumer)->void:::
java.util.stream.LongPipeline.StatelessOp#opIsStateful()->boolean:::
java.util.stream.LongPipeline.StatefulOp#opIsStateful()->boolean:::
java.util.stream.LongPipeline.StatefulOp#opEvaluateParallel(PipelineHelper<Long>, Spliterator<P_IN>, IntFunction<Long[]>)->Node<Long>:::
java.util.stream.LongStream#filter(LongPredicate)->LongStream:::Returns a stream consisting of the elements of this stream that match  the given predicate
java.util.stream.LongStream#map(LongUnaryOperator)->LongStream:::Returns a stream consisting of the results of applying the given  function to the elements of this stream
java.util.stream.LongStream#mapToObj(LongFunction<? extends U>)->Stream<U>:::Returns an object-valued {@code Stream} consisting of the results of  applying the given function to the elements of this stream
java.util.stream.LongStream#mapToInt(LongToIntFunction)->IntStream:::Returns an {@code IntStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.LongStream#mapToDouble(LongToDoubleFunction)->DoubleStream:::Returns a {@code DoubleStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.LongStream#flatMap(LongFunction<? extends LongStream>)->LongStream:::Returns a stream consisting of the results of replacing each element of  this stream with the contents of a mapped stream produced by applying  the provided mapping function to each element
java.util.stream.LongStream#distinct()->LongStream:::Returns a stream consisting of the distinct elements of this stream
java.util.stream.LongStream#sorted()->LongStream:::Returns a stream consisting of the elements of this stream in sorted  order
java.util.stream.LongStream#peek(LongConsumer)->LongStream:::Returns a stream consisting of the elements of this stream, additionally  performing the provided action on each element as elements are consumed  from the resulting stream
java.util.stream.LongStream#limit(long)->LongStream:::Returns a stream consisting of the elements of this stream, truncated  to be no longer than {@code maxSize} in length
java.util.stream.LongStream#skip(long)->LongStream:::Returns a stream consisting of the remaining elements of this stream  after discarding the first {@code n} elements of the stream
java.util.stream.LongStream#takeWhile(LongPredicate)->LongStream:::Returns, if this stream is ordered, a stream consisting of the longest  prefix of elements taken from this stream that match the given predicate
java.util.stream.LongStream#dropWhile(LongPredicate)->LongStream:::Returns, if this stream is ordered, a stream consisting of the remaining  elements of this stream after dropping the longest prefix of elements  that match the given predicate
java.util.stream.LongStream#forEach(LongConsumer)->void:::Performs an action for each element of this stream
java.util.stream.LongStream#forEachOrdered(LongConsumer)->void:::Performs an action for each element of this stream, guaranteeing that  each element is processed in encounter order for streams that have a  defined encounter order
java.util.stream.LongStream#toArray()->long[]:::Returns an array containing the elements of this stream
java.util.stream.LongStream#reduce(long, LongBinaryOperator)->long:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using the provided identity value and an  <a href="package-summary.html#Associativity">associative</a>  accumulation function, and returns the reduced value
java.util.stream.LongStream#reduce(LongBinaryOperator)->OptionalLong:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using an  <a href="package-summary.html#Associativity">associative</a> accumulation  function, and returns an {@code OptionalLong} describing the reduced value,  if any
java.util.stream.LongStream#collect(Supplier<R>, ObjLongConsumer<R>, BiConsumer<R, R>)->R:::Performs a <a href="package-summary.html#MutableReduction">mutable  reduction</a> operation on the elements of this stream
java.util.stream.LongStream#sum()->long:::Returns the sum of elements in this stream
java.util.stream.LongStream#min()->OptionalLong:::Returns an {@code OptionalLong} describing the minimum element of this  stream, or an empty optional if this stream is empty
java.util.stream.LongStream#max()->OptionalLong:::Returns an {@code OptionalLong} describing the maximum element of this  stream, or an empty optional if this stream is empty
java.util.stream.LongStream#count()->long:::Returns the count of elements in this stream
java.util.stream.LongStream#average()->OptionalDouble:::Returns an {@code OptionalDouble} describing the arithmetic mean of elements of  this stream, or an empty optional if this stream is empty
java.util.stream.LongStream#summaryStatistics()->LongSummaryStatistics:::Returns a {@code LongSummaryStatistics} describing various summary data  about the elements of this stream
java.util.stream.LongStream#anyMatch(LongPredicate)->boolean:::Returns whether any elements of this stream match the provided  predicate
java.util.stream.LongStream#allMatch(LongPredicate)->boolean:::Returns whether all elements of this stream match the provided predicate
java.util.stream.LongStream#noneMatch(LongPredicate)->boolean:::Returns whether no elements of this stream match the provided predicate
java.util.stream.LongStream#findFirst()->OptionalLong:::Returns an {@link OptionalLong} describing the first element of this  stream, or an empty {@code OptionalLong} if the stream is empty
java.util.stream.LongStream#findAny()->OptionalLong:::Returns an {@link OptionalLong} describing some element of the stream, or  an empty {@code OptionalLong} if the stream is empty
java.util.stream.LongStream#asDoubleStream()->DoubleStream:::Returns a {@code DoubleStream} consisting of the elements of this stream,  converted to {@code double}
java.util.stream.LongStream#boxed()->Stream<Long>:::Returns a {@code Stream} consisting of the elements of this stream,  each boxed to a {@code Long}
java.util.stream.LongStream#sequential()->LongStream:::
java.util.stream.LongStream#parallel()->LongStream:::
java.util.stream.LongStream#iterator()->PrimitiveIterator.OfLong:::
java.util.stream.LongStream#spliterator()->Spliterator.OfLong:::
java.util.stream.LongStream#builder()->Builder:::Returns a builder for a {@code LongStream}.
java.util.stream.LongStream#empty()->LongStream:::Returns an empty sequential {@code LongStream}.
java.util.stream.LongStream#of(long)->LongStream:::Returns a sequential {@code LongStream} containing a single element.
java.util.stream.LongStream#of(long...)->LongStream:::Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.LongStream#iterate(long, LongUnaryOperator)->LongStream:::Returns an infinite sequential ordered {@code LongStream} produced by iterative  application of a function {@code f} to an initial element {@code seed},  producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},  {@code f(f(seed))}, etc
java.util.stream.LongStream#iterate(long, LongPredicate, LongUnaryOperator)->LongStream:::Returns a sequential ordered {@code LongStream} produced by iterative  application of the given {@code next} function to an initial element,  conditioned on satisfying the given {@code hasNext} predicate
java.util.stream.LongStream#generate(LongSupplier)->LongStream:::Returns an infinite sequential unordered stream where each element is  generated by the provided {@code LongSupplier}
java.util.stream.LongStream#range(long, long)->LongStream:::Returns a sequential ordered {@code LongStream} from {@code startInclusive}  (inclusive) to {@code endExclusive} (exclusive) by an incremental step of  {@code 1}.
java.util.stream.LongStream#rangeClosed(long, long)->LongStream:::Returns a sequential ordered {@code LongStream} from {@code startInclusive}  (inclusive) to {@code endInclusive} (inclusive) by an incremental step of  {@code 1}.
java.util.stream.LongStream#concat(LongStream, LongStream)->LongStream:::Creates a lazily concatenated stream whose elements are all the  elements of the first stream followed by all the elements of the  second stream
java.util.stream.LongStream.Builder#accept(long)->void:::Adds an element to the stream being built.
java.util.stream.LongStream.Builder#add(long)->Builder:::Adds an element to the stream being built.
java.util.stream.LongStream.Builder#build()->LongStream:::Builds the stream, transitioning this builder to the built state
java.util.stream.MatchOps#Boolean> makeRef(Predicate<? super T>, MatchKind)->TerminalOp<T,:::Constructs a quantified predicate matcher for a Stream.
java.util.stream.MatchOps#Boolean> makeInt(IntPredicate, MatchKind)->TerminalOp<Integer,:::Constructs a quantified predicate matcher for an {@code IntStream}.
java.util.stream.MatchOps#Boolean> makeLong(LongPredicate, MatchKind)->TerminalOp<Long,:::Constructs a quantified predicate matcher for a {@code LongStream}.
java.util.stream.MatchOps#Boolean> makeDouble(DoublePredicate, MatchKind)->TerminalOp<Double,:::Constructs a quantified predicate matcher for a {@code DoubleStream}.
java.util.stream.MatchOps.MatchOp#getOpFlags()->int:::
java.util.stream.MatchOps.MatchOp#inputShape()->StreamShape:::
java.util.stream.MatchOps.MatchOp#evaluateSequential(PipelineHelper<T>, Spliterator<S>)->Boolean:::
java.util.stream.MatchOps.MatchOp#evaluateParallel(PipelineHelper<T>, Spliterator<S>)->Boolean:::
java.util.stream.MatchOps.BooleanTerminalSink#getAndClearState()->boolean:::
java.util.stream.MatchOps.BooleanTerminalSink#cancellationRequested()->boolean:::
java.util.stream.MatchOps.MatchTask#P_OUT> makeChild(Spliterator<P_IN>)->MatchTask<P_IN,:::
java.util.stream.MatchOps.MatchTask#doLeaf()->Boolean:::
java.util.stream.MatchOps.MatchTask#getEmptyResult()->Boolean:::
java.util.stream.Node#spliterator()->Spliterator<T>:::Returns a {@link Spliterator} describing the elements contained in this  {@code Node}.
java.util.stream.Node#forEach(Consumer<? super T>)->void:::Traverses the elements of this node, and invoke the provided  {@code Consumer} with each element
java.util.stream.Node#getChildCount()->int:::Returns the number of child nodes of this node.
java.util.stream.Node#getChild(int)->Node<T>:::Retrieves the child {@code Node} at a given index.
java.util.stream.Node#truncate(long, long, IntFunction<T[]>)->Node<T>:::Return a node describing a subsequence of the elements of this node,  starting at the given inclusive start offset and ending at the given  exclusive end offset.
java.util.stream.Node#asArray(IntFunction<T[]>)->T[]:::Provides an array view of the contents of this node
java.util.stream.Node#copyInto(T[], int)->void:::Copies the content of this {@code Node} into an array, starting at a  given offset into the array
java.util.stream.Node#getShape()->StreamShape:::Gets the {@code StreamShape} associated with this {@code Node}.
java.util.stream.Node#count()->long:::Returns the number of elements contained in this node.
java.util.stream.Node.Builder#build()->Node<T>:::Builds the node
java.util.stream.Node.Builder.OfInt#build()->Node.OfInt:::
java.util.stream.Node.Builder.OfLong#build()->Node.OfLong:::
java.util.stream.Node.Builder.OfDouble#build()->Node.OfDouble:::
java.util.stream.Node.OfPrimitive#spliterator()->T_SPLITR:::{@inheritDoc}
java.util.stream.Node.OfPrimitive#forEach(T_CONS)->void:::Traverses the elements of this node, and invoke the provided  {@code action} with each element.
java.util.stream.Node.OfPrimitive#getChild(int)->T_NODE:::
java.util.stream.Node.OfPrimitive#truncate(long, long, IntFunction<T[]>)->T_NODE:::
java.util.stream.Node.OfPrimitive#asArray(IntFunction<T[]>)->T[]:::{@inheritDoc}
java.util.stream.Node.OfPrimitive#asPrimitiveArray()->T_ARR:::Views this node as a primitive array
java.util.stream.Node.OfPrimitive#newArray(int)->T_ARR:::Creates a new primitive array.
java.util.stream.Node.OfPrimitive#copyInto(T_ARR, int)->void:::Copies the content of this {@code Node} into a primitive array,  starting at a given offset into the array
java.util.stream.Node.OfInt#forEach(Consumer<? super Integer>)->void:::{@inheritDoc}
java.util.stream.Node.OfInt#copyInto(Integer[], int)->void:::{@inheritDoc}
java.util.stream.Node.OfInt#truncate(long, long, IntFunction<Integer[]>)->Node.OfInt:::
java.util.stream.Node.OfInt#newArray(int)->int[]:::
java.util.stream.Node.OfInt#getShape()->StreamShape:::{@inheritDoc}
java.util.stream.Node.OfLong#forEach(Consumer<? super Long>)->void:::{@inheritDoc}
java.util.stream.Node.OfLong#copyInto(Long[], int)->void:::{@inheritDoc}
java.util.stream.Node.OfLong#truncate(long, long, IntFunction<Long[]>)->Node.OfLong:::
java.util.stream.Node.OfLong#newArray(int)->long[]:::
java.util.stream.Node.OfLong#getShape()->StreamShape:::{@inheritDoc}
java.util.stream.Node.OfDouble#forEach(Consumer<? super Double>)->void:::{@inheritDoc}
java.util.stream.Node.OfDouble#copyInto(Double[], int)->void:::{@inheritDoc}
java.util.stream.Node.OfDouble#truncate(long, long, IntFunction<Double[]>)->Node.OfDouble:::
java.util.stream.Node.OfDouble#newArray(int)->double[]:::
java.util.stream.Node.OfDouble#getShape()->StreamShape:::{@inheritDoc}
java.util.stream.Nodes#castingArray()->IntFunction<T[]>:::
java.util.stream.Nodes#emptyNode(StreamShape)->Node<T>:::Produces an empty node whose count is zero, has no children and no content.
java.util.stream.Nodes#conc(StreamShape, Node<T>, Node<T>)->Node<T>:::Produces a concatenated {@link Node} that has two or more children
java.util.stream.Nodes#node(T[])->Node<T>:::Produces a {@link Node} describing an array
java.util.stream.Nodes#node(Collection<T>)->Node<T>:::Produces a {@link Node} describing a {@link Collection}
java.util.stream.Nodes#builder(long, IntFunction<T[]>)->Node.Builder<T>:::Produces a {@link Node.Builder}.
java.util.stream.Nodes#builder()->Node.Builder<T>:::Produces a variable size @{link Node.Builder}.
java.util.stream.Nodes#node(int[])->Node.OfInt:::Produces a {@link Node.OfInt} describing an int[] array
java.util.stream.Nodes#intBuilder(long)->Node.Builder.OfInt:::Produces a {@link Node.Builder.OfInt}.
java.util.stream.Nodes#intBuilder()->Node.Builder.OfInt:::Produces a variable size @{link Node.Builder.OfInt}.
java.util.stream.Nodes#node(long[])->Node.OfLong:::Produces a {@link Node.OfLong} describing a long[] array
java.util.stream.Nodes#longBuilder(long)->Node.Builder.OfLong:::Produces a {@link Node.Builder.OfLong}.
java.util.stream.Nodes#longBuilder()->Node.Builder.OfLong:::Produces a variable size @{link Node.Builder.OfLong}.
java.util.stream.Nodes#node(double[])->Node.OfDouble:::Produces a {@link Node.OfDouble} describing a double[] array
java.util.stream.Nodes#doubleBuilder(long)->Node.Builder.OfDouble:::Produces a {@link Node.Builder.OfDouble}.
java.util.stream.Nodes#doubleBuilder()->Node.Builder.OfDouble:::Produces a variable size @{link Node.Builder.OfDouble}.
java.util.stream.Nodes#collect(PipelineHelper<P_OUT>, Spliterator<P_IN>, boolean, IntFunction<P_OUT[]>)->Node<P_OUT>:::Collect, in parallel, elements output from a pipeline and describe those  elements with a {@link Node}.
java.util.stream.Nodes#collectInt(PipelineHelper<Integer>, Spliterator<P_IN>, boolean)->Node.OfInt:::Collect, in parallel, elements output from an int-valued pipeline and  describe those elements with a {@link Node.OfInt}.
java.util.stream.Nodes#collectLong(PipelineHelper<Long>, Spliterator<P_IN>, boolean)->Node.OfLong:::Collect, in parallel, elements output from a long-valued pipeline and  describe those elements with a {@link Node.OfLong}.
java.util.stream.Nodes#collectDouble(PipelineHelper<Double>, Spliterator<P_IN>, boolean)->Node.OfDouble:::Collect, in parallel, elements output from n double-valued pipeline and  describe those elements with a {@link Node.OfDouble}.
java.util.stream.Nodes#flatten(Node<T>, IntFunction<T[]>)->Node<T>:::Flatten, in parallel, a {@link Node}
java.util.stream.Nodes#flattenInt(Node.OfInt)->Node.OfInt:::Flatten, in parallel, a {@link Node.OfInt}
java.util.stream.Nodes#flattenLong(Node.OfLong)->Node.OfLong:::Flatten, in parallel, a {@link Node.OfLong}
java.util.stream.Nodes#flattenDouble(Node.OfDouble)->Node.OfDouble:::Flatten, in parallel, a {@link Node.OfDouble}
java.util.stream.Nodes.EmptyNode#asArray(IntFunction<T[]>)->T[]:::
java.util.stream.Nodes.EmptyNode#copyInto(T_ARR, int)->void:::
java.util.stream.Nodes.EmptyNode#count()->long:::
java.util.stream.Nodes.EmptyNode#forEach(T_CONS)->void:::
java.util.stream.Nodes.EmptyNode.OfRef#spliterator()->Spliterator<T>:::
java.util.stream.Nodes.EmptyNode.OfInt#spliterator()->Spliterator.OfInt:::
java.util.stream.Nodes.EmptyNode.OfInt#asPrimitiveArray()->int[]:::
java.util.stream.Nodes.EmptyNode.OfLong#spliterator()->Spliterator.OfLong:::
java.util.stream.Nodes.EmptyNode.OfLong#asPrimitiveArray()->long[]:::
java.util.stream.Nodes.EmptyNode.OfDouble#spliterator()->Spliterator.OfDouble:::
java.util.stream.Nodes.EmptyNode.OfDouble#asPrimitiveArray()->double[]:::
java.util.stream.Nodes.ArrayNode#spliterator()->Spliterator<T>:::
java.util.stream.Nodes.ArrayNode#copyInto(T[], int)->void:::
java.util.stream.Nodes.ArrayNode#asArray(IntFunction<T[]>)->T[]:::
java.util.stream.Nodes.ArrayNode#count()->long:::
java.util.stream.Nodes.ArrayNode#forEach(Consumer<? super T>)->void:::
java.util.stream.Nodes.ArrayNode#toString()->String:::
java.util.stream.Nodes.CollectionNode#spliterator()->Spliterator<T>:::
java.util.stream.Nodes.CollectionNode#copyInto(T[], int)->void:::
java.util.stream.Nodes.CollectionNode#asArray(IntFunction<T[]>)->T[]:::
java.util.stream.Nodes.CollectionNode#count()->long:::
java.util.stream.Nodes.CollectionNode#forEach(Consumer<? super T>)->void:::
java.util.stream.Nodes.CollectionNode#toString()->String:::
java.util.stream.Nodes.AbstractConcNode#getChildCount()->int:::
java.util.stream.Nodes.AbstractConcNode#getChild(int)->T_NODE:::
java.util.stream.Nodes.AbstractConcNode#count()->long:::
java.util.stream.Nodes.ConcNode#spliterator()->Spliterator<T>:::
java.util.stream.Nodes.ConcNode#copyInto(T[], int)->void:::
java.util.stream.Nodes.ConcNode#asArray(IntFunction<T[]>)->T[]:::
java.util.stream.Nodes.ConcNode#forEach(Consumer<? super T>)->void:::
java.util.stream.Nodes.ConcNode#truncate(long, long, IntFunction<T[]>)->Node<T>:::
java.util.stream.Nodes.ConcNode#toString()->String:::
java.util.stream.Nodes.ConcNode.OfPrimitive#forEach(T_CONS)->void:::
java.util.stream.Nodes.ConcNode.OfPrimitive#copyInto(T_ARR, int)->void:::
java.util.stream.Nodes.ConcNode.OfPrimitive#asPrimitiveArray()->T_ARR:::
java.util.stream.Nodes.ConcNode.OfPrimitive#toString()->String:::
java.util.stream.Nodes.ConcNode.OfInt#spliterator()->Spliterator.OfInt:::
java.util.stream.Nodes.ConcNode.OfLong#spliterator()->Spliterator.OfLong:::
java.util.stream.Nodes.ConcNode.OfDouble#spliterator()->Spliterator.OfDouble:::
java.util.stream.Nodes.InternalNodeSpliterator#initStack()->Deque<N>:::Initiate a stack containing, in left-to-right order, the child nodes  covered by this spliterator
java.util.stream.Nodes.InternalNodeSpliterator#findNextLeafNode(Deque<N>)->N:::Depth first search, in left-to-right order, of the node tree, using  an explicit stack, to find the next non-empty leaf node.
java.util.stream.Nodes.InternalNodeSpliterator#initTryAdvance()->boolean:::
java.util.stream.Nodes.InternalNodeSpliterator#trySplit()->S:::
java.util.stream.Nodes.InternalNodeSpliterator#estimateSize()->long:::
java.util.stream.Nodes.InternalNodeSpliterator#characteristics()->int:::
java.util.stream.Nodes.InternalNodeSpliterator.OfRef#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.Nodes.InternalNodeSpliterator.OfRef#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.Nodes.InternalNodeSpliterator.OfPrimitive#tryAdvance(T_CONS)->boolean:::
java.util.stream.Nodes.InternalNodeSpliterator.OfPrimitive#forEachRemaining(T_CONS)->void:::
java.util.stream.Nodes.FixedNodeBuilder#build()->Node<T>:::
java.util.stream.Nodes.FixedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.FixedNodeBuilder#accept(T)->void:::
java.util.stream.Nodes.FixedNodeBuilder#end()->void:::
java.util.stream.Nodes.FixedNodeBuilder#toString()->String:::
java.util.stream.Nodes.SpinedNodeBuilder#spliterator()->Spliterator<T>:::
java.util.stream.Nodes.SpinedNodeBuilder#forEach(Consumer<? super T>)->void:::
java.util.stream.Nodes.SpinedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.SpinedNodeBuilder#accept(T)->void:::
java.util.stream.Nodes.SpinedNodeBuilder#end()->void:::
java.util.stream.Nodes.SpinedNodeBuilder#copyInto(T[], int)->void:::
java.util.stream.Nodes.SpinedNodeBuilder#asArray(IntFunction<T[]>)->T[]:::
java.util.stream.Nodes.SpinedNodeBuilder#build()->Node<T>:::
java.util.stream.Nodes.IntArrayNode#spliterator()->Spliterator.OfInt:::
java.util.stream.Nodes.IntArrayNode#asPrimitiveArray()->int[]:::
java.util.stream.Nodes.IntArrayNode#copyInto(int[], int)->void:::
java.util.stream.Nodes.IntArrayNode#count()->long:::
java.util.stream.Nodes.IntArrayNode#forEach(IntConsumer)->void:::
java.util.stream.Nodes.IntArrayNode#toString()->String:::
java.util.stream.Nodes.LongArrayNode#spliterator()->Spliterator.OfLong:::
java.util.stream.Nodes.LongArrayNode#asPrimitiveArray()->long[]:::
java.util.stream.Nodes.LongArrayNode#copyInto(long[], int)->void:::
java.util.stream.Nodes.LongArrayNode#count()->long:::
java.util.stream.Nodes.LongArrayNode#forEach(LongConsumer)->void:::
java.util.stream.Nodes.LongArrayNode#toString()->String:::
java.util.stream.Nodes.DoubleArrayNode#spliterator()->Spliterator.OfDouble:::
java.util.stream.Nodes.DoubleArrayNode#asPrimitiveArray()->double[]:::
java.util.stream.Nodes.DoubleArrayNode#copyInto(double[], int)->void:::
java.util.stream.Nodes.DoubleArrayNode#count()->long:::
java.util.stream.Nodes.DoubleArrayNode#forEach(DoubleConsumer)->void:::
java.util.stream.Nodes.DoubleArrayNode#toString()->String:::
java.util.stream.Nodes.IntFixedNodeBuilder#build()->Node.OfInt:::
java.util.stream.Nodes.IntFixedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.IntFixedNodeBuilder#accept(int)->void:::
java.util.stream.Nodes.IntFixedNodeBuilder#end()->void:::
java.util.stream.Nodes.IntFixedNodeBuilder#toString()->String:::
java.util.stream.Nodes.LongFixedNodeBuilder#build()->Node.OfLong:::
java.util.stream.Nodes.LongFixedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.LongFixedNodeBuilder#accept(long)->void:::
java.util.stream.Nodes.LongFixedNodeBuilder#end()->void:::
java.util.stream.Nodes.LongFixedNodeBuilder#toString()->String:::
java.util.stream.Nodes.DoubleFixedNodeBuilder#build()->Node.OfDouble:::
java.util.stream.Nodes.DoubleFixedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.DoubleFixedNodeBuilder#accept(double)->void:::
java.util.stream.Nodes.DoubleFixedNodeBuilder#end()->void:::
java.util.stream.Nodes.DoubleFixedNodeBuilder#toString()->String:::
java.util.stream.Nodes.IntSpinedNodeBuilder#spliterator()->Spliterator.OfInt:::
java.util.stream.Nodes.IntSpinedNodeBuilder#forEach(IntConsumer)->void:::
java.util.stream.Nodes.IntSpinedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.IntSpinedNodeBuilder#accept(int)->void:::
java.util.stream.Nodes.IntSpinedNodeBuilder#end()->void:::
java.util.stream.Nodes.IntSpinedNodeBuilder#copyInto(int[], int)->void:::
java.util.stream.Nodes.IntSpinedNodeBuilder#asPrimitiveArray()->int[]:::
java.util.stream.Nodes.IntSpinedNodeBuilder#build()->Node.OfInt:::
java.util.stream.Nodes.LongSpinedNodeBuilder#spliterator()->Spliterator.OfLong:::
java.util.stream.Nodes.LongSpinedNodeBuilder#forEach(LongConsumer)->void:::
java.util.stream.Nodes.LongSpinedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.LongSpinedNodeBuilder#accept(long)->void:::
java.util.stream.Nodes.LongSpinedNodeBuilder#end()->void:::
java.util.stream.Nodes.LongSpinedNodeBuilder#copyInto(long[], int)->void:::
java.util.stream.Nodes.LongSpinedNodeBuilder#asPrimitiveArray()->long[]:::
java.util.stream.Nodes.LongSpinedNodeBuilder#build()->Node.OfLong:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#spliterator()->Spliterator.OfDouble:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#forEach(DoubleConsumer)->void:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#begin(long)->void:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#accept(double)->void:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#end()->void:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#copyInto(double[], int)->void:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#asPrimitiveArray()->double[]:::
java.util.stream.Nodes.DoubleSpinedNodeBuilder#build()->Node.OfDouble:::
java.util.stream.Nodes.SizedCollectorTask#compute()->void:::
java.util.stream.Nodes.SizedCollectorTask#makeChild(Spliterator<P_IN>, long, long)->K:::
java.util.stream.Nodes.SizedCollectorTask#begin(long)->void:::
java.util.stream.Nodes.SizedCollectorTask.OfRef#P_OUT> makeChild(Spliterator<P_IN>, long, long)->OfRef<P_IN,:::
java.util.stream.Nodes.SizedCollectorTask.OfRef#accept(P_OUT)->void:::
java.util.stream.Nodes.SizedCollectorTask.OfInt#makeChild(Spliterator<P_IN>, long, long)->SizedCollectorTask.OfInt<P_IN>:::
java.util.stream.Nodes.SizedCollectorTask.OfInt#accept(int)->void:::
java.util.stream.Nodes.SizedCollectorTask.OfLong#makeChild(Spliterator<P_IN>, long, long)->SizedCollectorTask.OfLong<P_IN>:::
java.util.stream.Nodes.SizedCollectorTask.OfLong#accept(long)->void:::
java.util.stream.Nodes.SizedCollectorTask.OfDouble#makeChild(Spliterator<P_IN>, long, long)->SizedCollectorTask.OfDouble<P_IN>:::
java.util.stream.Nodes.SizedCollectorTask.OfDouble#accept(double)->void:::
java.util.stream.Nodes.ToArrayTask#copyNodeToArray()->void:::
java.util.stream.Nodes.ToArrayTask#makeChild(int, int)->K:::
java.util.stream.Nodes.ToArrayTask#compute()->void:::
java.util.stream.Nodes.ToArrayTask.OfRef#makeChild(int, int)->OfRef<T>:::
java.util.stream.Nodes.ToArrayTask.OfRef#copyNodeToArray()->void:::
java.util.stream.Nodes.ToArrayTask.OfPrimitive#T_CONS, T_ARR, T_SPLITR, T_NODE> makeChild(int, int)->OfPrimitive<T,:::
java.util.stream.Nodes.ToArrayTask.OfPrimitive#copyNodeToArray()->void:::
java.util.stream.Nodes.CollectorTask#P_OUT, T_NODE, T_BUILDER> makeChild(Spliterator<P_IN>)->CollectorTask<P_IN,:::
java.util.stream.Nodes.CollectorTask#doLeaf()->T_NODE:::
java.util.stream.Nodes.CollectorTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.PipelineHelper#getSourceShape()->StreamShape:::Gets the stream shape for the source of the pipeline segment.
java.util.stream.PipelineHelper#getStreamAndOpFlags()->int:::Gets the combined stream and operation flags for the output of the described  pipeline
java.util.stream.PipelineHelper#exactOutputSizeIfKnown(Spliterator<P_IN>)->long:::Returns the exact output size of the portion of the output resulting from  applying the pipeline stages described by this {@code PipelineHelper} to  the portion of the input described by the provided  {@code Spliterator}, if known
java.util.stream.PipelineHelper#wrapAndCopyInto(S, Spliterator<P_IN>)->S:::Applies the pipeline stages described by this {@code PipelineHelper} to  the provided {@code Spliterator} and send the results to the provided  {@code Sink}.
java.util.stream.PipelineHelper#copyInto(Sink<P_IN>, Spliterator<P_IN>)->void:::Pushes elements obtained from the {@code Spliterator} into the provided  {@code Sink}
java.util.stream.PipelineHelper#copyIntoWithCancel(Sink<P_IN>, Spliterator<P_IN>)->boolean:::Pushes elements obtained from the {@code Spliterator} into the provided  {@code Sink}, checking {@link Sink#cancellationRequested()} after each  element, and stopping if cancellation is requested.
java.util.stream.PipelineHelper#wrapSink(Sink<P_OUT>)->Sink<P_IN>:::Takes a {@code Sink} that accepts elements of the output type of the  {@code PipelineHelper}, and wrap it with a {@code Sink} that accepts  elements of the input type and implements all the intermediate operations  described by this {@code PipelineHelper}, delivering the result into the  provided {@code Sink}.
java.util.stream.PipelineHelper#wrapSpliterator(Spliterator<P_IN>)->Spliterator<P_OUT>:::
java.util.stream.PipelineHelper#makeNodeBuilder(long, IntFunction<P_OUT[]>)->Node.Builder<P_OUT>:::Constructs a @{link Node.Builder} compatible with the output shape of  this {@code PipelineHelper}.
java.util.stream.PipelineHelper#evaluate(Spliterator<P_IN>, boolean, IntFunction<P_OUT[]>)->Node<P_OUT>:::Collects all output elements resulting from applying the pipeline stages  to the source {@code Spliterator} into a {@code Node}.
java.util.stream.ReduceOps#U> makeRef(U, BiFunction<U, ? super T, U>, BinaryOperator<U>)->TerminalOp<T,:::Constructs a {@code TerminalOp} that implements a functional reduce on  reference values.
java.util.stream.ReduceOps#Optional<T>> makeRef(BinaryOperator<T>)->TerminalOp<T,:::Constructs a {@code TerminalOp} that implements a functional reduce on  reference values producing an optional reference result.
java.util.stream.ReduceOps#I> makeRef(Collector<? super T, I, ?>)->TerminalOp<T,:::Constructs a {@code TerminalOp} that implements a mutable reduce on  reference values.
java.util.stream.ReduceOps#R> makeRef(Supplier<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>)->TerminalOp<T,:::Constructs a {@code TerminalOp} that implements a mutable reduce on  reference values.
java.util.stream.ReduceOps#Long> makeRefCounting()->TerminalOp<T,:::Constructs a {@code TerminalOp} that counts the number of stream  elements
java.util.stream.ReduceOps#Integer> makeInt(int, IntBinaryOperator)->TerminalOp<Integer,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code int} values.
java.util.stream.ReduceOps#OptionalInt> makeInt(IntBinaryOperator)->TerminalOp<Integer,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code int} values, producing an optional integer result.
java.util.stream.ReduceOps#R> makeInt(Supplier<R>, ObjIntConsumer<R>, BinaryOperator<R>)->TerminalOp<Integer,:::Constructs a {@code TerminalOp} that implements a mutable reduce on  {@code int} values.
java.util.stream.ReduceOps#Long> makeIntCounting()->TerminalOp<Integer,:::Constructs a {@code TerminalOp} that counts the number of stream  elements
java.util.stream.ReduceOps#Long> makeLong(long, LongBinaryOperator)->TerminalOp<Long,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code long} values.
java.util.stream.ReduceOps#OptionalLong> makeLong(LongBinaryOperator)->TerminalOp<Long,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code long} values, producing an optional long result.
java.util.stream.ReduceOps#R> makeLong(Supplier<R>, ObjLongConsumer<R>, BinaryOperator<R>)->TerminalOp<Long,:::Constructs a {@code TerminalOp} that implements a mutable reduce on  {@code long} values.
java.util.stream.ReduceOps#Long> makeLongCounting()->TerminalOp<Long,:::Constructs a {@code TerminalOp} that counts the number of stream  elements
java.util.stream.ReduceOps#Double> makeDouble(double, DoubleBinaryOperator)->TerminalOp<Double,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code double} values.
java.util.stream.ReduceOps#OptionalDouble> makeDouble(DoubleBinaryOperator)->TerminalOp<Double,:::Constructs a {@code TerminalOp} that implements a functional reduce on  {@code double} values, producing an optional double result.
java.util.stream.ReduceOps#R> makeDouble(Supplier<R>, ObjDoubleConsumer<R>, BinaryOperator<R>)->TerminalOp<Double,:::Constructs a {@code TerminalOp} that implements a mutable reduce on  {@code double} values.
java.util.stream.ReduceOps#Long> makeDoubleCounting()->TerminalOp<Double,:::Constructs a {@code TerminalOp} that counts the number of stream  elements
java.util.stream.ReduceOps.CountingSink#begin(long)->void:::
java.util.stream.ReduceOps.CountingSink#get()->Long:::
java.util.stream.ReduceOps.CountingSink#combine(CountingSink<T>)->void:::
java.util.stream.ReduceOps.CountingSink.OfRef#accept(T)->void:::
java.util.stream.ReduceOps.CountingSink.OfInt#accept(int)->void:::
java.util.stream.ReduceOps.CountingSink.OfLong#accept(long)->void:::
java.util.stream.ReduceOps.CountingSink.OfDouble#accept(double)->void:::
java.util.stream.ReduceOps.AccumulatingSink#combine(K)->void:::
java.util.stream.ReduceOps.Box#get()->U:::
java.util.stream.ReduceOps.ReduceOp#makeSink()->S:::
java.util.stream.ReduceOps.ReduceOp#inputShape()->StreamShape:::
java.util.stream.ReduceOps.ReduceOp#evaluateSequential(PipelineHelper<T>, Spliterator<P_IN>)->R:::
java.util.stream.ReduceOps.ReduceOp#evaluateParallel(PipelineHelper<T>, Spliterator<P_IN>)->R:::
java.util.stream.ReduceOps.ReduceTask#P_OUT, R, S> makeChild(Spliterator<P_IN>)->ReduceTask<P_IN,:::
java.util.stream.ReduceOps.ReduceTask#doLeaf()->S:::
java.util.stream.ReduceOps.ReduceTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.ReferencePipeline#getOutputShape()->StreamShape:::
java.util.stream.ReferencePipeline#evaluateToNode(PipelineHelper<P_OUT>, Spliterator<P_IN>, boolean, IntFunction<P_OUT[]>)->Node<P_OUT>:::
java.util.stream.ReferencePipeline#wrap(PipelineHelper<P_OUT>, Supplier<Spliterator<P_IN>>, boolean)->Spliterator<P_OUT>:::
java.util.stream.ReferencePipeline#lazySpliterator(Supplier<? extends Spliterator<P_OUT>>)->Spliterator<P_OUT>:::
java.util.stream.ReferencePipeline#forEachWithCancel(Spliterator<P_OUT>, Sink<P_OUT>)->boolean:::
java.util.stream.ReferencePipeline#makeNodeBuilder(long, IntFunction<P_OUT[]>)->Node.Builder<P_OUT>:::
java.util.stream.ReferencePipeline#iterator()->Iterator<P_OUT>:::
java.util.stream.ReferencePipeline#unordered()->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#filter(Predicate<? super P_OUT>)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#map(Function<? super P_OUT, ? extends R>)->Stream<R>:::
java.util.stream.ReferencePipeline#mapToInt(ToIntFunction<? super P_OUT>)->IntStream:::
java.util.stream.ReferencePipeline#mapToLong(ToLongFunction<? super P_OUT>)->LongStream:::
java.util.stream.ReferencePipeline#mapToDouble(ToDoubleFunction<? super P_OUT>)->DoubleStream:::
java.util.stream.ReferencePipeline#flatMap(Function<? super P_OUT, ? extends Stream<? extends R>>)->Stream<R>:::
java.util.stream.ReferencePipeline#flatMapToInt(Function<? super P_OUT, ? extends IntStream>)->IntStream:::
java.util.stream.ReferencePipeline#flatMapToDouble(Function<? super P_OUT, ? extends DoubleStream>)->DoubleStream:::
java.util.stream.ReferencePipeline#flatMapToLong(Function<? super P_OUT, ? extends LongStream>)->LongStream:::
java.util.stream.ReferencePipeline#peek(Consumer<? super P_OUT>)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#distinct()->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#sorted()->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#sorted(Comparator<? super P_OUT>)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#limit(long)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#skip(long)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#takeWhile(Predicate<? super P_OUT>)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#dropWhile(Predicate<? super P_OUT>)->Stream<P_OUT>:::
java.util.stream.ReferencePipeline#forEach(Consumer<? super P_OUT>)->void:::
java.util.stream.ReferencePipeline#forEachOrdered(Consumer<? super P_OUT>)->void:::
java.util.stream.ReferencePipeline#toArray(IntFunction<A[]>)->A[]:::
java.util.stream.ReferencePipeline#toArray()->Object[]:::
java.util.stream.ReferencePipeline#anyMatch(Predicate<? super P_OUT>)->boolean:::
java.util.stream.ReferencePipeline#allMatch(Predicate<? super P_OUT>)->boolean:::
java.util.stream.ReferencePipeline#noneMatch(Predicate<? super P_OUT>)->boolean:::
java.util.stream.ReferencePipeline#findFirst()->Optional<P_OUT>:::
java.util.stream.ReferencePipeline#findAny()->Optional<P_OUT>:::
java.util.stream.ReferencePipeline#reduce(P_OUT, BinaryOperator<P_OUT>)->P_OUT:::
java.util.stream.ReferencePipeline#reduce(BinaryOperator<P_OUT>)->Optional<P_OUT>:::
java.util.stream.ReferencePipeline#reduce(R, BiFunction<R, ? super P_OUT, R>, BinaryOperator<R>)->R:::
java.util.stream.ReferencePipeline#collect(Collector<? super P_OUT, A, R>)->R:::
java.util.stream.ReferencePipeline#collect(Supplier<R>, BiConsumer<R, ? super P_OUT>, BiConsumer<R, R>)->R:::
java.util.stream.ReferencePipeline#max(Comparator<? super P_OUT>)->Optional<P_OUT>:::
java.util.stream.ReferencePipeline#min(Comparator<? super P_OUT>)->Optional<P_OUT>:::
java.util.stream.ReferencePipeline#count()->long:::
java.util.stream.ReferencePipeline.Head#opIsStateful()->boolean:::
java.util.stream.ReferencePipeline.Head#opWrapSink(int, Sink<E_OUT>)->Sink<E_IN>:::
java.util.stream.ReferencePipeline.Head#forEach(Consumer<? super E_OUT>)->void:::
java.util.stream.ReferencePipeline.Head#forEachOrdered(Consumer<? super E_OUT>)->void:::
java.util.stream.ReferencePipeline.StatelessOp#opIsStateful()->boolean:::
java.util.stream.ReferencePipeline.StatefulOp#opIsStateful()->boolean:::
java.util.stream.ReferencePipeline.StatefulOp#opEvaluateParallel(PipelineHelper<E_OUT>, Spliterator<P_IN>, IntFunction<E_OUT[]>)->Node<E_OUT>:::
java.util.stream.Sink#begin(long)->void:::Resets the sink state to receive a fresh data set
java.util.stream.Sink#end()->void:::Indicates that all elements have been pushed
java.util.stream.Sink#cancellationRequested()->boolean:::Indicates that this {@code Sink} does not wish to receive any more data.
java.util.stream.Sink#accept(int)->void:::Accepts an int value.
java.util.stream.Sink#accept(long)->void:::Accepts a long value.
java.util.stream.Sink#accept(double)->void:::Accepts a double value.
java.util.stream.Sink.OfInt#accept(int)->void:::
java.util.stream.Sink.OfInt#accept(Integer)->void:::
java.util.stream.Sink.OfLong#accept(long)->void:::
java.util.stream.Sink.OfLong#accept(Long)->void:::
java.util.stream.Sink.OfDouble#accept(double)->void:::
java.util.stream.Sink.OfDouble#accept(Double)->void:::
java.util.stream.Sink.ChainedReference#begin(long)->void:::
java.util.stream.Sink.ChainedReference#end()->void:::
java.util.stream.Sink.ChainedReference#cancellationRequested()->boolean:::
java.util.stream.Sink.ChainedInt#begin(long)->void:::
java.util.stream.Sink.ChainedInt#end()->void:::
java.util.stream.Sink.ChainedInt#cancellationRequested()->boolean:::
java.util.stream.Sink.ChainedLong#begin(long)->void:::
java.util.stream.Sink.ChainedLong#end()->void:::
java.util.stream.Sink.ChainedLong#cancellationRequested()->boolean:::
java.util.stream.Sink.ChainedDouble#begin(long)->void:::
java.util.stream.Sink.ChainedDouble#end()->void:::
java.util.stream.Sink.ChainedDouble#cancellationRequested()->boolean:::
java.util.stream.SliceOps#makeRef(AbstractPipeline<?, T, ?>, long, long)->Stream<T>:::Appends a "slice" operation to the provided stream
java.util.stream.SliceOps#makeInt(AbstractPipeline<?, Integer, ?>, long, long)->IntStream:::Appends a "slice" operation to the provided IntStream
java.util.stream.SliceOps#makeLong(AbstractPipeline<?, Long, ?>, long, long)->LongStream:::Appends a "slice" operation to the provided LongStream
java.util.stream.SliceOps#makeDouble(AbstractPipeline<?, Double, ?>, long, long)->DoubleStream:::Appends a "slice" operation to the provided DoubleStream
java.util.stream.SliceOps.SliceTask#P_OUT> makeChild(Spliterator<P_IN>)->SliceTask<P_IN,:::
java.util.stream.SliceOps.SliceTask#getEmptyResult()->Node<P_OUT>:::
java.util.stream.SliceOps.SliceTask#doLeaf()->Node<P_OUT>:::
java.util.stream.SliceOps.SliceTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.SliceOps.SliceTask#cancel()->void:::
java.util.stream.SortedOps#makeRef(AbstractPipeline<?, T, ?>)->Stream<T>:::Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps#makeRef(AbstractPipeline<?, T, ?>, Comparator<? super T>)->Stream<T>:::Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps#makeInt(AbstractPipeline<?, Integer, ?>)->IntStream:::Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps#makeLong(AbstractPipeline<?, Long, ?>)->LongStream:::Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps#makeDouble(AbstractPipeline<?, Double, ?>)->DoubleStream:::Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps.OfRef#opWrapSink(int, Sink<T>)->Sink<T>:::
java.util.stream.SortedOps.OfRef#opEvaluateParallel(PipelineHelper<T>, Spliterator<P_IN>, IntFunction<T[]>)->Node<T>:::
java.util.stream.SortedOps.OfInt#opWrapSink(int, Sink<Integer>)->Sink<Integer>:::
java.util.stream.SortedOps.OfInt#opEvaluateParallel(PipelineHelper<Integer>, Spliterator<P_IN>, IntFunction<Integer[]>)->Node<Integer>:::
java.util.stream.SortedOps.OfLong#opWrapSink(int, Sink<Long>)->Sink<Long>:::
java.util.stream.SortedOps.OfLong#opEvaluateParallel(PipelineHelper<Long>, Spliterator<P_IN>, IntFunction<Long[]>)->Node<Long>:::
java.util.stream.SortedOps.OfDouble#opWrapSink(int, Sink<Double>)->Sink<Double>:::
java.util.stream.SortedOps.OfDouble#opEvaluateParallel(PipelineHelper<Double>, Spliterator<P_IN>, IntFunction<Double[]>)->Node<Double>:::
java.util.stream.SortedOps.AbstractRefSortingSink#cancellationRequested()->boolean:::Records is cancellation is requested so short-circuiting behaviour  can be preserved when the sorted elements are pushed downstream.
java.util.stream.SortedOps.SizedRefSortingSink#begin(long)->void:::
java.util.stream.SortedOps.SizedRefSortingSink#end()->void:::
java.util.stream.SortedOps.SizedRefSortingSink#accept(T)->void:::
java.util.stream.SortedOps.RefSortingSink#begin(long)->void:::
java.util.stream.SortedOps.RefSortingSink#end()->void:::
java.util.stream.SortedOps.RefSortingSink#accept(T)->void:::
java.util.stream.SortedOps.AbstractIntSortingSink#cancellationRequested()->boolean:::
java.util.stream.SortedOps.SizedIntSortingSink#begin(long)->void:::
java.util.stream.SortedOps.SizedIntSortingSink#end()->void:::
java.util.stream.SortedOps.SizedIntSortingSink#accept(int)->void:::
java.util.stream.SortedOps.IntSortingSink#begin(long)->void:::
java.util.stream.SortedOps.IntSortingSink#end()->void:::
java.util.stream.SortedOps.IntSortingSink#accept(int)->void:::
java.util.stream.SortedOps.AbstractLongSortingSink#cancellationRequested()->boolean:::
java.util.stream.SortedOps.SizedLongSortingSink#begin(long)->void:::
java.util.stream.SortedOps.SizedLongSortingSink#end()->void:::
java.util.stream.SortedOps.SizedLongSortingSink#accept(long)->void:::
java.util.stream.SortedOps.LongSortingSink#begin(long)->void:::
java.util.stream.SortedOps.LongSortingSink#end()->void:::
java.util.stream.SortedOps.LongSortingSink#accept(long)->void:::
java.util.stream.SortedOps.AbstractDoubleSortingSink#cancellationRequested()->boolean:::
java.util.stream.SortedOps.SizedDoubleSortingSink#begin(long)->void:::
java.util.stream.SortedOps.SizedDoubleSortingSink#end()->void:::
java.util.stream.SortedOps.SizedDoubleSortingSink#accept(double)->void:::
java.util.stream.SortedOps.DoubleSortingSink#begin(long)->void:::
java.util.stream.SortedOps.DoubleSortingSink#end()->void:::
java.util.stream.SortedOps.DoubleSortingSink#accept(double)->void:::
java.util.stream.SpinedBuffer#capacity()->long:::Returns the current capacity of the buffer
java.util.stream.SpinedBuffer#ensureCapacity(long)->void:::Ensure that the buffer has at least capacity to hold the target size
java.util.stream.SpinedBuffer#increaseCapacity()->void:::Force the buffer to increase its capacity.
java.util.stream.SpinedBuffer#get(long)->E:::Retrieve the element at the specified index.
java.util.stream.SpinedBuffer#copyInto(E[], int)->void:::Copy the elements, starting at the specified offset, into the specified  array.
java.util.stream.SpinedBuffer#asArray(IntFunction<E[]>)->E[]:::Create a new array using the specified array factory, and copy the  elements into it.
java.util.stream.SpinedBuffer#clear()->void:::
java.util.stream.SpinedBuffer#iterator()->Iterator<E>:::
java.util.stream.SpinedBuffer#forEach(Consumer<? super E>)->void:::
java.util.stream.SpinedBuffer#accept(E)->void:::
java.util.stream.SpinedBuffer#toString()->String:::
java.util.stream.SpinedBuffer#spliterator()->Spliterator<E>:::Return a {@link Spliterator} describing the contents of the buffer.
java.util.stream.SpinedBuffer.OfPrimitive#iterator()->Iterator<E>:::
java.util.stream.SpinedBuffer.OfPrimitive#forEach(Consumer<? super E>)->void:::
java.util.stream.SpinedBuffer.OfPrimitive#newArrayArray(int)->T_ARR[]:::Create a new array-of-array of the proper type and size
java.util.stream.SpinedBuffer.OfPrimitive#newArray(int)->T_ARR:::Create a new array of the proper type and size
java.util.stream.SpinedBuffer.OfPrimitive#arrayLength(T_ARR)->int:::Get the length of an array
java.util.stream.SpinedBuffer.OfPrimitive#arrayForEach(T_ARR, int, int, T_CONS)->void:::Iterate an array with the provided consumer
java.util.stream.SpinedBuffer.OfPrimitive#capacity()->long:::
java.util.stream.SpinedBuffer.OfPrimitive#ensureCapacity(long)->void:::
java.util.stream.SpinedBuffer.OfPrimitive#increaseCapacity()->void:::
java.util.stream.SpinedBuffer.OfPrimitive#chunkFor(long)->int:::
java.util.stream.SpinedBuffer.OfPrimitive#copyInto(T_ARR, int)->void:::
java.util.stream.SpinedBuffer.OfPrimitive#asPrimitiveArray()->T_ARR:::
java.util.stream.SpinedBuffer.OfPrimitive#preAccept()->void:::
java.util.stream.SpinedBuffer.OfPrimitive#clear()->void:::
java.util.stream.SpinedBuffer.OfPrimitive#forEach(T_CONS)->void:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#newSpliterator(int, int, int, int)->T_SPLITR:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#arrayForOne(T_ARR, int, T_CONS)->void:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#arraySpliterator(T_ARR, int, int)->T_SPLITR:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#estimateSize()->long:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#characteristics()->int:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#tryAdvance(T_CONS)->boolean:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#forEachRemaining(T_CONS)->void:::
java.util.stream.SpinedBuffer.OfPrimitive.BaseSpliterator#trySplit()->T_SPLITR:::
java.util.stream.SpinedBuffer.OfInt#forEach(Consumer<? super Integer>)->void:::
java.util.stream.SpinedBuffer.OfInt#newArrayArray(int)->int[][]:::
java.util.stream.SpinedBuffer.OfInt#newArray(int)->int[]:::
java.util.stream.SpinedBuffer.OfInt#arrayLength(int[])->int:::
java.util.stream.SpinedBuffer.OfInt#arrayForEach(int[], int, int, IntConsumer)->void:::
java.util.stream.SpinedBuffer.OfInt#accept(int)->void:::
java.util.stream.SpinedBuffer.OfInt#get(long)->int:::
java.util.stream.SpinedBuffer.OfInt#iterator()->PrimitiveIterator.OfInt:::
java.util.stream.SpinedBuffer.OfInt#spliterator()->Spliterator.OfInt:::
java.util.stream.SpinedBuffer.OfInt#toString()->String:::
java.util.stream.SpinedBuffer.OfLong#forEach(Consumer<? super Long>)->void:::
java.util.stream.SpinedBuffer.OfLong#newArrayArray(int)->long[][]:::
java.util.stream.SpinedBuffer.OfLong#newArray(int)->long[]:::
java.util.stream.SpinedBuffer.OfLong#arrayLength(long[])->int:::
java.util.stream.SpinedBuffer.OfLong#arrayForEach(long[], int, int, LongConsumer)->void:::
java.util.stream.SpinedBuffer.OfLong#accept(long)->void:::
java.util.stream.SpinedBuffer.OfLong#get(long)->long:::
java.util.stream.SpinedBuffer.OfLong#iterator()->PrimitiveIterator.OfLong:::
java.util.stream.SpinedBuffer.OfLong#spliterator()->Spliterator.OfLong:::
java.util.stream.SpinedBuffer.OfLong#toString()->String:::
java.util.stream.SpinedBuffer.OfDouble#forEach(Consumer<? super Double>)->void:::
java.util.stream.SpinedBuffer.OfDouble#newArrayArray(int)->double[][]:::
java.util.stream.SpinedBuffer.OfDouble#newArray(int)->double[]:::
java.util.stream.SpinedBuffer.OfDouble#arrayLength(double[])->int:::
java.util.stream.SpinedBuffer.OfDouble#arrayForEach(double[], int, int, DoubleConsumer)->void:::
java.util.stream.SpinedBuffer.OfDouble#accept(double)->void:::
java.util.stream.SpinedBuffer.OfDouble#get(long)->double:::
java.util.stream.SpinedBuffer.OfDouble#iterator()->PrimitiveIterator.OfDouble:::
java.util.stream.SpinedBuffer.OfDouble#spliterator()->Spliterator.OfDouble:::
java.util.stream.SpinedBuffer.OfDouble#toString()->String:::
java.util.stream.Stream#filter(Predicate<? super T>)->Stream<T>:::Returns a stream consisting of the elements of this stream that match  the given predicate
java.util.stream.Stream#map(Function<? super T, ? extends R>)->Stream<R>:::Returns a stream consisting of the results of applying the given  function to the elements of this stream
java.util.stream.Stream#mapToInt(ToIntFunction<? super T>)->IntStream:::Returns an {@code IntStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.Stream#mapToLong(ToLongFunction<? super T>)->LongStream:::Returns a {@code LongStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.Stream#mapToDouble(ToDoubleFunction<? super T>)->DoubleStream:::Returns a {@code DoubleStream} consisting of the results of applying the  given function to the elements of this stream
java.util.stream.Stream#flatMap(Function<? super T, ? extends Stream<? extends R>>)->Stream<R>:::Returns a stream consisting of the results of replacing each element of  this stream with the contents of a mapped stream produced by applying  the provided mapping function to each element
java.util.stream.Stream#flatMapToInt(Function<? super T, ? extends IntStream>)->IntStream:::Returns an {@code IntStream} consisting of the results of replacing each  element of this stream with the contents of a mapped stream produced by  applying the provided mapping function to each element
java.util.stream.Stream#flatMapToLong(Function<? super T, ? extends LongStream>)->LongStream:::Returns an {@code LongStream} consisting of the results of replacing each  element of this stream with the contents of a mapped stream produced by  applying the provided mapping function to each element
java.util.stream.Stream#flatMapToDouble(Function<? super T, ? extends DoubleStream>)->DoubleStream:::Returns an {@code DoubleStream} consisting of the results of replacing  each element of this stream with the contents of a mapped stream produced  by applying the provided mapping function to each element
java.util.stream.Stream#distinct()->Stream<T>:::Returns a stream consisting of the distinct elements (according to  {@link Object#equals(Object)}) of this stream
java.util.stream.Stream#sorted()->Stream<T>:::Returns a stream consisting of the elements of this stream, sorted  according to natural order
java.util.stream.Stream#sorted(Comparator<? super T>)->Stream<T>:::Returns a stream consisting of the elements of this stream, sorted  according to the provided {@code Comparator}
java.util.stream.Stream#peek(Consumer<? super T>)->Stream<T>:::Returns a stream consisting of the elements of this stream, additionally  performing the provided action on each element as elements are consumed  from the resulting stream
java.util.stream.Stream#limit(long)->Stream<T>:::Returns a stream consisting of the elements of this stream, truncated  to be no longer than {@code maxSize} in length
java.util.stream.Stream#skip(long)->Stream<T>:::Returns a stream consisting of the remaining elements of this stream  after discarding the first {@code n} elements of the stream
java.util.stream.Stream#takeWhile(Predicate<? super T>)->Stream<T>:::Returns, if this stream is ordered, a stream consisting of the longest  prefix of elements taken from this stream that match the given predicate
java.util.stream.Stream#dropWhile(Predicate<? super T>)->Stream<T>:::Returns, if this stream is ordered, a stream consisting of the remaining  elements of this stream after dropping the longest prefix of elements  that match the given predicate
java.util.stream.Stream#forEach(Consumer<? super T>)->void:::Performs an action for each element of this stream
java.util.stream.Stream#forEachOrdered(Consumer<? super T>)->void:::Performs an action for each element of this stream, in the encounter  order of the stream if the stream has a defined encounter order
java.util.stream.Stream#toArray()->Object[]:::Returns an array containing the elements of this stream
java.util.stream.Stream#toArray(IntFunction<A[]>)->A[]:::Returns an array containing the elements of this stream, using the  provided {@code generator} function to allocate the returned array, as  well as any additional arrays that might be required for a partitioned  execution or for resizing
java.util.stream.Stream#reduce(T, BinaryOperator<T>)->T:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using the provided identity value and an  <a href="package-summary.html#Associativity">associative</a>  accumulation function, and returns the reduced value
java.util.stream.Stream#reduce(BinaryOperator<T>)->Optional<T>:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using an  <a href="package-summary.html#Associativity">associative</a> accumulation  function, and returns an {@code Optional} describing the reduced value,  if any
java.util.stream.Stream#reduce(U, BiFunction<U, ? super T, U>, BinaryOperator<U>)->U:::Performs a <a href="package-summary.html#Reduction">reduction</a> on the  elements of this stream, using the provided identity, accumulation and  combining functions
java.util.stream.Stream#collect(Supplier<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>)->R:::Performs a <a href="package-summary.html#MutableReduction">mutable  reduction</a> operation on the elements of this stream
java.util.stream.Stream#collect(Collector<? super T, A, R>)->R:::Performs a <a href="package-summary.html#MutableReduction">mutable  reduction</a> operation on the elements of this stream using a  {@code Collector}
java.util.stream.Stream#min(Comparator<? super T>)->Optional<T>:::Returns the minimum element of this stream according to the provided  {@code Comparator}
java.util.stream.Stream#max(Comparator<? super T>)->Optional<T>:::Returns the maximum element of this stream according to the provided  {@code Comparator}
java.util.stream.Stream#count()->long:::Returns the count of elements in this stream
java.util.stream.Stream#anyMatch(Predicate<? super T>)->boolean:::Returns whether any elements of this stream match the provided  predicate
java.util.stream.Stream#allMatch(Predicate<? super T>)->boolean:::Returns whether all elements of this stream match the provided predicate
java.util.stream.Stream#noneMatch(Predicate<? super T>)->boolean:::Returns whether no elements of this stream match the provided predicate
java.util.stream.Stream#findFirst()->Optional<T>:::Returns an {@link Optional} describing the first element of this stream,  or an empty {@code Optional} if the stream is empty
java.util.stream.Stream#findAny()->Optional<T>:::Returns an {@link Optional} describing some element of the stream, or an  empty {@code Optional} if the stream is empty
java.util.stream.Stream#builder()->Builder<T>:::Returns a builder for a {@code Stream}.
java.util.stream.Stream#empty()->Stream<T>:::Returns an empty sequential {@code Stream}.
java.util.stream.Stream#of(T)->Stream<T>:::Returns a sequential {@code Stream} containing a single element.
java.util.stream.Stream#ofNullable(T)->Stream<T>:::Returns a sequential {@code Stream} containing a single element, if  non-null, otherwise returns an empty {@code Stream}.
java.util.stream.Stream#of(T...)->Stream<T>:::Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.Stream#iterate(T, UnaryOperator<T>)->Stream<T>:::Returns an infinite sequential ordered {@code Stream} produced by iterative  application of a function {@code f} to an initial element {@code seed},  producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},  {@code f(f(seed))}, etc
java.util.stream.Stream#iterate(T, Predicate<? super T>, UnaryOperator<T>)->Stream<T>:::Returns a sequential ordered {@code Stream} produced by iterative  application of the given {@code next} function to an initial element,  conditioned on satisfying the given {@code hasNext} predicate
java.util.stream.Stream#generate(Supplier<? extends T>)->Stream<T>:::Returns an infinite sequential unordered stream where each element is  generated by the provided {@code Supplier}
java.util.stream.Stream#concat(Stream<? extends T>, Stream<? extends T>)->Stream<T>:::Creates a lazily concatenated stream whose elements are all the  elements of the first stream followed by all the elements of the  second stream
java.util.stream.Stream.Builder#accept(T)->void:::Adds an element to the stream being built.
java.util.stream.Stream.Builder#add(T)->Builder<T>:::Adds an element to the stream being built.
java.util.stream.Stream.Builder#build()->Stream<T>:::Builds the stream, transitioning this builder to the built state
java.util.stream.Streams.RangeIntSpliterator#tryAdvance(IntConsumer)->boolean:::
java.util.stream.Streams.RangeIntSpliterator#forEachRemaining(IntConsumer)->void:::
java.util.stream.Streams.RangeIntSpliterator#estimateSize()->long:::
java.util.stream.Streams.RangeIntSpliterator#characteristics()->int:::
java.util.stream.Streams.RangeIntSpliterator#super Integer> getComparator()->Comparator<?:::
java.util.stream.Streams.RangeIntSpliterator#trySplit()->Spliterator.OfInt:::
java.util.stream.Streams.RangeLongSpliterator#tryAdvance(LongConsumer)->boolean:::
java.util.stream.Streams.RangeLongSpliterator#forEachRemaining(LongConsumer)->void:::
java.util.stream.Streams.RangeLongSpliterator#estimateSize()->long:::
java.util.stream.Streams.RangeLongSpliterator#characteristics()->int:::
java.util.stream.Streams.RangeLongSpliterator#super Long> getComparator()->Comparator<?:::
java.util.stream.Streams.RangeLongSpliterator#trySplit()->Spliterator.OfLong:::
java.util.stream.Streams.AbstractStreamBuilderImpl#trySplit()->S:::
java.util.stream.Streams.AbstractStreamBuilderImpl#estimateSize()->long:::
java.util.stream.Streams.AbstractStreamBuilderImpl#characteristics()->int:::
java.util.stream.Streams.StreamBuilderImpl#accept(T)->void:::
java.util.stream.Streams.StreamBuilderImpl#add(T)->Stream.Builder<T>:::
java.util.stream.Streams.StreamBuilderImpl#build()->Stream<T>:::
java.util.stream.Streams.StreamBuilderImpl#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.Streams.StreamBuilderImpl#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.Streams.IntStreamBuilderImpl#accept(int)->void:::
java.util.stream.Streams.IntStreamBuilderImpl#build()->IntStream:::
java.util.stream.Streams.IntStreamBuilderImpl#tryAdvance(IntConsumer)->boolean:::
java.util.stream.Streams.IntStreamBuilderImpl#forEachRemaining(IntConsumer)->void:::
java.util.stream.Streams.LongStreamBuilderImpl#accept(long)->void:::
java.util.stream.Streams.LongStreamBuilderImpl#build()->LongStream:::
java.util.stream.Streams.LongStreamBuilderImpl#tryAdvance(LongConsumer)->boolean:::
java.util.stream.Streams.LongStreamBuilderImpl#forEachRemaining(LongConsumer)->void:::
java.util.stream.Streams.DoubleStreamBuilderImpl#accept(double)->void:::
java.util.stream.Streams.DoubleStreamBuilderImpl#build()->DoubleStream:::
java.util.stream.Streams.DoubleStreamBuilderImpl#tryAdvance(DoubleConsumer)->boolean:::
java.util.stream.Streams.DoubleStreamBuilderImpl#forEachRemaining(DoubleConsumer)->void:::
java.util.stream.Streams.ConcatSpliterator#trySplit()->T_SPLITR:::
java.util.stream.Streams.ConcatSpliterator#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.Streams.ConcatSpliterator#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.Streams.ConcatSpliterator#estimateSize()->long:::
java.util.stream.Streams.ConcatSpliterator#characteristics()->int:::
java.util.stream.Streams.ConcatSpliterator#super T> getComparator()->Comparator<?:::
java.util.stream.Streams.ConcatSpliterator.OfPrimitive#tryAdvance(T_CONS)->boolean:::
java.util.stream.Streams.ConcatSpliterator.OfPrimitive#forEachRemaining(T_CONS)->void:::
java.util.stream.Streams#composeWithExceptions(Runnable, Runnable)->Runnable:::Given two Runnables, return a Runnable that executes both in sequence,  even if the first throws an exception, and if both throw exceptions, add  any exceptions thrown by the second as suppressed exceptions of the first.
java.util.stream.Streams#composedClose(BaseStream<?, ?>, BaseStream<?, ?>)->Runnable:::Given two streams, return a Runnable that  executes both of their {@link BaseStream#close} methods in sequence,  even if the first throws an exception, and if both throw exceptions, add  any exceptions thrown by the second as suppressed exceptions of the first.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#init()->void:::Called before advancing to set up spliterator, if needed.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#doAdvance()->boolean:::Get an element from the source, pushing it into the sink chain,  setting up the buffer if needed
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#P_OUT, ?> wrap(Spliterator<P_IN>)->AbstractWrappingSpliterator<P_IN,:::Invokes the shape-specific constructor with the provided arguments  and returns the result.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#initPartialTraversalState()->void:::Initializes buffer, sink chain, and pusher for a shape-specific  implementation.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#trySplit()->Spliterator<P_OUT>:::
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#getExactSizeIfKnown()->long:::
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#super P_OUT> getComparator()->Comparator<?:::
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator#toString()->String:::
java.util.stream.StreamSpliterators.WrappingSpliterator#P_OUT> wrap(Spliterator<P_IN>)->WrappingSpliterator<P_IN,:::
java.util.stream.StreamSpliterators.WrappingSpliterator#initPartialTraversalState()->void:::
java.util.stream.StreamSpliterators.WrappingSpliterator#tryAdvance(Consumer<? super P_OUT>)->boolean:::
java.util.stream.StreamSpliterators.WrappingSpliterator#forEachRemaining(Consumer<? super P_OUT>)->void:::
java.util.stream.StreamSpliterators.IntWrappingSpliterator#Integer, ?> wrap(Spliterator<P_IN>)->AbstractWrappingSpliterator<P_IN,:::
java.util.stream.StreamSpliterators.IntWrappingSpliterator#initPartialTraversalState()->void:::
java.util.stream.StreamSpliterators.IntWrappingSpliterator#trySplit()->Spliterator.OfInt:::
java.util.stream.StreamSpliterators.IntWrappingSpliterator#tryAdvance(IntConsumer)->boolean:::
java.util.stream.StreamSpliterators.IntWrappingSpliterator#forEachRemaining(IntConsumer)->void:::
java.util.stream.StreamSpliterators.LongWrappingSpliterator#Long, ?> wrap(Spliterator<P_IN>)->AbstractWrappingSpliterator<P_IN,:::
java.util.stream.StreamSpliterators.LongWrappingSpliterator#initPartialTraversalState()->void:::
java.util.stream.StreamSpliterators.LongWrappingSpliterator#trySplit()->Spliterator.OfLong:::
java.util.stream.StreamSpliterators.LongWrappingSpliterator#tryAdvance(LongConsumer)->boolean:::
java.util.stream.StreamSpliterators.LongWrappingSpliterator#forEachRemaining(LongConsumer)->void:::
java.util.stream.StreamSpliterators.DoubleWrappingSpliterator#Double, ?> wrap(Spliterator<P_IN>)->AbstractWrappingSpliterator<P_IN,:::
java.util.stream.StreamSpliterators.DoubleWrappingSpliterator#initPartialTraversalState()->void:::
java.util.stream.StreamSpliterators.DoubleWrappingSpliterator#trySplit()->Spliterator.OfDouble:::
java.util.stream.StreamSpliterators.DoubleWrappingSpliterator#tryAdvance(DoubleConsumer)->boolean:::
java.util.stream.StreamSpliterators.DoubleWrappingSpliterator#forEachRemaining(DoubleConsumer)->void:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#get()->T_SPLITR:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#trySplit()->T_SPLITR:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#super T> getComparator()->Comparator<?:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#getExactSizeIfKnown()->long:::
java.util.stream.StreamSpliterators.DelegatingSpliterator#toString()->String:::
java.util.stream.StreamSpliterators.DelegatingSpliterator.OfPrimitive#tryAdvance(T_CONS)->boolean:::
java.util.stream.StreamSpliterators.DelegatingSpliterator.OfPrimitive#forEachRemaining(T_CONS)->void:::
java.util.stream.StreamSpliterators.SliceSpliterator#makeSpliterator(T_SPLITR, long, long, long, long)->T_SPLITR:::
java.util.stream.StreamSpliterators.SliceSpliterator#trySplit()->T_SPLITR:::
java.util.stream.StreamSpliterators.SliceSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.SliceSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfRef#makeSpliterator(Spliterator<T>, long, long, long, long)->Spliterator<T>:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfRef#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfRef#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfPrimitive#tryAdvance(T_CONS)->boolean:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfPrimitive#forEachRemaining(T_CONS)->void:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfPrimitive#emptyConsumer()->T_CONS:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfInt#makeSpliterator(Spliterator.OfInt, long, long, long, long)->Spliterator.OfInt:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfInt#emptyConsumer()->IntConsumer:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfLong#makeSpliterator(Spliterator.OfLong, long, long, long, long)->Spliterator.OfLong:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfLong#emptyConsumer()->LongConsumer:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfDouble#makeSpliterator(Spliterator.OfDouble, long, long, long, long)->Spliterator.OfDouble:::
java.util.stream.StreamSpliterators.SliceSpliterator.OfDouble#emptyConsumer()->DoubleConsumer:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#acquirePermits(long)->long:::Acquire permission to skip or process elements
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#permitStatus()->PermitStatus:::Call to check if permits might be available before acquiring data
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#trySplit()->T_SPLITR:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#makeSpliterator(T_SPLITR)->T_SPLITR:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfRef#accept(T)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfRef#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfRef#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfRef#makeSpliterator(Spliterator<T>)->Spliterator<T>:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfPrimitive#tryAdvance(T_CONS)->boolean:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfPrimitive#acceptConsumed(T_CONS)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfPrimitive#forEachRemaining(T_CONS)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfPrimitive#bufferCreate(int)->T_BUFF:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfInt#accept(int)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfInt#acceptConsumed(IntConsumer)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfInt#bufferCreate(int)->ArrayBuffer.OfInt:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfInt#makeSpliterator(Spliterator.OfInt)->Spliterator.OfInt:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfLong#accept(long)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfLong#acceptConsumed(LongConsumer)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfLong#bufferCreate(int)->ArrayBuffer.OfLong:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfLong#makeSpliterator(Spliterator.OfLong)->Spliterator.OfLong:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfDouble#accept(double)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfDouble#acceptConsumed(DoubleConsumer)->void:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfDouble#bufferCreate(int)->ArrayBuffer.OfDouble:::
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfDouble#makeSpliterator(Spliterator.OfDouble)->Spliterator.OfDouble:::
java.util.stream.StreamSpliterators.DistinctSpliterator#accept(T)->void:::
java.util.stream.StreamSpliterators.DistinctSpliterator#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.StreamSpliterators.DistinctSpliterator#forEachRemaining(Consumer<? super T>)->void:::
java.util.stream.StreamSpliterators.DistinctSpliterator#trySplit()->Spliterator<T>:::
java.util.stream.StreamSpliterators.DistinctSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.DistinctSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.DistinctSpliterator#super T> getComparator()->Comparator<?:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator#estimateSize()->long:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator#characteristics()->int:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfRef#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfRef#trySplit()->Spliterator<T>:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfInt#tryAdvance(IntConsumer)->boolean:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfInt#trySplit()->Spliterator.OfInt:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfLong#tryAdvance(LongConsumer)->boolean:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfLong#trySplit()->Spliterator.OfLong:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfDouble#tryAdvance(DoubleConsumer)->boolean:::
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator.OfDouble#trySplit()->Spliterator.OfDouble:::
java.util.stream.StreamSpliterators.ArrayBuffer#reset()->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfRef#accept(T)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfRef#forEach(Consumer<? super T>, long)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfPrimitive#reset()->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfPrimitive#forEach(T_CONS, long)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfInt#accept(int)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfInt#forEach(IntConsumer, long)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfLong#accept(long)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfLong#forEach(LongConsumer, long)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfDouble#accept(double)->void:::
java.util.stream.StreamSpliterators.ArrayBuffer.OfDouble#forEach(DoubleConsumer, long)->void:::
java.util.stream.StreamSupport#stream(Spliterator<T>, boolean)->Stream<T>:::Creates a new sequential or parallel {@code Stream} from a  {@code Spliterator}
java.util.stream.StreamSupport#stream(Supplier<? extends Spliterator<T>>, int, boolean)->Stream<T>:::Creates a new sequential or parallel {@code Stream} from a  {@code Supplier} of {@code Spliterator}
java.util.stream.StreamSupport#intStream(Spliterator.OfInt, boolean)->IntStream:::Creates a new sequential or parallel {@code IntStream} from a  {@code Spliterator.OfInt}
java.util.stream.StreamSupport#intStream(Supplier<? extends Spliterator.OfInt>, int, boolean)->IntStream:::Creates a new sequential or parallel {@code IntStream} from a  {@code Supplier} of {@code Spliterator.OfInt}
java.util.stream.StreamSupport#longStream(Spliterator.OfLong, boolean)->LongStream:::Creates a new sequential or parallel {@code LongStream} from a  {@code Spliterator.OfLong}
java.util.stream.StreamSupport#longStream(Supplier<? extends Spliterator.OfLong>, int, boolean)->LongStream:::Creates a new sequential or parallel {@code LongStream} from a  {@code Supplier} of {@code Spliterator.OfLong}
java.util.stream.StreamSupport#doubleStream(Spliterator.OfDouble, boolean)->DoubleStream:::Creates a new sequential or parallel {@code DoubleStream} from a  {@code Spliterator.OfDouble}
java.util.stream.StreamSupport#doubleStream(Supplier<? extends Spliterator.OfDouble>, int, boolean)->DoubleStream:::Creates a new sequential or parallel {@code DoubleStream} from a  {@code Supplier} of {@code Spliterator.OfDouble}
java.util.stream.TerminalOp#inputShape()->StreamShape:::Gets the shape of the input type of this operation.
java.util.stream.TerminalOp#getOpFlags()->int:::Gets the stream flags of the operation
java.util.stream.TerminalOp#evaluateParallel(PipelineHelper<E_IN>, Spliterator<P_IN>)->R:::Performs a parallel evaluation of the operation using the specified  {@code PipelineHelper}, which describes the upstream intermediate  operations.
java.util.stream.TerminalOp#evaluateSequential(PipelineHelper<E_IN>, Spliterator<P_IN>)->R:::Performs a sequential evaluation of the operation using the specified  {@code PipelineHelper}, which describes the upstream intermediate  operations.
java.util.stream.Tripwire#trip(Class<?>, String)->void:::Produces a log warning, using {@code PlatformLogger.getLogger(className)},  using the supplied message
java.util.stream.WhileOps#makeTakeWhileRef(AbstractPipeline<?, T, ?>, Predicate<? super T>)->Stream<T>:::Appends a "takeWhile" operation to the provided Stream.
java.util.stream.WhileOps#makeTakeWhileInt(AbstractPipeline<?, Integer, ?>, IntPredicate)->IntStream:::Appends a "takeWhile" operation to the provided IntStream.
java.util.stream.WhileOps#makeTakeWhileLong(AbstractPipeline<?, Long, ?>, LongPredicate)->LongStream:::Appends a "takeWhile" operation to the provided LongStream.
java.util.stream.WhileOps#makeTakeWhileDouble(AbstractPipeline<?, Double, ?>, DoublePredicate)->DoubleStream:::Appends a "takeWhile" operation to the provided DoubleStream.
java.util.stream.WhileOps.DropWhileOp#opWrapSink(Sink<T>, boolean)->DropWhileSink<T>:::Accepts a {@code Sink} which will receive the results of this  dropWhile operation, and return a {@code DropWhileSink} which  accepts  elements and which performs the dropWhile operation passing the  results to the provided {@code Sink}.
java.util.stream.WhileOps.DropWhileSink#getDropCount()->long:::
java.util.stream.WhileOps#makeDropWhileRef(AbstractPipeline<?, T, ?>, Predicate<? super T>)->Stream<T>:::Appends a "dropWhile" operation to the provided Stream.
java.util.stream.WhileOps#makeDropWhileInt(AbstractPipeline<?, Integer, ?>, IntPredicate)->IntStream:::Appends a "dropWhile" operation to the provided IntStream.
java.util.stream.WhileOps#makeDropWhileLong(AbstractPipeline<?, Long, ?>, LongPredicate)->LongStream:::Appends a "dropWhile" operation to the provided LongStream.
java.util.stream.WhileOps#makeDropWhileDouble(AbstractPipeline<?, Double, ?>, DoublePredicate)->DoubleStream:::Appends a "dropWhile" operation to the provided DoubleStream.
java.util.stream.WhileOps.UnorderedWhileSpliterator#estimateSize()->long:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#characteristics()->int:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#getExactSizeIfKnown()->long:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#super T> getComparator()->Comparator<?:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#trySplit()->T_SPLITR:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#checkCancelOnCount()->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator#makeSpliterator(T_SPLITR)->T_SPLITR:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef#accept(T)->void:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef.Taking#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef.Taking#trySplit()->Spliterator<T>:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef.Taking#makeSpliterator(Spliterator<T>)->Spliterator<T>:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef.Dropping#tryAdvance(Consumer<? super T>)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfRef.Dropping#makeSpliterator(Spliterator<T>)->Spliterator<T>:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt#accept(int)->void:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt.Taking#tryAdvance(IntConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt.Taking#trySplit()->Spliterator.OfInt:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt.Taking#makeSpliterator(Spliterator.OfInt)->Spliterator.OfInt:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt.Dropping#tryAdvance(IntConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfInt.Dropping#makeSpliterator(Spliterator.OfInt)->Spliterator.OfInt:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong#accept(long)->void:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong.Taking#tryAdvance(LongConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong.Taking#trySplit()->Spliterator.OfLong:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong.Taking#makeSpliterator(Spliterator.OfLong)->Spliterator.OfLong:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong.Dropping#tryAdvance(LongConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfLong.Dropping#makeSpliterator(Spliterator.OfLong)->Spliterator.OfLong:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble#accept(double)->void:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble.Taking#tryAdvance(DoubleConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble.Taking#trySplit()->Spliterator.OfDouble:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble.Taking#makeSpliterator(Spliterator.OfDouble)->Spliterator.OfDouble:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble.Dropping#tryAdvance(DoubleConsumer)->boolean:::
java.util.stream.WhileOps.UnorderedWhileSpliterator.OfDouble.Dropping#makeSpliterator(Spliterator.OfDouble)->Spliterator.OfDouble:::
java.util.stream.WhileOps.TakeWhileTask#P_OUT> makeChild(Spliterator<P_IN>)->TakeWhileTask<P_IN,:::
java.util.stream.WhileOps.TakeWhileTask#getEmptyResult()->Node<P_OUT>:::
java.util.stream.WhileOps.TakeWhileTask#doLeaf()->Node<P_OUT>:::
java.util.stream.WhileOps.TakeWhileTask#onCompletion(CountedCompleter<?>)->void:::
java.util.stream.WhileOps.TakeWhileTask#merge()->Node<P_OUT>:::
java.util.stream.WhileOps.TakeWhileTask#cancel()->void:::
java.util.stream.WhileOps.DropWhileTask#P_OUT> makeChild(Spliterator<P_IN>)->DropWhileTask<P_IN,:::
java.util.stream.WhileOps.DropWhileTask#doLeaf()->Node<P_OUT>:::
java.util.stream.WhileOps.DropWhileTask#onCompletion(CountedCompleter<?>)->void:::
