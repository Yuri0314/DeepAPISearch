AbstractBasicFileAttributeView.AttributesBuilder#create(Set, String[]):::Creates builder to build up a map of the matching attributes:::return->new->AttributesBuilder
AbstractBasicFileAttributeView.AttributesBuilder#match(String):::Returns true if the attribute should be returned in the map:::return->names->contains
AbstractBasicFileAttributeView.AttributesBuilder#unmodifiableMap():::Returns the map:::return->Collections->unmodifiableMap
AbstractBasicFileAttributeView#addRequestedBasicAttributes(BasicFileAttributes, AttributesBuilder):::Invoked by readAttributes or sub-classes to add all matching basic attributes to the builder:::if->builder->match->builder->attrs->size->add->if->builder->match->builder->attrs->creationTime->add->if->builder->match->builder->attrs->lastAccessTime->add->if->builder->match->builder->attrs->lastModifiedTime->add->if->builder->match->builder->attrs->fileKey->add->if->builder->match->builder->attrs->isDirectory->add->if->builder->match->builder->attrs->isRegularFile->add->if->builder->match->builder->attrs->isSymbolicLink->add->if->builder->match->builder->attrs->isOther->add
AbstractFileSystemProvider#getFileAttributeView(Path, String, LinkOption...):::Gets a DynamicFileAttributeView by name:::
AbstractFileSystemProvider#implDelete(Path, boolean):::Deletes a file:::
AbstractFileSystemProvider#isDirectory(Path):::Tests whether a file is a directory.:::try->return->readAttributes->isDirectory->catch->return->finally
AbstractFileSystemProvider#isRegularFile(Path):::Tests whether a file is a regular file with opaque content.:::try->return->readAttributes->isRegularFile->catch->return->finally
AbstractFileSystemProvider#exists(Path):::Checks the existence of a file.:::try->checkAccess->return->catch->return->finally
AbstractFileTypeDetector#getExtension(String):::Returns the extension of a file name, specifically the portion of the parameter string after the first dot:::ext->if->name->isEmpty->dot->name->indexOf->if->name->length->name->substring->return
AbstractFileTypeDetector#probeContentType(Path):::Invokes the appropriate probe method to guess a file's content type, and checks that the content type's syntax is valid.:::if->throw->new->NullPointerException->result->implProbeContentType->if->fileName->file->getFileName->if->fileNameMap->URLConnection->getFileNameMap->fileNameMap->fileName->toString->getContentTypeFor->return->parse
AbstractFileTypeDetector#implProbeContentType(Path):::Probes the given file to guess its content type.:::
AbstractPoller#start():::Starts the poller thread:::thisRunnable->AccessController->new->PrivilegedAction<>->doPrivileged
AbstractPoller#wakeup():::Wakeup poller thread so that it can service pending requests:::
AbstractPoller#implRegister(Path, Set>, WatchEvent.Modifier...):::Executed by poller thread to register directory for changes:::
AbstractPoller#implCancelKey(WatchKey):::Executed by poller thread to cancel key:::
AbstractPoller#implCloseAll():::Executed by poller thread to shutdown and cancel all keys:::
AbstractPoller#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Requests, and waits on, poller thread to register given file.:::if->throw->new->NullPointerException->eventSet->new->HashSet<>->foreach->if->eventSet->add->continue->if->continue->if->throw->new->NullPointerException->throw->event->name->new->UnsupportedOperationException->if->eventSet->isEmpty->throw->new->IllegalArgumentException->return->invoke
AbstractPoller#cancel(WatchKey):::Cancels, and waits on, poller thread to cancel given key.:::try->invoke->catch->throw->x->getMessage->new->AssertionError->finally
AbstractPoller#close():::Shutdown poller thread:::invoke
AbstractPoller#processRequests():::Invoked by poller thread to process all pending requests:::synchronized->req->while->requestList->poll->if->req->new->ClosedWatchServiceException->release->continue->switch->req->type->params->req->parameters->path->events->modifiers->req->implRegister->release->break->params->req->parameters->key->implCancelKey->req->release->break->implCloseAll->req->release->break->req->new->IOException->release->return
AbstractWatchKey#watchable():::Return the original watchable (Path):::return
AbstractWatchKey#signal():::Enqueues this key to the watch service:::synchronized->if->watcher->enqueueKey
AbstractWatchKey#signalEvent(WatchEvent.Kind, Object):::Adds the event to this key and signals it.:::isModify->synchronized->size->events->size->if->prev->events->get->if->prev->kind->prev->kind->Objects->prev->context->equals->increment->return->if->lastModifyEvents->isEmpty->if->ev->lastModifyEvents->get->if->increment->return->else->lastModifyEvents->remove->if->ev->new->Event<>->if->lastModifyEvents->put->else->if->events->clear->lastModifyEvents->clear->events->add->signal
AbstractWatchService#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Register the given object with this watch service:::
AbstractWatchService#isOpen():::Tells whether or not this watch service is open.:::return
AbstractWatchService#closeLock():::Retrieves the object upon which the close method synchronizes.:::return
AbstractWatchService#implClose():::Closes this watch service:::
BasicFileAttributesHolder#get():::Returns cached attributes (may be null):::
BasicFileAttributesHolder#invalidate():::Invalidates cached attributes:::
Cancellable#addressToPollForCancel():::Returns the memory address of a 4-byte int that should be polled to detect cancellation.:::return
Cancellable#cancelValue():::The value to write to the polled memory location to indicate that the task has been cancelled:::return
Cancellable#cancel():::"cancels" the task by writing bits into memory location that it polled by the task.:::synchronized->if->unsafe->cancelValue->putIntVolatile
Cancellable#implRun():::The task body:::
Cancellable#runInterruptibly(Cancellable):::Invokes the given task in its own thread:::t->new->Thread->t->start->cancelledByInterrupt->while->t->isAlive->try->t->join->catch->task->cancel->finally->if->Thread->currentThread->interrupt->exc->task->exception->if->throw->new->ExecutionException
DefaultFileSystemProvider#instance():::Returns the platform's default file system provider.:::return
DefaultFileSystemProvider#theFileSystem():::Returns the platform's default file system.:::return->INSTANCE->theFileSystem
DynamicFileAttributeView#setAttribute(String, Object):::Sets/updates the value of an attribute.:::
DynamicFileAttributeView#readAttributes(String[]):::Reads a set of file attributes as a bulk operation.:::
ExtendedOptions.InternalOption#register(OpenOption):::Register this internal option as a OpenOption.:::registerInternal
ExtendedOptions.InternalOption#register(CopyOption):::Register this internal option as a CopyOption.:::registerInternal
ExtendedOptions.InternalOption#register(WatchEvent.Modifier):::Register this internal option as a WatchEvent.Modifier.:::registerInternal
ExtendedOptions.InternalOption#register(WatchEvent.Modifier, T):::Register this internal option as a WatchEvent.Modifier with the given parameter.:::registerInternal
ExtendedOptions.InternalOption#matches(Object):::Returns true if the given option (or modifier) maps to this internal option.:::wrapper->internalToExternal->get->if->return->else->return
ExtendedOptions.InternalOption#parameter():::Returns the parameter object associated with this internal option.:::wrapper->internalToExternal->get->if->return->else->return->wrapper->parameter
NativeBuffers#allocNativeBuffer(int):::Allocates a native buffer, of at least the given size, from the heap.:::if->return->new->NativeBuffer
NativeBuffers#getNativeBufferFromCache(int):::Returns a native buffer, of at least the given size, from the thread local cache.:::buffers->threadLocal->get->if->for->i->return
NativeBuffers#getNativeBuffer(int):::Returns a native buffer, of at least the given size:::buffer->getNativeBufferFromCache->if->buffer->setOwner->return->else->return->allocNativeBuffer
NativeBuffers#releaseNativeBuffer(NativeBuffer):::Releases the given buffer:::buffers->threadLocal->get->if->new->NativeBufferArr->threadLocal->set->return->for->i->for->i->buffer->free
NativeBuffers#copyCStringToNativeBuffer(byte[], NativeBuffer):::Copies a byte array and zero terminator into a given native buffer.:::offset->len->unsafe->buffer->address->copyMemory->unsafe->buffer->address->putByte
NativeBuffers#asNativeBuffer(byte[]):::Copies a byte array and zero terminator into a native buffer, returning the buffer.:::buffer->getNativeBuffer->copyCStringToNativeBuffer->return
PollingWatchService#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Register the given file with this watch service:::eventSet->new->HashSet<>->foreach->if->eventSet->add->continue->if->continue->if->throw->new->NullPointerException->throw->event->name->new->UnsupportedOperationException->if->eventSet->isEmpty->throw->new->IllegalArgumentException->sensitivity->if->foreach->if->throw->new->NullPointerException->if->matches->parameter->else->if->matches->parameter->else->if->matches->parameter->else->throw->new->UnsupportedOperationException->if->isOpen->throw->new->ClosedWatchServiceException->try->value->return->AccessController->new->PrivilegedExceptionAction<PollingWatchKey>->doPrivileged->catch->cause->pae->getCause->if->throw->throw->new->AssertionError->finally
Reflect#lookupField(String, String):::Lookup the field of a given class.:::try->cl->Class->forName->f->cl->getDeclaredField->setAccessible->return->catch->throw->new->AssertionError->throw->new->AssertionError->finally
Util#jnuEncoding():::Returns Charset corresponding to the sun.jnu.encoding property:::return
Util#toBytes(String):::Encodes the given String into a sequence of bytes using the Charset specified by the sun.jnu.encoding property.:::return->s->getBytes
Util#toString(byte[]):::Constructs a new String by decoding the specified array of bytes using the Charset specified by the sun.jnu.encoding property.:::return->new->String
Util#split(String, char):::Splits a string around the given character:::count->for->i->s->length->result->new->StringArr->n->last->for->i->s->length->s->s->length->substring->return
Util#newSet(E...):::Returns a Set containing the given elements.:::set->new->HashSet<>->foreach->set->add->return
Util#newSet(Set, E...):::Returns a Set containing all the elements of the given Set plus the given elements.:::set->new->HashSet<>->foreach->set->add->return
Util#followLinks(LinkOption...):::Returns true if symbolic links should be followed:::followLinks->foreach->if->else->if->throw->new->NullPointerException->else->throw->new->AssertionError->return
WindowsChannelFactory#newFileChannel(String, String, Set, long):::Open/creates file, returning FileChannel to access the file:::flags->Flags->toFlags->if->if->else->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->fdObj->open->return->FileChannelImpl->open
WindowsChannelFactory#newAsynchronousFileChannel(String, String, Set, long, ThreadPool):::Open/creates file, returning AsynchronousFileChannel to access the file:::flags->Flags->toFlags->if->if->throw->new->UnsupportedOperationException->fdObj->try->open->catch->x->rethrowAsIOException->return->finally->try->return->WindowsAsynchronousFileChannelImpl->open->catch->fdAccess->close->throw->finally
WindowsFileAttributes#toFileTime(long):::Convert 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 to a FileTime.:::return->FileTime->from
WindowsFileAttributes#toWindowsTime(FileTime):::Convert FileTime to 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.:::value->time->to->return
WindowsFileAttributes#getBufferForFindData():::Allocates a native buffer for a WIN32_FIND_DATA structure:::return->NativeBuffers->getNativeBuffer
WindowsFileAttributes#fromFindData(long):::Create a WindowsFileAttributes from a WIN32_FIND_DATA structure:::fileAttrs->unsafe->getInt->creationTime->unsafe->getLong->lastAccessTime->unsafe->getLong->lastWriteTime->unsafe->getLong->size->unsafe->getInt->unsafe->getInt->reparseTag->isReparsePoint->unsafe->getInt->return->new->WindowsFileAttributes
WindowsFileAttributes#readAttributes(long):::Reads the attributes of an open file:::buffer->NativeBuffers->getNativeBuffer->try->address->buffer->address->GetFileInformationByHandle->reparseTag->fileAttrs->unsafe->getInt->if->isReparsePoint->size->reparseBuffer->NativeBuffers->getNativeBuffer->try->reparseBuffer->address->DeviceIoControlGetReparsePoint->unsafe->reparseBuffer->address->getLong->catch->finally->reparseBuffer->release->return->fromFileInformation->catch->finally->buffer->release
WindowsFileAttributes#get(WindowsPath, boolean):::Returns attributes of given file.:::if->firstException->buffer->NativeBuffers->getNativeBuffer->try->address->buffer->address->path->getPathForWin32Calls->GetFileAttributesEx->fileAttrs->unsafe->getInt->if->isReparsePoint->return->fromFileAttributeData->catch->if->x->lastError->throw->finally->buffer->release->if->search->path->getPathForWin32Calls->last->search->search->length->charAt->if->throw->getBufferForFindData->try->handle->buffer->address->FindFirstFile->FindClose->attrs->buffer->address->fromFindData->if->attrs->isReparsePoint->throw->return->catch->throw->finally->buffer->release->handle->path->openForReadAttributeAccess->try->return->readAttributes->catch->finally->CloseHandle
WindowsFileAttributes#isSameFile(WindowsFileAttributes, WindowsFileAttributes):::Returns true if the attributes are of the same file - both files must be open.:::return
WindowsFileAttributes#isReparsePoint(int):::Returns true if the attributes are of a file with a reparse point.:::return
WindowsFileCopy#copy(WindowsPath, WindowsPath, CopyOption...):::Copy file from source to target:::replaceExisting->copyAttributes->followLinks->interruptible->foreach->if->continue->if->continue->if->continue->if->matches->continue->if->throw->new->NullPointerException->throw->new->UnsupportedOperationException->sm->System->getSecurityManager->if->source->checkRead->target->checkWrite->sourceAttrs->targetAttrs->sourceHandle->try->source->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->targetHandle->try->target->openForReadAttributeAccess->try->WindowsFileAttributes->readAttributes->if->WindowsFileAttributes->isSameFile->return->if->throw->target->getPathForExceptionMessage->new->FileAlreadyExistsException->catch->finally->CloseHandle->catch->finally->catch->finally->CloseHandle->if->sourceAttrs->isSymbolicLink->sm->new->LinkPermission->checkPermission->sourcePath->asWin32Path->targetPath->asWin32Path->if->try->if->targetAttrs->isDirectory->targetAttrs->isDirectoryLink->RemoveDirectory->else->DeleteFile->catch->if->targetAttrs->isDirectory->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally->if->sourceAttrs->isDirectory->sourceAttrs->isDirectoryLink->flags->if->copyTask->new->Cancellable->try->Cancellable->runInterruptibly->catch->t->e->getCause->if->throw->throw->new->IOException->finally->else->try->CopyFileEx->catch->x->rethrowAsIOException->finally->if->try->copySecurityAttributes->catch->finally->return->try->if->sourceAttrs->isDirectory->CreateDirectory->else->linkTarget->WindowsLinkSupport->readLink->flags->WindowsPath->addPrefixIfNeeded->CreateSymbolicLink->catch->x->rethrowAsIOException->finally->if->view->WindowsFileAttributeViews->createDosView->try->view->setAttributes->catch->if->sourceAttrs->isDirectory->try->RemoveDirectory->catch->finally->finally->try->copySecurityAttributes->catch->finally
WindowsFileCopy#move(WindowsPath, WindowsPath, CopyOption...):::Move file from source to target:::atomicMove->replaceExisting->foreach->if->continue->if->continue->if->continue->if->throw->new->NullPointerException->throw->new->UnsupportedOperationException->sm->System->getSecurityManager->if->source->checkWrite->target->checkWrite->sourcePath->asWin32Path->targetPath->asWin32Path->if->try->MoveFileEx->catch->if->x->lastError->throw->source->getPathForExceptionMessage->target->getPathForExceptionMessage->x->errorString->new->AtomicMoveNotSupportedException->x->rethrowAsIOException->finally->return->sourceAttrs->targetAttrs->sourceHandle->try->source->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->targetHandle->try->target->openForReadAttributeAccess->try->WindowsFileAttributes->readAttributes->if->WindowsFileAttributes->isSameFile->return->if->throw->target->getPathForExceptionMessage->new->FileAlreadyExistsException->catch->finally->CloseHandle->catch->finally->catch->finally->CloseHandle->if->try->if->targetAttrs->isDirectory->targetAttrs->isDirectoryLink->RemoveDirectory->else->DeleteFile->catch->if->targetAttrs->isDirectory->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally->try->MoveFileEx->return->catch->if->x->lastError->x->rethrowAsIOException->finally->if->sourceAttrs->isDirectory->sourceAttrs->isDirectoryLink->try->MoveFileEx->catch->x->rethrowAsIOException->finally->try->copySecurityAttributes->catch->finally->return->try->if->sourceAttrs->isDirectory->ensureEmptyDir->CreateDirectory->else->linkTarget->WindowsLinkSupport->readLink->WindowsPath->addPrefixIfNeeded->CreateSymbolicLink->catch->x->rethrowAsIOException->finally->view->WindowsFileAttributeViews->createDosView->try->view->setAttributes->catch->try->RemoveDirectory->catch->finally->throw->finally->try->copySecurityAttributes->catch->finally->try->RemoveDirectory->catch->try->RemoveDirectory->catch->finally->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally
WindowsLinkSupport#readLink(WindowsPath):::Returns the target of a symbolic link:::handle->try->path->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->return->readLinkImpl->catch->finally->CloseHandle
WindowsLinkSupport#getFinalPath(WindowsPath):::Returns the final path (all symbolic links resolved) or null if this operation is not supported.:::h->try->input->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->return->GetFinalPathNameByHandle->stripPrefix->catch->if->x->lastError->x->rethrowAsIOException->finally->CloseHandle->return
WindowsLinkSupport#getFinalPath(WindowsPath, boolean):::Returns the final path of a given path as a String:::fs->input->getFileSystem->try->if->return->input->getPathForWin32Calls->if->WindowsFileAttributes->get->isSymbolicLink->return->input->getPathForWin32Calls->catch->x->rethrowAsIOException->finally->result->getFinalPath->if->return->target->linkCount->do->try->attrs->WindowsFileAttributes->get->if->attrs->isSymbolicLink->return->target->getPathForWin32Calls->catch->x->rethrowAsIOException->finally->link->WindowsPath->readLink->createFromNormalizedPath->parent->target->getParent->if->t->AccessController->new->PrivilegedAction<WindowsPath>->doPrivileged->target->getParent->parent->resolve->while->throw->input->getPathForExceptionMessage->new->FileSystemException
WindowsLinkSupport#getRealPath(WindowsPath, boolean):::Returns the actual path of a file, optionally resolving all symbolic links.:::fs->input->getFileSystem->path->try->input->toAbsolutePath->toString->catch->throw->x->getCause->finally->if->path->indexOf->try->GetFullPathName->catch->x->rethrowAsIOException->finally->sb->path->length->new->StringBuilder->start->c0->path->charAt->c1->path->charAt->if->path->charAt->sb->Character->toUpperCase->append->sb->append->else->if->last->path->length->pos->path->indexOf->if->throw->input->getPathForExceptionMessage->new->FileSystemException->path->indexOf->if->sb->append->append->else->sb->append->else->throw->new->AssertionError->if->path->length->result->sb->toString->try->GetFileAttributes->catch->x->rethrowAsIOException->finally->return->curr->while->path->length->next->path->indexOf->end->path->length->search->sb->toString->path->substring->try->fileData->WindowsPath->addPrefixIfNeeded->FindFirstFile->fileData->handle->FindClose->if->WindowsFileAttributes->fileData->attributes->isReparsePoint->result->getFinalPath->if->resolved->WindowsPath->createFromNormalizedPath->resolveAllLinks->getRealPath->return->sb->fileData->name->append->if->sb->append->catch->e->rethrowAsIOException->finally->return->sb->toString
WindowsNativeDispatcher#CreateEvent(boolean, boolean):::HANDLE CreateEvent(   LPSECURITY_ATTRIBUTES lpEventAttributes,   BOOL bManualReset,   BOOL bInitialState,   PCTSTR lpName );:::
WindowsNativeDispatcher#CreateFile(String, int, int, long, int, int):::HANDLE CreateFile(   LPCTSTR lpFileName,   DWORD dwDesiredAccess,   DWORD dwShareMode,   LPSECURITY_ATTRIBUTES lpSecurityAttributes,   DWORD dwCreationDisposition,   DWORD dwFlagsAndAttributes,   HANDLE hTemplateFile ):::buffer->asNativeBuffer->try->return->buffer->address->CreateFile0->catch->finally->buffer->release
WindowsNativeDispatcher#CloseHandle(long):::CloseHandle(   HANDLE hObject ):::
WindowsNativeDispatcher#DeleteFile(String):::DeleteFile(   LPCTSTR lpFileName ):::buffer->asNativeBuffer->try->buffer->address->DeleteFile0->catch->finally->buffer->release
WindowsNativeDispatcher#CreateDirectory(String, long):::CreateDirectory(   LPCTSTR lpPathName,   LPSECURITY_ATTRIBUTES lpSecurityAttributes ):::buffer->asNativeBuffer->try->buffer->address->CreateDirectory0->catch->finally->buffer->release
WindowsNativeDispatcher#RemoveDirectory(String):::RemoveDirectory(   LPCTSTR lpPathName ):::buffer->asNativeBuffer->try->buffer->address->RemoveDirectory0->catch->finally->buffer->release
WindowsNativeDispatcher#DeviceIoControlSetSparse(long):::Marks a file as a sparse file:::
WindowsNativeDispatcher#DeviceIoControlGetReparsePoint(long, long, int):::Retrieves the reparse point data associated with the file or directory:::
WindowsNativeDispatcher#FindFirstFile(String):::HANDLE FindFirstFile(   LPCTSTR lpFileName,   LPWIN32_FIND_DATA lpFindFileData ):::buffer->asNativeBuffer->try->data->new->FirstFile->buffer->address->FindFirstFile0->return->catch->finally->buffer->release
WindowsNativeDispatcher#FindFirstFile(String, long):::HANDLE FindFirstFile(   LPCTSTR lpFileName,   LPWIN32_FIND_DATA lpFindFileData ):::buffer->asNativeBuffer->try->return->buffer->address->FindFirstFile1->catch->finally->buffer->release
WindowsNativeDispatcher#FindNextFile(long, long):::FindNextFile(   HANDLE hFindFile,   LPWIN32_FIND_DATA lpFindFileData ):::
WindowsNativeDispatcher#FindFirstStream(String):::HANDLE FindFirstStreamW(   LPCWSTR lpFileName,   STREAM_INFO_LEVELS InfoLevel,   LPVOID lpFindStreamData,   DWORD dwFlags ):::buffer->asNativeBuffer->try->data->new->FirstStream->buffer->address->FindFirstStream0->if->data->handle->return->return->catch->finally->buffer->release
WindowsNativeDispatcher#FindClose(long):::FindClose(   HANDLE hFindFile ):::
WindowsNativeDispatcher#GetFileInformationByHandle(long, long):::GetFileInformationByHandle(   HANDLE hFile,   LPBY_HANDLE_FILE_INFORMATION lpFileInformation ):::
WindowsNativeDispatcher#CopyFileEx(String, String, int, long):::CopyFileEx(   LPCWSTR lpExistingFileName   LPCWSTR lpNewFileName,   LPPROGRESS_ROUTINE lpProgressRoutine   LPVOID lpData,   LPBOOL pbCancel,   DWORD dwCopyFlags ):::sourceBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->sourceBuffer->address->targetBuffer->address->CopyFileEx0->catch->finally->targetBuffer->release->sourceBuffer->release
WindowsNativeDispatcher#MoveFileEx(String, String, int):::MoveFileEx(   LPCTSTR lpExistingFileName,   LPCTSTR lpNewFileName,   DWORD dwFlags ):::sourceBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->sourceBuffer->address->targetBuffer->address->MoveFileEx0->catch->finally->targetBuffer->release->sourceBuffer->release
WindowsNativeDispatcher#GetFileAttributes(String):::DWORD GetFileAttributes(   LPCTSTR lpFileName ):::buffer->asNativeBuffer->try->return->buffer->address->GetFileAttributes0->catch->finally->buffer->release
WindowsNativeDispatcher#SetFileAttributes(String, int):::SetFileAttributes(   LPCTSTR lpFileName,   DWORD dwFileAttributes:::buffer->asNativeBuffer->try->buffer->address->SetFileAttributes0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFileAttributesEx(String, long):::GetFileAttributesEx(   LPCTSTR lpFileName,   GET_FILEEX_INFO_LEVELS fInfoLevelId,   LPVOID lpFileInformation );:::buffer->asNativeBuffer->try->buffer->address->GetFileAttributesEx0->catch->finally->buffer->release
WindowsNativeDispatcher#SetFileTime(long, long, long, long):::SetFileTime(   HANDLE hFile,   CONST FILETIME *lpCreationTime,   CONST FILETIME *lpLastAccessTime,   CONST FILETIME *lpLastWriteTime ):::
WindowsNativeDispatcher#SetEndOfFile(long):::SetEndOfFile(   HANDLE hFile ):::
WindowsNativeDispatcher#GetLogicalDrives():::DWORD GetLogicalDrives(VOID):::
WindowsNativeDispatcher#GetVolumeInformation(String):::GetVolumeInformation(   LPCTSTR lpRootPathName,   LPTSTR lpVolumeNameBuffer,   DWORD nVolumeNameSize,   LPDWORD lpVolumeSerialNumber,   LPDWORD lpMaximumComponentLength,   LPDWORD lpFileSystemFlags,   LPTSTR lpFileSystemNameBuffer,   DWORD nFileSystemNameSize ):::buffer->asNativeBuffer->try->info->new->VolumeInformation->buffer->address->GetVolumeInformation0->return->catch->finally->buffer->release
WindowsNativeDispatcher#GetDriveType(String):::UINT GetDriveType(   LPCTSTR lpRootPathName ):::buffer->asNativeBuffer->try->return->buffer->address->GetDriveType0->catch->finally->buffer->release
WindowsNativeDispatcher#GetDiskFreeSpaceEx(String):::GetDiskFreeSpaceEx(   LPCTSTR lpDirectoryName,   PULARGE_INTEGER lpFreeBytesAvailableToCaller,   PULARGE_INTEGER lpTotalNumberOfBytes,   PULARGE_INTEGER lpTotalNumberOfFreeBytes ):::buffer->asNativeBuffer->try->space->new->DiskFreeSpace->buffer->address->GetDiskFreeSpaceEx0->return->catch->finally->buffer->release
WindowsNativeDispatcher#GetDiskFreeSpace(String):::GetDiskFreeSpace(   LPCTSTR lpRootPathName,   LPDWORD lpSectorsPerCluster,   LPDWORD lpBytesPerSector,   LPDWORD lpNumberOfFreeClusters,   LPDWORD lpTotalNumberOfClusters ):::buffer->asNativeBuffer->try->space->new->DiskFreeSpace->buffer->address->GetDiskFreeSpace0->return->catch->finally->buffer->release
WindowsNativeDispatcher#GetVolumePathName(String):::GetVolumePathName(   LPCTSTR lpszFileName,   LPTSTR lpszVolumePathName,   DWORD cchBufferLength ):::buffer->asNativeBuffer->try->return->buffer->address->GetVolumePathName0->catch->finally->buffer->release
WindowsNativeDispatcher#InitializeSecurityDescriptor(long):::InitializeSecurityDescriptor(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   DWORD dwRevision ):::
WindowsNativeDispatcher#InitializeAcl(long, int):::InitializeAcl(   PACL pAcl,   DWORD nAclLength,   DWORD dwAclRevision ):::
WindowsNativeDispatcher#GetFileSecurity(String, int, long, int):::GetFileSecurity(   LPCTSTR lpFileName,   SECURITY_INFORMATION RequestedInformation,   PSECURITY_DESCRIPTOR pSecurityDescriptor,   DWORD nLength,   LPDWORD lpnLengthNeeded ):::buffer->asNativeBuffer->try->return->buffer->address->GetFileSecurity0->catch->finally->buffer->release
WindowsNativeDispatcher#SetFileSecurity(String, int, long):::SetFileSecurity(   LPCTSTR lpFileName,   SECURITY_INFORMATION SecurityInformation,   PSECURITY_DESCRIPTOR pSecurityDescriptor ):::buffer->asNativeBuffer->try->buffer->address->SetFileSecurity0->catch->finally->buffer->release
WindowsNativeDispatcher#GetSecurityDescriptorOwner(long):::GetSecurityDescriptorOwner(   PSECURITY_DESCRIPTOR pSecurityDescriptor   PSID *pOwner,   LPBOOL lpbOwnerDefaulted ):::
WindowsNativeDispatcher#SetSecurityDescriptorOwner(long, long):::SetSecurityDescriptorOwner(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   PSID pOwner,   BOOL bOwnerDefaulted ):::
WindowsNativeDispatcher#GetSecurityDescriptorDacl(long):::GetSecurityDescriptorDacl(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   LPBOOL lpbDaclPresent,   PACL *pDacl,   LPBOOL lpbDaclDefaulted ):::
WindowsNativeDispatcher#SetSecurityDescriptorDacl(long, long):::SetSecurityDescriptorDacl(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   BOOL bDaclPresent,   PACL pDacl,   BOOL bDaclDefaulted ):::
WindowsNativeDispatcher#GetAclInformation(long):::GetAclInformation(   PACL pAcl,   LPVOID pAclInformation,   DWORD nAclInformationLength,   ACL_INFORMATION_CLASS dwAclInformationClass ):::info->new->AclInformation->GetAclInformation0->return
WindowsNativeDispatcher#GetAce(long, int):::GetAce(   PACL pAcl,   DWORD dwAceIndex,   LPVOID *pAce ):::
WindowsNativeDispatcher#AddAccessAllowedAceEx(long, int, int, long):::AddAccessAllowedAceEx(   PACL pAcl,   DWORD dwAceRevision,   DWORD AceFlags,   DWORD AccessMask,   PSID pSid ):::
WindowsNativeDispatcher#AddAccessDeniedAceEx(long, int, int, long):::AddAccessDeniedAceEx(   PACL pAcl,   DWORD dwAceRevision,   DWORD AceFlags,   DWORD AccessMask,   PSID pSid ):::
WindowsNativeDispatcher#LookupAccountSid(long):::LookupAccountSid(   LPCTSTR lpSystemName,   PSID Sid,   LPTSTR Name,   LPDWORD cbName,   LPTSTR ReferencedDomainName,   LPDWORD cbReferencedDomainName,   PSID_NAME_USE peUse ):::acc->new->Account->LookupAccountSid0->return
WindowsNativeDispatcher#LookupAccountName(String, long, int):::LookupAccountName(   LPCTSTR lpSystemName,   LPCTSTR lpAccountName,   PSID Sid,   LPDWORD cbSid,   LPTSTR ReferencedDomainName,   LPDWORD cbReferencedDomainName,   PSID_NAME_USE peUse ):::buffer->asNativeBuffer->try->return->buffer->address->LookupAccountName0->catch->finally->buffer->release
WindowsNativeDispatcher#GetLengthSid(long):::DWORD GetLengthSid(   PSID pSid ):::
WindowsNativeDispatcher#ConvertSidToStringSid(long):::ConvertSidToStringSid(   PSID Sid,   LPTSTR* StringSid ):::
WindowsNativeDispatcher#ConvertStringSidToSid(String):::ConvertStringSidToSid(   LPCTSTR StringSid,   PSID* pSid ):::buffer->asNativeBuffer->try->return->buffer->address->ConvertStringSidToSid0->catch->finally->buffer->release
WindowsNativeDispatcher#GetCurrentProcess():::HANDLE GetCurrentProcess(VOID):::
WindowsNativeDispatcher#GetCurrentThread():::HANDLE GetCurrentThread(VOID):::
WindowsNativeDispatcher#OpenProcessToken(long, int):::OpenProcessToken(   HANDLE ProcessHandle,   DWORD DesiredAccess,   PHANDLE TokenHandle ):::
WindowsNativeDispatcher#OpenThreadToken(long, int, boolean):::OpenThreadToken(   HANDLE ThreadHandle,   DWORD DesiredAccess,   BOOL OpenAsSelf,   PHANDLE TokenHandle ):::
WindowsNativeDispatcher#SetThreadToken(long, long):::SetThreadToken(   PHANDLE Thread,   HANDLE Token ):::
WindowsNativeDispatcher#GetTokenInformation(long, int, long, int):::GetTokenInformation(   HANDLE TokenHandle,   TOKEN_INFORMATION_CLASS TokenInformationClass,   LPVOID TokenInformation,   DWORD TokenInformationLength,   PDWORD ReturnLength ):::
WindowsNativeDispatcher#AdjustTokenPrivileges(long, long, int):::AdjustTokenPrivileges(   HANDLE TokenHandle,   BOOL DisableAllPrivileges   PTOKEN_PRIVILEGES NewState   DWORD BufferLength   PTOKEN_PRIVILEGES   PDWORD ReturnLength ):::
WindowsNativeDispatcher#AccessCheck(long, long, int, int, int, int, int):::AccessCheck(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   HANDLE ClientToken,   DWORD DesiredAccess,   PGENERIC_MAPPING GenericMapping,   PPRIVILEGE_SET PrivilegeSet,   LPDWORD PrivilegeSetLength,   LPDWORD GrantedAccess,   LPBOOL AccessStatus ):::
WindowsNativeDispatcher#CreateSymbolicLink(String, String, int):::CreateSymbolicLink(   LPCWSTR lpSymlinkFileName,   LPCWSTR lpTargetFileName,   DWORD dwFlags ):::linkBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->linkBuffer->address->targetBuffer->address->CreateSymbolicLink0->catch->finally->targetBuffer->release->linkBuffer->release
WindowsNativeDispatcher#CreateHardLink(String, String):::CreateHardLink(    LPCTSTR lpFileName,    LPCTSTR lpExistingFileName,    LPSECURITY_ATTRIBUTES lpSecurityAttributes ):::newFileBuffer->asNativeBuffer->existingFileBuffer->asNativeBuffer->try->newFileBuffer->address->existingFileBuffer->address->CreateHardLink0->catch->finally->existingFileBuffer->release->newFileBuffer->release
WindowsNativeDispatcher#GetFullPathName(String):::GetFullPathName(   LPCTSTR lpFileName,   DWORD nBufferLength,   LPTSTR lpBuffer,   LPTSTR *lpFilePart ):::buffer->asNativeBuffer->try->return->buffer->address->GetFullPathName0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFinalPathNameByHandle(long):::GetFinalPathNameByHandle(   HANDLE hFile,   LPTSTR lpszFilePath,   DWORD cchFilePath,   DWORD dwFlags ):::
WindowsNativeDispatcher#FormatMessage(int):::FormatMessage(   DWORD dwFlags,   LPCVOID lpSource,   DWORD dwMessageId,   DWORD dwLanguageId,   LPTSTR lpBuffer,   DWORD nSize,   va_list *Arguments ):::
WindowsNativeDispatcher#LocalFree(long):::LocalFree(   HLOCAL hMem ):::
WindowsNativeDispatcher#CreateIoCompletionPort(long, long, long):::HANDLE CreateIoCompletionPort (   HANDLE FileHandle,   HANDLE ExistingCompletionPort,   ULONG_PTR CompletionKey,   DWORD NumberOfConcurrentThreads ):::
WindowsNativeDispatcher#GetQueuedCompletionStatus(long):::GetQueuedCompletionStatus(   HANDLE CompletionPort,   LPDWORD lpNumberOfBytesTransferred,   PULONG_PTR lpCompletionKey,   LPOVERLAPPED *lpOverlapped,   DWORD dwMilliseconds:::status->new->CompletionStatus->GetQueuedCompletionStatus0->return
WindowsNativeDispatcher#PostQueuedCompletionStatus(long, long):::PostQueuedCompletionStatus(   HANDLE CompletionPort,   DWORD dwNumberOfBytesTransferred,   ULONG_PTR dwCompletionKey,   LPOVERLAPPED lpOverlapped ):::
WindowsNativeDispatcher#ReadDirectoryChangesW(long, long, int, boolean, int, long, long):::ReadDirectoryChangesW(   HANDLE hDirectory,   LPVOID lpBuffer,   DWORD nBufferLength,   BOOL bWatchSubtree,   DWORD dwNotifyFilter,   LPDWORD lpBytesReturned,   LPOVERLAPPED lpOverlapped,   LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine ):::
WindowsNativeDispatcher#CancelIo(long):::CancelIo(   HANDLE hFile ):::
WindowsNativeDispatcher#GetOverlappedResult(long, long):::GetOverlappedResult(   HANDLE hFile,   LPOVERLAPPED lpOverlapped,   LPDWORD lpNumberOfBytesTransferred,   BOOL bWait );:::
WindowsPath#parse(WindowsFileSystem, String):::Creates a Path by parsing the given path.:::result->WindowsPathParser->parse->return->result->type->result->root->result->path->new->WindowsPath
WindowsPath#createFromNormalizedPath(WindowsFileSystem, String, BasicFileAttributes):::Creates a Path from a given path that is known to be normalized.:::try->result->WindowsPathParser->parseNormalizedPath->if->return->result->type->result->root->result->path->new->WindowsPath->else->return->result->type->result->root->result->path->new->WindowsPathWithAttributes->catch->throw->x->getMessage->new->AssertionError->finally
WindowsPath#createFromNormalizedPath(WindowsFileSystem, String):::Creates a WindowsPath from a given path that is known to be normalized.:::return->createFromNormalizedPath
WindowsPathParser.Result#type():::The path type:::return
WindowsPathParser.Result#root():::The root component:::return
WindowsPathParser.Result#path():::The normalized path (includes root):::return
WindowsPathParser#parse(String):::Parses the given input as a Windows path:::return->parse
WindowsPathParser#parseNormalizedPath(String):::Parses the given input as a Windows path where it is known that the path is already normalized.:::return->parse
WindowsSecurity#enablePrivilege(String):::Attempts to enable the given privilege for this method.:::pLuid->try->LookupPrivilegeValue->catch->throw->new->AssertionError->finally->hToken->impersontating->elevated->try->GetCurrentThread->OpenThreadToken->if->DuplicateTokenEx->SetThreadToken->if->AdjustTokenPrivileges->catch->finally->token->stopImpersontating->needToRevert->return->new->Privilege
WindowsSecurity#checkAccessMask(long, int, int, int, int, int):::Check the access right against the securityInfo in the current thread.:::privileges->hToken->GetCurrentThread->OpenThreadToken->if->DuplicateTokenEx->hasRight->if->try->AccessCheck->catch->finally->CloseHandle->return
WindowsSecurityDescriptor#release():::Releases memory associated with SecurityDescriptor:::if->sdBuffer->release->if->aclBuffer->release->if->foreach->LocalFree
WindowsSecurityDescriptor#address():::Returns address of SecurityDescriptor:::return->sdBuffer->address
WindowsSecurityDescriptor#create(List):::Creates a security descriptor with a DACL representing the given ACL.:::return->new->WindowsSecurityDescriptor
WindowsSecurityDescriptor#fromAttribute(FileAttribute...):::Processes the array of attributes looking for the attribute "acl:acl":::sd->foreach->if->sd->release->if->throw->new->NullPointerException->if->attr->name->equals->acl->attr->value->new->WindowsSecurityDescriptor->else->throw->attr->name->new->UnsupportedOperationException->return
WindowsSecurityDescriptor#getAcl(long):::Extracts DACL from security descriptor.:::aclAddress->GetSecurityDescriptorDacl->aceCount->if->else->aclInfo->GetAclInformation->aclInfo->aceCount->result->new->ArrayList<>->for->i->return
WindowsUriSupport#toUri(WindowsPath):::Converts given Path to a URI:::path->toAbsolutePath->s->path->toString->addSlash->if->s->endsWith->try->WindowsFileAttributes->get->isDirectory->catch->finally->return->path->isUnc->toUri
WindowsUriSupport#fromUri(WindowsFileSystem, URI):::Converts given URI to a Path:::if->uri->isAbsolute->throw->new->IllegalArgumentException->if->uri->isOpaque->throw->new->IllegalArgumentException->scheme->uri->getScheme->if->scheme->equalsIgnoreCase->throw->new->IllegalArgumentException->if->uri->getRawFragment->throw->new->IllegalArgumentException->if->uri->getRawQuery->throw->new->IllegalArgumentException->path->uri->getPath->if->path->equals->throw->new->IllegalArgumentException->auth->uri->getRawAuthority->if->auth->equals->host->uri->getHost->if->throw->new->IllegalArgumentException->if->uri->getUserInfo->throw->new->IllegalArgumentException->if->uri->getPort->throw->new->IllegalArgumentException->if->host->startsWith->host->host->length->substring->replace->replace->else->if->path->length->path->charAt->path->substring->return->WindowsPath->parse
