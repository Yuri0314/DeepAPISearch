AbstractAclFileAttributeView#name()::: abstract acl file attribute view name:::return
AbstractAclFileAttributeView#setAttribute(String, Object)::: abstract acl file attribute view set attribute:::if->attribute->equals->setOwner->return->if->attribute->equals->setAcl->return->throw->name->new->IllegalArgumentException
AbstractAclFileAttributeView#readAttributes(String[])::: abstract acl file attribute view read attributes:::acl->owner->foreach->if->attribute->equals->continue->if->attribute->equals->continue->if->attribute->equals->continue->throw->name->new->IllegalArgumentException->result->new->HashMap<>->if->result->getAcl->put->if->result->getOwner->put->return->Collections->unmodifiableMap
AbstractBasicFileAttributeView#name()::: abstract basic file attribute view name:::return
AbstractBasicFileAttributeView#setAttribute(String, Object)::: abstract basic file attribute view set attribute:::if->attribute->equals->setTimes->return->if->attribute->equals->setTimes->return->if->attribute->equals->setTimes->return->throw->name->new->IllegalArgumentException
AbstractBasicFileAttributeView.AttributesBuilder#create(Set, String[]):::Creates builder to build up a map of the matching attributes:::return->new->AttributesBuilder
AbstractBasicFileAttributeView.AttributesBuilder#match(String):::Returns true if the attribute should be returned in the map:::return->names->contains
AbstractBasicFileAttributeView.AttributesBuilder#add(String, Object)::: attributes builder add:::map->put
AbstractBasicFileAttributeView.AttributesBuilder#unmodifiableMap():::Returns the map:::return->Collections->unmodifiableMap
AbstractBasicFileAttributeView#addRequestedBasicAttributes(BasicFileAttributes, AttributesBuilder):::Invoked by readAttributes or sub-classes to add all matching basic attributes to the builder:::if->builder->match->builder->attrs->size->add->if->builder->match->builder->attrs->creationTime->add->if->builder->match->builder->attrs->lastAccessTime->add->if->builder->match->builder->attrs->lastModifiedTime->add->if->builder->match->builder->attrs->fileKey->add->if->builder->match->builder->attrs->isDirectory->add->if->builder->match->builder->attrs->isRegularFile->add->if->builder->match->builder->attrs->isSymbolicLink->add->if->builder->match->builder->attrs->isOther->add
AbstractBasicFileAttributeView#readAttributes(String[])::: abstract basic file attribute view read attributes:::builder->AttributesBuilder->create->readAttributes->addRequestedBasicAttributes->return->builder->unmodifiableMap
AbstractFileSystemProvider#split(String):::Splits the given attribute name into the name of an attribute view and the attribute:::s->new->StringArr->pos->attribute->indexOf->if->else->attribute->substring->attribute->length->attribute->substring->return
AbstractFileSystemProvider#getFileAttributeView(Path, String, LinkOption...):::Gets a DynamicFileAttributeView by name:::
AbstractFileSystemProvider#setAttribute(Path, String, Object, LinkOption...)::: abstract file system provider set attribute:::s->split->if->length->throw->new->IllegalArgumentException->view->getFileAttributeView->if->throw->new->UnsupportedOperationException->view->setAttribute
AbstractFileSystemProvider#readAttributes(Path, String, LinkOption...)::: abstract file system provider read attributes:::s->split->if->length->throw->new->IllegalArgumentException->view->getFileAttributeView->if->throw->new->UnsupportedOperationException->return->view->split->readAttributes
AbstractFileSystemProvider#implDelete(Path, boolean):::Deletes a file:::
AbstractFileSystemProvider#delete(Path)::: abstract file system provider delete:::implDelete
AbstractFileSystemProvider#deleteIfExists(Path)::: abstract file system provider delete if exists:::return->implDelete
AbstractFileSystemProvider#isDirectory(Path):::Tests whether a file is a directory.:::try->return->readAttributes->isDirectory->catch->return->finally
AbstractFileSystemProvider#isRegularFile(Path):::Tests whether a file is a regular file with opaque content.:::try->return->readAttributes->isRegularFile->catch->return->finally
AbstractFileSystemProvider#exists(Path):::Checks the existence of a file.:::try->checkAccess->return->catch->return->finally
AbstractFileTypeDetector#getExtension(String):::Returns the extension of a file name, specifically the portion of the parameter string after the first dot:::ext->if->name->isEmpty->dot->name->indexOf->if->name->length->name->substring->return
AbstractFileTypeDetector#probeContentType(Path):::Invokes the appropriate probe method to guess a file's content type, and checks that the content type's syntax is valid.:::if->throw->new->NullPointerException->result->implProbeContentType->if->fileName->file->getFileName->if->fileNameMap->URLConnection->getFileNameMap->fileNameMap->fileName->toString->getContentTypeFor->return->parse
AbstractFileTypeDetector#implProbeContentType(Path):::Probes the given file to guess its content type.:::
AbstractFileTypeDetector#parse(String):::Parses a candidate content type into its type and subtype, returning null if either token is invalid.:::slash->s->indexOf->semicolon->s->indexOf->if->return->type->s->substring->trim->toLowerCase->if->isValidToken->return->subtype->s->substring->s->substring->subtype->trim->toLowerCase->if->isValidToken->return->sb->type->length->subtype->length->new->StringBuilder->sb->append->sb->append->sb->append->return->sb->toString
AbstractFileTypeDetector#isTokenChar(char):::Returns true if the character is a valid token character.:::return->TSPECIALS->indexOf
AbstractFileTypeDetector#isValidToken(String):::Returns true if the given string is a legal type or subtype.:::len->s->length->if->return->for->i->return
AbstractPoller#start():::Starts the poller thread:::thisRunnable->AccessController->new->PrivilegedAction<>->doPrivileged
AbstractPoller#wakeup():::Wakeup poller thread so that it can service pending requests:::
AbstractPoller#implRegister(Path, Set>, WatchEvent.Modifier...):::Executed by poller thread to register directory for changes:::
AbstractPoller#implCancelKey(WatchKey):::Executed by poller thread to cancel key:::
AbstractPoller#implCloseAll():::Executed by poller thread to shutdown and cancel all keys:::
AbstractPoller#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Requests, and waits on, poller thread to register given file.:::if->throw->new->NullPointerException->eventSet->new->HashSet<>->foreach->if->eventSet->add->continue->if->continue->if->throw->new->NullPointerException->throw->event->name->new->UnsupportedOperationException->if->eventSet->isEmpty->throw->new->IllegalArgumentException->return->invoke
AbstractPoller#cancel(WatchKey):::Cancels, and waits on, poller thread to cancel given key.:::try->invoke->catch->throw->x->getMessage->new->AssertionError->finally
AbstractPoller#close():::Shutdown poller thread:::invoke
AbstractPoller.Request#type()::: request type:::return
AbstractPoller.Request#parameters()::: request parameters:::return
AbstractPoller.Request#release(Object)::: request release:::synchronized->notifyAll
AbstractPoller.Request#awaitResult():::Await completion of the request:::interrupted->synchronized->while->try->wait->catch->finally->if->Thread->currentThread->interrupt->return
AbstractPoller#invoke(RequestType, Object...):::Enqueues request to poller thread and waits for result:::req->new->Request->synchronized->if->throw->new->ClosedWatchServiceException->requestList->add->wakeup->result->req->awaitResult->if->throw->if->throw->return
AbstractPoller#processRequests():::Invoked by poller thread to process all pending requests:::synchronized->req->while->requestList->poll->if->req->new->ClosedWatchServiceException->release->continue->switch->req->type->params->req->parameters->path->events->modifiers->req->implRegister->release->break->params->req->parameters->key->implCancelKey->req->release->break->implCloseAll->req->release->break->req->new->IOException->release->return
AbstractUserDefinedFileAttributeView#checkAccess(String, boolean, boolean)::: abstract user defined file attribute view check access:::sm->System->getSecurityManager->if->if->sm->checkRead->if->sm->checkWrite->sm->new->RuntimePermission->checkPermission
AbstractUserDefinedFileAttributeView#name()::: abstract user defined file attribute view name:::return
AbstractUserDefinedFileAttributeView#setAttribute(String, Object)::: abstract user defined file attribute view set attribute:::bb->if->ByteBuffer->wrap->else->write
AbstractUserDefinedFileAttributeView#readAttributes(String[])::: abstract user defined file attribute view read attributes:::names->new->ArrayList<>->foreach->if->name->equals->list->break->else->if->name->length->throw->new->IllegalArgumentException->names->add->result->new->HashMap<>->foreach->size->size->buf->new->byteArr->n->ByteBuffer->wrap->read->value->Arrays->copyOf->result->put->return
AbstractWatchKey#watcher()::: abstract watch key watcher:::return
AbstractWatchKey#watchable():::Return the original watchable (Path):::return
AbstractWatchKey#signal():::Enqueues this key to the watch service:::synchronized->if->watcher->enqueueKey
AbstractWatchKey#signalEvent(WatchEvent.Kind, Object):::Adds the event to this key and signals it.:::isModify->synchronized->size->events->size->if->prev->events->get->if->prev->kind->prev->kind->Objects->prev->context->equals->increment->return->if->lastModifyEvents->isEmpty->if->ev->lastModifyEvents->get->if->increment->return->else->lastModifyEvents->remove->if->ev->new->Event<>->if->lastModifyEvents->put->else->if->events->clear->lastModifyEvents->clear->events->add->signal
AbstractWatchKey#pollEvents()::: abstract watch key poll events:::synchronized->result->new->ArrayList<>->lastModifyEvents->clear->return
AbstractWatchKey#reset()::: abstract watch key reset:::synchronized->if->isValid->if->events->isEmpty->else->watcher->enqueueKey->return->isValid
AbstractWatchKey.Event#kind()::: event kind:::return
AbstractWatchKey.Event#context()::: event context:::return
AbstractWatchKey.Event#count()::: event count:::return
AbstractWatchKey.Event#increment()::: event increment:::
AbstractWatchService#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Register the given object with this watch service:::
AbstractWatchService#enqueueKey(WatchKey)::: abstract watch service enqueue key:::pendingKeys->offer
AbstractWatchService#checkOpen():::Throws ClosedWatchServiceException if watch service is closed:::if->throw->new->ClosedWatchServiceException
AbstractWatchService#checkKey(WatchKey):::Checks the key isn't the special CLOSE_KEY used to unblock threads when the watch service is closed.:::if->enqueueKey->checkOpen
AbstractWatchService#poll()::: abstract watch service poll:::checkOpen->key->pendingKeys->poll->checkKey->return
AbstractWatchService#poll(long, TimeUnit)::: abstract watch service poll:::checkOpen->key->pendingKeys->poll->checkKey->return
AbstractWatchService#take()::: abstract watch service take:::checkOpen->key->pendingKeys->take->checkKey->return
AbstractWatchService#isOpen():::Tells whether or not this watch service is open.:::return
AbstractWatchService#closeLock():::Retrieves the object upon which the close method synchronizes.:::return
AbstractWatchService#implClose():::Closes this watch service:::
AbstractWatchService#close()::: abstract watch service close:::synchronized->if->return->implClose->pendingKeys->clear->pendingKeys->offer
BasicFileAttributesHolder#get():::Returns cached attributes (may be null):::
BasicFileAttributesHolder#invalidate():::Invalidates cached attributes:::
Cancellable#addressToPollForCancel():::Returns the memory address of a 4-byte int that should be polled to detect cancellation.:::return
Cancellable#cancelValue():::The value to write to the polled memory location to indicate that the task has been cancelled:::return
Cancellable#cancel():::"cancels" the task by writing bits into memory location that it polled by the task.:::synchronized->if->unsafe->cancelValue->putIntVolatile
Cancellable#exception():::Returns the exception thrown by the task or null if the task completed successfully.:::synchronized->return
Cancellable#run()::: cancellable run:::try->implRun->catch->synchronized->finally->synchronized->unsafe->freeMemory
Cancellable#implRun():::The task body:::
Cancellable#runInterruptibly(Cancellable):::Invokes the given task in its own thread:::t->new->Thread->t->start->cancelledByInterrupt->while->t->isAlive->try->t->join->catch->task->cancel->finally->if->Thread->currentThread->interrupt->exc->task->exception->if->throw->new->ExecutionException
DefaultFileSystemProvider#instance():::Returns the platform's default file system provider.:::return
DefaultFileSystemProvider#theFileSystem():::Returns the platform's default file system.:::return->INSTANCE->theFileSystem
DefaultFileTypeDetector#create()::: default file type detector create:::return->new->RegistryFileTypeDetector
DynamicFileAttributeView#setAttribute(String, Object):::Sets/updates the value of an attribute.:::
DynamicFileAttributeView#readAttributes(String[]):::Reads a set of file attributes as a bulk operation.:::
ExtendedOptions.Wrapper#parameter()::: wrapper parameter:::return
ExtendedOptions.InternalOption#registerInternal(Object, T)::: internal option register internal:::wrapper->new->Wrapper<T>->internalToExternal->put
ExtendedOptions.InternalOption#register(OpenOption):::Register this internal option as a OpenOption.:::registerInternal
ExtendedOptions.InternalOption#register(CopyOption):::Register this internal option as a CopyOption.:::registerInternal
ExtendedOptions.InternalOption#register(WatchEvent.Modifier):::Register this internal option as a WatchEvent.Modifier.:::registerInternal
ExtendedOptions.InternalOption#register(WatchEvent.Modifier, T):::Register this internal option as a WatchEvent.Modifier with the given parameter.:::registerInternal
ExtendedOptions.InternalOption#matches(Object):::Returns true if the given option (or modifier) maps to this internal option.:::wrapper->internalToExternal->get->if->return->else->return
ExtendedOptions.InternalOption#parameter():::Returns the parameter object associated with this internal option.:::wrapper->internalToExternal->get->if->return->else->return->wrapper->parameter
FileOwnerAttributeViewImpl#name()::: file owner attribute view impl name:::return
FileOwnerAttributeViewImpl#setAttribute(String, Object)::: file owner attribute view impl set attribute:::if->attribute->equals->setOwner->else->throw->name->new->IllegalArgumentException
FileOwnerAttributeViewImpl#readAttributes(String[])::: file owner attribute view impl read attributes:::result->new->HashMap<>->foreach->if->attribute->equals->attribute->equals->result->getOwner->put->else->throw->name->new->IllegalArgumentException->return
FileOwnerAttributeViewImpl#getOwner()::: file owner attribute view impl get owner:::if->return->readAttributes->owner->else->return->getOwner
FileOwnerAttributeViewImpl#setOwner(UserPrincipal)::: file owner attribute view impl set owner:::if->setOwner->else->setOwner
Globs#isRegexMeta(char)::: globs is regex meta:::return->regexMetaChars->indexOf
Globs#isGlobMeta(char)::: globs is glob meta:::return->globMetaChars->indexOf
Globs#next(String, int)::: globs next:::if->glob->length->return->glob->charAt->return
Globs#toRegexPattern(String, boolean):::Creates a regex pattern from the given glob expression.:::inGroup->regex->new->StringBuilder->i->while->globPattern->length->c->globPattern->charAt->switch->if->globPattern->length->throw->new->PatternSyntaxException->next->globPattern->charAt->if->isGlobMeta->isRegexMeta->regex->append->regex->append->break->if->regex->append->else->regex->append->break->if->regex->append->else->regex->append->if->next->regex->append->else->if->next->regex->append->if->next->regex->append->hasRangeStart->last->while->globPattern->length->globPattern->charAt->if->break->if->throw->new->PatternSyntaxException->if->next->regex->append->regex->append->if->if->throw->new->PatternSyntaxException->if->next->break->if->throw->new->PatternSyntaxException->regex->append->else->if->throw->new->PatternSyntaxException->regex->append->break->if->throw->new->PatternSyntaxException->regex->append->break->if->regex->append->else->regex->append->break->if->regex->append->else->regex->append->break->if->next->regex->append->else->if->regex->append->else->regex->append->break->if->regex->append->else->regex->append->break->if->isRegexMeta->regex->append->regex->append->if->throw->new->PatternSyntaxException->return->regex->append->toString
Globs#toUnixRegexPattern(String)::: globs to unix regex pattern:::return->toRegexPattern
Globs#toWindowsRegexPattern(String)::: globs to windows regex pattern:::return->toRegexPattern
NativeBuffer.Deallocator#run()::: deallocator run:::unsafe->freeMemory
NativeBuffer#release()::: native buffer release:::NativeBuffers->releaseNativeBuffer
NativeBuffer#address()::: native buffer address:::return
NativeBuffer#size()::: native buffer size:::return
NativeBuffer#free()::: native buffer free:::cleanable->clean
NativeBuffer#setOwner(Object)::: native buffer set owner:::
NativeBuffer#owner()::: native buffer owner:::return
NativeBuffers#allocNativeBuffer(int):::Allocates a native buffer, of at least the given size, from the heap.:::if->return->new->NativeBuffer
NativeBuffers#getNativeBufferFromCache(int):::Returns a native buffer, of at least the given size, from the thread local cache.:::buffers->threadLocal->get->if->for->i->return
NativeBuffers#getNativeBuffer(int):::Returns a native buffer, of at least the given size:::buffer->getNativeBufferFromCache->if->buffer->setOwner->return->else->return->allocNativeBuffer
NativeBuffers#releaseNativeBuffer(NativeBuffer):::Releases the given buffer:::buffers->threadLocal->get->if->new->NativeBufferArr->threadLocal->set->return->for->i->for->i->buffer->free
NativeBuffers#copyCStringToNativeBuffer(byte[], NativeBuffer):::Copies a byte array and zero terminator into a given native buffer.:::offset->len->unsafe->buffer->address->copyMemory->unsafe->buffer->address->putByte
NativeBuffers#asNativeBuffer(byte[]):::Copies a byte array and zero terminator into a native buffer, returning the buffer.:::buffer->getNativeBuffer->copyCStringToNativeBuffer->return
PollingWatchService#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...):::Register the given file with this watch service:::eventSet->new->HashSet<>->foreach->if->eventSet->add->continue->if->continue->if->throw->new->NullPointerException->throw->event->name->new->UnsupportedOperationException->if->eventSet->isEmpty->throw->new->IllegalArgumentException->sensitivity->if->foreach->if->throw->new->NullPointerException->if->matches->parameter->else->if->matches->parameter->else->if->matches->parameter->else->throw->new->UnsupportedOperationException->if->isOpen->throw->new->ClosedWatchServiceException->try->value->return->AccessController->new->PrivilegedExceptionAction<PollingWatchKey>->doPrivileged->catch->cause->pae->getCause->if->throw->throw->new->AssertionError->finally
PollingWatchService#doPrivilegedRegister(Path, Set>, int)::: polling watch service do privileged register:::attrs->Files->readAttributes->if->attrs->isDirectory->throw->path->toString->new->NotDirectoryException->fileKey->attrs->fileKey->if->throw->new->AssertionError->synchronized->closeLock->if->isOpen->throw->new->ClosedWatchServiceException->watchKey->synchronized->map->get->if->new->PollingWatchKey->map->put->else->watchKey->disable->watchKey->enable->return
PollingWatchService#implClose()::: polling watch service impl close:::synchronized->foreach->map->entrySet->watchKey->entry->getValue->watchKey->disable->watchKey->invalidate->map->clear->AccessController->new->PrivilegedAction<Void>->doPrivileged
PollingWatchService.CacheEntry#lastTickCount()::: cache entry last tick count:::return
PollingWatchService.CacheEntry#lastModified()::: cache entry last modified:::return
PollingWatchService.CacheEntry#update(long, int)::: cache entry update:::
PollingWatchService.PollingWatchKey#fileKey()::: polling watch key file key:::return
PollingWatchService.PollingWatchKey#isValid()::: polling watch key is valid:::return
PollingWatchService.PollingWatchKey#invalidate()::: polling watch key invalidate:::
PollingWatchService.PollingWatchKey#enable(Set>, long)::: polling watch key enable:::synchronized->thunk->new->Runnable->scheduledExecutor->scheduleAtFixedRate
PollingWatchService.PollingWatchKey#disable()::: polling watch key disable:::synchronized->if->poller->cancel
PollingWatchService.PollingWatchKey#cancel()::: polling watch key cancel:::synchronized->map->fileKey->remove->disable
PollingWatchService.PollingWatchKey#poll():::Polls the directory to detect for new files, modified files, or deleted files.:::if->return->stream->try->Files->watchable->newDirectoryStream->catch->cancel->signal->return->finally->try->foreach->lastModified->try->Files->getLastModifiedTime->toMillis->catch->continue->finally->e->entries->entry->getFileName->get->if->entries->entry->getFileName->new->CacheEntry->put->if->events->contains->entry->getFileName->signalEvent->continue->else->if->events->contains->entry->getFileName->signalEvent->continue->if->if->events->contains->entry->getFileName->signalEvent->e->update->catch->finally->try->stream->close->catch->finally->i->entries->entrySet->iterator->while->i->hasNext->mapEntry->i->next->entry->mapEntry->getValue->if->entry->lastTickCount->name->mapEntry->getKey->i->remove->if->events->contains->signalEvent
Reflect#setAccessible(AccessibleObject)::: reflect set accessible:::AccessController->new->PrivilegedAction<Object>->doPrivileged
Reflect#lookupField(String, String):::Lookup the field of a given class.:::try->cl->Class->forName->f->cl->getDeclaredField->setAccessible->return->catch->throw->new->AssertionError->throw->new->AssertionError->finally
RegistryFileTypeDetector#implProbeContentType(Path)::: registry file type detector impl probe content type:::if->return->name->file->getFileName->if->return->filename->name->toString->dot->filename->lastIndexOf->if->filename->length->return->key->filename->substring->keyBuffer->WindowsNativeDispatcher->asNativeBuffer->nameBuffer->WindowsNativeDispatcher->asNativeBuffer->try->return->keyBuffer->address->nameBuffer->address->queryStringValue->catch->finally->nameBuffer->release->keyBuffer->release
RegistryFileTypeDetector#queryStringValue(long, long)::: registry file type detector query string value:::
Util#jnuEncoding():::Returns Charset corresponding to the sun.jnu.encoding property:::return
Util#toBytes(String):::Encodes the given String into a sequence of bytes using the Charset specified by the sun.jnu.encoding property.:::return->s->getBytes
Util#toString(byte[]):::Constructs a new String by decoding the specified array of bytes using the Charset specified by the sun.jnu.encoding property.:::return->new->String
Util#split(String, char):::Splits a string around the given character:::count->for->i->s->length->result->new->StringArr->n->last->for->i->s->length->s->s->length->substring->return
Util#newSet(E...):::Returns a Set containing the given elements.:::set->new->HashSet<>->foreach->set->add->return
Util#newSet(Set, E...):::Returns a Set containing all the elements of the given Set plus the given elements.:::set->new->HashSet<>->foreach->set->add->return
Util#followLinks(LinkOption...):::Returns true if symbolic links should be followed:::followLinks->foreach->if->else->if->throw->new->NullPointerException->else->throw->new->AssertionError->return
WindowsAclFileAttributeView#checkAccess(WindowsPath, boolean, boolean)::: windows acl file attribute view check access:::sm->System->getSecurityManager->if->if->sm->file->getPathForPermissionCheck->checkRead->if->sm->file->getPathForPermissionCheck->checkWrite->sm->new->RuntimePermission->checkPermission
WindowsAclFileAttributeView#getFileSecurity(String, int)::: windows acl file attribute view get file security:::size->try->GetFileSecurity->catch->x->rethrowAsIOException->finally->buffer->NativeBuffers->getNativeBuffer->try->for->catch->buffer->release->x->rethrowAsIOException->return->finally
WindowsAclFileAttributeView#getOwner()::: windows acl file attribute view get owner:::checkAccess->path->WindowsLinkSupport->getFinalPath->buffer->getFileSecurity->try->sidAddress->buffer->address->GetSecurityDescriptorOwner->if->throw->new->IOException->return->WindowsUserPrincipals->fromSid->catch->x->rethrowAsIOException->return->finally->buffer->release
WindowsAclFileAttributeView#getAcl()::: windows acl file attribute view get acl:::checkAccess->path->WindowsLinkSupport->getFinalPath->buffer->getFileSecurity->try->return->WindowsSecurityDescriptor->buffer->address->getAcl->catch->finally->buffer->release
WindowsAclFileAttributeView#setOwner(UserPrincipal)::: windows acl file attribute view set owner:::if->throw->new->NullPointerException->if->throw->new->ProviderMismatchException->owner->checkAccess->path->WindowsLinkSupport->getFinalPath->pOwner->try->owner->sidString->ConvertStringSidToSid->catch->throw->owner->getName->x->errorString->new->IOException->finally->try->buffer->NativeBuffers->getNativeBuffer->try->buffer->address->InitializeSecurityDescriptor->buffer->address->SetSecurityDescriptorOwner->priv->WindowsSecurity->enablePrivilege->try->buffer->address->SetFileSecurity->catch->finally->priv->drop->catch->x->rethrowAsIOException->finally->buffer->release->catch->finally->LocalFree
WindowsAclFileAttributeView#setAcl(List)::: windows acl file attribute view set acl:::checkAccess->path->WindowsLinkSupport->getFinalPath->sd->WindowsSecurityDescriptor->create->try->sd->address->SetFileSecurity->catch->x->rethrowAsIOException->finally->sd->release
WindowsChannelFactory.Flags#toFlags(Set)::: flags to flags:::flags->new->Flags->foreach->if->switch->break->break->break->break->break->break->break->break->break->break->throw->new->UnsupportedOperationException->continue->if->continue->if->continue->if->matches->continue->if->matches->continue->if->matches->continue->if->matches->continue->if->throw->new->NullPointerException->throw->new->UnsupportedOperationException->return
WindowsChannelFactory#newFileChannel(String, String, Set, long):::Open/creates file, returning FileChannel to access the file:::flags->Flags->toFlags->if->if->else->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->fdObj->open->return->FileChannelImpl->open
WindowsChannelFactory#newAsynchronousFileChannel(String, String, Set, long, ThreadPool):::Open/creates file, returning AsynchronousFileChannel to access the file:::flags->Flags->toFlags->if->if->throw->new->UnsupportedOperationException->fdObj->try->open->catch->x->rethrowAsIOException->return->finally->try->return->WindowsAsynchronousFileChannelImpl->open->catch->fdAccess->close->throw->finally
WindowsChannelFactory#open(String, String, Flags, long):::Opens file based on parameters and options, returning a FileDescriptor encapsulating the handle to the open file.:::truncateAfterOpen->dwDesiredAccess->if->if->dwShareMode->if->if->if->dwFlagsAndAttributes->dwCreationDisposition->if->if->else->if->if->if->else->if->if->if->okayToFollowLinks->if->if->if->sm->System->getSecurityManager->if->if->sm->checkRead->if->sm->checkWrite->if->sm->checkDelete->handle->CreateFile->if->try->if->WindowsFileAttributes->readAttributes->isSymbolicLink->throw->new->WindowsException->catch->CloseHandle->throw->finally->if->try->SetEndOfFile->catch->CloseHandle->throw->finally->if->try->DeviceIoControlSetSparse->catch->finally->fdObj->new->FileDescriptor->fdAccess->setHandle->fdAccess->setAppend->fdAccess->registerCleanup->return
WindowsDirectoryStream#close()::: windows directory stream close:::synchronized->if->return->findDataBuffer->release->try->FindClose->catch->x->rethrowAsIOException->finally
WindowsDirectoryStream#iterator()::: windows directory stream iterator:::if->throw->new->IllegalStateException->synchronized->if->throw->new->IllegalStateException->new->WindowsDirectoryIterator->return
WindowsDirectoryStream.WindowsDirectoryIterator#isSelfOrParent(String)::: windows directory iterator is self or parent:::return->name->equals->name->equals
WindowsDirectoryStream.WindowsDirectoryIterator#acceptEntry(String, BasicFileAttributes)::: windows directory iterator accept entry:::entry->WindowsPath->dir->getFileSystem->createFromNormalizedPath->try->if->filter->accept->return->catch->throw->new->DirectoryIteratorException->finally->return
WindowsDirectoryStream.WindowsDirectoryIterator#readNextEntry()::: windows directory iterator read next entry:::if->isSelfOrParent->acceptEntry->if->return->for
WindowsDirectoryStream.WindowsDirectoryIterator#hasNext()::: windows directory iterator has next:::if->readNextEntry->return
WindowsDirectoryStream.WindowsDirectoryIterator#next()::: windows directory iterator next:::result->if->readNextEntry->else->if->throw->new->NoSuchElementException->return
WindowsDirectoryStream.WindowsDirectoryIterator#remove()::: windows directory iterator remove:::throw->new->UnsupportedOperationException
WindowsException#lastError()::: windows exception last error:::return
WindowsException#errorString()::: windows exception error string:::if->WindowsNativeDispatcher->FormatMessage->if->Integer->toHexString->return
WindowsException#getMessage()::: windows exception get message:::return->errorString
WindowsException#fillInStackTrace()::: windows exception fill in stack trace:::return
WindowsException#translateToIOException(String, String)::: windows exception translate to exception:::if->lastError->return->errorString->new->IOException->if->lastError->lastError->return->new->NoSuchFileException->if->lastError->lastError->return->new->FileAlreadyExistsException->if->lastError->return->new->AccessDeniedException->return->errorString->new->FileSystemException
WindowsException#rethrowAsIOException(String)::: windows exception rethrow as exception:::x->translateToIOException->throw
WindowsException#rethrowAsIOException(WindowsPath, WindowsPath)::: windows exception rethrow as exception:::a->file->getPathForExceptionMessage->b->other->getPathForExceptionMessage->x->translateToIOException->throw
WindowsException#rethrowAsIOException(WindowsPath)::: windows exception rethrow as exception:::rethrowAsIOException
WindowsException#asIOException(WindowsPath)::: windows exception as exception:::return->file->getPathForExceptionMessage->translateToIOException
WindowsFileAttributes#toFileTime(long):::Convert 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 to a FileTime.:::return->FileTime->from
WindowsFileAttributes#toWindowsTime(FileTime):::Convert FileTime to 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.:::value->time->to->return
WindowsFileAttributes#fromFileInformation(long, int):::Create a WindowsFileAttributes from a BY_HANDLE_FILE_INFORMATION structure:::fileAttrs->unsafe->getInt->creationTime->unsafe->getLong->lastAccessTime->unsafe->getLong->lastWriteTime->unsafe->getLong->size->unsafe->getInt->unsafe->getInt->volSerialNumber->unsafe->getInt->fileIndexHigh->unsafe->getInt->fileIndexLow->unsafe->getInt->return->new->WindowsFileAttributes
WindowsFileAttributes#fromFileAttributeData(long, int):::Create a WindowsFileAttributes from a WIN32_FILE_ATTRIBUTE_DATA structure:::fileAttrs->unsafe->getInt->creationTime->unsafe->getLong->lastAccessTime->unsafe->getLong->lastWriteTime->unsafe->getLong->size->unsafe->getInt->unsafe->getInt->return->new->WindowsFileAttributes
WindowsFileAttributes#getBufferForFindData():::Allocates a native buffer for a WIN32_FIND_DATA structure:::return->NativeBuffers->getNativeBuffer
WindowsFileAttributes#fromFindData(long):::Create a WindowsFileAttributes from a WIN32_FIND_DATA structure:::fileAttrs->unsafe->getInt->creationTime->unsafe->getLong->lastAccessTime->unsafe->getLong->lastWriteTime->unsafe->getLong->size->unsafe->getInt->unsafe->getInt->reparseTag->isReparsePoint->unsafe->getInt->return->new->WindowsFileAttributes
WindowsFileAttributes#readAttributes(long):::Reads the attributes of an open file:::buffer->NativeBuffers->getNativeBuffer->try->address->buffer->address->GetFileInformationByHandle->reparseTag->fileAttrs->unsafe->getInt->if->isReparsePoint->size->reparseBuffer->NativeBuffers->getNativeBuffer->try->reparseBuffer->address->DeviceIoControlGetReparsePoint->unsafe->reparseBuffer->address->getLong->catch->finally->reparseBuffer->release->return->fromFileInformation->catch->finally->buffer->release
WindowsFileAttributes#get(WindowsPath, boolean):::Returns attributes of given file.:::if->firstException->buffer->NativeBuffers->getNativeBuffer->try->address->buffer->address->path->getPathForWin32Calls->GetFileAttributesEx->fileAttrs->unsafe->getInt->if->isReparsePoint->return->fromFileAttributeData->catch->if->x->lastError->throw->finally->buffer->release->if->search->path->getPathForWin32Calls->last->search->search->length->charAt->if->throw->getBufferForFindData->try->handle->buffer->address->FindFirstFile->FindClose->attrs->buffer->address->fromFindData->if->attrs->isReparsePoint->throw->return->catch->throw->finally->buffer->release->handle->path->openForReadAttributeAccess->try->return->readAttributes->catch->finally->CloseHandle
WindowsFileAttributes#isSameFile(WindowsFileAttributes, WindowsFileAttributes):::Returns true if the attributes are of the same file - both files must be open.:::return
WindowsFileAttributes#isReparsePoint(int):::Returns true if the attributes are of a file with a reparse point.:::return
WindowsFileAttributes#attributes()::: windows file attributes attributes:::return
WindowsFileAttributes#volSerialNumber()::: windows file attributes vol serial number:::return
WindowsFileAttributes#fileIndexHigh()::: windows file attributes file index high:::return
WindowsFileAttributes#fileIndexLow()::: windows file attributes file index low:::return
WindowsFileAttributes#size()::: windows file attributes size:::return
WindowsFileAttributes#lastModifiedTime()::: windows file attributes last modified time:::return->toFileTime
WindowsFileAttributes#lastAccessTime()::: windows file attributes last access time:::return->toFileTime
WindowsFileAttributes#creationTime()::: windows file attributes creation time:::return->toFileTime
WindowsFileAttributes#fileKey()::: windows file attributes file key:::return
WindowsFileAttributes#isReparsePoint()::: windows file attributes is reparse point:::return->isReparsePoint
WindowsFileAttributes#isDirectoryLink()::: windows file attributes is directory link:::return->isSymbolicLink
WindowsFileAttributes#isSymbolicLink()::: windows file attributes is symbolic link:::return
WindowsFileAttributes#isDirectory()::: windows file attributes is directory:::if->isSymbolicLink->return->return
WindowsFileAttributes#isOther()::: windows file attributes is other:::if->isSymbolicLink->return->return
WindowsFileAttributes#isRegularFile()::: windows file attributes is regular file:::return->isSymbolicLink->isDirectory->isOther
WindowsFileAttributes#isReadOnly()::: windows file attributes is read only:::return
WindowsFileAttributes#isHidden()::: windows file attributes is hidden:::return
WindowsFileAttributes#isArchive()::: windows file attributes is archive:::return
WindowsFileAttributes#isSystem()::: windows file attributes is system:::return
WindowsFileAttributeViews.Basic#readAttributes()::: basic read attributes:::file->checkRead->try->return->WindowsFileAttributes->get->catch->x->rethrowAsIOException->return->finally
WindowsFileAttributeViews.Basic#adjustForFatEpoch(long):::Adjusts a Windows time for the FAT epoch.:::FAT_EPOCH->if->return->else->return
WindowsFileAttributeViews.Basic#setFileTimes(long, long, long):::Parameter values in Windows times.:::handle->try->flags->if->file->getPathForWin32Calls->CreateFile->catch->x->rethrowAsIOException->finally->try->SetFileTime->catch->if->x->lastError->try->if->WindowsFileStore->create->type->equals->adjustForFatEpoch->adjustForFatEpoch->adjustForFatEpoch->SetFileTime->catch->finally->if->x->rethrowAsIOException->finally->CloseHandle
WindowsFileAttributeViews.Basic#setTimes(FileTime, FileTime, FileTime)::: basic set times:::if->return->file->checkWrite->t1->WindowsFileAttributes->toWindowsTime->t2->WindowsFileAttributes->toWindowsTime->t3->WindowsFileAttributes->toWindowsTime->setFileTimes
WindowsFileAttributeViews.Dos#name()::: dos name:::return
WindowsFileAttributeViews.Dos#setAttribute(String, Object)::: dos set attribute:::if->attribute->equals->setReadOnly->return->if->attribute->equals->setArchive->return->if->attribute->equals->setSystem->return->if->attribute->equals->setHidden->return->super->setAttribute
WindowsFileAttributeViews.Dos#readAttributes(String[])::: dos read attributes:::builder->AttributesBuilder->create->attrs->readAttributes->addRequestedBasicAttributes->if->builder->match->builder->attrs->isReadOnly->add->if->builder->match->builder->attrs->isArchive->add->if->builder->match->builder->attrs->isSystem->add->if->builder->match->builder->attrs->isHidden->add->if->builder->match->builder->attrs->attributes->add->return->builder->unmodifiableMap
WindowsFileAttributeViews.Dos#updateAttributes(int, boolean):::Update DOS attributes:::file->checkWrite->path->WindowsLinkSupport->getFinalPath->try->oldValue->GetFileAttributes->newValue->if->else->if->SetFileAttributes->catch->x->rethrowAsIOException->finally
WindowsFileAttributeViews.Dos#setReadOnly(boolean)::: dos set read only:::updateAttributes
WindowsFileAttributeViews.Dos#setHidden(boolean)::: dos set hidden:::updateAttributes
WindowsFileAttributeViews.Dos#setArchive(boolean)::: dos set archive:::updateAttributes
WindowsFileAttributeViews.Dos#setSystem(boolean)::: dos set system:::updateAttributes
WindowsFileAttributeViews.Dos#setAttributes(WindowsFileAttributes)::: dos set attributes:::flags->if->attrs->isReadOnly->if->attrs->isHidden->if->attrs->isArchive->if->attrs->isSystem->updateAttributes->WindowsFileAttributes->attrs->creationTime->toWindowsTime->WindowsFileAttributes->attrs->lastModifiedTime->toWindowsTime->WindowsFileAttributes->attrs->lastAccessTime->toWindowsTime->setFileTimes
WindowsFileAttributeViews#createBasicView(WindowsPath, boolean)::: windows file attribute views create basic view:::return->new->Basic
WindowsFileAttributeViews#createDosView(WindowsPath, boolean)::: windows file attribute views create dos view:::return->new->Dos
WindowsFileCopy#copy(WindowsPath, WindowsPath, CopyOption...):::Copy file from source to target:::replaceExisting->copyAttributes->followLinks->interruptible->foreach->if->continue->if->continue->if->continue->if->matches->continue->if->throw->new->NullPointerException->throw->new->UnsupportedOperationException->sm->System->getSecurityManager->if->source->checkRead->target->checkWrite->sourceAttrs->targetAttrs->sourceHandle->try->source->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->targetHandle->try->target->openForReadAttributeAccess->try->WindowsFileAttributes->readAttributes->if->WindowsFileAttributes->isSameFile->return->if->throw->target->getPathForExceptionMessage->new->FileAlreadyExistsException->catch->finally->CloseHandle->catch->finally->catch->finally->CloseHandle->if->sourceAttrs->isSymbolicLink->sm->new->LinkPermission->checkPermission->sourcePath->asWin32Path->targetPath->asWin32Path->if->try->if->targetAttrs->isDirectory->targetAttrs->isDirectoryLink->RemoveDirectory->else->DeleteFile->catch->if->targetAttrs->isDirectory->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally->if->sourceAttrs->isDirectory->sourceAttrs->isDirectoryLink->flags->if->copyTask->new->Cancellable->try->Cancellable->runInterruptibly->catch->t->e->getCause->if->throw->throw->new->IOException->finally->else->try->CopyFileEx->catch->x->rethrowAsIOException->finally->if->try->copySecurityAttributes->catch->finally->return->try->if->sourceAttrs->isDirectory->CreateDirectory->else->linkTarget->WindowsLinkSupport->readLink->flags->WindowsPath->addPrefixIfNeeded->CreateSymbolicLink->catch->x->rethrowAsIOException->finally->if->view->WindowsFileAttributeViews->createDosView->try->view->setAttributes->catch->if->sourceAttrs->isDirectory->try->RemoveDirectory->catch->finally->finally->try->copySecurityAttributes->catch->finally
WindowsFileCopy#ensureEmptyDir(WindowsPath)::: windows file copy ensure empty dir:::try->dirStream->new->WindowsDirectoryStream->if->dirStream->iterator->hasNext->throw->dir->getPathForExceptionMessage->new->DirectoryNotEmptyException->catch->finally
WindowsFileCopy#move(WindowsPath, WindowsPath, CopyOption...):::Move file from source to target:::atomicMove->replaceExisting->foreach->if->continue->if->continue->if->continue->if->throw->new->NullPointerException->throw->new->UnsupportedOperationException->sm->System->getSecurityManager->if->source->checkWrite->target->checkWrite->sourcePath->asWin32Path->targetPath->asWin32Path->if->try->MoveFileEx->catch->if->x->lastError->throw->source->getPathForExceptionMessage->target->getPathForExceptionMessage->x->errorString->new->AtomicMoveNotSupportedException->x->rethrowAsIOException->finally->return->sourceAttrs->targetAttrs->sourceHandle->try->source->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->targetHandle->try->target->openForReadAttributeAccess->try->WindowsFileAttributes->readAttributes->if->WindowsFileAttributes->isSameFile->return->if->throw->target->getPathForExceptionMessage->new->FileAlreadyExistsException->catch->finally->CloseHandle->catch->finally->catch->finally->CloseHandle->if->try->if->targetAttrs->isDirectory->targetAttrs->isDirectoryLink->RemoveDirectory->else->DeleteFile->catch->if->targetAttrs->isDirectory->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally->try->MoveFileEx->return->catch->if->x->lastError->x->rethrowAsIOException->finally->if->sourceAttrs->isDirectory->sourceAttrs->isDirectoryLink->try->MoveFileEx->catch->x->rethrowAsIOException->finally->try->copySecurityAttributes->catch->finally->return->try->if->sourceAttrs->isDirectory->ensureEmptyDir->CreateDirectory->else->linkTarget->WindowsLinkSupport->readLink->WindowsPath->addPrefixIfNeeded->CreateSymbolicLink->catch->x->rethrowAsIOException->finally->view->WindowsFileAttributeViews->createDosView->try->view->setAttributes->catch->try->RemoveDirectory->catch->finally->throw->finally->try->copySecurityAttributes->catch->finally->try->RemoveDirectory->catch->try->RemoveDirectory->catch->finally->if->x->lastError->x->lastError->throw->target->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->finally
WindowsFileCopy#asWin32Path(WindowsPath)::: windows file copy as win32 path:::try->return->path->getPathForWin32Calls->catch->x->rethrowAsIOException->return->finally
WindowsFileCopy#copySecurityAttributes(WindowsPath, WindowsPath, boolean):::Copy DACL/owner/group from source to target:::path->WindowsLinkSupport->getFinalPath->priv->WindowsSecurity->enablePrivilege->try->request->buffer->WindowsAclFileAttributeView->getFileSecurity->try->try->target->getPathForWin32Calls->buffer->address->SetFileSecurity->catch->x->rethrowAsIOException->finally->catch->finally->buffer->release->catch->finally->priv->drop
WindowsFileStore#create(String, boolean)::: windows file store create:::try->return->new->WindowsFileStore->catch->if->x->lastError->return->x->rethrowAsIOException->return->finally
WindowsFileStore#create(WindowsPath)::: windows file store create:::try->target->WindowsLinkSupport->getFinalPath->try->return->createFromPath->catch->if->e->lastError->throw->WindowsLinkSupport->getFinalPath->if->throw->file->getPathForExceptionMessage->new->FileSystemException->return->createFromPath->finally->catch->x->rethrowAsIOException->return->finally
WindowsFileStore#createFromPath(String)::: windows file store create from path:::root->GetVolumePathName->return->new->WindowsFileStore
WindowsFileStore#volumeInformation()::: windows file store volume information:::return
WindowsFileStore#volumeType()::: windows file store volume type:::return
WindowsFileStore#name()::: windows file store name:::return->volInfo->volumeName
WindowsFileStore#type()::: windows file store type:::return->volInfo->fileSystemName
WindowsFileStore#isReadOnly()::: windows file store is read only:::return->volInfo->flags
WindowsFileStore#readDiskFreeSpaceEx()::: windows file store read disk free space ex:::try->return->GetDiskFreeSpaceEx->catch->x->rethrowAsIOException->return->finally
WindowsFileStore#readDiskFreeSpace()::: windows file store read disk free space:::try->return->GetDiskFreeSpace->catch->x->rethrowAsIOException->return->finally
WindowsFileStore#getTotalSpace()::: windows file store get total space:::return->readDiskFreeSpaceEx->totalNumberOfBytes
WindowsFileStore#getUsableSpace()::: windows file store get usable space:::return->readDiskFreeSpaceEx->freeBytesAvailable
WindowsFileStore#getBlockSize()::: windows file store get block size:::return->readDiskFreeSpace->bytesPerSector
WindowsFileStore#getUnallocatedSpace()::: windows file store get unallocated space:::return->readDiskFreeSpaceEx->freeBytesAvailable
WindowsFileStore#getFileStoreAttributeView(Class)::: windows file store get file store attribute view:::if->throw->new->NullPointerException->return
WindowsFileStore#getAttribute(String)::: windows file store get attribute:::if->attribute->equals->return->getTotalSpace->if->attribute->equals->return->getUsableSpace->if->attribute->equals->return->getUnallocatedSpace->if->attribute->equals->return->getBlockSize->if->attribute->equals->return->volInfo->volumeSerialNumber->if->attribute->equals->return->if->attribute->equals->return->throw->new->UnsupportedOperationException
WindowsFileStore#supportsFileAttributeView(Class)::: windows file store supports file attribute view:::if->throw->new->NullPointerException->if->return->if->return->volInfo->flags->if->return->volInfo->flags->return
WindowsFileStore#supportsFileAttributeView(String)::: windows file store supports file attribute view:::if->name->equals->name->equals->return->if->name->equals->return->supportsFileAttributeView->if->name->equals->return->supportsFileAttributeView->if->name->equals->return->supportsFileAttributeView->return
WindowsFileStore#equals(Object)::: windows file store equals:::if->return->if->return->other->return->root->equals
WindowsFileStore#hashCode()::: windows file store hash code:::return->root->hashCode
WindowsFileStore#toString()::: windows file store to string:::sb->new->StringBuilder->if->sb->length->sb->append->sb->append->sb->root->root->length->subSequence->append->sb->append->return->sb->toString
WindowsFileSystem#defaultDirectory()::: windows file system default directory:::return
WindowsFileSystem#defaultRoot()::: windows file system default root:::return
WindowsFileSystem#provider()::: windows file system provider:::return
WindowsFileSystem#getSeparator()::: windows file system get separator:::return
WindowsFileSystem#isOpen()::: windows file system is open:::return
WindowsFileSystem#isReadOnly()::: windows file system is read only:::return
WindowsFileSystem#close()::: windows file system close:::throw->new->UnsupportedOperationException
WindowsFileSystem#getRootDirectories()::: windows file system get root directories:::drives->try->WindowsNativeDispatcher->GetLogicalDrives->catch->throw->x->getMessage->new->AssertionError->finally->result->new->ArrayList<>->sm->System->getSecurityManager->for->i->return->Collections->unmodifiableList
WindowsFileSystem.FileStoreIterator#readNext()::: file store iterator read next:::for
WindowsFileSystem.FileStoreIterator#hasNext()::: file store iterator has next:::if->return->readNext->return
WindowsFileSystem.FileStoreIterator#next()::: file store iterator next:::if->readNext->if->throw->new->NoSuchElementException->else->result->return
WindowsFileSystem.FileStoreIterator#remove()::: file store iterator remove:::throw->new->UnsupportedOperationException
WindowsFileSystem#getFileStores()::: windows file system get file stores:::sm->System->getSecurityManager->if->try->sm->new->RuntimePermission->checkPermission->catch->return->Collections->emptyList->finally->return->new->Iterable<FileStore>
WindowsFileSystem#supportedFileAttributeViews()::: windows file system supported file attribute views:::return
WindowsFileSystem#getPath(String, String...)::: windows file system get path:::path->if->else->sb->new->StringBuilder->sb->append->foreach->if->segment->length->if->sb->length->sb->append->sb->append->sb->toString->return->WindowsPath->parse
WindowsFileSystem#getUserPrincipalLookupService()::: windows file system get user principal lookup service:::return
WindowsFileSystem#getPathMatcher(String)::: windows file system get path matcher:::pos->syntaxAndInput->indexOf->if->syntaxAndInput->length->throw->new->IllegalArgumentException->syntax->syntaxAndInput->substring->input->syntaxAndInput->substring->expr->if->syntax->equalsIgnoreCase->Globs->toWindowsRegexPattern->else->if->syntax->equalsIgnoreCase->else->throw->new->UnsupportedOperationException->pattern->Pattern->compile->return->new->PathMatcher
WindowsFileSystem#newWatchService()::: windows file system new watch service:::return->new->WindowsWatchService
WindowsFileSystemProvider#theFileSystem()::: windows file system provider the file system:::return
WindowsFileSystemProvider#getScheme()::: windows file system provider get scheme:::return
WindowsFileSystemProvider#checkUri(URI)::: windows file system provider check uri:::if->uri->getScheme->getScheme->equalsIgnoreCase->throw->new->IllegalArgumentException->if->uri->getRawAuthority->throw->new->IllegalArgumentException->path->uri->getPath->if->throw->new->IllegalArgumentException->if->path->equals->throw->new->IllegalArgumentException->if->uri->getRawQuery->throw->new->IllegalArgumentException->if->uri->getRawFragment->throw->new->IllegalArgumentException
WindowsFileSystemProvider#newFileSystem(URI, Map)::: windows file system provider new file system:::checkUri->throw->new->FileSystemAlreadyExistsException
WindowsFileSystemProvider#getFileSystem(URI)::: windows file system provider get file system:::checkUri->return
WindowsFileSystemProvider#getPath(URI)::: windows file system provider get path:::return->WindowsUriSupport->fromUri
WindowsFileSystemProvider#newFileChannel(Path, Set, FileAttribute...)::: windows file system provider new file channel:::if->throw->new->NullPointerException->if->throw->new->ProviderMismatchException->file->sd->WindowsSecurityDescriptor->fromAttribute->try->return->WindowsChannelFactory->file->getPathForWin32Calls->file->getPathForPermissionCheck->sd->address->newFileChannel->catch->x->rethrowAsIOException->return->finally->if->sd->release
WindowsFileSystemProvider#newAsynchronousFileChannel(Path, Set, ExecutorService, FileAttribute...)::: windows file system provider new asynchronous file channel:::if->throw->new->NullPointerException->if->throw->new->ProviderMismatchException->file->pool->ThreadPool->wrap->sd->WindowsSecurityDescriptor->fromAttribute->try->return->WindowsChannelFactory->file->getPathForWin32Calls->file->getPathForPermissionCheck->sd->address->newAsynchronousFileChannel->catch->x->rethrowAsIOException->return->finally->if->sd->release
WindowsFileSystemProvider#getFileAttributeView(Path, Class, LinkOption...)::: windows file system provider get file attribute view:::file->WindowsPath->toWindowsPath->if->throw->new->NullPointerException->followLinks->Util->followLinks->if->return->WindowsFileAttributeViews->createBasicView->if->return->WindowsFileAttributeViews->createDosView->if->return->new->WindowsAclFileAttributeView->if->return->new->WindowsAclFileAttributeView->new->FileOwnerAttributeViewImpl->if->return->new->WindowsUserDefinedFileAttributeView->return
WindowsFileSystemProvider#readAttributes(Path, Class, LinkOption...)::: windows file system provider read attributes:::view->if->else->if->else->if->throw->new->NullPointerException->else->throw->new->UnsupportedOperationException->return->getFileAttributeView->readAttributes
WindowsFileSystemProvider#getFileAttributeView(Path, String, LinkOption...)::: windows file system provider get file attribute view:::file->WindowsPath->toWindowsPath->followLinks->Util->followLinks->if->name->equals->return->WindowsFileAttributeViews->createBasicView->if->name->equals->return->WindowsFileAttributeViews->createDosView->if->name->equals->return->new->WindowsAclFileAttributeView->if->name->equals->return->new->WindowsAclFileAttributeView->new->FileOwnerAttributeViewImpl->if->name->equals->return->new->WindowsUserDefinedFileAttributeView->return
WindowsFileSystemProvider#newByteChannel(Path, Set, FileAttribute...)::: windows file system provider new byte channel:::file->WindowsPath->toWindowsPath->sd->WindowsSecurityDescriptor->fromAttribute->try->return->WindowsChannelFactory->file->getPathForWin32Calls->file->getPathForPermissionCheck->sd->address->newFileChannel->catch->x->rethrowAsIOException->return->finally->sd->release
WindowsFileSystemProvider#implDelete(Path, boolean)::: windows file system provider impl delete:::file->WindowsPath->toWindowsPath->file->checkDelete->attrs->try->WindowsFileAttributes->get->if->attrs->isDirectory->attrs->isDirectoryLink->file->getPathForWin32Calls->RemoveDirectory->else->file->getPathForWin32Calls->DeleteFile->return->catch->if->x->lastError->x->lastError->return->if->attrs->isDirectory->if->x->lastError->x->lastError->throw->file->getPathForExceptionMessage->new->DirectoryNotEmptyException->x->rethrowAsIOException->return->finally
WindowsFileSystemProvider#copy(Path, Path, CopyOption...)::: windows file system provider copy:::WindowsFileCopy->WindowsPath->toWindowsPath->WindowsPath->toWindowsPath->copy
WindowsFileSystemProvider#move(Path, Path, CopyOption...)::: windows file system provider move:::WindowsFileCopy->WindowsPath->toWindowsPath->WindowsPath->toWindowsPath->move
WindowsFileSystemProvider#hasDesiredAccess(WindowsPath, int):::Checks the file security against desired access.:::hasRights->target->WindowsLinkSupport->getFinalPath->aclBuffer->WindowsAclFileAttributeView->getFileSecurity->try->aclBuffer->address->checkAccessMask->catch->exc->rethrowAsIOException->finally->aclBuffer->release->return
WindowsFileSystemProvider#checkReadAccess(WindowsPath):::Checks if the given file(or directory) exists and is readable.:::try->opts->Collections->emptySet->fc->WindowsChannelFactory->file->getPathForWin32Calls->file->getPathForPermissionCheck->newFileChannel->fc->close->catch->try->new->WindowsDirectoryStream->close->catch->exc->rethrowAsIOException->finally->finally
WindowsFileSystemProvider#checkAccess(Path, AccessMode...)::: windows file system provider check access:::file->WindowsPath->toWindowsPath->r->w->x->foreach->switch->break->break->break->throw->new->AssertionError->if->checkReadAccess->return->mask->if->file->checkRead->if->file->checkWrite->if->sm->System->getSecurityManager->if->sm->file->getPathForPermissionCheck->checkExec->if->hasDesiredAccess->throw->file->getPathForExceptionMessage->new->AccessDeniedException->if->try->attrs->WindowsFileAttributes->get->if->attrs->isDirectory->attrs->isReadOnly->throw->file->getPathForExceptionMessage->new->AccessDeniedException->catch->exc->rethrowAsIOException->finally->if->WindowsFileStore->create->isReadOnly->throw->file->getPathForExceptionMessage->new->AccessDeniedException
WindowsFileSystemProvider#isSameFile(Path, Path)::: windows file system provider is same file:::file1->WindowsPath->toWindowsPath->if->file1->equals->return->if->throw->new->NullPointerException->if->return->file2->file1->checkRead->file2->checkRead->h1->try->file1->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->attrs1->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->h2->try->file2->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->attrs2->try->WindowsFileAttributes->readAttributes->catch->x->rethrowAsIOException->finally->return->WindowsFileAttributes->isSameFile->catch->finally->CloseHandle->catch->finally->CloseHandle
WindowsFileSystemProvider#isHidden(Path)::: windows file system provider is hidden:::file->WindowsPath->toWindowsPath->file->checkRead->attrs->try->WindowsFileAttributes->get->catch->x->rethrowAsIOException->finally->if->attrs->isDirectory->return->return->attrs->isHidden
WindowsFileSystemProvider#getFileStore(Path)::: windows file system provider get file store:::file->WindowsPath->toWindowsPath->sm->System->getSecurityManager->if->sm->new->RuntimePermission->checkPermission->file->checkRead->return->WindowsFileStore->create
WindowsFileSystemProvider#createDirectory(Path, FileAttribute...)::: windows file system provider create directory:::dir->WindowsPath->toWindowsPath->dir->checkWrite->sd->WindowsSecurityDescriptor->fromAttribute->try->dir->getPathForWin32Calls->sd->address->CreateDirectory->catch->if->x->lastError->try->if->WindowsFileAttributes->get->isDirectory->throw->dir->toString->new->FileAlreadyExistsException->catch->finally->x->rethrowAsIOException->finally->sd->release
WindowsFileSystemProvider#newDirectoryStream(Path, DirectoryStream.Filter)::: windows file system provider new directory stream:::dir->WindowsPath->toWindowsPath->dir->checkRead->if->throw->new->NullPointerException->return->new->WindowsDirectoryStream
WindowsFileSystemProvider#createSymbolicLink(Path, Path, FileAttribute...)::: windows file system provider create symbolic link:::link->WindowsPath->toWindowsPath->target->WindowsPath->toWindowsPath->if->WindowsSecurityDescriptor->fromAttribute->throw->new->UnsupportedOperationException->sm->System->getSecurityManager->if->sm->new->LinkPermission->checkPermission->link->checkWrite->if->target->type->throw->new->IOException->resolvedTarget->if->target->type->parent->link->getParent->parent->resolve->else->link->resolve->flags->try->wattrs->WindowsFileAttributes->get->if->wattrs->isDirectory->wattrs->isDirectoryLink->catch->finally->try->link->getPathForWin32Calls->WindowsPath->target->toString->addPrefixIfNeeded->CreateSymbolicLink->catch->if->x->lastError->x->rethrowAsIOException->else->x->rethrowAsIOException->finally
WindowsFileSystemProvider#createLink(Path, Path)::: windows file system provider create link:::link->WindowsPath->toWindowsPath->existing->WindowsPath->toWindowsPath->sm->System->getSecurityManager->if->sm->new->LinkPermission->checkPermission->link->checkWrite->existing->checkWrite->try->link->getPathForWin32Calls->existing->getPathForWin32Calls->CreateHardLink->catch->x->rethrowAsIOException->finally
WindowsFileSystemProvider#readSymbolicLink(Path)::: windows file system provider read symbolic link:::link->WindowsPath->toWindowsPath->fs->link->getFileSystem->sm->System->getSecurityManager->if->perm->link->getPathForPermissionCheck->new->FilePermission->sm->checkPermission->target->WindowsLinkSupport->readLink->return->WindowsPath->createFromNormalizedPath
WindowsLinkSupport#readLink(WindowsPath):::Returns the target of a symbolic link:::handle->try->path->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->return->readLinkImpl->catch->finally->CloseHandle
WindowsLinkSupport#getFinalPath(WindowsPath):::Returns the final path (all symbolic links resolved) or null if this operation is not supported.:::h->try->input->openForReadAttributeAccess->catch->x->rethrowAsIOException->finally->try->return->GetFinalPathNameByHandle->stripPrefix->catch->if->x->lastError->x->rethrowAsIOException->finally->CloseHandle->return
WindowsLinkSupport#getFinalPath(WindowsPath, boolean):::Returns the final path of a given path as a String:::fs->input->getFileSystem->try->if->return->input->getPathForWin32Calls->if->WindowsFileAttributes->get->isSymbolicLink->return->input->getPathForWin32Calls->catch->x->rethrowAsIOException->finally->result->getFinalPath->if->return->target->linkCount->do->try->attrs->WindowsFileAttributes->get->if->attrs->isSymbolicLink->return->target->getPathForWin32Calls->catch->x->rethrowAsIOException->finally->link->WindowsPath->readLink->createFromNormalizedPath->parent->target->getParent->if->t->AccessController->new->PrivilegedAction<WindowsPath>->doPrivileged->target->getParent->parent->resolve->while->throw->input->getPathForExceptionMessage->new->FileSystemException
WindowsLinkSupport#getRealPath(WindowsPath, boolean):::Returns the actual path of a file, optionally resolving all symbolic links.:::fs->input->getFileSystem->path->try->input->toAbsolutePath->toString->catch->throw->x->getCause->finally->if->path->indexOf->try->GetFullPathName->catch->x->rethrowAsIOException->finally->sb->path->length->new->StringBuilder->start->c0->path->charAt->c1->path->charAt->if->path->charAt->sb->Character->toUpperCase->append->sb->append->else->if->last->path->length->pos->path->indexOf->if->throw->input->getPathForExceptionMessage->new->FileSystemException->path->indexOf->if->sb->append->append->else->sb->append->else->throw->new->AssertionError->if->path->length->result->sb->toString->try->GetFileAttributes->catch->x->rethrowAsIOException->finally->return->curr->while->path->length->next->path->indexOf->end->path->length->search->sb->toString->path->substring->try->fileData->WindowsPath->addPrefixIfNeeded->FindFirstFile->fileData->handle->FindClose->if->WindowsFileAttributes->fileData->attributes->isReparsePoint->result->getFinalPath->if->resolved->WindowsPath->createFromNormalizedPath->resolveAllLinks->getRealPath->return->sb->fileData->name->append->if->sb->append->catch->e->rethrowAsIOException->finally->return->sb->toString
WindowsLinkSupport#readLinkImpl(long):::Returns target of a symbolic link given the handle of an open file (that should be a link).:::size->buffer->NativeBuffers->getNativeBuffer->try->try->buffer->address->DeviceIoControlGetReparsePoint->catch->if->x->lastError->throw->x->errorString->new->NotLinkException->x->rethrowAsIOException->finally->OFFSETOF_REPARSETAG->OFFSETOF_PATHOFFSET->OFFSETOF_PATHLENGTH->OFFSETOF_PATHBUFFER->tag->unsafe->buffer->address->getLong->if->throw->new->NotLinkException->nameOffset->unsafe->buffer->address->getShort->nameLengthInBytes->unsafe->buffer->address->getShort->if->throw->new->FileSystemException->name->new->charArr->unsafe->buffer->address->copyMemory->target->new->String->stripPrefix->if->target->length->throw->new->IOException->return->catch->finally->buffer->release
WindowsLinkSupport#resolveAllLinks(WindowsPath):::Resolve all symbolic-links in a given absolute and normalized path:::fs->path->getFileSystem->linkCount->elem->while->path->getNameCount->current->path->getRoot->path->subpath->resolve->attrs->try->WindowsFileAttributes->get->catch->x->rethrowAsIOException->finally->if->attrs->isSymbolicLink->if->throw->new->IOException->target->WindowsPath->readLink->createFromNormalizedPath->remainder->count->path->getNameCount->if->path->subpath->current->getParent->resolve->try->full->path->toString->GetFullPathName->if->full->path->toString->equals->WindowsPath->createFromNormalizedPath->catch->x->rethrowAsIOException->finally->if->path->resolve->else->return
WindowsLinkSupport#stripPrefix(String):::Strip long path or symbolic link prefix from path:::if->path->startsWith->if->path->startsWith->path->substring->else->path->substring->return->if->path->startsWith->if->path->startsWith->path->substring->else->path->substring->return->return
WindowsNativeDispatcher#CreateEvent(boolean, boolean):::HANDLE CreateEvent(   LPSECURITY_ATTRIBUTES lpEventAttributes,   BOOL bManualReset,   BOOL bInitialState,   PCTSTR lpName );:::
WindowsNativeDispatcher#CreateFile(String, int, int, long, int, int):::HANDLE CreateFile(   LPCTSTR lpFileName,   DWORD dwDesiredAccess,   DWORD dwShareMode,   LPSECURITY_ATTRIBUTES lpSecurityAttributes,   DWORD dwCreationDisposition,   DWORD dwFlagsAndAttributes,   HANDLE hTemplateFile ):::buffer->asNativeBuffer->try->return->buffer->address->CreateFile0->catch->finally->buffer->release
WindowsNativeDispatcher#CreateFile(String, int, int, int, int)::: windows native dispatcher  create file:::return->CreateFile
WindowsNativeDispatcher#CreateFile0(long, int, int, long, int, int)::: windows native dispatcher  create file0:::
WindowsNativeDispatcher#CloseHandle(long):::CloseHandle(   HANDLE hObject ):::
WindowsNativeDispatcher#DeleteFile(String):::DeleteFile(   LPCTSTR lpFileName ):::buffer->asNativeBuffer->try->buffer->address->DeleteFile0->catch->finally->buffer->release
WindowsNativeDispatcher#DeleteFile0(long)::: windows native dispatcher  delete file0:::
WindowsNativeDispatcher#CreateDirectory(String, long):::CreateDirectory(   LPCTSTR lpPathName,   LPSECURITY_ATTRIBUTES lpSecurityAttributes ):::buffer->asNativeBuffer->try->buffer->address->CreateDirectory0->catch->finally->buffer->release
WindowsNativeDispatcher#CreateDirectory0(long, long)::: windows native dispatcher  create directory0:::
WindowsNativeDispatcher#RemoveDirectory(String):::RemoveDirectory(   LPCTSTR lpPathName ):::buffer->asNativeBuffer->try->buffer->address->RemoveDirectory0->catch->finally->buffer->release
WindowsNativeDispatcher#RemoveDirectory0(long)::: windows native dispatcher  remove directory0:::
WindowsNativeDispatcher#DeviceIoControlSetSparse(long):::Marks a file as a sparse file:::
WindowsNativeDispatcher#DeviceIoControlGetReparsePoint(long, long, int):::Retrieves the reparse point data associated with the file or directory:::
WindowsNativeDispatcher#FindFirstFile(String):::HANDLE FindFirstFile(   LPCTSTR lpFileName,   LPWIN32_FIND_DATA lpFindFileData ):::buffer->asNativeBuffer->try->data->new->FirstFile->buffer->address->FindFirstFile0->return->catch->finally->buffer->release
WindowsNativeDispatcher.FirstFile#handle()::: first file handle:::return
WindowsNativeDispatcher.FirstFile#name()::: first file name:::return
WindowsNativeDispatcher.FirstFile#attributes()::: first file attributes:::return
WindowsNativeDispatcher#FindFirstFile0(long, FirstFile)::: windows native dispatcher  find first file0:::
WindowsNativeDispatcher#FindFirstFile(String, long):::HANDLE FindFirstFile(   LPCTSTR lpFileName,   LPWIN32_FIND_DATA lpFindFileData ):::buffer->asNativeBuffer->try->return->buffer->address->FindFirstFile1->catch->finally->buffer->release
WindowsNativeDispatcher#FindFirstFile1(long, long)::: windows native dispatcher  find first file1:::
WindowsNativeDispatcher#FindNextFile(long, long):::FindNextFile(   HANDLE hFindFile,   LPWIN32_FIND_DATA lpFindFileData ):::
WindowsNativeDispatcher#FindFirstStream(String):::HANDLE FindFirstStreamW(   LPCWSTR lpFileName,   STREAM_INFO_LEVELS InfoLevel,   LPVOID lpFindStreamData,   DWORD dwFlags ):::buffer->asNativeBuffer->try->data->new->FirstStream->buffer->address->FindFirstStream0->if->data->handle->return->return->catch->finally->buffer->release
WindowsNativeDispatcher.FirstStream#handle()::: first stream handle:::return
WindowsNativeDispatcher.FirstStream#name()::: first stream name:::return
WindowsNativeDispatcher#FindFirstStream0(long, FirstStream)::: windows native dispatcher  find first stream0:::
WindowsNativeDispatcher#FindNextStream(long)::: windows native dispatcher  find next stream:::
WindowsNativeDispatcher#FindClose(long):::FindClose(   HANDLE hFindFile ):::
WindowsNativeDispatcher#GetFileInformationByHandle(long, long):::GetFileInformationByHandle(   HANDLE hFile,   LPBY_HANDLE_FILE_INFORMATION lpFileInformation ):::
WindowsNativeDispatcher#CopyFileEx(String, String, int, long):::CopyFileEx(   LPCWSTR lpExistingFileName   LPCWSTR lpNewFileName,   LPPROGRESS_ROUTINE lpProgressRoutine   LPVOID lpData,   LPBOOL pbCancel,   DWORD dwCopyFlags ):::sourceBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->sourceBuffer->address->targetBuffer->address->CopyFileEx0->catch->finally->targetBuffer->release->sourceBuffer->release
WindowsNativeDispatcher#CopyFileEx0(long, long, int, long)::: windows native dispatcher  copy file ex0:::
WindowsNativeDispatcher#MoveFileEx(String, String, int):::MoveFileEx(   LPCTSTR lpExistingFileName,   LPCTSTR lpNewFileName,   DWORD dwFlags ):::sourceBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->sourceBuffer->address->targetBuffer->address->MoveFileEx0->catch->finally->targetBuffer->release->sourceBuffer->release
WindowsNativeDispatcher#MoveFileEx0(long, long, int)::: windows native dispatcher  move file ex0:::
WindowsNativeDispatcher#GetFileAttributes(String):::DWORD GetFileAttributes(   LPCTSTR lpFileName ):::buffer->asNativeBuffer->try->return->buffer->address->GetFileAttributes0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFileAttributes0(long)::: windows native dispatcher  get file attributes0:::
WindowsNativeDispatcher#SetFileAttributes(String, int):::SetFileAttributes(   LPCTSTR lpFileName,   DWORD dwFileAttributes:::buffer->asNativeBuffer->try->buffer->address->SetFileAttributes0->catch->finally->buffer->release
WindowsNativeDispatcher#SetFileAttributes0(long, int)::: windows native dispatcher  set file attributes0:::
WindowsNativeDispatcher#GetFileAttributesEx(String, long):::GetFileAttributesEx(   LPCTSTR lpFileName,   GET_FILEEX_INFO_LEVELS fInfoLevelId,   LPVOID lpFileInformation );:::buffer->asNativeBuffer->try->buffer->address->GetFileAttributesEx0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFileAttributesEx0(long, long)::: windows native dispatcher  get file attributes ex0:::
WindowsNativeDispatcher#SetFileTime(long, long, long, long):::SetFileTime(   HANDLE hFile,   CONST FILETIME *lpCreationTime,   CONST FILETIME *lpLastAccessTime,   CONST FILETIME *lpLastWriteTime ):::
WindowsNativeDispatcher#SetEndOfFile(long):::SetEndOfFile(   HANDLE hFile ):::
WindowsNativeDispatcher#GetLogicalDrives():::DWORD GetLogicalDrives(VOID):::
WindowsNativeDispatcher#GetVolumeInformation(String):::GetVolumeInformation(   LPCTSTR lpRootPathName,   LPTSTR lpVolumeNameBuffer,   DWORD nVolumeNameSize,   LPDWORD lpVolumeSerialNumber,   LPDWORD lpMaximumComponentLength,   LPDWORD lpFileSystemFlags,   LPTSTR lpFileSystemNameBuffer,   DWORD nFileSystemNameSize ):::buffer->asNativeBuffer->try->info->new->VolumeInformation->buffer->address->GetVolumeInformation0->return->catch->finally->buffer->release
WindowsNativeDispatcher.VolumeInformation#fileSystemName()::: volume information file system name:::return
WindowsNativeDispatcher.VolumeInformation#volumeName()::: volume information volume name:::return
WindowsNativeDispatcher.VolumeInformation#volumeSerialNumber()::: volume information volume serial number:::return
WindowsNativeDispatcher.VolumeInformation#flags()::: volume information flags:::return
WindowsNativeDispatcher#GetVolumeInformation0(long, VolumeInformation)::: windows native dispatcher  get volume information0:::
WindowsNativeDispatcher#GetDriveType(String):::UINT GetDriveType(   LPCTSTR lpRootPathName ):::buffer->asNativeBuffer->try->return->buffer->address->GetDriveType0->catch->finally->buffer->release
WindowsNativeDispatcher#GetDriveType0(long)::: windows native dispatcher  get drive type0:::
WindowsNativeDispatcher#GetDiskFreeSpaceEx(String):::GetDiskFreeSpaceEx(   LPCTSTR lpDirectoryName,   PULARGE_INTEGER lpFreeBytesAvailableToCaller,   PULARGE_INTEGER lpTotalNumberOfBytes,   PULARGE_INTEGER lpTotalNumberOfFreeBytes ):::buffer->asNativeBuffer->try->space->new->DiskFreeSpace->buffer->address->GetDiskFreeSpaceEx0->return->catch->finally->buffer->release
WindowsNativeDispatcher#GetDiskFreeSpace(String):::GetDiskFreeSpace(   LPCTSTR lpRootPathName,   LPDWORD lpSectorsPerCluster,   LPDWORD lpBytesPerSector,   LPDWORD lpNumberOfFreeClusters,   LPDWORD lpTotalNumberOfClusters ):::buffer->asNativeBuffer->try->space->new->DiskFreeSpace->buffer->address->GetDiskFreeSpace0->return->catch->finally->buffer->release
WindowsNativeDispatcher.DiskFreeSpace#freeBytesAvailable()::: disk free space free bytes available:::return
WindowsNativeDispatcher.DiskFreeSpace#totalNumberOfBytes()::: disk free space total number of bytes:::return
WindowsNativeDispatcher.DiskFreeSpace#totalNumberOfFreeBytes()::: disk free space total number of free bytes:::return
WindowsNativeDispatcher.DiskFreeSpace#bytesPerSector()::: disk free space bytes per sector:::return
WindowsNativeDispatcher#GetDiskFreeSpaceEx0(long, DiskFreeSpace)::: windows native dispatcher  get disk free space ex0:::
WindowsNativeDispatcher#GetDiskFreeSpace0(long, DiskFreeSpace)::: windows native dispatcher  get disk free space0:::
WindowsNativeDispatcher#GetVolumePathName(String):::GetVolumePathName(   LPCTSTR lpszFileName,   LPTSTR lpszVolumePathName,   DWORD cchBufferLength ):::buffer->asNativeBuffer->try->return->buffer->address->GetVolumePathName0->catch->finally->buffer->release
WindowsNativeDispatcher#GetVolumePathName0(long)::: windows native dispatcher  get volume path name0:::
WindowsNativeDispatcher#InitializeSecurityDescriptor(long):::InitializeSecurityDescriptor(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   DWORD dwRevision ):::
WindowsNativeDispatcher#InitializeAcl(long, int):::InitializeAcl(   PACL pAcl,   DWORD nAclLength,   DWORD dwAclRevision ):::
WindowsNativeDispatcher#GetFileSecurity(String, int, long, int):::GetFileSecurity(   LPCTSTR lpFileName,   SECURITY_INFORMATION RequestedInformation,   PSECURITY_DESCRIPTOR pSecurityDescriptor,   DWORD nLength,   LPDWORD lpnLengthNeeded ):::buffer->asNativeBuffer->try->return->buffer->address->GetFileSecurity0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFileSecurity0(long, int, long, int)::: windows native dispatcher  get file security0:::
WindowsNativeDispatcher#SetFileSecurity(String, int, long):::SetFileSecurity(   LPCTSTR lpFileName,   SECURITY_INFORMATION SecurityInformation,   PSECURITY_DESCRIPTOR pSecurityDescriptor ):::buffer->asNativeBuffer->try->buffer->address->SetFileSecurity0->catch->finally->buffer->release
WindowsNativeDispatcher#SetFileSecurity0(long, int, long)::: windows native dispatcher  set file security0:::
WindowsNativeDispatcher#GetSecurityDescriptorOwner(long):::GetSecurityDescriptorOwner(   PSECURITY_DESCRIPTOR pSecurityDescriptor   PSID *pOwner,   LPBOOL lpbOwnerDefaulted ):::
WindowsNativeDispatcher#SetSecurityDescriptorOwner(long, long):::SetSecurityDescriptorOwner(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   PSID pOwner,   BOOL bOwnerDefaulted ):::
WindowsNativeDispatcher#GetSecurityDescriptorDacl(long):::GetSecurityDescriptorDacl(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   LPBOOL lpbDaclPresent,   PACL *pDacl,   LPBOOL lpbDaclDefaulted ):::
WindowsNativeDispatcher#SetSecurityDescriptorDacl(long, long):::SetSecurityDescriptorDacl(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   BOOL bDaclPresent,   PACL pDacl,   BOOL bDaclDefaulted ):::
WindowsNativeDispatcher#GetAclInformation(long):::GetAclInformation(   PACL pAcl,   LPVOID pAclInformation,   DWORD nAclInformationLength,   ACL_INFORMATION_CLASS dwAclInformationClass ):::info->new->AclInformation->GetAclInformation0->return
WindowsNativeDispatcher.AclInformation#aceCount()::: acl information ace count:::return
WindowsNativeDispatcher#GetAclInformation0(long, AclInformation)::: windows native dispatcher  get acl information0:::
WindowsNativeDispatcher#GetAce(long, int):::GetAce(   PACL pAcl,   DWORD dwAceIndex,   LPVOID *pAce ):::
WindowsNativeDispatcher#AddAccessAllowedAceEx(long, int, int, long):::AddAccessAllowedAceEx(   PACL pAcl,   DWORD dwAceRevision,   DWORD AceFlags,   DWORD AccessMask,   PSID pSid ):::
WindowsNativeDispatcher#AddAccessDeniedAceEx(long, int, int, long):::AddAccessDeniedAceEx(   PACL pAcl,   DWORD dwAceRevision,   DWORD AceFlags,   DWORD AccessMask,   PSID pSid ):::
WindowsNativeDispatcher#LookupAccountSid(long):::LookupAccountSid(   LPCTSTR lpSystemName,   PSID Sid,   LPTSTR Name,   LPDWORD cbName,   LPTSTR ReferencedDomainName,   LPDWORD cbReferencedDomainName,   PSID_NAME_USE peUse ):::acc->new->Account->LookupAccountSid0->return
WindowsNativeDispatcher.Account#domain()::: account domain:::return
WindowsNativeDispatcher.Account#name()::: account name:::return
WindowsNativeDispatcher.Account#use()::: account use:::return
WindowsNativeDispatcher#LookupAccountSid0(long, Account)::: windows native dispatcher  lookup account sid0:::
WindowsNativeDispatcher#LookupAccountName(String, long, int):::LookupAccountName(   LPCTSTR lpSystemName,   LPCTSTR lpAccountName,   PSID Sid,   LPDWORD cbSid,   LPTSTR ReferencedDomainName,   LPDWORD cbReferencedDomainName,   PSID_NAME_USE peUse ):::buffer->asNativeBuffer->try->return->buffer->address->LookupAccountName0->catch->finally->buffer->release
WindowsNativeDispatcher#LookupAccountName0(long, long, int)::: windows native dispatcher  lookup account name0:::
WindowsNativeDispatcher#GetLengthSid(long):::DWORD GetLengthSid(   PSID pSid ):::
WindowsNativeDispatcher#ConvertSidToStringSid(long):::ConvertSidToStringSid(   PSID Sid,   LPTSTR* StringSid ):::
WindowsNativeDispatcher#ConvertStringSidToSid(String):::ConvertStringSidToSid(   LPCTSTR StringSid,   PSID* pSid ):::buffer->asNativeBuffer->try->return->buffer->address->ConvertStringSidToSid0->catch->finally->buffer->release
WindowsNativeDispatcher#ConvertStringSidToSid0(long)::: windows native dispatcher  convert string sid to sid0:::
WindowsNativeDispatcher#GetCurrentProcess():::HANDLE GetCurrentProcess(VOID):::
WindowsNativeDispatcher#GetCurrentThread():::HANDLE GetCurrentThread(VOID):::
WindowsNativeDispatcher#OpenProcessToken(long, int):::OpenProcessToken(   HANDLE ProcessHandle,   DWORD DesiredAccess,   PHANDLE TokenHandle ):::
WindowsNativeDispatcher#OpenThreadToken(long, int, boolean):::OpenThreadToken(   HANDLE ThreadHandle,   DWORD DesiredAccess,   BOOL OpenAsSelf,   PHANDLE TokenHandle ):::
WindowsNativeDispatcher#DuplicateTokenEx(long, int)::: windows native dispatcher  duplicate token ex:::
WindowsNativeDispatcher#SetThreadToken(long, long):::SetThreadToken(   PHANDLE Thread,   HANDLE Token ):::
WindowsNativeDispatcher#GetTokenInformation(long, int, long, int):::GetTokenInformation(   HANDLE TokenHandle,   TOKEN_INFORMATION_CLASS TokenInformationClass,   LPVOID TokenInformation,   DWORD TokenInformationLength,   PDWORD ReturnLength ):::
WindowsNativeDispatcher#AdjustTokenPrivileges(long, long, int):::AdjustTokenPrivileges(   HANDLE TokenHandle,   BOOL DisableAllPrivileges   PTOKEN_PRIVILEGES NewState   DWORD BufferLength   PTOKEN_PRIVILEGES   PDWORD ReturnLength ):::
WindowsNativeDispatcher#AccessCheck(long, long, int, int, int, int, int):::AccessCheck(   PSECURITY_DESCRIPTOR pSecurityDescriptor,   HANDLE ClientToken,   DWORD DesiredAccess,   PGENERIC_MAPPING GenericMapping,   PPRIVILEGE_SET PrivilegeSet,   LPDWORD PrivilegeSetLength,   LPDWORD GrantedAccess,   LPBOOL AccessStatus ):::
WindowsNativeDispatcher#LookupPrivilegeValue(String)::: windows native dispatcher  lookup privilege value:::buffer->asNativeBuffer->try->return->buffer->address->LookupPrivilegeValue0->catch->finally->buffer->release
WindowsNativeDispatcher#LookupPrivilegeValue0(long)::: windows native dispatcher  lookup privilege value0:::
WindowsNativeDispatcher#CreateSymbolicLink(String, String, int):::CreateSymbolicLink(   LPCWSTR lpSymlinkFileName,   LPCWSTR lpTargetFileName,   DWORD dwFlags ):::linkBuffer->asNativeBuffer->targetBuffer->asNativeBuffer->try->linkBuffer->address->targetBuffer->address->CreateSymbolicLink0->catch->finally->targetBuffer->release->linkBuffer->release
WindowsNativeDispatcher#CreateSymbolicLink0(long, long, int)::: windows native dispatcher  create symbolic link0:::
WindowsNativeDispatcher#CreateHardLink(String, String):::CreateHardLink(    LPCTSTR lpFileName,    LPCTSTR lpExistingFileName,    LPSECURITY_ATTRIBUTES lpSecurityAttributes ):::newFileBuffer->asNativeBuffer->existingFileBuffer->asNativeBuffer->try->newFileBuffer->address->existingFileBuffer->address->CreateHardLink0->catch->finally->existingFileBuffer->release->newFileBuffer->release
WindowsNativeDispatcher#CreateHardLink0(long, long)::: windows native dispatcher  create hard link0:::
WindowsNativeDispatcher#GetFullPathName(String):::GetFullPathName(   LPCTSTR lpFileName,   DWORD nBufferLength,   LPTSTR lpBuffer,   LPTSTR *lpFilePart ):::buffer->asNativeBuffer->try->return->buffer->address->GetFullPathName0->catch->finally->buffer->release
WindowsNativeDispatcher#GetFullPathName0(long)::: windows native dispatcher  get full path name0:::
WindowsNativeDispatcher#GetFinalPathNameByHandle(long):::GetFinalPathNameByHandle(   HANDLE hFile,   LPTSTR lpszFilePath,   DWORD cchFilePath,   DWORD dwFlags ):::
WindowsNativeDispatcher#FormatMessage(int):::FormatMessage(   DWORD dwFlags,   LPCVOID lpSource,   DWORD dwMessageId,   DWORD dwLanguageId,   LPTSTR lpBuffer,   DWORD nSize,   va_list *Arguments ):::
WindowsNativeDispatcher#LocalFree(long):::LocalFree(   HLOCAL hMem ):::
WindowsNativeDispatcher#CreateIoCompletionPort(long, long, long):::HANDLE CreateIoCompletionPort (   HANDLE FileHandle,   HANDLE ExistingCompletionPort,   ULONG_PTR CompletionKey,   DWORD NumberOfConcurrentThreads ):::
WindowsNativeDispatcher#GetQueuedCompletionStatus(long):::GetQueuedCompletionStatus(   HANDLE CompletionPort,   LPDWORD lpNumberOfBytesTransferred,   PULONG_PTR lpCompletionKey,   LPOVERLAPPED *lpOverlapped,   DWORD dwMilliseconds:::status->new->CompletionStatus->GetQueuedCompletionStatus0->return
WindowsNativeDispatcher.CompletionStatus#error()::: completion status error:::return
WindowsNativeDispatcher.CompletionStatus#bytesTransferred()::: completion status bytes transferred:::return
WindowsNativeDispatcher.CompletionStatus#completionKey()::: completion status completion key:::return
WindowsNativeDispatcher#GetQueuedCompletionStatus0(long, CompletionStatus)::: windows native dispatcher  get queued completion status0:::
WindowsNativeDispatcher#PostQueuedCompletionStatus(long, long):::PostQueuedCompletionStatus(   HANDLE CompletionPort,   DWORD dwNumberOfBytesTransferred,   ULONG_PTR dwCompletionKey,   LPOVERLAPPED lpOverlapped ):::
WindowsNativeDispatcher#ReadDirectoryChangesW(long, long, int, boolean, int, long, long):::ReadDirectoryChangesW(   HANDLE hDirectory,   LPVOID lpBuffer,   DWORD nBufferLength,   BOOL bWatchSubtree,   DWORD dwNotifyFilter,   LPDWORD lpBytesReturned,   LPOVERLAPPED lpOverlapped,   LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine ):::
WindowsNativeDispatcher#CancelIo(long):::CancelIo(   HANDLE hFile ):::
WindowsNativeDispatcher#GetOverlappedResult(long, long):::GetOverlappedResult(   HANDLE hFile,   LPOVERLAPPED lpOverlapped,   LPDWORD lpNumberOfBytesTransferred,   BOOL bWait );:::
WindowsNativeDispatcher#asNativeBuffer(String)::: windows native dispatcher as native buffer:::stringLengthInBytes->s->length->sizeInBytes->buffer->NativeBuffers->getNativeBufferFromCache->if->NativeBuffers->allocNativeBuffer->else->if->buffer->owner->return->chars->s->toCharArray->unsafe->buffer->address->copyMemory->unsafe->buffer->address->putChar->buffer->setOwner->return
WindowsNativeDispatcher#initIDs()::: windows native dispatcher init ds:::
WindowsPath#parse(WindowsFileSystem, String):::Creates a Path by parsing the given path.:::result->WindowsPathParser->parse->return->result->type->result->root->result->path->new->WindowsPath
WindowsPath#createFromNormalizedPath(WindowsFileSystem, String, BasicFileAttributes):::Creates a Path from a given path that is known to be normalized.:::try->result->WindowsPathParser->parseNormalizedPath->if->return->result->type->result->root->result->path->new->WindowsPath->else->return->result->type->result->root->result->path->new->WindowsPathWithAttributes->catch->throw->x->getMessage->new->AssertionError->finally
WindowsPath#createFromNormalizedPath(WindowsFileSystem, String):::Creates a WindowsPath from a given path that is known to be normalized.:::return->createFromNormalizedPath
WindowsPath.WindowsPathWithAttributes#get()::: windows path with attributes get:::return->ref->get
WindowsPath.WindowsPathWithAttributes#invalidate()::: windows path with attributes invalidate:::ref->clear
WindowsPath#getPathForExceptionMessage()::: windows path get path for exception message:::return
WindowsPath#getPathForPermissionCheck()::: windows path get path for permission check:::return
WindowsPath#getPathForWin32Calls()::: windows path get path for win32 calls:::if->isAbsolute->path->length->return->ref->resolved->ref->get->if->return->getAbsolutePath->if->resolved->length->if->resolved->length->throw->new->WindowsException->GetFullPathName->addPrefixIfNeeded->if->synchronized->new->WeakReference<String>->return
WindowsPath#getAbsolutePath()::: windows path get absolute path:::if->isAbsolute->return->if->defaultDirectory->getFileSystem->defaultDirectory->if->isEmpty->return->if->defaultDirectory->endsWith->return->else->sb->defaultDirectory->length->path->length->new->StringBuilder->return->sb->append->append->append->toString->if->defaultRoot->getFileSystem->defaultRoot->return->path->substring->if->getFileSystem->defaultRoot->isSameDrive->remaining->path->root->length->substring->defaultDirectory->getFileSystem->defaultDirectory->if->remaining->length->return->else->if->defaultDirectory->endsWith->return->else->return->else->wd->try->dt->GetDriveType->if->throw->new->WindowsException->GetFullPathName->catch->throw->Character->root->charAt->toUpperCase->new->WindowsException->finally->result->if->wd->endsWith->path->root->length->substring->else->if->path->length->root->length->path->root->length->substring->return
WindowsPath#isSameDrive(String, String)::: windows path is same drive:::return->Character->root1->charAt->toUpperCase->Character->root2->charAt->toUpperCase
WindowsPath#addPrefixIfNeeded(String)::: windows path add prefix if needed:::if->path->length->if->path->startsWith->path->path->length->substring->else->return
WindowsPath#getFileSystem()::: windows path get file system:::return
WindowsPath#isEmpty()::: windows path is empty:::return->path->length
WindowsPath#emptyPath()::: windows path empty path:::return->getFileSystem->new->WindowsPath
WindowsPath#getFileName()::: windows path get file name:::len->path->length->if->return->if->root->length->return->off->path->lastIndexOf->if->root->length->root->length->else->return->getFileSystem->path->substring->new->WindowsPath
WindowsPath#getParent()::: windows path get parent:::if->root->length->path->length->return->off->path->lastIndexOf->if->root->length->return->getRoot->else->return->getFileSystem->path->substring->new->WindowsPath
WindowsPath#getRoot()::: windows path get root:::if->root->length->return->return->getFileSystem->new->WindowsPath
WindowsPath#type()::: windows path type:::return
WindowsPath#isUnc()::: windows path is unc:::return
WindowsPath#needsSlashWhenResolving()::: windows path needs slash when resolving:::if->path->endsWith->return->return->path->length->root->length
WindowsPath#isAbsolute()::: windows path is absolute:::return
WindowsPath#toWindowsPath(Path)::: windows path to windows path:::if->throw->new->NullPointerException->if->throw->new->ProviderMismatchException->return
WindowsPath#hasDotOrDotDot()::: windows path has dot or dot dot:::n->getNameCount->for->i->return
WindowsPath#relativize(Path)::: windows path relativize:::child->toWindowsPath->if->this->equals->return->emptyPath->if->throw->new->IllegalArgumentException->if->equalsIgnoreCase->throw->new->IllegalArgumentException->if->this->isEmpty->return->base->if->base->hasDotOrDotDot->child->hasDotOrDotDot->base->normalize->child->normalize->baseCount->base->getNameCount->childCount->child->getNameCount->n->Math->min->i->while->if->base->getName->child->getName->equals->break->childRemaining->isChildEmpty->if->emptyPath->else->child->subpath->childRemaining->isEmpty->if->return->baseRemaining->base->subpath->if->baseRemaining->hasDotOrDotDot->throw->new->IllegalArgumentException->if->baseRemaining->isEmpty->return->dotdots->baseRemaining->getNameCount->if->return->result->new->StringBuilder->for->j->if->for->j->childRemaining->getNameCount->result->result->length->setLength->return->getFileSystem->result->toString->createFromNormalizedPath
WindowsPath#normalize()::: windows path normalize:::count->getNameCount->if->isEmpty->return->ignore->new->booleanArr->remaining->prevRemaining->do->prevName->for->i->while->if->return->if->return->root->length->emptyPath->getRoot->result->new->StringBuilder->if->result->append->for->i->result->result->length->setLength->return->getFileSystem->result->toString->createFromNormalizedPath
WindowsPath#resolve(Path)::: windows path resolve:::other->toWindowsPath->if->other->isEmpty->return->if->other->isAbsolute->return->switch->result->if->path->endsWith->root->length->path->length->else->return->getFileSystem->new->WindowsPath->result->if->root->endsWith->substring->else->return->getFileSystem->createFromNormalizedPath->if->root->endsWith->return->thisRoot->root->root->length->substring->if->thisRoot->equalsIgnoreCase->return->remaining->length->substring->result->if->path->endsWith->else->return->getFileSystem->createFromNormalizedPath->throw->new->AssertionError
WindowsPath#initOffsets()::: windows path init offsets:::if->list->new->ArrayList<>->if->isEmpty->list->add->else->start->root->length->off->root->length->while->path->length->if->path->charAt->else->list->add->if->list->add->synchronized->if->list->list->size->new->IntegerArr->toArray
WindowsPath#getNameCount()::: windows path get name count:::initOffsets->return
WindowsPath#elementAsString(int)::: windows path element as string:::initOffsets->if->return->path->substring->return->path->substring
WindowsPath#getName(int)::: windows path get name:::initOffsets->if->throw->new->IllegalArgumentException->return->getFileSystem->elementAsString->new->WindowsPath
WindowsPath#subpath(int, int)::: windows path subpath:::initOffsets->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->sb->new->StringBuilder->nelems->new->IntegerArr->for->i->return->getFileSystem->sb->toString->new->WindowsPath
WindowsPath#startsWith(Path)::: windows path starts with:::if->Objects->requireNonNull->return->other->if->equalsIgnoreCase->return->if->other->isEmpty->return->this->isEmpty->thisCount->getNameCount->otherCount->other->getNameCount->if->while->thisElement->this->elementAsString->otherElement->other->elementAsString->if->thisElement->equalsIgnoreCase->return->return->return
WindowsPath#endsWith(Path)::: windows path ends with:::if->Objects->requireNonNull->return->other->if->length->length->return->if->other->isEmpty->return->this->isEmpty->thisCount->this->getNameCount->otherCount->other->getNameCount->if->return->if->length->if->return->if->equalsIgnoreCase->return->off->while->thisElement->this->elementAsString->otherElement->other->elementAsString->if->thisElement->equalsIgnoreCase->return->return
WindowsPath#compareTo(Path)::: windows path compare to:::if->throw->new->NullPointerException->s1->s2->n1->s1->length->n2->s2->length->min->Math->min->for->i->return
WindowsPath#equals(Object)::: windows path equals:::if->return->compareTo->return
WindowsPath#hashCode()::: windows path hash code:::h->if->for->i->path->length->return
WindowsPath#toString()::: windows path to string:::return
WindowsPath#openForReadAttributeAccess(boolean)::: windows path open for read attribute access:::flags->if->return->getPathForWin32Calls->CreateFile
WindowsPath#checkRead()::: windows path check read:::sm->System->getSecurityManager->if->sm->getPathForPermissionCheck->checkRead
WindowsPath#checkWrite()::: windows path check write:::sm->System->getSecurityManager->if->sm->getPathForPermissionCheck->checkWrite
WindowsPath#checkDelete()::: windows path check delete:::sm->System->getSecurityManager->if->sm->getPathForPermissionCheck->checkDelete
WindowsPath#toUri()::: windows path to uri:::return->WindowsUriSupport->toUri
WindowsPath#toAbsolutePath()::: windows path to absolute path:::if->isAbsolute->return->sm->System->getSecurityManager->if->sm->checkPropertyAccess->try->return->getFileSystem->getAbsolutePath->createFromNormalizedPath->catch->throw->x->getMessage->new->IOException->new->IOError->finally
WindowsPath#toRealPath(LinkOption...)::: windows path to real path:::checkRead->rp->WindowsLinkSupport->Util->followLinks->getRealPath->return->getFileSystem->createFromNormalizedPath
WindowsPath#register(WatchService, WatchEvent.Kind[], WatchEvent.Modifier...)::: windows path register:::if->throw->new->NullPointerException->if->throw->new->ProviderMismatchException->sm->System->getSecurityManager->if->watchSubtree->ml->if->Arrays->copyOf->i->while->if->matches->break->s->getPathForPermissionCheck->sm->checkRead->if->sm->checkRead->return->register
WindowsPathParser.Result#type():::The path type:::return
WindowsPathParser.Result#root():::The root component:::return
WindowsPathParser.Result#path():::The normalized path (includes root):::return
WindowsPathParser#parse(String):::Parses the given input as a Windows path:::return->parse
WindowsPathParser#parseNormalizedPath(String):::Parses the given input as a Windows path where it is known that the path is already normalized.:::return->parse
WindowsPathParser#parse(String, boolean):::Parses the given input as a Windows path.:::root->type->len->input->length->off->if->c0->input->charAt->c1->input->charAt->c->next->if->isSlash->isSlash->nextNonSlash->nextSlash->if->throw->new->InvalidPathException->host->input->substring->nextNonSlash->nextSlash->if->throw->new->InvalidPathException->input->substring->else->if->isLetter->c2->if->input->charAt->isSlash->if->input->substring->else->input->substring->else->input->substring->if->if->input->charAt->isSlash->else->if->sb->input->length->new->StringBuilder->sb->append->return->normalize->new->Result->else->return->new->Result
WindowsPathParser#normalize(StringBuilder, String, int):::Remove redundant slashes from the rest of the path, forcing all slashes into the preferred slash.:::len->path->length->nextNonSlash->start->lastC->while->c->path->charAt->if->isSlash->if->throw->new->InvalidPathException->sb->append->nextNonSlash->if->sb->append->else->if->isInvalidPathChar->throw->new->InvalidPathException->if->if->throw->new->InvalidPathException->sb->append->return->sb->toString
WindowsPathParser#isSlash(char)::: windows path parser is slash:::return
WindowsPathParser#nextNonSlash(String, int, int)::: windows path parser next non slash:::while->path->charAt->isSlash->return
WindowsPathParser#nextSlash(String, int, int)::: windows path parser next slash:::c->while->path->charAt->isSlash->if->isInvalidPathChar->throw->new->InvalidPathException->return
WindowsPathParser#isLetter(char)::: windows path parser is letter:::return
WindowsPathParser#isInvalidPathChar(char)::: windows path parser is invalid path char:::return->reservedChars->indexOf
WindowsSecurity#openProcessToken(int)::: windows security open process token:::try->return->GetCurrentProcess->OpenProcessToken->catch->return->finally
WindowsSecurity.Privilege#drop()::: privilege drop:::
WindowsSecurity#enablePrivilege(String):::Attempts to enable the given privilege for this method.:::pLuid->try->LookupPrivilegeValue->catch->throw->new->AssertionError->finally->hToken->impersontating->elevated->try->GetCurrentThread->OpenThreadToken->if->DuplicateTokenEx->SetThreadToken->if->AdjustTokenPrivileges->catch->finally->token->stopImpersontating->needToRevert->return->new->Privilege
WindowsSecurity#checkAccessMask(long, int, int, int, int, int):::Check the access right against the securityInfo in the current thread.:::privileges->hToken->GetCurrentThread->OpenThreadToken->if->DuplicateTokenEx->hasRight->if->try->AccessCheck->catch->finally->CloseHandle->return
WindowsSecurityDescriptor#release():::Releases memory associated with SecurityDescriptor:::if->sdBuffer->release->if->aclBuffer->release->if->foreach->LocalFree
WindowsSecurityDescriptor#address():::Returns address of SecurityDescriptor:::return->sdBuffer->address
WindowsSecurityDescriptor#decode(long)::: windows security descriptor decode:::aceType->unsafe->getByte->if->return->type->if->else->aceFlags->unsafe->getByte->flags->EnumSet->noneOf->if->flags->add->if->flags->add->if->flags->add->if->flags->add->mask->unsafe->getInt->perms->EnumSet->noneOf->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->if->perms->add->sidAddress->user->WindowsUserPrincipals->fromSid->return->AclEntry->newBuilder->setType->setPrincipal->setFlags->setPermissions->build
WindowsSecurityDescriptor#encode(AclEntry, long, long)::: windows security descriptor encode:::if->ace->type->ace->type->return->allow->ace->type->aceMask->ace->permissions->mask->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->if->aceMask->contains->aceFlags->ace->flags->flags->if->aceFlags->contains->if->aceFlags->contains->if->aceFlags->contains->if->aceFlags->contains->if->AddAccessAllowedAceEx->else->AddAccessDeniedAceEx
WindowsSecurityDescriptor#create(List):::Creates a security descriptor with a DACL representing the given ACL.:::return->new->WindowsSecurityDescriptor
WindowsSecurityDescriptor#fromAttribute(FileAttribute...):::Processes the array of attributes looking for the attribute "acl:acl":::sd->foreach->if->sd->release->if->throw->new->NullPointerException->if->attr->name->equals->acl->attr->value->new->WindowsSecurityDescriptor->else->throw->attr->name->new->UnsupportedOperationException->return
WindowsSecurityDescriptor#getAcl(long):::Extracts DACL from security descriptor.:::aclAddress->GetSecurityDescriptorDacl->aceCount->if->else->aclInfo->GetAclInformation->aclInfo->aceCount->result->new->ArrayList<>->for->i->return
WindowsUriSupport#toUri(String, boolean, boolean):::Returns URI to represent the given (absolute) path:::uriHost->uriPath->if->slash->path->indexOf->path->substring->path->substring->replace->if->uriHost->endsWith->uriHost->uriHost->length->IPV6_LITERAL_SUFFIX->length->substring->replace->replace->else->path->replace->if->try->return->new->URI->catch->if->throw->new->AssertionError->finally->path->replace->if->try->return->new->URI->catch->throw->new->AssertionError->finally
WindowsUriSupport#toUri(WindowsPath):::Converts given Path to a URI:::path->toAbsolutePath->s->path->toString->addSlash->if->s->endsWith->try->WindowsFileAttributes->get->isDirectory->catch->finally->return->path->isUnc->toUri
WindowsUriSupport#fromUri(WindowsFileSystem, URI):::Converts given URI to a Path:::if->uri->isAbsolute->throw->new->IllegalArgumentException->if->uri->isOpaque->throw->new->IllegalArgumentException->scheme->uri->getScheme->if->scheme->equalsIgnoreCase->throw->new->IllegalArgumentException->if->uri->getRawFragment->throw->new->IllegalArgumentException->if->uri->getRawQuery->throw->new->IllegalArgumentException->path->uri->getPath->if->path->equals->throw->new->IllegalArgumentException->auth->uri->getRawAuthority->if->auth->equals->host->uri->getHost->if->throw->new->IllegalArgumentException->if->uri->getUserInfo->throw->new->IllegalArgumentException->if->uri->getPort->throw->new->IllegalArgumentException->if->host->startsWith->host->host->length->substring->replace->replace->else->if->path->length->path->charAt->path->substring->return->WindowsPath->parse
WindowsUserDefinedFileAttributeView#join(String, String)::: windows user defined file attribute view join:::if->throw->new->NullPointerException->return
WindowsUserDefinedFileAttributeView#join(WindowsPath, String)::: windows user defined file attribute view join:::return->file->getPathForWin32Calls->join
WindowsUserDefinedFileAttributeView#listUsingStreamEnumeration()::: windows user defined file attribute view list using stream enumeration:::list->new->ArrayList<>->try->first->file->getPathForWin32Calls->FindFirstStream->if->handle->first->handle->try->name->first->name->if->name->equals->segs->name->split->list->add->while->FindNextStream->segs->name->split->list->add->catch->finally->FindClose->catch->x->rethrowAsIOException->finally->return->Collections->unmodifiableList
WindowsUserDefinedFileAttributeView#list()::: windows user defined file attribute view list:::if->System->getSecurityManager->file->getPathForPermissionCheck->checkAccess->return->listUsingStreamEnumeration
WindowsUserDefinedFileAttributeView#size(String)::: windows user defined file attribute view size:::if->System->getSecurityManager->file->getPathForPermissionCheck->checkAccess->fc->try->opts->new->HashSet<>->opts->add->if->opts->add->WindowsChannelFactory->join->newFileChannel->catch->x->file->getPathForPermissionCheck->join->rethrowAsIOException->finally->try->size->fc->size->if->throw->new->ArithmeticException->return->catch->finally->fc->close
WindowsUserDefinedFileAttributeView#read(String, ByteBuffer)::: windows user defined file attribute view read:::if->System->getSecurityManager->file->getPathForPermissionCheck->checkAccess->fc->try->opts->new->HashSet<>->opts->add->if->opts->add->WindowsChannelFactory->join->newFileChannel->catch->x->file->getPathForPermissionCheck->join->rethrowAsIOException->finally->try->if->fc->size->dst->remaining->throw->new->IOException->total->while->dst->hasRemaining->n->fc->read->if->break->return->catch->finally->fc->close
WindowsUserDefinedFileAttributeView#write(String, ByteBuffer)::: windows user defined file attribute view write:::if->System->getSecurityManager->file->getPathForPermissionCheck->checkAccess->handle->try->flags->if->file->getPathForWin32Calls->CreateFile->catch->x->rethrowAsIOException->finally->try->opts->new->HashSet<>->if->opts->add->opts->add->opts->add->opts->add->named->try->WindowsChannelFactory->join->newFileChannel->catch->x->file->getPathForPermissionCheck->join->rethrowAsIOException->finally->try->rem->src->remaining->while->src->hasRemaining->named->write->return->catch->finally->named->close->catch->finally->CloseHandle
WindowsUserDefinedFileAttributeView#delete(String)::: windows user defined file attribute view delete:::if->System->getSecurityManager->file->getPathForPermissionCheck->checkAccess->path->WindowsLinkSupport->getFinalPath->toDelete->join->try->DeleteFile->catch->x->rethrowAsIOException->finally
WindowsUserPrincipals.User#sidString()::: user sid string:::return
WindowsUserPrincipals.User#getName()::: user get name:::return
WindowsUserPrincipals.User#toString()::: user to string:::type->switch->break->break->break->break->break->break->break->break->return
WindowsUserPrincipals.User#equals(Object)::: user equals:::if->return->if->return->other->return->equals
WindowsUserPrincipals.User#hashCode()::: user hash code:::return->sidString->hashCode
WindowsUserPrincipals#fromSid(long)::: windows user principals from sid:::sidString->try->ConvertSidToStringSid->if->throw->new->AssertionError->catch->throw->x->errorString->new->IOException->finally->account->name->try->LookupAccountSid->account->domain->account->name->catch->finally->sidType->account->use->if->return->new->Group->else->return->new->User
WindowsUserPrincipals#lookup(String)::: windows user principals lookup:::sm->System->getSecurityManager->if->sm->new->RuntimePermission->checkPermission->size->try->LookupAccountName->catch->if->x->lastError->throw->new->UserPrincipalNotFoundException->throw->x->errorString->new->IOException->finally->sidBuffer->NativeBuffers->getNativeBuffer->try->newSize->sidBuffer->address->LookupAccountName->if->throw->new->AssertionError->return->sidBuffer->address->fromSid->catch->throw->x->errorString->new->IOException->finally->sidBuffer->release
WindowsWatchService#register(Path, WatchEvent.Kind[], WatchEvent.Modifier...)::: windows watch service register:::return->poller->register
WindowsWatchService#implClose()::: windows watch service impl close:::poller->close
WindowsWatchService.WindowsWatchKey#init(long, Set>, boolean, NativeBuffer, long, long, int)::: windows watch key init:::return
WindowsWatchService.WindowsWatchKey#handle()::: windows watch key handle:::return
WindowsWatchService.WindowsWatchKey#events()::: windows watch key events:::return
WindowsWatchService.WindowsWatchKey#setEvents(Set>)::: windows watch key set events:::
WindowsWatchService.WindowsWatchKey#watchSubtree()::: windows watch key watch subtree:::return
WindowsWatchService.WindowsWatchKey#buffer()::: windows watch key buffer:::return
WindowsWatchService.WindowsWatchKey#countAddress()::: windows watch key count address:::return
WindowsWatchService.WindowsWatchKey#overlappedAddress()::: windows watch key overlapped address:::return
WindowsWatchService.WindowsWatchKey#fileKey()::: windows watch key file key:::return
WindowsWatchService.WindowsWatchKey#completionKey()::: windows watch key completion key:::return
WindowsWatchService.WindowsWatchKey#setErrorStartingOverlapped(boolean)::: windows watch key set error starting overlapped:::
WindowsWatchService.WindowsWatchKey#isErrorStartingOverlapped()::: windows watch key is error starting overlapped:::return
WindowsWatchService.WindowsWatchKey#invalidate()::: windows watch key invalidate:::watcher->releaseResources
WindowsWatchService.WindowsWatchKey#isValid()::: windows watch key is valid:::return
WindowsWatchService.WindowsWatchKey#cancel()::: windows watch key cancel:::if->isValid->watcher->cancel
WindowsWatchService.FileKey#hashCode()::: file key hash code:::return
WindowsWatchService.FileKey#equals(Object)::: file key equals:::if->return->if->return->other->if->return->if->return->return
WindowsWatchService.Poller#wakeup()::: poller wakeup:::try->PostQueuedCompletionStatus->catch->throw->x->getMessage->new->IOException->finally
WindowsWatchService.Poller#implRegister(Path, Set>, WatchEvent.Modifier...):::Register a directory for changes as follows:  1:::dir->watchSubtree->foreach->if->matches->else->if->return->new->NullPointerException->if->matches->matches->matches->return->new->UnsupportedOperationException->handle->try->dir->getPathForWin32Calls->CreateFile->catch->return->x->asIOException->finally->registered->try->attrs->try->WindowsFileAttributes->readAttributes->catch->return->x->asIOException->finally->if->attrs->isDirectory->return->dir->getPathForExceptionMessage->new->NotDirectoryException->fk->attrs->volSerialNumber->attrs->fileIndexHigh->attrs->fileIndexLow->new->FileKey->existing->fk2key->get->if->existing->watchSubtree->existing->setEvents->return->completionKey->if->try->CreateIoCompletionPort->catch->return->x->getMessage->new->IOException->finally->size->buffer->NativeBuffers->getNativeBuffer->bufferAddress->buffer->address->overlappedAddress->countAddress->UNSAFE->setMemory->try->createAndAttachEvent->ReadDirectoryChangesW->catch->closeAttachedEvent->buffer->release->return->x->getMessage->new->IOException->finally->watchKey->if->new->WindowsWatchKey->init->fk2key->put->else->ck2key->existing->completionKey->remove->releaseResources->existing->init->ck2key->put->return->catch->finally->if->CloseHandle
WindowsWatchService.Poller#releaseResources(WindowsWatchKey):::Cancels the outstanding I/O operation on the directory associated with the given key and releases the associated resources.:::if->key->isErrorStartingOverlapped->try->key->handle->CancelIo->key->handle->key->overlappedAddress->GetOverlappedResult->catch->finally->key->handle->CloseHandle->key->overlappedAddress->closeAttachedEvent->key->buffer->free
WindowsWatchService.Poller#createAndAttachEvent(long):::Creates an unnamed event and set it as the hEvent field in the given OVERLAPPED structure:::hEvent->CreateEvent->UNSAFE->putAddress
WindowsWatchService.Poller#closeAttachedEvent(long):::Closes the event attached to the given OVERLAPPED structure:::hEvent->UNSAFE->getAddress->if->CloseHandle
WindowsWatchService.Poller#implCancelKey(WatchKey)::: poller impl cancel key:::key->if->key->isValid->fk2key->key->fileKey->remove->ck2key->key->completionKey->remove->key->invalidate
WindowsWatchService.Poller#implCloseAll()::: poller impl close all:::ck2key->values->WindowsWatchKey->invalidate->forEach->fk2key->clear->ck2key->clear->CloseHandle
WindowsWatchService.Poller#translateActionToEvent(int)::: poller translate action to event:::switch->return->return->return->return
WindowsWatchService.Poller#processEvents(WindowsWatchKey, int)::: poller process events:::address->key->buffer->address->nextOffset->do->action->UNSAFE->getInt->kind->translateActionToEvent->if->key->events->contains->nameLengthInBytes->UNSAFE->getInt->if->throw->new->AssertionError->nameAsArray->new->charArr->UNSAFE->copyMemory->name->WindowsPath->new->String->createFromNormalizedPath->key->signalEvent->UNSAFE->getInt->while
WindowsWatchService.Poller#run():::Poller main loop:::for
