CommonedConstantsTest#test1Snippet(String):::A constant with usages before and after a non-inlined call.:::if->return->noninlineLength->sChars->s->toCharArray->count->for->i->return
CommonedConstantsTest#test2Snippet(String):::A constant with only usage in a loop.:::sChars->s->toCharArray->count->for->i->return
ConcreteSubtypeTest#testLeafAbstractType():::Test that #callAbstractType gets compiled into an empty method with a ConcreteSubtype assumption on AbstractBase and Subclass:::resolveAndInitialize->resolveAndInitialize->new->ConcreteSubtype->testAssumptionInvalidate
ConditionalEliminationTestBase#getDefaultHighTierContext():::These tests assume all code paths in called routines are reachable so disable removal of dead code based on method profiles.:::return->getProviders->getDefaultGraphBuilderSuite->remove->new->HighTierContext
FinalizableSubclassTest#test1():::Use a custom class loader to generate classes, to make sure the given classes are loaded in correct order.:::debug->getDebugContext->for->i
FindUniqueConcreteMethodBugTest#test():::Executing ResolvedJavaType#findUniqueConcreteMethod(ResolvedJavaMethod) for the method Person#getName() on the type AbstractPerson should return null as both PersonImpl and TenantImpl provide implementations (namely PersonImpl#getName() and Tenant#getName()).:::ifaceMethod->getMetaAccess->getDeclaredMethod->lookupJavaMethod->person->new->PersonImpl->tenant->new->TenantImpl->person->getName->tenant->getName->for->i->test->actual->getMetaAccess->lookupJavaType->findUniqueConcreteMethod->Assert->String->valueOf->assertNull
FindUniqueDefaultMethodTest#testFindUnique():::HotSpot has an internal mismatch with CHA and default methods:::cType->getMetaAccess->lookupJavaType->cType->initialize->v1Method->getMetaAccess->this->getMethod->lookupJavaMethod->method->cType->findUniqueConcreteMethod->assertDeepEquals
FindUniqueDefaultMethodTest#testInherited():::This test illustrates a common pattern where a method at the root of a hierarchy is the only implementation and can be statically inlined.:::s->new->Subclass2->testConstantReturn
FindUniqueDefaultMethodTest#testDefault():::Test same pattern as above but using default methods instead:::s->new->Subclass2->testConstantReturn
GraalCompilerAssumptionsTest#testAssumption(String, Assumption, String, boolean):::Checks the behavior of class loading on Assumption invalidation:::javaMethod->getResolvedJavaMethod->graph->parseEager->graph->getAssumptions->isEmpty->assertTrue->checkGraph->compilationResult->compile->installedCode->getBackend->graph->getDebug->createDefaultInstalledCode->installedCode->isValid->assertTrue->if->fullName->getClass->getName->try->Class->forName->catch->fail->finally->installedCode->isValid->assertTrue
GraalCompilerAssumptionsTest#resolveAndInitialize(Class):::Converts a Class to an initialized ResolvedJavaType.:::type->getMetaAccess->lookupJavaType->type->initialize->return
GraalCompilerTest#getInitialOptions():::Gets the initial option values provided by the Graal runtime:::return->Graal->getRequiredCapability
GraalCompilerTest#exportPackage(Class, String):::Exports the package named packageName declared in moduleMember's module to this object's module:::if->JLModule->getClass->exportPackageTo
GraalCompilerTest#checkHighTierGraph(StructuredGraph):::Can be overridden by unit tests to verify properties of the graph.:::
GraalCompilerTest#checkMidTierGraph(StructuredGraph):::Can be overridden by unit tests to verify properties of the graph.:::
GraalCompilerTest#checkLowTierGraph(StructuredGraph):::Can be overridden by unit tests to verify properties of the graph.:::
GraalCompilerTest#getDebugContext():::Gets a DebugContext object corresponding to options, creating a new one if none currently exists:::return->getInitialOptions->getDebugContext
GraalCompilerTest#before(ResolvedJavaMethod):::Called before a test is executed.:::
GraalCompilerTest#after():::Called after a test is executed.:::
GraalCompilerTest#argsWithReceiver(Object, Object...):::Prepends a non-null receiver argument to a given list or args.:::executeArgs->if->else->new->ObjectArr->for->i->return->applyArgSuppliers
GraalCompilerTest#supply(ArgSupplier):::Convenience method for using an ArgSupplier lambda in a varargs list.:::return
GraalCompilerTest#applyArgSuppliers(Object...):::Process a given set of arguments, converting any ArgSupplier argument to the argument it supplies.:::res->for->i->return
GraalCompilerTest#getCode(ResolvedJavaMethod):::Gets installed code for a given method, compiling it first if necessary:::return->getInitialOptions->getCode
GraalCompilerTest#getCode(ResolvedJavaMethod, StructuredGraph):::Gets installed code for a given method, compiling it first if necessary.:::return->getInitialOptions->graph->getOptions->getCode
GraalCompilerTest#getCode(ResolvedJavaMethod, StructuredGraph, boolean):::Gets installed code for a given method and graph, compiling it first if necessary.:::return->getInitialOptions->graph->getOptions->getCode
GraalCompilerTest#getCode(ResolvedJavaMethod, StructuredGraph, boolean, boolean, OptionValues):::Gets installed code for a given method and graph, compiling it first if necessary.:::useCache->getArgumentToBind->if->cached->cache->get->if->if->cached->isValid->return->for->retry->throw->GraalError->shouldNotReachHere
GraalCompilerTest#parseForCompile(ResolvedJavaMethod, OptionValues):::Used to produce a graph for a method about to be compiled by #compile(ResolvedJavaMethod, StructuredGraph) if the second parameter to that method is null:::return->getCompilationId->parseEager
GraalCompilerTest#compile(ResolvedJavaMethod, StructuredGraph):::Compiles a given method.:::options->getInitialOptions->graph->getOptions->compilationId->getOrCreateCompilationId->return->new->CompilationResult->compile
GraalCompilerTest#compile(ResolvedJavaMethod, StructuredGraph, CompilationResult, CompilationIdentifier, OptionValues):::Compiles a given method.:::graphToCompile->parseForCompile->debug->graphToCompile->getDebug->try->s->debug->scope->request->getProviders->getBackend->getDefaultGraphBuilderSuite->getOptimisticOptimizations->graphToCompile->getProfilingInfo->createSuites->createLIRSuites->new->Request<>->return->GraalCompiler->compile->catch->throw->debug->handle->finally
GraalCompilerTest#asResolvedJavaMethod(Executable):::Converts a reflection Method to a ResolvedJavaMethod.:::javaMethod->getMetaAccess->lookupJavaMethod->methodMap->put->return
GraalCompilerTest#lookupMethod(ResolvedJavaMethod):::Gets the reflection Method from which a given ResolvedJavaMethod was created or null if javaMethod does not correspond to a reflection method.:::return->methodMap->get
GraalCompilerTest#parseProfiled(String, AllowAssumptions):::Parses a Java method in GraphBuilderConfiguration#getDefault default mode to produce a graph.:::method->getResolvedJavaMethod->return->builder->getDefaultGraphBuilderSuite->parse
GraalCompilerTest#parseProfiled(ResolvedJavaMethod, AllowAssumptions):::Parses a Java method in GraphBuilderConfiguration#getDefault default mode to produce a graph.:::return->builder->getDefaultGraphBuilderSuite->parse
GraalCompilerTest#parseEager(String, AllowAssumptions):::Parses a Java method with GraphBuilderConfiguration#withEagerResolving(boolean) set to true to produce a graph.:::method->getResolvedJavaMethod->return->builder->getEagerGraphBuilderSuite->parse
GraalCompilerTest#parseEager(String, AllowAssumptions, OptionValues):::Parses a Java method with GraphBuilderConfiguration#withEagerResolving(boolean) set to true to produce a graph.:::method->getResolvedJavaMethod->return->builder->getEagerGraphBuilderSuite->parse
GraalCompilerTest#parseEager(ResolvedJavaMethod, AllowAssumptions):::Parses a Java method with GraphBuilderConfiguration#withEagerResolving(boolean) set to true to produce a graph.:::return->builder->getEagerGraphBuilderSuite->parse
GraalCompilerTest#parseEager(ResolvedJavaMethod, AllowAssumptions, OptionValues):::Parses a Java method with GraphBuilderConfiguration#withEagerResolving(boolean) set to true to produce a graph.:::return->builder->getEagerGraphBuilderSuite->parse
GraalCompilerTest#parseEager(ResolvedJavaMethod, AllowAssumptions, CompilationIdentifier, OptionValues):::Parses a Java method with GraphBuilderConfiguration#withEagerResolving(boolean) set to true to produce a graph.:::return->builder->getEagerGraphBuilderSuite->parse
GraalCompilerTest#getCancellable(ResolvedJavaMethod):::Gets the cancellable that should be associated with a graph being created by any of the parse...() methods.:::return
GraalCompilerTest#registerInvocationPlugins(InvocationPlugins):::Registers extra invocation plugins for this test:::invocationPlugins->new->InvocationPlugin->register->invocationPlugins->new->InvocationPlugin->register->invocationPlugins->new->InvocationPlugin->register
GraalCompilerTest#bytecodeParserShouldInlineInvoke(GraphBuilderContext, ResolvedJavaMethod, ValueNode[]):::Supplements BytecodeParserForceInline and BytecodeParserNeverInline in terms of allowing a test to influence the inlining decision made during bytecode parsing.:::return
GraalCompilerTest#branchProbability(double, boolean):::Inject a probability for a branch condition into the profiling information of this test case.:::return->GraalDirectives->injectBranchProbability
GraalCompilerTest#iterationCount(double, boolean):::Inject an iteration count for a loop condition into the profiling information of this test case.:::return->GraalDirectives->injectIterationCount
GraalCompilerTest#isArchitecture(String):::Test if the current test runs on the given platform:::return->name->backend->getTarget->getName->equals
InstalledCodeInvalidationTest#testInstalledCodeInvalidation():::Test that after uncommon trapping in an installed code it's still possible to invalidate all existing activations of that installed code.:::code->getMetaAccess->getMethod->lookupJavaMethod->getCode->code->executeVarargs
IntegerEqualsCanonicalizerTest#testShiftEquals():::Tests the canonicalization of (x >>> const) == 0 to x |test| (-1 << const).:::test
InterfaceMethodHandleTest#testInvokeInterface03():::Try to exercise a mixed calling sequence with regular JIT code calling a method handle that can't be inlined with an implementation compiled by Graal that throws an exception.:::goodInstance->new->A->badInstance->new->M2Thrower->getMetaAccess->getMethod->lookupJavaMethod->getCode->for->x
InterfaceMethodHandleTest.Gen#bytesForB():::Construct a type which claims to implement I but with incorrect access on I#m so that an exception must be thrown.:::cw->new->ClassWriter->mv->jvmName->NAME->replace->cw->new->StringArr->BASENAME->replace->visit->cw->visitMethod->mv->visitCode->l0->new->Label->mv->visitLabel->mv->visitVarInsn->mv->visitMethodInsn->mv->visitInsn->l1->new->Label->mv->visitLabel->mv->visitMaxs->mv->visitEnd->cw->visitMethod->mv->visitCode->new->Label->mv->visitLabel->mv->visitInsn->mv->visitInsn->new->Label->mv->visitLabel->mv->visitMaxs->mv->visitEnd->cw->visitEnd->cw->visitMethod->mv->visitCode->new->Label->mv->visitLabel->mv->visitInsn->mv->visitInsn->new->Label->mv->visitLabel->mv->visitMaxs->mv->visitEnd->cw->visitEnd->return->cw->toByteArray
MemoryArithmeticTest#before(ResolvedJavaMethod):::Called before a test is executed.:::method->reprofile
MemoryScheduleTest#testSimpleSnippet():::In this test the read should be scheduled before the write.:::try->return->catch->finally
MemoryScheduleTest#testSplit1Snippet(int):::In this case the read should be scheduled in the first block.:::try->return->catch->finally->if->else
MemoryScheduleTest#testSplit2Snippet(int):::Here the read should float to the end.:::try->return->catch->finally->if->else
MemoryScheduleTest#testLoop1Snippet(int, int):::Here the read should not float to the end.:::try->return->catch->finally->for->i->GraalDirectives->injectBranchProbability
MemoryScheduleTest#testLoop2Snippet(int, int):::Here the read should float to the end.:::try->return->catch->finally->for->i->GraalDirectives->injectBranchProbability
MemoryScheduleTest#testLoop3Snippet(int):::Here the read should float out of the loop.:::j->for->i->GraalDirectives->injectBranchProbability->return
MemoryScheduleTest#testLoop5Snippet(int, int, MemoryScheduleTest):::Here the read should float out of the loop.:::ret->bb->for->i->GraalDirectives->injectBranchProbability->return
MemoryScheduleTest#testLoop6Snippet(int, int, MemoryScheduleTest):::Here the read should not float out of the loop.:::ret->bb->for->i->GraalDirectives->injectBranchProbability->return
MemoryScheduleTest#testLoop7Snippet(int, int, MemoryScheduleTest):::Here the read should not float out of the loop.:::ret->bb->for->i->GraalDirectives->injectBranchProbability->return
MemoryScheduleTest#testLoop8Snippet(int, int):::Here the read should not float to the end.:::result->for->i->GraalDirectives->injectBranchProbability->GraalDirectives->controlFlowAnchor->return
MemoryScheduleTest#testLoop9Snippet(int, int):::Here the read should float after the loop.:::for->i->GraalDirectives->controlFlowAnchor->return
MemoryScheduleTest#testIfRead1Snippet(int):::Here the read should not float to the end.:::res->if->return
MemoryScheduleTest#testIfRead2Snippet(int):::Here the read should float in the else block.:::res->if->else->return
MemoryScheduleTest#testIfRead3Snippet(int):::Here the read should float to the end, right before the write.:::if->res->return
MemoryScheduleTest#testIfRead4Snippet(int):::Here the read should be just in the if branch (with the write).:::if->res->return->else->return
MemoryScheduleTest#testIfRead5Snippet(int):::Here the read should float to the end.:::if->return
MemoryScheduleTest#testBlockScheduleSnippet():::testing scheduling within a block.:::res->return
MemoryScheduleTest#testBlockSchedule2Snippet(int):::read should move inside the loop (out of loop is disabled).:::res->for->i->return
MergeCanonicalizerTest#getDefaultHighTierContext():::These tests assume all code paths are reachable so disable profile based dead code removal.:::return->getProviders->getDefaultGraphBuilderSuite->remove->new->HighTierContext
NewInstanceTest#test1():::Use a custom class loader to generate classes, substitute class names at the allocation site.:::checkGraph->loader1->new->ClassTemplateLoader->loader1->findClass->checkGraph->loader2->new->ClassTemplateLoader->loader2->findClass->checkGraph
ReflectionOptionDescriptors#extractEntries(Properties, String, boolean):::Extracts name/value entries from a set of properties based on a given name prefix.:::matches->EconomicMap->create->foreach->properties->entrySet->name->e->getKey->if->name->startsWith->value->e->getValue->if->name->prefix->length->substring->matches->put->return
VerifyDebugUsage#verifyDumpLevelParameter(StructuredGraph, MethodCallTargetNode, ResolvedJavaMethod, ValueNode):::The level arg for the Debug.dump(...) methods must be a reference to one of the Debug.*_LEVEL constants.:::c->arg->asConstant->if->dumpLevel->asInt->if->DebugLevels->contains->e->callerGraph->method->debugCallTarget->invoke->bci->asStackTraceElement->throw->verifiedCallee->format->new->VerificationError->return->e->callerGraph->method->debugCallTarget->invoke->bci->asStackTraceElement->throw->verifiedCallee->format->new->VerificationError
VerifyDebugUsage#verifyStructuredGraphDumping(StructuredGraph, MethodCallTargetNode, ResolvedJavaMethod, Integer):::Verifies that dumping a StructuredGraph at level DebugContext#BASIC_LEVEL or DebugContext#INFO_LEVEL only occurs in white-listed methods.:::if->e->callerGraph->method->debugCallTarget->invoke->bci->asStackTraceElement->qualifiedMethod->e->getClassName->e->getMethodName->if->BasicLevelStructuredGraphDumpWhitelist->contains->throw->verifiedCallee->format->getClass->getName->new->VerificationError->else->if->e->callerGraph->method->debugCallTarget->invoke->bci->asStackTraceElement->qualifiedMethod->e->getClassName->e->getMethodName->if->InfoLevelStructuredGraphDumpWhitelist->contains->throw->verifiedCallee->format->getClass->getName->new->VerificationError
