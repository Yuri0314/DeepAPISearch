AbstractParser#getToken(int):::Get the ith token.:::while->stream->last->if->stream->isFull->stream->grow->lexer->lexify->return->stream->get
AbstractParser#TokenType T(int):::Return the tokenType of the ith token.:::return->Token->getToken->descType
AbstractParser#next():::Seek next token that is not an EOL or comment.:::do->nextOrEOL->while->return
AbstractParser#nextOrEOL():::Seek next token or EOL (skipping comments.):::do->nextToken->if->checkDirectiveComment->while->return
AbstractParser#checkDirectiveComment()::: abstract parser check directive comment:::if->source->getExplicitURL->return->comment->lexer->getValueOf->len->comment->length->if->comment->substring->startsWith->source->comment->SOURCE_URL_PREFIX->length->substring->setExplicitURL
AbstractParser#nextToken():::Seek next token.:::if->if->lastToken->getToken->Token->descType->if->Token->descLength->if->Token->descLength->Token->descPosition->else->Token->descPosition->return
AbstractParser#message(String, String...):::Get the message string for a message ID and arguments:::return->ECMAErrors->getMessage
AbstractParser#error(String, long):::Report an error.:::return->error
AbstractParser#error(JSErrorType, String, long):::Report an error.:::position->Token->descPosition->lineNum->source->getLine->columnNum->source->getColumn->formatted->ErrorManager->format->return->new->ParserException
AbstractParser#error(String):::Report an error.:::return->error
AbstractParser#error(JSErrorType, String):::Report an error.:::position->Token->descPosition->column->formatted->ErrorManager->format->return->new->ParserException
AbstractParser#warning(JSErrorType, String, long):::Report a warning to the error manager.:::errors->error->warning
AbstractParser#expectMessage(TokenType):::Generate 'expected' message.:::tokenString->Token->toString->msg->if->AbstractParser->message->else->expectedName->expected->getNameOrType->AbstractParser->message->return
AbstractParser#expect(TokenType):::Check current token and advance to the next token.:::expectDontAdvance->next
AbstractParser#expectDontAdvance(TokenType):::Check current token, but don't advance to the next token.:::if->throw->expectMessage->error
AbstractParser#expectValue(TokenType):::Check next token, get its value and advance.:::if->throw->expectMessage->error->value->getValue->next->return
AbstractParser#getValue():::Get the value of the current token.:::return->getValue
AbstractParser#getValue(long):::Get the value of a specific token:::try->return->lexer->getValueOf->catch->errors->error->finally->return
AbstractParser#isNonStrictModeIdent():::Certain future reserved words can be used as identifiers in non-strict mode:::return->type->getKind
AbstractParser#getIdent():::Get ident.:::identToken->if->isNonStrictModeIdent->Token->recast->ident->getValue->next->return->createIdentNode->setIsFutureStrictName->ident->expectValue->if->return->return->createIdentNode
AbstractParser#createIdentNode(long, int, String):::Creates a new IdentNode as if invoked with a IdentNode#IdentNode(long, int, String) constructor but making sure that the name is deduplicated within this parse job.:::existingName->canonicalNames->putIfAbsent->canonicalName->return->new->IdentNode
AbstractParser#isIdentifierName():::Check if current token is in identifier name:::kind->type->getKind->if->return->if->switch->return->return->identToken->Token->recast->ident->getValue->return->ident->isEmpty->Character->ident->charAt->isJavaIdentifierStart
AbstractParser#getIdentifierName():::Create an IdentNode from the current token:::if->return->getIdent->else->if->isIdentifierName->identToken->Token->recast->ident->getValue->next->return->createIdentNode->else->expect->return
AbstractParser#getLiteral():::Create a LiteralNode from the current token:::literalToken->value->getValue->next->node->if->LiteralNode->newInstance->else->if->LiteralNode->newInstance->else->if->LiteralNode->newInstance->else->if->if->regex->try->RegExpFactory->regex->getExpression->regex->getOptions->validate->catch->throw->e->getMessage->error->finally->LiteralNode->newInstance->else->return
DateParser#parse():::Try parsing the given string as date according to the extended ISO 8601 format specified in ES5 15.9.1.15:::return->parseEcmaDate->parseLegacyDate
DateParser#parseEcmaDate():::Try parsing the date string according to the rules laid out in ES5 15.9.1.15:::if->next->while->switch->if->if->return->else->if->checkEcmaField->return->if->skipEcmaDelimiter->return->if->set->break->if->return->switch->if->return->break->if->equals->setTimezone->return->break->return->break->if->peek->return->if->else->if->readTimeZoneOffset->setTimezone->return->break->return->next->return->patchResult
DateParser#parseLegacyDate():::Try parsing the date using a fuzzy algorithm that can handle a variety of formats:::if->return->if->next->while->switch->if->skipDelimiter->if->setTimeField->return->do->next->if->setTimeField->return->while->isSet->skipDelimiter->else->if->setDateField->return->skipDelimiter->break->if->return->switch->if->setAmPm->return->break->if->setMonth->return->break->if->setTimezone->return->break->return->break->if->skipDelimiter->break->if->peek->return->if->readTimeZoneOffset->setTimezone->return->break->if->skipParentheses->return->break->break->return->next->return->patchResult
DateParser#getDateFields():::Get the parsed date and time fields as an array of Integers:::return
DateParser#isSet(int)::: date parser is set:::return
DateParser#get(int)::: date parser get:::return
DateParser#set(int, int)::: date parser set:::
DateParser#peek()::: date parser peek:::return->string->charAt
DateParser#skipNumberDelimiter(char)::: date parser skip number delimiter:::if->string->charAt->Character->string->charAt->getType->return->return
DateParser#skipDelimiter(char)::: date parser skip delimiter:::if->string->charAt->return->return
DateParser#next()::: date parser next:::if->return->c->string->charAt->if->return->type->Character->getType->switch->readNumber->return->return->readName->return->switch->return->return->return
DateParser#checkLegacyField(int, int)::: date parser check legacy field:::switch->return->isHour->return->isMinuteOrSecond->return->isMillisecond->return
DateParser#checkEcmaField(int, int)::: date parser check ecma field:::switch->return->return->isMonth->return->isDay->return->isHour->return->isMinuteOrSecond->return->isMillisecond->return
DateParser#skipEcmaDelimiter()::: date parser skip ecma delimiter:::switch->return->skipNumberDelimiter->peek->peek->return->peek->peek->return->skipNumberDelimiter->endOfTime->return->skipNumberDelimiter->endOfTime->return
DateParser#endOfTime()::: date parser end of time:::c->peek->return
DateParser#isAsciiLetter(char)::: date parser is ascii letter:::return
DateParser#isAsciiDigit(char)::: date parser is ascii digit:::return
DateParser#readNumber(int)::: date parser read number:::start->n->max->Math->min->while->string->charAt->isAsciiDigit->string->charAt->return
DateParser#readName()::: date parser read name:::start->limit->Math->min->while->string->charAt->isAsciiLetter->key->string->substring->toLowerCase->name->names->get->while->string->charAt->isAsciiLetter->if->name->matches->return->return
DateParser#readTimeZoneOffset()::: date parser read time zone offset:::sign->string->charAt->offset->readNumber->skipDelimiter->readNumber->return
DateParser#skipParentheses()::: date parser skip parentheses:::parenCount->while->c->string->charAt->if->else->if->return
DateParser#getDefaultValue(int)::: date parser get default value:::switch->return->return
DateParser#isDay(int)::: date parser is day:::return
DateParser#isMonth(int)::: date parser is month:::return
DateParser#isHour(int)::: date parser is hour:::return
DateParser#isMinuteOrSecond(int)::: date parser is minute or second:::return
DateParser#isMillisecond(int)::: date parser is millisecond:::return
DateParser#setMonth(int)::: date parser set month:::if->isSet->set->return->return
DateParser#setDateField(int)::: date parser set date field:::for->field->return
DateParser#setTimeField(int)::: date parser set time field:::for->field->return
DateParser#setTimezone(int, boolean)::: date parser set timezone:::if->isSet->get->set->return->return
DateParser#setAmPm(int)::: date parser set am pm:::if->isSet->return->hour->get->if->set->return
DateParser#patchResult(boolean)::: date parser patch result:::if->isSet->isSet->return->if->isSet->isSet->return->for->field->if->if->get->isDay->d->get->get->set->if->set->else->d2->get->set->set->if->get->isMonth->get->isDay->return->year->get->if->set->else->if->get->get->get->get->return->get->set->return
DateParser#addName(String, int, int)::: date parser add name:::name->new->Name->names->put
DateParser.Name#matches(String, int, int)::: name matches:::return->name->regionMatches
DateParser.Name#toString()::: name to string:::return
JSONParser#quote(String):::Implementation of the Quote(value) operation as defined in the ECMAscript spec:::product->new->StringBuilder->product->append->foreach->value->toCharArray->switch->product->append->break->product->append->break->product->append->break->product->append->break->product->append->break->product->append->break->product->append->break->if->product->Lexer->unicodeEscape->append->break->product->append->break->product->append->return->product->toString
JSONParser#parse():::Public parse method:::value->parseLiteral->skipWhiteSpace->if->throw->peek->toString->expectedError->return
JSONParser#parseLiteral()::: parser parse literal:::skipWhiteSpace->c->peek->if->throw->expectedError->switch->return->parseObject->return->parseArray->return->parseString->return->parseKeyword->return->parseKeyword->return->parseKeyword->if->isDigit->return->parseNumber->else->if->throw->numberError->else->throw->toString->expectedError
JSONParser#parseObject()::: parser parse object:::propertyMap->JD->getInitialMap->JO->getInitialMap->arrayData->values->new->ArrayList<>->state->while->skipWhiteSpace->c->peek->switch->if->throw->toString->expectedError->id->parseString->expectColon->value->parseLiteral->index->ArrayIndex->getArrayIndex->if->ArrayIndex->isValidArrayIndex->addArrayElement->else->addObjectProperty->break->if->throw->AbstractParser->message->error->break->if->throw->AbstractParser->message->error->return->createObject->throw->toString->expectedError->throw->expectedError
JSONParser#addArrayElement(ArrayData, int, Object)::: parser add array element:::oldLength->arrayData->length->longIndex->ArrayIndex->toLongIndex->newArrayData->if->newArrayData->ensure->if->newArrayData->delete->return->newArrayData->set
JSONParser#addObjectProperty(PropertyMap, List, String, Object)::: parser add object property:::oldProperty->propertyMap->findProperty->newMap->type->flags->if->getType->else->if->values->oldProperty->getSlot->set->propertyMap->oldProperty->getSlot->new->SpillProperty->replaceProperty->else->values->add->propertyMap->propertyMap->size->new->SpillProperty->addProperty->return
JSONParser#createObject(PropertyMap, List, ArrayData)::: parser create object:::primitiveSpill->values->size->new->longArr->objectSpill->values->size->new->ObjectArr->foreach->propertyMap->getProperties->if->property->getType->values->property->getSlot->get->property->getSlot->else->ObjectClassGenerator->values->property->getSlot->get->pack->property->getSlot->object->new->JD->new->JO->object->global->getObjectPrototype->setInitialProto->object->setArray->return
JSONParser#getType(Object)::: parser get type:::if->return->else->if->return->else->return
JSONParser#expectColon()::: parser expect colon:::skipWhiteSpace->n->next->if->throw->toString->expectedError
JSONParser#parseArray()::: parser parse array:::arrayData->state->while->skipWhiteSpace->c->peek->switch->if->throw->AbstractParser->message->error->break->if->throw->AbstractParser->message->error->return->global->wrapAsObject->if->throw->toString->expectedError->index->arrayData->length->arrayData->ensure->parseLiteral->set->break->throw->expectedError
JSONParser#parseString()::: parser parse string:::start->sb->while->c->next->if->throw->syntaxError->else->if->if->new->StringBuilder->sb->append->sb->parseEscapeSequence->append->else->if->if->sb->append->return->sb->toString->return->source->substring->throw->Lexer->message->error
JSONParser#parseEscapeSequence()::: parser parse escape sequence:::c->next->switch->return->return->return->return->return->return->return->return->return->parseUnicodeEscape->throw->Lexer->message->error
JSONParser#parseUnicodeEscape()::: parser parse unicode escape:::return->parseHexDigit->parseHexDigit->parseHexDigit->parseHexDigit
JSONParser#parseHexDigit()::: parser parse hex digit:::c->next->if->return->else->if->return->else->if->return->throw->Lexer->message->error
JSONParser#isDigit(int)::: parser is digit:::return
JSONParser#skipDigits()::: parser skip digits:::while->c->peek->if->isDigit->break
JSONParser#parseNumber()::: parser parse number:::start->c->next->if->next->if->isDigit->throw->numberError->if->skipDigits->if->peek->if->next->isDigit->throw->numberError->skipDigits->peek->if->next->if->next->if->isDigit->throw->numberError->skipDigits->d->Double->source->substring->parseDouble->if->JSType->isRepresentableAsInt->return->return
JSONParser#parseKeyword(String, Object)::: parser parse keyword:::if->source->keyword->length->regionMatches->throw->expectedError->keyword->length->return
JSONParser#peek()::: parser peek:::if->return->return->source->charAt
JSONParser#next()::: parser next:::next->peek->return
JSONParser#skipWhiteSpace()::: parser skip white space:::while->switch->peek->break->return
JSONParser#toString(int)::: parser to string:::return->String->valueOf
JSONParser#error(String, int, int)::: parser error:::token->Token->toDesc->pos->Token->descPosition->src->Source->sourceFor->lineNum->src->getLine->columnNum->src->getColumn->formatted->ErrorManager->format->return->new->ParserException
JSONParser#error(String, int)::: parser error:::return->error
JSONParser#numberError(int)::: parser number error:::return->Lexer->message->error
JSONParser#expectedError(int, String, String)::: parser expected error:::return->AbstractParser->message->error
JSONParser#syntaxError(int, String)::: parser syntax error:::message->ECMAErrors->getMessage->return->error
Lexer#unicodeEscape(char)::: lexer unicode escape:::sb->new->StringBuilder->sb->append->hex->Integer->toHexString->for->i->hex->length->sb->append->return->sb->toString
Lexer#saveState():::Save the state of the scan.:::return->new->State
Lexer#restoreState(State):::Restore the state of the scan.:::super->restoreState
Lexer#add(TokenType, int, int):::Add a new token to the stream.:::if->else->if->stream->Token->toDesc->put->stream->Token->toDesc->put
Lexer#add(TokenType, int):::Add a new token to the stream.:::add
Lexer#getWhitespaceRegExp():::Return the String of valid whitespace characters for regular expressions in JavaScript:::return
Lexer#skipEOL(boolean):::Skip end of line.:::if->skip->if->skip->else->skip->if->add
Lexer#skipLine(boolean):::Skip over rest of line including end of line.:::while->isEOL->atEOF->skip->skipEOL
Lexer#isJSWhitespace(char):::Test whether a char is valid JavaScript whitespace:::return->isOtherJSWhitespace
Lexer#isOtherJSWhitespace(char)::: lexer is other whitespace:::return->JAVASCRIPT_OTHER_WHITESPACE->indexOf
Lexer#isJSEOL(char):::Test whether a char is valid JavaScript end of line:::return
Lexer#isStringDelimiter(char):::Test if char is a string delimiter, e.g:::return
Lexer#isTemplateDelimiter(char):::Test if char is a template literal delimiter ('`').:::return
Lexer#isWhitespace(char):::Test whether a char is valid JavaScript whitespace:::return->Lexer->isJSWhitespace
Lexer#isEOL(char):::Test whether a char is valid JavaScript end of line:::return->Lexer->isJSEOL
Lexer#skipWhitespace(boolean):::Skip over whitespace and detect end of line, adding EOL tokens if encountered.:::while->isWhitespace->if->isEOL->skipEOL->else->skip
Lexer#skipComments():::Skip over comments.:::start->if->if->skip->directiveComment->if->while->atEOF->isEOL->skip->add->return->else->if->skip->while->atEOF->if->isEOL->skipEOL->else->skip->if->atEOF->add->else->skip->add->return->else->if->skip->while->atEOF->isEOL->skip->add->return->return
Lexer#valueOfPattern(int, int):::Convert a regex token to a token object.:::savePosition->reset->sb->new->StringBuilder->skip->inBrackets->while->atEOF->isEOL->if->sb->append->sb->append->skip->else->if->else->if->sb->append->skip->regex->sb->toString->skip->options->source->scanIdentifier->getString->reset->return->new->RegexToken
Lexer#canStartLiteral(TokenType):::Return true if the given token can be the beginning of a literal.:::return->token->startsWith->token->startsWith
Lexer.LineInfoReceiver#lineInfo(int, int):::Receives line information:::
Lexer#scanLiteral(long, TokenType, LineInfoReceiver):::Check whether the given token represents the beginning of a literal:::if->canStartLiteral->return->if->stream->stream->last->get->return->state->saveState->Token->descPosition->reset->if->return->scanRegEx->else->if->if->return->scanHereString->else->if->Character->isJavaIdentifierStart->return->scanXMLLiteral->return
Lexer#scanRegEx():::Scan over regex literal.:::if->start->skip->inBrackets->while->atEOF->isEOL->if->skip->if->isEOL->reset->return->skip->else->if->else->if->skip->if->skip->while->atEOF->Character->isJavaIdentifierPart->skip->add->return->reset->return
Lexer#convertDigit(char, int):::Convert a digit to a integer:::digit->if->else->if->else->if->else->return->return
Lexer#hexSequence(int, TokenType):::Get the value of a hexadecimal numeric sequence.:::value->for->i->return
Lexer#octalSequence():::Get the value of an octal numeric sequence:::value->for->i->return
Lexer#valueOfIdent(int, int):::Convert a string to a JavaScript identifier.:::savePosition->end->reset->sb->new->StringBuilder->while->atEOF->isEOL->if->skip->ch->hexSequence->sb->append->else->sb->append->skip->reset->return->sb->toString
Lexer#scanIdentifierOrKeyword():::Scan over and identifier or keyword:::start->length->scanIdentifier->type->TokenLookup->lookupKeyword->if->add
Lexer#valueOfString(int, int, boolean):::Convert a string to a JavaScript string object.:::savePosition->end->reset->sb->new->StringBuilder->while->if->skip->next->afterSlash->skip->switch->if->if->Lexer->message->error->reset->ch->octalSequence->if->sb->append->sb->append->else->sb->append->break->sb->append->break->sb->append->break->sb->append->break->sb->append->break->sb->append->break->sb->append->break->sb->append->break->sb->append->break->if->skip->break->ch->hexSequence->if->sb->append->sb->append->else->sb->append->break->ch->hexSequence->if->sb->append->sb->append->else->sb->append->break->sb->append->break->sb->append->break->else->if->sb->append->skip->else->sb->append->skip->reset->return->sb->toString
Lexer#scanString(boolean):::Scan over a string literal.:::type->quote->skip->stringState->saveState->while->atEOF->isEOL->if->skip->if->isEOL->skipEOL->continue->skip->if->skip->else->Lexer->message->error->if->stringState->setLimit->if->stringState->isEmpty->switch->add->add->editString->add->break->editString->break->add->break->break->else->add
Lexer#scanTemplate():::Scan over a template string literal.:::type->skip->stringState->saveState->while->atEOF->if->skip->stringState->setLimit->add->return->else->if->skip->stringState->setLimit->add->expressionLexer->saveState->new->Lexer->expressionLexer->lexify->expressionLexer->saveState->restoreState->skip->saveState->continue->else->if->skip->if->isEOL->skipEOL->continue->else->if->isEOL->skipEOL->continue->skip->Lexer->message->error
Lexer#valueOf(String, int):::Convert string to number.:::try->return->Integer->parseInt->catch->if->return->Double->valueOf->value->for->i->valueString->length->return->finally
Lexer#scanNumber():::Scan a number.:::start->type->digit->convertDigit->if->convertDigit->skip->while->convertDigit->skip->else->if->convertDigit->skip->while->convertDigit->skip->else->if->convertDigit->skip->while->convertDigit->skip->else->octal->if->skip->while->convertDigit->skip->if->else->if->if->skip->while->convertDigit->skip->if->skip->if->skip->while->convertDigit->skip->if->Character->isJavaIdentifierStart->Lexer->message->error->add
Lexer#valueOfXML(int, int):::Convert a regex token to a token object.:::return->source->getString->new->XMLToken
Lexer#scanXMLLiteral():::Scan over a XML token.:::if->start->openCount->do->if->if->Character->isJavaIdentifierStart->skip->else->if->Character->isJavaIdentifierStart->skip->else->if->skip->else->if->skip->else->reset->return->while->atEOF->if->skip->break->else->if->scanString->else->skip->if->reset->return->skip->else->if->atEOF->reset->return->else->skip->while->add->return->return
Lexer#scanIdentifier():::Scan over identifier characters.:::start->if->skip->ch->hexSequence->if->Character->isJavaIdentifierStart->Lexer->message->error->else->if->Character->isJavaIdentifierStart->return->while->atEOF->if->skip->ch->hexSequence->if->Character->isJavaIdentifierPart->Lexer->message->error->else->if->Character->isJavaIdentifierPart->skip->else->break->return
Lexer#identifierEqual(int, int, int, int):::Compare two identifiers (in content) for equality.:::if->for->i->return->return
Lexer#hasHereMarker(int, int):::Detect if a line starts with a marker identifier.:::skipWhitespace->return->scanIdentifier->identifierEqual
Lexer.EditStringLexer#lexify():::Lexify the contents of the string.:::stringStart->primed->while->if->atEOF->break->if->skip->continue->if->if->if->add->add->skip->expressionState->saveState->braceCount->while->atEOF->if->if->break->else->if->skip->if->Lexer->message->error->expressionState->setLimit->skip->add->add->lexer->new->Lexer->lexer->lexify->add->continue->skip->if->if->add->add
Lexer#editString(TokenType, State):::Edit string for nested expressions.:::lexer->new->EditStringLexer->lexer->lexify
Lexer#scanHereString(LineInfoReceiver, State):::Scan over a here string.:::if->saved->saveState->excludeLastEOL->if->skip->else->skip->quoteChar->noStringEditing->if->skip->identStart->identLength->scanIdentifier->if->if->Lexer->message->error->restoreState->return->skip->if->restoreState->return->restState->saveState->lastLine->skipLine->lastLinePosition->restState->setLimit->if->restoreState->skipLine->stringState->saveState->stringEnd->while->atEOF->skipWhitespace->if->hasHereMarker->break->skipLine->lir->lineInfo->stringState->setLimit->if->stringState->isEmpty->atEOF->Lexer->source->getString->message->error->restoreState->return->if->if->if->stringState->setLimit->if->stringState->isEmpty->editString->else->add->restLexer->new->Lexer->restLexer->lexify->return->return
Lexer#lexify():::Breaks source content down into lex units, adding tokens to the token stream:::while->stream->isFull->skipWhitespace->if->atEOF->if->add->break->if->skipComments->continue->if->skipComments->continue->type->if->convertDigit->scanNumber->else->if->TokenLookup->lookupOperator->if->if->else->if->if->break->typeLength->type->getLength->skip->add->if->canStartLiteral->break->else->if->break->else->if->Character->isJavaIdentifierStart->scanIdentifierOrKeyword->else->if->isStringDelimiter->scanString->else->if->Character->isDigit->scanNumber->else->if->isTemplateDelimiter->scanTemplate->else->if->isTemplateDelimiter->scanString->else->skip->add
Lexer#getValueOf(long, boolean):::Return value of token given its token descriptor.:::start->Token->descPosition->len->Token->descLength->switch->Token->descType->return->Lexer->source->getString->valueOf->return->Lexer->source->getString->valueOf->return->Lexer->source->getString->valueOf->return->Lexer->source->getString->valueOf->return->Lexer->source->getString->valueOf->str->source->getString->value->Double->valueOf->if->str->indexOf->return->if->JSType->isStrictlyRepresentableAsInt->return->return->return->source->getString->return->valueOfString->return->valueOfIdent->return->valueOfPattern->return->valueOfString->return->valueOfXML->return->source->getString->break->return
Lexer#valueOfRawString(long):::Get the raw string value of a template literal string part.:::start->Token->descPosition->length->Token->descLength->savePosition->end->reset->sb->new->StringBuilder->while->if->sb->append->skip->else->sb->append->skip->reset->return->sb->toString
Lexer#message(String, String...):::Get the correctly localized error message for a given message id format arguments:::return->ECMAErrors->getMessage
Lexer#error(String, TokenType, int, int):::Generate a runtime exception:::token->Token->toDesc->pos->Token->descPosition->lineNum->source->getLine->columnNum->source->getColumn->formatted->ErrorManager->format->throw->new->ParserException
Lexer.LexerToken#getExpression():::Get the expression:::return
Lexer.RegexToken#getOptions():::Get regexp options:::return
Lexer.RegexToken#toString()::: regex token to string:::return->getExpression
Parser#getLogger()::: parser get logger:::return
Parser#initLogger(Context)::: parser init logger:::return->context->this->getClass->getLogger
Parser#setFunctionName(String):::Sets the name for the first function:::defaultNames->createIdentNode->push
Parser#setReparsedFunction(RecompilableScriptFunctionData):::Sets the RecompilableScriptFunctionData representing the function being reparsed (when this parser instance is used to reparse a previously parsed function, as part of its on-demand compilation):::
Parser#parse():::Execute parse and return the resulting function node:::return->PROGRAM->symbolName->source->getLength->parse
Parser#scanFirstToken():::Set up first token:::next
Parser#parse(String, int, int, int):::Execute parse and return the resulting function node:::isTimingEnabled->env->isTimingEnabled->t0->System->nanoTime->log->info->try->new->TokenStream->new->Lexer->scanFirstToken->return->program->catch->handleParseException->return->finally->end->if->toString->System->nanoTime->accumulateTime->log->Timing->System->nanoTime->toMillisPrint->info->else->log->info
Parser#parseModule(String, int, int):::Parse and return the resulting module:::try->new->TokenStream->new->Lexer->scanFirstToken->return->module->catch->handleParseException->return->finally
Parser#parseModule(String):::Entry point for parsing a module.:::return->source->getLength->parseModule
Parser#parseFormalParameterList():::Parse and return the list of function parameter list:::try->new->TokenStream->new->Lexer->scanFirstToken->return->formalParameterList->catch->handleParseException->return->finally
Parser#parseFunctionBody():::Execute parse and return the resulting function node:::try->new->TokenStream->new->Lexer->functionLine->scanFirstToken->functionToken->Token->source->getLength->toDesc->ident->Token->descPosition->PROGRAM->symbolName->new->IdentNode->function->Collections->emptyList->createParserContextFunctionNode->lc->push->body->newBlock->new->ArrayList<>->sourceElements->addFunctionDeclarations->restoreBlock->body->setFlag->functionBody->source->getLength->body->getFlags->body->getStatements->new->Block->lc->pop->expect->functionNode->Collections->emptyList->createFunctionNode->printAST->return->catch->handleParseException->return->finally
Parser#handleParseException(Exception)::: parser handle parse exception:::message->e->getMessage->if->e->toString->if->errors->error->else->errors->error->if->e->env->getErr->printStackTrace
Parser#recover(Exception):::Skip to a good parsing recovery point.:::if->message->e->getMessage->if->e->toString->if->errors->error->else->errors->error->if->e->env->getErr->printStackTrace->while->switch->break->next->break->nextOrEOL->break
Parser#newBlock():::Set up a new block.:::return->lc->new->ParserContextBlockNode->push
Parser#createParserContextFunctionNode(IdentNode, long, FunctionNode.Kind, int, List)::: parser create parser context function node:::sb->new->StringBuilder->parentFunction->lc->getCurrentFunction->if->parentFunction->isProgram->sb->parentFunction->getName->append->symbolName->append->sb->ident->getName->append->name->namespace->sb->toString->uniqueName->flags->if->if->functionNode->new->ParserContextFunctionNode->functionNode->setFlag->return
Parser#createFunctionNode(ParserContextFunctionNode, long, IdentNode, List, FunctionNode.Kind, int, Block)::: parser create function node:::functionNode->body->getToken->Token->body->getToken->descPosition->function->getLastToken->function->getName->function->getParameterExpressions->function->getFlags->function->getEndParserState->function->getModule->function->getDebugFlags->new->FunctionNode->printAST->return
Parser#restoreBlock(ParserContextBlockNode):::Restore the current block.:::return->lc->pop
Parser#getBlock(boolean):::Get the statements in a block.:::blockToken->newBlock->newBlock->try->if->expect->statementList->catch->finally->restoreBlock->if->expect->flags->newBlock->getFlags->return->newBlock->getStatements->new->Block
Parser#getStatement():::Get all the statements generated by a single statement.:::return->getStatement
Parser#getStatement(boolean)::: parser get statement:::if->return->getBlock->newBlock->newBlock->try->statement->catch->finally->restoreBlock->return->newBlock->getToken->newBlock->getFlags->newBlock->getStatements->new->Block
Parser#detectSpecialFunction(IdentNode):::Detect calls to special functions.:::name->ident->getName->if->EVAL->symbolName->equals->markEval->else->if->SUPER->getName->equals->markSuperCall
Parser#detectSpecialProperty(IdentNode):::Detect use of special properties.:::if->isArguments->getCurrentNonArrowFunction->setFlag
Parser#useBlockScope()::: parser use block scope:::return
Parser#isES6()::: parser is s6:::return
Parser#isArguments(String)::: parser is arguments:::return->ARGUMENTS_NAME->equals
Parser#isArguments(IdentNode)::: parser is arguments:::return->ident->getName->isArguments
Parser#checkIdentLValue(IdentNode):::Tells whether a IdentNode can be used as L-value of an assignment:::return->ident->tokenType->getKind
Parser#verifyAssignment(long, Expression, Expression):::Verify an assignment expression.:::opType->Token->descType->switch->if->if->checkIdentLValue->return->referenceError->verifyIdent->break->else->if->break->else->if->isDestructuringLhs->verifyDestructuringAssignmentPattern->break->else->return->referenceError->break->if->BinaryNode->isLogical->return->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->BinaryNode->return->new->BinaryNode
Parser#isDestructuringLhs(Expression)::: parser is destructuring lhs:::if->return->isES6->return
Parser#verifyDestructuringAssignmentPattern(Expression, String)::: parser verify destructuring assignment pattern:::pattern->new->LexicalContext->new->VerifyDestructuringPatternNodeVisitor->accept
Parser#incDecExpression(long, TokenType, Expression, boolean):::Reduce increment/decrement to simpler operations.:::if->return->Token->recast->expression->getStart->Token->descPosition->Token->descLength->new->UnaryNode->return->new->UnaryNode
Parser#program(String, int):::Program :      SourceElements?  See 14  Parse the top level script.:::functionToken->Token->Token->Token->withDelimiter->descPosition->source->getLength->toDesc->functionLine->ident->Token->descPosition->new->IdentNode->script->Collections->emptyList->createParserContextFunctionNode->lc->push->body->newBlock->new->ArrayList<>->sourceElements->addFunctionDeclarations->restoreBlock->body->setFlag->programBody->body->getFlags->body->getStatements->new->Block->lc->pop->script->setLastToken->expect->return->Collections->emptyList->createFunctionNode
Parser#getDirective(Node):::Directive value or null if statement is not a directive.:::if->expr->getExpression->if->lit->litToken->lit->getToken->tt->Token->descType->if->return->source->lit->getStart->Token->descLength->getString->return
Parser#sourceElements(int):::SourceElements :      SourceElement      SourceElements SourceElement  See 14  Parse the elements of the script or function.:::directiveStmts->checkDirective->functionFlags->oldStrictMode->try->while->if->break->try->statement->if->lastStatement->lc->getLastStatement->directive->getDirective->if->if->if->new->ArrayList<>->directiveStmts->add->if->equals->function->lc->getCurrentFunction->function->setFlag->if->foreach->statement->getToken->getValue->function->getIdent->verifyIdent->foreach->function->getParameters->verifyIdent->else->if->debugFlag->FunctionNode->getDirectiveFlag->if->function->lc->getCurrentFunction->function->setDebugFlag->catch->errorLine->errorToken->recover->errorExpr->new->ErrorNode->expressionStatement->new->ExpressionStatement->appendStatement->finally->stream->commit->catch->finally
Parser#statement():::Parse any of the basic statement types:::statement
Parser#statement(boolean, int, boolean, boolean)::: parser statement:::switch->block->break->variableStatement->break->emptyStatement->break->ifStatement->break->forStatement->break->whileStatement->break->doStatement->break->continueStatement->break->breakStatement->break->returnStatement->break->withStatement->break->switchStatement->break->throwStatement->break->tryStatement->break->debuggerStatement->break->expect->break->if->if->throw->AbstractParser->message->error->functionExpression->return->if->useBlockScope->lookaheadIsLetDeclaration->if->throw->AbstractParser->type->getName->message->error->variableStatement->break->else->if->isES6->if->throw->AbstractParser->message->error->classDeclaration->break->if->variableStatement->break->if->isNonStrictModeIdent->if->T->labelStatement->return->if->ident->getValue->propertyToken->propertyLine->if->GET_NAME->equals->next->propertyGetterFunction->addPropertyFunctionStatement->return->else->if->SET_NAME->equals->next->propertySetterFunction->addPropertyFunctionStatement->return->if->isNonStrictModeIdent->ident->getValue->propertyToken->propertyLine->propertyKey->propertyName->flags->CONSTRUCTOR_NAME->equals->propertyMethodFunction->addPropertyFunctionStatement->return->expressionStatement->break
Parser#addPropertyFunctionStatement(PropertyFunction)::: parser add property function statement:::fn->functionDeclarations->fn->getLineNumber->fn->getToken->new->ExpressionStatement->add
Parser#classDeclaration(boolean):::ClassDeclaration[Yield, Default] :   class BindingIdentifier[?Yield] ClassTail[?Yield]   [+Default] class ClassTail[?Yield]:::classLineNumber->classExpression->classExpression->if->classVar->classExpression->getToken->classExpression->getIdent->getFinish->classExpression->getIdent->new->VarNode->appendStatement->return
Parser#classExpression(boolean):::ClassExpression[Yield] :   class BindingIdentifier[?Yield]opt ClassTail[?Yield]:::classLineNumber->classToken->next->className->if->getIdent->return->classTail
Parser.ClassElementKey#hashCode()::: class element key hash code:::prime->result->propertyName->hashCode->return
Parser.ClassElementKey#equals(Object)::: class element key equals:::if->other->return->Objects->equals->return
Parser#classTail(int, long, IdentNode, boolean):::Parse ClassTail and ClassBody:::oldStrictMode->try->classHeritage->if->next->leftHandSideExpression->expect->constructor->classElements->new->ArrayList<>->keyToIndexMap->new->HashMap<>->for->lastToken->expect->if->createDefaultClassConstructor->classElements->trimToSize->return->new->ClassNode->catch->finally
Parser#createDefaultClassConstructor(int, long, long, IdentNode, boolean)::: parser create default class constructor:::ctorFinish->statements->parameters->identToken->Token->recast->if->superIdent->SUPER->getName->createIdentNode->setIsDirectSuper->argsIdent->createIdentNode->setIsRestParameter->spreadArgs->Token->recast->new->UnaryNode->superCall->Collections->singletonList->new->CallNode->Collections->new->ExpressionStatement->singletonList->Collections->singletonList->else->Collections->emptyList->Collections->emptyList->body->new->Block->ctorName->createIdentNode->function->createParserContextFunctionNode->function->setLastToken->function->setFlag->function->setFlag->if->function->setFlag->function->setFlag->if->function->setFlag->constructor->createFunctionNode->new->PropertyNode->return
Parser#methodDefinition(boolean, boolean, boolean)::: parser method definition:::methodToken->methodLine->computed->isIdent->propertyName->propertyName->flags->if->name->getPropertyName->if->name->equals->methodDefinition->propertyGetterFunction->verifyAllowedMethodName->return->new->PropertyNode->else->if->name->equals->methodDefinition->propertySetterFunction->verifyAllowedMethodName->return->new->PropertyNode->else->if->name->equals->if->verifyAllowedMethodName->methodDefinition->propertyMethodFunction->return->new->PropertyNode
Parser#verifyAllowedMethodName(Expression, boolean, boolean, boolean, boolean):::ES6 14.5.1 Static Semantics: Early Errors.:::if->if->getPropertyName->equals->throw->AbstractParser->message->key->getToken->error->if->getPropertyName->equals->throw->AbstractParser->message->key->getToken->error->if->getPropertyName->equals->throw->AbstractParser->message->key->getToken->error
Parser#block():::block :      { StatementList? }  see 12.1  Parse a statement block.:::getBlock->new->BlockStatement->appendStatement
Parser#statementList():::StatementList :      Statement      StatementList Statement  See 12.1  Parse a list of statements.:::while->switch->break->break->statement
Parser#verifyIdent(IdentNode, String):::Make sure that the identifier name used is allowed.:::verifyStrictIdent->checkEscapedKeyword
Parser#verifyStrictIdent(IdentNode, String):::Make sure that in strict mode, the identifier name used is allowed.:::if->switch->ident->getName->throw->AbstractParser->ident->getName->message->ident->getToken->error->break->if->ident->isFutureStrictName->throw->AbstractParser->ident->getName->message->ident->getToken->error
Parser#checkEscapedKeyword(IdentNode):::ES6 11.6.2: A code point in a ReservedWord cannot be expressed by a | UnicodeEscapeSequence.:::if->isES6->ident->containsEscapes->tokenType->TokenLookup->ident->getName->toCharArray->ident->getName->length->lookupKeyword->if->tokenType->getKind->throw->AbstractParser->message->ident->getToken->error
Parser#variableStatement(TokenType)::: parser variable statement:::variableDeclarationList
Parser.ForVariableDeclarationListResult#recordMissingAssignment(Expression)::: for variable declaration list result record missing assignment:::if
Parser.ForVariableDeclarationListResult#recordDeclarationWithInitializer(long)::: for variable declaration list result record declaration with initializer:::if
Parser.ForVariableDeclarationListResult#addBinding(Expression)::: for variable declaration list result add binding:::if->else->if
Parser.ForVariableDeclarationListResult#addAssignment(Expression)::: for variable declaration list result add assignment:::if->else->Token->init->getToken->recast->new->BinaryNode
Parser#variableDeclarationList(TokenType, boolean, int)::: parser variable declaration list:::varLine->varToken->next->varFlags->if->else->if->forResult->new->ForVariableDeclarationListResult->while->if->inGeneratorFunction->expect->contextString->binding->bindingIdentifierOrPattern->isDestructuring->if->finalVarFlags->new->Consumer<IdentNode>->verifyDestructuringBindingPattern->init->if->if->forResult->recordDeclarationWithInitializer->next->if->defaultNames->push->try->assignmentExpression->catch->finally->if->defaultNames->pop->else->if->if->throw->AbstractParser->message->error->else->if->throw->AbstractParser->getName->message->error->if->ident->if->ident->getName->equals->throw->AbstractParser->message->error->name->ident->setIsDeclaredHere->if->if->forResult->recordMissingAssignment->forResult->new->IdentNode->addBinding->var->new->VarNode->appendStatement->else->if->assignment->Token->recast->verifyAssignment->if->assignment->getToken->new->ExpressionStatement->appendStatement->else->forResult->addAssignment->forResult->addBinding->else->if->forResult->recordMissingAssignment->forResult->addBinding->if->break->next->if->endOfLine->return
Parser#isBindingIdentifier()::: parser is binding identifier:::return->isNonStrictModeIdent
Parser#bindingIdentifier(String)::: parser binding identifier:::name->getIdent->verifyIdent->return
Parser#bindingPattern()::: parser binding pattern:::if->return->arrayLiteral->else->if->return->objectLiteral->else->throw->AbstractParser->message->error
Parser#bindingIdentifierOrPattern(String)::: parser binding identifier or pattern:::if->isBindingIdentifier->isES6->return->bindingIdentifier->else->return->bindingPattern
Parser.VerifyDestructuringPatternNodeVisitor#enterLiteralNode(LiteralNode)::: verify destructuring pattern node visitor enter literal node:::if->literalNode->isArray->if->hasSpread->hasTrailingComma->throw->literalNode->getElementExpressions->literalNode->getElementExpressions->size->get->getToken->error->restElement->foreach->literalNode->getElementExpressions->if->if->throw->element->getToken->error->if->element->isTokenType->lvalue->getExpression->verifySpreadElement->element->accept->return->else->return->enterDefault
Parser.VerifyDestructuringPatternNodeVisitor#verifySpreadElement(Expression)::: verify destructuring pattern node visitor verify spread element:::
Parser.VerifyDestructuringPatternNodeVisitor#enterObjectNode(ObjectNode)::: verify destructuring pattern node visitor enter object node:::return
Parser.VerifyDestructuringPatternNodeVisitor#enterPropertyNode(PropertyNode)::: verify destructuring pattern node visitor enter property node:::if->propertyNode->getValue->propertyNode->getValue->accept->return->else->return->enterDefault
Parser.VerifyDestructuringPatternNodeVisitor#enterBinaryNode(BinaryNode)::: verify destructuring pattern node visitor enter binary node:::if->binaryNode->isTokenType->binaryNode->lhs->accept->return->else->return->enterDefault
Parser.VerifyDestructuringPatternNodeVisitor#enterUnaryNode(UnaryNode)::: verify destructuring pattern node visitor enter unary node:::if->unaryNode->isTokenType->return->else->return->enterDefault
Parser#verifyDestructuringBindingPattern(Expression, Consumer):::Verify destructuring variable declaration binding pattern and extract bound variable declarations.:::pattern->new->LexicalContext->new->VerifyDestructuringPatternNodeVisitor->accept
Parser#emptyStatement():::EmptyStatement :      ;  See 12.3  Parse an empty statement.:::if->Token->descPosition->Token->descLength->new->EmptyNode->appendStatement->next
Parser#expressionStatement():::ExpressionStatement :      Expression ; // [lookahead ~({ or  function )]  See 12.4  Parse an expression used in a statement block.:::expressionLine->expressionToken->expression->expression->if->expressionStatement->new->ExpressionStatement->appendStatement->else->expect->endOfLine
Parser#ifStatement():::IfStatement :      if ( Expression ) Statement else Statement      if ( Expression ) Statement  See 12.5  Parse an IF statement.:::ifLine->ifToken->next->expect->test->expression->expect->pass->getStatement->fail->if->next->getStatement->fail->getFinish->pass->getFinish->new->IfNode->appendStatement
Parser#forStatement():::..:::forToken->forLine->forStart->Token->descPosition->outer->useBlockScope->newBlock->forNode->new->ParserContextLoopNode->lc->push->body->init->test->modify->varDeclList->flags->isForOf->try->next->if->getValue->equals->next->expect->varType->switch->variableDeclarationList->break->break->if->useBlockScope->lookaheadIsLetDeclaration->variableDeclarationList->break->if->variableDeclarationList->break->unaryExpression->COMMARIGHT->getPrecedence->expression->break->switch->if->if->if->throw->AbstractParser->getName->message->error->else->throw->AbstractParser->message->getToken->error->if->throw->AbstractParser->message->error->expect->if->joinPredecessorExpression->expect->if->joinPredecessorExpression->break->if->getValue->equals->else->expect->break->new->JoinPredecessorExpression->if->if->throw->AbstractParser->message->getToken->error->if->throw->AbstractParser->message->error->else->if->checkValidLValue->throw->AbstractParser->message->init->getToken->error->next->assignmentExpression->new->JoinPredecessorExpression->joinPredecessorExpression->break->expect->break->expect->getStatement->catch->finally->lc->pop->foreach->forNode->getStatements->appendStatement->if->body->getFinish->forNode->getFlags->new->ForNode->appendStatement->if->restoreBlock->if->statements->new->ArrayList<>->foreach->outer->getStatements->if->isBlockScoped->appendStatement->else->statements->add->outer->getToken->body->getFinish->new->Block->new->BlockStatement->appendStatement
Parser#checkValidLValue(Expression, String)::: parser check valid value:::if->if->checkIdentLValue->return->verifyIdent->return->else->if->return->else->if->isDestructuringLhs->verifyDestructuringAssignmentPattern->return->else->return
Parser#lookaheadIsLetDeclaration(boolean)::: parser lookahead is let declaration:::for->i
Parser#whileStatement():::...IterationStatement :           ..:::whileToken->whileLine->next->whileNode->new->ParserContextLoopNode->lc->push->test->body->try->expect->joinPredecessorExpression->expect->getStatement->catch->finally->lc->pop->if->body->getFinish->new->WhileNode->appendStatement
Parser#doStatement():::...IterationStatement :           ..:::doToken->doLine->next->doWhileNode->new->ParserContextLoopNode->lc->push->body->test->try->getStatement->expect->expect->joinPredecessorExpression->expect->if->endOfLine->catch->finally->lc->pop->new->WhileNode->appendStatement
Parser#continueStatement():::ContinueStatement :      continue Identifier? ; // [no LineTerminator here]  See 12.7  Parse CONTINUE statement.:::continueLine->continueToken->nextOrEOL->labelNode->switch->break->ident->getIdent->lc->ident->getName->findLabel->if->throw->AbstractParser->ident->getName->message->ident->getToken->error->break->labelName->labelNode->getLabelName->targetNode->lc->getContinueTo->if->throw->AbstractParser->message->error->endOfLine->new->ContinueNode->appendStatement
Parser#breakStatement():::BreakStatement :      break Identifier? ; // [no LineTerminator here]  See 12.8:::breakLine->breakToken->nextOrEOL->labelNode->switch->break->ident->getIdent->lc->ident->getName->findLabel->if->throw->AbstractParser->ident->getName->message->ident->getToken->error->break->labelName->labelNode->getLabelName->targetNode->lc->getBreakable->if->targetNode->setFlag->if->throw->AbstractParser->message->error->endOfLine->new->BreakNode->appendStatement
Parser#returnStatement():::ReturnStatement :      return Expression? ; // [no LineTerminator here]  See 12.9  Parse RETURN statement.:::if->lc->getCurrentFunction->getKind->lc->getCurrentFunction->getKind->throw->AbstractParser->message->error->returnLine->returnToken->nextOrEOL->expression->switch->break->expression->break->endOfLine->new->ReturnNode->appendStatement
Parser#yieldExpression(boolean):::Parse YieldExpression:::yieldToken->nextOrEOL->expression->yieldAsterisk->if->Token->recast->next->switch->if->newUndefinedLiteral->if->next->break->else->assignmentExpression->break->return->new->UnaryNode
Parser#newUndefinedLiteral(long, int)::: parser new undefined literal:::return->Token->recast->LiteralNode->newInstance->new->UnaryNode
Parser#withStatement():::WithStatement :      with ( Expression ) Statement  See 12.10  Parse WITH statement.:::withLine->withToken->next->if->throw->AbstractParser->message->error->expect->expression->expression->expect->body->getStatement->new->WithNode->appendStatement
Parser#switchStatement():::SwitchStatement :      switch ( Expression ) CaseBlock  CaseBlock :      { CaseClauses? }      { CaseClauses? DefaultClause CaseClauses }  CaseClauses :      CaseClause      CaseClauses CaseClause  CaseClause :      case Expression : StatementList?  DefaultClause :      default : StatementList?  See 12.11  Parse SWITCH statement.:::switchLine->switchToken->switchBlock->newBlock->next->switchNode->new->ParserContextSwitchNode->lc->push->defaultCase->cases->new->ArrayList<>->expression->try->expect->expression->expect->expect->while->caseExpression->caseToken->switch->next->expression->break->if->throw->AbstractParser->message->error->next->break->expect->break->expect->statements->getBlock->caseNode->new->CaseNode->if->cases->add->next->catch->finally->lc->pop->restoreBlock->switchStatement->new->SwitchNode->switchBlock->getFlags->new->Block->new->BlockStatement->appendStatement
Parser#labelStatement():::LabelledStatement :      Identifier : Statement  See 12.12  Parse label statement.:::labelToken->ident->getIdent->expect->if->lc->ident->getName->findLabel->throw->AbstractParser->ident->getName->message->error->labelNode->ident->getName->new->ParserContextLabelNode->body->try->lc->push->getStatement->catch->finally->lc->pop->ident->getName->new->LabelNode->appendStatement
Parser#throwStatement():::ThrowStatement :      throw Expression ; // [no LineTerminator here]  See 12.13  Parse throw statement.:::throwLine->throwToken->nextOrEOL->expression->switch->break->expression->break->if->throw->AbstractParser->type->getNameOrType->message->error->endOfLine->new->ThrowNode->appendStatement
Parser#tryStatement():::TryStatement :      try Block Catch      try Block Finally      try Block Catch Finally  Catch :      catch( Identifier if Expression ) Block      catch( Identifier ) Block  Finally :      finally Block  See 12.14  Parse TRY statement.:::tryLine->tryToken->next->startLine->outer->newBlock->try->tryBody->getBlock->catchBlocks->new->ArrayList<>->while->catchLine->catchToken->next->expect->contextString->exception->bindingIdentifierOrPattern->isDestructuring->if->new->Consumer<IdentNode>->verifyDestructuringBindingPattern->else->verifyIdent->ifExpression->if->next->expression->else->expect->catchBlock->newBlock->try->catchBody->getBlock->catchNode->new->CatchNode->appendStatement->catch->finally->restoreBlock->catchBlocks->catchBlock->getToken->catchBlock->getFlags->catchBlock->getStatements->new->Block->add->if->break->finallyStatements->if->next->getBlock->if->catchBlocks->isEmpty->throw->AbstractParser->message->error->tryNode->new->TryNode->appendStatement->catch->finally->restoreBlock->outer->getFlags->outer->getStatements->new->Block->new->BlockStatement->appendStatement
Parser#debuggerStatement():::DebuggerStatement :      debugger ;  See 12.15  Parse debugger statement.:::debuggerLine->debuggerToken->next->endOfLine->new->DebuggerNode->appendStatement
Parser#primaryExpression():::PrimaryExpression :      this      IdentifierReference      Literal      ArrayLiteral      ObjectLiteral      RegularExpressionLiteral      TemplateLiteral      CoverParenthesizedExpressionAndArrowParameterList  CoverParenthesizedExpressionAndArrowParameterList :      ( Expression )      ( )      ( ..:::primaryLine->primaryToken->switch->name->type->getName->next->markThis->return->new->IdentNode->ident->getIdent->if->break->detectSpecialProperty->checkEscapedKeyword->return->if->throw->AbstractParser->message->error->return->getLiteral->return->execString->next->return->LiteralNode->newInstance->next->return->LiteralNode->newInstance->next->return->LiteralNode->newInstance->return->arrayLiteral->return->objectLiteral->next->if->isES6->if->nextOrEOL->expectDontAdvance->return->Collections->emptyList->new->ExpressionList->else->if->restParam->formalParameterList->get->expectDontAdvance->nextOrEOL->expectDontAdvance->return->Collections->singletonList->new->ExpressionList->expression->expression->expect->return->return->templateLiteral->if->lexer->scanLiteral->next->return->getLiteral->if->isNonStrictModeIdent->return->getIdent->break->return
Parser#execString(int, long):::Convert execString to a call to $EXEC.:::execIdent->new->IdentNode->next->expect->arguments->Collections->expression->singletonList->expect->return->new->CallNode
Parser#arrayLiteral():::ArrayLiteral :      [ Elision? ]      [ ElementList ]      [ ElementList , Elision? ]      [ expression for (LeftHandExpression in expression) ( (if ( Expression ) )? ]  ElementList : Elision? AssignmentExpression      ElementList , Elision? AssignmentExpression  Elision :      ,      Elision ,  See 12.1.4 JavaScript 1.8  Parse array literal.:::arrayToken->next->elements->new->ArrayList<>->elision->hasSpread->while->spreadToken->switch->next->break->next->if->elements->add->break->if->isES6->next->if->throw->AbstractParser->type->getNameOrType->message->error->expression->assignmentExpression->if->if->Token->recast->new->UnaryNode->elements->add->else->expect->break->return->LiteralNode->newInstance
Parser#objectLiteral():::ObjectLiteral :      { }      { PropertyNameAndValueList } { PropertyNameAndValueList , }  PropertyNameAndValueList :      PropertyAssignment      PropertyNameAndValueList , PropertyAssignment  See 11.1.5  Parse an object literal.:::objectToken->next->elements->new->ArrayList<>->map->new->HashMap<>->commaSeen->while->switch->next->break->if->throw->AbstractParser->type->getNameOrType->message->error->next->break->if->throw->AbstractParser->type->getNameOrType->message->error->property->propertyAssignment->if->property->isComputed->elements->add->break->key->property->getKeyName->existing->map->get->if->map->elements->size->put->elements->add->break->existingProperty->elements->get->value->property->getValue->getter->property->getGetter->setter->property->getSetter->prevValue->existingProperty->getValue->prevGetter->existingProperty->getGetter->prevSetter->existingProperty->getSetter->if->isES6->checkPropertyRedefinition->else->if->property->getKey->property->getKey->isProtoPropertyName->existingProperty->getKey->existingProperty->getKey->isProtoPropertyName->throw->AbstractParser->message->property->getToken->error->if->map->elements->size->put->elements->add->else->if->elements->existingProperty->setGetter->set->else->if->elements->existingProperty->setSetter->set->break->return->new->ObjectNode
Parser#checkPropertyRedefinition(PropertyNode, Expression, FunctionNode, FunctionNode, Expression, FunctionNode, FunctionNode)::: parser check property redefinition:::if->throw->AbstractParser->property->getKeyName->message->property->getToken->error->isPrevAccessor->isAccessor->if->throw->AbstractParser->property->getKeyName->message->property->getToken->error->if->throw->AbstractParser->property->getKeyName->message->property->getToken->error->if->if->throw->AbstractParser->property->getKeyName->message->property->getToken->error
Parser#literalPropertyName():::LiteralPropertyName :      IdentifierName      StringLiteral      NumericLiteral:::switch->return->getIdent->setIsPropertyName->if->throw->AbstractParser->message->error->return->getLiteral->return->getIdentifierName->setIsPropertyName
Parser#computedPropertyName():::ComputedPropertyName :      AssignmentExpression:::expect->expression->assignmentExpression->expect->return
Parser#propertyName():::PropertyName :      LiteralPropertyName      ComputedPropertyName:::if->isES6->return->computedPropertyName->else->return->literalPropertyName
Parser#propertyAssignment():::PropertyAssignment :      PropertyName : AssignmentExpression      get PropertyName ( ) { FunctionBody }      set PropertyName ( PropertySetParameterList ) { FunctionBody }  PropertySetParameterList :      Identifier  PropertyName :      IdentifierName      StringLiteral      NumericLiteral  See 11.1.5  Parse an object literal property.:::propertyToken->functionLine->propertyName->isIdentifier->generator->if->isES6->next->computed->if->ident->expectValue->if->isES6->getSetToken->switch->getter->propertyGetterFunction->return->new->PropertyNode->setter->propertySetterFunction->return->new->PropertyNode->break->identNode->createIdentNode->setIsPropertyName->if->ident->equals->identNode->setIsProtoPropertyName->else->isNonStrictModeIdent->propertyName->propertyValue->if->expectDontAdvance->if->isES6->propertyMethodFunction->else->if->isES6->getPropertyName->createIdentNode->if->isES6->assignToken->next->rhs->assignmentExpression->verifyAssignment->else->expect->defaultNames->push->try->assignmentExpression->catch->finally->defaultNames->pop->return->new->PropertyNode
Parser#propertyGetterFunction(long, int)::: parser property getter function:::return->propertyGetterFunction
Parser#propertyGetterFunction(long, int, int)::: parser property getter function:::computed->propertyName->propertyName->getterName->getPropertyName->getDefaultValidFunctionName->getNameNode->getToken->NameCodec->encode->createIdentNode->expect->expect->functionNode->Collections->emptyList->createParserContextFunctionNode->functionNode->setFlag->if->functionNode->setFlag->lc->push->functionBody->try->functionBody->catch->finally->lc->pop->function->Collections->emptyList->createFunctionNode->return->new->PropertyFunction
Parser#propertySetterFunction(long, int)::: parser property setter function:::return->propertySetterFunction
Parser#propertySetterFunction(long, int, int)::: parser property setter function:::computed->propertyName->propertyName->setterName->getPropertyName->getDefaultValidFunctionName->setNameNode->getToken->NameCodec->encode->createIdentNode->expect->argIdent->if->isBindingIdentifier->getIdent->verifyIdent->else->expect->parameters->new->ArrayList<>->if->parameters->add->functionNode->createParserContextFunctionNode->functionNode->setFlag->if->functionNode->setFlag->lc->push->functionBody->try->functionBody->catch->finally->lc->pop->function->createFunctionNode->return->new->PropertyFunction
Parser#propertyMethodFunction(Expression, long, int, boolean, int, boolean)::: parser property method function:::methodName->getPropertyName->getDefaultValidFunctionName->methodNameNode->getToken->createIdentNode->functionKind->functionNode->createParserContextFunctionNode->functionNode->setFlag->if->functionNode->setFlag->lc->push->try->parameterBlock->newBlock->parameters->try->expect->formalParameterList->functionNode->setParameters->expect->catch->finally->restoreBlock->functionBody->functionBody->maybeWrapBodyInParameterBlock->function->createFunctionNode->return->new->PropertyFunction->catch->finally->lc->pop
Parser#leftHandSideExpression():::LeftHandSideExpression :      NewExpression      CallExpression  CallExpression :      MemberExpression Arguments      SuperCall      CallExpression Arguments      CallExpression [ Expression ]      CallExpression :::callLine->callToken->lhs->memberExpression->if->arguments->argumentList->optimizeList->if->detectSpecialFunction->checkEscapedKeyword->new->CallNode->while->switch->arguments->argumentList->optimizeList->new->CallNode->break->next->rhs->expression->expect->new->IndexNode->break->next->property->getIdentifierName->property->getName->new->AccessNode->break->arguments->templateLiteralArgumentList->new->CallNode->break->break->return
Parser#newExpression():::NewExpression :      MemberExpression      new NewExpression  See 11.2  Parse new expression.:::newToken->next->if->isES6->next->if->getValue->equals->if->lc->getCurrentFunction->isProgram->throw->AbstractParser->message->error->next->markNewTarget->return->new->IdentNode->else->throw->AbstractParser->message->error->callLine->constructor->memberExpression->if->return->arguments->if->argumentList->else->new->ArrayList<>->if->arguments->objectLiteral->add->callNode->constructor->getToken->optimizeList->new->CallNode->return->new->UnaryNode
Parser#memberExpression():::MemberExpression :      PrimaryExpression        FunctionExpression        ClassExpression        GeneratorExpression      MemberExpression [ Expression ]      MemberExpression :::lhs->isSuper->switch->newExpression->break->functionExpression->break->if->isES6->classExpression->break->else->if->isES6->currentFunction->getCurrentNonArrowFunction->if->currentFunction->isMethod->identToken->Token->recast->next->SUPER->getName->createIdentNode->switch->getCurrentNonArrowFunction->setFlag->break->if->currentFunction->isSubclassConstructor->setIsDirectSuper->break->else->throw->AbstractParser->message->error->break->else->else->primaryExpression->break->while->callToken->switch->next->index->expression->expect->new->IndexNode->if->setIsSuper->break->if->throw->AbstractParser->type->getNameOrType->message->error->next->property->getIdentifierName->property->getName->new->AccessNode->if->setIsSuper->break->callLine->arguments->templateLiteralArgumentList->new->CallNode->break->break->return
Parser#argumentList():::Arguments :      ( )      ( ArgumentList )  ArgumentList :      AssignmentExpression      ..:::nodeList->new->ArrayList<>->next->first->while->if->expect->else->spreadToken->if->isES6->next->expression->assignmentExpression->if->Token->recast->new->UnaryNode->nodeList->add->expect->return
Parser#optimizeList(ArrayList)::: parser optimize list:::switch->list->size->return->Collections->emptyList->return->Collections->list->get->singletonList->list->trimToSize->return
Parser#functionExpression(boolean, boolean):::FunctionDeclaration :      function Identifier ( FormalParameterList? ) { FunctionBody }  FunctionExpression :      function Identifier? ( FormalParameterList? ) { FunctionBody }  See 13  Parse function declaration.:::functionToken->functionLine->next->generator->if->isES6->next->name->if->isBindingIdentifier->if->inGeneratorFunction->expect->getIdent->verifyIdent->else->if->if->expect->isAnonymous->if->tmpName->getDefaultValidFunctionName->Token->descPosition->new->IdentNode->functionKind->parameters->Collections->emptyList->functionNode->createParserContextFunctionNode->lc->push->functionBody->hideDefaultName->try->parameterBlock->newBlock->try->expect->formalParameterList->functionNode->setParameters->expect->catch->finally->restoreBlock->functionBody->maybeWrapBodyInParameterBlock->catch->finally->defaultNames->pop->lc->pop->if->if->useBlockScope->functionNode->setFlag->else->if->throw->AbstractParser->message->error->else->if->throw->AbstractParser->message->error->else->if->AbstractParser->message->warning->if->isArguments->lc->getCurrentFunction->setFlag->if->functionNode->setFlag->verifyParameterList->function->createFunctionNode->if->if->new->ExpressionStatement->appendStatement->return->varFlags->useBlockScope->varNode->new->VarNode->if->functionDeclarations->add->else->if->useBlockScope->prependStatement->else->appendStatement->return
Parser#verifyParameterList(List, ParserContextFunctionNode)::: parser verify parameter list:::duplicateParameter->functionNode->getDuplicateParameterBinding->if->if->functionNode->isStrict->functionNode->getKind->functionNode->isSimpleParameterList->throw->AbstractParser->duplicateParameter->getName->message->duplicateParameter->getToken->error->arity->parameters->size->parametersSet->new->HashSet<>->for->i
Parser#maybeWrapBodyInParameterBlock(Block, ParserContextBlockNode)::: parser maybe wrap body in parameter block:::if->parameterBlock->getStatements->isEmpty->parameterBlock->new->BlockStatement->appendStatement->return->parameterBlock->getToken->functionBody->getFinish->functionBody->getFlags->parameterBlock->getStatements->new->Block->return
Parser#getDefaultValidFunctionName(int, boolean)::: parser get default valid function name:::defaultFunctionName->getDefaultFunctionName->if->isValidIdentifier->if->return->ANON_FUNCTION_PREFIX->symbolName->return->return->ANON_FUNCTION_PREFIX->symbolName
Parser#isValidIdentifier(String)::: parser is valid identifier:::if->name->isEmpty->return->if->Character->name->charAt->isJavaIdentifierStart->return->for->i->name->length->return
Parser#getDefaultFunctionName()::: parser get default function name:::if->defaultNames->isEmpty->nameExpr->defaultNames->peek->if->markDefaultNameUsed->return->getPropertyName->else->if->markDefaultNameUsed->return->getProperty->return
Parser#markDefaultNameUsed()::: parser mark default name used:::defaultNames->pop->hideDefaultName
Parser#hideDefaultName()::: parser hide default name:::defaultNames->push
Parser#formalParameterList(boolean):::FormalParameterList :      Identifier      FormalParameterList , Identifier  See 13  Parse function parameter list.:::return->formalParameterList
Parser#formalParameterList(TokenType, boolean):::Same as the other method of the same name - except that the end token type expected is passed as argument to this method:::parameters->new->ArrayList<>->first->while->if->expect->else->restParameter->if->isES6->next->if->expect->paramToken->paramLine->contextString->ident->if->isBindingIdentifier->isES6->bindingIdentifier->if->ident->setIsRestParameter->expectDontAdvance->parameters->add->break->else->if->isES6->next->ident->setIsDefaultParameter->if->expect->initializer->assignmentExpression->currentFunction->lc->getCurrentFunction->if->if->assignment->Token->recast->new->BinaryNode->currentFunction->addParameterExpression->else->test->Token->recast->newUndefinedLiteral->new->BinaryNode->value->Token->recast->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->TernaryNode->assignment->Token->recast->new->BinaryNode->lc->getFunctionBody->assignment->getToken->assignment->getFinish->new->ExpressionStatement->appendStatement->currentFunction->lc->getCurrentFunction->if->currentFunction->addParameterBinding->if->ident->isRestParameter->ident->isDefaultParameter->currentFunction->setSimpleParameterList->else->pattern->bindingPattern->pattern->getFinish->String->parameters->size->format->createIdentNode->setIsDestructuredParameter->verifyDestructuringParameterBindingPattern->value->if->next->ident->setIsDefaultParameter->initializer->assignmentExpression->if->else->test->Token->recast->newUndefinedLiteral->new->BinaryNode->Token->recast->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->TernaryNode->currentFunction->lc->getCurrentFunction->if->assignment->Token->recast->new->BinaryNode->if->if->ident->isDefaultParameter->currentFunction->addParameterExpression->else->currentFunction->addParameterExpression->else->lc->getFunctionBody->assignment->getToken->assignment->getFinish->new->ExpressionStatement->appendStatement->parameters->add->parameters->trimToSize->return
Parser#verifyDestructuringParameterBindingPattern(Expression, long, int, String)::: parser verify destructuring parameter binding pattern:::new->Consumer<IdentNode>->verifyDestructuringBindingPattern
Parser#functionBody(ParserContextFunctionNode):::FunctionBody :      SourceElements?  See 13  Parse function body.:::lastToken->body->bodyToken->functionBody->bodyFinish->parseBody->endParserState->try->newBlock->if->markEval->functionId->functionNode->getId->reparsedFunction->getFunctionNodeId->if->functionNode->getKind->expr->assignmentExpression->functionNode->setLastToken->lastFinish->Token->descPosition->Token->descType->Token->descLength->if->functionNode->setFlag->returnNode->functionNode->getLineNumber->expr->getToken->new->ReturnNode->appendStatement->else->expectDontAdvance->if->skipFunctionBody->next->prevFunctionDecls->new->ArrayList<>->try->sourceElements->addFunctionDeclarations->catch->finally->if->Token->descPosition->new->ParserState->functionNode->setLastToken->expect->catch->finally->restoreBlock->if->functionNode->setEndParserState->else->if->body->getStatements->isEmpty->body->Collections->emptyList->setStatements->if->data->reparsedFunction->functionNode->getId->getScriptFunctionData->if->functionNode->data->getFunctionFlags->setFlag->if->functionNode->hasNestedEval->body->setFlag->body->getFlags->body->getStatements->new->Block->return
Parser#skipFunctionBody(ParserContextFunctionNode)::: parser skip function body:::if->return->data->reparsedFunction->functionNode->getId->getScriptFunctionData->if->return->parserState->data->getEndParserState->if->stream->last->Token->stream->stream->last->get->descPosition->for->stream->last->stream->reset->parserState->createLexer->scanFirstToken->return
Parser.ParserState#createLexer(Source, Lexer, TokenStream, boolean, boolean)::: parser state create lexer:::newLexer->new->Lexer->newLexer->new->Lexer.State->restoreState->return
Parser#printAST(FunctionNode)::: parser print t:::if->functionNode->getDebugFlag->env->getErr->new->ASTWriter->println->if->functionNode->getDebugFlag->env->getErr->new->PrintVisitor->println
Parser#addFunctionDeclarations(ParserContextFunctionNode)::: parser add function declarations:::lastDecl->for->i->functionDeclarations->size
Parser#referenceError(Expression, Expression, boolean)::: parser reference error:::if->throw->AbstractParser->message->lhs->getToken->error->args->new->ArrayList<>->args->add->if->args->LiteralNode->lhs->getToken->lhs->getFinish->newInstance->add->else->args->add->args->LiteralNode->lhs->getToken->lhs->getFinish->lhs->toString->newInstance->add->return->lhs->getToken->lhs->getFinish->new->RuntimeNode
Parser#unaryExpression():::PostfixExpression :      LeftHandSideExpression      LeftHandSideExpression ++ // [no LineTerminator here]      LeftHandSideExpression -- // [no LineTerminator here]  See 11.3  UnaryExpression :      PostfixExpression      delete UnaryExpression      void UnaryExpression      typeof UnaryExpression      ++ UnaryExpression      -- UnaryExpression      + UnaryExpression      - UnaryExpression      ~ UnaryExpression      ! UnaryExpression  See 11.4  Parse unary expression.:::unaryLine->unaryToken->switch->opType->next->expr->unaryExpression->return->Token->recast->new->UnaryNode->next->expr->unaryExpression->return->new->UnaryNode->opType->next->lhs->leftHandSideExpression->if->throw->AbstractParser->type->getNameOrType->message->error->return->verifyIncDecExpression->break->expression->leftHandSideExpression->if->switch->opToken->opType->lhs->if->throw->AbstractParser->type->getNameOrType->message->error->next->return->verifyIncDecExpression->break->if->throw->AbstractParser->type->getNameOrType->message->error->return
Parser#verifyIncDecExpression(long, TokenType, Expression, boolean)::: parser verify inc dec expression:::if->return->referenceError->if->if->checkIdentLValue->return->referenceError->opType->getName->verifyIdent->return->incDecExpression
Parser#expression():::MultiplicativeExpression :      UnaryExpression      MultiplicativeExpression * UnaryExpression      MultiplicativeExpression / UnaryExpression      MultiplicativeExpression % UnaryExpression  See 11.5  AdditiveExpression :      MultiplicativeExpression      AdditiveExpression + MultiplicativeExpression      AdditiveExpression - MultiplicativeExpression  See 11.6  ShiftExpression :      AdditiveExpression      ShiftExpression << AdditiveExpression      ShiftExpression >> AdditiveExpression      ShiftExpression >>> AdditiveExpression  See 11.7  RelationalExpression :      ShiftExpression      RelationalExpression < ShiftExpression      RelationalExpression > ShiftExpression      RelationalExpression <= ShiftExpression      RelationalExpression >= ShiftExpression      RelationalExpression instanceof ShiftExpression      RelationalExpression in ShiftExpression // if !noIf  See 11.8       RelationalExpression      EqualityExpression == RelationalExpression      EqualityExpression != RelationalExpression      EqualityExpression === RelationalExpression      EqualityExpression !== RelationalExpression  See 11.9  BitwiseANDExpression :      EqualityExpression      BitwiseANDExpression & EqualityExpression  BitwiseXORExpression :      BitwiseANDExpression      BitwiseXORExpression ^ BitwiseANDExpression  BitwiseORExpression :      BitwiseXORExpression      BitwiseORExpression | BitwiseXORExpression  See 11.10  LogicalANDExpression :      BitwiseORExpression      LogicalANDExpression && BitwiseORExpression  LogicalORExpression :      LogicalANDExpression      LogicalORExpression || LogicalANDExpression  See 11.11  ConditionalExpression :      LogicalORExpression      LogicalORExpression ? AssignmentExpression : AssignmentExpression  See 11.12  AssignmentExpression :      ConditionalExpression      LeftHandSideExpression AssignmentOperator AssignmentExpression  AssignmentOperator :      = *= /= %= += -= <<= >>= >>>= &= ^= |=  See 11.13  Expression :      AssignmentExpression      Expression , AssignmentExpression  See 11.14   Parse expression.:::return->expression
Parser#expression(boolean)::: parser expression:::assignmentExpression->assignmentExpression->while->commaToken->next->rhsRestParameter->if->isES6->if->isRestParameterEndOfArrowFunctionParameterList->next->rhs->assignmentExpression->if->setIsRestParameter->new->BinaryNode->return
Parser#expression(int, boolean)::: parser expression:::return->unaryExpression->expression
Parser#joinPredecessorExpression()::: parser join predecessor expression:::return->expression->new->JoinPredecessorExpression
Parser#expression(Expression, int, boolean)::: parser expression:::precedence->type->getPrecedence->lhs->while->type->isOperator->op->if->next->trueExpr->unaryExpression->ASSIGN->getPrecedence->expression->expect->falseExpr->unaryExpression->ASSIGN->getPrecedence->expression->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->TernaryNode->else->next->rhs->isAssign->Token->descType->if->defaultNames->push->try->unaryExpression->nextPrecedence->type->getPrecedence->while->type->isOperator->type->isLeftAssociative->expression->type->getPrecedence->catch->finally->if->defaultNames->pop->verifyAssignment->type->getPrecedence->return
Parser#assignmentExpression(boolean):::AssignmentExpression:::if->inGeneratorFunction->isES6->return->yieldExpression->startToken->startLine->exprLhs->conditionalExpression->if->isES6->if->checkNoLineTerminator->paramListExpr->if->getExpressions->isEmpty->getExpressions->get->else->return->arrowFunction->if->isAssignmentOperator->isAssign->if->defaultNames->push->try->assignToken->next->exprRhs->assignmentExpression->return->verifyAssignment->catch->finally->if->defaultNames->pop->else->return
Parser#isAssignmentOperator(TokenType):::Is type one of = *= /= %= += -= <<= >>= >>>= &= ^= |=?:::switch->return->return
Parser#conditionalExpression(boolean):::ConditionalExpression.:::return->TERNARY->getPrecedence->expression
Parser#arrowFunction(long, int, Expression):::ArrowFunction.:::expect->functionToken->Token->recast->name->Token->descPosition->NameCodec->encode->new->IdentNode->functionNode->createParserContextFunctionNode->functionNode->setFlag->lc->push->try->parameterBlock->newBlock->parameters->try->convertArrowFunctionParameterList->functionNode->setParameters->if->functionNode->isSimpleParameterList->markEvalInArrowParameterList->catch->finally->restoreBlock->functionBody->functionBody->maybeWrapBodyInParameterBlock->verifyParameterList->function->createFunctionNode->return->catch->finally->lc->pop
Parser#markEvalInArrowParameterList(ParserContextBlockNode)::: parser mark eval in arrow parameter list:::iter->lc->getFunctions->current->iter->next->parent->iter->next->if->parent->getFlag->foreach->parameterBlock->getStatements->st->new->LexicalContext->new->NodeVisitor<LexicalContext>->accept
Parser#convertArrowFunctionParameterList(Expression, int)::: parser convert arrow function parameter list:::parameters->if->Collections->emptyList->else->if->paramListExpr->isTokenType->isDestructuringLhs->Collections->verifyArrowParameter->singletonList->else->if->Token->paramListExpr->getToken->descType->new->ArrayList<>->car->do->cdr->rhs->parameters->parameters->size->verifyArrowParameter->add->lhs->while->Token->car->getToken->descType->parameters->parameters->size->verifyArrowParameter->add->else->throw->AbstractParser->message->paramListExpr->getToken->error->return
Parser#verifyArrowParameter(Expression, int, int)::: parser verify arrow parameter:::contextString->if->ident->verifyIdent->currentFunction->lc->getCurrentFunction->if->currentFunction->addParameterBinding->return->if->param->isTokenType->lhs->lhs->paramToken->lhs->getToken->initializer->rhs->if->ident->currentFunction->lc->getCurrentFunction->if->if->currentFunction->addParameterExpression->else->test->Token->recast->newUndefinedLiteral->new->BinaryNode->value->Token->recast->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->TernaryNode->assignment->Token->recast->new->BinaryNode->lc->getFunctionBody->assignment->getToken->assignment->getFinish->new->ExpressionStatement->appendStatement->currentFunction->addParameterBinding->currentFunction->setSimpleParameterList->return->else->if->isDestructuringLhs->ident->param->getFinish->String->format->createIdentNode->setIsDestructuredParameter->setIsDefaultParameter->verifyDestructuringParameterBindingPattern->currentFunction->lc->getCurrentFunction->if->if->currentFunction->addParameterExpression->else->test->Token->recast->newUndefinedLiteral->new->BinaryNode->value->Token->recast->new->JoinPredecessorExpression->new->JoinPredecessorExpression->new->TernaryNode->assignment->Token->recast->new->BinaryNode->lc->getFunctionBody->assignment->getToken->assignment->getFinish->new->ExpressionStatement->appendStatement->return->else->if->isDestructuringLhs->paramToken->param->getToken->ident->param->getFinish->String->format->createIdentNode->setIsDestructuredParameter->verifyDestructuringParameterBindingPattern->currentFunction->lc->getCurrentFunction->if->if->currentFunction->addParameterExpression->else->assignment->Token->recast->new->BinaryNode->lc->getFunctionBody->assignment->getToken->assignment->getFinish->new->ExpressionStatement->appendStatement->return->throw->AbstractParser->message->param->getToken->error
Parser#checkNoLineTerminator()::: parser check no line terminator:::if->return->else->if->return->for->i->return
Parser#isRestParameterEndOfArrowFunctionParameterList():::Peek ahead to see if what follows after the ellipsis is a rest parameter at the end of an arrow function parameter list.:::i->for->for->for->return
Parser#endOfLine():::Parse an end of line.:::switch->next->break->break->if->expect->break
Parser#templateLiteral():::Parse untagged template literal as string concatenation.:::noSubstitutionTemplate->lastLiteralToken->literal->getLiteral->if->return->if->exprs->new->ArrayList<>->exprs->add->lastLiteralType->do->expression->expression->if->throw->AbstractParser->message->error->exprs->add->getLiteral->exprs->add->while->return->new->TemplateLiteral->else->concat->lastLiteralType->do->expression->expression->if->throw->AbstractParser->message->error->Token->recast->new->BinaryNode->getLiteral->Token->recast->new->BinaryNode->while->return
Parser#templateLiteralArgumentList():::Parse tagged template literal as argument list.:::argumentList->new->ArrayList<>->rawStrings->new->ArrayList<>->cookedStrings->new->ArrayList<>->argumentList->add->templateToken->hasSubstitutions->addTemplateLiteralString->if->lastLiteralType->do->expression->expression->if->throw->AbstractParser->message->error->argumentList->add->addTemplateLiteralString->while->rawStringArray->LiteralNode->newInstance->cookedStringArray->LiteralNode->newInstance->if->templateObject->new->RuntimeNode->argumentList->set->else->argumentList->set->return->optimizeList
Parser#addTemplateLiteralString(ArrayList, ArrayList)::: parser add template literal string:::stringToken->rawString->lexer->valueOfRawString->cookedString->getValue->next->rawStrings->LiteralNode->newInstance->add->cookedStrings->LiteralNode->newInstance->add
Parser#module(String):::Parse a module:::oldStrictMode->try->functionStart->Math->Token->Token->withDelimiter->descPosition->min->functionToken->Token->source->getLength->toDesc->functionLine->ident->Token->descPosition->new->IdentNode->script->Collections->emptyList->createParserContextFunctionNode->lc->push->module->new->ParserContextModuleNode->lc->push->body->newBlock->new->ArrayList<>->moduleBody->addFunctionDeclarations->restoreBlock->body->setFlag->programBody->body->getFlags->body->getStatements->new->Block->lc->pop->lc->pop->script->setLastToken->expect->script->module->createModule->setModule->return->Collections->emptyList->createFunctionNode->catch->finally
Parser#moduleBody():::Parse module body:::while->switch->break->importDeclaration->break->exportDeclaration->break->statement->break
Parser#importDeclaration():::Parse import declaration:::startPosition->expect->module->lc->getCurrentModule->if->moduleSpecifier->getValue->createIdentNode->next->module->addModuleRequest->else->importEntries->if->Collections->nameSpaceImport->singletonList->else->if->namedImports->else->if->isBindingIdentifier->importedDefaultBinding->bindingIdentifier->defaultImport->importSpecifier->if->next->new->ArrayList<>->if->importEntries->nameSpaceImport->add->else->if->importEntries->namedImports->addAll->else->throw->AbstractParser->message->error->else->Collections->singletonList->else->throw->AbstractParser->message->error->moduleSpecifier->fromClause->module->addModuleRequest->for->i->importEntries->size->expect
Parser#nameSpaceImport(int):::NameSpaceImport :     * as ImportedBinding:::starName->Token->recast->createIdentNode->next->asToken->as->expectValue->if->equals->throw->AbstractParser->message->error->localNameSpace->bindingIdentifier->return->importSpecifier
Parser#namedImports(int):::NamedImports :     { }     { ImportsList }     { ImportsList , } ImportsList :     ImportSpecifier     ImportsList , ImportSpecifier ImportSpecifier :     ImportedBinding     IdentifierName as ImportedBinding ImportedBinding :     BindingIdentifier:::next->importEntries->new->ArrayList<>->while->bindingIdentifier->isBindingIdentifier->nameToken->importName->getIdentifierName->if->getValue->equals->next->localName->bindingIdentifier->importEntries->importSpecifier->add->else->if->throw->AbstractParser->message->error->else->importEntries->importSpecifier->add->if->next->else->break->expect->return
Parser#fromClause():::FromClause :     from ModuleSpecifier:::fromToken->name->expectValue->if->equals->throw->AbstractParser->message->error->if->moduleSpecifier->Token->recast->getValue->createIdentNode->next->return->else->throw->expectMessage->error
Parser#exportDeclaration():::Parse export declaration:::expect->startPosition->module->lc->getCurrentModule->switch->starName->Token->recast->createIdentNode->next->moduleRequest->fromClause->expect->module->addModuleRequest->module->exportStarFrom->addStarExportEntry->break->exportEntries->exportClause->if->getValue->equals->moduleRequest->fromClause->module->addModuleRequest->foreach->module->exportEntry->withFrom->addIndirectExportEntry->else->foreach->module->addLocalExportEntry->expect->break->defaultName->Token->recast->createIdentNode->next->assignmentExpression->ident->lineNumber->rhsToken->declaration->switch->functionExpression->getIdent->break->classDeclaration->getIdent->break->assignmentExpression->break->if->module->exportDefault->addLocalExportEntry->else->Token->recast->createIdentNode->lc->Token->recast->new->VarNode->appendStatementToCurrentNode->if->expect->module->exportDefault->addLocalExportEntry->break->statements->lc->getCurrentBlock->getStatements->previousEnd->statements->size->variableStatement->foreach->statements->statements->size->subList->if->module->getName->exportSpecifier->addLocalExportEntry->break->classDeclaration->classDeclaration->module->classDeclaration->getIdent->exportSpecifier->addLocalExportEntry->break->functionDeclaration->functionExpression->module->functionDeclaration->getIdent->exportSpecifier->addLocalExportEntry->break->throw->AbstractParser->message->error
Parser#exportClause(int):::ExportClause :     { }     { ExportsList }     { ExportsList , } ExportsList :     ExportSpecifier     ExportsList , ExportSpecifier ExportSpecifier :     IdentifierName     IdentifierName as IdentifierName:::next->exports->new->ArrayList<>->while->localName->getIdentifierName->if->getValue->equals->next->exportName->getIdentifierName->exports->exportSpecifier->add->else->exports->exportSpecifier->add->if->next->else->break->expect->return
Parser#toString()::: parser to string:::return
Parser#markEval(ParserContext)::: parser mark eval:::iter->lc->getFunctions->flaggedCurrentFn->while->iter->hasNext->fn->iter->next->if->fn->setFlag->if->fn->getKind->markThis->markNewTarget->else->fn->setFlag->body->lc->getFunctionBody->body->setFlag->fn->setFlag
Parser#prependStatement(Statement)::: parser prepend statement:::lc->prependStatementToCurrentNode
Parser#appendStatement(Statement)::: parser append statement:::lc->appendStatementToCurrentNode
Parser#markSuperCall(ParserContext)::: parser mark super call:::iter->lc->getFunctions->while->iter->hasNext->fn->iter->next->if->fn->getKind->fn->setFlag->break
Parser#getCurrentNonArrowFunction()::: parser get current non arrow function:::iter->lc->getFunctions->while->iter->hasNext->fn->iter->next->if->fn->getKind->return->return
Parser#markThis(ParserContext)::: parser mark this:::iter->lc->getFunctions->while->iter->hasNext->fn->iter->next->fn->setFlag->if->fn->getKind->break
Parser#markNewTarget(ParserContext)::: parser mark new target:::iter->lc->getFunctions->while->iter->hasNext->fn->iter->next->if->fn->getKind->if->fn->isProgram->fn->setFlag->break
Parser#inGeneratorFunction()::: parser in generator function:::return->lc->getCurrentFunction->getKind
ParserContext#push(T):::Pushes a new block on top of the context, making it the innermost open block.:::if->newStack->new->ParserContextNodeArr->System->arraycopy->return
ParserContext#peek():::The topmost node on the stack:::return
ParserContext#pop(T):::Removes and returns the topmost Node from the stack.:::popped->return
ParserContext#contains(ParserContextNode):::Tests if a node is on the stack.:::for->i->return
ParserContext#getBreakable():::Returns the topmost ParserContextBreakableNode on the stack, null if none on stack:::for->iter->getCurrentFunction->new->NodeIterator<>->iter->hasNext->return
ParserContext#getBreakable(String):::Find the breakable node corresponding to this label.:::if->foundLabel->findLabel->if->breakable->for->iter->new->NodeIterator<>->iter->hasNext->return->return->return->getBreakable
ParserContext#getCurrentLoop():::Returns the loop node of the current loop, or null if not inside a loop:::iter->getCurrentFunction->new->NodeIterator<>->return->iter->hasNext->iter->next
ParserContext#getContinueTo()::: parser context get continue to:::return->getCurrentLoop
ParserContext#getContinueTo(String):::Find the continue target node corresponding to this label.:::if->foundLabel->findLabel->if->loop->for->iter->new->NodeIterator<>->iter->hasNext->return->return->return->getContinueTo
ParserContext#getFunctionBody(ParserContextFunctionNode):::Get the function body of a function node on the stack:::for->i->throw->functionNode->getName->new->AssertionError
ParserContext#findLabel(String):::Check the stack for a given label node by name:::for->iter->getCurrentFunction->new->NodeIterator<>->iter->hasNext->return
ParserContext#prependStatementToCurrentNode(Statement):::Prepends a statement to the current node.:::prependStatement
ParserContext#appendStatementToCurrentNode(Statement):::Appends a statement to the current Node.:::appendStatement
ParserContext#getCurrentFunction():::Returns the innermost function in the context.:::for->i->return
ParserContext#getBlocks():::Returns an iterator over all blocks in the context, with the top block (innermost lexical context) first.:::return->new->NodeIterator<>
ParserContext#getCurrentBlock():::Returns the innermost block in the context.:::return->getBlocks->next
ParserContext#getLastStatement():::The last statement added to the context:::if->return->top->s->top->getStatements->size->return->top->getStatements->get
ParserContext#getFunctions():::Returns an iterator over all functions in the context, with the top (innermost open) function first.:::return->new->NodeIterator<>
ParserContext#getCurrentModule()::: parser context get current module:::iter->getCurrentFunction->new->NodeIterator<>->return->iter->hasNext->iter->next
ParserContext.NodeIterator#hasNext()::: node iterator has next:::return
ParserContext.NodeIterator#next()::: node iterator next:::if->throw->new->NoSuchElementException->lnext->findNext->return
ParserContext.NodeIterator#findNext()::: node iterator find next:::for->i->return
ParserContext.NodeIterator#remove()::: node iterator remove:::throw->new->UnsupportedOperationException
ParserContextBaseNode#getFlags()::: parser context base node get flags:::return
ParserContextBaseNode#getFlag(int):::Returns a single flag:::return
ParserContextBaseNode#setFlag(int)::: parser context base node set flag:::return
ParserContextBaseNode#getStatements()::: parser context base node get statements:::return
ParserContextBaseNode#setStatements(List)::: parser context base node set statements:::
ParserContextBaseNode#appendStatement(Statement):::Adds a statement at the end of the statement list:::add
ParserContextBaseNode#prependStatement(Statement):::Adds a statement at the beginning of the statement list:::add
ParserContextBlockNode#isBreakableWithoutLabel()::: parser context block node is breakable without label:::return
ParserContextBlockNode#getToken():::Get token:::return
ParserContextBreakableNode#isBreakableWithoutLabel():::Returns true if not i breakable without label, false otherwise:::
ParserContextFunctionNode#getName()::: parser context function node get name:::return
ParserContextFunctionNode#getIdent()::: parser context function node get ident:::return
ParserContextFunctionNode#isProgram()::: parser context function node is program:::return->getFlag
ParserContextFunctionNode#isStrict()::: parser context function node is strict:::return->getFlag
ParserContextFunctionNode#hasNestedEval()::: parser context function node has nested eval:::return->getFlag
ParserContextFunctionNode#hasScopeBlock():::Returns true if any of the blocks in this function create their own scope.:::return->getFlag
ParserContextFunctionNode#uniqueName(String):::Create a unique name in the namespace of this FunctionNode:::return->namespace->uniqueName
ParserContextFunctionNode#getLineNumber()::: parser context function node get line number:::return
ParserContextFunctionNode#getKind()::: parser context function node get kind:::return
ParserContextFunctionNode#getParameters():::Get parameters:::return
ParserContextFunctionNode#setParameters(List)::: parser context function node set parameters:::
ParserContextFunctionNode#getParameterExpressions():::Return ES6 function parameter expressions:::return
ParserContextFunctionNode#addParameterExpression(IdentNode, Expression)::: parser context function node add parameter expression:::if->new->HashMap<>->parameterExpressions->put
ParserContextFunctionNode#setLastToken(long):::Set last token:::
ParserContextFunctionNode#getLastToken()::: parser context function node get last token:::return
ParserContextFunctionNode#getEndParserState():::Returns the ParserState of when the parsing of this function was ended:::return
ParserContextFunctionNode#setEndParserState(Object):::Sets the ParserState of when the parsing of this function was ended:::
ParserContextFunctionNode#getId():::Returns the if of this function:::return->isProgram->Token->descPosition
ParserContextFunctionNode#getDebugFlags():::Returns the debug flags for this function.:::return
ParserContextFunctionNode#setDebugFlag(int):::Sets a debug flag for this function.:::
ParserContextFunctionNode#isMethod()::: parser context function node is method:::return->getFlag
ParserContextFunctionNode#isClassConstructor()::: parser context function node is class constructor:::return->getFlag
ParserContextFunctionNode#isSubclassConstructor()::: parser context function node is subclass constructor:::return->getFlag
ParserContextFunctionNode#addParameterBinding(IdentNode)::: parser context function node add parameter binding:::if->Parser->isArguments->setFlag->if->new->HashSet<>->if->parameterBoundNames->bindingIdentifier->getName->add->return->else->return
ParserContextFunctionNode#getDuplicateParameterBinding()::: parser context function node get duplicate parameter binding:::return
ParserContextFunctionNode#isSimpleParameterList()::: parser context function node is simple parameter list:::return
ParserContextFunctionNode#setSimpleParameterList(boolean)::: parser context function node set simple parameter list:::
ParserContextFunctionNode#getModule()::: parser context function node get module:::return
ParserContextFunctionNode#setModule(Module)::: parser context function node set module:::
ParserContextLabelNode#getLabelName():::Returns the name of the label:::return
ParserContextLoopNode#isBreakableWithoutLabel()::: parser context loop node is breakable without label:::return
ParserContextModuleNode#getModuleName():::Returns the name of the module.:::return
ParserContextModuleNode#addModuleRequest(IdentNode)::: parser context module node add module request:::requestedModules->moduleRequest->getName->add
ParserContextModuleNode#addImportEntry(ImportEntry)::: parser context module node add import entry:::importEntries->add
ParserContextModuleNode#addLocalExportEntry(ExportEntry)::: parser context module node add local export entry:::localExportEntries->add
ParserContextModuleNode#addIndirectExportEntry(ExportEntry)::: parser context module node add indirect export entry:::indirectExportEntries->add
ParserContextModuleNode#addStarExportEntry(ExportEntry)::: parser context module node add star export entry:::starExportEntries->add
ParserContextModuleNode#createModule()::: parser context module node create module:::return->new->Module
ParserContextNode#getFlags()::: parser context node get flags:::
ParserContextNode#setFlag(int)::: parser context node set flag:::
ParserContextNode#getStatements()::: parser context node get statements:::
ParserContextNode#setStatements(List)::: parser context node set statements:::
ParserContextNode#appendStatement(Statement):::Adds a statement at the end of the statement list:::
ParserContextNode#prependStatement(Statement):::Adds a statement at the beginning of the statement list:::
ParserContextSwitchNode#isBreakableWithoutLabel()::: parser context switch node is breakable without label:::return
Scanner.State#setLimit(int):::Change the limit for a new scanner.:::
Scanner.State#isEmpty()::: state is empty:::return
Scanner#saveState():::Save the state of the scan.:::return->new->State
Scanner#restoreState(State):::Restore the state of the scan.:::reset
Scanner#atEOF():::Returns true of scanner is at end of input:::return
Scanner#charAt(int):::Get the ith character from the content.:::return
Scanner#reset(int):::Reset to a character position.:::charAt->charAt->charAt->charAt
Scanner#skip(int):::Skip ahead a number of characters.:::if->atEOF->charAt->else->if->reset
Token#toDesc(TokenType, int, int):::Create a compact form of token information.:::return->type->ordinal
Token#descPosition(long):::Extract token position from a token descriptor.:::return
Token#withDelimiter(long):::Normally returns the token itself, except in case of string tokens which report their position past their opening delimiter and thus need to have position and length adjusted.:::tokenType->Token->descType->switch->start->Token->descPosition->len->Token->descLength->return->toDesc->start->Token->descPosition->len->Token->descLength->return->toDesc->return
Token#descLength(long):::Extract token length from a token descriptor.:::return
Token#descType(long):::Extract token type from a token descriptor.:::return->TokenType->getValues
Token#recast(long, TokenType):::Change the token to use a new type.:::return->newType->ordinal
Token#toString(Source, long, boolean):::Return a string representation of a token.:::type->Token->descType->result->if->type->getKind->source->getString->else->type->getNameOrType->if->position->Token->descPosition->length->Token->descLength->return
Token#toString(Source, long):::String conversion of token:::return->Token->toString
Token#toString(long):::String conversion of token - version without source given:::return->Token->toString
Token#hashCode(long):::Static hash code computation function token:::return
TokenLookup#lookupKeyword(char[], int, int):::Lookup keyword.:::first->if->index->tokenType->while->tokenLength->tokenType->getLength->if->name->tokenType->getName->i->for->if->return->else->if->break->tokenType->getNext->return
TokenLookup#lookupOperator(char, char, char, char):::Lookup operator.:::if->index->tokenType->while->name->tokenType->getName->switch->name->length->return->if->name->charAt->return->break->if->name->charAt->name->charAt->return->break->if->name->charAt->name->charAt->name->charAt->return->break->break->tokenType->getNext->return
TokenStream#next(int):::Get the next position in the buffer.:::next->if->return
TokenStream#index(int):::Get the index position in the buffer.:::index->if->return
TokenStream#isEmpty():::Test to see if stream is empty.:::return
TokenStream#isFull():::Test to see if stream is full.:::return
TokenStream#count():::Get the number of tokens in the buffer.:::return
TokenStream#first():::Get the index of the first token in the stream.:::return
TokenStream#last():::Get the index of the last token in the stream.:::return
TokenStream#removeLast():::Remove the last token in the stream.:::if->if
TokenStream#put(long):::Put a token descriptor to the stream.:::if->grow->next
TokenStream#get(int):::Get the kth token descriptor from the stream.:::return->index
TokenStream#commit(int):::Advances the base of the stream.:::index
TokenStream#grow():::Grow the buffer to accommodate more token descriptors.:::newBuffer->new->longArr->if->System->arraycopy->else->portion->System->arraycopy->System->arraycopy
TokenStream#reset()::: token stream reset:::
