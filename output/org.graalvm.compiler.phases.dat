BasePhase_OptionDescriptors#get(String)::: base phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
BasePhase_OptionDescriptors#iterator()::: base phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
BasePhase#getBasePhaseStatistics(Class)::: base phase get base phase statistics:::return->statisticsClassValue->get
BasePhase#apply(StructuredGraph, C)::: base phase apply:::apply
BasePhase#getEnclosingPhase(DebugContext)::: base phase get enclosing phase:::foreach->debug->context->if->if->return->return
BasePhase#dumpBefore(StructuredGraph, C, boolean)::: base phase dump before:::debug->graph->getDebug->if->debug->isDumpEnabled->shouldDumpBeforeAtBasicLevel->debug->isDumpEnabled->if->shouldDumpBeforeAtBasicLevel->debug->getName->dump->else->debug->getName->dump->else->if->debug->isDumpEnabled->debug->getName->dump->else->if->debug->isDumpEnabled->shouldDump->debug->getName->dump->return->return
BasePhase#shouldDumpBeforeAtBasicLevel()::: base phase should dump before at basic level:::return
BasePhase#shouldDumpAfterAtBasicLevel()::: base phase should dump after at basic level:::return
BasePhase#apply(StructuredGraph, C, boolean)::: base phase apply:::graph->checkCancellation->debug->graph->getDebug->try->a->timer->start->s->debug->getClass->scope->c->memUseTracker->start->sizeBefore->before->options->graph->getOptions->verifySizeContract->getValue->checkContract->if->NodeCostUtil->computeGraphSize->graph->getMark->isTopLevel->graph->getDebug->getEnclosingPhase->dumpedBefore->if->debug->areScopesEnabled->dumpBefore->inputNodesCount->graph->getNodeCount->add->this->run->executionCount->increment->if->if->before->isCurrent->sizeAfter->NodeCostUtil->computeGraphSize->NodeCostUtil->phaseFulfillsSizeContract->if->debug->areScopesEnabled->dumpAfter->if->debug->isVerifyEnabled->debug->getName->verify->catch->throw->debug->handle->finally
BasePhase#dumpAfter(StructuredGraph, boolean, boolean)::: base phase dump after:::dumped->debug->graph->getDebug->if->if->shouldDumpAfterAtBasicLevel->if->debug->isDumpEnabled->debug->getName->dump->else->if->debug->isDumpEnabled->debug->getName->dump->else->if->debug->isDumpEnabled->debug->getName->dump->if->debug->isDumpEnabled->debug->getName->dump
BasePhase#shouldDump(StructuredGraph, C)::: base phase should dump:::debug->graph->getDebug->phaseChange->graph->getOptions->getValue->if->Pattern->getClass->getSimpleName->matches->graphCopy->graph->graph->getDebug->copy->listener->new->GraphChangeListener->try->s->graphCopy->trackNodeEvents->try->s2->debug->sandbox->run->catch->debug->handle->finally->catch->finally->return->return
BasePhase.GraphChangeListener#changed(NodeEvent, Node)::: graph change listener changed:::if->graph->isNew->node->isAlive->if
BasePhase#getName()::: base phase get name:::return->BasePhase.this->getClass->new->ClassTypeSequence
BasePhase#run(StructuredGraph, C)::: base phase run:::
BasePhase#contractorName()::: base phase contractor name:::return->getName->toString
BasePhase#codeSizeIncrease()::: base phase code size increase:::return
ClassTypeSequence#getName()::: class type sequence get name:::return->clazz->getName->replace
ClassTypeSequence#toJavaName()::: class type sequence to java name:::return->toJavaName
ClassTypeSequence#toJavaName(boolean)::: class type sequence to java name:::if->return->clazz->getName->else->lastDot->clazz->getName->lastIndexOf->return->clazz->getName->substring
ClassTypeSequence#getComponentType()::: class type sequence get component type:::return
ClassTypeSequence#getArrayClass()::: class type sequence get array class:::return
ClassTypeSequence#getJavaKind()::: class type sequence get java kind:::return
ClassTypeSequence#resolve(ResolvedJavaType)::: class type sequence resolve:::throw->new->UnsupportedOperationException
ClassTypeSequence#length()::: class type sequence length:::return->clazz->getName->length
ClassTypeSequence#charAt(int)::: class type sequence char at:::return->clazz->getName->charAt
ClassTypeSequence#subSequence(int, int)::: class type sequence sub sequence:::return->clazz->getName->subSequence
ClassTypeSequence#toString()::: class type sequence to string:::return->clazz->getName
LazyName#length()::: lazy name length:::return->toString->length
LazyName#charAt(int)::: lazy name char at:::return->toString->charAt
LazyName#subSequence(int, int)::: lazy name sub sequence:::return->toString->subSequence
LazyName#toString()::: lazy name to string:::if->createString->return
LazyName#createString():::Creates the String value of this name.:::
OptimisticOptimizations#addOptimization(OptionValues, ProfilingInfo, DeoptimizationReason, Optimization)::: optimistic optimizations add optimization:::if->checkDeoptimizations->enabledOpts->add
OptimisticOptimizations#remove(Optimization...)::: optimistic optimizations remove:::newOptimizations->EnumSet->copyOf->foreach->newOptimizations->remove->return->new->OptimisticOptimizations
OptimisticOptimizations#add(Optimization...)::: optimistic optimizations add:::newOptimizations->EnumSet->copyOf->foreach->newOptimizations->add->return->new->OptimisticOptimizations
OptimisticOptimizations#removeNeverExecutedCode(OptionValues)::: optimistic optimizations remove never executed code:::return->getValue->enabledOpts->contains
OptimisticOptimizations#useTypeCheckHints(OptionValues)::: optimistic optimizations use type check hints:::return->getValue->enabledOpts->contains
OptimisticOptimizations#inlineMonomorphicCalls(OptionValues)::: optimistic optimizations inline monomorphic calls:::return->getValue->enabledOpts->contains
OptimisticOptimizations#inlinePolymorphicCalls(OptionValues)::: optimistic optimizations inline polymorphic calls:::return->getValue->enabledOpts->contains
OptimisticOptimizations#inlineMegamorphicCalls(OptionValues)::: optimistic optimizations inline megamorphic calls:::return->getValue->enabledOpts->contains
OptimisticOptimizations#devirtualizeInvokes(OptionValues)::: optimistic optimizations devirtualize invokes:::return->getValue->enabledOpts->contains
OptimisticOptimizations#useExceptionProbability(OptionValues)::: optimistic optimizations use exception probability:::return->getValue->enabledOpts->contains
OptimisticOptimizations#useExceptionProbabilityForOperations()::: optimistic optimizations use exception probability for operations:::return->enabledOpts->contains
OptimisticOptimizations#useLoopLimitChecks(OptionValues)::: optimistic optimizations use loop limit checks:::return->getValue->enabledOpts->contains
OptimisticOptimizations#lessOptimisticThan(OptimisticOptimizations)::: optimistic optimizations less optimistic than:::foreach->Optimization->values->if->enabledOpts->contains->contains->return->return
OptimisticOptimizations#checkDeoptimizations(OptionValues, ProfilingInfo, DeoptimizationReason)::: optimistic optimizations check deoptimizations:::return->profilingInfo->getDeoptimizationCount->getValue
OptimisticOptimizations#toString()::: optimistic optimizations to string:::return->enabledOpts->toString
Phase#apply(StructuredGraph)::: phase apply:::apply
Phase#apply(StructuredGraph, boolean)::: phase apply:::apply
Phase#run(StructuredGraph)::: phase run:::
Phase#run(StructuredGraph, Object)::: phase run:::run
PhaseSuite#checkContract()::: phase suite check contract:::return
PhaseSuite#isImmutable()::: phase suite is immutable:::return
PhaseSuite#setImmutable()::: phase suite set immutable:::if->Collections->unmodifiableList
PhaseSuite#prependPhase(BasePhase):::Add a new phase at the beginning of this suite.:::phases->add
PhaseSuite#appendPhase(BasePhase):::Add a new phase at the end of this suite.:::phases->add
PhaseSuite#addBeforeLast(BasePhase):::Inserts a phase before the last phase in the suite:::last->findLastPhase->if->last->hasPrevious->last->previous->last->add
PhaseSuite#findLastPhase():::Returns a ListIterator at the position of the last phase in the suite:::it->phases->listIterator->while->it->hasNext->it->next->return
PhaseSuite#getPhases():::Gets an unmodifiable view on the phases in this suite.:::return->Collections->unmodifiableList
PhaseSuite#findPhase(Class>):::Returns a ListIterator at the position of the first phase which is an instance of phaseClass or null if no such phase can be found:::return->findPhase
PhaseSuite#findPhase(Class>, boolean):::Returns a ListIterator at the position of the first phase which is an instance of phaseClass or, if recursive is true, is a PhaseSuite containing a phase which is an instance of phaseClass:::it->phases->listIterator->if->findNextPhase->return->else->return
PhaseSuite#findNextPhase(ListIterator>, Class>)::: phase suite find next phase:::return->findNextPhase
PhaseSuite#findNextPhase(ListIterator>, Class>, boolean)::: phase suite find next phase:::while->it->hasNext->phase->it->next->if->phaseClass->isInstance->return->else->if->suite->if->suite->findPhase->return->return
PhaseSuite#removePhase(Class>):::Removes the first instance of the given phase class, looking recursively into inner phase suites.:::it->phases->listIterator->while->it->hasNext->phase->it->next->if->phaseClass->isInstance->it->remove->return->else->if->innerSuite->if->innerSuite->removePhase->if->isEmpty->it->remove->return->return
PhaseSuite#replacePhase(Class>, BasePhase):::Removes the first instance of the given phase class, looking recursively into inner phase suites.:::it->phases->listIterator->while->it->hasNext->phase->it->next->if->phaseClass->isInstance->it->set->return->else->if->innerSuite->if->innerSuite->replacePhase->return->return
PhaseSuite#run(StructuredGraph, C)::: phase suite run:::foreach->phase->apply
PhaseSuite#copy()::: phase suite copy:::suite->new->PhaseSuite<>->addAll->return
VerifyPhase#run(StructuredGraph, C)::: verify phase run:::verify
VerifyPhase#verify(StructuredGraph, C):::Checks graph against some invariants.:::
VerifyPhase#verifyClass(Class, MetaAccessProvider):::Checks clazz against some invariants.:::
