BasicJavacTask#getContext():::For internal use only:::return
DiagnosticFormatter#displaySource(D):::Whether the source code output for this diagnostic is to be displayed.:::
DiagnosticFormatter#format(D, Locale):::Format the contents of a diagnostics.:::
DiagnosticFormatter#formatMessage(D, Locale):::Controls the way in which a diagnostic message is displayed.:::
DiagnosticFormatter#formatKind(D, Locale):::Controls the way in which a diagnostic kind is displayed.:::
DiagnosticFormatter#formatSource(D, boolean, Locale):::Controls the way in which a diagnostic source is displayed.:::
DiagnosticFormatter#formatPosition(D, PositionKind, Locale):::Controls the way in which a diagnostic position is displayed.:::
DiagnosticFormatter#getConfiguration():::Get a list of all the enabled verbosity options.:::
DiagnosticFormatter.Configuration#setVisible(Set):::Configure the set of diagnostic parts that should be displayed by the formatter.:::
DiagnosticFormatter.Configuration#getVisible():::Retrieve the set of diagnostic parts that should be displayed by the formatter.:::
DiagnosticFormatter.Configuration#setMultilineLimit(MultilineLimit, int):::Set a limit for multiline diagnostics:::
DiagnosticFormatter.Configuration#getMultilineLimit(MultilineLimit):::Get a multiline diagnostic limit.:::
Formattable#toString(Locale, Messages):::Used to obtain a localized String representing the object accordingly to a given locale:::
Formattable#getKind():::Retrieve a pretty name of this object's kind:::
JavacTaskImpl#enter():::Translate all the abstract syntax trees to elements.:::return->enter
JavacTaskImpl#enter(Iterable):::Translate the given abstract syntax trees to elements.:::if->notYetEntered->isEmpty->return->List->nil->wasInitialized->prepareCompiler->roots->if->if->notYetEntered->size->if->parseInternal->foreach->args->getFileObjects->unit->notYetEntered->remove->if->if->new->ListBuffer<>->roots->append->notYetEntered->clear->else->foreach->if->if->new->ListBuffer<>->roots->append->notYetEntered->cu->getSourceFile->remove->else->throw->cu->toString->new->IllegalArgumentException->if->if->compiler->List->nil->initModules->return->List->nil->units->compiler->roots->toList->initModules->try->compiler->enterTrees->if->notYetEntered->isEmpty->compiler->processAnnotations->elements->new->ListBuffer<>->foreach->isPkgInfo->isNameCompatible->if->elements->append->else->foreach->if->node->hasTag->cdef->if->elements->append->else->if->node->hasTag->mdef->if->elements->append->return->elements->toList->catch->finally->flush
JavacTaskImpl#generate(Iterable):::Generate code corresponding to the given classes:::results->new->ListBuffer<>->try->analyze->if->compiler->compiler->desugar->generate->genList->clear->else->f->new->Filter->f->run->if->genList->isEmpty->compiler->reportDeferredDiagnostics->cleanup->catch->finally->if->flush->return
JavacTaskImpl#parseType(String, TypeElement):::For internal use only:::if->expr->equals->throw->new->IllegalArgumentException->JavaCompiler->instance->prev->useSource->parserFactory->ParserFactory->instance->attr->Attr->instance->try->buf->CharBuffer->toCharArray->expr->length->wrap->parser->parserFactory->newParser->tree->parser->parseType->return->attr->attribType->catch->finally->useSource
JavacTaskPool#getTask(Writer, JavaFileManager, DiagnosticListener, Iterable, Iterable, Iterable, Worker):::Creates a new task as if by javax.tools.JavaCompiler#getTask and runs the provided worker with it:::opts->StreamSupport->options->spliterator->stream->Collectors->ArrayList->new->toCollection->collect->ctx->synchronized->cached->options2Contexts->Collections->emptyList->getOrDefault->if->cached->isEmpty->new->ReusableContext->else->cached->remove->task->systemProvider->getTask->task->addTaskListener->result->worker->withTask->ctx->clear->if->else->task->cleanup->synchronized->while->cacheSize->toRemove->options2Contexts->values->stream->Collection->stream->flatMap->sorted->findFirst->get->options2Contexts->get->remove->options2Contexts->new->ArrayList<>->computeIfAbsent->add->return
JavacTool#create():::Static factory method for creating new instances of this tool.:::return->new->JavacTool
JavacTrees#getOriginalType(javax.lang.model.type.ErrorType):::Returns the original type from the ErrorType object.:::if->return->getOriginalType->if->errorType->getKind->ct->return->extraType2OriginalMap->ct->getEnclosingType->ct->getMetadata->new->ClassType->computeIfAbsent->return
JavacTrees#printMessage(Diagnostic.Kind, CharSequence, com.sun.source.tree.Tree, com.sun.source.tree.CompilationUnitTree):::Prints a message of the specified kind at the location of the tree within the provided compilation unit:::pos->printMessage
Messages#add(String):::Add a new resource bundle to the list that is searched for localized messages.:::
Messages#getLocalizedString(Locale, String, Object...):::Get a localized formatted string.:::
MultiTaskListener#instance(Context):::Get the MultiTaskListener instance for this context.:::instance->context->get->if->new->MultiTaskListener->return
WrappingJavaFileManager#wrap(FileObject):::This implementation returns the given file object:::return
WrappingJavaFileManager#wrap(JavaFileObject):::This implementation forwards to #wrap(FileObject):::return->wrap
WrappingJavaFileManager#unwrap(FileObject):::This implementation returns the given file object:::return
WrappingJavaFileManager#unwrap(JavaFileObject):::This implementation forwards to #unwrap(FileObject):::return->unwrap
WrappingJavaFileManager#wrap(Iterable):::This implementation maps the given list of file objects by calling wrap on each:::mapped->new->ArrayList<>->foreach->mapped->wrap->add->return->Collections->unmodifiableList
WrappingJavaFileManager#unwrap(URI):::This implementation returns the given URI:::return
