AccessorGenerator#emitBoxingContantPoolEntries():::Constant pool entries required to be able to box/unbox primitive         types:::asm->emitConstantPoolUTF8->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolClass->asm->cpi->asm->emitConstantPoolUTF8->asm->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi->asm->emitConstantPoolUTF8->asm->emitConstantPoolUTF8->asm->asm->cpi->sub->asm->cpi->emitConstantPoolNameAndType->asm->asm->cpi->sub->asm->cpi->emitConstantPoolMethodref->asm->cpi
AccessorGenerator#getClassName(Class, boolean):::Returns class name in "internal" form (i.e., '/' separators         instead of '.'):::if->c->isPrimitive->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->throw->new->InternalError->else->if->c->isArray->return->c->getComponentType->getClassName->else->if->return->c->getName->internalize->else->return->c->getName->internalize
AccessorGenerator#canWidenTo(Class, Class):::Returns true for widening or identity conversions for primitive         types only:::if->type->isPrimitive->return->if->if->return->else->if->if->return->else->if->if->return->else->if->if->return->else->if->if->return->else->if->if->return->else->if->if->return->else->if->if->return->return
AccessorGenerator#emitWideningBytecodeForPrimitiveConversion(ClassFileAssembler, Class, Class):::Emits the widening bytecode for the given primitive conversion         (or none if the identity conversion):::if->if->cb->opc_i2l->else->if->cb->opc_i2f->else->if->cb->opc_i2d->else->if->if->cb->opc_l2f->else->if->cb->opc_l2d->else->if->if->cb->opc_f2d
AccessorGenerator#isPrimitive(Class):::We don't consider "Void" to be a primitive type:::return->c->isPrimitive
ClassDefiner#defineClass(String, byte[], int, int, ClassLoader):::<P> We define generated code into a new class loader which       delegates to the defining loader of the target class:::newLoader->AccessController->new->PrivilegedAction<ClassLoader>->doPrivileged->return->unsafe->defineClass
ClassFileAssembler#getLength():::Length in bytes:::return->vec->getLength
ClassFileAssembler#cpi():::Keeps track of the current (one-based) constant pool index;         incremented after emitting one of the following constant pool         entries:::if->throw->new->RuntimeException->return
ClassFileAssembler#setMaxLocals(int):::It's necessary to be able to specify the number of arguments at         the beginning of the method (which translates to the initial         value of max locals):::
ClassFileAssembler#getStack():::Needed to do flow control:::return
ClassFileAssembler#setStack(int):::Needed to do flow control.:::if
ClassFileAssembler#opc_ifeq(Label):::Control flow with forward-reference BCI:::instrBCI->getLength->emitByte->l->getLength->getStack->add->emitShort
ClassFileAssembler#opc_if_icmpeq(Label):::Control flow with forward-reference BCI:::instrBCI->getLength->emitByte->l->getLength->getStack->add->emitShort
ClassFileAssembler#opc_goto(Label):::Control flow with forward-reference BCI:::instrBCI->getLength->emitByte->l->getLength->getStack->add->emitShort
ClassFileAssembler#opc_ifnull(Label):::Control flow with forward-reference BCI:::instrBCI->getLength->emitByte->l->getLength->getStack->add->emitShort->decStack
ClassFileAssembler#opc_ifnonnull(Label):::Control flow with forward-reference BCI:::instrBCI->getLength->emitByte->l->getLength->getStack->add->emitShort->decStack
ClassFileAssembler#opc_invokevirtual(short, int, int):::Long and double arguments and return types count as 2 arguments;         other values count as 1.:::emitByte->emitShort->getStack->setStack
ClassFileAssembler#opc_invokespecial(short, int, int):::Long and double arguments and return types count as 2 arguments;         other values count as 1.:::emitByte->emitShort->getStack->setStack
ClassFileAssembler#opc_invokestatic(short, int, int):::Long and double arguments and return types count as 2 arguments;         other values count as 1.:::emitByte->emitShort->getStack->setStack
ClassFileAssembler#opc_invokeinterface(short, int, byte, int):::Long and double arguments and return types count as 2 arguments;         other values count as 1.:::emitByte->emitShort->emitByte->emitByte->getStack->setStack
ClassFileAssembler#opc_checkcast(short):::Assumes the checkcast succeeds:::emitByte->emitShort
ConstructorAccessor#newInstance(Object[]):::Matches specification in java.lang.reflect.Constructor:::
ConstructorAccessorImpl#newInstance(Object[]):::Matches specification in java.lang.reflect.Constructor:::
FieldAccessor#get(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getBoolean(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getByte(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getChar(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getShort(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getInt(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getLong(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getFloat(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#getDouble(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#set(Object, Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setBoolean(Object, boolean):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setByte(Object, byte):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setChar(Object, char):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setShort(Object, short):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setInt(Object, int):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setLong(Object, long):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setFloat(Object, float):::Matches specification in java.lang.reflect.Field:::
FieldAccessor#setDouble(Object, double):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#get(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getBoolean(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getByte(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getChar(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getShort(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getInt(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getLong(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getFloat(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#getDouble(Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#set(Object, Object):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setBoolean(Object, boolean):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setByte(Object, byte):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setChar(Object, char):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setShort(Object, short):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setInt(Object, int):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setLong(Object, long):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setFloat(Object, float):::Matches specification in java.lang.reflect.Field:::
FieldAccessorImpl#setDouble(Object, double):::Matches specification in java.lang.reflect.Field:::
LangReflectAccess#newField(Class, String, Class, int, int, String, byte[]):::Creates a new java.lang.reflect.Field:::
LangReflectAccess#newMethod(Class, String, Class[], Class, Class[], int, int, String, byte[], byte[], byte[]):::Creates a new java.lang.reflect.Method:::
LangReflectAccess#newConstructor(Class, Class[], Class[], int, int, String, byte[], byte[]):::Creates a new java.lang.reflect.Constructor:::
LangReflectAccess#getMethodAccessor(Method):::Gets the MethodAccessor object for a java.lang.reflect.Method:::
LangReflectAccess#setMethodAccessor(Method, MethodAccessor):::Sets the MethodAccessor object for a java.lang.reflect.Method:::
LangReflectAccess#getConstructorAccessor(Constructor):::Gets the ConstructorAccessor object for a         java.lang.reflect.Constructor:::
LangReflectAccess#setConstructorAccessor(Constructor, ConstructorAccessor):::Sets the ConstructorAccessor object for a         java.lang.reflect.Constructor:::
LangReflectAccess#getExecutableTypeAnnotationBytes(Executable):::Gets the byte[] that encodes TypeAnnotations on an Executable.:::
LangReflectAccess#getConstructorSlot(Constructor):::Gets the "slot" field from a Constructor (used for serialization):::
LangReflectAccess#getConstructorSignature(Constructor):::Gets the "signature" field from a Constructor (used for serialization):::
LangReflectAccess#getConstructorAnnotations(Constructor):::Gets the "annotations" field from a Constructor (used for serialization):::
LangReflectAccess#getConstructorParameterAnnotations(Constructor):::Gets the "parameterAnnotations" field from a Constructor (used for serialization):::
LangReflectAccess#getExecutableSharedParameterTypes(Executable):::Gets the shared array of parameter types of an Executable.:::
LangReflectAccess#copyMethod(Method):::Makes a "child" copy of a Method:::
LangReflectAccess#leafCopyMethod(Method):::Makes a copy of this non-root a Method:::
LangReflectAccess#copyField(Field):::Makes a "child" copy of a Field:::
LangReflectAccess#copyConstructor(Constructor):::Makes a "child" copy of a Constructor:::
LangReflectAccess#getRoot(T):::Gets the root of the given AccessibleObject object; null if arg is the root:::
MethodAccessor#invoke(Object, Object[]):::Matches specification in java.lang.reflect.Method:::
MethodAccessorGenerator#generateMethod(Class, String, Class[], Class, Class[], int):::This routine is not thread-safe:::return->generate
MethodAccessorGenerator#generateConstructor(Class, Class[], Class[], int):::This routine is not thread-safe:::return->generate
MethodAccessorGenerator#generateSerializationConstructor(Class, Class[], Class[], int, Class):::This routine is not thread-safe:::return->generate
MethodAccessorImpl#invoke(Object, Object[]):::Matches specification in java.lang.reflect.Method:::
Reflection#getCallerClass():::Returns the class of the caller of the method calling this method,         ignoring frames associated with java.lang.reflect.Method.invoke()         and its implementation.:::
Reflection#getClassAccessFlags(Class):::Retrieves the access flags written to the class file:::
Reflection#ensureMemberAccess(Class, Class, Class, int):::Ensures that access to a member is granted and throws IllegalAccessException if not.:::if->verifyMemberAccess->throw->newIllegalAccessException
Reflection#verifyMemberAccess(Class, Class, Class, int):::Verify access to a member and return true if it is granted.:::if->return->if->currentClass->getModule->verifyModuleAccess->return->gotIsSameClassPackage->isSameClassPackage->if->Modifier->getClassAccessFlags->isPublic->isSameClassPackage->if->return->if->Modifier->isPublic->return->if->Modifier->isPrivate->if->areNestMates->return->successSoFar->if->Modifier->isProtected->if->isSubclassOf->if->Modifier->isPrivate->if->isSameClassPackage->if->if->return->if->Modifier->isProtected->if->isSameClassPackage->if->if->isSubclassOf->return->return
Reflection#verifyModuleAccess(Module, Class):::Returns true if memberClass's module exports memberClass's package to currentModule.:::memberModule->memberClass->getModule->if->return->else->pkg->memberClass->getPackageName->return->memberModule->isExported
Reflection#isCallerSensitive(Method):::Tests if the given method is caller-sensitive and the declaring class is defined by either the bootstrap class loader or platform class loader.:::loader->m->getDeclaringClass->getClassLoader->if->VM->isSystemDomainLoader->return->m->isAnnotationPresent->return
Reflection#newIllegalAccessException(Class, Class, Class, int):::Returns an IllegalAccessException with an exception message based on the access that is denied.:::currentSuffix->memberSuffix->m1->currentClass->getModule->if->m1->isNamed->m2->memberClass->getModule->if->m2->isNamed->memberPackageName->memberClass->getPackageName->msg->if->m2->isExported->Modifier->toString->else->if->m2->isNamed->return->new->IllegalAccessException
Reflection#areNestMates(Class, Class):::Returns true if currentClass and memberClass are nestmates - that is, if they have the same nesthost as determined by the VM.:::
ReflectionFactory#getReflectionFactory():::Provides the caller with the capability to instantiate reflective objects:::security->System->getSecurityManager->if->security->checkPermission->return
ReflectionFactory#setLangReflectAccess(LangReflectAccess):::Called only by java.lang.reflect.Modifier's static initializer:::
ReflectionFactory#newFieldAccessor(Field, boolean):::Note: this routine can cause the declaring class for the field be initialized and therefore must not be called until the first get/set of this field.:::checkInitted->root->langReflectAccess->getRoot->if->if->root->getModifiers->field->getModifiers->return->UnsafeFieldAccessorFactory->newFieldAccessor
ReflectionFactory#newField(Class, String, Class, int, int, String, byte[]):::Creates a new java.lang.reflect.Field:::return->langReflectAccess->newField
ReflectionFactory#newMethod(Class, String, Class[], Class, Class[], int, int, String, byte[], byte[], byte[]):::Creates a new java.lang.reflect.Method:::return->langReflectAccess->newMethod
ReflectionFactory#newConstructor(Class, Class[], Class[], int, int, String, byte[], byte[]):::Creates a new java.lang.reflect.Constructor:::return->langReflectAccess->newConstructor
ReflectionFactory#getMethodAccessor(Method):::Gets the MethodAccessor object for a java.lang.reflect.Method:::return->langReflectAccess->getMethodAccessor
ReflectionFactory#setMethodAccessor(Method, MethodAccessor):::Sets the MethodAccessor object for a java.lang.reflect.Method:::langReflectAccess->setMethodAccessor
ReflectionFactory#getConstructorAccessor(Constructor):::Gets the ConstructorAccessor object for a         java.lang.reflect.Constructor:::return->langReflectAccess->getConstructorAccessor
ReflectionFactory#setConstructorAccessor(Constructor, ConstructorAccessor):::Sets the ConstructorAccessor object for a         java.lang.reflect.Constructor:::langReflectAccess->setConstructorAccessor
ReflectionFactory#copyMethod(Method):::Makes a copy of the passed method:::return->langReflectAccess->copyMethod
ReflectionFactory#leafCopyMethod(Method):::Makes a copy of the passed method:::return->langReflectAccess->leafCopyMethod
ReflectionFactory#copyField(Field):::Makes a copy of the passed field:::return->langReflectAccess->copyField
ReflectionFactory#copyConstructor(Constructor):::Makes a copy of the passed constructor:::return->langReflectAccess->copyConstructor
ReflectionFactory#getExecutableTypeAnnotationBytes(Executable):::Gets the byte[] that encodes TypeAnnotations on an executable.:::return->langReflectAccess->getExecutableTypeAnnotationBytes
ReflectionFactory#newConstructorForSerialization(Class):::Returns a constructor that allocates an instance of cl and that then initializes the instance by calling the no-arg constructor of its first non-serializable superclass:::initCl->while->isAssignableFrom->prev->if->initCl->getSuperclass->superHasAccessibleConstructor->return->constructorToCall->try->initCl->getDeclaredConstructor->mods->constructorToCall->getModifiers->if->packageEquals->return->catch->return->finally->return->generateConstructor
ReflectionFactory#writeReplaceForSerialization(Class):::Returns a MethodHandle for writeReplace on the serializable class or null if no match found.:::return->getReplaceResolveForSerialization
ReflectionFactory#readResolveForSerialization(Class):::Returns a MethodHandle for readResolve on the serializable class or null if no match found.:::return->getReplaceResolveForSerialization
ReflectionFactory#hasStaticInitializerForSerialization(Class):::Returns true if the given class defines a static initializer method, false otherwise.:::m->if->try->new->Class<?>Arr->getDeclaredMethod->m->setAccessible->catch->throw->new->InternalError->finally->try->return->m->invoke->catch->throw->new->InternalError->finally
ReflectionFactory#newOptionalDataExceptionForSerialization():::Return the accessible constructor for OptionalDataException signaling eof.:::try->boolCtor->getDeclaredConstructor->boolCtor->setAccessible->return->catch->throw->new->InternalError->finally
SignatureIterator#returnType():::Should only be called when atEnd() is true:::if->atEnd->throw->new->InternalError->return->sig->sig->length->substring
