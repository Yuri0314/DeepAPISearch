CompositeValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure):::Invoke proc on each Value element of this CompositeValue:::
CompositeValue#visitValueArray(LIRInstruction, Value[], OperandMode, InstructionValueProcedure, EnumSet):::A helper method to visit Value[] ensuring that a copy of the array is made if it's needed.:::newValues->for->i->return
ControlFlowOptimizer#run(TargetDescription, LIRGenerationResult, PostAllocationOptimizationContext):::Performs control flow optimizations on the given LIR graph.:::lir->lirGenRes->getLIR->new->Optimizer->lir->codeEmittingOrder->deleteEmptyBlocks
InstructionValueConsumer#visitValue(LIRInstruction, Value, OperandMode, EnumSet):::Iterator method to be overwritten.:::
InstructionValueProcedure#doValue(LIRInstruction, Value, OperandMode, EnumSet):::Iterator method to be overwritten.:::
LabelRef#forSuccessor(LIR, AbstractBlockBase, int):::Returns a new reference to a successor of the given block.:::return->new->LabelRef
LIR#hasDebugInfo():::Determines if any instruction in the LIR has debug info associated with it.:::foreach->linearScanOrder->foreach->getLIRforBlock->if->op->hasState->return->return
LIR#linearScanOrder():::Gets the linear scan ordering of blocks as an array.:::return
LIR#hasArgInCallerFrame():::Determines if any of the parameters to the method are passed via the stack where the parameters are located in the caller's frame.:::return
LIR#getNextBlock(AbstractBlockBase[], int):::Gets the next non-null block in a list.:::for->nextIndex->return
LIR#getExceptionEdge(LIRInstruction):::Gets the exception edge (if any) originating at a given operation.:::exceptionEdge->op->if->forEachState->return
LIRFrameState#forEachState(LIRInstruction, InstructionValueProcedure):::Iterates the frame state and calls the InstructionValueProcedure for every variable.:::for->cur->cur->caller->if->foreach->obj->getValues->processValues->if->liveBasePointers->forEach
LIRFrameState#visitEachState(LIRInstruction, InstructionValueConsumer):::Iterates the frame state and calls the InstructionValueConsumer for every variable.:::for->cur->cur->caller->if->foreach->obj->getValues->visitValues->if->liveBasePointers->visitEach
LIRFrameState#initDebugInfo(FrameMap, boolean):::Called by the register allocator to initialize the frame state.:::new->DebugInfo
LIRInsertionBuffer#init(List):::Initialize this buffer:::
LIRInsertionBuffer#append(int, LIRInstruction):::Enqueue a new instruction that will be appended to the instruction list when #finish() is called:::i->numberOfInsertionPoints->if->indexAt->appendNew->else->countAt->setCountAt->ops->add
LIRInsertionBuffer#finish():::Append all enqueued instructions to the instruction list:::if->ops->size->n->lir->size->for->i->ops->size->opIndex->ops->size->ipIndex->numberOfInsertionPoints->fromIndex->toIndex->lir->size->while->index->indexAt->while->lir->lir->get->set->for->i->countAt->ops->clear
LIRInstruction#isMoveOp():::Returns true if the instruction is a MoveOp:::return->instructionClass->isMoveOp
LIRInstruction#isValueMoveOp():::Returns true if the instruction is a ValueMoveOp:::return->instructionClass->isValueMoveOp
LIRInstruction#isLoadConstantOp():::Returns true if the instruction is a LoadConstantOp:::return->instructionClass->isLoadConstantOp
LIRInstruction#addStackSlotsToTemporaries(Value[], Value[]):::Utility method to add stack arguments to a list of temporaries:::extraTemps->foreach->if->isStackSlot->if->index->newTemporaries->Arrays->copyOf->foreach->if->isStackSlot->return->return
LIRInstruction#setComment(LIRGenerationResult, String):::Adds a comment to this instruction.:::res->setComment
LIRInstruction#getComment(LIRGenerationResult):::Gets the comment attached to this instruction.:::return->res->getComment
LIRIntrospection.ValueFieldInfo#compareTo(FieldsScanner.FieldInfo):::Sorts non-array fields before array fields.:::if->VALUE_ARRAY_CLASS->isAssignableFrom->if->VALUE_ARRAY_CLASS->isAssignableFrom->return->else->if->VALUE_ARRAY_CLASS->isAssignableFrom->return->return->super->compareTo
LIRValueUtil#differentRegisters(Object...):::Checks if all the provided values are different physical registers:::registers->new->ArrayList<Register>->collectRegisters->for->i->registers->size->return
LIRValueUtil#subtractRegisters(Value[], Value[]):::Subtract sets of registers (x - y).:::result->new->ArrayList<>->foreach->append->foreach->if->sameRegister->break->if->result->add->resultArray->result->size->new->ValueArr->return->result->toArray
StandardOp.SaveRegistersOp#supportsRemove():::Determines if the #remove(EconomicSet) operation is supported for this object.:::
StandardOp.SaveRegistersOp#remove(EconomicSet):::Prunes doNotSave from the registers saved by this operation.:::
StandardOp.SaveRegistersOp#getMap(FrameMap):::Gets a map from the saved registers saved by this operation to the frame slots in which they are saved.:::
SwitchStrategy.BaseSwitchClosure#conditionalJump(int, Condition, Label):::This method generates code for a comparison between the actual value and the constant at the given index and a condition jump to target.:::
SwitchStrategy#registerEffort(int, int, int):::Tells the system that the given (inclusive) range of keys is reached after depth number of comparisons, which is used to calculate the average effort.:::if->for->i
SwitchStrategy#registerDefaultEffort(int):::Tells the system that the default successor is reached after depth number of comparisons, which is used to calculate average effort.:::if
SwitchStrategy#getBestStrategy(double[], JavaConstant[], LabelRef[]):::Creates all switch strategies for the given switch, evaluates them (based on average effort) and returns the best one.:::strategies->getStrategies->bestEffort->bestStrategy->foreach->if->strategy->getAverageEffort->strategy->getAverageEffort->return
ValueConsumer#visitValue(Value, OperandMode, EnumSet):::Iterator method to be overwritten.:::
ValueProcedure#doValue(Value, OperandMode, EnumSet):::Iterator method to be overwritten.:::
