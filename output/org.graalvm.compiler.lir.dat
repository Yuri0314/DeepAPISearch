org.graalvm.compiler.lir.CompositeValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)->CompositeValue:::Invoke proc on each Value element of this CompositeValue
org.graalvm.compiler.lir.CompositeValue#visitValueArray(LIRInstruction, Value[], OperandMode, InstructionValueProcedure, EnumSet)->Value[]:::A helper method to visit Value[] ensuring that a copy of the array is made if it's needed.
org.graalvm.compiler.lir.CompositeValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)->void::: composite value visit each component
org.graalvm.compiler.lir.CompositeValue#toString()->String::: composite value to string
org.graalvm.compiler.lir.CompositeValue#hashCode()->int::: composite value hash code
org.graalvm.compiler.lir.CompositeValue#equals(Object)->boolean::: composite value equals
org.graalvm.compiler.lir.CompositeValueClass#get(Class)->CompositeValueClass::: composite value class get
org.graalvm.compiler.lir.CompositeValueClass#getAllFields()->Fields[]::: composite value class get all fields
org.graalvm.compiler.lir.CompositeValueClass#toString()->String::: composite value class to string
org.graalvm.compiler.lir.CompositeValueClass#format(CompositeValue)->String::: composite value class format
org.graalvm.compiler.lir.ConstantValue#getConstant()->Constant::: constant value get constant
org.graalvm.compiler.lir.ConstantValue#isJavaConstant()->boolean::: constant value is java constant
org.graalvm.compiler.lir.ConstantValue#getJavaConstant()->JavaConstant::: constant value get java constant
org.graalvm.compiler.lir.ConstantValue#toString()->String::: constant value to string
org.graalvm.compiler.lir.ConstantValue#equals(Object)->boolean::: constant value equals
org.graalvm.compiler.lir.ConstantValue#hashCode()->int::: constant value hash code
org.graalvm.compiler.lir.ControlFlowOptimizer#run(TargetDescription, LIRGenerationResult, PostAllocationOptimizationContext)->void:::Performs control flow optimizations on the given LIR graph.
org.graalvm.compiler.lir.EdgeMoveOptimizer#run(TargetDescription, LIRGenerationResult, PostAllocationOptimizationContext)->void::: edge move optimizer run
org.graalvm.compiler.lir.FullInfopointOp#emitCode(CompilationResultBuilder)->void::: full infopoint op emit code
org.graalvm.compiler.lir.InstructionStateProcedure#doState(LIRInstruction, LIRFrameState)->void::: instruction state procedure do state
org.graalvm.compiler.lir.InstructionValueConsumer#visitValue(LIRInstruction, Value, OperandMode, EnumSet)->void:::Iterator method to be overwritten.
org.graalvm.compiler.lir.InstructionValueProcedure#doValue(LIRInstruction, Value, OperandMode, EnumSet)->Value:::Iterator method to be overwritten.
org.graalvm.compiler.lir.LabelRef#forSuccessor(LIR, AbstractBlockBase, int)->LabelRef:::Returns a new reference to a successor of the given block.
org.graalvm.compiler.lir.LabelRef#getSourceBlock()->AbstractBlockBase::: label ref get source block
org.graalvm.compiler.lir.LabelRef#getTargetBlock()->AbstractBlockBase::: label ref get target block
org.graalvm.compiler.lir.LabelRef#label()->Label::: label ref label
org.graalvm.compiler.lir.LabelRef#toString()->String::: label ref to string
org.graalvm.compiler.lir.LIR#getControlFlowGraph()->AbstractControlFlowGraph::: r get control flow graph
org.graalvm.compiler.lir.LIR#getOptions()->OptionValues::: r get options
org.graalvm.compiler.lir.LIR#getDebug()->DebugContext::: r get debug
org.graalvm.compiler.lir.LIR#hasDebugInfo()->boolean:::Determines if any instruction in the LIR has debug info associated with it.
org.graalvm.compiler.lir.LIR#getLIRforBlock(AbstractBlockBase)->ArrayList::: r get rfor block
org.graalvm.compiler.lir.LIR#setLIRforBlock(AbstractBlockBase, ArrayList)->void::: r set rfor block
org.graalvm.compiler.lir.LIR#linearScanOrder()->AbstractBlockBase[]:::Gets the linear scan ordering of blocks as an array.
org.graalvm.compiler.lir.LIR#codeEmittingOrder()->AbstractBlockBase[]::: r code emitting order
org.graalvm.compiler.lir.LIR#setHasArgInCallerFrame()->void::: r set has arg in caller frame
org.graalvm.compiler.lir.LIR#hasArgInCallerFrame()->boolean:::Determines if any of the parameters to the method are passed via the stack where the parameters are located in the caller's frame.
org.graalvm.compiler.lir.LIR#getNextBlock(AbstractBlockBase[], int)->AbstractBlockBase:::Gets the next non-null block in a list.
org.graalvm.compiler.lir.LIR#getExceptionEdge(LIRInstruction)->LabelRef:::Gets the exception edge (if any) originating at a given operation.
org.graalvm.compiler.lir.LIR#verifyBlock(LIR, AbstractBlockBase)->boolean::: r verify block
org.graalvm.compiler.lir.LIR#verifyBlocks(LIR, AbstractBlockBase[])->boolean::: r verify blocks
org.graalvm.compiler.lir.LIR#resetLabels()->void::: r reset labels
org.graalvm.compiler.lir.LIRFrameState#hasDebugInfo()->boolean::: frame state has debug info
org.graalvm.compiler.lir.LIRFrameState#debugInfo()->DebugInfo::: frame state debug info
org.graalvm.compiler.lir.LIRFrameState#forEachState(LIRInstruction, InstructionValueProcedure)->void:::Iterates the frame state and calls the InstructionValueProcedure for every variable.
org.graalvm.compiler.lir.LIRFrameState#visitEachState(LIRInstruction, InstructionValueConsumer)->void:::Iterates the frame state and calls the InstructionValueConsumer for every variable.
org.graalvm.compiler.lir.LIRFrameState#processValues(LIRInstruction, JavaValue[], InstructionValueProcedure)->void::: frame state process values
org.graalvm.compiler.lir.LIRFrameState#visitValues(LIRInstruction, JavaValue[], InstructionValueConsumer)->void::: frame state visit values
org.graalvm.compiler.lir.LIRFrameState#initDebugInfo(FrameMap, boolean)->void:::Called by the register allocator to initialize the frame state.
org.graalvm.compiler.lir.LIRFrameState#getLiveBasePointers()->IndexedValueMap::: frame state get live base pointers
org.graalvm.compiler.lir.LIRFrameState#setLiveBasePointers(IndexedValueMap)->void::: frame state set live base pointers
org.graalvm.compiler.lir.LIRFrameState#toString()->String::: frame state to string
org.graalvm.compiler.lir.LIRInsertionBuffer#init(List)->void:::Initialize this buffer
org.graalvm.compiler.lir.LIRInsertionBuffer#initialized()->boolean::: insertion buffer initialized
org.graalvm.compiler.lir.LIRInsertionBuffer#lirList()->List::: insertion buffer lir list
org.graalvm.compiler.lir.LIRInsertionBuffer#append(int, LIRInstruction)->void:::Enqueue a new instruction that will be appended to the instruction list when #finish() is called
org.graalvm.compiler.lir.LIRInsertionBuffer#finish()->void:::Append all enqueued instructions to the instruction list
org.graalvm.compiler.lir.LIRInstruction#emitCode(CompilationResultBuilder)->void::: instruction emit code
org.graalvm.compiler.lir.LIRInstruction#id()->int::: instruction id
org.graalvm.compiler.lir.LIRInstruction#setId(int)->void::: instruction set id
org.graalvm.compiler.lir.LIRInstruction#getPosition()->NodeSourcePosition::: instruction get position
org.graalvm.compiler.lir.LIRInstruction#setPosition(NodeSourcePosition)->void::: instruction set position
org.graalvm.compiler.lir.LIRInstruction#name()->String::: instruction name
org.graalvm.compiler.lir.LIRInstruction#hasOperands()->boolean::: instruction has operands
org.graalvm.compiler.lir.LIRInstruction#hasState()->boolean::: instruction has state
org.graalvm.compiler.lir.LIRInstruction#destroysCallerSavedRegisters()->boolean::: instruction destroys caller saved registers
org.graalvm.compiler.lir.LIRInstruction#forEachInput(InstructionValueProcedure)->void::: instruction for each input
org.graalvm.compiler.lir.LIRInstruction#forEachAlive(InstructionValueProcedure)->void::: instruction for each alive
org.graalvm.compiler.lir.LIRInstruction#forEachTemp(InstructionValueProcedure)->void::: instruction for each temp
org.graalvm.compiler.lir.LIRInstruction#forEachOutput(InstructionValueProcedure)->void::: instruction for each output
org.graalvm.compiler.lir.LIRInstruction#forEachState(InstructionValueProcedure)->void::: instruction for each state
org.graalvm.compiler.lir.LIRInstruction#forEachInput(ValueProcedure)->void::: instruction for each input
org.graalvm.compiler.lir.LIRInstruction#forEachAlive(ValueProcedure)->void::: instruction for each alive
org.graalvm.compiler.lir.LIRInstruction#forEachTemp(ValueProcedure)->void::: instruction for each temp
org.graalvm.compiler.lir.LIRInstruction#forEachOutput(ValueProcedure)->void::: instruction for each output
org.graalvm.compiler.lir.LIRInstruction#forEachState(ValueProcedure)->void::: instruction for each state
org.graalvm.compiler.lir.LIRInstruction#forEachState(InstructionStateProcedure)->void::: instruction for each state
org.graalvm.compiler.lir.LIRInstruction#forEachState(StateProcedure)->void::: instruction for each state
org.graalvm.compiler.lir.LIRInstruction#visitEachInput(InstructionValueConsumer)->void::: instruction visit each input
org.graalvm.compiler.lir.LIRInstruction#visitEachAlive(InstructionValueConsumer)->void::: instruction visit each alive
org.graalvm.compiler.lir.LIRInstruction#visitEachTemp(InstructionValueConsumer)->void::: instruction visit each temp
org.graalvm.compiler.lir.LIRInstruction#visitEachOutput(InstructionValueConsumer)->void::: instruction visit each output
org.graalvm.compiler.lir.LIRInstruction#visitEachState(InstructionValueConsumer)->void::: instruction visit each state
org.graalvm.compiler.lir.LIRInstruction#visitEachInput(ValueConsumer)->void::: instruction visit each input
org.graalvm.compiler.lir.LIRInstruction#visitEachAlive(ValueConsumer)->void::: instruction visit each alive
org.graalvm.compiler.lir.LIRInstruction#visitEachTemp(ValueConsumer)->void::: instruction visit each temp
org.graalvm.compiler.lir.LIRInstruction#visitEachOutput(ValueConsumer)->void::: instruction visit each output
org.graalvm.compiler.lir.LIRInstruction#visitEachState(ValueConsumer)->void::: instruction visit each state
org.graalvm.compiler.lir.LIRInstruction#forEachRegisterHint(Value, OperandMode, InstructionValueProcedure)->Value::: instruction for each register hint
org.graalvm.compiler.lir.LIRInstruction#forEachRegisterHint(Value, OperandMode, ValueProcedure)->Value::: instruction for each register hint
org.graalvm.compiler.lir.LIRInstruction#isMoveOp()->boolean:::Returns true if the instruction is a MoveOp
org.graalvm.compiler.lir.LIRInstruction#isValueMoveOp()->boolean:::Returns true if the instruction is a ValueMoveOp
org.graalvm.compiler.lir.LIRInstruction#isLoadConstantOp()->boolean:::Returns true if the instruction is a LoadConstantOp
org.graalvm.compiler.lir.LIRInstruction#addStackSlotsToTemporaries(Value[], Value[])->Value[]:::Utility method to add stack arguments to a list of temporaries
org.graalvm.compiler.lir.LIRInstruction#verify()->void::: instruction verify
org.graalvm.compiler.lir.LIRInstruction#setComment(LIRGenerationResult, String)->void:::Adds a comment to this instruction.
org.graalvm.compiler.lir.LIRInstruction#getComment(LIRGenerationResult)->String:::Gets the comment attached to this instruction.
org.graalvm.compiler.lir.LIRInstruction#toStringWithIdPrefix()->String::: instruction to string with id prefix
org.graalvm.compiler.lir.LIRInstruction#toString()->String::: instruction to string
org.graalvm.compiler.lir.LIRInstruction#toString(LIRGenerationResult)->String::: instruction to string
org.graalvm.compiler.lir.LIRInstruction#getLIRInstructionClass()->LIRInstructionClass::: instruction get instruction class
org.graalvm.compiler.lir.LIRInstruction#hashCode()->int::: instruction hash code
org.graalvm.compiler.lir.LIRInstructionClass#create(Class)->LIRInstructionClass::: instruction class create
org.graalvm.compiler.lir.LIRInstructionClass#get(Class)->LIRInstructionClass::: instruction class get
org.graalvm.compiler.lir.LIRInstructionClass#getAllFields()->Fields[]::: instruction class get all fields
org.graalvm.compiler.lir.LIRInstructionClass#toString()->String::: instruction class to string
org.graalvm.compiler.lir.LIRInstructionClass#getValues(OperandMode)->Values::: instruction class get values
org.graalvm.compiler.lir.LIRInstructionClass#getOpcode(LIRInstruction)->String::: instruction class get opcode
org.graalvm.compiler.lir.LIRInstructionClass#hasOperands()->boolean::: instruction class has operands
org.graalvm.compiler.lir.LIRInstructionClass#hasState(LIRInstruction)->boolean::: instruction class has state
org.graalvm.compiler.lir.LIRInstructionClass#forEachUse(LIRInstruction, InstructionValueProcedure)->void::: instruction class for each use
org.graalvm.compiler.lir.LIRInstructionClass#forEachAlive(LIRInstruction, InstructionValueProcedure)->void::: instruction class for each alive
org.graalvm.compiler.lir.LIRInstructionClass#forEachTemp(LIRInstruction, InstructionValueProcedure)->void::: instruction class for each temp
org.graalvm.compiler.lir.LIRInstructionClass#forEachDef(LIRInstruction, InstructionValueProcedure)->void::: instruction class for each def
org.graalvm.compiler.lir.LIRInstructionClass#visitEachUse(LIRInstruction, InstructionValueConsumer)->void::: instruction class visit each use
org.graalvm.compiler.lir.LIRInstructionClass#visitEachAlive(LIRInstruction, InstructionValueConsumer)->void::: instruction class visit each alive
org.graalvm.compiler.lir.LIRInstructionClass#visitEachTemp(LIRInstruction, InstructionValueConsumer)->void::: instruction class visit each temp
org.graalvm.compiler.lir.LIRInstructionClass#visitEachDef(LIRInstruction, InstructionValueConsumer)->void::: instruction class visit each def
org.graalvm.compiler.lir.LIRInstructionClass#forEachState(LIRInstruction, InstructionValueProcedure)->void::: instruction class for each state
org.graalvm.compiler.lir.LIRInstructionClass#visitEachState(LIRInstruction, InstructionValueConsumer)->void::: instruction class visit each state
org.graalvm.compiler.lir.LIRInstructionClass#forEachState(LIRInstruction, InstructionStateProcedure)->void::: instruction class for each state
org.graalvm.compiler.lir.LIRInstructionClass#forEachRegisterHint(LIRInstruction, OperandMode, InstructionValueProcedure)->Value::: instruction class for each register hint
org.graalvm.compiler.lir.LIRInstructionClass#toString(LIRInstruction)->String::: instruction class to string
org.graalvm.compiler.lir.LIRInstructionClass#isMoveOp()->boolean::: instruction class is move op
org.graalvm.compiler.lir.LIRInstructionClass#isValueMoveOp()->boolean::: instruction class is value move op
org.graalvm.compiler.lir.LIRInstructionClass#isLoadConstantOp()->boolean::: instruction class is load constant op
org.graalvm.compiler.lir.LIRIntrospection.Values#getDirectCount()->int::: values get direct count
org.graalvm.compiler.lir.LIRIntrospection.Values#getFlags(int)->EnumSet::: values get flags
org.graalvm.compiler.lir.LIRIntrospection.Values#getValue(Object, int)->Value::: values get value
org.graalvm.compiler.lir.LIRIntrospection.Values#setValue(Object, int, Value)->void::: values set value
org.graalvm.compiler.lir.LIRIntrospection.Values#getValueArray(Object, int)->Value[]::: values get value array
org.graalvm.compiler.lir.LIRIntrospection.Values#setValueArray(Object, int, Value[])->void::: values set value array
org.graalvm.compiler.lir.LIRIntrospection.ValueFieldInfo#compareTo(FieldsScanner.FieldInfo)->int:::Sorts non-array fields before array fields.
org.graalvm.compiler.lir.LIRIntrospection.ValueFieldInfo#toString()->String::: value field info to string
org.graalvm.compiler.lir.LIRIntrospection.LIRFieldsScanner#getOperandModeAnnotation(Field)->OperandModeAnnotation::: fields scanner get operand mode annotation
org.graalvm.compiler.lir.LIRIntrospection.LIRFieldsScanner#getFlags(Field)->EnumSet::: fields scanner get flags
org.graalvm.compiler.lir.LIRIntrospection.LIRFieldsScanner#scanField(Field, long)->void::: fields scanner scan field
org.graalvm.compiler.lir.LIRIntrospection#forEach(LIRInstruction, Values, OperandMode, InstructionValueProcedure)->void::: introspection for each
org.graalvm.compiler.lir.LIRIntrospection#visitEach(LIRInstruction, Values, OperandMode, InstructionValueConsumer)->void::: introspection visit each
org.graalvm.compiler.lir.LIRIntrospection#appendValues(StringBuilder, Object, String, String, String, String, String[], Fields...)->void::: introspection append values
org.graalvm.compiler.lir.LIRIntrospection#getFieldString(Object, int, Fields)->String::: introspection get field string
org.graalvm.compiler.lir.LIRValueUtil#isVariable(Value)->boolean::: value util is variable
org.graalvm.compiler.lir.LIRValueUtil#asVariable(Value)->Variable::: value util as variable
org.graalvm.compiler.lir.LIRValueUtil#isConstantValue(Value)->boolean::: value util is constant value
org.graalvm.compiler.lir.LIRValueUtil#asConstantValue(Value)->ConstantValue::: value util as constant value
org.graalvm.compiler.lir.LIRValueUtil#asConstant(Value)->Constant::: value util as constant
org.graalvm.compiler.lir.LIRValueUtil#isJavaConstant(Value)->boolean::: value util is java constant
org.graalvm.compiler.lir.LIRValueUtil#asJavaConstant(Value)->JavaConstant::: value util as java constant
org.graalvm.compiler.lir.LIRValueUtil#isNullConstant(Value)->boolean::: value util is null constant
org.graalvm.compiler.lir.LIRValueUtil#isIntConstant(Value, long)->boolean::: value util is int constant
org.graalvm.compiler.lir.LIRValueUtil#isStackSlotValue(Value)->boolean::: value util is stack slot value
org.graalvm.compiler.lir.LIRValueUtil#isVirtualStackSlot(Value)->boolean::: value util is virtual stack slot
org.graalvm.compiler.lir.LIRValueUtil#asVirtualStackSlot(Value)->VirtualStackSlot::: value util as virtual stack slot
org.graalvm.compiler.lir.LIRValueUtil#sameRegister(Value, Value)->boolean::: value util same register
org.graalvm.compiler.lir.LIRValueUtil#sameRegister(Value, Value, Value)->boolean::: value util same register
org.graalvm.compiler.lir.LIRValueUtil#differentRegisters(Object...)->boolean:::Checks if all the provided values are different physical registers
org.graalvm.compiler.lir.LIRValueUtil#subtractRegisters(Value[], Value[])->Value[]:::Subtract sets of registers (x - y).
org.graalvm.compiler.lir.LIRVerifier#verify(LIRInstruction)->boolean::: verifier verify
org.graalvm.compiler.lir.LIRVerifier#verify(boolean, LIR, FrameMap)->boolean::: verifier verify
org.graalvm.compiler.lir.NullCheckOptimizer#run(TargetDescription, LIRGenerationResult, PostAllocationOptimizationContext)->void::: null check optimizer run
org.graalvm.compiler.lir.RedundantMoveElimination#run(TargetDescription, LIRGenerationResult, PostAllocationOptimizationContext)->void::: redundant move elimination run
org.graalvm.compiler.lir.StandardOp.NullCheck#getCheckedValue()->Value::: null check get checked value
org.graalvm.compiler.lir.StandardOp.NullCheck#getState()->LIRFrameState::: null check get state
org.graalvm.compiler.lir.StandardOp.ImplicitNullCheck#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: implicit null check make null check for
org.graalvm.compiler.lir.StandardOp.LabelHoldingOp#getLabel()->Label::: label holding op get label
org.graalvm.compiler.lir.StandardOp.LabelOp#setPhiValues(Value[])->void::: label op set phi values
org.graalvm.compiler.lir.StandardOp.LabelOp#getPhiSize()->int::: label op get phi size
org.graalvm.compiler.lir.StandardOp.LabelOp#setIncomingValues(Value[])->void::: label op set incoming values
org.graalvm.compiler.lir.StandardOp.LabelOp#getIncomingSize()->int::: label op get incoming size
org.graalvm.compiler.lir.StandardOp.LabelOp#getIncomingValue(int)->Value::: label op get incoming value
org.graalvm.compiler.lir.StandardOp.LabelOp#clearIncomingValues()->void::: label op clear incoming values
org.graalvm.compiler.lir.StandardOp.LabelOp#addIncomingValues(Value[])->void::: label op add incoming values
org.graalvm.compiler.lir.StandardOp.LabelOp#emitCode(CompilationResultBuilder)->void::: label op emit code
org.graalvm.compiler.lir.StandardOp.LabelOp#getLabel()->Label::: label op get label
org.graalvm.compiler.lir.StandardOp.LabelOp#isPhiIn()->boolean::: label op is phi in
org.graalvm.compiler.lir.StandardOp.LabelOp#forEachIncomingValue(InstructionValueProcedure)->void::: label op for each incoming value
org.graalvm.compiler.lir.StandardOp.JumpOp#emitCode(CompilationResultBuilder)->void::: jump op emit code
org.graalvm.compiler.lir.StandardOp.JumpOp#destination()->LabelRef::: jump op destination
org.graalvm.compiler.lir.StandardOp.JumpOp#setPhiValues(Value[])->void::: jump op set phi values
org.graalvm.compiler.lir.StandardOp.JumpOp#getPhiSize()->int::: jump op get phi size
org.graalvm.compiler.lir.StandardOp.JumpOp#getOutgoingValue(int)->Value::: jump op get outgoing value
org.graalvm.compiler.lir.StandardOp.JumpOp#clearOutgoingValues()->void::: jump op clear outgoing values
org.graalvm.compiler.lir.StandardOp.MoveOp#getResult()->AllocatableValue::: move op get result
org.graalvm.compiler.lir.StandardOp.MoveOp#asMoveOp(LIRInstruction)->MoveOp::: move op as move op
org.graalvm.compiler.lir.StandardOp.MoveOp#isMoveOp(LIRInstruction)->boolean::: move op is move op
org.graalvm.compiler.lir.StandardOp.ValueMoveOp#getInput()->AllocatableValue::: value move op get input
org.graalvm.compiler.lir.StandardOp.ValueMoveOp#asValueMoveOp(LIRInstruction)->ValueMoveOp::: value move op as value move op
org.graalvm.compiler.lir.StandardOp.ValueMoveOp#isValueMoveOp(LIRInstruction)->boolean::: value move op is value move op
org.graalvm.compiler.lir.StandardOp.LoadConstantOp#getConstant()->Constant::: load constant op get constant
org.graalvm.compiler.lir.StandardOp.LoadConstantOp#asLoadConstantOp(LIRInstruction)->LoadConstantOp::: load constant op as load constant op
org.graalvm.compiler.lir.StandardOp.LoadConstantOp#isLoadConstantOp(LIRInstruction)->boolean::: load constant op is load constant op
org.graalvm.compiler.lir.StandardOp.SaveRegistersOp#supportsRemove()->boolean:::Determines if the #remove(EconomicSet) operation is supported for this object.
org.graalvm.compiler.lir.StandardOp.SaveRegistersOp#remove(EconomicSet)->int:::Prunes doNotSave from the registers saved by this operation.
org.graalvm.compiler.lir.StandardOp.SaveRegistersOp#getMap(FrameMap)->RegisterSaveLayout:::Gets a map from the saved registers saved by this operation to the frame slots in which they are saved.
org.graalvm.compiler.lir.StandardOp.NoOp#replace(LIR, LIRInstruction)->void::: no op replace
org.graalvm.compiler.lir.StandardOp.NoOp#remove(LIR)->void::: no op remove
org.graalvm.compiler.lir.StandardOp.NoOp#emitCode(CompilationResultBuilder)->void::: no op emit code
org.graalvm.compiler.lir.StandardOp.BlackholeOp#emitCode(CompilationResultBuilder)->void::: blackhole op emit code
org.graalvm.compiler.lir.StandardOp.BindToRegisterOp#emitCode(CompilationResultBuilder)->void::: bind to register op emit code
org.graalvm.compiler.lir.StandardOp.SpillRegistersOp#destroysCallerSavedRegisters()->boolean::: spill registers op destroys caller saved registers
org.graalvm.compiler.lir.StandardOp.SpillRegistersOp#emitCode(CompilationResultBuilder)->void::: spill registers op emit code
org.graalvm.compiler.lir.StandardOp.StackMove#emitCode(CompilationResultBuilder)->void::: stack move emit code
org.graalvm.compiler.lir.StandardOp.StackMove#getInput()->AllocatableValue::: stack move get input
org.graalvm.compiler.lir.StandardOp.StackMove#getResult()->AllocatableValue::: stack move get result
org.graalvm.compiler.lir.StateProcedure#doState(LIRFrameState)->void::: state procedure do state
org.graalvm.compiler.lir.StateProcedure#doState(LIRInstruction, LIRFrameState)->void::: state procedure do state
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#conditionalJump(int, Condition, Label)->void:::This method generates code for a comparison between the actual value and the constant at the given index and a condition jump to target.
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#conditionalJump(int, Condition, boolean)->void::: base switch closure conditional jump
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#conditionalJumpOrDefault(int, Condition, boolean)->void::: base switch closure conditional jump or default
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#conditionalJump(int, Condition)->Label::: base switch closure conditional jump
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#bind(Label)->void::: base switch closure bind
org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure#isSameTarget(int, int)->boolean::: base switch closure is same target
org.graalvm.compiler.lir.SwitchStrategy#getKeyConstants()->Constant[]::: switch strategy get key constants
org.graalvm.compiler.lir.SwitchStrategy#getAverageEffort()->double::: switch strategy get average effort
org.graalvm.compiler.lir.SwitchStrategy#registerEffort(int, int, int)->void:::Tells the system that the given (inclusive) range of keys is reached after depth number of comparisons, which is used to calculate the average effort.
org.graalvm.compiler.lir.SwitchStrategy#registerDefaultEffort(int)->void:::Tells the system that the default successor is reached after depth number of comparisons, which is used to calculate average effort.
org.graalvm.compiler.lir.SwitchStrategy#toString()->String::: switch strategy to string
org.graalvm.compiler.lir.SwitchStrategy.SequentialStrategy#getKeyConstants()->Constant[]::: sequential strategy get key constants
org.graalvm.compiler.lir.SwitchStrategy.SequentialStrategy#run(SwitchClosure)->void::: sequential strategy run
org.graalvm.compiler.lir.SwitchStrategy.RangesStrategy#run(SwitchClosure)->void::: ranges strategy run
org.graalvm.compiler.lir.SwitchStrategy.BinaryStrategy#run(SwitchClosure)->void::: binary strategy run
org.graalvm.compiler.lir.SwitchStrategy#run(SwitchClosure)->void::: switch strategy run
org.graalvm.compiler.lir.SwitchStrategy#getBestStrategy(double[], JavaConstant[], LabelRef[])->SwitchStrategy:::Creates all switch strategies for the given switch, evaluates them (based on average effort) and returns the best one.
org.graalvm.compiler.lir.ValueConsumer#visitValue(Value, OperandMode, EnumSet)->void:::Iterator method to be overwritten.
org.graalvm.compiler.lir.ValueConsumer#visitValue(LIRInstruction, Value, OperandMode, EnumSet)->void::: value consumer visit value
org.graalvm.compiler.lir.ValueProcedure#doValue(Value, OperandMode, EnumSet)->Value:::Iterator method to be overwritten.
org.graalvm.compiler.lir.ValueProcedure#doValue(LIRInstruction, Value, OperandMode, EnumSet)->Value::: value procedure do value
org.graalvm.compiler.lir.Variable#setName(String)->void::: variable set name
org.graalvm.compiler.lir.Variable#getName()->String::: variable get name
org.graalvm.compiler.lir.Variable#toString()->String::: variable to string
org.graalvm.compiler.lir.Variable#hashCode()->int::: variable hash code
org.graalvm.compiler.lir.Variable#equals(Object)->boolean::: variable equals
org.graalvm.compiler.lir.VirtualStackSlot#getId()->int::: virtual stack slot get id
org.graalvm.compiler.lir.VirtualStackSlot#toString()->String::: virtual stack slot to string
org.graalvm.compiler.lir.VirtualStackSlot#hashCode()->int::: virtual stack slot hash code
org.graalvm.compiler.lir.VirtualStackSlot#equals(Object)->boolean::: virtual stack slot equals
