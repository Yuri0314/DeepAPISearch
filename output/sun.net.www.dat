HeaderParser#subsequence(int, int):::create a new HeaderParser from this, whose keys (and corresponding values) range from "start" to "end-1":::if->return->if->throw->new->IllegalArgumentException->n->new->HeaderParser->new->StringArrs->System->arraycopy->return
HeaderParser#parse()::: header parser parse:::if->raw->trim->ca->raw->toCharArray->beg->end->i->inKey->inQuote->len->while->c->if->new->String->toLowerCase->else->if->if->new->String->do->while->else->else->if->if->continue->else->if->new->String->toLowerCase->else->new->String->while->else->if->ntab->new->StringArrs->System->arraycopy->if->if->if->new->String->else->new->String->else->new->String->toLowerCase->else->if->if->if->String->valueOf->else->String->valueOf->else->String->valueOf->toLowerCase
HeaderParser#findKey(int)::: header parser find key:::if->return->return
HeaderParser#findValue(int)::: header parser find value:::if->return->return
HeaderParser#findValue(String)::: header parser find value:::return->findValue
HeaderParser#findValue(String, String)::: header parser find value:::if->return->k->toLowerCase->for->i->return
HeaderParser.ParserIterator#hasNext()::: parser iterator has next:::return
HeaderParser.ParserIterator#next()::: parser iterator next:::return
HeaderParser.ParserIterator#remove()::: parser iterator remove:::throw->new->UnsupportedOperationException
HeaderParser#keys()::: header parser keys:::return->new->ParserIterator
HeaderParser#values()::: header parser values:::return->new->ParserIterator
HeaderParser#toString()::: header parser to string:::k->keys->sb->new->StringBuilder->sb->append->append->append->append->append->for->i->k->hasNext->sb->append->return->sb->toString
HeaderParser#findInt(String, int)::: header parser find int:::try->return->Integer->String->valueOf->findValue->parseInt->catch->return->finally
MessageHeader#getHeaderNamesInList():::Returns list of header names in a comma separated list:::joiner->new->StringJoiner->for->i->return->joiner->toString
MessageHeader#reset():::Reset a message header (all key/values removed):::grow
MessageHeader#findValue(String):::Find the value that corresponds to this key:::if->for->i->else->for->i->return
MessageHeader#getKey(String)::: message header get key:::for->i->return
MessageHeader#getKey(int)::: message header get key:::if->return->return
MessageHeader#getValue(int)::: message header get value:::if->return->return
MessageHeader#findNextValue(String, String):::Deprecated: Use multiValueIterator() instead:::foundV->if->for->i->else->for->i->return
MessageHeader#filterNTLMResponses(String):::Removes bare Negotiate and Kerberos headers when an "NTLM ..." appears:::found->for->i->if->j->for->i->if->return->return
MessageHeader.HeaderIterator#hasNext()::: header iterator has next:::synchronized->if->return->while->if->key->equalsIgnoreCase->return->return
MessageHeader.HeaderIterator#next()::: header iterator next:::synchronized->if->return->if->hasNext->return->next->else->throw->new->NoSuchElementException
MessageHeader.HeaderIterator#remove()::: header iterator remove:::throw->new->UnsupportedOperationException
MessageHeader#multiValueIterator(String):::return an Iterator that returns all values of a particular key in sequence:::return->new->HeaderIterator
MessageHeader#getHeaders()::: message header get headers:::return->getHeaders
MessageHeader#getHeaders(String[])::: message header get headers:::return->filterAndAddHeaders
MessageHeader#filterAndAddHeaders(String[], Map>)::: message header filter and add headers:::skipIt->m->new->HashMap<>->for->i->if->foreach->include->entrySet->l->m->entry->getKey->get->if->new->ArrayList<>->m->entry->getKey->put->l->entry->getValue->addAll->foreach->m->keySet->m->Collections->m->get->unmodifiableList->put->return->Collections->unmodifiableMap
MessageHeader#isRequestline(String):::Check if a line of message header looks like a request line:::k->line->trim->i->k->lastIndexOf->if->return->len->k->length->if->return->c1->k->charAt->c2->k->charAt->c3->k->charAt->if->return->if->return->if->return->return->k->substring->equalsIgnoreCase
MessageHeader#print(PrintStream):::Prints the key-value pairs represented by this         header:::for->i->p->print->p->flush
MessageHeader#add(String, String):::Adds a key value pair to the end of the         header:::grow
MessageHeader#prepend(String, String):::Prepends a key value pair to the beginning of the         header:::grow->for->i
MessageHeader#set(int, String, String)::: message header set:::grow->if->return->else->if->add->else
MessageHeader#grow()::: message header grow:::if->nk->new->StringArr->nv->new->StringArr->if->System->arraycopy->if->System->arraycopy
MessageHeader#remove(String):::Remove the key from the header:::if->for->i->else->for->i
MessageHeader#set(String, String):::Sets the value of a key:::for->i->add
MessageHeader#setIfNotSet(String, String)::: message header set if not set:::if->findValue->add
MessageHeader#canonicalID(String):::Convert a message-id string to canonical form (strips off         leading and trailing <>s):::if->return->st->len->id->length->substr->c->while->id->charAt->while->id->charAt->return->id->substring
MessageHeader#parseHeader(InputStream):::Parse a MIME header from an input stream.:::synchronized->mergeHeader
MessageHeader#mergeHeader(InputStream):::Parse and merge a MIME header from an input stream.:::if->return->s->new->charArr->firstc->is->read->while->len->keyend->c->inKey->while->is->read->switch->if->break->break->is->read->if->is->read->if->is->read->if->break->break->if->ns->new->charArr->System->arraycopy->while->k->if->else->String->copyValueOf->if->while->v->if->new->String->else->String->copyValueOf->add
MessageHeader#toString()::: message header to string:::result->super->toString->for->i->return
MeteredStream#justRead(long)::: metered stream just read:::if->if->isMarked->close->return->if->if->pi->updateProgress->if->isMarked->return->if->if->close
MeteredStream#isMarked():::Returns true if the mark is valid, false otherwise:::if->return->if->return->return
MeteredStream#read()::: metered stream read:::if->return->c->in->read->if->justRead->else->justRead->return
MeteredStream#read(byte[], int, int)::: metered stream read:::if->return->n->in->read->justRead->return
MeteredStream#skip(long)::: metered stream skip:::if->return->if->in->skip->else->min->in->skip->justRead->return
MeteredStream#close()::: metered stream close:::if->return->if->pi->finishTracking->in->close
MeteredStream#available()::: metered stream available:::return->in->available
MeteredStream#mark(int)::: metered stream mark:::if->return->super->mark
MeteredStream#reset()::: metered stream reset:::if->return->if->isMarked->throw->new->IOException->super->reset
MeteredStream#markSupported()::: metered stream mark supported:::if->return->return->super->markSupported
MeteredStream#finalize()::: metered stream finalize:::try->close->if->pi->close->catch->finally->super->finalize
MimeEntry#getType()::: mime entry get type:::return
MimeEntry#setType(String)::: mime entry set type:::type->toLowerCase
MimeEntry#getAction()::: mime entry get action:::return
MimeEntry#setAction(int, String)::: mime entry set action:::
MimeEntry#setAction(int)::: mime entry set action:::
MimeEntry#getLaunchString()::: mime entry get launch string:::return
MimeEntry#setCommand(String)::: mime entry set command:::
MimeEntry#getDescription()::: mime entry get description:::return
MimeEntry#setDescription(String)::: mime entry set description:::
MimeEntry#getImageFileName()::: mime entry get image file name:::return
MimeEntry#setImageFileName(String)::: mime entry set image file name:::file->new->File->if->file->getParent->System->getProperty->else->if->filename->lastIndexOf
MimeEntry#getTempFileTemplate()::: mime entry get temp file template:::return
MimeEntry#getExtensions()::: mime entry get extensions:::return
MimeEntry#getExtensionsAsList()::: mime entry get extensions as list:::extensionsAsString->if->for->i->return
MimeEntry#setExtensions(String)::: mime entry set extensions:::extTokens->new->StringTokenizer->numExts->extTokens->countTokens->extensionStrings->new->StringArr->for->i
MimeEntry#isStarred(String)::: mime entry is starred:::return->typeName->length->typeName->endsWith
MimeEntry#launch(java.net.URLConnection, InputStream, MimeTable):::Invoke the MIME type specific behavior for this MIME type:::switch->try->return->catch->return->finally->try->return->urlc->getContent->catch->return->finally->threadName->fst->threadName->indexOf->if->threadName->substring->return->mt->getTempFileTemplate->new->MimeLauncher->return->return
MimeEntry#matches(String)::: mime entry matches:::if->return->type->startsWith->else->return->type->equals
MimeEntry#clone()::: mime entry clone:::theClone->new->MimeEntry->return
MimeEntry#toProperty()::: mime entry to property:::sj->new->StringJoiner->action->getAction->if->sj->add->command->getLaunchString->if->command->length->sj->add->image->getImageFileName->if->sj->add->extensions->getExtensionsAsList->if->extensions->length->sj->add->description->getDescription->if->description->getType->equals->sj->add->return->sj->toString
MimeEntry#toString()::: mime entry to string:::return->getExtensionsAsList
MimeLauncher#getTempFileName(URL, String)::: mime launcher get temp file name:::tempFilename->wildcard->tempFilename->lastIndexOf->prefix->tempFilename->substring->suffix->if->tempFilename->length->tempFilename->substring->timestamp->System->currentTimeMillis->argIndex->while->prefix->indexOf->prefix->substring->prefix->substring->filename->url->getFile->extension->dot->filename->lastIndexOf->if->filename->lastIndexOf->filename->substring->url->hashCode->return
MimeLauncher#run()::: mime launcher run:::try->ofn->m->getTempFileTemplate->if->uc->getURL->getTempFileName->try->os->new->FileOutputStream->buf->new->byteArr->i->try->while->is->read->os->write->catch->finally->os->close->is->close->catch->finally->inx->c->while->c->indexOf->c->substring->uc->getContentType->c->substring->substituted->while->c->indexOf->c->substring->c->substring->if->Runtime->getRuntime->exec->catch->finally
MimeLauncher#findExecutablePath(String)::: mime launcher find executable path:::if->str->length->return->command->index->str->indexOf->if->str->substring->else->f->new->File->if->f->isFile->return->execPathList->GetPropertyAction->privilegedGetProperty->if->return->iter->new->StringTokenizer->while->iter->hasMoreElements->prefix->iter->nextElement->fullCmd->new->File->if->f->isFile->return->return
MimeTable.DefaultInstanceHolder#getDefaultInstance()::: default instance holder get default instance:::return->new->java.security.PrivilegedAction<MimeTable>->doPrivileged
MimeTable#getDefaultTable():::Get the single instance of this class:::return
MimeTable#loadTable()::: mime table load table:::mt->getDefaultTable->return
MimeTable#getSize()::: mime table get size:::return->entries->size
MimeTable#getContentTypeFor(String)::: mime table get content type for:::entry->findByFileName->if->return->entry->getType->else->return
MimeTable#add(MimeEntry)::: mime table add:::entries->m->getType->put->exts->m->getExtensions->if->return->for->i
MimeTable#remove(String)::: mime table remove:::entry->entries->get->return->remove
MimeTable#remove(MimeEntry)::: mime table remove:::extensionKeys->entry->getExtensions->if->for->i->return->entries->entry->getType->remove
MimeTable#find(String)::: mime table find:::entry->entries->get->if->e->entries->elements->while->e->hasMoreElements->wild->e->nextElement->if->wild->matches->return->return
MimeTable#findByFileName(String):::Locate a MimeEntry by the file extension that has been associated with it:::ext->i->fname->lastIndexOf->if->fname->substring->fname->lastIndexOf->Math->fname->lastIndexOf->max->Math->fname->lastIndexOf->max->if->fname->charAt->fname->substring->toLowerCase->return->findByExt
MimeTable#findByExt(String):::Locate a MimeEntry by the file extension that has been associated with it.:::return->extensionMap->get
MimeTable#findByDescription(String)::: mime table find by description:::e->elements->while->e->hasMoreElements->entry->e->nextElement->if->description->entry->getDescription->equals->return->return->find
MimeTable#getTempFileTemplate()::: mime table get temp file template:::return
MimeTable#elements()::: mime table elements:::return->entries->elements
MimeTable#load()::: mime table load:::entries->new->Properties->file->in->userTablePath->System->getProperty->if->new->File->exists->try->new->FileInputStream->catch->file->getPath->println->return->finally->else->getResourceAsStream->if->throw->new->InternalError->try->bin->new->BufferedInputStream->entries->load->catch->e->getMessage->println->finally->parse
MimeTable#parse(Properties)::: mime table parse:::tempFileTemplate->entries->get->if->entries->remove->types->entries->propertyNames->while->types->hasMoreElements->type->types->nextElement->attrs->entries->getProperty->parse
MimeTable#parse(String, String)::: mime table parse:::newEntry->new->MimeEntry->tokenizer->new->StringTokenizer->while->tokenizer->hasMoreTokens->pair->tokenizer->nextToken->parse->add
MimeTable#parse(String, MimeEntry)::: mime table parse:::name->value->gotName->tokenizer->new->StringTokenizer->while->tokenizer->hasMoreTokens->if->tokenizer->nextToken->trim->else->tokenizer->nextToken->trim->fill
MimeTable#fill(MimeEntry, String, String)::: mime table fill:::if->equalsIgnoreCase->entry->setDescription->else->if->equalsIgnoreCase->entry->getActionCode->setAction->else->if->equalsIgnoreCase->entry->setCommand->else->if->equalsIgnoreCase->entry->setImageFileName->else->if->equalsIgnoreCase->entry->setExtensions
MimeTable#getExtensions(String)::: mime table get extensions:::tokenizer->new->StringTokenizer->n->tokenizer->countTokens->extensions->new->StringArr->for->i->return
MimeTable#getActionCode(String)::: mime table get action code:::for->i->return
MimeTable#getAsProperties()::: mime table get as properties:::properties->new->Properties->e->elements->while->e->hasMoreElements->entry->e->nextElement->properties->entry->getType->entry->toProperty->put->return
MimeTable#saveAsProperties(File)::: mime table save as properties:::os->try->new->FileOutputStream->properties->getAsProperties->properties->put->tag->sm->System->getSecurityManager->if->sm->checkPropertyAccess->user->StaticProperty->userName->if->properties->store->else->properties->store->catch->e->printStackTrace->return->finally->if->try->os->close->catch->finally->return
ParseUtil#encodePath(String):::Constructs an encoded version of the specified path string suitable for use in the construction of a URL:::return->encodePath
ParseUtil#encodePath(String, boolean)::: parse util encode path:::if->return->encodePath->else->index->firstEncodeIndex->if->return->encodePath->else->return
ParseUtil#firstEncodeIndex(String)::: parse util first encode index:::len->path->length->for->i->return
ParseUtil#encodePath(String, int, char)::: parse util encode path:::pathCC->path->toCharArray->retCC->new->charArr->if->System->arraycopy->retLen->for->i->return->new->String
ParseUtil#escape(char[], char, int):::Appends the URL escape sequence for the specified char to the specified StringBuffer.:::Character->forDigit->Character->forDigit->return
ParseUtil#unescape(String, int):::Un-escape and return the character at position i in string s.:::return->Integer->parseInt
ParseUtil#decode(String):::Returns a new String constructed from the specified String by replacing the URL escape sequences and UTF8 encoding with the characters they represent.:::n->s->length->if->s->indexOf->return->sb->new->StringBuilder->bb->ByteBuffer->allocate->cb->CharBuffer->allocate->dec->ThreadLocalCoders->decoderFor->onMalformedInput->onUnmappableCharacter->c->s->charAt->for->i->return->sb->toString
ParseUtil#canonizeString(String):::Returns a canonical version of the specified string.:::len->file->length->if->file->indexOf->file->charAt->return->else->return->doCanonize
ParseUtil#doCanonize(String)::: parse util do canonize:::i->lim->while->file->indexOf->if->file->lastIndexOf->file->substring->file->substring->else->file->substring->while->file->indexOf->file->substring->file->substring->while->file->endsWith->file->indexOf->if->file->lastIndexOf->file->substring->else->file->substring->if->file->endsWith->file->file->length->substring->return
ParseUtil#fileToEncodedURL(File)::: parse util file to encoded l:::path->file->getAbsolutePath->ParseUtil->encodePath->if->path->startsWith->if->path->endsWith->file->isDirectory->return->new->URL
ParseUtil#toURI(URL)::: parse util to i:::protocol->url->getProtocol->auth->url->getAuthority->path->url->getPath->query->url->getQuery->ref->url->getRef->if->path->startsWith->if->auth->endsWith->auth->auth->length->substring->uri->try->createURI->catch->finally->return
ParseUtil#createURI(String, String, String, String, String)::: parse util create i:::s->toString->checkPath->return->new->URI
ParseUtil#toString(String, String, String, String, String, int, String, String, String)::: parse util to string:::sb->new->StringBuffer->if->sb->append->sb->append->appendSchemeSpecificPart->appendFragment->return->sb->toString
ParseUtil#appendSchemeSpecificPart(StringBuffer, String, String, String, String, int, String, String)::: parse util append scheme specific part:::if->if->opaquePart->startsWith->end->opaquePart->indexOf->if->opaquePart->indexOf->doquote->dontquote->if->opaquePart->length->else->opaquePart->substring->opaquePart->substring->sb->append->sb->quote->append->else->sb->quote->append->else->appendAuthority->if->sb->quote->append->if->sb->append->sb->quote->append
ParseUtil#appendAuthority(StringBuffer, String, String, String, int)::: parse util append authority:::if->sb->append->if->sb->quote->append->sb->append->needBrackets->host->indexOf->host->startsWith->host->endsWith->if->sb->append->sb->append->if->sb->append->if->sb->append->sb->append->else->if->sb->append->if->authority->startsWith->end->authority->indexOf->if->authority->indexOf->doquote->dontquote->if->authority->length->else->authority->substring->authority->substring->sb->append->sb->quote->append->else->sb->quote->append
ParseUtil#appendFragment(StringBuffer, String)::: parse util append fragment:::if->sb->append->sb->quote->append
ParseUtil#quote(String, long, long)::: parse util quote:::n->s->length->sb->allowNonASCII->for->i->s->length->return->sb->toString
ParseUtil#isEscaped(String, int)::: parse util is escaped:::if->s->length->return->return->s->charAt->s->charAt->match->s->charAt->match
ParseUtil#appendEncoded(StringBuffer, char)::: parse util append encoded:::bb->try->ThreadLocalCoders->encoderFor->CharBuffer->wrap->encode->catch->finally->while->bb->hasRemaining->b->bb->get->if->appendEscape->else->sb->append
ParseUtil#appendEscape(StringBuffer, byte)::: parse util append escape:::sb->append->sb->append->sb->append
ParseUtil#match(char, long, long)::: parse util match:::if->return->if->return->return
ParseUtil#checkPath(String, String, String)::: parse util check path:::if->if->path->length->path->charAt->throw->new->URISyntaxException
URLConnection#getProperties():::Call this routine to get the property list for this object:::return
URLConnection#setProperties(MessageHeader):::Call this routine to set the property list for this object.:::
URLConnection#setRequestProperty(String, String)::: connection set request property:::if->throw->new->IllegalAccessError->if->throw->new->NullPointerException->properties->set
URLConnection#addRequestProperty(String, String):::The following three methods addRequestProperty, getRequestProperty, and getRequestProperties were copied from the superclass implementation before it was changed by CR:6230836, to maintain backward compatibility.:::if->throw->new->IllegalStateException->if->throw->new->NullPointerException
URLConnection#getRequestProperty(String)::: connection get request property:::if->throw->new->IllegalStateException->return
URLConnection#getRequestProperties()::: connection get request properties:::if->throw->new->IllegalStateException->return->Collections->emptyMap
URLConnection#getHeaderField(String)::: connection get header field:::try->getInputStream->catch->return->finally->return->properties->findValue
URLConnection#getHeaderFieldKey(int):::Return the key for the nth header field:::try->getInputStream->catch->return->finally->props->return->props->getKey
URLConnection#getHeaderField(int):::Return the value for the nth header field:::try->getInputStream->catch->return->finally->props->return->props->getValue
URLConnection#getContentType():::Call this routine to get the content-type associated with this object.:::if->getHeaderField->if->ct->try->getInputStream->guessContentTypeFromStream->catch->finally->ce->properties->findValue->if->properties->findValue->if->if->url->getFile->endsWith->else->url->getFile->guessContentTypeFromName->if->ce->equalsIgnoreCase->ce->equalsIgnoreCase->ce->equalsIgnoreCase->setContentType->return
URLConnection#setContentType(String):::Set the content type of this URL to a specific value.:::properties->set
URLConnection#getContentLength():::Call this routine to get the content-length associated with this object.:::try->getInputStream->catch->return->finally->l->if->try->Integer->properties->findValue->parseInt->setContentLength->catch->finally->return
URLConnection#setContentLength(int):::Call this routine to set the content-length associated with this object.:::properties->String->valueOf->set
URLConnection#canCache():::Returns true if the data associated with this URL can be cached.:::return->url->getFile->indexOf
URLConnection#close():::Call this to close the connection and flush any remaining data:::
URLConnection#setProxiedHost(String)::: connection set proxied host:::proxiedHosts->host->toLowerCase->put
URLConnection#isProxiedHost(String)::: connection is proxied host:::return->proxiedHosts->host->toLowerCase->containsKey
