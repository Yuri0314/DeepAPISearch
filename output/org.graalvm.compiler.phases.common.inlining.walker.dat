CallsiteHolder#method():::Gets the method associated with the #graph() graph represented by this object.:::
CallsiteHolder#hasRemainingInvokes():::The stack realized by InliningData grows upon InliningData#moveForward() deciding to explore (depth-first) a callsite of the graph associated to this CallsiteHolder:::
CallsiteHolder#graph():::The graph about which this object contains inlining information.:::
CallsiteHolderExplorable#fixedParamsAt(BitSet)::: callsite holder explorable fixed params at:::if->freshlyInstantiatedArguments->isEmpty->return->EconomicSet->create->result->EconomicSet->create->foreach->graph->getNodes->if->freshlyInstantiatedArguments->p->index->get->result->add->return
CallsiteHolderExplorable#getFixedParams()::: Parameters for which the callsite targeting #graph() provides "fixed" arguments:::return
CallsiteHolderExplorable#repOK()::: callsite holder explorable rep k:::foreach->if->invoke->asNode->isAlive->containsInvoke->return->if->allArgsNonNull->return->foreach->if->containsParam->return->return
CallsiteHolderExplorable#method()::: callsite holder explorable method:::return->graph->method
CallsiteHolderExplorable#hasRemainingInvokes()::: callsite holder explorable has remaining invokes:::return->remainingInvokes->isEmpty
CallsiteHolderExplorable#graph()::: callsite holder explorable graph:::return
CallsiteHolderExplorable#popInvoke()::: callsite holder explorable pop invoke:::return->remainingInvokes->removeFirst
CallsiteHolderExplorable#pushInvoke(Invoke)::: callsite holder explorable push invoke:::remainingInvokes->push
CallsiteHolderExplorable#allArgsNonNull(Invoke)::: callsite holder explorable all args non null:::foreach->invoke->callTarget->arguments->if->return->return
CallsiteHolderExplorable#containsInvoke(Invoke)::: callsite holder explorable contains invoke:::foreach->graph->getInvokes->if->return->return
CallsiteHolderExplorable#containsParam(ParameterNode)::: callsite holder explorable contains param:::foreach->graph->getNodes->if->return->return
CallsiteHolderExplorable#computeProbabilities()::: callsite holder explorable compute probabilities:::computeInliningRelevance->compute
CallsiteHolderExplorable#invokeProbability(Invoke)::: callsite holder explorable invoke probability:::return->probabilities->invoke->asNode->applyAsDouble
CallsiteHolderExplorable#invokeRelevance(Invoke)::: callsite holder explorable invoke relevance:::return->Math->min->computeInliningRelevance->getRelevance
CallsiteHolderExplorable#toString()::: callsite holder explorable to string:::return->method->format
ComputeInliningRelevance#compute():::Initializes or updates the relevance computation:::if->graph->hasLoops->graph->start->new->Scope->else->if->EconomicMap->InliningUtil->getNodeCount->create->workList->graph->createNodeWorkList->loops->EconomicMap->create->topScope->graph->start->new->Scope->foreach->graph->getNodes->createLoopScope->topScope->process->foreach->loops->getValues->scope->process
ComputeInliningRelevance#getRelevance(Invoke)::: compute inlining relevance get relevance:::if->return->rootScope->computeInvokeRelevance->return->nodeRelevances->invoke->asNode->get
ComputeInliningRelevance#createLoopScope(LoopBeginNode, EconomicMap, Scope):::Determines the parent of the given loop and creates a Scope object for each one:::scope->loops->get->if->parent->current->loopBegin->forwardEnd->while->if->current->predecessor->if->createLoopScope->break->else->if->break->else->forwardEndAt->else->if->loopBegin->createLoopScope->break->else->current->predecessor->new->Scope->loops->put->return
ComputeInliningRelevance.Scope#getFastPathMinProbability()::: scope get fast path min probability:::if->Math->computeFastPathMinProbability->max->return
ComputeInliningRelevance.Scope#getScopeRelevanceWithinParent():::Computes the ratio between the probabilities of the current scope's entry point and the parent scope's fastPathMinProbability.:::if->if->scopeEntryProbability->nodeProbabilities->forwardEnd->applyAsDouble->parent->getFastPathMinProbability->else->return
ComputeInliningRelevance.Scope#process(NodeWorkList):::Processes all invokes in this scope by starting at the scope's start node and iterating all fixed nodes:::workList->start->successors->addAll->foreach->if->nodeRelevances->computeInvokeRelevance->put->workList->current->successors->addAll->else->if->loopExits->workList->exit->next->add->forEach->else->if->else->if->else->if->workList->next->add->else->if->workList->merge->add->else->if->else->if->workList->current->successors->addAll->else
ComputeInliningRelevance.Scope#computeInvokeRelevance(Invoke):::The relevance of an invoke is the ratio between the invoke's probability and the current scope's fastPathMinProbability, adjusted by scopeRelevanceWithinParent.:::invokeProbability->nodeProbabilities->invoke->asNode->applyAsDouble->relevance->getFastPathMinProbability->Math->getScopeRelevanceWithinParent->min->return
ComputeInliningRelevance#computeFastPathMinProbability(FixedNode):::Computes the minimum probability along the most probable path within the scope:::pathBeginNodes->new->ArrayList<>->pathBeginNodes->add->minPathProbability->nodeProbabilities->applyAsDouble->isLoopScope->do->current->pathBeginNodes->pathBeginNodes->size->remove->do->if->loopExits->contains->return->else->if->getMaxProbabilityLoopExit->getMinPathProbability->else->if->getMaxProbabilitySux->getMinPathProbability->else->current->successors->first->while->while->pathBeginNodes->isEmpty->return
ComputeInliningRelevance#getMinPathProbability(FixedNode, double)::: compute inlining relevance get min path probability:::return->Math->nodeProbabilities->applyAsDouble->min
ComputeInliningRelevance#getMaxProbabilitySux(ControlSplitNode, ArrayList):::Returns the most probable successor:::maxSux->maxProbability->pathBeginCount->pathBeginNodes->size->foreach->controlSplit->successors->probability->controlSplit->probability->if->truncate->else->if->pathBeginNodes->add->return
ComputeInliningRelevance#getMaxProbabilityLoopExit(LoopBeginNode, ArrayList):::Returns the most probable loop exit:::maxSux->maxProbability->pathBeginCount->pathBeginNodes->size->foreach->loopBegin->loopExits->probability->nodeProbabilities->applyAsDouble->if->truncate->else->if->pathBeginNodes->add->return
ComputeInliningRelevance#truncate(ArrayList, int)::: compute inlining relevance truncate:::for->i->pathBeginNodes->size
InliningData#isFreshInstantiation(ValueNode)::: inlining data is fresh instantiation:::return
InliningData#checkTargetConditionsHelper(ResolvedJavaMethod, int)::: inlining data check target conditions helper:::options->rootGraph->getOptions->if->return->else->if->method->isNative->Intrinsify->getValue->context->getReplacements->rootGraph->trackNodeSourcePosition->getSubstitution->return->else->if->method->isAbstract->return->else->if->method->getDeclaringClass->isInitialized->return->else->if->method->canBeInlined->return->else->if->countRecursiveInlining->MaximumRecursiveInlining->getValue->return->else->if->rootGraph->getProfilingInfo->new->OptimisticOptimizations->context->getOptimisticOptimizations->lessOptimisticThan->return->else->return
InliningData#checkTargetConditions(Invoke, ResolvedJavaMethod)::: inlining data check target conditions:::failureMessage->invoke->bci->checkTargetConditionsHelper->if->return->else->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return
InliningData#getInlineInfo(Invoke):::Determines if inlining is possible at the given invoke node.:::failureMessage->InliningUtil->checkInvokeConditions->if->InliningUtil->logNotInlinedMethod->return->callTarget->invoke->callTarget->targetMethod->callTarget->targetMethod->invokeKind->callTarget->invokeKind->if->targetMethod->canBeStaticallyBound->return->getExactInlineInfo->holder->targetMethod->getDeclaringClass->if->callTarget->receiver->stamp->return->receiverStamp->callTarget->receiver->stamp->if->receiverStamp->alwaysNull->return->contextType->invoke->getContextType->if->receiverStamp->type->receiverType->receiverStamp->type->if->holder->isAssignableFrom->if->receiverStamp->isExactType->resolvedMethod->holder->resolveConcreteMethod->if->return->getExactInlineInfo->if->holder->isArray->resolvedMethod->holder->resolveConcreteMethod->if->return->getExactInlineInfo->leafConcreteSubtype->holder->findLeafConcreteSubtype->if->resolvedMethod->leafConcreteSubtype->getResult->resolveConcreteMethod->if->leafConcreteSubtype->callTarget->graph->getAssumptions->canRecordTo->return->getAssumptionInlineInfo->concrete->holder->findUniqueConcreteMethod->if->concrete->callTarget->graph->getAssumptions->canRecordTo->return->concrete->getResult->getAssumptionInlineInfo->return->getTypeCheckedInlineInfo
InliningData#getTypeCheckedInlineInfo(Invoke, ResolvedJavaMethod)::: inlining data get type checked inline info:::typeProfile->invoke->callTarget->getProfile->if->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->ptypes->typeProfile->getTypes->if->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->contextType->invoke->getContextType->notRecordedTypeProbability->typeProfile->getNotRecordedProbability->optimisticOpts->context->getOptimisticOptimizations->options->invoke->asNode->getOptions->if->if->optimisticOpts->inlineMonomorphicCalls->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->type->getType->concrete->type->resolveConcreteMethod->if->checkTargetConditions->return->return->new->TypeGuardInlineInfo->else->invoke->setPolymorphic->if->optimisticOpts->inlinePolymorphicCalls->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->if->optimisticOpts->inlineMegamorphicCalls->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->concreteMethods->new->ArrayList<>->concreteMethodsProbabilities->new->ArrayList<>->for->i->if->newConcreteMethods->new->ArrayList<>->newConcreteMethodsProbabilities->new->ArrayList<>->for->i->concreteMethods->size->if->newConcreteMethods->isEmpty->InliningUtil->inliningDepth->concreteMethods->size->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->concreteMethods->size->addDecision->return->if->concreteMethods->size->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->usedTypes->new->ArrayList<>->typesToConcretes->new->ArrayList<>->foreach->concrete->type->getType->resolveConcreteMethod->index->concreteMethods->indexOf->if->type->getProbability->else->usedTypes->add->typesToConcretes->add->if->usedTypes->isEmpty->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->foreach->if->checkTargetConditions->InliningUtil->inliningDepth->traceNotInlinedMethod->invoke->asNode->graph->getInliningLog->addDecision->return->return->new->MultiTypeGuardInlineInfo
InliningData#getAssumptionInlineInfo(Invoke, ResolvedJavaMethod, AssumptionResult)::: inlining data get assumption inline info:::if->checkTargetConditions->return->new->AssumptionInlineInfo->return
InliningData#getExactInlineInfo(Invoke, ResolvedJavaMethod)::: inlining data get exact inline info:::if->checkTargetConditions->return->new->ExactInlineInfo->return
InliningData#doInline(CallsiteHolderExplorable, MethodInvocation, String)::: inlining data do inline:::callerGraph->callerCallsiteHolder->graph->calleeInfo->calleeInvocation->callee->try->try->scope->debug->scope->canonicalizedNodes->EconomicSet->create->canonicalizedNodes->calleeInfo->invoke->asNode->usages->addAll->parameterUsages->calleeInfo->new->Providers->inline->canonicalizedNodes->addAll->counterInliningRuns->increment->debug->dump->markBeforeCanonicalization->callerGraph->getMark->canonicalizer->applyIncremental->foreach->callerGraph->getNewNodes->if->callerCallsiteHolder->pushInvoke->callerCallsiteHolder->computeProbabilities->counterInliningPerformed->increment->catch->finally->catch->throw->throw->new->GraalError->calleeInfo->toString->addContext->throw->e->calleeInfo->toString->addContext->throw->debug->handle->finally
InliningData#tryToInline(MethodInvocation, int):::This method attempts: <ol> <li>to inline at the callsite given by calleeInvocation, where that callsite belongs to the CallsiteHolderExplorable at the top of the #graphQueue maintained in this class.</li> <li>otherwise, to devirtualize the callsite in question.</li> </ol>:::callerCallsiteHolder->currentGraph->calleeInfo->calleeInvocation->callee->counterInliningConsidered->increment->decision->inliningPolicy->context->getReplacements->isWorthInlining->if->decision->shouldInline->decision->getReason->doInline->return->if->context->getOptimisticOptimizations->calleeInfo->graph->getOptions->devirtualizeInvokes->calleeInfo->new->Providers->tryToDevirtualizeInvoke->return
InliningData#processNextInvoke():::This method picks one of the callsites belonging to the current CallsiteHolderExplorable:::callsiteHolder->currentGraph->invoke->callsiteHolder->popInvoke->info->getInlineInfo->if->info->currentGraph->graph->rootGraph->getOptions->populateInlinableElements->invokeProbability->callsiteHolder->invokeProbability->invokeRelevance->callsiteHolder->invokeRelevance->methodInvocation->callsiteHolder->getFixedParams->freshlyInstantiatedArguments->new->MethodInvocation->pushInvocationAndGraphs
InliningData#freshlyInstantiatedArguments(Invoke, EconomicSet):::Gets the freshly instantiated arguments:::result->argIdx->foreach->invoke->callTarget->arguments->if->isFreshInstantiation->fixedParams->contains->if->new->BitSet->result->set->return
InliningData#paramsAndInvokeAreInSameGraph(Invoke, EconomicSet)::: inlining data params and invoke are in same graph:::if->fixedParams->isEmpty->return->foreach->if->p->graph->invoke->asNode->graph->return->return
InliningData#graphCount()::: inlining data graph count:::return->graphQueue->size
InliningData#hasUnprocessedGraphs()::: inlining data has unprocessed graphs:::return->graphQueue->isEmpty
InliningData#currentGraph()::: inlining data current graph:::return->graphQueue->peek
InliningData#popGraph()::: inlining data pop graph:::graphQueue->pop
InliningData#popGraphs(int)::: inlining data pop graphs:::for->i
InliningData#inliningContext():::Gets the call hierarchy of this inlining from outer most call to inner most callee.:::if->debug->isDumpEnabled->return->result->graphQueue->size->new->ObjectArr->i->foreach->g->method->return
InliningData#currentInvocation()::: inlining data current invocation:::return->invocationQueue->peekFirst
InliningData#pushInvocationAndGraphs(MethodInvocation)::: inlining data push invocation and graphs:::invocationQueue->addFirst->info->methodInvocation->callee->info->numberOfMethods->for->i->info->numberOfMethods
InliningData#popInvocation()::: inlining data pop invocation:::invocationQueue->peekFirst->callee->numberOfMethods->invocationQueue->removeFirst
InliningData#countRecursiveInlining(ResolvedJavaMethod)::: inlining data count recursive inlining:::count->foreach->if->method->callsiteHolder->method->equals->return
InliningData#inliningDepth()::: inlining data inlining depth:::return->invocationQueue->size
InliningData#toString()::: inlining data to string:::result->new->StringBuilder->foreach->if->invocation->callee->result->invocation->callee->numberOfMethods->append->result->append->result->invocation->callee->invoke->append->result->append->result->append->foreach->result->graph->graph->append->result->append->return->result->toString
InliningData#getInvocationStackTrace():::Gets a stack trace representing the current inlining stack represented by this object.:::result->new->ArrayList<>->foreach->result->graph->method->asStackTraceElement->add->return
InliningData#contains(StructuredGraph)::: inlining data contains:::foreach->if->info->graph->return->return
InliningData#moveForward()::: The stack realized by InliningData grows and shrinks as choices are made among the alternatives below: <ol> <li>not worth inlining: pop stack top, which comprises: <ul> <li>pop any remaining graphs not yet delved into</li> <li>pop the current invocation</li> </ul> </li> <li>#processNextInvoke() delve into one of the callsites hosted in the current graph, such callsite is explored next by #moveForward()</li> <li>#tryToInline(MethodInvocation, int) try to inline: move past the current graph (remove it from the topmost element):::currentInvocation->currentInvocation->backtrack->currentInvocation->isRoot->inliningPolicy->context->getReplacements->currentInvocation->callee->inliningDepth->isWorthInlining->shouldInline->if->remainingGraphs->currentInvocation->totalGraphs->currentInvocation->processedGraphs->popGraphs->popInvocation->return->delve->currentGraph->hasRemainingInvokes->inliningPolicy->currentGraph->graph->continueInlining->if->processNextInvoke->return->popGraph->if->currentInvocation->isRoot->return->currentInvocation->incrementProcessedGraphs->if->currentInvocation->processedGraphs->currentInvocation->totalGraphs->popInvocation->try->s->debug->inliningContext->scope->if->inliningDepth->tryToInline->return->currentGraph->graph->return->catch->throw->debug->handle->finally->return
InliningData#topGraphsForTopInvocation():::Checks an invariant that #moveForward() must maintain: "the top invocation records how many concrete target methods (for it) remain on the #graphQueue; those targets 'belong' to the current invocation in question.:::if->invocationQueue->isEmpty->return->if->currentInvocation->isRoot->if->graphQueue->isEmpty->return->remainingGraphs->currentInvocation->totalGraphs->currentInvocation->processedGraphs->iter->graphQueue->iterator->for->i->return
InliningData#repOK():::This method checks invariants for this class:::return
InliningIterator#apply()::: inlining iterator apply:::invokes->new->LinkedList<>->current->forcedQueue->while->nextQueuedNode->if->callTarget->if->invokes->addLast->queueSuccessors->else->if->queueSuccessors->else->if->else->if->queueSuccessors->else->if->queueSuccessors->else->if->queueMerge->else->if->else->if->queueSuccessors->else->return
InliningIterator#queueSuccessors(FixedNode)::: inlining iterator queue successors:::foreach->x->successors->queue
InliningIterator#queue(Node)::: inlining iterator queue:::if->queuedNodes->isMarked->forcedQueue
InliningIterator#forcedQueue(Node)::: inlining iterator forced queue:::queuedNodes->mark->nodeQueue->addFirst
InliningIterator#nextQueuedNode()::: inlining iterator next queued node:::if->nodeQueue->isEmpty->return->result->nodeQueue->removeFirst->return
InliningIterator#queueMerge(AbstractEndNode)::: inlining iterator queue merge:::merge->end->merge->if->queuedNodes->isMarked->visitedAllEnds->queuedNodes->mark->nodeQueue->add
InliningIterator#visitedAllEnds(AbstractMergeNode)::: inlining iterator visited all ends:::for->i->merge->forwardEndCount->return
InliningIterator#count(Iterable)::: inlining iterator count:::count->iterator->invokes->iterator->while->iterator->hasNext->iterator->next->return
MethodInvocation#incrementProcessedGraphs()::: method invocation increment processed graphs:::
MethodInvocation#processedGraphs()::: method invocation processed graphs:::return
MethodInvocation#totalGraphs()::: method invocation total graphs:::return->callee->numberOfMethods
MethodInvocation#callee()::: method invocation callee:::return
MethodInvocation#probability()::: method invocation probability:::return
MethodInvocation#relevance()::: method invocation relevance:::return
MethodInvocation#isRoot()::: method invocation is root:::return
MethodInvocation#getFreshlyInstantiatedArguments()::: method invocation get freshly instantiated arguments:::return
MethodInvocation#getSizeFreshArgs()::: method invocation get size fresh args:::return
MethodInvocation#buildCallsiteHolderForElement(int)::: method invocation build callsite holder for element:::elem->callee->inlineableElementAt->ig->invokeProbability->callee->probabilityAt->invokeRelevance->callee->relevanceAt->return->ig->getGraph->new->CallsiteHolderExplorable
MethodInvocation#toString()::: method invocation to string:::if->isRoot->return->callTarget->callee->invoke->callTarget->if->calleeMethod->targetMethod->return->calleeMethod->format->else->return->callTarget->targetName
