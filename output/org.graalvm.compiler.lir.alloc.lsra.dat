LinearScanEliminateSpillMovePhase_OptionDescriptors#get(String)::: linear scan eliminate spill move phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
LinearScanEliminateSpillMovePhase_OptionDescriptors#iterator()::: linear scan eliminate spill move phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
LinearScan_OptionDescriptors#get(String)::: linear scan_ option descriptors get:::switch->return->OptionDescriptor->create->return
LinearScan_OptionDescriptors#iterator()::: linear scan_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
OptimizingLinearScanWalker_OptionDescriptors#get(String)::: optimizing linear scan walker_ option descriptors get:::switch->return->OptionDescriptor->create->return->OptionDescriptor->create->return
OptimizingLinearScanWalker_OptionDescriptors#iterator()::: optimizing linear scan walker_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
Interval.RegisterBindingLists#get(RegisterBinding):::Gets the list for a specified binding.:::switch->return->return->return->throw->GraalError->shouldNotReachHere
Interval.RegisterBindingLists#set(RegisterBinding, Interval):::Sets the list for a specified binding.:::switch->break->break->break
Interval.RegisterBindingLists#addToListSortedByCurrentFromPositions(RegisterBinding, Interval):::Adds an interval to a list sorted by Interval#currentFrom() current from positions.:::list->get->prev->cur->while->cur->currentFrom->interval->currentFrom->result->if->else->set
Interval.RegisterBindingLists#addToListSortedByStartAndUsePositions(RegisterBinding, Interval):::Adds an interval to a list sorted by Interval#from() start positions and Interval#firstUsage(RegisterPriority) first usage positions.:::list->get->prev->cur->while->cur->from->interval->from->cur->from->interval->from->cur->firstUsage->interval->firstUsage->if->else->set
Interval.RegisterBindingLists#remove(RegisterBinding, Interval):::Removes an interval from a list.:::list->get->prev->cur->while->if->set->else
Interval.UsePosList#splitAt(int):::Splits this list around a given position:::i->size->len->while->usePos->listSplitIndex->childList->IntList->copy->childList->setSize->child->new->UsePosList->return
Interval.UsePosList#usePos(int):::Gets the use position at a specified index in this list.:::return->list->get
Interval.UsePosList#registerPriority(int):::Gets the register priority for the use position at a specified index in this list.:::return->list->get
Interval.UsePosList#add(int, RegisterPriority)::: use pos list add:::list->add->list->registerPriority->ordinal->add
Interval.UsePosList#size()::: use pos list size:::return->list->size
Interval.UsePosList#removeLowestUsePos()::: use pos list remove lowest use pos:::list->list->size->setSize
Interval.UsePosList#setRegisterPriority(int, RegisterPriority)::: use pos list set register priority:::list->registerPriority->ordinal->set
Interval.UsePosList#toString()::: use pos list to string:::buf->new->StringBuilder->for->i->size->return->buf->append->toString
Interval#assignLocation(AllocatableValue)::: interval assign location:::if->isRegister->if->newLocation->getValueKind->equals->kind->equals->asRegister->asValue->return->else->if->isIllegal->else
Interval#isEndMarker():::Returns true is this is the sentinel interval that denotes the end of an interval list.:::return
Interval#location():::Gets the RegisterValue register or StackSlot spill slot assigned to this interval.:::return
Interval#kind()::: interval kind:::return
Interval#setKind(ValueKind)::: interval set kind:::
Interval#first()::: interval first:::return
Interval#from()::: interval from:::return
Interval#to()::: interval to:::if->calcTo->return
Interval#numUsePositions()::: interval num use positions:::return->usePosList->size
Interval#setLocationHint(Interval)::: interval set location hint:::
Interval#isSplitParent()::: interval is split parent:::return
Interval#isSplitChild()::: interval is split child:::return
Interval#splitParent():::Gets the split parent for this interval.:::return
Interval#spillSlot():::Gets the canonical spill slot for this interval.:::return->splitParent
Interval#setSpillSlot(AllocatableValue)::: interval set spill slot:::splitParent
Interval#currentSplitChild()::: interval current split child:::return->splitParent
Interval#makeCurrentSplitChild()::: interval make current split child:::splitParent
Interval#insertMoveWhenActivated()::: interval insert move when activated:::return
Interval#setInsertMoveWhenActivated(boolean)::: interval set insert move when activated:::
Interval#spillState()::: interval spill state:::return->splitParent
Interval#spillDefinitionPos()::: interval spill definition pos:::return->splitParent
Interval#setSpillState(SpillState)::: interval set spill state:::splitParent
Interval#setSpillDefinitionPos(int)::: interval set spill definition pos:::splitParent
Interval#alwaysInMemory()::: interval always in memory:::return->spillState->contains->canMaterialize
Interval#removeFirstUsePos()::: interval remove first use pos:::usePosList->removeLowestUsePos
Interval#intersects(Interval)::: interval intersects:::return->first->intersects
Interval#intersectsAt(Interval)::: interval intersects at:::return->first->intersectsAt
Interval#rewindRange()::: interval rewind range:::
Interval#nextRange()::: interval next range:::
Interval#currentFrom()::: interval current from:::return
Interval#currentTo()::: interval current to:::return
Interval#currentAtEnd()::: interval current at end:::return->current->isEndMarker
Interval#currentIntersects(Interval)::: interval current intersects:::return->current->intersects
Interval#currentIntersectsAt(Interval)::: interval current intersects at:::return->current->intersectsAt
Interval#addMaterializationValue(Constant):::Sets the value which is used for re-materialization.:::if->else
Interval#canMaterialize():::Returns true if this interval can be re-materialized when spilled:::return->getMaterializedValue
Interval#getMaterializedValue():::Returns a value which can be moved to a register instead of a restore-move from stack.:::return->splitParent
Interval#calcTo()::: interval calc to:::r->while->isEndMarker->return
Interval#checkSplitChildren()::: interval check split children:::if->splitChildren->isEmpty->for->i->splitChildren->size->return
Interval#locationHint(boolean)::: interval location hint:::if->return->if->if->isRegister->return->else->if->isEmpty->len->size->for->i->return
Interval#getSplitChildAtOpId(int, LIRInstruction.OperandMode, LinearScan)::: interval get split child at op id:::if->splitChildren->isEmpty->return->else->result->len->splitChildren->size->toOffset->i->for->return
Interval#checkSplitChild(Interval, int, LinearScan, int, LIRInstruction.OperandMode)::: interval check split child:::if->msg->this->toString->new->StringBuilder->append->append->if->splitChildren->isEmpty->firstChild->splitChildren->get->lastChild->splitChildren->splitChildren->size->get->msg->append->append->append->append->append->throw->new->GraalError->if->splitChildren->isEmpty->foreach->if->interval->from->interval->to->throw->result->logString->interval->logString->new->GraalError->return
Interval#getIntervalCoveringOpId(int)::: interval get interval covering op id:::if->from->return->parent->splitParent->result->len->size->for->i->return
Interval#getSplitChildBeforeOpId(int)::: interval get split child before op id:::parent->splitParent->result->len->size->for->i->return
Interval#splitChildCovers(int, LIRInstruction.OperandMode)::: interval split child covers:::if->splitChildren->isEmpty->return->covers->else->len->splitChildren->size->for->i->return
Interval#adaptPriority(RegisterPriority)::: interval adapt priority:::if->canMaterialize->return->return
Interval#firstUsage(RegisterPriority)::: interval first usage:::for->i->usePosList->size->return
Interval#nextUsage(RegisterPriority, int)::: interval next usage:::for->i->usePosList->size->return
Interval#nextUsageExact(RegisterPriority, int)::: interval next usage exact:::for->i->usePosList->size->return
Interval#previousUsage(RegisterPriority, int)::: interval previous usage:::prev->for->i->usePosList->size->return
Interval#addUsePos(int, RegisterPriority, boolean)::: interval add use pos:::if->isVariable->if->for->i->usePosList->size->len->usePosList->size->if->usePosList->usePos->usePosList->add->else->if->usePosList->registerPriority->lessThan->usePosList->setRegisterPriority
Interval#addRange(int, int)::: interval add range:::if->Math->first->min->Math->first->max->else->first->new->Range
Interval#newSplitChild(LinearScan)::: interval new split child:::parent->splitParent->result->allocator->createDerivedInterval->result->kind->setKind->result->setLocationHint->if->isEmpty->new->ArrayList<>->add->add->return
Interval#split(int, LinearScan):::Splits this interval at a specified position and returns the remainder as a new child interval of this interval's #splitParent() parent interval:::result->newSplitChild->prev->cur->while->cur->isEndMarker->if->new->Range->else->usePosList->splitAt->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->for->i->usePosList->size->for->i->size->return
Interval#splitFromStart(int, LinearScan):::Splits this interval at a specified position and returns the head as a new interval (this interval is the tail):::result->newSplitChild->result->addRange->if->else->return
Interval#covers(int, LIRInstruction.OperandMode)::: interval covers:::cur->while->cur->isEndMarker->if->cur->isEndMarker->if->return->else->return->return
Interval#hasHoleBetween(int, int)::: interval has hole between:::cur->while->cur->isEndMarker->if->return->else->if->return->else->if->return->return
Interval#toString()::: interval to string:::from->to->if->first->isEndMarker->String->from->valueOf->String->calcTo->valueOf->locationString->return->isRegister
Interval#usePosList():::Gets the use position information for this interval.:::return
Interval#logString(LinearScan):::Gets a single line string for logging the details of this interval to a log stream.:::buf->new->StringBuilder->buf->append->append->append->append->if->isRegister->if->buf->append->append->append->buf->append->append->hint->locationHint->if->buf->append->append->buf->append->cur->while->cur->isEndMarker->if->buf->append->buf->append->buf->append->prev->for->i->usePosList->size->buf->append->spillState->append->append->if->canMaterialize->buf->append->getMaterializedValue->toString->append->append->return->buf->toString
Interval#getSplitChildren()::: interval get split children:::return->Collections->unmodifiableList
IntervalWalker#activateCurrent(Interval):::Processes the currentInterval interval in an attempt to allocate a physical register to it and thus allow it to be moved to a list of #activeLists active intervals.:::return
IntervalWalker#walkBefore(int)::: interval walker walk before:::walkTo
IntervalWalker#walk()::: interval walker walk:::walkTo
IntervalWalker#removeFromList(Interval)::: interval walker remove from list:::if->activeLists->remove->else->inactiveLists->remove
IntervalWalker#walkTo(State, int)::: interval walker walk to:::foreach->walkTo
IntervalWalker#walkTo(State, int, RegisterBinding)::: interval walker walk to:::prevprev->prev->activeLists->get->inactiveLists->get->next->while->next->currentFrom->cur->rangeHasChanged->while->cur->currentTo->cur->nextRange->cur->currentFrom->if->if->if->activeLists->set->else->inactiveLists->set->else->newState->if->cur->currentAtEnd->else->if->cur->currentFrom->activeLists->addToListSortedByCurrentFromPositions->else->inactiveLists->addToListSortedByCurrentFromPositions->if->intervalMoved->else
IntervalWalker#nextInterval(int):::Get the next interval from #unhandledLists which starts before or at toOpId:::binding->any->fixed->if->any->isEndMarker->fixed->isEndMarker->fixed->from->any->from->else->if->fixed->isEndMarker->else->return->currentInterval->unhandledLists->get->if->currentInterval->from->return->unhandledLists->set->currentInterval->rewindRange->return
IntervalWalker#walkTo(int):::Walk up to toOpId.:::for->currentInterval->nextInterval->nextInterval->if->allocator->maxOpId->updateUnhandledStackIntervals->walkTo->walkTo
IntervalWalker#intervalMoved(Interval, State, State)::: interval walker interval moved:::debug->allocator->getDebug->if->debug->isLogEnabled->debug->interval->logString->log
IntervalWalker#updateUnhandledStackIntervals(int):::Move #unhandledLists unhandled stack intervals to IntervalWalker #activeLists active:::currentInterval->unhandledLists->get->while->currentInterval->isEndMarker->currentInterval->from->next->if->currentInterval->to->activeLists->addToListSortedByCurrentFromPositions->intervalMoved->else->intervalMoved->unhandledLists->set
LinearScan#getLIRGenerationResult()::: linear scan get generation result:::return
LinearScan#intervalEndMarker()::: linear scan interval end marker:::return
LinearScan#getOptions()::: linear scan get options:::return->ir->getOptions
LinearScan#getDebug()::: linear scan get debug:::return
LinearScan#getFirstLirInstructionId(AbstractBlockBase)::: linear scan get first lir instruction id:::result->ir->getLIRforBlock->get->id->return
LinearScan#getLastLirInstructionId(AbstractBlockBase)::: linear scan get last lir instruction id:::instructions->ir->getLIRforBlock->result->instructions->instructions->size->get->id->return
LinearScan#getSpillMoveFactory()::: linear scan get spill move factory:::return
LinearScan#createMoveResolver()::: linear scan create move resolver:::moveResolver->new->MoveResolver->return
LinearScan#isVariableOrRegister(Value)::: linear scan is variable or register:::return->isVariable->isRegister
LinearScan#operandNumber(Value):::Converts an operand (variable or register) to an index in a flat address space covering all the Variable variables and RegisterValue registers being processed by this allocator.:::if->isRegister->number->asRegister->return->return
LinearScan#operandSize():::Gets the number of operands:::return
LinearScan#maxRegisterNumber():::Gets the highest operand number for a register operand:::return
LinearScan#getBlockData(AbstractBlockBase)::: linear scan get block data:::return->blockData->get
LinearScan#initBlockData(AbstractBlockBase)::: linear scan init block data:::blockData->new->BlockData->put
LinearScan#attributes(Register):::Gets an object describing the attributes of a given register according to this register configuration.:::return
LinearScan#assignSpillSlot(Interval)::: linear scan assign spill slot:::if->interval->canMaterialize->interval->assignLocation->else->if->interval->spillSlot->interval->interval->spillSlot->assignLocation->else->slot->frameMapBuilder->interval->kind->allocateSpillSlot->interval->setSpillSlot->interval->assignLocation
LinearScan#intervals():::Map from #operandNumber(Value) operand numbers to intervals.:::return
LinearScan#initIntervals()::: linear scan init intervals:::operandSize->new->IntervalArr
LinearScan#createInterval(AllocatableValue):::Creates a new interval.:::operandNumber->operandNumber->interval->new->Interval->return
LinearScan#createDerivedInterval(Interval):::Creates an interval as a result of splitting or spilling another interval.:::if->if->Arrays->copyOf->variable->source->kind->new->Variable->interval->createInterval->return
LinearScan#blockCount()::: linear scan block count:::return
LinearScan#blockAt(int)::: linear scan block at:::return
LinearScan#liveSetSize():::Gets the size of the BlockData#liveIn and BlockData#liveOut sets for a basic block:::return->operandSize
LinearScan#numLoops()::: linear scan num loops:::return->ir->getControlFlowGraph->getLoops->size
LinearScan#intervalFor(int)::: linear scan interval for:::return
LinearScan#intervalFor(Value)::: linear scan interval for:::operandNumber->operandNumber->return
LinearScan#getOrCreateInterval(AllocatableValue)::: linear scan get or create interval:::ret->intervalFor->if->return->createInterval->else->return
LinearScan#initOpIdMaps(int)::: linear scan init op id maps:::new->LIRInstructionArr->new->AbstractBlockBase<?>Arr
LinearScan#putOpIdMaps(int, LIRInstruction, AbstractBlockBase)::: linear scan put op id maps:::
LinearScan#maxOpId():::Gets the highest instruction id allocated by this object.:::return
LinearScan#opIdToIndex(int):::Converts an LIRInstruction#id instruction id to an instruction index:::return
LinearScan#instructionForId(int):::Retrieves the LIRInstruction based on its LIRInstruction#id id.:::instr->opIdToIndex->return
LinearScan#blockForId(int):::Gets the block containing a given instruction.:::return->opIdToIndex
LinearScan#isBlockBegin(int)::: linear scan is block begin:::return->blockForId->blockForId
LinearScan#coversBlockBegin(int, int)::: linear scan covers block begin:::return->blockForId->blockForId
LinearScan#hasCall(int):::Determines if an LIRInstruction destroys all caller saved registers.:::return->instructionForId->destroysCallerSavedRegisters
LinearScan.IntervalPredicate#apply(Interval)::: interval predicate apply:::
LinearScan#isProcessed(Value)::: linear scan is processed:::return->isRegister->asRegister->attributes->isAllocatable
LinearScan#isSorted(Interval[])::: linear scan is sorted:::from->foreach->interval->from->return
LinearScan#addToList(Interval, Interval, Interval)::: linear scan add to list:::newFirst->if->else->return
LinearScan#createUnhandledLists(IntervalPredicate, IntervalPredicate)::: linear scan create unhandled lists:::list1->list2->list1Prev->list2Prev->v->n->for->i->if->if->return->Pair->create
LinearScan#sortIntervalsBeforeAllocation()::: linear scan sort intervals before allocation:::sortedLen->foreach->if->sortedList->new->IntervalArr->sortedIdx->sortedFromMax->foreach->if->from->interval->from->if->interval->from->else->j->for->from
LinearScan#sortIntervalsAfterAllocation()::: linear scan sort intervals after allocation:::if->return->oldList->newList->Arrays->copyOfRange->oldLen->newLen->Arrays->a->from->b->from->sort->combinedList->new->IntervalArr->oldIdx->newIdx->while->if->from->from->else
LinearScan#splitChildAtOpId(Interval, int, LIRInstruction.OperandMode)::: linear scan split child at op id:::result->interval->getSplitChildAtOpId->if->if->debug->isLogEnabled->debug->log->return->throw->new->GraalError
LinearScan#canonicalSpillOpr(Interval)::: linear scan canonical spill opr:::return->interval->spillSlot
LinearScan#isMaterialized(AllocatableValue, int, OperandMode)::: linear scan is materialized:::interval->intervalFor->if->splitChildAtOpId->return->interval->location->isIllegal->interval->canMaterialize
LinearScan#isCallerSave(Value)::: linear scan is caller save:::return->asRegister->attributes->isCallerSave
LinearScan#allocate(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan allocate:::try->indent->debug->logAndIndent->createLifetimeAnalysisPhase->apply->try->s->debug->scope->sortIntervalsBeforeAllocation->createRegisterAllocationPhase->apply->if->getOptions->getValue->createOptimizeSpillPositionPhase->apply->createResolveDataFlowPhase->apply->sortIntervalsAfterAllocation->if->verify->beforeSpillMoveElimination->createSpillMoveEliminationPhase->apply->createAssignLocationsPhase->apply->if->verifyIntervals->catch->throw->debug->handle->finally->catch->finally
LinearScan#beforeSpillMoveElimination()::: linear scan before spill move elimination:::
LinearScan#createLifetimeAnalysisPhase()::: linear scan create lifetime analysis phase:::return->new->LinearScanLifetimeAnalysisPhase
LinearScan#createRegisterAllocationPhase()::: linear scan create register allocation phase:::return->new->LinearScanRegisterAllocationPhase
LinearScan#createOptimizeSpillPositionPhase()::: linear scan create optimize spill position phase:::return->new->LinearScanOptimizeSpillPositionPhase
LinearScan#createResolveDataFlowPhase()::: linear scan create resolve data flow phase:::return->new->LinearScanResolveDataFlowPhase
LinearScan#createSpillMoveEliminationPhase()::: linear scan create spill move elimination phase:::return->new->LinearScanEliminateSpillMovePhase
LinearScan#createAssignLocationsPhase()::: linear scan create assign locations phase:::return->new->LinearScanAssignLocationsPhase
LinearScan#printIntervals(String)::: linear scan print intervals:::if->debug->isLogEnabled->try->indent->debug->logAndIndent->foreach->if->debug->interval->logString->log->try->indent2->debug->logAndIndent->for->i->blockCount->catch->finally->catch->finally->debug->Arrays->copyOf->new->LinearScanIntervalDumper->dump
LinearScan#verify()::: linear scan verify:::verifyIntervals->verifyRegisters->debug->log->return
LinearScan#verifyRegisters()::: linear scan verify registers:::try->indent->debug->logAndIndent->verifier->new->RegisterVerifier->verifier->blockAt->verify->catch->finally
LinearScan#verifyIntervals()::: linear scan verify intervals:::try->indent->debug->logAndIndent->len->for->i->catch->finally
LinearScan.CheckConsumer#visitValue(Value, OperandMode, EnumSet)::: check consumer visit value:::if->isRegister->if->intervalFor
LinearScan#verifyNoOopsInFixedIntervals()::: linear scan verify no oops in fixed intervals:::try->indent->debug->logAndIndent->checkConsumer->new->CheckConsumer->fixedIntervals->otherIntervals->createUnhandledLists->getLeft->new->Interval->otherIntervals->addRange->iw->new->IntervalWalker->foreach->instructions->ir->getLIRforBlock->for->j->instructions->size->catch->finally
LinearScan#getLIR()::: linear scan get r:::return
LinearScan#getFrameMapBuilder()::: linear scan get frame map builder:::return
LinearScan#sortedBlocks()::: linear scan sorted blocks:::return
LinearScan#getRegisters()::: linear scan get registers:::return
LinearScan#getRegisterAllocationConfig()::: linear scan get register allocation config:::return
LinearScan#callKillsRegisters()::: linear scan call kills registers:::return->regAllocConfig->getRegisterConfig->areAllAllocatableRegistersCallerSaved
LinearScan#neverSpillConstants()::: linear scan never spill constants:::return
LinearScanAllocationPhase#getName()::: linear scan allocation phase get name:::return->LIRPhase->getClass->createName
LinearScanAllocationPhase#toString()::: linear scan allocation phase to string:::return->getName->toString
LinearScanAllocationPhase#apply(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan allocation phase apply:::apply
LinearScanAllocationPhase#apply(TargetDescription, LIRGenerationResult, AllocationContext, boolean)::: linear scan allocation phase apply:::debug->lirGenRes->getLIR->getDebug->try->s->debug->getName->scope->run->if->if->debug->isDumpEnabled->debug->lirGenRes->getLIR->getName->dump->catch->throw->debug->handle->finally
LinearScanAllocationPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan allocation phase run:::
LinearScanAssignLocationsPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan assign locations phase run:::assignLocations
LinearScanAssignLocationsPhase#colorLirOperand(LIRInstruction, Variable, OperandMode):::Assigns the allocated location for an LIR instruction operand back into the instruction.:::opId->op->id->interval->allocator->intervalFor->if->if->block->allocator->blockForId->if->block->getSuccessorCount->allocator->getLastLirInstructionId->instr->allocator->getLIR->getLIRforBlock->allocator->getLIR->getLIRforBlock->size->get->if->if->allocator->getBlockData->allocator->operandNumber->get->allocator->splitChildAtOpId->if->interval->location->isIllegal->interval->canMaterialize->return->interval->kind->interval->getMaterializedValue->new->ConstantValue->return->interval->location
LinearScanAssignLocationsPhase#debugInfoProcedure(LIRInstruction, Value)::: linear scan assign locations phase debug info procedure:::if->isVirtualStackSlot->return->tempOpId->op->id->mode->block->allocator->blockForId->if->block->getSuccessorCount->allocator->getLastLirInstructionId->instr->allocator->getLIR->getLIRforBlock->allocator->getLIR->getLIRforBlock->size->get->if->if->allocator->getBlockData->allocator->operandNumber->get->allocator->block->getSuccessors->getFirstLirInstructionId->result->colorLirOperand->return
LinearScanAssignLocationsPhase#assignLocations(ArrayList)::: linear scan assign locations phase assign locations:::numInst->instructions->size->hasDead->for->j->if->instructions->Collections->singleton->removeAll
LinearScanAssignLocationsPhase#assignLocations(LIRInstruction):::Assigns the operand of an LIRInstruction.:::if->MoveOp->isMoveOp->result->MoveOp->asMoveOp->getResult->if->isVariable->allocator->op->id->isMaterialized->return->op->forEachInput->op->forEachAlive->op->forEachTemp->op->forEachOutput->op->forEachState->if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->move->getResult->equals->return->return
LinearScanAssignLocationsPhase#assignLocations()::: linear scan assign locations phase assign locations:::debug->allocator->getDebug->try->indent->debug->logAndIndent->foreach->allocator->sortedBlocks->try->indent2->debug->block->getId->logAndIndent->allocator->getLIR->getLIRforBlock->assignLocations->catch->finally->catch->finally
LinearScanEliminateSpillMovePhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan eliminate spill move phase run:::eliminateSpillMoves
LinearScanEliminateSpillMovePhase#firstInstructionOfInterest()::: linear scan eliminate spill move phase first instruction of interest:::return
LinearScanEliminateSpillMovePhase#eliminateSpillMoves(LIRGenerationResult)::: linear scan eliminate spill move phase eliminate spill moves:::debug->allocator->getDebug->try->indent->debug->logAndIndent->interval->allocator->createUnhandledLists->getLeft->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->checkIntervals->insertionBuffer->new->LIRInsertionBuffer->foreach->allocator->sortedBlocks->try->indent1->debug->logAndIndent->instructions->allocator->getLIR->getLIRforBlock->numInst->instructions->size->for->j->firstInstructionOfInterest->if->insertionBuffer->initialized->insertionBuffer->finish->catch->finally->catch->finally
LinearScanEliminateSpillMovePhase#canEliminateSpillMove(AbstractBlockBase, MoveOp)::: linear scan eliminate spill move phase can eliminate spill move:::curInterval->allocator->move->getResult->intervalFor->if->curInterval->location->isRegister->curInterval->alwaysInMemory->return->return
LinearScanEliminateSpillMovePhase#checkIntervals(DebugContext, Interval)::: linear scan eliminate spill move phase check intervals:::prev->temp->while->temp->isEndMarker->if->if->debug->isLogEnabled->debug->temp->from->temp->to->temp->spillDefinitionPos->log
LinearScanIntervalDumper#visitIntervals(IntervalVisitor)::: linear scan interval dumper visit intervals:::foreach->if->printInterval
LinearScanIntervalDumper#printInterval(Interval, IntervalVisitor)::: linear scan interval dumper print interval:::hint->interval->locationHint->interval->locationHint->operand->type->isRegister->operand->getValueKind->getPlatformKind->toString->visitor->interval->splitParent->interval->location->visitIntervalStart->cur->interval->first->while->cur->isEndMarker->visitor->visitRange->prev->usePosList->interval->usePosList->for->i->usePosList->size->visitor->interval->spillState->visitIntervalEnd
LinearScanLifetimeAnalysisPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan lifetime analysis phase run:::numberInstructions->debug->lirGenRes->getLIR->dump->computeLocalLiveSets->computeGlobalLiveSets->Assertions->allocator->getOptions->detailedAssertionsEnabled->buildIntervals
LinearScanLifetimeAnalysisPhase#isIntervalInLoop(int, int)::: linear scan lifetime analysis phase is interval in loop:::return->intervalInLoop->at
LinearScanLifetimeAnalysisPhase#numberInstructions():::Numbers all instructions in all blocks:::allocator->initIntervals->setVariableConsumer->if->isVariable->allocator->asVariable->getOrCreateInterval->numInstructions->foreach->allocator->sortedBlocks->allocator->getLIR->getLIRforBlock->size->allocator->initOpIdMaps->opId->index->foreach->allocator->sortedBlocks->allocator->initBlockData->instructions->allocator->getLIR->getLIRforBlock->numInst->instructions->size->for->j
LinearScanLifetimeAnalysisPhase#computeLocalLiveSets():::Computes local live sets (i.e:::liveSize->allocator->liveSetSize->allocator->operandSize->allocator->numLoops->new->BitMap2D->try->liveGenScratch->new->BitSet->liveKillScratch->new->BitSet->foreach->allocator->sortedBlocks->try->indent->debug->logAndIndent->liveGenScratch->clear->liveKillScratch->clear->instructions->allocator->getLIR->getLIRforBlock->numInst->instructions->size->useConsumer->if->isVariable->operandNum->getOperandNumber->if->liveKillScratch->get->liveGenScratch->set->if->debug->isLogEnabled->debug->log->if->block->getLoop->intervalInLoop->block->getLoop->getIndex->setBit->if->verifyInput->stateConsumer->if->LinearScan->isVariableOrRegister->operandNum->getOperandNumber->if->liveKillScratch->get->liveGenScratch->set->if->debug->isLogEnabled->debug->log->defConsumer->if->isVariable->varNum->getOperandNumber->liveKillScratch->set->if->debug->isLogEnabled->debug->log->if->block->getLoop->intervalInLoop->block->getLoop->getIndex->setBit->if->verifyTemp->for->j->blockSets->allocator->getBlockData->trimClone->trimClone->new->BitSet->new->BitSet->if->debug->isLogEnabled->debug->block->getId->log->debug->block->getId->log->catch->finally->catch->throw->new->PermanentBailoutException->finally
LinearScanLifetimeAnalysisPhase#verifyTemp(BitSet, Value)::: linear scan lifetime analysis phase verify temp:::if->isRegister->if->allocator->isProcessed->liveKill->getOperandNumber->set
LinearScanLifetimeAnalysisPhase#verifyInput(AbstractBlockBase, BitSet, Value)::: linear scan lifetime analysis phase verify input:::if->isRegister->allocator->getLIR->getControlFlowGraph->getStartBlock->if->allocator->isProcessed
LinearScanLifetimeAnalysisPhase#getOperandNumber(Value)::: linear scan lifetime analysis phase get operand number:::return->allocator->operandNumber
LinearScanLifetimeAnalysisPhase#computeGlobalLiveSets():::Performs a backward dataflow analysis to compute global live sets (i.e:::try->indent->debug->logAndIndent->numBlocks->allocator->blockCount->changeOccurred->changeOccurredInBlock->iterationCount->scratch->allocator->liveSetSize->new->BitSet->do->try->indent2->debug->logAndIndent->for->i->if->throw->new->PermanentBailoutException->catch->finally->while->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->verifyLiveness->startBlock->allocator->getLIR->getControlFlowGraph->getStartBlock->if->allocator->getBlockData->cardinality->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->reportFailure->throw->allocator->getBlockData->new->GraalError->catch->finally
LinearScanLifetimeAnalysisPhase#trimClone(BitSet):::Creates a trimmed copy a bit set:::trimmedSet->new->BitSet->trimmedSet->or->return
LinearScanLifetimeAnalysisPhase#reportFailure(int)::: linear scan lifetime analysis phase report failure:::try->s->debug->forceLog->try->indent->debug->logAndIndent->startBlockLiveIn->allocator->allocator->getLIR->getControlFlowGraph->getStartBlock->getBlockData->try->indent2->debug->logAndIndent->for->operandNum->startBlockLiveIn->nextSetBit->startBlockLiveIn->nextSetBit->catch->finally->for->operandNum->startBlockLiveIn->nextSetBit->startBlockLiveIn->nextSetBit->catch->finally->catch->throw->debug->handle->finally
LinearScanLifetimeAnalysisPhase#verifyLiveness()::: linear scan lifetime analysis phase verify liveness:::foreach->allocator->sortedBlocks->for->j->allocator->maxRegisterNumber
LinearScanLifetimeAnalysisPhase#addUse(AllocatableValue, int, int, RegisterPriority, ValueKind, boolean)::: linear scan lifetime analysis phase add use:::if->allocator->isProcessed->return->interval->allocator->getOrCreateInterval->if->kind->equals->interval->setKind->interval->addRange->interval->addUsePos->if->debug->isLogEnabled->debug->registerPriority->name->log
LinearScanLifetimeAnalysisPhase#addTemp(AllocatableValue, int, RegisterPriority, ValueKind, boolean)::: linear scan lifetime analysis phase add temp:::if->allocator->isProcessed->return->interval->allocator->getOrCreateInterval->if->kind->equals->interval->setKind->interval->addRange->interval->addUsePos->interval->addMaterializationValue->if->debug->isLogEnabled->debug->name->log
LinearScanLifetimeAnalysisPhase#addDef(AllocatableValue, LIRInstruction, RegisterPriority, ValueKind, boolean)::: linear scan lifetime analysis phase add def:::if->allocator->isProcessed->return->defPos->op->id->interval->allocator->getOrCreateInterval->if->kind->equals->interval->setKind->r->interval->first->if->interval->addUsePos->else->interval->addRange->interval->addUsePos->if->debug->isLogEnabled->debug->log->changeSpillDefinitionPos->if->interval->spillState->ordinal->ordinal->isStackSlot->interval->setSpillState->interval->getMaterializedValue->addMaterializationValue->if->debug->isLogEnabled->debug->registerPriority->name->log
LinearScanLifetimeAnalysisPhase#handleMethodArguments(LIRInstruction):::Optimizes moves related to incoming stack based arguments:::if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->optimizeMethodArgument->slot->move->getInput->asStackSlot->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->if->debug->isLogEnabled->debug->move->getResult->log->interval->allocator->move->getResult->intervalFor->interval->setSpillSlot->interval->assignLocation
LinearScanLifetimeAnalysisPhase#addRegisterHint(LIRInstruction, Value, OperandMode, EnumSet, boolean)::: linear scan lifetime analysis phase add register hint:::if->flags->contains->LinearScan->isVariableOrRegister->op->if->LinearScan->isVariableOrRegister->from->allocator->getOrCreateInterval->to->allocator->getOrCreateInterval->if->to->setLocationHint->else->from->setLocationHint->if->debug->isLogEnabled->debug->op->id->log->return->return->forEachRegisterHint
LinearScanLifetimeAnalysisPhase#changeSpillDefinitionPos(LIRInstruction, AllocatableValue, Interval, int):::Eliminates moves from register to stack if the stack slot is known to be correct.:::switch->interval->spillState->interval->setSpillDefinitionPos->interval->setSpillState->break->if->interval->spillDefinitionPos->interval->setSpillState->else->break->break->throw->GraalError->shouldNotReachHere
LinearScanLifetimeAnalysisPhase#optimizeMethodArgument(Value)::: linear scan lifetime analysis phase optimize method argument:::return->isStackSlot->asStackSlot->isInCallerFrame->LIRKind->isValue
LinearScanLifetimeAnalysisPhase#registerPriorityOfOutputOperand(LIRInstruction):::Determines the register priority for an instruction's output/result operand.:::if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->optimizeMethodArgument->return->return
LinearScanLifetimeAnalysisPhase#registerPriorityOfInputOperand(EnumSet):::Determines the priority which with an instruction's input operand will be allocated a register.:::if->flags->contains->return->return
LinearScanLifetimeAnalysisPhase#buildIntervals(boolean)::: linear scan lifetime analysis phase build intervals:::try->indent->debug->logAndIndent->outputConsumer->if->LinearScan->isVariableOrRegister->registerPriorityOfOutputOperand->operand->getValueKind->addDef->addRegisterHint->tempConsumer->if->LinearScan->isVariableOrRegister->op->id->operand->getValueKind->addTemp->addRegisterHint->aliveConsumer->if->LinearScan->isVariableOrRegister->p->registerPriorityOfInputOperand->opId->op->id->blockFrom->allocator->allocator->blockForId->getFirstLirInstructionId->operand->getValueKind->addUse->addRegisterHint->inputConsumer->if->LinearScan->isVariableOrRegister->opId->op->id->blockFrom->allocator->allocator->blockForId->getFirstLirInstructionId->p->registerPriorityOfInputOperand->operand->getValueKind->addUse->addRegisterHint->stateProc->if->LinearScan->isVariableOrRegister->opId->op->id->blockFrom->allocator->allocator->blockForId->getFirstLirInstructionId->operand->getValueKind->addUse->callerSaveRegs->allocator->getRegisterAllocationConfig->getRegisterConfig->getCallerSaveRegisters->for->i->allocator->blockCount->foreach->allocator->intervals->if->isRegister->interval->addRange->catch->finally
LinearScanLifetimeAnalysisPhase#getMaterializedValue(LIRInstruction, Value, Interval):::Returns a value for a interval definition, which can be used for re-materialization.:::if->LoadConstantOp->isLoadConstantOp->move->LoadConstantOp->asLoadConstantOp->if->allocator->neverSpillConstants->usePosList->interval->usePosList->numUsePos->usePosList->size->for->useIdx->return->move->getConstant->return
LinearScanOptimizeSpillPositionPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan optimize spill position phase run:::optimizeSpillPosition->allocator->printIntervals
LinearScanOptimizeSpillPositionPhase#optimizeSpillPosition(LIRGenerationResult)::: linear scan optimize spill position phase optimize spill position:::try->indent0->debug->logAndIndent->insertionBuffers->allocator->getLIR->linearScanOrder->new->LIRInsertionBufferArr->foreach->allocator->intervals->optimizeInterval->foreach->if->insertionBuffer->finish->catch->finally
LinearScanOptimizeSpillPositionPhase#optimizeInterval(LIRInsertionBuffer[], Interval, LIRGenerationResult)::: linear scan optimize spill position phase optimize interval:::if->interval->isSplitParent->interval->spillState->return->defBlock->allocator->interval->spillDefinitionPos->blockForId->spillBlock->firstSpillChild->try->indent->debug->logAndIndent->foreach->interval->getSplitChildren->if->splitChild->location->isStackSlotValue->if->splitChild->from->firstSpillChild->from->else->foreach->blocksForInterval->if->dominates->debug->log->if->else->commonDominator->if->debug->log->interval->setSpillState->return->debug->log->if->defBlock->getLoopDepth->spillBlock->getLoopDepth->moveSpillOutOfLoop->debug->log->if->defBlock->equals->spillBlock->allocator->firstSpillChild->from->blockForId->equals->dom->spillBlock->getDominator->if->debug->isLogEnabled->debug->log->if->defBlock->equals->debug->log->interval->setSpillState->return->betterSpillPos->increment->if->debug->isLogEnabled->debug->log->if->defBlock->getRelativeFrequency->spillBlock->getRelativeFrequency->debug->defBlock->getRelativeFrequency->spillBlock->getRelativeFrequency->log->interval->setSpillState->return->insertionBuffer->spillBlock->getId->if->new->LIRInsertionBuffer->spillBlock->getId->insertionBuffer->allocator->getLIR->getLIRforBlock->init->spillOpId->allocator->getFirstLirInstructionId->fromLocation->interval->getSplitChildAtOpId->location->toLocation->LinearScan->canonicalSpillOpr->move->allocator->getSpillMoveFactory->createMove->move->setComment->debug->log->move->setId->insertionBuffer->append->betterSpillPosWithLowerProbability->increment->interval->setSpillDefinitionPos->catch->finally
LinearScanOptimizeSpillPositionPhase.IntervalBlockIterator#next()::: interval block iterator next:::currentBlock->nextBlockIndex->block->getLinearScanNumber->if->allocator->sortedBlocks->allocator->sortedBlocks->if->allocator->getFirstLirInstructionId->if->range->isEndMarker->else->allocator->blockForId->else->return
LinearScanOptimizeSpillPositionPhase.IntervalBlockIterator#hasNext()::: interval block iterator has next:::return
LinearScanOptimizeSpillPositionPhase#blocksForInterval(Interval)::: linear scan optimize spill position phase blocks for interval:::return->new->Iterable<AbstractBlockBase<?>>
LinearScanOptimizeSpillPositionPhase#moveSpillOutOfLoop(AbstractBlockBase, AbstractBlockBase)::: linear scan optimize spill position phase move spill out of loop:::defLoopDepth->defBlock->getLoopDepth->for->block->spillBlock->getDominator->defBlock->equals->block->getDominator->return
LinearScanPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan phase run:::spillMoveFactory->registerAllocationConfig->allocator->lirGenRes->getLIR->linearScanOrder->getNeverSpillConstants->new->SSALinearScan->allocator->allocate
LinearScanRegisterAllocationPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan register allocation phase run:::allocator->printIntervals->allocateRegisters->allocator->printIntervals
LinearScanRegisterAllocationPhase#allocateRegisters()::: linear scan register allocation phase allocate registers:::try->indent->allocator->getDebug->logAndIndent->precoloredIntervals->notPrecoloredIntervals->result->allocator->createUnhandledLists->result->getLeft->result->getRight->lsw->if->allocator->getOptions->getValue->new->OptimizingLinearScanWalker->else->new->LinearScanWalker->lsw->walk->lsw->finishAllocation->catch->finally
LinearScanResolveDataFlowPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)::: linear scan resolve data flow phase run:::resolveDataFlow->allocator->printIntervals
LinearScanResolveDataFlowPhase#resolveCollectMappings(AbstractBlockBase, AbstractBlockBase, AbstractBlockBase, MoveResolver)::: linear scan resolve data flow phase resolve collect mappings:::toBlockFirstInstructionId->allocator->getFirstLirInstructionId->fromBlockLastInstructionId->allocator->getLastLirInstructionId->numOperands->allocator->operandSize->liveAtEdge->allocator->getBlockData->for->operandNum->liveAtEdge->nextSetBit->liveAtEdge->nextSetBit
LinearScanResolveDataFlowPhase#resolveFindInsertPos(AbstractBlockBase, AbstractBlockBase, MoveResolver)::: linear scan resolve data flow phase resolve find insert pos:::debug->allocator->getDebug->if->fromBlock->getSuccessorCount->if->debug->isLogEnabled->debug->fromBlock->getId->log->instructions->allocator->getLIR->getLIRforBlock->instr->instructions->instructions->size->get->if->moveResolver->instructions->size->setInsertPosition->else->moveResolver->instructions->size->setInsertPosition->else->if->debug->isLogEnabled->debug->toBlock->getId->log->if->foreach->toBlock->getPredecessors->moveResolver->allocator->getLIR->getLIRforBlock->setInsertPosition
LinearScanResolveDataFlowPhase#resolveDataFlow():::Inserts necessary moves (spilling or reloading) at edges between blocks for intervals that have been split.:::try->indent->allocator->getDebug->logAndIndent->moveResolver->allocator->createMoveResolver->blockCompleted->allocator->blockCount->new->BitSet->optimizeEmptyBlocks->resolveDataFlow0->catch->finally
LinearScanResolveDataFlowPhase#optimizeEmptyBlocks(MoveResolver, BitSet)::: linear scan resolve data flow phase optimize empty blocks:::foreach->allocator->sortedBlocks->if->block->getPredecessorCount->block->getSuccessorCount->instructions->allocator->getLIR->getLIRforBlock->if->instructions->size->pred->block->getPredecessors->sux->block->getSuccessors->if->blockCompleted->pred->getLinearScanNumber->get->blockCompleted->sux->getLinearScanNumber->get->debug->allocator->getDebug->if->debug->isLogEnabled->debug->block->getId->pred->getId->sux->getId->log->blockCompleted->block->getLinearScanNumber->set->resolveCollectMappings->if->moveResolver->hasMappings->moveResolver->setInsertPosition->moveResolver->resolveAndAppendMoves
LinearScanResolveDataFlowPhase#resolveDataFlow0(MoveResolver, BitSet)::: linear scan resolve data flow phase resolve data flow0:::alreadyResolved->allocator->blockCount->new->BitSet->foreach->allocator->sortedBlocks->if->blockCompleted->fromBlock->getLinearScanNumber->get->alreadyResolved->clear->alreadyResolved->or->foreach->fromBlock->getSuccessors->if->alreadyResolved->toBlock->getLinearScanNumber->get->debug->allocator->getDebug->if->debug->isLogEnabled->debug->fromBlock->getId->toBlock->getId->log->alreadyResolved->toBlock->getLinearScanNumber->set->resolveCollectMappings->if->moveResolver->hasMappings->resolveFindInsertPos->moveResolver->resolveAndAppendMoves
LinearScanWalker#blockCount()::: linear scan walker block count:::return->allocator->blockCount
LinearScanWalker#blockAt(int)::: linear scan walker block at:::return->allocator->blockAt
LinearScanWalker#blockOfOpWithId(int)::: linear scan walker block of op with id:::return->allocator->blockForId
LinearScanWalker#initUseLists(boolean)::: linear scan walker init use lists:::foreach->i->if->clear
LinearScanWalker#maxRegisterNumber()::: linear scan walker max register number:::return
LinearScanWalker#minRegisterNumber()::: linear scan walker min register number:::return
LinearScanWalker#isRegisterInRange(int)::: linear scan walker is register in range:::return->minRegisterNumber->maxRegisterNumber
LinearScanWalker#excludeFromUse(Interval)::: linear scan walker exclude from use:::location->i->location->i1->asRegister->if->isRegisterInRange
LinearScanWalker#setUsePos(Interval, int, boolean)::: linear scan walker set use pos:::if->i->interval->location->asRegister->if->isRegisterInRange->if->if->list->if->new->ArrayList<>->list->add
LinearScanWalker#setBlockPos(Interval, int)::: linear scan walker set block pos:::if->reg->i->location->asRegister->if->isRegisterInRange->if->if
LinearScanWalker#freeExcludeActiveFixed()::: linear scan walker free exclude active fixed:::interval->activeLists->get->while->interval->isEndMarker->excludeFromUse
LinearScanWalker#freeExcludeActiveAny()::: linear scan walker free exclude active any:::interval->activeLists->get->while->interval->isEndMarker->excludeFromUse
LinearScanWalker#freeCollectInactiveFixed(Interval)::: linear scan walker free collect inactive fixed:::interval->inactiveLists->get->while->interval->isEndMarker->if->current->to->interval->currentFrom->interval->currentFrom->setUsePos->else->interval->currentIntersectsAt->setUsePos
LinearScanWalker#freeCollectInactiveAny(Interval)::: linear scan walker free collect inactive any:::interval->inactiveLists->get->while->interval->isEndMarker->interval->currentIntersectsAt->setUsePos
LinearScanWalker#freeCollectUnhandled(RegisterBinding, Interval)::: linear scan walker free collect unhandled:::interval->unhandledLists->get->while->interval->isEndMarker->interval->intersectsAt->setUsePos->if->current->to->interval->from->interval->from->setUsePos
LinearScanWalker#spillExcludeActiveFixed()::: linear scan walker spill exclude active fixed:::interval->activeLists->get->while->interval->isEndMarker->excludeFromUse
LinearScanWalker#spillBlockUnhandledFixed(Interval)::: linear scan walker spill block unhandled fixed:::interval->unhandledLists->get->while->interval->isEndMarker->interval->intersectsAt->setBlockPos
LinearScanWalker#spillBlockInactiveFixed(Interval)::: linear scan walker spill block inactive fixed:::interval->inactiveLists->get->while->interval->isEndMarker->if->current->to->interval->currentFrom->interval->currentIntersectsAt->setBlockPos->else
LinearScanWalker#spillCollectActiveAny(RegisterPriority)::: linear scan walker spill collect active any:::interval->activeLists->get->while->interval->isEndMarker->Math->interval->nextUsage->interval->to->min->setUsePos
LinearScanWalker#spillCollectInactiveAny(Interval)::: linear scan walker spill collect inactive any:::interval->inactiveLists->get->while->interval->isEndMarker->if->interval->currentIntersects->Math->interval->nextUsage->interval->to->min->setUsePos
LinearScanWalker#insertMove(int, Interval, Interval)::: linear scan walker insert move:::opId->opBlock->allocator->blockForId->instructions->allocator->getLIR->getLIRforBlock->index->instructions->get->id->while->instructions->get->id->moveResolver->moveInsertPosition->moveResolver->addMapping
LinearScanWalker#findOptimalSplitPos(AbstractBlockBase, AbstractBlockBase, int)::: linear scan walker find optimal split pos:::fromBlockNr->minBlock->getLinearScanNumber->toBlockNr->maxBlock->getLinearScanNumber->optimalSplitPos->allocator->getLastLirInstructionId->if->allocator->getFirstLirInstructionId->minLoopDepth->maxBlock->getLoopDepth->for->i->return
LinearScanWalker#findOptimalSplitPos(Interval, int, int, boolean)::: linear scan walker find optimal split pos:::debug->allocator->getDebug->optimalSplitPos->if->if->debug->isLogEnabled->debug->log->else->minBlock->allocator->blockForId->maxBlock->allocator->blockForId->if->if->debug->isLogEnabled->debug->log->else->if->interval->hasHoleBetween->allocator->isBlockBegin->if->debug->isLogEnabled->debug->log->else->if->debug->isLogEnabled->debug->minBlock->getId->maxBlock->getId->log->if->loopEndPos->interval->allocator->getLastLirInstructionId->nextUsageExact->if->debug->isLogEnabled->debug->log->if->loopBlock->allocator->blockForId->if->debug->isLogEnabled->debug->loopBlock->getId->maxBlock->getId->loopBlock->getId->log->maxSpillPos->allocator->getLastLirInstructionId->findOptimalSplitPos->if->if->debug->isLogEnabled->debug->log->else->if->debug->isLogEnabled->debug->log->if->findOptimalSplitPos->if->debug->isLogEnabled->debug->log->return
LinearScanWalker#splitBeforeUsage(Interval, int, int)::: linear scan walker split before usage:::debug->allocator->getDebug->try->indent->debug->logAndIndent->optimalSplitPos->findOptimalSplitPos->if->interval->to->interval->nextUsage->if->debug->isLogEnabled->debug->log->return->moveNecessary->allocator->isBlockBegin->interval->hasHoleBetween->if->allocator->isBlockBegin->if->debug->isLogEnabled->debug->log->splitPart->interval->split->splitPart->setInsertMoveWhenActivated->unhandledLists->addToListSortedByStartAndUsePositions->if->debug->isLogEnabled->debug->interval->logString->log->debug->splitPart->logString->log->catch->finally
LinearScanWalker#splitForSpilling(Interval)::: linear scan walker split for spilling:::debug->allocator->getDebug->maxSplitPos->previousUsage->interval->previousUsage->if->interval->previousUsage->minSplitPos->Math->interval->from->max->try->indent->debug->logAndIndent->if->interval->from->try->indent2->debug->interval->usePosList->size->logAndIndent->allocator->assignSpillSlot->handleSpillSlot->changeSpillState->parent->while->parent->isSplitChild->parent->parent->from->getSplitChildBeforeOpId->if->parent->location->isRegister->if->parent->firstUsage->if->debug->isLogEnabled->debug->log->allocator->assignSpillSlot->handleSpillSlot->else->catch->finally->else->optimalSplitPos->findOptimalSplitPos->if->allocator->isBlockBegin->try->indent2->debug->logAndIndent->spilledPart->interval->split->allocator->assignSpillSlot->handleSpillSlot->changeSpillState->if->allocator->isBlockBegin->if->debug->isLogEnabled->debug->log->insertMove->spilledPart->makeCurrentSplitChild->if->debug->isLogEnabled->debug->interval->logString->log->debug->spilledPart->logString->log->catch->finally->catch->finally
LinearScanWalker#changeSpillState(Interval, int)::: linear scan walker change spill state:::switch->interval->spillState->defLoopDepth->allocator->interval->spillDefinitionPos->blockForId->getLoopDepth->spillLoopDepth->allocator->blockForId->getLoopDepth->if->if->allocator->getOptions->getValue->interval->setSpillState->else->interval->setSpillState->else->interval->setSpillState->break->defLoopDepth->allocator->interval->spillDefinitionPos->blockForId->getLoopDepth->spillLoopDepth->allocator->blockForId->getLoopDepth->if->if->allocator->getOptions->getValue->interval->setSpillState->else->interval->setSpillState->break->break->throw->GraalError->shouldNotReachHere
LinearScanWalker#handleSpillSlot(Interval):::This is called for every interval that is assigned to a stack slot.:::
LinearScanWalker#splitStackInterval(Interval)::: linear scan walker split stack interval:::minSplitPos->maxSplitPos->Math->interval->firstUsage->interval->to->min->splitBeforeUsage
LinearScanWalker#splitWhenPartialRegisterAvailable(Interval, int)::: linear scan walker split when partial register available:::minSplitPos->Math->interval->previousUsage->interval->from->max->splitBeforeUsage
LinearScanWalker#splitAndSpillInterval(Interval)::: linear scan walker split and spill interval:::currentPos->if->splitBeforeUsage->else->minSplitPos->maxSplitPos->Math->interval->nextUsage->interval->to->min->splitBeforeUsage->splitForSpilling
LinearScanWalker#allocFreeRegister(Interval)::: linear scan walker alloc free register:::debug->allocator->getDebug->try->indent->debug->logAndIndent->initUseLists->freeExcludeActiveFixed->freeExcludeActiveAny->freeCollectInactiveFixed->freeCollectInactiveAny->if->debug->isLogEnabled->try->indent2->debug->logAndIndent->foreach->i->debug->log->catch->finally->hint->locationHint->interval->locationHint->if->locationHint->location->locationHint->location->isRegister->locationHint->location->asRegister->if->debug->isLogEnabled->debug->log->regNeededUntil->interval->from->intervalTo->interval->to->needSplit->splitPos->reg->minFullReg->maxPartialReg->foreach->number->if->if->availableReg->equals->minFullReg->equals->else->if->if->availableReg->equals->maxPartialReg->equals->if->else->if->else->return->interval->reg->interval->kind->asValue->assignLocation->if->debug->isLogEnabled->debug->log->if->splitWhenPartialRegisterAvailable->return->catch->finally
LinearScanWalker#splitAndSpillIntersectingIntervals(Register)::: linear scan walker split and spill intersecting intervals:::for->i->size
LinearScanWalker#allocLockedRegister(Interval)::: linear scan walker alloc locked register:::debug->allocator->getDebug->try->indent->debug->logAndIndent->firstUsage->interval->firstUsage->firstShouldHaveUsage->interval->firstUsage->regNeededUntil->Math->interval->from->min->intervalTo->interval->to->reg->ignore->for->registerPriority->needSplit->splitPos->if->debug->isLogEnabled->debug->log->interval->reg->interval->kind->asValue->assignLocation->if->splitWhenPartialRegisterAvailable->splitAndSpillIntersectingIntervals->return->catch->finally
LinearScanWalker#generateOutOfRegErrorMsg(Interval, int, Register[])::: linear scan walker generate out of reg error msg:::return->interval->from->Arrays->toString
LinearScanWalker#printRegisterState()::: linear scan walker print register state:::debug->allocator->getDebug->try->indent2->debug->logAndIndent->foreach->i->try->indent3->debug->logAndIndent->for->j->size->catch->finally->catch->finally
LinearScanWalker#noAllocationPossible(Interval)::: linear scan walker no allocation possible:::if->allocator->callKillsRegisters->pos->interval->from->if->isOdd->if->allocator->maxOpId->allocator->hasCall->interval->to->debug->allocator->getDebug->if->debug->isLogEnabled->debug->log->return->return
LinearScanWalker#initVarsForAlloc(Interval)::: linear scan walker init vars for alloc:::allocatableRegisters->allocator->getRegisterAllocationConfig->interval->kind->getPlatformKind->getAllocatableRegisters
LinearScanWalker#isMove(LIRInstruction, Interval, Interval)::: linear scan walker is move:::if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->isVariable->move->getResult->isVariable->return->move->getInput->move->getInput->equals->move->getResult->move->getResult->equals->return
LinearScanWalker#combineSpilledIntervals(Interval)::: linear scan walker combine spilled intervals:::if->interval->isSplitChild->return->registerHint->interval->locationHint->if->return->if->interval->spillState->registerHint->spillState->return->beginPos->interval->from->endPos->interval->to->if->allocator->maxOpId->isOdd->isOdd->return->if->allocator->instructionForId->isMove->allocator->instructionForId->isMove->return->beginHint->registerHint->getSplitChildAtOpId->endHint->registerHint->getSplitChildAtOpId->if->beginHint->to->endHint->from->return->if->beginHint->location->isRegister->return->interval->registerHint->spillSlot->setSpillSlot->interval->removeFirstUsePos->endHint->removeFirstUsePos
LinearScanWalker#activateCurrent(Interval)::: linear scan walker activate current:::result->debug->allocator->getDebug->try->indent->debug->interval->splitParent->logAndIndent->operand->if->interval->location->interval->location->isStackSlotValue->if->debug->isLogEnabled->debug->log->splitStackInterval->else->if->interval->location->if->debug->isLogEnabled->debug->log->combineSpilledIntervals->initVarsForAlloc->if->noAllocationPossible->allocFreeRegister->allocLockedRegister->if->interval->location->isRegister->if->interval->insertMoveWhenActivated->if->debug->isLogEnabled->debug->interval->currentSplitChild->log->interval->from->interval->currentSplitChild->insertMove->interval->makeCurrentSplitChild->catch->finally->return
LinearScanWalker#finishAllocation()::: linear scan walker finish allocation:::moveResolver->resolveAndAppendMoves
MoveResolver#setValueBlocked(Value, int)::: move resolver set value blocked:::if->isRegister->asRegister->else->throw->GraalError->shouldNotReachHere
MoveResolver#getMappingFrom(int)::: move resolver get mapping from:::return->mappingFrom->get
MoveResolver#mappingFromSize()::: move resolver mapping from size:::return->mappingFrom->size
MoveResolver#valueBlocked(Value)::: move resolver value blocked:::if->isRegister->return->asRegister->throw->GraalError->shouldNotReachHere
MoveResolver#setMultipleReadsAllowed()::: move resolver set multiple reads allowed:::
MoveResolver#areMultipleReadsAllowed()::: move resolver are multiple reads allowed:::return
MoveResolver#hasMappings()::: move resolver has mappings:::return->mappingFrom->size
MoveResolver#getAllocator()::: move resolver get allocator:::return
MoveResolver#checkEmpty()::: move resolver check empty:::for->i->getAllocator->getRegisters->size->checkMultipleReads->return
MoveResolver#checkMultipleReads()::: move resolver check multiple reads:::
MoveResolver#verifyBeforeResolve()::: move resolver verify before resolve:::i->j->if->areMultipleReadsAllowed->for->mappingFrom->size->for->mappingTo->size->usedRegs->EconomicSet->create->if->areMultipleReadsAllowed->for->mappingFrom->size->usedRegs->clear->for->mappingTo->size->verifyStackSlotMapping->return
MoveResolver#verifyStackSlotMapping()::: move resolver verify stack slot mapping:::usedRegs->EconomicSet->create->for->i->mappingFrom->size->for->i->mappingTo->size
MoveResolver#checkIntervalLocation(Interval, Interval, Constant)::: move resolver check interval location:::if->return->else->return->to->location->from->location->equals
MoveResolver#blockRegisters(Interval)::: move resolver block registers:::location->interval->location->if->mightBeBlocked->direction->setValueBlocked->allocator->getDebug->log
MoveResolver#unblockRegisters(Interval)::: move resolver unblock registers:::location->interval->location->if->mightBeBlocked->setValueBlocked->allocator->getDebug->log
MoveResolver#safeToProcessMove(Interval, Interval):::Checks if the Interval#location() location of to is not blocked or is only blocked by from.:::fromReg->from->location->location->to->location->if->mightBeBlocked->if->valueBlocked->valueBlocked->isMoveToSelf->return->return
MoveResolver#isMoveToSelf(Value, Value)::: move resolver is move to self:::if->to->equals->return->if->isRegister->isRegister->asRegister->asRegister->equals->return->return
MoveResolver#mightBeBlocked(Value)::: move resolver might be blocked:::return->isRegister
MoveResolver#createInsertionBuffer(ArrayList)::: move resolver create insertion buffer:::insertionBuffer->init
MoveResolver#appendInsertionBuffer()::: move resolver append insertion buffer:::if->insertionBuffer->initialized->insertionBuffer->finish
MoveResolver#insertMove(Interval, Interval)::: move resolver insert move:::move->fromInterval->location->toInterval->location->createMove->insertionBuffer->append->debug->allocator->getDebug->if->debug->isLogEnabled->debug->log->return
MoveResolver#createMove(AllocatableValue, AllocatableValue, AllocatableValue, AllocatableValue)::: move resolver create move:::return->getAllocator->getSpillMoveFactory->createMove
MoveResolver#insertMove(Constant, Interval)::: move resolver insert move:::toOpr->move->if->LIRValueUtil->toInterval->location->isStackSlotValue->getAllocator->getSpillMoveFactory->createStackLoad->else->getAllocator->getSpillMoveFactory->createLoad->insertionBuffer->append->debug->allocator->getDebug->if->debug->isLogEnabled->debug->log->return
MoveResolver#resolveMappings()::: move resolver resolve mappings:::debug->allocator->getDebug->try->indent->debug->logAndIndent->if->debug->isLogEnabled->printMapping->i->for->mappingFrom->size->busySpillSlots->while->mappingFrom->size->processedInterval->spillCandidate->for->mappingFrom->size->if->breakCycle->catch->finally
MoveResolver#breakCycle(int)::: move resolver break cycle:::fromInterval->mappingFrom->get->spillSlot->fromInterval->spillSlot->if->getAllocator->getFrameMapBuilder->fromInterval->kind->allocateSpillSlot->fromInterval->setSpillSlot->cycleBreakingSlotsAllocated->allocator->getDebug->increment->spillInterval
MoveResolver#spillInterval(int, Interval, AllocatableValue)::: move resolver spill interval:::spillInterval->getAllocator->createDerivedInterval->spillInterval->fromInterval->kind->setKind->spillInterval->addRange->spillInterval->assignLocation->debug->allocator->getDebug->if->debug->isLogEnabled->debug->log->blockRegisters->move->insertMove->mappingFrom->set->unblockRegisters->move->setComment
MoveResolver#printMapping()::: move resolver print mapping:::debug->allocator->getDebug->try->indent->debug->logAndIndent->for->i->mappingFrom->size->catch->finally
MoveResolver#setInsertPosition(ArrayList, int)::: move resolver set insert position:::createInsertionBuffer
MoveResolver#moveInsertPosition(ArrayList, int)::: move resolver move insert position:::if->insertionBuffer->lirList->insertionBuffer->lirList->resolveMappings->if->insertionBuffer->lirList->appendInsertionBuffer->createInsertionBuffer
MoveResolver#addMapping(Interval, Interval)::: move resolver add mapping:::debug->allocator->getDebug->if->toInterval->location->isIllegal->toInterval->canMaterialize->if->debug->isLogEnabled->debug->log->return->if->fromInterval->location->isIllegal->fromInterval->canMaterialize->rematValue->fromInterval->getMaterializedValue->addMapping->return->if->debug->isLogEnabled->debug->log->mappingFrom->add->mappingFromOpr->add->mappingTo->add
MoveResolver#addMapping(Constant, Interval)::: move resolver add mapping:::debug->allocator->getDebug->if->debug->isLogEnabled->debug->log->mappingFrom->add->mappingFromOpr->add->mappingTo->add
MoveResolver#resolveAndAppendMoves()::: move resolver resolve and append moves:::if->hasMappings->resolveMappings->appendInsertionBuffer
OptimizingLinearScanWalker#handleSpillSlot(Interval)::: optimizing linear scan walker handle spill slot:::if->interval->canMaterialize->return->debug->allocator->getDebug->try->s1->debug->scope->debug->log->unhandledLists->addToListSortedByStartAndUsePositions->catch->finally
OptimizingLinearScanWalker#printRegisterBindingList(DebugContext, RegisterBindingLists, RegisterBinding)::: optimizing linear scan walker print register binding list:::for->interval->list->get->interval->isEndMarker
OptimizingLinearScanWalker#walk()::: optimizing linear scan walker walk:::try->s->allocator->getDebug->scope->foreach->allocator->sortedBlocks->optimizeBlock->catch->finally->super->walk
OptimizingLinearScanWalker#optimizeBlock(AbstractBlockBase)::: optimizing linear scan walker optimize block:::if->block->getPredecessorCount->nextBlock->allocator->getFirstLirInstructionId->debug->allocator->getDebug->try->s1->debug->scope->debug->log->catch->finally->try->indent0->debug->indent->walkTo->try->s1->debug->scope->changed->while->try->indent1->debug->logAndIndent->for->active->activeLists->get->active->isEndMarker->for->active->activeLists->get->active->isEndMarker->catch->finally->catch->finally->catch->finally
OptimizingLinearScanWalker#optimize(int, AbstractBlockBase, Interval, RegisterBinding)::: optimizing linear scan walker optimize:::if->currentInterval->isSplitChild->return->if->currentInterval->from->return->currentLocation->currentInterval->location->predecessorBlock->currentBlock->getPredecessors->predEndId->allocator->getLastLirInstructionId->predecessorInterval->currentInterval->getIntervalCoveringOpId->predecessorLocation->predecessorInterval->location->if->currentLocation->equals->return->if->isStackSlotValue->isRegister->return->debug->allocator->getDebug->try->indent->debug->logAndIndent->debug->log->splitPart->currentInterval->split->activeLists->remove->splitPart->makeCurrentSplitChild->if->debug->isLogEnabled->debug->currentInterval->logString->log->debug->splitPart->logString->log->if->allocator->getOptions->getValue->unhandledLists->addToListSortedByStartAndUsePositions->else->if->isRegister->asRegister->splitRegisterInterval->else->debug->log->splitPart->assignLocation->activeLists->addToListSortedByCurrentFromPositions->splitStackInterval->catch->finally->return
OptimizingLinearScanWalker#splitRegisterInterval(Interval, Register)::: optimizing linear scan walker split register interval:::initVarsForAlloc->initUseLists->spillExcludeActiveFixed->spillBlockInactiveFixed->spillCollectActiveAny->spillCollectInactiveAny->debug->allocator->getDebug->if->debug->isLogEnabled->try->indent2->debug->logAndIndent->foreach->i->try->indent3->debug->logAndIndent->for->j->size->catch->finally->catch->finally->needSplit->interval->to->splitPos->debug->log->interval->reg->interval->kind->asValue->assignLocation->if->splitWhenPartialRegisterAvailable->splitAndSpillIntersectingIntervals->activeLists->addToListSortedByCurrentFromPositions
Range#intersects(Range)::: range intersects:::return->intersectsAt
Range#isEndMarker()::: range is end marker:::return
Range#intersectsAt(Range)::: range intersects at:::r1->r2->do->if->if->if->r1->isEndMarker->return->else->return->else->if->if->if->r2->isEndMarker->return->else->return->else->if->if->r1->isEndMarker->return->else->if->if->r2->isEndMarker->return->else->return->while
Range#toString()::: range to string:::return
RegisterVerifier#intervalAt(Value)::: register verifier interval at:::return->allocator->intervalFor
RegisterVerifier#stateSize()::: register verifier state size:::return->allocator->maxRegisterNumber
RegisterVerifier#stateForBlock(AbstractBlockBase)::: register verifier state for block:::return->savedStates->get
RegisterVerifier#setStateForBlock(AbstractBlockBase, Interval[])::: register verifier set state for block:::savedStates->put
RegisterVerifier#addToWorkList(AbstractBlockBase)::: register verifier add to work list:::if->workList->contains->workList->add
RegisterVerifier#verify(AbstractBlockBase)::: register verifier verify:::debug->allocator->getDebug->try->s->debug->scope->inputState->stateSize->new->IntervalArr->setStateForBlock->addToWorkList->do->block->workList->get->workList->remove->processBlock->while->workList->isEmpty->catch->finally
RegisterVerifier#processBlock(AbstractBlockBase)::: register verifier process block:::debug->allocator->getDebug->try->indent->debug->block->getId->logAndIndent->inputState->stateForBlock->copy->try->indent2->debug->logAndIndent->printState->catch->finally->processOperations->try->indent2->debug->logAndIndent->printState->catch->finally->foreach->block->getSuccessors->processSuccessor->catch->finally
RegisterVerifier#printState(Interval[])::: register verifier print state:::debug->allocator->getDebug->for->i->stateSize
RegisterVerifier#processSuccessor(AbstractBlockBase, Interval[])::: register verifier process successor:::debug->allocator->getDebug->savedState->stateForBlock->if->savedStateCorrect->for->i->stateSize->if->debug->block->getId->log->else->debug->block->getId->log->addToWorkList->else->debug->block->getId->log->copy->setStateForBlock->addToWorkList
RegisterVerifier#copy(Interval[])::: register verifier copy:::return->inputState->clone
RegisterVerifier#statePut(DebugContext, Interval[], Value, Interval)::: register verifier state put:::if->isRegister->reg->asRegister->regNum->if->debug->log->else->if->debug->log
RegisterVerifier#checkState(AbstractBlockBase, LIRInstruction, Interval[], Value, Value, Interval)::: register verifier check state:::if->isRegister->if->asRegister->throw->asRegister->new->GraalError->return
RegisterVerifier#processOperations(AbstractBlockBase, Interval[])::: register verifier process operations:::ops->allocator->getLIR->getLIRforBlock->debug->allocator->getDebug->useConsumer->new->InstructionValueConsumer->defConsumer->if->LinearScan->isVariableOrRegister->allocator->isProcessed->interval->intervalAt->if->op->id->interval->op->id->getSplitChildAtOpId->interval->location->interval->splitParent->statePut->for->i->ops->size
