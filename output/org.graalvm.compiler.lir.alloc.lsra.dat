Interval.RegisterBindingLists#get(RegisterBinding):::Gets the list for a specified binding.:::switch->return->return->return->throw->GraalError->shouldNotReachHere
Interval.RegisterBindingLists#set(RegisterBinding, Interval):::Sets the list for a specified binding.:::switch->break->break->break
Interval.RegisterBindingLists#addToListSortedByCurrentFromPositions(RegisterBinding, Interval):::Adds an interval to a list sorted by Interval#currentFrom() current from positions.:::list->get->prev->cur->while->cur->currentFrom->interval->currentFrom->result->if->else->set
Interval.RegisterBindingLists#addToListSortedByStartAndUsePositions(RegisterBinding, Interval):::Adds an interval to a list sorted by Interval#from() start positions and Interval#firstUsage(RegisterPriority) first usage positions.:::list->get->prev->cur->while->cur->from->interval->from->cur->from->interval->from->cur->firstUsage->interval->firstUsage->if->else->set
Interval.RegisterBindingLists#remove(RegisterBinding, Interval):::Removes an interval from a list.:::list->get->prev->cur->while->if->set->else
Interval.UsePosList#splitAt(int):::Splits this list around a given position:::i->size->len->while->usePos->listSplitIndex->childList->IntList->copy->childList->setSize->child->new->UsePosList->return
Interval.UsePosList#usePos(int):::Gets the use position at a specified index in this list.:::return->list->get
Interval.UsePosList#registerPriority(int):::Gets the register priority for the use position at a specified index in this list.:::return->list->get
Interval#isEndMarker():::Returns true is this is the sentinel interval that denotes the end of an interval list.:::return
Interval#location():::Gets the RegisterValue register or StackSlot spill slot assigned to this interval.:::return
Interval#splitParent():::Gets the split parent for this interval.:::return
Interval#spillSlot():::Gets the canonical spill slot for this interval.:::return->splitParent
Interval#addMaterializationValue(Constant):::Sets the value which is used for re-materialization.:::if->else
Interval#canMaterialize():::Returns true if this interval can be re-materialized when spilled:::return->getMaterializedValue
Interval#getMaterializedValue():::Returns a value which can be moved to a register instead of a restore-move from stack.:::return->splitParent
Interval#split(int, LinearScan):::Splits this interval at a specified position and returns the remainder as a new child interval of this interval's #splitParent() parent interval:::result->newSplitChild->prev->cur->while->cur->isEndMarker->if->new->Range->else->usePosList->splitAt->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->for->i->usePosList->size->for->i->size->return
Interval#splitFromStart(int, LinearScan):::Splits this interval at a specified position and returns the head as a new interval (this interval is the tail):::result->newSplitChild->result->addRange->if->else->return
Interval#usePosList():::Gets the use position information for this interval.:::return
Interval#logString(LinearScan):::Gets a single line string for logging the details of this interval to a log stream.:::buf->new->StringBuilder->buf->append->append->append->append->if->isRegister->if->buf->append->append->append->buf->append->append->hint->locationHint->if->buf->append->append->buf->append->cur->while->cur->isEndMarker->if->buf->append->buf->append->buf->append->prev->for->i->usePosList->size->buf->append->spillState->append->append->if->canMaterialize->buf->append->getMaterializedValue->toString->append->append->return->buf->toString
IntervalWalker#activateCurrent(Interval):::Processes the currentInterval interval in an attempt to allocate a physical register to it and thus allow it to be moved to a list of #activeLists active intervals.:::return
IntervalWalker#walkTo(int):::Walk up to toOpId.:::for->currentInterval->nextInterval->nextInterval->if->allocator->maxOpId->updateUnhandledStackIntervals->walkTo->walkTo
LinearScan#operandNumber(Value):::Converts an operand (variable or register) to an index in a flat address space covering all the Variable variables and RegisterValue registers being processed by this allocator.:::if->isRegister->number->asRegister->return->return
LinearScan#operandSize():::Gets the number of operands:::return
LinearScan#maxRegisterNumber():::Gets the highest operand number for a register operand:::return
LinearScan#attributes(Register):::Gets an object describing the attributes of a given register according to this register configuration.:::return
LinearScan#intervals():::Map from #operandNumber(Value) operand numbers to intervals.:::return
LinearScan#createInterval(AllocatableValue):::Creates a new interval.:::operandNumber->operandNumber->interval->new->Interval->return
LinearScan#createDerivedInterval(Interval):::Creates an interval as a result of splitting or spilling another interval.:::if->if->Arrays->copyOf->variable->source->kind->new->Variable->interval->createInterval->return
LinearScan#liveSetSize():::Gets the size of the BlockData#liveIn and BlockData#liveOut sets for a basic block:::return->operandSize
LinearScan#maxOpId():::Gets the highest instruction id allocated by this object.:::return
LinearScan#instructionForId(int):::Retrieves the LIRInstruction based on its LIRInstruction#id id.:::instr->opIdToIndex->return
LinearScan#blockForId(int):::Gets the block containing a given instruction.:::return->opIdToIndex
LinearScan#hasCall(int):::Determines if an LIRInstruction destroys all caller saved registers.:::return->instructionForId->destroysCallerSavedRegisters
LinearScanAssignLocationsPhase#colorLirOperand(LIRInstruction, Variable, OperandMode):::Assigns the allocated location for an LIR instruction operand back into the instruction.:::opId->op->id->interval->allocator->intervalFor->if->if->block->allocator->blockForId->if->block->getSuccessorCount->allocator->getLastLirInstructionId->instr->allocator->getLIR->getLIRforBlock->allocator->getLIR->getLIRforBlock->size->get->if->if->allocator->getBlockData->allocator->operandNumber->get->allocator->splitChildAtOpId->if->interval->location->isIllegal->interval->canMaterialize->return->interval->kind->interval->getMaterializedValue->new->ConstantValue->return->interval->location
LinearScanAssignLocationsPhase#assignLocations(LIRInstruction):::Assigns the operand of an LIRInstruction.:::if->MoveOp->isMoveOp->result->MoveOp->asMoveOp->getResult->if->isVariable->allocator->op->id->isMaterialized->return->op->forEachInput->op->forEachAlive->op->forEachTemp->op->forEachOutput->op->forEachState->if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->move->getResult->equals->return->return
LinearScanLifetimeAnalysisPhase#numberInstructions():::Numbers all instructions in all blocks:::allocator->initIntervals->setVariableConsumer->if->isVariable->allocator->asVariable->getOrCreateInterval->numInstructions->foreach->allocator->sortedBlocks->allocator->getLIR->getLIRforBlock->size->allocator->initOpIdMaps->opId->index->foreach->allocator->sortedBlocks->allocator->initBlockData->instructions->allocator->getLIR->getLIRforBlock->numInst->instructions->size->for->j
LinearScanLifetimeAnalysisPhase#computeLocalLiveSets():::Computes local live sets (i.e:::liveSize->allocator->liveSetSize->allocator->operandSize->allocator->numLoops->new->BitMap2D->try->liveGenScratch->new->BitSet->liveKillScratch->new->BitSet->foreach->allocator->sortedBlocks->try->indent->debug->logAndIndent->liveGenScratch->clear->liveKillScratch->clear->instructions->allocator->getLIR->getLIRforBlock->numInst->instructions->size->useConsumer->if->isVariable->operandNum->getOperandNumber->if->liveKillScratch->get->liveGenScratch->set->if->debug->isLogEnabled->debug->log->if->block->getLoop->intervalInLoop->block->getLoop->getIndex->setBit->if->verifyInput->stateConsumer->if->LinearScan->isVariableOrRegister->operandNum->getOperandNumber->if->liveKillScratch->get->liveGenScratch->set->if->debug->isLogEnabled->debug->log->defConsumer->if->isVariable->varNum->getOperandNumber->liveKillScratch->set->if->debug->isLogEnabled->debug->log->if->block->getLoop->intervalInLoop->block->getLoop->getIndex->setBit->if->verifyTemp->for->j->blockSets->allocator->getBlockData->trimClone->trimClone->new->BitSet->new->BitSet->if->debug->isLogEnabled->debug->block->getId->log->debug->block->getId->log->catch->finally->catch->throw->new->PermanentBailoutException->finally
LinearScanLifetimeAnalysisPhase#computeGlobalLiveSets():::Performs a backward dataflow analysis to compute global live sets (i.e:::try->indent->debug->logAndIndent->numBlocks->allocator->blockCount->changeOccurred->changeOccurredInBlock->iterationCount->scratch->allocator->liveSetSize->new->BitSet->do->try->indent2->debug->logAndIndent->for->i->if->throw->new->PermanentBailoutException->catch->finally->while->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->verifyLiveness->startBlock->allocator->getLIR->getControlFlowGraph->getStartBlock->if->allocator->getBlockData->cardinality->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->reportFailure->throw->allocator->getBlockData->new->GraalError->catch->finally
LinearScanLifetimeAnalysisPhase#handleMethodArguments(LIRInstruction):::Optimizes moves related to incoming stack based arguments:::if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->optimizeMethodArgument->slot->move->getInput->asStackSlot->if->Assertions->allocator->getOptions->detailedAssertionsEnabled->if->debug->isLogEnabled->debug->move->getResult->log->interval->allocator->move->getResult->intervalFor->interval->setSpillSlot->interval->assignLocation
LinearScanLifetimeAnalysisPhase#changeSpillDefinitionPos(LIRInstruction, AllocatableValue, Interval, int):::Eliminates moves from register to stack if the stack slot is known to be correct.:::switch->interval->spillState->interval->setSpillDefinitionPos->interval->setSpillState->break->if->interval->spillDefinitionPos->interval->setSpillState->else->break->break->throw->GraalError->shouldNotReachHere
LinearScanLifetimeAnalysisPhase#registerPriorityOfOutputOperand(LIRInstruction):::Determines the register priority for an instruction's output/result operand.:::if->ValueMoveOp->isValueMoveOp->move->ValueMoveOp->asValueMoveOp->if->move->getInput->optimizeMethodArgument->return->return
LinearScanLifetimeAnalysisPhase#registerPriorityOfInputOperand(EnumSet):::Determines the priority which with an instruction's input operand will be allocated a register.:::if->flags->contains->return->return
LinearScanLifetimeAnalysisPhase#getMaterializedValue(LIRInstruction, Value, Interval):::Returns a value for a interval definition, which can be used for re-materialization.:::if->LoadConstantOp->isLoadConstantOp->move->LoadConstantOp->asLoadConstantOp->if->allocator->neverSpillConstants->usePosList->interval->usePosList->numUsePos->usePosList->size->for->useIdx->return->move->getConstant->return
LinearScanResolveDataFlowPhase#resolveDataFlow():::Inserts necessary moves (spilling or reloading) at edges between blocks for intervals that have been split.:::try->indent->allocator->getDebug->logAndIndent->moveResolver->allocator->createMoveResolver->blockCompleted->allocator->blockCount->new->BitSet->optimizeEmptyBlocks->resolveDataFlow0->catch->finally
LinearScanWalker#handleSpillSlot(Interval):::This is called for every interval that is assigned to a stack slot.:::
