org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase_OptionDescriptors#get(String)->OptionDescriptor::: linear scan eliminate spill move phase_ option descriptors get
org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase_OptionDescriptors#iterator()->Iterator::: linear scan eliminate spill move phase_ option descriptors iterator
org.graalvm.compiler.lir.alloc.lsra.LinearScan_OptionDescriptors#get(String)->OptionDescriptor::: linear scan_ option descriptors get
org.graalvm.compiler.lir.alloc.lsra.LinearScan_OptionDescriptors#iterator()->Iterator::: linear scan_ option descriptors iterator
org.graalvm.compiler.lir.alloc.lsra.OptimizingLinearScanWalker_OptionDescriptors#get(String)->OptionDescriptor::: optimizing linear scan walker_ option descriptors get
org.graalvm.compiler.lir.alloc.lsra.OptimizingLinearScanWalker_OptionDescriptors#iterator()->Iterator::: optimizing linear scan walker_ option descriptors iterator
org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBindingLists#get(RegisterBinding)->Interval:::Gets the list for a specified binding.
org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBindingLists#set(RegisterBinding, Interval)->void:::Sets the list for a specified binding.
org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBindingLists#addToListSortedByCurrentFromPositions(RegisterBinding, Interval)->void:::Adds an interval to a list sorted by Interval#currentFrom() current from positions.
org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBindingLists#addToListSortedByStartAndUsePositions(RegisterBinding, Interval)->void:::Adds an interval to a list sorted by Interval#from() start positions and Interval#firstUsage(RegisterPriority) first usage positions.
org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBindingLists#remove(RegisterBinding, Interval)->void:::Removes an interval from a list.
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#splitAt(int)->UsePosList:::Splits this list around a given position
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#usePos(int)->int:::Gets the use position at a specified index in this list.
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#registerPriority(int)->RegisterPriority:::Gets the register priority for the use position at a specified index in this list.
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#add(int, RegisterPriority)->void::: use pos list add
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#size()->int::: use pos list size
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#removeLowestUsePos()->void::: use pos list remove lowest use pos
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#setRegisterPriority(int, RegisterPriority)->void::: use pos list set register priority
org.graalvm.compiler.lir.alloc.lsra.Interval.UsePosList#toString()->String::: use pos list to string
org.graalvm.compiler.lir.alloc.lsra.Interval#assignLocation(AllocatableValue)->void::: interval assign location
org.graalvm.compiler.lir.alloc.lsra.Interval#isEndMarker()->boolean:::Returns true is this is the sentinel interval that denotes the end of an interval list.
org.graalvm.compiler.lir.alloc.lsra.Interval#location()->AllocatableValue:::Gets the RegisterValue register or StackSlot spill slot assigned to this interval.
org.graalvm.compiler.lir.alloc.lsra.Interval#kind()->ValueKind::: interval kind
org.graalvm.compiler.lir.alloc.lsra.Interval#setKind(ValueKind)->void::: interval set kind
org.graalvm.compiler.lir.alloc.lsra.Interval#first()->Range::: interval first
org.graalvm.compiler.lir.alloc.lsra.Interval#from()->int::: interval from
org.graalvm.compiler.lir.alloc.lsra.Interval#to()->int::: interval to
org.graalvm.compiler.lir.alloc.lsra.Interval#numUsePositions()->int::: interval num use positions
org.graalvm.compiler.lir.alloc.lsra.Interval#setLocationHint(Interval)->void::: interval set location hint
org.graalvm.compiler.lir.alloc.lsra.Interval#isSplitParent()->boolean::: interval is split parent
org.graalvm.compiler.lir.alloc.lsra.Interval#isSplitChild()->boolean::: interval is split child
org.graalvm.compiler.lir.alloc.lsra.Interval#splitParent()->Interval:::Gets the split parent for this interval.
org.graalvm.compiler.lir.alloc.lsra.Interval#spillSlot()->AllocatableValue:::Gets the canonical spill slot for this interval.
org.graalvm.compiler.lir.alloc.lsra.Interval#setSpillSlot(AllocatableValue)->void::: interval set spill slot
org.graalvm.compiler.lir.alloc.lsra.Interval#currentSplitChild()->Interval::: interval current split child
org.graalvm.compiler.lir.alloc.lsra.Interval#makeCurrentSplitChild()->void::: interval make current split child
org.graalvm.compiler.lir.alloc.lsra.Interval#insertMoveWhenActivated()->boolean::: interval insert move when activated
org.graalvm.compiler.lir.alloc.lsra.Interval#setInsertMoveWhenActivated(boolean)->void::: interval set insert move when activated
org.graalvm.compiler.lir.alloc.lsra.Interval#spillState()->SpillState::: interval spill state
org.graalvm.compiler.lir.alloc.lsra.Interval#spillDefinitionPos()->int::: interval spill definition pos
org.graalvm.compiler.lir.alloc.lsra.Interval#setSpillState(SpillState)->void::: interval set spill state
org.graalvm.compiler.lir.alloc.lsra.Interval#setSpillDefinitionPos(int)->void::: interval set spill definition pos
org.graalvm.compiler.lir.alloc.lsra.Interval#alwaysInMemory()->boolean::: interval always in memory
org.graalvm.compiler.lir.alloc.lsra.Interval#removeFirstUsePos()->void::: interval remove first use pos
org.graalvm.compiler.lir.alloc.lsra.Interval#intersects(Interval)->boolean::: interval intersects
org.graalvm.compiler.lir.alloc.lsra.Interval#intersectsAt(Interval)->int::: interval intersects at
org.graalvm.compiler.lir.alloc.lsra.Interval#rewindRange()->void::: interval rewind range
org.graalvm.compiler.lir.alloc.lsra.Interval#nextRange()->void::: interval next range
org.graalvm.compiler.lir.alloc.lsra.Interval#currentFrom()->int::: interval current from
org.graalvm.compiler.lir.alloc.lsra.Interval#currentTo()->int::: interval current to
org.graalvm.compiler.lir.alloc.lsra.Interval#currentAtEnd()->boolean::: interval current at end
org.graalvm.compiler.lir.alloc.lsra.Interval#currentIntersects(Interval)->boolean::: interval current intersects
org.graalvm.compiler.lir.alloc.lsra.Interval#currentIntersectsAt(Interval)->int::: interval current intersects at
org.graalvm.compiler.lir.alloc.lsra.Interval#addMaterializationValue(Constant)->void:::Sets the value which is used for re-materialization.
org.graalvm.compiler.lir.alloc.lsra.Interval#canMaterialize()->boolean:::Returns true if this interval can be re-materialized when spilled
org.graalvm.compiler.lir.alloc.lsra.Interval#getMaterializedValue()->Constant:::Returns a value which can be moved to a register instead of a restore-move from stack.
org.graalvm.compiler.lir.alloc.lsra.Interval#calcTo()->int::: interval calc to
org.graalvm.compiler.lir.alloc.lsra.Interval#checkSplitChildren()->boolean::: interval check split children
org.graalvm.compiler.lir.alloc.lsra.Interval#locationHint(boolean)->Interval::: interval location hint
org.graalvm.compiler.lir.alloc.lsra.Interval#getSplitChildAtOpId(int, LIRInstruction.OperandMode, LinearScan)->Interval::: interval get split child at op id
org.graalvm.compiler.lir.alloc.lsra.Interval#getIntervalCoveringOpId(int)->Interval::: interval get interval covering op id
org.graalvm.compiler.lir.alloc.lsra.Interval#getSplitChildBeforeOpId(int)->Interval::: interval get split child before op id
org.graalvm.compiler.lir.alloc.lsra.Interval#splitChildCovers(int, LIRInstruction.OperandMode)->boolean::: interval split child covers
org.graalvm.compiler.lir.alloc.lsra.Interval#firstUsage(RegisterPriority)->int::: interval first usage
org.graalvm.compiler.lir.alloc.lsra.Interval#nextUsage(RegisterPriority, int)->int::: interval next usage
org.graalvm.compiler.lir.alloc.lsra.Interval#nextUsageExact(RegisterPriority, int)->int::: interval next usage exact
org.graalvm.compiler.lir.alloc.lsra.Interval#previousUsage(RegisterPriority, int)->int::: interval previous usage
org.graalvm.compiler.lir.alloc.lsra.Interval#addUsePos(int, RegisterPriority, boolean)->void::: interval add use pos
org.graalvm.compiler.lir.alloc.lsra.Interval#addRange(int, int)->void::: interval add range
org.graalvm.compiler.lir.alloc.lsra.Interval#newSplitChild(LinearScan)->Interval::: interval new split child
org.graalvm.compiler.lir.alloc.lsra.Interval#split(int, LinearScan)->Interval:::Splits this interval at a specified position and returns the remainder as a new child interval of this interval's #splitParent() parent interval
org.graalvm.compiler.lir.alloc.lsra.Interval#splitFromStart(int, LinearScan)->Interval:::Splits this interval at a specified position and returns the head as a new interval (this interval is the tail)
org.graalvm.compiler.lir.alloc.lsra.Interval#covers(int, LIRInstruction.OperandMode)->boolean::: interval covers
org.graalvm.compiler.lir.alloc.lsra.Interval#hasHoleBetween(int, int)->boolean::: interval has hole between
org.graalvm.compiler.lir.alloc.lsra.Interval#toString()->String::: interval to string
org.graalvm.compiler.lir.alloc.lsra.Interval#usePosList()->UsePosList:::Gets the use position information for this interval.
org.graalvm.compiler.lir.alloc.lsra.Interval#logString(LinearScan)->String:::Gets a single line string for logging the details of this interval to a log stream.
org.graalvm.compiler.lir.alloc.lsra.Interval#getSplitChildren()->List::: interval get split children
org.graalvm.compiler.lir.alloc.lsra.IntervalWalker#activateCurrent(Interval)->boolean:::Processes the currentInterval interval in an attempt to allocate a physical register to it and thus allow it to be moved to a list of #activeLists active intervals.
org.graalvm.compiler.lir.alloc.lsra.IntervalWalker#walkBefore(int)->void::: interval walker walk before
org.graalvm.compiler.lir.alloc.lsra.IntervalWalker#walk()->void::: interval walker walk
org.graalvm.compiler.lir.alloc.lsra.IntervalWalker#removeFromList(Interval)->void::: interval walker remove from list
org.graalvm.compiler.lir.alloc.lsra.IntervalWalker#walkTo(int)->void:::Walk up to toOpId.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getLIRGenerationResult()->LIRGenerationResult::: linear scan get generation result
org.graalvm.compiler.lir.alloc.lsra.LinearScan#intervalEndMarker()->Interval::: linear scan interval end marker
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getOptions()->OptionValues::: linear scan get options
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getDebug()->DebugContext::: linear scan get debug
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getFirstLirInstructionId(AbstractBlockBase)->int::: linear scan get first lir instruction id
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getLastLirInstructionId(AbstractBlockBase)->int::: linear scan get last lir instruction id
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getSpillMoveFactory()->MoveFactory::: linear scan get spill move factory
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createMoveResolver()->MoveResolver::: linear scan create move resolver
org.graalvm.compiler.lir.alloc.lsra.LinearScan#isVariableOrRegister(Value)->boolean::: linear scan is variable or register
org.graalvm.compiler.lir.alloc.lsra.LinearScan#operandNumber(Value)->int:::Converts an operand (variable or register) to an index in a flat address space covering all the Variable variables and RegisterValue registers being processed by this allocator.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#operandSize()->int:::Gets the number of operands
org.graalvm.compiler.lir.alloc.lsra.LinearScan#maxRegisterNumber()->int:::Gets the highest operand number for a register operand
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getBlockData(AbstractBlockBase)->BlockData::: linear scan get block data
org.graalvm.compiler.lir.alloc.lsra.LinearScan#initBlockData(AbstractBlockBase)->void::: linear scan init block data
org.graalvm.compiler.lir.alloc.lsra.LinearScan#attributes(Register)->RegisterAttributes:::Gets an object describing the attributes of a given register according to this register configuration.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#assignSpillSlot(Interval)->void::: linear scan assign spill slot
org.graalvm.compiler.lir.alloc.lsra.LinearScan#intervals()->Interval[]:::Map from #operandNumber(Value) operand numbers to intervals.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#initIntervals()->void::: linear scan init intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createInterval(AllocatableValue)->Interval:::Creates a new interval.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createDerivedInterval(Interval)->Interval:::Creates an interval as a result of splitting or spilling another interval.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#blockCount()->int::: linear scan block count
org.graalvm.compiler.lir.alloc.lsra.LinearScan#blockAt(int)->AbstractBlockBase::: linear scan block at
org.graalvm.compiler.lir.alloc.lsra.LinearScan#liveSetSize()->int:::Gets the size of the BlockData#liveIn and BlockData#liveOut sets for a basic block
org.graalvm.compiler.lir.alloc.lsra.LinearScan#numLoops()->int::: linear scan num loops
org.graalvm.compiler.lir.alloc.lsra.LinearScan#intervalFor(int)->Interval::: linear scan interval for
org.graalvm.compiler.lir.alloc.lsra.LinearScan#intervalFor(Value)->Interval::: linear scan interval for
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getOrCreateInterval(AllocatableValue)->Interval::: linear scan get or create interval
org.graalvm.compiler.lir.alloc.lsra.LinearScan#initOpIdMaps(int)->void::: linear scan init op id maps
org.graalvm.compiler.lir.alloc.lsra.LinearScan#putOpIdMaps(int, LIRInstruction, AbstractBlockBase)->void::: linear scan put op id maps
org.graalvm.compiler.lir.alloc.lsra.LinearScan#maxOpId()->int:::Gets the highest instruction id allocated by this object.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#instructionForId(int)->LIRInstruction:::Retrieves the LIRInstruction based on its LIRInstruction#id id.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#blockForId(int)->AbstractBlockBase:::Gets the block containing a given instruction.
org.graalvm.compiler.lir.alloc.lsra.LinearScan#isBlockBegin(int)->boolean::: linear scan is block begin
org.graalvm.compiler.lir.alloc.lsra.LinearScan#coversBlockBegin(int, int)->boolean::: linear scan covers block begin
org.graalvm.compiler.lir.alloc.lsra.LinearScan#hasCall(int)->boolean:::Determines if an LIRInstruction destroys all caller saved registers.
org.graalvm.compiler.lir.alloc.lsra.LinearScan.IntervalPredicate#apply(Interval)->boolean::: interval predicate apply
org.graalvm.compiler.lir.alloc.lsra.LinearScan#isProcessed(Value)->boolean::: linear scan is processed
org.graalvm.compiler.lir.alloc.lsra.LinearScan#addToList(Interval, Interval, Interval)->Interval::: linear scan add to list
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createUnhandledLists(IntervalPredicate, IntervalPredicate)->Pair::: linear scan create unhandled lists
org.graalvm.compiler.lir.alloc.lsra.LinearScan#sortIntervalsBeforeAllocation()->void::: linear scan sort intervals before allocation
org.graalvm.compiler.lir.alloc.lsra.LinearScan#sortIntervalsAfterAllocation()->void::: linear scan sort intervals after allocation
org.graalvm.compiler.lir.alloc.lsra.LinearScan#splitChildAtOpId(Interval, int, LIRInstruction.OperandMode)->Interval::: linear scan split child at op id
org.graalvm.compiler.lir.alloc.lsra.LinearScan#canonicalSpillOpr(Interval)->AllocatableValue::: linear scan canonical spill opr
org.graalvm.compiler.lir.alloc.lsra.LinearScan#isMaterialized(AllocatableValue, int, OperandMode)->boolean::: linear scan is materialized
org.graalvm.compiler.lir.alloc.lsra.LinearScan#isCallerSave(Value)->boolean::: linear scan is caller save
org.graalvm.compiler.lir.alloc.lsra.LinearScan#allocate(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan allocate
org.graalvm.compiler.lir.alloc.lsra.LinearScan#beforeSpillMoveElimination()->void::: linear scan before spill move elimination
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createLifetimeAnalysisPhase()->LinearScanLifetimeAnalysisPhase::: linear scan create lifetime analysis phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createRegisterAllocationPhase()->LinearScanRegisterAllocationPhase::: linear scan create register allocation phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createOptimizeSpillPositionPhase()->LinearScanOptimizeSpillPositionPhase::: linear scan create optimize spill position phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createResolveDataFlowPhase()->LinearScanResolveDataFlowPhase::: linear scan create resolve data flow phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createSpillMoveEliminationPhase()->LinearScanEliminateSpillMovePhase::: linear scan create spill move elimination phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#createAssignLocationsPhase()->LinearScanAssignLocationsPhase::: linear scan create assign locations phase
org.graalvm.compiler.lir.alloc.lsra.LinearScan#printIntervals(String)->void::: linear scan print intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScan#verify()->boolean::: linear scan verify
org.graalvm.compiler.lir.alloc.lsra.LinearScan#verifyIntervals()->void::: linear scan verify intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScan.CheckConsumer#visitValue(Value, OperandMode, EnumSet)->void::: check consumer visit value
org.graalvm.compiler.lir.alloc.lsra.LinearScan#verifyNoOopsInFixedIntervals()->void::: linear scan verify no oops in fixed intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getLIR()->LIR::: linear scan get r
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getFrameMapBuilder()->FrameMapBuilder::: linear scan get frame map builder
org.graalvm.compiler.lir.alloc.lsra.LinearScan#sortedBlocks()->AbstractBlockBase[]::: linear scan sorted blocks
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getRegisters()->RegisterArray::: linear scan get registers
org.graalvm.compiler.lir.alloc.lsra.LinearScan#getRegisterAllocationConfig()->RegisterAllocationConfig::: linear scan get register allocation config
org.graalvm.compiler.lir.alloc.lsra.LinearScan#callKillsRegisters()->boolean::: linear scan call kills registers
org.graalvm.compiler.lir.alloc.lsra.LinearScan#neverSpillConstants()->boolean::: linear scan never spill constants
org.graalvm.compiler.lir.alloc.lsra.LinearScanAllocationPhase#getName()->CharSequence::: linear scan allocation phase get name
org.graalvm.compiler.lir.alloc.lsra.LinearScanAllocationPhase#toString()->String::: linear scan allocation phase to string
org.graalvm.compiler.lir.alloc.lsra.LinearScanAllocationPhase#apply(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan allocation phase apply
org.graalvm.compiler.lir.alloc.lsra.LinearScanAllocationPhase#apply(TargetDescription, LIRGenerationResult, AllocationContext, boolean)->void::: linear scan allocation phase apply
org.graalvm.compiler.lir.alloc.lsra.LinearScanAllocationPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan allocation phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanAssignLocationsPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan assign locations phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanAssignLocationsPhase#colorLirOperand(LIRInstruction, Variable, OperandMode)->Value:::Assigns the allocated location for an LIR instruction operand back into the instruction.
org.graalvm.compiler.lir.alloc.lsra.LinearScanAssignLocationsPhase#assignLocations(LIRInstruction)->boolean:::Assigns the operand of an LIRInstruction.
org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan eliminate spill move phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase#firstInstructionOfInterest()->int::: linear scan eliminate spill move phase first instruction of interest
org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase#eliminateSpillMoves(LIRGenerationResult)->void::: linear scan eliminate spill move phase eliminate spill moves
org.graalvm.compiler.lir.alloc.lsra.LinearScanEliminateSpillMovePhase#canEliminateSpillMove(AbstractBlockBase, MoveOp)->boolean::: linear scan eliminate spill move phase can eliminate spill move
org.graalvm.compiler.lir.alloc.lsra.LinearScanIntervalDumper#visitIntervals(IntervalVisitor)->void::: linear scan interval dumper visit intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan lifetime analysis phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#isIntervalInLoop(int, int)->boolean::: linear scan lifetime analysis phase is interval in loop
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#numberInstructions()->void:::Numbers all instructions in all blocks
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#computeLocalLiveSets()->void:::Computes local live sets (i.e
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#getOperandNumber(Value)->int::: linear scan lifetime analysis phase get operand number
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#computeGlobalLiveSets()->void:::Performs a backward dataflow analysis to compute global live sets (i.e
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#reportFailure(int)->void::: linear scan lifetime analysis phase report failure
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#verifyLiveness()->void::: linear scan lifetime analysis phase verify liveness
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#addUse(AllocatableValue, int, int, RegisterPriority, ValueKind, boolean)->void::: linear scan lifetime analysis phase add use
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#addTemp(AllocatableValue, int, RegisterPriority, ValueKind, boolean)->void::: linear scan lifetime analysis phase add temp
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#addDef(AllocatableValue, LIRInstruction, RegisterPriority, ValueKind, boolean)->void::: linear scan lifetime analysis phase add def
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#handleMethodArguments(LIRInstruction)->void:::Optimizes moves related to incoming stack based arguments
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#addRegisterHint(LIRInstruction, Value, OperandMode, EnumSet, boolean)->void::: linear scan lifetime analysis phase add register hint
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#changeSpillDefinitionPos(LIRInstruction, AllocatableValue, Interval, int)->void:::Eliminates moves from register to stack if the stack slot is known to be correct.
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#registerPriorityOfOutputOperand(LIRInstruction)->RegisterPriority:::Determines the register priority for an instruction's output/result operand.
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#registerPriorityOfInputOperand(EnumSet)->RegisterPriority:::Determines the priority which with an instruction's input operand will be allocated a register.
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#buildIntervals(boolean)->void::: linear scan lifetime analysis phase build intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase#getMaterializedValue(LIRInstruction, Value, Interval)->Constant:::Returns a value for a interval definition, which can be used for re-materialization.
org.graalvm.compiler.lir.alloc.lsra.LinearScanOptimizeSpillPositionPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan optimize spill position phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanRegisterAllocationPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan register allocation phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanRegisterAllocationPhase#allocateRegisters()->void::: linear scan register allocation phase allocate registers
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#run(TargetDescription, LIRGenerationResult, AllocationContext)->void::: linear scan resolve data flow phase run
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#resolveCollectMappings(AbstractBlockBase, AbstractBlockBase, AbstractBlockBase, MoveResolver)->void::: linear scan resolve data flow phase resolve collect mappings
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#resolveFindInsertPos(AbstractBlockBase, AbstractBlockBase, MoveResolver)->void::: linear scan resolve data flow phase resolve find insert pos
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#resolveDataFlow()->void:::Inserts necessary moves (spilling or reloading) at edges between blocks for intervals that have been split.
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#optimizeEmptyBlocks(MoveResolver, BitSet)->void::: linear scan resolve data flow phase optimize empty blocks
org.graalvm.compiler.lir.alloc.lsra.LinearScanResolveDataFlowPhase#resolveDataFlow0(MoveResolver, BitSet)->void::: linear scan resolve data flow phase resolve data flow0
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#blockCount()->int::: linear scan walker block count
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#blockAt(int)->AbstractBlockBase::: linear scan walker block at
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#blockOfOpWithId(int)->AbstractBlockBase::: linear scan walker block of op with id
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#initUseLists(boolean)->void::: linear scan walker init use lists
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#maxRegisterNumber()->int::: linear scan walker max register number
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#minRegisterNumber()->int::: linear scan walker min register number
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#isRegisterInRange(int)->boolean::: linear scan walker is register in range
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#excludeFromUse(Interval)->void::: linear scan walker exclude from use
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#setUsePos(Interval, int, boolean)->void::: linear scan walker set use pos
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#setBlockPos(Interval, int)->void::: linear scan walker set block pos
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#freeExcludeActiveFixed()->void::: linear scan walker free exclude active fixed
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#freeExcludeActiveAny()->void::: linear scan walker free exclude active any
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#freeCollectInactiveFixed(Interval)->void::: linear scan walker free collect inactive fixed
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#freeCollectInactiveAny(Interval)->void::: linear scan walker free collect inactive any
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#freeCollectUnhandled(RegisterBinding, Interval)->void::: linear scan walker free collect unhandled
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#spillExcludeActiveFixed()->void::: linear scan walker spill exclude active fixed
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#spillBlockUnhandledFixed(Interval)->void::: linear scan walker spill block unhandled fixed
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#spillBlockInactiveFixed(Interval)->void::: linear scan walker spill block inactive fixed
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#spillCollectActiveAny(RegisterPriority)->void::: linear scan walker spill collect active any
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#spillCollectInactiveAny(Interval)->void::: linear scan walker spill collect inactive any
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#insertMove(int, Interval, Interval)->void::: linear scan walker insert move
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#findOptimalSplitPos(AbstractBlockBase, AbstractBlockBase, int)->int::: linear scan walker find optimal split pos
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#findOptimalSplitPos(Interval, int, int, boolean)->int::: linear scan walker find optimal split pos
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitBeforeUsage(Interval, int, int)->void::: linear scan walker split before usage
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitForSpilling(Interval)->void::: linear scan walker split for spilling
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#handleSpillSlot(Interval)->void:::This is called for every interval that is assigned to a stack slot.
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitStackInterval(Interval)->void::: linear scan walker split stack interval
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitWhenPartialRegisterAvailable(Interval, int)->void::: linear scan walker split when partial register available
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitAndSpillInterval(Interval)->void::: linear scan walker split and spill interval
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#allocFreeRegister(Interval)->boolean::: linear scan walker alloc free register
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#splitAndSpillIntersectingIntervals(Register)->void::: linear scan walker split and spill intersecting intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#allocLockedRegister(Interval)->void::: linear scan walker alloc locked register
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#printRegisterState()->void::: linear scan walker print register state
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#noAllocationPossible(Interval)->boolean::: linear scan walker no allocation possible
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#initVarsForAlloc(Interval)->void::: linear scan walker init vars for alloc
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#isMove(LIRInstruction, Interval, Interval)->boolean::: linear scan walker is move
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#combineSpilledIntervals(Interval)->void::: linear scan walker combine spilled intervals
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#activateCurrent(Interval)->boolean::: linear scan walker activate current
org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker#finishAllocation()->void::: linear scan walker finish allocation
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#setValueBlocked(Value, int)->void::: move resolver set value blocked
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#getMappingFrom(int)->Interval::: move resolver get mapping from
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#mappingFromSize()->int::: move resolver mapping from size
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#valueBlocked(Value)->int::: move resolver value blocked
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#setMultipleReadsAllowed()->void::: move resolver set multiple reads allowed
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#areMultipleReadsAllowed()->boolean::: move resolver are multiple reads allowed
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#hasMappings()->boolean::: move resolver has mappings
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#getAllocator()->LinearScan::: move resolver get allocator
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#checkEmpty()->boolean::: move resolver check empty
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#checkMultipleReads()->void::: move resolver check multiple reads
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#verifyStackSlotMapping()->void::: move resolver verify stack slot mapping
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#isMoveToSelf(Value, Value)->boolean::: move resolver is move to self
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#mightBeBlocked(Value)->boolean::: move resolver might be blocked
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#createMove(AllocatableValue, AllocatableValue, AllocatableValue, AllocatableValue)->LIRInstruction::: move resolver create move
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#breakCycle(int)->void::: move resolver break cycle
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#spillInterval(int, Interval, AllocatableValue)->void::: move resolver spill interval
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#setInsertPosition(ArrayList, int)->void::: move resolver set insert position
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#moveInsertPosition(ArrayList, int)->void::: move resolver move insert position
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#addMapping(Interval, Interval)->void::: move resolver add mapping
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#addMapping(Constant, Interval)->void::: move resolver add mapping
org.graalvm.compiler.lir.alloc.lsra.MoveResolver#resolveAndAppendMoves()->void::: move resolver resolve and append moves
org.graalvm.compiler.lir.alloc.lsra.OptimizingLinearScanWalker#handleSpillSlot(Interval)->void::: optimizing linear scan walker handle spill slot
org.graalvm.compiler.lir.alloc.lsra.OptimizingLinearScanWalker#walk()->void::: optimizing linear scan walker walk
org.graalvm.compiler.lir.alloc.lsra.Range#intersects(Range)->boolean::: range intersects
org.graalvm.compiler.lir.alloc.lsra.Range#isEndMarker()->boolean::: range is end marker
org.graalvm.compiler.lir.alloc.lsra.Range#intersectsAt(Range)->int::: range intersects at
org.graalvm.compiler.lir.alloc.lsra.Range#toString()->String::: range to string
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#intervalAt(Value)->Interval::: register verifier interval at
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#stateSize()->int::: register verifier state size
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#stateForBlock(AbstractBlockBase)->Interval[]::: register verifier state for block
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#setStateForBlock(AbstractBlockBase, Interval[])->void::: register verifier set state for block
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#addToWorkList(AbstractBlockBase)->void::: register verifier add to work list
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#verify(AbstractBlockBase)->void::: register verifier verify
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#printState(Interval[])->void::: register verifier print state
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#copy(Interval[])->Interval[]::: register verifier copy
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#statePut(DebugContext, Interval[], Value, Interval)->void::: register verifier state put
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#checkState(AbstractBlockBase, LIRInstruction, Interval[], Value, Value, Interval)->boolean::: register verifier check state
org.graalvm.compiler.lir.alloc.lsra.RegisterVerifier#processOperations(AbstractBlockBase, Interval[])->void::: register verifier process operations
