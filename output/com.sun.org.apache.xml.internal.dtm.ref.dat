ChunkedIntArray#appendSlot(int, int, int, int):::Append a 4-integer record to the CIA, starting with record 1:::slotsize->newoffset->chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt->return
ChunkedIntArray#readEntry(int, int):::Retrieve an integer from the CIA by record number and column within the record, both 0-based (though position 0 is reserved for special purposes).:::if->throw->XMLMessages->createXMLMessage->new->ArrayIndexOutOfBoundsException->chunkpos->slotpos->chunk->chunks->elementAt->return
ChunkedIntArray#discardLast():::Disard the highest-numbered record:::
ChunkedIntArray#writeEntry(int, int, int):::Overwrite the integer found at a specific record and column:::if->throw->XMLMessages->createXMLMessage->new->ArrayIndexOutOfBoundsException->chunkpos->slotpos->chunk->chunks->elementAt
ChunkedIntArray#writeSlot(int, int, int, int, int):::Overwrite an entire (4-integer) record at the specified index:::chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt
ChunkedIntArray#readSlot(int, int[]):::Retrieve the contents of a record into a user-supplied buffer array:::chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt->System->arraycopy
CoroutineManager#co_joinCoroutineSet(int):::Each coroutine in the set managed by a single CoroutineManager is identified by a small positive integer:::if->if->m_activeIDs->get->return->else->while->if->m_activeIDs->get->else->break->if->return->m_activeIDs->set->return
CoroutineManager#co_entry_pause(int):::In the standard coroutine architecture, coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them; its's presumed that this recognizes the not-already-running case and does the right thing:::if->m_activeIDs->get->throw->new->java.lang.NoSuchMethodException->while->try->wait->catch->finally->return
CoroutineManager#co_resume(Object, int, int):::Transfer control to another coroutine which has already been started and is waiting on this CoroutineManager:::if->m_activeIDs->get->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->java.lang.NoSuchMethodException->notify->while->try->wait->catch->finally->if->co_exit->throw->XMLMessages->createXMLMessage->new->java.lang.NoSuchMethodException->return
CoroutineManager#co_exit(int):::Terminate this entire set of coroutines:::m_activeIDs->clear->notify
CoroutineManager#co_exit_to(Object, int, int):::Make the ID available for reuse and terminate this coroutine, transferring control to the specified coroutine:::if->m_activeIDs->get->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->java.lang.NoSuchMethodException->m_activeIDs->clear->notify
CoroutineParser#setContentHandler(ContentHandler):::Register a SAX-style content handler for us to output to:::
CoroutineParser#setLexHandler(org.xml.sax.ext.LexicalHandler)::: Register a SAX-style lexical handler for us to output to  Not all parsers support this..:::
CoroutineParser#doParse(InputSource, int):::doParse() is a simple API which tells the coroutine parser to begin reading from a file:::
CoroutineParser#doMore(boolean, int):::doMore() is a simple API which tells the coroutine parser that we need more nodes:::
CoroutineParser#doTerminate(int):::doTerminate() is a simple API which tells the coroutine parser to terminate itself:::
CoroutineParser#init(CoroutineManager, int, XMLReader):::Initialize the coroutine parser:::
DTMAxisIteratorBase#getStartNode():::Get start to END should 'close' the iterator, i.e:::return
DTMAxisIteratorBase#includeSelf():::Set the flag to include the start node in the iteration.:::return
DTMAxisIteratorBase#getLast():::Returns the position of the last node within the iteration, as defined by XPath:::if->temp->setMark->reset->do->while->next->gotoMark->return
DTMAxisIteratorBase#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->return->catch->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally
DTMAxisIteratorBase#returnNode(int):::Do any final cleanup that is required before returning the node that was passed in, and then return it:::return
DTMAxisIteratorBase#resetPosition():::Reset the position to zero:::return
DTMAxisIteratorBase#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order.:::return
DTMAxisIteratorBase#getAxis():::Returns the axis being iterated, if it is known.:::return
DTMAxisIteratorBase#getNodeByPosition(int):::Return the node at the given position.:::if->pos->isReverse->getLast->node->while->next->if->getPosition->return->return
DTMAxisIterNodeList#getDTMAxisIterator():::Access the wrapped DTMIterator:::return
DTMAxisIterNodeList#item(int):::Returns the indexth item in the collection:::if->node->count->m_cachedNodes->size->if->m_cachedNodes->elementAt->return->m_dtm->getNode->else->if->while->m_iter->next->m_cachedNodes->addElement->if->else->return->m_dtm->getNode->return
DTMAxisIterNodeList#getLength():::The number of nodes in the list:::if->node->while->m_iter->next->m_cachedNodes->addElement->m_cachedNodes->size->return
DTMChildIterNodeList#item(int):::Returns the indexth item in the collection:::handle->while->m_parentDTM->getNextSibling->if->return->return->m_parentDTM->getNode
DTMChildIterNodeList#getLength():::The number of nodes in the list:::count->for->handle->m_parentDTM->getNextSibling->return
DTMDefaultBase#ensureSizeOfIndex(int, int):::Ensure that the size of the element indexes can hold the information.:::if->new->intArrs->else->if->indexes->new->intArrs->System->arraycopy->localNameIndex->if->new->intArrs->else->if->indexes->new->intArrs->System->arraycopy->elemHandles->if->new->intArr->else->if->indexes->new->intArr->System->arraycopy
DTMDefaultBase#indexNode(int, int):::Add a node to the element indexes:::ent->type->ent->getType->if->namespaceID->ent->getNamespaceID->localNameID->ent->getLocalNameID->ensureSizeOfIndex->index
DTMDefaultBase#findGTE(int[], int, int, int):::Find the first index that occurs in the list that is greater than or equal to the given value.:::low->high->end->while->mid->c->if->else->if->else->return->return
DTMDefaultBase#findElementFromIndex(int, int, int):::Find the first matching element from the index at or after the given node.:::indexes->if->lnIndexs->if->elems->if->pos->findGTE->if->return->return
DTMDefaultBase#getNextNodeIdentity(int):::Get the next node identity value in the list, and call the iterator if it hasn't been added yet.:::
DTMDefaultBase#nextNode():::This method should try and build one or more nodes in the table.:::
DTMDefaultBase#getNumberOfNodes():::Get the number of nodes that have been added.:::
DTMDefaultBase#_type(int):::Get the simple type ID for the given node identity.:::info->_exptype->if->return->m_expandedNameTable->getType->else->return
DTMDefaultBase#_exptype(int):::Get the expanded type ID for the given node identity.:::if->return->while->if->nextNode->return->return->m_exptype->elementAt
DTMDefaultBase#_level(int):::Get the level in the tree for the given node identity.:::while->isMore->nextNode->if->return->i->while->_parent->return
DTMDefaultBase#_firstch(int):::Get the first child for the given node identity.:::info->m_firstch->elementAt->while->isMore->nextNode->if->return->else->m_firstch->elementAt->if->return->return
DTMDefaultBase#_nextsib(int):::Get the next sibling for the given node identity.:::info->m_nextsib->elementAt->while->isMore->nextNode->if->return->else->m_nextsib->elementAt->if->return->return
DTMDefaultBase#_prevsib(int):::Get the previous sibling for the given node identity.:::if->return->m_prevsib->elementAt->while->isMore->nextNode->if->return->else->if->return->m_prevsib->elementAt
DTMDefaultBase#_parent(int):::Get the parent for the given node identity.:::if->return->m_parent->elementAt->while->isMore->nextNode->if->return->else->if->return->m_parent->elementAt
DTMDefaultBase#dumpDTM(OutputStream):::Diagnostics function to dump the DTM.:::try->if->f->hashCode->new->File->f->getAbsolutePath->println->new->FileOutputStream->ps->new->PrintStream->while->nextNode->nRecords->ps->println->for->index->catch->ioe->printStackTrace->throw->ioe->getMessage->new->RuntimeException->finally
DTMDefaultBase#dumpNode(int):::Diagnostics function to dump a single node:::if->return->typestring->switch->getNodeType->break->break->break->break->break->break->break->break->break->break->break->break->break->break->break->return->Integer->getExpandedTypeID->toHexString->getNodeNameX->getNamespaceURI->getNodeValue
DTMDefaultBase#setFeature(String, boolean):::Set an implementation dependent feature:::
DTMDefaultBase#hasChildNodes(int):::Given a node handle, test if it has child nodes:::identity->makeNodeIdentity->firstChild->_firstch->return
DTMDefaultBase#makeNodeHandle(int):::Given a node identity, return a node handle:::if->return->if->println->return->m_dtmIdent->elementAt
DTMDefaultBase#makeNodeIdentity(int):::Given a node handle, return a node identity:::if->return->if->whichDTMindex->if->return->else->return->whichDTMid->m_dtmIdent->indexOf->return
DTMDefaultBase#getFirstChild(int):::Given a node handle, get the handle of the node's first child:::identity->makeNodeIdentity->firstChild->_firstch->return->makeNodeHandle
DTMDefaultBase#getTypedFirstChild(int, int):::Given a node handle, get the handle of the node's first child:::firstChild->eType->if->for->makeNodeIdentity->_firstch->_nextsib->else->for->makeNodeIdentity->_firstch->_nextsib->return
DTMDefaultBase#getLastChild(int):::Given a node handle, advance to its last child:::identity->makeNodeIdentity->child->_firstch->lastChild->while->_nextsib->return->makeNodeHandle
DTMDefaultBase#getAttributeNode(int, String, String):::Retrieves an attribute node by by qualified name and namespace URI.:::
DTMDefaultBase#getFirstAttribute(int):::Given a node handle, get the index of the node's first attribute.:::nodeID->makeNodeIdentity->return->getFirstAttributeIdentity->makeNodeHandle
DTMDefaultBase#getFirstAttributeIdentity(int):::Given a node identity, get the index of the node's first attribute.:::type->_type->if->while->getNextNodeIdentity->_type->if->return->else->if->break->return
DTMDefaultBase#getTypedAttribute(int, int):::Given a node handle and an expanded type ID, get the index of the node's attribute of that type, if any.:::type->getNodeType->if->identity->makeNodeIdentity->while->getNextNodeIdentity->_type->if->if->_exptype->return->makeNodeHandle->else->if->break->return
DTMDefaultBase#getNextSibling(int):::Given a node handle, advance to its next sibling:::if->return->return->makeNodeIdentity->_nextsib->makeNodeHandle
DTMDefaultBase#getTypedNextSibling(int, int):::Given a node handle, advance to its next sibling:::if->return->node->makeNodeIdentity->eType->while->_nextsib->_exptype->m_expandedNameTable->getType->return->makeNodeHandle
DTMDefaultBase#getPreviousSibling(int):::Given a node handle, find its preceeding sibling:::if->return->if->return->makeNodeIdentity->_prevsib->makeNodeHandle->else->nodeID->makeNodeIdentity->parent->_parent->node->_firstch->result->while->_nextsib->return->makeNodeHandle
DTMDefaultBase#getNextAttribute(int):::Given a node handle, advance to the next attribute:::nodeID->makeNodeIdentity->if->_type->return->getNextAttributeIdentity->makeNodeHandle->return
DTMDefaultBase#getNextAttributeIdentity(int):::Given a node identity for an attribute, advance to the next attribute.:::while->getNextNodeIdentity->type->_type->if->return->else->if->break->return
DTMDefaultBase#declareNamespaceInContext(int, int):::Build table of namespace declaration locations during DTM construction:::nsList->if->new->SuballocatedIntVector->m_namespaceDeclSetElements->addElement->new->Vector<>->new->SuballocatedIntVector->m_namespaceDeclSets->add->else->last->m_namespaceDeclSetElements->size->if->m_namespaceDeclSetElements->elementAt->m_namespaceDeclSets->get->if->m_namespaceDeclSetElements->addElement->inherited->_parent->findNamespaceContext->if->isize->inherited->size->Math->Math->min->max->new->SuballocatedIntVector->for->i->else->new->SuballocatedIntVector->m_namespaceDeclSets->add->newEType->_exptype->for->i->nsList->size->nsList->makeNodeHandle->addElement
DTMDefaultBase#findNamespaceContext(int):::Retrieve list of namespace declaration locations active at this node:::if->wouldBeAt->findInSortedSuballocatedIntVector->if->return->m_namespaceDeclSets->get->if->return->candidate->m_namespaceDeclSetElements->elementAt->ancestor->_parent->if->rootHandle->makeNodeHandle->getDocumentRoot->rootID->makeNodeIdentity->uppermostNSCandidateID->if->getNodeType->ch->_firstch->else->if->return->m_namespaceDeclSets->get->while->if->return->m_namespaceDeclSets->get->else->if->do->_parent->while->else->if->m_namespaceDeclSetElements->elementAt->else->break->return
DTMDefaultBase#findInSortedSuballocatedIntVector(SuballocatedIntVector, int):::Subroutine: Locate the specified node within m_namespaceDeclSetElements, or the last element which preceeds it in document order  %REVIEW% Inlne this into findNamespaceContext? Create SortedSuballocatedIntVector type?:::i->if->first->last->vector->size->while->test->vector->elementAt->if->return->else->if->else->if->return
DTMDefaultBase#getFirstNamespaceNode(int, boolean):::Given a node handle, get the index of the node's first child:::if->identity->makeNodeIdentity->if->_type->nsContext->findNamespaceContext->if->nsContext->size->return->return->nsContext->elementAt->else->return->else->identity->makeNodeIdentity->if->_type->while->getNextNodeIdentity->type->_type->if->return->makeNodeHandle->else->if->break->return->else->return
DTMDefaultBase#getNextNamespaceNode(int, int, boolean):::Given a namespace handle, advance to the next namespace.:::if->nsContext->makeNodeIdentity->findNamespaceContext->if->return->i->nsContext->indexOf->if->nsContext->size->return->return->nsContext->elementAt->else->identity->makeNodeIdentity->while->getNextNodeIdentity->type->_type->if->return->makeNodeHandle->else->if->break->return
DTMDefaultBase#getParent(int):::Given a node handle, find its parent node.:::identity->makeNodeIdentity->if->return->_parent->makeNodeHandle->else->return
DTMDefaultBase#getDocument():::Find the Document node handle for the document currently under construction:::return->m_dtmIdent->elementAt
DTMDefaultBase#getOwnerDocument(int):::Given a node handle, find the owning document node:::if->getNodeType->return->return->getDocumentRoot
DTMDefaultBase#getDocumentRoot(int):::Given a node handle, find the owning document node:::return->getManager->getDTM->getDocument
DTMDefaultBase#getStringValue(int):::Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value).:::
DTMDefaultBase#getStringValueChunkCount(int):::Get number of character array chunks in the string-value of a node:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getStringValueChunk(int, int, int[]):::Get a character array chunk in the string-value of a node:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getExpandedTypeID(int):::Given a node handle, return an ID that represents the node's expanded name.:::id->makeNodeIdentity->if->return->return->_exptype
DTMDefaultBase#getExpandedTypeID(String, String, int):::Given an expanded name, return an ID:::ent->return->ent->getExpandedTypeID
DTMDefaultBase#getLocalNameFromExpandedNameID(int):::Given an expanded-name ID, return the local name part.:::return->m_expandedNameTable->getLocalName
DTMDefaultBase#getNamespaceFromExpandedNameID(int):::Given an expanded-name ID, return the namespace URI part.:::return->m_expandedNameTable->getNamespace
DTMDefaultBase#getNamespaceType(int):::Returns the namespace type of a specific node:::identity->makeNodeIdentity->expandedNameID->_exptype->return->m_expandedNameTable->getNamespaceID
DTMDefaultBase#getNodeName(int):::Given a node handle, return its DOM-style node name:::
DTMDefaultBase#getNodeNameX(int):::Given a node handle, return the XPath node name:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getLocalName(int):::Given a node handle, return its XPath-style localname:::
DTMDefaultBase#getPrefix(int):::Given a namespace handle, return the prefix that the namespace decl is mapping:::
DTMDefaultBase#getNamespaceURI(int):::Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.)  %REVIEW% Null or ""? -sb:::
DTMDefaultBase#getNodeValue(int):::Given a node handle, return its node value:::
DTMDefaultBase#getNodeType(int):::Given a node handle, return its DOM-style node type:::if->return->return->m_expandedNameTable->makeNodeIdentity->_exptype->getType
DTMDefaultBase#getLevel(int):::Get the depth level of this node in the tree (equals 1 for a parentless node).:::identity->makeNodeIdentity->return->_level
DTMDefaultBase#getNodeIdent(int):::Get the identity of this node in the tree:::return->makeNodeIdentity
DTMDefaultBase#getNodeHandle(int):::Get the handle of this node in the tree:::return->makeNodeHandle
DTMDefaultBase#isSupported(String, String):::Tests whether DTM DOM implementation implements a specific feature and that feature is supported by this node.:::return
DTMDefaultBase#getDocumentBaseURI():::Return the base URI of the document entity:::return
DTMDefaultBase#setDocumentBaseURI(String):::Set the base URI of the document entity.:::
DTMDefaultBase#getDocumentSystemIdentifier(int):::Return the system identifier of the document entity:::return
DTMDefaultBase#getDocumentEncoding(int):::Return the name of the character encoding scheme        in which the document entity is expressed.:::return
DTMDefaultBase#getDocumentStandalone(int):::Return an indication of the standalone status of the document,        either "yes" or "no":::return
DTMDefaultBase#getDocumentVersion(int):::Return a string representing the XML version of the document:::return
DTMDefaultBase#getDocumentAllDeclarationsProcessed():::Return an indication of whether the processor has read the complete DTD:::return
DTMDefaultBase#getDocumentTypeDeclarationSystemIdentifier():::  A document type declaration information item has the following properties:      1:::
DTMDefaultBase#getDocumentTypeDeclarationPublicIdentifier():::Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]:::
DTMDefaultBase#getElementById(String):::Returns the Element whose ID is given by elementId:::
DTMDefaultBase#getUnparsedEntityURI(String):::The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]):::
DTMDefaultBase#supportsPreStripping():::Return true if the xsl:strip-space or xsl:preserve-space was processed during construction of the DTM document.:::return
DTMDefaultBase#isNodeAfter(int, int):::Figure out whether nodeHandle2 should be considered as being later in the document than nodeHandle1, in Document Order as defined by the XPath model:::index1->makeNodeIdentity->index2->makeNodeIdentity->return
DTMDefaultBase#isCharacterElementContentWhitespace(int):::    2:::return
DTMDefaultBase#isDocumentAllDeclarationsProcessed(int):::   10:::return
DTMDefaultBase#isAttributeSpecified(int):::    5:::
DTMDefaultBase#dispatchCharactersEvents(int, org.xml.sax.ContentHandler, boolean):::Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value):::
DTMDefaultBase#dispatchToEvents(int, org.xml.sax.ContentHandler):::Directly create SAX parser events from a subtree.:::
DTMDefaultBase#getNode(int):::Return an DOM node for the given node.:::return->new->DTMNodeProxy
DTMDefaultBase#appendChild(int, boolean, boolean):::Append a child to the end of the document:::XMLMessages->createXMLMessage->error
DTMDefaultBase#appendTextChild(String):::Append a text node child that will be constructed from a string, to the end of the document:::XMLMessages->createXMLMessage->error
DTMDefaultBase#error(String):::Simple error for asserts and the like.:::throw->new->DTMException
DTMDefaultBase#getShouldStripWhitespace():::Find out whether or not to strip whispace nodes.:::return
DTMDefaultBase#pushShouldStripWhitespace(boolean):::Set whether to strip whitespaces and push in current value of m_shouldStripWS in m_shouldStripWhitespaceStack.:::if->m_shouldStripWhitespaceStack->push
DTMDefaultBase#popShouldStripWhitespace():::Set whether to strip whitespaces at this point by popping out m_shouldStripWhitespaceStack.:::if->m_shouldStripWhitespaceStack->popAndTop
DTMDefaultBase#setShouldStripWhitespace(boolean):::Set whether to strip whitespaces and set the top of the stack to the current value of m_shouldStripWS.:::if->m_shouldStripWhitespaceStack->setTop
DTMDefaultBase#documentRegistration():::A dummy routine to satisify the abstract interface:::
DTMDefaultBase#documentRelease():::A dummy routine to satisify the abstract interface:::
DTMDefaultBase#migrateTo(DTMManager):::Migrate a DTM built with an old DTMManager to a new DTMManager:::if
DTMDefaultBase#getManager():::Query which DTMManager this DTM is currently being handled by:::return
DTMDefaultBase#getDTMIDs():::Query which DTMIDs this DTM is currently using within the DTMManager:::if->return->return
DTMDefaultBaseIterators#getTypedAxisIterator(int, int):::Get an iterator that can navigate over an XPath Axis, predicated by the extended type ID:::iterator->switch->new->TypedSingletonIterator->break->new->TypedChildrenIterator->break->return->new->ParentIterator->setNodeType->return->new->TypedAncestorIterator->return->new->TypedAncestorIterator->includeSelf->return->new->TypedAttributeIterator->new->TypedDescendantIterator->break->new->TypedDescendantIterator->includeSelf->break->new->TypedFollowingIterator->break->new->TypedPrecedingIterator->break->new->TypedFollowingSiblingIterator->break->new->TypedPrecedingSiblingIterator->break->new->TypedNamespaceIterator->break->new->TypedRootIterator->break->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDefaultBaseIterators#getAxisIterator(int):::This is a shortcut to the iterators that implement the XPath axes:::iterator->switch->new->SingletonIterator->break->new->ChildrenIterator->break->return->new->ParentIterator->return->new->AncestorIterator->return->new->AncestorIterator->includeSelf->return->new->AttributeIterator->new->DescendantIterator->break->new->DescendantIterator->includeSelf->break->new->FollowingIterator->break->new->PrecedingIterator->break->new->FollowingSiblingIterator->break->new->PrecedingSiblingIterator->break->new->NamespaceIterator->break->new->RootIterator->break->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDefaultBaseIterators.InternalAxisIteratorBase#setMark():::Remembers the current node for the next call to gotoMark():::
DTMDefaultBaseIterators.InternalAxisIteratorBase#gotoMark():::Restores the current node remembered by setMark():::
DTMDefaultBaseIterators.ChildrenIterator#setStartNode(int):::Setting start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch->return->resetPosition->return
DTMDefaultBaseIterators.ChildrenIterator#next():::Get the next node in the iteration.:::if->node->_nextsib->return->makeNodeHandle->returnNode->return
DTMDefaultBaseIterators.ParentIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getParent->return->resetPosition->return
DTMDefaultBaseIterators.ParentIterator#setNodeType(int):::Set the node type of the parent that we're looking for:::return
DTMDefaultBaseIterators.ParentIterator#next():::Get the next node in the iteration:::result->if->if->getExpandedTypeID->else->if->if->getNodeType->return->returnNode
DTMDefaultBaseIterators.TypedChildrenIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch->return->resetPosition->return
DTMDefaultBaseIterators.TypedChildrenIterator#next():::Get the next node in the iteration.:::eType->node->nodeType->if->while->_exptype->_nextsib->else->while->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->_nextsib->if->return->else->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.NamespaceChildrenIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceChildrenIterator#next():::Get the next node in the iteration.:::if->for->node->makeNodeIdentity->_firstch->_nextsib->_nextsib->return
DTMDefaultBaseIterators.NamespaceIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getFirstNamespaceNode->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceIterator#next():::Get the next node in the iteration.:::node->if->getNextNamespaceNode->return->returnNode
DTMDefaultBaseIterators.TypedNamespaceIterator#next():::Get the next node in the iteration.:::node->for->getNextNamespaceNode->return
DTMDefaultBaseIterators.RootIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocumentRoot->return->resetPosition->return
DTMDefaultBaseIterators.RootIterator#next():::Get the next node in the iteration.:::if->return->return->returnNode
DTMDefaultBaseIterators.TypedRootIterator#next():::Get the next node in the iteration.:::if->return->nodeType->node->expType->getExpandedTypeID->if->if->return->returnNode->else->if->if->return->returnNode->else->if->m_expandedNameTable->getType->return->returnNode->return
DTMDefaultBaseIterators.NamespaceAttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getFirstNamespaceNode->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceAttributeIterator#next():::Get the next node in the iteration.:::node->if->getNextNamespaceNode->return->returnNode
DTMDefaultBaseIterators.FollowingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->return->resetPosition->return
DTMDefaultBaseIterators.FollowingSiblingIterator#next():::Get the next node in the iteration.:::_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.TypedFollowingSiblingIterator#next():::Get the next node in the iteration.:::if->return->node->eType->nodeType->if->do->_nextsib->while->_exptype->else->while->_nextsib->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.AttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->getFirstAttributeIdentity->return->resetPosition->return
DTMDefaultBaseIterators.AttributeIterator#next():::Get the next node in the iteration.:::node->if->getNextAttributeIdentity->return->makeNodeHandle->returnNode->return
DTMDefaultBaseIterators.TypedAttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getTypedAttribute->return->resetPosition->return
DTMDefaultBaseIterators.TypedAttributeIterator#next():::Get the next node in the iteration.:::node->return->returnNode
DTMDefaultBaseIterators.PrecedingSiblingIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.PrecedingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->type->m_expandedNameTable->_exptype->getType->if->else->_parent->if->_firstch->else->return->resetPosition->return
DTMDefaultBaseIterators.PrecedingSiblingIterator#next():::Get the next node in the iteration.:::if->return->else->node->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.TypedPrecedingSiblingIterator#next():::Get the next node in the iteration.:::node->expType->nodeType->startID->if->while->_exptype->_nextsib->else->while->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->_nextsib->if->return->else->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.PrecedingIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.PrecedingIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->stackCopy->new->intArr->System->arraycopy->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
DTMDefaultBaseIterators.PrecedingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->parent->index->if->_type->_parent->while->_parent->if->stack->new->intArr->System->arraycopy->if->return->resetPosition->return
DTMDefaultBaseIterators.PrecedingIterator#next():::Get the next node in the iteration.:::for->return
DTMDefaultBaseIterators.PrecedingIterator#reset():::Resets the iterator to the last start node.:::return->resetPosition
DTMDefaultBaseIterators.TypedPrecedingIterator#next():::Get the next node in the iteration.:::node->nodeType->if->while->if->break->else->if->if->break->else->if->_exptype->break->else->expType->while->if->break->else->if->if->break->else->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.FollowingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->m_traverser->first->return->resetPosition->return
DTMDefaultBaseIterators.FollowingIterator#next():::Get the next node in the iteration.:::node->m_traverser->next->return->returnNode
DTMDefaultBaseIterators.TypedFollowingIterator#next():::Get the next node in the iteration.:::node->do->m_traverser->next->while->getExpandedTypeID->getNodeType->return->returnNode
DTMDefaultBaseIterators.AncestorIterator#getStartNode():::Get start to END should 'close' the iterator, i.e:::return
DTMDefaultBaseIterators.AncestorIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.AncestorIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
DTMDefaultBaseIterators.AncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->if->_parent->makeNodeHandle->while->m_ancestors->addElement->_parent->makeNodeHandle->m_ancestors->size->m_ancestors->elementAt->return->resetPosition->return
DTMDefaultBaseIterators.AncestorIterator#reset():::Resets the iterator to the last start node.:::m_ancestors->size->m_ancestors->elementAt->return->resetPosition
DTMDefaultBaseIterators.AncestorIterator#next():::Get the next node in the iteration.:::next->pos->m_ancestors->elementAt->return->returnNode
DTMDefaultBaseIterators.TypedAncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->nodeType->if->_parent->if->while->eType->_exptype->if->m_ancestors->makeNodeHandle->addElement->_parent->else->while->eType->_exptype->if->m_expandedNameTable->getType->m_ancestors->makeNodeHandle->addElement->_parent->m_ancestors->size->m_ancestors->elementAt->return->resetPosition->return
DTMDefaultBaseIterators.DescendantIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->return
DTMDefaultBaseIterators.DescendantIterator#isDescendant(int):::Tell if this node identity is a descendant:::return->_parent
DTMDefaultBaseIterators.DescendantIterator#next():::Get the next node in the iteration.:::if->return->if->return->makeNodeHandle->returnNode->node->type->do->_type->if->isDescendant->return->while->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.DescendantIterator#reset():::Reset.:::temp->makeNodeHandle->setStartNode->return
DTMDefaultBaseIterators.TypedDescendantIterator#next():::Get the next node in the iteration.:::node->type->if->return->do->_type->if->isDescendant->return->while->_exptype->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.NthDescendantIterator#next():::Get the next node in the iteration.:::node->while->super->next->makeNodeIdentity->parent->_parent->child->_firstch->pos->do->type->_type->if->while->_nextsib->if->return->return
DTMDefaultBaseIterators.SingletonIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->return->resetPosition->else->if->return->resetPosition->return
DTMDefaultBaseIterators.SingletonIterator#reset():::Resets the iterator to the last start node.:::if->return->resetPosition->else->temp->setStartNode->return
DTMDefaultBaseIterators.SingletonIterator#next():::Get the next node in the iteration.:::result->return->returnNode
DTMDefaultBaseIterators.TypedSingletonIterator#next():::Get the next node in the iteration.:::result->nodeType->if->if->getExpandedTypeID->return->returnNode->else->if->getNodeType->return->returnNode->return
DTMDefaultBaseTraversers#getAxisTraverser(int):::This returns a stateless "traverser", that can navigate over an XPath axis, though perhaps not in document order.:::traverser->if->Axis->getNamesLength->new->DTMAxisTraverserArr->else->if->return->switch->new->AncestorTraverser->break->new->AncestorOrSelfTraverser->break->new->AttributeTraverser->break->new->ChildTraverser->break->new->DescendantTraverser->break->new->DescendantOrSelfTraverser->break->new->FollowingTraverser->break->new->FollowingSiblingTraverser->break->new->NamespaceTraverser->break->new->NamespaceDeclsTraverser->break->new->ParentTraverser->break->new->PrecedingTraverser->break->new->PrecedingSiblingTraverser->break->new->SelfTraverser->break->new->AllFromRootTraverser->break->new->AllFromNodeTraverser->break->new->PrecedingAndAncestorTraverser->break->new->DescendantFromRootTraverser->break->new->DescendantOrSelfFromRootTraverser->break->new->RootTraverser->break->return->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->DTMException->if->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDocumentImpl#setIncrementalSAXSource(IncrementalSAXSource):::Bind a IncrementalSAXSource to this DTM:::source->setContentHandler->source->setLexicalHandler
DTMDocumentImpl#setFeature(String, boolean):::Set an implementation dependent feature:::
DTMDocumentImpl#setLocalNameTable(DTMStringPool):::Set a reference pointer to the element name symbol table:::
DTMDocumentImpl#getLocalNameTable():::Get a reference pointer to the element name symbol table.:::return
DTMDocumentImpl#setNsNameTable(DTMStringPool):::Set a reference pointer to the namespace URI symbol table:::
DTMDocumentImpl#getNsNameTable():::Get a reference pointer to the namespace URI symbol table.:::return
DTMDocumentImpl#setPrefixNameTable(DTMStringPool):::Set a reference pointer to the prefix name symbol table:::
DTMDocumentImpl#getPrefixNameTable():::Get a reference pointer to the prefix name symbol table.:::return
DTMDocumentImpl#setContentBuffer(FastStringBuffer):::Set a reference pointer to the content-text repository:::
DTMDocumentImpl#getContentBuffer():::Get a reference pointer to the content-text repository:::return
DTMDocumentImpl#getContentHandler():::getContentHandler returns "our SAX builder" -- the thing that someone else should send SAX events to in order to extend this DTM model.:::if->return->else->return
DTMDocumentImpl#getLexicalHandler():::Return this DTM's lexical handler:::if->return->else->return
DTMDocumentImpl#getEntityResolver():::Return this DTM's EntityResolver.:::return
DTMDocumentImpl#getDTDHandler():::Return this DTM's DTDHandler.:::return
DTMDocumentImpl#getErrorHandler():::Return this DTM's ErrorHandler.:::return
DTMDocumentImpl#getDeclHandler():::Return this DTM's DeclHandler.:::return
DTMDocumentImpl#initDocument(int):::Reset a dtm document to its initial (empty) state:::nodes->writeSlot
DTMDocumentImpl#hasChildNodes(int):::Given a node handle, test if it has child nodes:::return->getFirstChild
DTMDocumentImpl#getFirstChild(int):::Given a node handle, get the handle of the node's first child:::nodes->readSlot->type->if->kid->nodes->readSlot->while->if->return->nodes->readSlot->if->firstChild->return->return
DTMDocumentImpl#getLastChild(int):::Given a node handle, advance to its last child:::lastChild->for->nextkid->getFirstChild->getNextSibling->return
DTMDocumentImpl#getAttributeNode(int, String, String):::Retrieves an attribute node by by qualified name and namespace URI.:::nsIndex->m_nsNames->stringToIndex->nameIndex->m_localNames->stringToIndex->nodes->readSlot->type->if->while->if->return->nodes->readSlot->return
DTMDocumentImpl#getFirstAttribute(int):::Given a node handle, get the index of the node's first attribute.:::if->nodes->readEntry->return->return->nodes->readEntry
DTMDocumentImpl#getFirstNamespaceNode(int, boolean):::Given a node handle, get the index of the node's first child:::return
DTMDocumentImpl#getNextSibling(int):::Given a node handle, advance to its next sibling:::if->return->type->nodes->readEntry->if->nextSib->nodes->readEntry->if->return->if->return->thisParent->nodes->readEntry->if->nodes->readEntry->return->return
DTMDocumentImpl#getPreviousSibling(int):::Given a node handle, find its preceeding sibling:::if->return->parent->nodes->readEntry->kid->for->nextkid->getFirstChild->getNextSibling->return
DTMDocumentImpl#getNextAttribute(int):::Given a node handle, advance to the next attribute:::nodes->readSlot->type->if->return->getFirstAttribute->else->if->if->return->return
DTMDocumentImpl#getNextNamespaceNode(int, int, boolean):::Given a namespace handle, advance to the next namespace:::return
DTMDocumentImpl#getNextDescendant(int, int):::Given a node handle, advance to its next descendant:::if->return->while->if->nodes->slotsUsed->break->if->nodes->readSlot->if->type->if->else->nextParentPos->if->return->else->break->else->if->else->break->else->return
DTMDocumentImpl#getNextFollowing(int, int):::Given a node handle, advance to the next node on the following axis.:::return
DTMDocumentImpl#getNextPreceding(int, int):::Given a node handle, advance to the next node on the preceding axis.:::while->if->nodes->readEntry->continue->return->nodes->specialFind->return
DTMDocumentImpl#getParent(int):::Given a node handle, find its parent node.:::return->nodes->readEntry
DTMDocumentImpl#getDocumentRoot():::Returns the root element of the document.:::return
DTMDocumentImpl#getDocument():::Given a node handle, find the owning document node.:::return
DTMDocumentImpl#getOwnerDocument(int):::Given a node handle, find the owning document node:::if->return->return
DTMDocumentImpl#getDocumentRoot(int):::Given a node handle, find the owning document node:::if->return->return
DTMDocumentImpl#getStringValue(int):::Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value).:::nodes->readSlot->nodetype->value->switch->m_char->getString->break->break->return->m_xsf->newstr
DTMDocumentImpl#getExpandedTypeID(int):::Given a node handle, return an ID that represents the node's expanded name.:::nodes->readSlot->qName->m_localNames->indexToString->colonpos->qName->indexOf->localName->qName->substring->namespace->m_nsNames->indexToString->expandedName->expandedNameID->m_nsNames->stringToIndex->return
DTMDocumentImpl#getExpandedTypeID(String, String, int):::Given an expanded name, return an ID:::expandedName->expandedNameID->m_nsNames->stringToIndex->return
DTMDocumentImpl#getLocalNameFromExpandedNameID(int):::Given an expanded-name ID, return the local name part.:::expandedName->m_localNames->indexToString->colonpos->expandedName->indexOf->localName->expandedName->substring->return
DTMDocumentImpl#getNamespaceFromExpandedNameID(int):::Given an expanded-name ID, return the namespace URI part.:::expandedName->m_localNames->indexToString->colonpos->expandedName->indexOf->nsName->expandedName->substring->return
DTMDocumentImpl#getNodeName(int):::Given a node handle, return its DOM-style node name:::nodes->readSlot->type->name->if->i->println->m_localNames->indexToString->prefix->m_prefixNames->indexToString->if->prefix->length->return
DTMDocumentImpl#getNodeNameX(int):::Given a node handle, return the XPath node name:::return
DTMDocumentImpl#getLocalName(int):::Given a node handle, return its DOM-style localname:::nodes->readSlot->type->name->if->i->m_localNames->indexToString->if->return
DTMDocumentImpl#getPrefix(int):::Given a namespace handle, return the prefix that the namespace decl is mapping:::nodes->readSlot->type->name->if->i->m_prefixNames->indexToString->if->return
DTMDocumentImpl#getNamespaceURI(int):::Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.):::return
DTMDocumentImpl#getNodeValue(int):::Given a node handle, return its node value:::nodes->readSlot->nodetype->value->switch->nodes->readSlot->m_char->getString->break->break->return
DTMDocumentImpl#getNodeType(int):::Given a node handle, return its DOM-style node type:::return->nodes->readEntry
DTMDocumentImpl#getLevel(int):::Get the depth level of this node in the tree (equals 1 for a parentless node).:::count->while->nodes->readEntry->return
DTMDocumentImpl#isSupported(String, String):::Tests whether DTM DOM implementation implements a specific feature and that feature is supported by this node.:::return
DTMDocumentImpl#getDocumentBaseURI():::Return the base URI of the document entity:::return
DTMDocumentImpl#setDocumentBaseURI(String):::Set the base URI of the document entity.:::
DTMDocumentImpl#getDocumentSystemIdentifier(int):::Return the system identifier of the document entity:::return
DTMDocumentImpl#getDocumentEncoding(int):::Return the name of the character encoding scheme        in which the document entity is expressed.:::return
DTMDocumentImpl#getDocumentStandalone(int):::Return an indication of the standalone status of the document,        either "yes" or "no":::return
DTMDocumentImpl#getDocumentVersion(int):::Return a string representing the XML version of the document:::return
DTMDocumentImpl#getDocumentAllDeclarationsProcessed():::Return an indication of whether the processor has read the complete DTD:::return
DTMDocumentImpl#getDocumentTypeDeclarationSystemIdentifier():::  A document type declaration information item has the following properties:      1:::return
DTMDocumentImpl#getDocumentTypeDeclarationPublicIdentifier():::Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]:::return
DTMDocumentImpl#getElementById(String):::Returns the Element whose ID is given by elementId:::return
DTMDocumentImpl#getUnparsedEntityURI(String):::The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]):::return
DTMDocumentImpl#supportsPreStripping():::Return true if the xsl:strip-space or xsl:preserve-space was processed during construction of the DTM document:::return
DTMDocumentImpl#isNodeAfter(int, int):::Figure out whether nodeHandle2 should be considered as being later in the document than nodeHandle1, in Document Order as defined by the XPath model:::return
DTMDocumentImpl#isCharacterElementContentWhitespace(int):::    2:::return
DTMDocumentImpl#isDocumentAllDeclarationsProcessed(int):::   10:::return
DTMDocumentImpl#isAttributeSpecified(int):::    5:::return
DTMDocumentImpl#dispatchCharactersEvents(int, org.xml.sax.ContentHandler, boolean):::Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value):::
DTMDocumentImpl#getNode(int):::Return an DOM node for the given node.:::return
DTMDocumentImpl#appendChild(int, boolean, boolean):::Append a child to the end of the child list of the current node:::sameDoc->if->else
DTMDocumentImpl#appendTextChild(String):::Append a text node child that will be constructed from a string, to the end of the document:::
DTMDocumentImpl#appendTextChild(int, int):::Append a text child at the current insertion point:::w0->w1->w2->w3->ourslot->appendNode
DTMDocumentImpl#appendComment(int, int):::Append a comment child at the current insertion point:::w0->w1->w2->w3->ourslot->appendNode
DTMDocumentImpl#appendStartElement(int, int, int):::Append an Element child at the current insertion point:::w0->w1->w2->w3->println->ourslot->appendNode->if
DTMDocumentImpl#appendNSDeclaration(int, int, boolean):::Append a Namespace Declaration child at the current insertion point:::namespaceForNamespaces->m_nsNames->stringToIndex->w0->m_nsNames->stringToIndex->w1->w2->w3->ourslot->appendNode->return
DTMDocumentImpl#appendAttribute(int, int, int, boolean, int, int):::Append an Attribute child at the current insertion point:::w0->w1->w2->w3->println->ourslot->appendNode->appendNode->return
DTMDocumentImpl#getAxisTraverser(int):::This returns a stateless "traverser", that can navigate over an XPath axis, though not in document order.:::return
DTMDocumentImpl#getAxisIterator(int):::This is a shortcut to the iterators that implement the supported XPath axes (only namespace::) is not supported:::return
DTMDocumentImpl#getTypedAxisIterator(int, int):::Get an iterator that can navigate over an XPath Axis, predicated by the extended type ID.:::return
DTMDocumentImpl#appendEndElement():::Terminate the element currently acting as an insertion point:::if->nodes->writeEntry->nodes->readSlot
DTMDocumentImpl#appendStartDocument()::: Starting a new document:::initDocument
DTMDocumentImpl#appendEndDocument()::: All appends to this document have finished; do whatever final cleanup is needed.:::
DTMDocumentImpl#setProperty(String, Object):::For the moment all the run time properties are ignored by this class.:::
DTMDocumentImpl#getSourceLocatorFor(int):::Source information is not handled yet, so return null here.:::return
DTMDocumentImpl#documentRegistration():::A dummy routine to satisify the abstract interface:::
DTMDocumentImpl#documentRelease():::A dummy routine to satisify the abstract interface:::
DTMDocumentImpl#migrateTo(DTMManager):::Migrate a DTM built with an old DTMManager to a new DTMManager:::
DTMManagerDefault#addDTM(DTM, int):::Add a DTM to the DTM table:::addDTM
DTMManagerDefault#addDTM(DTM, int, int):::Add a DTM to the DTM table.:::if->throw->XMLMessages->createXMLMessage->new->DTMException->oldlen->if->newlen->Math->min->new_m_dtms->new->DTMArr->System->arraycopy->new_m_dtm_offsets->new->intArr->System->arraycopy->dtm->documentRegistration
DTMManagerDefault#getFirstFreeDTMID():::Get the first free DTM ID available:::n->for->i->return
DTMManagerDefault#getDTM(Source, boolean, DTMWSFilter, boolean, boolean):::Get an instance of a DTM, loaded with the content from the specified source:::if->source->getSystemId->println->xstringFactory->dtmPos->getFirstFreeDTMID->documentID->if->dtm->new->DOM2DTM->addDTM->return->else->isSAXSource->isStreamSource->if->reader->dtm->try->xmlSource->if->else->getXMLReader->SAXSource->sourceToInputSource->urlOfSource->xmlSource->getSystemId->if->try->SystemIDResolver->getAbsoluteURI->catch->println->finally->xmlSource->setSystemId->if->new->SAX2RTFDTM->else->new->SAX2DTM->addDTM->haveXercesParser->reader->getClass->getName->equals->if->if->coParser->if->try->new->com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces->catch->ex->printStackTrace->finally->if->if->new->IncrementalSAXSource_Filter->else->filter->new->IncrementalSAXSource_Filter->filter->setXMLReader->dtm->setIncrementalSAXSource->if->return->if->reader->getErrorHandler->reader->setErrorHandler->reader->setDTDHandler->try->coParser->startParse->catch->dtm->clearCoRoutine->throw->dtm->clearCoRoutine->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally->else->if->return->reader->setContentHandler->reader->setDTDHandler->if->reader->getErrorHandler->reader->setErrorHandler->try->reader->setProperty->catch->finally->try->reader->parse->catch->dtm->clearCoRoutine->throw->dtm->clearCoRoutine->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally->if->println->dtm->dumpDTM->return->catch->finally->if->reader->setContentHandler->reader->setDTDHandler->reader->setErrorHandler->try->reader->setProperty->catch->finally->releaseXMLReader->else->throw->XMLMessages->new->ObjectArr->createXMLMessage->new->DTMException
DTMManagerDefault#getDTMHandleFromNode(org.w3c.dom.Node):::Given a W3C DOM node, try and return a DTM handle:::if->throw->XMLMessages->createXMLMessage->new->IllegalArgumentException->if->return->getDTMNodeNumber->else->max->for->i->root->p->root->getNodeType->getOwnerElement->root->getParentNode->for->p->getParentNode->dtm->new->javax.xml.transform.dom.DOMSource->getDTM->handle->if->dtm->getOwnerElement->getHandleOfNode->dtm->node->getNamespaceURI->node->getLocalName->getAttributeNode->else->dtm->getHandleOfNode->if->throw->XMLMessages->createXMLMessage->new->RuntimeException->return
DTMManagerDefault#getXMLReader(Source):::This method returns the SAX2 parser to use with the InputSource obtained from this URI:::try->reader->getXMLReader->if->if->XMLReaderManager->super->overrideDefaultParser->getInstance->m_readerManager->getXMLReader->return->catch->throw->se->getMessage->new->DTMException->finally
DTMManagerDefault#releaseXMLReader(XMLReader):::Indicates that the XMLReader object is no longer in use for the transform:::if->m_readerManager->releaseXMLReader
DTMManagerDefault#getDTM(int):::Return the DTM object containing a representation of this node.:::try->return->catch->if->return->else->throw->finally
DTMManagerDefault#getDTMIdentity(DTM):::Given a DTM, find the ID number in the DTM tables which addresses the start of the document:::if->dtmdb->if->dtmdb->getManager->return->dtmdb->getDTMIDs->elementAt->else->return->n->for->i->return
DTMManagerDefault#release(DTM, boolean):::Release the DTMManager's reference(s) to a DTM, making it unmanaged:::if->dtm->getDocumentBaseURI->println->if->clearCoRoutine->if->ids->getDTMIDs->for->i->ids->size->else->i->getDTMIdentity->if->dtm->documentRelease->return
DTMManagerDefault#createDocumentFragment():::Method createDocumentFragment   NEEDSDOC (createDocumentFragment) @return:::try->dbf->JdkXmlUtils->super->overrideDefaultParser->getDOMFactory->db->dbf->newDocumentBuilder->doc->db->newDocument->df->doc->createDocumentFragment->return->new->DOMSource->getDTM->catch->throw->new->DTMException->finally
DTMManagerDefault#createDTMIterator(int, DTMFilter, boolean):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param whatToShow NEEDSDOC @param filter NEEDSDOC @param entityReferenceExpansion  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(String, PrefixResolver):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param xpathString NEEDSDOC @param presolver  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(int):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param node  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(Object, int):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param xpathCompiler NEEDSDOC @param pos  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#getExpandedNameTable(DTM):::return the expanded name table:::return
DTMNamedNodeMap#getLength():::Return the number of Attributes on this Element:::if->count->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#getNamedItem(String):::Retrieves a node specified by name.:::for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#item(int):::Returns the indexth item in the map:::count->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#setNamedItem(Node):::Adds a node using its nodeName attribute:::throw->new->DTMException
DTMNamedNodeMap#removeNamedItem(String):::Removes a node specified by name:::throw->new->DTMException
DTMNamedNodeMap#getNamedItemNS(String, String):::Retrieves a node specified by local name and namespace URI:::retNode->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#setNamedItemNS(Node):::Adds a node using its namespaceURI and localName:::throw->new->DTMException
DTMNamedNodeMap#removeNamedItemNS(String, String):::Removes a node specified by local name and namespace URI:::throw->new->DTMException
DTMNodeIterator#getDTMIterator():::Access the wrapped DTMIterator:::return
DTMNodeIterator#detach():::Detaches the NodeIterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::
DTMNodeIterator#getExpandEntityReferences():::The value of this flag determines whether the children of entity reference nodes are visible to the iterator.:::return
DTMNodeIterator#getFilter():::Return a handle to the filter used to screen nodes:::throw->new->DTMDOMException
DTMNodeIterator#getWhatToShow():::Return a mask describing which node types are presented via the iterator.:::return->dtm_iter->getWhatToShow
DTMNodeList#getDTMIterator():::Access the wrapped DTMIterator:::return
DTMNodeList#item(int):::Returns the indexth item in the collection:::if->handle->m_iter->item->if->return->return->m_iter->getDTM->getNode->else->return
DTMNodeList#getLength():::The number of nodes in the list:::return->m_iter->getLength
DTMNodeListBase#item(int):::Returns the indexth item in the collection:::return
DTMNodeListBase#getLength():::The number of nodes in the list:::return
DTMNodeProxy#getDTM():::NON-DOM: Return the DTM model:::return
DTMNodeProxy#getDTMNodeNumber():::NON-DOM: Return the DTM node number:::return
DTMNodeProxy#equals(Node):::Test for equality based on node number.:::try->dtmp->return->catch->return->finally
DTMNodeProxy#equals(Object):::Test for equality based on node number.:::return->equals
DTMNodeProxy#sameNodeAs(Node):::FUTURE DOM: Test node identity, in lieu of Node==Node:::if->return->that->return
DTMNodeProxy#getTarget():::A PI's "target" states what processor channel the PI's data should be directed to:::return->dtm->getNodeName
DTMNodeProxy#supports(String, String):::Ask whether we support a given DOM feature:::return->implementation->hasFeature
DTMNodeProxy#isSupported(String, String):::Ask whether we support a given DOM feature:::return->implementation->hasFeature
DTMNodeProxy#hasAttribute(String):::Method hasAttribute:::return->dtm->getAttributeNode
DTMNodeProxy#hasAttributeNS(String, String):::Method hasAttributeNS:::return->dtm->getAttributeNode
DTMNodeProxy#getDocumentElement():::This is a bit of a problem in DTM, since a DTM may be a Document Fragment and hence not have a clear-cut Document Element:::dochandle->dtm->getDocument->elementhandle->for->kidhandle->dtm->getFirstChild->dtm->getNextSibling->if->throw->new->DTMDOMException->else->return->dtm->getNode
DTMNodeProxy#hasAttributes():::Introduced in DOM Level 2.:::return->dtm->getFirstAttribute
DTMNodeProxy#getOwnerElement():::Get the owner element of an attribute.:::if->getNodeType->return->newnode->dtm->getParent->return->dtm->getNode
DTMNodeProxy#adoptNode(Node):::NEEDSDOC Method adoptNode   NEEDSDOC @param source  NEEDSDOC (adoptNode) @return:::throw->new->DTMDOMException
DTMNodeProxy#getInputEncoding():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setEncoding(String):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getStandalone():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setStandalone(boolean):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getStrictErrorChecking():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setStrictErrorChecking(boolean):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getVersion():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setVersion(String):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy.DTMNodeProxyImplementation#hasFeature(String, String):::Ask whether we support a given DOM feature:::if->feature->toUpperCase->equals->feature->toUpperCase->equals->equals->equals->return->return
DTMNodeProxy.DTMNodeProxyImplementation#getFeature(String, String)::: This method returns a specialized object which implements the specialized APIs of the specified feature and version:::return
DTMNodeProxy#getUserData(String):::Retrieves the object associated to a key on a this node:::return->getOwnerDocument->getUserData
DTMNodeProxy#getFeature(String, String)::: This method returns a specialized object which implements the specialized APIs of the specified feature and version:::return->isSupported
DTMNodeProxy#isEqualNode(Node):::Tests whether two nodes are equal:::if->return->if->arg->getNodeType->getNodeType->return->if->getNodeName->if->arg->getNodeName->return->else->if->getNodeName->arg->getNodeName->equals->return->if->getLocalName->if->arg->getLocalName->return->else->if->getLocalName->arg->getLocalName->equals->return->if->getNamespaceURI->if->arg->getNamespaceURI->return->else->if->getNamespaceURI->arg->getNamespaceURI->equals->return->if->getPrefix->if->arg->getPrefix->return->else->if->getPrefix->arg->getPrefix->equals->return->if->getNodeValue->if->arg->getNodeValue->return->else->if->getNodeValue->arg->getNodeValue->equals->return->return
DTMNodeProxy#lookupNamespaceURI(String):::DOM Level 3 Look up the namespace URI associated to the given prefix, starting from this node:::type->this->getNodeType->switch->namespace->this->getNamespaceURI->prefix->this->getPrefix->if->if->return->else->if->prefix->equals->return->if->this->hasAttributes->map->this->getAttributes->length->map->getLength->for->i->return->return->if->this->getOwnerElement->getNodeType->return->getOwnerElement->lookupNamespaceURI->return->return
DTMNodeProxy#isDefaultNamespace(String)::: DOM Level 3  This method checks if the specified namespaceURI is the  default namespace or not.:::return
DTMNodeProxy#lookupPrefix(String):::DOM Level 3 Look up the prefix associated to the given namespace URI, starting from this node.:::if->return->type->this->getNodeType->switch->return->if->this->getOwnerElement->getNodeType->return->getOwnerElement->lookupPrefix->return->return
DTMNodeProxy#isSameNode(Node):::Returns whether this node is the same node as the given one:::return
DTMNodeProxy#setTextContent(String):::This attribute returns the text content of this node and its descendants:::setNodeValue
DTMNodeProxy#getTextContent():::This attribute returns the text content of this node and its descendants:::return->dtm->getStringValue->toString
DTMNodeProxy#compareDocumentPosition(Node):::Compares a node with this node with regard to their position in the document.:::return
DTMNodeProxy#getBaseURI():::The absolute base URI of this node or null if undefined:::return
DTMNodeProxy#renameNode(Node, String, String):::DOM Level 3 Renaming node:::return
DTMNodeProxy#normalizeDocument()::: DOM Level 3  Normalize document.:::
DTMNodeProxy#getDomConfig():::The configuration used when Document.normalizeDocument is invoked.:::return
DTMNodeProxy#setDocumentURI(String):::DOM Level 3:::
DTMNodeProxy#getDocumentURI():::DOM Level 3 The location of the document or null if undefined:::return
DTMNodeProxy#getActualEncoding():::DOM Level 3 An attribute specifying the actual encoding of this document:::return
DTMNodeProxy#setActualEncoding(String):::DOM Level 3 An attribute specifying the actual encoding of this document:::
DTMNodeProxy#replaceWholeText(String):::DOM Level 3:::return
DTMNodeProxy#getWholeText():::DOM Level 3 Returns all text of Text nodes logically-adjacent text nodes to this node, concatenated in document order.:::return
DTMNodeProxy#isElementContentWhitespace():::DOM Level 3 Returns whether this text node contains whitespace in element content, often abusively called "ignorable whitespace".:::return
DTMNodeProxy#setIdAttribute(boolean):::NON-DOM: set the type of this attribute to be ID type.:::
DTMNodeProxy#setIdAttribute(String, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#setIdAttributeNode(Attr, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#setIdAttributeNS(String, String, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#getSchemaTypeInfo():::Method getSchemaTypeInfo.:::return
DTMSafeStringPool#_main(String[]):::Command-line unit test driver:::word->pool->new->DTMSafeStringPool->println->for->pass
DTMStringPool#_main(String[]):::Command-line unit test driver:::word->pool->new->DTMStringPool->println->for->pass
DTMTreeWalker#setDTM(DTM):::Set the DTM to be traversed.:::
DTMTreeWalker#getcontentHandler():::Get the ContentHandler used for the tree walk.:::return
DTMTreeWalker#setcontentHandler(ContentHandler):::Set the ContentHandler used for the tree walk.:::
DTMTreeWalker#traverse(int):::Perform a non-recursive pre-order/post-order traversal, operating as a Visitor:::top->while->startNode->nextNode->m_dtm->getFirstChild->while->endNode->if->break->m_dtm->getNextSibling->if->m_dtm->getParent->if->if->endNode->break
DTMTreeWalker#traverse(int, int):::Perform a non-recursive pre-order/post-order traversal, operating as a Visitor:::while->startNode->nextNode->m_dtm->getFirstChild->while->endNode->if->break->m_dtm->getNextSibling->if->m_dtm->getParent->if->break
DTMTreeWalker#startNode(int):::Start processing given node:::if->switch->m_dtm->getNodeType->data->m_dtm->getStringValue->if->lh->data->dispatchAsComment->break->break->startDocument->break->dtm->for->nsn->dtm->getFirstNamespaceNode->dtm->getNextNamespaceNode->ns->dtm->getNamespaceURI->if->attrs->new->org.xml.sax.helpers.AttributesImpl->for->i->dtm->getFirstAttribute->dtm->getNextAttribute->m_dtm->getLocalName->m_dtm->getNodeName->startElement->break->name->m_dtm->getNodeName->if->name->equals->else->m_dtm->getNodeValue->processingInstruction->break->isLexH->lh->if->lh->startCDATA->dispatachChars->if->lh->endCDATA->break->if->m_contentHandler->processingInstruction->dispatachChars->m_contentHandler->processingInstruction->else->dispatachChars->break->if->m_dtm->getNodeName->startEntity->else->break
DTMTreeWalker#endNode(int):::End processing of given node:::switch->m_dtm->getNodeType->endDocument->break->ns->m_dtm->getNamespaceURI->if->m_dtm->getLocalName->m_dtm->getNodeName->endElement->for->nsn->m_dtm->getFirstNamespaceNode->m_dtm->getNextNamespaceNode->break->break->if->lh->lh->m_dtm->getNodeName->endEntity->break
ExpandedNameTable#getExpandedTypeID(String, String, int):::Given an expanded name represented by namespace, local name and node type, return an ID:::return->getExpandedTypeID
ExpandedNameTable#getExpandedTypeID(String, String, int, boolean):::Given an expanded name represented by namespace, local name and node type, return an ID:::if->if->hash->namespace->hashCode->localName->hashCode->hashET->redefine->index->if->for->e->if->return->if->rehash->if->newET->new->ExtendedType->if->newArray->new->ExtendedTypeArr->System->arraycopy->entry->new->HashEntry->return
ExpandedNameTable#getExpandedTypeID(int):::Given a type, return an expanded name ID.Any additional nodes that are created that have this expanded name will use this ID.:::return
ExpandedNameTable#getLocalName(int):::Given an expanded-name ID, return the local name part.:::return->getLocalName
ExpandedNameTable#getLocalNameID(int):::Given an expanded-name ID, return the local name ID.:::if->getLocalName->equals->return->else->return
ExpandedNameTable#getNamespace(int):::Given an expanded-name ID, return the namespace URI part.:::namespace->getNamespace->return->namespace->equals
ExpandedNameTable#getNamespaceID(int):::Given an expanded-name ID, return the namespace URI ID.:::if->getNamespace->equals->return->else->return
ExpandedNameTable#getType(int):::Given an expanded-name ID, return the local name ID.:::return->getNodeType
ExpandedNameTable#getSize():::Return the size of the ExpandedNameTable:::return
ExpandedNameTable#getExtendedTypes():::Return the array of extended types:::return
ExtendedType#redefine(int, String, String):::Redefine this ExtendedType object to represent a different extended type:::namespace->hashCode->localName->hashCode
ExtendedType#redefine(int, String, String, int):::Redefine this ExtendedType object to represent a different extended type:::
ExtendedType#hashCode():::Override the hashCode() method in the Object class:::return
ExtendedType#equals(ExtendedType):::Test if this ExtendedType object is equal to the given ExtendedType.:::try->return->equals->equals->catch->return->finally
ExtendedType#getNodeType():::Return the node type:::return
ExtendedType#getLocalName():::Return the local name:::return
ExtendedType#getNamespace():::Return the namespace:::return
IncrementalSAXSource#setContentHandler(ContentHandler):::Register a SAX-style content handler for us to output to:::
IncrementalSAXSource#setLexicalHandler(org.xml.sax.ext.LexicalHandler)::: Register a SAX-style lexical handler for us to output to:::
IncrementalSAXSource#setDTDHandler(org.xml.sax.DTDHandler)::: Register a SAX-style DTD handler for us to output to:::
IncrementalSAXSource#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the thread in which the IncrementalSAXSource is running to deliver more events (true), or stop delivering events and close out its input (false):::
IncrementalSAXSource#startParse(InputSource):::Launch an XMLReader's parsing operation, feeding events to this IncrementalSAXSource:::
IncrementalSAXSource_Filter#setXMLReader(XMLReader):::Bind our input streams to an XMLReader:::eventsource->setContentHandler->eventsource->setDTDHandler->eventsource->setErrorHandler->try->eventsource->setProperty->catch->finally
IncrementalSAXSource_Filter#count_and_yield(boolean):::In the SAX delegation code, I've inlined the count-down in the hope of encouraging compilers to deliver better performance:::if->if->co_yield
IncrementalSAXSource_Filter#startParse(InputSource):::Launch a thread that will run an XMLReader's parse() operation within  a thread, feeding events to this IncrementalSAXSource_Filter:::if->throw->XMLMessages->createXMLMessage->new->SAXException->if->throw->XMLMessages->createXMLMessage->new->SAXException->ThreadControllerWrapper->runThread
IncrementalSAXSource_Filter#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the coroutine parser that we need more nodes:::if->return->try->result->fCoroutineManager->co_resume->if->fCoroutineManager->co_exit->return->catch->return->finally
IncrementalSAXSource_Xerces#startParse(InputSource):::startParse() is a simple API which tells the IncrementalSAXSource to begin reading a document.:::if->throw->XMLMessages->createXMLMessage->new->SAXException->if->throw->XMLMessages->createXMLMessage->new->SAXException->ok->try->parseSomeSetup->catch->throw->new->SAXException->finally->if->throw->XMLMessages->createXMLMessage->new->SAXException
IncrementalSAXSource_Xerces#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the coroutine parser that we need more nodes:::if->return->arg->try->keepgoing->parseSome->catch->new->SAXException->finally->return
IncrementalSAXSource_Xerces#_main(String[]):::Simple unit test:::println->co->new->CoroutineManager->appCoroutineID->co->co_joinCoroutineSet->if->println->return->parser->createIncrementalSAXSource->trace->new->com.sun.org.apache.xml.internal.serialize.XMLSerializer->parser->setContentHandler->parser->setLexicalHandler->for->arg
NodeLocator#getPublicId():::getPublicId returns the public ID of the node.:::return
NodeLocator#getSystemId():::getSystemId returns the system ID of the node.:::return
NodeLocator#getLineNumber():::getLineNumber returns the line number of the node.:::return
NodeLocator#getColumnNumber():::getColumnNumber returns the column number of the node.:::return
NodeLocator#toString():::toString returns a string representation of this NodeLocator instance.:::return
