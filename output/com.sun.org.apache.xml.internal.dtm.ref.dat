ChunkedIntArray#appendSlot(int, int, int, int):::Append a 4-integer record to the CIA, starting with record 1:::slotsize->newoffset->chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt->return
ChunkedIntArray#readEntry(int, int):::Retrieve an integer from the CIA by record number and column within the record, both 0-based (though position 0 is reserved for special purposes).:::if->throw->XMLMessages->createXMLMessage->new->ArrayIndexOutOfBoundsException->chunkpos->slotpos->chunk->chunks->elementAt->return
ChunkedIntArray#specialFind(int, int)::: chunked int array special find:::ancestor->while->chunkpos->slotpos->chunk->chunks->elementAt->if->break->if->return->return
ChunkedIntArray#slotsUsed()::: chunked int array slots used:::return
ChunkedIntArray#discardLast():::Disard the highest-numbered record:::
ChunkedIntArray#writeEntry(int, int, int):::Overwrite the integer found at a specific record and column:::if->throw->XMLMessages->createXMLMessage->new->ArrayIndexOutOfBoundsException->chunkpos->slotpos->chunk->chunks->elementAt
ChunkedIntArray#writeSlot(int, int, int, int, int):::Overwrite an entire (4-integer) record at the specified index:::chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt
ChunkedIntArray#readSlot(int, int[]):::Retrieve the contents of a record into a user-supplied buffer array:::chunkpos->slotpos->if->chunks->size->chunks->new->intArr->addElement->chunk->chunks->elementAt->System->arraycopy
ChunkedIntArray.ChunksVector#size()::: chunks vector size:::return
ChunkedIntArray.ChunksVector#addElement(int[])::: chunks vector add element:::if->orgMapSize->while->newMap->new->intArrs->System->arraycopy
ChunkedIntArray.ChunksVector#elementAt(int)::: chunks vector element at:::return
CoroutineManager#co_joinCoroutineSet(int):::Each coroutine in the set managed by a single CoroutineManager is identified by a small positive integer:::if->if->m_activeIDs->get->return->else->while->if->m_activeIDs->get->else->break->if->return->m_activeIDs->set->return
CoroutineManager#co_entry_pause(int):::In the standard coroutine architecture, coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them; its's presumed that this recognizes the not-already-running case and does the right thing:::if->m_activeIDs->get->throw->new->java.lang.NoSuchMethodException->while->try->wait->catch->finally->return
CoroutineManager#co_resume(Object, int, int):::Transfer control to another coroutine which has already been started and is waiting on this CoroutineManager:::if->m_activeIDs->get->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->java.lang.NoSuchMethodException->notify->while->try->wait->catch->finally->if->co_exit->throw->XMLMessages->createXMLMessage->new->java.lang.NoSuchMethodException->return
CoroutineManager#co_exit(int):::Terminate this entire set of coroutines:::m_activeIDs->clear->notify
CoroutineManager#co_exit_to(Object, int, int):::Make the ID available for reuse and terminate this coroutine, transferring control to the specified coroutine:::if->m_activeIDs->get->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->java.lang.NoSuchMethodException->m_activeIDs->clear->notify
CoroutineParser#getParserCoroutineID()::: coroutine parser get parser coroutine d:::
CoroutineParser#getCoroutineManager()::: coroutine parser get coroutine manager:::
CoroutineParser#setContentHandler(ContentHandler):::Register a SAX-style content handler for us to output to:::
CoroutineParser#setLexHandler(org.xml.sax.ext.LexicalHandler)::: Register a SAX-style lexical handler for us to output to  Not all parsers support this..:::
CoroutineParser#doParse(InputSource, int):::doParse() is a simple API which tells the coroutine parser to begin reading from a file:::
CoroutineParser#doMore(boolean, int):::doMore() is a simple API which tells the coroutine parser that we need more nodes:::
CoroutineParser#doTerminate(int):::doTerminate() is a simple API which tells the coroutine parser to terminate itself:::
CoroutineParser#init(CoroutineManager, int, XMLReader):::Initialize the coroutine parser:::
CustomStringPool#removeAllElements()::: custom string pool remove all elements:::m_intToString->clear->if->m_stringToInt->clear
CustomStringPool#indexToString(int)::: custom string pool index to string:::return->m_intToString->get
CustomStringPool#stringToIndex(String)::: custom string pool string to index:::if->return->iobj->m_stringToInt->get->if->m_intToString->add->m_intToString->size->m_stringToInt->put->return
DTMAxisIteratorBase#getStartNode():::Get start to END should 'close' the iterator, i.e:::return
DTMAxisIteratorBase#reset()::: axis iterator base reset:::temp->setStartNode->return
DTMAxisIteratorBase#includeSelf():::Set the flag to include the start node in the iteration.:::return
DTMAxisIteratorBase#getLast():::Returns the position of the last node within the iteration, as defined by XPath:::if->temp->setMark->reset->do->while->next->gotoMark->return
DTMAxisIteratorBase#getPosition()::: axis iterator base get position:::return
DTMAxisIteratorBase#isReverse()::: axis iterator base is reverse:::return
DTMAxisIteratorBase#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->return->catch->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally
DTMAxisIteratorBase#returnNode(int):::Do any final cleanup that is required before returning the node that was passed in, and then return it:::return
DTMAxisIteratorBase#resetPosition():::Reset the position to zero:::return
DTMAxisIteratorBase#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order.:::return
DTMAxisIteratorBase#getAxis():::Returns the axis being iterated, if it is known.:::return
DTMAxisIteratorBase#setRestartable(boolean)::: axis iterator base set restartable:::
DTMAxisIteratorBase#getNodeByPosition(int):::Return the node at the given position.:::if->pos->isReverse->getLast->node->while->next->if->getPosition->return->return
DTMAxisIterNodeList#getDTMAxisIterator():::Access the wrapped DTMIterator:::return
DTMAxisIterNodeList#item(int):::Returns the indexth item in the collection:::if->node->count->m_cachedNodes->size->if->m_cachedNodes->elementAt->return->m_dtm->getNode->else->if->while->m_iter->next->m_cachedNodes->addElement->if->else->return->m_dtm->getNode->return
DTMAxisIterNodeList#getLength():::The number of nodes in the list:::if->node->while->m_iter->next->m_cachedNodes->addElement->m_cachedNodes->size->return
DTMChildIterNodeList#item(int):::Returns the indexth item in the collection:::handle->while->m_parentDTM->getNextSibling->if->return->return->m_parentDTM->getNode
DTMChildIterNodeList#getLength():::The number of nodes in the list:::count->for->handle->m_parentDTM->getNextSibling->return
DTMDefaultBase#ensureSizeOfIndex(int, int):::Ensure that the size of the element indexes can hold the information.:::if->new->intArrs->else->if->indexes->new->intArrs->System->arraycopy->localNameIndex->if->new->intArrs->else->if->indexes->new->intArrs->System->arraycopy->elemHandles->if->new->intArr->else->if->indexes->new->intArr->System->arraycopy
DTMDefaultBase#indexNode(int, int):::Add a node to the element indexes:::ent->type->ent->getType->if->namespaceID->ent->getNamespaceID->localNameID->ent->getLocalNameID->ensureSizeOfIndex->index
DTMDefaultBase#findGTE(int[], int, int, int):::Find the first index that occurs in the list that is greater than or equal to the given value.:::low->high->end->while->mid->c->if->else->if->else->return->return
DTMDefaultBase#findElementFromIndex(int, int, int):::Find the first matching element from the index at or after the given node.:::indexes->if->lnIndexs->if->elems->if->pos->findGTE->if->return->return
DTMDefaultBase#getNextNodeIdentity(int):::Get the next node identity value in the list, and call the iterator if it hasn't been added yet.:::
DTMDefaultBase#nextNode():::This method should try and build one or more nodes in the table.:::
DTMDefaultBase#getNumberOfNodes():::Get the number of nodes that have been added.:::
DTMDefaultBase#_type(int):::Get the simple type ID for the given node identity.:::info->_exptype->if->return->m_expandedNameTable->getType->else->return
DTMDefaultBase#_exptype(int):::Get the expanded type ID for the given node identity.:::if->return->while->if->nextNode->return->return->m_exptype->elementAt
DTMDefaultBase#_level(int):::Get the level in the tree for the given node identity.:::while->isMore->nextNode->if->return->i->while->_parent->return
DTMDefaultBase#_firstch(int):::Get the first child for the given node identity.:::info->m_firstch->elementAt->while->isMore->nextNode->if->return->else->m_firstch->elementAt->if->return->return
DTMDefaultBase#_nextsib(int):::Get the next sibling for the given node identity.:::info->m_nextsib->elementAt->while->isMore->nextNode->if->return->else->m_nextsib->elementAt->if->return->return
DTMDefaultBase#_prevsib(int):::Get the previous sibling for the given node identity.:::if->return->m_prevsib->elementAt->while->isMore->nextNode->if->return->else->if->return->m_prevsib->elementAt
DTMDefaultBase#_parent(int):::Get the parent for the given node identity.:::if->return->m_parent->elementAt->while->isMore->nextNode->if->return->else->if->return->m_parent->elementAt
DTMDefaultBase#dumpDTM(OutputStream):::Diagnostics function to dump the DTM.:::try->if->f->hashCode->new->File->f->getAbsolutePath->println->new->FileOutputStream->ps->new->PrintStream->while->nextNode->nRecords->ps->println->for->index->catch->ioe->printStackTrace->throw->ioe->getMessage->new->RuntimeException->finally
DTMDefaultBase#dumpNode(int):::Diagnostics function to dump a single node:::if->return->typestring->switch->getNodeType->break->break->break->break->break->break->break->break->break->break->break->break->break->break->break->return->Integer->getExpandedTypeID->toHexString->getNodeNameX->getNamespaceURI->getNodeValue
DTMDefaultBase#setFeature(String, boolean):::Set an implementation dependent feature:::
DTMDefaultBase#hasChildNodes(int):::Given a node handle, test if it has child nodes:::identity->makeNodeIdentity->firstChild->_firstch->return
DTMDefaultBase#makeNodeHandle(int):::Given a node identity, return a node handle:::if->return->if->println->return->m_dtmIdent->elementAt
DTMDefaultBase#makeNodeIdentity(int):::Given a node handle, return a node identity:::if->return->if->whichDTMindex->if->return->else->return->whichDTMid->m_dtmIdent->indexOf->return
DTMDefaultBase#getFirstChild(int):::Given a node handle, get the handle of the node's first child:::identity->makeNodeIdentity->firstChild->_firstch->return->makeNodeHandle
DTMDefaultBase#getTypedFirstChild(int, int):::Given a node handle, get the handle of the node's first child:::firstChild->eType->if->for->makeNodeIdentity->_firstch->_nextsib->else->for->makeNodeIdentity->_firstch->_nextsib->return
DTMDefaultBase#getLastChild(int):::Given a node handle, advance to its last child:::identity->makeNodeIdentity->child->_firstch->lastChild->while->_nextsib->return->makeNodeHandle
DTMDefaultBase#getAttributeNode(int, String, String):::Retrieves an attribute node by by qualified name and namespace URI.:::
DTMDefaultBase#getFirstAttribute(int):::Given a node handle, get the index of the node's first attribute.:::nodeID->makeNodeIdentity->return->getFirstAttributeIdentity->makeNodeHandle
DTMDefaultBase#getFirstAttributeIdentity(int):::Given a node identity, get the index of the node's first attribute.:::type->_type->if->while->getNextNodeIdentity->_type->if->return->else->if->break->return
DTMDefaultBase#getTypedAttribute(int, int):::Given a node handle and an expanded type ID, get the index of the node's attribute of that type, if any.:::type->getNodeType->if->identity->makeNodeIdentity->while->getNextNodeIdentity->_type->if->if->_exptype->return->makeNodeHandle->else->if->break->return
DTMDefaultBase#getNextSibling(int):::Given a node handle, advance to its next sibling:::if->return->return->makeNodeIdentity->_nextsib->makeNodeHandle
DTMDefaultBase#getTypedNextSibling(int, int):::Given a node handle, advance to its next sibling:::if->return->node->makeNodeIdentity->eType->while->_nextsib->_exptype->m_expandedNameTable->getType->return->makeNodeHandle
DTMDefaultBase#getPreviousSibling(int):::Given a node handle, find its preceeding sibling:::if->return->if->return->makeNodeIdentity->_prevsib->makeNodeHandle->else->nodeID->makeNodeIdentity->parent->_parent->node->_firstch->result->while->_nextsib->return->makeNodeHandle
DTMDefaultBase#getNextAttribute(int):::Given a node handle, advance to the next attribute:::nodeID->makeNodeIdentity->if->_type->return->getNextAttributeIdentity->makeNodeHandle->return
DTMDefaultBase#getNextAttributeIdentity(int):::Given a node identity for an attribute, advance to the next attribute.:::while->getNextNodeIdentity->type->_type->if->return->else->if->break->return
DTMDefaultBase#declareNamespaceInContext(int, int):::Build table of namespace declaration locations during DTM construction:::nsList->if->new->SuballocatedIntVector->m_namespaceDeclSetElements->addElement->new->Vector<>->new->SuballocatedIntVector->m_namespaceDeclSets->add->else->last->m_namespaceDeclSetElements->size->if->m_namespaceDeclSetElements->elementAt->m_namespaceDeclSets->get->if->m_namespaceDeclSetElements->addElement->inherited->_parent->findNamespaceContext->if->isize->inherited->size->Math->Math->min->max->new->SuballocatedIntVector->for->i->else->new->SuballocatedIntVector->m_namespaceDeclSets->add->newEType->_exptype->for->i->nsList->size->nsList->makeNodeHandle->addElement
DTMDefaultBase#findNamespaceContext(int):::Retrieve list of namespace declaration locations active at this node:::if->wouldBeAt->findInSortedSuballocatedIntVector->if->return->m_namespaceDeclSets->get->if->return->candidate->m_namespaceDeclSetElements->elementAt->ancestor->_parent->if->rootHandle->makeNodeHandle->getDocumentRoot->rootID->makeNodeIdentity->uppermostNSCandidateID->if->getNodeType->ch->_firstch->else->if->return->m_namespaceDeclSets->get->while->if->return->m_namespaceDeclSets->get->else->if->do->_parent->while->else->if->m_namespaceDeclSetElements->elementAt->else->break->return
DTMDefaultBase#findInSortedSuballocatedIntVector(SuballocatedIntVector, int):::Subroutine: Locate the specified node within m_namespaceDeclSetElements, or the last element which preceeds it in document order  %REVIEW% Inlne this into findNamespaceContext? Create SortedSuballocatedIntVector type?:::i->if->first->last->vector->size->while->test->vector->elementAt->if->return->else->if->else->if->return
DTMDefaultBase#getFirstNamespaceNode(int, boolean):::Given a node handle, get the index of the node's first child:::if->identity->makeNodeIdentity->if->_type->nsContext->findNamespaceContext->if->nsContext->size->return->return->nsContext->elementAt->else->return->else->identity->makeNodeIdentity->if->_type->while->getNextNodeIdentity->type->_type->if->return->makeNodeHandle->else->if->break->return->else->return
DTMDefaultBase#getNextNamespaceNode(int, int, boolean):::Given a namespace handle, advance to the next namespace.:::if->nsContext->makeNodeIdentity->findNamespaceContext->if->return->i->nsContext->indexOf->if->nsContext->size->return->return->nsContext->elementAt->else->identity->makeNodeIdentity->while->getNextNodeIdentity->type->_type->if->return->makeNodeHandle->else->if->break->return
DTMDefaultBase#getParent(int):::Given a node handle, find its parent node.:::identity->makeNodeIdentity->if->return->_parent->makeNodeHandle->else->return
DTMDefaultBase#getDocument():::Find the Document node handle for the document currently under construction:::return->m_dtmIdent->elementAt
DTMDefaultBase#getOwnerDocument(int):::Given a node handle, find the owning document node:::if->getNodeType->return->return->getDocumentRoot
DTMDefaultBase#getDocumentRoot(int):::Given a node handle, find the owning document node:::return->getManager->getDTM->getDocument
DTMDefaultBase#getStringValue(int):::Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value).:::
DTMDefaultBase#getStringValueChunkCount(int):::Get number of character array chunks in the string-value of a node:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getStringValueChunk(int, int, int[]):::Get a character array chunk in the string-value of a node:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getExpandedTypeID(int):::Given a node handle, return an ID that represents the node's expanded name.:::id->makeNodeIdentity->if->return->return->_exptype
DTMDefaultBase#getExpandedTypeID(String, String, int):::Given an expanded name, return an ID:::ent->return->ent->getExpandedTypeID
DTMDefaultBase#getLocalNameFromExpandedNameID(int):::Given an expanded-name ID, return the local name part.:::return->m_expandedNameTable->getLocalName
DTMDefaultBase#getNamespaceFromExpandedNameID(int):::Given an expanded-name ID, return the namespace URI part.:::return->m_expandedNameTable->getNamespace
DTMDefaultBase#getNamespaceType(int):::Returns the namespace type of a specific node:::identity->makeNodeIdentity->expandedNameID->_exptype->return->m_expandedNameTable->getNamespaceID
DTMDefaultBase#getNodeName(int):::Given a node handle, return its DOM-style node name:::
DTMDefaultBase#getNodeNameX(int):::Given a node handle, return the XPath node name:::XMLMessages->createXMLMessage->error->return
DTMDefaultBase#getLocalName(int):::Given a node handle, return its XPath-style localname:::
DTMDefaultBase#getPrefix(int):::Given a namespace handle, return the prefix that the namespace decl is mapping:::
DTMDefaultBase#getNamespaceURI(int):::Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.)  %REVIEW% Null or ""? -sb:::
DTMDefaultBase#getNodeValue(int):::Given a node handle, return its node value:::
DTMDefaultBase#getNodeType(int):::Given a node handle, return its DOM-style node type:::if->return->return->m_expandedNameTable->makeNodeIdentity->_exptype->getType
DTMDefaultBase#getLevel(int):::Get the depth level of this node in the tree (equals 1 for a parentless node).:::identity->makeNodeIdentity->return->_level
DTMDefaultBase#getNodeIdent(int):::Get the identity of this node in the tree:::return->makeNodeIdentity
DTMDefaultBase#getNodeHandle(int):::Get the handle of this node in the tree:::return->makeNodeHandle
DTMDefaultBase#isSupported(String, String):::Tests whether DTM DOM implementation implements a specific feature and that feature is supported by this node.:::return
DTMDefaultBase#getDocumentBaseURI():::Return the base URI of the document entity:::return
DTMDefaultBase#setDocumentBaseURI(String):::Set the base URI of the document entity.:::
DTMDefaultBase#getDocumentSystemIdentifier(int):::Return the system identifier of the document entity:::return
DTMDefaultBase#getDocumentEncoding(int):::Return the name of the character encoding scheme        in which the document entity is expressed.:::return
DTMDefaultBase#getDocumentStandalone(int):::Return an indication of the standalone status of the document,        either "yes" or "no":::return
DTMDefaultBase#getDocumentVersion(int):::Return a string representing the XML version of the document:::return
DTMDefaultBase#getDocumentAllDeclarationsProcessed():::Return an indication of whether the processor has read the complete DTD:::return
DTMDefaultBase#getDocumentTypeDeclarationSystemIdentifier():::  A document type declaration information item has the following properties:      1:::
DTMDefaultBase#getDocumentTypeDeclarationPublicIdentifier():::Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]:::
DTMDefaultBase#getElementById(String):::Returns the Element whose ID is given by elementId:::
DTMDefaultBase#getUnparsedEntityURI(String):::The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]):::
DTMDefaultBase#supportsPreStripping():::Return true if the xsl:strip-space or xsl:preserve-space was processed during construction of the DTM document.:::return
DTMDefaultBase#isNodeAfter(int, int):::Figure out whether nodeHandle2 should be considered as being later in the document than nodeHandle1, in Document Order as defined by the XPath model:::index1->makeNodeIdentity->index2->makeNodeIdentity->return
DTMDefaultBase#isCharacterElementContentWhitespace(int):::    2:::return
DTMDefaultBase#isDocumentAllDeclarationsProcessed(int):::   10:::return
DTMDefaultBase#isAttributeSpecified(int):::    5:::
DTMDefaultBase#dispatchCharactersEvents(int, org.xml.sax.ContentHandler, boolean):::Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value):::
DTMDefaultBase#dispatchToEvents(int, org.xml.sax.ContentHandler):::Directly create SAX parser events from a subtree.:::
DTMDefaultBase#getNode(int):::Return an DOM node for the given node.:::return->new->DTMNodeProxy
DTMDefaultBase#appendChild(int, boolean, boolean):::Append a child to the end of the document:::XMLMessages->createXMLMessage->error
DTMDefaultBase#appendTextChild(String):::Append a text node child that will be constructed from a string, to the end of the document:::XMLMessages->createXMLMessage->error
DTMDefaultBase#error(String):::Simple error for asserts and the like.:::throw->new->DTMException
DTMDefaultBase#getShouldStripWhitespace():::Find out whether or not to strip whispace nodes.:::return
DTMDefaultBase#pushShouldStripWhitespace(boolean):::Set whether to strip whitespaces and push in current value of m_shouldStripWS in m_shouldStripWhitespaceStack.:::if->m_shouldStripWhitespaceStack->push
DTMDefaultBase#popShouldStripWhitespace():::Set whether to strip whitespaces at this point by popping out m_shouldStripWhitespaceStack.:::if->m_shouldStripWhitespaceStack->popAndTop
DTMDefaultBase#setShouldStripWhitespace(boolean):::Set whether to strip whitespaces and set the top of the stack to the current value of m_shouldStripWS.:::if->m_shouldStripWhitespaceStack->setTop
DTMDefaultBase#documentRegistration():::A dummy routine to satisify the abstract interface:::
DTMDefaultBase#documentRelease():::A dummy routine to satisify the abstract interface:::
DTMDefaultBase#migrateTo(DTMManager):::Migrate a DTM built with an old DTMManager to a new DTMManager:::if
DTMDefaultBase#getManager():::Query which DTMManager this DTM is currently being handled by:::return
DTMDefaultBase#getDTMIDs():::Query which DTMIDs this DTM is currently using within the DTMManager:::if->return->return
DTMDefaultBaseIterators#getTypedAxisIterator(int, int):::Get an iterator that can navigate over an XPath Axis, predicated by the extended type ID:::iterator->switch->new->TypedSingletonIterator->break->new->TypedChildrenIterator->break->return->new->ParentIterator->setNodeType->return->new->TypedAncestorIterator->return->new->TypedAncestorIterator->includeSelf->return->new->TypedAttributeIterator->new->TypedDescendantIterator->break->new->TypedDescendantIterator->includeSelf->break->new->TypedFollowingIterator->break->new->TypedPrecedingIterator->break->new->TypedFollowingSiblingIterator->break->new->TypedPrecedingSiblingIterator->break->new->TypedNamespaceIterator->break->new->TypedRootIterator->break->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDefaultBaseIterators#getAxisIterator(int):::This is a shortcut to the iterators that implement the XPath axes:::iterator->switch->new->SingletonIterator->break->new->ChildrenIterator->break->return->new->ParentIterator->return->new->AncestorIterator->return->new->AncestorIterator->includeSelf->return->new->AttributeIterator->new->DescendantIterator->break->new->DescendantIterator->includeSelf->break->new->FollowingIterator->break->new->PrecedingIterator->break->new->FollowingSiblingIterator->break->new->PrecedingSiblingIterator->break->new->NamespaceIterator->break->new->RootIterator->break->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDefaultBaseIterators.InternalAxisIteratorBase#setMark():::Remembers the current node for the next call to gotoMark():::
DTMDefaultBaseIterators.InternalAxisIteratorBase#gotoMark():::Restores the current node remembered by setMark():::
DTMDefaultBaseIterators.ChildrenIterator#setStartNode(int):::Setting start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch->return->resetPosition->return
DTMDefaultBaseIterators.ChildrenIterator#next():::Get the next node in the iteration.:::if->node->_nextsib->return->makeNodeHandle->returnNode->return
DTMDefaultBaseIterators.ParentIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getParent->return->resetPosition->return
DTMDefaultBaseIterators.ParentIterator#setNodeType(int):::Set the node type of the parent that we're looking for:::return
DTMDefaultBaseIterators.ParentIterator#next():::Get the next node in the iteration:::result->if->if->getExpandedTypeID->else->if->if->getNodeType->return->returnNode
DTMDefaultBaseIterators.TypedChildrenIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch->return->resetPosition->return
DTMDefaultBaseIterators.TypedChildrenIterator#next():::Get the next node in the iteration.:::eType->node->nodeType->if->while->_exptype->_nextsib->else->while->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->_nextsib->if->return->else->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.NamespaceChildrenIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceChildrenIterator#next():::Get the next node in the iteration.:::if->for->node->makeNodeIdentity->_firstch->_nextsib->_nextsib->return
DTMDefaultBaseIterators.NamespaceIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getFirstNamespaceNode->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceIterator#next():::Get the next node in the iteration.:::node->if->getNextNamespaceNode->return->returnNode
DTMDefaultBaseIterators.TypedNamespaceIterator#next():::Get the next node in the iteration.:::node->for->getNextNamespaceNode->return
DTMDefaultBaseIterators.RootIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocumentRoot->return->resetPosition->return
DTMDefaultBaseIterators.RootIterator#next():::Get the next node in the iteration.:::if->return->return->returnNode
DTMDefaultBaseIterators.TypedRootIterator#next():::Get the next node in the iteration.:::if->return->nodeType->node->expType->getExpandedTypeID->if->if->return->returnNode->else->if->if->return->returnNode->else->if->m_expandedNameTable->getType->return->returnNode->return
DTMDefaultBaseIterators.NamespaceAttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->getFirstNamespaceNode->return->resetPosition->return
DTMDefaultBaseIterators.NamespaceAttributeIterator#next():::Get the next node in the iteration.:::node->if->getNextNamespaceNode->return->returnNode
DTMDefaultBaseIterators.FollowingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->return->resetPosition->return
DTMDefaultBaseIterators.FollowingSiblingIterator#next():::Get the next node in the iteration.:::_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.TypedFollowingSiblingIterator#next():::Get the next node in the iteration.:::if->return->node->eType->nodeType->if->do->_nextsib->while->_exptype->else->while->_nextsib->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.AttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->getFirstAttributeIdentity->return->resetPosition->return
DTMDefaultBaseIterators.AttributeIterator#next():::Get the next node in the iteration.:::node->if->getNextAttributeIdentity->return->makeNodeHandle->returnNode->return
DTMDefaultBaseIterators.TypedAttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getTypedAttribute->return->resetPosition->return
DTMDefaultBaseIterators.TypedAttributeIterator#next():::Get the next node in the iteration.:::node->return->returnNode
DTMDefaultBaseIterators.PrecedingSiblingIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.PrecedingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->type->m_expandedNameTable->_exptype->getType->if->else->_parent->if->_firstch->else->return->resetPosition->return
DTMDefaultBaseIterators.PrecedingSiblingIterator#next():::Get the next node in the iteration.:::if->return->else->node->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.TypedPrecedingSiblingIterator#next():::Get the next node in the iteration.:::node->expType->nodeType->startID->if->while->_exptype->_nextsib->else->while->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->_nextsib->if->return->else->_nextsib->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.PrecedingIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.PrecedingIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->stackCopy->new->intArr->System->arraycopy->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
DTMDefaultBaseIterators.PrecedingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->parent->index->if->_type->_parent->while->_parent->if->stack->new->intArr->System->arraycopy->if->return->resetPosition->return
DTMDefaultBaseIterators.PrecedingIterator#next():::Get the next node in the iteration.:::for->return
DTMDefaultBaseIterators.PrecedingIterator#reset():::Resets the iterator to the last start node.:::return->resetPosition
DTMDefaultBaseIterators.PrecedingIterator#setMark()::: preceding iterator set mark:::
DTMDefaultBaseIterators.PrecedingIterator#gotoMark()::: preceding iterator goto mark:::
DTMDefaultBaseIterators.TypedPrecedingIterator#next():::Get the next node in the iteration.:::node->nodeType->if->while->if->break->else->if->if->break->else->if->_exptype->break->else->expType->while->if->break->else->if->if->break->else->_exptype->if->if->break->else->if->m_expandedNameTable->getType->break->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.FollowingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->m_traverser->first->return->resetPosition->return
DTMDefaultBaseIterators.FollowingIterator#next():::Get the next node in the iteration.:::node->m_traverser->next->return->returnNode
DTMDefaultBaseIterators.TypedFollowingIterator#next():::Get the next node in the iteration.:::node->do->m_traverser->next->while->getExpandedTypeID->getNodeType->return->returnNode
DTMDefaultBaseIterators.AncestorIterator#getStartNode():::Get start to END should 'close' the iterator, i.e:::return
DTMDefaultBaseIterators.AncestorIterator#isReverse():::True if this iterator has a reversed axis.:::return
DTMDefaultBaseIterators.AncestorIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
DTMDefaultBaseIterators.AncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->if->_parent->makeNodeHandle->while->m_ancestors->addElement->_parent->makeNodeHandle->m_ancestors->size->m_ancestors->elementAt->return->resetPosition->return
DTMDefaultBaseIterators.AncestorIterator#reset():::Resets the iterator to the last start node.:::m_ancestors->size->m_ancestors->elementAt->return->resetPosition
DTMDefaultBaseIterators.AncestorIterator#next():::Get the next node in the iteration.:::next->pos->m_ancestors->elementAt->return->returnNode
DTMDefaultBaseIterators.AncestorIterator#setMark()::: ancestor iterator set mark:::
DTMDefaultBaseIterators.AncestorIterator#gotoMark()::: ancestor iterator goto mark:::m_ancestors->elementAt
DTMDefaultBaseIterators.TypedAncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->nodeType->if->_parent->if->while->eType->_exptype->if->m_ancestors->makeNodeHandle->addElement->_parent->else->while->eType->_exptype->if->m_expandedNameTable->getType->m_ancestors->makeNodeHandle->addElement->_parent->m_ancestors->size->m_ancestors->elementAt->return->resetPosition->return
DTMDefaultBaseIterators.DescendantIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->return
DTMDefaultBaseIterators.DescendantIterator#isDescendant(int):::Tell if this node identity is a descendant:::return->_parent
DTMDefaultBaseIterators.DescendantIterator#next():::Get the next node in the iteration.:::if->return->if->return->makeNodeHandle->returnNode->node->type->do->_type->if->isDescendant->return->while->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.DescendantIterator#reset():::Reset.:::temp->makeNodeHandle->setStartNode->return
DTMDefaultBaseIterators.TypedDescendantIterator#next():::Get the next node in the iteration.:::node->type->if->return->do->_type->if->isDescendant->return->while->_exptype->return->makeNodeHandle->returnNode
DTMDefaultBaseIterators.NthDescendantIterator#next():::Get the next node in the iteration.:::node->while->super->next->makeNodeIdentity->parent->_parent->child->_firstch->pos->do->type->_type->if->while->_nextsib->if->return->return
DTMDefaultBaseIterators.SingletonIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->return->resetPosition->else->if->return->resetPosition->return
DTMDefaultBaseIterators.SingletonIterator#reset():::Resets the iterator to the last start node.:::if->return->resetPosition->else->temp->setStartNode->return
DTMDefaultBaseIterators.SingletonIterator#next():::Get the next node in the iteration.:::result->return->returnNode
DTMDefaultBaseIterators.TypedSingletonIterator#next():::Get the next node in the iteration.:::result->nodeType->if->if->getExpandedTypeID->return->returnNode->else->if->getNodeType->return->returnNode->return
DTMDefaultBaseTraversers#getAxisTraverser(int):::This returns a stateless "traverser", that can navigate over an XPath axis, though perhaps not in document order.:::traverser->if->Axis->getNamesLength->new->DTMAxisTraverserArr->else->if->return->switch->new->AncestorTraverser->break->new->AncestorOrSelfTraverser->break->new->AttributeTraverser->break->new->ChildTraverser->break->new->DescendantTraverser->break->new->DescendantOrSelfTraverser->break->new->FollowingTraverser->break->new->FollowingSiblingTraverser->break->new->NamespaceTraverser->break->new->NamespaceDeclsTraverser->break->new->ParentTraverser->break->new->PrecedingTraverser->break->new->PrecedingSiblingTraverser->break->new->SelfTraverser->break->new->AllFromRootTraverser->break->new->AllFromNodeTraverser->break->new->PrecedingAndAncestorTraverser->break->new->DescendantFromRootTraverser->break->new->DescendantOrSelfFromRootTraverser->break->new->RootTraverser->break->return->throw->XMLMessages->new->ObjectArr->Integer->toString->createXMLMessage->new->DTMException->if->throw->XMLMessages->new->ObjectArr->Axis->getNames->createXMLMessage->new->DTMException->return
DTMDefaultBaseTraversers.AncestorTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getParent
DTMDefaultBaseTraversers.AncestorTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::makeNodeIdentity->while->m_parent->elementAt->if->m_exptype->elementAt->return->makeNodeHandle->return
DTMDefaultBaseTraversers.AncestorOrSelfTraverser#first(int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return
DTMDefaultBaseTraversers.AncestorOrSelfTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return->getExpandedTypeID->next
DTMDefaultBaseTraversers.AttributeTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getFirstAttribute->getNextAttribute
DTMDefaultBaseTraversers.AttributeTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::getFirstAttribute->getNextAttribute->do->if->getExpandedTypeID->return->while->getNextAttribute->return
DTMDefaultBaseTraversers.ChildTraverser#getNextIndexed(int, int, int):::Get the next indexed node that matches the expanded type ID:::nsIndex->m_expandedNameTable->getNamespaceID->lnIndex->m_expandedNameTable->getLocalNameID->for->return
DTMDefaultBaseTraversers.ChildTraverser#first(int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return->getFirstChild
DTMDefaultBaseTraversers.ChildTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::if->identity->makeNodeIdentity->firstMatch->_firstch->getNextIndexed->return->makeNodeHandle->else->for->current->makeNodeIdentity->_firstch->_nextsib->return
DTMDefaultBaseTraversers.ChildTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getNextSibling
DTMDefaultBaseTraversers.ChildTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::for->makeNodeIdentity->_nextsib->_nextsib->return
DTMDefaultBaseTraversers.IndexedDTMAxisTraverser#isIndexed(int):::Tell if the indexing is on and the given expanded type ID matches what is in the indexes:::return->m_expandedNameTable->getType
DTMDefaultBaseTraversers.IndexedDTMAxisTraverser#isAfterAxis(int, int):::Tell if a node is outside the axis being traversed:::
DTMDefaultBaseTraversers.IndexedDTMAxisTraverser#axisHasBeenProcessed(int):::Tell if the axis has been fully processed to tell if a the wait for an arriving node should terminate:::
DTMDefaultBaseTraversers.IndexedDTMAxisTraverser#getNextIndexed(int, int, int):::Get the next indexed node that matches the expanded type ID:::nsIndex->m_expandedNameTable->getNamespaceID->lnIndex->m_expandedNameTable->getLocalNameID->while->next->findElementFromIndex->if->if->isAfterAxis->return->return->else->if->axisHasBeenProcessed->break->nextNode->return
DTMDefaultBaseTraversers.DescendantTraverser#getFirstPotential(int):::Get the first potential identity that can be returned:::return
DTMDefaultBaseTraversers.DescendantTraverser#axisHasBeenProcessed(int):::Tell if the axis has been fully processed to tell if a the wait for an arriving node should terminate.:::return->m_nextsib->elementAt
DTMDefaultBaseTraversers.DescendantTraverser#getSubtreeRoot(int):::Get the subtree root identity from the handle that was passed in by the caller:::return->makeNodeIdentity
DTMDefaultBaseTraversers.DescendantTraverser#isDescendant(int, int):::Tell if this node identity is a descendant:::return->_parent
DTMDefaultBaseTraversers.DescendantTraverser#isAfterAxis(int, int):::Tell if a node is outside the axis being traversed:::do->if->return->m_parent->elementAt->while->return
DTMDefaultBaseTraversers.DescendantTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::if->isIndexed->identity->getSubtreeRoot->firstPotential->getFirstPotential->return->getNextIndexed->makeNodeHandle->return->next
DTMDefaultBaseTraversers.DescendantTraverser#next(int, int):::Traverse to the next node after the current node.:::subtreeRootIdent->getSubtreeRoot->for->makeNodeIdentity
DTMDefaultBaseTraversers.DescendantTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::subtreeRootIdent->getSubtreeRoot->makeNodeIdentity->if->isIndexed->return->getNextIndexed->makeNodeHandle->for
DTMDefaultBaseTraversers.DescendantOrSelfTraverser#getFirstPotential(int):::Get the first potential identity that can be returned, which is the axis context, in this case.:::return
DTMDefaultBaseTraversers.DescendantOrSelfTraverser#first(int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return
DTMDefaultBaseTraversers.AllFromNodeTraverser#next(int, int):::Traverse to the next node after the current node.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity
DTMDefaultBaseTraversers.FollowingTraverser#first(int):::Get the first of the following.:::makeNodeIdentity->first->type->_type->if->_parent->_firstch->if->return->makeNodeHandle->do->_nextsib->if->_parent->while->return->makeNodeHandle
DTMDefaultBaseTraversers.FollowingTraverser#first(int, int):::Get the first of the following.:::first->type->getNodeType->if->getParent->getFirstChild->if->if->getExpandedTypeID->return->else->return->next->do->getNextSibling->if->getParent->else->if->getExpandedTypeID->return->else->return->next->while->return
DTMDefaultBaseTraversers.FollowingTraverser#next(int, int):::Traverse to the next node after the current node.:::makeNodeIdentity->while->type->_type->if->return->if->continue->return->makeNodeHandle
DTMDefaultBaseTraversers.FollowingTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::makeNodeIdentity->while->etype->_exptype->if->return->if->continue->return->makeNodeHandle
DTMDefaultBaseTraversers.FollowingSiblingTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getNextSibling
DTMDefaultBaseTraversers.FollowingSiblingTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::while->getNextSibling->if->getExpandedTypeID->return->return
DTMDefaultBaseTraversers.NamespaceDeclsTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getFirstNamespaceNode->getNextNamespaceNode
DTMDefaultBaseTraversers.NamespaceDeclsTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::getFirstNamespaceNode->getNextNamespaceNode->do->if->getExpandedTypeID->return->while->getNextNamespaceNode->return
DTMDefaultBaseTraversers.NamespaceTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getFirstNamespaceNode->getNextNamespaceNode
DTMDefaultBaseTraversers.NamespaceTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::getFirstNamespaceNode->getNextNamespaceNode->do->if->getExpandedTypeID->return->while->getNextNamespaceNode->return
DTMDefaultBaseTraversers.ParentTraverser#first(int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return->getParent
DTMDefaultBaseTraversers.ParentTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::makeNodeIdentity->while->m_parent->elementAt->if->m_exptype->elementAt->return->makeNodeHandle->return
DTMDefaultBaseTraversers.ParentTraverser#next(int, int):::Traverse to the next node after the current node.:::return
DTMDefaultBaseTraversers.ParentTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::return
DTMDefaultBaseTraversers.PrecedingTraverser#isAncestor(int, int):::Tell if the current identity is an ancestor of the context identity:::for->m_parent->elementAt->m_parent->elementAt->return
DTMDefaultBaseTraversers.PrecedingTraverser#next(int, int):::Traverse to the next node after the current node.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity->return
DTMDefaultBaseTraversers.PrecedingTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity->return
DTMDefaultBaseTraversers.PrecedingAndAncestorTraverser#next(int, int):::Traverse to the next node after the current node.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity->return
DTMDefaultBaseTraversers.PrecedingAndAncestorTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity->return
DTMDefaultBaseTraversers.PrecedingSiblingTraverser#next(int, int):::Traverse to the next node after the current node.:::return->getPreviousSibling
DTMDefaultBaseTraversers.PrecedingSiblingTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::while->getPreviousSibling->if->getExpandedTypeID->return->return
DTMDefaultBaseTraversers.SelfTraverser#first(int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return
DTMDefaultBaseTraversers.SelfTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::return->getExpandedTypeID
DTMDefaultBaseTraversers.SelfTraverser#next(int, int):::Traverse to the next node after the current node.:::return
DTMDefaultBaseTraversers.SelfTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::return
DTMDefaultBaseTraversers.AllFromRootTraverser#first(int):::Return the root.:::return->getDocumentRoot
DTMDefaultBaseTraversers.AllFromRootTraverser#first(int, int):::Return the root if it matches the expanded type ID.:::return->getDocumentRoot->getExpandedTypeID->next
DTMDefaultBaseTraversers.AllFromRootTraverser#next(int, int):::Traverse to the next node after the current node.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity
DTMDefaultBaseTraversers.AllFromRootTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::subtreeRootIdent->makeNodeIdentity->for->makeNodeIdentity
DTMDefaultBaseTraversers.RootTraverser#first(int, int):::Return the root if it matches the expanded type ID, else return null (nothing found):::root->getDocumentRoot->return->getExpandedTypeID
DTMDefaultBaseTraversers.RootTraverser#next(int, int):::Traverse to the next node after the current node.:::return
DTMDefaultBaseTraversers.RootTraverser#next(int, int, int):::Traverse to the next node after the current node that is matched by the expanded type ID.:::return
DTMDefaultBaseTraversers.DescendantOrSelfFromRootTraverser#getFirstPotential(int):::Get the first potential identity that can be returned, which is the axis root context in this case.:::return
DTMDefaultBaseTraversers.DescendantOrSelfFromRootTraverser#getSubtreeRoot(int):::Get the first potential identity that can be returned.:::return->getDocument->makeNodeIdentity
DTMDefaultBaseTraversers.DescendantOrSelfFromRootTraverser#first(int):::Return the root.:::return->getDocumentRoot
DTMDefaultBaseTraversers.DescendantOrSelfFromRootTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::if->isIndexed->identity->firstPotential->getFirstPotential->return->getNextIndexed->makeNodeHandle->root->first->return->next
DTMDefaultBaseTraversers.DescendantFromRootTraverser#getFirstPotential(int):::Get the first potential identity that can be returned, which is the axis root context in this case.:::return->_firstch
DTMDefaultBaseTraversers.DescendantFromRootTraverser#getSubtreeRoot(int):::Get the first potential identity that can be returned.:::return
DTMDefaultBaseTraversers.DescendantFromRootTraverser#first(int):::Return the root.:::return->_firstch->makeNodeHandle
DTMDefaultBaseTraversers.DescendantFromRootTraverser#first(int, int):::By the nature of the stateless traversal, the context node can not be returned or the iteration will go into an infinate loop:::if->isIndexed->identity->firstPotential->getFirstPotential->return->getNextIndexed->makeNodeHandle->root->getDocumentRoot->return->next
DTMDocumentImpl#setIncrementalSAXSource(IncrementalSAXSource):::Bind a IncrementalSAXSource to this DTM:::source->setContentHandler->source->setLexicalHandler
DTMDocumentImpl#appendNode(int, int, int, int):::Wrapper for ChunkedIntArray.append, to automatically update the previous sibling's "next" reference (if necessary) and periodically wake a reader who may have encountered incomplete data and entered a wait state.:::slotnumber->nodes->appendSlot->if->println->if->nodes->writeEntry->return
DTMDocumentImpl#setFeature(String, boolean):::Set an implementation dependent feature:::
DTMDocumentImpl#setLocalNameTable(DTMStringPool):::Set a reference pointer to the element name symbol table:::
DTMDocumentImpl#getLocalNameTable():::Get a reference pointer to the element name symbol table.:::return
DTMDocumentImpl#setNsNameTable(DTMStringPool):::Set a reference pointer to the namespace URI symbol table:::
DTMDocumentImpl#getNsNameTable():::Get a reference pointer to the namespace URI symbol table.:::return
DTMDocumentImpl#setPrefixNameTable(DTMStringPool):::Set a reference pointer to the prefix name symbol table:::
DTMDocumentImpl#getPrefixNameTable():::Get a reference pointer to the prefix name symbol table.:::return
DTMDocumentImpl#setContentBuffer(FastStringBuffer):::Set a reference pointer to the content-text repository:::
DTMDocumentImpl#getContentBuffer():::Get a reference pointer to the content-text repository:::return
DTMDocumentImpl#getContentHandler():::getContentHandler returns "our SAX builder" -- the thing that someone else should send SAX events to in order to extend this DTM model.:::if->return->else->return
DTMDocumentImpl#getLexicalHandler():::Return this DTM's lexical handler:::if->return->else->return
DTMDocumentImpl#getEntityResolver():::Return this DTM's EntityResolver.:::return
DTMDocumentImpl#getDTDHandler():::Return this DTM's DTDHandler.:::return
DTMDocumentImpl#getErrorHandler():::Return this DTM's ErrorHandler.:::return
DTMDocumentImpl#getDeclHandler():::Return this DTM's DeclHandler.:::return
DTMDocumentImpl#needsTwoThreads()::: document impl needs two threads:::return
DTMDocumentImpl#characters(char[], int, int)::: document impl characters:::m_char->append
DTMDocumentImpl#processAccumulatedText()::: document impl process accumulated text:::len->m_char->length->if->appendTextChild
DTMDocumentImpl#endDocument()::: document impl end document:::appendEndDocument
DTMDocumentImpl#endElement(java.lang.String, java.lang.String, java.lang.String)::: document impl end element:::processAccumulatedText->appendEndElement
DTMDocumentImpl#endPrefixMapping(java.lang.String)::: document impl end prefix mapping:::
DTMDocumentImpl#ignorableWhitespace(char[], int, int)::: document impl ignorable whitespace:::
DTMDocumentImpl#processingInstruction(java.lang.String, java.lang.String)::: document impl processing instruction:::processAccumulatedText
DTMDocumentImpl#setDocumentLocator(Locator)::: document impl set document locator:::
DTMDocumentImpl#skippedEntity(java.lang.String)::: document impl skipped entity:::processAccumulatedText
DTMDocumentImpl#startDocument()::: document impl start document:::appendStartDocument
DTMDocumentImpl#startElement(java.lang.String, java.lang.String, java.lang.String, Attributes)::: document impl start element:::processAccumulatedText->prefix->colon->qName->indexOf->if->qName->substring->m_prefixNames->stringToIndex->println->m_nsNames->stringToIndex->m_localNames->stringToIndex->m_prefixNames->stringToIndex->appendStartElement->nAtts->atts->getLength->for->i->for->i
DTMDocumentImpl#startPrefixMapping(java.lang.String, java.lang.String)::: document impl start prefix mapping:::
DTMDocumentImpl#comment(char[], int, int)::: document impl comment:::processAccumulatedText->m_char->append->appendComment
DTMDocumentImpl#endCDATA()::: document impl end a:::
DTMDocumentImpl#endDTD()::: document impl end d:::
DTMDocumentImpl#endEntity(java.lang.String)::: document impl end entity:::
DTMDocumentImpl#startCDATA()::: document impl start a:::
DTMDocumentImpl#startDTD(java.lang.String, java.lang.String, java.lang.String)::: document impl start d:::
DTMDocumentImpl#startEntity(java.lang.String)::: document impl start entity:::
DTMDocumentImpl#initDocument(int):::Reset a dtm document to its initial (empty) state:::nodes->writeSlot
DTMDocumentImpl#hasChildNodes(int):::Given a node handle, test if it has child nodes:::return->getFirstChild
DTMDocumentImpl#getFirstChild(int):::Given a node handle, get the handle of the node's first child:::nodes->readSlot->type->if->kid->nodes->readSlot->while->if->return->nodes->readSlot->if->firstChild->return->return
DTMDocumentImpl#getLastChild(int):::Given a node handle, advance to its last child:::lastChild->for->nextkid->getFirstChild->getNextSibling->return
DTMDocumentImpl#getAttributeNode(int, String, String):::Retrieves an attribute node by by qualified name and namespace URI.:::nsIndex->m_nsNames->stringToIndex->nameIndex->m_localNames->stringToIndex->nodes->readSlot->type->if->while->if->return->nodes->readSlot->return
DTMDocumentImpl#getFirstAttribute(int):::Given a node handle, get the index of the node's first attribute.:::if->nodes->readEntry->return->return->nodes->readEntry
DTMDocumentImpl#getFirstNamespaceNode(int, boolean):::Given a node handle, get the index of the node's first child:::return
DTMDocumentImpl#getNextSibling(int):::Given a node handle, advance to its next sibling:::if->return->type->nodes->readEntry->if->nextSib->nodes->readEntry->if->return->if->return->thisParent->nodes->readEntry->if->nodes->readEntry->return->return
DTMDocumentImpl#getPreviousSibling(int):::Given a node handle, find its preceeding sibling:::if->return->parent->nodes->readEntry->kid->for->nextkid->getFirstChild->getNextSibling->return
DTMDocumentImpl#getNextAttribute(int):::Given a node handle, advance to the next attribute:::nodes->readSlot->type->if->return->getFirstAttribute->else->if->if->return->return
DTMDocumentImpl#getNextNamespaceNode(int, int, boolean):::Given a namespace handle, advance to the next namespace:::return
DTMDocumentImpl#getNextDescendant(int, int):::Given a node handle, advance to its next descendant:::if->return->while->if->nodes->slotsUsed->break->if->nodes->readSlot->if->type->if->else->nextParentPos->if->return->else->break->else->if->else->break->else->return
DTMDocumentImpl#getNextFollowing(int, int):::Given a node handle, advance to the next node on the following axis.:::return
DTMDocumentImpl#getNextPreceding(int, int):::Given a node handle, advance to the next node on the preceding axis.:::while->if->nodes->readEntry->continue->return->nodes->specialFind->return
DTMDocumentImpl#getParent(int):::Given a node handle, find its parent node.:::return->nodes->readEntry
DTMDocumentImpl#getDocumentRoot():::Returns the root element of the document.:::return
DTMDocumentImpl#getDocument():::Given a node handle, find the owning document node.:::return
DTMDocumentImpl#getOwnerDocument(int):::Given a node handle, find the owning document node:::if->return->return
DTMDocumentImpl#getDocumentRoot(int):::Given a node handle, find the owning document node:::if->return->return
DTMDocumentImpl#getStringValue(int):::Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value).:::nodes->readSlot->nodetype->value->switch->m_char->getString->break->break->return->m_xsf->newstr
DTMDocumentImpl#getStringValueChunkCount(int)::: document impl get string value chunk count:::return
DTMDocumentImpl#getStringValueChunk(int, int, int[])::: document impl get string value chunk:::return->new->charArr
DTMDocumentImpl#getExpandedTypeID(int):::Given a node handle, return an ID that represents the node's expanded name.:::nodes->readSlot->qName->m_localNames->indexToString->colonpos->qName->indexOf->localName->qName->substring->namespace->m_nsNames->indexToString->expandedName->expandedNameID->m_nsNames->stringToIndex->return
DTMDocumentImpl#getExpandedTypeID(String, String, int):::Given an expanded name, return an ID:::expandedName->expandedNameID->m_nsNames->stringToIndex->return
DTMDocumentImpl#getLocalNameFromExpandedNameID(int):::Given an expanded-name ID, return the local name part.:::expandedName->m_localNames->indexToString->colonpos->expandedName->indexOf->localName->expandedName->substring->return
DTMDocumentImpl#getNamespaceFromExpandedNameID(int):::Given an expanded-name ID, return the namespace URI part.:::expandedName->m_localNames->indexToString->colonpos->expandedName->indexOf->nsName->expandedName->substring->return
DTMDocumentImpl#getNodeName(int):::Given a node handle, return its DOM-style node name:::nodes->readSlot->type->name->if->i->println->m_localNames->indexToString->prefix->m_prefixNames->indexToString->if->prefix->length->return
DTMDocumentImpl#getNodeNameX(int):::Given a node handle, return the XPath node name:::return
DTMDocumentImpl#getLocalName(int):::Given a node handle, return its DOM-style localname:::nodes->readSlot->type->name->if->i->m_localNames->indexToString->if->return
DTMDocumentImpl#getPrefix(int):::Given a namespace handle, return the prefix that the namespace decl is mapping:::nodes->readSlot->type->name->if->i->m_prefixNames->indexToString->if->return
DTMDocumentImpl#getNamespaceURI(int):::Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.):::return
DTMDocumentImpl#getNodeValue(int):::Given a node handle, return its node value:::nodes->readSlot->nodetype->value->switch->nodes->readSlot->m_char->getString->break->break->return
DTMDocumentImpl#getNodeType(int):::Given a node handle, return its DOM-style node type:::return->nodes->readEntry
DTMDocumentImpl#getLevel(int):::Get the depth level of this node in the tree (equals 1 for a parentless node).:::count->while->nodes->readEntry->return
DTMDocumentImpl#isSupported(String, String):::Tests whether DTM DOM implementation implements a specific feature and that feature is supported by this node.:::return
DTMDocumentImpl#getDocumentBaseURI():::Return the base URI of the document entity:::return
DTMDocumentImpl#setDocumentBaseURI(String):::Set the base URI of the document entity.:::
DTMDocumentImpl#getDocumentSystemIdentifier(int):::Return the system identifier of the document entity:::return
DTMDocumentImpl#getDocumentEncoding(int):::Return the name of the character encoding scheme        in which the document entity is expressed.:::return
DTMDocumentImpl#getDocumentStandalone(int):::Return an indication of the standalone status of the document,        either "yes" or "no":::return
DTMDocumentImpl#getDocumentVersion(int):::Return a string representing the XML version of the document:::return
DTMDocumentImpl#getDocumentAllDeclarationsProcessed():::Return an indication of whether the processor has read the complete DTD:::return
DTMDocumentImpl#getDocumentTypeDeclarationSystemIdentifier():::  A document type declaration information item has the following properties:      1:::return
DTMDocumentImpl#getDocumentTypeDeclarationPublicIdentifier():::Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]:::return
DTMDocumentImpl#getElementById(String):::Returns the Element whose ID is given by elementId:::return
DTMDocumentImpl#getUnparsedEntityURI(String):::The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]):::return
DTMDocumentImpl#supportsPreStripping():::Return true if the xsl:strip-space or xsl:preserve-space was processed during construction of the DTM document:::return
DTMDocumentImpl#isNodeAfter(int, int):::Figure out whether nodeHandle2 should be considered as being later in the document than nodeHandle1, in Document Order as defined by the XPath model:::return
DTMDocumentImpl#isCharacterElementContentWhitespace(int):::    2:::return
DTMDocumentImpl#isDocumentAllDeclarationsProcessed(int):::   10:::return
DTMDocumentImpl#isAttributeSpecified(int):::    5:::return
DTMDocumentImpl#dispatchCharactersEvents(int, org.xml.sax.ContentHandler, boolean):::Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value):::
DTMDocumentImpl#dispatchToEvents(int, org.xml.sax.ContentHandler)::: document impl dispatch to events:::
DTMDocumentImpl#getNode(int):::Return an DOM node for the given node.:::return
DTMDocumentImpl#appendChild(int, boolean, boolean):::Append a child to the end of the child list of the current node:::sameDoc->if->else
DTMDocumentImpl#appendTextChild(String):::Append a text node child that will be constructed from a string, to the end of the document:::
DTMDocumentImpl#appendTextChild(int, int):::Append a text child at the current insertion point:::w0->w1->w2->w3->ourslot->appendNode
DTMDocumentImpl#appendComment(int, int):::Append a comment child at the current insertion point:::w0->w1->w2->w3->ourslot->appendNode
DTMDocumentImpl#appendStartElement(int, int, int):::Append an Element child at the current insertion point:::w0->w1->w2->w3->println->ourslot->appendNode->if
DTMDocumentImpl#appendNSDeclaration(int, int, boolean):::Append a Namespace Declaration child at the current insertion point:::namespaceForNamespaces->m_nsNames->stringToIndex->w0->m_nsNames->stringToIndex->w1->w2->w3->ourslot->appendNode->return
DTMDocumentImpl#appendAttribute(int, int, int, boolean, int, int):::Append an Attribute child at the current insertion point:::w0->w1->w2->w3->println->ourslot->appendNode->appendNode->return
DTMDocumentImpl#getAxisTraverser(int):::This returns a stateless "traverser", that can navigate over an XPath axis, though not in document order.:::return
DTMDocumentImpl#getAxisIterator(int):::This is a shortcut to the iterators that implement the supported XPath axes (only namespace::) is not supported:::return
DTMDocumentImpl#getTypedAxisIterator(int, int):::Get an iterator that can navigate over an XPath Axis, predicated by the extended type ID.:::return
DTMDocumentImpl#appendEndElement():::Terminate the element currently acting as an insertion point:::if->nodes->writeEntry->nodes->readSlot
DTMDocumentImpl#appendStartDocument()::: Starting a new document:::initDocument
DTMDocumentImpl#appendEndDocument()::: All appends to this document have finished; do whatever final cleanup is needed.:::
DTMDocumentImpl#setProperty(String, Object):::For the moment all the run time properties are ignored by this class.:::
DTMDocumentImpl#getSourceLocatorFor(int):::Source information is not handled yet, so return null here.:::return
DTMDocumentImpl#documentRegistration():::A dummy routine to satisify the abstract interface:::
DTMDocumentImpl#documentRelease():::A dummy routine to satisify the abstract interface:::
DTMDocumentImpl#migrateTo(DTMManager):::Migrate a DTM built with an old DTMManager to a new DTMManager:::
DTMManagerDefault#addDTM(DTM, int):::Add a DTM to the DTM table:::addDTM
DTMManagerDefault#addDTM(DTM, int, int):::Add a DTM to the DTM table.:::if->throw->XMLMessages->createXMLMessage->new->DTMException->oldlen->if->newlen->Math->min->new_m_dtms->new->DTMArr->System->arraycopy->new_m_dtm_offsets->new->intArr->System->arraycopy->dtm->documentRegistration
DTMManagerDefault#getFirstFreeDTMID():::Get the first free DTM ID available:::n->for->i->return
DTMManagerDefault#getDTM(Source, boolean, DTMWSFilter, boolean, boolean):::Get an instance of a DTM, loaded with the content from the specified source:::if->source->getSystemId->println->xstringFactory->dtmPos->getFirstFreeDTMID->documentID->if->dtm->new->DOM2DTM->addDTM->return->else->isSAXSource->isStreamSource->if->reader->dtm->try->xmlSource->if->else->getXMLReader->SAXSource->sourceToInputSource->urlOfSource->xmlSource->getSystemId->if->try->SystemIDResolver->getAbsoluteURI->catch->println->finally->xmlSource->setSystemId->if->new->SAX2RTFDTM->else->new->SAX2DTM->addDTM->haveXercesParser->reader->getClass->getName->equals->if->if->coParser->if->try->new->com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces->catch->ex->printStackTrace->finally->if->if->new->IncrementalSAXSource_Filter->else->filter->new->IncrementalSAXSource_Filter->filter->setXMLReader->dtm->setIncrementalSAXSource->if->return->if->reader->getErrorHandler->reader->setErrorHandler->reader->setDTDHandler->try->coParser->startParse->catch->dtm->clearCoRoutine->throw->dtm->clearCoRoutine->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally->else->if->return->reader->setContentHandler->reader->setDTDHandler->if->reader->getErrorHandler->reader->setErrorHandler->try->reader->setProperty->catch->finally->try->reader->parse->catch->dtm->clearCoRoutine->throw->dtm->clearCoRoutine->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally->if->println->dtm->dumpDTM->return->catch->finally->if->reader->setContentHandler->reader->setDTDHandler->reader->setErrorHandler->try->reader->setProperty->catch->finally->releaseXMLReader->else->throw->XMLMessages->new->ObjectArr->createXMLMessage->new->DTMException
DTMManagerDefault#getDTMHandleFromNode(org.w3c.dom.Node):::Given a W3C DOM node, try and return a DTM handle:::if->throw->XMLMessages->createXMLMessage->new->IllegalArgumentException->if->return->getDTMNodeNumber->else->max->for->i->root->p->root->getNodeType->getOwnerElement->root->getParentNode->for->p->getParentNode->dtm->new->javax.xml.transform.dom.DOMSource->getDTM->handle->if->dtm->getOwnerElement->getHandleOfNode->dtm->node->getNamespaceURI->node->getLocalName->getAttributeNode->else->dtm->getHandleOfNode->if->throw->XMLMessages->createXMLMessage->new->RuntimeException->return
DTMManagerDefault#getXMLReader(Source):::This method returns the SAX2 parser to use with the InputSource obtained from this URI:::try->reader->getXMLReader->if->if->XMLReaderManager->super->overrideDefaultParser->getInstance->m_readerManager->getXMLReader->return->catch->throw->se->getMessage->new->DTMException->finally
DTMManagerDefault#releaseXMLReader(XMLReader):::Indicates that the XMLReader object is no longer in use for the transform:::if->m_readerManager->releaseXMLReader
DTMManagerDefault#getDTM(int):::Return the DTM object containing a representation of this node.:::try->return->catch->if->return->else->throw->finally
DTMManagerDefault#getDTMIdentity(DTM):::Given a DTM, find the ID number in the DTM tables which addresses the start of the document:::if->dtmdb->if->dtmdb->getManager->return->dtmdb->getDTMIDs->elementAt->else->return->n->for->i->return
DTMManagerDefault#release(DTM, boolean):::Release the DTMManager's reference(s) to a DTM, making it unmanaged:::if->dtm->getDocumentBaseURI->println->if->clearCoRoutine->if->ids->getDTMIDs->for->i->ids->size->else->i->getDTMIdentity->if->dtm->documentRelease->return
DTMManagerDefault#createDocumentFragment():::Method createDocumentFragment   NEEDSDOC (createDocumentFragment) @return:::try->dbf->JdkXmlUtils->super->overrideDefaultParser->getDOMFactory->db->dbf->newDocumentBuilder->doc->db->newDocument->df->doc->createDocumentFragment->return->new->DOMSource->getDTM->catch->throw->new->DTMException->finally
DTMManagerDefault#createDTMIterator(int, DTMFilter, boolean):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param whatToShow NEEDSDOC @param filter NEEDSDOC @param entityReferenceExpansion  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(String, PrefixResolver):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param xpathString NEEDSDOC @param presolver  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(int):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param node  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#createDTMIterator(Object, int):::NEEDSDOC Method createDTMIterator   NEEDSDOC @param xpathCompiler NEEDSDOC @param pos  NEEDSDOC (createDTMIterator) @return:::return
DTMManagerDefault#getExpandedNameTable(DTM):::return the expanded name table:::return
DTMNamedNodeMap#getLength():::Return the number of Attributes on this Element:::if->count->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#getNamedItem(String):::Retrieves a node specified by name.:::for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#item(int):::Returns the indexth item in the map:::count->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#setNamedItem(Node):::Adds a node using its nodeName attribute:::throw->new->DTMException
DTMNamedNodeMap#removeNamedItem(String):::Removes a node specified by name:::throw->new->DTMException
DTMNamedNodeMap#getNamedItemNS(String, String):::Retrieves a node specified by local name and namespace URI:::retNode->for->n->dtm->getFirstAttribute->dtm->getNextAttribute->return
DTMNamedNodeMap#setNamedItemNS(Node):::Adds a node using its namespaceURI and localName:::throw->new->DTMException
DTMNamedNodeMap#removeNamedItemNS(String, String):::Removes a node specified by local name and namespace URI:::throw->new->DTMException
DTMNodeIterator#getDTMIterator():::Access the wrapped DTMIterator:::return
DTMNodeIterator#detach():::Detaches the NodeIterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::
DTMNodeIterator#getExpandEntityReferences():::The value of this flag determines whether the children of entity reference nodes are visible to the iterator.:::return
DTMNodeIterator#getFilter():::Return a handle to the filter used to screen nodes:::throw->new->DTMDOMException
DTMNodeIterator#getRoot()::: node iterator get root:::handle->dtm_iter->getRoot->return->dtm_iter->getDTM->getNode
DTMNodeIterator#getWhatToShow():::Return a mask describing which node types are presented via the iterator.:::return->dtm_iter->getWhatToShow
DTMNodeIterator#nextNode()::: node iterator next node:::if->throw->new->DTMDOMException->handle->dtm_iter->nextNode->if->return->return->dtm_iter->getDTM->getNode
DTMNodeIterator#previousNode()::: node iterator previous node:::if->throw->new->DTMDOMException->handle->dtm_iter->previousNode->if->return->return->dtm_iter->getDTM->getNode
DTMNodeList#getDTMIterator():::Access the wrapped DTMIterator:::return
DTMNodeList#item(int):::Returns the indexth item in the collection:::if->handle->m_iter->item->if->return->return->m_iter->getDTM->getNode->else->return
DTMNodeList#getLength():::The number of nodes in the list:::return->m_iter->getLength
DTMNodeListBase#item(int):::Returns the indexth item in the collection:::return
DTMNodeListBase#getLength():::The number of nodes in the list:::return
DTMNodeProxy#getDTM():::NON-DOM: Return the DTM model:::return
DTMNodeProxy#getDTMNodeNumber():::NON-DOM: Return the DTM node number:::return
DTMNodeProxy#equals(Node):::Test for equality based on node number.:::try->dtmp->return->catch->return->finally
DTMNodeProxy#equals(Object):::Test for equality based on node number.:::return->equals
DTMNodeProxy#hashCode()::: node proxy hash code:::hash->Objects->hashCode->return
DTMNodeProxy#sameNodeAs(Node):::FUTURE DOM: Test node identity, in lieu of Node==Node:::if->return->that->return
DTMNodeProxy#getNodeName()::: node proxy get node name:::return->dtm->getNodeName
DTMNodeProxy#getTarget():::A PI's "target" states what processor channel the PI's data should be directed to:::return->dtm->getNodeName
DTMNodeProxy#getLocalName()::: node proxy get local name:::return->dtm->getLocalName
DTMNodeProxy#getPrefix()::: node proxy get prefix:::return->dtm->getPrefix
DTMNodeProxy#setPrefix(String)::: node proxy set prefix:::throw->new->DTMDOMException
DTMNodeProxy#getNamespaceURI()::: node proxy get namespace i:::return->dtm->getNamespaceURI
DTMNodeProxy#supports(String, String):::Ask whether we support a given DOM feature:::return->implementation->hasFeature
DTMNodeProxy#isSupported(String, String):::Ask whether we support a given DOM feature:::return->implementation->hasFeature
DTMNodeProxy#getNodeValue()::: node proxy get node value:::return->dtm->getNodeValue
DTMNodeProxy#getStringValue()::: node proxy get string value:::return->dtm->getStringValue->toString
DTMNodeProxy#setNodeValue(String)::: node proxy set node value:::throw->new->DTMDOMException
DTMNodeProxy#getNodeType()::: node proxy get node type:::return->dtm->getNodeType
DTMNodeProxy#getParentNode()::: node proxy get parent node:::if->getNodeType->return->newnode->dtm->getParent->return->dtm->getNode
DTMNodeProxy#getOwnerNode()::: node proxy get owner node:::newnode->dtm->getParent->return->dtm->getNode
DTMNodeProxy#getChildNodes()::: node proxy get child nodes:::return->new->DTMChildIterNodeList
DTMNodeProxy#getFirstChild()::: node proxy get first child:::newnode->dtm->getFirstChild->return->dtm->getNode
DTMNodeProxy#getLastChild()::: node proxy get last child:::newnode->dtm->getLastChild->return->dtm->getNode
DTMNodeProxy#getPreviousSibling()::: node proxy get previous sibling:::newnode->dtm->getPreviousSibling->return->dtm->getNode
DTMNodeProxy#getNextSibling()::: node proxy get next sibling:::if->dtm->getNodeType->return->newnode->dtm->getNextSibling->return->dtm->getNode
DTMNodeProxy#getAttributes()::: node proxy get attributes:::return->new->DTMNamedNodeMap
DTMNodeProxy#hasAttribute(String):::Method hasAttribute:::return->dtm->getAttributeNode
DTMNodeProxy#hasAttributeNS(String, String):::Method hasAttributeNS:::return->dtm->getAttributeNode
DTMNodeProxy#getOwnerDocument()::: node proxy get owner document:::return->dtm->dtm->getOwnerDocument->getNode
DTMNodeProxy#insertBefore(Node, Node)::: node proxy insert before:::throw->new->DTMDOMException
DTMNodeProxy#replaceChild(Node, Node)::: node proxy replace child:::throw->new->DTMDOMException
DTMNodeProxy#removeChild(Node)::: node proxy remove child:::throw->new->DTMDOMException
DTMNodeProxy#appendChild(Node)::: node proxy append child:::throw->new->DTMDOMException
DTMNodeProxy#hasChildNodes()::: node proxy has child nodes:::return->dtm->getFirstChild
DTMNodeProxy#cloneNode(boolean)::: node proxy clone node:::throw->new->DTMDOMException
DTMNodeProxy#getDoctype()::: node proxy get doctype:::return
DTMNodeProxy#getImplementation()::: node proxy get implementation:::return
DTMNodeProxy#getDocumentElement():::This is a bit of a problem in DTM, since a DTM may be a Document Fragment and hence not have a clear-cut Document Element:::dochandle->dtm->getDocument->elementhandle->for->kidhandle->dtm->getFirstChild->dtm->getNextSibling->if->throw->new->DTMDOMException->else->return->dtm->getNode
DTMNodeProxy#createElement(String)::: node proxy create element:::throw->new->DTMDOMException
DTMNodeProxy#createDocumentFragment()::: node proxy create document fragment:::throw->new->DTMDOMException
DTMNodeProxy#createTextNode(String)::: node proxy create text node:::throw->new->DTMDOMException
DTMNodeProxy#createComment(String)::: node proxy create comment:::throw->new->DTMDOMException
DTMNodeProxy#createCDATASection(String)::: node proxy create section:::throw->new->DTMDOMException
DTMNodeProxy#createProcessingInstruction(String, String)::: node proxy create processing instruction:::throw->new->DTMDOMException
DTMNodeProxy#createAttribute(String)::: node proxy create attribute:::throw->new->DTMDOMException
DTMNodeProxy#createEntityReference(String)::: node proxy create entity reference:::throw->new->DTMDOMException
DTMNodeProxy#getElementsByTagName(String)::: node proxy get elements by tag name:::listVector->new->ArrayList<>->retNode->dtm->getNode->if->isTagNameWildCard->equals->if->retNode->getNodeType->nodeList->retNode->getChildNodes->for->i->nodeList->getLength->else->if->retNode->getNodeType->dtm->getNode->traverseChildren->size->listVector->size->nodeSet->new->NodeSet->for->i->return
DTMNodeProxy#traverseChildren(List, Node, String, boolean)::: node proxy traverse children:::if->return->else->if->tempNode->getNodeType->tempNode->getNodeName->equals->listVector->add->if->tempNode->hasChildNodes->nodeList->tempNode->getChildNodes->for->i->nodeList->getLength
DTMNodeProxy#importNode(Node, boolean)::: node proxy import node:::throw->new->DTMDOMException
DTMNodeProxy#createElementNS(String, String)::: node proxy create element s:::throw->new->DTMDOMException
DTMNodeProxy#createAttributeNS(String, String)::: node proxy create attribute s:::throw->new->DTMDOMException
DTMNodeProxy#getElementsByTagNameNS(String, String)::: node proxy get elements by tag name s:::listVector->new->ArrayList<>->retNode->dtm->getNode->if->isNamespaceURIWildCard->equals->isLocalNameWildCard->equals->if->retNode->getNodeType->nodeList->retNode->getChildNodes->for->i->nodeList->getLength->else->if->retNode->getNodeType->dtm->getNode->traverseChildren->size->listVector->size->nodeSet->new->NodeSet->for->i->return
DTMNodeProxy#traverseChildren(List, Node, String, String, boolean, boolean)::: node proxy traverse children:::if->return->else->if->tempNode->getNodeType->tempNode->getLocalName->equals->nsURI->tempNode->getNamespaceURI->if->namespaceURI->equals->listVector->add->if->tempNode->hasChildNodes->nl->tempNode->getChildNodes->for->i->nl->getLength
DTMNodeProxy#getElementById(String)::: node proxy get element by id:::return->dtm->dtm->getElementById->getNode
DTMNodeProxy#splitText(int)::: node proxy split text:::throw->new->DTMDOMException
DTMNodeProxy#getData()::: node proxy get data:::return->dtm->getNodeValue
DTMNodeProxy#setData(String)::: node proxy set data:::throw->new->DTMDOMException
DTMNodeProxy#getLength()::: node proxy get length:::return->dtm->getNodeValue->length
DTMNodeProxy#substringData(int, int)::: node proxy substring data:::return->getData->substring
DTMNodeProxy#appendData(String)::: node proxy append data:::throw->new->DTMDOMException
DTMNodeProxy#insertData(int, String)::: node proxy insert data:::throw->new->DTMDOMException
DTMNodeProxy#deleteData(int, int)::: node proxy delete data:::throw->new->DTMDOMException
DTMNodeProxy#replaceData(int, int, String)::: node proxy replace data:::throw->new->DTMDOMException
DTMNodeProxy#getTagName()::: node proxy get tag name:::return->dtm->getNodeName
DTMNodeProxy#getAttribute(String)::: node proxy get attribute:::map->new->DTMNamedNodeMap->n->map->getNamedItem->return->n->getNodeValue
DTMNodeProxy#setAttribute(String, String)::: node proxy set attribute:::throw->new->DTMDOMException
DTMNodeProxy#removeAttribute(String)::: node proxy remove attribute:::throw->new->DTMDOMException
DTMNodeProxy#getAttributeNode(String)::: node proxy get attribute node:::map->new->DTMNamedNodeMap->return->map->getNamedItem
DTMNodeProxy#setAttributeNode(Attr)::: node proxy set attribute node:::throw->new->DTMDOMException
DTMNodeProxy#removeAttributeNode(Attr)::: node proxy remove attribute node:::throw->new->DTMDOMException
DTMNodeProxy#hasAttributes():::Introduced in DOM Level 2.:::return->dtm->getFirstAttribute
DTMNodeProxy#normalize()::: node proxy normalize:::throw->new->DTMDOMException
DTMNodeProxy#getAttributeNS(String, String)::: node proxy get attribute s:::retNode->n->dtm->getAttributeNode->if->dtm->getNode->return->retNode->getNodeValue
DTMNodeProxy#setAttributeNS(String, String, String)::: node proxy set attribute s:::throw->new->DTMDOMException
DTMNodeProxy#removeAttributeNS(String, String)::: node proxy remove attribute s:::throw->new->DTMDOMException
DTMNodeProxy#getAttributeNodeNS(String, String)::: node proxy get attribute node s:::retAttr->n->dtm->getAttributeNode->if->dtm->getNode->return
DTMNodeProxy#setAttributeNodeNS(Attr)::: node proxy set attribute node s:::throw->new->DTMDOMException
DTMNodeProxy#getName()::: node proxy get name:::return->dtm->getNodeName
DTMNodeProxy#getSpecified()::: node proxy get specified:::return
DTMNodeProxy#getValue()::: node proxy get value:::return->dtm->getNodeValue
DTMNodeProxy#setValue(String)::: node proxy set value:::throw->new->DTMDOMException
DTMNodeProxy#getOwnerElement():::Get the owner element of an attribute.:::if->getNodeType->return->newnode->dtm->getParent->return->dtm->getNode
DTMNodeProxy#adoptNode(Node):::NEEDSDOC Method adoptNode   NEEDSDOC @param source  NEEDSDOC (adoptNode) @return:::throw->new->DTMDOMException
DTMNodeProxy#getInputEncoding():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setEncoding(String):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getStandalone():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setStandalone(boolean):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getStrictErrorChecking():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setStrictErrorChecking(boolean):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#getVersion():::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy#setVersion(String):::EXPERIMENTAL! Based on the Document Object Model (DOM) Level 3 Core Working Draft of 5 June 2001.:::throw->new->DTMDOMException
DTMNodeProxy.DTMNodeProxyImplementation#createDocumentType(String, String, String)::: node proxy implementation create document type:::throw->new->DTMDOMException
DTMNodeProxy.DTMNodeProxyImplementation#createDocument(String, String, DocumentType)::: node proxy implementation create document:::throw->new->DTMDOMException
DTMNodeProxy.DTMNodeProxyImplementation#hasFeature(String, String):::Ask whether we support a given DOM feature:::if->feature->toUpperCase->equals->feature->toUpperCase->equals->equals->equals->return->return
DTMNodeProxy.DTMNodeProxyImplementation#getFeature(String, String)::: This method returns a specialized object which implements the specialized APIs of the specified feature and version:::return
DTMNodeProxy#setUserData(String, Object, UserDataHandler)::: node proxy set user data:::return->getOwnerDocument->setUserData
DTMNodeProxy#getUserData(String):::Retrieves the object associated to a key on a this node:::return->getOwnerDocument->getUserData
DTMNodeProxy#getFeature(String, String)::: This method returns a specialized object which implements the specialized APIs of the specified feature and version:::return->isSupported
DTMNodeProxy#isEqualNode(Node):::Tests whether two nodes are equal:::if->return->if->arg->getNodeType->getNodeType->return->if->getNodeName->if->arg->getNodeName->return->else->if->getNodeName->arg->getNodeName->equals->return->if->getLocalName->if->arg->getLocalName->return->else->if->getLocalName->arg->getLocalName->equals->return->if->getNamespaceURI->if->arg->getNamespaceURI->return->else->if->getNamespaceURI->arg->getNamespaceURI->equals->return->if->getPrefix->if->arg->getPrefix->return->else->if->getPrefix->arg->getPrefix->equals->return->if->getNodeValue->if->arg->getNodeValue->return->else->if->getNodeValue->arg->getNodeValue->equals->return->return
DTMNodeProxy#lookupNamespaceURI(String):::DOM Level 3 Look up the namespace URI associated to the given prefix, starting from this node:::type->this->getNodeType->switch->namespace->this->getNamespaceURI->prefix->this->getPrefix->if->if->return->else->if->prefix->equals->return->if->this->hasAttributes->map->this->getAttributes->length->map->getLength->for->i->return->return->if->this->getOwnerElement->getNodeType->return->getOwnerElement->lookupNamespaceURI->return->return
DTMNodeProxy#isDefaultNamespace(String)::: DOM Level 3  This method checks if the specified namespaceURI is the  default namespace or not.:::return
DTMNodeProxy#lookupPrefix(String):::DOM Level 3 Look up the prefix associated to the given namespace URI, starting from this node.:::if->return->type->this->getNodeType->switch->return->if->this->getOwnerElement->getNodeType->return->getOwnerElement->lookupPrefix->return->return
DTMNodeProxy#isSameNode(Node):::Returns whether this node is the same node as the given one:::return
DTMNodeProxy#setTextContent(String):::This attribute returns the text content of this node and its descendants:::setNodeValue
DTMNodeProxy#getTextContent():::This attribute returns the text content of this node and its descendants:::return->dtm->getStringValue->toString
DTMNodeProxy#compareDocumentPosition(Node):::Compares a node with this node with regard to their position in the document.:::return
DTMNodeProxy#getBaseURI():::The absolute base URI of this node or null if undefined:::return
DTMNodeProxy#renameNode(Node, String, String):::DOM Level 3 Renaming node:::return
DTMNodeProxy#normalizeDocument()::: DOM Level 3  Normalize document.:::
DTMNodeProxy#getDomConfig():::The configuration used when Document.normalizeDocument is invoked.:::return
DTMNodeProxy#setDocumentURI(String):::DOM Level 3:::
DTMNodeProxy#getDocumentURI():::DOM Level 3 The location of the document or null if undefined:::return
DTMNodeProxy#getActualEncoding():::DOM Level 3 An attribute specifying the actual encoding of this document:::return
DTMNodeProxy#setActualEncoding(String):::DOM Level 3 An attribute specifying the actual encoding of this document:::
DTMNodeProxy#replaceWholeText(String):::DOM Level 3:::return
DTMNodeProxy#getWholeText():::DOM Level 3 Returns all text of Text nodes logically-adjacent text nodes to this node, concatenated in document order.:::return
DTMNodeProxy#isElementContentWhitespace():::DOM Level 3 Returns whether this text node contains whitespace in element content, often abusively called "ignorable whitespace".:::return
DTMNodeProxy#setIdAttribute(boolean):::NON-DOM: set the type of this attribute to be ID type.:::
DTMNodeProxy#setIdAttribute(String, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#setIdAttributeNode(Attr, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#setIdAttributeNS(String, String, boolean):::DOM Level 3: register the given attribute node as an ID attribute:::
DTMNodeProxy#getSchemaTypeInfo():::Method getSchemaTypeInfo.:::return
DTMNodeProxy#isId()::: node proxy is id:::return
DTMNodeProxy#getXmlEncoding()::: node proxy get xml encoding:::return
DTMNodeProxy#setXmlEncoding(String)::: node proxy set xml encoding:::
DTMNodeProxy#getXmlStandalone()::: node proxy get xml standalone:::return
DTMNodeProxy#setXmlStandalone(boolean)::: node proxy set xml standalone:::
DTMNodeProxy#getXmlVersion()::: node proxy get xml version:::return
DTMNodeProxy#setXmlVersion(String)::: node proxy set xml version:::
DTMSafeStringPool#removeAllElements()::: safe string pool remove all elements:::super->removeAllElements
DTMSafeStringPool#indexToString(int)::: safe string pool index to string:::return->super->indexToString
DTMSafeStringPool#stringToIndex(String)::: safe string pool string to index:::return->super->stringToIndex
DTMSafeStringPool#_main(String[]):::Command-line unit test driver:::word->pool->new->DTMSafeStringPool->println->for->pass
DTMStringPool#removeAllElements()::: string pool remove all elements:::m_intToString->clear->for->i->m_hashChain->removeAllElements
DTMStringPool#indexToString(int)::: string pool index to string:::if->return->return->m_intToString->get
DTMStringPool#stringToIndex(String)::: string pool string to index:::if->return->hashslot->s->hashCode->if->hashlast->hashcandidate->while->if->m_intToString->get->equals->return->m_hashChain->elementAt->newIndex->m_intToString->size->m_intToString->add->m_hashChain->addElement->if->else->m_hashChain->setElementAt->return
DTMStringPool#_main(String[]):::Command-line unit test driver:::word->pool->new->DTMStringPool->println->for->pass
DTMTreeWalker#setDTM(DTM):::Set the DTM to be traversed.:::
DTMTreeWalker#getcontentHandler():::Get the ContentHandler used for the tree walk.:::return
DTMTreeWalker#setcontentHandler(ContentHandler):::Set the ContentHandler used for the tree walk.:::
DTMTreeWalker#traverse(int):::Perform a non-recursive pre-order/post-order traversal, operating as a Visitor:::top->while->startNode->nextNode->m_dtm->getFirstChild->while->endNode->if->break->m_dtm->getNextSibling->if->m_dtm->getParent->if->if->endNode->break
DTMTreeWalker#traverse(int, int):::Perform a non-recursive pre-order/post-order traversal, operating as a Visitor:::while->startNode->nextNode->m_dtm->getFirstChild->while->endNode->if->break->m_dtm->getNextSibling->if->m_dtm->getParent->if->break
DTMTreeWalker#dispatachChars(int):::Optimized dispatch of characters.:::m_dtm->dispatchCharactersEvents
DTMTreeWalker#startNode(int):::Start processing given node:::if->switch->m_dtm->getNodeType->data->m_dtm->getStringValue->if->lh->data->dispatchAsComment->break->break->startDocument->break->dtm->for->nsn->dtm->getFirstNamespaceNode->dtm->getNextNamespaceNode->ns->dtm->getNamespaceURI->if->attrs->new->org.xml.sax.helpers.AttributesImpl->for->i->dtm->getFirstAttribute->dtm->getNextAttribute->m_dtm->getLocalName->m_dtm->getNodeName->startElement->break->name->m_dtm->getNodeName->if->name->equals->else->m_dtm->getNodeValue->processingInstruction->break->isLexH->lh->if->lh->startCDATA->dispatachChars->if->lh->endCDATA->break->if->m_contentHandler->processingInstruction->dispatachChars->m_contentHandler->processingInstruction->else->dispatachChars->break->if->m_dtm->getNodeName->startEntity->else->break
DTMTreeWalker#endNode(int):::End processing of given node:::switch->m_dtm->getNodeType->endDocument->break->ns->m_dtm->getNamespaceURI->if->m_dtm->getLocalName->m_dtm->getNodeName->endElement->for->nsn->m_dtm->getFirstNamespaceNode->m_dtm->getNextNamespaceNode->break->break->if->lh->lh->m_dtm->getNodeName->endEntity->break
EmptyIterator#getInstance()::: empty iterator get instance:::return
EmptyIterator#next()::: empty iterator next:::return
EmptyIterator#reset()::: empty iterator reset:::return
EmptyIterator#getLast()::: empty iterator get last:::return
EmptyIterator#getPosition()::: empty iterator get position:::return
EmptyIterator#setMark()::: empty iterator set mark:::
EmptyIterator#gotoMark()::: empty iterator goto mark:::
EmptyIterator#setStartNode(int)::: empty iterator set start node:::return
EmptyIterator#getStartNode()::: empty iterator get start node:::return
EmptyIterator#isReverse()::: empty iterator is reverse:::return
EmptyIterator#cloneIterator()::: empty iterator clone iterator:::return
EmptyIterator#setRestartable(boolean)::: empty iterator set restartable:::
EmptyIterator#getNodeByPosition(int)::: empty iterator get node by position:::return
ExpandedNameTable#initExtendedTypes()::: Initialize the vector of extended types with the  basic DOM node types.:::new->ExtendedTypeArr->for->i
ExpandedNameTable#getExpandedTypeID(String, String, int):::Given an expanded name represented by namespace, local name and node type, return an ID:::return->getExpandedTypeID
ExpandedNameTable#getExpandedTypeID(String, String, int, boolean):::Given an expanded name represented by namespace, local name and node type, return an ID:::if->if->hash->namespace->hashCode->localName->hashCode->hashET->redefine->index->if->for->e->if->return->if->rehash->if->newET->new->ExtendedType->if->newArray->new->ExtendedTypeArr->System->arraycopy->entry->new->HashEntry->return
ExpandedNameTable#rehash():::Increases the capacity of and internally reorganizes the hashtable, in order to accommodate and access its entries more efficiently:::oldCapacity->oldTable->newCapacity->new->HashEntryArr->for->i
ExpandedNameTable#getExpandedTypeID(int):::Given a type, return an expanded name ID.Any additional nodes that are created that have this expanded name will use this ID.:::return
ExpandedNameTable#getLocalName(int):::Given an expanded-name ID, return the local name part.:::return->getLocalName
ExpandedNameTable#getLocalNameID(int):::Given an expanded-name ID, return the local name ID.:::if->getLocalName->equals->return->else->return
ExpandedNameTable#getNamespace(int):::Given an expanded-name ID, return the namespace URI part.:::namespace->getNamespace->return->namespace->equals
ExpandedNameTable#getNamespaceID(int):::Given an expanded-name ID, return the namespace URI ID.:::if->getNamespace->equals->return->else->return
ExpandedNameTable#getType(int):::Given an expanded-name ID, return the local name ID.:::return->getNodeType
ExpandedNameTable#getSize():::Return the size of the ExpandedNameTable:::return
ExpandedNameTable#getExtendedTypes():::Return the array of extended types:::return
ExtendedType#redefine(int, String, String):::Redefine this ExtendedType object to represent a different extended type:::namespace->hashCode->localName->hashCode
ExtendedType#redefine(int, String, String, int):::Redefine this ExtendedType object to represent a different extended type:::
ExtendedType#hashCode():::Override the hashCode() method in the Object class:::return
ExtendedType#equals(ExtendedType):::Test if this ExtendedType object is equal to the given ExtendedType.:::try->return->equals->equals->catch->return->finally
ExtendedType#getNodeType():::Return the node type:::return
ExtendedType#getLocalName():::Return the local name:::return
ExtendedType#getNamespace():::Return the namespace:::return
IncrementalSAXSource#setContentHandler(ContentHandler):::Register a SAX-style content handler for us to output to:::
IncrementalSAXSource#setLexicalHandler(org.xml.sax.ext.LexicalHandler)::: Register a SAX-style lexical handler for us to output to:::
IncrementalSAXSource#setDTDHandler(org.xml.sax.DTDHandler)::: Register a SAX-style DTD handler for us to output to:::
IncrementalSAXSource#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the thread in which the IncrementalSAXSource is running to deliver more events (true), or stop delivering events and close out its input (false):::
IncrementalSAXSource#startParse(InputSource):::Launch an XMLReader's parsing operation, feeding events to this IncrementalSAXSource:::
IncrementalSAXSource_Filter#createIncrementalSAXSource(CoroutineManager, int)::: incremental source_ filter create incremental source:::return->new->IncrementalSAXSource_Filter
IncrementalSAXSource_Filter#init(CoroutineManager, int, int)::: incremental source_ filter init:::if->new->CoroutineManager->co->co_joinCoroutineSet->co->co_joinCoroutineSet->if->throw->XMLMessages->createXMLMessage->new->RuntimeException
IncrementalSAXSource_Filter#setXMLReader(XMLReader):::Bind our input streams to an XMLReader:::eventsource->setContentHandler->eventsource->setDTDHandler->eventsource->setErrorHandler->try->eventsource->setProperty->catch->finally
IncrementalSAXSource_Filter#setContentHandler(ContentHandler)::: incremental source_ filter set content handler:::
IncrementalSAXSource_Filter#setDTDHandler(DTDHandler)::: incremental source_ filter set handler:::
IncrementalSAXSource_Filter#setLexicalHandler(LexicalHandler)::: incremental source_ filter set lexical handler:::
IncrementalSAXSource_Filter#setErrHandler(ErrorHandler)::: incremental source_ filter set err handler:::
IncrementalSAXSource_Filter#setReturnFrequency(int)::: incremental source_ filter set return frequency:::if
IncrementalSAXSource_Filter#characters(char[], int, int)::: incremental source_ filter characters:::if->co_yield->if->clientContentHandler->characters
IncrementalSAXSource_Filter#endDocument()::: incremental source_ filter end document:::if->clientContentHandler->endDocument->co_yield
IncrementalSAXSource_Filter#endElement(java.lang.String, java.lang.String, java.lang.String)::: incremental source_ filter end element:::if->co_yield->if->clientContentHandler->endElement
IncrementalSAXSource_Filter#endPrefixMapping(java.lang.String)::: incremental source_ filter end prefix mapping:::if->co_yield->if->clientContentHandler->endPrefixMapping
IncrementalSAXSource_Filter#ignorableWhitespace(char[], int, int)::: incremental source_ filter ignorable whitespace:::if->co_yield->if->clientContentHandler->ignorableWhitespace
IncrementalSAXSource_Filter#processingInstruction(java.lang.String, java.lang.String)::: incremental source_ filter processing instruction:::if->co_yield->if->clientContentHandler->processingInstruction
IncrementalSAXSource_Filter#setDocumentLocator(Locator)::: incremental source_ filter set document locator:::if->if->clientContentHandler->setDocumentLocator
IncrementalSAXSource_Filter#skippedEntity(java.lang.String)::: incremental source_ filter skipped entity:::if->co_yield->if->clientContentHandler->skippedEntity
IncrementalSAXSource_Filter#startDocument()::: incremental source_ filter start document:::co_entry_pause->if->co_yield->if->clientContentHandler->startDocument
IncrementalSAXSource_Filter#startElement(java.lang.String, java.lang.String, java.lang.String, Attributes)::: incremental source_ filter start element:::if->co_yield->if->clientContentHandler->startElement
IncrementalSAXSource_Filter#startPrefixMapping(java.lang.String, java.lang.String)::: incremental source_ filter start prefix mapping:::if->co_yield->if->clientContentHandler->startPrefixMapping
IncrementalSAXSource_Filter#comment(char[], int, int)::: incremental source_ filter comment:::if->clientLexicalHandler->comment
IncrementalSAXSource_Filter#endCDATA()::: incremental source_ filter end a:::if->clientLexicalHandler->endCDATA
IncrementalSAXSource_Filter#endDTD()::: incremental source_ filter end d:::if->clientLexicalHandler->endDTD
IncrementalSAXSource_Filter#endEntity(java.lang.String)::: incremental source_ filter end entity:::if->clientLexicalHandler->endEntity
IncrementalSAXSource_Filter#startCDATA()::: incremental source_ filter start a:::if->clientLexicalHandler->startCDATA
IncrementalSAXSource_Filter#startDTD(java.lang.String, java.lang.String, java.lang.String)::: incremental source_ filter start d:::if->clientLexicalHandler->startDTD
IncrementalSAXSource_Filter#startEntity(java.lang.String)::: incremental source_ filter start entity:::if->clientLexicalHandler->startEntity
IncrementalSAXSource_Filter#notationDecl(String, String, String)::: incremental source_ filter notation decl:::if->clientDTDHandler->notationDecl
IncrementalSAXSource_Filter#unparsedEntityDecl(String, String, String, String)::: incremental source_ filter unparsed entity decl:::if->clientDTDHandler->unparsedEntityDecl
IncrementalSAXSource_Filter#error(SAXParseException)::: incremental source_ filter error:::if->clientErrorHandler->error
IncrementalSAXSource_Filter#fatalError(SAXParseException)::: incremental source_ filter fatal error:::if->clientErrorHandler->error->co_yield
IncrementalSAXSource_Filter#warning(SAXParseException)::: incremental source_ filter warning:::if->clientErrorHandler->error
IncrementalSAXSource_Filter#getSourceCoroutineID()::: incremental source_ filter get source coroutine d:::return
IncrementalSAXSource_Filter#getControllerCoroutineID()::: incremental source_ filter get controller coroutine d:::return
IncrementalSAXSource_Filter#getCoroutineManager()::: incremental source_ filter get coroutine manager:::return
IncrementalSAXSource_Filter#count_and_yield(boolean):::In the SAX delegation code, I've inlined the count-down in the hope of encouraging compilers to deliver better performance:::if->if->co_yield
IncrementalSAXSource_Filter#co_entry_pause():::co_entry_pause is called in startDocument() before anything else happens:::if->init->try->arg->fCoroutineManager->co_entry_pause->if->co_yield->catch->if->e->printStackTrace->throw->new->SAXException->finally
IncrementalSAXSource_Filter#co_yield(boolean):::Co_Yield handles coroutine interactions while a parse is in progress:::if->return->try->arg->if->fCoroutineManager->co_resume->if->if->throw->new->StopException->fCoroutineManager->co_exit_to->catch->fCoroutineManager->co_exit->throw->new->SAXException->finally
IncrementalSAXSource_Filter#startParse(InputSource):::Launch a thread that will run an XMLReader's parse() operation within  a thread, feeding events to this IncrementalSAXSource_Filter:::if->throw->XMLMessages->createXMLMessage->new->SAXException->if->throw->XMLMessages->createXMLMessage->new->SAXException->ThreadControllerWrapper->runThread
IncrementalSAXSource_Filter#run()::: incremental source_ filter run:::if->return->if->println->arg->try->fXMLReader->parse->catch->if->println->inner->ex->getException->if->if->println->else->if->println->inner->printStackTrace->finally->try->fCoroutineManager->co_exit_to->catch->e->printStackTrace->fCoroutineManager->co_exit->finally
IncrementalSAXSource_Filter#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the coroutine parser that we need more nodes:::if->return->try->result->fCoroutineManager->co_resume->if->fCoroutineManager->co_exit->return->catch->return->finally
IncrementalSAXSource_Xerces#createIncrementalSAXSource()::: incremental source_ xerces create incremental source:::try->return->new->IncrementalSAXSource_Xerces->catch->iss->new->IncrementalSAXSource_Filter->iss->new->SAXParser->setXMLReader->return->finally
IncrementalSAXSource_Xerces#createIncrementalSAXSource(SAXParser)::: incremental source_ xerces create incremental source:::try->return->new->IncrementalSAXSource_Xerces->catch->iss->new->IncrementalSAXSource_Filter->iss->setXMLReader->return->finally
IncrementalSAXSource_Xerces#setContentHandler(org.xml.sax.ContentHandler)::: incremental source_ xerces set content handler:::setContentHandler
IncrementalSAXSource_Xerces#setLexicalHandler(org.xml.sax.ext.LexicalHandler)::: incremental source_ xerces set lexical handler:::try->setProperty->catch->finally
IncrementalSAXSource_Xerces#setDTDHandler(org.xml.sax.DTDHandler)::: incremental source_ xerces set handler:::setDTDHandler
IncrementalSAXSource_Xerces#startParse(InputSource):::startParse() is a simple API which tells the IncrementalSAXSource to begin reading a document.:::if->throw->XMLMessages->createXMLMessage->new->SAXException->if->throw->XMLMessages->createXMLMessage->new->SAXException->ok->try->parseSomeSetup->catch->throw->new->SAXException->finally->if->throw->XMLMessages->createXMLMessage->new->SAXException
IncrementalSAXSource_Xerces#deliverMoreNodes(boolean):::deliverMoreNodes() is a simple API which tells the coroutine parser that we need more nodes:::if->return->arg->try->keepgoing->parseSome->catch->new->SAXException->finally->return
IncrementalSAXSource_Xerces#parseSomeSetup(InputSource)::: incremental source_ xerces parse some setup:::if->parms1->source->getPublicId->source->getSystemId->xmlsource->fConfigInputSourceCtor->newInstance->parmsa->source->getByteStream->fConfigSetByteStream->invoke->source->getCharacterStream->fConfigSetCharStream->invoke->source->getEncoding->fConfigSetEncoding->invoke->noparms->new->ObjectArr->fReset->invoke->fConfigSetInput->invoke->return->parseSome->else->parm->ret->fParseSomeSetup->invoke->return->booleanValue
IncrementalSAXSource_Xerces#parseSome()::: incremental source_ xerces parse some:::if->ret->fConfigParse->invoke->return->booleanValue->else->ret->fParseSome->invoke->return->booleanValue
IncrementalSAXSource_Xerces#_main(String[]):::Simple unit test:::println->co->new->CoroutineManager->appCoroutineID->co->co_joinCoroutineSet->if->println->return->parser->createIncrementalSAXSource->trace->new->com.sun.org.apache.xml.internal.serialize.XMLSerializer->parser->setContentHandler->parser->setLexicalHandler->for->arg
NodeLocator#getPublicId():::getPublicId returns the public ID of the node.:::return
NodeLocator#getSystemId():::getSystemId returns the system ID of the node.:::return
NodeLocator#getLineNumber():::getLineNumber returns the line number of the node.:::return
NodeLocator#getColumnNumber():::getColumnNumber returns the column number of the node.:::return
NodeLocator#toString():::toString returns a string representation of this NodeLocator instance.:::return
