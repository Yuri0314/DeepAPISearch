ClassTracker.ClassInfo#getClassName()::: class info get class name:::return
ClassTracker.ClassInfo#getLoadedBytes()::: class info get loaded bytes:::return
ClassTracker.ClassInfo#getCurrentBytes()::: class info get current bytes:::return
ClassTracker.ClassInfo#setCurrentBytes(byte[])::: class info set current bytes:::
ClassTracker.ClassInfo#setLoadedBytes(byte[])::: class info set loaded bytes:::
ClassTracker.ClassInfo#isLoaded()::: class info is loaded:::return
ClassTracker.ClassInfo#isCurrent()::: class info is current:::return->Arrays->equals
ClassTracker.ClassInfo#toClassBytecodes()::: class info to class bytecodes:::return->new->ClassBytecodes
ClassTracker.ClassInfo#equals(Object)::: class info equals:::return->equals
ClassTracker.ClassInfo#hashCode()::: class info hash code:::return->Objects->hashCode
ClassTracker#markLoaded(ClassBytecodes[])::: class tracker mark loaded:::foreach->cbc->name->get->cbc->bytecodes->setLoadedBytes
ClassTracker#markLoaded(ClassBytecodes[], boolean[])::: class tracker mark loaded:::for->i
ClassTracker#setCurrentBytes(String, byte[])::: class tracker set current bytes:::ci->get->ci->setCurrentBytes
ClassTracker#get(String)::: class tracker get:::return->map->ClassInfo->new->computeIfAbsent
CompletenessAnalyzer#error()::: completeness analyzer error:::return
CompletenessAnalyzer#scan(String)::: completeness analyzer scan:::try->parser->scannerFactory->newScanner->new->Matched->parse->new->Parser->stat->parser->parseUnit->endPos->s->length->parser->endPos->return->new->CaInfo->catch->return->error->s->length->new->CaInfo->finally
CompletenessAnalyzer#die()::: completeness analyzer die:::throw->new->SyntaxException
CompletenessAnalyzer.CaLog#createLog(Context)::: ca log create log:::pw->new->StringWriter->new->PrintWriter->log->new->CaLog->context->put->return
CompletenessAnalyzer.CaLog#error(String, Object...)::: ca log error:::die
CompletenessAnalyzer.CaLog#error(int, Error)::: ca log error:::die
CompletenessAnalyzer.CaLog#error(int, String, Object...)::: ca log error:::die
CompletenessAnalyzer.CaLog#report(JCDiagnostic)::: ca log report:::
CompletenessAnalyzer.Matched#hasNext()::: matched has next:::return
CompletenessAnalyzer.Matched#advance()::: matched advance:::prev->scanner->nextToken->scanner->token->return
CompletenessAnalyzer.Matched#next()::: matched next:::nextCT->return
CompletenessAnalyzer.Matched#match(TK, TokenKind)::: matched match:::tok->advance->db->if->stack->isEmpty->return->new->CT->p->stack->pop->if->return->new->CT->return->new->CT
CompletenessAnalyzer.Matched#db(String, Object...)::: matched db:::
CompletenessAnalyzer.Matched#nextCT()::: matched next t:::prevTK->while->db->ct->switch->db->if->stack->isEmpty->new->CT->else->unmatched->stack->pop->stack->clear->new->CT->break->stack->advance->push->continue->match->break->match->break->match->break->TK->tokenKindToTK->advance->new->CT->break->if->isStart->prevTK->isOkToTerminate->return->new->CT->if->stack->isEmpty->isError->return
CompletenessAnalyzer.Parser#resetInput()::: parser reset input:::matchedFactory->get->nextToken
CompletenessAnalyzer.Parser#nextToken()::: parser next token:::in->next
CompletenessAnalyzer.Parser#shouldAbort(TK)::: parser should abort:::if->nextToken->return->switch->isOkToTerminate->return->return->error->return
CompletenessAnalyzer.Parser#lastly(TK)::: parser lastly:::if->shouldAbort->return->return
CompletenessAnalyzer.Parser#optionalFinalSemi()::: parser optional final semi:::if->shouldAbort->return->if->return->return
CompletenessAnalyzer.Parser#shouldAbort(Completeness)::: parser should abort:::return
CompletenessAnalyzer.Parser#endPos()::: parser end pos:::return
CompletenessAnalyzer.Parser#parseUnit()::: parser parse unit:::switch->return->parseExpressionOptionalSemi->stat->parseSimpleStatement->return->error->return->parseDeclaration->return->disambiguateDeclarationVsExpression->if->return->parseExpressionStatement->return->error->throw->new->InternalError
CompletenessAnalyzer.Parser#parseDeclaration()::: parser parse declaration:::isImport->isBracesNeeded->while->isDeclaration->isBracesNeeded->nextToken->switch->nextToken->return->parseExpressionStatement->nextToken->return->nextToken->return->switch->return->return->return->if->return->else->return->return->return->error
CompletenessAnalyzer.Parser#disambiguateDeclarationVsExpression()::: parser disambiguate declaration vs expression:::return->parseFactory->units->pt->units->if->units->isEmpty->return->error->unitTree->units->get->switch->unitTree->getKind->return->parseExpressionOptionalSemi->if->shouldAbort->return->if->shouldAbort->return->return->parseStatement->return->parseDeclaration->return->error->apply
CompletenessAnalyzer.Parser#parseExpressionStatement()::: parser parse expression statement:::if->parseExpression->shouldAbort->return->return->lastly
CompletenessAnalyzer.Parser#parseExpressionOptionalSemi()::: parser parse expression optional semi:::if->parseExpression->shouldAbort->return->return->optionalFinalSemi
CompletenessAnalyzer.Parser#parseExpression()::: parser parse expression:::while->isExpression->nextToken->return
CompletenessAnalyzer.Parser#parseStatement()::: parser parse statement:::stat->parseSimpleStatement->if->return->parseExpressionStatement->return
CompletenessAnalyzer.Parser#parseSimpleStatement():::Statement = Block | IF ParExpression Statement [ELSE Statement] | FOR "(" ForInitOpt ";" [Expression] ";" ForUpdateOpt ")" Statement | FOR "(" FormalParameter : Expression ")" Statement | WHILE ParExpression Statement | DO Statement WHILE ParExpression ";" | TRY Block ( Catches | [Catches] FinallyPart ) | TRY "(" ResourceSpecification ";"opt ")" Block [Catches] [FinallyPart] | SWITCH ParExpression "{" SwitchBlockStatementGroups "}" | SYNCHRONIZED ParExpression Block | RETURN [Expression] ";" | THROW Expression ";" | BREAK [Ident] ";" | CONTINUE [Ident] ";" | ASSERT Expression [ ":" Expression ] ";" | ";":::switch->return->lastly->nextToken->if->shouldAbort->return->thenpart->parseStatement->if->shouldAbort->return->if->nextToken->return->parseStatement->return->nextToken->if->shouldAbort->return->if->parseStatement->shouldAbort->return->return->nextToken->if->shouldAbort->return->error->return->parseStatement->nextToken->switch->parseStatement->return->return->error->break->if->shouldAbort->return->if->shouldAbort->return->return->lastly->hasResources->nextToken->if->nextToken->if->shouldAbort->return->if->while->if->shouldAbort->return->if->shouldAbort->return->if->shouldAbort->return->if->if->shouldAbort->return->if->shouldAbort->return->else->if->if->return->else->return->error->return->nextToken->if->shouldAbort->return->return->lastly->nextToken->if->shouldAbort->return->return->lastly->nextToken->if->parseExpression->shouldAbort->return->return->lastly->return->lastly->nextToken->return->parseExpressionStatement->nextToken->return->parseExpressionStatement->return->error->return->return
Corraller#corralType(ClassTree)::: corraller corral type:::return->corral
Corraller#corralMethod(MethodTree)::: corraller corral method:::return->corral
Corraller#corral(Tree)::: corraller corral:::try->printStat->catch->throw->new->AssertionError->finally->return->Wrap->out->toString->simpleWrap
Corraller#visitBlock(JCBlock)::: corraller visit block:::super->resolutionExceptionBlock->visitBlock
Corraller#visitVarDef(JCVariableDecl)::: corraller visit var def:::super->visitVarDef
Corraller#visitClassDef(JCClassDecl)::: corraller visit class def:::if->tree->getMembers->stream->t->getKind->getName->anyMatch->ndefs->new->ListBuffer<>->ndefs->addAll->ndefs->make->make->Modifiers->List->nil->List->nil->List->nil->resolutionExceptionBlock->MethodDef->add->ndefs->toList->super->visitClassDef
Corraller#resolutionExceptionBlock()::: corraller resolution exception block:::if->expClass->foreach->getName->split->nm->names->fromString->if->make->Ident->else->make->Select->exp->make->List->make->Literal->of->NewClass->make->List->make->Throw->of->Block->return
DeclarationSnippet#corralled()::: declaration snippet corralled:::return
DeclarationSnippet#declareReferences()::: declaration snippet declare references:::return
DeclarationSnippet#bodyReferences()::: declaration snippet body references:::return
DeclarationSnippet#importLine(JShell)::: declaration snippet import line:::return->classFullName->name
Diag#isError():::Indicates whether this diagnostic is an error (as opposed to a warning or note).:::
Diag#getPosition():::Returns a character offset from the beginning of the source object associated with this diagnostic that indicates the location of the problem:::
Diag#getStartPosition():::Returns the character offset from the beginning of the file associated with this diagnostic that indicates the start of the problem.:::
Diag#getEndPosition():::Returns the character offset from the beginning of the file associated with this diagnostic that indicates the end of the problem.:::
Diag#getCode():::Returns a diagnostic code indicating the type of diagnostic:::
Diag#getMessage(Locale):::Returns a localized message for the given locale:::
Diag#snippetOrNull():::Internal: If this is from a compile/analyze wrapped in an outer class, extract the snippet:::return
Diag#isUnreachableError():::This is an unreachable-statement error:::return->getCode->equals
Diag#isNotAStatementError():::This is a not-a-statement error:::return->getCode->equals
Diag#isResolutionError():::This is a resolution error.:::return->getCode->startsWith->getCode->equals
DiagList#tally(Diag)::: diag list tally:::if->d->isError->if->d->isUnreachableError->else->if->d->isNotAStatementError->else->if->d->isResolutionError->else
DiagList#addAll(Collection)::: diag list add all:::return->c->stream->this->add->filter->count
DiagList#set(int, Diag)::: diag list set:::throw->new->UnsupportedOperationException
DiagList#add(int, Diag)::: diag list add:::throw->new->UnsupportedOperationException
DiagList#add(Diag)::: diag list add:::added->super->add->if->tally->return
DiagList#addAll(int, Collection)::: diag list add all:::throw->new->UnsupportedOperationException
DiagList#remove(Object)::: diag list remove:::throw->new->UnsupportedOperationException
DiagList#ofUnit(Unit)::: diag list of unit:::return->this->stream->snn->d->snippetOrNull->return->u->snippet->filter->Collectors->DiagList->new->toCollection->collect
DiagList#hasErrors()::: diag list has errors:::return
DiagList#hasResolutionErrorsAndNoOthers()::: diag list has resolution errors and no others:::return
DiagList#hasUnreachableError()::: diag list has unreachable error:::return
DiagList#hasNotStatement()::: diag list has not statement:::return
DiagList#hasOtherThanNotStatementErrors()::: diag list has other than not statement errors:::return
ErroneousSnippet#probableKind():::Returns what appears to be the intended Kind in this erroneous snippet.:::return
Eval#eval(String):::Evaluates a snippet of source.:::allEvents->new->ArrayList<>->foreach->sourceToSnippets->if->snip->kind->installSnippet->allEvents->new->SnippetEvent->add->else->allEvents->snip->syntheticDiags->declare->addAll->return
Eval#sourceToSnippetsWithWrappers(String):::Converts the user source of a snippet into a Snippet list -- Snippet will have wrappers.:::snippets->sourceToSnippets->foreach->if->snip->outerWrap->snip->snip->kind->snip->guts->wrapImport->snip->guts->wrapInTrialClass->setOuterWrap->return
Eval#toScratchSnippets(String):::Converts the user source of a snippet into a Snippet object (or list of objects in the case of: int x, y, z;):::try->return->sourceToSnippets->catch->finally
Eval#sourceToSnippets(String):::Converts the user source of a snippet into a Snippet object (or list of objects in the case of: int x, y, z;):::compileSource->Util->new->MaskCommentsAndModifiers->cleared->trimEnd->if->compileSource->length->return->Collections->emptyList->return->units->pt->units->if->units->isEmpty->return->compileFailResult->unitTree->units->get->if->pt->getDiagnostics->hasOtherThanNotStatementErrors->return->kindOfTree->compileFailResult->compileSourceInt->new->MaskCommentsAndModifiers->cleared->state->unitTree->getKind->debug->switch->unitTree->getKind->return->processImport->return->processVariables->return->processExpression->return->processClass->return->processClass->return->processClass->return->processClass->return->processMethod->return->processStatement->parse
Eval#processImport(String, String)::: eval process import:::guts->Wrap->simpleWrap->mat->IMPORT_PATTERN->matcher->fullname->name->isStatic->if->mat->find->mat->group->mat->group->mat->group->else->compileSource->contains->fullkey->isStar->name->equals->keyName->snippetKind->snip->keyForImport->new->ImportSnippet->return->singletonList
Eval.EvalPretty#print(Object):::Print string, DO NOT replacing all non-ascii character with unicode escapes.:::out->o->toString->write
Eval.EvalPretty#prettyExpr(JCTree, boolean)::: eval pretty pretty expr:::out->new->StringWriter->try->new->EvalPretty->printExpr->catch->throw->new->AssertionError->finally->return->out->toString
Eval#processVariables(String, List, String, ParseTask)::: eval process variables:::snippets->new->ArrayList<>->dis->TreeDissector->createByFirstClass->foreach->vt->name->vt->getName->toString->typeName->fullTypeName->displayType->hasEnhancedType->tds->new->TreeDependencyScanner->typeWrap->anonDeclareWrap->winit->enhancedDesugaring->anonymousClasses->Collections->emptySet->sbBrackets->new->StringBuilder->baseType->vt->getType->if->tds->scan->EvalPretty->vt->getType->prettyExpr->while->getType->sbBrackets->append->rtype->dis->treeToRange->Wrap->rangeWrap->else->dl->Wrap->methodWrap->trialCompile->if->dl->hasErrors->return->kindOfTree->compileFailResult->init->vt->getInitializer->if->rinit->dis->treeToRange->initCode->rinit->part->ei->ExpressionToTypeInfo->localVariableTypeForInitializer->if->typeName->equals->anonymous2Member->anonymous2Member->stream->map->Collectors->toSet->collect->else->tds->scan->else->Wrap->identityWrap->runit->dis->treeToRange->new->Range->it->vt->getInitializer->nameMax->subkind->if->rinit->dis->treeToRange->Wrap->rangeWrap->else->nameStart->compileSource->lastIndexOf->if->throw->new->AssertionError->nameEnd->name->length->rname->new->Range->guts->Wrap->sbBrackets->toString->varWrap->modDiag->vt->getModifiers->modifierDiagnostics->snip->keyForVariable->tds->declareReferences->new->VarSnippet->snippets->add->return
Eval#anonymous2Member(ExpressionInfo, String, Range, TreeDissector, Tree):::Convert anonymous classes in "init" to member classes, based on the additional information from ExpressionInfo.anonymousClasses:::anonymousDeclarations->new->ArrayList<>->partitionedInit->new->ArrayList<>->lastPos->toConvert->ExpressionToTypeInfo->listAnonymousClassesToConvert->descriptions->while->toConvert->nonEmpty->descriptions->nonEmpty->node->ad->classBodyParts->new->ArrayList<>->foreach->classBodyParts->add->constructorParts->new->ArrayList<>->constructorParts->add->sep->if->constructorParts->add->idx->foreach->constructorParts->add->constructorParts->add->foreach->constructorParts->add->constructorParts->add->if->constructorParts->add->else->constructorParts->add->for->i->constructorParts->add->foreach->constructorParts->add->members->node->getClassBody->getMembers->foreach->if->member->getKind->vt->if->vt->getInitializer->wholeVar->dis->treeToRange->name->classBodyParts->Wrap->new->Range->rangeWrap->vt->getName->toString->new->CompoundWrap->add->constructorParts->Wrap->new->Range->rangeWrap->add->continue->classBodyParts->Wrap->dis->treeToRange->rangeWrap->add->constructorParts->add->classBodyParts->constructorParts->toArray->new->CompoundWrap->add->classBodyWrap->classBodyParts->toArray->new->CompoundWrap->anonymousDeclarations->new->CompoundWrap->add->argRange->dis->node->getArguments->treeListToRange->argWrap->if->Wrap->rangeWrap->else->Wrap->simpleWrap->if->enclosingRanges->dis->node->getEnclosingExpression->treeToRange->enclosingWrap->Wrap->rangeWrap->Wrap->simpleWrap->new->CompoundWrap->current->dis->treeToRange->capturedArgs->if->isEmpty->isEmpty->stream->map->Collectors->joining->collect->else->if->partitionedInit->Wrap->new->Range->rangeWrap->add->partitionedInit->new->CompoundWrap->add->if->partitionedInit->Wrap->new->Range->rangeWrap->add->return->anonymousDeclarations->toArray->new->CompoundWrap->partitionedInit->toArray->new->CompoundWrap->new->Pair<>
Eval#processExpression(String, Tree, String, ParseTask)::: eval process expression:::expr->name->ei->ExpressionToTypeInfo->expressionInfo->assignVar->guts->snip->if->typeName->subkind->if->id->id->getName->toString->else->if->getVariable->assignVar->toString->else->if->shouldGenTempVar->if->else->if->get->while->doesVariableNameExist->dis->TreeDissector->createByFirstClass->varEI->ExpressionToTypeInfo->localVariableTypeForInitializer->declareTypeName->fullTypeName->displayTypeName->anonymousClasses->if->anonymous2Member->compileSource->length->new->Range->expr->getExpression->anonymous2Member->Wrap->wrapped->tempVarWrap->stream->map->Collectors->toSet->collect->else->Wrap->tempVarWrap->Collections->emptySet->declareReferences->keyForVariable->new->VarSnippet->else->Wrap->methodReturnWrap->keyForExpression->new->ExpressionSnippet->else->Wrap->methodWrap->if->dl->trialCompile->if->dl->hasNotStatement->Wrap->methodReturnWrap->trialCompile->if->dl->hasErrors->return->compileFailResult->keyForStatement->new->StatementSnippet->return->singletonList
Eval#processClass(String, Tree, String, SubKind, ParseTask)::: eval process class:::tds->new->TreeDependencyScanner->tds->scan->dis->TreeDissector->createByFirstClass->klassTree->name->klassTree->getSimpleName->toString->modDiag->klassTree->getModifiers->modifierDiagnostics->key->keyForClass->corralled->key->index->pt->getContext->new->Corraller->corralType->guts->Wrap->classMemberWrap->snip->tds->declareReferences->tds->bodyReferences->new->TypeDeclSnippet->return->singletonList
Eval#processStatement(String, String)::: eval process statement:::guts->Wrap->methodWrap->dl->trialCompile->if->dl->hasErrors->if->dl->hasUnreachableError->Wrap->methodUnreachableSemiWrap->trialCompile->if->dl->hasErrors->if->dl->hasUnreachableError->Wrap->methodUnreachableWrap->trialCompile->if->dl->hasErrors->return->compileFailResult->else->return->compileFailResult->snip->keyForStatement->new->StatementSnippet->return->singletonList
Eval#trialCompile(Wrap)::: eval trial compile:::outer->wrapInTrialClass->return->AnalyzeTask->getDiagnostics->analyze
Eval#processMethod(String, Tree, String, ParseTask)::: eval process method:::tds->new->TreeDependencyScanner->tds->scan->dis->TreeDissector->createByFirstClass->mt->name->mt->getName->toString->if->objectMethods->contains->possibleStart->dis->mt->getReturnType->getEndPosition->possibleRange->dis->mt->getBody->getStartPosition->new->Range->possibleNameSection->possibleRange->part->offset->possibleNameSection->indexOf->start->return->objectMethodNameDiag->new->DiagList->compileFailResult->parameterTypes->mt->getParameters->stream->dis->param->getType->treeToRange->part->map->Collectors->joining->collect->returnType->mt->getReturnType->modDiag->mt->getModifiers->modifierDiagnostics->key->keyForMethod->corralled->key->index->pt->getContext->new->Corraller->corralMethod->if->modDiag->hasErrors->return->compileFailResult->guts->Wrap->classMemberWrap->typeRange->dis->treeToRange->signature->typeRange->part->snip->tds->declareReferences->tds->bodyReferences->new->MethodSnippet->return->singletonList
Eval#kindOfTree(Tree)::: eval kind of tree:::switch->tree->getKind->return->return->return->return->return->return
Eval#compileFailResult(BaseTask, String, Kind):::The snippet has failed, return with the rejected snippet:::return->xt->getDiagnostics->compileFailResult
Eval#compileFailResult(DiagList, String, Kind):::The snippet has failed, return with the rejected snippet:::key->keyForErroneous->snip->new->ErroneousSnippet->snip->setFailed->compileSource->Util->new->MaskCommentsAndModifiers->cleared->trimEnd->outer->switch->Wrap->simpleWrap->wrapImport->break->Wrap->methodReturnWrap->wrapInTrialClass->break->Wrap->classMemberWrap->wrapInTrialClass->break->Wrap->methodWrap->wrapInTrialClass->break->snip->setOuterWrap->return->singletonList
Eval#shouldGenTempVar(SubKind):::Should a temp var wrap the expression:::return
Eval#drop(Snippet)::: eval drop:::c->new->Unit->outs->if->ins->c->dependents->toSet->collect->compileAndLoad->else->Collections->emptySet->return->events
Eval#declare(Snippet, DiagList)::: eval declare:::c->new->Unit->ins->new->LinkedHashSet<>->ins->add->outs->compileAndLoad->if->si->status->isDefined->si->diagnostics->isEmpty->si->unresolved->isEmpty->si->outs->stream->u->snippet->diagnostics->stream->flatMap->Collectors->DiagList->new->toCollection->collect->setDiagnostics->value->exception->if->si->status->isDefined->if->si->isExecutable->try->state->executionControl->si->classFullName->invoke->si->subKind->hasValue->expunge->catch->asUnresolvedReferenceException->asEvalException->state->debug->state->debug->state->closeDown->finally->else->if->si->subKind->switch->typeName->break->break->break->break->break->return->events
Eval#asEvalException(UserException)::: eval as eval exception:::return->ue->getMessage->ue->causeExceptionClass->translateExceptionStack->ue->getCause->asJShellException->new->EvalException
Eval#asUnresolvedReferenceException(ResolutionException)::: eval as unresolved reference exception:::sn->re->id->getSnippetDeadOrAlive->return->translateExceptionStack->new->UnresolvedReferenceException
Eval#asJShellException(Throwable)::: eval as shell exception:::if->return->else->if->return->asEvalException->else->if->return->asUnresolvedReferenceException->else->throw->new->AssertionError
Eval#interestingEvent(SnippetEvent)::: eval interesting event:::return->e->isSignatureChange->e->causeSnippet->e->status->e->previousStatus->e->exception
Eval#events(Unit, Collection, String, JShellException)::: eval events:::events->new->ArrayList<>->events->c->event->add->events->outs->stream->filter->u->event->map->this->interestingEvent->filter->Collectors->toList->collect->addAll->events->outs->stream->u->secondaryEvents->stream->flatMap->this->interestingEvent->filter->Collectors->toList->collect->addAll->return
Eval#outerWrapSet(Collection)::: eval outer wrap set:::return->units->stream->u->snippet->outerWrap->map->toSet->collect
Eval#compileAndLoad(Set)::: eval compile and load:::if->ins->isEmpty->return->replaced->new->LinkedHashSet<>->while->state->debug->ins->stream->Unit->initialize->forEach->ins->stream->u->setWrap->forEach->outerWrapSet->ins->stream->u->setDiagnostics->forEach->if->ins->stream->u->corralIfNeeded->anyMatch->outerWrapSet->ins->stream->u->setCorralledDiagnostics->forEach->ins->stream->u->setStatus->forEach->return->analyze->else->ins->stream->u->setStatus->forEach->return->analyze->success->while->legit->ins->stream->Unit->isDefined->filter->toList->collect->state->debug->if->legit->isEmpty->else->legit->stream->u->setWrap->forEach->res->outerWrapSet->if->ct->compile->if->legit->stream->u->smashingErrorDiagnostics->filter->count->return->else->state->debug->legit->stream->u->ct->u->snippet->outerWrap->classList->classesToLoad->flatMap->toSet->collect->load->toReplace->legit->stream->u->doRedefines->filter->toList->collect->if->toReplace->isEmpty->replaced->addAll->replaced->stream->Unit->markForReplacement->forEach->replaced->stream->u->setWrap->forEach->return->toReplace->isEmpty->compile->switch->continue->break->break->break->newDependencies->ins->stream->Unit->effectedDependents->flatMap->toList->collect->state->debug->if->ins->addAll->ins->stream->Unit->finish->forEach->return
Eval#load(Collection):::If there are classes to load, loads by calling the execution engine.:::if->classbytecodes->isEmpty->cbcs->classbytecodes->classbytecodes->size->new->ClassBytecodesArr->toArray->try->state->executionControl->load->markLoaded->catch->ex->installed->markLoaded->state->debug->state->closeDown->state->closeDown->finally
Eval#translateExceptionStack(Exception)::: eval translate exception stack:::raw->ex->getStackTrace->last->do->if->break->while->isWrap->elems->new->StackTraceElementArr->for->i->return
Eval#isWrap(StackTraceElement)::: eval is wrap:::return->PREFIX_PATTERN->ste->getClassName->matcher->find
Eval#objectMethodNameDiag(String, long):::Construct a diagnostic for a method name matching an Object method name:::return->new->Diag
Eval#modifierDiagnostics(ModifiersTree, TreeDissector, boolean)::: eval modifier diagnostics:::list->new->ArrayList<>->fatal->foreach->modtree->getFlags->switch->list->add->break->if->list->add->break->break->list->add->break->return->list->isEmpty->new->DiagList->new->ModifierDiagnostic->new->DiagList
Eval#computeDeclareName(TypeSymbol)::: eval compute declare name:::return->Long->toUnsignedString
EvalException#getExceptionClassName():::Returns the name of the Throwable subclass which was thrown in the executing client:::return
EvalException#getCause():::Returns the wrapped cause of the throwable in the executing client represented by this EvalException or null if the cause is nonexistent or unknown.:::return->super->getCause
ExpressionSnippet#name():::Variable name which is the value of the expression:::return->key->name
ExpressionSnippet#typeName():::Type of the expression:::return->key->typeName
ExpressionSnippet#key()::: expression snippet key:::return->super->key
ExpressionToTypeInfo.PathFinder#visitCompilationUnit(CompilationUnitTree, Boolean)::: path finder visit compilation unit:::return->node->getTypeDecls->scan
ExpressionToTypeInfo.PathFinder#visitClass(ClassTree, Boolean)::: path finder visit class:::return->node->getMembers->scan
ExpressionToTypeInfo.PathFinder#visitMethod(MethodTree, Boolean)::: path finder visit method:::if->Util->node->getName->isDoIt->return->node->getBody->scan->else->return
ExpressionToTypeInfo.PathFinder#visitReturn(ReturnTree, Boolean)::: path finder visit return:::tree->node->getExpression->tp->getCurrentPath->new->TreePath->if->throw->new->Result->else->return
ExpressionToTypeInfo.PathFinder#visitVariable(VariableTree, Boolean)::: path finder visit variable:::if->throw->getCurrentPath->new->Result->else->return
ExpressionToTypeInfo#pathToType(TreePath)::: expression to type info path to type:::return->at->trees->getTypeMirror
ExpressionToTypeInfo#pathToType(TreePath, Tree)::: expression to type info path to type:::if->cet->tmt->cet->getTrueExpression->new->TreePath->pathToType->tmf->cet->getFalseExpression->new->TreePath->pathToType->if->tmt->isPrimitive->tmf->isPrimitive->lub->types->lub->return->return->pathToType
ExpressionToTypeInfo#expressionInfo(String, JShell):::Entry method: get expression info:::if->code->isEmpty->return->codeWrap->Wrap->methodReturnWrap->wrapInTrialClass->try->return->cu->at->firstCuTree->if->at->hasErrors->return->return->new->ExpressionToTypeInfo->typeOfExpression->analyze->catch->return->finally
ExpressionToTypeInfo#localVariableTypeForInitializer(String, JShell, boolean):::Entry method: get expression info corresponding to a local variable declaration if its type has been inferred automatically from the given initializer.:::if->code->isEmpty->return->try->codeWrap->Wrap->methodWrap->wrapInTrialClass->return->cu->at->firstCuTree->if->at->hasErrors->return->return->new->ExpressionToTypeInfo->typeOfExpression->analyze->catch->return->finally
ExpressionToTypeInfo#listAnonymousClassesToConvert(Tree):::List (in a stable order) all NewClassTree instances under from that should be converted to member classes:::classes->new->ListBuffer<>->new->TreeScanner<Void,Void>->scan->return->classes->toList
ExpressionToTypeInfo#typeOfExpression()::: expression to type info type of expression:::return->findExpressionPath->treeToInfo
ExpressionToTypeInfo#findExpressionPath()::: expression to type info find expression path:::try->new->PathFinder->new->TreePath->scan->catch->return->finally->return
ExpressionToTypeInfo#isAccessible(Type):::A type is accessible if it is public or if it is package-private and is a type defined in JShell:::tsym->type->asElement->return->tsym->flags->tsym->flags->Util->tsym->flatName->toString->isInJShellClass->type->getTypeArguments->stream->this->isAccessible->allMatch
ExpressionToTypeInfo#supertype(Type):::Return the superclass.:::sup->types->supertype->if->return->return
ExpressionToTypeInfo#findAccessibleSupertypes(Type):::Find an accessible supertype.:::accessible->List->nil->accessibleSuper->for->sup->types->isSameType->supertype->for->sup->types->isSameType->supertype->if->accessible->isEmpty->accessible->prepend->return->accessible->reverse
ExpressionToTypeInfo#treeToInfo(TreePath)::: expression to type info tree to info:::if->tree->tp->getLeaf->isExpression->if->tree->getKind->ei->new->ExpressionInfo->if->type->pathToType->if->switch->type->getKind->break->break->type->isPrimitive->varTypeName->accessibleTypes->findAccessibleSupertypes->varTypeName->if->accessibleType->accessibleTypes->size->types->makeIntersectionType->varTypeName->varTypeName->varTypeName->break->if->tree->getKind->init->getInitializer->foreach->listAnonymousClassesToConvert->captured->tp->getCompilationUnit->capturedVariables->clazz->node->getClassBody->superCall->clazz->getMembers->stream->TreeInfo->firstConstructorCall->map->findAny->get->superCallPath->at->trees->tp->getCompilationUnit->superCall->getMethodSelect->getPath->constrType->pathToType->desc->new->AnonymousDescription->constrType->getParameterTypes->stream->varTypeName->map->List->collector->collect->if->node->getEnclosingExpression->enclPath->node->getEnclosingExpression->new->TreePath->pathToType->varTypeName->currentPath->at->trees->tp->getCompilationUnit->getPath->nodeType->pathToType->varTypeName->varTypeName->captured->stream->ve->asType->varTypeName->ve->getSimpleName->toString->new->VariableDesc->map->List->collector->collect->getTypes->directSupertypes->size->prepend->reverse->return->return
ExpressionToTypeInfo#capturedVariables(AnalyzeTask, CompilationUnitTree, Tree)::: expression to type info captured variables:::capturedVars->new->HashSet<>->new->TreeScanner<Void,Void>->scan->return
ExpressionToTypeInfo#varTypeName(Type, boolean, AnonymousTypeKind)::: expression to type info var type name:::try->anonymousClass2DeclareName->anon2Name->state.eval->computeDeclareName->computeIfAbsent->tp->at->messages->state.maps->fullClassNameAndPackageToClass->new->TypePrinter->captures->types->captures->res->tp->types->upward->toString->if->return->catch->return->finally
GeneralWrap#wrapped()::: general wrap wrapped:::
GeneralWrap#snippetIndexToWrapIndex(int)::: general wrap snippet index to wrap index:::
GeneralWrap#wrapIndexToSnippetIndex(int)::: general wrap wrap index to snippet index:::
GeneralWrap#wrapIndexToSnippetIndex(long)::: general wrap wrap index to snippet index:::return->wrapIndexToSnippetIndex
GeneralWrap#firstSnippetIndex()::: general wrap first snippet index:::
GeneralWrap#lastSnippetIndex()::: general wrap last snippet index:::
GeneralWrap#snippetLineToWrapLine(int)::: general wrap snippet line to wrap line:::
GeneralWrap#wrapLineToSnippetLine(int)::: general wrap wrap line to snippet line:::
GeneralWrap#firstSnippetLine()::: general wrap first snippet line:::
GeneralWrap#lastSnippetLine()::: general wrap last snippet line:::
GeneralWrap#debugPos(long)::: general wrap debug pos:::pos->len->wrapped->length->return->wrapped->Math->max->Math->Math->min->max->substring->wrapped->Math->Math->min->max->Math->Math->min->max->substring
ImportSnippet#name():::The identifying name of the import:::return->key->name
ImportSnippet#fullname():::The qualified name of the import:::return
ImportSnippet#isStatic():::Indicates whether this snippet represents a static import.:::return
ImportSnippet#key()::: import snippet key:::return->super->key
ImportSnippet#importLine(JShell)::: import snippet import line:::return->guts->wrapped
JShell.Builder#in(InputStream):::Sets the input for the running evaluation (it's System.in):::return
JShell.Builder#out(PrintStream):::Sets the output for the running evaluation (it's System.out):::return
JShell.Builder#err(PrintStream):::Sets the error output for the running evaluation (it's System.err):::return
JShell.Builder#tempVariableNameGenerator(Supplier):::Sets a generator of temp variable names for jdk.jshell.VarSnippet of jdk.jshell.Snippet.SubKind#TEMP_VAR_EXPRESSION_SUBKIND:::return
JShell.Builder#idGenerator(BiFunction):::Sets the generator of identifying names for Snippets:::return
JShell.Builder#remoteVMOptions(String...):::Sets additional VM options for launching the VM.:::Arrays->asList->addAll->return
JShell.Builder#compilerOptions(String...):::Adds compiler options:::Arrays->asList->addAll->return
JShell.Builder#executionEngine(String):::Sets the custom engine for execution:::return
JShell.Builder#executionEngine(ExecutionControlProvider, Map):::Sets the custom engine for execution:::return
JShell.Builder#fileManager(Function):::Configure the FileManager to be used by compilation and source analysis:::return
JShell.Builder#build():::Builds a JShell state engine:::return->new->JShell
JShell#create():::Create a new JShell state engine:::return->builder->build
JShell#builder():::Factory method for JShell.Builder which, in-turn, is used for creating instances of JShell:::return->new->Builder
JShell#sourceCodeAnalysis():::Access to source code analysis functionality:::if->new->SourceCodeAnalysisImpl->return
JShell#eval(String):::Evaluate the input String, including definition and/or execution, if applicable:::a->if->a->suspendIndexing->try->checkIfAlive->events->eval->eval->events->this->notifyKeyStatusEvent->forEach->return->Collections->unmodifiableList->catch->finally->if->a->resumeIndexing
JShell#drop(Snippet):::Remove a declaration from the state:::checkIfAlive->checkValidSnippet->events->eval->drop->events->this->notifyKeyStatusEvent->forEach->return->Collections->unmodifiableList
JShell#addToClasspath(String):::The specified path is added to the end of the classpath used in eval():::checkIfAlive->taskFactory->addToClasspath->try->executionControl->addToClasspath->catch->debug->finally->if->sourceCodeAnalysis->classpathChanged
JShell#stop():::Attempt to stop currently running evaluation:::if->try->executionControl->stop->catch->debug->finally
JShell#close():::Close this state engine:::closeDown
JShell#snippets():::Return all snippets.:::return->maps->snippetList->stream
JShell#variables():::Returns the active variable snippets:::return->snippets->status->isActive->sn->kind->filter->map
JShell#methods():::Returns the active method snippets:::return->snippets->status->isActive->sn->kind->filter->map
JShell#types():::Returns the active type declaration (class, interface, annotation type, and enum) snippets:::return->snippets->status->isActive->sn->kind->filter->map
JShell#imports():::Returns the active import snippets:::return->snippets->status->isActive->sn->kind->filter->map
JShell#status(Snippet):::Return the status of the snippet:::return->checkValidSnippet->status
JShell#diagnostics(Snippet):::Return the diagnostics of the most recent evaluation of the snippet:::return->checkValidSnippet->diagnostics->stream
JShell#unresolvedDependencies(DeclarationSnippet):::For jdk.jshell.Snippet.Status#RECOVERABLE_DEFINED RECOVERABLE_DEFINED or jdk.jshell.Snippet.Status#RECOVERABLE_NOT_DEFINED RECOVERABLE_NOT_DEFINED declarations, the names of current unresolved dependencies for the snippet:::return->checkValidSnippet->unresolved->stream
JShell#varValue(VarSnippet):::Get the current value of a variable.:::checkIfAlive->checkValidSnippet->if->snippet->status->throw->snippet->status->messageFormat->new->IllegalArgumentException->value->try->executionControl->snippet->classFullName->snippet->name->varValue->catch->throw->ex->getMessage->new->IllegalStateException->debug->return->ex->getMessage->finally->return->expunge
JShell#onSnippetEvent(Consumer):::Register a callback to be called when the Status of a snippet changes:::return->onX
JShell#onShutdown(Consumer):::Register a callback to be called when this JShell instance terminates:::return->onX
JShell#unsubscribe(Subscription):::Cancel a callback subscription.:::synchronized->accept
JShell.ExecutionEnvImpl#userIn()::: execution env impl user in:::return
JShell.ExecutionEnvImpl#userOut()::: execution env impl user out:::return
JShell.ExecutionEnvImpl#userErr()::: execution env impl user err:::return
JShell.ExecutionEnvImpl#extraRemoteVMOptions()::: execution env impl extra remote options:::return
JShell.ExecutionEnvImpl#closeDown()::: execution env impl close down:::JShell.this->closeDown
JShell#executionControl()::: shell execution control:::return
JShell#debug(int, String, Object...)::: shell debug:::InternalDebugControl->debug
JShell#debug(Throwable, String)::: shell debug:::InternalDebugControl->debug
JShell#nextKeyIndex():::Generate the next key index, indicating a unique snippet signature.:::return
JShell#onX(Map>, Consumer)::: shell on x:::Objects->requireNonNull->checkIfAlive->token->map->remove->new->Subscription->map->put->return
JShell#notifyKeyStatusEvent(SnippetEvent)::: shell notify key status event:::keyStatusListeners->values->l->accept->forEach
JShell#notifyShutdownEvent(JShell)::: shell notify shutdown event:::shutdownListeners->values->l->accept->forEach
JShell#closeDown()::: shell close down:::if->try->notifyShutdownEvent->catch->finally->try->executionControl->close->catch->finally->if->sourceCodeAnalysis->close->InternalDebugControl->release
JShell#checkIfAlive():::Check if this JShell has been closed:::if->throw->messageFormat->new->IllegalStateException
JShell#checkValidSnippet(Snippet):::Check a Snippet parameter coming from the API user:::if->throw->messageFormat->new->NullPointerException->else->if->sn->key->state->sn->id->throw->sn->toString->messageFormat->new->IllegalArgumentException->return
JShell#messageFormat(String, Object...):::Format using resource bundle look-up using MessageFormat:::if->try->ResourceBundle->getBundle->catch->throw->new->InternalError->finally->s->try->outputRB->getString->catch->throw->new->InternalError->finally->return->MessageFormat->format
Key#index():::The unique numeric identifier for the snippet:::return
Key#kind():::The kind for the key:::
Key#state():::For foreign key testing.:::return
Key.PersistentKey#name():::Name of the snippet.:::return
Key.TypeDeclKey#kind()::: type decl key kind:::return
Key.TypeDeclKey#toString()::: type decl key to string:::return->name->index
Key.MethodKey#kind()::: method key kind:::return
Key.MethodKey#parameterTypes():::The parameter types of the method:::return
Key.MethodKey#toString()::: method key to string:::return->name->parameterTypes->index
Key.VarKey#kind()::: var key kind:::return
Key.VarKey#toString()::: var key to string:::return->name->index
Key.ImportKey#kind()::: import key kind:::return
Key.ImportKey#snippetKind():::Which kind of import.:::return
Key.ImportKey#toString()::: import key to string:::return->name->index
Key.StatementKey#kind()::: statement key kind:::return
Key.StatementKey#toString()::: statement key to string:::return->index
Key.ExpressionKey#kind()::: expression key kind:::return
Key.ExpressionKey#name():::Variable name which is the value of the expression:::return
Key.ExpressionKey#typeName():::Type of the expression:::return
Key.ExpressionKey#toString()::: expression key to string:::return->name->index
Key.ErroneousKey#kind()::: erroneous key kind:::return
Key.ErroneousKey#toString()::: erroneous key to string:::return->index
KeyMap#keyForClass(String)::: key map key for class:::return->classMap->new->TypeDeclKey->computeIfAbsent
KeyMap#keyForMethod(String, String)::: key map key for method:::return->methodMap->new->MethodKey->computeIfAbsent
KeyMap#keyForVariable(String)::: key map key for variable:::return->varMap->new->VarKey->computeIfAbsent
KeyMap#keyForImport(String, SubKind)::: key map key for import:::return->importMap->snippetKind->toString->new->ImportKey->computeIfAbsent
KeyMap#keyForStatement()::: key map key for statement:::return->new->StatementKey
KeyMap#keyForExpression(String, String)::: key map key for expression:::return->new->ExpressionKey
KeyMap#keyForErroneous()::: key map key for erroneous:::return->new->ErroneousKey
KeyMap#doesVariableNameExist(String)::: key map does variable name exist:::return->varMap->get
KeyMap#importKeys()::: key map import keys:::return->importMap->values->stream
MaskCommentsAndModifiers#cleared()::: mask comments and modifiers cleared:::return->sbCleared->toString
MaskCommentsAndModifiers#mask()::: mask comments and modifiers mask:::return->sbMask->toString
MaskCommentsAndModifiers#endsWithOpenComment()::: mask comments and modifiers ends with open comment:::return
MaskCommentsAndModifiers#read():::Read the next character:::return->str->charAt
MaskCommentsAndModifiers#unread()::: mask comments and modifiers unread:::if
MaskCommentsAndModifiers#writeTo(StringBuilder, int)::: mask comments and modifiers write to:::sb->append
MaskCommentsAndModifiers#write(int)::: mask comments and modifiers write:::if->writeTo->Character->isWhitespace->writeTo
MaskCommentsAndModifiers#writeMask(int)::: mask comments and modifiers write mask:::if->writeTo->Character->isWhitespace->writeTo
MaskCommentsAndModifiers#write(CharSequence)::: mask comments and modifiers write:::foreach->s->chars->toArray->write
MaskCommentsAndModifiers#writeMask(CharSequence)::: mask comments and modifiers write mask:::foreach->s->chars->toArray->writeMask
MaskCommentsAndModifiers#next()::: mask comments and modifiers next:::switch->write->match->while->read->write->if->read->write->write->break->read->switch->writeMask->writeMask->prevc->while->read->writeMask->writeMask->break->writeMask->writeMask->while->read->writeMask->writeMask->break->write->unread->break->break->do->write->read->while->Character->isJavaIdentifierPart->while->Character->isWhitespace->write->read->if->write->prevMaskModifiers->parenCnt->while->read->if->if->break->else->if->next->write->else->unread->break->if->Character->isJavaIdentifierStart->sb->new->StringBuilder->do->writeTo->read->while->Character->isJavaIdentifierPart->unread->id->sb->toString->if->IGNORED_MODIFIERS->contains->writeMask->else->write->if->OTHER_MODIFIERS->contains->else->if->Character->isWhitespace->write->break
MemoryFileManager#getLocationAsPaths(Location)::: memory file manager get location as paths:::return->getLocationAsPaths
MemoryFileManager.SourceMemoryJavaFileObject#getOrigin()::: source memory java file object get origin:::return
MemoryFileManager.SourceMemoryJavaFileObject#getCharContent(boolean)::: source memory java file object get char content:::return
MemoryFileManager.OutputMemoryJavaFileObject#getBytes()::: output memory java file object get bytes:::if->bos->toByteArray->return
MemoryFileManager.OutputMemoryJavaFileObject#dump()::: output memory java file object dump:::try->dumpDir->FileSystems->getDefault->getPath->if->Files->notExists->Files->createDirectory->file->FileSystems->getDefault->getName->getPath->Files->getBytes->write->catch->throw->new->RuntimeException->finally
MemoryFileManager.OutputMemoryJavaFileObject#getName()::: output memory java file object get name:::return
MemoryFileManager.OutputMemoryJavaFileObject#openOutputStream():::Will provide the compiler with an output stream that leads to our byte array.:::return
MemoryFileManager.OutputMemoryJavaFileObject#openInputStream()::: output memory java file object open input stream:::return->getBytes->new->ByteArrayInputStream
MemoryFileManager#generatedClasses()::: memory file manager generated classes:::return->classObjects->values
MemoryFileManager#dumpClasses()::: memory file manager dump classes:::foreach->generatedClasses->co->dump
MemoryFileManager#createSourceFileObject(Object, String, String)::: memory file manager create source file object:::return->new->SourceMemoryJavaFileObject
MemoryFileManager#getClassLoader(JavaFileManager.Location):::Returns a class loader for loading plug-ins from the given location:::proc->debug->return->stdFileManager->getClassLoader
MemoryFileManager#list(JavaFileManager.Location, String, Set, boolean):::Lists all file objects matching the given criteria in the given location:::stdList->stdFileManager->list->if->packageName->equals->return->new->Iterator<JavaFileObject>->else->return
MemoryFileManager#inferBinaryName(JavaFileManager.Location, JavaFileObject):::Infers a binary name of a file object based on a location:::if->ofo->proc->ofo->getName->debug->return->ofo->getName->else->return->stdFileManager->inferBinaryName
MemoryFileManager#isSameFile(FileObject, FileObject):::Compares two file objects and return true if they represent the same underlying object.:::return->stdFileManager->isSameFile
MemoryFileManager#isSupportedOption(String):::Determines if the given option is supported and if so, the number of arguments the option takes.:::proc->debug->return->stdFileManager->isSupportedOption
MemoryFileManager#handleOption(String, Iterator):::Handles one option:::proc->debug->return->stdFileManager->handleOption
MemoryFileManager#hasLocation(JavaFileManager.Location):::Determines if a location is known to this file manager.:::proc->debug->return->stdFileManager->hasLocation
MemoryFileManager.ClassFileCreationListener#newClassFile(OutputMemoryJavaFileObject, JavaFileManager.Location, String, Kind, FileObject)::: class file creation listener new class file:::
MemoryFileManager#registerClassFileCreationListener(ClassFileCreationListener)::: memory file manager register class file creation listener:::
MemoryFileManager#getJavaFileForInput(JavaFileManager.Location, String, JavaFileObject.Kind):::Returns a JavaFileObject file object for input representing the specified class of the specified kind in the given location.:::return->stdFileManager->getJavaFileForInput
MemoryFileManager#getJavaFileForOutput(JavaFileManager.Location, String, Kind, FileObject):::Returns a JavaFileObject file object for output representing the specified class of the specified kind in the given location:::fo->new->OutputMemoryJavaFileObject->classObjects->put->proc->debug->if->classListener->newClassFile->return
MemoryFileManager#getFileForInput(JavaFileManager.Location, String, String):::Returns a FileObject file object for input representing the specified relative name in the specified package in the given location:::proc->debug->return->stdFileManager->getFileForInput
MemoryFileManager#getFileForOutput(JavaFileManager.Location, String, String, FileObject):::Returns a FileObject file object for output representing the specified relative name in the specified package in the given location:::throw->new->UnsupportedOperationException
MemoryFileManager#getLocationForModule(Location, String)::: memory file manager get location for module:::return->stdFileManager->getLocationForModule
MemoryFileManager#getLocationForModule(Location, JavaFileObject)::: memory file manager get location for module:::return->stdFileManager->getLocationForModule
MemoryFileManager#inferModuleName(Location)::: memory file manager infer module name:::return->stdFileManager->inferModuleName
MemoryFileManager#listLocationsForModules(Location)::: memory file manager list locations for modules:::return->stdFileManager->listLocationsForModules
MemoryFileManager#contains(Location, FileObject)::: memory file manager contains:::return->stdFileManager->contains
MemoryFileManager#flush():::Flushes any resources opened for output by this file manager directly or indirectly:::
MemoryFileManager#close():::Releases any resources opened by this file manager directly or indirectly:::
MethodSnippet#parameterTypes():::A String representation of the parameter types of the method.:::return->key->parameterTypes
MethodSnippet#signature():::The full type signature of the method, including return type.:::return
MethodSnippet#toString()::: method snippet to string:::sb->new->StringBuilder->sb->append->sb->name->append->sb->append->sb->signature->append->sb->append->sb->source->append->return->sb->toString
MethodSnippet#key()::: method snippet key:::return->super->key
MethodSnippet#qualifiedParameterTypes()::: method snippet qualified parameter types:::return
MethodSnippet#setQualifiedParameterTypes(String)::: method snippet set qualified parameter types:::
OuterImportSnippetWrap#wrapDiag(Diagnostic)::: outer import snippet wrap wrap diag:::return->new->WrappedDiagnostic
OuterImportSnippetWrap#toString()::: outer import snippet wrap to string:::return
OuterSnippetsClassWrap#wrapLineToSnippet(int)::: outer snippets class wrap wrap line to snippet:::wrap->wrapLineToWrap->return->wrapToSnippet->get
OuterSnippetsClassWrap#wrapDiag(Diagnostic)::: outer snippets class wrap wrap diag:::return->new->WrappedDiagnostic
OuterSnippetsClassWrap#ordinal(Snippet)::: outer snippets class wrap ordinal:::i->foreach->wrapToSnippet->values->if->return->return
OuterSnippetsClassWrap#className()::: outer snippets class wrap class name:::return
OuterSnippetsClassWrap#toString()::: outer snippets class wrap to string:::return
OuterWrap#wrapped()::: outer wrap wrapped:::return->w->wrapped
OuterWrap#snippetIndexToWrapIndex(int)::: outer wrap snippet index to wrap index:::return->w->snippetIndexToWrapIndex
OuterWrap#wrapIndexToSnippetIndex(int)::: outer wrap wrap index to snippet index:::return->w->wrapIndexToSnippetIndex
OuterWrap#firstSnippetIndex()::: outer wrap first snippet index:::return->w->firstSnippetIndex
OuterWrap#lastSnippetIndex()::: outer wrap last snippet index:::return->w->lastSnippetIndex
OuterWrap#snippetLineToWrapLine(int)::: outer wrap snippet line to wrap line:::return->w->snippetLineToWrapLine
OuterWrap#wrapLineToSnippetLine(int)::: outer wrap wrap line to snippet line:::return->w->wrapLineToSnippetLine
OuterWrap#firstSnippetLine()::: outer wrap first snippet line:::return->w->firstSnippetLine
OuterWrap#lastSnippetLine()::: outer wrap last snippet line:::return->w->lastSnippetLine
OuterWrap#className()::: outer wrap class name:::return
OuterWrap#classFullName()::: outer wrap class full name:::return->className
OuterWrap#hashCode()::: outer wrap hash code:::return->className->hashCode
OuterWrap#equals(Object)::: outer wrap equals:::return->className->className->equals
OuterWrap#toString()::: outer wrap to string:::return
OuterWrap#wrapDiag(Diagnostic)::: outer wrap wrap diag:::return->new->WrappedDiagnostic
OuterWrap.WrappedDiagnostic#isError()::: wrapped diagnostic is error:::return->diag->getKind
OuterWrap.WrappedDiagnostic#getPosition()::: wrapped diagnostic get position:::return->diag->getPosition->wrapIndexToSnippetIndex
OuterWrap.WrappedDiagnostic#getStartPosition()::: wrapped diagnostic get start position:::return->diag->getStartPosition->wrapIndexToSnippetIndex
OuterWrap.WrappedDiagnostic#getEndPosition()::: wrapped diagnostic get end position:::return->diag->getEndPosition->wrapIndexToSnippetIndex
OuterWrap.WrappedDiagnostic#getCode()::: wrapped diagnostic get code:::return->diag->getCode
OuterWrap.WrappedDiagnostic#getMessage(Locale)::: wrapped diagnostic get message:::return->diag->getMessage->expunge
OuterWrap.WrappedDiagnostic#isResolutionError()::: wrapped diagnostic is resolution error:::if->super->isResolutionError->return->foreach->diag->getMessage->split->if->line->trim->startsWith->if->line->contains->return->return
OuterWrap.WrappedDiagnostic#toString()::: wrapped diagnostic to string:::return->getMessage->getPosition
OuterWrapMap#getOuter(String)::: outer wrap map get outer:::matcher->PREFIX_PATTERN->matcher->cn->if->matcher->find->matcher->group->return->classOuters->get->return
OuterWrapMap#wrappedInClass(String, String, List)::: outer wrap map wrapped in class:::elems->wraps->size->new->ArrayList<>->elems->add->elems->addAll->elems->add->return->elems->toArray->new->CompoundWrap
OuterWrapMap#wrapInClass(Set, Collection, List, List)::: outer wrap map wrap in class:::imports->packageAndImportsExcept->className->snippets->stream->sn1->key->index->sn2->key->index->sorted->sn->key->index->sn->sequenceNumber->asLetters->map->Collectors->joining->collect->w->wrappedInClass->now->new->OuterSnippetsClassWrap->classOuters->put->return
OuterWrapMap#wrapInTrialClass(Wrap)::: outer wrap map wrap in trial class:::imports->packageAndImportsExcept->w->Collections->singletonList->wrappedInClass->return->new->OuterWrap
OuterWrapMap#wrapImport(Wrap, Snippet)::: outer wrap map wrap import:::return->new->OuterImportSnippetWrap
PersistentSnippet#name():::Name of the Snippet.:::return
ReplParser#parseCompilationUnit():::As faithful a clone of the overridden method as possible while still achieving the goal of allowing the parse of a stand-alone snippet:::firstToken->mods->seenImport->seenPackage->defs->new->ListBuffer<>->if->modifiersOpt->firstTypeDecl->while->if->skip->if->break->if->defs->importDeclaration->append->else->docComment->token->comment->if->firstToken->comment->udefs->replUnit->foreach->defs->append->break->rdefs->defs->toList->toplevel->new->ReplUnit->if->rdefs->isEmpty->S->prevToken->storeEnd->S->getLineMap->setParser->return
ReplParser#replUnit(JCModifiers, Comment)::: repl parser repl unit:::switch->return->List->nil->return->List->parseStatement->of->if->peekToken->return->List->parseStatement->of->mods->modifiersOpt->if->return->List->classOrInterfaceOrEnumDeclaration->of->else->pos->typarams->typeParametersOpt->if->typarams->nonEmpty->storeEnd->annosAfterParams->annotationsOpt->if->annosAfterParams->nonEmpty->checkSourceLevel->appendList->if->prevToken->t->isVoid->if->F->at->TypeIdent->to->nextToken->else->term->if->t->hasTag->nextToken->stat->parseStatement->return->List->F->at->prevToken->name->Labelled->of->else->if->LAX_IDENTIFIER->accepts->name->ident->if->return->List->methodDeclaratorRest->of->else->if->typarams->isEmpty->defs->new->ListBuffer<JCTree>->variableDeclaratorsRest->toList->accept->defs->last->S->prevToken->storeEnd->return->else->err->List->F->at->List->nil->List->nil->MethodDef->toP->of->return->List->Errors->Expected->syntaxError->of->else->if->typarams->isEmpty->return->List->syntaxError->of->else->expr->F->at->Exec->toP->return->List->of
ReplParserFactory#preRegister(Context, boolean)::: repl parser factory pre register:::if->context->get->context->new->ReplParserFactory->put->context->new->Mark->put
ReplParserFactory#newParser(CharSequence, boolean, boolean, boolean)::: repl parser factory new parser:::lexer->scannerFactory->newScanner->return->new->ReplParser
ReplParserFactory#newParser(CharSequence, boolean, boolean, boolean, boolean)::: repl parser factory new parser:::return->newParser
ReplResolve#isStatic(Env)::: repl resolve is static:::return->Resolve->isStatic
Snippet#id():::The unique identifier for the snippet:::return
Snippet#kind():::The jdk.jshell.Snippet.Kind for the snippet:::return->subkind->kind
Snippet#subKind():::Return the SubKind of snippet:::return
Snippet#source():::Return the source code of the snippet.:::return
Snippet#toString()::: snippet to string:::sb->new->StringBuilder->sb->append->if->key->sb->key->toString->append->sb->append->sb->append->return->sb->toString
Snippet#name()::: snippet name:::return
Snippet#key()::: snippet key:::return
Snippet#unresolved()::: snippet unresolved:::return->Collections->unmodifiableList
Snippet#diagnostics()::: snippet diagnostics:::return
Snippet#syntheticDiags()::: snippet synthetic diags:::return
Snippet#corralled()::: snippet corralled:::return
Snippet#declareReferences()::: snippet declare references:::return
Snippet#bodyReferences()::: snippet body references:::return
Snippet#importLine(JShell)::: snippet import line:::return
Snippet#setId(String)::: snippet set id:::
Snippet#setSequenceNumber(int)::: snippet set sequence number:::
Snippet#setOuterWrap(OuterWrap)::: snippet set outer wrap:::
Snippet#setCompilationStatus(Status, List, DiagList)::: snippet set compilation status:::
Snippet#setDiagnostics(DiagList)::: snippet set diagnostics:::
Snippet#setFailed(DiagList)::: snippet set failed:::Collections->emptyList
Snippet#setDropped()::: snippet set dropped:::
Snippet#setOverwritten()::: snippet set overwritten:::
Snippet#status()::: snippet status:::return
Snippet#className()::: snippet class name:::return->outer->className
Snippet#classFullName()::: snippet class full name:::return->outer->classFullName
Snippet#outerWrap():::Top-level wrap:::return
Snippet#sequenceNumber():::Basically, class version for this Key.:::return
Snippet#guts()::: snippet guts:::return
Snippet#isExecutable()::: snippet is executable:::return->subkind->isExecutable
SnippetEvent#snippet():::The Snippet which has changed:::return
SnippetEvent#previousStatus():::The status before the transition:::return
SnippetEvent#status():::The after status:::return
SnippetEvent#isSignatureChange():::Indicates whether the signature has changed:::return
SnippetEvent#causeSnippet():::Either the snippet whose change caused this update or null:::return
SnippetEvent#exception():::An instance of jdk.jshell.UnresolvedReferenceException, if an unresolved reference was encountered, or an instance of jdk.jshell.EvalException if an exception was thrown during execution, otherwise null.:::return
SnippetEvent#value():::The result value of successful run:::return
SnippetEvent#toString():::Return a string representation of the event:::return
SnippetMaps#installSnippet(Snippet)::: snippet maps install snippet:::if->snippets->add->if->sn->key->sn->sn->key->index->apply->sn->key->index->setId->sn->key->index->setSnippet
SnippetMaps#setSnippet(int, Snippet)::: snippet maps set snippet:::while->keyIndexToSnippet->size->keyIndexToSnippet->add->keyIndexToSnippet->set
SnippetMaps#getSnippet(Key)::: snippet maps get snippet:::return->key->index->getSnippet
SnippetMaps#getSnippet(int)::: snippet maps get snippet:::sn->getSnippetDeadOrAlive->return->sn->status->isActive
SnippetMaps#getSnippetDeadOrAlive(int)::: snippet maps get snippet dead or alive:::if->keyIndexToSnippet->size->return->return->keyIndexToSnippet->get
SnippetMaps#snippetList()::: snippet maps snippet list:::return->new->ArrayList<>
SnippetMaps#packageAndImportsExcept(Set, Collection)::: snippet maps package and imports except:::sb->new->StringBuilder->sb->append->append->append->foreach->if->si->status->isDefined->except->si->key->contains->sb->si->importLine->append->if->plus->stream->sb->psi->importLine->append->forEach->return->sb->toString
SnippetMaps#getDependents(Snippet)::: snippet maps get dependents:::if->snip->kind->isPersistent->return->Collections->emptyList->depset->if->equals->new->HashSet<>->foreach->dependencies->values->depset->addAll->else->dependencies->snip->name->get->if->return->Collections->emptyList->deps->new->ArrayList<>->foreach->dep->getSnippetDeadOrAlive->if->deps->add->state->snip->name->dep->name->debug->return
SnippetMaps#mapDependencies(Snippet)::: snippet maps map dependencies:::snip->declareReferences->addDependencies->snip->bodyReferences->addDependencies
SnippetMaps#addDependencies(Collection, Snippet)::: snippet maps add dependencies:::if->return->foreach->dependencies->new->HashSet<>->computeIfAbsent->snip->key->index->add->state->snip->name->debug
SnippetMaps#fullClassNameAndPackageToClass(String, String)::: snippet maps full class name and package to class:::mat->PREFIX_PATTERN->matcher->if->mat->lookingAt->return->full->mat->end->substring->state->debug->klasses->importSnippets->filter->map->toList->collect->foreach->if->k->equals->return->full->full->lastIndexOf->full->length->substring->pkgs->importSnippets->filter->lastIndexOf->substring->map->toList->collect->pkgs->add->foreach->if->ipkg->isEmpty->ipkg->equals->return->full->pkg->length->substring->return
SnippetMaps#importSnippets():::Compute the set of imports to prepend to a snippet:::return->importKeys->getSnippet->map->state->status->isDefined->filter
SourceCodeAnalysis#analyzeCompletion(String):::Given an input string, find the first snippet of code (one statement, definition, import, or expression) and evaluate if it is complete.:::
SourceCodeAnalysis#completionSuggestions(String, int, int[]):::Compute possible follow-ups for the given input:::
SourceCodeAnalysis#documentation(String, int, boolean):::Compute documentation for the given user's input:::
SourceCodeAnalysis#analyzeType(String, int):::Infer the type of the given expression:::
SourceCodeAnalysis#listQualifiedNames(String, int):::List qualified names known for the simple name in the given code immediately to the left of the given cursor position:::
SourceCodeAnalysis#wrapper(Snippet):::Returns the wrapper information for the Snippet:::
SourceCodeAnalysis#wrappers(String):::Returns the wrapper information for the snippet within the input source string:::
SourceCodeAnalysis#sourceToSnippets(String):::Converts the source code of a snippet into a Snippet object (or list of Snippet objects in the case of some var declarations, e.g.: int x, y, z;):::
SourceCodeAnalysis#dependents(Snippet):::Returns a collection of Snippets which might need updating if the given Snippet is updated:::
SourceCodeAnalysis.CompletionInfo#completeness():::The analyzed completeness of the input.:::
SourceCodeAnalysis.CompletionInfo#remaining():::Input remaining after the complete part of the source.:::
SourceCodeAnalysis.CompletionInfo#source():::Source code for the first Snippet of code input:::
SourceCodeAnalysis.Suggestion#continuation():::The candidate continuation of the given user's input.:::
SourceCodeAnalysis.Suggestion#matchesType():::Indicates whether input continuation matches the target type and is thus more likely to be the desired continuation:::
SourceCodeAnalysis.Documentation#signature():::The signature of the given element.:::
SourceCodeAnalysis.Documentation#javadoc():::The javadoc of the given element.:::
SourceCodeAnalysis.QualifiedNames#getNames():::Known qualified names for the given simple name in the original code.:::return
SourceCodeAnalysis.QualifiedNames#getSimpleNameLength():::The length of the simple name in the original code for which the qualified names where gathered.:::return
SourceCodeAnalysis.QualifiedNames#isUpToDate():::Indicates whether the result is based on up-to-date data:::return
SourceCodeAnalysis.QualifiedNames#isResolvable():::Indicates whether the given simple name in the original code refers to a resolvable element.:::return
SourceCodeAnalysis.SnippetWrapper#source():::Returns the input that is wrapped:::
SourceCodeAnalysis.SnippetWrapper#wrapped():::Returns a Java class definition that wraps the SnippetWrapper#source() or, if an import, the import source:::
SourceCodeAnalysis.SnippetWrapper#fullClassName():::Returns the fully qualified class name of the SnippetWrapper#wrapped()  class:::
SourceCodeAnalysis.SnippetWrapper#kind():::Returns the Snippet.Kind of the SnippetWrapper#source().:::
SourceCodeAnalysis.SnippetWrapper#sourceToWrappedPosition(int):::Maps character position within the source to character position within the wrapped.:::
SourceCodeAnalysis.SnippetWrapper#wrappedToSourcePosition(int):::Maps character position within the wrapped to character position within the source.:::
SourceCodeAnalysisImpl#analyzeCompletion(String)::: source code analysis impl analyze completion:::mcm->new->MaskCommentsAndModifiers->if->mcm->endsWithOpenComment->proc->debug->return->new->CompletionInfoImpl->cleared->mcm->cleared->trimmedInput->Util->trimEnd->if->trimmedInput->isEmpty->return->new->CompletionInfoImpl->info->ca->scan->status->unitEndPos->if->srcInput->length->srcInput->length->nonCommentNonWhiteLength->trimmedInput->length->src->srcInput->substring->switch->if->compileSource->mcm->mask->substring->proc->debug->proc->debug->return->new->CompletionInfoImpl->else->remain->srcInput->substring->proc->debug->proc->debug->return->new->CompletionInfoImpl->compileSource->mcm->mask->substring->proc->debug->proc->debug->return->new->CompletionInfoImpl->proc->debug->return->new->CompletionInfoImpl->compileSource->mcm->mask->substring->proc->debug->return->new->CompletionInfoImpl->proc->debug->return->new->CompletionInfoImpl->proc->debug->return->new->CompletionInfoImpl->throw->new->InternalError
SourceCodeAnalysisImpl#guessKind(String)::: source code analysis impl guess kind:::return->units->pt->units->if->units->isEmpty->return->unitTree->units->get->proc->unitTree->getKind->debug->return->unitTree->getKind->parse
SourceCodeAnalysisImpl#completionSuggestions(String, int, int[])::: source code analysis impl completion suggestions:::suspendIndexing->try->return->completionSuggestionsImpl->catch->proc->debug->return->Collections->emptyList->finally->resumeIndexing
SourceCodeAnalysisImpl#completionSuggestionsImpl(String, int, int[])::: source code analysis impl completion suggestions impl:::code->substring->m->JAVA_IDENTIFIER->matcher->identifier->while->m->find->if->m->end->code->length->m->start->code->substring->m->group->code->substring->if->code->trim->isEmpty->codeWrap->switch->guessKind->Wrap->simpleWrap->wrapImport->break->Wrap->classMemberWrap->wrapInTrialClass->break->Wrap->methodWrap->wrapInTrialClass->break->requiredPrefix->return->computeSuggestions->stream->s->continuation->startsWith->s->continuation->equals->filter->Comparator->Suggestion->continuation->comparing->sorted->toList->Collections->unmodifiableList->collectingAndThen->collect
SourceCodeAnalysisImpl#computeSuggestions(OuterWrap, int, int[])::: source code analysis impl compute suggestions:::return->sp->at->trees->getSourcePositions->topLevel->at->firstCuTree->result->new->ArrayList<>->tp->code->snippetIndexToWrapIndex->pathFor->if->scope->at->trees->getScope->accessibility->createAccessibilityFilter->smartTypeFilter->smartFilter->targetTypes->findTargetType->if->resultOf->resultTypeOf->return->Util->stream->at->getTypes->isAssignable->anyMatch->IS_CLASS->negate->IS_INTERFACE->negate->and->IS_PACKAGE->negate->and->and->else->switch->tp->getLeaf->getKind->mst->tp->getLeaf->if->mst->getIdentifier->contentEquals->break->exprPath->mst->getExpression->new->TreePath->site->at->trees->getTypeMirror->staticOnly->isStaticContext->it->findImport->isImport->members->membersOf->filter->paren->if->isNewClass->constructorFilter->accessibility->and->if->el->getEnclosingElement->getEnclosingElement->getKind->return->el->getEnclosingElement->getModifiers->contains->return->and->membersOf->addElements->filter->and->else->if->isThrowsClause->filter->IS_PACKAGE->or->or->and->IS_PACKAGE->negate->and->else->if->if->it->isStatic->filter->IS_PACKAGE->or->or->and->else->filter->IS_CONSTRUCTOR->negate->and->filter->and->addElements->break->if->isNewClass->listEnclosed->el->getKind->Collections->singletonList->el->getEnclosedElements->filter->accessibility->IS_CONSTRUCTOR->or->and->newClassTree->tp->getParentPath->getLeaf->enclosingExpression->newClassTree->getEnclosingExpression->if->site->at->trees->new->TreePath->getTypeMirror->filter->el->getEnclosingElement->getKind->el->getEnclosingElement->getModifiers->contains->and->membersOf->membersOf->addElements->else->addScopeElements->break->if->isThrowsClause->accept->accessibility->and->IS_PACKAGE->or->or->and->IS_PACKAGE->negate->and->addScopeElements->break->it->findImport->if->listPackages->it->isStatic->STATIC_ONLY->and->addElements->break->accept->accessibility->and->addScopeElements->primitivesOrVoid->addElements->break->staticOnly->ReplResolve->getEnv->isStatic->accept->accessibility->and->if->isClass->clazz->tp->getParentPath->getLeaf->if->clazz->getExtendsClause->tp->getLeaf->accept->and->smartFilter->el->getKind->and->else->f->clazz->getImplementsClause->tp->getLeaf->smartFilterFromList->if->accept->and->f->el->getKind->and->else->if->isTypeParameter->tpt->tp->getParentPath->getLeaf->f->tpt->getBounds->tp->getLeaf->smartFilterFromList->if->accept->and->if->tpt->getBounds->isEmpty->tpt->getBounds->get->tp->getLeaf->smartFilter->el->getKind->and->else->if->isVariable->var->tp->getParentPath->getLeaf->if->var->getType->tp->getLeaf->accept->and->addScopeElements->parent->tp->getParentPath->getLeaf->switch->parent->getKind->getType->tp->getLeaf->IS_VOID->negate->break->break->break->primitivesOrVoid->addElements->break->return->analyze
SourceCodeAnalysisImpl#smartFilterFromList(AnalyzeTask, TreePath, Collection, Tree)::: source code analysis impl smart filter from list:::existingEls->new->HashSet<>->foreach->if->return->existingEls->contains->existingEls->at->trees->new->TreePath->getElement->add->return
SourceCodeAnalysisImpl#wrapper(Snippet)::: source code analysis impl wrapper:::return->new->SnippetWrapper
SourceCodeAnalysisImpl#wrappers(String)::: source code analysis impl wrappers:::return->sourceToSnippetsWithWrappers->stream->this->wrapper->map->toList->collect
SourceCodeAnalysisImpl#sourceToSnippets(String)::: source code analysis impl source to snippets:::proc->checkIfAlive->snl->toScratchSnippets->foreach->sn->setId->return
SourceCodeAnalysisImpl#dependents(Snippet)::: source code analysis impl dependents:::return->getDependents
SourceCodeAnalysisImpl#isStaticContext(AnalyzeTask, TreePath)::: source code analysis impl is static context:::switch->path->getLeaf->getKind->return->selectEl->at->trees->getElement->return->selectEl->getKind->isClass->selectEl->getKind->isInterface->selectEl->getKind->selectEl->asType->getKind
SourceCodeAnalysisImpl#pathFor(CompilationUnitTree, SourcePositions, int)::: source code analysis impl path for:::deepest->new->TreePathArr->new->TreePathScanner<Void,Void>->scan->return
SourceCodeAnalysisImpl#isNewClass(TreePath)::: source code analysis impl is new class:::return->tp->getParentPath->tp->getParentPath->getLeaf->getKind->tp->getParentPath->getLeaf->getIdentifier->tp->getLeaf
SourceCodeAnalysisImpl#isThrowsClause(TreePath)::: source code analysis impl is throws clause:::parent->tp->getParentPath->getLeaf->return->parent->getKind->getThrows->tp->getLeaf->contains
SourceCodeAnalysisImpl#isClass(TreePath)::: source code analysis impl is class:::return->tp->getParentPath->CLASS_KINDS->tp->getParentPath->getLeaf->getKind->contains
SourceCodeAnalysisImpl#isTypeParameter(TreePath)::: source code analysis impl is type parameter:::return->tp->getParentPath->tp->getParentPath->getLeaf->getKind
SourceCodeAnalysisImpl#isVariable(TreePath)::: source code analysis impl is variable:::return->tp->getParentPath->tp->getParentPath->getLeaf->getKind
SourceCodeAnalysisImpl#findImport(TreePath)::: source code analysis impl find import:::while->tp->getLeaf->getKind->tp->getParentPath->return->tp->getLeaf
SourceCodeAnalysisImpl#createAccessibilityFilter(AnalyzeTask, TreePath)::: source code analysis impl create accessibility filter:::scope->at->trees->getScope->return->switch->el->getKind->return->at->trees->isAccessible->return->type->el->getEnclosingElement->asType->if->type->getKind->return->at->trees->isAccessible->else->return
SourceCodeAnalysisImpl#addElements(Iterable, Predicate, Predicate, List)::: source code analysis impl add elements:::addElements
SourceCodeAnalysisImpl#addElements(Iterable, Predicate, Predicate, Function, List)::: source code analysis impl add elements:::hasParams->Util->stream->filter->IS_CONSTRUCTOR->or->filter->getParameters->isEmpty->filter->this->simpleName->map->toSet->collect->foreach->if->accept->test->continue->if->c->getKind->c->getSimpleName->contentEquals->getParameters->isEmpty->continue->simpleName->simpleName->switch->c->getKind->paren->hasParams->contains->apply->break->break->result->smart->test->new->SuggestionImpl->add
SourceCodeAnalysisImpl#simpleName(Element)::: source code analysis impl simple name:::return->el->getKind->el->getEnclosingElement->getSimpleName->toString->el->getSimpleName->toString
SourceCodeAnalysisImpl#membersOf(AnalyzeTask, TypeMirror, boolean)::: source code analysis impl members of:::if->return->Collections->emptyList->switch->site->getKind->result->new->ArrayList<>->foreach->getBounds->result->membersOf->addAll->return->element->at->getTypes->asElement->result->new->ArrayList<>->result->at->getElements->getAllMembers->addAll->if->result->createDotClassSymbol->add->result->el->getKind->removeIf->return->typeElement->at->getTypes->asElement->enclosingElement->typeElement->getEnclosingElement->parentPackageName->getQualifiedName->toString->packages->listPackages->return->packages->stream->p->getQualifiedName->typeElement->getQualifiedName->equals->filter->findAny->p->asType->membersOf->map->Collections->emptyList->orElse->packageName->site->toString->result->new->ArrayList<>->result->at->getElements->getPackageElement->getEnclosedElements->addAll->result->listPackages->addAll->return->return->Collections->createDotClassSymbol->singletonList->Collections->emptyList->result->new->ArrayList<>->result->createArrayLengthSymbol->add->if->result->createDotClassSymbol->add->return->return->Collections->emptyList
SourceCodeAnalysisImpl#membersOf(AnalyzeTask, List)::: source code analysis impl members of:::return->elements->stream->e->asType->membersOf->stream->flatMap->toList->collect
SourceCodeAnalysisImpl#getEnclosedElements(PackageElement)::: source code analysis impl get enclosed elements:::if->return->Collections->emptyList->while->try->return->packageEl->getEnclosedElements->stream->el->asType->filter->el->asType->getKind->filter->toList->collect->catch->finally
SourceCodeAnalysisImpl#primitivesOrVoid(AnalyzeTask)::: source code analysis impl primitives or void:::types->at->getTypes->return->Stream->of->types->getNoType->types->getPrimitiveType->map->Type->asElement->map->toList->collect
SourceCodeAnalysisImpl#classpathChanged()::: source code analysis impl classpath changed:::synchronized->cpVersion->INDEXER->refreshIndexes->submit
SourceCodeAnalysisImpl#listPackages(AnalyzeTask, String)::: source code analysis impl list packages:::synchronized->return->currentIndexes->values->stream->stream->flatMap->enclosingPackage->isEmpty->p->startsWith->filter->dot->p->enclosingPackage->length->indexOf->return->p->substring->map->distinct->createPackageElement->map->Collectors->toSet->collect
SourceCodeAnalysisImpl#createPackageElement(AnalyzeTask, String)::: source code analysis impl create package element:::names->Names->at->getContext->instance->syms->Symtab->at->getContext->instance->existing->syms->names->fromString->enterPackage->return
SourceCodeAnalysisImpl#createArrayLengthSymbol(AnalyzeTask, TypeMirror)::: source code analysis impl create array length symbol:::length->Names->at->getContext->instance->intType->Symtab->at->getContext->instance->return->new->VarSymbol
SourceCodeAnalysisImpl#createDotClassSymbol(AnalyzeTask, TypeMirror)::: source code analysis impl create dot class symbol:::_class->Names->at->getContext->instance->classType->Symtab->at->getContext->instance->erasedSite->at->getTypes->erasure->classType->getEnclosingType->of->classType->asElement->new->ClassType->return->new->VarSymbol
SourceCodeAnalysisImpl#scopeContent(AnalyzeTask, Scope, Function>)::: source code analysis impl scope content:::scopeIterable->new->Iterator<Scope>->result->Util->stream->this->localElements->flatMap->Util->elementConvertor->apply->stream->flatMap->ArrayList->new->toCollection->collect->result->listPackages->addAll->return
SourceCodeAnalysisImpl#localElements(Scope)::: source code analysis impl local elements:::elementsIt->new->Iterator<Element>->elements->Util->stream->if->scope->getEnclosingScope->scope->getEnclosingClass->scope->getEnclosingScope->getEnclosingClass->Stream->scope->getEnclosingClass->getEnclosedElements->stream->concat->return
SourceCodeAnalysisImpl#findTargetType(AnalyzeTask, TreePath)::: source code analysis impl find target type:::if->forPath->getParentPath->return->current->forPath->getLeaf->switch->forPath->getParentPath->getLeaf->getKind->tree->forPath->getParentPath->getLeaf->if->tree->getExpression->return->Collections->at->trees->forPath->getParentPath->tree->getVariable->new->TreePath->getTypeMirror->singletonList->break->tree->forPath->getParentPath->getLeaf->if->tree->getInitializer->return->Collections->at->trees->forPath->getParentPath->getTypeMirror->singletonList->break->return->forPath->getParentPath->findTargetType->nct->forPath->getParentPath->getLeaf->actuals->nct->getArguments->computeActualInvocationTypes->if->candidateConstructors->forPath->getParentPath->newClassCandidates->return->computeSmartTypesForExecutableType->else->return->forPath->getParentPath->findTargetType->if->isThrowsClause->break->return->Collections->at->getElements->getTypeElement->asType->singletonList->mit->forPath->getParentPath->getLeaf->actuals->mit->getArguments->computeActualInvocationTypes->if->return->candidateMethods->forPath->getParentPath->methodCandidates->return->computeSmartTypesForExecutableType->return
SourceCodeAnalysisImpl#computeActualInvocationTypes(AnalyzeTask, List, TreePath)::: source code analysis impl compute actual invocation types:::if->return->paramIndex->arguments->currentArgument->getLeaf->indexOf->if->return->actuals->new->ArrayList<>->foreach->arguments->subList->actuals->at->trees->currentArgument->getParentPath->new->TreePath->getTypeMirror->add->return
SourceCodeAnalysisImpl#filterExecutableTypesByArguments(AnalyzeTask, Iterable>, List)::: source code analysis impl filter executable types by arguments:::candidate->new->ArrayList<>->paramIndex->precedingActualTypes->size->foreach->varargInvocation->getParameterTypes->size->for->i->candidate->add->return
SourceCodeAnalysisImpl#parameterType(ExecutableElement, ExecutableType, int, boolean)::: source code analysis impl parameter type:::paramCount->methodType->getParameterTypes->size->if->method->isVarArgs->return->Stream->empty->if->method->isVarArgs->return->Stream->methodType->getParameterTypes->get->of->varargType->methodType->getParameterTypes->get->elemenType->getComponentType->if->return->Stream->of->return->Stream->of
SourceCodeAnalysisImpl#computeSmartTypesForExecutableType(AnalyzeTask, Iterable>, List)::: source code analysis impl compute smart types for executable type:::candidate->new->ArrayList<>->paramIndex->precedingActualTypes->size->this->filterExecutableTypesByArguments->stream->parameterType->flatMap->candidate->add->forEach->return
SourceCodeAnalysisImpl#resultTypeOf(Element)::: source code analysis impl result type of:::switch->el->getKind->return->getReturnType->return->el->getEnclosingElement->asType->return->el->asType
SourceCodeAnalysisImpl#addScopeElements(AnalyzeTask, Scope, Function>, Predicate, Predicate, List)::: source code analysis impl add scope elements:::scopeContent->addElements
SourceCodeAnalysisImpl#methodCandidates(AnalyzeTask, TreePath)::: source code analysis impl method candidates:::mit->invocation->getLeaf->select->mit->getMethodSelect->result->new->ArrayList<>->accessibility->createAccessibilityFilter->switch->select->getKind->mst->tp->new->TreePath->mst->getExpression->new->TreePath->site->at->trees->getTypeMirror->if->site->getKind->break->siteEl->at->getTypes->asElement->if->break->if->isStaticContext->accessibility->and->foreach->ElementFilter->siteEl->asType->membersOf->methodsIn->if->ee->getSimpleName->mst->getIdentifier->contentEquals->if->accessibility->test->result->Pair->at->getTypes->asMemberOf->of->add->break->it->foreach->ElementFilter->at->trees->getScope->scopeContent->methodsIn->if->ee->getSimpleName->it->getName->contentEquals->if->accessibility->test->result->Pair->ee->asType->of->add->break->break->return
SourceCodeAnalysisImpl#newClassCandidates(AnalyzeTask, TreePath)::: source code analysis impl new class candidates:::nct->newClassPath->getLeaf->type->at->trees->newClassPath->getParentPath->nct->getIdentifier->new->TreePath->getElement->targetType->at->trees->getTypeMirror->if->targetType->getKind->targetTypes->findTargetType->if->Collections->emptyList->StreamSupport->targetTypes->spliterator->stream->at->getTypes->asElement->filter->findAny->at->getTypes->type->asType->erasure->orElse->candidateConstructors->new->ArrayList<>->accessibility->createAccessibilityFilter->if->targetType->getKind->type->getKind->isClass->type->getKind->isInterface->foreach->ElementFilter->type->getEnclosedElements->constructorsIn->if->accessibility->test->constrType->at->getTypes->asMemberOf->candidateConstructors->Pair->of->add->return
SourceCodeAnalysisImpl#documentation(String, int, boolean)::: source code analysis impl documentation:::suspendIndexing->try->return->documentationImpl->catch->proc->debug->return->Collections->emptyList->finally->resumeIndexing
SourceCodeAnalysisImpl#documentationImpl(String, int, boolean)::: source code analysis impl documentation impl:::code->substring->if->code->trim->isEmpty->if->guessKind->return->Collections->emptyList->codeWrap->Wrap->methodWrap->wrapInTrialClass->return->List->of->sp->at->trees->getSourcePositions->topLevel->at->firstCuTree->tp->codeWrap->snippetIndexToWrapIndex->pathFor->if->return->Collections->emptyList->prevPath->while->tp->getLeaf->getKind->tp->getLeaf->getKind->tp->getLeaf->getKind->tp->getLeaf->getKind->tp->getParentPath->if->return->Collections->emptyList->elements->candidates->arguments->if->tp->getLeaf->getKind->tp->getLeaf->getKind->if->tp->getLeaf->getKind->mit->tp->getLeaf->methodCandidates->mit->getArguments->else->nct->tp->getLeaf->newClassCandidates->nct->getArguments->if->isEmptyArgumentsContext->actuals->computeActualInvocationTypes->fullActuals->Collections->emptyList->this->filterExecutableTypesByArguments->stream->fullActuals->size->parameterType->findAny->isPresent->filter->Collectors->toList->collect->Util->stream->map->else->if->tp->getLeaf->getKind->tp->getLeaf->getKind->el->at->trees->getElement->if->el->asType->getKind->el->getKind->el->getEnclosedElements->isEmpty->return->Collections->emptyList->Stream->of->else->return->Collections->emptyList->result->Collections->emptyList->try->helper->JavadocHelper->findSources->create->elements->constructDocumentation->map->Objects->nonNull->filter->Collectors->toList->collect->catch->proc->debug->finally->return->analyze
SourceCodeAnalysisImpl#constructDocumentation(AnalyzeTask, JavadocHelper, Element, boolean)::: source code analysis impl construct documentation:::javadoc->try->if->hasSyntheticParameterNames->helper->getSourceElement->if->helper->getResolvedDocComment->catch->proc->debug->finally->signature->Util->hasSyntheticParameterNames->elementHeader->expunge->return->new->DocumentationImpl
SourceCodeAnalysisImpl#close()::: source code analysis impl close:::foreach->try->closeable->close->catch->proc->debug->finally
SourceCodeAnalysisImpl.DocumentationImpl#signature()::: documentation impl signature:::return
SourceCodeAnalysisImpl.DocumentationImpl#javadoc()::: documentation impl javadoc:::return
SourceCodeAnalysisImpl#isEmptyArgumentsContext(List)::: source code analysis impl is empty arguments context:::if->arguments->size->firstArgument->arguments->get->return->firstArgument->getKind->return
SourceCodeAnalysisImpl#hasSyntheticParameterNames(Element)::: source code analysis impl has synthetic parameter names:::if->el->getKind->el->getKind->return->ee->if->ee->getParameters->isEmpty->return->return->ee->getParameters->stream->param->getSimpleName->toString->startsWith->allMatch
SourceCodeAnalysisImpl#findSources()::: source code analysis impl find sources:::if->return->if->return->result->new->ArrayList<>->home->Paths->System->getProperty->get->srcZip->home->resolve->resolve->if->Files->isReadable->home->getParent->resolve->if->Files->isReadable->keepOpen->zipFO->try->uri->URI->srcZip->toUri->create->FileSystems->Collections->emptyMap->newFileSystem->root->zipFO->getRootDirectories->iterator->next->if->Files->root->zipFO->getSeparator->replace->resolve->exists->result->add->else->if->Files->root->zipFO->getSeparator->replace->resolve->exists->try->ds->Files->newDirectoryStream->foreach->if->Files->isDirectory->result->add->catch->finally->catch->proc->debug->finally->if->if->closeables->add->else->try->zipFO->close->catch->proc->debug->finally->return
SourceCodeAnalysisImpl#elementHeader(AnalyzeTask, Element, boolean, boolean)::: source code analysis impl element header:::switch->el->getKind->type->fullname->type->getQualifiedName->toString->pkg->at->getElements->getPackageOf->name->getQualifiedName->toString->fullClassNameAndPackageToClass->return->type->getTypeParameters->typeParametersOpt->tp->name->tp->getSimpleName->toString->bounds->tp->getBounds->boundIsObject->bounds->isEmpty->bounds->size->at->getTypes->bounds->get->Symtab->at->getContext->instance->isSameType->return->bounds->stream->printType->map->joining->collect->return->el->getEnclosingElement->elementHeader->appendDot->el->getSimpleName->el->asType->return->el->getEnclosingElement->elementHeader->appendDot->el->getSimpleName->return->el->getSimpleName->el->asType->header->new->StringBuilder->isMethod->el->getKind->method->if->header->method->getReturnType->printType->append->append->else->typeParameters->method->getTypeParameters->typeParametersOpt->if->typeParameters->isEmpty->header->append->append->clazz->el->getEnclosingElement->elementHeader->header->append->if->clazz->isEmpty->header->append->method->getTypeParameters->typeParametersOpt->append->el->getSimpleName->append->header->append->sep->for->i->method->getParameters->iterator->i->hasNext->header->append->thrownTypes->method->getThrownTypes->if->thrownTypes->isEmpty->header->append->thrownTypes->stream->printType->map->joining->collect->append->return->header->toString->return->el->toString
SourceCodeAnalysisImpl#appendDot(String)::: source code analysis impl append dot:::return->fqn->isEmpty
SourceCodeAnalysisImpl#unwrapArrayType(TypeMirror)::: source code analysis impl unwrap array type:::if->arrayType->getKind->return->getComponentType->return
SourceCodeAnalysisImpl#typeParametersOpt(AnalyzeTask, List, boolean)::: source code analysis impl type parameters opt:::return->typeParameters->isEmpty->typeParameters->stream->elementHeader->map->joining->collect
SourceCodeAnalysisImpl#analyzeType(String, int)::: source code analysis impl analyze type:::switch->guessKind->return->break->ei->ExpressionToTypeInfo->expressionInfo->return
SourceCodeAnalysisImpl#listQualifiedNames(String, int)::: source code analysis impl list qualified names:::codeFin->code->substring->if->codeFin->trim->isEmpty->return->Collections->emptyList->new->QualifiedNames->codeWrap->switch->guessKind->return->Collections->emptyList->new->QualifiedNames->Wrap->classMemberWrap->wrapInTrialClass->break->Wrap->methodWrap->wrapInTrialClass->break->return->sp->at->trees->getSourcePositions->topLevel->at->firstCuTree->tp->codeWrap->codeFin->length->snippetIndexToWrapIndex->pathFor->if->tp->getLeaf->getKind->return->Collections->emptyList->new->QualifiedNames->scope->at->trees->getScope->type->at->trees->getTypeMirror->el->at->trees->getElement->erroneous->type->getKind->el->getKind->el->getKind->el->getEnclosedElements->isEmpty->simpleName->tp->getLeaf->getName->toString->upToDate->result->synchronized->currentIndexes->values->stream->Collections->emptyList->getOrDefault->stream->flatMap->distinct->isAccessible->filter->sorted->Collectors->toList->collect->return->simpleName->length->new->QualifiedNames->analyze
SourceCodeAnalysisImpl#isAccessible(AnalyzeTask, Scope, String)::: source code analysis impl is accessible:::type->at->getElements->getTypeElement->if->return->return->at->trees->isAccessible
SourceCodeAnalysisImpl#waitIndexingNotSuspended()::: source code analysis impl wait indexing not suspended:::suspendedNotified->synchronized->while->if->try->suspendLock->wait->catch->finally
SourceCodeAnalysisImpl#suspendIndexing()::: source code analysis impl suspend indexing:::synchronized
SourceCodeAnalysisImpl#resumeIndexing()::: source code analysis impl resume indexing:::synchronized->if->suspendLock->notifyAll
SourceCodeAnalysisImpl#refreshIndexes(int)::: source code analysis impl refresh indexes:::try->paths->new->ArrayList<>->fm->fileManager->appendPaths->appendPaths->appendPaths->newIndexes->new->HashMap<>->foreach->index->PATH_TO_INDEX->get->if->newIndexes->put->synchronized->currentIndexes->clear->currentIndexes->putAll->foreach->waitIndexingNotSuspended->index->indexForPath->newIndexes->put->synchronized->currentIndexes->clear->currentIndexes->putAll->catch->proc->debug->finally->synchronized
SourceCodeAnalysisImpl#appendPaths(MemoryFileManager, Location, Collection)::: source code analysis impl append paths:::locationPaths->fm->getLocationAsPaths->if->return->foreach->if->path->toString->equals->continue->paths->add
SourceCodeAnalysisImpl#indexForPath(Path)::: source code analysis impl index for path:::if->isJRTMarkerFile->jrtfs->FileSystems->URI->create->getFileSystem->modules->jrtfs->getPath->return->PATH_TO_INDEX->try->lastModified->Files->getLastModifiedTime->toMillis->if->try->stream->Files->newDirectoryStream->doIndex->catch->finally->return->catch->proc->path->toString->debug->return->Collections->emptySet->Collections->emptyMap->new->ClassIndex->finally->compute->else->if->Files->isDirectory->if->Files->exists->return->PATH_TO_INDEX->try->lastModified->Files->getLastModifiedTime->toMillis->if->cl->getClassLoader->try->zip->FileSystems->newFileSystem->zip->getRootDirectories->doIndex->catch->finally->return->catch->proc->path->toString->debug->return->Collections->emptySet->Collections->emptyMap->new->ClassIndex->finally->compute->else->return->Collections->emptySet->Collections->emptyMap->new->ClassIndex->else->return->PATH_TO_INDEX->if->Arrays->asList->doIndex->return->compute
SourceCodeAnalysisImpl#isJRTMarkerFile(Path)::: source code analysis impl is marker file:::return->path->Paths->System->getProperty->get->equals
SourceCodeAnalysisImpl#doIndex(long, Path, Iterable)::: source code analysis impl do index:::packages->new->HashSet<>->classSimpleName2FQN->new->HashMap<>->foreach->try->Files->new->FileVisitor<Path>->walkFileTree->catch->proc->d->toString->debug->finally->return->new->ClassIndex
SourceCodeAnalysisImpl#addClassName2Map(Map>, String)::: source code analysis impl add class name2 map:::simpleNameDot->typeName->lastIndexOf->classSimpleName2FQN->typeName->substring->new->LinkedHashSet<>->computeIfAbsent->add
SourceCodeAnalysisImpl#waitBackgroundTaskFinished()::: source code analysis impl wait background task finished:::upToDate->synchronized->while->INDEXER->submit->get->synchronized
SourceCodeAnalysisImpl.SuggestionImpl#continuation():::The candidate continuation of the given user's input.:::return
SourceCodeAnalysisImpl.SuggestionImpl#matchesType():::Indicates whether input continuation matches the target type and is thus more likely to be the desired continuation:::return
SourceCodeAnalysisImpl.CompletionInfoImpl#completeness():::The analyzed completeness of the input.:::return
SourceCodeAnalysisImpl.CompletionInfoImpl#remaining():::Input remaining after the complete part of the source.:::return
SourceCodeAnalysisImpl.CompletionInfoImpl#source():::Source code for the first Snippet of code input:::return
TaskFactory#addToClasspath(String)::: task factory add to classpath:::args->new->ArrayList<>->args->add->fileManager->args->iterator->handleOption->initTaskPool
TaskFactory#fileManager()::: task factory file manager:::return
TaskFactory#parse(String, boolean, Worker)::: task factory parse:::sh->new->StringSourceHandler->return->Stream->of->List->of->new->ParseTask->runTask
TaskFactory#analyze(OuterWrap, Worker)::: task factory analyze:::return->Collections->singletonList->analyze
TaskFactory#analyze(OuterWrap, List, Worker)::: task factory analyze:::return->Collections->singletonList->analyze
TaskFactory#analyze(Collection, Worker)::: task factory analyze:::return->Collections->emptyList->analyze
TaskFactory#analyze(Collection, List, Worker)::: task factory analyze:::sh->new->WrapSourceHandler->allOptions->new->ArrayList<>->allOptions->add->allOptions->add->allOptions->add->allOptions->addAll->return->wraps->stream->new->AnalyzeTask->runTask
TaskFactory#compile(Collection, Worker)::: task factory compile:::sh->new->WrapSourceHandler->return->wraps->stream->List->of->new->CompileTask->runTask
TaskFactory#runTask(Stream, SourceHandler, List, BiFunction, T>, Worker)::: task factory run task:::allOptions->options->size->size->new->ArrayList<>->allOptions->addAll->allOptions->addAll->compilationUnits->inputs->sh->sourceToFileObject->map->Collectors->toList->collect->diagnostics->new->DiagnosticCollector<>->state->debug->return->javacTaskPool->jti->context->jti->getContext->DisableAccessibilityResolve->preRegister->jti->new->TaskListenerImpl->addTaskListener->try->return->worker->creator->apply->withTask->catch->finally->syms->Symtab->instance->names->Names->instance->repl->syms->names->fromString->getPackage->if->foreach->syms->getAllClasses->if->clazz->packge->syms->clazz->flatName->removeClass->ClassFinder->instance->getCompleter->getTask
TaskFactory.Worker#withTask(T)::: worker with task:::
TaskFactory#parse(String, Worker)::: task factory parse:::return->if->pt->units->isEmpty->pt->units->get->getKind->pt->getDiagnostics->hasOtherThanNotStatementErrors->return->if->ept->getDiagnostics->hasOtherThanNotStatementErrors->return->worker->withTask->else->return->worker->withTask->parse->return->worker->withTask->parse
TaskFactory.SourceHandler#sourceToFileObject(MemoryFileManager, T)::: source handler source to file object:::
TaskFactory.SourceHandler#diag(Diagnostic)::: source handler diag:::
TaskFactory.StringSourceHandler#sourceToFileObject(MemoryFileManager, String)::: string source handler source to file object:::return->fm->createSourceFileObject
TaskFactory.StringSourceHandler#diag(Diagnostic)::: string source handler diag:::return->new->Diag
TaskFactory.WrapSourceHandler#sourceToFileObject(MemoryFileManager, OuterWrap)::: wrap source handler source to file object:::return->fm->w->classFullName->w->wrapped->createSourceFileObject
TaskFactory.WrapSourceHandler#diag(Diagnostic):::Get the source information from the wrap:::jfo->d->getSource->return->getOrigin->wrapDiag->new->StringSourceHandler->diag
TaskFactory.ParseTask#parse()::: parse task parse:::try->return->task->parse->catch->throw->ex->getMessage->new->InternalError->finally
TaskFactory.ParseTask#units()::: parse task units:::return
TaskFactory.ParseTask#cuTrees()::: parse task cu trees:::return
TaskFactory.AnalyzeTask#analyze()::: analyze task analyze:::try->cuts->task->parse->task->analyze->return->catch->throw->ex->getMessage->new->InternalError->finally
TaskFactory.AnalyzeTask#cuTrees()::: analyze task cu trees:::return
TaskFactory.AnalyzeTask#getElements()::: analyze task get elements:::return->task->getElements
TaskFactory.AnalyzeTask#getTypes()::: analyze task get types:::return->task->getTypes
TaskFactory.CompileTask#compile()::: compile task compile:::fileManager->this->listenForNewClassFile->registerClassFileCreationListener->result->task->call->fileManager->registerClassFileCreationListener->return
TaskFactory.CompileTask#classList(OuterWrap)::: compile task class list:::l->classObjs->get->if->return->Collections->emptyList->list->new->ArrayList<>->foreach->fo->getName->fo->getBytes->setCurrentBytes->list->fo->getName->add->return
TaskFactory.CompileTask#listenForNewClassFile(OutputMemoryJavaFileObject, JavaFileManager.Location, String, JavaFileObject.Kind, FileObject)::: compile task listen for new class file:::if->state->debug->w->getOrigin->getOrigin->classObjs->new->ArrayList<>->compute->add
TaskFactory.CompileTask#cuTrees()::: compile task cu trees:::throw->new->UnsupportedOperationException
TaskFactory#initTaskPool()::: task factory init task pool:::new->JavacTaskPool
TaskFactory.BaseTask#cuTrees()::: base task cu trees:::
TaskFactory.BaseTask#firstCuTree()::: base task first cu tree:::return->cuTrees->iterator->next
TaskFactory.BaseTask#diag(Diagnostic)::: base task diag:::return->sourceHandler->diag
TaskFactory.BaseTask#getContext()::: base task get context:::return
TaskFactory.BaseTask#types()::: base task types:::if->Types->instance->return
TaskFactory.BaseTask#messages()::: base task messages:::if->JavacMessages->instance->return
TaskFactory.BaseTask#trees()::: base task trees:::if->Trees->instance->return
TaskFactory.BaseTask#getDiagnostics()::: base task get diagnostics:::if->diagMap->new->LinkedHashMap<>->foreach->diagnostics->getDiagnostics->d->diag->uniqueKey->d->getCode->d->getPosition->d->getMessage->diagMap->put->diagMap->values->new->DiagList->return
TaskFactory.BaseTask#hasErrors()::: base task has errors:::return->getDiagnostics->hasErrors
TaskFactory.BaseTask#shortErrorMessage()::: base task short error message:::sb->new->StringBuilder->foreach->getDiagnostics->foreach->diag->getMessage->split->if->line->trim->startsWith->sb->append->return->sb->toString
TaskFactory.BaseTask#debugPrintDiagnostics(String)::: base task debug print diagnostics:::foreach->getDiagnostics->state->debug->foreach->diag->getMessage->split->if->line->trim->startsWith->state->debug->start->diag->getStartPosition->end->diag->getEndPosition->if->srcLines->src->split->foreach->state->debug->sb->new->StringBuilder->for->i->sb->append->if->for->i->sb->append->state->sb->toString->debug->state->diag->getStartPosition->debug->state->diag->getCode->debug->state->diag->getPosition->diag->getStartPosition->diag->getEndPosition->diag->getMessage->debug
TaskFactory.TaskListenerImpl#started(TaskEvent)::: task listener impl started:::if->e->getKind->return->foreach->e->getCompilationUnit->getTypeDecls->ct->foreach->ct->getMembers->if->member->getKind->continue->vsym->original->var2OriginalType->remove->if
TaskFactory.TaskListenerImpl#finished(TaskEvent)::: task listener impl finished:::if->e->getKind->return->snippetList->stream->s->status->filter->s->kind->filter->s->subKind->s->subKind->filter->setVariableType->forEach
TaskFactory.TaskListenerImpl#setVariableType(VarSnippet)::: task listener impl set variable type:::typeName->if->return->syms->Symtab->instance->names->Names->instance->log->Log->instance->parserFactory->ParserFactory->instance->attr->Attr->instance->enter->Enter->instance->rs->Resolve->instance->clazz->syms->names->s->classFullName->fromString->getClass->if->clazz->isCompleted->return->field->clazz->members->names->s->name->fromString->findFirst->if->var2OriginalType->containsKey->prev->log->useSource->h->new->DiscardDiagnosticHandler->try->buf->CharBuffer->toCharArray->typeName->length->wrap->parser->parserFactory->newParser->expr->parser->parseExpression->if->expr->hasTag->var2OriginalType->put->tree->rs->attr->enter->getEnvs->iterator->next->attribType->runWithoutAccessChecks->catch->finally->log->popDiagnosticHandler->log->useSource
TaskFactory.DisableAccessibilityResolve#preRegister(Context)::: disable accessibility resolve pre register:::if->context->get->context->new->DisableAccessibilityResolve->put->context->new->Marker->put
TaskFactory.DisableAccessibilityResolve#runWithoutAccessChecks(Runnable):::Run the given Runnable with all access checks disabled.:::prevNoAccessCheckes->try->r->run->catch->finally
TaskFactory.DisableAccessibilityResolve#isAccessible(Env, TypeSymbol, boolean)::: disable accessibility resolve is accessible:::if->return->return->super->isAccessible
TaskFactory.DisableAccessibilityResolve#isAccessible(Env, Type, Symbol, boolean)::: disable accessibility resolve is accessible:::if->return->return->super->isAccessible
TreeDependencyScanner#scan(Tree)::: tree dependency scanner scan:::scan
TreeDependencyScanner#declareReferences()::: tree dependency scanner declare references:::return
TreeDependencyScanner#bodyReferences()::: tree dependency scanner body references:::return
TreeDependencyScanner#add(Set, Name)::: tree dependency scanner add:::p->name->toString->add
TreeDependencyScanner#visitClass(ClassTree, Set)::: tree dependency scanner visit class:::node->getModifiers->scan->node->getTypeParameters->scan->node->getExtendsClause->scan->node->getImplementsClause->scan->node->getMembers->scan->return
TreeDependencyScanner#visitMethod(MethodTree, Set)::: tree dependency scanner visit method:::node->getModifiers->scan->node->getReturnType->scan->node->getTypeParameters->scan->node->getParameters->scan->node->getReceiverParameter->scan->node->getThrows->scan->node->getBody->scan->node->getDefaultValue->scan->return
TreeDependencyScanner#visitVariable(VariableTree, Set)::: tree dependency scanner visit variable:::node->getModifiers->scan->node->getType->scan->node->getNameExpression->scan->node->getInitializer->scan->return
TreeDependencyScanner#visitPackage(PackageTree, Set)::: tree dependency scanner visit package:::return
TreeDependencyScanner#visitImport(ImportTree, Set)::: tree dependency scanner visit import:::return
TreeDependencyScanner#visitMemberSelect(MemberSelectTree, Set)::: tree dependency scanner visit member select:::node->getIdentifier->add->return->super->visitMemberSelect
TreeDependencyScanner#visitIdentifier(IdentifierTree, Set)::: tree dependency scanner visit identifier:::node->getName->add->return->super->visitIdentifier
TreeDissector#createByFirstClass(TaskFactory.BaseTask)::: tree dissector create by first class:::pair->bt->firstCuTree->classes->findFirst->bt->firstCuTree->new->Pair<>->orElseGet->return->new->TreeDissector
TreeDissector#classes(CompilationUnitTree)::: tree dissector classes:::return->Stream->empty->cut->getTypeDecls->stream->filter->new->Pair<>->map
TreeDissector#classes(Iterable)::: tree dissector classes:::return->Util->stream->TreeDissector->classes->flatMap
TreeDissector#createBySnippet(TaskFactory.BaseTask, Snippet)::: tree dissector create by snippet:::name->si->className->pair->bt->cuTrees->classes->getSimpleName->contentEquals->filter->findFirst->new->IllegalArgumentException->orElseThrow->return->new->TreeDissector
TreeDissector#types()::: tree dissector types:::return->bt->types
TreeDissector#trees()::: tree dissector trees:::return->bt->trees
TreeDissector#getSourcePositions()::: tree dissector get source positions:::if->trees->getSourcePositions->return
TreeDissector#getStartPosition(Tree)::: tree dissector get start position:::return->getSourcePositions->getStartPosition
TreeDissector#getEndPosition(Tree)::: tree dissector get end position:::return->getSourcePositions->getEndPosition
TreeDissector#treeToRange(Tree)::: tree dissector tree to range:::return->getStartPosition->getEndPosition->new->Range
TreeDissector#treeListToRange(List)::: tree dissector tree list to range:::start->end->foreach->tstart->getStartPosition->tend->getEndPosition->if->if->if->return->return->new->Range
TreeDissector#method(MethodSnippet)::: tree dissector method:::if->return->ow->msn->outerWrap->if->return->ordinal->ordinal->if->return->count->name->msn->name->foreach->targetClass->getMembers->if->mem->getKind->mt->if->mt->getName->toString->equals->if->return->return
TreeDissector#firstStatement()::: tree dissector first statement:::if->foreach->targetClass->getMembers->if->mem->getKind->mt->if->mt->getName->isDoIt->stmts->mt->getBody->getStatements->if->stmts->isEmpty->return->stmts->get->return
TreeDissector#firstVariable()::: tree dissector first variable:::if->foreach->targetClass->getMembers->if->mem->getKind->vt->return->return
TreeDissector#typeOfMethod(MethodSnippet)::: tree dissector type of method:::unitTree->method->if->mtree->mt->types->erasure->if->return->types->signature->return
TreeDissector#signature(Types, MethodType)::: tree dissector signature:::sg->new->TDSignatureGenerator->sg->assembleSig->return->sg->toString
TreeDissector#printType(AnalyzeTask, JShell, TypeMirror)::: tree dissector print type:::typeImpl->try->tp->at->messages->state.maps->fullClassNameAndPackageToClass->new->TypePrinter->return->tp->toString->catch->return->finally
TreeDissector.TDSignatureGenerator#append(char)::: signature generator append:::sb->append
TreeDissector.TDSignatureGenerator#append(byte[])::: signature generator append:::sb->new->String->append
TreeDissector.TDSignatureGenerator#append(Name)::: signature generator append:::sb->append
TreeDissector.TDSignatureGenerator#toString()::: signature generator to string:::return->sb->toString
TypeDeclSnippet#key()::: type decl snippet key:::return->super->key
TypePrinter#toString(Type)::: type printer to string:::return->Locale->getDefault->visit
TypePrinter#localize(Locale, String, Object...)::: type printer localize:::return->messages->getLocalizedString
TypePrinter#capturedVarId(Type.CapturedType, Locale)::: type printer captured var id:::throw->new->InternalError
TypePrinter#visitCapturedType(Type.CapturedType, Locale)::: type printer visit captured type:::return->visit
TypePrinter#visitType(Type, Locale)::: type printer visit type:::s->toString->return
TypePrinter#className(ClassType, boolean, Locale):::Converts a class name into a (possibly localized) string:::sym->if->length->sym->flags->if->return->getExplicitComponents->stream->visit->map->Collectors->joining->collect->else->return->else->if->length->if->return->anonymousToName->apply->s->isClass->norm->if->else->if->nonEmpty->visit->else->visit->if->return->else->if->pkg->for->psym->return->fullClassNameAndPackageToClass->sym->getQualifiedName->toString->apply->else->return->toString
TypePrinter#visitClassSymbol(ClassSymbol, Locale)::: type printer visit class symbol:::return->isEmpty->toString->toString
TypePrinter#visitPackageSymbol(PackageSymbol, Locale)::: type printer visit package symbol:::return->s->isUnnamed->toString
Unit#hashCode()::: unit hash code:::return->si->hashCode
Unit#equals(Object)::: unit equals:::return->si->equals
Unit#snippet()::: unit snippet:::return
Unit#isDependency()::: unit is dependency:::return
Unit#initialize()::: unit initialize:::si->guts->markOldDeclarationOverwritten
Unit#setWrap(Collection, Collection)::: unit set wrap:::if->isImport->si->wrapImport->setOuterWrap->else->units->if->snippet->kind->name->snippet->name->plusUnfiltered->stream->u->snippet->kind->u->snippet->name->equals->filter->toList->collect->else->Collections->singletonList->except->exceptUnit->stream->u->snippet->key->map->toSet->collect->plus->plusUnfiltered->stream->units->contains->filter->Unit->snippet->map->toList->collect->snippets->units->stream->Unit->snippet->map->toList->collect->wraps->units->stream->map->toList->collect->si->wrapInClass->setOuterWrap->state->si->outerWrap->wrapped->debug
Unit#setDiagnostics(AnalyzeTask)::: unit set diagnostics:::ct->getDiagnostics->ofUnit->setDiagnostics
Unit#setDiagnostics(DiagList)::: unit set diagnostics:::ue->new->UnresolvedExtractor->ue->unresolved->state->si->outerWrap->wrapped->debug
Unit#isRecoverable()::: unit is recoverable:::return->compilationDiagnostics->hasErrors->isDependency->si->subKind->compilationDiagnostics->hasResolutionErrorsAndNoOthers
Unit#corralIfNeeded(Collection):::If it meets the conditions for corralling, install the corralled wrap:::if->isRecoverable->si->corralled->si->corralled->setWrap->return->return
Unit#setCorralledDiagnostics(AnalyzeTask)::: unit set corralled diagnostics:::cct->getDiagnostics->ofUnit->state->si->outerWrap->wrapped->debug
Unit#smashingErrorDiagnostics(CompileTask)::: unit smashing error diagnostics:::if->isDefined->dl->ct->getDiagnostics->ofUnit->if->dl->hasErrors->setDiagnostics->state->si->outerWrap->wrapped->debug->return->return
Unit#setStatus(AnalyzeTask)::: unit set status:::if->compilationDiagnostics->hasErrors->else->if->isRecoverable->if->recompilationDiagnostics->hasErrors->else->else->checkForOverwrite->state->debug
Unit#isDefined()::: unit is defined:::return->status->isDefined
Unit#classesToLoad(List):::Process the class information from the last compile:::new->ArrayList<>->toLoad->new->ArrayList<>->if->status->isDefined->isImport->foreach->ci->get->if->ci->isLoaded->if->ci->isCurrent->else->toRedefine->add->else->toLoad->ci->toClassBytecodes->add->return->toLoad->stream
Unit#doRedefines():::Redefine classes needing redefine:::if->toRedefine->isEmpty->return->cbcs->toRedefine->stream->ClassInfo->toClassBytecodes->map->ClassBytecodes[]->new->toArray->try->state->executionControl->redefine->markLoaded->return->catch->ex->installed->markLoaded->return->state->closeDown->return->return->finally
Unit#markForReplacement()::: unit mark for replacement:::si->setSequenceNumber
Unit#isImport()::: unit is import:::return->si->kind
Unit#sigChanged()::: unit sig changed:::return->status->isDefined->prevStatus->isDefined->status->isDefined->si->className->equals
Unit#effectedDependents()::: unit effected dependents:::return->sigChanged->dependents->Stream->empty
Unit#dependents()::: unit dependents:::return->getDependents->stream->xsi->status->isActive->filter->new->DiagList->new->Unit->map
Unit#finish()::: unit finish:::recordCompilation->installSnippet
Unit#markOldDeclarationOverwritten()::: unit mark old declaration overwritten:::if->siOld->status->isActive->siOld->status->new->SnippetEvent->siOld->setOverwritten
Unit#computeDiagnostics()::: unit compute diagnostics:::diagnostics->new->DiagList->diags->if->ue->new->UnresolvedExtractor->diagnostics->ue->otherAll->addAll->else->Collections->emptyList->diagnostics->addAll->diagnostics->addAll->return
Unit#recordCompilation()::: unit record compilation:::mapDependencies->diags->computeDiagnostics->si->setCompilationStatus->state->debug
Unit#checkForOverwrite(AnalyzeTask)::: unit check for overwrite:::new->ArrayList<>->if->secondaryEvents->add->if->si->kind->status->isDefined->msi->msi->computeQualifiedParameterTypes->setQualifiedParameterTypes->overwrittenStatus->overwriteMatchingMethod->if
Unit#overwriteMatchingMethod(MethodSnippet)::: unit overwrite matching method:::qpt->msi->qualifiedParameterTypes->matching->state->methods->sn->status->isActive->sn->name->msi->name->equals->qpt->sn->qualifiedParameterTypes->equals->filter->toList->collect->overwrittenStatus->foreach->sn->status->se->new->SnippetEvent->sn->setOverwritten->secondaryEvents->add->state->secondaryEvents->size->se->snippet->se->previousStatus->se->status->se->isSignatureChange->se->causeSnippet->debug->return
Unit#computeQualifiedParameterTypes(AnalyzeTask, MethodSnippet)::: unit compute qualified parameter types:::rawSig->TreeDissector->createBySnippet->typeOfMethod->signature->expunge->paren->signature->lastIndexOf->return->signature->substring->msi->parameterTypes
Unit#event(String, JShellException)::: unit event:::wasSignatureChanged->sigChanged->state->si->id->si->status->debug->return->si->status->new->SnippetEvent
Unit#secondaryEvents()::: unit secondary events:::return->Collections->emptyList
Unit#toString()::: unit to string:::return->si->name
Unit.UnresolvedExtractor#otherCorralledErrors()::: unresolved extractor other corralled errors:::return
Unit.UnresolvedExtractor#otherAll()::: unresolved extractor other all:::return
Unit.UnresolvedExtractor#unresolved()::: unresolved extractor unresolved:::return->new->ArrayList<>
UnresolvedReferenceException#getSnippet():::Return the Snippet which has the unresolved reference(s).:::return
Util#isDoIt(Name)::: util is do it:::return->name->toString->isDoIt
Util#isDoIt(String)::: util is do it:::return->sname->equals
Util#expunge(String)::: util expunge:::sb->new->StringBuilder->foreach->PREFIX_PATTERN->split->sb->append->return->sb->toString
Util#isInJShellClass(String):::Check if this is the name of something in JShell.:::m->PREFIX_PATTERN->matcher->return->m->find->m->start
Util#asLetters(int)::: util as letters:::if->return->buf->new->charArr->charPos->while->return->new->String
Util#trimEnd(String)::: util trim end:::last->s->length->i->while->Character->s->charAt->isWhitespace->if->return->s->substring->else->return
Util#stream(Iterable)::: util stream:::return->StreamSupport->iterable->spliterator->stream
Util#join(String[], String[])::: util join:::result->new->ArrayList<>->result->Arrays->asList->addAll->result->Arrays->asList->addAll->return->result->new->StringArr->toArray
VarSnippet#typeName():::A String representation of the type of the variable.:::return
VarSnippet#importLine(JShell)::: var snippet import line:::return->classFullName->name->anonymousClasses->stream->classFullName->map->Collectors->joining->collect
Wrap#methodWrap(String, String, String)::: wrap method wrap:::wunit->new->NoWrap->return->new->CompoundWrap->new->DoitMethodWrap
Wrap#methodWrap(String)::: wrap method wrap:::return->semi->methodWrap
Wrap#methodReturnWrap(String)::: wrap method return wrap:::return->semi->methodWrap
Wrap#methodUnreachableSemiWrap(String)::: wrap method unreachable semi wrap:::return->semi->methodWrap
Wrap#methodUnreachableWrap(String)::: wrap method unreachable wrap:::return->methodWrap
Wrap#indent(int)::: wrap indent:::return->substring
Wrap#nlindent(int)::: wrap nlindent:::return->indent
Wrap#varWrap(String, Wrap, String, Range, Wrap, boolean, Wrap):::Create a stub of a compilable representation of a variable snippet:::wname->new->RangeWrap->components->new->ArrayList<>->components->new->VarDeclareWrap->add->wmeth->if->new->NoWrap->new->CompoundWrap->else->if->waux->semi->new->CompoundWrap->components->add->new->CompoundWrap->else->semi->new->CompoundWrap->components->new->DoitMethodWrap->add->if->components->add->return->components->toArray->new->CompoundWrap
Wrap#tempVarWrap(String, String, String, Wrap)::: wrap temp var wrap:::winit->new->NoWrap->wmeth->semi->new->CompoundWrap->wInitMeth->new->DoitMethodWrap->varDecl->return->new->CompoundWrap->new->CompoundWrap
Wrap#simpleWrap(String)::: wrap simple wrap:::return->new->NoWrap
Wrap#identityWrap(String)::: wrap identity wrap:::return->new->NoWrap
Wrap#rangeWrap(String, Range)::: wrap range wrap:::return->new->RangeWrap
Wrap#classMemberWrap(String)::: wrap class member wrap:::w->new->NoWrap->return->new->CompoundWrap
Wrap#countLines(String)::: wrap count lines:::return->s->length->countLines
Wrap#countLines(String, int, int)::: wrap count lines:::cnt->idx->while->s->indexOf->if->break->return
Wrap.Range#part(String)::: range part:::return->s->substring
Wrap.Range#length()::: range length:::return
Wrap.Range#isEmpty()::: range is empty:::return
Wrap.Range#verify(String)::: range verify:::if->s->length->throw->new->InternalError
Wrap.Range#toString()::: range to string:::return
Wrap.CompoundWrap#wrapped()::: compound wrap wrapped:::return
Wrap.CompoundWrap#snippetIndexToWrapIndex(int)::: compound wrap snippet index to wrap index:::before->foreach->if->s->s->length->else->if->w->if->w->firstSnippetIndex->w->lastSnippetIndex->return->w->snippetIndexToWrapIndex->w->wrapped->length->return
Wrap.CompoundWrap#wrapIndexToWrap(long)::: compound wrap wrap index to wrap:::before->w->foreach->if->s->s->length->else->if->len->w->wrapped->length->if->return->return
Wrap.CompoundWrap#wrapIndexToSnippetIndex(int)::: compound wrap wrap index to snippet index:::before->foreach->if->s->s->length->else->if->w->len->w->wrapped->length->if->return->w->wrapIndexToSnippetIndex->return->lastSnippetIndex
Wrap.CompoundWrap#firstSnippetIndex()::: compound wrap first snippet index:::return
Wrap.CompoundWrap#lastSnippetIndex()::: compound wrap last snippet index:::return
Wrap.CompoundWrap#snippetLineToWrapLine(int)::: compound wrap snippet line to wrap line:::before->foreach->if->s->countLines->else->if->w->if->w->firstSnippetLine->w->lastSnippetLine->return->w->snippetLineToWrapLine->w->wrapped->countLines->return
Wrap.CompoundWrap#wrapLineToWrap(int)::: compound wrap wrap line to wrap:::before->w->foreach->if->s->countLines->else->if->lns->w->wrapped->countLines->if->return->return
Wrap.CompoundWrap#wrapLineToSnippetLine(int)::: compound wrap wrap line to snippet line:::before->foreach->if->s->countLines->else->if->w->lns->w->wrapped->countLines->if->return->w->wrapLineToSnippetLine->return
Wrap.CompoundWrap#firstSnippetLine()::: compound wrap first snippet line:::return
Wrap.CompoundWrap#lastSnippetLine()::: compound wrap last snippet line:::return
Wrap.CompoundWrap#toString()::: compound wrap to string:::return->Arrays->stream->Object->toString->map->joining->collect
Wrap.RangeWrap#wrapped()::: range wrap wrapped:::return
Wrap.RangeWrap#snippetIndexToWrapIndex(int)::: range wrap snippet index to wrap index:::if->return->if->return->range->length->return
Wrap.RangeWrap#wrapIndexToSnippetIndex(int)::: range wrap wrap index to snippet index:::if->return->max->range->length->if->return
Wrap.RangeWrap#firstSnippetIndex()::: range wrap first snippet index:::return
Wrap.RangeWrap#lastSnippetIndex()::: range wrap last snippet index:::return
Wrap.RangeWrap#snippetLineToWrapLine(int)::: range wrap snippet line to wrap line:::if->return->if->return->return
Wrap.RangeWrap#wrapLineToSnippetLine(int)::: range wrap wrap line to snippet line:::if->return->max->if->return
Wrap.RangeWrap#firstSnippetLine()::: range wrap first snippet line:::return
Wrap.RangeWrap#lastSnippetLine()::: range wrap last snippet line:::return
Wrap.RangeWrap#toString()::: range wrap to string:::return
Wrap#semi(Wrap)::: wrap semi:::return->w->wrapped->semi
Wrap#semi(String)::: wrap semi:::return->s->endsWith->s->endsWith
