AbstractConstantGroup#toString():::Produce a string using the non-resolving list view, where unresolved elements are presented as asterisks.:::asList("*").toString
AbstractConstantGroup.WithCache#fillCache(int):::hook for local subclasses:::
AbstractValidatingLambdaMetafactory#buildCallSite():::Build the CallSite.:::
AbstractValidatingLambdaMetafactory#validateMetafactoryArgs():::Check the meta-factory arguments for errors:::implMethodType.parameterCount->invokedType.parameterCount->samMethodType.parameterCount->instantiatedMethodType.parameterCount->String.format->String.format->bridgeMT.parameterCount->String.format->invokedType.parameterType->instantiatedMethodType.parameterType->implClass.isAssignableFrom->String.format->implMethodType.parameterType->invokedType.parameterType->capturedParamType.equals->String.format->implMethodType.parameterType->instantiatedMethodType.parameterType->this.isAdaptableTo->String.format->instantiatedMethodType.returnType->implMethodType.returnType->this.isAdaptableToAsReturn->String.format->this.checkDescriptor->this.checkDescriptor
BootstrapCallInfo#bootstrapMethod():::Returns the bootstrap method for this call.:::
BootstrapCallInfo#invocationName():::Returns the method name or constant name for this call.:::
BootstrapCallInfo#invocationType():::Returns the method type or constant type for this call.:::
BootstrapCallInfo#makeBootstrapCallInfo(MethodHandle, String, T, ConstantGroup):::Make a new bootstrap call descriptor with the given components.:::constants.size->constants.asList->bsci.initializeCache
BootstrapMethodInvoker#invoke(Class, MethodHandle, String, Object, Object, Class):::Factored code for invoking a bootstrap method for invokedynamic or a dynamic constant.:::IMPL_LOOKUP.in->this.isPullModeBSM->this.staticArgumentsPulled->this.pushMePullYou->this.pushMePullYou->this.maybeReBox->info.getClass().isArray->info.getClass->this.maybeReBoxElements->bootstrapMethod.type->this.isLambdaMetafactoryIndyBSM->this.isLambdaMetafactoryCondyBSM->this.isStringConcatFactoryBSM->this.isLambdaMetafactoryAltMetafactoryBSM->this.invoke->this.invoke->this.invoke->this.invoke->this.invoke->this.invoke->this.invoke->this.invokeWithManyArguments->bootstrapMethod.invokeExact->Arrays.copyOfRange->bootstrapMethod.invokeExact->bootstrapMethod.invokeExact->bootstrapMethod.invokeExact->pullModeBSM.invoke->bootstrapMethod.type->this.isStringConcatFactoryBSM->this.invoke->bootstrapMethod.invokeExact->this.invoke->resultType.isPrimitive->MethodHandles.identity->funnel.invoke->Wrapper.asWrapperType->resultType.cast
BootstrapMethodInvoker#pushMePullYou(MethodHandle, boolean):::Given a push-mode BSM (taking one argument) convert it to a  pull-mode BSM (taking N pre-resolved arguments):::bsm.type->System.out.println->this.isPullModeBSM->PullAdapter.MH_pullFromBootstrapMethod.bindTo(bsm).withVarargs->PushAdapter.MH_pushToBootstrapMethod.bindTo(bsm).withVarargs
BoundMethodHandle#makeReinvoker(MethodHandle):::A reinvoker MH has this form: lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }:::Species_L.BMH_SPECIES.getterFunction->DelegatingMethodHandle.makeReinvokerForm->target.type->Species_L.make
CallSite#type():::Returns the type of this call site's target:::target.type
CallSite#getTarget():::Returns the target method of the call site, according to the behavior defined by this call site's specific class:::
CallSite#setTarget(MethodHandle):::Updates the target method of this call site, according to the behavior defined by this call site's specific class:::
CallSite#dynamicInvoker():::Produces a method handle equivalent to an invokedynamic instruction which has been linked to this call site:::
ClassSpecializer#topClass():::Return the top type mirror, for type T:::
ClassSpecializer#keyType():::Return the key type mirror, for type K:::
ClassSpecializer#metaType():::Return the species metadata type mirror, for type S:::
ClassSpecializer#baseConstructorType():::Report the leading arguments (if any) required by every species factory:::
ClassSpecializer#topSpecies():::Return the trivial species for the null sequence of arguments.:::
ClassSpecializer#transformMethods():::Return the list of transform methods originally given at creation of this specializer.:::
ClassSpecializer#factory():::Return the factory object used to build and load concrete species code.:::
ClassSpecializer.SpeciesData#speciesCode():::Throws NPE if this species is not yet resolved.:::Objects.requireNonNull
ClassSpecializer.SpeciesData#getter(int):::Return a MethodHandle which can get the indexed field of this species:::getters.get
ClassSpecializer.SpeciesData#getterFunction(int):::Return a LambdaForm.Name containing a LambdaForm.NamedFunction that represents a MH bound to a generic invoker, which in turn forwards to the corresponding getter.:::nominalGetters.get->nf.memberDeclaringClassOrNull->this.speciesCode->nf.returnType->fieldTypes.get->BasicType.basicType
ClassSpecializer.SpeciesData#deriveFieldTypes(K):::Given a key, derive the list of field types, which all instances of this species must store.:::
ClassSpecializer.SpeciesData#deriveTransformHelper(MemberName, int):::Given the index of a method in the transforms list, supply a factory method that takes the arguments of the transform, plus the local fields, and produce a value of the required type:::
ClassSpecializer.SpeciesData#deriveTransformHelperArguments(MemberName, int, List, List):::During code generation, this method is called once per transform to determine what is the mix of arguments to hand to the transform-helper:::
ClassSpecializer.SpeciesData#deriveClassName():::Given a key, generate the name of the class which implements the species for that key:::outer().topClass().getName->this.deriveTypeString
ClassSpecializer.SpeciesData#deriveTypeString():::Default implementation collects basic type characters, plus possibly type names, if some types don't correspond to basic types.:::this.fieldTypes->BasicType.basicType->basicType.basicTypeClass->buf.append->this.classSig->end.append->basicType.basicTypeChar->buf.append->end.length->buf.toString->buf.append("_").append(end).toString->BytecodeName.toBytecodeName->LambdaForm.shortenSignature
ClassSpecializer.SpeciesData#deriveSuperClass():::Report what immediate super-class to use for the concrete class of this species:::this.topClass->baseConstructorType().parameterArray->this.reflectConstructor->topc.isInterface->con.getModifiers->Modifier.isPrivate->this.newInternalError
ClassSpecializer.Factory#loadSpecies(S):::Get a concrete subclass of the top class for a given combination of bound types.:::speciesData.deriveClassName->className.indexOf->ex.getMessage->System.out.println->BootLoader.loadClassOrNull->System.out.println->System.out.println->this.generateConcreteSpeciesCode->System.out.println->this.linkSpeciesDataToCode->this.linkCodeToSpeciesData->this.topClass->salvage.asSubclass->this.linkSpeciesDataToCode->this.linkCodeToSpeciesData->speciesData.isResolved->this.newInternalError->this.loadSpeciesDataFromCode
ClassSpecializer.Factory#generateConcreteSpeciesCode(String, ClassSpecializer.SpeciesData):::Generate a concrete subclass of the top class for a given combination of bound types:::this.generateConcreteSpeciesCodeFile->this.classBCName->InvokerBytecodeGenerator.maybeDump->topClass().getClassLoader->AccessController.doPrivileged->this.newInternalError->UNSAFE.defineClass->this.topClass->speciesCode.asSubclass
ClassSpecializer.Factory#chooseFieldName(Class, int):::Field names in concrete species classes adhere to this pattern: type + index, where type is a single character (L, I, J, F, D):::BasicType.basicType->bt.basicTypeChar
ClassSpecializer#makeFactory():::Hook that virtualizes the Factory class, allowing subclasses to extend it.:::
ConstantBootstraps#nullConstant(MethodHandles.Lookup, String, Class):::Returns a null object reference for the reference type specified by type.:::requireNonNull(type).isPrimitive->String.format
ConstantBootstraps#primitiveClass(MethodHandles.Lookup, String, Class):::Returns a Class mirror for the primitive type whose type descriptor is specified by name.:::this.requireNonNull->this.requireNonNull->name.length->name.length->String.format->Wrapper.forPrimitiveType(name.charAt(0)).primitiveType
ConstantBootstraps#enumConstant(MethodHandles.Lookup, String, Class):::Returns an enum constant of the type specified by type with the name specified by name.:::this.requireNonNull->this.requireNonNull->this.requireNonNull->this.validateClassAccess->Enum.valueOf
ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class, Class):::Returns the value of a static final field.:::this.requireNonNull->this.requireNonNull->this.requireNonNull->this.requireNonNull->this.mapLookupExceptionToError->lookup.findStaticGetter->mh.internalMemberName->member.isFinal->mh.invoke
ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class):::Returns the value of a static final field declared in the class which is the same as the field's type (or, for primitive-valued fields, declared in the wrapper class.)  This is a simplified form of #getStaticFinal(MethodHandles.Lookup, String, Class, Class) for the case where a class declares distinguished constant instances of itself.:::this.requireNonNull->type.isPrimitive->Wrapper.forPrimitiveType(type).wrapperType->this.getStaticFinal
ConstantBootstraps#invoke(MethodHandles.Lookup, String, Class, MethodHandle, Object...):::Returns the result of invoking a method handle with the provided arguments:::this.requireNonNull->this.requireNonNull->this.requireNonNull->handle.type().returnType->handle.isVarargsCollector->handle.asType(handle.type().changeReturnType(type)).withVarargs->handle.invokeWithArguments
ConstantBootstraps#fieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class):::Finds a VarHandle for an instance field.:::this.requireNonNull->this.requireNonNull->this.requireNonNull->this.requireNonNull->this.requireNonNull->this.mapLookupExceptionToError->lookup.findVarHandle
ConstantBootstraps#staticFieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class):::Finds a VarHandle for a static field.:::this.requireNonNull->this.requireNonNull->this.requireNonNull->this.requireNonNull->this.requireNonNull->this.mapLookupExceptionToError->lookup.findStaticVarHandle
ConstantBootstraps#arrayVarHandle(MethodHandles.Lookup, String, Class, Class):::Finds a VarHandle for an array type.:::this.requireNonNull->this.requireNonNull->this.requireNonNull->this.validateClassAccess->MethodHandles.arrayElementVarHandle
ConstantCallSite#getTarget():::Returns the target method of the call site, which behaves like a final field of the ConstantCallSite:::
ConstantCallSite#setTarget(MethodHandle):::Always throws an UnsupportedOperationException:::
ConstantCallSite#dynamicInvoker():::Returns this call site's permanent target:::this.getTarget
ConstantGroup#size():::Returns the number of constants in this group:::
ConstantGroup#get(int):::Returns the selected constant, resolving it if necessary:::
ConstantGroup#get(int, Object):::Returns the selected constant, or the given sentinel value if there is none available:::
ConstantGroup#isPresent(int):::Returns an indication of whether a constant may be available:::
ConstantGroup#asList():::Create a view on this group as a List view:::this.size
ConstantGroup#asList(Object):::Create a view on this group as a List view:::this.size
ConstantGroup#subGroup(int, int):::Create a view on a sub-sequence of this group.:::
ConstantGroup#copyConstants(int, int, Object[], int):::Copy a sequence of constant values into a given buffer:::this.get
ConstantGroup#copyConstants(int, int, Object[], int, Object):::Copy a sequence of constant values into a given buffer:::this.get
ConstantGroup#makeConstantGroup(List, Object, IntFunction):::Make a new constant group with the given constants:::constants.size->this.initializeCache->super.fillCache->constantProvider.apply
ConstantGroup#makeConstantGroup(List):::Make a new constant group with the given constant values:::constants.contains->this.makeConstantGroup
DelegatingMethodHandle#getTarget():::Define this to extract the delegated target which supplies the invocation behavior.:::
DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, boolean, NamedFunction, NamedFunction):::Create a LF which simply reinvokes a target of the given basic type.:::target.type().basicType->this.whichKind->mtype.parameterSlotCount->mtype.form().cachedLambdaForm->mtype.parameterCount->mtype.invokerType->LambdaForm.arguments->names[THIS_DMH].withConstraint->Arrays.copyOfRange->Arrays.copyOfRange->mtype.form().setCachedLambdaForm
DirectMethodHandle#internalMemberName(Object):::Static wrapper for DirectMethodHandle.internalMemberName.:::
DirectMethodHandle#checkReceiver(Object):::Used for interface receiver type checks, by Interface and Special modes.:::
InnerClassLambdaMetafactory#buildCallSite():::Build the CallSite:::this.spinInnerClass->invokedType.parameterCount->UNSAFE.ensureClassInitialized->MethodHandles.Lookup.IMPL_LOOKUP.findStatic->AccessController.doPrivileged->innerClass.getCanonicalName->ctrs[0].newInstance->MethodHandles.constant
InvokerBytecodeGenerator#generateCustomizedCode(LambdaForm, MethodType):::Generate customized bytecode for a given LambdaForm.:::this.lookupPregenerated->g.generateCustomizedCodeBytes->g.loadMethod
InvokerBytecodeGenerator#emitInvoke(Name):::Emit an invoke for the given name.:::name.isLinkerMethodInvoke->this.emitAloadInsn->this.emitReferenceCast->mv.visitFieldInsn->mv.visitFieldInsn->name.function.resolvedHandle->name.exprString->this.constantPlaceholder->mv.visitLdcInsn->this.emitReferenceCast->this.emitPushArguments->name.function.methodType->type.basicType().toMethodDescriptorString->mv.visitMethodInsn
InvokerBytecodeGenerator#emitStaticInvoke(MemberName, Name):::Emit an invoke for the given name, using the MemberName directly.:::name.function.member->member.equals->member.getDeclaringClass->this.getInternalName->member.getName->member.getReferenceKind->member.canBeStaticallyBound->member.getDeclaringClass().isInterface->this.emitPushArguments->member.isMethod->member.getFieldType->MethodType.toFieldDescriptorString->this.refKindOpcode->mv.visitFieldInsn->member.getMethodType().toMethodDescriptorString->this.refKindOpcode->member.getDeclaringClass().isInterface->mv.visitMethodInsn->member.getInvocationType().returnType->rtype.isPrimitive->rtype.isInterface->this.assertStaticType
InvokerBytecodeGenerator#generateLambdaFormInterpreterEntryPoint(MethodType):::Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.:::this.basicTypeSignature->this.isValidSignature->mt.returnType->this.basicTypeChar->type.changeParameterType->g.generateLambdaFormInterpreterEntryPointBytes->g.loadMethod
InvokerBytecodeGenerator#generateNamedFunctionInvoker(MethodTypeForm):::Generate bytecode for a NamedFunction invoker.:::typeForm.erasedType->this.basicTypeSignature->this.shortenSignature->g.generateNamedFunctionInvokerImpl->g.loadMethod
Invokers#invokeHandleForm(MethodType, boolean, int):::Returns an adapter for invokeExact or generic invoke, as a MH or constant pool linker:::mtype.basicType->mtype.form().cachedLambdaForm->mtype.parameterCount->mtype.invokerType->invokerFormType.invokerType->invokerFormType.appendParameterTypes->this.arguments->Arrays.asList->BoundMethodHandle.speciesData_L->names[THIS_MH].withConstraint->speciesData.getterFunction->mtype.basicType->Arrays.copyOfRange->this.getFunction->this.getFunction->this.getFunction->lform.compileToBytecode->mtype.form().setCachedLambdaForm
LambdaForm#customize(MethodHandle):::Customize LambdaForm for a particular MethodHandle:::customForm.compileToBytecode
LambdaForm#uncustomize():::Get uncustomized flavor of the LambdaForm:::uncustomizedForm.compileToBytecode
LambdaForm#nameRefsAreLegal():::Check that all embedded Name references are localizable to this lambda, and are properly ordered after their corresponding definitions:::n.index->n.index->Arrays.asList->n.isParam->n.index->n.debugString->n.debugString->n2.debugString->names[i2].debugString->Arrays.asList
LambdaForm#returnType():::Report the return type.:::
LambdaForm#parameterType(int):::Report the N-th argument type.:::this.parameter
LambdaForm#parameter(int):::Report the N-th argument name.:::param.isParam
LambdaForm#parameterConstraint(int):::Report the N-th argument type constraint.:::this.parameter
LambdaForm#arity():::Report the arity.:::
LambdaForm#expressionCount():::Report the number of expressions (non-parameter names).:::
LambdaForm#methodType():::Return the method type corresponding to my basic type signature.:::this.parameterType->MethodType.makeImpl
LambdaForm#basicTypeSignature():::Return ABC_Z, where the ABC are parameter type characters, and Z is the return type character.:::this.arity->parameterType(i).basicTypeChar->buf.append->this.arity->buf.append('_').append(returnType().basicTypeChar()).toString
LambdaForm#isSelectAlternative(int):::Check if i-th name is a call to MethodHandleImpl.selectAlternative.:::name0.refersTo->name1.isInvokeBasic->name1.lastUseIndex->this.lastUseIndex
LambdaForm#isGuardWithCatch(int):::Check if i-th name is a start of GuardWithCatch idiom.:::this.isMatchingIdiom
LambdaForm#isTryFinally(int):::Check if i-th name is a start of the tryFinally idiom.:::this.isMatchingIdiom
LambdaForm#isLoop(int):::Check if i-th name is a start of the loop idiom.:::this.isMatchingIdiom
LambdaForm#prepare():::Make this LF directly executable, as part of a MethodHandle:::this.forceInterpretation->this.compileToBytecode->this.methodType->mtype.form().cachedLambdaForm->this.basicTypeSignature->this.isValidSignature->InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint->mtype.form().setCachedLambdaForm
LambdaForm#compileToBytecode():::Generate optimizable bytecode for this form.:::this.forceInterpretation->this.methodType->vmentry.getMethodType().basicType().equals->failedCompilationCounter().increment->System.out.println->bge.printStackTrace->this.toString->this.newInternalError->InvokerBytecodeGenerator.generateCustomizedCode->this.traceInterpreter
LambdaForm#shortenSignature(String):::Hack to make signatures more readable when they show up in method names:::signature.length->signature.substring->buf.append->signature.charAt->buf.append->new StringBuilder().append->buf.append((char) c0).append->buf.toString
LambdaForm.Name#replaceNames(Name[], Name[], int, int):::In the arguments of this Name, replace oldNames[i] pairwise by newNames[i]:::arguments.clone
LambdaForm.Name#isInvokeBasic():::Check if MemberName is a call to MethodHandle.invokeBasic.:::function.member->member.refersTo->member.isPublic->member.isStatic
LambdaForm.Name#isLinkerMethodInvoke():::Check if MemberName is a call to MethodHandle.linkToStatic, etc.:::function.member->member.getDeclaringClass->member.isPublic->member.isStatic->member.getName().startsWith
LambdaForm.Name#lastUseIndex(Name):::Return the index of the last occurrence of n in the argument array:::
LambdaForm.Name#useCount(Name):::Return the number of occurrences of n in the argument array:::
LambdaForm#lastUseIndex(Name):::Return the index of the last name which contains n as an argument:::names[i].lastUseIndex
LambdaForm#useCount(Name):::Return the number of times n is used as an argument or return value.:::this.lastUseIndex->n.index->names[i].useCount
LambdaFormBuffer#startEdit():::Create a private, writable copy of names:::this.verifyArity->this.ownedCount->this.inTrans->Math.max->Arrays.copyOf->this.ownedCount->this.copyNamesInto->this.inTrans
LambdaFormBuffer#setResult(Name):::Change the result name:::this.lastIndexOf
LambdaFormBuffer#endEdit():::Finish a transaction.:::this.verifyFirstChange->name.replaceNames->Math.max->this.inTrans->this.clearDuplicatesAndNulls->name.isParam->System.arraycopy->this.verifyArity->this.lambdaForm
LambdaFormBuffer#replaceFunctions(List, List, Object...):::Replace any Name whose function is in oldFns with a copy  whose function is in the corresponding position in newFns:::this.inTrans->oldFns.isEmpty->this.indexOf->Arrays.equals->this.changeName
LambdaFormBuffer#renameParameter(int, Name):::Replace a parameter by a fresh parameter.:::newParam.isParam->this.replaceName
LambdaFormBuffer#replaceParameterByNewExpression(int, Name):::Replace a parameter by a fresh expression.:::binding.isParam->this.lastIndexOf->this.replaceName
LambdaFormBuffer#replaceParameterByCopy(int, int):::Replace a parameter by another parameter or expression already in the form.:::this.replaceName->this.noteDuplicate
LambdaFormBuffer#insertExpression(int, Name):::Insert a fresh expression.:::expr.isParam->this.insertName
LambdaFormBuffer#insertParameter(int, Name):::Insert a fresh parameter.:::param.isParam->this.insertName
LambdaMetafactory#metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType):::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments:::mf.validateMetafactoryArgs->mf.buildCallSite
LambdaMetafactory#altMetafactory(MethodHandles.Lookup, String, MethodType, Object...):::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments:::System.arraycopy->System.arraycopy->invokedType.returnType->Serializable.class.isAssignableFrom->Serializable.class.isAssignableFrom->Arrays.copyOf->mf.validateMetafactoryArgs->mf.buildCallSite
MemberName#getDeclaringClass():::Return the declaring class of this member:::
MemberName#getClassLoader():::Utility method producing the class loader of the declaring class.:::clazz.getClassLoader
MemberName#getName():::Return the simple name of this member:::this.expandFromVM
MemberName#getMethodType():::Return the declared type of this member, which  must be a method or constructor.:::this.expandFromVM->this.isInvocable->this.newIllegalArgumentException->MethodType.makeImpl->this.getClassLoader->MethodType.fromDescriptor
MemberName#getMethodDescriptor():::Return the descriptor of this member, which  must be a method or constructor.:::this.expandFromVM->this.isInvocable->this.newIllegalArgumentException->getMethodType().toMethodDescriptorString
MemberName#getInvocationType():::Return the actual type under which this method or constructor must be invoked:::this.getMethodOrFieldType->this.isConstructor->this.getReferenceKind->itype.changeReturnType->this.isStatic->itype.insertParameterTypes
MemberName#getParameterTypes():::Utility method producing the parameter types of the method type.:::getMethodType().parameterArray
MemberName#getReturnType():::Utility method producing the return type of the method type.:::getMethodType().returnType
MemberName#getFieldType():::Return the declared type of this member, which  must be a field or type:::this.expandFromVM->this.isInvocable->this.newIllegalArgumentException->this.getClassLoader->MethodType.fromDescriptor->mtype.returnType
MemberName#getType():::Utility method to produce either the method type or field type of this member.:::this.isInvocable->this.getFieldType->this.getMethodType
MemberName#getSignature():::Utility method to produce the signature of this member,  used within the class file format to describe its type.:::this.expandFromVM->this.isInvocable->this.getFieldType->BytecodeDescriptor.unparse->this.getMethodType->BytecodeDescriptor.unparse
MemberName#getModifiers():::Return the modifier flags of this member.:::
MemberName#getReferenceKind():::Return the reference kind of this member, or zero if none.:::
MemberName#isMethodHandleInvoke():::Utility method to query if this member is a method handle invocation (invoke or invokeExact).:::this.testFlags->this.isMethodHandleInvokeName
MemberName#isStatic():::Utility method to query the modifier flags of this member.:::Modifier.isStatic
MemberName#isPublic():::Utility method to query the modifier flags of this member.:::Modifier.isPublic
MemberName#isPrivate():::Utility method to query the modifier flags of this member.:::Modifier.isPrivate
MemberName#isProtected():::Utility method to query the modifier flags of this member.:::Modifier.isProtected
MemberName#isFinal():::Utility method to query the modifier flags of this member.:::Modifier.isFinal
MemberName#canBeStaticallyBound():::Utility method to query whether this member or its defining class is final.:::clazz.getModifiers->Modifier.isFinal
MemberName#isVolatile():::Utility method to query the modifier flags of this member.:::Modifier.isVolatile
MemberName#isAbstract():::Utility method to query the modifier flags of this member.:::Modifier.isAbstract
MemberName#isNative():::Utility method to query the modifier flags of this member.:::Modifier.isNative
MemberName#isBridge():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::this.testAllFlags
MemberName#isVarargs():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::this.testAllFlags->this.isInvocable
MemberName#isSynthetic():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::this.testAllFlags
MemberName#isInvocable():::Utility method to query whether this member is a method or constructor.:::this.testAnyFlags
MemberName#isFieldOrMethod():::Utility method to query whether this member is a method, constructor, or field.:::this.testAnyFlags
MemberName#isMethod():::Query whether this member is a method.:::this.testAllFlags
MemberName#isConstructor():::Query whether this member is a constructor.:::this.testAllFlags
MemberName#isField():::Query whether this member is a field.:::this.testAllFlags
MemberName#isType():::Query whether this member is a type.:::this.testAllFlags
MemberName#isPackage():::Utility method to query whether this member is neither public, private, nor protected.:::this.testAnyFlags
MemberName#isCallerSensitive():::Query whether this member has a CallerSensitive annotation.:::this.testAllFlags
MemberName#isAccessibleFrom(Class):::Utility method to query whether this member is accessible from a given lookup class.:::this.getDeclaringClass->this.getDeclaringClass->VerifyAccess.isMemberAccessible
MemberName#refersTo(Class, String):::Check if MemberName is a call to a method named name in class declaredClass.:::getName().equals
MemberName#asConstructor():::If this MN is not REF_newInvokeSpecial, return a clone with that ref:::clone().changeReferenceKind->this.getReferenceKind->this.toString
MemberName#asNormalOriginal():::If this MN is a REF_invokeSpecial, return a clone with the "normal" kind  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface:::clazz.isInterface->this.getReferenceKind->clone().changeReferenceKind->result.getReferenceKind->this.referenceKindIsConsistentWith
MemberName#makeMethodHandleInvoke(String, MethodType):::Create a name for a signature-polymorphic invoker:::this.makeMethodHandleInvoke
MemberName#getDefinition():::Get the definition of this member name:::this.isResolved->this.isType->this.clone->res.expandFromVM->this.getName->res.getName().equals
MemberName#equals(MemberName):::Decide if two member names have exactly the same symbolic content:::this.getReferenceKind->that.getReferenceKind->Objects.equals->this.getType->that.getType->Objects.equals
MemberName#hasReceiverTypeDispatch():::Query whether this member name is resolved to a non-static, non-final method.:::this.getReferenceKind->MethodHandleNatives.refKindDoesDispatch
MemberName#isResolved():::Query whether this member name is resolved:::
MemberName#toString():::Produce a string form of this member name:::this.isType->type.toString->this.getDeclaringClass->this.getName->buf.append->buf.append->buf.append->this.isInvocable->buf.append->buf.append->buf.append->this.getReferenceKind->buf.append->MethodHandleNatives.refKindName->buf.append->buf.toString
MemberName.Factory#resolveOrFail(byte, MemberName, Class, Class):::Produce a resolved version of the given member:::this.resolve->result.isResolved->result.makeAccessException->nsmClass.cast
MemberName.Factory#resolveOrNull(byte, MemberName, Class):::Produce a resolved version of the given member:::this.resolve->result.isResolved
MemberName.Factory#getMethods(Class, boolean, Class):::Return a list of all methods defined by the given class:::this.getMethods
MemberName.Factory#getMethods(Class, boolean, String, MethodType, Class):::Return a list of matching methods defined by the given class:::this.getMembers
MemberName.Factory#getConstructors(Class, Class):::Return a list of all constructors defined by the given class:::this.getMembers
MemberName.Factory#getFields(Class, boolean, Class):::Return a list of all fields defined by the given class:::this.getFields
MemberName.Factory#getFields(Class, boolean, String, Class, Class):::Return a list of all fields defined by the given class:::this.getMembers
MemberName.Factory#getNestedTypes(Class, boolean, Class):::Return a list of all nested types defined by the given class:::this.getMembers
MethodHandle#type():::Reports the type of this method handle:::
MethodHandle#invokeExact(Object...):::Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match:::
MethodHandle#invoke(Object...):::Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values:::
MethodHandle#invokeBasic(Object...):::Private method for trusted invocation of a method handle respecting simplified signatures:::
MethodHandle#linkToVirtual(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeVirtual:::
MethodHandle#linkToStatic(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeStatic:::
MethodHandle#linkToSpecial(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeSpecial:::
MethodHandle#linkToInterface(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeInterface:::
MethodHandle#invokeWithArguments(Object...):::Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument array:::MethodType.genericMethodType->this.asType->invocationType.invokers().spreadInvoker(0).invokeExact
MethodHandle#invokeWithArguments(java.util.List):::Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument list:::arguments.toArray->this.invokeWithArguments
MethodHandle#asType(MethodType):::Produces an adapter method handle which adapts the type of the current method handle to a new type:::this.asTypeCached->this.asTypeUncached
MethodHandle#asSpreader(Class, int):::Makes an array-spreading method handle, which accepts a trailing array argument and spreads its elements as positional arguments:::type().parameterCount->this.asSpreader
MethodHandle#asSpreader(int, Class, int):::Makes an array-spreading method handle, which accepts an array argument at a given position and spreads its elements as positional arguments in place of the array:::this.asSpreaderChecks->this.asType->afterSpread.rebind->mh.editor().spreadArgumentsForm->postSpreadType.replaceParameterTypes->mh.copyWith
MethodHandle#withVarargs(boolean):::Adapts this method handle to be #asVarargsCollector variable arity if the boolean flag is true, else #asFixedArity fixed arity:::this.isVarargsCollector->type().lastParameterType->this.asVarargsCollector
MethodHandle#asCollector(Class, int):::Makes an array-collecting method handle, which accepts a given number of trailing positional arguments and collects them into an array argument:::type().parameterCount->this.asCollector
MethodHandle#asCollector(int, Class, int):::Makes an array-collecting method handle, which accepts a given number of positional arguments starting at a given position, and collects them into an array argument:::this.asCollectorChecks->this.rebind->type().asCollectorType->MethodHandleImpl.varargsArray->mh.editor().collectArgumentArrayForm->mh.copyWith->newArray.type().basicType->mh.editor().collectArgumentsForm->mh.copyWithExtendL
MethodHandle#asVarargsCollector(Class):::Makes a variable arity adapter which is able to accept any number of trailing positional arguments and collect them into an array argument:::Objects.requireNonNull->type().parameterCount->this.asCollectorChecks->this.isVarargsCollector->MethodHandleImpl.makeVarargsCollector
MethodHandle#isVarargsCollector():::Determines if this method handle supports #asVarargsCollector variable arity calls:::
MethodHandle#asFixedArity():::Makes a fixed arity method handle which is otherwise equivalent to the current method handle:::this.isVarargsCollector
MethodHandle#bindTo(Object):::Binds a value x to the first argument of a method handle, without invoking it:::type.leadingReferenceParameter().cast->this.bindArgumentL
MethodHandle#toString():::Returns a string representation of the method handle, starting with the string "MethodHandle" and ending with the string representation of the method handle's type:::this.debugString->this.standardString
MethodHandle#debugString():::Return a string with a several lines describing the method handle structure:::this.internalForm->this.internalProperties
MethodHandle#rebind():::Require this method handle to be a BMH, or else replace it with a "wrapper" BMH:::
MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean, boolean):::Create a JVM-level adapter method handle to conform the given method handle to the similar newType, using only pairwise argument conversions:::target.type->this.makePairwiseConvertByEditor
MethodHandleImpl#valueConversion(Class, Class, boolean, boolean):::Find a conversion function from the given source to the given destination:::VerifyType.isNullConversion->src.isPrimitive->dst.isPrimitive->Wrapper.forPrimitiveType->wdst.wrapperType->ValueConversions.unboxCast->ValueConversions.unboxWiden->ValueConversions.unboxExact->dst.isPrimitive->Wrapper.forPrimitiveType->ValueConversions.boxExact->fn.type().parameterType->wsrc.primitiveType->fn.type().returnType->wsrc.wrapperType->wsrc.wrapperType->VerifyType.isNullConversion->MethodType.methodType->MethodHandleImpl.makePairwiseConvert->fn.asType->ValueConversions.convertPrimitive->fn.type().parameterCount->src.getSimpleName->dst.getSimpleName->Arrays.asList
MethodHandleImpl#makeSpreadArguments(MethodHandle, Class, int, int):::Factory method:  Spread selected argument.:::target.type->VerifyType.spreadArgElementType->targetType.changeParameterType->target.asType->targetType.replaceParameterTypes->srcType.invokerType->this.arguments->lambdaType.parameterCount->targetType.parameterCount->lambdaType.parameterType->MethodHandles.arrayElementGetter->this.getFunction->targetType.parameterCount->targetType.parameterCount->targetType.parameterCount->lambdaType.parameterCount->SimpleMethodHandle.make
MethodHandleImpl#makeCollectArguments(MethodHandle, MethodHandle, int, boolean):::Factory method:  Collect or filter selected argument(s).:::target.type->collector.type->collectorType.parameterCount->collectorType.returnType->// (a..., [b...])=>r
targetType.dropParameterTypes->collectorType.parameterArray->srcType.insertParameterTypes->srcType.invokerType->this.arguments->Arrays.copyOfRange->targetType.parameterCount->System.arraycopy->System.arraycopy->System.arraycopy->lambdaType.parameterCount->SimpleMethodHandle.make
MethodHandleImpl#makeBlockInliningWrapper(MethodHandle):::Block inlining during JIT-compilation of a target method handle if it hasn't been invoked enough times:::Makers.PRODUCE_REINVOKER_FORM.apply->Makers.PRODUCE_BLOCK_INLINING_FORM.apply
MethodHandleImpl#guardWithCatch(MethodHandle, Class, MethodHandle, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch).:::exType.isInstance->this.prepend->catcher.asFixedArity().invokeWithArguments->target.asFixedArity().invokeWithArguments
MethodHandleImpl#bindCaller(MethodHandle, Class):::Create an alias for the method handle which, when called, appears to be called from the same class loader and protection domain as hostClass:::BindCaller.bindCaller
MethodHandleImpl#varargsArray(int):::Return a method handle that takes the indicated number of Object  arguments and returns an Object array of them, as if for varargs.:::this.getConstantHandle->this.getConstantHandle->this.buildVarargsArray->this.findCollector->this.assertCorrectArity->this.makeIntrinsic
MethodHandleImpl#varargsArray(Class, int):::Return a method handle that takes the indicated number of  typed arguments and returns an array of them:::arrayType.getComponentType->elemType.isPrimitive->Wrapper.forPrimitiveType(elemType).stackSlots->arrayType.getSimpleName->this.varargsArray->Makers.TYPED_COLLECTORS.get->elemType.isPrimitive->arrayType.asSubclass->Arrays.copyOf->getConstantHandle(MH_fillNewTypedArray).bindTo->this.getConstantHandle->this.buildVarargsArray->this.getConstantHandle->this.buildArrayProducer->this.buildVarargsArray->arrayType.getComponentType->java.lang.reflect.Array.newInstance->MethodHandles.constant->Collections.nCopies->MethodType.methodType->mh.asType->this.makeIntrinsic->this.assertCorrectArity
MethodHandleImpl#makeLoop(Class, List>, List, List, List, List):::Assembles a loop method handle from the given handles and type information.:::MethodType.methodType->init.stream().map(h -> h.type().returnType()).map(BasicType::basicType).toArray->type.basicType->this.makeLoopForm->type.changeReturnType->varargsArray(type.parameterCount()).asType->this.unboxResultHandle->this.toArray->this.toArray->this.toArray->this.toArray->BoundMethodHandle.speciesData_LLL->this.uncaughtException->data.factory().invokeBasic->mh.type
MethodHandleImpl#loop(BasicType[], LoopClauses, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitLoop(int)).:::Stream.of(init).filter(h -> h.type().returnType() != void.class).count->init[0].type().parameterCount->ih.type().returnType->ih.invokeWithArguments->ih.invokeWithArguments->System.arraycopy->s.type().returnType->s.invokeWithArguments->s.invokeWithArguments->p.invokeWithArguments->f.invokeWithArguments
MethodHandleImpl#countedLoopPredicate(int, int):::This method is bound as the predicate in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops.:::
MethodHandleImpl#countedLoopStep(int, int):::This method is bound as the step function in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops to increment the counter.:::
MethodHandleImpl#initIterator(Iterable):::This is bound to initialize the loop-local iterator in MethodHandles#iteratedLoop iterating loops.:::it.iterator
MethodHandleImpl#iteratePredicate(Iterator):::This method is bound as the predicate in MethodHandles#iteratedLoop iterating loops.:::it.hasNext
MethodHandleImpl#iterateNext(Iterator):::This method is bound as the step for retrieving the current value from the iterator in MethodHandles#iteratedLoop iterating loops.:::it.next
MethodHandleImpl#makeTryFinally(MethodHandle, MethodHandle, Class, List>):::Makes a try-finally handle that conforms to the type constraints.:::MethodType.methodType->type.basicType->this.makeTryFinallyForm->type.changeReturnType->varargsArray(type.parameterCount()).asType->this.unboxResultHandle->BoundMethodHandle.speciesData_LLLL->this.uncaughtException->data.factory().invokeBasic->mh.type
MethodHandleImpl#tryFinally(MethodHandle, MethodHandle, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitTryFinally emitTryFinally).:::target.type().returnType->this.prepend->this.prepend->cleanup.invokeWithArguments->target.invokeWithArguments
MethodHandleInfo#getReferenceKind():::Returns the reference kind of the cracked method handle, which in turn determines whether the method handle's underlying member was a constructor, method, or field:::
MethodHandleInfo#getDeclaringClass():::Returns the class in which the cracked method handle's underlying member was defined.:::
MethodHandleInfo#getName():::Returns the name of the cracked method handle's underlying member:::
MethodHandleInfo#getMethodType():::Returns the nominal type of the cracked symbolic reference, expressed as a method type:::
MethodHandleInfo#reflectAs(Class, Lookup):::Reflects the underlying member as a method, constructor, or field object:::
MethodHandleInfo#getModifiers():::Returns the access modifiers of the underlying member.:::
MethodHandleInfo#referenceKindToString(int):::Returns the descriptive name of the given reference kind, as defined in the table above:::MethodHandleNatives.refKindIsValid->this.newIllegalArgumentException->MethodHandleNatives.refKindName
MethodHandleInfo#toString(int, Class, String, MethodType):::Returns a string representation for a MethodHandleInfo, given the four parts of its symbolic reference:::Objects.requireNonNull->Objects.requireNonNull->this.referenceKindToString->defc.getName->String.format
MethodHandleNatives#setCallSiteTargetNormal(CallSite, MethodHandle):::Tell the JVM that we need to change the target of a CallSite.:::
MethodHandleNatives#linkCallSite(Object, int, Object, Object, Object, Object, Object[]):::The JVM is linking an invokedynamic instruction:::nameObj.toString().intern->this.linkCallSiteImpl->this.linkCallSiteTracing
MethodHandleNatives#staticArgumentsPulled(Object):::The JVM is requesting pull-mode bootstrap when it provides  a tuple of the form int[]{ argc, vmindex }:::
MethodHandleNatives#isPullModeBSM(MethodHandle):::A BSM runs in pull-mode if and only if its sole arguments are (Lookup, BootstrapCallInfo), or can be converted pairwise to those types, and it is not of variable arity:::
MethodHandleNatives#findMethodHandleType(Class, Class[]):::The JVM wants a pointer to a MethodType:::MethodType.makeImpl
MethodHandleNatives#linkMethod(Class, int, Class, String, Object, Object[]):::The JVM wants to link a call site that requires a dynamic type check:::this.linkMethodImpl->this.linkMethodTracing
MethodHandleNatives#linkMethodHandleConstant(Class, int, Class, String, Object):::The JVM is resolving a CONSTANT_MethodHandle CP entry:::this.mapLookupExceptionToError->IMPL_LOOKUP.in->this.refKindIsValid->lookup.linkMethodHandleConstant
MethodHandleNatives#mapLookupExceptionToError(ReflectiveOperationException):::Map a reflective exception to a linkage error.:::ex.getMessage->ex.getMessage->ex.getCause->ex.getMessage->this.initCauseFrom
MethodHandleNatives#initCauseFrom(E, Exception):::Use best possible cause for err.initCause(), substituting the cause for err itself if the cause has the same (or better) type.:::ex.getCause->err.getClass->Eclass.isInstance->Eclass.cast->err.initCause
MethodHandleNatives#isCallerSensitive(MemberName):::Is this method a caller-sensitive method? I.e., does it call Reflection.getCallerClass or a similar method to ask about the identity of its caller?:::mem.isInvocable->mem.isCallerSensitive->this.canBeCalledVirtual
MethodHandleProxies#isWrapperInstance(Object):::Determines if the given object was produced by a call to #asInterfaceInstance asInterfaceInstance.:::
MethodHandleProxies#wrapperInstanceTarget(Object):::Produces or recovers a target method handle which is behaviorally equivalent to the unique method of this wrapper instance:::asWrapperInstance(x).getWrapperInstanceTarget
MethodHandleProxies#wrapperInstanceType(Object):::Recovers the unique single-method interface type for which this wrapper instance was created:::asWrapperInstance(x).getWrapperInstanceType
MethodHandles#lookup():::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors of the caller:::Reflection.getCallerClass
MethodHandles#publicLookup():::Returns a Lookup lookup object which is trusted minimally:::
MethodHandles#privateLookupIn(Class, Lookup):::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors, including  private access, on a target class:::System.getSecurityManager->sm.checkPermission->targetClass.isPrimitive->targetClass.isArray->targetClass.getModule->lookup.lookupClass().getModule->callerModule.canRead->targetModule.isNamed->targetClass.getPackageName->pn.length->targetModule.isOpen->lookup.lookupModes->callerModule.isNamed->targetModule.isNamed->IllegalAccessLogger.illegalAccessLogger->logger.logIfOpenedForIllegalAccess
MethodHandles#reflectAs(Class, MethodHandle):::Performs an unchecked "crack" of a direct method handle:::System.getSecurityManager->smgr.checkPermission->lookup.revealDirect(target).reflectAs
MethodHandles.Lookup#lookupClass():::Tells which class is performing the lookup:::
MethodHandles.Lookup#lookupModes():::Tells which access-protection classes of members this lookup object can produce:::
MethodHandles.Lookup#in(Class):::Creates a lookup on the specified new lookup class:::Objects.requireNonNull->VerifyAccess.isSameModule->this.lookupClass.getModule().isNamed->VerifyAccess.isSamePackage->VerifyAccess.isSamePackageMember->VerifyAccess.isClassAccessible->this.checkUnprivilegedlookupClass
MethodHandles.Lookup#dropLookupMode(int):::Creates a lookup on the same lookup class which this lookup object finds members, but with a lookup mode that has lost the given lookup mode:::this.lookupModes->this.lookupClass
MethodHandles.Lookup#defineClass(byte[]):::Defines a class to the same class loader and in the same runtime package and java.security.ProtectionDomain protection domain as this lookup's #lookupClass() lookup class:::System.getSecurityManager->sm.checkPermission->this.lookupModes->this.lookupModes->bytes.clone->cfe.initCause->reader.getClassName->name.lastIndexOf->name.replace->cn.substring->lookupClass.getPackageName->pn.equals->lookupClass.getClassLoader->this.lookupClassProtectionDomain->SharedSecrets.getJavaLangAccess().defineClass->clazz.getClassLoader->lookupClass.getClassLoader->lookupClass.getPackageName->clazz.getPackageName().equals->this.protectionDomain->this.lookupClassProtectionDomain
MethodHandles.Lookup#toString():::Displays the name of the class from which lookups are to be made:::lookupClass.getName->Integer.toHexString
MethodHandles.Lookup#findStatic(Class, String, MethodType):::Produces a method handle for a static method:::this.resolveOrFail->this.findBoundCallerClass->this.getDirectMethod
MethodHandles.Lookup#findVirtual(Class, String, MethodType):::Produces a method handle for a virtual method:::this.findVirtualForVH->this.findVirtualForMH->refc.isInterface->this.resolveOrFail->this.findBoundCallerClass->this.getDirectMethod
MethodHandles.Lookup#findConstructor(Class, MethodType):::Produces a method handle which creates an object and initializes it, using the constructor of the specified type:::refc.isArray->refc.getName->this.resolveOrFail->this.getDirectConstructor
MethodHandles.Lookup#findClass(String):::Looks up a class by name from the lookup context defined by this Lookup object:::lookupClass.getClassLoader->Class.forName->this.accessClass
MethodHandles.Lookup#accessClass(Class):::Determines if a class can be accessed from the lookup context defined by this Lookup object:::VerifyAccess.isClassAccessible->new MemberName(targetClass).makeAccessException->this.checkSecurityManager
MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class):::Produces an early-bound method handle for a virtual method:::this.checkSpecialCaller->this.in->specialLookup.resolveOrFail->this.findBoundCallerClass->specialLookup.getDirectMethod
MethodHandles.Lookup#findGetter(Class, String, Class):::Produces a method handle giving read access to a non-static field:::this.resolveOrFail->this.getDirectField
MethodHandles.Lookup#findSetter(Class, String, Class):::Produces a method handle giving write access to a non-static field:::this.resolveOrFail->this.getDirectField
MethodHandles.Lookup#findVarHandle(Class, String, Class):::Produces a VarHandle giving access to a non-static field name of type type declared in a class of type recv:::this.resolveOrFail->this.resolveOrFail->this.getFieldVarHandle
MethodHandles.Lookup#findStaticGetter(Class, String, Class):::Produces a method handle giving read access to a static field:::this.resolveOrFail->this.getDirectField
MethodHandles.Lookup#findStaticSetter(Class, String, Class):::Produces a method handle giving write access to a static field:::this.resolveOrFail->this.getDirectField
MethodHandles.Lookup#findStaticVarHandle(Class, String, Class):::Produces a VarHandle giving access to a static field name of type type declared in a class of type decl:::this.resolveOrFail->this.resolveOrFail->this.getFieldVarHandle
MethodHandles.Lookup#bind(Object, String, MethodType):::Produces an early-bound method handle for a non-static method:::receiver.getClass->this.resolveOrFail->this.findBoundCallerClass->this.getDirectMethodNoRestrictInvokeSpecial->receiver.getClass->mh.type().leadingReferenceParameter().isAssignableFrom->mh.type().leadingReferenceParameter().getName->receiver.getClass().getName->mh.bindArgumentL(0, receiver).setVarargs
MethodHandles.Lookup#unreflect(Method):::Makes a direct method handle to m, if the lookup class has permission:::m.getDeclaringClass->this.unreflectForMH->m.getDeclaringClass->this.unreflectForVH->method.getReferenceKind->method.isMethod->m.isAccessible->method.getDeclaringClass->this.findBoundCallerClass->lookup.getDirectMethodNoSecurityManager
MethodHandles.Lookup#unreflectSpecial(Method, Class):::Produces a method handle for a reflected method:::this.checkSpecialCaller->this.in->method.isMethod->method.getDeclaringClass->this.findBoundCallerClass->specialLookup.getDirectMethodNoSecurityManager
MethodHandles.Lookup#unreflectConstructor(Constructor):::Produces a method handle for a reflected constructor:::ctor.isConstructor->c.isAccessible->ctor.getDeclaringClass->lookup.getDirectConstructorNoSecurityManager
MethodHandles.Lookup#unreflectGetter(Field):::Produces a method handle giving read access to a reflected field:::this.unreflectField
MethodHandles.Lookup#unreflectSetter(Field):::Produces a method handle giving write access to a reflected field:::this.unreflectField
MethodHandles.Lookup#unreflectVarHandle(Field):::Produces a VarHandle giving access to a reflected field f of type T declared in a class of type R:::getField.getReferenceKind->putField.getReferenceKind->f.getDeclaringClass->this.getFieldVarHandleNoSecurityManager
MethodHandles.Lookup#revealDirect(MethodHandle):::Cracks a direct method handle created by this lookup object or a similar one:::target.internalMemberName->member.isResolved->member.isMethodHandleInvoke->member.isVarHandleMethodInvoke->this.newIllegalArgumentException->member.getDeclaringClass->member.getReferenceKind->MethodHandleNatives.refKindIsValid->target.isInvokeSpecial->defc.isInterface->this.checkAccess->this.checkSecurityManager->member.isCallerSensitive->target.internalCallerClass->this.hasPrivateAccess->this.lookupClass
MethodHandles.Lookup#checkMethodName(byte, String):::Check name for an illegal leading "&lt;" character.:::name.startsWith
MethodHandles.Lookup#findBoundCallerClass(MemberName):::Find my trustable caller class if m is a caller sensitive method:::MethodHandleNatives.isCallerSensitive->this.hasPrivateAccess
MethodHandles.Lookup#hasPrivateAccess():::Returns true if this lookup has PRIVATE access.:::
MethodHandles.Lookup#checkSecurityManager(Class, MemberName):::Perform necessary access checks:::System.getSecurityManager->this.hasPrivateAccess->VerifyAccess.classLoaderIsAncestor->ReflectUtil.checkPackageAccess->smgr.checkPermission->m.isPublic->smgr.checkPermission->m.getDeclaringClass->ReflectUtil.checkPackageAccess
MethodHandles.Lookup#checkAccess(byte, Class, MemberName):::Check public/protected/private bits on the symbolic reference class and its member.:::m.referenceKindIsConsistentWith->MethodHandleNatives.refKindIsValid->MethodHandleNatives.refKindIsField->m.isField->m.getModifiers->Modifier.isProtected->m.getDeclaringClass->m.getName().equals->refc.isArray->Modifier.isProtected->Modifier.isFinal->MethodHandleNatives.refKindIsSetter->m.makeAccessException->this.fixmods->m.getDeclaringClass->this.lookupClass->VerifyAccess.isSamePackage->m.getDeclaringClass->this.lookupClass->VerifyAccess.isMemberAccessible->this.accessFailedMessage->m.makeAccessException
MethodHandles#arrayConstructor(Class):::Produces a method handle constructing arrays of a desired type, as if by the anewarray bytecode:::arrayClass.isArray->arrayClass.getName->this.newIllegalArgumentException->arrayClass.getComponentType->MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).bindTo->ani.type().changeReturnType->ani.asType
MethodHandles#arrayLength(Class):::Produces a method handle returning the length of an array, as if by the arraylength bytecode:::MethodHandleImpl.makeArrayElementAccessor
MethodHandles#arrayElementGetter(Class):::Produces a method handle giving read access to elements of an array, as if by the aaload bytecode:::MethodHandleImpl.makeArrayElementAccessor
MethodHandles#arrayElementSetter(Class):::Produces a method handle giving write access to elements of an array, as if by the astore bytecode:::MethodHandleImpl.makeArrayElementAccessor
MethodHandles#arrayElementVarHandle(Class):::Produces a VarHandle giving access to elements of an array of type arrayClass:::VarHandles.makeArrayElementHandle
MethodHandles#byteArrayViewVarHandle(Class, ByteOrder):::Produces a VarHandle giving access to elements of a byte[] array viewed as if it were a different primitive array type, such as int[] or long[]:::Objects.requireNonNull->VarHandles.byteArrayViewHandle
MethodHandles#byteBufferViewVarHandle(Class, ByteOrder):::Produces a VarHandle giving access to elements of a ByteBuffer viewed as if it were an array of elements of a different primitive component type to that of byte, such as int[] or long[]:::Objects.requireNonNull->VarHandles.makeByteBufferViewHandle
MethodHandles#spreadInvoker(MethodType, int):::Produces a method handle which will invoke any method handle of the given type, with a given number of trailing arguments replaced by a single trailing Object[] array:::type.parameterCount->this.newIllegalArgumentException->type.parameterCount->type.asSpreaderType->type.invokers().spreadInvoker
MethodHandles#exactInvoker(MethodType):::Produces a special invoker method handle which can be used to invoke any method handle of the given type, as if by MethodHandle#invokeExact invokeExact:::type.invokers().exactInvoker
MethodHandles#invoker(MethodType):::Produces a special invoker method handle which can be used to invoke any method handle compatible with the given type, as if by MethodHandle#invoke invoke:::type.invokers().genericInvoker
MethodHandles#varHandleExactInvoker(VarHandle.AccessMode, MethodType):::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type:::type.invokers().varHandleMethodExactInvoker
MethodHandles#varHandleInvoker(VarHandle.AccessMode, MethodType):::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type:::type.invokers().varHandleMethodInvoker
MethodHandles#explicitCastArguments(MethodHandle, MethodType):::Produces a method handle which adapts the type of the given method handle to a new type by pairwise argument and return type conversion:::this.explicitCastArgumentsChecks->target.type->oldType.explicitCastEquivalentToAsType->target.asFixedArity().asType->MethodHandleImpl.makePairwiseConvert
MethodHandles#permuteArguments(MethodHandle, MethodType, int...):::Produces a method handle which adapts the calling sequence of the given method handle to a new type, by reordering the arguments:::reorder.clone->target.type->this.permuteArgumentChecks->target.rebind->newType.parameterCount->newType.parameterType->BasicType.basicType->form.editor().addArgumentForm->oldType.insertParameterTypes->Arrays.copyOf->System.arraycopy->form.editor().dupArgumentForm->oldType.dropParameterTypes->System.arraycopy->Arrays.copyOf->this.permuteArgumentChecks->this.findFirstDupOrDrop->form.editor().permuteArgumentsForm->result.type->result.internalForm->result.copyWith
MethodHandles#constant(Class, Object):::Produces a method handle of the requested return type which returns the given constant value every time it is invoked:::type.isPrimitive->this.zero->identity(type).bindTo->this.newIllegalArgumentException->Wrapper.forPrimitiveType->w.convert->w.zero().equals->this.zero->this.identity->this.insertArguments
MethodHandles#identity(Class):::Produces a method handle which returns its sole argument when invoked.:::type.isPrimitive->Wrapper.forPrimitiveType->btw.ordinal->btw.primitiveType->this.makeIdentity->this.setCachedMethodHandle->ident.type().returnType->this.makeIdentity
MethodHandles#zero(Class):::Produces a constant method handle of the requested return type which returns the default value for that type every time it is invoked:::Objects.requireNonNull->type.isPrimitive->this.zero->Wrapper.forPrimitiveType->this.zero
MethodHandles#empty(MethodType):::Produces a method handle of the requested type which ignores any arguments, does nothing, and returns a suitable default depending on the return type:::Objects.requireNonNull->type.returnType->this.zero->type.parameterList->this.dropArguments
MethodHandles#insertArguments(MethodHandle, int, Object...):::Provides a target method handle with one or more bound arguments in advance of the method handle's invocation:::this.insertArgumentsChecks->target.rebind->ptype.isPrimitive->ptype.cast->result.bindArgumentL->this.insertArgumentPrimitive
MethodHandles#dropArguments(MethodHandle, int, List>):::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle:::valueTypes.toArray->this.copyTypes->this.dropArguments0
MethodHandles#dropArguments(MethodHandle, int, Class...):::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle:::this.copyTypes->this.dropArguments0
MethodHandles#dropArgumentsToMatch(MethodHandle, int, List>, int):::Adapts a target method handle to match the given parameter type list:::Objects.requireNonNull->Objects.requireNonNull->this.dropArgumentsToMatch
MethodHandles#filterArguments(MethodHandle, int, MethodHandle...):::Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function:::this.filterArgumentsCheckArity->this.filterArgument
MethodHandles#collectArguments(MethodHandle, int, MethodHandle):::Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle):::this.collectArgumentsChecks->filter.type->target.rebind->collectorType.returnType().isArray->filter.intrinsicName->result.editor().collectArgumentArrayForm->result.copyWith->collectorType.basicType->result.editor().collectArgumentsForm->result.copyWithExtendL
MethodHandles#filterReturnValue(MethodHandle, MethodHandle):::Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle):::target.type->filter.type->this.filterReturnValueChecks->target.rebind->filterType.returnType->BasicType.basicType->result.editor().filterReturnForm->filterType.returnType->targetType.changeReturnType->result.copyWithExtendL
MethodHandles#foldArguments(MethodHandle, MethodHandle):::Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments:::this.foldArguments
MethodHandles#foldArguments(MethodHandle, int, MethodHandle):::Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments just before the folded arguments:::target.type->combiner.type->this.foldArgumentChecks->target.rebind->combinerType.basicType->result.editor().foldArgumentsForm->newType.dropParameterTypes->result.copyWithExtendL
MethodHandles#foldArguments(MethodHandle, int, MethodHandle, int...):::As foldArguments(MethodHandle, int, MethodHandle), but with the added capability of selecting the arguments from the targets parameters to call the combiner with:::target.type->combiner.type->this.foldArgumentChecks->target.rebind->combinerType.basicType->result.editor().foldArgumentsForm->newType.dropParameterTypes->result.copyWithExtendL
MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle):::Makes a method handle which adapts a target method handle, by guarding it with a test, a boolean-valued method handle:::test.type->target.type->fallback.type->ttype.equals->this.misMatchedTypes->gtype.returnType->this.newIllegalArgumentException->ttype.parameterList->this.dropArgumentsToMatch->this.misMatchedTypes->MethodHandleImpl.makeGuardWithTest
MethodHandles#catchException(MethodHandle, Class, MethodHandle):::Makes a method handle which adapts a target method handle, by running it inside an exception handler:::target.type->handler.type->Throwable.class.isAssignableFrom->exType.getName->htype.parameterCount->htype.parameterType(0).isAssignableFrom->this.newIllegalArgumentException->htype.returnType->ttype.returnType->this.misMatchedTypes->ttype.parameterList->this.dropArgumentsToMatch->this.misMatchedTypes->MethodHandleImpl.makeGuardWithCatch
MethodHandles#throwException(Class, Class):::Produces a method handle which will throw exceptions of the given exType:::Throwable.class.isAssignableFrom->exType.getName->this.methodType->MethodHandleImpl.throwException
MethodHandles#loop(MethodHandle[]...):::Constructs a method handle representing a loop with several loop variables that are updated and checked upon each iteration:::this.loopChecks0->Stream.of(clauses).filter(c -> Stream.of(c).anyMatch(Objects::nonNull)).forEach->Stream.of(init, step, pred, fini).map(List::size).distinct().count->init.size->init.get->step.get->iterationVariableTypes.add->this.loopChecks1a->in.type().returnType->iterationVariableTypes.add->iterationVariableTypes.add->Collectors.toList->iterationVariableTypes.stream().filter(t -> t != void.class).collect->commonPrefix.size->this.buildCommonSuffix->this.loopChecks1b->fini.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).findFirst().orElse->this.loopChecks1cd->commonParameterSequence.addAll->this.loopChecks2->iterationVariableTypes.get->init.get->this.methodType->this.empty->init.set->step.get->this.identityOrVoid->this.dropArgumentsToMatch->step.set->pred.get->this.constant->this.dropArguments0->pred.set->fini.get->this.methodType->this.empty->fini.set->this.fillParameterTypes->this.fixArities->this.fillParameterTypes->this.fixArities->this.fillParameterTypes->this.fixArities->this.fillParameterTypes->this.fixArities->finit.stream().map(MethodHandle::type).map(MethodType::parameterList).allMatch->Stream.of(fstep, fpred, ffini).flatMap(List::stream).map(MethodHandle::type).map(MethodType::parameterList).allMatch->MethodHandleImpl.makeLoop
MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a while loop from an initializer, a body, and a predicate:::this.whileLoopChecks->body.type().returnType->this.identityOrVoid->this.loop
MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a do-while loop from an initializer, a body, and a predicate:::this.whileLoopChecks->body.type().returnType->this.identityOrVoid->this.loop
MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that runs a given number of iterations:::iterations.type->this.empty->this.countedLoop
MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that counts over a range of numbers:::this.countedLoopChecks->start.type().returnType->end.type().returnType->body.type().returnType->MethodHandleImpl.getConstantHandle->MethodHandleImpl.getConstantHandle->this.dropArguments->this.dropArguments->this.identity->this.dropArguments->this.dropArguments->this.loop
MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that ranges over the values produced by an Iterator<T>:::this.iteratedLoopChecks->body.type().returnType->MethodHandleImpl.getConstantHandle->MethodHandleImpl.getConstantHandle->iterator.type().changeReturnType->MethodHandleImpl.getConstantHandle->startIter.type().changeParameterType->body.type().parameterType->nextRaw.type().changeReturnType->startIter.asType->nextRaw.asType->this.identity->this.dropArguments->this.swapArguments->this.filterArgument->this.loop
MethodHandles#tryFinally(MethodHandle, MethodHandle):::Makes a method handle that adapts a target method handle by wrapping it in a try-finally block:::target.type().parameterList->target.type().returnType->this.tryFinallyChecks->this.dropArgumentsToMatch->cleanup.type().changeParameterType->cleanup.asType->target.asFixedArity->cleanup.asFixedArity->MethodHandleImpl.makeTryFinally
MethodType#methodType(Class, Class[]):::Finds or creates an instance of the given method type.:::this.makeImpl
MethodType#methodType(Class, List>):::Finds or creates a method type with the given components:::this.listToArray->this.makeImpl
MethodType#methodType(Class, Class, Class...):::Finds or creates a method type with the given components:::System.arraycopy->this.makeImpl
MethodType#methodType(Class):::Finds or creates a method type with the given components:::this.makeImpl
MethodType#methodType(Class, Class):::Finds or creates a method type with the given components:::this.makeImpl
MethodType#methodType(Class, MethodType):::Finds or creates a method type with the given components:::this.makeImpl
MethodType#genericMethodType(int, boolean):::Finds or creates a method type whose components are Object with an optional trailing Object[] array:::this.checkSlotCount->Arrays.fill->this.makeImpl
MethodType#genericMethodType(int):::Finds or creates a method type whose components are all Object:::this.genericMethodType
MethodType#changeParameterType(int, Class):::Finds or creates a method type with a single different parameter type:::this.parameterType->this.checkPtype->ptypes.clone->this.makeImpl
MethodType#insertParameterTypes(int, Class...):::Finds or creates a method type with additional parameter types:::this.newIndexOutOfBoundsException->this.checkPtypes->this.parameterSlotCount->this.checkSlotCount->System.arraycopy->System.arraycopy->System.arraycopy->this.makeImpl
MethodType#appendParameterTypes(Class...):::Finds or creates a method type with additional parameter types:::this.parameterCount->this.insertParameterTypes
MethodType#insertParameterTypes(int, List>):::Finds or creates a method type with additional parameter types:::this.listToArray->this.insertParameterTypes
MethodType#appendParameterTypes(List>):::Finds or creates a method type with additional parameter types:::this.parameterCount->this.insertParameterTypes
MethodType#dropParameterTypes(int, int):::Finds or creates a method type with some parameter types omitted:::this.newIndexOutOfBoundsException->Arrays.copyOfRange->System.arraycopy->Arrays.copyOfRange->Arrays.copyOfRange->this.makeImpl
MethodType#changeReturnType(Class):::Finds or creates a method type with a different return type:::this.returnType->this.makeImpl
MethodType#hasPrimitives():::Reports if this type contains a primitive argument or return value:::form.hasPrimitives
MethodType#hasWrappers():::Reports if this type contains a wrapper argument or return value:::this.unwrap
MethodType#erase():::Erases all reference types to Object:::form.erasedType
MethodType#generic():::Converts all types, both reference and primitive, to Object:::this.parameterCount->this.genericMethodType
MethodType#wrap():::Converts all primitive types to their corresponding wrapper types:::this.hasPrimitives->this.wrapWithPrims
MethodType#unwrap():::Converts all wrapper types to their corresponding primitive types:::this.hasPrimitives->this.wrapWithPrims->this.unwrapWithNoPrims
MethodType#parameterType(int):::Returns the parameter type at the specified index, within this method type.:::
MethodType#parameterCount():::Returns the number of parameter types in this method type.:::
MethodType#returnType():::Returns the return type of this method type.:::
MethodType#parameterList():::Presents the parameter types as a list (a convenience method):::ptypes.clone->Arrays.asList->Collections.unmodifiableList
MethodType#lastParameterType():::Returns the last parameter type of this method type:::
MethodType#parameterArray():::Presents the parameter types as an array (a convenience method):::ptypes.clone
MethodType#equals(Object):::Compares the specified object with this type for equality:::this.equals
MethodType#hashCode():::Returns the hash code value for this method type:::rtype.hashCode->ptype.hashCode
MethodType#toString():::Returns a string representation of the method type, of the form "(PT0,PT1...)RT":::rtype.getSimpleName->ptypes[i].getSimpleName->sj.add->sj.toString
MethodType#fromMethodDescriptorString(String, ClassLoader):::Finds or creates an instance of a method type, given the spelling of its bytecode descriptor:::this.fromDescriptor
MethodType#fromDescriptor(String, ClassLoader):::Same as #fromMethodDescriptorString(String, ClassLoader), but null ClassLoader means the bootstrap loader is used here:::descriptor.startsWith->descriptor.indexOf->descriptor.indexOf->this.newIllegalArgumentException->BytecodeDescriptor.parseMethod->types.size->types.remove->this.listToArray->this.makeImpl
MethodType#toMethodDescriptorString():::Produces a bytecode descriptor representation of the method type:::BytecodeDescriptor.unparseMethod
MethodTypeForm#erasedType():::Return the type corresponding uniquely (1-1) to this MT-form:::
MethodTypeForm#basicType():::Return the basic type derived from the erased type of this MT-form:::
MethodTypeForm#canonicalize(MethodType, int, int):::Canonicalize the types in the given method type:::mt.ptypes->MethodTypeForm.canonicalizeAll->mt.returnType->MethodTypeForm.canonicalize->MethodType.makeImpl
MethodTypeForm#canonicalize(Class, int):::Canonicalize the given return or param type:::t.isPrimitive->Wrapper.asWrapperType->Wrapper.asPrimitiveType
MethodTypeForm#canonicalizeAll(Class[], int):::Canonicalize each param type in the given array:::this.canonicalize->ts.clone
MutableCallSite#getTarget():::Returns the target method of the call site, which behaves like a normal field of the MutableCallSite:::
MutableCallSite#setTarget(MethodHandle):::Updates the target method of this call site, as a normal variable:::this.checkTargetChange->this.setTargetNormal
MutableCallSite#syncAll(MutableCallSite[]):::Performs a synchronization operation on each call site in the given array, forcing all other threads to throw away any cached values previously loaded from the target of any of the call sites:::STORE_BARRIER.lazySet->Objects.requireNonNull
SerializedLambda#getCapturingClass():::Get the name of the class that captured this lambda.:::capturingClass.getName().replace
SerializedLambda#getFunctionalInterfaceClass():::Get the name of the invoked type to which this lambda has been converted:::
SerializedLambda#getFunctionalInterfaceMethodName():::Get the name of the primary method for the functional interface to which this lambda has been converted.:::
SerializedLambda#getFunctionalInterfaceMethodSignature():::Get the signature of the primary method for the functional interface to which this lambda has been converted.:::
SerializedLambda#getImplClass():::Get the name of the class containing the implementation method.:::
SerializedLambda#getImplMethodName():::Get the name of the implementation method.:::
SerializedLambda#getImplMethodSignature():::Get the signature of the implementation method.:::
SerializedLambda#getImplMethodKind():::Get the method handle kind (see MethodHandleInfo) of the implementation method.:::
SerializedLambda#getInstantiatedMethodType():::Get the signature of the primary functional interface method after type variables are substituted with their instantiation from the capture site.:::
SerializedLambda#getCapturedArgCount():::Get the count of dynamic arguments to the lambda capture site.:::
SerializedLambda#getCapturedArg(int):::Get a dynamic argument to the lambda capture site.:::
StringConcatFactory#makeConcat(MethodHandles.Lookup, String, MethodType):::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments:::System.out.println->this.doStringConcat
StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup, String, MethodType, String, Object...):::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments:::Arrays.toString->System.out.println->this.doStringConcat
SwitchPoint#hasBeenInvalidated():::Determines if this switch point has been invalidated yet:::mcs.getTarget
SwitchPoint#guardWithTest(MethodHandle, MethodHandle):::Returns a method handle which always delegates either to the target or the fallback:::mcs.getTarget->MethodHandles.guardWithTest
SwitchPoint#invalidateAll(SwitchPoint[]):::Sets all of the given switch points into the invalid state:::spt.mcs.setTarget->MutableCallSite.syncAll
TypeConvertingMethodAdapter#unbox(String, Wrapper):::Convert types by unboxing:::this.unboxMethod->this.unboxingDescriptor->this.visitMethodInsn
TypeConvertingMethodAdapter#convertType(Class, Class, Class):::Convert an argument of type 'arg' to be passed to 'target' assuring that it is 'functional':::arg.equals->arg.equals->arg.isPrimitive->BytecodeDescriptor.unparse->functional.isPrimitive->BytecodeDescriptor.unparse->this.cast->BytecodeDescriptor.unparse->target.isPrimitive->this.cast->this.toWrapper->this.wrapperOrNullFromDescriptor->wTarget.isSigned->wTarget.isFloating->this.wrapperName->this.cast->this.unbox->wps.isSigned->wps.isFloating->this.wrapperName->this.unbox->this.widen->this.wrapperName->this.unbox->Wrapper.forPrimitiveType->target.isPrimitive->BytecodeDescriptor.unparse->this.wrapperOrNullFromDescriptor->this.box->this.wrapperName->this.cast->this.widen->this.box->Wrapper.forPrimitiveType->this.widen
TypeConvertingMethodAdapter#iconst(int):::The following method is copied from org.objectweb.asm.commons.InstructionAdapter:::mv.visitLdcInsn->mv.visitIntInsn->mv.visitIntInsn->mv.visitInsn
VarHandle#get(Object...):::Returns the value of a variable, with memory semantics of reading as if the variable was declared non-volatile:::
VarHandle#set(Object...):::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared non-volatile and non-final:::
VarHandle#getVolatile(Object...):::Returns the value of a variable, with memory semantics of reading as if the variable was declared volatile:::
VarHandle#setVolatile(Object...):::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared volatile:::
VarHandle#getOpaque(Object...):::Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads:::
VarHandle#setOpaque(Object...):::Sets the value of a variable to the newValue, in program order, but with no assurance of memory ordering effects with respect to other threads:::
VarHandle#getAcquire(Object...):::Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access:::
VarHandle#setRelease(Object...):::Sets the value of a variable to the newValue, and ensures that prior loads and stores are not reordered after this access:::
VarHandle#compareAndSet(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#compareAndExchange(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#compareAndExchangeAcquire(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire:::
VarHandle#compareAndExchangeRelease(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#weakCompareAndSetPlain(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#weakCompareAndSet(Object...):::Possibly atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#weakCompareAndSetAcquire(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire:::
VarHandle#weakCompareAndSetRelease(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#getAndSet(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndSetAcquire(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndSetRelease(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndAdd(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #setVolatile, and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndAddAcquire(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #set, and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndAddRelease(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #setRelease, and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseOr(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseOrAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseOrRelease(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseAnd(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseAndAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseAndRelease(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseXor(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseXorAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseXorRelease(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#varType():::Returns the variable type of variables referenced by this VarHandle.:::this.accessModeType->typeSet.parameterCount->typeSet.parameterType
VarHandle#coordinateTypes():::Returns the coordinate types for this VarHandle.:::this.accessModeType->typeGet.parameterList
VarHandle#accessModeType(AccessMode):::Obtains the access mode type for this VarHandle and a given access mode:::this.getTypesAndInvokers->accessMode.at.ordinal->accessMode.at.ordinal->this.accessModeTypeUncached
VarHandle#isAccessModeSupported(AccessMode):::Returns true if the given access mode is supported, otherwise false:::accessMode.ordinal->AccessMode.getMemberName
VarHandle#toMethodHandle(AccessMode):::Obtains a method handle bound to this VarHandle and the given access mode.:::accessMode.ordinal->AccessMode.getMemberName->MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).bindTo->accessMode.ordinal->this.getMethodHandle->mh.bindTo
VarHandle#fullFence():::Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.:::UNSAFE.fullFence
VarHandle#acquireFence():::Ensures that loads before the fence will not be reordered with loads and stores after the fence.:::UNSAFE.loadFence
VarHandle#releaseFence():::Ensures that loads and stores before the fence will not be reordered with stores after the fence.:::UNSAFE.storeFence
VarHandle#loadLoadFence():::Ensures that loads before the fence will not be reordered with loads after the fence.:::UNSAFE.loadLoadFence
VarHandle#storeStoreFence():::Ensures that stores before the fence will not be reordered with stores after the fence.:::UNSAFE.storeStoreFence
VolatileCallSite#getTarget():::Returns the target method of the call site, which behaves like a volatile field of the VolatileCallSite:::this.getTargetVolatile
VolatileCallSite#setTarget(MethodHandle):::Updates the target method of this call site, as a volatile variable:::this.getTargetVolatile->this.checkTargetChange->this.setTargetVolatile
