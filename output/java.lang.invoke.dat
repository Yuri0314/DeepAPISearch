AbstractConstantGroup#size()::: abstract constant group size:::return
AbstractConstantGroup#get(int)::: abstract constant group get:::
AbstractConstantGroup#get(int, Object)::: abstract constant group get:::
AbstractConstantGroup#isPresent(int)::: abstract constant group is present:::
AbstractConstantGroup#toString():::Produce a string using the non-resolving list view, where unresolved elements are presented as asterisks.:::return->asList->toString
AbstractConstantGroup.AsIterator#hasNext()::: as iterator has next:::return
AbstractConstantGroup.AsIterator#next()::: as iterator next:::i->bumpIndex->if->return->self->get->else->return->self->get
AbstractConstantGroup.AsIterator#bumpIndex()::: as iterator bump index:::i->if->throw->new->NoSuchElementException->return
AbstractConstantGroup.SubGroup#mapIndex(int)::: sub group map index:::return->rangeCheck1
AbstractConstantGroup.SubGroup#get(int)::: sub group get:::return->self->mapIndex->get
AbstractConstantGroup.SubGroup#get(int, Object)::: sub group get:::return->self->mapIndex->get
AbstractConstantGroup.SubGroup#isPresent(int)::: sub group is present:::return->self->mapIndex->isPresent
AbstractConstantGroup.SubGroup#subGroup(int, int)::: sub group sub group:::rangeCheck2->return->new->SubGroup
AbstractConstantGroup.SubGroup#asList()::: sub group as list:::return->new->AsList
AbstractConstantGroup.SubGroup#asList(Object)::: sub group as list:::return->new->AsList
AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int)::: sub group copy constants:::rangeCheck2->return->self->copyConstants
AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int, Object)::: sub group copy constants:::rangeCheck2->return->self->copyConstants
AbstractConstantGroup.AsList#mapIndex(int)::: as list map index:::return->rangeCheck1
AbstractConstantGroup.AsList#size()::: as list size:::return
AbstractConstantGroup.AsList#get(int)::: as list get:::if->return->self->mapIndex->get->else->return->self->mapIndex->get
AbstractConstantGroup.AsList#iterator()::: as list iterator:::if->return->new->AsIterator->else->return->new->AsIterator
AbstractConstantGroup.AsList#subList(int, int)::: as list sub list:::rangeCheck2->return->new->AsList
AbstractConstantGroup.AsList#toArray()::: as list to array:::return->new->ObjectArr->toArray
AbstractConstantGroup.AsList#toArray(T[])::: as list to array:::pad->if->Arrays->copyOf->if->self->copyConstants->else->self->copyConstants->if->return
AbstractConstantGroup.WithCache#initializeCache(List, Object)::: with cache initialize cache:::for->i
AbstractConstantGroup.WithCache#get(int)::: with cache get:::x->if->fillCache->return->unwrapNull
AbstractConstantGroup.WithCache#get(int, Object)::: with cache get:::x->if->return->return->unwrapNull
AbstractConstantGroup.WithCache#isPresent(int)::: with cache is present:::return
AbstractConstantGroup.WithCache#fillCache(int):::hook for local subclasses:::throw->new->NoSuchElementException
AbstractConstantGroup.WithCache#wrapNull(Object)::: with cache wrap null:::return
AbstractConstantGroup.WithCache#unwrapNull(Object)::: with cache unwrap null:::return
AbstractConstantGroup.BSCIWithCache#toString()::: with cache to string:::return->super->toString
AbstractConstantGroup.BSCIWithCache#bootstrapMethod()::: with cache bootstrap method:::return
AbstractConstantGroup.BSCIWithCache#invocationName()::: with cache invocation name:::return
AbstractConstantGroup.BSCIWithCache#invocationType()::: with cache invocation type:::return
AbstractValidatingLambdaMetafactory#buildCallSite():::Build the CallSite.:::
AbstractValidatingLambdaMetafactory#validateMetafactoryArgs():::Check the meta-factory arguments for errors:::implArity->implMethodType->parameterCount->capturedArity->invokedType->parameterCount->samArity->samMethodType->parameterCount->instantiatedArity->instantiatedMethodType->parameterCount->if->throw->String->format->new->LambdaConversionException->if->throw->String->format->new->LambdaConversionException->foreach->if->bridgeMT->parameterCount->throw->String->format->new->LambdaConversionException->capturedStart->samStart->if->receiverClass->if->instantiatedMethodType->parameterType->else->invokedType->parameterType->if->implClass->isAssignableFrom->throw->String->format->new->LambdaConversionException->else->for->i->for->i->expectedType->instantiatedMethodType->returnType->actualReturnType->implMethodType->returnType->if->isAdaptableToAsReturn->throw->String->format->new->LambdaConversionException->checkDescriptor->foreach->checkDescriptor
AbstractValidatingLambdaMetafactory#checkDescriptor(MethodType):::Validate that the given descriptor's types are compatible with instantiatedMethodType *:::for->i->instantiatedMethodType->parameterCount->instantiatedReturnType->instantiatedMethodType->returnType->descriptorReturnType->descriptor->returnType->if->isAdaptableToAsReturnStrict->msg->String->format->throw->new->LambdaConversionException
AbstractValidatingLambdaMetafactory#isAdaptableTo(Class, Class, boolean):::Check type adaptability for parameter types.:::if->fromType->equals->return->if->fromType->isPrimitive->wfrom->forPrimitiveType->if->toType->isPrimitive->wto->forPrimitiveType->return->wto->isConvertibleFrom->else->return->toType->wfrom->wrapperType->isAssignableFrom->else->if->toType->isPrimitive->wfrom->if->isWrapperType->forWrapperType->primitiveType->isPrimitive->wto->forPrimitiveType->return->wto->isConvertibleFrom->else->return->else->return->toType->isAssignableFrom
AbstractValidatingLambdaMetafactory#isAdaptableToAsReturn(Class, Class):::Check type adaptability for return types -- special handling of void type) and parameterized fromType:::return->toType->equals->fromType->equals->isAdaptableTo
AbstractValidatingLambdaMetafactory#isAdaptableToAsReturnStrict(Class, Class)::: abstract validating lambda metafactory is adaptable to as return strict:::if->fromType->equals->toType->equals->return->fromType->equals->else->return->isAdaptableTo
BootstrapCallInfo#bootstrapMethod():::Returns the bootstrap method for this call.:::
BootstrapCallInfo#invocationName():::Returns the method name or constant name for this call.:::
BootstrapCallInfo#invocationType():::Returns the method type or constant type for this call.:::
BootstrapCallInfo#makeBootstrapCallInfo(MethodHandle, String, T, ConstantGroup):::Make a new bootstrap call descriptor with the given components.:::bsci->constants->size->new->AbstractConstantGroup.BSCIWithCache<>->NP->bsci->constants->asList->initializeCache->return
BootstrapMethodInvoker#invoke(Class, MethodHandle, String, Object, Object, Class):::Factored code for invoking a bootstrap method for invokedynamic or a dynamic constant.:::caller->IMPL_LOOKUP->in->result->pullMode->isPullModeBSM->vmIsPushing->staticArgumentsPulled->pullModeBSM->if->if->pushMePullYou->else->pushMePullYou->try->maybeReBox->if->invoke->else->if->info->getClass->isArray->if->bootstrapMethod->type->isStringConcatFactoryBSM->bootstrapMethod->new->ObjectArr->invokeExact->else->invoke->else->if->info->getClass->bsci->new->VM_BSCI<>->pullModeBSM->invoke->else->argv->maybeReBoxElements->bsmType->bootstrapMethod->type->if->isLambdaMetafactoryIndyBSM->bootstrapMethod->invokeExact->else->if->isLambdaMetafactoryCondyBSM->bootstrapMethod->invokeExact->else->if->isStringConcatFactoryBSM->recipe->shiftedArgs->Arrays->copyOfRange->bootstrapMethod->invokeExact->else->if->isLambdaMetafactoryAltMetafactoryBSM->bootstrapMethod->invokeExact->else->switch->invoke->break->invoke->break->invoke->break->invoke->break->invoke->break->invoke->break->invoke->break->invokeWithManyArguments->if->resultType->isPrimitive->funnel->MethodHandles->identity->funnel->invoke->Wrapper->asWrapperType->return->resultType->cast->catch->throw->throw->new->BootstrapMethodError->finally
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object, Object, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object, Object, Object, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invoke(MethodHandle, Lookup, String, Object, Object, Object, Object, Object, Object, Object)::: bootstrap method invoker invoke:::if->return->bootstrapMethod->invoke->else->return->bootstrapMethod->invoke
BootstrapMethodInvoker#invokeWithManyArguments(MethodHandle, Lookup, String, Object, Object[])::: bootstrap method invoker invoke with many arguments:::NON_SPREAD_ARG_COUNT->MAX_SAFE_SIZE->if->newargv->new->ObjectArr->System->arraycopy->return->bootstrapMethod->invokeWithArguments->else->invocationType->MethodType->genericMethodType->typedBSM->bootstrapMethod->asType->spreader->invocationType->invokers->spreadInvoker->return->spreader->invokeExact
BootstrapMethodInvoker#isStringConcatFactoryBSM(MethodType)::: bootstrap method invoker is string concat factory m:::return
BootstrapMethodInvoker#isLambdaMetafactoryCondyBSM(MethodType)::: bootstrap method invoker is lambda metafactory condy m:::return
BootstrapMethodInvoker#isLambdaMetafactoryIndyBSM(MethodType)::: bootstrap method invoker is lambda metafactory indy m:::return
BootstrapMethodInvoker#isLambdaMetafactoryAltMetafactoryBSM(MethodType)::: bootstrap method invoker is lambda metafactory alt metafactory m:::return
BootstrapMethodInvoker#maybeReBox(Object):::The JVM produces java.lang.Integer values to box  CONSTANT_Integer boxes but does not intern them:::if->xi->if->return
BootstrapMethodInvoker#maybeReBoxElements(Object[])::: bootstrap method invoker maybe re box elements:::for->i
BootstrapMethodInvoker.VM_BSCI#fillCache(int)::: m_ i fill cache:::buf->copyConstants->res->wrapNull->next->if->maybePrefetchIntoCache->return
BootstrapMethodInvoker.VM_BSCI#copyConstants(int, int, Object[], int)::: m_ i copy constants:::i->bufi->while->x->if->break->unwrapNull->if->return->temp->new->ObjectArr->if->Arrays->caller->getSimpleName->Arrays->toString->asList->println->copyOutBootstrapArguments->foreach->maybeReBox->wrapNull->if->maybePrefetchIntoCache->return
BootstrapMethodInvoker.VM_BSCI#maybePrefetchIntoCache(int, boolean)::: m_ i maybe prefetch into cache:::len->pfLimit->if->if->if->empty->nonEmpty->lastEmpty->for->j->if->return->prefetchIntoCache
BootstrapMethodInvoker.VM_BSCI#prefetchIntoCache(int, int)::: m_ i prefetch into cache:::if->return->temp->new->ObjectArr->if->Arrays->caller->getSimpleName->Arrays->toString->asList->println->copyOutBootstrapArguments->foreach->if->maybeReBox->wrapNull
BootstrapMethodInvoker.PushAdapter#pushToBootstrapMethod(MethodHandle, MethodHandles.Lookup, String, Object, Object...)::: push adapter push to bootstrap method:::cons->Arrays->asList->makeConstantGroup->bsci->makeBootstrapCallInfo->if->println->return->pullModeBSM->invoke
BootstrapMethodInvoker.PullAdapter#pullFromBootstrapMethod(MethodHandle, MethodHandles.Lookup, BootstrapCallInfo)::: pull adapter pull from bootstrap method:::argc->bsci->size->switch->return->pushModeBSM->bsci->invocationName->bsci->invocationType->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->bsci->get->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->bsci->get->bsci->get->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->bsci->get->bsci->get->bsci->get->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->bsci->get->bsci->get->bsci->get->bsci->get->invoke->return->pushModeBSM->bsci->invocationName->bsci->invocationType->bsci->get->bsci->get->bsci->get->bsci->get->bsci->get->bsci->get->invoke->NON_SPREAD_ARG_COUNT->MAX_SAFE_SIZE->if->newargv->new->ObjectArr->bsci->invocationName->bsci->invocationType->bsci->copyConstants->return->pushModeBSM->invokeWithArguments->invocationType->MethodType->genericMethodType->typedBSM->pushModeBSM->asType->spreader->invocationType->invokers->spreadInvoker->argv->new->ObjectArr->bsci->copyConstants->return->spreader->bsci->invocationName->bsci->invocationType->invokeExact
BootstrapMethodInvoker#pushMePullYou(MethodHandle, boolean):::Given a push-mode BSM (taking one argument) convert it to a  pull-mode BSM (taking N pre-resolved arguments):::if->bsm->type->println->if->return->bindTo->withVarargs->else->return->bindTo->withVarargs
BoundMethodHandle#bindSingle(MethodType, LambdaForm, BasicType, Object)::: bound method handle bind single:::try->switch->return->bindSingle->return->SPECIALIZER->topSpecies->extendWith->factory->ValueConversions->widenSubword->invokeBasic->return->SPECIALIZER->topSpecies->extendWith->factory->invokeBasic->return->SPECIALIZER->topSpecies->extendWith->factory->invokeBasic->return->SPECIALIZER->topSpecies->extendWith->factory->invokeBasic->throw->newInternalError->catch->throw->uncaughtException->finally
BoundMethodHandle#editor()::: bound method handle editor:::return->form->editor
BoundMethodHandle#bindSingle(MethodType, LambdaForm, Object)::: bound method handle bind single:::return->Species_L->make
BoundMethodHandle#bindArgumentL(int, Object)::: bound method handle bind argument l:::return->editor->bindArgumentL
BoundMethodHandle#bindArgumentI(int, int)::: bound method handle bind argument i:::return->editor->bindArgumentI
BoundMethodHandle#bindArgumentJ(int, long)::: bound method handle bind argument j:::return->editor->bindArgumentJ
BoundMethodHandle#bindArgumentF(int, float)::: bound method handle bind argument f:::return->editor->bindArgumentF
BoundMethodHandle#bindArgumentD(int, double)::: bound method handle bind argument d:::return->editor->bindArgumentD
BoundMethodHandle#rebind()::: bound method handle rebind:::if->tooComplex->return->return->makeReinvoker
BoundMethodHandle#tooComplex()::: bound method handle too complex:::return->fieldCount->form->expressionCount
BoundMethodHandle#makeReinvoker(MethodHandle):::A reinvoker MH has this form: lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }:::form->DelegatingMethodHandle->getterFunction->makeReinvokerForm->return->Species_L->target->type->make
BoundMethodHandle#speciesData()::: bound method handle species data:::
BoundMethodHandle#speciesDataFor(LambdaForm)::: bound method handle species data for:::c->if->return->return->SPECIALIZER->topSpecies
BoundMethodHandle#fieldCount()::: bound method handle field count:::return->speciesData->fieldCount
BoundMethodHandle#internalProperties()::: bound method handle internal properties:::return->internalValues
BoundMethodHandle#internalValues()::: bound method handle internal values:::count->fieldCount->if->return->arg->sb->new->StringBuilder->for->i->return->sb->append->toString
BoundMethodHandle#arg(int)::: bound method handle arg:::try->fieldType->speciesData->fieldTypes->get->switch->BasicType->basicType->return->speciesData->getter->invokeBasic->return->speciesData->getter->invokeBasic->return->speciesData->getter->invokeBasic->return->speciesData->getter->invokeBasic->return->speciesData->getter->invokeBasic->catch->throw->uncaughtException->finally->throw->speciesData->key->new->InternalError
BoundMethodHandle#copyWith(MethodType, LambdaForm)::: bound method handle copy with:::
BoundMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)::: bound method handle copy with extend l:::
BoundMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)::: bound method handle copy with extend i:::
BoundMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)::: bound method handle copy with extend j:::
BoundMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)::: bound method handle copy with extend f:::
BoundMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)::: bound method handle copy with extend d:::
BoundMethodHandle.Species_L#speciesData()::: species_ l species data:::return
BoundMethodHandle.Species_L#make(MethodType, LambdaForm, Object)::: species_ l make:::return->new->Species_L
BoundMethodHandle.Species_L#copyWith(MethodType, LambdaForm)::: species_ l copy with:::return->new->Species_L
BoundMethodHandle.Species_L#copyWithExtendL(MethodType, LambdaForm, Object)::: species_ l copy with extend l:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
BoundMethodHandle.Species_L#copyWithExtendI(MethodType, LambdaForm, int)::: species_ l copy with extend i:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
BoundMethodHandle.Species_L#copyWithExtendJ(MethodType, LambdaForm, long)::: species_ l copy with extend j:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
BoundMethodHandle.Species_L#copyWithExtendF(MethodType, LambdaForm, float)::: species_ l copy with extend f:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
BoundMethodHandle.Species_L#copyWithExtendD(MethodType, LambdaForm, double)::: species_ l copy with extend d:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
BoundMethodHandle.SpeciesData#deriveClassName()::: species data derive class name:::typeString->deriveTypeString->if->typeString->isEmpty->return->getName->return->getName
BoundMethodHandle.SpeciesData#deriveFieldTypes(String)::: species data derive field types:::types->key->length->new->ArrayList<>->for->i->key->length->return
BoundMethodHandle.SpeciesData#deriveTypeString()::: species data derive type string:::return->key
BoundMethodHandle.SpeciesData#deriveTransformHelper(MemberName, int)::: species data derive transform helper:::if->return->factory->else->if->return->extendWith->factory->else->throw->newInternalError
BoundMethodHandle.SpeciesData#deriveTransformHelperArguments(MemberName, int, List, List)::: species data derive transform helper arguments:::args->addAll->return
BoundMethodHandle.SpeciesData#verifyTHAargs(MemberName, int, List, List)::: species data verify aargs:::MH_AND_LF->if->else->if->type->basicType->else->return->return
BoundMethodHandle.SpeciesData#extendWith(byte)::: species data extend with:::sd->if->return->SPECIALIZER->key->BasicType->basicType->basicTypeChar->findSpecies->return
BoundMethodHandle.Specializer#topSpeciesKey()::: specializer top species key:::return
BoundMethodHandle.Specializer#newSpeciesData(String)::: specializer new species data:::return->new->BoundMethodHandle.SpeciesData
BoundMethodHandle.Specializer.Factory#chooseFieldName(Class, int)::: factory choose field name:::return->super->chooseFieldName
BoundMethodHandle.Specializer#makeFactory()::: specializer make factory:::return->new->Factory
BoundMethodHandle#speciesData_L()::: bound method handle species data_ l:::return
BoundMethodHandle#speciesData_LL()::: bound method handle species data_ l:::return->SPECIALIZER->findSpecies
BoundMethodHandle#speciesData_LLL()::: bound method handle species data_ l:::return->SPECIALIZER->findSpecies
BoundMethodHandle#speciesData_LLLL()::: bound method handle species data_ l:::return->SPECIALIZER->findSpecies
BoundMethodHandle#speciesData_LLLLL()::: bound method handle species data_ l:::return->SPECIALIZER->findSpecies
CallSite#type():::Returns the type of this call site's target:::return->target->type
CallSite#getTarget():::Returns the target method of the call site, according to the behavior defined by this call site's specific class:::
CallSite#setTarget(MethodHandle):::Updates the target method of this call site, according to the behavior defined by this call site's specific class:::
CallSite#checkTargetChange(MethodHandle, MethodHandle)::: call site check target change:::oldType->oldTarget->type->newType->newTarget->type->if->newType->equals->throw->wrongTargetType
CallSite#wrongTargetType(MethodHandle, MethodType)::: call site wrong target type:::return->String->valueOf->new->WrongMethodTypeException
CallSite#dynamicInvoker():::Produces a method handle equivalent to an invokedynamic instruction which has been linked to this call site:::
CallSite#makeDynamicInvoker()::: call site make dynamic invoker:::getTarget->getTargetHandle->bindArgumentL->invoker->MethodHandles->this->type->exactInvoker->return->MethodHandles->foldArguments
CallSite#getTargetHandle()::: call site get target handle:::handle->if->return->try->return->IMPL_LOOKUP->MethodType->methodType->findVirtual->catch->throw->newInternalError->finally
CallSite#uninitializedCallSiteHandle()::: call site uninitialized call site handle:::handle->if->return->try->return->IMPL_LOOKUP->MethodType->methodType->findStatic->catch->throw->newInternalError->finally
CallSite#uninitializedCallSite(Object...):::This guy is rolled into the default target if a MethodType is supplied to the constructor.:::throw->new->IllegalStateException
CallSite#makeUninitializedCallSite(MethodType)::: call site make uninitialized call site:::basicType->targetType->basicType->invoker->basicType->form->cachedMethodHandle->if->uninitializedCallSiteHandle->asType->basicType->form->setCachedMethodHandle->return->invoker->viewAsType
CallSite#getTargetOffset()::: call site get target offset:::offset->if->return->UNSAFE->objectFieldOffset->return
CallSite#setTargetNormal(MethodHandle)::: call site set target normal:::MethodHandleNatives->setCallSiteTargetNormal
CallSite#getTargetVolatile()::: call site get target volatile:::return->UNSAFE->getTargetOffset->getObjectVolatile
CallSite#setTargetVolatile(MethodHandle)::: call site set target volatile:::MethodHandleNatives->setCallSiteTargetVolatile
CallSite#makeSite(MethodHandle, String, MethodType, Object, Class)::: call site make site:::site->try->binding->BootstrapMethodInvoker->invoke->if->else->throw->new->ClassCastException->if->site->getTarget->type->equals->throw->site->getTarget->wrongTargetType->catch->throw->throw->new->BootstrapMethodError->finally->return
ClassSpecializer#topClass():::Return the top type mirror, for type T:::return
ClassSpecializer#keyType():::Return the key type mirror, for type K:::return
ClassSpecializer#metaType():::Return the species metadata type mirror, for type S:::return
ClassSpecializer#baseConstructorType():::Report the leading arguments (if any) required by every species factory:::return
ClassSpecializer#topSpecies():::Return the trivial species for the null sequence of arguments.:::return
ClassSpecializer#transformMethods():::Return the list of transform methods originally given at creation of this specializer.:::return
ClassSpecializer#factory():::Return the factory object used to build and load concrete species code.:::return
ClassSpecializer#reflectConstructor(Class, Class...)::: class specializer reflect constructor:::try->return->defc->getDeclaredConstructor->catch->throw->defc->getName->MethodType->methodType->newIAE->finally
ClassSpecializer#reflectField(Class, String)::: class specializer reflect field:::try->return->defc->getDeclaredField->catch->throw->defc->getName->newIAE->finally
ClassSpecializer#newIAE(String, Throwable)::: class specializer new e:::return->new->IllegalArgumentException
ClassSpecializer#findSpecies(K)::: class specializer find species:::speciesDataOrReservation->cache->computeIfAbsent->speciesData->if->speciesDataOrReservation->getClass->synchronized->existingSpeciesData->cache->get->if->newSpeciesData->factory->loadSpecies->if->cache->replace->throw->newInternalError->else->metaType->cast->else->metaType->cast->return
ClassSpecializer.SpeciesData#key()::: species data key:::return
ClassSpecializer.SpeciesData#fieldTypes()::: species data field types:::return
ClassSpecializer.SpeciesData#fieldCount()::: species data field count:::return->fieldTypes->size
ClassSpecializer.SpeciesData#outer()::: species data outer:::return
ClassSpecializer.SpeciesData#isResolved()::: species data is resolved:::return->factories->isEmpty
ClassSpecializer.SpeciesData#toString()::: species data to string:::return->metaType->getSimpleName->key->toString->isResolved->speciesCode->getSimpleName
ClassSpecializer.SpeciesData#hashCode()::: species data hash code:::return->key->hashCode
ClassSpecializer.SpeciesData#equals(Object)::: species data equals:::if->return->that->return->this->outer->that->outer->equals
ClassSpecializer.SpeciesData#speciesCode():::Throws NPE if this species is not yet resolved.:::return->Objects->requireNonNull
ClassSpecializer.SpeciesData#getter(int):::Return a MethodHandle which can get the indexed field of this species:::return->getters->get
ClassSpecializer.SpeciesData#getterFunction(int):::Return a LambdaForm.Name containing a LambdaForm.NamedFunction that represents a MH bound to a generic invoker, which in turn forwards to the corresponding getter.:::nf->nominalGetters->get->return
ClassSpecializer.SpeciesData#getterFunctions()::: species data getter functions:::return
ClassSpecializer.SpeciesData#getters()::: species data getters:::return
ClassSpecializer.SpeciesData#factory()::: species data factory:::return->factories->get
ClassSpecializer.SpeciesData#transformHelper(int)::: species data transform helper:::mh->if->return->transformMethods->get->deriveTransformHelper->mt->transformHelperType->mh->asType->return
ClassSpecializer.SpeciesData#transformHelperType(int)::: species data transform helper type:::tm->transformMethods->get->args->new->ArrayList<>->fields->new->ArrayList<>->Collections->tm->getParameterTypes->addAll->fields->fieldTypes->addAll->helperArgs->deriveTransformHelperArguments->return->MethodType->tm->getReturnType->methodType
ClassSpecializer.SpeciesData#deriveFieldTypes(K):::Given a key, derive the list of field types, which all instances of this species must store.:::
ClassSpecializer.SpeciesData#deriveTransformHelper(MemberName, int):::Given the index of a method in the transforms list, supply a factory method that takes the arguments of the transform, plus the local fields, and produce a value of the required type:::
ClassSpecializer.SpeciesData#deriveTransformHelperArguments(MemberName, int, List, List):::During code generation, this method is called once per transform to determine what is the mix of arguments to hand to the transform-helper:::
ClassSpecializer.SpeciesData#deriveClassName():::Given a key, generate the name of the class which implements the species for that key:::return->outer->topClass->getName->deriveTypeString
ClassSpecializer.SpeciesData#deriveTypeString():::Default implementation collects basic type characters, plus possibly type names, if some types don't correspond to basic types.:::types->fieldTypes->buf->new->StringBuilder->end->new->StringBuilder->foreach->basicType->BasicType->basicType->if->basicType->basicTypeClass->buf->basicType->basicTypeChar->append->else->buf->append->end->classSig->append->typeString->if->end->length->BytecodeName->buf->append->append->toString->toBytecodeName->else->buf->toString->return->LambdaForm->shortenSignature
ClassSpecializer.SpeciesData#deriveSuperClass():::Report what immediate super-class to use for the concrete class of this species:::topc->topClass->if->try->con->baseConstructorType->parameterArray->reflectConstructor->if->topc->isInterface->Modifier->con->getModifiers->isPrivate->catch->finally->if->throw->newInternalError->return
ClassSpecializer#newSpeciesData(K)::: class specializer new species data:::
ClassSpecializer#topSpeciesKey()::: class specializer top species key:::return
ClassSpecializer.Factory#loadSpecies(S):::Get a concrete subclass of the top class for a given combination of bound types.:::className->speciesData->deriveClassName->salvage->try->BootLoader->loadClassOrNull->if->println->catch->if->ex->getMessage->println->finally->speciesCode->if->salvage->topClass->asSubclass->linkSpeciesDataToCode->linkCodeToSpeciesData->else->try->generateConcreteSpeciesCode->if->println->linkSpeciesDataToCode->linkCodeToSpeciesData->catch->if->println->throw->finally->if->speciesData->isResolved->throw->newInternalError->return
ClassSpecializer.Factory#generateConcreteSpeciesCode(String, ClassSpecializer.SpeciesData):::Generate a concrete subclass of the top class for a given combination of bound types:::classFile->generateConcreteSpeciesCodeFile->InvokerBytecodeGenerator->classBCName->maybeDump->speciesCode->cl->topClass->getClassLoader->pd->if->AccessController->new->PrivilegedAction<>->doPrivileged->try->UNSAFE->defineClass->catch->throw->newInternalError->finally->return->speciesCode->topClass->asSubclass
ClassSpecializer.Factory#generateConcreteSpeciesCodeFile(String, ClassSpecializer.SpeciesData)::: factory generate concrete species code file:::className->classBCName->superClassName->speciesData->deriveSuperClass->classBCName->cw->new->ClassWriter->NOT_ACC_PUBLIC->cw->visit->sourceFile->className->className->lastIndexOf->substring->cw->visitSource->fw->cw->visitField->fw->visitAnnotation->fw->visitEnd->NO_THIS->new->Var->AFTER_THIS->new->Var->IN_HEAP->new->Var->fieldTypes->speciesData->fieldTypes->fields->fieldTypes->size->new->ArrayList<>->nextF->foreach->fn->nextF->nextIndex->chooseFieldName->new->Var->fields->add->foreach->cw->visitField->visitEnd->mv->cw->visitMethod->mv->visitCode->mv->visitFieldInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->superCtorType->ClassSpecializer.this->baseConstructorType->thisCtorType->superCtorType->appendParameterTypes->cw->methodSig->visitMethod->mv->visitCode->mv->visitVarInsn->ctorArgs->AFTER_THIS->superCtorType->parameterList->fromTypes->foreach->ca->emitVarInstruction->mv->methodSig->visitMethodInsn->lastFV->AFTER_THIS->lastOf->foreach->mv->visitVarInsn->new->Var->lastFV->emitVarInstruction->f->emitFieldInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->ftryType->thisCtorType->topClass->changeReturnType->cw->methodSig->visitMethod->mv->visitCode->mv->visitTypeInsn->mv->visitInsn->foreach->NO_THIS->ftryType->parameterList->fromTypes->v->emitVarInstruction->mv->methodSig->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->for->whichtm->TRANSFORM_NAMES->size->cw->visitEnd->return->cw->toByteArray
ClassSpecializer.Factory#typeLoadOp(char)::: factory type load op:::switch->return->return->return->return->return->throw->newInternalError
ClassSpecializer.Factory#emitIntConstant(int, MethodVisitor)::: factory emit int constant:::if->mv->visitInsn->else->if->mv->visitIntInsn->else->if->mv->visitIntInsn->else->mv->visitLdcInsn
ClassSpecializer.Factory#findGetter(Class, List>, int)::: factory find getter:::fieldType->types->get->fieldName->chooseFieldName->try->return->IMPL_LOOKUP->findGetter->catch->throw->newInternalError->finally
ClassSpecializer.Factory#findGetters(Class, List>)::: factory find getters:::mhs->types->size->new->MethodHandleArr->for->i->return->List->of
ClassSpecializer.Factory#findFactories(Class, List>)::: factory find factories:::mhs->new->MethodHandleArr->findFactory->return->List->of
ClassSpecializer.Factory#makeNominalGetters(List>, List)::: factory make nominal getters:::nfs->types->size->new->LambdaForm.NamedFunctionArr->for->i->return->List->of
ClassSpecializer.Factory#linkSpeciesDataToCode(ClassSpecializer.SpeciesData, Class)::: factory link species data to code:::speciesCode->asSubclass->types->this->findFactories->this->findGetters->this->makeNominalGetters
ClassSpecializer.Factory#reflectSDField(Class)::: factory reflect field:::field->reflectField->return
ClassSpecializer.Factory#readSpeciesDataFromCode(Class)::: factory read species data from code:::try->sdField->IMPL_LOOKUP->resolveOrFail->base->MethodHandleNatives->staticFieldBase->offset->MethodHandleNatives->staticFieldOffset->UNSAFE->loadFence->return->metaType->UNSAFE->getObject->cast->catch->throw->throw->speciesCode->getName->newInternalError->throw->uncaughtException->finally
ClassSpecializer.Factory#loadSpeciesDataFromCode(Class)::: factory load species data from code:::if->topClass->return->result->readSpeciesDataFromCode->if->result->outer->throw->newInternalError->return
ClassSpecializer.Factory#linkCodeToSpeciesData(Class, ClassSpecializer.SpeciesData, boolean)::: factory link code to species data:::try->sdField->IMPL_LOOKUP->resolveOrFail->base->MethodHandleNatives->staticFieldBase->offset->MethodHandleNatives->staticFieldOffset->UNSAFE->storeFence->UNSAFE->putObject->UNSAFE->storeFence->catch->throw->throw->speciesCode->getName->newInternalError->throw->uncaughtException->finally
ClassSpecializer.Factory#chooseFieldName(Class, int):::Field names in concrete species classes adhere to this pattern: type + index, where type is a single character (L, I, J, F, D):::bt->BasicType->basicType->return->bt->basicTypeChar
ClassSpecializer.Factory#findFactory(Class, List>)::: factory find factory:::type->baseConstructorType->topClass->changeReturnType->appendParameterTypes->try->return->IMPL_LOOKUP->findStatic->catch->throw->newInternalError->finally
ClassSpecializer#makeFactory():::Hook that virtualizes the Factory class, allowing subclasses to extend it.:::return->new->Factory
ClassSpecializer#methodSig(MethodType)::: class specializer method sig:::return->mt->toMethodDescriptorString
ClassSpecializer#classSig(Class)::: class specializer class sig:::if->cls->isPrimitive->cls->isArray->return->MethodType->methodType->toMethodDescriptorString->substring->return->classBCName->classSig
ClassSpecializer#classSig(String)::: class specializer class sig:::return
ClassSpecializer#classBCName(Class)::: class specializer class name:::return->className->classBCName
ClassSpecializer#classBCName(String)::: class specializer class name:::return->str->replace
ClassSpecializer#className(Class)::: class specializer class name:::return->cls->getName
ConstantBootstraps#makeConstant(MethodHandle, String, Class, Object, Class)::: constant bootstraps make constant:::mt->bootstrapMethod->type->if->mt->parameterCount->mt->parameterType->isAssignableFrom->throw->new->BootstrapMethodError->return->BootstrapMethodInvoker->invoke
ConstantBootstraps#nullConstant(MethodHandles.Lookup, String, Class):::Returns a null object reference for the reference type specified by type.:::if->requireNonNull->isPrimitive->throw->String->format->new->IllegalArgumentException->return
ConstantBootstraps#primitiveClass(MethodHandles.Lookup, String, Class):::Returns a Class mirror for the primitive type whose type descriptor is specified by name.:::requireNonNull->requireNonNull->if->throw->new->IllegalArgumentException->if->name->length->name->length->throw->String->format->new->IllegalArgumentException->return->Wrapper->name->charAt->forPrimitiveType->primitiveType
ConstantBootstraps#enumConstant(MethodHandles.Lookup, String, Class):::Returns an enum constant of the type specified by type with the name specified by name.:::requireNonNull->requireNonNull->requireNonNull->validateClassAccess->return->Enum->valueOf
ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class, Class):::Returns the value of a static final field.:::requireNonNull->requireNonNull->requireNonNull->requireNonNull->mh->try->lookup->findStaticGetter->member->mh->internalMemberName->if->member->isFinal->throw->new->IncompatibleClassChangeError->catch->throw->mapLookupExceptionToError->finally->try->return->mh->invoke->catch->throw->throw->new->LinkageError->finally
ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class):::Returns the value of a static final field declared in the class which is the same as the field's type (or, for primitive-valued fields, declared in the wrapper class.)  This is a simplified form of #getStaticFinal(MethodHandles.Lookup, String, Class, Class) for the case where a class declares distinguished constant instances of itself.:::requireNonNull->declaring->type->isPrimitive->Wrapper->forPrimitiveType->wrapperType->return->getStaticFinal
ConstantBootstraps#invoke(MethodHandles.Lookup, String, Class, MethodHandle, Object...):::Returns the result of invoking a method handle with the provided arguments:::requireNonNull->requireNonNull->requireNonNull->if->handle->type->returnType->handle->handle->type->changeReturnType->asType->handle->isVarargsCollector->withVarargs->return->handle->invokeWithArguments
ConstantBootstraps#fieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class):::Finds a VarHandle for an instance field.:::requireNonNull->requireNonNull->requireNonNull->requireNonNull->requireNonNull->if->throw->new->IllegalArgumentException->try->return->lookup->findVarHandle->catch->throw->mapLookupExceptionToError->finally
ConstantBootstraps#staticFieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class):::Finds a VarHandle for a static field.:::requireNonNull->requireNonNull->requireNonNull->requireNonNull->requireNonNull->if->throw->new->IllegalArgumentException->try->return->lookup->findStaticVarHandle->catch->throw->mapLookupExceptionToError->finally
ConstantBootstraps#arrayVarHandle(MethodHandles.Lookup, String, Class, Class):::Finds a VarHandle for an array type.:::requireNonNull->requireNonNull->requireNonNull->if->throw->new->IllegalArgumentException->return->MethodHandles->validateClassAccess->arrayElementVarHandle
ConstantBootstraps#validateClassAccess(MethodHandles.Lookup, Class)::: constant bootstraps validate class access:::try->lookup->accessClass->return->catch->throw->mapLookupExceptionToError->finally
ConstantCallSite#getTarget():::Returns the target method of the call site, which behaves like a final field of the ConstantCallSite:::if->throw->new->IllegalStateException->return
ConstantCallSite#setTarget(MethodHandle):::Always throws an UnsupportedOperationException:::throw->new->UnsupportedOperationException
ConstantCallSite#dynamicInvoker():::Returns this call site's permanent target:::return->getTarget
ConstantGroup#size():::Returns the number of constants in this group:::
ConstantGroup#get(int):::Returns the selected constant, resolving it if necessary:::
ConstantGroup#get(int, Object):::Returns the selected constant, or the given sentinel value if there is none available:::
ConstantGroup#isPresent(int):::Returns an indication of whether a constant may be available:::
ConstantGroup#asList():::Create a view on this group as a List view:::return->size->new->AbstractConstantGroup.AsList
ConstantGroup#asList(Object):::Create a view on this group as a List view:::return->size->new->AbstractConstantGroup.AsList
ConstantGroup#subGroup(int, int):::Create a view on a sub-sequence of this group.:::return->new->AbstractConstantGroup.SubGroup
ConstantGroup#copyConstants(int, int, Object[], int):::Copy a sequence of constant values into a given buffer:::bufBase->for->i->return
ConstantGroup#copyConstants(int, int, Object[], int, Object):::Copy a sequence of constant values into a given buffer:::bufBase->for->i->return
ConstantGroup#makeConstantGroup(List, Object, IntFunction):::Make a new constant group with the given constants:::return->new->Impl
ConstantGroup#makeConstantGroup(List):::Make a new constant group with the given constant values:::NP->return->makeConstantGroup
DelegatingMethodHandle#getTarget():::Define this to extract the delegated target which supplies the invocation behavior.:::
DelegatingMethodHandle#asTypeUncached(MethodType)::: delegating method handle as type uncached:::
DelegatingMethodHandle#internalMemberName()::: delegating method handle internal member name:::return->getTarget->internalMemberName
DelegatingMethodHandle#isInvokeSpecial()::: delegating method handle is invoke special:::return->getTarget->isInvokeSpecial
DelegatingMethodHandle#internalCallerClass()::: delegating method handle internal caller class:::return->getTarget->internalCallerClass
DelegatingMethodHandle#copyWith(MethodType, LambdaForm)::: delegating method handle copy with:::throw->newIllegalArgumentException
DelegatingMethodHandle#internalProperties()::: delegating method handle internal properties:::return->getClass->getSimpleName->getTarget->debugString
DelegatingMethodHandle#rebind()::: delegating method handle rebind:::return->getTarget->rebind
DelegatingMethodHandle#chooseDelegatingForm(MethodHandle)::: delegating method handle choose delegating form:::if->return->target->internalForm->return->makeReinvokerForm
DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, NamedFunction)::: delegating method handle make reinvoker form:::return->makeReinvokerForm
DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, boolean, NamedFunction, NamedFunction):::Create a LF which simply reinvokes a target of the given basic type.:::mtype->target->type->basicType->kind->whichKind->customized->mtype->parameterSlotCount->hasPreAction->form->if->mtype->form->cachedLambdaForm->if->return->THIS_DMH->ARG_BASE->ARG_LIMIT->mtype->parameterCount->nameCursor->PRE_ACTION->NEXT_MH->REINVOKE->names->LambdaForm->mtype->invokerType->arguments->withConstraint->targetArgs->if->new->LambdaForm.Name->if->Arrays->copyOfRange->new->LambdaForm.Name->else->new->LambdaForm.Name->Arrays->copyOfRange->new->LambdaForm.Name->new->LambdaForm->if->mtype->form->setCachedLambdaForm->return
DelegatingMethodHandle#whichKind(int)::: delegating method handle which kind:::switch->return->return->return
DirectMethodHandle#make(byte, Class, MemberName, Class)::: direct method handle make:::mtype->member->getMethodOrFieldType->if->member->isStatic->if->member->getDeclaringClass->isAssignableFrom->member->isConstructor->throw->member->toString->new->InternalError->mtype->insertParameterTypes->if->member->isField->switch->member->asSpecial->if->throw->new->InternalError->lform->callerClass->isInterface->preparedLambdaForm->return->new->Special->lform->preparedLambdaForm->return->new->Interface->lform->preparedLambdaForm->return->new->DirectMethodHandle->else->lform->preparedFieldLambdaForm->if->member->isStatic->offset->MethodHandleNatives->staticFieldOffset->base->MethodHandleNatives->staticFieldBase->return->new->StaticAccessor->else->offset->MethodHandleNatives->objectFieldOffset->return->new->Accessor
DirectMethodHandle#make(Class, MemberName)::: direct method handle make:::refKind->member->getReferenceKind->if->return->make
DirectMethodHandle#make(MemberName)::: direct method handle make:::if->member->isConstructor->return->makeAllocator->return->member->getDeclaringClass->make
DirectMethodHandle#makeAllocator(MemberName)::: direct method handle make allocator:::instanceClass->ctor->getDeclaringClass->ctor->asConstructor->mtype->ctor->getMethodType->changeReturnType->lform->preparedLambdaForm->init->ctor->asSpecial->return->new->Constructor
DirectMethodHandle#rebind()::: direct method handle rebind:::return->BoundMethodHandle->makeReinvoker
DirectMethodHandle#copyWith(MethodType, LambdaForm)::: direct method handle copy with:::return->new->DirectMethodHandle
DirectMethodHandle#internalProperties()::: direct method handle internal properties:::return->internalMemberName
DirectMethodHandle#internalMemberName()::: direct method handle internal member name:::return
DirectMethodHandle#preparedLambdaForm(MemberName, boolean):::Create a LF which can invoke the given method:::mtype->m->getInvocationType->basicType->which->switch->m->getReferenceKind->break->break->break->break->break->throw->m->toString->new->InternalError->if->shouldBeInitialized->preparedLambdaForm->if->lform->preparedLambdaForm->maybeCompile->return
DirectMethodHandle#preparedLambdaForm(MemberName)::: direct method handle prepared lambda form:::return->preparedLambdaForm
DirectMethodHandle#preparedLambdaForm(MethodType, int)::: direct method handle prepared lambda form:::lform->mtype->form->cachedLambdaForm->if->return->makePreparedLambdaForm->return->mtype->form->setCachedLambdaForm
DirectMethodHandle#makePreparedLambdaForm(MethodType, int)::: direct method handle make prepared lambda form:::needsInit->doesAlloc->needsReceiverCheck->linkerName->kind->switch->break->break->break->break->break->break->break->throw->new->InternalError->mtypeWithArg->mtype->appendParameterTypes->if->mtypeWithArg->insertParameterTypes->changeReturnType->linker->new->MemberName->try->IMPL_NAMES->resolveOrFail->catch->throw->newInternalError->finally->DMH_THIS->ARG_BASE->ARG_LIMIT->mtype->parameterCount->nameCursor->NEW_OBJ->GET_MEMBER->CHECK_RECEIVER->LINKER_CALL->names->mtype->invokerType->arguments->if->getFunction->new->Name->getFunction->new->Name->else->if->getFunction->new->Name->else->getFunction->new->Name->outArgs->Arrays->copyOfRange->if->getFunction->new->Name->result->if->System->arraycopy->new->Name->lform->new->LambdaForm->lform->compileToBytecode->return
DirectMethodHandle#findDirectMethodHandle(Name)::: direct method handle find direct method handle:::if->getFunction->equals->getFunction->equals->getFunction->equals->return->return
DirectMethodHandle#maybeCompile(LambdaForm, MemberName)::: direct method handle maybe compile:::if->VerifyAccess->m->getDeclaringClass->isSamePackage->lform->compileToBytecode
DirectMethodHandle#internalMemberName(Object):::Static wrapper for DirectMethodHandle.internalMemberName.:::return
DirectMethodHandle#internalMemberNameEnsureInit(Object)::: direct method handle internal member name ensure init:::dmh->dmh->ensureInitialized->return
DirectMethodHandle#shouldBeInitialized(MemberName)::: direct method handle should be initialized:::switch->member->getReferenceKind->break->return->cls->member->getDeclaringClass->if->return->if->VerifyAccess->isSamePackage->VerifyAccess->isSamePackage->if->UNSAFE->shouldBeInitialized->UNSAFE->ensureClassInitialized->return->return->UNSAFE->shouldBeInitialized
DirectMethodHandle.EnsureInitialized#computeValue(Class)::: ensure initialized compute value:::UNSAFE->ensureClassInitialized->if->UNSAFE->shouldBeInitialized->return->Thread->currentThread->new->WeakReference<>->return
DirectMethodHandle#ensureInitialized()::: direct method handle ensure initialized:::if->checkInitialized->if->member->isField->preparedFieldLambdaForm->updateForm->else->preparedLambdaForm->updateForm
DirectMethodHandle#checkInitialized(MemberName)::: direct method handle check initialized:::defc->member->getDeclaringClass->ref->get->if->return->clinitThread->ref->get->if->Thread->currentThread->if->UNSAFE->shouldBeInitialized->return->else->UNSAFE->ensureClassInitialized->remove->return
DirectMethodHandle#ensureInitialized(Object)::: direct method handle ensure initialized:::ensureInitialized
DirectMethodHandle.Special#isInvokeSpecial()::: special is invoke special:::return
DirectMethodHandle.Special#copyWith(MethodType, LambdaForm)::: special copy with:::return->new->Special
DirectMethodHandle.Special#checkReceiver(Object)::: special check receiver:::if->caller->isInstance->msg->String->recv->getClass->getName->caller->getName->format->throw->new->IncompatibleClassChangeError->return
DirectMethodHandle.Interface#copyWith(MethodType, LambdaForm)::: interface copy with:::return->new->Interface
DirectMethodHandle.Interface#checkReceiver(Object)::: interface check receiver:::if->refc->isInstance->msg->String->recv->getClass->getName->refc->getName->format->throw->new->IncompatibleClassChangeError->return
DirectMethodHandle#checkReceiver(Object):::Used for interface receiver type checks, by Interface and Special modes.:::throw->new->InternalError
DirectMethodHandle.Constructor#copyWith(MethodType, LambdaForm)::: constructor copy with:::return->new->Constructor
DirectMethodHandle#constructorMethod(Object)::: direct method handle constructor method:::dmh->return
DirectMethodHandle#allocateInstance(Object)::: direct method handle allocate instance:::dmh->return->UNSAFE->allocateInstance
DirectMethodHandle.Accessor#checkCast(Object)::: accessor check cast:::return->fieldType->cast
DirectMethodHandle.Accessor#copyWith(MethodType, LambdaForm)::: accessor copy with:::return->new->Accessor
DirectMethodHandle#fieldOffset(Object)::: direct method handle field offset:::return
DirectMethodHandle#checkBase(Object)::: direct method handle check base:::return->Objects->requireNonNull
DirectMethodHandle.StaticAccessor#checkCast(Object)::: static accessor check cast:::return->fieldType->cast
DirectMethodHandle.StaticAccessor#copyWith(MethodType, LambdaForm)::: static accessor copy with:::return->new->StaticAccessor
DirectMethodHandle#nullCheck(Object)::: direct method handle null check:::return->Objects->requireNonNull
DirectMethodHandle#staticBase(Object)::: direct method handle static base:::return
DirectMethodHandle#staticOffset(Object)::: direct method handle static offset:::return
DirectMethodHandle#checkCast(Object, Object)::: direct method handle check cast:::return->checkCast
DirectMethodHandle#checkCast(Object)::: direct method handle check cast:::return->member->getReturnType->cast
DirectMethodHandle#afIndex(byte, boolean, int)::: direct method handle af index:::return
DirectMethodHandle#ftypeKind(Class)::: direct method handle ftype kind:::if->ftype->isPrimitive->return->Wrapper->forPrimitiveType->ordinal->else->if->VerifyType->isNullReferenceConversion->return->else->return
DirectMethodHandle#preparedFieldLambdaForm(MemberName):::Create a LF which can access the given field:::ftype->m->getFieldType->isVolatile->m->isVolatile->formOp->switch->m->getReferenceKind->break->break->break->break->throw->m->toString->new->InternalError->if->shouldBeInitialized->preparedFieldLambdaForm->lform->preparedFieldLambdaForm->maybeCompile->return
DirectMethodHandle#preparedFieldLambdaForm(byte, boolean, Class)::: direct method handle prepared field lambda form:::ftypeKind->ftypeKind->afIndex->afIndex->lform->if->return->makePreparedFieldLambdaForm->return
DirectMethodHandle#getFieldKind(boolean, boolean, Wrapper)::: direct method handle get field kind:::if->if->switch->return->return->return->return->return->return->return->return->return->else->switch->return->return->return->return->return->return->return->return->return->else->if->switch->return->return->return->return->return->return->return->return->return->else->switch->return->return->return->return->return->return->return->return->return->throw->new->AssertionError
DirectMethodHandle#makePreparedFieldLambdaForm(byte, boolean, int)::: direct method handle make prepared field lambda form:::isGetter->isStatic->needsInit->needsCast->fw->ft->fw->primitiveType->kind->getFieldKind->linkerType->if->MethodType->methodType->else->MethodType->methodType->linker->new->MemberName->try->IMPL_NAMES->resolveOrFail->catch->throw->newInternalError->finally->mtype->if->MethodType->methodType->else->MethodType->methodType->mtype->basicType->if->mtype->insertParameterTypes->DMH_THIS->ARG_BASE->ARG_LIMIT->mtype->parameterCount->OBJ_BASE->SET_VALUE->nameCursor->F_HOLDER->F_OFFSET->OBJ_CHECK->U_HOLDER->INIT_BAR->PRE_CAST->LINKER_CALL->POST_CAST->RESULT->names->mtype->invokerType->arguments->if->getFunction->new->Name->if->getFunction->new->Name->outArgs->linkerType->parameterCount->new->ObjectArr->getFunction->new->Name->if->getFunction->new->Name->getFunction->new->Name->else->getFunction->new->Name->getFunction->new->Name->if->foreach->new->Name->if->getFunction->new->Name->foreach->form->if->new->LambdaForm->else->new->LambdaForm->if->LambdaForm->debugNames->nameBuilder->new->StringBuilder->if->nameBuilder->append->else->nameBuilder->append->if->nameBuilder->append->if->nameBuilder->append->LambdaForm->nameBuilder->toString->associateWithDebugName->return
DirectMethodHandle#getFunction(byte)::: direct method handle get function:::nf->if->return->createFunction->return
DirectMethodHandle#createFunction(byte)::: direct method handle create function:::try->switch->return->getNamedFunction->return->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->getNamedFunction->return->getNamedFunction->return->getNamedFunction->return->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->getNamedFunction->return->getNamedFunction->member->new->MemberName->return->MemberName->getFactory->resolveOrFail->new->NamedFunction->new->MemberName->return->MemberName->getFactory->resolveOrFail->new->NamedFunction->throw->newInternalError->catch->throw->newInternalError->finally
DirectMethodHandle#getNamedFunction(String, MethodType)::: direct method handle get named function:::member->new->MemberName->return->MemberName->getFactory->resolveOrFail->new->NamedFunction
GenerateJLIClassesHelper#generateBasicFormsClassBytes(String)::: generate classes helper generate basic forms class bytes:::forms->new->ArrayList<>->names->new->ArrayList<>->dedupSet->new->HashSet<>->foreach->values->zero->LambdaForm->zeroForm->name->zero->returnType->basicTypeChar->if->dedupSet->add->names->add->forms->add->identity->LambdaForm->identityForm->identity->returnType->basicTypeChar->if->dedupSet->add->names->add->forms->add->return->names->new->StringArr->toArray->forms->new->LambdaFormArr->toArray->generateCodeBytesForLFs
GenerateJLIClassesHelper#generateDirectMethodHandleHolderClassBytes(String, MethodType[], int[])::: generate classes helper generate direct method handle holder class bytes:::forms->new->ArrayList<>->names->new->ArrayList<>->for->i->foreach->Wrapper->values->if->continue->for->b->return->names->new->StringArr->toArray->forms->new->LambdaFormArr->toArray->generateCodeBytesForLFs
GenerateJLIClassesHelper#generateDelegatingMethodHandleHolderClassBytes(String, MethodType[])::: generate classes helper generate delegating method handle holder class bytes:::dedupSet->new->HashSet<>->forms->new->ArrayList<>->names->new->ArrayList<>->for->i->return->names->new->StringArr->toArray->forms->new->LambdaFormArr->toArray->generateCodeBytesForLFs
GenerateJLIClassesHelper#generateInvokersHolderClassBytes(String, MethodType[], MethodType[])::: generate classes helper generate invokers holder class bytes:::dedupSet->new->HashSet<>->forms->new->ArrayList<>->names->new->ArrayList<>->types->for->i->new->HashSet<>->for->i->return->names->new->StringArr->toArray->forms->new->LambdaFormArr->toArray->generateCodeBytesForLFs
GenerateJLIClassesHelper#generateCodeBytesForLFs(String, String[], LambdaForm[])::: generate classes helper generate code bytes for fs:::cw->new->ClassWriter->cw->visit->cw->className->className->lastIndexOf->substring->visitSource->for->i->return->cw->toByteArray
GenerateJLIClassesHelper#addMethod(String, String, LambdaForm, MethodType, ClassWriter)::: generate classes helper add method:::g->new->InvokerBytecodeGenerator->g->setClassWriter->g->addMethod
GenerateJLIClassesHelper#makeReinvokerFor(MethodType)::: generate classes helper make reinvoker for:::emptyHandle->MethodHandles->empty->return->DelegatingMethodHandle->BoundMethodHandle->speciesData_L->BoundMethodHandle->speciesData_L->getterFunction->makeReinvokerForm
GenerateJLIClassesHelper#makeDelegateFor(MethodType)::: generate classes helper make delegate for:::handle->MethodHandles->empty->return->DelegatingMethodHandle->makeReinvokerForm
GenerateJLIClassesHelper#generateConcreteBMHClassBytes(String)::: generate classes helper generate concrete class bytes:::foreach->types->toCharArray->if->indexOf->throw->new->IllegalArgumentException->species->findSpecies->className->species->speciesCode->getName->factory->factory->code->factory->generateConcreteSpeciesCodeFile->return->Map->className->replace->entry
InfoFromMemberName#getDeclaringClass()::: info from member name get declaring class:::return->member->getDeclaringClass
InfoFromMemberName#getName()::: info from member name get name:::return->member->getName
InfoFromMemberName#getMethodType()::: info from member name get method type:::return->member->getMethodOrFieldType
InfoFromMemberName#getModifiers()::: info from member name get modifiers:::return->member->getModifiers
InfoFromMemberName#getReferenceKind()::: info from member name get reference kind:::return
InfoFromMemberName#toString()::: info from member name to string:::return->MethodHandleInfo->getReferenceKind->getDeclaringClass->getName->getMethodType->toString
InfoFromMemberName#reflectAs(Class, Lookup)::: info from member name reflect as:::if->member->isMethodHandleInvoke->member->isVarHandleMethodInvoke->member->isVarargs->throw->new->IllegalArgumentException->mem->AccessController->new->PrivilegedAction<>->doPrivileged->try->defc->getDeclaringClass->refKind->getReferenceKind->lookup->convertToMemberName->checkAccess->catch->throw->new->IllegalArgumentException->finally->return->expected->cast
InfoFromMemberName#reflectUnchecked()::: info from member name reflect unchecked:::refKind->getReferenceKind->defc->getDeclaringClass->isPublic->Modifier->getModifiers->isPublic->if->MethodHandleNatives->refKindIsMethod->if->return->defc->getName->getMethodType->parameterArray->getMethod->else->return->defc->getName->getMethodType->parameterArray->getDeclaredMethod->else->if->MethodHandleNatives->refKindIsConstructor->if->return->defc->getMethodType->parameterArray->getConstructor->else->return->defc->getMethodType->parameterArray->getDeclaredConstructor->else->if->MethodHandleNatives->refKindIsField->if->return->defc->getName->getField->else->return->defc->getName->getDeclaredField->else->throw->new->IllegalArgumentException
InfoFromMemberName#convertToMemberName(byte, Member)::: info from member name convert to member name:::if->wantSpecial->return->new->MemberName->else->if->return->new->MemberName->else->if->isSetter->return->new->MemberName->throw->mem->getClass->getName->new->InternalError
InnerClassLambdaMetafactory#buildCallSite():::Build the CallSite:::innerClass->spinInnerClass->if->invokedType->parameterCount->ctrs->AccessController->new->PrivilegedAction<>->doPrivileged->if->throw->innerClass->getCanonicalName->new->LambdaConversionException->try->inst->newInstance->return->MethodHandles->constant->new->ConstantCallSite->catch->throw->new->LambdaConversionException->finally->else->try->if->UNSAFE->ensureClassInitialized->return->findStatic->new->ConstantCallSite->catch->throw->new->LambdaConversionException->finally
InnerClassLambdaMetafactory#spinInnerClass():::Generate a class file which implements the functional interface, define and return the class.:::interfaces->samIntf->samBase->getName->replace->accidentallySerializable->isAssignableFrom->if->new->StringArr->else->itfs->new->LinkedHashSet<>->itfs->add->foreach->itfs->markerInterface->getName->replace->add->isAssignableFrom->itfs->itfs->size->new->StringArr->toArray->cw->visit->for->i->generateConstructor->if->invokedType->parameterCount->generateFactory->mv->cw->samMethodType->toMethodDescriptorString->visitMethod->mv->visitAnnotation->new->ForwardingMethodGenerator->generate->if->foreach->cw->mt->toMethodDescriptorString->visitMethod->mv->visitAnnotation->new->ForwardingMethodGenerator->generate->if->generateSerializationFriendlyMethods->else->if->generateSerializationHostileMethods->cw->visitEnd->classBytes->cw->toByteArray->if->AccessController->new->PrivilegedAction<>->new->FilePermission->new->PropertyPermission->doPrivileged->return->UNSAFE->defineAnonymousClass
InnerClassLambdaMetafactory#generateFactory():::Generate the factory method for the class:::m->cw->invokedType->toMethodDescriptorString->visitMethod->m->visitCode->m->visitTypeInsn->m->visitInsn->parameterCount->invokedType->parameterCount->for->typeIndex->varIndex->m->constructorType->toMethodDescriptorString->visitMethodInsn->m->visitInsn->m->visitMaxs->m->visitEnd
InnerClassLambdaMetafactory#generateConstructor():::Generate the constructor for the class:::ctor->cw->constructorType->toMethodDescriptorString->visitMethod->ctor->visitCode->ctor->visitVarInsn->ctor->visitMethodInsn->parameterCount->invokedType->parameterCount->for->i->lvIndex->ctor->visitInsn->ctor->visitMaxs->ctor->visitEnd
InnerClassLambdaMetafactory#generateSerializationFriendlyMethods():::Generate a writeReplace method that supports serialization:::mv->cw->visitMethod->new->TypeConvertingMethodAdapter->mv->visitCode->mv->visitTypeInsn->mv->visitInsn->mv->Type->getType->visitLdcInsn->mv->invokedType->returnType->getName->replace->visitLdcInsn->mv->visitLdcInsn->mv->samMethodType->toMethodDescriptorString->visitLdcInsn->mv->implInfo->getReferenceKind->visitLdcInsn->mv->implInfo->getDeclaringClass->getName->replace->visitLdcInsn->mv->implInfo->getName->visitLdcInsn->mv->implInfo->getMethodType->toMethodDescriptorString->visitLdcInsn->mv->instantiatedMethodType->toMethodDescriptorString->visitLdcInsn->mv->iconst->mv->visitTypeInsn->for->i->mv->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd
InnerClassLambdaMetafactory#generateSerializationHostileMethods():::Generate a readObject/writeObject method that is hostile to serialization:::mv->cw->visitMethod->mv->visitCode->mv->visitTypeInsn->mv->visitInsn->mv->visitLdcInsn->mv->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->cw->visitMethod->mv->visitCode->mv->visitTypeInsn->mv->visitInsn->mv->visitLdcInsn->mv->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd
InnerClassLambdaMetafactory.ForwardingMethodGenerator#generate(MethodType)::: forwarding method generator generate:::visitCode->if->visitTypeInsn->visitInsn->for->i->convertArgumentTypes->invocationOpcode->implClass->isInterface->visitMethodInsn->implReturnClass->implMethodType->returnType->samReturnClass->methodType->returnType->convertType->getReturnOpcode->visitInsn->visitMaxs->visitEnd
InnerClassLambdaMetafactory.ForwardingMethodGenerator#convertArgumentTypes(MethodType)::: forwarding method generator convert argument types:::lvIndex->samParametersLength->samType->parameterCount->captureArity->invokedType->parameterCount->for->i
InnerClassLambdaMetafactory.ForwardingMethodGenerator#invocationOpcode()::: forwarding method generator invocation opcode:::switch->return->return->return->return->return->throw->new->InternalError
InnerClassLambdaMetafactory#getParameterSize(Class)::: inner class lambda metafactory get parameter size:::if->return->else->if->return->return
InnerClassLambdaMetafactory#getLoadOpcode(Class)::: inner class lambda metafactory get load opcode:::if->throw->new->InternalError->return->getOpcodeOffset
InnerClassLambdaMetafactory#getReturnOpcode(Class)::: inner class lambda metafactory get return opcode:::if->return->return->getOpcodeOffset
InnerClassLambdaMetafactory#getOpcodeOffset(Class)::: inner class lambda metafactory get opcode offset:::if->c->isPrimitive->if->return->else->if->return->else->if->return->return->else->return
InvokerBytecodeGenerator#maybeDump(byte[])::: invoker bytecode generator maybe dump:::if->maybeDump
InvokerBytecodeGenerator#maybeDump(String, byte[])::: invoker bytecode generator maybe dump:::if->new->java.security.PrivilegedAction<>->doPrivileged
InvokerBytecodeGenerator#makeDumpableClassName(String)::: invoker bytecode generator make dumpable class name:::ctr->synchronized->DUMP_CLASS_FILES_COUNTERS->get->if->DUMP_CLASS_FILES_COUNTERS->put->sfx->ctr->toString->while->sfx->length->return
InvokerBytecodeGenerator.CpPatch#toString()::: cp patch to string:::return
InvokerBytecodeGenerator#constantPlaceholder(Object)::: invoker bytecode generator constant placeholder:::cpPlaceholder->if->debugString->index->cw->newConst->cpPatches->new->CpPatch->add->return
InvokerBytecodeGenerator#cpPatches(byte[])::: invoker bytecode generator cp patches:::size->getConstantPoolSize->res->new->ObjectArr->foreach->if->throw->Arrays->Arrays->copyOf->toString->new->InternalError->return
InvokerBytecodeGenerator#debugString(Object)::: invoker bytecode generator debug string:::if->mh->member->mh->internalMemberName->if->return->member->toString->return->mh->debugString->return->arg->toString
InvokerBytecodeGenerator#getConstantPoolSize(byte[]):::Extract the number of constant pool entries from a given class file.:::return
InvokerBytecodeGenerator#loadMethod(byte[]):::Extract the MemberName of a newly-defined method.:::invokerClass->cpPatches->loadAndInitializeInvokerClass->return->resolveInvokerMember
InvokerBytecodeGenerator#loadAndInitializeInvokerClass(byte[], Object[]):::Define a given class as anonymous class in the runtime system.:::invokerClass->UNSAFE->defineAnonymousClass->UNSAFE->ensureClassInitialized->return
InvokerBytecodeGenerator#resolveInvokerMember(Class, String, MethodType)::: invoker bytecode generator resolve invoker member:::member->new->MemberName->try->MEMBERNAME_FACTORY->resolveOrFail->catch->throw->newInternalError->finally->return
InvokerBytecodeGenerator#classFilePrologue():::Set up class file generation.:::NOT_ACC_PUBLIC->new->ClassWriter->cw->visit->cw->visitSource->return
InvokerBytecodeGenerator#methodPrologue()::: invoker bytecode generator method prologue:::invokerDesc->invokerType->toMethodDescriptorString->cw->visitMethod
InvokerBytecodeGenerator#methodEpilogue():::Tear down class file generation.:::mv->visitMaxs->mv->visitEnd
InvokerBytecodeGenerator#emitConst(Object)::: invoker bytecode generator emit const:::if->mv->visitInsn->return->if->emitIconstInsn->return->if->emitIconstInsn->return->if->emitIconstInsn->return->if->emitIconstInsn->return->if->x->sx->if->if->mv->visitInsn->else->emitIconstInsn->mv->visitInsn->return->if->x->sx->if->if->mv->visitInsn->else->emitIconstInsn->mv->visitInsn->return->if->x->sx->if->if->mv->visitInsn->else->emitIconstInsn->mv->visitInsn->return->if->emitIconstInsn->return->mv->visitLdcInsn
InvokerBytecodeGenerator#emitIconstInsn(int)::: invoker bytecode generator emit iconst insn:::if->mv->visitInsn->else->if->mv->visitIntInsn->else->if->mv->visitIntInsn->else->mv->visitLdcInsn
InvokerBytecodeGenerator#emitLoadInsn(BasicType, int)::: invoker bytecode generator emit load insn:::opcode->loadInsnOpcode->mv->visitVarInsn
InvokerBytecodeGenerator#loadInsnOpcode(BasicType)::: invoker bytecode generator load insn opcode:::switch->return->return->return->return->return->throw->new->InternalError
InvokerBytecodeGenerator#emitAloadInsn(int)::: invoker bytecode generator emit aload insn:::emitLoadInsn
InvokerBytecodeGenerator#emitStoreInsn(BasicType, int)::: invoker bytecode generator emit store insn:::opcode->storeInsnOpcode->mv->visitVarInsn
InvokerBytecodeGenerator#storeInsnOpcode(BasicType)::: invoker bytecode generator store insn opcode:::switch->return->return->return->return->return->throw->new->InternalError
InvokerBytecodeGenerator#emitAstoreInsn(int)::: invoker bytecode generator emit astore insn:::emitStoreInsn
InvokerBytecodeGenerator#arrayTypeCode(Wrapper)::: invoker bytecode generator array type code:::switch->return->return->return->return->return->return->return->return->return->throw->new->InternalError
InvokerBytecodeGenerator#arrayInsnOpcode(byte, int)::: invoker bytecode generator array insn opcode:::xas->switch->break->break->break->break->break->break->break->break->break->throw->new->InternalError->return
InvokerBytecodeGenerator#emitBoxing(Wrapper):::Emit a boxing call.:::owner->wrapper->wrapperType->getSimpleName->name->desc->wrapper->basicTypeChar->mv->visitMethodInsn
InvokerBytecodeGenerator#emitUnboxing(Wrapper):::Emit an unboxing call (plus preceding checkcast).:::owner->wrapper->wrapperType->getSimpleName->name->wrapper->primitiveSimpleName->desc->wrapper->basicTypeChar->wrapper->wrapperType->emitReferenceCast->mv->visitMethodInsn
InvokerBytecodeGenerator#emitImplicitConversion(BasicType, Class, Object):::Emit an implicit conversion for an argument which must be of the given pclass:::if->ptype->basicTypeClass->return->switch->if->VerifyType->isNullConversion->if->emitReferenceCast->return->emitReferenceCast->return->if->VerifyType->isNullConversion->ptype->basicTypeWrapper->Wrapper->forPrimitiveType->emitPrimCast->return->throw->newInternalError
InvokerBytecodeGenerator#assertStaticType(Class, Name):::Update localClasses type map:::local->n->index->aclass->if->cls->isAssignableFrom->return->else->if->aclass->isAssignableFrom->return
InvokerBytecodeGenerator#emitReferenceCast(Class, Object)::: invoker bytecode generator emit reference cast:::writeBack->if->n->if->lambdaForm->useCount->if->assertStaticType->return->if->isStaticallyNameable->sig->getInternalName->mv->visitTypeInsn->else->mv->constantPlaceholder->visitLdcInsn->mv->visitTypeInsn->mv->visitInsn->mv->visitMethodInsn->if->isAssignableFrom->mv->visitTypeInsn->else->if->mv->visitTypeInsn->if->mv->visitInsn->writeBack->index->emitAstoreInsn
InvokerBytecodeGenerator#emitReturnInsn(BasicType):::Emits an actual return instruction conforming to the given return type.:::opcode->switch->break->break->break->break->break->break->throw->new->InternalError->mv->visitInsn
InvokerBytecodeGenerator#getInternalName(Class)::: invoker bytecode generator get internal name:::if->return->else->if->return->else->if->return->else->if->return->if->return->return->c->getName->replace
InvokerBytecodeGenerator#resolveFrom(String, MethodType, Class)::: invoker bytecode generator resolve from:::member->new->MemberName->resolvedMember->MemberName->getFactory->resolveOrNull->if->holder->getName->basicTypeSignature->shortenSignature->println->return
InvokerBytecodeGenerator#lookupPregenerated(LambdaForm, MethodType)::: invoker bytecode generator lookup pregenerated:::if->return->name->switch->BoundMethodHandle->speciesDataFor->key->return->resolveFrom->return->resolveFrom->form->returnType->basicTypeChar->return->resolveFrom->return->invokerType->basicType->resolveFrom->return->resolveFrom->return
InvokerBytecodeGenerator#generateCustomizedCode(LambdaForm, MethodType):::Generate customized bytecode for a given LambdaForm.:::pregenerated->lookupPregenerated->if->return->g->new->InvokerBytecodeGenerator->return->g->g->generateCustomizedCodeBytes->loadMethod
InvokerBytecodeGenerator#checkActualReceiver():::Generates code to check that actual receiver and LambdaForm matches:::mv->visitInsn->mv->visitVarInsn->mv->visitMethodInsn->return
InvokerBytecodeGenerator#className(String)::: invoker bytecode generator class name:::return
InvokerBytecodeGenerator#checkClassName(String)::: invoker bytecode generator check class name:::tp->Type->getType->if->tp->getSort->return->try->c->Class->tp->getClassName->forName->return->catch->return->finally
InvokerBytecodeGenerator#generateCustomizedCodeBytes():::Generate an invoker method for the passed LambdaForm.:::classFilePrologue->addMethod->bogusMethod->classFile->toByteArray->maybeDump->return
InvokerBytecodeGenerator#setClassWriter(ClassWriter)::: invoker bytecode generator set class writer:::
InvokerBytecodeGenerator#addMethod()::: invoker bytecode generator add method:::methodPrologue->mv->visitAnnotation->mv->visitAnnotation->if->mv->visitAnnotation->else->mv->visitAnnotation->constantPlaceholder->if->mv->constantPlaceholder->visitLdcInsn->mv->visitTypeInsn->mv->visitVarInsn->onStack->for->i->emitReturn->methodEpilogue
InvokerBytecodeGenerator#toByteArray()::: invoker bytecode generator to byte array:::try->return->cw->toByteArray->catch->throw->new->BytecodeGenerationException->finally
InvokerBytecodeGenerator#emitArrayLoad(Name)::: invoker bytecode generator emit array load:::emitArrayOp
InvokerBytecodeGenerator#emitArrayStore(Name)::: invoker bytecode generator emit array store:::emitArrayOp
InvokerBytecodeGenerator#emitArrayLength(Name)::: invoker bytecode generator emit array length:::emitArrayOp
InvokerBytecodeGenerator#emitArrayOp(Name, int)::: invoker bytecode generator emit array op:::elementType->methodType->parameterType->getComponentType->emitPushArguments->if->elementType->isPrimitive->w->Wrapper->forPrimitiveType->arrayTypeCode->arrayInsnOpcode->mv->visitInsn
InvokerBytecodeGenerator#emitInvoke(Name):::Emit an invoke for the given name.:::if->target->resolvedHandle->mv->constantPlaceholder->visitLdcInsn->emitReferenceCast->else->emitAloadInsn->emitReferenceCast->mv->visitFieldInsn->mv->visitFieldInsn->emitPushArguments->type->methodType->mv->type->basicType->toMethodDescriptorString->visitMethodInsn
InvokerBytecodeGenerator#isStaticallyInvocable(NamedFunction...)::: invoker bytecode generator is statically invocable:::foreach->if->nf->member->isStaticallyInvocable->return->return
InvokerBytecodeGenerator#isStaticallyInvocable(Name)::: invoker bytecode generator is statically invocable:::return->member->isStaticallyInvocable
InvokerBytecodeGenerator#isStaticallyInvocable(MemberName)::: invoker bytecode generator is statically invocable:::if->return->if->member->isConstructor->return->cls->member->getDeclaringClass->if->isAssignableFrom->member->isPrivate->return->if->cls->isArray->cls->isPrimitive->return->if->cls->isAnonymousClass->cls->isLocalClass->return->if->cls->getClassLoader->getClassLoader->return->if->ReflectUtil->isVMAnonymousClass->return->if->member->getMethodOrFieldType->isStaticallyInvocableType->return->if->member->isPrivate->VerifyAccess->isSamePackage->return->if->member->isPublic->isStaticallyNameable->return->return
InvokerBytecodeGenerator#isStaticallyInvocableType(MethodType)::: invoker bytecode generator is statically invocable type:::if->mtype->returnType->isStaticallyNameable->return->foreach->mtype->parameterArray->if->isStaticallyNameable->return->return
InvokerBytecodeGenerator#isStaticallyNameable(Class)::: invoker bytecode generator is statically nameable:::if->return->if->isAssignableFrom->return->while->cls->isArray->cls->getComponentType->if->cls->isPrimitive->return->if->ReflectUtil->isVMAnonymousClass->return->if->cls->getClassLoader->getClassLoader->return->if->VerifyAccess->isSamePackage->return->if->Modifier->cls->getModifiers->isPublic->return->foreach->if->VerifyAccess->isSamePackage->return->return
InvokerBytecodeGenerator#emitStaticInvoke(Name)::: invoker bytecode generator emit static invoke:::member->emitStaticInvoke
InvokerBytecodeGenerator#emitStaticInvoke(MemberName, Name):::Emit an invoke for the given name, using the MemberName directly.:::defc->member->getDeclaringClass->cname->getInternalName->mname->member->getName->mtype->refKind->member->getReferenceKind->if->emitPushArguments->if->member->isMethod->member->getMethodType->toMethodDescriptorString->mv->refKindOpcode->member->getDeclaringClass->isInterface->visitMethodInsn->else->MethodType->member->getFieldType->toFieldDescriptorString->mv->refKindOpcode->visitFieldInsn->if->rtype->member->getInvocationType->returnType->if->rtype->isInterface->assertStaticType
InvokerBytecodeGenerator#emitNewArray(Name)::: invoker bytecode generator emit new array:::rtype->methodType->returnType->if->emptyArray->try->resolvedHandle->invoke->catch->throw->uncaughtException->finally->mv->constantPlaceholder->visitLdcInsn->emitReferenceCast->return->arrayElementType->rtype->getComponentType->emitIconstInsn->xas->if->arrayElementType->isPrimitive->mv->getInternalName->visitTypeInsn->else->tc->Wrapper->forPrimitiveType->arrayTypeCode->arrayInsnOpcode->mv->visitIntInsn->for->i->assertStaticType
InvokerBytecodeGenerator#refKindOpcode(byte)::: invoker bytecode generator ref kind opcode:::switch->return->return->return->return->return->return->return->return->throw->new->InternalError
InvokerBytecodeGenerator#emitSelectAlternative(Name, Name):::Emit bytecode for the selectAlternative idiom:::receiver->L_fallback->new->Label->L_done->new->Label->emitPushArgument->mv->visitJumpInsn->preForkClasses->localClasses->clone->emitPushArgument->receiver->index->emitAstoreInsn->emitStaticInvoke->mv->visitJumpInsn->mv->visitLabel->System->arraycopy->emitPushArgument->receiver->index->emitAstoreInsn->emitStaticInvoke->mv->visitLabel->System->arraycopy->return
InvokerBytecodeGenerator#emitGuardWithCatch(int):::Emit bytecode for the guardWithCatch idiom:::args->invoker->result->L_startBlock->new->Label->L_endBlock->new->Label->L_handler->new->Label->L_done->new->Label->returnType->resolvedHandle->type->returnType->type->resolvedHandle->type->dropParameterTypes->changeReturnType->mv->visitTryCatchBlock->mv->visitLabel->emitPushArgument->emitPushArguments->mv->type->basicType->toMethodDescriptorString->visitMethodInsn->mv->visitLabel->mv->visitJumpInsn->mv->visitLabel->mv->visitInsn->emitPushArgument->mv->visitInsn->mv->visitMethodInsn->L_rethrow->new->Label->mv->visitJumpInsn->emitPushArgument->mv->visitInsn->emitPushArguments->catcherType->type->insertParameterTypes->mv->catcherType->basicType->toMethodDescriptorString->visitMethodInsn->mv->visitJumpInsn->mv->visitLabel->mv->visitInsn->mv->visitLabel->return
InvokerBytecodeGenerator#emitTryFinally(int):::Emit bytecode for the tryFinally idiom:::args->invoker->result->lFrom->new->Label->lTo->new->Label->lCatch->new->Label->lDone->new->Label->returnType->resolvedHandle->type->returnType->isNonVoid->type->resolvedHandle->type->dropParameterTypes->changeReturnType->cleanupType->type->insertParameterTypes->if->cleanupType->insertParameterTypes->cleanupDesc->cleanupType->basicType->toMethodDescriptorString->mv->visitTryCatchBlock->mv->visitLabel->emitPushArgument->emitPushArguments->mv->type->basicType->toMethodDescriptorString->visitMethodInsn->mv->visitLabel->emitPushArgument->if->mv->visitInsn->mv->visitInsn->if->mv->visitInsn->emitPushArguments->mv->visitMethodInsn->mv->visitJumpInsn->mv->visitLabel->mv->visitInsn->emitPushArgument->mv->visitInsn->if->BasicType->basicType->emitZero->emitPushArguments->mv->visitMethodInsn->if->mv->visitInsn->mv->visitInsn->mv->visitLabel->return
InvokerBytecodeGenerator#emitLoop(int):::Emit bytecode for the loop idiom:::args->invoker->result->loopClauseTypes->loopLocalStateTypes->Stream->of->filter->BasicType->basicTypeClass->map->Class<?>[]->new->toArray->localTypes->new->Class<?>Arr->System->arraycopy->clauseDataIndex->extendLocalsMap->firstLoopStateIndex->returnType->resolvedHandle->type->returnType->loopType->resolvedHandle->type->dropParameterTypes->changeReturnType->loopHandleType->loopType->insertParameterTypes->predType->loopHandleType->changeReturnType->finiType->nClauses->inits->steps->preds->finis->lLoop->new->Label->lDone->new->Label->lNext->emitPushArgument->mv->visitFieldInsn->emitAstoreInsn->for->c->state->mv->visitLabel->for->c->state->mv->visitJumpInsn->mv->visitLabel->return
InvokerBytecodeGenerator#extendLocalsMap(Class[])::: invoker bytecode generator extend locals map:::firstSlot->Arrays->copyOf->Arrays->copyOf->System->arraycopy->index->lastSlots->for->i->return
InvokerBytecodeGenerator#emitLoopHandleInvoke(Name, int, int, Name, boolean, MethodType, Class[], int, int)::: invoker bytecode generator emit loop handle invoke:::emitPushClauseArray->emitIconstInsn->mv->visitInsn->if->for->s->emitPushArguments->mv->type->toMethodDescriptorString->visitMethodInsn
InvokerBytecodeGenerator#emitPushClauseArray(int, int)::: invoker bytecode generator emit push clause array:::emitAloadInsn->emitIconstInsn->mv->visitInsn
InvokerBytecodeGenerator#emitZero(BasicType)::: invoker bytecode generator emit zero:::switch->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->throw->new->InternalError
InvokerBytecodeGenerator#emitPushArguments(Name, int)::: invoker bytecode generator emit push arguments:::type->methodType->for->i
InvokerBytecodeGenerator#emitPushArgument(Name, int)::: invoker bytecode generator emit push argument:::arg->ptype->methodType->parameterType->emitPushArgument
InvokerBytecodeGenerator#emitPushArgument(Class, Object)::: invoker bytecode generator emit push argument:::bptype->basicType->if->n->n->index->emitLoadInsn->emitImplicitConversion->else->if->emitConst->else->if->Wrapper->arg->getClass->isWrapperType->emitConst->else->mv->constantPlaceholder->visitLdcInsn->emitImplicitConversion
InvokerBytecodeGenerator#emitStoreResult(Name):::Store the name to its local, if necessary.:::if->name->index->emitStoreInsn
InvokerBytecodeGenerator#emitReturn(Name):::Emits a return statement from a LF invoker:::rclass->invokerType->returnType->rtype->lambdaForm->returnType->if->mv->visitInsn->else->rn->if->emitLoadInsn->emitImplicitConversion->emitReturnInsn
InvokerBytecodeGenerator#emitPrimCast(Wrapper, Wrapper):::Emit a type conversion bytecode casting from "from" to "to".:::if->return->if->from->isSubwordOrInt->emitI2X->else->if->to->isSubwordOrInt->emitX2I->if->to->bitWidth->emitI2X->else->error->switch->switch->mv->visitInsn->break->mv->visitInsn->break->break->break->switch->mv->visitInsn->break->mv->visitInsn->break->break->break->switch->mv->visitInsn->break->mv->visitInsn->break->break->break->break->if->throw->new->IllegalStateException
InvokerBytecodeGenerator#emitI2X(Wrapper)::: invoker bytecode generator emit i2 x:::switch->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->break->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->mv->visitInsn->break->throw->new->InternalError
InvokerBytecodeGenerator#emitX2I(Wrapper)::: invoker bytecode generator emit x2 i:::switch->mv->visitInsn->break->mv->visitInsn->break->mv->visitInsn->break->throw->new->InternalError
InvokerBytecodeGenerator#generateLambdaFormInterpreterEntryPoint(MethodType):::Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.:::name->mt->returnType->basicTypeChar->type->type->changeParameterType->g->new->InvokerBytecodeGenerator->return->g->g->generateLambdaFormInterpreterEntryPointBytes->loadMethod
InvokerBytecodeGenerator#generateLambdaFormInterpreterEntryPointBytes()::: invoker bytecode generator generate lambda form interpreter entry point bytes:::classFilePrologue->methodPrologue->mv->visitAnnotation->mv->visitAnnotation->invokerType->parameterCount->emitIconstInsn->mv->visitTypeInsn->for->i->invokerType->parameterCount->emitAloadInsn->mv->visitFieldInsn->mv->visitInsn->mv->visitMethodInsn->rtype->invokerType->returnType->if->rtype->isPrimitive->Wrapper->forPrimitiveType->emitUnboxing->basicType->emitReturnInsn->methodEpilogue->bogusMethod->classFile->cw->toByteArray->maybeDump->return
InvokerBytecodeGenerator#generateNamedFunctionInvoker(MethodTypeForm):::Generate bytecode for a NamedFunction invoker.:::invokerType->invokerName->typeForm->erasedType->basicTypeSignature->shortenSignature->g->new->InvokerBytecodeGenerator->return->g->g->generateNamedFunctionInvokerImpl->loadMethod
InvokerBytecodeGenerator#generateNamedFunctionInvokerImpl(MethodTypeForm)::: invoker bytecode generator generate named function invoker impl:::dstType->typeForm->erasedType->classFilePrologue->methodPrologue->mv->visitAnnotation->mv->visitAnnotation->emitAloadInsn->for->i->dstType->parameterCount->targetDesc->dstType->basicType->toMethodDescriptorString->mv->visitMethodInsn->rtype->dstType->returnType->if->rtype->isPrimitive->srcWrapper->Wrapper->forBasicType->dstWrapper->srcWrapper->isSubwordOrInt->emitPrimCast->emitBoxing->if->mv->visitInsn->emitReturnInsn->methodEpilogue->bogusMethod->classFile->cw->toByteArray->maybeDump->return
InvokerBytecodeGenerator#bogusMethod(Object):::Emit a bogus method that just loads some string constants:::if->cw->visitMethod->mv->os->toString->visitLdcInsn->mv->visitInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd
Invokers#exactInvoker()::: invokers exact invoker:::invoker->cachedInvoker->if->return->makeExactOrGeneralInvoker->return->setCachedInvoker
Invokers#genericInvoker()::: invokers generic invoker:::invoker->cachedInvoker->if->return->makeExactOrGeneralInvoker->return->setCachedInvoker
Invokers#basicInvoker()::: invokers basic invoker:::invoker->cachedInvoker->if->return->basicType->targetType->basicType->if->return->basicType->invokers->basicInvoker->setCachedInvoker->basicType->form->cachedMethodHandle->if->method->invokeBasicMethod->DirectMethodHandle->make->basicType->form->setCachedMethodHandle->return->setCachedInvoker
Invokers#varHandleMethodInvoker(VarHandle.AccessMode)::: invokers var handle method invoker:::return->makeVarHandleMethodInvoker
Invokers#varHandleMethodExactInvoker(VarHandle.AccessMode)::: invokers var handle method exact invoker:::return->makeVarHandleMethodInvoker
Invokers#cachedInvoker(int)::: invokers cached invoker:::return
Invokers#setCachedInvoker(int, MethodHandle)::: invokers set cached invoker:::prev->if->return->return
Invokers#makeExactOrGeneralInvoker(boolean)::: invokers make exact or general invoker:::mtype->invokerType->mtype->invokerType->which->lform->invokeHandleForm->invoker->BoundMethodHandle->bindSingle->whichName->invoker->MemberName->makeMethodHandleInvoke->withInternalMemberName->maybeCompileToBytecode->return
Invokers#makeVarHandleMethodInvoker(VarHandle.AccessMode, boolean)::: invokers make var handle method invoker:::mtype->invokerType->mtype->insertParameterTypes->lform->varHandleMethodInvokerHandleForm->ad->ordinal->ak->ordinal->new->VarHandle.AccessDescriptor->invoker->BoundMethodHandle->bindSingle->invoker->MemberName->ak->methodName->makeVarHandleMethodInvoke->withInternalMemberName->maybeCompileToBytecode->return
Invokers#maybeCompileToBytecode(MethodHandle):::If the target type seems to be common enough, eagerly compile the invoker to bytecodes.:::EAGER_COMPILE_ARITY_LIMIT->if->targetType->erase->targetType->parameterCount->compileToBytecode
Invokers#invokeBasicMethod(MethodType)::: invokers invoke basic method:::try->return->IMPL_LOOKUP->resolveOrFail->catch->throw->newInternalError->finally
Invokers#checkInvoker(MethodHandle)::: invokers check invoker:::return
Invokers#checkVarHandleInvoker(MethodHandle)::: invokers check var handle invoker:::invokerType->targetType->insertParameterTypes->return
Invokers#spreadInvoker(int)::: invokers spread invoker:::spreadArgCount->targetType->parameterCount->postSpreadType->argArrayType->impliedRestargType->if->postSpreadType->parameterSlotCount->return->genericInvoker->asSpreader->preSpreadType->postSpreadType->postSpreadType->parameterCount->replaceParameterTypes->arrayInvoker->MethodHandles->invoker->makeSpreader->MethodHandles->insertArguments->return->MethodHandles->filterArgument
Invokers#impliedRestargType(MethodType, int)::: invokers implied restarg type:::if->restargType->isGeneric->return->maxPos->restargType->parameterCount->if->return->argType->restargType->parameterType->for->i->if->return->return->Array->newInstance->getClass
Invokers#toString()::: invokers to string:::return
Invokers#methodHandleInvokeLinkerMethod(String, MethodType, Object[])::: invokers method handle invoke linker method:::which->switch->break->break->throw->new->InternalError->lform->if->mtype->parameterSlotCount->invokeHandleForm->else->invokeHandleForm->return
Invokers#invokeHandleForm(MethodType, boolean, int):::Returns an adapter for invokeExact or generic invoke, as a MH or constant pool linker:::isCached->if->mtype->basicType->else->isLinker->isGeneric->kind->switch->break->break->break->break->throw->new->InternalError->lform->if->mtype->form->cachedLambdaForm->if->return->THIS_MH->CALL_MH->ARG_BASE->OUTARG_LIMIT->mtype->parameterCount->INARG_LIMIT->nameCursor->MTYPE_ARG->CHECK_TYPE->CHECK_CUSTOM->LINKER_CALL->invokerFormType->mtype->invokerType->if->if->invokerFormType->appendParameterTypes->else->invokerFormType->invokerType->names->arguments->if->speciesData->BoundMethodHandle->speciesData_L->withConstraint->getter->speciesData->getterFunction->new->Name->outCallType->mtype->basicType->outArgs->Arrays->copyOfRange->mtypeArg->if->getFunction->new->Name->else->getFunction->new->Name->if->getFunction->new->Name->new->Name->if->new->LambdaForm->else->new->LambdaForm->if->lform->compileToBytecode->if->mtype->form->setCachedLambdaForm->return
Invokers#varHandleInvokeLinkerMethod(VarHandle.AccessMode, MethodType)::: invokers var handle invoke linker method:::lform->if->mtype->parameterSlotCount->varHandleMethodGenericLinkerHandleForm->else->throw->mtype->parameterSlotCount->newInternalError->return
Invokers#varHandleMethodGenericLinkerHandleForm(VarHandle.AccessMode, MethodType)::: invokers var handle method generic linker handle form:::THIS_VH->ARG_BASE->ARG_LIMIT->mtype->parameterCount->nameCursor->VAD_ARG->CHECK_TYPE->CHECK_CUSTOM->LINKER_CALL->names->new->NameArr->BasicType->basicType->argument->for->i->mtype->parameterCount->BasicType->basicType->new->Name->getFunction->new->Name->outArgs->new->ObjectArr->for->i->if->getFunction->new->Name->outCallType->mtype->insertParameterTypes->basicType->new->Name->lform->new->LambdaForm->if->LambdaForm->debugNames->name->ak->methodName->basicTypeSignature->shortenSignature->LambdaForm->associateWithDebugName->lform->compileToBytecode->return
Invokers#varHandleMethodInvokerHandleForm(VarHandle.AccessMode, MethodType, boolean)::: invokers var handle method invoker handle form:::THIS_MH->CALL_VH->ARG_BASE->ARG_LIMIT->mtype->parameterCount->nameCursor->VAD_ARG->CHECK_TYPE->LINKER_CALL->names->new->NameArr->BasicType->basicType->argument->BasicType->basicType->argument->for->i->mtype->parameterCount->speciesData->BoundMethodHandle->speciesData_L->withConstraint->getter->speciesData->getterFunction->new->Name->if->getFunction->new->Name->else->getFunction->new->Name->outArgs->new->ObjectArr->for->i->outCallType->mtype->insertParameterTypes->basicType->new->Name->kind->lform->new->LambdaForm->if->LambdaForm->debugNames->name->ak->methodName->basicTypeSignature->shortenSignature->LambdaForm->associateWithDebugName->lform->prepare->return
Invokers#checkVarHandleGenericType(VarHandle, VarHandle.AccessDescriptor)::: invokers check var handle generic type:::mh->handle->getMethodHandle->if->mh->type->return->else->return->mh->asType
Invokers#checkVarHandleExactType(VarHandle, VarHandle.AccessDescriptor)::: invokers check var handle exact type:::mh->handle->getMethodHandle->mt->mh->type->if->throw->newWrongMethodTypeException->return
Invokers#newWrongMethodTypeException(MethodType, MethodType)::: invokers new wrong method type exception:::return->new->WrongMethodTypeException
Invokers#checkExactType(MethodHandle, MethodType)::: invokers check exact type:::actual->mh->type->if->throw->newWrongMethodTypeException
Invokers#checkGenericType(MethodHandle, MethodType)::: invokers check generic type:::return->mh->asType
Invokers#linkToCallSiteMethod(MethodType)::: invokers link to call site method:::lform->callSiteForm->return
Invokers#linkToTargetMethod(MethodType)::: invokers link to target method:::lform->callSiteForm->return
Invokers#callSiteForm(MethodType, boolean)::: invokers call site form:::mtype->basicType->which->lform->mtype->form->cachedLambdaForm->if->return->ARG_BASE->OUTARG_LIMIT->mtype->parameterCount->INARG_LIMIT->nameCursor->APPENDIX_ARG->CSITE_ARG->CALL_MH->LINKER_CALL->invokerFormType->mtype->appendParameterTypes->names->arguments->if->getFunction->new->Name->PREPEND_MH->PREPEND_COUNT->outArgs->Arrays->copyOfRange->System->arraycopy->new->Name->new->LambdaForm->lform->compileToBytecode->mtype->form->setCachedLambdaForm->return
Invokers#getCallSiteTarget(CallSite)::: invokers get call site target:::return->site->getTarget
Invokers#checkCustomized(MethodHandle)::: invokers check customized:::if->MethodHandleImpl->isCompileConstant->return->if->maybeCustomize
Invokers#maybeCustomize(MethodHandle)::: invokers maybe customize:::count->if->mh->customize->else
Invokers#getFunction(byte)::: invokers get function:::nf->if->return->createFunction->return
Invokers#createFunction(byte)::: invokers create function:::try->switch->return->MethodType->methodType->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->MethodType->methodType->getNamedFunction->return->MethodType->methodType->getNamedFunction->throw->newInternalError->catch->throw->newInternalError->finally
Invokers#getNamedFunction(String, MethodType)::: invokers get named function:::member->new->MemberName->return->MemberName->getFactory->resolveOrFail->new->NamedFunction
LambdaForm#buildNames(Name[], Name[], Name)::: lambda form build names:::arity->length->names->Arrays->copyOf->System->arraycopy->if->return
LambdaForm#buildEmptyNames(int, MethodType, boolean)::: lambda form build empty names:::names->arguments->if->zero->mt->returnType->basicType->constantZero->new->Name->zero->newIndex->return
LambdaForm#fixResult(int, Name[])::: lambda form fix result:::if->if->return
LambdaForm#debugNames()::: lambda form debug names:::return
LambdaForm#associateWithDebugName(LambdaForm, String)::: lambda form associate with debug name:::synchronized->DEBUG_NAMES->put
LambdaForm#lambdaName()::: lambda form lambda name:::if->synchronized->name->DEBUG_NAMES->get->if->generateDebugName->return->return
LambdaForm#generateDebugName()::: lambda form generate debug name:::debugNameStem->ctr->DEBUG_NAME_COUNTERS->getOrDefault->DEBUG_NAME_COUNTERS->put->buf->new->StringBuilder->leadingZero->buf->length->buf->append->for->i->buf->length->buf->append->buf->basicTypeSignature->append->name->buf->toString->associateWithDebugName->return
LambdaForm#namesOK(int, Name[])::: lambda form names k:::for->i->return
LambdaForm#customize(MethodHandle):::Customize LambdaForm for a particular MethodHandle:::customForm->new->LambdaForm->if->customForm->compileToBytecode->return
LambdaForm#uncustomize():::Get uncustomized flavor of the LambdaForm:::if->return->uncustomizedForm->if->uncustomizedForm->compileToBytecode->return
LambdaForm#normalize():::Renumber and/or replace params so that they are interned and canonically numbered.:::oldNames->maxOutArity->changesStart->for->i->if->startFixing->if->for->i->maxInterned->Math->min->needIntern->for->i->if->for->i->return
LambdaForm#nameRefsAreLegal():::Check that all embedded Name references are localizable to this lambda, and are properly ordered after their corresponding definitions:::for->i->for->i->return
LambdaForm#returnType():::Report the return type.:::if->return->n->return
LambdaForm#parameterType(int):::Report the N-th argument type.:::return->parameter
LambdaForm#parameter(int):::Report the N-th argument name.:::param->return
LambdaForm#parameterConstraint(int):::Report the N-th argument type constraint.:::return->parameter
LambdaForm#arity():::Report the arity.:::return
LambdaForm#expressionCount():::Report the number of expressions (non-parameter names).:::return
LambdaForm#methodType():::Return the method type corresponding to my basic type signature.:::ptypes->new->Class<?>Arr->for->i->return->MethodType->returnType->makeImpl
LambdaForm#basicTypeSignature():::Return ABC_Z, where the ABC are parameter type characters, and Z is the return type character.:::buf->arity->new->StringBuilder->for->i->a->arity->return->buf->append->returnType->basicTypeChar->append->toString
LambdaForm#signatureArity(String)::: lambda form signature arity:::return->sig->indexOf
LambdaForm#signatureReturn(String)::: lambda form signature return:::return->sig->signatureArity->charAt->basicType
LambdaForm#isValidSignature(String)::: lambda form is valid signature:::arity->sig->indexOf->if->return->siglen->sig->length->if->return->for->i->return
LambdaForm#signatureType(String)::: lambda form signature type:::ptypes->signatureArity->new->Class<?>Arr->for->i->rtype->signatureReturn->return->MethodType->makeImpl
LambdaForm#basicMethodType(MethodType)::: lambda form basic method type:::return->basicTypeSignature->signatureType
LambdaForm#isSelectAlternative(int):::Check if i-th name is a call to MethodHandleImpl.selectAlternative.:::if->return->name0->name1->return->name0->refersTo->name1->isInvokeBasic->name1->lastUseIndex->lastUseIndex
LambdaForm#isMatchingIdiom(int, String, int)::: lambda form is matching idiom:::if->return->name0->name1->name2->return->name1->refersTo->name0->isInvokeBasic->name2->isInvokeBasic->name1->lastUseIndex->lastUseIndex->name2->lastUseIndex->lastUseIndex
LambdaForm#isGuardWithCatch(int):::Check if i-th name is a start of GuardWithCatch idiom.:::return->isMatchingIdiom
LambdaForm#isTryFinally(int):::Check if i-th name is a start of the tryFinally idiom.:::return->isMatchingIdiom
LambdaForm#isLoop(int):::Check if i-th name is a start of the loop idiom.:::return->isMatchingIdiom
LambdaForm#prepare():::Make this LF directly executable, as part of a MethodHandle:::if->forceInterpretation->compileToBytecode->if->return->mtype->methodType->prep->mtype->form->cachedLambdaForm->if->new->LambdaForm->InvokerBytecodeGenerator->generateLambdaFormInterpreterEntryPoint->mtype->form->setCachedLambdaForm
LambdaForm#failedCompilationCounter()::: lambda form failed compilation counter:::if->PerfCounter->newPerfCounter->return
LambdaForm#compileToBytecode():::Generate optimizable bytecode for this form.:::if->forceInterpretation->return->if->return->invokerType->methodType->try->InvokerBytecodeGenerator->generateCustomizedCode->if->traceInterpreter->catch->failedCompilationCounter->increment->if->println->bge->printStackTrace->throw->throw->this->toString->newInternalError->finally
LambdaForm#argumentTypesMatch(String, Object[])::: lambda form argument types match:::arity->signatureArity->mh->mt->mh->type->for->i->return
LambdaForm#valueMatches(BasicType, Class, Object)::: lambda form value matches:::if->switch->break->break->break->break->break->break->return
LambdaForm#checkInt(Class, Object)::: lambda form check int:::if->return->w->Wrapper->forBasicType->x1->w->wrap->wrap->return->x->equals
LambdaForm#checkRef(Class, Object)::: lambda form check ref:::if->return->if->type->isInterface->return->return->type->isInstance
LambdaForm#forceInterpretation()::: lambda form force interpretation:::return
LambdaForm#interpretWithArguments(Object...)::: lambda form interpret with arguments:::if->return->interpretWithArgumentsTracing->checkInvocationCounter->values->Arrays->copyOf->for->i->rv->return
LambdaForm#interpretName(Name, Object[])::: lambda form interpret name:::if->name->debugString->traceInterpreter->arguments->Arrays->copyOf->for->i->return->invokeWithArguments
LambdaForm#checkInvocationCounter()::: lambda form check invocation counter:::if->forceInterpretation->if->compileToBytecode
LambdaForm#interpretWithArgumentsTracing(Object...)::: lambda form interpret with arguments tracing:::traceInterpreter->if->forceInterpretation->ctr->traceInterpreter->if->compileToBytecode->rval->try->values->Arrays->copyOf->for->i->catch->traceInterpreter->throw->finally->traceInterpreter->return
LambdaForm#traceInterpreter(String, Object, Object...)::: lambda form trace interpreter:::if->Arrays->asList->println
LambdaForm#traceInterpreter(String, Object)::: lambda form trace interpreter:::traceInterpreter
LambdaForm#arityCheck(Object[])::: lambda form arity check:::mh->basicTypeSignature->argumentTypesMatch->return
LambdaForm#resultCheck(Object[], Object)::: lambda form result check:::mh->mt->mh->type->return
LambdaForm#isEmpty()::: lambda form is empty:::if->return->else->if->return->isConstantZero->else->return
LambdaForm#toString()::: lambda form to string:::lambdaName->lambdaName->buf->new->StringBuilder->for->i->if->buf->append->buf->append->append->if->buf->append->basicTypeSignature->append->buf->append->append->return->buf->toString
LambdaForm#equals(Object)::: lambda form equals:::return->equals
LambdaForm#equals(LambdaForm)::: lambda form equals:::if->return->return->Arrays->equals
LambdaForm#hashCode()::: lambda form hash code:::return->Arrays->hashCode
LambdaForm#editor()::: lambda form editor:::return->LambdaFormEditor->lambdaFormEditor
LambdaForm#contains(Name)::: lambda form contains:::pos->name->index->if->return->name->equals->for->i->return
LambdaForm.NamedFunction#isInvokeBasic(MemberName)::: named function is invoke basic:::return->member->getDeclaringClass->member->getName->equals
LambdaForm.NamedFunction#resolvedHandle()::: named function resolved handle:::if->resolve->return
LambdaForm.NamedFunction#resolve()::: named function resolve:::if->DirectMethodHandle->make
LambdaForm.NamedFunction#equals(Object)::: named function equals:::if->return->if->return->if->return->that->return->equals
LambdaForm.NamedFunction#hashCode()::: named function hash code:::if->return->member->hashCode->return->super->hashCode
LambdaForm.NamedFunction#computeInvoker(MethodTypeForm)::: named function compute invoker:::typeForm->basicType->form->mh->typeForm->cachedMethodHandle->if->return->invoker->InvokerBytecodeGenerator->generateNamedFunctionInvoker->DirectMethodHandle->make->mh2->typeForm->cachedMethodHandle->if->return->if->mh->type->equals->throw->mh->debugString->newInternalError->return->typeForm->setCachedMethodHandle
LambdaForm.NamedFunction#invokeWithArguments(Object...)::: named function invoke with arguments:::if->return->invokeWithArgumentsTracing->return->invoker->resolvedHandle->invokeBasic
LambdaForm.NamedFunction#invokeWithArgumentsTracing(Object[])::: named function invoke with arguments tracing:::rval->try->traceInterpreter->if->traceInterpreter->invoker->if->traceInterpreter->resolvedHandle->invoker->resolvedHandle->invokeBasic->catch->traceInterpreter->throw->finally->traceInterpreter->return
LambdaForm.NamedFunction#invoker()::: named function invoker:::if->return->return->methodType->form->computeInvoker
LambdaForm.NamedFunction#methodType()::: named function method type:::if->return->resolvedHandle->type->else->return->member->getInvocationType
LambdaForm.NamedFunction#member()::: named function member:::return
LambdaForm.NamedFunction#assertMemberIsConsistent()::: named function assert member is consistent:::if->m->resolvedHandle->internalMemberName->return
LambdaForm.NamedFunction#memberDeclaringClassOrNull()::: named function member declaring class or null:::return->member->getDeclaringClass
LambdaForm.NamedFunction#returnType()::: named function return type:::return->methodType->returnType->basicType
LambdaForm.NamedFunction#parameterType(int)::: named function parameter type:::return->methodType->parameterType->basicType
LambdaForm.NamedFunction#arity()::: named function arity:::return->methodType->parameterCount
LambdaForm.NamedFunction#toString()::: named function to string:::if->return->String->valueOf->return->member->getDeclaringClass->getSimpleName->member->getName
LambdaForm.NamedFunction#isIdentity()::: named function is identity:::return->this->returnType->identity->equals
LambdaForm.NamedFunction#isConstantZero()::: named function is constant zero:::return->this->returnType->constantZero->equals
LambdaForm.NamedFunction#intrinsicName()::: named function intrinsic name:::return
LambdaForm#basicTypeSignature(MethodType)::: lambda form basic type signature:::params->type->parameterCount->sig->new->charArr->sigp->while->type->parameterType->basicTypeChar->type->returnType->basicTypeChar->return->String->valueOf
LambdaForm#shortenSignature(String):::Hack to make signatures more readable when they show up in method names:::NO_CHAR->MIN_RUN->c0->c1->c1reps->buf->len->signature->length->if->return->for->i->return->buf->toString
LambdaForm.Name#type()::: name type:::return
LambdaForm.Name#index()::: name index:::return
LambdaForm.Name#initIndex(int)::: name init index:::if->if->return->return
LambdaForm.Name#typeChar()::: name type char:::return
LambdaForm.Name#resolve()::: name resolve:::if->function->resolve
LambdaForm.Name#newIndex(int)::: name new index:::if->initIndex->return->return->cloneWithIndex
LambdaForm.Name#cloneWithIndex(int)::: name clone with index:::newArguments->arguments->clone->return->new->Name->withConstraint
LambdaForm.Name#withConstraint(Object)::: name with constraint:::if->return->return->new->Name
LambdaForm.Name#replaceName(Name, Name)::: name replace name:::if->return->arguments->if->return->replaced->for->j->if->return->return->new->Name
LambdaForm.Name#replaceNames(Name[], Name[], int, int):::In the arguments of this Name, replace oldNames[i] pairwise by newNames[i]:::if->return->arguments->replaced->for->j->if->return->return->new->Name
LambdaForm.Name#internArguments()::: name intern arguments:::arguments->for->j
LambdaForm.Name#isParam()::: name is param:::return
LambdaForm.Name#isConstantZero()::: name is constant zero:::return->isParam->function->isConstantZero
LambdaForm.Name#refersTo(Class, String)::: name refers to:::return->function->member->function->member->refersTo
LambdaForm.Name#isInvokeBasic():::Check if MemberName is a call to MethodHandle.invokeBasic.:::if->return->if->return->member->function->member->return->member->refersTo->member->isPublic->member->isStatic
LambdaForm.Name#isLinkerMethodInvoke():::Check if MemberName is a call to MethodHandle.linkToStatic, etc.:::if->return->if->return->member->function->member->return->member->getDeclaringClass->member->isPublic->member->isStatic->member->getName->startsWith
LambdaForm.Name#toString()::: name to string:::return->isParam->System->identityHashCode->typeChar
LambdaForm.Name#debugString()::: name debug string:::s->paramString->return->exprString
LambdaForm.Name#paramString()::: name param string:::s->toString->c->if->return->if->getSimpleName->return
LambdaForm.Name#exprString()::: name expr string:::if->return->toString->buf->function->toString->new->StringBuilder->buf->append->cma->foreach->buf->append->if->buf->append->else->buf->append->append->append->buf->append->return->buf->toString
LambdaForm.Name#typesMatch(NamedFunction, Object...)::: name types match:::for->i->return
LambdaForm.Name#typesMatch(BasicType, Object)::: name types match:::if->return->switch->return->return->return->return->return
LambdaForm.Name#lastUseIndex(Name):::Return the index of the last occurrence of n in the argument array:::if->return->for->i->return
LambdaForm.Name#useCount(Name):::Return the number of occurrences of n in the argument array:::if->return->count->for->i->return
LambdaForm.Name#contains(Name)::: name contains:::return->lastUseIndex
LambdaForm.Name#equals(Name)::: name equals:::if->return->if->isParam->return->return->equals->Arrays->equals
LambdaForm.Name#equals(Object)::: name equals:::return->equals
LambdaForm.Name#hashCode()::: name hash code:::if->isParam->return->type->ordinal->return->function->hashCode->Arrays->hashCode
LambdaForm#lastUseIndex(Name):::Return the index of the last name which contains n as an argument:::ni->nmax->if->return->for->i->return
LambdaForm#useCount(Name):::Return the number of times n is used as an argument or return value.:::nmax->end->lastUseIndex->if->return->count->if->beg->n->index->if->for->i->return
LambdaForm#argument(int, BasicType)::: lambda form argument:::if->return->new->Name->return->type->ordinal
LambdaForm#internArgument(Name)::: lambda form intern argument:::if->return->return->argument
LambdaForm#arguments(int, MethodType)::: lambda form arguments:::length->types->parameterCount->names->new->NameArr->for->i->return
LambdaForm#identityForm(BasicType)::: lambda form identity form:::ord->type->ordinal->form->if->return->createFormsFor->return
LambdaForm#zeroForm(BasicType)::: lambda form zero form:::ord->type->ordinal->form->if->return->createFormsFor->return
LambdaForm#identity(BasicType)::: lambda form identity:::ord->type->ordinal->function->if->return->createFormsFor->return
LambdaForm#constantZero(BasicType)::: lambda form constant zero:::ord->type->ordinal->function->if->return->createFormsFor->return
LambdaForm#createFormsFor(BasicType)::: lambda form create forms for:::UNSAFE->ensureClassInitialized->synchronized->ord->type->ordinal->idForm->if->return->btChar->type->basicTypeChar->isVoid->btClass->zeType->MethodType->methodType->idType->MethodType->methodType->idMem->new->MemberName->zeMem->try->IMPL_NAMES->resolveOrFail->if->new->MemberName->IMPL_NAMES->resolveOrFail->catch->throw->newInternalError->finally->idFun->zeForm->zeFun->if->idNames->new->NameArr->argument->new->LambdaForm->idForm->compileToBytecode->SimpleMethodHandle->idMem->getInvocationType->make->new->NamedFunction->else->idNames->new->NameArr->argument->argument->new->LambdaForm->idForm->compileToBytecode->SimpleMethodHandle->idMem->getInvocationType->make->new->NamedFunction->zeValue->Wrapper->forBasicType->zero->zeNames->new->NameArr->argument->new->Name->new->LambdaForm->zeForm->compileToBytecode->SimpleMethodHandle->zeMem->getInvocationType->make->new->NamedFunction
LambdaForm#identity_I(int)::: lambda form identity_ i:::return
LambdaForm#identity_J(long)::: lambda form identity_ j:::return
LambdaForm#identity_F(float)::: lambda form identity_ f:::return
LambdaForm#identity_D(double)::: lambda form identity_ d:::return
LambdaForm#identity_L(Object)::: lambda form identity_ l:::return
LambdaForm#identity_V()::: lambda form identity_ v:::return
LambdaForm#zero_I()::: lambda form zero_ i:::return
LambdaForm#zero_J()::: lambda form zero_ j:::return
LambdaForm#zero_F()::: lambda form zero_ f:::return
LambdaForm#zero_D()::: lambda form zero_ d:::return
LambdaForm#zero_L()::: lambda form zero_ l:::return
LambdaFormBuffer#lambdaForm()::: lambda form buffer lambda form:::return->nameArray->resultIndex->new->LambdaForm
LambdaFormBuffer#name(int)::: lambda form buffer name:::return
LambdaFormBuffer#nameArray()::: lambda form buffer name array:::return->Arrays->copyOf
LambdaFormBuffer#resultIndex()::: lambda form buffer result index:::if->return->index->indexOf->return
LambdaFormBuffer#setNames(Name[])::: lambda form buffer set names:::
LambdaFormBuffer#verifyArity()::: lambda form buffer verify arity:::for->i->for->i->for->i->if->resultIndex->indexOf->return
LambdaFormBuffer#verifyFirstChange()::: lambda form buffer verify first change:::for->i->return
LambdaFormBuffer#indexOf(NamedFunction, List)::: lambda form buffer index of:::for->i->fns->size->return
LambdaFormBuffer#indexOf(Name, Name[])::: lambda form buffer index of:::for->i->return
LambdaFormBuffer#inTrans()::: lambda form buffer in trans:::return
LambdaFormBuffer#ownedCount()::: lambda form buffer owned count:::return
LambdaFormBuffer#growNames(int, int)::: lambda form buffer grow names:::oldLength->newLength->oc->ownedCount->if->Arrays->copyOf->if->if->Arrays->copyOf->if->if->return->insertEnd->tailLength->System->arraycopy->Arrays->fill->if->System->arraycopy->Arrays->fill->if
LambdaFormBuffer#lastIndexOf(Name)::: lambda form buffer last index of:::result->for->i->return
LambdaFormBuffer#noteDuplicate(int, int):::We have just overwritten the name at pos1 with the name at pos2:::n->if->new->ArrayList<>->dups->add
LambdaFormBuffer#clearDuplicatesAndNulls():::Replace duplicate names by nulls, and remove all nulls.:::if->foreach->for->i->dups->clear->oldLength->for->i->if->Arrays->fill
LambdaFormBuffer#startEdit():::Create a private, writable copy of names:::oc->ownedCount->oldNames->ownBuffer->if->copyNamesInto->else->SLOP->Arrays->Math->max->copyOf->if
LambdaFormBuffer#changeName(int, Name)::: lambda form buffer change name:::oldName->if->ownedCount->growNames->if->if
LambdaFormBuffer#setResult(Name):::Change the result name:::
LambdaFormBuffer#endEdit():::Finish a transaction.:::for->i->Math->max->clearDuplicatesAndNulls->if->exprs->new->NameArr->argp->exprp->for->i->System->arraycopy->return->lambdaForm
LambdaFormBuffer#copyNamesInto(Name[])::: lambda form buffer copy names into:::System->arraycopy->Arrays->fill->return
LambdaFormBuffer#replaceFunctions(List, List, Object...):::Replace any Name whose function is in oldFns with a copy  whose function is in the corresponding position in newFns:::if->oldFns->isEmpty->return->for->i->return
LambdaFormBuffer#replaceName(int, Name)::: lambda form buffer replace name:::param->changeName
LambdaFormBuffer#renameParameter(int, Name):::Replace a parameter by a fresh parameter.:::replaceName->return
LambdaFormBuffer#replaceParameterByNewExpression(int, Name):::Replace a parameter by a fresh expression.:::replaceName->return
LambdaFormBuffer#replaceParameterByCopy(int, int):::Replace a parameter by another parameter or expression already in the form.:::replaceName->noteDuplicate->return
LambdaFormBuffer#insertName(int, Name, boolean)::: lambda form buffer insert name:::growNames->if->changeName
LambdaFormBuffer#insertExpression(int, Name):::Insert a fresh expression.:::insertName->return
LambdaFormBuffer#insertParameter(int, Name):::Insert a fresh parameter.:::insertName->return
LambdaFormEditor#lambdaFormEditor(LambdaForm)::: lambda form editor lambda form editor:::return->lambdaForm->uncustomize->new->LambdaFormEditor
LambdaFormEditor.Transform#packedBytes(byte[])::: transform packed bytes:::if->return->pb->bitset->for->i->if->inRange->return->return
LambdaFormEditor.Transform#packedBytes(int, int)::: transform packed bytes:::return
LambdaFormEditor.Transform#packedBytes(int, int, int)::: transform packed bytes:::return
LambdaFormEditor.Transform#packedBytes(int, int, int, int)::: transform packed bytes:::return
LambdaFormEditor.Transform#inRange(int)::: transform in range:::return
LambdaFormEditor.Transform#fullBytes(int...)::: transform full bytes:::bytes->new->byteArr->i->foreach->bval->return
LambdaFormEditor.Transform#bval(int)::: transform bval:::return
LambdaFormEditor.Transform#of(byte, int)::: transform of:::b0->bval->if->inRange->return->packedBytes->new->Transform->else->return->fullBytes->new->Transform
LambdaFormEditor.Transform#of(byte, int, int)::: transform of:::if->inRange->return->packedBytes->new->Transform->else->return->fullBytes->new->Transform
LambdaFormEditor.Transform#of(byte, int, int, int)::: transform of:::if->inRange->return->packedBytes->new->Transform->else->return->fullBytes->new->Transform
LambdaFormEditor.Transform#of(byte, int...)::: transform of:::return->ofBothArrays
LambdaFormEditor.Transform#of(byte, int, byte[])::: transform of:::return->new->intArr->ofBothArrays
LambdaFormEditor.Transform#of(byte, int, int, byte[])::: transform of:::return->new->intArr->ofBothArrays
LambdaFormEditor.Transform#ofBothArrays(byte, int[], byte[])::: transform of both arrays:::fullBytes->new->byteArr->i->bval->foreach->bval->foreach->packedBytes->packedBytes->if->return->new->Transform->else->return->new->Transform
LambdaFormEditor.Transform#withResult(LambdaForm)::: transform with result:::return->new->Transform
LambdaFormEditor.Transform#equals(Object)::: transform equals:::return->equals
LambdaFormEditor.Transform#equals(Transform)::: transform equals:::return->Arrays->equals
LambdaFormEditor.Transform#hashCode()::: transform hash code:::if->return->Long->hashCode->return->Arrays->hashCode
LambdaFormEditor.Transform#toString()::: transform to string:::buf->new->StringBuilder->bits->if->buf->append->while->buf->append->if->buf->append->buf->append->if->buf->append->buf->Arrays->toString->append->result->get->if->buf->append->buf->append->return->buf->toString
LambdaFormEditor#getInCache(Transform):::Find a previously cached transform equivalent to the given one, and return its result.:::c->k->if->m->m->get->else->if->return->else->if->t->if->t->equals->else->ta->for->i->return->k->get
LambdaFormEditor#putInCache(Transform, LambdaForm):::Cache a transform with its result, and return that result:::key->withResult->for->pass
LambdaFormEditor#buffer()::: lambda form editor buffer:::return->new->LambdaFormBuffer
LambdaFormEditor#oldSpeciesData()::: lambda form editor old species data:::return->BoundMethodHandle->speciesDataFor
LambdaFormEditor#newSpeciesData(BasicType)::: lambda form editor new species data:::return->oldSpeciesData->type->ordinal->extendWith
LambdaFormEditor#bindArgumentL(BoundMethodHandle, int, Object)::: lambda form editor bind argument l:::bt->type2->bindArgumentType->form2->bindArgumentForm->return->mh->copyWithExtendL
LambdaFormEditor#bindArgumentI(BoundMethodHandle, int, int)::: lambda form editor bind argument i:::bt->type2->bindArgumentType->form2->bindArgumentForm->return->mh->copyWithExtendI
LambdaFormEditor#bindArgumentJ(BoundMethodHandle, int, long)::: lambda form editor bind argument j:::bt->type2->bindArgumentType->form2->bindArgumentForm->return->mh->copyWithExtendJ
LambdaFormEditor#bindArgumentF(BoundMethodHandle, int, float)::: lambda form editor bind argument f:::bt->type2->bindArgumentType->form2->bindArgumentForm->return->mh->copyWithExtendF
LambdaFormEditor#bindArgumentD(BoundMethodHandle, int, double)::: lambda form editor bind argument d:::bt->type2->bindArgumentType->form2->bindArgumentForm->return->mh->copyWithExtendD
LambdaFormEditor#bindArgumentType(BoundMethodHandle, int, BasicType)::: lambda form editor bind argument type:::return->mh->type->dropParameterTypes
LambdaFormEditor#bindArgumentForm(int)::: lambda form editor bind argument form:::key->Transform->of->form->getInCache->if->return->buf->buffer->buf->startEdit->oldData->oldSpeciesData->newData->lambdaForm->parameterType->newSpeciesData->oldBaseAddress->lambdaForm->parameter->newBaseAddress->getter->newData->oldData->fieldCount->getterFunction->if->buf->oldData->getterFunctions->newData->getterFunctions->replaceFunctions->oldBaseAddress->withConstraint->buf->renameParameter->buf->new->Name->replaceParameterByNewExpression->else->new->Name->withConstraint->buf->new->Name->replaceParameterByNewExpression->buf->insertParameter->buf->endEdit->return->putInCache
LambdaFormEditor#addArgumentForm(int, BasicType)::: lambda form editor add argument form:::key->Transform->type->ordinal->of->form->getInCache->if->return->buf->buffer->buf->startEdit->buf->new->Name->insertParameter->buf->endEdit->return->putInCache
LambdaFormEditor#dupArgumentForm(int, int)::: lambda form editor dup argument form:::key->Transform->of->form->getInCache->if->return->buf->buffer->buf->startEdit->buf->replaceParameterByCopy->buf->endEdit->return->putInCache
LambdaFormEditor#spreadArgumentsForm(int, Class, int)::: lambda form editor spread arguments form:::elementType->arrayType->getComponentType->erasedArrayType->if->elementType->isPrimitive->bt->basicType->elementTypeKey->bt->ordinal->if->bt->basicTypeClass->if->elementType->isPrimitive->Wrapper->forPrimitiveType->ordinal->key->Transform->of->form->getInCache->if->return->buf->buffer->buf->startEdit->spreadParam->new->Name->checkSpread->MethodHandleImpl->getFunction->new->Name->exprPos->lambdaForm->arity->buf->insertExpression->aload->MethodHandles->arrayElementGetter->for->i->buf->insertParameter->buf->endEdit->return->putInCache
LambdaFormEditor#collectArgumentsForm(int, MethodType)::: lambda form editor collect arguments form:::collectorArity->collectorType->parameterCount->dropResult->collectorType->returnType->if->return->collectorType->parameterType->basicType->filterArgumentForm->newTypes->BasicType->collectorType->parameterArray->basicTypesOrd->kind->if->key->Transform->of->form->getInCache->if->return->makeArgumentCombinationForm->return->putInCache
LambdaFormEditor#collectArgumentArrayForm(int, MethodHandle)::: lambda form editor collect argument array form:::collectorType->arrayCollector->type->collectorArity->collectorType->parameterCount->arrayType->collectorType->returnType->elementType->arrayType->getComponentType->argType->basicType->argTypeKey->argType->ordinal->if->argType->basicTypeClass->if->elementType->isPrimitive->return->Wrapper->forPrimitiveType->ordinal->kind->key->Transform->of->form->getInCache->if->return->buf->buffer->buf->startEdit->newParams->new->NameArr->for->i->callCombiner->new->NamedFunction->new->Name->exprPos->lambdaForm->arity->buf->insertExpression->argPos->foreach->buf->insertParameter->buf->replaceParameterByCopy->buf->endEdit->return->putInCache
LambdaFormEditor#filterArgumentForm(int, BasicType)::: lambda form editor filter argument form:::key->Transform->newType->ordinal->of->form->getInCache->if->return->oldType->lambdaForm->parameterType->filterType->MethodType->oldType->basicTypeClass->newType->basicTypeClass->methodType->makeArgumentCombinationForm->return->putInCache
LambdaFormEditor#makeArgumentCombinationForm(int, MethodType, boolean, boolean)::: lambda form editor make argument combination form:::buf->buffer->buf->startEdit->combinerArity->combinerType->parameterCount->resultArity->oldData->oldSpeciesData->newData->newSpeciesData->oldBaseAddress->lambdaForm->parameter->buf->oldData->getterFunctions->newData->getterFunctions->replaceFunctions->newBaseAddress->oldBaseAddress->withConstraint->buf->renameParameter->getCombiner->newData->oldData->fieldCount->getterFunction->new->Name->combinerArgs->new->ObjectArr->newParams->if->new->NameArr->System->arraycopy->else->new->NameArr->for->i->System->arraycopy->callCombiner->new->Name->exprPos->lambdaForm->arity->buf->insertExpression->buf->insertExpression->argPos->foreach->buf->insertParameter->if->buf->replaceParameterByCopy->return->buf->endEdit
LambdaFormEditor#makeArgumentCombinationForm(int, MethodType, int[], boolean, boolean)::: lambda form editor make argument combination form:::buf->buffer->buf->startEdit->combinerArity->combinerType->parameterCount->resultArity->oldData->oldSpeciesData->newData->newSpeciesData->oldBaseAddress->lambdaForm->parameter->buf->oldData->getterFunctions->newData->getterFunctions->replaceFunctions->newBaseAddress->oldBaseAddress->withConstraint->buf->renameParameter->getCombiner->newData->oldData->fieldCount->getterFunction->new->Name->combinerArgs->new->ObjectArr->newParams->if->new->NameArr->for->i->else->new->NameArr->for->i->System->arraycopy->callCombiner->new->Name->exprPos->lambdaForm->arity->buf->insertExpression->buf->insertExpression->argPos->foreach->buf->insertParameter->if->buf->replaceParameterByCopy->return->buf->endEdit
LambdaFormEditor#filterReturnForm(BasicType, boolean)::: lambda form editor filter return form:::kind->key->Transform->newType->ordinal->of->form->getInCache->if->return->buf->buffer->buf->startEdit->insPos->callFilter->if->if->else->constantZero->new->Name->else->oldData->oldSpeciesData->newData->newSpeciesData->oldBaseAddress->lambdaForm->parameter->buf->oldData->getterFunctions->newData->getterFunctions->replaceFunctions->newBaseAddress->oldBaseAddress->withConstraint->buf->renameParameter->getFilter->newData->oldData->fieldCount->getterFunction->new->Name->buf->insertExpression->oldType->lambdaForm->returnType->if->filterType->MethodType->newType->basicTypeClass->methodType->new->Name->else->filterType->MethodType->newType->basicTypeClass->oldType->basicTypeClass->methodType->new->Name->if->buf->insertExpression->buf->setResult->buf->endEdit->return->putInCache
LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType)::: lambda form editor fold arguments form:::combinerArity->combinerType->parameterCount->kind->key->Transform->of->form->getInCache->if->return->makeArgumentCombinationForm->return->putInCache
LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType, int...)::: lambda form editor fold arguments form:::kind->keyArgs->Arrays->copyOf->key->Transform->of->form->getInCache->if->return->makeArgumentCombinationForm->return->putInCache
LambdaFormEditor#permuteArgumentsForm(int, int[])::: lambda form editor permute arguments form:::length->outArgs->inTypes->nullPerm->for->i->if->return->key->Transform->of->form->getInCache->if->return->types->new->BasicTypeArr->for->i->pos->while->names2->new->NameArr->System->arraycopy->bodyLength->System->arraycopy->arity2->result2->if->if->else->for->j->for->i->for->j->new->LambdaForm->return->putInCache
LambdaFormEditor#noteLoopLocalTypesForm(int, BasicType[])::: lambda form editor note loop local types form:::desc->BasicType->basicTypeOrds->Arrays->copyOf->key->Transform->of->form->getInCache->if->return->invokeLoop->args->Arrays->copyOf->buf->buffer->buf->startEdit->buf->MethodHandleImpl->getFunction->new->Name->changeName->buf->endEdit->return->putInCache
LambdaFormEditor#permutedTypesMatch(int[], BasicType[], Name[], int)::: lambda form editor permuted types match:::for->i->return
LambdaMetafactory#metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType):::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments:::mf->new->InnerClassLambdaMetafactory->mf->validateMetafactoryArgs->return->mf->buildCallSite
LambdaMetafactory#altMetafactory(MethodHandles.Lookup, String, MethodType, Object...):::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments:::samMethodType->implMethod->instantiatedMethodType->flags->markerInterfaces->bridges->argIndex->if->markerCount->new->Class<?>Arr->System->arraycopy->else->if->bridgeCount->new->MethodTypeArr->System->arraycopy->else->isSerializable->if->foundSerializableSupertype->invokedType->returnType->isAssignableFrom->foreach->isAssignableFrom->if->Arrays->copyOf->mf->new->InnerClassLambdaMetafactory->mf->validateMetafactoryArgs->return->mf->buildCallSite
MemberName#getDeclaringClass():::Return the declaring class of this member:::return
MemberName#getClassLoader():::Utility method producing the class loader of the declaring class.:::return->clazz->getClassLoader
MemberName#getName():::Return the simple name of this member:::if->expandFromVM->if->return->return
MemberName#getMethodOrFieldType()::: member name get method or field type:::if->isInvocable->return->getMethodType->if->isGetter->return->MethodType->getFieldType->methodType->if->isSetter->return->MethodType->getFieldType->methodType->throw->new->InternalError
MemberName#getMethodType():::Return the declared type of this member, which  must be a method or constructor.:::if->expandFromVM->if->return->if->isInvocable->throw->newIllegalArgumentException->type->if->return->synchronized->if->sig->res->MethodType->getClassLoader->fromDescriptor->else->if->typeInfo->ptypes->rtype->res->MethodType->makeImpl->return
MemberName#getMethodDescriptor():::Return the descriptor of this member, which  must be a method or constructor.:::if->expandFromVM->if->return->if->isInvocable->throw->newIllegalArgumentException->type->if->return->else->return->getMethodType->toMethodDescriptorString
MemberName#getInvocationType():::Return the actual type under which this method or constructor must be invoked:::itype->getMethodOrFieldType->if->isConstructor->getReferenceKind->return->itype->changeReturnType->if->isStatic->return->itype->insertParameterTypes->return
MemberName#getParameterTypes():::Utility method producing the parameter types of the method type.:::return->getMethodType->parameterArray
MemberName#getReturnType():::Utility method producing the return type of the method type.:::return->getMethodType->returnType
MemberName#getFieldType():::Return the declared type of this member, which  must be a field or type:::if->expandFromVM->if->return->if->isInvocable->throw->newIllegalArgumentException->type->if->return->synchronized->if->sig->mtype->MethodType->getClassLoader->fromDescriptor->res->mtype->returnType->return
MemberName#getType():::Utility method to produce either the method type or field type of this member.:::return->isInvocable->getMethodType->getFieldType
MemberName#getSignature():::Utility method to produce the signature of this member,  used within the class file format to describe its type.:::if->expandFromVM->if->return->if->isInvocable->return->BytecodeDescriptor->getMethodType->unparse->else->return->BytecodeDescriptor->getFieldType->unparse
MemberName#getModifiers():::Return the modifier flags of this member.:::return
MemberName#getReferenceKind():::Return the reference kind of this member, or zero if none.:::return
MemberName#referenceKindIsConsistent()::: member name reference kind is consistent:::refKind->getReferenceKind->if->return->isType->if->isField->else->if->isConstructor->else->if->isMethod->if->clazz->isInterface->else->return
MemberName#isObjectPublicMethod()::: member name is object public method:::if->return->mtype->getMethodType->if->name->equals->mtype->returnType->mtype->parameterCount->return->if->name->equals->mtype->returnType->mtype->parameterCount->return->if->name->equals->mtype->returnType->mtype->parameterCount->mtype->parameterType->return->return
MemberName#referenceKindIsConsistentWith(int)::: member name reference kind is consistent with:::refKind->getReferenceKind->if->return->switch->return->return->return
MemberName#staticIsConsistent()::: member name static is consistent:::refKind->getReferenceKind->return->MethodHandleNatives->refKindIsStatic->isStatic->getModifiers
MemberName#vminfoIsConsistent()::: member name vminfo is consistent:::refKind->getReferenceKind->vminfo->MethodHandleNatives->getMemberVMInfo->vmindex->vmtarget->if->MethodHandleNatives->refKindIsField->else->if->MethodHandleNatives->refKindDoesDispatch->else->return
MemberName#changeReferenceKind(byte, byte)::: member name change reference kind:::return
MemberName#testFlags(int, int)::: member name test flags:::return
MemberName#testAllFlags(int)::: member name test all flags:::return->testFlags
MemberName#testAnyFlags(int)::: member name test any flags:::return->testFlags
MemberName#isMethodHandleInvoke():::Utility method to query if this member is a method handle invocation (invoke or invokeExact).:::bits->negs->if->testFlags->return->isMethodHandleInvokeName->return
MemberName#isMethodHandleInvokeName(String)::: member name is method handle invoke name:::switch->return->return
MemberName#isVarHandleMethodInvoke()::: member name is var handle method invoke:::bits->negs->if->testFlags->return->isVarHandleMethodInvokeName->return
MemberName#isVarHandleMethodInvokeName(String)::: member name is var handle method invoke name:::try->valueFromMethodName->return->catch->return->finally
MemberName#isStatic():::Utility method to query the modifier flags of this member.:::return->Modifier->isStatic
MemberName#isPublic():::Utility method to query the modifier flags of this member.:::return->Modifier->isPublic
MemberName#isPrivate():::Utility method to query the modifier flags of this member.:::return->Modifier->isPrivate
MemberName#isProtected():::Utility method to query the modifier flags of this member.:::return->Modifier->isProtected
MemberName#isFinal():::Utility method to query the modifier flags of this member.:::return->Modifier->isFinal
MemberName#canBeStaticallyBound():::Utility method to query whether this member or its defining class is final.:::return->Modifier->clazz->getModifiers->isFinal
MemberName#isVolatile():::Utility method to query the modifier flags of this member.:::return->Modifier->isVolatile
MemberName#isAbstract():::Utility method to query the modifier flags of this member.:::return->Modifier->isAbstract
MemberName#isNative():::Utility method to query the modifier flags of this member.:::return->Modifier->isNative
MemberName#isBridge():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::return->testAllFlags
MemberName#isVarargs():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::return->testAllFlags->isInvocable
MemberName#isSynthetic():::Utility method to query the modifier flags of this member; returns false if the member is not a method.:::return->testAllFlags
MemberName#isInvocable():::Utility method to query whether this member is a method or constructor.:::return->testAnyFlags
MemberName#isFieldOrMethod():::Utility method to query whether this member is a method, constructor, or field.:::return->testAnyFlags
MemberName#isMethod():::Query whether this member is a method.:::return->testAllFlags
MemberName#isConstructor():::Query whether this member is a constructor.:::return->testAllFlags
MemberName#isField():::Query whether this member is a field.:::return->testAllFlags
MemberName#isType():::Query whether this member is a type.:::return->testAllFlags
MemberName#isPackage():::Utility method to query whether this member is neither public, private, nor protected.:::return->testAnyFlags
MemberName#isCallerSensitive():::Query whether this member has a CallerSensitive annotation.:::return->testAllFlags
MemberName#isAccessibleFrom(Class):::Utility method to query whether this member is accessible from a given lookup class.:::mode->return->VerifyAccess->this->getDeclaringClass->this->getDeclaringClass->isMemberAccessible
MemberName#refersTo(Class, String):::Check if MemberName is a call to a method named name in class declaredClass.:::return->getName->equals
MemberName#init(Class, String, Object, int):::Initialize a query:::
MemberName#expandFromVM():::Calls down to the VM to fill in the fields:::if->return->if->isResolved->return->MethodHandleNatives->expand
MemberName#flagsMods(int, int, byte)::: member name flags mods:::return
MemberName#asSpecial()::: member name as special:::switch->getReferenceKind->return->return->clone->changeReferenceKind->return->clone->changeReferenceKind->return->clone->changeReferenceKind->throw->this->toString->new->IllegalArgumentException
MemberName#asConstructor():::If this MN is not REF_newInvokeSpecial, return a clone with that ref:::switch->getReferenceKind->return->clone->changeReferenceKind->return->throw->this->toString->new->IllegalArgumentException
MemberName#asNormalOriginal():::If this MN is a REF_invokeSpecial, return a clone with the "normal" kind  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface:::normalVirtual->clazz->isInterface->refKind->getReferenceKind->newRefKind->result->switch->break->if->return->clone->changeReferenceKind->return
MemberName#isGetter()::: member name is getter:::return->MethodHandleNatives->getReferenceKind->refKindIsGetter
MemberName#isSetter()::: member name is setter:::return->MethodHandleNatives->getReferenceKind->refKindIsSetter
MemberName#asSetter()::: member name as setter:::refKind->getReferenceKind->setterRefKind->return->clone->changeReferenceKind
MemberName#makeMethodHandleInvoke(String, MethodType):::Create a name for a signature-polymorphic invoker:::return->makeMethodHandleInvoke
MemberName#makeMethodHandleInvoke(String, MethodType, int)::: member name make method handle invoke:::mem->new->MemberName->return
MemberName#makeVarHandleMethodInvoke(String, MethodType)::: member name make var handle method invoke:::return->makeVarHandleMethodInvoke
MemberName#makeVarHandleMethodInvoke(String, MethodType, int)::: member name make var handle method invoke:::mem->new->MemberName->return
MemberName#clone()::: member name clone:::try->return->super->clone->catch->throw->newInternalError->finally
MemberName#getDefinition():::Get the definition of this member name:::if->isResolved->throw->new->IllegalStateException->if->isType->return->res->this->clone->res->expandFromVM->return
MemberName#hashCode()::: member name hash code:::return->Objects->getReferenceKind->new->Byte->getType->hash
MemberName#equals(Object)::: member name equals:::return->this->equals
MemberName#equals(MemberName):::Decide if two member names have exactly the same symbolic content:::if->return->if->return->return->this->getReferenceKind->that->getReferenceKind->Objects->equals->Objects->this->getType->that->getType->equals
MemberName#hasReceiverTypeDispatch():::Query whether this member name is resolved to a non-static, non-final method.:::return->MethodHandleNatives->getReferenceKind->refKindDoesDispatch
MemberName#isResolved():::Query whether this member name is resolved:::return
MemberName#initResolved(boolean)::: member name init resolved:::if
MemberName#checkForTypeAlias(Class)::: member name check for type alias:::if->isInvocable->type->if->else->getMethodType->if->type->erase->return->if->VerifyAccess->isTypeVisible->return->throw->new->LinkageError->else->type->if->else->getFieldType->if->VerifyAccess->isTypeVisible->return->throw->new->LinkageError
MemberName#toString():::Produce a string form of this member name:::if->isType->return->type->toString->buf->new->StringBuilder->if->getDeclaringClass->buf->getName->append->buf->append->name->buf->append->type->if->isInvocable->buf->append->buf->getName->append->else->buf->getName->append->refKind->getReferenceKind->if->buf->append->buf->MethodHandleNatives->refKindName->append->return->buf->toString
MemberName#getName(Object)::: member name get name:::if->return->getName->return->String->valueOf
MemberName#makeAccessException(String, Object)::: member name make access exception:::toString->if->if->MethodHandles->publicLookup->else->m->if->lookup->lookup->lookupClass->getModule->else->from->getClass->getModule->return->new->IllegalAccessException
MemberName#message()::: member name message:::if->isResolved->return->else->if->isConstructor->return->else->if->isMethod->return->else->return
MemberName#makeAccessException()::: member name make access exception:::message->message->toString->ex->if->isResolved->new->IllegalAccessException->else->if->isConstructor->new->NoSuchMethodException->else->if->isMethod->new->NoSuchMethodException->else->new->NoSuchFieldException->if->ex->initCause->return
MemberName#getFactory()::: member name get factory:::return
MemberName.Factory#getMembers(Class, String, Object, int, Class)::: factory get members:::matchSig->if->BytecodeDescriptor->unparse->if->matchSig->startsWith->else->BUF_MAX->len1->buf->newMemberBuffer->totalCount->bufs->bufCount->for->result->new->ArrayList<>->if->foreach->Collections->addAll->for->i->if->for->it->result->iterator->it->hasNext->return
MemberName.Factory#resolve(byte, MemberName, Class, boolean):::Produce a resolved version of the given member:::m->ref->clone->try->MethodHandleNatives->resolve->if->return->m->m->getDeclaringClass->checkForTypeAlias->catch->return->finally->m->initResolved->return
MemberName.Factory#resolveOrFail(byte, MemberName, Class, Class):::Produce a resolved version of the given member:::result->resolve->if->result->isResolved->return->ex->result->makeAccessException->if->throw->throw->nsmClass->cast
MemberName.Factory#resolveOrNull(byte, MemberName, Class):::Produce a resolved version of the given member:::result->resolve->if->result->isResolved->return->return
MemberName.Factory#getMethods(Class, boolean, Class):::Return a list of all methods defined by the given class:::return->getMethods
MemberName.Factory#getMethods(Class, boolean, String, MethodType, Class):::Return a list of matching methods defined by the given class:::matchFlags->return->getMembers
MemberName.Factory#getConstructors(Class, Class):::Return a list of all constructors defined by the given class:::return->getMembers
MemberName.Factory#getFields(Class, boolean, Class):::Return a list of all fields defined by the given class:::return->getFields
MemberName.Factory#getFields(Class, boolean, String, Class, Class):::Return a list of all fields defined by the given class:::matchFlags->return->getMembers
MemberName.Factory#getNestedTypes(Class, boolean, Class):::Return a list of all nested types defined by the given class:::matchFlags->return->getMembers
MemberName.Factory#newMemberBuffer(int)::: factory new member buffer:::buf->new->MemberNameArr->for->i->return
MethodHandle#type():::Reports the type of this method handle:::return
MethodHandle#invokeExact(Object...):::Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match:::
MethodHandle#invoke(Object...):::Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values:::
MethodHandle#invokeBasic(Object...):::Private method for trusted invocation of a method handle respecting simplified signatures:::
MethodHandle#linkToVirtual(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeVirtual:::
MethodHandle#linkToStatic(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeStatic:::
MethodHandle#linkToSpecial(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeSpecial:::
MethodHandle#linkToInterface(Object...):::Private method for trusted invocation of a MemberName of kind REF_invokeInterface:::
MethodHandle#invokeWithArguments(Object...):::Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument array:::invocationType->MethodType->genericMethodType->return->invocationType->invokers->spreadInvoker->asType->invokeExact
MethodHandle#invokeWithArguments(java.util.List):::Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument list:::return->arguments->toArray->invokeWithArguments
MethodHandle#asType(MethodType):::Produces an adapter method handle which adapts the type of the current method handle to a new type:::if->return->atc->asTypeCached->if->return->return->asTypeUncached
MethodHandle#asTypeCached(MethodType)::: method handle as type cached:::atc->if->return->return
MethodHandle#asTypeUncached(MethodType)::: method handle as type uncached:::if->type->isConvertibleTo->throw->new->WrongMethodTypeException->return->MethodHandleImpl->makePairwiseConvert
MethodHandle#asSpreader(Class, int):::Makes an array-spreading method handle, which accepts a trailing array argument and spreads its elements as positional arguments:::return->type->parameterCount->asSpreader
MethodHandle#asSpreader(int, Class, int):::Makes an array-spreading method handle, which accepts an array argument at a given position and spreads its elements as positional arguments in place of the array:::postSpreadType->asSpreaderChecks->afterSpread->this->asType->mh->afterSpread->rebind->lform->mh->editor->spreadArgumentsForm->preSpreadType->postSpreadType->replaceParameterTypes->return->mh->copyWith
MethodHandle#asSpreaderChecks(Class, int, int):::See if asSpreader can be validly called with the given arguments:::spreadArrayChecks->nargs->type->parameterCount->if->throw->newIllegalArgumentException->if->throw->newIllegalArgumentException->arrayElement->arrayType->getComponentType->mtype->type->match->fail->for->i->if->return->needType->mtype->asSpreaderType->if->return->this->asType->throw->newInternalError
MethodHandle#spreadArrayChecks(Class, int)::: method handle spread array checks:::arrayElement->arrayType->getComponentType->if->throw->newIllegalArgumentException->if->if->throw->newIllegalArgumentException->if->throw->newIllegalArgumentException
MethodHandle#withVarargs(boolean):::Adapts this method handle to be #asVarargsCollector variable arity if the boolean flag is true, else #asFixedArity fixed arity:::if->return->type->lastParameterType->asVarargsCollector->else->return
MethodHandle#asCollector(Class, int):::Makes an array-collecting method handle, which accepts a given number of trailing positional arguments and collects them into an array argument:::return->type->parameterCount->asCollector
MethodHandle#asCollector(int, Class, int):::Makes an array-collecting method handle, which accepts a given number of positional arguments starting at a given position, and collects them into an array argument:::asCollectorChecks->mh->rebind->resultType->type->asCollectorType->newArray->MethodHandleImpl->varargsArray->lform->mh->editor->collectArgumentArrayForm->if->return->mh->copyWith->mh->editor->newArray->type->basicType->collectArgumentsForm->return->mh->copyWithExtendL
MethodHandle#asCollectorChecks(Class, int, int)::: method handle as collector checks:::spreadArrayChecks->nargs->type->parameterCount->if->throw->newIllegalArgumentException->if->param->type->parameterType->if->return->if->param->isAssignableFrom->return->throw->newIllegalArgumentException
MethodHandle#asVarargsCollector(Class):::Makes a variable arity adapter which is able to accept any number of trailing positional arguments and collect them into an array argument:::Objects->requireNonNull->lastMatch->type->parameterCount->asCollectorChecks->if->isVarargsCollector->return->return->MethodHandleImpl->makeVarargsCollector
MethodHandle#isVarargsCollector():::Determines if this method handle supports #asVarargsCollector variable arity calls:::return
MethodHandle#asFixedArity():::Makes a fixed arity method handle which is otherwise equivalent to the current method handle:::return
MethodHandle#bindTo(Object):::Binds a value x to the first argument of a method handle, without invoking it:::type->leadingReferenceParameter->cast->return->bindArgumentL
MethodHandle#toString():::Returns a string representation of the method handle, starting with the string "MethodHandle" and ending with the string representation of the method handle's type:::if->return->debugString->return->standardString
MethodHandle#standardString()::: method handle standard string:::return
MethodHandle#debugString():::Return a string with a several lines describing the method handle structure:::return->internalForm->internalProperties
MethodHandle#bindArgumentL(int, Object)::: method handle bind argument l:::return->rebind->bindArgumentL
MethodHandle#setVarargs(MemberName)::: method handle set varargs:::if->member->isVarargs->return->try->return->this->withVarargs->catch->throw->member->makeAccessException->finally
MethodHandle#viewAsType(MethodType, boolean)::: method handle view as type:::mh->rebind->return->mh->copyWith
MethodHandle#viewAsTypeChecks(MethodType, boolean)::: method handle view as type checks:::if->else->return
MethodHandle#internalForm()::: method handle internal form:::return
MethodHandle#internalMemberName()::: method handle internal member name:::return
MethodHandle#internalCallerClass()::: method handle internal caller class:::return
MethodHandle#intrinsicName()::: method handle intrinsic name:::return
MethodHandle#withInternalMemberName(MemberName, boolean)::: method handle with internal member name:::if->return->MethodHandleImpl->makeWrappedMember->else->if->internalMemberName->return->else->result->rebind->return
MethodHandle#isInvokeSpecial()::: method handle is invoke special:::return
MethodHandle#internalValues()::: method handle internal values:::return
MethodHandle#internalProperties()::: method handle internal properties:::return
MethodHandle#copyWith(MethodType, LambdaForm)::: method handle copy with:::
MethodHandle#rebind():::Require this method handle to be a BMH, or else replace it with a "wrapper" BMH:::
MethodHandle#updateForm(LambdaForm)::: method handle update form:::if->return->newForm->prepare->UNSAFE->putObject->UNSAFE->fullFence
MethodHandle#customize()::: method handle customize:::form->if->newForm->form->customize->updateForm->else
MethodHandleImpl#makeArrayElementAccessor(Class, ArrayAccess)::: method handle impl make array element accessor:::if->return->ArrayAccess->objectAccessor->if->arrayClass->isArray->throw->newIllegalArgumentException->cache->get->cacheIndex->ArrayAccess->cacheIndex->mh->if->return->ArrayAccessor->getAccessor->correctType->ArrayAccessor->correctType->if->mh->type->mh->viewAsType->ArrayAccess->intrinsic->makeIntrinsic->synchronized->if->else->return
MethodHandleImpl#unmatchedArrayAccess(ArrayAccess)::: method handle impl unmatched array access:::return->newInternalError
MethodHandleImpl.ArrayAccessor#getElementI(int[], int)::: array accessor get element i:::return
MethodHandleImpl.ArrayAccessor#getElementJ(long[], int)::: array accessor get element j:::return
MethodHandleImpl.ArrayAccessor#getElementF(float[], int)::: array accessor get element f:::return
MethodHandleImpl.ArrayAccessor#getElementD(double[], int)::: array accessor get element d:::return
MethodHandleImpl.ArrayAccessor#getElementZ(boolean[], int)::: array accessor get element z:::return
MethodHandleImpl.ArrayAccessor#getElementB(byte[], int)::: array accessor get element b:::return
MethodHandleImpl.ArrayAccessor#getElementS(short[], int)::: array accessor get element s:::return
MethodHandleImpl.ArrayAccessor#getElementC(char[], int)::: array accessor get element c:::return
MethodHandleImpl.ArrayAccessor#getElementL(Object[], int)::: array accessor get element l:::return
MethodHandleImpl.ArrayAccessor#setElementI(int[], int, int)::: array accessor set element i:::
MethodHandleImpl.ArrayAccessor#setElementJ(long[], int, long)::: array accessor set element j:::
MethodHandleImpl.ArrayAccessor#setElementF(float[], int, float)::: array accessor set element f:::
MethodHandleImpl.ArrayAccessor#setElementD(double[], int, double)::: array accessor set element d:::
MethodHandleImpl.ArrayAccessor#setElementZ(boolean[], int, boolean)::: array accessor set element z:::
MethodHandleImpl.ArrayAccessor#setElementB(byte[], int, byte)::: array accessor set element b:::
MethodHandleImpl.ArrayAccessor#setElementS(short[], int, short)::: array accessor set element s:::
MethodHandleImpl.ArrayAccessor#setElementC(char[], int, char)::: array accessor set element c:::
MethodHandleImpl.ArrayAccessor#setElementL(Object[], int, Object)::: array accessor set element l:::
MethodHandleImpl.ArrayAccessor#lengthI(int[])::: array accessor length i:::return
MethodHandleImpl.ArrayAccessor#lengthJ(long[])::: array accessor length j:::return
MethodHandleImpl.ArrayAccessor#lengthF(float[])::: array accessor length f:::return
MethodHandleImpl.ArrayAccessor#lengthD(double[])::: array accessor length d:::return
MethodHandleImpl.ArrayAccessor#lengthZ(boolean[])::: array accessor length z:::return
MethodHandleImpl.ArrayAccessor#lengthB(byte[])::: array accessor length b:::return
MethodHandleImpl.ArrayAccessor#lengthS(short[])::: array accessor length s:::return
MethodHandleImpl.ArrayAccessor#lengthC(char[])::: array accessor length c:::return
MethodHandleImpl.ArrayAccessor#lengthL(Object[])::: array accessor length l:::return
MethodHandleImpl.ArrayAccessor#name(Class, ArrayAccess)::: array accessor name:::elemClass->arrayClass->getComponentType->if->throw->newIllegalArgumentException->return->ArrayAccess->opName->Wrapper->basicTypeChar
MethodHandleImpl.ArrayAccessor#type(Class, ArrayAccess)::: array accessor type:::elemClass->arrayClass->getComponentType->arrayArgClass->if->elemClass->isPrimitive->switch->return->MethodType->methodType->return->MethodType->methodType->return->MethodType->methodType->throw->unmatchedArrayAccess
MethodHandleImpl.ArrayAccessor#correctType(Class, ArrayAccess)::: array accessor correct type:::elemClass->arrayClass->getComponentType->switch->return->MethodType->methodType->return->MethodType->methodType->return->MethodType->methodType->throw->unmatchedArrayAccess
MethodHandleImpl.ArrayAccessor#getAccessor(Class, ArrayAccess)::: array accessor get accessor:::name->name->type->type->try->return->IMPL_LOOKUP->findStatic->catch->throw->uncaughtException->finally
MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean, boolean):::Create a JVM-level adapter method handle to conform the given method handle to the similar newType, using only pairwise argument conversions:::dstType->target->type->if->return->return->makePairwiseConvertByEditor
MethodHandleImpl#countNonNull(Object[])::: method handle impl count non null:::count->foreach->if->return
MethodHandleImpl#makePairwiseConvertByEditor(MethodHandle, MethodType, boolean, boolean)::: method handle impl make pairwise convert by editor:::convSpecs->target->type->computeValueConversions->convCount->countNonNull->if->return->target->viewAsType->basicSrcType->srcType->basicType->midType->target->type->basicType->mh->target->rebind->for->i->convSpec->if->fn->if->if->else->getConstantHandle->bindTo->else->newType->basicSrcType->returnType->if->mh->rebind->form2->mh->editor->BasicType->basicType->filterReturnForm->mh->copyWithExtendL->else->form2->mh->editor->BasicType->basicType->filterReturnForm->mh->copyWith->return
MethodHandleImpl#makePairwiseConvertIndirect(MethodHandle, MethodType, boolean, boolean)::: method handle impl make pairwise convert indirect:::convSpecs->target->type->computeValueConversions->INARG_COUNT->srcType->parameterCount->convCount->countNonNull->retConv->retVoid->srcType->returnType->if->IN_MH->INARG_BASE->INARG_LIMIT->NAME_LIMIT->RETURN_CONV->OUT_CALL->RESULT->lambdaType->srcType->basicType->invokerType->names->arguments->OUTARG_BASE->outArgs->new->ObjectArr->nameCursor->for->i->new->Name->convSpec->if->else->conv->if->LambdaForm->BasicType->srcType->returnType->basicType->constantZero->new->Name->else->if->convClass->getConstantHandle->new->Name->else->fn->if->fn->type->parameterCount->new->Name->else->new->Name->form->lambdaType->parameterCount->new->LambdaForm->return->SimpleMethodHandle->make
MethodHandleImpl#computeValueConversions(MethodType, MethodType, boolean, boolean)::: method handle impl compute value conversions:::INARG_COUNT->srcType->parameterCount->convSpecs->new->ObjectArr->for->i->return
MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean)::: method handle impl make pairwise convert:::return->makePairwiseConvert
MethodHandleImpl#valueConversion(Class, Class, boolean, boolean):::Find a conversion function from the given source to the given destination:::if->return->fn->if->src->isPrimitive->if->return->else->if->dst->isPrimitive->ValueConversions->convertPrimitive->else->wsrc->Wrapper->forPrimitiveType->ValueConversions->boxExact->if->VerifyType->wsrc->wrapperType->isNullConversion->mt->MethodType->methodType->if->fn->asType->else->MethodHandleImpl->makePairwiseConvert->else->if->dst->isPrimitive->wdst->Wrapper->forPrimitiveType->if->wdst->wrapperType->ValueConversions->unboxExact->else->ValueConversions->unboxWiden->ValueConversions->unboxCast->else->return->return
MethodHandleImpl#makeVarargsCollector(MethodHandle, Class)::: method handle impl make varargs collector:::type->target->type->last->type->parameterCount->if->type->parameterType->target->type->changeParameterType->asType->target->asFixedArity->return->new->AsVarargsCollector
MethodHandleImpl.AsVarargsCollector#isVarargsCollector()::: as varargs collector is varargs collector:::return
MethodHandleImpl.AsVarargsCollector#getTarget()::: as varargs collector get target:::return
MethodHandleImpl.AsVarargsCollector#asFixedArity()::: as varargs collector as fixed arity:::return
MethodHandleImpl.AsVarargsCollector#setVarargs(MemberName)::: as varargs collector set varargs:::if->member->isVarargs->return->return->asFixedArity
MethodHandleImpl.AsVarargsCollector#withVarargs(boolean)::: as varargs collector with varargs:::if->return->return->asFixedArity
MethodHandleImpl.AsVarargsCollector#asTypeUncached(MethodType)::: as varargs collector as type uncached:::type->this->type->collectArg->type->parameterCount->newArity->newType->parameterCount->if->type->parameterType->newType->parameterType->isAssignableFrom->return->asFixedArity->asType->acc->if->acc->type->parameterCount->return->acc->asType->arrayLength->collector->try->asFixedArity->asCollector->catch->throw->new->WrongMethodTypeException->finally->return->collector->asType
MethodHandleImpl.AsVarargsCollector#viewAsTypeChecks(MethodType, boolean)::: as varargs collector view as type checks:::super->viewAsTypeChecks->if->return->return
MethodHandleImpl.AsVarargsCollector#invokeWithArguments(Object...)::: as varargs collector invoke with arguments:::type->this->type->argc->MAX_SAFE->if->type->parameterCount->return->super->invokeWithArguments->uncollected->type->parameterCount->elemType->arrayType->getComponentType->collected->collArgs->new->ObjectArr->Array->newInstance->if->elemType->isPrimitive->try->System->arraycopy->catch->return->super->invokeWithArguments->finally->else->arraySetter->MethodHandles->arrayElementSetter->try->for->i->catch->return->super->invokeWithArguments->finally->newArgs->new->ObjectArr->System->arraycopy->return->asFixedArity->invokeWithArguments
MethodHandleImpl#makeSpreadArguments(MethodHandle, Class, int, int):::Factory method:  Spread selected argument.:::targetType->target->type->for->i->target->asType->srcType->targetType->replaceParameterTypes->lambdaType->srcType->invokerType->names->arguments->nameCursor->lambdaType->parameterCount->indexes->targetType->parameterCount->new->intArr->for->i->argIndex->targetType->parameterCount->targetArgs->targetType->parameterCount->new->NameArr->for->i->targetType->parameterCount->new->Name->form->lambdaType->parameterCount->new->LambdaForm->return->SimpleMethodHandle->make
MethodHandleImpl#checkSpreadArgument(Object, int)::: method handle impl check spread argument:::if->return->else->if->throw->new->NullPointerException->else->if->len->if->return->else->len->getLength->if->return->throw->newIllegalArgumentException
MethodHandleImpl#makeCollectArguments(MethodHandle, MethodHandle, int, boolean):::Factory method:  Collect or filter selected argument(s).:::targetType->target->type->collectorType->collector->type->collectArgCount->collectorType->parameterCount->collectValType->collectorType->returnType->collectValCount->srcType->targetType->dropParameterTypes->if->srcType->collectorType->parameterArray->insertParameterTypes->lambdaType->srcType->invokerType->names->arguments->collectNamePos->targetNamePos->collectorArgs->Arrays->copyOfRange->new->Name->targetArgs->targetType->parameterCount->new->NameArr->inputArgPos->targetArgPos->chunk->System->arraycopy->if->if->System->arraycopy->System->arraycopy->new->Name->form->lambdaType->parameterCount->new->LambdaForm->return->SimpleMethodHandle->make
MethodHandleImpl#selectAlternative(boolean, MethodHandle, MethodHandle)::: method handle impl select alternative:::if->return->else->return
MethodHandleImpl#profileBoolean(boolean, int[])::: method handle impl profile boolean:::idx->try->Math->addExact->catch->finally->return
MethodHandleImpl#isCompileConstant(Object)::: method handle impl is compile constant:::return
MethodHandleImpl#makeGuardWithTest(MethodHandle, MethodHandle, MethodHandle)::: method handle impl make guard with test:::type->target->type->basicType->type->basicType->form->makeGuardWithTestForm->mh->try->if->counts->new->intArr->BoundMethodHandle->speciesData_LLLL->factory->profile->profile->invokeBasic->else->BoundMethodHandle->speciesData_LLL->factory->profile->profile->invokeBasic->catch->throw->uncaughtException->finally->return
MethodHandleImpl#profile(MethodHandle)::: method handle impl profile:::if->return->makeBlockInliningWrapper->else->return
MethodHandleImpl#makeBlockInliningWrapper(MethodHandle):::Block inlining during JIT-compilation of a target method handle if it hasn't been invoked enough times:::lform->if->apply->else->apply->return->new->CountingWrapper
MethodHandleImpl.CountingWrapper#getTarget()::: counting wrapper get target:::return
MethodHandleImpl.CountingWrapper#asTypeUncached(MethodType)::: counting wrapper as type uncached:::newTarget->target->asType->wrapper->if->lform->countingFormProducer->apply->new->CountingWrapper->else->return
MethodHandleImpl.CountingWrapper#maybeCustomizeTarget()::: counting wrapper maybe customize target:::c->if->if->target->customize
MethodHandleImpl.CountingWrapper#countDown()::: counting wrapper count down:::c->maybeCustomizeTarget->if->if->return->else->return->else->return
MethodHandleImpl.CountingWrapper#maybeStopCounting(Object)::: counting wrapper maybe stop counting:::wrapper->if->wrapper->countDown->lform->apply->lform->compileToBytecode->wrapper->updateForm
MethodHandleImpl#makeGuardWithTestForm(MethodType)::: method handle impl make guard with test form:::lform->basicType->form->cachedLambdaForm->if->return->THIS_MH->ARG_BASE->ARG_LIMIT->basicType->parameterCount->nameCursor->GET_TEST->GET_TARGET->GET_FALLBACK->GET_COUNTERS->CALL_TEST->PROFILE->TEST->SELECT_ALT->CALL_TARGET->lambdaType->basicType->invokerType->names->arguments->data->BoundMethodHandle->speciesData_LLLL->BoundMethodHandle->speciesData_LLL->withConstraint->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->if->data->getterFunction->new->Name->invokeArgs->Arrays->copyOfRange->testType->basicType->changeReturnType->basicType->new->Name->if->getFunction->new->Name->getConstantHandle->new->NamedFunction->new->Name->new->Name->lambdaType->parameterCount->new->LambdaForm->return->basicType->form->setCachedLambdaForm
MethodHandleImpl#makeGuardWithCatchForm(MethodType):::The LambdaForm shape for catchException combinator is the following: guardWithCatch=Lambda(a0:L,a1:L,a2:L)=>{    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I }  argL0 and argL2 are target and catcher method handles:::lambdaType->basicType->invokerType->lform->basicType->form->cachedLambdaForm->if->return->THIS_MH->ARG_BASE->ARG_LIMIT->basicType->parameterCount->nameCursor->GET_TARGET->GET_CLASS->GET_CATCHER->GET_COLLECT_ARGS->GET_UNBOX_RESULT->BOXED_ARGS->TRY_CATCH->UNBOX_RESULT->names->arguments->data->BoundMethodHandle->speciesData_LLLLL->withConstraint->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->collectArgsType->basicType->changeReturnType->invokeBasic->MethodHandles->basicInvoker->args->invokeBasic->type->parameterCount->new->ObjectArr->System->arraycopy->new->NamedFunction->new->Name->gwcArgs->new->ObjectArr->getFunction->new->Name->invokeBasicUnbox->MethodHandles->MethodType->basicType->rtype->methodType->basicInvoker->unboxArgs->new->ObjectArr->new->Name->lambdaType->parameterCount->new->LambdaForm->return->basicType->form->setCachedLambdaForm
MethodHandleImpl#makeGuardWithCatch(MethodHandle, Class, MethodHandle)::: method handle impl make guard with catch:::type->target->type->form->type->basicType->makeGuardWithCatchForm->varargsType->type->changeReturnType->collectArgs->type->parameterCount->varargsArray->asType->unboxResult->type->returnType->unboxResultHandle->data->BoundMethodHandle->speciesData_LLLLL->mh->try->data->factory->invokeBasic->catch->throw->uncaughtException->finally->return
MethodHandleImpl#guardWithCatch(MethodHandle, Class, MethodHandle, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch).:::try->return->target->asFixedArity->invokeWithArguments->catch->if->exType->isInstance->throw->return->catcher->asFixedArity->prepend->invokeWithArguments->finally
MethodHandleImpl#prepend(Object[], Object...):::Prepend elements to an array.:::nArray->nElems->newArray->new->ObjectArr->System->arraycopy->System->arraycopy->return
MethodHandleImpl#throwException(MethodType)::: method handle impl throw exception:::arity->type->parameterCount->if->mh->type->dropParameterTypes->throwException->MethodHandles->Arrays->type->parameterArray->copyOfRange->dropArguments->return->return->getFunction->resolvedHandle->makePairwiseConvert
MethodHandleImpl#throwException(T)::: method handle impl throw exception:::throw
MethodHandleImpl#fakeMethodHandleInvoke(MemberName)::: method handle impl fake method handle invoke:::idx->switch->method->getName->break->break->throw->method->getName->new->InternalError->mh->if->return->type->MethodType->methodType->throwException->mh->new->UnsupportedOperationException->bindTo->if->method->getInvocationType->mh->type->equals->throw->method->toString->new->InternalError->mh->withInternalMemberName->mh->withVarargs->return
MethodHandleImpl#fakeVarHandleInvoke(MemberName)::: method handle impl fake var handle invoke:::type->MethodType->method->getReturnType->methodType->mh->throwException->mh->new->UnsupportedOperationException->bindTo->if->method->getInvocationType->mh->type->equals->throw->method->toString->new->InternalError->mh->withInternalMemberName->mh->asVarargsCollector->return
MethodHandleImpl#bindCaller(MethodHandle, Class):::Create an alias for the method handle which, when called, appears to be called from the same class loader and protection domain as hostClass:::return->BindCaller->bindCaller
MethodHandleImpl.BindCaller#bindCaller(MethodHandle, Class)::: bind caller bind caller:::if->hostClass->isArray->hostClass->isPrimitive->hostClass->getName->startsWith->throw->new->InternalError->vamh->prepareForInvoker->bccInvoker->CV_makeInjectedInvoker->get->return->bccInvoker->bindTo->restoreToType
MethodHandleImpl.BindCaller#makeInjectedInvoker(Class)::: bind caller make injected invoker:::try->invokerClass->UNSAFE->defineAnonymousClass->return->IMPL_LOOKUP->findStatic->catch->throw->uncaughtException->finally
MethodHandleImpl.BindCaller#prepareForInvoker(MethodHandle)::: bind caller prepare for invoker:::mh->asFixedArity->mt->mh->type->arity->mt->parameterCount->vamh->mh->mt->generic->asType->vamh->internalForm->compileToBytecode->vamh->asSpreader->vamh->internalForm->compileToBytecode->return
MethodHandleImpl.BindCaller#restoreToType(MethodHandle, MethodHandle, Class)::: bind caller restore to type:::type->original->type->mh->vamh->type->parameterCount->asCollector->member->original->internalMemberName->mh->asType->original->isInvokeSpecial->new->WrappedMember->return
MethodHandleImpl.BindCaller#checkInjectedInvoker(Class, Class)::: bind caller check injected invoker:::try->catch->finally->try->invoker->IMPL_LOOKUP->findStatic->vamh->prepareForInvoker->return->invoker->new->ObjectArr->invoke->catch->throw->new->InternalError->finally
MethodHandleImpl.BindCaller#checkCallerClass(Class)::: bind caller check caller class:::actual->Reflection->getCallerClass->if->throw->actual->getName->expected->getName->new->InternalError->return
MethodHandleImpl.BindCaller#generateInvokerTemplate():::Produces byte code for a class that is used as an injected invoker.:::cw->new->ClassWriter->cw->visit->mv->cw->visitMethod->av0->mv->visitAnnotation->av0->visitEnd->mv->visitCode->mv->visitVarInsn->mv->visitVarInsn->mv->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->cw->visitEnd->return->cw->toByteArray
MethodHandleImpl.WrappedMember#internalMemberName()::: wrapped member internal member name:::return
MethodHandleImpl.WrappedMember#internalCallerClass()::: wrapped member internal caller class:::return
MethodHandleImpl.WrappedMember#isInvokeSpecial()::: wrapped member is invoke special:::return
MethodHandleImpl.WrappedMember#getTarget()::: wrapped member get target:::return
MethodHandleImpl.WrappedMember#asTypeUncached(MethodType)::: wrapped member as type uncached:::return->target->asType
MethodHandleImpl#makeWrappedMember(MethodHandle, MemberName, boolean)::: method handle impl make wrapped member:::if->member->target->internalMemberName->equals->target->isInvokeSpecial->return->return->target->type->new->WrappedMember
MethodHandleImpl.IntrinsicMethodHandle#getTarget()::: intrinsic method handle get target:::return
MethodHandleImpl.IntrinsicMethodHandle#intrinsicName()::: intrinsic method handle intrinsic name:::return
MethodHandleImpl.IntrinsicMethodHandle#asTypeUncached(MethodType)::: intrinsic method handle as type uncached:::return->target->asType
MethodHandleImpl.IntrinsicMethodHandle#internalProperties()::: intrinsic method handle internal properties:::return->super->internalProperties
MethodHandleImpl.IntrinsicMethodHandle#asCollector(Class, int)::: intrinsic method handle as collector:::if->resultType->type->type->parameterCount->asCollectorType->newArray->MethodHandleImpl->varargsArray->return->newArray->asType->return->super->asCollector
MethodHandleImpl#makeIntrinsic(MethodHandle, Intrinsic)::: method handle impl make intrinsic:::if->target->intrinsicName->return->return->new->IntrinsicMethodHandle
MethodHandleImpl#makeIntrinsic(MethodType, LambdaForm, Intrinsic)::: method handle impl make intrinsic:::return->SimpleMethodHandle->make->new->IntrinsicMethodHandle
MethodHandleImpl#findCollector(String, int, Class, Class...)::: method handle impl find collector:::type->MethodType->genericMethodType->changeReturnType->insertParameterTypes->try->return->IMPL_LOOKUP->findStatic->catch->return->finally
MethodHandleImpl#makeArray(Object...)::: method handle impl make array:::return
MethodHandleImpl#array()::: method handle impl array:::return
MethodHandleImpl#array(Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#array(Object, Object, Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl array:::return->makeArray
MethodHandleImpl#fillNewArray(Integer, Object[])::: method handle impl fill new array:::a->new->ObjectArr->fillWithArguments->return
MethodHandleImpl#fillNewTypedArray(Object[], Integer, Object[])::: method handle impl fill new typed array:::a->Arrays->copyOf->fillWithArguments->return
MethodHandleImpl#fillWithArguments(Object[], int, Object...)::: method handle impl fill with arguments:::System->arraycopy
MethodHandleImpl#fillArray(Integer, Object[], Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#fillArray(Integer, Object[], Object, Object, Object, Object, Object, Object, Object, Object, Object, Object)::: method handle impl fill array:::fillWithArguments->return
MethodHandleImpl#getFillArray(int)::: method handle impl get fill array:::mh->if->return->findCollector->return
MethodHandleImpl#copyAsPrimitiveArray(Wrapper, Object...)::: method handle impl copy as primitive array:::a->w->makeArray->w->copyArrayUnboxing->return
MethodHandleImpl#varargsArray(int):::Return a method handle that takes the indicated number of Object  arguments and returns an Object array of them, as if for varargs.:::mh->if->return->if->findCollector->else->getConstantHandle->getConstantHandle->buildVarargsArray->makeIntrinsic->return
MethodHandleImpl#assertCorrectArity(MethodHandle, int)::: method handle impl assert correct arity:::return
MethodHandleImpl#identity(T[])::: method handle impl identity:::return
MethodHandleImpl#buildVarargsArray(MethodHandle, MethodHandle, int)::: method handle impl build varargs array:::leftLen->Math->min->rightLen->leftCollector->newArray->bindTo->leftCollector->asCollector->mh->if->rightFiller->fillToRight->if->mh->getConstantHandle->equals->else->MethodHandles->collectArguments->if->mh->getConstantHandle->equals->else->MethodHandles->collectArguments->return
MethodHandleImpl#fillToRight(int):::fill_array_to_right(N).invoke(a, argL..arg[N-1])  fills a[L]..a[N-1] with corresponding arguments,  and then returns a:::filler->if->return->buildFiller->return
MethodHandleImpl#buildFiller(int)::: method handle impl build filler:::if->return->getConstantHandle->CHUNK->rightLen->midLen->if->if->for->j->if->midFill->fillToRight->rightFill->getFillArray->bindTo->if->return->else->return->MethodHandles->collectArguments
MethodHandleImpl#varargsArray(Class, int):::Return a method handle that takes the indicated number of  typed arguments and returns an array of them:::elemType->arrayType->getComponentType->if->throw->new->IllegalArgumentException->if->slots->MAX_ARRAY_SLOTS->if->elemType->isPrimitive->Wrapper->forPrimitiveType->stackSlots->if->throw->arrayType->getSimpleName->new->IllegalArgumentException->if->return->varargsArray->cache->get->mh->if->return->if->example->arrayType->getComponentType->newInstance->MethodHandles->constant->else->if->elemType->isPrimitive->builder->getConstantHandle->producer->buildArrayProducer->buildVarargsArray->else->objArrayType->arrayType->asSubclass->example->Arrays->copyOf->builder->getConstantHandle->bindTo->producer->getConstantHandle->buildVarargsArray->mh->MethodType->Collections->nCopies->methodType->asType->makeIntrinsic->if->return
MethodHandleImpl#buildArrayProducer(Class)::: method handle impl build array producer:::elemType->arrayType->getComponentType->return->getConstantHandle->Wrapper->forPrimitiveType->bindTo
MethodHandleImpl#assertSame(Object, Object)::: method handle impl assert same:::if->msg->String->format->throw->newInternalError
MethodHandleImpl#getFunction(byte)::: method handle impl get function:::nf->if->return->return->createFunction
MethodHandleImpl#createFunction(byte)::: method handle impl create function:::try->switch->return->getDeclaredMethod->new->NamedFunction->return->getDeclaredMethod->new->NamedFunction->return->getDeclaredMethod->new->NamedFunction->return->getDeclaredMethod->new->NamedFunction->return->getDeclaredMethod->new->NamedFunction->return->getDeclaredMethod->new->NamedFunction->throw->new->InternalError->catch->throw->newInternalError->finally
MethodHandleImpl#unboxResultHandle(Class):::Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore().:::if->returnType->isPrimitive->if->return->ValueConversions->ignore->else->w->Wrapper->forPrimitiveType->return->ValueConversions->unboxExact->else->return->MethodHandles->identity
MethodHandleImpl#makeLoop(Class, List>, List, List, List, List):::Assembles a loop method handle from the given handles and type information.:::type->MethodType->methodType->initClauseTypes->init->stream->h->type->returnType->map->BasicType->basicType->map->BasicType[]->new->toArray->form->type->basicType->makeLoopForm->varargsType->type->changeReturnType->collectArgs->type->parameterCount->varargsArray->asType->unboxResult->unboxResultHandle->clauseData->new->MethodHandleArrs->toArray->toArray->toArray->toArray->new->LoopClauses->data->BoundMethodHandle->speciesData_LLL->mh->try->data->factory->invokeBasic->catch->throw->uncaughtException->finally->return
MethodHandleImpl#toArray(List)::: method handle impl to array:::return->l->new->MethodHandleArr->toArray
MethodHandleImpl#makeLoopForm(MethodType, BasicType[]):::Loops introduce some complexity as they can have additional local state:::lambdaType->basicType->invokerType->THIS_MH->ARG_BASE->ARG_LIMIT->basicType->parameterCount->nameCursor->GET_CLAUSE_DATA->GET_COLLECT_ARGS->GET_UNBOX_RESULT->BOXED_ARGS->LOOP->UNBOX_RESULT->lform->basicType->form->cachedLambdaForm->if->names->arguments->data->BoundMethodHandle->speciesData_LLL->withConstraint->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->collectArgsType->basicType->changeReturnType->invokeBasic->MethodHandles->basicInvoker->args->invokeBasic->type->parameterCount->new->ObjectArr->System->arraycopy->new->NamedFunction->new->Name->lArgs->new->ObjectArr->getFunction->new->Name->invokeBasicUnbox->MethodHandles->MethodType->basicType->rtype->methodType->basicInvoker->unboxArgs->new->ObjectArr->new->Name->basicType->form->lambdaType->parameterCount->new->LambdaForm->setCachedLambdaForm->return->lform->editor->noteLoopLocalTypesForm
MethodHandleImpl.LoopClauses#toString()::: loop clauses to string:::sb->new->StringBuffer->for->i->sb->append->return->sb->toString
MethodHandleImpl#loop(BasicType[], LoopClauses, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitLoop(int)).:::init->step->pred->fini->varSize->Stream->of->h->type->returnType->filter->count->nArgs->type->parameterCount->varsAndArgs->new->ObjectArr->for->i->v->System->arraycopy->nSteps->for
MethodHandleImpl#countedLoopPredicate(int, int):::This method is bound as the predicate in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops.:::return
MethodHandleImpl#countedLoopStep(int, int):::This method is bound as the step function in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops to increment the counter.:::return
MethodHandleImpl#initIterator(Iterable):::This is bound to initialize the loop-local iterator in MethodHandles#iteratedLoop iterating loops.:::return->it->iterator
MethodHandleImpl#iteratePredicate(Iterator):::This method is bound as the predicate in MethodHandles#iteratedLoop iterating loops.:::return->it->hasNext
MethodHandleImpl#iterateNext(Iterator):::This method is bound as the step for retrieving the current value from the iterator in MethodHandles#iteratedLoop iterating loops.:::return->it->next
MethodHandleImpl#makeTryFinally(MethodHandle, MethodHandle, Class, List>):::Makes a try-finally handle that conforms to the type constraints.:::type->MethodType->methodType->form->type->basicType->makeTryFinallyForm->varargsType->type->changeReturnType->collectArgs->type->parameterCount->varargsArray->asType->unboxResult->unboxResultHandle->data->BoundMethodHandle->speciesData_LLLL->mh->try->data->factory->invokeBasic->catch->throw->uncaughtException->finally->return
MethodHandleImpl#makeTryFinallyForm(MethodType):::The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in a1, and a reference return type, with the return value represented by t8): tryFinally=Lambda(a0:L,a1:L)=>{    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L    // unbox the result; return the result }  argL0 and argL1 are the target and cleanup method handles:::lambdaType->basicType->invokerType->lform->basicType->form->cachedLambdaForm->if->return->THIS_MH->ARG_BASE->ARG_LIMIT->basicType->parameterCount->nameCursor->GET_TARGET->GET_CLEANUP->GET_COLLECT_ARGS->GET_UNBOX_RESULT->BOXED_ARGS->TRY_FINALLY->UNBOX_RESULT->names->arguments->data->BoundMethodHandle->speciesData_LLLL->withConstraint->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->data->getterFunction->new->Name->collectArgsType->basicType->changeReturnType->invokeBasic->MethodHandles->basicInvoker->args->invokeBasic->type->parameterCount->new->ObjectArr->System->arraycopy->new->NamedFunction->new->Name->tfArgs->new->ObjectArr->getFunction->new->Name->invokeBasicUnbox->MethodHandles->MethodType->basicType->rtype->methodType->basicInvoker->unboxArgs->new->ObjectArr->new->Name->lambdaType->parameterCount->new->LambdaForm->return->basicType->form->setCachedLambdaForm
MethodHandleImpl#tryFinally(MethodHandle, MethodHandle, Object...):::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitTryFinally emitTryFinally).:::t->r->try->target->invokeWithArguments->catch->throw->finally->args->target->type->returnType->prepend->prepend->cleanup->invokeWithArguments->return
MethodHandleImpl#getConstantHandle(int)::: method handle impl get constant handle:::handle->if->return->return->makeConstantHandle->setCachedHandle
MethodHandleImpl#setCachedHandle(int, MethodHandle)::: method handle impl set cached handle:::prev->if->return->return
MethodHandleImpl#makeConstantHandle(int)::: method handle impl make constant handle:::try->switch->return->IMPL_LOOKUP->MethodType->methodType->findVirtual->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->return->IMPL_LOOKUP->MethodType->methodType->findStatic->catch->throw->newInternalError->finally->throw->newInternalError
MethodHandleInfo#getReferenceKind():::Returns the reference kind of the cracked method handle, which in turn determines whether the method handle's underlying member was a constructor, method, or field:::
MethodHandleInfo#getDeclaringClass():::Returns the class in which the cracked method handle's underlying member was defined.:::
MethodHandleInfo#getName():::Returns the name of the cracked method handle's underlying member:::
MethodHandleInfo#getMethodType():::Returns the nominal type of the cracked symbolic reference, expressed as a method type:::
MethodHandleInfo#reflectAs(Class, Lookup):::Reflects the underlying member as a method, constructor, or field object:::
MethodHandleInfo#getModifiers():::Returns the access modifiers of the underlying member.:::
MethodHandleInfo#isVarArgs()::: method handle info is var args:::if->MethodHandleNatives->getReferenceKind->refKindIsField->return->ACC_VARARGS->return->Modifier->getModifiers->isTransient
MethodHandleInfo#referenceKindToString(int):::Returns the descriptive name of the given reference kind, as defined in the table above:::if->MethodHandleNatives->refKindIsValid->throw->newIllegalArgumentException->return->MethodHandleNatives->refKindName
MethodHandleInfo#toString(int, Class, String, MethodType):::Returns a string representation for a MethodHandleInfo, given the four parts of its symbolic reference:::Objects->requireNonNull->Objects->requireNonNull->return->String->referenceKindToString->defc->getName->format
MethodHandleNatives#init(MemberName, Object)::: method handle natives init:::
MethodHandleNatives#expand(MemberName)::: method handle natives expand:::
MethodHandleNatives#resolve(MemberName, Class, boolean)::: method handle natives resolve:::
MethodHandleNatives#getMembers(Class, String, String, int, Class, int, MemberName[])::: method handle natives get members:::
MethodHandleNatives#objectFieldOffset(MemberName)::: method handle natives object field offset:::
MethodHandleNatives#staticFieldOffset(MemberName)::: method handle natives static field offset:::
MethodHandleNatives#staticFieldBase(MemberName)::: method handle natives static field base:::
MethodHandleNatives#getMemberVMInfo(MemberName)::: method handle natives get member info:::
MethodHandleNatives#setCallSiteTargetNormal(CallSite, MethodHandle):::Tell the JVM that we need to change the target of a CallSite.:::
MethodHandleNatives#setCallSiteTargetVolatile(CallSite, MethodHandle)::: method handle natives set call site target volatile:::
MethodHandleNatives#copyOutBootstrapArguments(Class, int[], int, int, Object[], int, boolean, Object)::: method handle natives copy out bootstrap arguments:::
MethodHandleNatives.CallSiteContext#make(CallSite)::: call site context make:::newContext->new->CallSiteContext->CleanerFactory->cleaner->register->return
MethodHandleNatives.CallSiteContext#run()::: call site context run:::MethodHandleNatives->clearCallSiteContext
MethodHandleNatives#clearCallSiteContext(CallSiteContext):::Invalidate all recorded nmethods.:::
MethodHandleNatives#registerNatives()::: method handle natives register natives:::
MethodHandleNatives#refKindIsValid(int)::: method handle natives ref kind is valid:::return
MethodHandleNatives#refKindIsField(byte)::: method handle natives ref kind is field:::return
MethodHandleNatives#refKindIsGetter(byte)::: method handle natives ref kind is getter:::return
MethodHandleNatives#refKindIsSetter(byte)::: method handle natives ref kind is setter:::return->refKindIsField->refKindIsGetter
MethodHandleNatives#refKindIsMethod(byte)::: method handle natives ref kind is method:::return->refKindIsField
MethodHandleNatives#refKindIsConstructor(byte)::: method handle natives ref kind is constructor:::return
MethodHandleNatives#refKindHasReceiver(byte)::: method handle natives ref kind has receiver:::return
MethodHandleNatives#refKindIsStatic(byte)::: method handle natives ref kind is static:::return->refKindHasReceiver
MethodHandleNatives#refKindDoesDispatch(byte)::: method handle natives ref kind does dispatch:::return
MethodHandleNatives#refKindName(byte)::: method handle natives ref kind name:::switch->return->return->return->return->return->return->return->return->return->return
MethodHandleNatives#getNamedCon(int, Object[])::: method handle natives get named con:::
MethodHandleNatives#verifyConstants()::: method handle natives verify constants:::box->for->i->return
MethodHandleNatives#linkCallSite(Object, int, Object, Object, Object, Object, Object[]):::The JVM is linking an invokedynamic instruction:::bootstrapMethod->caller->name->nameObj->toString->intern->type->if->return->linkCallSiteImpl->return->linkCallSiteTracing
MethodHandleNatives#linkCallSiteImpl(Class, MethodHandle, String, MethodType, Object, Object[])::: method handle natives link call site impl:::callSite->CallSite->makeSite->if->callSite->dynamicInvoker->return->Invokers->linkToTargetMethod->else->return->Invokers->linkToCallSiteMethod
MethodHandleNatives#linkCallSiteTracing(Class, MethodHandle, String, MethodType, Object, Object[])::: method handle natives link call site tracing:::bsmReference->bootstrapMethod->internalMemberName->if->staticArglist->staticArglistForTrace->caller->getName->println->try->res->linkCallSiteImpl->println->return->catch->ex->printStackTrace->println->throw->finally
MethodHandleNatives#linkDynamicConstant(Object, int, Object, Object, Object, Object)::: method handle natives link dynamic constant:::bootstrapMethod->caller->name->nameObj->toString->intern->type->if->return->linkDynamicConstantImpl->return->linkDynamicConstantTracing
MethodHandleNatives#linkDynamicConstantImpl(Class, MethodHandle, String, Class, Object)::: method handle natives link dynamic constant impl:::return->ConstantBootstraps->makeConstant
MethodHandleNatives#staticArglistForTrace(Object)::: method handle natives static arglist for trace:::if->return->asList->if->return->toString->if->return->return
MethodHandleNatives#linkDynamicConstantTracing(Class, MethodHandle, String, Class, Object)::: method handle natives link dynamic constant tracing:::bsmReference->bootstrapMethod->internalMemberName->if->staticArglist->staticArglistForTrace->caller->getName->println->try->res->linkDynamicConstantImpl->println->return->catch->ex->printStackTrace->println->throw->finally
MethodHandleNatives#staticArgumentsPulled(Object):::The JVM is requesting pull-mode bootstrap when it provides  a tuple of the form int[]{ argc, vmindex }:::return
MethodHandleNatives#isPullModeBSM(MethodHandle):::A BSM runs in pull-mode if and only if its sole arguments are (Lookup, BootstrapCallInfo), or can be converted pairwise to those types, and it is not of variable arity:::return
MethodHandleNatives#findMethodHandleType(Class, Class[]):::The JVM wants a pointer to a MethodType:::return->MethodType->makeImpl
MethodHandleNatives#linkMethod(Class, int, Class, String, Object, Object[]):::The JVM wants to link a call site that requires a dynamic type check:::if->return->linkMethodImpl->return->linkMethodTracing
MethodHandleNatives#linkMethodImpl(Class, int, Class, String, Object, Object[])::: method handle natives link method impl:::try->if->if->return->Invokers->fixMethodType->methodHandleInvokeLinkerMethod->else->if->return->fixMethodType->varHandleOperationLinkerMethod->catch->throw->throw->ex->getMessage->new->LinkageError->finally->throw->defc->getName->new->LinkageError
MethodHandleNatives#fixMethodType(Class, Object)::: method handle natives fix method type:::if->return->else->return->MethodType->callerClass->getClassLoader->fromDescriptor
MethodHandleNatives#linkMethodTracing(Class, int, Class, String, Object, Object[])::: method handle natives link method tracing:::defc->getName->Integer->toHexString->println->try->res->linkMethodImpl->println->return->catch->println->throw->finally
MethodHandleNatives#varHandleOperationLinkerMethod(String, MethodType, Object[]):::Obtain the method to link to the VarHandle operation:::sigType->mtype->basicType->ak->try->valueFromMethodName->catch->throw->MethodHandleStatics->newInternalError->finally->ad->ordinal->ak->ordinal->new->VarHandle.AccessDescriptor->if->guardReturnType->sigType->returnType->if->if->mtype->returnType->throw->newNoSuchMethodErrorOnVarHandle->guardParams->sigType->parameterCount->new->Class<?>Arr->for->i->sigType->parameterCount->guardType->MethodType->makeImpl->linker->getVarHandleGuardMethodName->new->MemberName->MemberName->getFactory->resolveOrNull->if->return->return->Invokers->varHandleInvokeLinkerMethod
MethodHandleNatives#getVarHandleGuardMethodName(MethodType)::: method handle natives get var handle guard method name:::prefix->sb->prefix->length->guardType->parameterCount->new->StringBuilder->sb->append->for->i->guardType->parameterCount->sb->append->guardType->returnType->getCharType->append->return->sb->toString
MethodHandleNatives#getCharType(Class)::: method handle natives get char type:::return->Wrapper->forBasicType->basicTypeChar
MethodHandleNatives#newNoSuchMethodErrorOnVarHandle(String, MethodType)::: method handle natives new no such method error on var handle:::return->new->NoSuchMethodError
MethodHandleNatives#linkMethodHandleConstant(Class, int, Class, String, Object):::The JVM is resolving a CONSTANT_MethodHandle CP entry:::try->lookup->IMPL_LOOKUP->in->return->lookup->linkMethodHandleConstant->catch->throw->mapLookupExceptionToError->finally
MethodHandleNatives#mapLookupExceptionToError(ReflectiveOperationException):::Map a reflective exception to a linkage error.:::err->if->cause->ex->getCause->if->return->else->ex->getMessage->new->IllegalAccessError->else->if->ex->getMessage->new->NoSuchMethodError->else->if->ex->getMessage->new->NoSuchFieldError->else->new->IncompatibleClassChangeError->return->initCauseFrom
MethodHandleNatives#initCauseFrom(E, Exception):::Use best possible cause for err.initCause(), substituting the cause for err itself if the cause has the same (or better) type.:::th->ex->getCause->Eclass->err->getClass->if->Eclass->isInstance->return->Eclass->cast->err->initCause->return
MethodHandleNatives#isCallerSensitive(MemberName):::Is this method a caller-sensitive method? I.e., does it call Reflection.getCallerClass or a similar method to ask about the identity of its caller?:::if->mem->isInvocable->return->return->mem->isCallerSensitive->canBeCalledVirtual
MethodHandleNatives#canBeCalledVirtual(MemberName)::: method handle natives can be called virtual:::switch->mem->getName->return->canBeCalledVirtual->return
MethodHandleNatives#canBeCalledVirtual(MemberName, Class)::: method handle natives can be called virtual:::symbolicRefClass->symbolicRef->getDeclaringClass->if->return->if->symbolicRef->isStatic->symbolicRef->isPrivate->return->return->definingClass->isAssignableFrom->symbolicRefClass->isInterface
MethodHandleProxies#asInterfaceInstance(Class, MethodHandle)::: method handle proxies as interface instance:::if->intfc->isInterface->Modifier->intfc->getModifiers->isPublic->throw->intfc->getName->newIllegalArgumentException->mh->if->System->getSecurityManager->caller->Reflection->getCallerClass->ccl->caller->getClassLoader->ReflectUtil->checkProxyPackageAccess->bindCaller->else->proxyLoader->intfc->getClassLoader->if->cl->Thread->currentThread->getContextClassLoader->ClassLoader->getSystemClassLoader->methods->getSingleNameMethods->if->throw->intfc->getName->newIllegalArgumentException->vaTargets->new->MethodHandleArr->for->i->defaultMethodMap->hasDefaultMethods->new->ConcurrentHashMap<>->ih->new->InvocationHandler->proxy->if->System->getSecurityManager->loader->AccessController->new->PrivilegedAction<>->doPrivileged->else->Proxy->new->Class<?>Arr->newProxyInstance->return->intfc->cast
MethodHandleProxies#bindCaller(MethodHandle, Class)::: method handle proxies bind caller:::return->MethodHandleImpl->bindCaller->target->isVarargsCollector->withVarargs
MethodHandleProxies#isWrapperInstance(Object):::Determines if the given object was produced by a call to #asInterfaceInstance asInterfaceInstance.:::return
MethodHandleProxies#asWrapperInstance(Object)::: method handle proxies as wrapper instance:::try->if->return->catch->finally->throw->newIllegalArgumentException
MethodHandleProxies#wrapperInstanceTarget(Object):::Produces or recovers a target method handle which is behaviorally equivalent to the unique method of this wrapper instance:::return->asWrapperInstance->getWrapperInstanceTarget
MethodHandleProxies#wrapperInstanceType(Object):::Recovers the unique single-method interface type for which this wrapper instance was created:::return->asWrapperInstance->getWrapperInstanceType
MethodHandleProxies#isObjectMethod(Method)::: method handle proxies is object method:::switch->m->getName->return->m->getReturnType->m->getParameterTypes->return->m->getReturnType->m->getParameterTypes->return->m->getReturnType->m->getParameterTypes->m->getParameterTypes->return
MethodHandleProxies#callObjectMethod(Object, Method, Object[])::: method handle proxies call object method:::switch->m->getName->return->self->getClass->getName->Integer->self->hashCode->toHexString->return->System->identityHashCode->return->return
MethodHandleProxies#getSingleNameMethods(Class)::: method handle proxies get single name methods:::methods->new->ArrayList<>->uniqueName->foreach->intfc->getMethods->if->isObjectMethod->continue->if->Modifier->m->getModifiers->isAbstract->continue->mname->m->getName->if->else->if->uniqueName->equals->return->methods->add->if->return->return->methods->methods->size->new->MethodArr->toArray
MethodHandleProxies#isDefaultMethod(Method)::: method handle proxies is default method:::return->Modifier->m->getModifiers->isAbstract
MethodHandleProxies#hasDefaultMethods(Class)::: method handle proxies has default methods:::foreach->intfc->getMethods->if->isObjectMethod->Modifier->m->getModifiers->isAbstract->return->return
MethodHandleProxies#callDefaultMethod(ConcurrentHashMap, Object, Class, Method, Object[])::: method handle proxies call default method:::dmh->defaultMethodMap->try->mh->mk->getName->MethodType->mk->getReturnType->mk->getParameterTypes->methodType->self->getClass->findSpecial->return->mh->mk->getParameterCount->asSpreader->catch->throw->new->InternalError->finally->computeIfAbsent->return->dmh->invoke
MethodHandles#lookup():::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors of the caller:::return->Reflection->getCallerClass->new->Lookup
MethodHandles#reflected$lookup():::This reflected$lookup method is the alternate implementation of the lookup method when being invoked by reflection.:::caller->Reflection->getCallerClass->if->caller->getClassLoader->throw->newIllegalArgumentException->return->new->Lookup
MethodHandles#publicLookup():::Returns a Lookup lookup object which is trusted minimally:::return
MethodHandles#privateLookupIn(Class, Lookup):::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors, including  private access, on a target class:::sm->System->getSecurityManager->if->sm->checkPermission->if->targetClass->isPrimitive->throw->new->IllegalArgumentException->if->targetClass->isArray->throw->new->IllegalArgumentException->targetModule->targetClass->getModule->callerModule->lookup->lookupClass->getModule->if->callerModule->canRead->throw->new->IllegalAccessException->if->targetModule->isNamed->pn->targetClass->getPackageName->if->targetModule->isOpen->throw->new->IllegalAccessException->if->lookup->lookupModes->throw->new->IllegalAccessException->if->callerModule->isNamed->targetModule->isNamed->logger->IllegalAccessLogger->illegalAccessLogger->if->logger->logIfOpenedForIllegalAccess->return->new->Lookup
MethodHandles#reflectAs(Class, MethodHandle):::Performs an unchecked "crack" of a direct method handle:::smgr->System->getSecurityManager->if->smgr->checkPermission->lookup->return->lookup->revealDirect->reflectAs
MethodHandles.Lookup#fixmods(int)::: lookup fixmods:::return
MethodHandles.Lookup#lookupClass():::Tells which class is performing the lookup:::return
MethodHandles.Lookup#lookupClassOrNull()::: lookup lookup class or null:::return
MethodHandles.Lookup#lookupModes():::Tells which access-protection classes of members this lookup object can produce:::return
MethodHandles.Lookup#in(Class):::Creates a lookup on the specified new lookup class:::Objects->requireNonNull->if->return->new->Lookup->if->return->newModes->if->VerifyAccess->isSameModule->if->getModule->isNamed->else->if->VerifyAccess->isSamePackage->if->VerifyAccess->isSamePackageMember->if->VerifyAccess->isClassAccessible->checkUnprivilegedlookupClass->return->new->Lookup
MethodHandles.Lookup#dropLookupMode(int):::Creates a lookup on the same lookup class which this lookup object finds members, but with a lookup mode that has lost the given lookup mode:::oldModes->lookupModes->newModes->switch->break->break->break->break->throw->new->IllegalArgumentException->if->return->return->lookupClass->new->Lookup
MethodHandles.Lookup#defineClass(byte[]):::Defines a class to the same class loader and in the same runtime package and java.security.ProtectionDomain protection domain as this lookup's #lookupClass() lookup class:::sm->System->getSecurityManager->if->sm->new->RuntimePermission->checkPermission->if->lookupModes->throw->new->IllegalAccessException->bytes->clone->name->try->reader->new->ClassReader->reader->getClassName->catch->cfe->new->ClassFormatError->cfe->initCause->throw->finally->cn->pn->index->name->lastIndexOf->if->else->name->replace->cn->substring->if->pn->lookupClass->getPackageName->equals->throw->new->IllegalArgumentException->loader->lookupClass->getClassLoader->pd->lookupClassProtectionDomain->source->clazz->SharedSecrets->getJavaLangAccess->defineClass->return
MethodHandles.Lookup#lookupClassProtectionDomain()::: lookup lookup class protection domain:::pd->if->protectionDomain->return
MethodHandles.Lookup#protectionDomain(Class)::: lookup protection domain:::pa->clazz->getProtectionDomain->return->AccessController->doPrivileged
MethodHandles.Lookup#checkUnprivilegedlookupClass(Class)::: lookup check unprivilegedlookup class:::name->lookupClass->getName->if->name->startsWith->throw->newIllegalArgumentException
MethodHandles.Lookup#toString():::Displays the name of the class from which lookups are to be made:::cname->lookupClass->getName->switch->return->return->return->return->return->return->return->return->Integer->toHexString->return
MethodHandles.Lookup#findStatic(Class, String, MethodType):::Produces a method handle for a static method:::method->resolveOrFail->return->findBoundCallerClass->getDirectMethod
MethodHandles.Lookup#findVirtual(Class, String, MethodType):::Produces a method handle for a virtual method:::if->mh->findVirtualForMH->if->return->else->if->mh->findVirtualForVH->if->return->refKind->refc->isInterface->method->resolveOrFail->return->findBoundCallerClass->getDirectMethod
MethodHandles.Lookup#findVirtualForMH(String, MethodType)::: lookup find virtual for h:::if->equals->return->invoker->if->equals->return->exactInvoker->return
MethodHandles.Lookup#findVirtualForVH(String, MethodType)::: lookup find virtual for h:::try->return->valueFromMethodName->varHandleInvoker->catch->return->finally
MethodHandles.Lookup#findConstructor(Class, MethodType):::Produces a method handle which creates an object and initializes it, using the constructor of the specified type:::if->refc->isArray->throw->refc->getName->new->NoSuchMethodException->name->ctor->resolveOrFail->return->getDirectConstructor
MethodHandles.Lookup#findClass(String):::Looks up a class by name from the lookup context defined by this Lookup object:::targetClass->Class->lookupClass->getClassLoader->forName->return->accessClass
MethodHandles.Lookup#accessClass(Class):::Determines if a class can be accessed from the lookup context defined by this Lookup object:::if->VerifyAccess->isClassAccessible->throw->new->MemberName->makeAccessException->checkSecurityManager->return
MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class):::Produces an early-bound method handle for a virtual method:::checkSpecialCaller->specialLookup->this->in->method->specialLookup->resolveOrFail->return->specialLookup->findBoundCallerClass->getDirectMethod
MethodHandles.Lookup#findGetter(Class, String, Class):::Produces a method handle giving read access to a non-static field:::field->resolveOrFail->return->getDirectField
MethodHandles.Lookup#findSetter(Class, String, Class):::Produces a method handle giving write access to a non-static field:::field->resolveOrFail->return->getDirectField
MethodHandles.Lookup#findVarHandle(Class, String, Class):::Produces a VarHandle giving access to a non-static field name of type type declared in a class of type recv:::getField->resolveOrFail->putField->resolveOrFail->return->getFieldVarHandle
MethodHandles.Lookup#findStaticGetter(Class, String, Class):::Produces a method handle giving read access to a static field:::field->resolveOrFail->return->getDirectField
MethodHandles.Lookup#findStaticSetter(Class, String, Class):::Produces a method handle giving write access to a static field:::field->resolveOrFail->return->getDirectField
MethodHandles.Lookup#findStaticVarHandle(Class, String, Class):::Produces a VarHandle giving access to a static field name of type type declared in a class of type decl:::getField->resolveOrFail->putField->resolveOrFail->return->getFieldVarHandle
MethodHandles.Lookup#bind(Object, String, MethodType):::Produces an early-bound method handle for a non-static method:::refc->receiver->getClass->method->resolveOrFail->mh->findBoundCallerClass->getDirectMethodNoRestrictInvokeSpecial->if->mh->type->leadingReferenceParameter->receiver->getClass->isAssignableFrom->throw->mh->type->leadingReferenceParameter->getName->receiver->getClass->getName->new->IllegalAccessException->return->mh->bindArgumentL->setVarargs
MethodHandles.Lookup#unreflect(Method):::Makes a direct method handle to m, if the lookup class has permission:::if->m->getDeclaringClass->mh->unreflectForMH->if->return->if->m->getDeclaringClass->mh->unreflectForVH->if->return->method->new->MemberName->refKind->method->getReferenceKind->if->lookup->m->isAccessible->return->lookup->method->getDeclaringClass->findBoundCallerClass->getDirectMethodNoSecurityManager
MethodHandles.Lookup#unreflectForMH(Method)::: lookup unreflect for h:::if->MemberName->m->getName->isMethodHandleInvokeName->return->MethodHandleImpl->new->MemberName->fakeMethodHandleInvoke->return
MethodHandles.Lookup#unreflectForVH(Method)::: lookup unreflect for h:::if->MemberName->m->getName->isVarHandleMethodInvokeName->return->MethodHandleImpl->new->MemberName->fakeVarHandleInvoke->return
MethodHandles.Lookup#unreflectSpecial(Method, Class):::Produces a method handle for a reflected method:::checkSpecialCaller->specialLookup->this->in->method->new->MemberName->return->specialLookup->method->getDeclaringClass->findBoundCallerClass->getDirectMethodNoSecurityManager
MethodHandles.Lookup#unreflectConstructor(Constructor):::Produces a method handle for a reflected constructor:::ctor->new->MemberName->lookup->c->isAccessible->return->lookup->ctor->getDeclaringClass->getDirectConstructorNoSecurityManager
MethodHandles.Lookup#unreflectGetter(Field):::Produces a method handle giving read access to a reflected field:::return->unreflectField
MethodHandles.Lookup#unreflectField(Field, boolean)::: lookup unreflect field:::field->new->MemberName->lookup->f->isAccessible->return->lookup->field->getReferenceKind->f->getDeclaringClass->getDirectFieldNoSecurityManager
MethodHandles.Lookup#unreflectSetter(Field):::Produces a method handle giving write access to a reflected field:::return->unreflectField
MethodHandles.Lookup#unreflectVarHandle(Field):::Produces a VarHandle giving access to a reflected field f of type T declared in a class of type R:::getField->new->MemberName->putField->new->MemberName->return->getField->getReferenceKind->putField->getReferenceKind->f->getDeclaringClass->getFieldVarHandleNoSecurityManager
MethodHandles.Lookup#revealDirect(MethodHandle):::Cracks a direct method handle created by this lookup object or a similar one:::member->target->internalMemberName->if->member->isResolved->member->isMethodHandleInvoke->member->isVarHandleMethodInvoke->throw->newIllegalArgumentException->defc->member->getDeclaringClass->refKind->member->getReferenceKind->if->target->isInvokeSpecial->if->defc->isInterface->try->checkAccess->checkSecurityManager->catch->throw->new->IllegalArgumentException->finally->if->member->isCallerSensitive->callerClass->target->internalCallerClass->if->hasPrivateAccess->lookupClass->throw->new->IllegalArgumentException->return->new->InfoFromMemberName
MethodHandles.Lookup#resolveOrFail(byte, Class, String, Class)::: lookup resolve or fail:::checkSymbolicClass->Objects->requireNonNull->Objects->requireNonNull->return->IMPL_NAMES->new->MemberName->lookupClassOrNull->resolveOrFail
MethodHandles.Lookup#resolveOrFail(byte, Class, String, MethodType)::: lookup resolve or fail:::checkSymbolicClass->Objects->requireNonNull->Objects->requireNonNull->checkMethodName->return->IMPL_NAMES->new->MemberName->lookupClassOrNull->resolveOrFail
MethodHandles.Lookup#resolveOrFail(byte, MemberName)::: lookup resolve or fail:::member->getDeclaringClass->checkSymbolicClass->Objects->member->getName->requireNonNull->Objects->member->getType->requireNonNull->return->IMPL_NAMES->lookupClassOrNull->resolveOrFail
MethodHandles.Lookup#resolveOrNull(byte, MemberName)::: lookup resolve or null:::if->member->getDeclaringClass->isClassAccessible->return->Objects->member->getName->requireNonNull->Objects->member->getType->requireNonNull->return->IMPL_NAMES->lookupClassOrNull->resolveOrNull
MethodHandles.Lookup#checkSymbolicClass(Class)::: lookup check symbolic class:::if->isClassAccessible->throw->new->MemberName->makeAccessException
MethodHandles.Lookup#isClassAccessible(Class)::: lookup is class accessible:::Objects->requireNonNull->caller->lookupClassOrNull->return->VerifyAccess->isClassAccessible
MethodHandles.Lookup#checkMethodName(byte, String):::Check name for an illegal leading "&lt;" character.:::if->name->startsWith->throw->new->NoSuchMethodException
MethodHandles.Lookup#findBoundCallerClass(MemberName):::Find my trustable caller class if m is a caller sensitive method:::callerClass->if->MethodHandleNatives->isCallerSensitive->if->hasPrivateAccess->else->throw->new->IllegalAccessException->return
MethodHandles.Lookup#hasPrivateAccess():::Returns true if this lookup has PRIVATE access.:::return
MethodHandles.Lookup#checkSecurityManager(Class, MemberName):::Perform necessary access checks:::smgr->System->getSecurityManager->if->return->if->return->fullPowerLookup->hasPrivateAccess->if->VerifyAccess->classLoaderIsAncestor->ReflectUtil->checkPackageAccess->if->if->smgr->checkPermission->return->if->m->isPublic->return->if->smgr->checkPermission->defc->m->getDeclaringClass->if->ReflectUtil->checkPackageAccess
MethodHandles.Lookup#checkMethod(byte, Class, MemberName)::: lookup check method:::wantStatic->message->if->m->isConstructor->else->if->m->isMethod->else->if->m->isStatic->else->checkAccess->return->throw->m->makeAccessException
MethodHandles.Lookup#checkField(byte, Class, MemberName)::: lookup check field:::wantStatic->MethodHandleNatives->refKindHasReceiver->message->if->m->isStatic->else->checkAccess->return->throw->m->makeAccessException
MethodHandles.Lookup#checkAccess(byte, Class, MemberName):::Check public/protected/private bits on the symbolic reference class and its member.:::allowedModes->if->return->mods->m->getModifiers->if->Modifier->isProtected->m->getDeclaringClass->m->getName->equals->refc->isArray->if->Modifier->isProtected->if->Modifier->isFinal->MethodHandleNatives->refKindIsSetter->throw->m->makeAccessException->requestedModes->fixmods->if->if->VerifyAccess->m->getDeclaringClass->lookupClass->isMemberAccessible->return->else->if->VerifyAccess->m->getDeclaringClass->lookupClass->isSamePackage->return->throw->m->accessFailedMessage->makeAccessException
MethodHandles.Lookup#accessFailedMessage(Class, MemberName)::: lookup access failed message:::defc->m->getDeclaringClass->mods->m->getModifiers->classOK->Modifier->defc->getModifiers->isPublic->Modifier->refc->getModifiers->isPublic->if->VerifyAccess->lookupClass->isClassAccessible->VerifyAccess->lookupClass->isClassAccessible->if->return->if->Modifier->isPublic->return->if->Modifier->isPrivate->return->if->Modifier->isProtected->return->return
MethodHandles.Lookup#checkSpecialCaller(Class, Class)::: lookup check special caller:::allowedModes->if->return->if->hasPrivateAccess->lookupClass->refc->isInterface->refc->isAssignableFrom->throw->new->MemberName->makeAccessException
MethodHandles.Lookup#restrictProtectedReceiver(MemberName)::: lookup restrict protected receiver:::if->method->isProtected->method->isStatic->method->getDeclaringClass->lookupClass->VerifyAccess->method->getDeclaringClass->lookupClass->isSamePackage->return->return
MethodHandles.Lookup#restrictReceiver(MemberName, DirectMethodHandle, Class)::: lookup restrict receiver:::if->method->getDeclaringClass->isAssignableFrom->throw->method->makeAccessException->rawType->mh->type->if->caller->rawType->parameterType->isAssignableFrom->return->narrowType->rawType->changeParameterType->return->mh->copyWith
MethodHandles.Lookup#getDirectMethod(byte, Class, MemberName, Class):::Check access and get the requested method.:::doRestrict->checkSecurity->return->getDirectMethodCommon
MethodHandles.Lookup#getDirectMethodNoRestrictInvokeSpecial(Class, MemberName, Class):::Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules.:::doRestrict->checkSecurity->return->getDirectMethodCommon
MethodHandles.Lookup#getDirectMethodNoSecurityManager(byte, Class, MemberName, Class):::Check access and get the requested method, eliding security manager checks.:::doRestrict->checkSecurity->return->getDirectMethodCommon
MethodHandles.Lookup#getDirectMethodCommon(byte, Class, MemberName, boolean, boolean, Class):::Common code for all methods; do not call directly except from immediately above.:::checkMethod->if->checkSecurityManager->if->lookupClass->refc->isInterface->lookupClass->getSuperclass->refc->lookupClass->isAssignableFrom->refcAsSuper->lookupClass->m2->do->refcAsSuper->getSuperclass->method->getName->method->getMethodType->new->MemberName->IMPL_NAMES->lookupClassOrNull->resolveOrNull->while->if->throw->method->toString->new->InternalError->checkMethod->dmh->DirectMethodHandle->lookupClass->make->mh->if->MethodHandleNatives->refKindHasReceiver->restrictProtectedReceiver->lookupClass->restrictReceiver->maybeBindCaller->mh->setVarargs->return
MethodHandles.Lookup#maybeBindCaller(MemberName, MethodHandle, Class)::: lookup maybe bind caller:::if->MethodHandleNatives->isCallerSensitive->return->hostClass->if->hasPrivateAccess->cbmh->MethodHandleImpl->bindCaller->return
MethodHandles.Lookup#getDirectField(byte, Class, MemberName):::Check access and get the requested field.:::checkSecurity->return->getDirectFieldCommon
MethodHandles.Lookup#getDirectFieldNoSecurityManager(byte, Class, MemberName):::Check access and get the requested field, eliding security manager checks.:::checkSecurity->return->getDirectFieldCommon
MethodHandles.Lookup#getDirectFieldCommon(byte, Class, MemberName, boolean):::Common code for all fields; do not call directly except from immediately above.:::checkField->if->checkSecurityManager->dmh->DirectMethodHandle->make->doRestrict->MethodHandleNatives->refKindHasReceiver->restrictProtectedReceiver->if->return->lookupClass->restrictReceiver->return
MethodHandles.Lookup#getFieldVarHandle(byte, byte, Class, MemberName, MemberName)::: lookup get field var handle:::checkSecurity->return->getFieldVarHandleCommon
MethodHandles.Lookup#getFieldVarHandleNoSecurityManager(byte, byte, Class, MemberName, MemberName)::: lookup get field var handle no security manager:::checkSecurity->return->getFieldVarHandleCommon
MethodHandles.Lookup#getFieldVarHandleCommon(byte, byte, Class, MemberName, MemberName, boolean)::: lookup get field var handle common:::checkField->if->checkSecurityManager->if->putField->isFinal->checkField->if->checkSecurityManager->doRestrict->MethodHandleNatives->refKindHasReceiver->restrictProtectedReceiver->if->if->getField->getDeclaringClass->lookupClass->isAssignableFrom->throw->getField->lookupClass->makeAccessException->lookupClass->return->VarHandles->getField->getFieldType->makeFieldHandle
MethodHandles.Lookup#getDirectConstructor(Class, MemberName):::Check access and get the requested constructor.:::checkSecurity->return->getDirectConstructorCommon
MethodHandles.Lookup#getDirectConstructorNoSecurityManager(Class, MemberName):::Check access and get the requested constructor, eliding security manager checks.:::checkSecurity->return->getDirectConstructorCommon
MethodHandles.Lookup#getDirectConstructorCommon(Class, MemberName, boolean):::Common code for all constructors; do not call directly except from immediately above.:::checkAccess->if->checkSecurityManager->return->DirectMethodHandle->make->setVarargs
MethodHandles.Lookup#linkMethodHandleConstant(byte, Class, String, Object)::: lookup link method handle constant:::if->throw->new->InternalError->member->new->MemberName->mh->LOOKASIDE_TABLE->get->if->checkSymbolicClass->return->if->member->getName->member->getMethodType->findVirtualForMH->if->return->else->if->member->getName->member->getMethodType->findVirtualForVH->if->return->resolved->resolveOrFail->getDirectMethodForConstant->if->canBeCached->key->mh->internalMemberName->if->key->asNormalOriginal->if->member->equals->LOOKASIDE_TABLE->put->return
MethodHandles.Lookup#canBeCached(byte, Class, MemberName)::: lookup can be cached:::if->return->if->Modifier->defc->getModifiers->isPublic->Modifier->member->getDeclaringClass->getModifiers->isPublic->member->isPublic->member->isCallerSensitive->return->loader->defc->getClassLoader->if->sysl->ClassLoader->getSystemClassLoader->found->while->if->break->sysl->getParent->if->return->try->resolved2->publicLookup->member->getName->member->getType->new->MemberName->resolveOrNull->if->return->checkSecurityManager->catch->return->finally->return
MethodHandles.Lookup#getDirectMethodForConstant(byte, Class, MemberName)::: lookup get direct method for constant:::if->MethodHandleNatives->refKindIsField->return->getDirectFieldNoSecurityManager->else->if->MethodHandleNatives->refKindIsMethod->return->getDirectMethodNoSecurityManager->else->if->return->getDirectConstructorNoSecurityManager->throw->newIllegalArgumentException
MethodHandles#arrayConstructor(Class):::Produces a method handle constructing arrays of a desired type, as if by the anewarray bytecode:::if->arrayClass->isArray->throw->arrayClass->getName->newIllegalArgumentException->ani->MethodHandleImpl->getConstantHandle->arrayClass->getComponentType->bindTo->return->ani->ani->type->changeReturnType->asType
MethodHandles#arrayLength(Class):::Produces a method handle returning the length of an array, as if by the arraylength bytecode:::return->MethodHandleImpl->makeArrayElementAccessor
MethodHandles#arrayElementGetter(Class):::Produces a method handle giving read access to elements of an array, as if by the aaload bytecode:::return->MethodHandleImpl->makeArrayElementAccessor
MethodHandles#arrayElementSetter(Class):::Produces a method handle giving write access to elements of an array, as if by the astore bytecode:::return->MethodHandleImpl->makeArrayElementAccessor
MethodHandles#arrayElementVarHandle(Class):::Produces a VarHandle giving access to elements of an array of type arrayClass:::return->VarHandles->makeArrayElementHandle
MethodHandles#byteArrayViewVarHandle(Class, ByteOrder):::Produces a VarHandle giving access to elements of a byte[] array viewed as if it were a different primitive array type, such as int[] or long[]:::Objects->requireNonNull->return->VarHandles->byteArrayViewHandle
MethodHandles#byteBufferViewVarHandle(Class, ByteOrder):::Produces a VarHandle giving access to elements of a ByteBuffer viewed as if it were an array of elements of a different primitive component type to that of byte, such as int[] or long[]:::Objects->requireNonNull->return->VarHandles->makeByteBufferViewHandle
MethodHandles#spreadInvoker(MethodType, int):::Produces a method handle which will invoke any method handle of the given type, with a given number of trailing arguments replaced by a single trailing Object[] array:::if->type->parameterCount->throw->newIllegalArgumentException->type->type->parameterCount->asSpreaderType->return->type->invokers->spreadInvoker
MethodHandles#exactInvoker(MethodType):::Produces a special invoker method handle which can be used to invoke any method handle of the given type, as if by MethodHandle#invokeExact invokeExact:::return->type->invokers->exactInvoker
MethodHandles#invoker(MethodType):::Produces a special invoker method handle which can be used to invoke any method handle compatible with the given type, as if by MethodHandle#invoke invoke:::return->type->invokers->genericInvoker
MethodHandles#varHandleExactInvoker(VarHandle.AccessMode, MethodType):::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type:::return->type->invokers->varHandleMethodExactInvoker
MethodHandles#varHandleInvoker(VarHandle.AccessMode, MethodType):::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type:::return->type->invokers->varHandleMethodInvoker
MethodHandles#basicInvoker(MethodType)::: method handles basic invoker:::return->type->invokers->basicInvoker
MethodHandles#explicitCastArguments(MethodHandle, MethodType):::Produces a method handle which adapts the type of the given method handle to a new type by pairwise argument and return type conversion:::explicitCastArgumentsChecks->oldType->target->type->if->return->if->oldType->explicitCastEquivalentToAsType->return->target->asFixedArity->asType->return->MethodHandleImpl->makePairwiseConvert
MethodHandles#explicitCastArgumentsChecks(MethodHandle, MethodType)::: method handles explicit cast arguments checks:::if->target->type->parameterCount->newType->parameterCount->throw->new->WrongMethodTypeException
MethodHandles#permuteArguments(MethodHandle, MethodType, int...):::Produces a method handle which adapts the calling sequence of the given method handle to a new type, by reordering the arguments:::reorder->clone->oldType->target->type->permuteArgumentChecks->originalReorder->result->target->rebind->form->newArity->newType->parameterCount->for->ddIdx->findFirstDupOrDrop->form->editor->permuteArgumentsForm->if->result->type->result->internalForm->return->return->result->copyWith
MethodHandles#findFirstDupOrDrop(int[], int):::Return an indication of any duplicate or omission in reorder:::BIT_LIMIT->if->mask->for->i->if->return->zeroBit->Long->lowestOneBit->zeroPos->Long->numberOfTrailingZeros->if->return->return->else->mask->new->BitSet->for->i->zeroPos->mask->nextClearBit->if->return->return
MethodHandles#permuteArgumentChecks(int[], MethodType, MethodType)::: method handles permute argument checks:::if->newType->returnType->oldType->returnType->throw->newIllegalArgumentException->if->oldType->parameterCount->limit->newType->parameterCount->bad->for->j->if->return->throw->Arrays->toString->newIllegalArgumentException
MethodHandles#constant(Class, Object):::Produces a method handle of the requested return type which returns the given constant value every time it is invoked:::if->type->isPrimitive->if->throw->newIllegalArgumentException->w->Wrapper->forPrimitiveType->w->convert->if->w->zero->equals->return->zero->return->identity->insertArguments->else->if->return->zero->return->identity->bindTo
MethodHandles#identity(Class):::Produces a method handle which returns its sole argument when invoked.:::btw->type->isPrimitive->Wrapper->forPrimitiveType->pos->btw->ordinal->ident->if->btw->primitiveType->makeIdentity->setCachedMethodHandle->if->ident->type->returnType->return->return->makeIdentity
MethodHandles#zero(Class):::Produces a constant method handle of the requested return type which returns the default value for that type every time it is invoked:::Objects->requireNonNull->return->type->isPrimitive->Wrapper->forPrimitiveType->zero->zero
MethodHandles#identityOrVoid(Class)::: method handles identity or void:::return->zero->identity
MethodHandles#empty(MethodType):::Produces a method handle of the requested type which ignores any arguments, does nothing, and returns a suitable default depending on the return type:::Objects->requireNonNull->return->type->returnType->zero->type->parameterList->dropArguments
MethodHandles#makeIdentity(Class)::: method handles make identity:::mtype->methodType->lform->LambdaForm->BasicType->basicType->identityForm->return->MethodHandleImpl->makeIntrinsic
MethodHandles#zero(Wrapper, Class)::: method handles zero:::pos->btw->ordinal->zero->if->btw->primitiveType->makeZero->setCachedMethodHandle->if->zero->type->returnType->return->return->makeZero
MethodHandles#makeZero(Class)::: method handles make zero:::mtype->methodType->lform->LambdaForm->BasicType->basicType->zeroForm->return->MethodHandleImpl->makeIntrinsic
MethodHandles#setCachedMethodHandle(MethodHandle[], int, MethodHandle)::: method handles set cached method handle:::prev->if->return->return
MethodHandles#insertArguments(MethodHandle, int, Object...):::Provides a target method handle with one or more bound arguments in advance of the method handle's invocation:::insCount->ptypes->insertArgumentsChecks->if->return->result->target->rebind->for->i->return
MethodHandles#insertArgumentPrimitive(BoundMethodHandle, int, Class, Object)::: method handles insert argument primitive:::w->Wrapper->forPrimitiveType->w->convert->switch->return->result->bindArgumentI->return->result->bindArgumentJ->return->result->bindArgumentF->return->result->bindArgumentD->return->result->ValueConversions->widenSubword->bindArgumentI
MethodHandles#insertArgumentsChecks(MethodHandle, int, int)::: method handles insert arguments checks:::oldType->target->type->outargs->oldType->parameterCount->inargs->if->throw->newIllegalArgumentException->if->throw->newIllegalArgumentException->return->oldType->ptypes
MethodHandles#dropArguments(MethodHandle, int, List>):::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle:::return->valueTypes->toArray->copyTypes->dropArguments0
MethodHandles#copyTypes(Object[])::: method handles copy types:::return->Arrays->Arrays->copyOf->asList
MethodHandles#dropArguments0(MethodHandle, int, List>)::: method handles drop arguments0:::oldType->target->type->dropped->dropArgumentChecks->newType->oldType->insertParameterTypes->if->return->result->target->rebind->lform->insertFormArg->foreach->lform->editor->BasicType->basicType->addArgumentForm->result->copyWith->return
MethodHandles#dropArgumentChecks(MethodType, int, List>)::: method handles drop argument checks:::dropped->valueTypes->size->MethodType->checkSlotCount->outargs->oldType->parameterCount->inargs->if->throw->Arrays->asList->newIllegalArgumentException->return
MethodHandles#dropArguments(MethodHandle, int, Class...):::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle:::return->copyTypes->dropArguments0
MethodHandles#dropArgumentsToMatch(MethodHandle, int, List>, int, boolean)::: method handles drop arguments to match:::newTypes->toArray->copyTypes->oldTypes->target->type->parameterList->match->oldTypes->size->if->if->throw->newIllegalArgumentException->oldTypes->subList->addTypes->add->addTypes->size->if->if->throw->newIllegalArgumentException->addTypes->subList->if->oldTypes->addTypes->subList->equals->if->return->throw->newIllegalArgumentException->addTypes->subList->adapter->if->dropArguments0->if->newTypes->subList->dropArguments0->return
MethodHandles#dropArgumentsToMatch(MethodHandle, int, List>, int):::Adapts a target method handle to match the given parameter type list:::Objects->requireNonNull->Objects->requireNonNull->return->dropArgumentsToMatch
MethodHandles#filterArguments(MethodHandle, int, MethodHandle...):::Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function:::filterArgumentsCheckArity->adapter->for->i->return
MethodHandles#filterArgument(MethodHandle, int, MethodHandle)::: method handles filter argument:::filterArgumentChecks->targetType->target->type->filterType->filter->type->result->target->rebind->newParamType->filterType->parameterType->lform->result->editor->BasicType->basicType->filterArgumentForm->newType->targetType->changeParameterType->result->copyWithExtendL->return
MethodHandles#filterArgumentsCheckArity(MethodHandle, int, MethodHandle[])::: method handles filter arguments check arity:::targetType->target->type->maxPos->targetType->parameterCount->if->throw->newIllegalArgumentException
MethodHandles#filterArgumentChecks(MethodHandle, int, MethodHandle)::: method handles filter argument checks:::targetType->target->type->filterType->filter->type->if->filterType->parameterCount->filterType->returnType->targetType->parameterType->throw->newIllegalArgumentException
MethodHandles#collectArguments(MethodHandle, int, MethodHandle):::Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle):::newType->collectArgumentsChecks->collectorType->filter->type->result->target->rebind->lform->if->collectorType->returnType->isArray->filter->intrinsicName->result->editor->collectArgumentArrayForm->if->return->result->copyWith->result->editor->collectorType->basicType->collectArgumentsForm->return->result->copyWithExtendL
MethodHandles#collectArgumentsChecks(MethodHandle, int, MethodHandle)::: method handles collect arguments checks:::targetType->target->type->filterType->filter->type->rtype->filterType->returnType->filterArgs->filterType->parameterList->if->return->targetType->insertParameterTypes->if->targetType->parameterType->throw->newIllegalArgumentException->return->targetType->dropParameterTypes->insertParameterTypes
MethodHandles#filterReturnValue(MethodHandle, MethodHandle):::Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle):::targetType->target->type->filterType->filter->type->filterReturnValueChecks->result->target->rebind->rtype->BasicType->filterType->returnType->basicType->lform->result->editor->filterReturnForm->newType->targetType->filterType->returnType->changeReturnType->result->copyWithExtendL->return
MethodHandles#filterReturnValueChecks(MethodType, MethodType)::: method handles filter return value checks:::rtype->targetType->returnType->filterValues->filterType->parameterCount->if->filterType->parameterType->throw->newIllegalArgumentException
MethodHandles#foldArguments(MethodHandle, MethodHandle):::Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments:::return->foldArguments
MethodHandles#foldArguments(MethodHandle, int, MethodHandle):::Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments just before the folded arguments:::targetType->target->type->combinerType->combiner->type->rtype->foldArgumentChecks->result->target->rebind->dropResult->lform->result->editor->combinerType->basicType->foldArgumentsForm->newType->if->newType->dropParameterTypes->result->copyWithExtendL->return
MethodHandles#foldArguments(MethodHandle, int, MethodHandle, int...):::As foldArguments(MethodHandle, int, MethodHandle), but with the added capability of selecting the arguments from the targets parameters to call the combiner with:::targetType->target->type->combinerType->combiner->type->rtype->foldArgumentChecks->result->target->rebind->dropResult->lform->result->editor->combinerType->basicType->foldArgumentsForm->newType->if->newType->dropParameterTypes->result->copyWithExtendL->return
MethodHandles#foldArgumentChecks(int, MethodType, MethodType)::: method handles fold argument checks:::foldArgs->combinerType->parameterCount->rtype->combinerType->returnType->foldVals->afterInsertPos->ok->targetType->parameterCount->if->for->i->if->combinerType->returnType->targetType->parameterType->if->throw->misMatchedTypes->return
MethodHandles#foldArgumentChecks(int, MethodType, MethodType, int...)::: method handles fold argument checks:::foldArgs->combinerType->parameterCount->if->throw->newIllegalArgumentException->rtype->combinerType->returnType->foldVals->ok->for->i->if->combinerType->returnType->targetType->parameterType->if->throw->misMatchedTypes->return
MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle):::Makes a method handle which adapts a target method handle, by guarding it with a test, a boolean-valued method handle:::gtype->test->type->ttype->target->type->ftype->fallback->type->if->ttype->equals->throw->misMatchedTypes->if->gtype->returnType->throw->newIllegalArgumentException->targs->ttype->parameterList->dropArgumentsToMatch->if->throw->misMatchedTypes->return->MethodHandleImpl->makeGuardWithTest
MethodHandles#misMatchedTypes(String, T, T)::: method handles mis matched types:::return->newIllegalArgumentException
MethodHandles#catchException(MethodHandle, Class, MethodHandle):::Makes a method handle which adapts a target method handle, by running it inside an exception handler:::ttype->target->type->htype->handler->type->if->isAssignableFrom->throw->exType->getName->new->ClassCastException->if->htype->parameterCount->htype->parameterType->isAssignableFrom->throw->newIllegalArgumentException->if->htype->returnType->ttype->returnType->throw->misMatchedTypes->ttype->parameterList->dropArgumentsToMatch->if->throw->misMatchedTypes->return->MethodHandleImpl->makeGuardWithCatch
MethodHandles#throwException(Class, Class):::Produces a method handle which will throw exceptions of the given exType:::if->isAssignableFrom->throw->exType->getName->new->ClassCastException->return->MethodHandleImpl->methodType->throwException
MethodHandles#loop(MethodHandle[]...):::Constructs a method handle representing a loop with several loop variables that are updated and checked upon each iteration:::loopChecks0->init->new->ArrayList<>->step->new->ArrayList<>->pred->new->ArrayList<>->fini->new->ArrayList<>->Stream->of->Stream->of->Objects->nonNull->anyMatch->filter->init->add->step->add->pred->add->fini->add->forEach->nclauses->init->size->iterationVariableTypes->new->ArrayList<>->for->i->commonPrefix->iterationVariableTypes->stream->filter->Collectors->toList->collect->commonSuffix->commonPrefix->size->buildCommonSuffix->loopChecks1b->loopReturnType->fini->stream->Objects->nonNull->filter->MethodHandle->type->map->MethodType->returnType->map->findFirst->orElse->loopChecks1cd->commonParameterSequence->new->ArrayList<>->commonParameterSequence->addAll->loopChecks2->for->i->finit->fillParameterTypes->fixArities->fstep->fillParameterTypes->fixArities->fpred->fillParameterTypes->fixArities->ffini->fillParameterTypes->fixArities->return->MethodHandleImpl->makeLoop
MethodHandles#loopChecks0(MethodHandle[][])::: method handles loop checks0:::if->throw->newIllegalArgumentException->if->Stream->of->Objects->isNull->anyMatch->throw->newIllegalArgumentException->if->Stream->of->anyMatch->throw->newIllegalArgumentException
MethodHandles#loopChecks1a(int, MethodHandle, MethodHandle)::: method handles loop checks1a:::if->in->type->returnType->st->type->returnType->throw->in->type->returnType->st->type->returnType->misMatchedTypes
MethodHandles#longestParameterList(Stream, int)::: method handles longest parameter list:::empty->List->of->longest->mhs->Objects->nonNull->filter->MethodHandle->type->map->t->parameterCount->filter->MethodType->parameterList->map->p->size->q->size->reduce->orElse->return->longest->size->longest->longest->size->subList
MethodHandles#longestParameterList(List>>)::: method handles longest parameter list:::empty->List->of->return->lists->stream->p->size->q->size->reduce->orElse
MethodHandles#buildCommonSuffix(List, List, List, List, int)::: method handles build common suffix:::longest1->Stream->of->List->stream->flatMap->longestParameterList->longest2->init->stream->longestParameterList->return->Arrays->asList->longestParameterList
MethodHandles#loopChecks1b(List, List>)::: method handles loop checks1b:::if->init->stream->Objects->nonNull->filter->MethodHandle->type->map->t->effectivelyIdenticalParameters->anyMatch->throw->newIllegalArgumentException
MethodHandles#loopChecks1cd(List, List, Class)::: method handles loop checks1cd:::if->fini->stream->Objects->nonNull->filter->MethodHandle->type->map->MethodType->returnType->map->anyMatch->throw->newIllegalArgumentException->if->pred->stream->Objects->nonNull->filter->findFirst->isPresent->throw->newIllegalArgumentException->if->pred->stream->Objects->nonNull->filter->MethodHandle->type->map->MethodType->returnType->map->anyMatch->throw->newIllegalArgumentException
MethodHandles#loopChecks2(List, List, List, List>)::: method handles loop checks2:::if->Stream->of->List->stream->flatMap->Objects->nonNull->filter->MethodHandle->type->map->t->effectivelyIdenticalParameters->anyMatch->throw->newIllegalArgumentException
MethodHandles#fillParameterTypes(List, List>)::: method handles fill parameter types:::return->hs->stream->pc->h->type->parameterCount->tpsize->targetParams->size->return->targetParams->subList->dropArguments0->map->Collectors->toList->collect
MethodHandles#fixArities(List)::: method handles fix arities:::return->hs->stream->MethodHandle->asFixedArity->map->Collectors->toList->collect
MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a while loop from an initializer, a body, and a predicate:::whileLoopChecks->fini->body->type->returnType->identityOrVoid->checkExit->varBody->return->loop
MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a do-while loop from an initializer, a body, and a predicate:::whileLoopChecks->fini->body->type->returnType->identityOrVoid->clause->return->loop
MethodHandles#whileLoopChecks(MethodHandle, MethodHandle, MethodHandle)::: method handles while loop checks:::Objects->requireNonNull->Objects->requireNonNull->bodyType->body->type->returnType->bodyType->returnType->innerList->bodyType->parameterList->outerList->if->else->if->innerList->size->innerList->get->expected->bodyType->insertParameterTypes->throw->misMatchedTypes->else->innerList->innerList->size->subList->predType->pred->type->if->predType->returnType->predType->effectivelyIdenticalParameters->throw->methodType->misMatchedTypes->if->initType->init->type->if->initType->returnType->initType->effectivelyIdenticalParameters->throw->methodType->misMatchedTypes
MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that runs a given number of iterations:::return->iterations->type->empty->countedLoop
MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that counts over a range of numbers:::countedLoopChecks->counterType->start->type->returnType->limitType->end->type->returnType->returnType->body->type->returnType->incr->MethodHandleImpl->getConstantHandle->pred->MethodHandleImpl->getConstantHandle->retv->if->dropArguments->dropArguments->identity->dropArguments->dropArguments->loopLimit->bodyClause->indexVar->return->loop
MethodHandles#countedLoopChecks(MethodHandle, MethodHandle, MethodHandle, MethodHandle)::: method handles counted loop checks:::Objects->requireNonNull->Objects->requireNonNull->Objects->requireNonNull->counterType->start->type->returnType->if->expected->start->type->changeReturnType->throw->start->type->misMatchedTypes->else->if->end->type->returnType->expected->end->type->changeReturnType->throw->end->type->misMatchedTypes->bodyType->body->type->returnType->bodyType->returnType->innerList->bodyType->parameterList->vsize->if->innerList->size->innerList->get->expected->bodyType->insertParameterTypes->throw->misMatchedTypes->else->if->innerList->size->innerList->get->expected->bodyType->insertParameterTypes->throw->misMatchedTypes->outerList->innerList->innerList->size->subList->if->outerList->isEmpty->end->type->parameterList->bodyType->insertParameterTypes->parameterList->expected->methodType->if->start->type->effectivelyIdenticalParameters->throw->start->type->misMatchedTypes->if->end->type->start->type->end->type->effectivelyIdenticalParameters->throw->end->type->misMatchedTypes->if->initType->init->type->if->initType->returnType->initType->effectivelyIdenticalParameters->throw->methodType->misMatchedTypes
MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle):::Constructs a loop that ranges over the values produced by an Iterator<T>:::iterableType->iteratedLoopChecks->returnType->body->type->returnType->hasNext->MethodHandleImpl->getConstantHandle->nextRaw->MethodHandleImpl->getConstantHandle->startIter->nextVal->iteratorType->if->MethodHandleImpl->getConstantHandle->startIter->type->changeParameterType->else->iterator->type->changeReturnType->ttype->body->type->parameterType->nextValType->nextRaw->type->changeReturnType->try->startIter->asType->nextRaw->asType->catch->throw->new->IllegalArgumentException->finally->retv->step->if->identity->dropArguments->swapArguments->iterVar->bodyClause->filterArgument->return->loop
MethodHandles#iteratedLoopChecks(MethodHandle, MethodHandle, MethodHandle)::: method handles iterated loop checks:::Objects->requireNonNull->bodyType->body->type->returnType->bodyType->returnType->internalParamList->bodyType->parameterList->vsize->if->internalParamList->size->internalParamList->get->expected->bodyType->insertParameterTypes->throw->misMatchedTypes->else->if->internalParamList->size->expected->bodyType->insertParameterTypes->throw->misMatchedTypes->externalParamList->internalParamList->internalParamList->size->subList->iterableType->if->if->externalParamList->isEmpty->iterator->type->parameterList->itype->iterator->type->if->itype->returnType->isAssignableFrom->throw->newIllegalArgumentException->if->itype->effectivelyIdenticalParameters->expected->itype->returnType->methodType->throw->misMatchedTypes->else->if->externalParamList->isEmpty->Arrays->asList->else->externalParamList->get->if->isAssignableFrom->throw->newIllegalArgumentException->if->initType->init->type->if->initType->returnType->initType->effectivelyIdenticalParameters->throw->methodType->misMatchedTypes->return
MethodHandles#swapArguments(MethodHandle, int, int)::: method handles swap arguments:::arity->mh->type->parameterCount->order->new->intArr->for->k->types->mh->type->parameterArray->ti->swapType->mh->type->returnType->methodType->return->permuteArguments
MethodHandles#tryFinally(MethodHandle, MethodHandle):::Makes a method handle that adapts a target method handle by wrapping it in a try-finally block:::targetParamTypes->target->type->parameterList->rtype->target->type->returnType->tryFinallyChecks->dropArgumentsToMatch->cleanup->cleanup->type->changeParameterType->asType->return->MethodHandleImpl->target->asFixedArity->cleanup->asFixedArity->makeTryFinally
MethodHandles#tryFinallyChecks(MethodHandle, MethodHandle)::: method handles try finally checks:::rtype->target->type->returnType->if->cleanup->type->returnType->throw->cleanup->type->returnType->misMatchedTypes->cleanupType->cleanup->type->if->cleanupType->parameterType->isAssignableFrom->throw->cleanup->type->misMatchedTypes->if->cleanupType->parameterType->throw->cleanup->type->misMatchedTypes->cleanupArgIndex->if->cleanupType->target->type->parameterList->effectivelyIdenticalParameters->throw->cleanup->type->target->type->misMatchedTypes
MethodHandleStatics#debugEnabled()::: method handle statics debug enabled:::return
MethodHandleStatics#newInternalError(String)::: method handle statics new internal error:::return->new->InternalError
MethodHandleStatics#newInternalError(String, Exception)::: method handle statics new internal error:::return->new->InternalError
MethodHandleStatics#newInternalError(Exception)::: method handle statics new internal error:::return->new->InternalError
MethodHandleStatics#newIllegalStateException(String)::: method handle statics new illegal state exception:::return->new->IllegalStateException
MethodHandleStatics#newIllegalStateException(String, Object)::: method handle statics new illegal state exception:::return->message->new->IllegalStateException
MethodHandleStatics#newIllegalArgumentException(String)::: method handle statics new illegal argument exception:::return->new->IllegalArgumentException
MethodHandleStatics#newIllegalArgumentException(String, Object)::: method handle statics new illegal argument exception:::return->message->new->IllegalArgumentException
MethodHandleStatics#newIllegalArgumentException(String, Object, Object)::: method handle statics new illegal argument exception:::return->message->new->IllegalArgumentException
MethodHandleStatics#uncaughtException(Throwable)::: method handle statics uncaught exception:::if->throw->if->throw->throw->new->InternalError
MethodHandleStatics#message(String, Object)::: method handle statics message:::if->return
MethodHandleStatics#message(String, Object, Object)::: method handle statics message:::if->return
MethodHandleStatics#rangeCheck2(int, int, int)::: method handle statics range check2:::if->throw->new->IndexOutOfBoundsException
MethodHandleStatics#rangeCheck1(int, int)::: method handle statics range check1:::if->throw->new->IndexOutOfBoundsException->return
MethodType#form()::: method type form:::return
MethodType#rtype()::: method type rtype:::return
MethodType#ptypes()::: method type ptypes:::return
MethodType#setForm(MethodTypeForm)::: method type set form:::
MethodType#checkRtype(Class)::: method type check rtype:::Objects->requireNonNull
MethodType#checkPtype(Class)::: method type check ptype:::Objects->requireNonNull->if->throw->newIllegalArgumentException
MethodType#checkPtypes(Class[]):::Return number of extra slots (count of long/double args).:::slots->foreach->checkPtype->if->checkSlotCount->return
MethodType#checkSlotCount(int)::: method type check slot count:::if->throw->newIllegalArgumentException
MethodType#newIndexOutOfBoundsException(Object)::: method type new index out of bounds exception:::if->return->num->toString->new->IndexOutOfBoundsException
MethodType#methodType(Class, Class[]):::Finds or creates an instance of the given method type.:::return->makeImpl
MethodType#methodType(Class, List>):::Finds or creates a method type with the given components:::notrust->return->listToArray->makeImpl
MethodType#listToArray(List>)::: method type list to array:::ptypes->size->checkSlotCount->return->ptypes->toArray
MethodType#methodType(Class, Class, Class...):::Finds or creates a method type with the given components:::ptypes1->new->Class<?>Arr->System->arraycopy->return->makeImpl
MethodType#methodType(Class):::Finds or creates a method type with the given components:::return->makeImpl
MethodType#methodType(Class, Class):::Finds or creates a method type with the given components:::return->new->Class<?>Arr->makeImpl
MethodType#methodType(Class, MethodType):::Finds or creates a method type with the given components:::return->makeImpl
MethodType#makeImpl(Class, Class[], boolean)::: method type make impl:::if->primordialMT->new->MethodType->mt->internTable->get->if->return->MethodType->checkRtype->if->MethodType->checkPtypes->else->Arrays->copyOf->MethodType->checkPtypes->new->MethodType->MethodTypeForm->findForm->return->internTable->add
MethodType#genericMethodType(int, boolean):::Finds or creates a method type whose components are Object with an optional trailing Object[] array:::mt->checkSlotCount->ivarargs->ootIndex->if->if->return->ptypes->new->Class<?>Arr->Arrays->fill->if->makeImpl->if->return
MethodType#genericMethodType(int):::Finds or creates a method type whose components are all Object:::return->genericMethodType
MethodType#changeParameterType(int, Class):::Finds or creates a method type with a single different parameter type:::if->parameterType->return->checkPtype->nptypes->ptypes->clone->return->makeImpl
MethodType#insertParameterTypes(int, Class...):::Finds or creates a method type with additional parameter types:::len->if->throw->newIndexOutOfBoundsException->ins->checkPtypes->parameterSlotCount->checkSlotCount->ilen->if->return->nptypes->new->Class<?>Arr->if->System->arraycopy->System->arraycopy->if->System->arraycopy->return->makeImpl
MethodType#appendParameterTypes(Class...):::Finds or creates a method type with additional parameter types:::return->parameterCount->insertParameterTypes
MethodType#insertParameterTypes(int, List>):::Finds or creates a method type with additional parameter types:::return->listToArray->insertParameterTypes
MethodType#appendParameterTypes(List>):::Finds or creates a method type with additional parameter types:::return->parameterCount->insertParameterTypes
MethodType#replaceParameterTypes(int, int, Class...)::: method type replace parameter types:::if->return->insertParameterTypes->len->if->throw->newIndexOutOfBoundsException->ilen->if->return->dropParameterTypes->return->dropParameterTypes->insertParameterTypes
MethodType#asSpreaderType(Class, int, int)::: method type as spreader type:::spreadPos->if->return->if->if->isGeneric->return->if->res->genericMethodType->if->res->changeReturnType->return->elemType->arrayType->getComponentType->for->i->return
MethodType#leadingReferenceParameter()::: method type leading reference parameter:::ptype->if->isPrimitive->throw->newIllegalArgumentException->return
MethodType#asCollectorType(Class, int, int)::: method type as collector type:::res->if->genericMethodType->if->res->changeReturnType->else->elemType->arrayType->getComponentType->Collections->nCopies->methodType->if->return->else->if->res->Arrays->copyOfRange->insertParameterTypes->return->res->Arrays->copyOf->insertParameterTypes
MethodType#dropParameterTypes(int, int):::Finds or creates a method type with some parameter types omitted:::len->if->throw->newIndexOutOfBoundsException->if->return->nptypes->if->if->else->Arrays->copyOfRange->else->if->Arrays->copyOfRange->else->tail->Arrays->copyOfRange->System->arraycopy->return->makeImpl
MethodType#changeReturnType(Class):::Finds or creates a method type with a different return type:::if->returnType->return->return->makeImpl
MethodType#hasPrimitives():::Reports if this type contains a primitive argument or return value:::return->form->hasPrimitives
MethodType#hasWrappers():::Reports if this type contains a wrapper argument or return value:::return->unwrap
MethodType#erase():::Erases all reference types to Object:::return->form->erasedType
MethodType#basicType()::: method type basic type:::return->form->basicType
MethodType#invokerType()::: method type invoker type:::return->insertParameterTypes
MethodType#generic():::Converts all types, both reference and primitive, to Object:::return->parameterCount->genericMethodType
MethodType#isGeneric()::: method type is generic:::return->erase->hasPrimitives
MethodType#wrap():::Converts all primitive types to their corresponding wrapper types:::return->hasPrimitives->wrapWithPrims
MethodType#unwrap():::Converts all wrapper types to their corresponding primitive types:::noprims->hasPrimitives->wrapWithPrims->return->unwrapWithNoPrims
MethodType#wrapWithPrims(MethodType)::: method type wrap with prims:::wt->if->MethodTypeForm->canonicalize->return
MethodType#unwrapWithNoPrims(MethodType)::: method type unwrap with no prims:::uwt->if->MethodTypeForm->canonicalize->if->return
MethodType#parameterType(int):::Returns the parameter type at the specified index, within this method type.:::return
MethodType#parameterCount():::Returns the number of parameter types in this method type.:::return
MethodType#returnType():::Returns the return type of this method type.:::return
MethodType#parameterList():::Presents the parameter types as a list (a convenience method):::return->Collections->Arrays->ptypes->clone->asList->unmodifiableList
MethodType#lastParameterType():::Returns the last parameter type of this method type:::len->return
MethodType#parameterArray():::Presents the parameter types as an array (a convenience method):::return->ptypes->clone
MethodType#equals(Object):::Compares the specified object with this type for equality:::return->equals
MethodType#equals(MethodType)::: method type equals:::return->Arrays->equals
MethodType#hashCode():::Returns the hash code value for this method type:::hashCode->rtype->hashCode->foreach->ptype->hashCode->return
MethodType#toString():::Returns a string representation of the method type, of the form "(PT0,PT1...)RT":::sj->rtype->getSimpleName->new->StringJoiner->for->i->return->sj->toString
MethodType#effectivelyIdenticalParameters(int, List>)::: method type effectively identical parameters:::myLen->fullLen->fullList->size->if->return->myList->Arrays->asList->if->myList->subList->if->return->myList->equals->else->return->myList->fullList->subList->equals
MethodType#isViewableAs(MethodType, boolean)::: method type is viewable as:::if->VerifyType->returnType->newType->returnType->isNullConversion->return->if->return->if->return->argc->parameterCount->if->newType->parameterCount->return->for->i->return
MethodType#isConvertibleTo(MethodType)::: method type is convertible to:::oldForm->this->form->newForm->newType->form->if->return->if->returnType->newType->returnType->canConvert->return->srcTypes->dstTypes->if->return->argc->if->return->if->if->canConvert->return->return->if->oldForm->primitiveParameterCount->newForm->primitiveParameterCount->return->return->canConvertParameters
MethodType#explicitCastEquivalentToAsType(MethodType)::: method type explicit cast equivalent to as type:::if->return->if->explicitCastEquivalentToAsType->return->srcTypes->dstTypes->if->return->for->i->return
MethodType#explicitCastEquivalentToAsType(Class, Class):::Reports true if the src can be converted to the dst, by both asType and MHs.eCE,  and with the same effect:::if->return->if->src->isPrimitive->return->canConvert->else->if->dst->isPrimitive->return->else->return->dst->isInterface->dst->isAssignableFrom
MethodType#canConvertParameters(Class[], Class[])::: method type can convert parameters:::for->i->return
MethodType#canConvert(Class, Class)::: method type can convert:::if->return->if->src->isPrimitive->if->return->sw->Wrapper->forPrimitiveType->if->dst->isPrimitive->return->Wrapper->forPrimitiveType->isConvertibleFrom->else->return->dst->sw->wrapperType->isAssignableFrom->else->if->dst->isPrimitive->if->return->dw->Wrapper->forPrimitiveType->if->src->dw->wrapperType->isAssignableFrom->return->if->Wrapper->isWrapperType->dw->Wrapper->forWrapperType->isConvertibleFrom->return->return->else->return
MethodType#parameterSlotCount()::: method type parameter slot count:::return->form->parameterSlotCount
MethodType#invokers()::: method type invokers:::inv->if->return->new->Invokers->return
MethodType#parameterSlotDepth(int)::: method type parameter slot depth:::if->parameterType->return->form->parameterToArgSlot
MethodType#returnSlotCount()::: method type return slot count:::return->form->returnSlotCount
MethodType#fromMethodDescriptorString(String, ClassLoader):::Finds or creates an instance of a method type, given the spelling of its bytecode descriptor:::return->ClassLoader->getSystemClassLoader->fromDescriptor
MethodType#fromDescriptor(String, ClassLoader):::Same as #fromMethodDescriptorString(String, ClassLoader), but null ClassLoader means the bootstrap loader is used here:::if->descriptor->startsWith->descriptor->indexOf->descriptor->indexOf->throw->newIllegalArgumentException->types->BytecodeDescriptor->parseMethod->rtype->types->types->size->remove->ptypes->listToArray->return->makeImpl
MethodType#toMethodDescriptorString():::Produces a bytecode descriptor representation of the method type:::desc->if->BytecodeDescriptor->unparseMethod->return
MethodType#toFieldDescriptorString(Class)::: method type to field descriptor string:::return->BytecodeDescriptor->unparse
MethodType#writeObject(java.io.ObjectOutputStream):::Save the MethodType instance to a stream.:::s->defaultWriteObject->s->returnType->writeObject->s->parameterArray->writeObject
MethodType#readObject(java.io.ObjectInputStream):::Reconstitute the MethodType instance from a stream (that is, deserialize it):::UNSAFE->putObject->UNSAFE->putObject->s->defaultReadObject->returnType->s->readObject->parameterArray->s->readObject->new->MethodTypeArr->MethodType->methodType
MethodType#readResolve():::Resolves and initializes a MethodType object after serialization.:::mt->return
MethodType.ConcurrentWeakInternSet#get(T):::Get the existing interned element:::if->throw->new->NullPointerException->expungeStaleElements->value->map->new->WeakEntry<>->get->if->res->value->get->if->return->return
MethodType.ConcurrentWeakInternSet#add(T):::Interns the element:::if->throw->new->NullPointerException->interned->e->new->WeakEntry<>->do->expungeStaleElements->exist->map->putIfAbsent->exist->get->while->return
MethodType.ConcurrentWeakInternSet#expungeStaleElements()::: concurrent weak intern set expunge stale elements:::reference->while->stale->poll->map->remove
MethodType.ConcurrentWeakInternSet.WeakEntry#equals(Object)::: weak entry equals:::if->that->get->mine->get->return->mine->equals->return
MethodType.ConcurrentWeakInternSet.WeakEntry#hashCode()::: weak entry hash code:::return
MethodTypeForm#erasedType():::Return the type corresponding uniquely (1-1) to this MT-form:::return
MethodTypeForm#basicType():::Return the basic type derived from the erased type of this MT-form:::return
MethodTypeForm#assertIsBasicType()::: method type form assert is basic type:::return
MethodTypeForm#cachedMethodHandle(int)::: method type form cached method handle:::entry->return->entry->get
MethodTypeForm#setCachedMethodHandle(int, MethodHandle)::: method type form set cached method handle:::entry->if->prev->entry->get->if->return->new->SoftReference<>->return
MethodTypeForm#cachedLambdaForm(int)::: method type form cached lambda form:::entry->return->entry->get
MethodTypeForm#setCachedLambdaForm(int, LambdaForm)::: method type form set cached lambda form:::entry->if->prev->entry->get->if->return->new->SoftReference<>->return
MethodTypeForm#pack(int, int, int, int)::: method type form pack:::hw->lw->return
MethodTypeForm#unpack(long, int)::: method type form unpack:::return
MethodTypeForm#parameterCount()::: method type form parameter count:::return->unpack
MethodTypeForm#parameterSlotCount()::: method type form parameter slot count:::return->unpack
MethodTypeForm#returnCount()::: method type form return count:::return->unpack
MethodTypeForm#returnSlotCount()::: method type form return slot count:::return->unpack
MethodTypeForm#primitiveParameterCount()::: method type form primitive parameter count:::return->unpack
MethodTypeForm#longPrimitiveParameterCount()::: method type form long primitive parameter count:::return->unpack
MethodTypeForm#primitiveReturnCount()::: method type form primitive return count:::return->unpack
MethodTypeForm#longPrimitiveReturnCount()::: method type form long primitive return count:::return->unpack
MethodTypeForm#hasPrimitives()::: method type form has primitives:::return
MethodTypeForm#hasNonVoidPrimitives()::: method type form has non void primitives:::if->return->if->primitiveParameterCount->return->return->primitiveReturnCount->returnCount
MethodTypeForm#hasLongPrimitives()::: method type form has long primitives:::return->longPrimitiveParameterCount->longPrimitiveReturnCount
MethodTypeForm#parameterToArgSlot(int)::: method type form parameter to arg slot:::return
MethodTypeForm#argSlotToParameter(int)::: method type form arg slot to parameter:::return
MethodTypeForm#findForm(MethodType)::: method type form find form:::erased->canonicalize->if->return->new->MethodTypeForm->else->return->erased->form
MethodTypeForm#canonicalize(MethodType, int, int):::Canonicalize the types in the given method type:::ptypes->mt->ptypes->ptc->MethodTypeForm->canonicalizeAll->rtype->mt->returnType->rtc->MethodTypeForm->canonicalize->if->return->if->if->return->MethodType->makeImpl
MethodTypeForm#canonicalize(Class, int):::Canonicalize the given return or param type:::ct->if->else->if->t->isPrimitive->switch->Wrapper->asPrimitiveType->if->return->break->return->else->if->switch->return->return->else->switch->return->Wrapper->asWrapperType->if->return->if->return->return->if->return->return->if->return->return->return
MethodTypeForm#canonicalizeAll(Class[], int):::Canonicalize each param type in the given array:::cs->for->imax->i->return
MethodTypeForm#toString()::: method type form to string:::return
MutableCallSite#getTarget():::Returns the target method of the call site, which behaves like a normal field of the MutableCallSite:::return
MutableCallSite#setTarget(MethodHandle):::Updates the target method of this call site, as a normal variable:::checkTargetChange->setTargetNormal
MutableCallSite#dynamicInvoker()::: mutable call site dynamic invoker:::return->makeDynamicInvoker
MutableCallSite#syncAll(MutableCallSite[]):::Performs a synchronization operation on each call site in the given array, forcing all other threads to throw away any cached values previously loaded from the target of any of the call sites:::if->return->STORE_BARRIER->lazySet->foreach->Objects->requireNonNull
ProxyClassesDumper#getInstance(String)::: proxy classes dumper get instance:::if->return->try->path->trim->dir->Path->path->length->of->AccessController->new->PrivilegedAction<>->new->FilePermission->doPrivileged->return->new->ProxyClassesDumper->catch->PlatformLogger->getName->getLogger->warning->PlatformLogger->getName->getLogger->iae->getMessage->warning->finally->return
ProxyClassesDumper#validateDumpDir(Path)::: proxy classes dumper validate dump dir:::if->Files->exists->throw->new->IllegalArgumentException->else->if->Files->isDirectory->throw->new->IllegalArgumentException->else->if->Files->isWritable->throw->new->IllegalArgumentException
ProxyClassesDumper#encodeForFilename(String)::: proxy classes dumper encode for filename:::len->className->length->sb->new->StringBuilder->for->i->return->sb->toString
ProxyClassesDumper#dumpClass(String, byte[])::: proxy classes dumper dump class:::file->try->dumpDir->encodeForFilename->resolve->catch->PlatformLogger->getName->getLogger->warning->return->finally->try->dir->file->getParent->Files->createDirectories->Files->write->catch->PlatformLogger->getName->getLogger->file->toString->warning->finally
SerializedLambda#getCapturingClass():::Get the name of the class that captured this lambda.:::return->capturingClass->getName->replace
SerializedLambda#getFunctionalInterfaceClass():::Get the name of the invoked type to which this lambda has been converted:::return
SerializedLambda#getFunctionalInterfaceMethodName():::Get the name of the primary method for the functional interface to which this lambda has been converted.:::return
SerializedLambda#getFunctionalInterfaceMethodSignature():::Get the signature of the primary method for the functional interface to which this lambda has been converted.:::return
SerializedLambda#getImplClass():::Get the name of the class containing the implementation method.:::return
SerializedLambda#getImplMethodName():::Get the name of the implementation method.:::return
SerializedLambda#getImplMethodSignature():::Get the signature of the implementation method.:::return
SerializedLambda#getImplMethodKind():::Get the method handle kind (see MethodHandleInfo) of the implementation method.:::return
SerializedLambda#getInstantiatedMethodType():::Get the signature of the primary functional interface method after type variables are substituted with their instantiation from the capture site.:::return
SerializedLambda#getCapturedArgCount():::Get the count of dynamic arguments to the lambda capture site.:::return
SerializedLambda#getCapturedArg(int):::Get a dynamic argument to the lambda capture site.:::return
SerializedLambda#readResolve()::: serialized lambda read resolve:::try->deserialize->AccessController->new->PrivilegedExceptionAction<>->doPrivileged->return->deserialize->invoke->catch->cause->e->getException->if->throw->else->if->throw->else->throw->new->RuntimeException->finally
SerializedLambda#toString()::: serialized lambda to string:::implKind->MethodHandleInfo->referenceKindToString->return->String->format
SimpleMethodHandle#make(MethodType, LambdaForm)::: simple method handle make:::return->new->SimpleMethodHandle
SimpleMethodHandle#speciesData()::: simple method handle species data:::return
SimpleMethodHandle#copyWith(MethodType, LambdaForm)::: simple method handle copy with:::return->make
SimpleMethodHandle#internalProperties()::: simple method handle internal properties:::return->getClass->getSimpleName
SimpleMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)::: simple method handle copy with extend l:::return->BoundMethodHandle->bindSingle
SimpleMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)::: simple method handle copy with extend i:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
SimpleMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)::: simple method handle copy with extend j:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
SimpleMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)::: simple method handle copy with extend f:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
SimpleMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)::: simple method handle copy with extend d:::try->return->BMH_SPECIES->extendWith->factory->invokeBasic->catch->throw->uncaughtException->finally
StringConcatFactory.Key#equals(Object)::: key equals:::if->return->if->getClass->o->getClass->return->key->if->className->equals->return->if->mt->equals->return->if->recipe->equals->return->return
StringConcatFactory.Key#hashCode()::: key hash code:::result->className->hashCode->mt->hashCode->recipe->hashCode->return
StringConcatFactory.Recipe#getElements()::: recipe get elements:::return
StringConcatFactory.Recipe#equals(Object)::: recipe equals:::if->return->if->getClass->o->getClass->return->recipe->return->elements->equals
StringConcatFactory.Recipe#hashCode()::: recipe hash code:::return->elements->hashCode
StringConcatFactory.RecipeElement#getValue()::: recipe element get value:::return
StringConcatFactory.RecipeElement#getArgPos()::: recipe element get arg pos:::return
StringConcatFactory.RecipeElement#getTag()::: recipe element get tag:::return
StringConcatFactory.RecipeElement#equals(Object)::: recipe element equals:::if->return->if->getClass->o->getClass->return->that->if->return->if->value->equals->return->if->return->return
StringConcatFactory.RecipeElement#hashCode()::: recipe element hash code:::return
StringConcatFactory#makeConcat(MethodHandles.Lookup, String, MethodType):::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments:::if->println->return->doStringConcat
StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup, String, MethodType, String, Object...):::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments:::if->Arrays->toString->println->return->doStringConcat
StringConcatFactory#doStringConcat(MethodHandles.Lookup, String, MethodType, boolean, String, Object...)::: string concat factory do string concat:::Objects->requireNonNull->Objects->requireNonNull->Objects->requireNonNull->Objects->requireNonNull->foreach->Objects->requireNonNull->if->lookup->lookupModes->throw->lookup->lookupClass->getName->new->StringConcatException->cCount->oCount->if->value->concatType->parameterCount->new->charArr->Arrays->fill->new->String->concatType->parameterCount->else->Objects->requireNonNull->for->i->recipe->length->if->concatType->parameterCount->throw->concatType->parameterCount->new->StringConcatException->if->throw->new->StringConcatException->if->concatType->returnType->isAssignableFrom->throw->concatType->returnType->new->StringConcatException->if->concatType->parameterSlotCount->throw->concatType->parameterSlotCount->new->StringConcatException->className->lookup->lookupClass->getClassName->mt->adaptType->rec->new->Recipe->mh->if->key->new->Key->CACHE->get->if->generate->CACHE->put->else->generate->return->mh->asType->new->ConstantCallSite
StringConcatFactory#adaptType(MethodType):::Adapt method type to an API we are going to use:::ptypes->for->i->args->parameterCount->return->MethodType->args->returnType->methodType
StringConcatFactory#getClassName(Class)::: string concat factory get class name:::switch->if->pkgName->hostClass->getPackageName->return->pkgName->isEmpty->pkgName->replace->else->return->hostClass->getName->replace->return->throw->new->StringConcatException
StringConcatFactory#generate(Lookup, String, MethodType, Recipe)::: string concat factory generate:::try->switch->return->BytecodeStringBuilderStrategy->generate->return->BytecodeStringBuilderStrategy->generate->return->BytecodeStringBuilderStrategy->generate->return->MethodHandleStringBuilderStrategy->generate->return->MethodHandleStringBuilderStrategy->generate->return->MethodHandleInlineCopyStrategy->generate->throw->new->StringConcatException->catch->throw->throw->new->StringConcatException->finally
StringConcatFactory.BytecodeStringBuilderStrategy#generate(Lookup, String, MethodType, Recipe, Mode)::: bytecode string builder strategy generate:::cw->new->ClassWriter->cw->visit->mv->cw->args->toMethodDescriptorString->visitMethod->mv->visitAnnotation->mv->visitCode->arr->args->parameterArray->guaranteedNonNull->new->booleanArr->if->mode->isExact->off->modOff->for->c->if->mode->isSized->off->foreach->recipe->getElements->switch->el->getTag->break->ac->el->getArgPos->cl->if->l0->new->Label->mv->visitIntInsn->mv->visitJumpInsn->mv->visitLdcInsn->mv->visitIntInsn->mv->visitLabel->getParameterSize->break->throw->el->getTag->new->StringConcatException->mv->visitTypeInsn->mv->visitInsn->if->mode->isSized->len->off->mv->visitInsn->foreach->recipe->getElements->switch->el->getTag->el->getValue->length->break->cl->el->getArgPos->if->mv->visitIntInsn->mv->visitMethodInsn->mv->visitInsn->else->if->cl->isPrimitive->estimateSize->getParameterSize->break->throw->el->getTag->new->StringConcatException->if->iconst->mv->visitInsn->mv->visitMethodInsn->else->mv->visitMethodInsn->off->foreach->recipe->getElements->desc->switch->el->getTag->mv->el->getValue->visitLdcInsn->getSBAppendDesc->break->cl->el->getArgPos->mv->getLoadOpcode->visitVarInsn->getParameterSize->getSBAppendDesc->break->throw->el->getTag->new->StringConcatException->mv->visitMethodInsn->if->mode->isExact->mv->visitInsn->mv->visitInsn->mv->visitMethodInsn->mv->visitInsn->mv->visitMethodInsn->mv->visitMethodInsn->l0->new->Label->mv->visitJumpInsn->mv->visitTypeInsn->mv->visitInsn->mv->visitLdcInsn->mv->visitMethodInsn->mv->visitInsn->mv->visitLabel->mv->visitMethodInsn->mv->visitInsn->mv->visitMaxs->mv->visitEnd->cw->visitEnd->classBytes->cw->toByteArray->try->hostClass->lookup->lookupClass->innerClass->UNSAFE->defineAnonymousClass->UNSAFE->ensureClassInitialized->innerClass->getName->dumpIfEnabled->return->findStatic->catch->dumpIfEnabled->throw->new->StringConcatException->finally
StringConcatFactory.BytecodeStringBuilderStrategy#dumpIfEnabled(String, byte[])::: bytecode string builder strategy dump if enabled:::if->DUMPER->dumpClass
StringConcatFactory.BytecodeStringBuilderStrategy#getSBAppendDesc(Class)::: bytecode string builder strategy get append desc:::if->cl->isPrimitive->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->throw->new->IllegalStateException->else->if->return->else->return
StringConcatFactory.BytecodeStringBuilderStrategy#getStringValueOfDesc(Class)::: bytecode string builder strategy get string value of desc:::if->cl->isPrimitive->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->throw->new->IllegalStateException->else->if->return->else->return
StringConcatFactory.BytecodeStringBuilderStrategy#iconst(MethodVisitor, int):::The following method is copied from org.objectweb.asm.commons.InstructionAdapter:::if->mv->visitInsn->else->if->mv->visitIntInsn->else->if->mv->visitIntInsn->else->mv->visitLdcInsn
StringConcatFactory.BytecodeStringBuilderStrategy#getLoadOpcode(Class)::: bytecode string builder strategy get load opcode:::if->throw->new->InternalError->return->getOpcodeOffset
StringConcatFactory.BytecodeStringBuilderStrategy#getOpcodeOffset(Class)::: bytecode string builder strategy get opcode offset:::if->c->isPrimitive->if->return->else->if->return->else->if->return->return->else->return
StringConcatFactory.BytecodeStringBuilderStrategy#getParameterSize(Class)::: bytecode string builder strategy get parameter size:::if->return->else->if->return->return
StringConcatFactory.MethodHandleStringBuilderStrategy#generate(MethodType, Recipe, Mode)::: method handle string builder strategy generate:::pc->mt->parameterCount->ptypes->mt->parameterArray->filters->new->MethodHandleArr->for->i->lengthers->new->MethodHandleArr->initial->foreach->recipe->getElements->switch->el->getTag->el->getValue->length->break->i->el->getArgPos->type->if->type->isPrimitive->est->MethodHandles->estimateSize->constant->MethodHandles->dropArguments->else->break->throw->el->getTag->new->StringConcatException->builder->MethodHandles->MethodHandles->identity->dropArguments->elements->recipe->getElements->for->i->elements->size->sum->getReducerFor->adder->MethodHandles->insertArguments->MethodHandles->filterArguments->newBuilder->MethodHandles->filterReturnValue->mh->MethodHandles->foldArguments->MethodHandles->filterArguments->if->mode->isExact->MethodHandles->filterReturnValue->else->MethodHandles->filterReturnValue->return
StringConcatFactory.MethodHandleStringBuilderStrategy#getReducerFor(int)::: method handle string builder strategy get reducer for:::return->SUMMERS->computeIfAbsent
StringConcatFactory.MethodHandleStringBuilderStrategy#appender(Class)::: method handle string builder strategy appender:::appender->MethodHandles->publicLookup->adaptToStringBuilder->lookupVirtual->nt->MethodType->methodType->return->appender->asType
StringConcatFactory.MethodHandleStringBuilderStrategy#toStringChecked(StringBuilder)::: method handle string builder strategy to string checked:::s->sb->toString->if->s->length->sb->capacity->throw->s->length->sb->capacity->new->AssertionError->return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int, int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int, int, int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int, int, int, int, int, int, int)::: method handle string builder strategy sum:::return
StringConcatFactory.MethodHandleStringBuilderStrategy#sum(int, int[])::: method handle string builder strategy sum:::sum->foreach->return
StringConcatFactory.MethodHandleInlineCopyStrategy#generate(MethodType, Recipe)::: method handle inline copy strategy generate:::ptypes->mt->parameterArray->filters->for->i->mh->MethodHandles->dropArguments->foreach->recipe->getElements->MethodHandles->dropArguments->switch->el->getTag->prepender->MethodHandles->prepender->el->getValue->insertArguments->MethodHandles->foldArguments->break->pos->el->getArgPos->prepender->prepender->MethodHandles->foldArguments->break->throw->el->getTag->new->StringConcatException->MethodHandles->foldArguments->initialCoder->initialLen->foreach->recipe->getElements->switch->el->getTag->constant->el->getValue->coderMixer->invoke->constant->length->break->ac->el->getArgPos->argClass->lm->lengthMixer->cm->coderMixer->MethodHandles->dropArguments->MethodHandles->foldArguments->MethodHandles->foldArguments->break->throw->el->getTag->new->StringConcatException->MethodHandles->insertArguments->if->MethodHandles->filterArguments->return
StringConcatFactory.MethodHandleInlineCopyStrategy#newArray(int, byte)::: method handle inline copy strategy new array:::return->UNSAFE->allocateUninitializedArray
StringConcatFactory.MethodHandleInlineCopyStrategy#prepender(Class)::: method handle inline copy strategy prepender:::return->PREPENDERS->computeIfAbsent
StringConcatFactory.MethodHandleInlineCopyStrategy#coderMixer(Class)::: method handle inline copy strategy coder mixer:::return->CODER_MIXERS->computeIfAbsent
StringConcatFactory.MethodHandleInlineCopyStrategy#lengthMixer(Class)::: method handle inline copy strategy length mixer:::return->LENGTH_MIXERS->computeIfAbsent
StringConcatFactory.Stringifiers.StringifierMost#computeValue(Class)::: stringifier most compute value:::if->return->MethodHandles->publicLookup->lookupStatic->else->if->return->MethodHandles->publicLookup->lookupStatic->else->if->return->MethodHandles->publicLookup->lookupStatic->else->if->cl->isPrimitive->mhObject->MethodHandles->publicLookup->lookupStatic->return->MethodHandles->mhObject->MethodType->methodType->asType->filterReturnValue->return
StringConcatFactory.Stringifiers.StringifierAny#computeValue(Class)::: stringifier any compute value:::if->return->MethodHandles->publicLookup->lookupStatic->else->if->return->MethodHandles->publicLookup->lookupStatic->else->if->return->MethodHandles->publicLookup->lookupStatic->else->if->return->MethodHandles->publicLookup->lookupStatic->else->mh->STRINGIFIERS_MOST->get->if->return->else->throw->new->IllegalStateException
StringConcatFactory.Stringifiers#forMost(Class):::Returns a stringifier for references and floats/doubles only:::return->STRINGIFIERS_MOST->get
StringConcatFactory.Stringifiers#forAny(Class):::Returns a stringifier for any type:::return->STRINGIFIERS_ANY->get
StringConcatFactory#lookupStatic(Lookup, Class, String, Class, Class...)::: string concat factory lookup static:::try->return->lookup->MethodType->methodType->findStatic->catch->throw->new->AssertionError->finally
StringConcatFactory#lookupVirtual(Lookup, Class, String, Class, Class...)::: string concat factory lookup virtual:::try->return->lookup->MethodType->methodType->findVirtual->catch->throw->new->AssertionError->finally
StringConcatFactory#lookupConstructor(Lookup, Class, Class)::: string concat factory lookup constructor:::try->return->lookup->MethodType->methodType->findConstructor->catch->throw->new->AssertionError->finally
StringConcatFactory#estimateSize(Class)::: string concat factory estimate size:::if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->throw->new->IllegalArgumentException
StringConcatFactory#adaptToStringBuilder(Class)::: string concat factory adapt to string builder:::if->c->isPrimitive->if->return->else->if->return->return
SwitchPoint#hasBeenInvalidated():::Determines if this switch point has been invalidated yet:::return->mcs->getTarget
SwitchPoint#guardWithTest(MethodHandle, MethodHandle):::Returns a method handle which always delegates either to the target or the fallback:::if->mcs->getTarget->return->return->MethodHandles->guardWithTest
SwitchPoint#invalidateAll(SwitchPoint[]):::Sets all of the given switch points into the invalid state:::if->return->sites->new->MutableCallSiteArr->for->i->MutableCallSite->syncAll
TypeConvertingMethodAdapter#initWidening(Wrapper, int, Wrapper...)::: type converting method adapter init widening:::foreach->f->ordinal->to->ordinal
TypeConvertingMethodAdapter#hashWrapperName(String):::Class name to Wrapper hash, derived from Wrapper.hashWrap():::if->xn->length->return->return->xn->charAt->xn->charAt
TypeConvertingMethodAdapter#wrapperOrNullFromDescriptor(String)::: type converting method adapter wrapper or null from descriptor:::if->desc->startsWith->return->cname->desc->WRAPPER_PREFIX->length->desc->length->substring->w->hashWrapperName->if->w->wrapperSimpleName->equals->return->else->return
TypeConvertingMethodAdapter#wrapperName(Wrapper)::: type converting method adapter wrapper name:::return->w->wrapperSimpleName
TypeConvertingMethodAdapter#unboxMethod(Wrapper)::: type converting method adapter unbox method:::return->w->primitiveSimpleName
TypeConvertingMethodAdapter#boxingDescriptor(Wrapper)::: type converting method adapter boxing descriptor:::return->w->basicTypeChar->wrapperName
TypeConvertingMethodAdapter#unboxingDescriptor(Wrapper)::: type converting method adapter unboxing descriptor:::return->w->basicTypeChar
TypeConvertingMethodAdapter#boxIfTypePrimitive(Type)::: type converting method adapter box if type primitive:::w->t->getSort->if->box
TypeConvertingMethodAdapter#widen(Wrapper, Wrapper)::: type converting method adapter widen:::if->opcode->ws->ordinal->wt->ordinal->if->visitInsn
TypeConvertingMethodAdapter#box(Wrapper)::: type converting method adapter box:::wrapperName->boxingDescriptor->visitMethodInsn
TypeConvertingMethodAdapter#unbox(String, Wrapper):::Convert types by unboxing:::unboxMethod->unboxingDescriptor->visitMethodInsn
TypeConvertingMethodAdapter#descriptorToName(String)::: type converting method adapter descriptor to name:::last->desc->length->if->desc->charAt->desc->charAt->return->desc->substring->else->return
TypeConvertingMethodAdapter#cast(String, String)::: type converting method adapter cast:::ns->descriptorToName->nt->descriptorToName->if->nt->equals->nt->equals->visitTypeInsn
TypeConvertingMethodAdapter#toWrapper(String)::: type converting method adapter to wrapper:::first->desc->charAt->if->return->Wrapper->forBasicType
TypeConvertingMethodAdapter#convertType(Class, Class, Class):::Convert an argument of type 'arg' to be passed to 'target' assuring that it is 'functional':::if->arg->equals->arg->equals->return->if->return->if->arg->isPrimitive->wArg->Wrapper->forPrimitiveType->if->target->isPrimitive->Wrapper->forPrimitiveType->widen->else->dTarget->BytecodeDescriptor->unparse->wPrimTarget->wrapperOrNullFromDescriptor->if->widen->box->else->box->wrapperName->cast->else->dArg->BytecodeDescriptor->unparse->dSrc->if->functional->isPrimitive->else->BytecodeDescriptor->unparse->cast->dTarget->BytecodeDescriptor->unparse->if->target->isPrimitive->wTarget->toWrapper->wps->wrapperOrNullFromDescriptor->if->if->wps->isSigned->wps->isFloating->wrapperName->unbox->else->wrapperName->unbox->widen->else->intermediate->if->wTarget->isSigned->wTarget->isFloating->else->wrapperName->cast->unbox->else->cast
TypeConvertingMethodAdapter#iconst(int):::The following method is copied from org.objectweb.asm.commons.InstructionAdapter:::if->mv->visitInsn->else->if->mv->visitIntInsn->else->if->mv->visitIntInsn->else->mv->visitLdcInsn
VarForm#getMethodType(int)::: var form get method type:::return
VarForm#getMemberName(int)::: var form get member name:::mn->if->throw->new->UnsupportedOperationException->return
VarForm#getMethodType_V_init()::: var form get method type_ v_init:::table->values->new->MethodTypeArr->for->i->return
VarForm#getMethodType_V(int)::: var form get method type_ v:::table->if->getMethodType_V_init->return
VarForm#linkFromStatic(Class):::Link all signature polymorphic methods.:::table->AccessMode->values->new->MemberNameArr->for->c->c->getSuperclass->return
VarHandle#unsupported()::: var handle unsupported:::return->new->UnsupportedOperationException
VarHandle#get(Object...):::Returns the value of a variable, with memory semantics of reading as if the variable was declared non-volatile:::
VarHandle#set(Object...):::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared non-volatile and non-final:::
VarHandle#getVolatile(Object...):::Returns the value of a variable, with memory semantics of reading as if the variable was declared volatile:::
VarHandle#setVolatile(Object...):::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared volatile:::
VarHandle#getOpaque(Object...):::Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads:::
VarHandle#setOpaque(Object...):::Sets the value of a variable to the newValue, in program order, but with no assurance of memory ordering effects with respect to other threads:::
VarHandle#getAcquire(Object...):::Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access:::
VarHandle#setRelease(Object...):::Sets the value of a variable to the newValue, and ensures that prior loads and stores are not reordered after this access:::
VarHandle#compareAndSet(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#compareAndExchange(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#compareAndExchangeAcquire(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire:::
VarHandle#compareAndExchangeRelease(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#weakCompareAndSetPlain(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#weakCompareAndSet(Object...):::Possibly atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile:::
VarHandle#weakCompareAndSetAcquire(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire:::
VarHandle#weakCompareAndSetRelease(Object...):::Possibly atomically sets the value of a variable to the newValue with the semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get:::
VarHandle#getAndSet(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndSetAcquire(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndSetRelease(Object...):::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndAdd(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #setVolatile, and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndAddAcquire(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #set, and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndAddRelease(Object...):::Atomically adds the value to the current value of a variable with the memory semantics of #setRelease, and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseOr(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseOrAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseOrRelease(Object...):::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseAnd(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseAndAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseAndRelease(Object...):::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#getAndBitwiseXor(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile:::
VarHandle#getAndBitwiseXorAcquire(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire:::
VarHandle#getAndBitwiseXorRelease(Object...):::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get:::
VarHandle#varType():::Returns the variable type of variables referenced by this VarHandle.:::typeSet->accessModeType->return->typeSet->typeSet->parameterCount->parameterType
VarHandle#coordinateTypes():::Returns the coordinate types for this VarHandle.:::typeGet->accessModeType->return->typeGet->parameterList
VarHandle#accessModeType(AccessMode):::Obtains the access mode type for this VarHandle and a given access mode:::tis->getTypesAndInvokers->mt->ordinal->if->accessModeTypeUncached->ordinal->return
VarHandle#accessModeTypeUncached(AccessMode)::: var handle access mode type uncached:::
VarHandle#isAccessModeSupported(AccessMode):::Returns true if the given access mode is supported, otherwise false:::return->AccessMode->accessMode->ordinal->getMemberName
VarHandle#toMethodHandle(AccessMode):::Obtains a method handle bound to this VarHandle and the given access mode.:::mn->AccessMode->accessMode->ordinal->getMemberName->if->mh->accessMode->ordinal->getMethodHandle->return->mh->bindTo->else->return->MethodHandles->accessModeType->varHandleInvoker->bindTo
VarHandle#getTypesAndInvokers()::: var handle get types and invokers:::tis->if->new->TypesAndInvokers->return
VarHandle#getMethodHandle(int)::: var handle get method handle:::tis->getTypesAndInvokers->mh->if->getMethodHandleUncached->return
VarHandle#getMethodHandleUncached(int)::: var handle get method handle uncached:::mt->AccessMode->values->accessModeType->insertParameterTypes->mn->vform->getMemberName->dmh->DirectMethodHandle->make->mh->dmh->copyWith->return
VarHandle#updateVarForm(VarForm)::: var handle update var form:::if->return->UNSAFE->putObject->UNSAFE->fullFence
VarHandle#fullFence():::Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.:::UNSAFE->fullFence
VarHandle#acquireFence():::Ensures that loads before the fence will not be reordered with loads and stores after the fence.:::UNSAFE->loadFence
VarHandle#releaseFence():::Ensures that loads and stores before the fence will not be reordered with stores after the fence.:::UNSAFE->storeFence
VarHandle#loadLoadFence():::Ensures that loads before the fence will not be reordered with loads after the fence.:::UNSAFE->loadLoadFence
VarHandle#storeStoreFence():::Ensures that stores before the fence will not be reordered with stores after the fence.:::UNSAFE->storeStoreFence
VarHandleBooleans.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleBooleans.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getBoolean
VarHandleBooleans.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getBooleanVolatile
VarHandleBooleans.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getBooleanOpaque
VarHandleBooleans.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, boolean)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putBoolean
VarHandleBooleans.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, boolean)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putBooleanVolatile
VarHandleBooleans.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, boolean)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putBooleanOpaque
VarHandleBooleans.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, boolean)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetBoolean
VarHandleBooleans.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeBoolean
VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetBooleanPlain
VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetBoolean
VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, boolean, boolean)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetBoolean
VarHandleBooleans.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrBoolean
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndBoolean
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndBooleanAcquire
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorBoolean
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorBooleanRelease
VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, boolean)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorBooleanAcquire
VarHandleBooleans.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleBooleans.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getBoolean
VarHandleBooleans.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getBooleanVolatile
VarHandleBooleans.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getBooleanOpaque
VarHandleBooleans.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#set(FieldStaticReadWrite, boolean)::: field static read write set:::UNSAFE->putBoolean
VarHandleBooleans.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, boolean)::: field static read write set volatile:::UNSAFE->putBooleanVolatile
VarHandleBooleans.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, boolean)::: field static read write set opaque:::UNSAFE->putBooleanOpaque
VarHandleBooleans.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, boolean)::: field static read write set release:::UNSAFE->putBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, boolean, boolean)::: field static read write compare and set:::return->UNSAFE->compareAndSetBoolean
VarHandleBooleans.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, boolean, boolean)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeBoolean
VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, boolean, boolean)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, boolean, boolean)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, boolean, boolean)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetBooleanPlain
VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, boolean, boolean)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetBoolean
VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, boolean, boolean)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, boolean, boolean)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, boolean)::: field static read write get and set:::return->UNSAFE->getAndSetBoolean
VarHandleBooleans.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, boolean)::: field static read write get and set acquire:::return->UNSAFE->getAndSetBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, boolean)::: field static read write get and set release:::return->UNSAFE->getAndSetBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, boolean)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrBoolean
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, boolean)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, boolean)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, boolean)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndBoolean
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, boolean)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, boolean)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndBooleanAcquire
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, boolean)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorBoolean
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, boolean)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorBooleanRelease
VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, boolean)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorBooleanAcquire
VarHandleBooleans.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleBooleans.Array#get(Array, Object, int)::: array get:::array->return
VarHandleBooleans.Array#set(Array, Object, int, boolean)::: array set:::array
VarHandleBooleans.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getBooleanVolatile
VarHandleBooleans.Array#setVolatile(Array, Object, int, boolean)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putBooleanVolatile
VarHandleBooleans.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getBooleanOpaque
VarHandleBooleans.Array#setOpaque(Array, Object, int, boolean)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putBooleanOpaque
VarHandleBooleans.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getBooleanAcquire
VarHandleBooleans.Array#setRelease(Array, Object, int, boolean)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putBooleanRelease
VarHandleBooleans.Array#compareAndSet(Array, Object, int, boolean, boolean)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetBoolean
VarHandleBooleans.Array#compareAndExchange(Array, Object, int, boolean, boolean)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeBoolean
VarHandleBooleans.Array#compareAndExchangeAcquire(Array, Object, int, boolean, boolean)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeBooleanAcquire
VarHandleBooleans.Array#compareAndExchangeRelease(Array, Object, int, boolean, boolean)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeBooleanRelease
VarHandleBooleans.Array#weakCompareAndSetPlain(Array, Object, int, boolean, boolean)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetBooleanPlain
VarHandleBooleans.Array#weakCompareAndSet(Array, Object, int, boolean, boolean)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetBoolean
VarHandleBooleans.Array#weakCompareAndSetAcquire(Array, Object, int, boolean, boolean)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetBooleanAcquire
VarHandleBooleans.Array#weakCompareAndSetRelease(Array, Object, int, boolean, boolean)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetBooleanRelease
VarHandleBooleans.Array#getAndSet(Array, Object, int, boolean)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetBoolean
VarHandleBooleans.Array#getAndSetAcquire(Array, Object, int, boolean)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetBooleanAcquire
VarHandleBooleans.Array#getAndSetRelease(Array, Object, int, boolean)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetBooleanRelease
VarHandleBooleans.Array#getAndBitwiseOr(Array, Object, int, boolean)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrBoolean
VarHandleBooleans.Array#getAndBitwiseOrRelease(Array, Object, int, boolean)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrBooleanRelease
VarHandleBooleans.Array#getAndBitwiseOrAcquire(Array, Object, int, boolean)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrBooleanAcquire
VarHandleBooleans.Array#getAndBitwiseAnd(Array, Object, int, boolean)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndBoolean
VarHandleBooleans.Array#getAndBitwiseAndRelease(Array, Object, int, boolean)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndBooleanRelease
VarHandleBooleans.Array#getAndBitwiseAndAcquire(Array, Object, int, boolean)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndBooleanAcquire
VarHandleBooleans.Array#getAndBitwiseXor(Array, Object, int, boolean)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorBoolean
VarHandleBooleans.Array#getAndBitwiseXorRelease(Array, Object, int, boolean)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorBooleanRelease
VarHandleBooleans.Array#getAndBitwiseXorAcquire(Array, Object, int, boolean)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorBooleanAcquire
VarHandleByteArrayAsChars#convEndian(boolean, char)::: var handle byte array as chars conv endian:::return->Character->reverseBytes
VarHandleByteArrayAsChars.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsChars.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsChars.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsChars.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->return->UNSAFE->index->getCharUnaligned
VarHandleByteArrayAsChars.ArrayHandle#set(ArrayHandle, Object, int, char)::: array handle set:::ba->UNSAFE->index->putCharUnaligned
VarHandleByteArrayAsChars.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getCharVolatile->convEndian
VarHandleByteArrayAsChars.ArrayHandle#setVolatile(ArrayHandle, Object, int, char)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putCharVolatile
VarHandleByteArrayAsChars.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getCharAcquire->convEndian
VarHandleByteArrayAsChars.ArrayHandle#setRelease(ArrayHandle, Object, int, char)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putCharRelease
VarHandleByteArrayAsChars.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getCharOpaque->convEndian
VarHandleByteArrayAsChars.ArrayHandle#setOpaque(ArrayHandle, Object, int, char)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putCharOpaque
VarHandleByteArrayAsChars.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsChars.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsChars.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsChars.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsChars.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getCharUnaligned
VarHandleByteArrayAsChars.ByteBufferHandle#set(ByteBufferHandle, Object, int, char)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->putCharUnaligned
VarHandleByteArrayAsChars.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getCharVolatile->convEndian
VarHandleByteArrayAsChars.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, char)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putCharVolatile
VarHandleByteArrayAsChars.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getCharAcquire->convEndian
VarHandleByteArrayAsChars.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, char)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putCharRelease
VarHandleByteArrayAsChars.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getCharOpaque->convEndian
VarHandleByteArrayAsChars.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, char)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putCharOpaque
VarHandleByteArrayAsDoubles#convEndian(boolean, double)::: var handle byte array as doubles conv endian:::rv->Double->doubleToRawLongBits->return->Long->reverseBytes
VarHandleByteArrayAsDoubles#convEndian(boolean, long)::: var handle byte array as doubles conv endian:::Long->reverseBytes->return->Double->longBitsToDouble
VarHandleByteArrayAsDoubles.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsDoubles.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsDoubles.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsDoubles.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->rawValue->UNSAFE->index->getLongUnaligned->return->Double->longBitsToDouble
VarHandleByteArrayAsDoubles.ArrayHandle#set(ArrayHandle, Object, int, double)::: array handle set:::ba->UNSAFE->index->Double->doubleToRawLongBits->putLongUnaligned
VarHandleByteArrayAsDoubles.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getLongVolatile->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#setVolatile(ArrayHandle, Object, int, double)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putLongVolatile
VarHandleByteArrayAsDoubles.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#setRelease(ArrayHandle, Object, int, double)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putLongRelease
VarHandleByteArrayAsDoubles.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getLongOpaque->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#setOpaque(ArrayHandle, Object, int, double)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putLongOpaque
VarHandleByteArrayAsDoubles.ArrayHandle#compareAndSet(ArrayHandle, Object, int, double, double)::: array handle compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndSetLong
VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, double, double)::: array handle compare and exchange:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLong->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, double, double)::: array handle compare and exchange acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, double, double)::: array handle compare and exchange release:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLongRelease->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, double, double)::: array handle weak compare and set plain:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongPlain
VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, double, double)::: array handle weak compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLong
VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, double, double)::: array handle weak compare and set acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongAcquire
VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, double, double)::: array handle weak compare and set release:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongRelease
VarHandleByteArrayAsDoubles.ArrayHandle#getAndSet(ArrayHandle, Object, int, double)::: array handle get and set:::ba->return->UNSAFE->index->address->convEndian->getAndSetLong->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, double)::: array handle get and set acquire:::ba->return->UNSAFE->index->address->convEndian->getAndSetLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, double)::: array handle get and set release:::ba->return->UNSAFE->index->address->convEndian->getAndSetLongRelease->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsDoubles.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsDoubles.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsDoubles.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsDoubles.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->rawValue->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getLongUnaligned->return->Double->longBitsToDouble
VarHandleByteArrayAsDoubles.ByteBufferHandle#set(ByteBufferHandle, Object, int, double)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->Double->doubleToRawLongBits->putLongUnaligned
VarHandleByteArrayAsDoubles.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongVolatile->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, double)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongVolatile
VarHandleByteArrayAsDoubles.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, double)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongRelease
VarHandleByteArrayAsDoubles.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongOpaque->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, double)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongOpaque
VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, double, double)::: byte buffer handle compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndSetLong
VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, double, double)::: byte buffer handle compare and exchange:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLong->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, double, double)::: byte buffer handle compare and exchange acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, double, double)::: byte buffer handle compare and exchange release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLongRelease->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, double, double)::: byte buffer handle weak compare and set plain:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongPlain
VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, double, double)::: byte buffer handle weak compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLong
VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, double, double)::: byte buffer handle weak compare and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongAcquire
VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, double, double)::: byte buffer handle weak compare and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongRelease
VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, double)::: byte buffer handle get and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLong->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, double)::: byte buffer handle get and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLongAcquire->convEndian
VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, double)::: byte buffer handle get and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLongRelease->convEndian
VarHandleByteArrayAsFloats#convEndian(boolean, float)::: var handle byte array as floats conv endian:::rv->Float->floatToRawIntBits->return->Integer->reverseBytes
VarHandleByteArrayAsFloats#convEndian(boolean, int)::: var handle byte array as floats conv endian:::Integer->reverseBytes->return->Float->intBitsToFloat
VarHandleByteArrayAsFloats.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsFloats.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsFloats.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsFloats.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->rawValue->UNSAFE->index->getIntUnaligned->return->Float->intBitsToFloat
VarHandleByteArrayAsFloats.ArrayHandle#set(ArrayHandle, Object, int, float)::: array handle set:::ba->UNSAFE->index->Float->floatToRawIntBits->putIntUnaligned
VarHandleByteArrayAsFloats.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getIntVolatile->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#setVolatile(ArrayHandle, Object, int, float)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putIntVolatile
VarHandleByteArrayAsFloats.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getIntAcquire->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#setRelease(ArrayHandle, Object, int, float)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putIntRelease
VarHandleByteArrayAsFloats.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getIntOpaque->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#setOpaque(ArrayHandle, Object, int, float)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putIntOpaque
VarHandleByteArrayAsFloats.ArrayHandle#compareAndSet(ArrayHandle, Object, int, float, float)::: array handle compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndSetInt
VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, float, float)::: array handle compare and exchange:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeInt->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, float, float)::: array handle compare and exchange acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeIntAcquire->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, float, float)::: array handle compare and exchange release:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeIntRelease->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, float, float)::: array handle weak compare and set plain:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntPlain
VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, float, float)::: array handle weak compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetInt
VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, float, float)::: array handle weak compare and set acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntAcquire
VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, float, float)::: array handle weak compare and set release:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntRelease
VarHandleByteArrayAsFloats.ArrayHandle#getAndSet(ArrayHandle, Object, int, float)::: array handle get and set:::ba->return->UNSAFE->index->address->convEndian->getAndSetInt->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, float)::: array handle get and set acquire:::ba->return->UNSAFE->index->address->convEndian->getAndSetIntAcquire->convEndian
VarHandleByteArrayAsFloats.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, float)::: array handle get and set release:::ba->return->UNSAFE->index->address->convEndian->getAndSetIntRelease->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsFloats.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsFloats.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsFloats.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsFloats.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->rawValue->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getIntUnaligned->return->Float->intBitsToFloat
VarHandleByteArrayAsFloats.ByteBufferHandle#set(ByteBufferHandle, Object, int, float)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->Float->floatToRawIntBits->putIntUnaligned
VarHandleByteArrayAsFloats.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntVolatile->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, float)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntVolatile
VarHandleByteArrayAsFloats.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntAcquire->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, float)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntRelease
VarHandleByteArrayAsFloats.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntOpaque->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, float)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntOpaque
VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, float, float)::: byte buffer handle compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndSetInt
VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, float, float)::: byte buffer handle compare and exchange:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeInt->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, float, float)::: byte buffer handle compare and exchange acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeIntAcquire->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, float, float)::: byte buffer handle compare and exchange release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeIntRelease->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, float, float)::: byte buffer handle weak compare and set plain:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntPlain
VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, float, float)::: byte buffer handle weak compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetInt
VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, float, float)::: byte buffer handle weak compare and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntAcquire
VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, float, float)::: byte buffer handle weak compare and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntRelease
VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, float)::: byte buffer handle get and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetInt->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, float)::: byte buffer handle get and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetIntAcquire->convEndian
VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, float)::: byte buffer handle get and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetIntRelease->convEndian
VarHandleByteArrayAsInts#convEndian(boolean, int)::: var handle byte array as ints conv endian:::return->Integer->reverseBytes
VarHandleByteArrayAsInts.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsInts.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsInts.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsInts.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->return->UNSAFE->index->getIntUnaligned
VarHandleByteArrayAsInts.ArrayHandle#set(ArrayHandle, Object, int, int)::: array handle set:::ba->UNSAFE->index->putIntUnaligned
VarHandleByteArrayAsInts.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getIntVolatile->convEndian
VarHandleByteArrayAsInts.ArrayHandle#setVolatile(ArrayHandle, Object, int, int)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putIntVolatile
VarHandleByteArrayAsInts.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getIntAcquire->convEndian
VarHandleByteArrayAsInts.ArrayHandle#setRelease(ArrayHandle, Object, int, int)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putIntRelease
VarHandleByteArrayAsInts.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getIntOpaque->convEndian
VarHandleByteArrayAsInts.ArrayHandle#setOpaque(ArrayHandle, Object, int, int)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putIntOpaque
VarHandleByteArrayAsInts.ArrayHandle#compareAndSet(ArrayHandle, Object, int, int, int)::: array handle compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndSetInt
VarHandleByteArrayAsInts.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, int, int)::: array handle compare and exchange:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeInt->convEndian
VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, int, int)::: array handle compare and exchange acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeIntAcquire->convEndian
VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, int, int)::: array handle compare and exchange release:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeIntRelease->convEndian
VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, int, int)::: array handle weak compare and set plain:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntPlain
VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, int, int)::: array handle weak compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetInt
VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, int, int)::: array handle weak compare and set acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntAcquire
VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, int, int)::: array handle weak compare and set release:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetIntRelease
VarHandleByteArrayAsInts.ArrayHandle#getAndSet(ArrayHandle, Object, int, int)::: array handle get and set:::ba->return->UNSAFE->index->address->convEndian->getAndSetInt->convEndian
VarHandleByteArrayAsInts.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, int)::: array handle get and set acquire:::ba->return->UNSAFE->index->address->convEndian->getAndSetIntAcquire->convEndian
VarHandleByteArrayAsInts.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, int)::: array handle get and set release:::ba->return->UNSAFE->index->address->convEndian->getAndSetIntRelease->convEndian
VarHandleByteArrayAsInts.ArrayHandle#getAndAdd(ArrayHandle, Object, int, int)::: array handle get and add:::ba->if->return->UNSAFE->index->address->getAndAddInt->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, int)::: array handle get and add acquire:::ba->if->return->UNSAFE->index->address->getAndAddIntAcquire->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, int)::: array handle get and add release:::ba->if->return->UNSAFE->index->address->getAndAddIntRelease->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, int)::: array handle get and add conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, int)::: array handle get and bitwise or:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrInt->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, int)::: array handle get and bitwise or release:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrIntRelease->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, int)::: array handle get and bitwise or acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrIntAcquire->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, int)::: array handle get and bitwise or conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, int)::: array handle get and bitwise and:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndInt->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, int)::: array handle get and bitwise and release:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndIntRelease->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, int)::: array handle get and bitwise and acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndIntAcquire->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, int)::: array handle get and bitwise and conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, int)::: array handle get and bitwise xor:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorInt->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, int)::: array handle get and bitwise xor release:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorIntRelease->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, int)::: array handle get and bitwise xor acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorIntAcquire->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, int)::: array handle get and bitwise xor conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsInts.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsInts.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsInts.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsInts.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getIntUnaligned
VarHandleByteArrayAsInts.ByteBufferHandle#set(ByteBufferHandle, Object, int, int)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->putIntUnaligned
VarHandleByteArrayAsInts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntVolatile->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, int)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntVolatile
VarHandleByteArrayAsInts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntAcquire->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntRelease
VarHandleByteArrayAsInts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getIntOpaque->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, int)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putIntOpaque
VarHandleByteArrayAsInts.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, int, int)::: byte buffer handle compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndSetInt
VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, int, int)::: byte buffer handle compare and exchange:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeInt->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, int, int)::: byte buffer handle compare and exchange acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeIntAcquire->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, int, int)::: byte buffer handle compare and exchange release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeIntRelease->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, int, int)::: byte buffer handle weak compare and set plain:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntPlain
VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, int, int)::: byte buffer handle weak compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetInt
VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, int, int)::: byte buffer handle weak compare and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntAcquire
VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, int, int)::: byte buffer handle weak compare and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetIntRelease
VarHandleByteArrayAsInts.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, int)::: byte buffer handle get and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetInt->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, int)::: byte buffer handle get and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetIntAcquire->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle get and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetIntRelease->convEndian
VarHandleByteArrayAsInts.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, int)::: byte buffer handle get and add:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddInt->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, int)::: byte buffer handle get and add acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddIntAcquire->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle get and add release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddIntRelease->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, int)::: byte buffer handle get and add conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise or:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrInt->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise or release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrIntRelease->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise or acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrIntAcquire->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, int)::: byte buffer handle get and bitwise or conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise and:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndInt->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise and release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndIntRelease->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise and acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndIntAcquire->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, int)::: byte buffer handle get and bitwise and conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise xor:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorInt->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise xor release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorIntRelease->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, int)::: byte buffer handle get and bitwise xor acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorIntAcquire->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, int)::: byte buffer handle get and bitwise xor conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getIntVolatile->Integer->reverseBytes->while->UNSAFE->Integer->reverseBytes->weakCompareAndSetInt->return
VarHandleByteArrayAsLongs#convEndian(boolean, long)::: var handle byte array as longs conv endian:::return->Long->reverseBytes
VarHandleByteArrayAsLongs.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsLongs.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsLongs.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsLongs.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->return->UNSAFE->index->getLongUnaligned
VarHandleByteArrayAsLongs.ArrayHandle#set(ArrayHandle, Object, int, long)::: array handle set:::ba->UNSAFE->index->putLongUnaligned
VarHandleByteArrayAsLongs.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getLongVolatile->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#setVolatile(ArrayHandle, Object, int, long)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putLongVolatile
VarHandleByteArrayAsLongs.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getLongAcquire->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#setRelease(ArrayHandle, Object, int, long)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putLongRelease
VarHandleByteArrayAsLongs.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getLongOpaque->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#setOpaque(ArrayHandle, Object, int, long)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putLongOpaque
VarHandleByteArrayAsLongs.ArrayHandle#compareAndSet(ArrayHandle, Object, int, long, long)::: array handle compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndSetLong
VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, long, long)::: array handle compare and exchange:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLong->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, long, long)::: array handle compare and exchange acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLongAcquire->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, long, long)::: array handle compare and exchange release:::ba->return->UNSAFE->index->address->convEndian->convEndian->compareAndExchangeLongRelease->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, long, long)::: array handle weak compare and set plain:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongPlain
VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, long, long)::: array handle weak compare and set:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLong
VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, long, long)::: array handle weak compare and set acquire:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongAcquire
VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, long, long)::: array handle weak compare and set release:::ba->return->UNSAFE->index->address->convEndian->convEndian->weakCompareAndSetLongRelease
VarHandleByteArrayAsLongs.ArrayHandle#getAndSet(ArrayHandle, Object, int, long)::: array handle get and set:::ba->return->UNSAFE->index->address->convEndian->getAndSetLong->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, long)::: array handle get and set acquire:::ba->return->UNSAFE->index->address->convEndian->getAndSetLongAcquire->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, long)::: array handle get and set release:::ba->return->UNSAFE->index->address->convEndian->getAndSetLongRelease->convEndian
VarHandleByteArrayAsLongs.ArrayHandle#getAndAdd(ArrayHandle, Object, int, long)::: array handle get and add:::ba->if->return->UNSAFE->index->address->getAndAddLong->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, long)::: array handle get and add acquire:::ba->if->return->UNSAFE->index->address->getAndAddLongAcquire->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, long)::: array handle get and add release:::ba->if->return->UNSAFE->index->address->getAndAddLongRelease->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, long)::: array handle get and add conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, long)::: array handle get and bitwise or:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrLong->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, long)::: array handle get and bitwise or release:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrLongRelease->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, long)::: array handle get and bitwise or acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseOrLongAcquire->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, long)::: array handle get and bitwise or conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, long)::: array handle get and bitwise and:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndLong->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, long)::: array handle get and bitwise and release:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndLongRelease->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, long)::: array handle get and bitwise and acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseAndLongAcquire->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, long)::: array handle get and bitwise and conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, long)::: array handle get and bitwise xor:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorLong->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, long)::: array handle get and bitwise xor release:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorLongRelease->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, long)::: array handle get and bitwise xor acquire:::ba->if->return->UNSAFE->index->address->getAndBitwiseXorLongAcquire->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, long)::: array handle get and bitwise xor conv endian with s:::nativeExpectedValue->expectedValue->offset->index->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsLongs.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsLongs.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsLongs.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsLongs.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getLongUnaligned
VarHandleByteArrayAsLongs.ByteBufferHandle#set(ByteBufferHandle, Object, int, long)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->putLongUnaligned
VarHandleByteArrayAsLongs.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongVolatile->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, long)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongVolatile
VarHandleByteArrayAsLongs.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongAcquire->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongRelease
VarHandleByteArrayAsLongs.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getLongOpaque->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, long)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putLongOpaque
VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, long, long)::: byte buffer handle compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndSetLong
VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, long, long)::: byte buffer handle compare and exchange:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLong->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, long, long)::: byte buffer handle compare and exchange acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLongAcquire->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, long, long)::: byte buffer handle compare and exchange release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->compareAndExchangeLongRelease->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, long, long)::: byte buffer handle weak compare and set plain:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongPlain
VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, long, long)::: byte buffer handle weak compare and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLong
VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, long, long)::: byte buffer handle weak compare and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongAcquire
VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, long, long)::: byte buffer handle weak compare and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->convEndian->weakCompareAndSetLongRelease
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, long)::: byte buffer handle get and set:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLong->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, long)::: byte buffer handle get and set acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLongAcquire->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle get and set release:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->getAndSetLongRelease->convEndian
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, long)::: byte buffer handle get and add:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddLong->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, long)::: byte buffer handle get and add acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddLongAcquire->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle get and add release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndAddLongRelease->else->return->getAndAddConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, long)::: byte buffer handle get and add conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise or:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrLong->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise or release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrLongRelease->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise or acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseOrLongAcquire->else->return->getAndBitwiseOrConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, long)::: byte buffer handle get and bitwise or conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise and:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndLong->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise and release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndLongRelease->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise and acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseAndLongAcquire->else->return->getAndBitwiseAndConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, long)::: byte buffer handle get and bitwise and conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise xor:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorLong->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise xor release:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorLongRelease->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, long)::: byte buffer handle get and bitwise xor acquire:::bb->Objects->requireNonNull->if->return->UNSAFE->UNSAFE->getObject->indexRO->address->getAndBitwiseXorLongAcquire->else->return->getAndBitwiseXorConvEndianWithCAS
VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, long)::: byte buffer handle get and bitwise xor conv endian with s:::nativeExpectedValue->expectedValue->base->UNSAFE->getObject->offset->indexRO->address->do->UNSAFE->getLongVolatile->Long->reverseBytes->while->UNSAFE->Long->reverseBytes->weakCompareAndSetLong->return
VarHandleByteArrayAsShorts#convEndian(boolean, short)::: var handle byte array as shorts conv endian:::return->Short->reverseBytes
VarHandleByteArrayAsShorts.ArrayHandle#accessModeTypeUncached(AccessMode)::: array handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsShorts.ArrayHandle#index(byte[], int)::: array handle index:::return->Preconditions->checkIndex
VarHandleByteArrayAsShorts.ArrayHandle#address(byte[], int)::: array handle address:::address->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsShorts.ArrayHandle#get(ArrayHandle, Object, int)::: array handle get:::ba->return->UNSAFE->index->getShortUnaligned
VarHandleByteArrayAsShorts.ArrayHandle#set(ArrayHandle, Object, int, short)::: array handle set:::ba->UNSAFE->index->putShortUnaligned
VarHandleByteArrayAsShorts.ArrayHandle#getVolatile(ArrayHandle, Object, int)::: array handle get volatile:::ba->return->UNSAFE->index->address->getShortVolatile->convEndian
VarHandleByteArrayAsShorts.ArrayHandle#setVolatile(ArrayHandle, Object, int, short)::: array handle set volatile:::ba->UNSAFE->index->address->convEndian->putShortVolatile
VarHandleByteArrayAsShorts.ArrayHandle#getAcquire(ArrayHandle, Object, int)::: array handle get acquire:::ba->return->UNSAFE->index->address->getShortAcquire->convEndian
VarHandleByteArrayAsShorts.ArrayHandle#setRelease(ArrayHandle, Object, int, short)::: array handle set release:::ba->UNSAFE->index->address->convEndian->putShortRelease
VarHandleByteArrayAsShorts.ArrayHandle#getOpaque(ArrayHandle, Object, int)::: array handle get opaque:::ba->return->UNSAFE->index->address->getShortOpaque->convEndian
VarHandleByteArrayAsShorts.ArrayHandle#setOpaque(ArrayHandle, Object, int, short)::: array handle set opaque:::ba->UNSAFE->index->address->convEndian->putShortOpaque
VarHandleByteArrayAsShorts.ByteBufferHandle#accessModeTypeUncached(AccessMode)::: byte buffer handle access mode type uncached:::return->accessModeType
VarHandleByteArrayAsShorts.ByteBufferHandle#index(ByteBuffer, int)::: byte buffer handle index:::return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsShorts.ByteBufferHandle#indexRO(ByteBuffer, int)::: byte buffer handle index o:::if->UNSAFE->getBoolean->throw->new->ReadOnlyBufferException->return->Preconditions->UNSAFE->getInt->checkIndex
VarHandleByteArrayAsShorts.ByteBufferHandle#address(ByteBuffer, int)::: byte buffer handle address:::address->UNSAFE->getLong->if->throw->newIllegalStateExceptionForMisalignedAccess->return
VarHandleByteArrayAsShorts.ByteBufferHandle#get(ByteBufferHandle, Object, int)::: byte buffer handle get:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->UNSAFE->getLong->getShortUnaligned
VarHandleByteArrayAsShorts.ByteBufferHandle#set(ByteBufferHandle, Object, int, short)::: byte buffer handle set:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->UNSAFE->getLong->putShortUnaligned
VarHandleByteArrayAsShorts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)::: byte buffer handle get volatile:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getShortVolatile->convEndian
VarHandleByteArrayAsShorts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, short)::: byte buffer handle set volatile:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putShortVolatile
VarHandleByteArrayAsShorts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)::: byte buffer handle get acquire:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getShortAcquire->convEndian
VarHandleByteArrayAsShorts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, short)::: byte buffer handle set release:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putShortRelease
VarHandleByteArrayAsShorts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)::: byte buffer handle get opaque:::bb->Objects->requireNonNull->return->UNSAFE->UNSAFE->getObject->index->address->getShortOpaque->convEndian
VarHandleByteArrayAsShorts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, short)::: byte buffer handle set opaque:::bb->Objects->requireNonNull->UNSAFE->UNSAFE->getObject->indexRO->address->convEndian->putShortOpaque
VarHandleByteArrayBase#newIllegalStateExceptionForMisalignedAccess(int)::: var handle byte array base new illegal state exception for misaligned access:::return->new->IllegalStateException
VarHandleBytes.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleBytes.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getByte
VarHandleBytes.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getByteVolatile
VarHandleBytes.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getByteOpaque
VarHandleBytes.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getByteAcquire
VarHandleBytes.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, byte)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putByte
VarHandleBytes.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, byte)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putByteVolatile
VarHandleBytes.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, byte)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putByteOpaque
VarHandleBytes.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putByteRelease
VarHandleBytes.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetByte
VarHandleBytes.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeByte
VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeByteAcquire
VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeByteRelease
VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetBytePlain
VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetByte
VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetByteAcquire
VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, byte, byte)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, byte)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetByte
VarHandleBytes.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, byte)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetByteAcquire
VarHandleBytes.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, byte)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddByte
VarHandleBytes.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, byte)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddByteAcquire
VarHandleBytes.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrByte
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrByteAcquire
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndByte
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndByteAcquire
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorByte
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorByteRelease
VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, byte)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorByteAcquire
VarHandleBytes.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleBytes.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getByte
VarHandleBytes.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getByteVolatile
VarHandleBytes.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getByteOpaque
VarHandleBytes.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getByteAcquire
VarHandleBytes.FieldStaticReadWrite#set(FieldStaticReadWrite, byte)::: field static read write set:::UNSAFE->putByte
VarHandleBytes.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, byte)::: field static read write set volatile:::UNSAFE->putByteVolatile
VarHandleBytes.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, byte)::: field static read write set opaque:::UNSAFE->putByteOpaque
VarHandleBytes.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, byte)::: field static read write set release:::UNSAFE->putByteRelease
VarHandleBytes.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, byte, byte)::: field static read write compare and set:::return->UNSAFE->compareAndSetByte
VarHandleBytes.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, byte, byte)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeByte
VarHandleBytes.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, byte, byte)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeByteAcquire
VarHandleBytes.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, byte, byte)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeByteRelease
VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, byte, byte)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetBytePlain
VarHandleBytes.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, byte, byte)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetByte
VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, byte, byte)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetByteAcquire
VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, byte, byte)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, byte)::: field static read write get and set:::return->UNSAFE->getAndSetByte
VarHandleBytes.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, byte)::: field static read write get and set acquire:::return->UNSAFE->getAndSetByteAcquire
VarHandleBytes.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, byte)::: field static read write get and set release:::return->UNSAFE->getAndSetByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, byte)::: field static read write get and add:::return->UNSAFE->getAndAddByte
VarHandleBytes.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, byte)::: field static read write get and add acquire:::return->UNSAFE->getAndAddByteAcquire
VarHandleBytes.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, byte)::: field static read write get and add release:::return->UNSAFE->getAndAddByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, byte)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrByte
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, byte)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, byte)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrByteAcquire
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, byte)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndByte
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, byte)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, byte)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndByteAcquire
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, byte)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorByte
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, byte)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorByteRelease
VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, byte)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorByteAcquire
VarHandleBytes.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleBytes.Array#get(Array, Object, int)::: array get:::array->return
VarHandleBytes.Array#set(Array, Object, int, byte)::: array set:::array
VarHandleBytes.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getByteVolatile
VarHandleBytes.Array#setVolatile(Array, Object, int, byte)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putByteVolatile
VarHandleBytes.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getByteOpaque
VarHandleBytes.Array#setOpaque(Array, Object, int, byte)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putByteOpaque
VarHandleBytes.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getByteAcquire
VarHandleBytes.Array#setRelease(Array, Object, int, byte)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putByteRelease
VarHandleBytes.Array#compareAndSet(Array, Object, int, byte, byte)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetByte
VarHandleBytes.Array#compareAndExchange(Array, Object, int, byte, byte)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeByte
VarHandleBytes.Array#compareAndExchangeAcquire(Array, Object, int, byte, byte)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeByteAcquire
VarHandleBytes.Array#compareAndExchangeRelease(Array, Object, int, byte, byte)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeByteRelease
VarHandleBytes.Array#weakCompareAndSetPlain(Array, Object, int, byte, byte)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetBytePlain
VarHandleBytes.Array#weakCompareAndSet(Array, Object, int, byte, byte)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetByte
VarHandleBytes.Array#weakCompareAndSetAcquire(Array, Object, int, byte, byte)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetByteAcquire
VarHandleBytes.Array#weakCompareAndSetRelease(Array, Object, int, byte, byte)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetByteRelease
VarHandleBytes.Array#getAndSet(Array, Object, int, byte)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetByte
VarHandleBytes.Array#getAndSetAcquire(Array, Object, int, byte)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetByteAcquire
VarHandleBytes.Array#getAndSetRelease(Array, Object, int, byte)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetByteRelease
VarHandleBytes.Array#getAndAdd(Array, Object, int, byte)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddByte
VarHandleBytes.Array#getAndAddAcquire(Array, Object, int, byte)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddByteAcquire
VarHandleBytes.Array#getAndAddRelease(Array, Object, int, byte)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddByteRelease
VarHandleBytes.Array#getAndBitwiseOr(Array, Object, int, byte)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrByte
VarHandleBytes.Array#getAndBitwiseOrRelease(Array, Object, int, byte)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrByteRelease
VarHandleBytes.Array#getAndBitwiseOrAcquire(Array, Object, int, byte)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrByteAcquire
VarHandleBytes.Array#getAndBitwiseAnd(Array, Object, int, byte)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndByte
VarHandleBytes.Array#getAndBitwiseAndRelease(Array, Object, int, byte)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndByteRelease
VarHandleBytes.Array#getAndBitwiseAndAcquire(Array, Object, int, byte)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndByteAcquire
VarHandleBytes.Array#getAndBitwiseXor(Array, Object, int, byte)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorByte
VarHandleBytes.Array#getAndBitwiseXorRelease(Array, Object, int, byte)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorByteRelease
VarHandleBytes.Array#getAndBitwiseXorAcquire(Array, Object, int, byte)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorByteAcquire
VarHandleChars.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleChars.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getChar
VarHandleChars.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getCharVolatile
VarHandleChars.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getCharOpaque
VarHandleChars.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getCharAcquire
VarHandleChars.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, char)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putChar
VarHandleChars.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, char)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putCharVolatile
VarHandleChars.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, char)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putCharOpaque
VarHandleChars.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, char)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putCharRelease
VarHandleChars.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, char, char)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetChar
VarHandleChars.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, char, char)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeChar
VarHandleChars.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, char, char)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeCharAcquire
VarHandleChars.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, char, char)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeCharRelease
VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, char, char)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetCharPlain
VarHandleChars.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, char, char)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetChar
VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, char, char)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetCharAcquire
VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, char, char)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, char)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetChar
VarHandleChars.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, char)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetCharAcquire
VarHandleChars.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, char)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, char)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddChar
VarHandleChars.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, char)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddCharAcquire
VarHandleChars.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, char)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrChar
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrCharAcquire
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndChar
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndCharAcquire
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorChar
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorCharRelease
VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, char)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorCharAcquire
VarHandleChars.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleChars.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getChar
VarHandleChars.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getCharVolatile
VarHandleChars.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getCharOpaque
VarHandleChars.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getCharAcquire
VarHandleChars.FieldStaticReadWrite#set(FieldStaticReadWrite, char)::: field static read write set:::UNSAFE->putChar
VarHandleChars.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, char)::: field static read write set volatile:::UNSAFE->putCharVolatile
VarHandleChars.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, char)::: field static read write set opaque:::UNSAFE->putCharOpaque
VarHandleChars.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, char)::: field static read write set release:::UNSAFE->putCharRelease
VarHandleChars.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, char, char)::: field static read write compare and set:::return->UNSAFE->compareAndSetChar
VarHandleChars.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, char, char)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeChar
VarHandleChars.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, char, char)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeCharAcquire
VarHandleChars.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, char, char)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeCharRelease
VarHandleChars.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, char, char)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetCharPlain
VarHandleChars.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, char, char)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetChar
VarHandleChars.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, char, char)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetCharAcquire
VarHandleChars.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, char, char)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetCharRelease
VarHandleChars.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, char)::: field static read write get and set:::return->UNSAFE->getAndSetChar
VarHandleChars.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, char)::: field static read write get and set acquire:::return->UNSAFE->getAndSetCharAcquire
VarHandleChars.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, char)::: field static read write get and set release:::return->UNSAFE->getAndSetCharRelease
VarHandleChars.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, char)::: field static read write get and add:::return->UNSAFE->getAndAddChar
VarHandleChars.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, char)::: field static read write get and add acquire:::return->UNSAFE->getAndAddCharAcquire
VarHandleChars.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, char)::: field static read write get and add release:::return->UNSAFE->getAndAddCharRelease
VarHandleChars.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, char)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrChar
VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, char)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrCharRelease
VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, char)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrCharAcquire
VarHandleChars.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, char)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndChar
VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, char)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndCharRelease
VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, char)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndCharAcquire
VarHandleChars.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, char)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorChar
VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, char)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorCharRelease
VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, char)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorCharAcquire
VarHandleChars.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleChars.Array#get(Array, Object, int)::: array get:::array->return
VarHandleChars.Array#set(Array, Object, int, char)::: array set:::array
VarHandleChars.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getCharVolatile
VarHandleChars.Array#setVolatile(Array, Object, int, char)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putCharVolatile
VarHandleChars.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getCharOpaque
VarHandleChars.Array#setOpaque(Array, Object, int, char)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putCharOpaque
VarHandleChars.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getCharAcquire
VarHandleChars.Array#setRelease(Array, Object, int, char)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putCharRelease
VarHandleChars.Array#compareAndSet(Array, Object, int, char, char)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetChar
VarHandleChars.Array#compareAndExchange(Array, Object, int, char, char)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeChar
VarHandleChars.Array#compareAndExchangeAcquire(Array, Object, int, char, char)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeCharAcquire
VarHandleChars.Array#compareAndExchangeRelease(Array, Object, int, char, char)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeCharRelease
VarHandleChars.Array#weakCompareAndSetPlain(Array, Object, int, char, char)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetCharPlain
VarHandleChars.Array#weakCompareAndSet(Array, Object, int, char, char)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetChar
VarHandleChars.Array#weakCompareAndSetAcquire(Array, Object, int, char, char)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetCharAcquire
VarHandleChars.Array#weakCompareAndSetRelease(Array, Object, int, char, char)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetCharRelease
VarHandleChars.Array#getAndSet(Array, Object, int, char)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetChar
VarHandleChars.Array#getAndSetAcquire(Array, Object, int, char)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetCharAcquire
VarHandleChars.Array#getAndSetRelease(Array, Object, int, char)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetCharRelease
VarHandleChars.Array#getAndAdd(Array, Object, int, char)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddChar
VarHandleChars.Array#getAndAddAcquire(Array, Object, int, char)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddCharAcquire
VarHandleChars.Array#getAndAddRelease(Array, Object, int, char)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddCharRelease
VarHandleChars.Array#getAndBitwiseOr(Array, Object, int, char)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrChar
VarHandleChars.Array#getAndBitwiseOrRelease(Array, Object, int, char)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrCharRelease
VarHandleChars.Array#getAndBitwiseOrAcquire(Array, Object, int, char)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrCharAcquire
VarHandleChars.Array#getAndBitwiseAnd(Array, Object, int, char)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndChar
VarHandleChars.Array#getAndBitwiseAndRelease(Array, Object, int, char)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndCharRelease
VarHandleChars.Array#getAndBitwiseAndAcquire(Array, Object, int, char)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndCharAcquire
VarHandleChars.Array#getAndBitwiseXor(Array, Object, int, char)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorChar
VarHandleChars.Array#getAndBitwiseXorRelease(Array, Object, int, char)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorCharRelease
VarHandleChars.Array#getAndBitwiseXorAcquire(Array, Object, int, char)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorCharAcquire
VarHandleDoubles.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleDoubles.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getDouble
VarHandleDoubles.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getDoubleVolatile
VarHandleDoubles.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getDoubleOpaque
VarHandleDoubles.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getDoubleAcquire
VarHandleDoubles.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, double)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putDouble
VarHandleDoubles.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, double)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putDoubleVolatile
VarHandleDoubles.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, double)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putDoubleOpaque
VarHandleDoubles.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, double)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putDoubleRelease
VarHandleDoubles.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, double, double)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetDouble
VarHandleDoubles.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, double, double)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeDouble
VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, double, double)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeDoubleAcquire
VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, double, double)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeDoubleRelease
VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, double, double)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetDoublePlain
VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, double, double)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetDouble
VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, double, double)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetDoubleAcquire
VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, double, double)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetDoubleRelease
VarHandleDoubles.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, double)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetDouble
VarHandleDoubles.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, double)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetDoubleAcquire
VarHandleDoubles.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, double)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetDoubleRelease
VarHandleDoubles.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, double)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddDouble
VarHandleDoubles.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, double)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddDoubleAcquire
VarHandleDoubles.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, double)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddDoubleRelease
VarHandleDoubles.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleDoubles.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getDouble
VarHandleDoubles.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getDoubleVolatile
VarHandleDoubles.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getDoubleOpaque
VarHandleDoubles.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getDoubleAcquire
VarHandleDoubles.FieldStaticReadWrite#set(FieldStaticReadWrite, double)::: field static read write set:::UNSAFE->putDouble
VarHandleDoubles.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, double)::: field static read write set volatile:::UNSAFE->putDoubleVolatile
VarHandleDoubles.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, double)::: field static read write set opaque:::UNSAFE->putDoubleOpaque
VarHandleDoubles.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, double)::: field static read write set release:::UNSAFE->putDoubleRelease
VarHandleDoubles.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, double, double)::: field static read write compare and set:::return->UNSAFE->compareAndSetDouble
VarHandleDoubles.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, double, double)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeDouble
VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, double, double)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeDoubleAcquire
VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, double, double)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeDoubleRelease
VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, double, double)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetDoublePlain
VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, double, double)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetDouble
VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, double, double)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetDoubleAcquire
VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, double, double)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetDoubleRelease
VarHandleDoubles.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, double)::: field static read write get and set:::return->UNSAFE->getAndSetDouble
VarHandleDoubles.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, double)::: field static read write get and set acquire:::return->UNSAFE->getAndSetDoubleAcquire
VarHandleDoubles.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, double)::: field static read write get and set release:::return->UNSAFE->getAndSetDoubleRelease
VarHandleDoubles.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, double)::: field static read write get and add:::return->UNSAFE->getAndAddDouble
VarHandleDoubles.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, double)::: field static read write get and add acquire:::return->UNSAFE->getAndAddDoubleAcquire
VarHandleDoubles.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, double)::: field static read write get and add release:::return->UNSAFE->getAndAddDoubleRelease
VarHandleDoubles.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleDoubles.Array#get(Array, Object, int)::: array get:::array->return
VarHandleDoubles.Array#set(Array, Object, int, double)::: array set:::array
VarHandleDoubles.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getDoubleVolatile
VarHandleDoubles.Array#setVolatile(Array, Object, int, double)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putDoubleVolatile
VarHandleDoubles.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getDoubleOpaque
VarHandleDoubles.Array#setOpaque(Array, Object, int, double)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putDoubleOpaque
VarHandleDoubles.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getDoubleAcquire
VarHandleDoubles.Array#setRelease(Array, Object, int, double)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putDoubleRelease
VarHandleDoubles.Array#compareAndSet(Array, Object, int, double, double)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetDouble
VarHandleDoubles.Array#compareAndExchange(Array, Object, int, double, double)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeDouble
VarHandleDoubles.Array#compareAndExchangeAcquire(Array, Object, int, double, double)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeDoubleAcquire
VarHandleDoubles.Array#compareAndExchangeRelease(Array, Object, int, double, double)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeDoubleRelease
VarHandleDoubles.Array#weakCompareAndSetPlain(Array, Object, int, double, double)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetDoublePlain
VarHandleDoubles.Array#weakCompareAndSet(Array, Object, int, double, double)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetDouble
VarHandleDoubles.Array#weakCompareAndSetAcquire(Array, Object, int, double, double)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetDoubleAcquire
VarHandleDoubles.Array#weakCompareAndSetRelease(Array, Object, int, double, double)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetDoubleRelease
VarHandleDoubles.Array#getAndSet(Array, Object, int, double)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetDouble
VarHandleDoubles.Array#getAndSetAcquire(Array, Object, int, double)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetDoubleAcquire
VarHandleDoubles.Array#getAndSetRelease(Array, Object, int, double)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetDoubleRelease
VarHandleDoubles.Array#getAndAdd(Array, Object, int, double)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddDouble
VarHandleDoubles.Array#getAndAddAcquire(Array, Object, int, double)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddDoubleAcquire
VarHandleDoubles.Array#getAndAddRelease(Array, Object, int, double)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddDoubleRelease
VarHandleFloats.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleFloats.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getFloat
VarHandleFloats.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getFloatVolatile
VarHandleFloats.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getFloatOpaque
VarHandleFloats.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getFloatAcquire
VarHandleFloats.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, float)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putFloat
VarHandleFloats.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, float)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putFloatVolatile
VarHandleFloats.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, float)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putFloatOpaque
VarHandleFloats.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, float)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putFloatRelease
VarHandleFloats.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, float, float)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetFloat
VarHandleFloats.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, float, float)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeFloat
VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, float, float)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeFloatAcquire
VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, float, float)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeFloatRelease
VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, float, float)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetFloatPlain
VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, float, float)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetFloat
VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, float, float)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetFloatAcquire
VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, float, float)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetFloatRelease
VarHandleFloats.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, float)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetFloat
VarHandleFloats.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, float)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetFloatAcquire
VarHandleFloats.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, float)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetFloatRelease
VarHandleFloats.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, float)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddFloat
VarHandleFloats.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, float)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddFloatAcquire
VarHandleFloats.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, float)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddFloatRelease
VarHandleFloats.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleFloats.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getFloat
VarHandleFloats.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getFloatVolatile
VarHandleFloats.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getFloatOpaque
VarHandleFloats.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getFloatAcquire
VarHandleFloats.FieldStaticReadWrite#set(FieldStaticReadWrite, float)::: field static read write set:::UNSAFE->putFloat
VarHandleFloats.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, float)::: field static read write set volatile:::UNSAFE->putFloatVolatile
VarHandleFloats.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, float)::: field static read write set opaque:::UNSAFE->putFloatOpaque
VarHandleFloats.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, float)::: field static read write set release:::UNSAFE->putFloatRelease
VarHandleFloats.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, float, float)::: field static read write compare and set:::return->UNSAFE->compareAndSetFloat
VarHandleFloats.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, float, float)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeFloat
VarHandleFloats.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, float, float)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeFloatAcquire
VarHandleFloats.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, float, float)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeFloatRelease
VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, float, float)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetFloatPlain
VarHandleFloats.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, float, float)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetFloat
VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, float, float)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetFloatAcquire
VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, float, float)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetFloatRelease
VarHandleFloats.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, float)::: field static read write get and set:::return->UNSAFE->getAndSetFloat
VarHandleFloats.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, float)::: field static read write get and set acquire:::return->UNSAFE->getAndSetFloatAcquire
VarHandleFloats.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, float)::: field static read write get and set release:::return->UNSAFE->getAndSetFloatRelease
VarHandleFloats.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, float)::: field static read write get and add:::return->UNSAFE->getAndAddFloat
VarHandleFloats.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, float)::: field static read write get and add acquire:::return->UNSAFE->getAndAddFloatAcquire
VarHandleFloats.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, float)::: field static read write get and add release:::return->UNSAFE->getAndAddFloatRelease
VarHandleFloats.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleFloats.Array#get(Array, Object, int)::: array get:::array->return
VarHandleFloats.Array#set(Array, Object, int, float)::: array set:::array
VarHandleFloats.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getFloatVolatile
VarHandleFloats.Array#setVolatile(Array, Object, int, float)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putFloatVolatile
VarHandleFloats.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getFloatOpaque
VarHandleFloats.Array#setOpaque(Array, Object, int, float)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putFloatOpaque
VarHandleFloats.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getFloatAcquire
VarHandleFloats.Array#setRelease(Array, Object, int, float)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putFloatRelease
VarHandleFloats.Array#compareAndSet(Array, Object, int, float, float)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetFloat
VarHandleFloats.Array#compareAndExchange(Array, Object, int, float, float)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeFloat
VarHandleFloats.Array#compareAndExchangeAcquire(Array, Object, int, float, float)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeFloatAcquire
VarHandleFloats.Array#compareAndExchangeRelease(Array, Object, int, float, float)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeFloatRelease
VarHandleFloats.Array#weakCompareAndSetPlain(Array, Object, int, float, float)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetFloatPlain
VarHandleFloats.Array#weakCompareAndSet(Array, Object, int, float, float)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetFloat
VarHandleFloats.Array#weakCompareAndSetAcquire(Array, Object, int, float, float)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetFloatAcquire
VarHandleFloats.Array#weakCompareAndSetRelease(Array, Object, int, float, float)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetFloatRelease
VarHandleFloats.Array#getAndSet(Array, Object, int, float)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetFloat
VarHandleFloats.Array#getAndSetAcquire(Array, Object, int, float)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetFloatAcquire
VarHandleFloats.Array#getAndSetRelease(Array, Object, int, float)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetFloatRelease
VarHandleFloats.Array#getAndAdd(Array, Object, int, float)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddFloat
VarHandleFloats.Array#getAndAddAcquire(Array, Object, int, float)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddFloatAcquire
VarHandleFloats.Array#getAndAddRelease(Array, Object, int, float)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddFloatRelease
VarHandleGuards#guard_L_L(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LL_V(VarHandle, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LL_L(VarHandle, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LLL_Z(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LLL_L(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_L_I(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LI_V(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LI_I(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LII_Z(VarHandle, Object, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LII_I(VarHandle, Object, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_L_J(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJ_V(VarHandle, Object, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LJ_J(VarHandle, Object, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJJ_Z(VarHandle, Object, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJJ_J(VarHandle, Object, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_L_F(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LF_V(VarHandle, Object, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LF_F(VarHandle, Object, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LFF_Z(VarHandle, Object, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LFF_F(VarHandle, Object, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_L_D(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LD_V(VarHandle, Object, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LD_D(VarHandle, Object, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LDD_Z(VarHandle, Object, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LDD_D(VarHandle, Object, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard__L(VarHandle, VarHandle.AccessDescriptor)::: var handle guards guard__ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_L_V(VarHandle, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LL_Z(VarHandle, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard__I(VarHandle, VarHandle.AccessDescriptor)::: var handle guards guard__ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_I_V(VarHandle, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_I_I(VarHandle, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_II_Z(VarHandle, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_II_I(VarHandle, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard__J(VarHandle, VarHandle.AccessDescriptor)::: var handle guards guard__ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_J_V(VarHandle, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_J_J(VarHandle, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_JJ_Z(VarHandle, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_JJ_J(VarHandle, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard__F(VarHandle, VarHandle.AccessDescriptor)::: var handle guards guard__ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_F_V(VarHandle, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_F_F(VarHandle, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_FF_Z(VarHandle, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_FF_F(VarHandle, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard__D(VarHandle, VarHandle.AccessDescriptor)::: var handle guards guard__ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_D_V(VarHandle, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_D_D(VarHandle, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_DD_Z(VarHandle, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_DD_D(VarHandle, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LI_L(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIL_V(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LIL_L(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LILL_Z(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LILL_L(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)::: var handle guards guard_ l_ l:::if->r->MethodHandle->getMemberName->linkToStatic->return->cast->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LII_V(VarHandle, Object, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LIII_Z(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIII_I(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LI_J(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIJ_V(VarHandle, Object, int, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LIJ_J(VarHandle, Object, int, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIJJ_Z(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIJJ_J(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LI_F(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIF_V(VarHandle, Object, int, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LIF_F(VarHandle, Object, int, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIFF_Z(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIFF_F(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)::: var handle guards guard_ f_ f:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LI_D(VarHandle, Object, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LID_V(VarHandle, Object, int, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LID_D(VarHandle, Object, int, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIDD_Z(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LIDD_D(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)::: var handle guards guard_ d_ d:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJ_I(VarHandle, Object, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJI_V(VarHandle, Object, long, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LJI_I(VarHandle, Object, long, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJII_Z(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJII_I(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)::: var handle guards guard_ i_ i:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJJ_V(VarHandle, Object, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ v:::if->MethodHandle->getMemberName->linkToStatic->else->if->getMethodType_V->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->mh->asType->invokeBasic
VarHandleGuards#guard_LJJJ_Z(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ z:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleGuards#guard_LJJJ_J(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)::: var handle guards guard_ j_ j:::if->return->MethodHandle->getMemberName->linkToStatic->else->mh->handle->getMethodHandle->return->mh->asType->invokeBasic
VarHandleInts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleInts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getInt
VarHandleInts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getIntVolatile
VarHandleInts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getIntOpaque
VarHandleInts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getIntAcquire
VarHandleInts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, int)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putInt
VarHandleInts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, int)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putIntVolatile
VarHandleInts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, int)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putIntOpaque
VarHandleInts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, int)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putIntRelease
VarHandleInts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, int, int)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetInt
VarHandleInts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, int, int)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeInt
VarHandleInts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, int, int)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeIntAcquire
VarHandleInts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, int, int)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeIntRelease
VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, int, int)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetIntPlain
VarHandleInts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, int, int)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetInt
VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, int, int)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetIntAcquire
VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, int, int)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, int)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetInt
VarHandleInts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, int)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetIntAcquire
VarHandleInts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, int)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, int)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddInt
VarHandleInts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, int)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddIntAcquire
VarHandleInts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, int)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrInt
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrIntAcquire
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndInt
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndIntAcquire
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorInt
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorIntRelease
VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, int)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorIntAcquire
VarHandleInts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleInts.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getInt
VarHandleInts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getIntVolatile
VarHandleInts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getIntOpaque
VarHandleInts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getIntAcquire
VarHandleInts.FieldStaticReadWrite#set(FieldStaticReadWrite, int)::: field static read write set:::UNSAFE->putInt
VarHandleInts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, int)::: field static read write set volatile:::UNSAFE->putIntVolatile
VarHandleInts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, int)::: field static read write set opaque:::UNSAFE->putIntOpaque
VarHandleInts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, int)::: field static read write set release:::UNSAFE->putIntRelease
VarHandleInts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, int, int)::: field static read write compare and set:::return->UNSAFE->compareAndSetInt
VarHandleInts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, int, int)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeInt
VarHandleInts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, int, int)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeIntAcquire
VarHandleInts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, int, int)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeIntRelease
VarHandleInts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, int, int)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetIntPlain
VarHandleInts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, int, int)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetInt
VarHandleInts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, int, int)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetIntAcquire
VarHandleInts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, int, int)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetIntRelease
VarHandleInts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, int)::: field static read write get and set:::return->UNSAFE->getAndSetInt
VarHandleInts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, int)::: field static read write get and set acquire:::return->UNSAFE->getAndSetIntAcquire
VarHandleInts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, int)::: field static read write get and set release:::return->UNSAFE->getAndSetIntRelease
VarHandleInts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, int)::: field static read write get and add:::return->UNSAFE->getAndAddInt
VarHandleInts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, int)::: field static read write get and add acquire:::return->UNSAFE->getAndAddIntAcquire
VarHandleInts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, int)::: field static read write get and add release:::return->UNSAFE->getAndAddIntRelease
VarHandleInts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, int)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrInt
VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, int)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrIntRelease
VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, int)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrIntAcquire
VarHandleInts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, int)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndInt
VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, int)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndIntRelease
VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, int)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndIntAcquire
VarHandleInts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, int)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorInt
VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, int)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorIntRelease
VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, int)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorIntAcquire
VarHandleInts.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleInts.Array#get(Array, Object, int)::: array get:::array->return
VarHandleInts.Array#set(Array, Object, int, int)::: array set:::array
VarHandleInts.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getIntVolatile
VarHandleInts.Array#setVolatile(Array, Object, int, int)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putIntVolatile
VarHandleInts.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getIntOpaque
VarHandleInts.Array#setOpaque(Array, Object, int, int)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putIntOpaque
VarHandleInts.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getIntAcquire
VarHandleInts.Array#setRelease(Array, Object, int, int)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putIntRelease
VarHandleInts.Array#compareAndSet(Array, Object, int, int, int)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetInt
VarHandleInts.Array#compareAndExchange(Array, Object, int, int, int)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeInt
VarHandleInts.Array#compareAndExchangeAcquire(Array, Object, int, int, int)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeIntAcquire
VarHandleInts.Array#compareAndExchangeRelease(Array, Object, int, int, int)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeIntRelease
VarHandleInts.Array#weakCompareAndSetPlain(Array, Object, int, int, int)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetIntPlain
VarHandleInts.Array#weakCompareAndSet(Array, Object, int, int, int)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetInt
VarHandleInts.Array#weakCompareAndSetAcquire(Array, Object, int, int, int)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetIntAcquire
VarHandleInts.Array#weakCompareAndSetRelease(Array, Object, int, int, int)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetIntRelease
VarHandleInts.Array#getAndSet(Array, Object, int, int)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetInt
VarHandleInts.Array#getAndSetAcquire(Array, Object, int, int)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetIntAcquire
VarHandleInts.Array#getAndSetRelease(Array, Object, int, int)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetIntRelease
VarHandleInts.Array#getAndAdd(Array, Object, int, int)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddInt
VarHandleInts.Array#getAndAddAcquire(Array, Object, int, int)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddIntAcquire
VarHandleInts.Array#getAndAddRelease(Array, Object, int, int)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddIntRelease
VarHandleInts.Array#getAndBitwiseOr(Array, Object, int, int)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrInt
VarHandleInts.Array#getAndBitwiseOrRelease(Array, Object, int, int)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrIntRelease
VarHandleInts.Array#getAndBitwiseOrAcquire(Array, Object, int, int)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrIntAcquire
VarHandleInts.Array#getAndBitwiseAnd(Array, Object, int, int)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndInt
VarHandleInts.Array#getAndBitwiseAndRelease(Array, Object, int, int)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndIntRelease
VarHandleInts.Array#getAndBitwiseAndAcquire(Array, Object, int, int)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndIntAcquire
VarHandleInts.Array#getAndBitwiseXor(Array, Object, int, int)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorInt
VarHandleInts.Array#getAndBitwiseXorRelease(Array, Object, int, int)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorIntRelease
VarHandleInts.Array#getAndBitwiseXorAcquire(Array, Object, int, int)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorIntAcquire
VarHandleLongs.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleLongs.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getLong
VarHandleLongs.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getLongVolatile
VarHandleLongs.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getLongOpaque
VarHandleLongs.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getLongAcquire
VarHandleLongs.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, long)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putLong
VarHandleLongs.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, long)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putLongVolatile
VarHandleLongs.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, long)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putLongOpaque
VarHandleLongs.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, long)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putLongRelease
VarHandleLongs.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, long, long)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetLong
VarHandleLongs.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, long, long)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeLong
VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, long, long)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeLongAcquire
VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, long, long)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeLongRelease
VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, long, long)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetLongPlain
VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, long, long)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetLong
VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, long, long)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetLongAcquire
VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, long, long)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, long)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetLong
VarHandleLongs.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, long)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetLongAcquire
VarHandleLongs.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, long)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, long)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddLong
VarHandleLongs.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, long)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddLongAcquire
VarHandleLongs.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, long)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrLong
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrLongAcquire
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndLong
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndLongAcquire
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorLong
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorLongRelease
VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, long)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorLongAcquire
VarHandleLongs.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleLongs.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getLong
VarHandleLongs.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getLongVolatile
VarHandleLongs.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getLongOpaque
VarHandleLongs.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getLongAcquire
VarHandleLongs.FieldStaticReadWrite#set(FieldStaticReadWrite, long)::: field static read write set:::UNSAFE->putLong
VarHandleLongs.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, long)::: field static read write set volatile:::UNSAFE->putLongVolatile
VarHandleLongs.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, long)::: field static read write set opaque:::UNSAFE->putLongOpaque
VarHandleLongs.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, long)::: field static read write set release:::UNSAFE->putLongRelease
VarHandleLongs.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, long, long)::: field static read write compare and set:::return->UNSAFE->compareAndSetLong
VarHandleLongs.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, long, long)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeLong
VarHandleLongs.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, long, long)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeLongAcquire
VarHandleLongs.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, long, long)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeLongRelease
VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, long, long)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetLongPlain
VarHandleLongs.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, long, long)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetLong
VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, long, long)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetLongAcquire
VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, long, long)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, long)::: field static read write get and set:::return->UNSAFE->getAndSetLong
VarHandleLongs.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, long)::: field static read write get and set acquire:::return->UNSAFE->getAndSetLongAcquire
VarHandleLongs.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, long)::: field static read write get and set release:::return->UNSAFE->getAndSetLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, long)::: field static read write get and add:::return->UNSAFE->getAndAddLong
VarHandleLongs.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, long)::: field static read write get and add acquire:::return->UNSAFE->getAndAddLongAcquire
VarHandleLongs.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, long)::: field static read write get and add release:::return->UNSAFE->getAndAddLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, long)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrLong
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, long)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, long)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrLongAcquire
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, long)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndLong
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, long)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, long)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndLongAcquire
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, long)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorLong
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, long)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorLongRelease
VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, long)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorLongAcquire
VarHandleLongs.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleLongs.Array#get(Array, Object, int)::: array get:::array->return
VarHandleLongs.Array#set(Array, Object, int, long)::: array set:::array
VarHandleLongs.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getLongVolatile
VarHandleLongs.Array#setVolatile(Array, Object, int, long)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putLongVolatile
VarHandleLongs.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getLongOpaque
VarHandleLongs.Array#setOpaque(Array, Object, int, long)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putLongOpaque
VarHandleLongs.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getLongAcquire
VarHandleLongs.Array#setRelease(Array, Object, int, long)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putLongRelease
VarHandleLongs.Array#compareAndSet(Array, Object, int, long, long)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetLong
VarHandleLongs.Array#compareAndExchange(Array, Object, int, long, long)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeLong
VarHandleLongs.Array#compareAndExchangeAcquire(Array, Object, int, long, long)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeLongAcquire
VarHandleLongs.Array#compareAndExchangeRelease(Array, Object, int, long, long)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeLongRelease
VarHandleLongs.Array#weakCompareAndSetPlain(Array, Object, int, long, long)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetLongPlain
VarHandleLongs.Array#weakCompareAndSet(Array, Object, int, long, long)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetLong
VarHandleLongs.Array#weakCompareAndSetAcquire(Array, Object, int, long, long)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetLongAcquire
VarHandleLongs.Array#weakCompareAndSetRelease(Array, Object, int, long, long)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetLongRelease
VarHandleLongs.Array#getAndSet(Array, Object, int, long)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetLong
VarHandleLongs.Array#getAndSetAcquire(Array, Object, int, long)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetLongAcquire
VarHandleLongs.Array#getAndSetRelease(Array, Object, int, long)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetLongRelease
VarHandleLongs.Array#getAndAdd(Array, Object, int, long)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddLong
VarHandleLongs.Array#getAndAddAcquire(Array, Object, int, long)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddLongAcquire
VarHandleLongs.Array#getAndAddRelease(Array, Object, int, long)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddLongRelease
VarHandleLongs.Array#getAndBitwiseOr(Array, Object, int, long)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrLong
VarHandleLongs.Array#getAndBitwiseOrRelease(Array, Object, int, long)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrLongRelease
VarHandleLongs.Array#getAndBitwiseOrAcquire(Array, Object, int, long)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrLongAcquire
VarHandleLongs.Array#getAndBitwiseAnd(Array, Object, int, long)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndLong
VarHandleLongs.Array#getAndBitwiseAndRelease(Array, Object, int, long)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndLongRelease
VarHandleLongs.Array#getAndBitwiseAndAcquire(Array, Object, int, long)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndLongAcquire
VarHandleLongs.Array#getAndBitwiseXor(Array, Object, int, long)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorLong
VarHandleLongs.Array#getAndBitwiseXorRelease(Array, Object, int, long)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorLongRelease
VarHandleLongs.Array#getAndBitwiseXorAcquire(Array, Object, int, long)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorLongAcquire
VarHandleObjects.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleObjects.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getObject
VarHandleObjects.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getObjectVolatile
VarHandleObjects.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getObjectOpaque
VarHandleObjects.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getObjectAcquire
VarHandleObjects.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, Object)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->cast->putObject
VarHandleObjects.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, Object)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->cast->putObjectVolatile
VarHandleObjects.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, Object)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->cast->putObjectOpaque
VarHandleObjects.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, Object)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->cast->putObjectRelease
VarHandleObjects.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->compareAndSetObject
VarHandleObjects.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->compareAndExchangeObject
VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->compareAndExchangeObjectAcquire
VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->compareAndExchangeObjectRelease
VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->weakCompareAndSetObjectPlain
VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->weakCompareAndSetObject
VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->weakCompareAndSetObjectAcquire
VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, Object, Object)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->cast->cast->weakCompareAndSetObjectRelease
VarHandleObjects.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, Object)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->cast->getAndSetObject
VarHandleObjects.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, Object)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->cast->getAndSetObjectAcquire
VarHandleObjects.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, Object)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->cast->getAndSetObjectRelease
VarHandleObjects.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleObjects.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getObject
VarHandleObjects.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getObjectVolatile
VarHandleObjects.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getObjectOpaque
VarHandleObjects.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getObjectAcquire
VarHandleObjects.FieldStaticReadWrite#set(FieldStaticReadWrite, Object)::: field static read write set:::UNSAFE->cast->putObject
VarHandleObjects.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, Object)::: field static read write set volatile:::UNSAFE->cast->putObjectVolatile
VarHandleObjects.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, Object)::: field static read write set opaque:::UNSAFE->cast->putObjectOpaque
VarHandleObjects.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, Object)::: field static read write set release:::UNSAFE->cast->putObjectRelease
VarHandleObjects.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, Object, Object)::: field static read write compare and set:::return->UNSAFE->cast->cast->compareAndSetObject
VarHandleObjects.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, Object, Object)::: field static read write compare and exchange:::return->UNSAFE->cast->cast->compareAndExchangeObject
VarHandleObjects.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, Object, Object)::: field static read write compare and exchange acquire:::return->UNSAFE->cast->cast->compareAndExchangeObjectAcquire
VarHandleObjects.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, Object, Object)::: field static read write compare and exchange release:::return->UNSAFE->cast->cast->compareAndExchangeObjectRelease
VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, Object, Object)::: field static read write weak compare and set plain:::return->UNSAFE->cast->cast->weakCompareAndSetObjectPlain
VarHandleObjects.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, Object, Object)::: field static read write weak compare and set:::return->UNSAFE->cast->cast->weakCompareAndSetObject
VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, Object, Object)::: field static read write weak compare and set acquire:::return->UNSAFE->cast->cast->weakCompareAndSetObjectAcquire
VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, Object, Object)::: field static read write weak compare and set release:::return->UNSAFE->cast->cast->weakCompareAndSetObjectRelease
VarHandleObjects.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, Object)::: field static read write get and set:::return->UNSAFE->cast->getAndSetObject
VarHandleObjects.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, Object)::: field static read write get and set acquire:::return->UNSAFE->cast->getAndSetObjectAcquire
VarHandleObjects.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, Object)::: field static read write get and set release:::return->UNSAFE->cast->getAndSetObjectRelease
VarHandleObjects.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->arrayType->getComponentType->accessModeType
VarHandleObjects.Array#runtimeTypeCheck(Array, Object[], Object)::: array runtime type check:::if->oarray->getClass->return->cast->else->return->reflectiveTypeCheck
VarHandleObjects.Array#reflectiveTypeCheck(Object[], Object)::: array reflective type check:::try->return->oarray->getClass->getComponentType->cast->catch->throw->new->ArrayStoreException->finally
VarHandleObjects.Array#get(Array, Object, int)::: array get:::array->cast->return
VarHandleObjects.Array#set(Array, Object, int, Object)::: array set:::array->cast->cast
VarHandleObjects.Array#getVolatile(Array, Object, int)::: array get volatile:::array->cast->return->UNSAFE->Preconditions->checkIndex->getObjectVolatile
VarHandleObjects.Array#setVolatile(Array, Object, int, Object)::: array set volatile:::array->cast->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->putObjectVolatile
VarHandleObjects.Array#getOpaque(Array, Object, int)::: array get opaque:::array->cast->return->UNSAFE->Preconditions->checkIndex->getObjectOpaque
VarHandleObjects.Array#setOpaque(Array, Object, int, Object)::: array set opaque:::array->cast->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->putObjectOpaque
VarHandleObjects.Array#getAcquire(Array, Object, int)::: array get acquire:::array->cast->return->UNSAFE->Preconditions->checkIndex->getObjectAcquire
VarHandleObjects.Array#setRelease(Array, Object, int, Object)::: array set release:::array->cast->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->putObjectRelease
VarHandleObjects.Array#compareAndSet(Array, Object, int, Object, Object)::: array compare and set:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->compareAndSetObject
VarHandleObjects.Array#compareAndExchange(Array, Object, int, Object, Object)::: array compare and exchange:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->compareAndExchangeObject
VarHandleObjects.Array#compareAndExchangeAcquire(Array, Object, int, Object, Object)::: array compare and exchange acquire:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->compareAndExchangeObjectAcquire
VarHandleObjects.Array#compareAndExchangeRelease(Array, Object, int, Object, Object)::: array compare and exchange release:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->compareAndExchangeObjectRelease
VarHandleObjects.Array#weakCompareAndSetPlain(Array, Object, int, Object, Object)::: array weak compare and set plain:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->weakCompareAndSetObjectPlain
VarHandleObjects.Array#weakCompareAndSet(Array, Object, int, Object, Object)::: array weak compare and set:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->weakCompareAndSetObject
VarHandleObjects.Array#weakCompareAndSetAcquire(Array, Object, int, Object, Object)::: array weak compare and set acquire:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->weakCompareAndSetObjectAcquire
VarHandleObjects.Array#weakCompareAndSetRelease(Array, Object, int, Object, Object)::: array weak compare and set release:::array->cast->return->UNSAFE->Preconditions->checkIndex->cast->runtimeTypeCheck->weakCompareAndSetObjectRelease
VarHandleObjects.Array#getAndSet(Array, Object, int, Object)::: array get and set:::array->cast->return->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->getAndSetObject
VarHandleObjects.Array#getAndSetAcquire(Array, Object, int, Object)::: array get and set acquire:::array->cast->return->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->getAndSetObjectAcquire
VarHandleObjects.Array#getAndSetRelease(Array, Object, int, Object)::: array get and set release:::array->cast->return->UNSAFE->Preconditions->checkIndex->runtimeTypeCheck->getAndSetObjectRelease
VarHandles#makeFieldHandle(MemberName, Class, Class, boolean)::: var handles make field handle:::if->f->isStatic->foffset->MethodHandleNatives->objectFieldOffset->if->type->isPrimitive->return->f->isFinal->new->VarHandleObjects.FieldInstanceReadOnly->new->VarHandleObjects.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleBooleans.FieldInstanceReadOnly->new->VarHandleBooleans.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleBytes.FieldInstanceReadOnly->new->VarHandleBytes.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleShorts.FieldInstanceReadOnly->new->VarHandleShorts.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleChars.FieldInstanceReadOnly->new->VarHandleChars.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleInts.FieldInstanceReadOnly->new->VarHandleInts.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleLongs.FieldInstanceReadOnly->new->VarHandleLongs.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleFloats.FieldInstanceReadOnly->new->VarHandleFloats.FieldInstanceReadWrite->else->if->return->f->isFinal->new->VarHandleDoubles.FieldInstanceReadOnly->new->VarHandleDoubles.FieldInstanceReadWrite->else->throw->new->UnsupportedOperationException->else->if->UNSAFE->shouldBeInitialized->UNSAFE->ensureClassInitialized->base->MethodHandleNatives->staticFieldBase->foffset->MethodHandleNatives->staticFieldOffset->if->type->isPrimitive->return->f->isFinal->new->VarHandleObjects.FieldStaticReadOnly->new->VarHandleObjects.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleBooleans.FieldStaticReadOnly->new->VarHandleBooleans.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleBytes.FieldStaticReadOnly->new->VarHandleBytes.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleShorts.FieldStaticReadOnly->new->VarHandleShorts.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleChars.FieldStaticReadOnly->new->VarHandleChars.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleInts.FieldStaticReadOnly->new->VarHandleInts.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleLongs.FieldStaticReadOnly->new->VarHandleLongs.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleFloats.FieldStaticReadOnly->new->VarHandleFloats.FieldStaticReadWrite->else->if->return->f->isFinal->new->VarHandleDoubles.FieldStaticReadOnly->new->VarHandleDoubles.FieldStaticReadWrite->else->throw->new->UnsupportedOperationException
VarHandles#makeArrayElementHandle(Class)::: var handles make array element handle:::if->arrayClass->isArray->throw->new->IllegalArgumentException->componentType->arrayClass->getComponentType->aoffset->UNSAFE->arrayBaseOffset->ascale->UNSAFE->arrayIndexScale->ashift->Integer->numberOfLeadingZeros->if->componentType->isPrimitive->return->new->VarHandleObjects.Array->else->if->return->new->VarHandleBooleans.Array->else->if->return->new->VarHandleBytes.Array->else->if->return->new->VarHandleShorts.Array->else->if->return->new->VarHandleChars.Array->else->if->return->new->VarHandleInts.Array->else->if->return->new->VarHandleLongs.Array->else->if->return->new->VarHandleFloats.Array->else->if->return->new->VarHandleDoubles.Array->else->throw->new->UnsupportedOperationException
VarHandles#byteArrayViewHandle(Class, boolean)::: var handles byte array view handle:::if->viewArrayClass->isArray->throw->new->IllegalArgumentException->viewComponentType->viewArrayClass->getComponentType->if->return->new->VarHandleByteArrayAsLongs.ArrayHandle->else->if->return->new->VarHandleByteArrayAsInts.ArrayHandle->else->if->return->new->VarHandleByteArrayAsShorts.ArrayHandle->else->if->return->new->VarHandleByteArrayAsChars.ArrayHandle->else->if->return->new->VarHandleByteArrayAsDoubles.ArrayHandle->else->if->return->new->VarHandleByteArrayAsFloats.ArrayHandle->throw->new->UnsupportedOperationException
VarHandles#makeByteBufferViewHandle(Class, boolean)::: var handles make byte buffer view handle:::if->viewArrayClass->isArray->throw->new->IllegalArgumentException->viewComponentType->viewArrayClass->getComponentType->if->return->new->VarHandleByteArrayAsLongs.ByteBufferHandle->else->if->return->new->VarHandleByteArrayAsInts.ByteBufferHandle->else->if->return->new->VarHandleByteArrayAsShorts.ByteBufferHandle->else->if->return->new->VarHandleByteArrayAsChars.ByteBufferHandle->else->if->return->new->VarHandleByteArrayAsDoubles.ByteBufferHandle->else->if->return->new->VarHandleByteArrayAsFloats.ByteBufferHandle->throw->new->UnsupportedOperationException
VarHandleShorts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)::: field instance read only access mode type uncached:::return->accessModeType
VarHandleShorts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)::: field instance read only get:::return->UNSAFE->Objects->cast->requireNonNull->getShort
VarHandleShorts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)::: field instance read only get volatile:::return->UNSAFE->Objects->cast->requireNonNull->getShortVolatile
VarHandleShorts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)::: field instance read only get opaque:::return->UNSAFE->Objects->cast->requireNonNull->getShortOpaque
VarHandleShorts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)::: field instance read only get acquire:::return->UNSAFE->Objects->cast->requireNonNull->getShortAcquire
VarHandleShorts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, short)::: field instance read write set:::UNSAFE->Objects->cast->requireNonNull->putShort
VarHandleShorts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, short)::: field instance read write set volatile:::UNSAFE->Objects->cast->requireNonNull->putShortVolatile
VarHandleShorts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, short)::: field instance read write set opaque:::UNSAFE->Objects->cast->requireNonNull->putShortOpaque
VarHandleShorts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, short)::: field instance read write set release:::UNSAFE->Objects->cast->requireNonNull->putShortRelease
VarHandleShorts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, short, short)::: field instance read write compare and set:::return->UNSAFE->Objects->cast->requireNonNull->compareAndSetShort
VarHandleShorts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, short, short)::: field instance read write compare and exchange:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeShort
VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, short, short)::: field instance read write compare and exchange acquire:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeShortAcquire
VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, short, short)::: field instance read write compare and exchange release:::return->UNSAFE->Objects->cast->requireNonNull->compareAndExchangeShortRelease
VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, short, short)::: field instance read write weak compare and set plain:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetShortPlain
VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, short, short)::: field instance read write weak compare and set:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetShort
VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, short, short)::: field instance read write weak compare and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetShortAcquire
VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, short, short)::: field instance read write weak compare and set release:::return->UNSAFE->Objects->cast->requireNonNull->weakCompareAndSetShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, short)::: field instance read write get and set:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetShort
VarHandleShorts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, short)::: field instance read write get and set acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetShortAcquire
VarHandleShorts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, short)::: field instance read write get and set release:::return->UNSAFE->Objects->cast->requireNonNull->getAndSetShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, short)::: field instance read write get and add:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddShort
VarHandleShorts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, short)::: field instance read write get and add acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddShortAcquire
VarHandleShorts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, short)::: field instance read write get and add release:::return->UNSAFE->Objects->cast->requireNonNull->getAndAddShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise or:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrShort
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise or release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise or acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseOrShortAcquire
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise and:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndShort
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise and release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise and acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseAndShortAcquire
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise xor:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorShort
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise xor release:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorShortRelease
VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, short)::: field instance read write get and bitwise xor acquire:::return->UNSAFE->Objects->cast->requireNonNull->getAndBitwiseXorShortAcquire
VarHandleShorts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)::: field static read only access mode type uncached:::return->accessModeType
VarHandleShorts.FieldStaticReadOnly#get(FieldStaticReadOnly)::: field static read only get:::return->UNSAFE->getShort
VarHandleShorts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)::: field static read only get volatile:::return->UNSAFE->getShortVolatile
VarHandleShorts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)::: field static read only get opaque:::return->UNSAFE->getShortOpaque
VarHandleShorts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)::: field static read only get acquire:::return->UNSAFE->getShortAcquire
VarHandleShorts.FieldStaticReadWrite#set(FieldStaticReadWrite, short)::: field static read write set:::UNSAFE->putShort
VarHandleShorts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, short)::: field static read write set volatile:::UNSAFE->putShortVolatile
VarHandleShorts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, short)::: field static read write set opaque:::UNSAFE->putShortOpaque
VarHandleShorts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, short)::: field static read write set release:::UNSAFE->putShortRelease
VarHandleShorts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, short, short)::: field static read write compare and set:::return->UNSAFE->compareAndSetShort
VarHandleShorts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, short, short)::: field static read write compare and exchange:::return->UNSAFE->compareAndExchangeShort
VarHandleShorts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, short, short)::: field static read write compare and exchange acquire:::return->UNSAFE->compareAndExchangeShortAcquire
VarHandleShorts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, short, short)::: field static read write compare and exchange release:::return->UNSAFE->compareAndExchangeShortRelease
VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, short, short)::: field static read write weak compare and set plain:::return->UNSAFE->weakCompareAndSetShortPlain
VarHandleShorts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, short, short)::: field static read write weak compare and set:::return->UNSAFE->weakCompareAndSetShort
VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, short, short)::: field static read write weak compare and set acquire:::return->UNSAFE->weakCompareAndSetShortAcquire
VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, short, short)::: field static read write weak compare and set release:::return->UNSAFE->weakCompareAndSetShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, short)::: field static read write get and set:::return->UNSAFE->getAndSetShort
VarHandleShorts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, short)::: field static read write get and set acquire:::return->UNSAFE->getAndSetShortAcquire
VarHandleShorts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, short)::: field static read write get and set release:::return->UNSAFE->getAndSetShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, short)::: field static read write get and add:::return->UNSAFE->getAndAddShort
VarHandleShorts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, short)::: field static read write get and add acquire:::return->UNSAFE->getAndAddShortAcquire
VarHandleShorts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, short)::: field static read write get and add release:::return->UNSAFE->getAndAddShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, short)::: field static read write get and bitwise or:::return->UNSAFE->getAndBitwiseOrShort
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, short)::: field static read write get and bitwise or release:::return->UNSAFE->getAndBitwiseOrShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, short)::: field static read write get and bitwise or acquire:::return->UNSAFE->getAndBitwiseOrShortAcquire
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, short)::: field static read write get and bitwise and:::return->UNSAFE->getAndBitwiseAndShort
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, short)::: field static read write get and bitwise and release:::return->UNSAFE->getAndBitwiseAndShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, short)::: field static read write get and bitwise and acquire:::return->UNSAFE->getAndBitwiseAndShortAcquire
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, short)::: field static read write get and bitwise xor:::return->UNSAFE->getAndBitwiseXorShort
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, short)::: field static read write get and bitwise xor release:::return->UNSAFE->getAndBitwiseXorShortRelease
VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, short)::: field static read write get and bitwise xor acquire:::return->UNSAFE->getAndBitwiseXorShortAcquire
VarHandleShorts.Array#accessModeTypeUncached(AccessMode)::: array access mode type uncached:::return->accessModeType
VarHandleShorts.Array#get(Array, Object, int)::: array get:::array->return
VarHandleShorts.Array#set(Array, Object, int, short)::: array set:::array
VarHandleShorts.Array#getVolatile(Array, Object, int)::: array get volatile:::array->return->UNSAFE->Preconditions->checkIndex->getShortVolatile
VarHandleShorts.Array#setVolatile(Array, Object, int, short)::: array set volatile:::array->UNSAFE->Preconditions->checkIndex->putShortVolatile
VarHandleShorts.Array#getOpaque(Array, Object, int)::: array get opaque:::array->return->UNSAFE->Preconditions->checkIndex->getShortOpaque
VarHandleShorts.Array#setOpaque(Array, Object, int, short)::: array set opaque:::array->UNSAFE->Preconditions->checkIndex->putShortOpaque
VarHandleShorts.Array#getAcquire(Array, Object, int)::: array get acquire:::array->return->UNSAFE->Preconditions->checkIndex->getShortAcquire
VarHandleShorts.Array#setRelease(Array, Object, int, short)::: array set release:::array->UNSAFE->Preconditions->checkIndex->putShortRelease
VarHandleShorts.Array#compareAndSet(Array, Object, int, short, short)::: array compare and set:::array->return->UNSAFE->Preconditions->checkIndex->compareAndSetShort
VarHandleShorts.Array#compareAndExchange(Array, Object, int, short, short)::: array compare and exchange:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeShort
VarHandleShorts.Array#compareAndExchangeAcquire(Array, Object, int, short, short)::: array compare and exchange acquire:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeShortAcquire
VarHandleShorts.Array#compareAndExchangeRelease(Array, Object, int, short, short)::: array compare and exchange release:::array->return->UNSAFE->Preconditions->checkIndex->compareAndExchangeShortRelease
VarHandleShorts.Array#weakCompareAndSetPlain(Array, Object, int, short, short)::: array weak compare and set plain:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetShortPlain
VarHandleShorts.Array#weakCompareAndSet(Array, Object, int, short, short)::: array weak compare and set:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetShort
VarHandleShorts.Array#weakCompareAndSetAcquire(Array, Object, int, short, short)::: array weak compare and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetShortAcquire
VarHandleShorts.Array#weakCompareAndSetRelease(Array, Object, int, short, short)::: array weak compare and set release:::array->return->UNSAFE->Preconditions->checkIndex->weakCompareAndSetShortRelease
VarHandleShorts.Array#getAndSet(Array, Object, int, short)::: array get and set:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetShort
VarHandleShorts.Array#getAndSetAcquire(Array, Object, int, short)::: array get and set acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetShortAcquire
VarHandleShorts.Array#getAndSetRelease(Array, Object, int, short)::: array get and set release:::array->return->UNSAFE->Preconditions->checkIndex->getAndSetShortRelease
VarHandleShorts.Array#getAndAdd(Array, Object, int, short)::: array get and add:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddShort
VarHandleShorts.Array#getAndAddAcquire(Array, Object, int, short)::: array get and add acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddShortAcquire
VarHandleShorts.Array#getAndAddRelease(Array, Object, int, short)::: array get and add release:::array->return->UNSAFE->Preconditions->checkIndex->getAndAddShortRelease
VarHandleShorts.Array#getAndBitwiseOr(Array, Object, int, short)::: array get and bitwise or:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrShort
VarHandleShorts.Array#getAndBitwiseOrRelease(Array, Object, int, short)::: array get and bitwise or release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrShortRelease
VarHandleShorts.Array#getAndBitwiseOrAcquire(Array, Object, int, short)::: array get and bitwise or acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseOrShortAcquire
VarHandleShorts.Array#getAndBitwiseAnd(Array, Object, int, short)::: array get and bitwise and:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndShort
VarHandleShorts.Array#getAndBitwiseAndRelease(Array, Object, int, short)::: array get and bitwise and release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndShortRelease
VarHandleShorts.Array#getAndBitwiseAndAcquire(Array, Object, int, short)::: array get and bitwise and acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseAndShortAcquire
VarHandleShorts.Array#getAndBitwiseXor(Array, Object, int, short)::: array get and bitwise xor:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorShort
VarHandleShorts.Array#getAndBitwiseXorRelease(Array, Object, int, short)::: array get and bitwise xor release:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorShortRelease
VarHandleShorts.Array#getAndBitwiseXorAcquire(Array, Object, int, short)::: array get and bitwise xor acquire:::array->return->UNSAFE->Preconditions->checkIndex->getAndBitwiseXorShortAcquire
VolatileCallSite#getTarget():::Returns the target method of the call site, which behaves like a volatile field of the VolatileCallSite:::return->getTargetVolatile
VolatileCallSite#setTarget(MethodHandle):::Updates the target method of this call site, as a volatile variable:::getTargetVolatile->checkTargetChange->setTargetVolatile
VolatileCallSite#dynamicInvoker()::: volatile call site dynamic invoker:::return->makeDynamicInvoker
