java.lang.invoke.AbstractConstantGroup#size()->int::: abstract constant group size
java.lang.invoke.AbstractConstantGroup#get(int)->Object::: abstract constant group get
java.lang.invoke.AbstractConstantGroup#get(int, Object)->Object::: abstract constant group get
java.lang.invoke.AbstractConstantGroup#isPresent(int)->boolean::: abstract constant group is present
java.lang.invoke.AbstractConstantGroup#toString()->String:::Produce a string using the non-resolving list view, where unresolved elements are presented as asterisks.
java.lang.invoke.AbstractConstantGroup.AsIterator#hasNext()->boolean::: as iterator has next
java.lang.invoke.AbstractConstantGroup.AsIterator#next()->Object::: as iterator next
java.lang.invoke.AbstractConstantGroup.SubGroup#get(int)->Object::: sub group get
java.lang.invoke.AbstractConstantGroup.SubGroup#get(int, Object)->Object::: sub group get
java.lang.invoke.AbstractConstantGroup.SubGroup#isPresent(int)->boolean::: sub group is present
java.lang.invoke.AbstractConstantGroup.SubGroup#subGroup(int, int)->ConstantGroup::: sub group sub group
java.lang.invoke.AbstractConstantGroup.SubGroup#asList()->List::: sub group as list
java.lang.invoke.AbstractConstantGroup.SubGroup#asList(Object)->List::: sub group as list
java.lang.invoke.AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int)->int::: sub group copy constants
java.lang.invoke.AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int, Object)->int::: sub group copy constants
java.lang.invoke.AbstractConstantGroup.AsList#size()->int::: as list size
java.lang.invoke.AbstractConstantGroup.AsList#get(int)->Object::: as list get
java.lang.invoke.AbstractConstantGroup.AsList#iterator()->Iterator::: as list iterator
java.lang.invoke.AbstractConstantGroup.AsList#subList(int, int)->List::: as list sub list
java.lang.invoke.AbstractConstantGroup.AsList#toArray()->Object[]::: as list to array
java.lang.invoke.AbstractConstantGroup.AsList#toArray(T[])->T[]::: as list to array
java.lang.invoke.AbstractConstantGroup.WithCache#initializeCache(List, Object)->void::: with cache initialize cache
java.lang.invoke.AbstractConstantGroup.WithCache#get(int)->Object::: with cache get
java.lang.invoke.AbstractConstantGroup.WithCache#get(int, Object)->Object::: with cache get
java.lang.invoke.AbstractConstantGroup.WithCache#isPresent(int)->boolean::: with cache is present
java.lang.invoke.AbstractConstantGroup.WithCache#fillCache(int)->Object:::hook for local subclasses
java.lang.invoke.AbstractConstantGroup.WithCache#wrapNull(Object)->Object::: with cache wrap null
java.lang.invoke.AbstractConstantGroup.WithCache#unwrapNull(Object)->Object::: with cache unwrap null
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#toString()->String::: with cache to string
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#bootstrapMethod()->MethodHandle::: with cache bootstrap method
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#invocationName()->String::: with cache invocation name
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#invocationType()->T::: with cache invocation type
java.lang.invoke.AbstractValidatingLambdaMetafactory#buildCallSite()->CallSite:::Build the CallSite.
java.lang.invoke.AbstractValidatingLambdaMetafactory#validateMetafactoryArgs()->void:::Check the meta-factory arguments for errors
java.lang.invoke.BootstrapCallInfo#bootstrapMethod()->MethodHandle:::Returns the bootstrap method for this call.
java.lang.invoke.BootstrapCallInfo#invocationName()->String:::Returns the method name or constant name for this call.
java.lang.invoke.BootstrapCallInfo#invocationType()->T:::Returns the method type or constant type for this call.
java.lang.invoke.BootstrapCallInfo#makeBootstrapCallInfo(MethodHandle, String, T, ConstantGroup)->BootstrapCallInfo:::Make a new bootstrap call descriptor with the given components.
java.lang.invoke.BootstrapMethodInvoker#invoke(Class, MethodHandle, String, Object, Object, Class)->T:::Factored code for invoking a bootstrap method for invokedynamic or a dynamic constant.
java.lang.invoke.BootstrapMethodInvoker.PushAdapter#pushToBootstrapMethod(MethodHandle, MethodHandles.Lookup, String, Object, Object...)->Object::: push adapter push to bootstrap method
java.lang.invoke.BootstrapMethodInvoker.PullAdapter#pullFromBootstrapMethod(MethodHandle, MethodHandles.Lookup, BootstrapCallInfo)->Object::: pull adapter pull from bootstrap method
java.lang.invoke.BootstrapMethodInvoker#pushMePullYou(MethodHandle, boolean)->MethodHandle:::Given a push-mode BSM (taking one argument) convert it to a  pull-mode BSM (taking N pre-resolved arguments)
java.lang.invoke.BoundMethodHandle#bindSingle(MethodType, LambdaForm, BasicType, Object)->BoundMethodHandle::: bound method handle bind single
java.lang.invoke.BoundMethodHandle#editor()->LambdaFormEditor::: bound method handle editor
java.lang.invoke.BoundMethodHandle#bindSingle(MethodType, LambdaForm, Object)->BoundMethodHandle::: bound method handle bind single
java.lang.invoke.BoundMethodHandle#bindArgumentL(int, Object)->BoundMethodHandle::: bound method handle bind argument l
java.lang.invoke.BoundMethodHandle#bindArgumentI(int, int)->BoundMethodHandle::: bound method handle bind argument i
java.lang.invoke.BoundMethodHandle#bindArgumentJ(int, long)->BoundMethodHandle::: bound method handle bind argument j
java.lang.invoke.BoundMethodHandle#bindArgumentF(int, float)->BoundMethodHandle::: bound method handle bind argument f
java.lang.invoke.BoundMethodHandle#bindArgumentD(int, double)->BoundMethodHandle::: bound method handle bind argument d
java.lang.invoke.BoundMethodHandle#rebind()->BoundMethodHandle::: bound method handle rebind
java.lang.invoke.BoundMethodHandle#makeReinvoker(MethodHandle)->BoundMethodHandle:::A reinvoker MH has this form: lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }
java.lang.invoke.BoundMethodHandle#speciesData()->BoundMethodHandle.SpeciesData::: bound method handle species data
java.lang.invoke.BoundMethodHandle#speciesDataFor(LambdaForm)->BoundMethodHandle.SpeciesData::: bound method handle species data for
java.lang.invoke.BoundMethodHandle#fieldCount()->int::: bound method handle field count
java.lang.invoke.BoundMethodHandle#internalProperties()->Object::: bound method handle internal properties
java.lang.invoke.BoundMethodHandle#internalValues()->String::: bound method handle internal values
java.lang.invoke.BoundMethodHandle#arg(int)->Object::: bound method handle arg
java.lang.invoke.BoundMethodHandle#copyWith(MethodType, LambdaForm)->BoundMethodHandle::: bound method handle copy with
java.lang.invoke.BoundMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)->BoundMethodHandle::: bound method handle copy with extend l
java.lang.invoke.BoundMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)->BoundMethodHandle::: bound method handle copy with extend i
java.lang.invoke.BoundMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)->BoundMethodHandle::: bound method handle copy with extend j
java.lang.invoke.BoundMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)->BoundMethodHandle::: bound method handle copy with extend f
java.lang.invoke.BoundMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)->BoundMethodHandle::: bound method handle copy with extend d
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveClassName()->String::: species data derive class name
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveFieldTypes(String)->List>::: species data derive field types
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTypeString()->String::: species data derive type string
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTransformHelper(MemberName, int)->MethodHandle::: species data derive transform helper
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTransformHelperArguments(MemberName, int, List, List)->List::: species data derive transform helper arguments
java.lang.invoke.BoundMethodHandle.SpeciesData#extendWith(byte)->SpeciesData::: species data extend with
java.lang.invoke.BoundMethodHandle.Specializer#topSpeciesKey()->String::: specializer top species key
java.lang.invoke.BoundMethodHandle.Specializer#newSpeciesData(String)->BoundMethodHandle.SpeciesData::: specializer new species data
java.lang.invoke.BoundMethodHandle.Specializer.Factory#chooseFieldName(Class, int)->String::: factory choose field name
java.lang.invoke.BoundMethodHandle.Specializer#makeFactory()->Factory::: specializer make factory
java.lang.invoke.BoundMethodHandle#speciesData_L()->SpeciesData::: bound method handle species data_ l
java.lang.invoke.BoundMethodHandle#speciesData_LL()->SpeciesData::: bound method handle species data_ l
java.lang.invoke.BoundMethodHandle#speciesData_LLL()->SpeciesData::: bound method handle species data_ l
java.lang.invoke.BoundMethodHandle#speciesData_LLLL()->SpeciesData::: bound method handle species data_ l
java.lang.invoke.BoundMethodHandle#speciesData_LLLLL()->SpeciesData::: bound method handle species data_ l
java.lang.invoke.CallSite#type()->MethodType:::Returns the type of this call site's target
java.lang.invoke.CallSite#getTarget()->MethodHandle:::Returns the target method of the call site, according to the behavior defined by this call site's specific class
java.lang.invoke.CallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, according to the behavior defined by this call site's specific class
java.lang.invoke.CallSite#checkTargetChange(MethodHandle, MethodHandle)->void::: call site check target change
java.lang.invoke.CallSite#dynamicInvoker()->MethodHandle:::Produces a method handle equivalent to an invokedynamic instruction which has been linked to this call site
java.lang.invoke.CallSite#makeDynamicInvoker()->MethodHandle::: call site make dynamic invoker
java.lang.invoke.CallSite#setTargetNormal(MethodHandle)->void::: call site set target normal
java.lang.invoke.CallSite#getTargetVolatile()->MethodHandle::: call site get target volatile
java.lang.invoke.CallSite#setTargetVolatile(MethodHandle)->void::: call site set target volatile
java.lang.invoke.CallSite#makeSite(MethodHandle, String, MethodType, Object, Class)->CallSite::: call site make site
java.lang.invoke.ClassSpecializer#topClass()->Class:::Return the top type mirror, for type T
java.lang.invoke.ClassSpecializer#keyType()->Class:::Return the key type mirror, for type K
java.lang.invoke.ClassSpecializer#metaType()->Class:::Return the species metadata type mirror, for type S
java.lang.invoke.ClassSpecializer#baseConstructorType()->MethodType:::Report the leading arguments (if any) required by every species factory
java.lang.invoke.ClassSpecializer#topSpecies()->S:::Return the trivial species for the null sequence of arguments.
java.lang.invoke.ClassSpecializer#transformMethods()->List:::Return the list of transform methods originally given at creation of this specializer.
java.lang.invoke.ClassSpecializer#factory()->Factory:::Return the factory object used to build and load concrete species code.
java.lang.invoke.ClassSpecializer#reflectConstructor(Class, Class...)->Constructor::: class specializer reflect constructor
java.lang.invoke.ClassSpecializer#reflectField(Class, String)->Field::: class specializer reflect field
java.lang.invoke.ClassSpecializer#findSpecies(K)->S::: class specializer find species
java.lang.invoke.ClassSpecializer.SpeciesData#key()->K::: species data key
java.lang.invoke.ClassSpecializer.SpeciesData#fieldTypes()->List>::: species data field types
java.lang.invoke.ClassSpecializer.SpeciesData#fieldCount()->int::: species data field count
java.lang.invoke.ClassSpecializer.SpeciesData#outer()->ClassSpecializer::: species data outer
java.lang.invoke.ClassSpecializer.SpeciesData#isResolved()->boolean::: species data is resolved
java.lang.invoke.ClassSpecializer.SpeciesData#toString()->String::: species data to string
java.lang.invoke.ClassSpecializer.SpeciesData#hashCode()->int::: species data hash code
java.lang.invoke.ClassSpecializer.SpeciesData#equals(Object)->boolean::: species data equals
java.lang.invoke.ClassSpecializer.SpeciesData#speciesCode()->Class:::Throws NPE if this species is not yet resolved.
java.lang.invoke.ClassSpecializer.SpeciesData#getter(int)->MethodHandle:::Return a MethodHandle which can get the indexed field of this species
java.lang.invoke.ClassSpecializer.SpeciesData#getterFunction(int)->LambdaForm.NamedFunction:::Return a LambdaForm.Name containing a LambdaForm.NamedFunction that represents a MH bound to a generic invoker, which in turn forwards to the corresponding getter.
java.lang.invoke.ClassSpecializer.SpeciesData#getterFunctions()->List::: species data getter functions
java.lang.invoke.ClassSpecializer.SpeciesData#getters()->List::: species data getters
java.lang.invoke.ClassSpecializer.SpeciesData#factory()->MethodHandle::: species data factory
java.lang.invoke.ClassSpecializer.SpeciesData#transformHelper(int)->MethodHandle::: species data transform helper
java.lang.invoke.ClassSpecializer.SpeciesData#deriveFieldTypes(K)->List>:::Given a key, derive the list of field types, which all instances of this species must store.
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTransformHelper(MemberName, int)->MethodHandle:::Given the index of a method in the transforms list, supply a factory method that takes the arguments of the transform, plus the local fields, and produce a value of the required type
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTransformHelperArguments(MemberName, int, List, List)->List:::During code generation, this method is called once per transform to determine what is the mix of arguments to hand to the transform-helper
java.lang.invoke.ClassSpecializer.SpeciesData#deriveClassName()->String:::Given a key, generate the name of the class which implements the species for that key
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTypeString()->String:::Default implementation collects basic type characters, plus possibly type names, if some types don't correspond to basic types.
java.lang.invoke.ClassSpecializer.SpeciesData#deriveSuperClass()->Class:::Report what immediate super-class to use for the concrete class of this species
java.lang.invoke.ClassSpecializer#newSpeciesData(K)->S::: class specializer new species data
java.lang.invoke.ClassSpecializer#topSpeciesKey()->K::: class specializer top species key
java.lang.invoke.ClassSpecializer.Factory#loadSpecies(S)->S:::Get a concrete subclass of the top class for a given combination of bound types.
java.lang.invoke.ClassSpecializer.Factory#generateConcreteSpeciesCode(String, ClassSpecializer.SpeciesData)->Class:::Generate a concrete subclass of the top class for a given combination of bound types
java.lang.invoke.ClassSpecializer.Factory#generateConcreteSpeciesCodeFile(String, ClassSpecializer.SpeciesData)->byte[]::: factory generate concrete species code file
java.lang.invoke.ClassSpecializer.Factory#makeNominalGetters(List>, List)->List::: factory make nominal getters
java.lang.invoke.ClassSpecializer.Factory#linkSpeciesDataToCode(ClassSpecializer.SpeciesData, Class)->void::: factory link species data to code
java.lang.invoke.ClassSpecializer.Factory#loadSpeciesDataFromCode(Class)->S::: factory load species data from code
java.lang.invoke.ClassSpecializer.Factory#linkCodeToSpeciesData(Class, ClassSpecializer.SpeciesData, boolean)->void::: factory link code to species data
java.lang.invoke.ClassSpecializer.Factory#chooseFieldName(Class, int)->String:::Field names in concrete species classes adhere to this pattern: type + index, where type is a single character (L, I, J, F, D)
java.lang.invoke.ClassSpecializer.Factory#findFactory(Class, List>)->MethodHandle::: factory find factory
java.lang.invoke.ClassSpecializer#makeFactory()->Factory:::Hook that virtualizes the Factory class, allowing subclasses to extend it.
java.lang.invoke.ClassSpecializer#methodSig(MethodType)->String::: class specializer method sig
java.lang.invoke.ClassSpecializer#classSig(Class)->String::: class specializer class sig
java.lang.invoke.ClassSpecializer#classSig(String)->String::: class specializer class sig
java.lang.invoke.ClassSpecializer#classBCName(Class)->String::: class specializer class name
java.lang.invoke.ClassSpecializer#classBCName(String)->String::: class specializer class name
java.lang.invoke.ClassSpecializer#className(Class)->String::: class specializer class name
java.lang.invoke.ConstantBootstraps#makeConstant(MethodHandle, String, Class, Object, Class)->Object::: constant bootstraps make constant
java.lang.invoke.ConstantBootstraps#nullConstant(MethodHandles.Lookup, String, Class)->Object:::Returns a null object reference for the reference type specified by type.
java.lang.invoke.ConstantBootstraps#primitiveClass(MethodHandles.Lookup, String, Class)->Class:::Returns a Class mirror for the primitive type whose type descriptor is specified by name.
java.lang.invoke.ConstantBootstraps#enumConstant(MethodHandles.Lookup, String, Class)->E:::Returns an enum constant of the type specified by type with the name specified by name.
java.lang.invoke.ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class, Class)->Object:::Returns the value of a static final field.
java.lang.invoke.ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class)->Object:::Returns the value of a static final field declared in the class which is the same as the field's type (or, for primitive-valued fields, declared in the wrapper class.)  This is a simplified form of #getStaticFinal(MethodHandles.Lookup, String, Class, Class) for the case where a class declares distinguished constant instances of itself.
java.lang.invoke.ConstantBootstraps#invoke(MethodHandles.Lookup, String, Class, MethodHandle, Object...)->Object:::Returns the result of invoking a method handle with the provided arguments
java.lang.invoke.ConstantBootstraps#fieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class)->VarHandle:::Finds a VarHandle for an instance field.
java.lang.invoke.ConstantBootstraps#staticFieldVarHandle(MethodHandles.Lookup, String, Class, Class, Class)->VarHandle:::Finds a VarHandle for a static field.
java.lang.invoke.ConstantBootstraps#arrayVarHandle(MethodHandles.Lookup, String, Class, Class)->VarHandle:::Finds a VarHandle for an array type.
java.lang.invoke.ConstantCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves like a final field of the ConstantCallSite
java.lang.invoke.ConstantCallSite#setTarget(MethodHandle)->void:::Always throws an UnsupportedOperationException
java.lang.invoke.ConstantCallSite#dynamicInvoker()->MethodHandle:::Returns this call site's permanent target
java.lang.invoke.ConstantGroup#size()->int:::Returns the number of constants in this group
java.lang.invoke.ConstantGroup#get(int)->Object:::Returns the selected constant, resolving it if necessary
java.lang.invoke.ConstantGroup#get(int, Object)->Object:::Returns the selected constant, or the given sentinel value if there is none available
java.lang.invoke.ConstantGroup#isPresent(int)->boolean:::Returns an indication of whether a constant may be available
java.lang.invoke.ConstantGroup#asList()->List:::Create a view on this group as a List view
java.lang.invoke.ConstantGroup#asList(Object)->List:::Create a view on this group as a List view
java.lang.invoke.ConstantGroup#subGroup(int, int)->ConstantGroup:::Create a view on a sub-sequence of this group.
java.lang.invoke.ConstantGroup#copyConstants(int, int, Object[], int)->int:::Copy a sequence of constant values into a given buffer
java.lang.invoke.ConstantGroup#copyConstants(int, int, Object[], int, Object)->int:::Copy a sequence of constant values into a given buffer
java.lang.invoke.ConstantGroup#makeConstantGroup(List, Object, IntFunction)->ConstantGroup:::Make a new constant group with the given constants
java.lang.invoke.ConstantGroup#makeConstantGroup(List)->ConstantGroup:::Make a new constant group with the given constant values
java.lang.invoke.DelegatingMethodHandle#getTarget()->MethodHandle:::Define this to extract the delegated target which supplies the invocation behavior.
java.lang.invoke.DelegatingMethodHandle#asTypeUncached(MethodType)->MethodHandle::: delegating method handle as type uncached
java.lang.invoke.DelegatingMethodHandle#internalMemberName()->MemberName::: delegating method handle internal member name
java.lang.invoke.DelegatingMethodHandle#isInvokeSpecial()->boolean::: delegating method handle is invoke special
java.lang.invoke.DelegatingMethodHandle#internalCallerClass()->Class::: delegating method handle internal caller class
java.lang.invoke.DelegatingMethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle::: delegating method handle copy with
java.lang.invoke.DelegatingMethodHandle#internalProperties()->String::: delegating method handle internal properties
java.lang.invoke.DelegatingMethodHandle#rebind()->BoundMethodHandle::: delegating method handle rebind
java.lang.invoke.DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, NamedFunction)->LambdaForm::: delegating method handle make reinvoker form
java.lang.invoke.DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, boolean, NamedFunction, NamedFunction)->LambdaForm:::Create a LF which simply reinvokes a target of the given basic type.
java.lang.invoke.DirectMethodHandle#make(byte, Class, MemberName, Class)->DirectMethodHandle::: direct method handle make
java.lang.invoke.DirectMethodHandle#make(Class, MemberName)->DirectMethodHandle::: direct method handle make
java.lang.invoke.DirectMethodHandle#make(MemberName)->DirectMethodHandle::: direct method handle make
java.lang.invoke.DirectMethodHandle#rebind()->BoundMethodHandle::: direct method handle rebind
java.lang.invoke.DirectMethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle::: direct method handle copy with
java.lang.invoke.DirectMethodHandle#internalProperties()->String::: direct method handle internal properties
java.lang.invoke.DirectMethodHandle#internalMemberName()->MemberName::: direct method handle internal member name
java.lang.invoke.DirectMethodHandle#makePreparedLambdaForm(MethodType, int)->LambdaForm::: direct method handle make prepared lambda form
java.lang.invoke.DirectMethodHandle#findDirectMethodHandle(Name)->Object::: direct method handle find direct method handle
java.lang.invoke.DirectMethodHandle#internalMemberName(Object)->Object:::Static wrapper for DirectMethodHandle.internalMemberName.
java.lang.invoke.DirectMethodHandle#internalMemberNameEnsureInit(Object)->Object::: direct method handle internal member name ensure init
java.lang.invoke.DirectMethodHandle#shouldBeInitialized(MemberName)->boolean::: direct method handle should be initialized
java.lang.invoke.DirectMethodHandle#ensureInitialized(Object)->void::: direct method handle ensure initialized
java.lang.invoke.DirectMethodHandle.Special#isInvokeSpecial()->boolean::: special is invoke special
java.lang.invoke.DirectMethodHandle.Special#copyWith(MethodType, LambdaForm)->MethodHandle::: special copy with
java.lang.invoke.DirectMethodHandle.Special#checkReceiver(Object)->Object::: special check receiver
java.lang.invoke.DirectMethodHandle.Interface#copyWith(MethodType, LambdaForm)->MethodHandle::: interface copy with
java.lang.invoke.DirectMethodHandle.Interface#checkReceiver(Object)->Object::: interface check receiver
java.lang.invoke.DirectMethodHandle#checkReceiver(Object)->Object:::Used for interface receiver type checks, by Interface and Special modes.
java.lang.invoke.DirectMethodHandle.Constructor#copyWith(MethodType, LambdaForm)->MethodHandle::: constructor copy with
java.lang.invoke.DirectMethodHandle#constructorMethod(Object)->Object::: direct method handle constructor method
java.lang.invoke.DirectMethodHandle#allocateInstance(Object)->Object::: direct method handle allocate instance
java.lang.invoke.DirectMethodHandle.Accessor#checkCast(Object)->Object::: accessor check cast
java.lang.invoke.DirectMethodHandle.Accessor#copyWith(MethodType, LambdaForm)->MethodHandle::: accessor copy with
java.lang.invoke.DirectMethodHandle#fieldOffset(Object)->long::: direct method handle field offset
java.lang.invoke.DirectMethodHandle#checkBase(Object)->Object::: direct method handle check base
java.lang.invoke.DirectMethodHandle.StaticAccessor#checkCast(Object)->Object::: static accessor check cast
java.lang.invoke.DirectMethodHandle.StaticAccessor#copyWith(MethodType, LambdaForm)->MethodHandle::: static accessor copy with
java.lang.invoke.DirectMethodHandle#nullCheck(Object)->Object::: direct method handle null check
java.lang.invoke.DirectMethodHandle#staticBase(Object)->Object::: direct method handle static base
java.lang.invoke.DirectMethodHandle#staticOffset(Object)->long::: direct method handle static offset
java.lang.invoke.DirectMethodHandle#checkCast(Object, Object)->Object::: direct method handle check cast
java.lang.invoke.DirectMethodHandle#checkCast(Object)->Object::: direct method handle check cast
java.lang.invoke.DirectMethodHandle#ftypeKind(Class)->int::: direct method handle ftype kind
java.lang.invoke.DirectMethodHandle#makePreparedFieldLambdaForm(byte, boolean, int)->LambdaForm::: direct method handle make prepared field lambda form
java.lang.invoke.GenerateJLIClassesHelper#generateBasicFormsClassBytes(String)->byte[]::: generate classes helper generate basic forms class bytes
java.lang.invoke.GenerateJLIClassesHelper#generateDirectMethodHandleHolderClassBytes(String, MethodType[], int[])->byte[]::: generate classes helper generate direct method handle holder class bytes
java.lang.invoke.GenerateJLIClassesHelper#generateDelegatingMethodHandleHolderClassBytes(String, MethodType[])->byte[]::: generate classes helper generate delegating method handle holder class bytes
java.lang.invoke.GenerateJLIClassesHelper#generateInvokersHolderClassBytes(String, MethodType[], MethodType[])->byte[]::: generate classes helper generate invokers holder class bytes
java.lang.invoke.GenerateJLIClassesHelper#generateConcreteBMHClassBytes(String)->Map.Entry::: generate classes helper generate concrete class bytes
java.lang.invoke.InfoFromMemberName#getDeclaringClass()->Class::: info from member name get declaring class
java.lang.invoke.InfoFromMemberName#getName()->String::: info from member name get name
java.lang.invoke.InfoFromMemberName#getMethodType()->MethodType::: info from member name get method type
java.lang.invoke.InfoFromMemberName#getModifiers()->int::: info from member name get modifiers
java.lang.invoke.InfoFromMemberName#getReferenceKind()->int::: info from member name get reference kind
java.lang.invoke.InfoFromMemberName#toString()->String::: info from member name to string
java.lang.invoke.InfoFromMemberName#reflectAs(Class, Lookup)->T::: info from member name reflect as
java.lang.invoke.InnerClassLambdaMetafactory#buildCallSite()->CallSite:::Build the CallSite
java.lang.invoke.InnerClassLambdaMetafactory#getParameterSize(Class)->int::: inner class lambda metafactory get parameter size
java.lang.invoke.InnerClassLambdaMetafactory#getLoadOpcode(Class)->int::: inner class lambda metafactory get load opcode
java.lang.invoke.InnerClassLambdaMetafactory#getReturnOpcode(Class)->int::: inner class lambda metafactory get return opcode
java.lang.invoke.InvokerBytecodeGenerator#maybeDump(String, byte[])->void::: invoker bytecode generator maybe dump
java.lang.invoke.InvokerBytecodeGenerator.CpPatch#toString()->String::: cp patch to string
java.lang.invoke.InvokerBytecodeGenerator#constantPlaceholder(Object)->String::: invoker bytecode generator constant placeholder
java.lang.invoke.InvokerBytecodeGenerator#cpPatches(byte[])->Object[]::: invoker bytecode generator cp patches
java.lang.invoke.InvokerBytecodeGenerator#generateCustomizedCode(LambdaForm, MethodType)->MemberName:::Generate customized bytecode for a given LambdaForm.
java.lang.invoke.InvokerBytecodeGenerator#className(String)->String::: invoker bytecode generator class name
java.lang.invoke.InvokerBytecodeGenerator#checkClassName(String)->boolean::: invoker bytecode generator check class name
java.lang.invoke.InvokerBytecodeGenerator#setClassWriter(ClassWriter)->void::: invoker bytecode generator set class writer
java.lang.invoke.InvokerBytecodeGenerator#addMethod()->void::: invoker bytecode generator add method
java.lang.invoke.InvokerBytecodeGenerator#emitArrayLoad(Name)->void::: invoker bytecode generator emit array load
java.lang.invoke.InvokerBytecodeGenerator#emitArrayStore(Name)->void::: invoker bytecode generator emit array store
java.lang.invoke.InvokerBytecodeGenerator#emitArrayLength(Name)->void::: invoker bytecode generator emit array length
java.lang.invoke.InvokerBytecodeGenerator#emitArrayOp(Name, int)->void::: invoker bytecode generator emit array op
java.lang.invoke.InvokerBytecodeGenerator#emitInvoke(Name)->void:::Emit an invoke for the given name.
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(NamedFunction...)->boolean::: invoker bytecode generator is statically invocable
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(Name)->boolean::: invoker bytecode generator is statically invocable
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(MemberName)->boolean::: invoker bytecode generator is statically invocable
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyNameable(Class)->boolean::: invoker bytecode generator is statically nameable
java.lang.invoke.InvokerBytecodeGenerator#emitStaticInvoke(Name)->void::: invoker bytecode generator emit static invoke
java.lang.invoke.InvokerBytecodeGenerator#emitStaticInvoke(MemberName, Name)->void:::Emit an invoke for the given name, using the MemberName directly.
java.lang.invoke.InvokerBytecodeGenerator#emitNewArray(Name)->void::: invoker bytecode generator emit new array
java.lang.invoke.InvokerBytecodeGenerator#refKindOpcode(byte)->int::: invoker bytecode generator ref kind opcode
java.lang.invoke.InvokerBytecodeGenerator#generateLambdaFormInterpreterEntryPoint(MethodType)->MemberName:::Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
java.lang.invoke.InvokerBytecodeGenerator#generateNamedFunctionInvoker(MethodTypeForm)->MemberName:::Generate bytecode for a NamedFunction invoker.
java.lang.invoke.Invokers#exactInvoker()->MethodHandle::: invokers exact invoker
java.lang.invoke.Invokers#genericInvoker()->MethodHandle::: invokers generic invoker
java.lang.invoke.Invokers#basicInvoker()->MethodHandle::: invokers basic invoker
java.lang.invoke.Invokers#varHandleMethodInvoker(VarHandle.AccessMode)->MethodHandle::: invokers var handle method invoker
java.lang.invoke.Invokers#varHandleMethodExactInvoker(VarHandle.AccessMode)->MethodHandle::: invokers var handle method exact invoker
java.lang.invoke.Invokers#invokeBasicMethod(MethodType)->MemberName::: invokers invoke basic method
java.lang.invoke.Invokers#spreadInvoker(int)->MethodHandle::: invokers spread invoker
java.lang.invoke.Invokers#toString()->String::: invokers to string
java.lang.invoke.Invokers#methodHandleInvokeLinkerMethod(String, MethodType, Object[])->MemberName::: invokers method handle invoke linker method
java.lang.invoke.Invokers#invokeHandleForm(MethodType, boolean, int)->LambdaForm:::Returns an adapter for invokeExact or generic invoke, as a MH or constant pool linker
java.lang.invoke.Invokers#varHandleInvokeLinkerMethod(VarHandle.AccessMode, MethodType)->MemberName::: invokers var handle invoke linker method
java.lang.invoke.Invokers#checkVarHandleGenericType(VarHandle, VarHandle.AccessDescriptor)->MethodHandle::: invokers check var handle generic type
java.lang.invoke.Invokers#checkVarHandleExactType(VarHandle, VarHandle.AccessDescriptor)->MethodHandle::: invokers check var handle exact type
java.lang.invoke.Invokers#newWrongMethodTypeException(MethodType, MethodType)->WrongMethodTypeException::: invokers new wrong method type exception
java.lang.invoke.Invokers#checkExactType(MethodHandle, MethodType)->void::: invokers check exact type
java.lang.invoke.Invokers#checkGenericType(MethodHandle, MethodType)->MethodHandle::: invokers check generic type
java.lang.invoke.Invokers#linkToCallSiteMethod(MethodType)->MemberName::: invokers link to call site method
java.lang.invoke.Invokers#linkToTargetMethod(MethodType)->MemberName::: invokers link to target method
java.lang.invoke.Invokers#callSiteForm(MethodType, boolean)->LambdaForm::: invokers call site form
java.lang.invoke.Invokers#getCallSiteTarget(CallSite)->MethodHandle::: invokers get call site target
java.lang.invoke.Invokers#checkCustomized(MethodHandle)->void::: invokers check customized
java.lang.invoke.Invokers#maybeCustomize(MethodHandle)->void::: invokers maybe customize
java.lang.invoke.LambdaForm#debugNames()->boolean::: lambda form debug names
java.lang.invoke.LambdaForm#associateWithDebugName(LambdaForm, String)->void::: lambda form associate with debug name
java.lang.invoke.LambdaForm#lambdaName()->String::: lambda form lambda name
java.lang.invoke.LambdaForm#customize(MethodHandle)->LambdaForm:::Customize LambdaForm for a particular MethodHandle
java.lang.invoke.LambdaForm#uncustomize()->LambdaForm:::Get uncustomized flavor of the LambdaForm
java.lang.invoke.LambdaForm#nameRefsAreLegal()->boolean:::Check that all embedded Name references are localizable to this lambda, and are properly ordered after their corresponding definitions
java.lang.invoke.LambdaForm#returnType()->BasicType:::Report the return type.
java.lang.invoke.LambdaForm#parameterType(int)->BasicType:::Report the N-th argument type.
java.lang.invoke.LambdaForm#parameter(int)->Name:::Report the N-th argument name.
java.lang.invoke.LambdaForm#parameterConstraint(int)->Object:::Report the N-th argument type constraint.
java.lang.invoke.LambdaForm#arity()->int:::Report the arity.
java.lang.invoke.LambdaForm#expressionCount()->int:::Report the number of expressions (non-parameter names).
java.lang.invoke.LambdaForm#methodType()->MethodType:::Return the method type corresponding to my basic type signature.
java.lang.invoke.LambdaForm#basicTypeSignature()->String:::Return ABC_Z, where the ABC are parameter type characters, and Z is the return type character.
java.lang.invoke.LambdaForm#signatureArity(String)->int::: lambda form signature arity
java.lang.invoke.LambdaForm#signatureReturn(String)->BasicType::: lambda form signature return
java.lang.invoke.LambdaForm#isValidSignature(String)->boolean::: lambda form is valid signature
java.lang.invoke.LambdaForm#signatureType(String)->MethodType::: lambda form signature type
java.lang.invoke.LambdaForm#basicMethodType(MethodType)->MethodType::: lambda form basic method type
java.lang.invoke.LambdaForm#isSelectAlternative(int)->boolean:::Check if i-th name is a call to MethodHandleImpl.selectAlternative.
java.lang.invoke.LambdaForm#isGuardWithCatch(int)->boolean:::Check if i-th name is a start of GuardWithCatch idiom.
java.lang.invoke.LambdaForm#isTryFinally(int)->boolean:::Check if i-th name is a start of the tryFinally idiom.
java.lang.invoke.LambdaForm#isLoop(int)->boolean:::Check if i-th name is a start of the loop idiom.
java.lang.invoke.LambdaForm#prepare()->void:::Make this LF directly executable, as part of a MethodHandle
java.lang.invoke.LambdaForm#compileToBytecode()->void:::Generate optimizable bytecode for this form.
java.lang.invoke.LambdaForm#interpretWithArguments(Object...)->Object::: lambda form interpret with arguments
java.lang.invoke.LambdaForm#interpretName(Name, Object[])->Object::: lambda form interpret name
java.lang.invoke.LambdaForm#interpretWithArgumentsTracing(Object...)->Object::: lambda form interpret with arguments tracing
java.lang.invoke.LambdaForm#traceInterpreter(String, Object, Object...)->void::: lambda form trace interpreter
java.lang.invoke.LambdaForm#traceInterpreter(String, Object)->void::: lambda form trace interpreter
java.lang.invoke.LambdaForm#toString()->String::: lambda form to string
java.lang.invoke.LambdaForm#equals(Object)->boolean::: lambda form equals
java.lang.invoke.LambdaForm#equals(LambdaForm)->boolean::: lambda form equals
java.lang.invoke.LambdaForm#hashCode()->int::: lambda form hash code
java.lang.invoke.LambdaForm#editor()->LambdaFormEditor::: lambda form editor
java.lang.invoke.LambdaForm#contains(Name)->boolean::: lambda form contains
java.lang.invoke.LambdaForm.NamedFunction#resolvedHandle()->MethodHandle::: named function resolved handle
java.lang.invoke.LambdaForm.NamedFunction#resolve()->void::: named function resolve
java.lang.invoke.LambdaForm.NamedFunction#equals(Object)->boolean::: named function equals
java.lang.invoke.LambdaForm.NamedFunction#hashCode()->int::: named function hash code
java.lang.invoke.LambdaForm.NamedFunction#invokeWithArguments(Object...)->Object::: named function invoke with arguments
java.lang.invoke.LambdaForm.NamedFunction#invokeWithArgumentsTracing(Object[])->Object::: named function invoke with arguments tracing
java.lang.invoke.LambdaForm.NamedFunction#methodType()->MethodType::: named function method type
java.lang.invoke.LambdaForm.NamedFunction#member()->MemberName::: named function member
java.lang.invoke.LambdaForm.NamedFunction#memberDeclaringClassOrNull()->Class::: named function member declaring class or null
java.lang.invoke.LambdaForm.NamedFunction#returnType()->BasicType::: named function return type
java.lang.invoke.LambdaForm.NamedFunction#parameterType(int)->BasicType::: named function parameter type
java.lang.invoke.LambdaForm.NamedFunction#arity()->int::: named function arity
java.lang.invoke.LambdaForm.NamedFunction#toString()->String::: named function to string
java.lang.invoke.LambdaForm.NamedFunction#isIdentity()->boolean::: named function is identity
java.lang.invoke.LambdaForm.NamedFunction#isConstantZero()->boolean::: named function is constant zero
java.lang.invoke.LambdaForm.NamedFunction#intrinsicName()->MethodHandleImpl.Intrinsic::: named function intrinsic name
java.lang.invoke.LambdaForm#basicTypeSignature(MethodType)->String::: lambda form basic type signature
java.lang.invoke.LambdaForm#shortenSignature(String)->String:::Hack to make signatures more readable when they show up in method names
java.lang.invoke.LambdaForm.Name#type()->BasicType::: name type
java.lang.invoke.LambdaForm.Name#index()->int::: name index
java.lang.invoke.LambdaForm.Name#initIndex(int)->boolean::: name init index
java.lang.invoke.LambdaForm.Name#typeChar()->char::: name type char
java.lang.invoke.LambdaForm.Name#resolve()->void::: name resolve
java.lang.invoke.LambdaForm.Name#newIndex(int)->Name::: name new index
java.lang.invoke.LambdaForm.Name#cloneWithIndex(int)->Name::: name clone with index
java.lang.invoke.LambdaForm.Name#withConstraint(Object)->Name::: name with constraint
java.lang.invoke.LambdaForm.Name#replaceName(Name, Name)->Name::: name replace name
java.lang.invoke.LambdaForm.Name#replaceNames(Name[], Name[], int, int)->Name:::In the arguments of this Name, replace oldNames[i] pairwise by newNames[i]
java.lang.invoke.LambdaForm.Name#internArguments()->void::: name intern arguments
java.lang.invoke.LambdaForm.Name#isParam()->boolean::: name is param
java.lang.invoke.LambdaForm.Name#isConstantZero()->boolean::: name is constant zero
java.lang.invoke.LambdaForm.Name#refersTo(Class, String)->boolean::: name refers to
java.lang.invoke.LambdaForm.Name#isInvokeBasic()->boolean:::Check if MemberName is a call to MethodHandle.invokeBasic.
java.lang.invoke.LambdaForm.Name#isLinkerMethodInvoke()->boolean:::Check if MemberName is a call to MethodHandle.linkToStatic, etc.
java.lang.invoke.LambdaForm.Name#toString()->String::: name to string
java.lang.invoke.LambdaForm.Name#debugString()->String::: name debug string
java.lang.invoke.LambdaForm.Name#paramString()->String::: name param string
java.lang.invoke.LambdaForm.Name#exprString()->String::: name expr string
java.lang.invoke.LambdaForm.Name#lastUseIndex(Name)->int:::Return the index of the last occurrence of n in the argument array
java.lang.invoke.LambdaForm.Name#useCount(Name)->int:::Return the number of occurrences of n in the argument array
java.lang.invoke.LambdaForm.Name#contains(Name)->boolean::: name contains
java.lang.invoke.LambdaForm.Name#equals(Name)->boolean::: name equals
java.lang.invoke.LambdaForm.Name#equals(Object)->boolean::: name equals
java.lang.invoke.LambdaForm.Name#hashCode()->int::: name hash code
java.lang.invoke.LambdaForm#lastUseIndex(Name)->int:::Return the index of the last name which contains n as an argument
java.lang.invoke.LambdaForm#useCount(Name)->int:::Return the number of times n is used as an argument or return value.
java.lang.invoke.LambdaForm#argument(int, BasicType)->Name::: lambda form argument
java.lang.invoke.LambdaForm#internArgument(Name)->Name::: lambda form intern argument
java.lang.invoke.LambdaForm#arguments(int, MethodType)->Name[]::: lambda form arguments
java.lang.invoke.LambdaForm#identityForm(BasicType)->LambdaForm::: lambda form identity form
java.lang.invoke.LambdaForm#zeroForm(BasicType)->LambdaForm::: lambda form zero form
java.lang.invoke.LambdaForm#identity(BasicType)->NamedFunction::: lambda form identity
java.lang.invoke.LambdaForm#constantZero(BasicType)->NamedFunction::: lambda form constant zero
java.lang.invoke.LambdaFormBuffer#name(int)->Name::: lambda form buffer name
java.lang.invoke.LambdaFormBuffer#nameArray()->Name[]::: lambda form buffer name array
java.lang.invoke.LambdaFormBuffer#resultIndex()->int::: lambda form buffer result index
java.lang.invoke.LambdaFormBuffer#setNames(Name[])->void::: lambda form buffer set names
java.lang.invoke.LambdaFormBuffer#inTrans()->boolean::: lambda form buffer in trans
java.lang.invoke.LambdaFormBuffer#ownedCount()->int::: lambda form buffer owned count
java.lang.invoke.LambdaFormBuffer#growNames(int, int)->void::: lambda form buffer grow names
java.lang.invoke.LambdaFormBuffer#lastIndexOf(Name)->int::: lambda form buffer last index of
java.lang.invoke.LambdaFormBuffer#startEdit()->void:::Create a private, writable copy of names
java.lang.invoke.LambdaFormBuffer#changeName(int, Name)->void::: lambda form buffer change name
java.lang.invoke.LambdaFormBuffer#setResult(Name)->void:::Change the result name
java.lang.invoke.LambdaFormBuffer#endEdit()->LambdaForm:::Finish a transaction.
java.lang.invoke.LambdaFormBuffer#replaceFunctions(List, List, Object...)->LambdaFormBuffer:::Replace any Name whose function is in oldFns with a copy  whose function is in the corresponding position in newFns
java.lang.invoke.LambdaFormBuffer#renameParameter(int, Name)->LambdaFormBuffer:::Replace a parameter by a fresh parameter.
java.lang.invoke.LambdaFormBuffer#replaceParameterByNewExpression(int, Name)->LambdaFormBuffer:::Replace a parameter by a fresh expression.
java.lang.invoke.LambdaFormBuffer#replaceParameterByCopy(int, int)->LambdaFormBuffer:::Replace a parameter by another parameter or expression already in the form.
java.lang.invoke.LambdaFormBuffer#insertExpression(int, Name)->LambdaFormBuffer:::Insert a fresh expression.
java.lang.invoke.LambdaFormBuffer#insertParameter(int, Name)->LambdaFormBuffer:::Insert a fresh parameter.
java.lang.invoke.LambdaFormEditor#lambdaFormEditor(LambdaForm)->LambdaFormEditor::: lambda form editor lambda form editor
java.lang.invoke.LambdaFormEditor#bindArgumentL(BoundMethodHandle, int, Object)->BoundMethodHandle::: lambda form editor bind argument l
java.lang.invoke.LambdaFormEditor#bindArgumentI(BoundMethodHandle, int, int)->BoundMethodHandle::: lambda form editor bind argument i
java.lang.invoke.LambdaFormEditor#bindArgumentJ(BoundMethodHandle, int, long)->BoundMethodHandle::: lambda form editor bind argument j
java.lang.invoke.LambdaFormEditor#bindArgumentF(BoundMethodHandle, int, float)->BoundMethodHandle::: lambda form editor bind argument f
java.lang.invoke.LambdaFormEditor#bindArgumentD(BoundMethodHandle, int, double)->BoundMethodHandle::: lambda form editor bind argument d
java.lang.invoke.LambdaFormEditor#bindArgumentForm(int)->LambdaForm::: lambda form editor bind argument form
java.lang.invoke.LambdaFormEditor#addArgumentForm(int, BasicType)->LambdaForm::: lambda form editor add argument form
java.lang.invoke.LambdaFormEditor#dupArgumentForm(int, int)->LambdaForm::: lambda form editor dup argument form
java.lang.invoke.LambdaFormEditor#spreadArgumentsForm(int, Class, int)->LambdaForm::: lambda form editor spread arguments form
java.lang.invoke.LambdaFormEditor#collectArgumentsForm(int, MethodType)->LambdaForm::: lambda form editor collect arguments form
java.lang.invoke.LambdaFormEditor#collectArgumentArrayForm(int, MethodHandle)->LambdaForm::: lambda form editor collect argument array form
java.lang.invoke.LambdaFormEditor#filterArgumentForm(int, BasicType)->LambdaForm::: lambda form editor filter argument form
java.lang.invoke.LambdaFormEditor#filterReturnForm(BasicType, boolean)->LambdaForm::: lambda form editor filter return form
java.lang.invoke.LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType)->LambdaForm::: lambda form editor fold arguments form
java.lang.invoke.LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType, int...)->LambdaForm::: lambda form editor fold arguments form
java.lang.invoke.LambdaFormEditor#permuteArgumentsForm(int, int[])->LambdaForm::: lambda form editor permute arguments form
java.lang.invoke.LambdaFormEditor#noteLoopLocalTypesForm(int, BasicType[])->LambdaForm::: lambda form editor note loop local types form
java.lang.invoke.LambdaFormEditor#permutedTypesMatch(int[], BasicType[], Name[], int)->boolean::: lambda form editor permuted types match
java.lang.invoke.LambdaMetafactory#metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)->CallSite:::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments
java.lang.invoke.LambdaMetafactory#altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)->CallSite:::Facilitates the creation of simple "function objects" that implement one or more interfaces by delegation to a provided MethodHandle, after appropriate type adaptation and partial evaluation of arguments
java.lang.invoke.MemberName#getDeclaringClass()->Class:::Return the declaring class of this member
java.lang.invoke.MemberName#getClassLoader()->ClassLoader:::Utility method producing the class loader of the declaring class.
java.lang.invoke.MemberName#getName()->String:::Return the simple name of this member
java.lang.invoke.MemberName#getMethodOrFieldType()->MethodType::: member name get method or field type
java.lang.invoke.MemberName#getMethodType()->MethodType:::Return the declared type of this member, which  must be a method or constructor.
java.lang.invoke.MemberName#getMethodDescriptor()->String:::Return the descriptor of this member, which  must be a method or constructor.
java.lang.invoke.MemberName#getInvocationType()->MethodType:::Return the actual type under which this method or constructor must be invoked
java.lang.invoke.MemberName#getParameterTypes()->Class[]:::Utility method producing the parameter types of the method type.
java.lang.invoke.MemberName#getReturnType()->Class:::Utility method producing the return type of the method type.
java.lang.invoke.MemberName#getFieldType()->Class:::Return the declared type of this member, which  must be a field or type
java.lang.invoke.MemberName#getType()->Object:::Utility method to produce either the method type or field type of this member.
java.lang.invoke.MemberName#getSignature()->String:::Utility method to produce the signature of this member,  used within the class file format to describe its type.
java.lang.invoke.MemberName#getModifiers()->int:::Return the modifier flags of this member.
java.lang.invoke.MemberName#getReferenceKind()->byte:::Return the reference kind of this member, or zero if none.
java.lang.invoke.MemberName#referenceKindIsConsistentWith(int)->boolean::: member name reference kind is consistent with
java.lang.invoke.MemberName#isMethodHandleInvoke()->boolean:::Utility method to query if this member is a method handle invocation (invoke or invokeExact).
java.lang.invoke.MemberName#isMethodHandleInvokeName(String)->boolean::: member name is method handle invoke name
java.lang.invoke.MemberName#isVarHandleMethodInvoke()->boolean::: member name is var handle method invoke
java.lang.invoke.MemberName#isVarHandleMethodInvokeName(String)->boolean::: member name is var handle method invoke name
java.lang.invoke.MemberName#isStatic()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isPublic()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isPrivate()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isProtected()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isFinal()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#canBeStaticallyBound()->boolean:::Utility method to query whether this member or its defining class is final.
java.lang.invoke.MemberName#isVolatile()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isAbstract()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isNative()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isBridge()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isVarargs()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isSynthetic()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isInvocable()->boolean:::Utility method to query whether this member is a method or constructor.
java.lang.invoke.MemberName#isFieldOrMethod()->boolean:::Utility method to query whether this member is a method, constructor, or field.
java.lang.invoke.MemberName#isMethod()->boolean:::Query whether this member is a method.
java.lang.invoke.MemberName#isConstructor()->boolean:::Query whether this member is a constructor.
java.lang.invoke.MemberName#isField()->boolean:::Query whether this member is a field.
java.lang.invoke.MemberName#isType()->boolean:::Query whether this member is a type.
java.lang.invoke.MemberName#isPackage()->boolean:::Utility method to query whether this member is neither public, private, nor protected.
java.lang.invoke.MemberName#isCallerSensitive()->boolean:::Query whether this member has a CallerSensitive annotation.
java.lang.invoke.MemberName#isAccessibleFrom(Class)->boolean:::Utility method to query whether this member is accessible from a given lookup class.
java.lang.invoke.MemberName#refersTo(Class, String)->boolean:::Check if MemberName is a call to a method named name in class declaredClass.
java.lang.invoke.MemberName#asSpecial()->MemberName::: member name as special
java.lang.invoke.MemberName#asConstructor()->MemberName:::If this MN is not REF_newInvokeSpecial, return a clone with that ref
java.lang.invoke.MemberName#asNormalOriginal()->MemberName:::If this MN is a REF_invokeSpecial, return a clone with the "normal" kind  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface
java.lang.invoke.MemberName#isGetter()->boolean::: member name is getter
java.lang.invoke.MemberName#isSetter()->boolean::: member name is setter
java.lang.invoke.MemberName#asSetter()->MemberName::: member name as setter
java.lang.invoke.MemberName#makeMethodHandleInvoke(String, MethodType)->MemberName:::Create a name for a signature-polymorphic invoker
java.lang.invoke.MemberName#makeMethodHandleInvoke(String, MethodType, int)->MemberName::: member name make method handle invoke
java.lang.invoke.MemberName#makeVarHandleMethodInvoke(String, MethodType)->MemberName::: member name make var handle method invoke
java.lang.invoke.MemberName#makeVarHandleMethodInvoke(String, MethodType, int)->MemberName::: member name make var handle method invoke
java.lang.invoke.MemberName#clone()->MemberName::: member name clone
java.lang.invoke.MemberName#getDefinition()->MemberName:::Get the definition of this member name
java.lang.invoke.MemberName#hashCode()->int::: member name hash code
java.lang.invoke.MemberName#equals(Object)->boolean::: member name equals
java.lang.invoke.MemberName#equals(MemberName)->boolean:::Decide if two member names have exactly the same symbolic content
java.lang.invoke.MemberName#hasReceiverTypeDispatch()->boolean:::Query whether this member name is resolved to a non-static, non-final method.
java.lang.invoke.MemberName#isResolved()->boolean:::Query whether this member name is resolved
java.lang.invoke.MemberName#initResolved(boolean)->void::: member name init resolved
java.lang.invoke.MemberName#checkForTypeAlias(Class)->void::: member name check for type alias
java.lang.invoke.MemberName#toString()->String:::Produce a string form of this member name
java.lang.invoke.MemberName#makeAccessException(String, Object)->IllegalAccessException::: member name make access exception
java.lang.invoke.MemberName#makeAccessException()->ReflectiveOperationException::: member name make access exception
java.lang.invoke.MemberName#getFactory()->Factory::: member name get factory
java.lang.invoke.MemberName.Factory#getMembers(Class, String, Object, int, Class)->List::: factory get members
java.lang.invoke.MemberName.Factory#resolveOrFail(byte, MemberName, Class, Class)->MemberName:::Produce a resolved version of the given member
java.lang.invoke.MemberName.Factory#resolveOrNull(byte, MemberName, Class)->MemberName:::Produce a resolved version of the given member
java.lang.invoke.MemberName.Factory#getMethods(Class, boolean, Class)->List:::Return a list of all methods defined by the given class
java.lang.invoke.MemberName.Factory#getMethods(Class, boolean, String, MethodType, Class)->List:::Return a list of matching methods defined by the given class
java.lang.invoke.MemberName.Factory#getConstructors(Class, Class)->List:::Return a list of all constructors defined by the given class
java.lang.invoke.MemberName.Factory#getFields(Class, boolean, Class)->List:::Return a list of all fields defined by the given class
java.lang.invoke.MemberName.Factory#getFields(Class, boolean, String, Class, Class)->List:::Return a list of all fields defined by the given class
java.lang.invoke.MemberName.Factory#getNestedTypes(Class, boolean, Class)->List:::Return a list of all nested types defined by the given class
java.lang.invoke.MethodHandle#type()->MethodType:::Reports the type of this method handle
java.lang.invoke.MethodHandle#invokeExact(Object...)->Object:::Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match
java.lang.invoke.MethodHandle#invoke(Object...)->Object:::Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values
java.lang.invoke.MethodHandle#invokeBasic(Object...)->Object:::Private method for trusted invocation of a method handle respecting simplified signatures
java.lang.invoke.MethodHandle#linkToVirtual(Object...)->Object:::Private method for trusted invocation of a MemberName of kind REF_invokeVirtual
java.lang.invoke.MethodHandle#linkToStatic(Object...)->Object:::Private method for trusted invocation of a MemberName of kind REF_invokeStatic
java.lang.invoke.MethodHandle#linkToSpecial(Object...)->Object:::Private method for trusted invocation of a MemberName of kind REF_invokeSpecial
java.lang.invoke.MethodHandle#linkToInterface(Object...)->Object:::Private method for trusted invocation of a MemberName of kind REF_invokeInterface
java.lang.invoke.MethodHandle#invokeWithArguments(Object...)->Object:::Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument array
java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List)->Object:::Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact #invoke invoke from a call site which mentions only the type Object, and whose actual argument count is the length of the argument list
java.lang.invoke.MethodHandle#asType(MethodType)->MethodHandle:::Produces an adapter method handle which adapts the type of the current method handle to a new type
java.lang.invoke.MethodHandle#asTypeUncached(MethodType)->MethodHandle::: method handle as type uncached
java.lang.invoke.MethodHandle#asSpreader(Class, int)->MethodHandle:::Makes an array-spreading method handle, which accepts a trailing array argument and spreads its elements as positional arguments
java.lang.invoke.MethodHandle#asSpreader(int, Class, int)->MethodHandle:::Makes an array-spreading method handle, which accepts an array argument at a given position and spreads its elements as positional arguments in place of the array
java.lang.invoke.MethodHandle#withVarargs(boolean)->MethodHandle:::Adapts this method handle to be #asVarargsCollector variable arity if the boolean flag is true, else #asFixedArity fixed arity
java.lang.invoke.MethodHandle#asCollector(Class, int)->MethodHandle:::Makes an array-collecting method handle, which accepts a given number of trailing positional arguments and collects them into an array argument
java.lang.invoke.MethodHandle#asCollector(int, Class, int)->MethodHandle:::Makes an array-collecting method handle, which accepts a given number of positional arguments starting at a given position, and collects them into an array argument
java.lang.invoke.MethodHandle#asCollectorChecks(Class, int, int)->boolean::: method handle as collector checks
java.lang.invoke.MethodHandle#asVarargsCollector(Class)->MethodHandle:::Makes a variable arity adapter which is able to accept any number of trailing positional arguments and collect them into an array argument
java.lang.invoke.MethodHandle#isVarargsCollector()->boolean:::Determines if this method handle supports #asVarargsCollector variable arity calls
java.lang.invoke.MethodHandle#asFixedArity()->MethodHandle:::Makes a fixed arity method handle which is otherwise equivalent to the current method handle
java.lang.invoke.MethodHandle#bindTo(Object)->MethodHandle:::Binds a value x to the first argument of a method handle, without invoking it
java.lang.invoke.MethodHandle#toString()->String:::Returns a string representation of the method handle, starting with the string "MethodHandle" and ending with the string representation of the method handle's type
java.lang.invoke.MethodHandle#standardString()->String::: method handle standard string
java.lang.invoke.MethodHandle#debugString()->String:::Return a string with a several lines describing the method handle structure
java.lang.invoke.MethodHandle#bindArgumentL(int, Object)->BoundMethodHandle::: method handle bind argument l
java.lang.invoke.MethodHandle#setVarargs(MemberName)->MethodHandle::: method handle set varargs
java.lang.invoke.MethodHandle#viewAsType(MethodType, boolean)->MethodHandle::: method handle view as type
java.lang.invoke.MethodHandle#viewAsTypeChecks(MethodType, boolean)->boolean::: method handle view as type checks
java.lang.invoke.MethodHandle#internalForm()->LambdaForm::: method handle internal form
java.lang.invoke.MethodHandle#internalMemberName()->MemberName::: method handle internal member name
java.lang.invoke.MethodHandle#internalCallerClass()->Class::: method handle internal caller class
java.lang.invoke.MethodHandle#intrinsicName()->MethodHandleImpl.Intrinsic::: method handle intrinsic name
java.lang.invoke.MethodHandle#withInternalMemberName(MemberName, boolean)->MethodHandle::: method handle with internal member name
java.lang.invoke.MethodHandle#isInvokeSpecial()->boolean::: method handle is invoke special
java.lang.invoke.MethodHandle#internalValues()->Object::: method handle internal values
java.lang.invoke.MethodHandle#internalProperties()->Object::: method handle internal properties
java.lang.invoke.MethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle::: method handle copy with
java.lang.invoke.MethodHandle#rebind()->BoundMethodHandle:::Require this method handle to be a BMH, or else replace it with a "wrapper" BMH
java.lang.invoke.MethodHandle#updateForm(LambdaForm)->void::: method handle update form
java.lang.invoke.MethodHandle#customize()->void::: method handle customize
java.lang.invoke.MethodHandleImpl#makeArrayElementAccessor(Class, ArrayAccess)->MethodHandle::: method handle impl make array element accessor
java.lang.invoke.MethodHandleImpl#unmatchedArrayAccess(ArrayAccess)->InternalError::: method handle impl unmatched array access
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementI(int[], int)->int::: array accessor get element i
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementJ(long[], int)->long::: array accessor get element j
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementF(float[], int)->float::: array accessor get element f
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementD(double[], int)->double::: array accessor get element d
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementZ(boolean[], int)->boolean::: array accessor get element z
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementB(byte[], int)->byte::: array accessor get element b
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementS(short[], int)->short::: array accessor get element s
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementC(char[], int)->char::: array accessor get element c
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementL(Object[], int)->Object::: array accessor get element l
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementI(int[], int, int)->void::: array accessor set element i
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementJ(long[], int, long)->void::: array accessor set element j
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementF(float[], int, float)->void::: array accessor set element f
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementD(double[], int, double)->void::: array accessor set element d
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementZ(boolean[], int, boolean)->void::: array accessor set element z
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementB(byte[], int, byte)->void::: array accessor set element b
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementS(short[], int, short)->void::: array accessor set element s
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementC(char[], int, char)->void::: array accessor set element c
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementL(Object[], int, Object)->void::: array accessor set element l
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthI(int[])->int::: array accessor length i
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthJ(long[])->int::: array accessor length j
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthF(float[])->int::: array accessor length f
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthD(double[])->int::: array accessor length d
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthZ(boolean[])->int::: array accessor length z
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthB(byte[])->int::: array accessor length b
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthS(short[])->int::: array accessor length s
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthC(char[])->int::: array accessor length c
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthL(Object[])->int::: array accessor length l
java.lang.invoke.MethodHandleImpl.ArrayAccessor#name(Class, ArrayAccess)->String::: array accessor name
java.lang.invoke.MethodHandleImpl.ArrayAccessor#type(Class, ArrayAccess)->MethodType::: array accessor type
java.lang.invoke.MethodHandleImpl.ArrayAccessor#correctType(Class, ArrayAccess)->MethodType::: array accessor correct type
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getAccessor(Class, ArrayAccess)->MethodHandle::: array accessor get accessor
java.lang.invoke.MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean, boolean)->MethodHandle:::Create a JVM-level adapter method handle to conform the given method handle to the similar newType, using only pairwise argument conversions
java.lang.invoke.MethodHandleImpl#makePairwiseConvertByEditor(MethodHandle, MethodType, boolean, boolean)->MethodHandle::: method handle impl make pairwise convert by editor
java.lang.invoke.MethodHandleImpl#makePairwiseConvertIndirect(MethodHandle, MethodType, boolean, boolean)->MethodHandle::: method handle impl make pairwise convert indirect
java.lang.invoke.MethodHandleImpl#computeValueConversions(MethodType, MethodType, boolean, boolean)->Object[]::: method handle impl compute value conversions
java.lang.invoke.MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean)->MethodHandle::: method handle impl make pairwise convert
java.lang.invoke.MethodHandleImpl#valueConversion(Class, Class, boolean, boolean)->Object:::Find a conversion function from the given source to the given destination
java.lang.invoke.MethodHandleImpl#makeVarargsCollector(MethodHandle, Class)->MethodHandle::: method handle impl make varargs collector
java.lang.invoke.MethodHandleImpl#makeSpreadArguments(MethodHandle, Class, int, int)->MethodHandle:::Factory method:  Spread selected argument.
java.lang.invoke.MethodHandleImpl#checkSpreadArgument(Object, int)->void::: method handle impl check spread argument
java.lang.invoke.MethodHandleImpl#makeCollectArguments(MethodHandle, MethodHandle, int, boolean)->MethodHandle:::Factory method:  Collect or filter selected argument(s).
java.lang.invoke.MethodHandleImpl#selectAlternative(boolean, MethodHandle, MethodHandle)->MethodHandle::: method handle impl select alternative
java.lang.invoke.MethodHandleImpl#profileBoolean(boolean, int[])->boolean::: method handle impl profile boolean
java.lang.invoke.MethodHandleImpl#isCompileConstant(Object)->boolean::: method handle impl is compile constant
java.lang.invoke.MethodHandleImpl#makeGuardWithTest(MethodHandle, MethodHandle, MethodHandle)->MethodHandle::: method handle impl make guard with test
java.lang.invoke.MethodHandleImpl#profile(MethodHandle)->MethodHandle::: method handle impl profile
java.lang.invoke.MethodHandleImpl#makeBlockInliningWrapper(MethodHandle)->MethodHandle:::Block inlining during JIT-compilation of a target method handle if it hasn't been invoked enough times
java.lang.invoke.MethodHandleImpl.CountingWrapper#getTarget()->MethodHandle::: counting wrapper get target
java.lang.invoke.MethodHandleImpl.CountingWrapper#asTypeUncached(MethodType)->MethodHandle::: counting wrapper as type uncached
java.lang.invoke.MethodHandleImpl.CountingWrapper#countDown()->boolean::: counting wrapper count down
java.lang.invoke.MethodHandleImpl.CountingWrapper#maybeStopCounting(Object)->void::: counting wrapper maybe stop counting
java.lang.invoke.MethodHandleImpl#makeGuardWithTestForm(MethodType)->LambdaForm::: method handle impl make guard with test form
java.lang.invoke.MethodHandleImpl#makeGuardWithCatch(MethodHandle, Class, MethodHandle)->MethodHandle::: method handle impl make guard with catch
java.lang.invoke.MethodHandleImpl#guardWithCatch(MethodHandle, Class, MethodHandle, Object...)->Object:::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch).
java.lang.invoke.MethodHandleImpl#throwException(MethodType)->MethodHandle::: method handle impl throw exception
java.lang.invoke.MethodHandleImpl#throwException(T)->Empty::: method handle impl throw exception
java.lang.invoke.MethodHandleImpl#fakeMethodHandleInvoke(MemberName)->MethodHandle::: method handle impl fake method handle invoke
java.lang.invoke.MethodHandleImpl#fakeVarHandleInvoke(MemberName)->MethodHandle::: method handle impl fake var handle invoke
java.lang.invoke.MethodHandleImpl#bindCaller(MethodHandle, Class)->MethodHandle:::Create an alias for the method handle which, when called, appears to be called from the same class loader and protection domain as hostClass
java.lang.invoke.MethodHandleImpl#makeWrappedMember(MethodHandle, MemberName, boolean)->MethodHandle::: method handle impl make wrapped member
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#getTarget()->MethodHandle::: intrinsic method handle get target
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#intrinsicName()->Intrinsic::: intrinsic method handle intrinsic name
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#asTypeUncached(MethodType)->MethodHandle::: intrinsic method handle as type uncached
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#internalProperties()->String::: intrinsic method handle internal properties
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#asCollector(Class, int)->MethodHandle::: intrinsic method handle as collector
java.lang.invoke.MethodHandleImpl#makeIntrinsic(MethodHandle, Intrinsic)->MethodHandle::: method handle impl make intrinsic
java.lang.invoke.MethodHandleImpl#makeIntrinsic(MethodType, LambdaForm, Intrinsic)->MethodHandle::: method handle impl make intrinsic
java.lang.invoke.MethodHandleImpl#varargsArray(int)->MethodHandle:::Return a method handle that takes the indicated number of Object  arguments and returns an Object array of them, as if for varargs.
java.lang.invoke.MethodHandleImpl#identity(T[])->T[]::: method handle impl identity
java.lang.invoke.MethodHandleImpl#varargsArray(Class, int)->MethodHandle:::Return a method handle that takes the indicated number of  typed arguments and returns an array of them
java.lang.invoke.MethodHandleImpl#assertSame(Object, Object)->void::: method handle impl assert same
java.lang.invoke.MethodHandleImpl#getFunction(byte)->NamedFunction::: method handle impl get function
java.lang.invoke.MethodHandleImpl#makeLoop(Class, List>, List, List, List, List)->MethodHandle:::Assembles a loop method handle from the given handles and type information.
java.lang.invoke.MethodHandleImpl.LoopClauses#toString()->String::: loop clauses to string
java.lang.invoke.MethodHandleImpl#loop(BasicType[], LoopClauses, Object...)->Object:::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitLoop(int)).
java.lang.invoke.MethodHandleImpl#countedLoopPredicate(int, int)->boolean:::This method is bound as the predicate in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops.
java.lang.invoke.MethodHandleImpl#countedLoopStep(int, int)->int:::This method is bound as the step function in MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle) counting loops to increment the counter.
java.lang.invoke.MethodHandleImpl#initIterator(Iterable)->Iterator:::This is bound to initialize the loop-local iterator in MethodHandles#iteratedLoop iterating loops.
java.lang.invoke.MethodHandleImpl#iteratePredicate(Iterator)->boolean:::This method is bound as the predicate in MethodHandles#iteratedLoop iterating loops.
java.lang.invoke.MethodHandleImpl#iterateNext(Iterator)->Object:::This method is bound as the step for retrieving the current value from the iterator in MethodHandles#iteratedLoop iterating loops.
java.lang.invoke.MethodHandleImpl#makeTryFinally(MethodHandle, MethodHandle, Class, List>)->MethodHandle:::Makes a try-finally handle that conforms to the type constraints.
java.lang.invoke.MethodHandleImpl#tryFinally(MethodHandle, MethodHandle, Object...)->Object:::Intrinsified during LambdaForm compilation (see InvokerBytecodeGenerator#emitTryFinally emitTryFinally).
java.lang.invoke.MethodHandleImpl#getConstantHandle(int)->MethodHandle::: method handle impl get constant handle
java.lang.invoke.MethodHandleInfo#getReferenceKind()->int:::Returns the reference kind of the cracked method handle, which in turn determines whether the method handle's underlying member was a constructor, method, or field
java.lang.invoke.MethodHandleInfo#getDeclaringClass()->Class:::Returns the class in which the cracked method handle's underlying member was defined.
java.lang.invoke.MethodHandleInfo#getName()->String:::Returns the name of the cracked method handle's underlying member
java.lang.invoke.MethodHandleInfo#getMethodType()->MethodType:::Returns the nominal type of the cracked symbolic reference, expressed as a method type
java.lang.invoke.MethodHandleInfo#reflectAs(Class, Lookup)->T:::Reflects the underlying member as a method, constructor, or field object
java.lang.invoke.MethodHandleInfo#getModifiers()->int:::Returns the access modifiers of the underlying member.
java.lang.invoke.MethodHandleInfo#isVarArgs()->boolean::: method handle info is var args
java.lang.invoke.MethodHandleInfo#referenceKindToString(int)->String:::Returns the descriptive name of the given reference kind, as defined in the table above
java.lang.invoke.MethodHandleInfo#toString(int, Class, String, MethodType)->String:::Returns a string representation for a MethodHandleInfo, given the four parts of its symbolic reference
java.lang.invoke.MethodHandleNatives#init(MemberName, Object)->void::: method handle natives init
java.lang.invoke.MethodHandleNatives#expand(MemberName)->void::: method handle natives expand
java.lang.invoke.MethodHandleNatives#resolve(MemberName, Class, boolean)->MemberName::: method handle natives resolve
java.lang.invoke.MethodHandleNatives#getMembers(Class, String, String, int, Class, int, MemberName[])->int::: method handle natives get members
java.lang.invoke.MethodHandleNatives#objectFieldOffset(MemberName)->long::: method handle natives object field offset
java.lang.invoke.MethodHandleNatives#staticFieldOffset(MemberName)->long::: method handle natives static field offset
java.lang.invoke.MethodHandleNatives#staticFieldBase(MemberName)->Object::: method handle natives static field base
java.lang.invoke.MethodHandleNatives#getMemberVMInfo(MemberName)->Object::: method handle natives get member info
java.lang.invoke.MethodHandleNatives#setCallSiteTargetNormal(CallSite, MethodHandle)->void:::Tell the JVM that we need to change the target of a CallSite.
java.lang.invoke.MethodHandleNatives#setCallSiteTargetVolatile(CallSite, MethodHandle)->void::: method handle natives set call site target volatile
java.lang.invoke.MethodHandleNatives#copyOutBootstrapArguments(Class, int[], int, int, Object[], int, boolean, Object)->void::: method handle natives copy out bootstrap arguments
java.lang.invoke.MethodHandleNatives.CallSiteContext#make(CallSite)->CallSiteContext::: call site context make
java.lang.invoke.MethodHandleNatives.CallSiteContext#run()->void::: call site context run
java.lang.invoke.MethodHandleNatives#refKindIsValid(int)->boolean::: method handle natives ref kind is valid
java.lang.invoke.MethodHandleNatives#refKindIsField(byte)->boolean::: method handle natives ref kind is field
java.lang.invoke.MethodHandleNatives#refKindIsGetter(byte)->boolean::: method handle natives ref kind is getter
java.lang.invoke.MethodHandleNatives#refKindIsSetter(byte)->boolean::: method handle natives ref kind is setter
java.lang.invoke.MethodHandleNatives#refKindIsMethod(byte)->boolean::: method handle natives ref kind is method
java.lang.invoke.MethodHandleNatives#refKindIsConstructor(byte)->boolean::: method handle natives ref kind is constructor
java.lang.invoke.MethodHandleNatives#refKindHasReceiver(byte)->boolean::: method handle natives ref kind has receiver
java.lang.invoke.MethodHandleNatives#refKindIsStatic(byte)->boolean::: method handle natives ref kind is static
java.lang.invoke.MethodHandleNatives#refKindDoesDispatch(byte)->boolean::: method handle natives ref kind does dispatch
java.lang.invoke.MethodHandleNatives#refKindName(byte)->String::: method handle natives ref kind name
java.lang.invoke.MethodHandleNatives#verifyConstants()->boolean::: method handle natives verify constants
java.lang.invoke.MethodHandleNatives#linkCallSite(Object, int, Object, Object, Object, Object, Object[])->MemberName:::The JVM is linking an invokedynamic instruction
java.lang.invoke.MethodHandleNatives#linkCallSiteImpl(Class, MethodHandle, String, MethodType, Object, Object[])->MemberName::: method handle natives link call site impl
java.lang.invoke.MethodHandleNatives#linkCallSiteTracing(Class, MethodHandle, String, MethodType, Object, Object[])->MemberName::: method handle natives link call site tracing
java.lang.invoke.MethodHandleNatives#linkDynamicConstant(Object, int, Object, Object, Object, Object)->Object::: method handle natives link dynamic constant
java.lang.invoke.MethodHandleNatives#linkDynamicConstantImpl(Class, MethodHandle, String, Class, Object)->Object::: method handle natives link dynamic constant impl
java.lang.invoke.MethodHandleNatives#linkDynamicConstantTracing(Class, MethodHandle, String, Class, Object)->Object::: method handle natives link dynamic constant tracing
java.lang.invoke.MethodHandleNatives#staticArgumentsPulled(Object)->boolean:::The JVM is requesting pull-mode bootstrap when it provides  a tuple of the form int[]{ argc, vmindex }
java.lang.invoke.MethodHandleNatives#isPullModeBSM(MethodHandle)->boolean:::A BSM runs in pull-mode if and only if its sole arguments are (Lookup, BootstrapCallInfo), or can be converted pairwise to those types, and it is not of variable arity
java.lang.invoke.MethodHandleNatives#findMethodHandleType(Class, Class[])->MethodType:::The JVM wants a pointer to a MethodType
java.lang.invoke.MethodHandleNatives#linkMethod(Class, int, Class, String, Object, Object[])->MemberName:::The JVM wants to link a call site that requires a dynamic type check
java.lang.invoke.MethodHandleNatives#linkMethodImpl(Class, int, Class, String, Object, Object[])->MemberName::: method handle natives link method impl
java.lang.invoke.MethodHandleNatives#linkMethodTracing(Class, int, Class, String, Object, Object[])->MemberName::: method handle natives link method tracing
java.lang.invoke.MethodHandleNatives#getVarHandleGuardMethodName(MethodType)->String::: method handle natives get var handle guard method name
java.lang.invoke.MethodHandleNatives#getCharType(Class)->char::: method handle natives get char type
java.lang.invoke.MethodHandleNatives#newNoSuchMethodErrorOnVarHandle(String, MethodType)->NoSuchMethodError::: method handle natives new no such method error on var handle
java.lang.invoke.MethodHandleNatives#linkMethodHandleConstant(Class, int, Class, String, Object)->MethodHandle:::The JVM is resolving a CONSTANT_MethodHandle CP entry
java.lang.invoke.MethodHandleNatives#mapLookupExceptionToError(ReflectiveOperationException)->LinkageError:::Map a reflective exception to a linkage error.
java.lang.invoke.MethodHandleNatives#initCauseFrom(E, Exception)->E:::Use best possible cause for err.initCause(), substituting the cause for err itself if the cause has the same (or better) type.
java.lang.invoke.MethodHandleNatives#isCallerSensitive(MemberName)->boolean:::Is this method a caller-sensitive method? I.e., does it call Reflection.getCallerClass or a similar method to ask about the identity of its caller?
java.lang.invoke.MethodHandleNatives#canBeCalledVirtual(MemberName)->boolean::: method handle natives can be called virtual
java.lang.invoke.MethodHandleNatives#canBeCalledVirtual(MemberName, Class)->boolean::: method handle natives can be called virtual
java.lang.invoke.MethodHandleProxies#asInterfaceInstance(Class, MethodHandle)->T::: method handle proxies as interface instance
java.lang.invoke.MethodHandleProxies#isWrapperInstance(Object)->boolean:::Determines if the given object was produced by a call to #asInterfaceInstance asInterfaceInstance.
java.lang.invoke.MethodHandleProxies#wrapperInstanceTarget(Object)->MethodHandle:::Produces or recovers a target method handle which is behaviorally equivalent to the unique method of this wrapper instance
java.lang.invoke.MethodHandleProxies#wrapperInstanceType(Object)->Class:::Recovers the unique single-method interface type for which this wrapper instance was created
java.lang.invoke.MethodHandles#lookup()->Lookup:::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors of the caller
java.lang.invoke.MethodHandles#publicLookup()->Lookup:::Returns a Lookup lookup object which is trusted minimally
java.lang.invoke.MethodHandles#privateLookupIn(Class, Lookup)->Lookup:::Returns a Lookup lookup object with full capabilities to emulate all supported bytecode behaviors, including  private access, on a target class
java.lang.invoke.MethodHandles#reflectAs(Class, MethodHandle)->T:::Performs an unchecked "crack" of a direct method handle
java.lang.invoke.MethodHandles.Lookup#lookupClass()->Class:::Tells which class is performing the lookup
java.lang.invoke.MethodHandles.Lookup#lookupModes()->int:::Tells which access-protection classes of members this lookup object can produce
java.lang.invoke.MethodHandles.Lookup#in(Class)->Lookup:::Creates a lookup on the specified new lookup class
java.lang.invoke.MethodHandles.Lookup#dropLookupMode(int)->Lookup:::Creates a lookup on the same lookup class which this lookup object finds members, but with a lookup mode that has lost the given lookup mode
java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])->Class:::Defines a class to the same class loader and in the same runtime package and java.security.ProtectionDomain protection domain as this lookup's #lookupClass() lookup class
java.lang.invoke.MethodHandles.Lookup#toString()->String:::Displays the name of the class from which lookups are to be made
java.lang.invoke.MethodHandles.Lookup#findStatic(Class, String, MethodType)->MethodHandle:::Produces a method handle for a static method
java.lang.invoke.MethodHandles.Lookup#findVirtual(Class, String, MethodType)->MethodHandle:::Produces a method handle for a virtual method
java.lang.invoke.MethodHandles.Lookup#findConstructor(Class, MethodType)->MethodHandle:::Produces a method handle which creates an object and initializes it, using the constructor of the specified type
java.lang.invoke.MethodHandles.Lookup#findClass(String)->Class:::Looks up a class by name from the lookup context defined by this Lookup object
java.lang.invoke.MethodHandles.Lookup#accessClass(Class)->Class:::Determines if a class can be accessed from the lookup context defined by this Lookup object
java.lang.invoke.MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class)->MethodHandle:::Produces an early-bound method handle for a virtual method
java.lang.invoke.MethodHandles.Lookup#findGetter(Class, String, Class)->MethodHandle:::Produces a method handle giving read access to a non-static field
java.lang.invoke.MethodHandles.Lookup#findSetter(Class, String, Class)->MethodHandle:::Produces a method handle giving write access to a non-static field
java.lang.invoke.MethodHandles.Lookup#findVarHandle(Class, String, Class)->VarHandle:::Produces a VarHandle giving access to a non-static field name of type type declared in a class of type recv
java.lang.invoke.MethodHandles.Lookup#findStaticGetter(Class, String, Class)->MethodHandle:::Produces a method handle giving read access to a static field
java.lang.invoke.MethodHandles.Lookup#findStaticSetter(Class, String, Class)->MethodHandle:::Produces a method handle giving write access to a static field
java.lang.invoke.MethodHandles.Lookup#findStaticVarHandle(Class, String, Class)->VarHandle:::Produces a VarHandle giving access to a static field name of type type declared in a class of type decl
java.lang.invoke.MethodHandles.Lookup#bind(Object, String, MethodType)->MethodHandle:::Produces an early-bound method handle for a non-static method
java.lang.invoke.MethodHandles.Lookup#unreflect(Method)->MethodHandle:::Makes a direct method handle to m, if the lookup class has permission
java.lang.invoke.MethodHandles.Lookup#unreflectSpecial(Method, Class)->MethodHandle:::Produces a method handle for a reflected method
java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor)->MethodHandle:::Produces a method handle for a reflected constructor
java.lang.invoke.MethodHandles.Lookup#unreflectGetter(Field)->MethodHandle:::Produces a method handle giving read access to a reflected field
java.lang.invoke.MethodHandles.Lookup#unreflectSetter(Field)->MethodHandle:::Produces a method handle giving write access to a reflected field
java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle(Field)->VarHandle:::Produces a VarHandle giving access to a reflected field f of type T declared in a class of type R
java.lang.invoke.MethodHandles.Lookup#revealDirect(MethodHandle)->MethodHandleInfo:::Cracks a direct method handle created by this lookup object or a similar one
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, Class, String, Class)->MemberName::: lookup resolve or fail
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, Class, String, MethodType)->MemberName::: lookup resolve or fail
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, MemberName)->MemberName::: lookup resolve or fail
java.lang.invoke.MethodHandles.Lookup#resolveOrNull(byte, MemberName)->MemberName::: lookup resolve or null
java.lang.invoke.MethodHandles.Lookup#checkSymbolicClass(Class)->void::: lookup check symbolic class
java.lang.invoke.MethodHandles.Lookup#isClassAccessible(Class)->boolean::: lookup is class accessible
java.lang.invoke.MethodHandles.Lookup#checkMethodName(byte, String)->void:::Check name for an illegal leading "&lt;" character.
java.lang.invoke.MethodHandles.Lookup#findBoundCallerClass(MemberName)->Class:::Find my trustable caller class if m is a caller sensitive method
java.lang.invoke.MethodHandles.Lookup#hasPrivateAccess()->boolean:::Returns true if this lookup has PRIVATE access.
java.lang.invoke.MethodHandles.Lookup#checkSecurityManager(Class, MemberName)->void:::Perform necessary access checks
java.lang.invoke.MethodHandles.Lookup#checkMethod(byte, Class, MemberName)->void::: lookup check method
java.lang.invoke.MethodHandles.Lookup#checkField(byte, Class, MemberName)->void::: lookup check field
java.lang.invoke.MethodHandles.Lookup#checkAccess(byte, Class, MemberName)->void:::Check public/protected/private bits on the symbolic reference class and its member.
java.lang.invoke.MethodHandles.Lookup#accessFailedMessage(Class, MemberName)->String::: lookup access failed message
java.lang.invoke.MethodHandles.Lookup#linkMethodHandleConstant(byte, Class, String, Object)->MethodHandle::: lookup link method handle constant
java.lang.invoke.MethodHandles#arrayConstructor(Class)->MethodHandle:::Produces a method handle constructing arrays of a desired type, as if by the anewarray bytecode
java.lang.invoke.MethodHandles#arrayLength(Class)->MethodHandle:::Produces a method handle returning the length of an array, as if by the arraylength bytecode
java.lang.invoke.MethodHandles#arrayElementGetter(Class)->MethodHandle:::Produces a method handle giving read access to elements of an array, as if by the aaload bytecode
java.lang.invoke.MethodHandles#arrayElementSetter(Class)->MethodHandle:::Produces a method handle giving write access to elements of an array, as if by the astore bytecode
java.lang.invoke.MethodHandles#arrayElementVarHandle(Class)->VarHandle:::Produces a VarHandle giving access to elements of an array of type arrayClass
java.lang.invoke.MethodHandles#byteArrayViewVarHandle(Class, ByteOrder)->VarHandle:::Produces a VarHandle giving access to elements of a byte[] array viewed as if it were a different primitive array type, such as int[] or long[]
java.lang.invoke.MethodHandles#byteBufferViewVarHandle(Class, ByteOrder)->VarHandle:::Produces a VarHandle giving access to elements of a ByteBuffer viewed as if it were an array of elements of a different primitive component type to that of byte, such as int[] or long[]
java.lang.invoke.MethodHandles#spreadInvoker(MethodType, int)->MethodHandle:::Produces a method handle which will invoke any method handle of the given type, with a given number of trailing arguments replaced by a single trailing Object[] array
java.lang.invoke.MethodHandles#exactInvoker(MethodType)->MethodHandle:::Produces a special invoker method handle which can be used to invoke any method handle of the given type, as if by MethodHandle#invokeExact invokeExact
java.lang.invoke.MethodHandles#invoker(MethodType)->MethodHandle:::Produces a special invoker method handle which can be used to invoke any method handle compatible with the given type, as if by MethodHandle#invoke invoke
java.lang.invoke.MethodHandles#varHandleExactInvoker(VarHandle.AccessMode, MethodType)->MethodHandle:::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type
java.lang.invoke.MethodHandles#varHandleInvoker(VarHandle.AccessMode, MethodType)->MethodHandle:::Produces a special invoker method handle which can be used to invoke a signature-polymorphic access mode method on any VarHandle whose associated access mode type is compatible with the given type
java.lang.invoke.MethodHandles#basicInvoker(MethodType)->MethodHandle::: method handles basic invoker
java.lang.invoke.MethodHandles#explicitCastArguments(MethodHandle, MethodType)->MethodHandle:::Produces a method handle which adapts the type of the given method handle to a new type by pairwise argument and return type conversion
java.lang.invoke.MethodHandles#permuteArguments(MethodHandle, MethodType, int...)->MethodHandle:::Produces a method handle which adapts the calling sequence of the given method handle to a new type, by reordering the arguments
java.lang.invoke.MethodHandles#constant(Class, Object)->MethodHandle:::Produces a method handle of the requested return type which returns the given constant value every time it is invoked
java.lang.invoke.MethodHandles#identity(Class)->MethodHandle:::Produces a method handle which returns its sole argument when invoked.
java.lang.invoke.MethodHandles#zero(Class)->MethodHandle:::Produces a constant method handle of the requested return type which returns the default value for that type every time it is invoked
java.lang.invoke.MethodHandles#empty(MethodType)->MethodHandle:::Produces a method handle of the requested type which ignores any arguments, does nothing, and returns a suitable default depending on the return type
java.lang.invoke.MethodHandles#insertArguments(MethodHandle, int, Object...)->MethodHandle:::Provides a target method handle with one or more bound arguments in advance of the method handle's invocation
java.lang.invoke.MethodHandles#dropArguments(MethodHandle, int, List>)->MethodHandle:::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle
java.lang.invoke.MethodHandles#dropArguments(MethodHandle, int, Class...)->MethodHandle:::Produces a method handle which will discard some dummy arguments before calling some other specified target method handle
java.lang.invoke.MethodHandles#dropArgumentsToMatch(MethodHandle, int, List>, int)->MethodHandle:::Adapts a target method handle to match the given parameter type list
java.lang.invoke.MethodHandles#filterArguments(MethodHandle, int, MethodHandle...)->MethodHandle:::Adapts a target method handle by pre-processing one or more of its arguments, each with its own unary filter function, and then calling the target with each pre-processed argument replaced by the result of its corresponding filter function
java.lang.invoke.MethodHandles#filterArgument(MethodHandle, int, MethodHandle)->MethodHandle::: method handles filter argument
java.lang.invoke.MethodHandles#collectArguments(MethodHandle, int, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing a sub-sequence of its arguments with a filter (another method handle)
java.lang.invoke.MethodHandles#filterReturnValue(MethodHandle, MethodHandle)->MethodHandle:::Adapts a target method handle by post-processing its return value (if any) with a filter (another method handle)
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing some of its arguments, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, int, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then calling the target with the result of the pre-processing, inserted into the original sequence of arguments just before the folded arguments
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, int, MethodHandle, int...)->MethodHandle:::As foldArguments(MethodHandle, int, MethodHandle), but with the added capability of selecting the arguments from the targets parameters to call the combiner with
java.lang.invoke.MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Makes a method handle which adapts a target method handle, by guarding it with a test, a boolean-valued method handle
java.lang.invoke.MethodHandles#misMatchedTypes(String, T, T)->RuntimeException::: method handles mis matched types
java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)->MethodHandle:::Makes a method handle which adapts a target method handle, by running it inside an exception handler
java.lang.invoke.MethodHandles#throwException(Class, Class)->MethodHandle:::Produces a method handle which will throw exceptions of the given exType
java.lang.invoke.MethodHandles#loop(MethodHandle[]...)->MethodHandle:::Constructs a method handle representing a loop with several loop variables that are updated and checked upon each iteration
java.lang.invoke.MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a while loop from an initializer, a body, and a predicate
java.lang.invoke.MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a do-while loop from an initializer, a body, and a predicate
java.lang.invoke.MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that runs a given number of iterations
java.lang.invoke.MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that counts over a range of numbers
java.lang.invoke.MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that ranges over the values produced by an Iterator<T>
java.lang.invoke.MethodHandles#swapArguments(MethodHandle, int, int)->MethodHandle::: method handles swap arguments
java.lang.invoke.MethodHandles#tryFinally(MethodHandle, MethodHandle)->MethodHandle:::Makes a method handle that adapts a target method handle by wrapping it in a try-finally block
java.lang.invoke.MethodHandleStatics#debugEnabled()->boolean::: method handle statics debug enabled
java.lang.invoke.MethodHandleStatics#newInternalError(String)->InternalError::: method handle statics new internal error
java.lang.invoke.MethodHandleStatics#newInternalError(String, Exception)->InternalError::: method handle statics new internal error
java.lang.invoke.MethodHandleStatics#newInternalError(Exception)->InternalError::: method handle statics new internal error
java.lang.invoke.MethodHandleStatics#newIllegalStateException(String)->RuntimeException::: method handle statics new illegal state exception
java.lang.invoke.MethodHandleStatics#newIllegalStateException(String, Object)->RuntimeException::: method handle statics new illegal state exception
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String)->RuntimeException::: method handle statics new illegal argument exception
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String, Object)->RuntimeException::: method handle statics new illegal argument exception
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String, Object, Object)->RuntimeException::: method handle statics new illegal argument exception
java.lang.invoke.MethodHandleStatics#uncaughtException(Throwable)->Error::: method handle statics uncaught exception
java.lang.invoke.MethodHandleStatics#rangeCheck2(int, int, int)->void::: method handle statics range check2
java.lang.invoke.MethodHandleStatics#rangeCheck1(int, int)->int::: method handle statics range check1
java.lang.invoke.MethodType#form()->MethodTypeForm::: method type form
java.lang.invoke.MethodType#rtype()->Class::: method type rtype
java.lang.invoke.MethodType#ptypes()->Class[]::: method type ptypes
java.lang.invoke.MethodType#setForm(MethodTypeForm)->void::: method type set form
java.lang.invoke.MethodType#checkSlotCount(int)->void::: method type check slot count
java.lang.invoke.MethodType#methodType(Class, Class[])->MethodType:::Finds or creates an instance of the given method type.
java.lang.invoke.MethodType#methodType(Class, List>)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class, Class, Class...)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class, Class)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class, MethodType)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#makeImpl(Class, Class[], boolean)->MethodType::: method type make impl
java.lang.invoke.MethodType#genericMethodType(int, boolean)->MethodType:::Finds or creates a method type whose components are Object with an optional trailing Object[] array
java.lang.invoke.MethodType#genericMethodType(int)->MethodType:::Finds or creates a method type whose components are all Object
java.lang.invoke.MethodType#changeParameterType(int, Class)->MethodType:::Finds or creates a method type with a single different parameter type
java.lang.invoke.MethodType#insertParameterTypes(int, Class...)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#appendParameterTypes(Class...)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#insertParameterTypes(int, List>)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#appendParameterTypes(List>)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#replaceParameterTypes(int, int, Class...)->MethodType::: method type replace parameter types
java.lang.invoke.MethodType#asSpreaderType(Class, int, int)->MethodType::: method type as spreader type
java.lang.invoke.MethodType#leadingReferenceParameter()->Class::: method type leading reference parameter
java.lang.invoke.MethodType#asCollectorType(Class, int, int)->MethodType::: method type as collector type
java.lang.invoke.MethodType#dropParameterTypes(int, int)->MethodType:::Finds or creates a method type with some parameter types omitted
java.lang.invoke.MethodType#changeReturnType(Class)->MethodType:::Finds or creates a method type with a different return type
java.lang.invoke.MethodType#hasPrimitives()->boolean:::Reports if this type contains a primitive argument or return value
java.lang.invoke.MethodType#hasWrappers()->boolean:::Reports if this type contains a wrapper argument or return value
java.lang.invoke.MethodType#erase()->MethodType:::Erases all reference types to Object
java.lang.invoke.MethodType#basicType()->MethodType::: method type basic type
java.lang.invoke.MethodType#invokerType()->MethodType::: method type invoker type
java.lang.invoke.MethodType#generic()->MethodType:::Converts all types, both reference and primitive, to Object
java.lang.invoke.MethodType#isGeneric()->boolean::: method type is generic
java.lang.invoke.MethodType#wrap()->MethodType:::Converts all primitive types to their corresponding wrapper types
java.lang.invoke.MethodType#unwrap()->MethodType:::Converts all wrapper types to their corresponding primitive types
java.lang.invoke.MethodType#parameterType(int)->Class:::Returns the parameter type at the specified index, within this method type.
java.lang.invoke.MethodType#parameterCount()->int:::Returns the number of parameter types in this method type.
java.lang.invoke.MethodType#returnType()->Class:::Returns the return type of this method type.
java.lang.invoke.MethodType#parameterList()->List>:::Presents the parameter types as a list (a convenience method)
java.lang.invoke.MethodType#lastParameterType()->Class:::Returns the last parameter type of this method type
java.lang.invoke.MethodType#parameterArray()->Class[]:::Presents the parameter types as an array (a convenience method)
java.lang.invoke.MethodType#equals(Object)->boolean:::Compares the specified object with this type for equality
java.lang.invoke.MethodType#hashCode()->int:::Returns the hash code value for this method type
java.lang.invoke.MethodType#toString()->String:::Returns a string representation of the method type, of the form "(PT0,PT1...)RT"
java.lang.invoke.MethodType#effectivelyIdenticalParameters(int, List>)->boolean::: method type effectively identical parameters
java.lang.invoke.MethodType#isViewableAs(MethodType, boolean)->boolean::: method type is viewable as
java.lang.invoke.MethodType#isConvertibleTo(MethodType)->boolean::: method type is convertible to
java.lang.invoke.MethodType#explicitCastEquivalentToAsType(MethodType)->boolean::: method type explicit cast equivalent to as type
java.lang.invoke.MethodType#canConvert(Class, Class)->boolean::: method type can convert
java.lang.invoke.MethodType#parameterSlotCount()->int::: method type parameter slot count
java.lang.invoke.MethodType#invokers()->Invokers::: method type invokers
java.lang.invoke.MethodType#parameterSlotDepth(int)->int::: method type parameter slot depth
java.lang.invoke.MethodType#returnSlotCount()->int::: method type return slot count
java.lang.invoke.MethodType#fromMethodDescriptorString(String, ClassLoader)->MethodType:::Finds or creates an instance of a method type, given the spelling of its bytecode descriptor
java.lang.invoke.MethodType#fromDescriptor(String, ClassLoader)->MethodType:::Same as #fromMethodDescriptorString(String, ClassLoader), but null ClassLoader means the bootstrap loader is used here
java.lang.invoke.MethodType#toMethodDescriptorString()->String:::Produces a bytecode descriptor representation of the method type
java.lang.invoke.MethodType#toFieldDescriptorString(Class)->String::: method type to field descriptor string
java.lang.invoke.MethodTypeForm#erasedType()->MethodType:::Return the type corresponding uniquely (1-1) to this MT-form
java.lang.invoke.MethodTypeForm#basicType()->MethodType:::Return the basic type derived from the erased type of this MT-form
java.lang.invoke.MethodTypeForm#cachedMethodHandle(int)->MethodHandle::: method type form cached method handle
java.lang.invoke.MethodTypeForm#setCachedMethodHandle(int, MethodHandle)->MethodHandle::: method type form set cached method handle
java.lang.invoke.MethodTypeForm#cachedLambdaForm(int)->LambdaForm::: method type form cached lambda form
java.lang.invoke.MethodTypeForm#setCachedLambdaForm(int, LambdaForm)->LambdaForm::: method type form set cached lambda form
java.lang.invoke.MethodTypeForm#parameterCount()->int::: method type form parameter count
java.lang.invoke.MethodTypeForm#parameterSlotCount()->int::: method type form parameter slot count
java.lang.invoke.MethodTypeForm#returnCount()->int::: method type form return count
java.lang.invoke.MethodTypeForm#returnSlotCount()->int::: method type form return slot count
java.lang.invoke.MethodTypeForm#primitiveParameterCount()->int::: method type form primitive parameter count
java.lang.invoke.MethodTypeForm#longPrimitiveParameterCount()->int::: method type form long primitive parameter count
java.lang.invoke.MethodTypeForm#primitiveReturnCount()->int::: method type form primitive return count
java.lang.invoke.MethodTypeForm#longPrimitiveReturnCount()->int::: method type form long primitive return count
java.lang.invoke.MethodTypeForm#hasPrimitives()->boolean::: method type form has primitives
java.lang.invoke.MethodTypeForm#hasNonVoidPrimitives()->boolean::: method type form has non void primitives
java.lang.invoke.MethodTypeForm#hasLongPrimitives()->boolean::: method type form has long primitives
java.lang.invoke.MethodTypeForm#parameterToArgSlot(int)->int::: method type form parameter to arg slot
java.lang.invoke.MethodTypeForm#argSlotToParameter(int)->int::: method type form arg slot to parameter
java.lang.invoke.MethodTypeForm#findForm(MethodType)->MethodTypeForm::: method type form find form
java.lang.invoke.MethodTypeForm#canonicalize(MethodType, int, int)->MethodType:::Canonicalize the types in the given method type
java.lang.invoke.MethodTypeForm#canonicalize(Class, int)->Class:::Canonicalize the given return or param type
java.lang.invoke.MethodTypeForm#canonicalizeAll(Class[], int)->Class[]:::Canonicalize each param type in the given array
java.lang.invoke.MethodTypeForm#toString()->String::: method type form to string
java.lang.invoke.MutableCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves like a normal field of the MutableCallSite
java.lang.invoke.MutableCallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, as a normal variable
java.lang.invoke.MutableCallSite#dynamicInvoker()->MethodHandle::: mutable call site dynamic invoker
java.lang.invoke.MutableCallSite#syncAll(MutableCallSite[])->void:::Performs a synchronization operation on each call site in the given array, forcing all other threads to throw away any cached values previously loaded from the target of any of the call sites
java.lang.invoke.ProxyClassesDumper#getInstance(String)->ProxyClassesDumper::: proxy classes dumper get instance
java.lang.invoke.ProxyClassesDumper#encodeForFilename(String)->String::: proxy classes dumper encode for filename
java.lang.invoke.ProxyClassesDumper#dumpClass(String, byte[])->void::: proxy classes dumper dump class
java.lang.invoke.SerializedLambda#getCapturingClass()->String:::Get the name of the class that captured this lambda.
java.lang.invoke.SerializedLambda#getFunctionalInterfaceClass()->String:::Get the name of the invoked type to which this lambda has been converted
java.lang.invoke.SerializedLambda#getFunctionalInterfaceMethodName()->String:::Get the name of the primary method for the functional interface to which this lambda has been converted.
java.lang.invoke.SerializedLambda#getFunctionalInterfaceMethodSignature()->String:::Get the signature of the primary method for the functional interface to which this lambda has been converted.
java.lang.invoke.SerializedLambda#getImplClass()->String:::Get the name of the class containing the implementation method.
java.lang.invoke.SerializedLambda#getImplMethodName()->String:::Get the name of the implementation method.
java.lang.invoke.SerializedLambda#getImplMethodSignature()->String:::Get the signature of the implementation method.
java.lang.invoke.SerializedLambda#getImplMethodKind()->int:::Get the method handle kind (see MethodHandleInfo) of the implementation method.
java.lang.invoke.SerializedLambda#getInstantiatedMethodType()->String:::Get the signature of the primary functional interface method after type variables are substituted with their instantiation from the capture site.
java.lang.invoke.SerializedLambda#getCapturedArgCount()->int:::Get the count of dynamic arguments to the lambda capture site.
java.lang.invoke.SerializedLambda#getCapturedArg(int)->Object:::Get a dynamic argument to the lambda capture site.
java.lang.invoke.SerializedLambda#toString()->String::: serialized lambda to string
java.lang.invoke.SimpleMethodHandle#make(MethodType, LambdaForm)->BoundMethodHandle::: simple method handle make
java.lang.invoke.SimpleMethodHandle#speciesData()->BoundMethodHandle.SpeciesData::: simple method handle species data
java.lang.invoke.SimpleMethodHandle#copyWith(MethodType, LambdaForm)->BoundMethodHandle::: simple method handle copy with
java.lang.invoke.SimpleMethodHandle#internalProperties()->String::: simple method handle internal properties
java.lang.invoke.SimpleMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)->BoundMethodHandle::: simple method handle copy with extend l
java.lang.invoke.SimpleMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)->BoundMethodHandle::: simple method handle copy with extend i
java.lang.invoke.SimpleMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)->BoundMethodHandle::: simple method handle copy with extend j
java.lang.invoke.SimpleMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)->BoundMethodHandle::: simple method handle copy with extend f
java.lang.invoke.SimpleMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)->BoundMethodHandle::: simple method handle copy with extend d
java.lang.invoke.StringConcatFactory#makeConcat(MethodHandles.Lookup, String, MethodType)->CallSite:::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments
java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup, String, MethodType, String, Object...)->CallSite:::Facilitates the creation of optimized String concatenation methods, that can be used to efficiently concatenate a known number of arguments of known types, possibly after type adaptation and partial evaluation of arguments
java.lang.invoke.StringConcatFactory#lookupStatic(Lookup, Class, String, Class, Class...)->MethodHandle::: string concat factory lookup static
java.lang.invoke.StringConcatFactory#lookupVirtual(Lookup, Class, String, Class, Class...)->MethodHandle::: string concat factory lookup virtual
java.lang.invoke.StringConcatFactory#lookupConstructor(Lookup, Class, Class)->MethodHandle::: string concat factory lookup constructor
java.lang.invoke.StringConcatFactory#estimateSize(Class)->int::: string concat factory estimate size
java.lang.invoke.StringConcatFactory#adaptToStringBuilder(Class)->Class::: string concat factory adapt to string builder
java.lang.invoke.SwitchPoint#hasBeenInvalidated()->boolean:::Determines if this switch point has been invalidated yet
java.lang.invoke.SwitchPoint#guardWithTest(MethodHandle, MethodHandle)->MethodHandle:::Returns a method handle which always delegates either to the target or the fallback
java.lang.invoke.SwitchPoint#invalidateAll(SwitchPoint[])->void:::Sets all of the given switch points into the invalid state
java.lang.invoke.TypeConvertingMethodAdapter#boxIfTypePrimitive(Type)->void::: type converting method adapter box if type primitive
java.lang.invoke.TypeConvertingMethodAdapter#widen(Wrapper, Wrapper)->void::: type converting method adapter widen
java.lang.invoke.TypeConvertingMethodAdapter#box(Wrapper)->void::: type converting method adapter box
java.lang.invoke.TypeConvertingMethodAdapter#unbox(String, Wrapper)->void:::Convert types by unboxing
java.lang.invoke.TypeConvertingMethodAdapter#cast(String, String)->void::: type converting method adapter cast
java.lang.invoke.TypeConvertingMethodAdapter#convertType(Class, Class, Class)->void:::Convert an argument of type 'arg' to be passed to 'target' assuring that it is 'functional'
java.lang.invoke.TypeConvertingMethodAdapter#iconst(int)->void:::The following method is copied from org.objectweb.asm.commons.InstructionAdapter
java.lang.invoke.VarForm#getMethodType(int)->MethodType::: var form get method type
java.lang.invoke.VarForm#getMemberName(int)->MemberName::: var form get member name
java.lang.invoke.VarForm#getMethodType_V_init()->MethodType[]::: var form get method type_ v_init
java.lang.invoke.VarForm#getMethodType_V(int)->MethodType::: var form get method type_ v
java.lang.invoke.VarHandle#unsupported()->RuntimeException::: var handle unsupported
java.lang.invoke.VarHandle#get(Object...)->Object:::Returns the value of a variable, with memory semantics of reading as if the variable was declared non-volatile
java.lang.invoke.VarHandle#set(Object...)->void:::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared non-volatile and non-final
java.lang.invoke.VarHandle#getVolatile(Object...)->Object:::Returns the value of a variable, with memory semantics of reading as if the variable was declared volatile
java.lang.invoke.VarHandle#setVolatile(Object...)->void:::Sets the value of a variable to the newValue, with memory semantics of setting as if the variable was declared volatile
java.lang.invoke.VarHandle#getOpaque(Object...)->Object:::Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads
java.lang.invoke.VarHandle#setOpaque(Object...)->void:::Sets the value of a variable to the newValue, in program order, but with no assurance of memory ordering effects with respect to other threads
java.lang.invoke.VarHandle#getAcquire(Object...)->Object:::Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access
java.lang.invoke.VarHandle#setRelease(Object...)->void:::Sets the value of a variable to the newValue, and ensures that prior loads and stores are not reordered after this access
java.lang.invoke.VarHandle#compareAndSet(Object...)->boolean:::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#compareAndExchange(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#compareAndExchangeAcquire(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#compareAndExchangeRelease(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#weakCompareAndSetPlain(Object...)->boolean:::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#weakCompareAndSet(Object...)->boolean:::Possibly atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#weakCompareAndSetAcquire(Object...)->boolean:::Possibly atomically sets the value of a variable to the newValue with the semantics of #set if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#weakCompareAndSetRelease(Object...)->boolean:::Possibly atomically sets the value of a variable to the newValue with the semantics of #setRelease if the variable's current value, referred to as the witness value, == the expectedValue, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#getAndSet(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#getAndSetAcquire(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#getAndSetRelease(Object...)->Object:::Atomically sets the value of a variable to the newValue with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#getAndAdd(Object...)->Object:::Atomically adds the value to the current value of a variable with the memory semantics of #setVolatile, and returns the variable's previous value, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#getAndAddAcquire(Object...)->Object:::Atomically adds the value to the current value of a variable with the memory semantics of #set, and returns the variable's previous value, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#getAndAddRelease(Object...)->Object:::Atomically adds the value to the current value of a variable with the memory semantics of #setRelease, and returns the variable's previous value, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#getAndBitwiseOr(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#getAndBitwiseOrAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#getAndBitwiseOrRelease(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#getAndBitwiseAnd(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#getAndBitwiseAndAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#getAndBitwiseAndRelease(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#getAndBitwiseXor(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setVolatile and returns the variable's previous value, as accessed with the memory semantics of #getVolatile
java.lang.invoke.VarHandle#getAndBitwiseXorAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #set and returns the variable's previous value, as accessed with the memory semantics of #getAcquire
java.lang.invoke.VarHandle#getAndBitwiseXorRelease(Object...)->Object:::Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the mask with the memory semantics of #setRelease and returns the variable's previous value, as accessed with the memory semantics of #get
java.lang.invoke.VarHandle#varType()->Class:::Returns the variable type of variables referenced by this VarHandle.
java.lang.invoke.VarHandle#coordinateTypes()->List>:::Returns the coordinate types for this VarHandle.
java.lang.invoke.VarHandle#accessModeType(AccessMode)->MethodType:::Obtains the access mode type for this VarHandle and a given access mode
java.lang.invoke.VarHandle#accessModeTypeUncached(AccessMode)->MethodType::: var handle access mode type uncached
java.lang.invoke.VarHandle#isAccessModeSupported(AccessMode)->boolean:::Returns true if the given access mode is supported, otherwise false
java.lang.invoke.VarHandle#toMethodHandle(AccessMode)->MethodHandle:::Obtains a method handle bound to this VarHandle and the given access mode.
java.lang.invoke.VarHandle#getMethodHandle(int)->MethodHandle::: var handle get method handle
java.lang.invoke.VarHandle#updateVarForm(VarForm)->void::: var handle update var form
java.lang.invoke.VarHandle#fullFence()->void:::Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.
java.lang.invoke.VarHandle#acquireFence()->void:::Ensures that loads before the fence will not be reordered with loads and stores after the fence.
java.lang.invoke.VarHandle#releaseFence()->void:::Ensures that loads and stores before the fence will not be reordered with stores after the fence.
java.lang.invoke.VarHandle#loadLoadFence()->void:::Ensures that loads before the fence will not be reordered with loads after the fence.
java.lang.invoke.VarHandle#storeStoreFence()->void:::Ensures that stores before the fence will not be reordered with stores after the fence.
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->boolean::: field instance read only get
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->boolean::: field instance read only get volatile
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->boolean::: field instance read only get opaque
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->boolean::: field instance read only get acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, boolean)->void::: field instance read write set
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, boolean)->void::: field instance read write set volatile
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, boolean)->void::: field instance read write set opaque
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, boolean)->void::: field instance read write set release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write compare and exchange
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write compare and exchange release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, boolean, boolean)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and set
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and set acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and set release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise or
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise and
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, boolean)->boolean::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#get(FieldStaticReadOnly)->boolean::: field static read only get
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->boolean::: field static read only get volatile
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->boolean::: field static read only get opaque
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->boolean::: field static read only get acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#set(FieldStaticReadWrite, boolean)->void::: field static read write set
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, boolean)->void::: field static read write set volatile
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, boolean)->void::: field static read write set opaque
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, boolean)->void::: field static read write set release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write compare and exchange
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write compare and exchange release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, boolean, boolean)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, boolean)->boolean::: field static read write get and set
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, boolean)->boolean::: field static read write get and set acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, boolean)->boolean::: field static read write get and set release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise or
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise or release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise and
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise and release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise xor
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, boolean)->boolean::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleBooleans.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleBooleans.Array#get(Array, Object, int)->boolean::: array get
java.lang.invoke.VarHandleBooleans.Array#set(Array, Object, int, boolean)->void::: array set
java.lang.invoke.VarHandleBooleans.Array#getVolatile(Array, Object, int)->boolean::: array get volatile
java.lang.invoke.VarHandleBooleans.Array#setVolatile(Array, Object, int, boolean)->void::: array set volatile
java.lang.invoke.VarHandleBooleans.Array#getOpaque(Array, Object, int)->boolean::: array get opaque
java.lang.invoke.VarHandleBooleans.Array#setOpaque(Array, Object, int, boolean)->void::: array set opaque
java.lang.invoke.VarHandleBooleans.Array#getAcquire(Array, Object, int)->boolean::: array get acquire
java.lang.invoke.VarHandleBooleans.Array#setRelease(Array, Object, int, boolean)->void::: array set release
java.lang.invoke.VarHandleBooleans.Array#compareAndSet(Array, Object, int, boolean, boolean)->boolean::: array compare and set
java.lang.invoke.VarHandleBooleans.Array#compareAndExchange(Array, Object, int, boolean, boolean)->boolean::: array compare and exchange
java.lang.invoke.VarHandleBooleans.Array#compareAndExchangeAcquire(Array, Object, int, boolean, boolean)->boolean::: array compare and exchange acquire
java.lang.invoke.VarHandleBooleans.Array#compareAndExchangeRelease(Array, Object, int, boolean, boolean)->boolean::: array compare and exchange release
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetPlain(Array, Object, int, boolean, boolean)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSet(Array, Object, int, boolean, boolean)->boolean::: array weak compare and set
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetAcquire(Array, Object, int, boolean, boolean)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetRelease(Array, Object, int, boolean, boolean)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleBooleans.Array#getAndSet(Array, Object, int, boolean)->boolean::: array get and set
java.lang.invoke.VarHandleBooleans.Array#getAndSetAcquire(Array, Object, int, boolean)->boolean::: array get and set acquire
java.lang.invoke.VarHandleBooleans.Array#getAndSetRelease(Array, Object, int, boolean)->boolean::: array get and set release
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOr(Array, Object, int, boolean)->boolean::: array get and bitwise or
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOrRelease(Array, Object, int, boolean)->boolean::: array get and bitwise or release
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOrAcquire(Array, Object, int, boolean)->boolean::: array get and bitwise or acquire
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAnd(Array, Object, int, boolean)->boolean::: array get and bitwise and
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAndRelease(Array, Object, int, boolean)->boolean::: array get and bitwise and release
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAndAcquire(Array, Object, int, boolean)->boolean::: array get and bitwise and acquire
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXor(Array, Object, int, boolean)->boolean::: array get and bitwise xor
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXorRelease(Array, Object, int, boolean)->boolean::: array get and bitwise xor release
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXorAcquire(Array, Object, int, boolean)->boolean::: array get and bitwise xor acquire
java.lang.invoke.VarHandleByteArrayAsChars#convEndian(boolean, char)->char::: var handle byte array as chars conv endian
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#get(ArrayHandle, Object, int)->char::: array handle get
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#set(ArrayHandle, Object, int, char)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getVolatile(ArrayHandle, Object, int)->char::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setVolatile(ArrayHandle, Object, int, char)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getAcquire(ArrayHandle, Object, int)->char::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setRelease(ArrayHandle, Object, int, char)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getOpaque(ArrayHandle, Object, int)->char::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setOpaque(ArrayHandle, Object, int, char)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#get(ByteBufferHandle, Object, int)->char::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#set(ByteBufferHandle, Object, int, char)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->char::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, char)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->char::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, char)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->char::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, char)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayAsDoubles#convEndian(boolean, double)->long::: var handle byte array as doubles conv endian
java.lang.invoke.VarHandleByteArrayAsDoubles#convEndian(boolean, long)->double::: var handle byte array as doubles conv endian
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#get(ArrayHandle, Object, int)->double::: array handle get
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#set(ArrayHandle, Object, int, double)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getVolatile(ArrayHandle, Object, int)->double::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setVolatile(ArrayHandle, Object, int, double)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAcquire(ArrayHandle, Object, int)->double::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setRelease(ArrayHandle, Object, int, double)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getOpaque(ArrayHandle, Object, int)->double::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setOpaque(ArrayHandle, Object, int, double)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndSet(ArrayHandle, Object, int, double, double)->boolean::: array handle compare and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, double, double)->double::: array handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, double, double)->double::: array handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, double, double)->double::: array handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, double, double)->boolean::: array handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, double, double)->boolean::: array handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, double, double)->boolean::: array handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, double, double)->boolean::: array handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSet(ArrayHandle, Object, int, double)->double::: array handle get and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, double)->double::: array handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, double)->double::: array handle get and set release
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#get(ByteBufferHandle, Object, int)->double::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#set(ByteBufferHandle, Object, int, double)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->double::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, double)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->double::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, double)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->double::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, double)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, double, double)->boolean::: byte buffer handle compare and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, double, double)->double::: byte buffer handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, double, double)->double::: byte buffer handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, double, double)->double::: byte buffer handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, double, double)->boolean::: byte buffer handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, double, double)->boolean::: byte buffer handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, double, double)->boolean::: byte buffer handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, double, double)->boolean::: byte buffer handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, double)->double::: byte buffer handle get and set
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, double)->double::: byte buffer handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, double)->double::: byte buffer handle get and set release
java.lang.invoke.VarHandleByteArrayAsFloats#convEndian(boolean, float)->int::: var handle byte array as floats conv endian
java.lang.invoke.VarHandleByteArrayAsFloats#convEndian(boolean, int)->float::: var handle byte array as floats conv endian
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#get(ArrayHandle, Object, int)->float::: array handle get
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#set(ArrayHandle, Object, int, float)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getVolatile(ArrayHandle, Object, int)->float::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setVolatile(ArrayHandle, Object, int, float)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAcquire(ArrayHandle, Object, int)->float::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setRelease(ArrayHandle, Object, int, float)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getOpaque(ArrayHandle, Object, int)->float::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setOpaque(ArrayHandle, Object, int, float)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndSet(ArrayHandle, Object, int, float, float)->boolean::: array handle compare and set
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, float, float)->float::: array handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, float, float)->float::: array handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, float, float)->float::: array handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, float, float)->boolean::: array handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, float, float)->boolean::: array handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, float, float)->boolean::: array handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, float, float)->boolean::: array handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSet(ArrayHandle, Object, int, float)->float::: array handle get and set
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, float)->float::: array handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, float)->float::: array handle get and set release
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#get(ByteBufferHandle, Object, int)->float::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#set(ByteBufferHandle, Object, int, float)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->float::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, float)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->float::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, float)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->float::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, float)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, float, float)->boolean::: byte buffer handle compare and set
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, float, float)->float::: byte buffer handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, float, float)->float::: byte buffer handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, float, float)->float::: byte buffer handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, float, float)->boolean::: byte buffer handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, float, float)->boolean::: byte buffer handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, float, float)->boolean::: byte buffer handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, float, float)->boolean::: byte buffer handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, float)->float::: byte buffer handle get and set
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, float)->float::: byte buffer handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, float)->float::: byte buffer handle get and set release
java.lang.invoke.VarHandleByteArrayAsInts#convEndian(boolean, int)->int::: var handle byte array as ints conv endian
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#get(ArrayHandle, Object, int)->int::: array handle get
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#set(ArrayHandle, Object, int, int)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getVolatile(ArrayHandle, Object, int)->int::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setVolatile(ArrayHandle, Object, int, int)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAcquire(ArrayHandle, Object, int)->int::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setRelease(ArrayHandle, Object, int, int)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getOpaque(ArrayHandle, Object, int)->int::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setOpaque(ArrayHandle, Object, int, int)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndSet(ArrayHandle, Object, int, int, int)->boolean::: array handle compare and set
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, int, int)->int::: array handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, int, int)->int::: array handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, int, int)->int::: array handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, int, int)->boolean::: array handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, int, int)->boolean::: array handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, int, int)->boolean::: array handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, int, int)->boolean::: array handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSet(ArrayHandle, Object, int, int)->int::: array handle get and set
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, int)->int::: array handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, int)->int::: array handle get and set release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAdd(ArrayHandle, Object, int, int)->int::: array handle get and add
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, int)->int::: array handle get and add acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, int)->int::: array handle get and add release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, int)->int::: array handle get and add conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, int)->int::: array handle get and bitwise or
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, int)->int::: array handle get and bitwise or release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, int)->int::: array handle get and bitwise or acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, int)->int::: array handle get and bitwise or conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, int)->int::: array handle get and bitwise and
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, int)->int::: array handle get and bitwise and release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, int)->int::: array handle get and bitwise and acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, int)->int::: array handle get and bitwise and conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, int)->int::: array handle get and bitwise xor
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, int)->int::: array handle get and bitwise xor release
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, int)->int::: array handle get and bitwise xor acquire
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, int)->int::: array handle get and bitwise xor conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#get(ByteBufferHandle, Object, int)->int::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#set(ByteBufferHandle, Object, int, int)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->int::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, int)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->int::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, int)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->int::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, int)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, int, int)->boolean::: byte buffer handle compare and set
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, int, int)->int::: byte buffer handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, int, int)->int::: byte buffer handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, int, int)->int::: byte buffer handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, int, int)->boolean::: byte buffer handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, int, int)->boolean::: byte buffer handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, int, int)->boolean::: byte buffer handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, int, int)->boolean::: byte buffer handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and set
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and set release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and add
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and add acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and add release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, int)->int::: byte buffer handle get and add conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise or
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise or release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise or acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, int)->int::: byte buffer handle get and bitwise or conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise and
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise and release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise and acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, int)->int::: byte buffer handle get and bitwise and conv endian with s
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise xor
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise xor release
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, int)->int::: byte buffer handle get and bitwise xor acquire
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, int)->int::: byte buffer handle get and bitwise xor conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs#convEndian(boolean, long)->long::: var handle byte array as longs conv endian
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#get(ArrayHandle, Object, int)->long::: array handle get
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#set(ArrayHandle, Object, int, long)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getVolatile(ArrayHandle, Object, int)->long::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setVolatile(ArrayHandle, Object, int, long)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAcquire(ArrayHandle, Object, int)->long::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setRelease(ArrayHandle, Object, int, long)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getOpaque(ArrayHandle, Object, int)->long::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setOpaque(ArrayHandle, Object, int, long)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndSet(ArrayHandle, Object, int, long, long)->boolean::: array handle compare and set
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, long, long)->long::: array handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, long, long)->long::: array handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, long, long)->long::: array handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, long, long)->boolean::: array handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, long, long)->boolean::: array handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, long, long)->boolean::: array handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, long, long)->boolean::: array handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSet(ArrayHandle, Object, int, long)->long::: array handle get and set
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, long)->long::: array handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, long)->long::: array handle get and set release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAdd(ArrayHandle, Object, int, long)->long::: array handle get and add
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, long)->long::: array handle get and add acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, long)->long::: array handle get and add release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, long)->long::: array handle get and add conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, long)->long::: array handle get and bitwise or
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, long)->long::: array handle get and bitwise or release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, long)->long::: array handle get and bitwise or acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, long)->long::: array handle get and bitwise or conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, long)->long::: array handle get and bitwise and
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, long)->long::: array handle get and bitwise and release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, long)->long::: array handle get and bitwise and acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, long)->long::: array handle get and bitwise and conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, long)->long::: array handle get and bitwise xor
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, long)->long::: array handle get and bitwise xor release
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, long)->long::: array handle get and bitwise xor acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, long)->long::: array handle get and bitwise xor conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#get(ByteBufferHandle, Object, int)->long::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#set(ByteBufferHandle, Object, int, long)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->long::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, long)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->long::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, long)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->long::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, long)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, long, long)->boolean::: byte buffer handle compare and set
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, long, long)->long::: byte buffer handle compare and exchange
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, long, long)->long::: byte buffer handle compare and exchange acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, long, long)->long::: byte buffer handle compare and exchange release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, long, long)->boolean::: byte buffer handle weak compare and set plain
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, long, long)->boolean::: byte buffer handle weak compare and set
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, long, long)->boolean::: byte buffer handle weak compare and set acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, long, long)->boolean::: byte buffer handle weak compare and set release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and set
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and set acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and set release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and add
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and add acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and add release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, long)->long::: byte buffer handle get and add conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise or
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise or release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise or acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, long)->long::: byte buffer handle get and bitwise or conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise and
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise and release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise and acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, long)->long::: byte buffer handle get and bitwise and conv endian with s
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise xor
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise xor release
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, long)->long::: byte buffer handle get and bitwise xor acquire
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, long)->long::: byte buffer handle get and bitwise xor conv endian with s
java.lang.invoke.VarHandleByteArrayAsShorts#convEndian(boolean, short)->short::: var handle byte array as shorts conv endian
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType::: array handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#index(byte[], int)->int::: array handle index
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#address(byte[], int)->long::: array handle address
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#get(ArrayHandle, Object, int)->short::: array handle get
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#set(ArrayHandle, Object, int, short)->void::: array handle set
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getVolatile(ArrayHandle, Object, int)->short::: array handle get volatile
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setVolatile(ArrayHandle, Object, int, short)->void::: array handle set volatile
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getAcquire(ArrayHandle, Object, int)->short::: array handle get acquire
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setRelease(ArrayHandle, Object, int, short)->void::: array handle set release
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getOpaque(ArrayHandle, Object, int)->short::: array handle get opaque
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setOpaque(ArrayHandle, Object, int, short)->void::: array handle set opaque
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType::: byte buffer handle access mode type uncached
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#index(ByteBuffer, int)->int::: byte buffer handle index
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#indexRO(ByteBuffer, int)->int::: byte buffer handle index o
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#address(ByteBuffer, int)->long::: byte buffer handle address
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#get(ByteBufferHandle, Object, int)->short::: byte buffer handle get
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#set(ByteBufferHandle, Object, int, short)->void::: byte buffer handle set
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->short::: byte buffer handle get volatile
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, short)->void::: byte buffer handle set volatile
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->short::: byte buffer handle get acquire
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, short)->void::: byte buffer handle set release
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->short::: byte buffer handle get opaque
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, short)->void::: byte buffer handle set opaque
java.lang.invoke.VarHandleByteArrayBase#newIllegalStateExceptionForMisalignedAccess(int)->IllegalStateException::: var handle byte array base new illegal state exception for misaligned access
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->byte::: field instance read only get
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->byte::: field instance read only get volatile
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->byte::: field instance read only get opaque
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->byte::: field instance read only get acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, byte)->void::: field instance read write set
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, byte)->void::: field instance read write set volatile
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, byte)->void::: field instance read write set opaque
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, byte)->void::: field instance read write set release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, byte, byte)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, byte, byte)->byte::: field instance read write compare and exchange
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, byte, byte)->byte::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, byte, byte)->byte::: field instance read write compare and exchange release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, byte, byte)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, byte, byte)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, byte, byte)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, byte, byte)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and set
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and set acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and set release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and add
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and add acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and add release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise or
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise and
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, byte)->byte::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#get(FieldStaticReadOnly)->byte::: field static read only get
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->byte::: field static read only get volatile
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->byte::: field static read only get opaque
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->byte::: field static read only get acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#set(FieldStaticReadWrite, byte)->void::: field static read write set
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, byte)->void::: field static read write set volatile
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, byte)->void::: field static read write set opaque
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, byte)->void::: field static read write set release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, byte, byte)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, byte, byte)->byte::: field static read write compare and exchange
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, byte, byte)->byte::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, byte, byte)->byte::: field static read write compare and exchange release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, byte, byte)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, byte, byte)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, byte, byte)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, byte, byte)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, byte)->byte::: field static read write get and set
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, byte)->byte::: field static read write get and set acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, byte)->byte::: field static read write get and set release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, byte)->byte::: field static read write get and add
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, byte)->byte::: field static read write get and add acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, byte)->byte::: field static read write get and add release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise or
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise or release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise and
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise and release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise xor
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, byte)->byte::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleBytes.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleBytes.Array#get(Array, Object, int)->byte::: array get
java.lang.invoke.VarHandleBytes.Array#set(Array, Object, int, byte)->void::: array set
java.lang.invoke.VarHandleBytes.Array#getVolatile(Array, Object, int)->byte::: array get volatile
java.lang.invoke.VarHandleBytes.Array#setVolatile(Array, Object, int, byte)->void::: array set volatile
java.lang.invoke.VarHandleBytes.Array#getOpaque(Array, Object, int)->byte::: array get opaque
java.lang.invoke.VarHandleBytes.Array#setOpaque(Array, Object, int, byte)->void::: array set opaque
java.lang.invoke.VarHandleBytes.Array#getAcquire(Array, Object, int)->byte::: array get acquire
java.lang.invoke.VarHandleBytes.Array#setRelease(Array, Object, int, byte)->void::: array set release
java.lang.invoke.VarHandleBytes.Array#compareAndSet(Array, Object, int, byte, byte)->boolean::: array compare and set
java.lang.invoke.VarHandleBytes.Array#compareAndExchange(Array, Object, int, byte, byte)->byte::: array compare and exchange
java.lang.invoke.VarHandleBytes.Array#compareAndExchangeAcquire(Array, Object, int, byte, byte)->byte::: array compare and exchange acquire
java.lang.invoke.VarHandleBytes.Array#compareAndExchangeRelease(Array, Object, int, byte, byte)->byte::: array compare and exchange release
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetPlain(Array, Object, int, byte, byte)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSet(Array, Object, int, byte, byte)->boolean::: array weak compare and set
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetAcquire(Array, Object, int, byte, byte)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetRelease(Array, Object, int, byte, byte)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleBytes.Array#getAndSet(Array, Object, int, byte)->byte::: array get and set
java.lang.invoke.VarHandleBytes.Array#getAndSetAcquire(Array, Object, int, byte)->byte::: array get and set acquire
java.lang.invoke.VarHandleBytes.Array#getAndSetRelease(Array, Object, int, byte)->byte::: array get and set release
java.lang.invoke.VarHandleBytes.Array#getAndAdd(Array, Object, int, byte)->byte::: array get and add
java.lang.invoke.VarHandleBytes.Array#getAndAddAcquire(Array, Object, int, byte)->byte::: array get and add acquire
java.lang.invoke.VarHandleBytes.Array#getAndAddRelease(Array, Object, int, byte)->byte::: array get and add release
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOr(Array, Object, int, byte)->byte::: array get and bitwise or
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOrRelease(Array, Object, int, byte)->byte::: array get and bitwise or release
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOrAcquire(Array, Object, int, byte)->byte::: array get and bitwise or acquire
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAnd(Array, Object, int, byte)->byte::: array get and bitwise and
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAndRelease(Array, Object, int, byte)->byte::: array get and bitwise and release
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAndAcquire(Array, Object, int, byte)->byte::: array get and bitwise and acquire
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXor(Array, Object, int, byte)->byte::: array get and bitwise xor
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXorRelease(Array, Object, int, byte)->byte::: array get and bitwise xor release
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXorAcquire(Array, Object, int, byte)->byte::: array get and bitwise xor acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->char::: field instance read only get
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->char::: field instance read only get volatile
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->char::: field instance read only get opaque
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->char::: field instance read only get acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, char)->void::: field instance read write set
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, char)->void::: field instance read write set volatile
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, char)->void::: field instance read write set opaque
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, char)->void::: field instance read write set release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, char, char)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, char, char)->char::: field instance read write compare and exchange
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, char, char)->char::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, char, char)->char::: field instance read write compare and exchange release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, char, char)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, char, char)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, char, char)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, char, char)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and set
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and set acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and set release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and add
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and add acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and add release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise or
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise and
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, char)->char::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#get(FieldStaticReadOnly)->char::: field static read only get
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->char::: field static read only get volatile
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->char::: field static read only get opaque
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->char::: field static read only get acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#set(FieldStaticReadWrite, char)->void::: field static read write set
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, char)->void::: field static read write set volatile
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, char)->void::: field static read write set opaque
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, char)->void::: field static read write set release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, char, char)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, char, char)->char::: field static read write compare and exchange
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, char, char)->char::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, char, char)->char::: field static read write compare and exchange release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, char, char)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, char, char)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, char, char)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, char, char)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, char)->char::: field static read write get and set
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, char)->char::: field static read write get and set acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, char)->char::: field static read write get and set release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, char)->char::: field static read write get and add
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, char)->char::: field static read write get and add acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, char)->char::: field static read write get and add release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, char)->char::: field static read write get and bitwise or
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, char)->char::: field static read write get and bitwise or release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, char)->char::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, char)->char::: field static read write get and bitwise and
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, char)->char::: field static read write get and bitwise and release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, char)->char::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, char)->char::: field static read write get and bitwise xor
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, char)->char::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, char)->char::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleChars.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleChars.Array#get(Array, Object, int)->char::: array get
java.lang.invoke.VarHandleChars.Array#set(Array, Object, int, char)->void::: array set
java.lang.invoke.VarHandleChars.Array#getVolatile(Array, Object, int)->char::: array get volatile
java.lang.invoke.VarHandleChars.Array#setVolatile(Array, Object, int, char)->void::: array set volatile
java.lang.invoke.VarHandleChars.Array#getOpaque(Array, Object, int)->char::: array get opaque
java.lang.invoke.VarHandleChars.Array#setOpaque(Array, Object, int, char)->void::: array set opaque
java.lang.invoke.VarHandleChars.Array#getAcquire(Array, Object, int)->char::: array get acquire
java.lang.invoke.VarHandleChars.Array#setRelease(Array, Object, int, char)->void::: array set release
java.lang.invoke.VarHandleChars.Array#compareAndSet(Array, Object, int, char, char)->boolean::: array compare and set
java.lang.invoke.VarHandleChars.Array#compareAndExchange(Array, Object, int, char, char)->char::: array compare and exchange
java.lang.invoke.VarHandleChars.Array#compareAndExchangeAcquire(Array, Object, int, char, char)->char::: array compare and exchange acquire
java.lang.invoke.VarHandleChars.Array#compareAndExchangeRelease(Array, Object, int, char, char)->char::: array compare and exchange release
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetPlain(Array, Object, int, char, char)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleChars.Array#weakCompareAndSet(Array, Object, int, char, char)->boolean::: array weak compare and set
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetAcquire(Array, Object, int, char, char)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetRelease(Array, Object, int, char, char)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleChars.Array#getAndSet(Array, Object, int, char)->char::: array get and set
java.lang.invoke.VarHandleChars.Array#getAndSetAcquire(Array, Object, int, char)->char::: array get and set acquire
java.lang.invoke.VarHandleChars.Array#getAndSetRelease(Array, Object, int, char)->char::: array get and set release
java.lang.invoke.VarHandleChars.Array#getAndAdd(Array, Object, int, char)->char::: array get and add
java.lang.invoke.VarHandleChars.Array#getAndAddAcquire(Array, Object, int, char)->char::: array get and add acquire
java.lang.invoke.VarHandleChars.Array#getAndAddRelease(Array, Object, int, char)->char::: array get and add release
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOr(Array, Object, int, char)->char::: array get and bitwise or
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOrRelease(Array, Object, int, char)->char::: array get and bitwise or release
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOrAcquire(Array, Object, int, char)->char::: array get and bitwise or acquire
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAnd(Array, Object, int, char)->char::: array get and bitwise and
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAndRelease(Array, Object, int, char)->char::: array get and bitwise and release
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAndAcquire(Array, Object, int, char)->char::: array get and bitwise and acquire
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXor(Array, Object, int, char)->char::: array get and bitwise xor
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXorRelease(Array, Object, int, char)->char::: array get and bitwise xor release
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXorAcquire(Array, Object, int, char)->char::: array get and bitwise xor acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->double::: field instance read only get
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->double::: field instance read only get volatile
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->double::: field instance read only get opaque
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->double::: field instance read only get acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, double)->void::: field instance read write set
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, double)->void::: field instance read write set volatile
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, double)->void::: field instance read write set opaque
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, double)->void::: field instance read write set release
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, double, double)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, double, double)->double::: field instance read write compare and exchange
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, double, double)->double::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, double, double)->double::: field instance read write compare and exchange release
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, double, double)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, double, double)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, double, double)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, double, double)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and set
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and set acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and set release
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and add
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and add acquire
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, double)->double::: field instance read write get and add release
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#get(FieldStaticReadOnly)->double::: field static read only get
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->double::: field static read only get volatile
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->double::: field static read only get opaque
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->double::: field static read only get acquire
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#set(FieldStaticReadWrite, double)->void::: field static read write set
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, double)->void::: field static read write set volatile
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, double)->void::: field static read write set opaque
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, double)->void::: field static read write set release
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, double, double)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, double, double)->double::: field static read write compare and exchange
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, double, double)->double::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, double, double)->double::: field static read write compare and exchange release
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, double, double)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, double, double)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, double, double)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, double, double)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, double)->double::: field static read write get and set
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, double)->double::: field static read write get and set acquire
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, double)->double::: field static read write get and set release
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, double)->double::: field static read write get and add
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, double)->double::: field static read write get and add acquire
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, double)->double::: field static read write get and add release
java.lang.invoke.VarHandleDoubles.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleDoubles.Array#get(Array, Object, int)->double::: array get
java.lang.invoke.VarHandleDoubles.Array#set(Array, Object, int, double)->void::: array set
java.lang.invoke.VarHandleDoubles.Array#getVolatile(Array, Object, int)->double::: array get volatile
java.lang.invoke.VarHandleDoubles.Array#setVolatile(Array, Object, int, double)->void::: array set volatile
java.lang.invoke.VarHandleDoubles.Array#getOpaque(Array, Object, int)->double::: array get opaque
java.lang.invoke.VarHandleDoubles.Array#setOpaque(Array, Object, int, double)->void::: array set opaque
java.lang.invoke.VarHandleDoubles.Array#getAcquire(Array, Object, int)->double::: array get acquire
java.lang.invoke.VarHandleDoubles.Array#setRelease(Array, Object, int, double)->void::: array set release
java.lang.invoke.VarHandleDoubles.Array#compareAndSet(Array, Object, int, double, double)->boolean::: array compare and set
java.lang.invoke.VarHandleDoubles.Array#compareAndExchange(Array, Object, int, double, double)->double::: array compare and exchange
java.lang.invoke.VarHandleDoubles.Array#compareAndExchangeAcquire(Array, Object, int, double, double)->double::: array compare and exchange acquire
java.lang.invoke.VarHandleDoubles.Array#compareAndExchangeRelease(Array, Object, int, double, double)->double::: array compare and exchange release
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetPlain(Array, Object, int, double, double)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSet(Array, Object, int, double, double)->boolean::: array weak compare and set
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetAcquire(Array, Object, int, double, double)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetRelease(Array, Object, int, double, double)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleDoubles.Array#getAndSet(Array, Object, int, double)->double::: array get and set
java.lang.invoke.VarHandleDoubles.Array#getAndSetAcquire(Array, Object, int, double)->double::: array get and set acquire
java.lang.invoke.VarHandleDoubles.Array#getAndSetRelease(Array, Object, int, double)->double::: array get and set release
java.lang.invoke.VarHandleDoubles.Array#getAndAdd(Array, Object, int, double)->double::: array get and add
java.lang.invoke.VarHandleDoubles.Array#getAndAddAcquire(Array, Object, int, double)->double::: array get and add acquire
java.lang.invoke.VarHandleDoubles.Array#getAndAddRelease(Array, Object, int, double)->double::: array get and add release
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->float::: field instance read only get
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->float::: field instance read only get volatile
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->float::: field instance read only get opaque
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->float::: field instance read only get acquire
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, float)->void::: field instance read write set
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, float)->void::: field instance read write set volatile
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, float)->void::: field instance read write set opaque
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, float)->void::: field instance read write set release
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, float, float)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, float, float)->float::: field instance read write compare and exchange
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, float, float)->float::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, float, float)->float::: field instance read write compare and exchange release
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, float, float)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, float, float)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, float, float)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, float, float)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and set
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and set acquire
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and set release
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and add
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and add acquire
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, float)->float::: field instance read write get and add release
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#get(FieldStaticReadOnly)->float::: field static read only get
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->float::: field static read only get volatile
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->float::: field static read only get opaque
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->float::: field static read only get acquire
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#set(FieldStaticReadWrite, float)->void::: field static read write set
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, float)->void::: field static read write set volatile
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, float)->void::: field static read write set opaque
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, float)->void::: field static read write set release
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, float, float)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, float, float)->float::: field static read write compare and exchange
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, float, float)->float::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, float, float)->float::: field static read write compare and exchange release
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, float, float)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, float, float)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, float, float)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, float, float)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, float)->float::: field static read write get and set
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, float)->float::: field static read write get and set acquire
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, float)->float::: field static read write get and set release
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, float)->float::: field static read write get and add
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, float)->float::: field static read write get and add acquire
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, float)->float::: field static read write get and add release
java.lang.invoke.VarHandleFloats.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleFloats.Array#get(Array, Object, int)->float::: array get
java.lang.invoke.VarHandleFloats.Array#set(Array, Object, int, float)->void::: array set
java.lang.invoke.VarHandleFloats.Array#getVolatile(Array, Object, int)->float::: array get volatile
java.lang.invoke.VarHandleFloats.Array#setVolatile(Array, Object, int, float)->void::: array set volatile
java.lang.invoke.VarHandleFloats.Array#getOpaque(Array, Object, int)->float::: array get opaque
java.lang.invoke.VarHandleFloats.Array#setOpaque(Array, Object, int, float)->void::: array set opaque
java.lang.invoke.VarHandleFloats.Array#getAcquire(Array, Object, int)->float::: array get acquire
java.lang.invoke.VarHandleFloats.Array#setRelease(Array, Object, int, float)->void::: array set release
java.lang.invoke.VarHandleFloats.Array#compareAndSet(Array, Object, int, float, float)->boolean::: array compare and set
java.lang.invoke.VarHandleFloats.Array#compareAndExchange(Array, Object, int, float, float)->float::: array compare and exchange
java.lang.invoke.VarHandleFloats.Array#compareAndExchangeAcquire(Array, Object, int, float, float)->float::: array compare and exchange acquire
java.lang.invoke.VarHandleFloats.Array#compareAndExchangeRelease(Array, Object, int, float, float)->float::: array compare and exchange release
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetPlain(Array, Object, int, float, float)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSet(Array, Object, int, float, float)->boolean::: array weak compare and set
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetAcquire(Array, Object, int, float, float)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetRelease(Array, Object, int, float, float)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleFloats.Array#getAndSet(Array, Object, int, float)->float::: array get and set
java.lang.invoke.VarHandleFloats.Array#getAndSetAcquire(Array, Object, int, float)->float::: array get and set acquire
java.lang.invoke.VarHandleFloats.Array#getAndSetRelease(Array, Object, int, float)->float::: array get and set release
java.lang.invoke.VarHandleFloats.Array#getAndAdd(Array, Object, int, float)->float::: array get and add
java.lang.invoke.VarHandleFloats.Array#getAndAddAcquire(Array, Object, int, float)->float::: array get and add acquire
java.lang.invoke.VarHandleFloats.Array#getAndAddRelease(Array, Object, int, float)->float::: array get and add release
java.lang.invoke.VarHandleGuards#guard_L_L(VarHandle, Object, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ l_ l
java.lang.invoke.VarHandleGuards#guard_LL_V(VarHandle, Object, Object, VarHandle.AccessDescriptor)->void::: var handle guards guard_ l_ v
java.lang.invoke.VarHandleGuards#guard_LL_L(VarHandle, Object, Object, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ l_ l
java.lang.invoke.VarHandleGuards#guard_LLL_Z(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ l_ z
java.lang.invoke.VarHandleGuards#guard_LLL_L(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ l_ l
java.lang.invoke.VarHandleGuards#guard_L_I(VarHandle, Object, VarHandle.AccessDescriptor)->int::: var handle guards guard_ l_ i
java.lang.invoke.VarHandleGuards#guard_LI_V(VarHandle, Object, int, VarHandle.AccessDescriptor)->void::: var handle guards guard_ i_ v
java.lang.invoke.VarHandleGuards#guard_LI_I(VarHandle, Object, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_LII_Z(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ i_ z
java.lang.invoke.VarHandleGuards#guard_LII_I(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_L_J(VarHandle, Object, VarHandle.AccessDescriptor)->long::: var handle guards guard_ l_ j
java.lang.invoke.VarHandleGuards#guard_LJ_V(VarHandle, Object, long, VarHandle.AccessDescriptor)->void::: var handle guards guard_ j_ v
java.lang.invoke.VarHandleGuards#guard_LJ_J(VarHandle, Object, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard_LJJ_Z(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ j_ z
java.lang.invoke.VarHandleGuards#guard_LJJ_J(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard_L_F(VarHandle, Object, VarHandle.AccessDescriptor)->float::: var handle guards guard_ l_ f
java.lang.invoke.VarHandleGuards#guard_LF_V(VarHandle, Object, float, VarHandle.AccessDescriptor)->void::: var handle guards guard_ f_ v
java.lang.invoke.VarHandleGuards#guard_LF_F(VarHandle, Object, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard_LFF_Z(VarHandle, Object, float, float, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ f_ z
java.lang.invoke.VarHandleGuards#guard_LFF_F(VarHandle, Object, float, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard_L_D(VarHandle, Object, VarHandle.AccessDescriptor)->double::: var handle guards guard_ l_ d
java.lang.invoke.VarHandleGuards#guard_LD_V(VarHandle, Object, double, VarHandle.AccessDescriptor)->void::: var handle guards guard_ d_ v
java.lang.invoke.VarHandleGuards#guard_LD_D(VarHandle, Object, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard_LDD_Z(VarHandle, Object, double, double, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ d_ z
java.lang.invoke.VarHandleGuards#guard_LDD_D(VarHandle, Object, double, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard__L(VarHandle, VarHandle.AccessDescriptor)->Object::: var handle guards guard__ l
java.lang.invoke.VarHandleGuards#guard_L_V(VarHandle, Object, VarHandle.AccessDescriptor)->void::: var handle guards guard_ l_ v
java.lang.invoke.VarHandleGuards#guard_LL_Z(VarHandle, Object, Object, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ l_ z
java.lang.invoke.VarHandleGuards#guard__I(VarHandle, VarHandle.AccessDescriptor)->int::: var handle guards guard__ i
java.lang.invoke.VarHandleGuards#guard_I_V(VarHandle, int, VarHandle.AccessDescriptor)->void::: var handle guards guard_ i_ v
java.lang.invoke.VarHandleGuards#guard_I_I(VarHandle, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_II_Z(VarHandle, int, int, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ i_ z
java.lang.invoke.VarHandleGuards#guard_II_I(VarHandle, int, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard__J(VarHandle, VarHandle.AccessDescriptor)->long::: var handle guards guard__ j
java.lang.invoke.VarHandleGuards#guard_J_V(VarHandle, long, VarHandle.AccessDescriptor)->void::: var handle guards guard_ j_ v
java.lang.invoke.VarHandleGuards#guard_J_J(VarHandle, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard_JJ_Z(VarHandle, long, long, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ j_ z
java.lang.invoke.VarHandleGuards#guard_JJ_J(VarHandle, long, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard__F(VarHandle, VarHandle.AccessDescriptor)->float::: var handle guards guard__ f
java.lang.invoke.VarHandleGuards#guard_F_V(VarHandle, float, VarHandle.AccessDescriptor)->void::: var handle guards guard_ f_ v
java.lang.invoke.VarHandleGuards#guard_F_F(VarHandle, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard_FF_Z(VarHandle, float, float, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ f_ z
java.lang.invoke.VarHandleGuards#guard_FF_F(VarHandle, float, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard__D(VarHandle, VarHandle.AccessDescriptor)->double::: var handle guards guard__ d
java.lang.invoke.VarHandleGuards#guard_D_V(VarHandle, double, VarHandle.AccessDescriptor)->void::: var handle guards guard_ d_ v
java.lang.invoke.VarHandleGuards#guard_D_D(VarHandle, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard_DD_Z(VarHandle, double, double, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ d_ z
java.lang.invoke.VarHandleGuards#guard_DD_D(VarHandle, double, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard_LI_L(VarHandle, Object, int, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ i_ l
java.lang.invoke.VarHandleGuards#guard_LIL_V(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)->void::: var handle guards guard_ l_ v
java.lang.invoke.VarHandleGuards#guard_LIL_L(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ l_ l
java.lang.invoke.VarHandleGuards#guard_LILL_Z(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ l_ z
java.lang.invoke.VarHandleGuards#guard_LILL_L(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)->Object::: var handle guards guard_ l_ l
java.lang.invoke.VarHandleGuards#guard_LII_V(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->void::: var handle guards guard_ i_ v
java.lang.invoke.VarHandleGuards#guard_LIII_Z(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ i_ z
java.lang.invoke.VarHandleGuards#guard_LIII_I(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_LI_J(VarHandle, Object, int, VarHandle.AccessDescriptor)->long::: var handle guards guard_ i_ j
java.lang.invoke.VarHandleGuards#guard_LIJ_V(VarHandle, Object, int, long, VarHandle.AccessDescriptor)->void::: var handle guards guard_ j_ v
java.lang.invoke.VarHandleGuards#guard_LIJ_J(VarHandle, Object, int, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard_LIJJ_Z(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ j_ z
java.lang.invoke.VarHandleGuards#guard_LIJJ_J(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleGuards#guard_LI_F(VarHandle, Object, int, VarHandle.AccessDescriptor)->float::: var handle guards guard_ i_ f
java.lang.invoke.VarHandleGuards#guard_LIF_V(VarHandle, Object, int, float, VarHandle.AccessDescriptor)->void::: var handle guards guard_ f_ v
java.lang.invoke.VarHandleGuards#guard_LIF_F(VarHandle, Object, int, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard_LIFF_Z(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ f_ z
java.lang.invoke.VarHandleGuards#guard_LIFF_F(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)->float::: var handle guards guard_ f_ f
java.lang.invoke.VarHandleGuards#guard_LI_D(VarHandle, Object, int, VarHandle.AccessDescriptor)->double::: var handle guards guard_ i_ d
java.lang.invoke.VarHandleGuards#guard_LID_V(VarHandle, Object, int, double, VarHandle.AccessDescriptor)->void::: var handle guards guard_ d_ v
java.lang.invoke.VarHandleGuards#guard_LID_D(VarHandle, Object, int, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard_LIDD_Z(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ d_ z
java.lang.invoke.VarHandleGuards#guard_LIDD_D(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)->double::: var handle guards guard_ d_ d
java.lang.invoke.VarHandleGuards#guard_LJ_I(VarHandle, Object, long, VarHandle.AccessDescriptor)->int::: var handle guards guard_ j_ i
java.lang.invoke.VarHandleGuards#guard_LJI_V(VarHandle, Object, long, int, VarHandle.AccessDescriptor)->void::: var handle guards guard_ i_ v
java.lang.invoke.VarHandleGuards#guard_LJI_I(VarHandle, Object, long, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_LJII_Z(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ i_ z
java.lang.invoke.VarHandleGuards#guard_LJII_I(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)->int::: var handle guards guard_ i_ i
java.lang.invoke.VarHandleGuards#guard_LJJ_V(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->void::: var handle guards guard_ j_ v
java.lang.invoke.VarHandleGuards#guard_LJJJ_Z(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)->boolean::: var handle guards guard_ j_ z
java.lang.invoke.VarHandleGuards#guard_LJJJ_J(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)->long::: var handle guards guard_ j_ j
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->int::: field instance read only get
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->int::: field instance read only get volatile
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->int::: field instance read only get opaque
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->int::: field instance read only get acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, int)->void::: field instance read write set
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, int)->void::: field instance read write set volatile
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, int)->void::: field instance read write set opaque
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, int)->void::: field instance read write set release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, int, int)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, int, int)->int::: field instance read write compare and exchange
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, int, int)->int::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, int, int)->int::: field instance read write compare and exchange release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, int, int)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, int, int)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, int, int)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, int, int)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and set
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and set acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and set release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and add
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and add acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and add release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise or
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise and
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, int)->int::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#get(FieldStaticReadOnly)->int::: field static read only get
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->int::: field static read only get volatile
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->int::: field static read only get opaque
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->int::: field static read only get acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#set(FieldStaticReadWrite, int)->void::: field static read write set
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, int)->void::: field static read write set volatile
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, int)->void::: field static read write set opaque
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, int)->void::: field static read write set release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, int, int)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, int, int)->int::: field static read write compare and exchange
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, int, int)->int::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, int, int)->int::: field static read write compare and exchange release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, int, int)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, int, int)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, int, int)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, int, int)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, int)->int::: field static read write get and set
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, int)->int::: field static read write get and set acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, int)->int::: field static read write get and set release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, int)->int::: field static read write get and add
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, int)->int::: field static read write get and add acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, int)->int::: field static read write get and add release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, int)->int::: field static read write get and bitwise or
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, int)->int::: field static read write get and bitwise or release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, int)->int::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, int)->int::: field static read write get and bitwise and
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, int)->int::: field static read write get and bitwise and release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, int)->int::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, int)->int::: field static read write get and bitwise xor
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, int)->int::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, int)->int::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleInts.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleInts.Array#get(Array, Object, int)->int::: array get
java.lang.invoke.VarHandleInts.Array#set(Array, Object, int, int)->void::: array set
java.lang.invoke.VarHandleInts.Array#getVolatile(Array, Object, int)->int::: array get volatile
java.lang.invoke.VarHandleInts.Array#setVolatile(Array, Object, int, int)->void::: array set volatile
java.lang.invoke.VarHandleInts.Array#getOpaque(Array, Object, int)->int::: array get opaque
java.lang.invoke.VarHandleInts.Array#setOpaque(Array, Object, int, int)->void::: array set opaque
java.lang.invoke.VarHandleInts.Array#getAcquire(Array, Object, int)->int::: array get acquire
java.lang.invoke.VarHandleInts.Array#setRelease(Array, Object, int, int)->void::: array set release
java.lang.invoke.VarHandleInts.Array#compareAndSet(Array, Object, int, int, int)->boolean::: array compare and set
java.lang.invoke.VarHandleInts.Array#compareAndExchange(Array, Object, int, int, int)->int::: array compare and exchange
java.lang.invoke.VarHandleInts.Array#compareAndExchangeAcquire(Array, Object, int, int, int)->int::: array compare and exchange acquire
java.lang.invoke.VarHandleInts.Array#compareAndExchangeRelease(Array, Object, int, int, int)->int::: array compare and exchange release
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetPlain(Array, Object, int, int, int)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleInts.Array#weakCompareAndSet(Array, Object, int, int, int)->boolean::: array weak compare and set
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetAcquire(Array, Object, int, int, int)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetRelease(Array, Object, int, int, int)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleInts.Array#getAndSet(Array, Object, int, int)->int::: array get and set
java.lang.invoke.VarHandleInts.Array#getAndSetAcquire(Array, Object, int, int)->int::: array get and set acquire
java.lang.invoke.VarHandleInts.Array#getAndSetRelease(Array, Object, int, int)->int::: array get and set release
java.lang.invoke.VarHandleInts.Array#getAndAdd(Array, Object, int, int)->int::: array get and add
java.lang.invoke.VarHandleInts.Array#getAndAddAcquire(Array, Object, int, int)->int::: array get and add acquire
java.lang.invoke.VarHandleInts.Array#getAndAddRelease(Array, Object, int, int)->int::: array get and add release
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOr(Array, Object, int, int)->int::: array get and bitwise or
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOrRelease(Array, Object, int, int)->int::: array get and bitwise or release
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOrAcquire(Array, Object, int, int)->int::: array get and bitwise or acquire
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAnd(Array, Object, int, int)->int::: array get and bitwise and
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAndRelease(Array, Object, int, int)->int::: array get and bitwise and release
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAndAcquire(Array, Object, int, int)->int::: array get and bitwise and acquire
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXor(Array, Object, int, int)->int::: array get and bitwise xor
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXorRelease(Array, Object, int, int)->int::: array get and bitwise xor release
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXorAcquire(Array, Object, int, int)->int::: array get and bitwise xor acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->long::: field instance read only get
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->long::: field instance read only get volatile
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->long::: field instance read only get opaque
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->long::: field instance read only get acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, long)->void::: field instance read write set
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, long)->void::: field instance read write set volatile
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, long)->void::: field instance read write set opaque
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, long)->void::: field instance read write set release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, long, long)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, long, long)->long::: field instance read write compare and exchange
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, long, long)->long::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, long, long)->long::: field instance read write compare and exchange release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, long, long)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, long, long)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, long, long)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, long, long)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and set
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and set acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and set release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and add
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and add acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and add release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise or
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise and
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, long)->long::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#get(FieldStaticReadOnly)->long::: field static read only get
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->long::: field static read only get volatile
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->long::: field static read only get opaque
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->long::: field static read only get acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#set(FieldStaticReadWrite, long)->void::: field static read write set
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, long)->void::: field static read write set volatile
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, long)->void::: field static read write set opaque
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, long)->void::: field static read write set release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, long, long)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, long, long)->long::: field static read write compare and exchange
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, long, long)->long::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, long, long)->long::: field static read write compare and exchange release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, long, long)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, long, long)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, long, long)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, long, long)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, long)->long::: field static read write get and set
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, long)->long::: field static read write get and set acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, long)->long::: field static read write get and set release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, long)->long::: field static read write get and add
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, long)->long::: field static read write get and add acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, long)->long::: field static read write get and add release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, long)->long::: field static read write get and bitwise or
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, long)->long::: field static read write get and bitwise or release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, long)->long::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, long)->long::: field static read write get and bitwise and
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, long)->long::: field static read write get and bitwise and release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, long)->long::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, long)->long::: field static read write get and bitwise xor
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, long)->long::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, long)->long::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleLongs.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleLongs.Array#get(Array, Object, int)->long::: array get
java.lang.invoke.VarHandleLongs.Array#set(Array, Object, int, long)->void::: array set
java.lang.invoke.VarHandleLongs.Array#getVolatile(Array, Object, int)->long::: array get volatile
java.lang.invoke.VarHandleLongs.Array#setVolatile(Array, Object, int, long)->void::: array set volatile
java.lang.invoke.VarHandleLongs.Array#getOpaque(Array, Object, int)->long::: array get opaque
java.lang.invoke.VarHandleLongs.Array#setOpaque(Array, Object, int, long)->void::: array set opaque
java.lang.invoke.VarHandleLongs.Array#getAcquire(Array, Object, int)->long::: array get acquire
java.lang.invoke.VarHandleLongs.Array#setRelease(Array, Object, int, long)->void::: array set release
java.lang.invoke.VarHandleLongs.Array#compareAndSet(Array, Object, int, long, long)->boolean::: array compare and set
java.lang.invoke.VarHandleLongs.Array#compareAndExchange(Array, Object, int, long, long)->long::: array compare and exchange
java.lang.invoke.VarHandleLongs.Array#compareAndExchangeAcquire(Array, Object, int, long, long)->long::: array compare and exchange acquire
java.lang.invoke.VarHandleLongs.Array#compareAndExchangeRelease(Array, Object, int, long, long)->long::: array compare and exchange release
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetPlain(Array, Object, int, long, long)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSet(Array, Object, int, long, long)->boolean::: array weak compare and set
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetAcquire(Array, Object, int, long, long)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetRelease(Array, Object, int, long, long)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleLongs.Array#getAndSet(Array, Object, int, long)->long::: array get and set
java.lang.invoke.VarHandleLongs.Array#getAndSetAcquire(Array, Object, int, long)->long::: array get and set acquire
java.lang.invoke.VarHandleLongs.Array#getAndSetRelease(Array, Object, int, long)->long::: array get and set release
java.lang.invoke.VarHandleLongs.Array#getAndAdd(Array, Object, int, long)->long::: array get and add
java.lang.invoke.VarHandleLongs.Array#getAndAddAcquire(Array, Object, int, long)->long::: array get and add acquire
java.lang.invoke.VarHandleLongs.Array#getAndAddRelease(Array, Object, int, long)->long::: array get and add release
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOr(Array, Object, int, long)->long::: array get and bitwise or
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOrRelease(Array, Object, int, long)->long::: array get and bitwise or release
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOrAcquire(Array, Object, int, long)->long::: array get and bitwise or acquire
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAnd(Array, Object, int, long)->long::: array get and bitwise and
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAndRelease(Array, Object, int, long)->long::: array get and bitwise and release
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAndAcquire(Array, Object, int, long)->long::: array get and bitwise and acquire
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXor(Array, Object, int, long)->long::: array get and bitwise xor
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXorRelease(Array, Object, int, long)->long::: array get and bitwise xor release
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXorAcquire(Array, Object, int, long)->long::: array get and bitwise xor acquire
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->Object::: field instance read only get
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->Object::: field instance read only get volatile
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->Object::: field instance read only get opaque
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->Object::: field instance read only get acquire
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, Object)->void::: field instance read write set
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, Object)->void::: field instance read write set volatile
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, Object)->void::: field instance read write set opaque
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, Object)->void::: field instance read write set release
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, Object, Object)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, Object, Object)->Object::: field instance read write compare and exchange
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, Object, Object)->Object::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, Object, Object)->Object::: field instance read write compare and exchange release
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, Object, Object)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, Object, Object)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, Object, Object)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, Object, Object)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, Object)->Object::: field instance read write get and set
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, Object)->Object::: field instance read write get and set acquire
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, Object)->Object::: field instance read write get and set release
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#get(FieldStaticReadOnly)->Object::: field static read only get
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->Object::: field static read only get volatile
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->Object::: field static read only get opaque
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->Object::: field static read only get acquire
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#set(FieldStaticReadWrite, Object)->void::: field static read write set
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, Object)->void::: field static read write set volatile
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, Object)->void::: field static read write set opaque
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, Object)->void::: field static read write set release
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, Object, Object)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, Object, Object)->Object::: field static read write compare and exchange
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, Object, Object)->Object::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, Object, Object)->Object::: field static read write compare and exchange release
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, Object, Object)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, Object, Object)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, Object, Object)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, Object, Object)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, Object)->Object::: field static read write get and set
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, Object)->Object::: field static read write get and set acquire
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, Object)->Object::: field static read write get and set release
java.lang.invoke.VarHandleObjects.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleObjects.Array#runtimeTypeCheck(Array, Object[], Object)->Object::: array runtime type check
java.lang.invoke.VarHandleObjects.Array#reflectiveTypeCheck(Object[], Object)->Object::: array reflective type check
java.lang.invoke.VarHandleObjects.Array#get(Array, Object, int)->Object::: array get
java.lang.invoke.VarHandleObjects.Array#set(Array, Object, int, Object)->void::: array set
java.lang.invoke.VarHandleObjects.Array#getVolatile(Array, Object, int)->Object::: array get volatile
java.lang.invoke.VarHandleObjects.Array#setVolatile(Array, Object, int, Object)->void::: array set volatile
java.lang.invoke.VarHandleObjects.Array#getOpaque(Array, Object, int)->Object::: array get opaque
java.lang.invoke.VarHandleObjects.Array#setOpaque(Array, Object, int, Object)->void::: array set opaque
java.lang.invoke.VarHandleObjects.Array#getAcquire(Array, Object, int)->Object::: array get acquire
java.lang.invoke.VarHandleObjects.Array#setRelease(Array, Object, int, Object)->void::: array set release
java.lang.invoke.VarHandleObjects.Array#compareAndSet(Array, Object, int, Object, Object)->boolean::: array compare and set
java.lang.invoke.VarHandleObjects.Array#compareAndExchange(Array, Object, int, Object, Object)->Object::: array compare and exchange
java.lang.invoke.VarHandleObjects.Array#compareAndExchangeAcquire(Array, Object, int, Object, Object)->Object::: array compare and exchange acquire
java.lang.invoke.VarHandleObjects.Array#compareAndExchangeRelease(Array, Object, int, Object, Object)->Object::: array compare and exchange release
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetPlain(Array, Object, int, Object, Object)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSet(Array, Object, int, Object, Object)->boolean::: array weak compare and set
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetAcquire(Array, Object, int, Object, Object)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetRelease(Array, Object, int, Object, Object)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleObjects.Array#getAndSet(Array, Object, int, Object)->Object::: array get and set
java.lang.invoke.VarHandleObjects.Array#getAndSetAcquire(Array, Object, int, Object)->Object::: array get and set acquire
java.lang.invoke.VarHandleObjects.Array#getAndSetRelease(Array, Object, int, Object)->Object::: array get and set release
java.lang.invoke.VarHandles#makeFieldHandle(MemberName, Class, Class, boolean)->VarHandle::: var handles make field handle
java.lang.invoke.VarHandles#makeArrayElementHandle(Class)->VarHandle::: var handles make array element handle
java.lang.invoke.VarHandles#byteArrayViewHandle(Class, boolean)->VarHandle::: var handles byte array view handle
java.lang.invoke.VarHandles#makeByteBufferViewHandle(Class, boolean)->VarHandle::: var handles make byte buffer view handle
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field instance read only access mode type uncached
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->short::: field instance read only get
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->short::: field instance read only get volatile
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->short::: field instance read only get opaque
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->short::: field instance read only get acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, short)->void::: field instance read write set
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, short)->void::: field instance read write set volatile
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, short)->void::: field instance read write set opaque
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, short)->void::: field instance read write set release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, short, short)->boolean::: field instance read write compare and set
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, short, short)->short::: field instance read write compare and exchange
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, short, short)->short::: field instance read write compare and exchange acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, short, short)->short::: field instance read write compare and exchange release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, short, short)->boolean::: field instance read write weak compare and set plain
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, short, short)->boolean::: field instance read write weak compare and set
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, short, short)->boolean::: field instance read write weak compare and set acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, short, short)->boolean::: field instance read write weak compare and set release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and set
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and set acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and set release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and add
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and add acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and add release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise or
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise or release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise or acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise and
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise and release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise and acquire
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise xor
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise xor release
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, short)->short::: field instance read write get and bitwise xor acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType::: field static read only access mode type uncached
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#get(FieldStaticReadOnly)->short::: field static read only get
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->short::: field static read only get volatile
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->short::: field static read only get opaque
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->short::: field static read only get acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#set(FieldStaticReadWrite, short)->void::: field static read write set
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, short)->void::: field static read write set volatile
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, short)->void::: field static read write set opaque
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, short)->void::: field static read write set release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, short, short)->boolean::: field static read write compare and set
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, short, short)->short::: field static read write compare and exchange
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, short, short)->short::: field static read write compare and exchange acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, short, short)->short::: field static read write compare and exchange release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, short, short)->boolean::: field static read write weak compare and set plain
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, short, short)->boolean::: field static read write weak compare and set
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, short, short)->boolean::: field static read write weak compare and set acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, short, short)->boolean::: field static read write weak compare and set release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, short)->short::: field static read write get and set
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, short)->short::: field static read write get and set acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, short)->short::: field static read write get and set release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, short)->short::: field static read write get and add
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, short)->short::: field static read write get and add acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, short)->short::: field static read write get and add release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, short)->short::: field static read write get and bitwise or
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, short)->short::: field static read write get and bitwise or release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, short)->short::: field static read write get and bitwise or acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, short)->short::: field static read write get and bitwise and
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, short)->short::: field static read write get and bitwise and release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, short)->short::: field static read write get and bitwise and acquire
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, short)->short::: field static read write get and bitwise xor
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, short)->short::: field static read write get and bitwise xor release
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, short)->short::: field static read write get and bitwise xor acquire
java.lang.invoke.VarHandleShorts.Array#accessModeTypeUncached(AccessMode)->MethodType::: array access mode type uncached
java.lang.invoke.VarHandleShorts.Array#get(Array, Object, int)->short::: array get
java.lang.invoke.VarHandleShorts.Array#set(Array, Object, int, short)->void::: array set
java.lang.invoke.VarHandleShorts.Array#getVolatile(Array, Object, int)->short::: array get volatile
java.lang.invoke.VarHandleShorts.Array#setVolatile(Array, Object, int, short)->void::: array set volatile
java.lang.invoke.VarHandleShorts.Array#getOpaque(Array, Object, int)->short::: array get opaque
java.lang.invoke.VarHandleShorts.Array#setOpaque(Array, Object, int, short)->void::: array set opaque
java.lang.invoke.VarHandleShorts.Array#getAcquire(Array, Object, int)->short::: array get acquire
java.lang.invoke.VarHandleShorts.Array#setRelease(Array, Object, int, short)->void::: array set release
java.lang.invoke.VarHandleShorts.Array#compareAndSet(Array, Object, int, short, short)->boolean::: array compare and set
java.lang.invoke.VarHandleShorts.Array#compareAndExchange(Array, Object, int, short, short)->short::: array compare and exchange
java.lang.invoke.VarHandleShorts.Array#compareAndExchangeAcquire(Array, Object, int, short, short)->short::: array compare and exchange acquire
java.lang.invoke.VarHandleShorts.Array#compareAndExchangeRelease(Array, Object, int, short, short)->short::: array compare and exchange release
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetPlain(Array, Object, int, short, short)->boolean::: array weak compare and set plain
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSet(Array, Object, int, short, short)->boolean::: array weak compare and set
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetAcquire(Array, Object, int, short, short)->boolean::: array weak compare and set acquire
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetRelease(Array, Object, int, short, short)->boolean::: array weak compare and set release
java.lang.invoke.VarHandleShorts.Array#getAndSet(Array, Object, int, short)->short::: array get and set
java.lang.invoke.VarHandleShorts.Array#getAndSetAcquire(Array, Object, int, short)->short::: array get and set acquire
java.lang.invoke.VarHandleShorts.Array#getAndSetRelease(Array, Object, int, short)->short::: array get and set release
java.lang.invoke.VarHandleShorts.Array#getAndAdd(Array, Object, int, short)->short::: array get and add
java.lang.invoke.VarHandleShorts.Array#getAndAddAcquire(Array, Object, int, short)->short::: array get and add acquire
java.lang.invoke.VarHandleShorts.Array#getAndAddRelease(Array, Object, int, short)->short::: array get and add release
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOr(Array, Object, int, short)->short::: array get and bitwise or
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOrRelease(Array, Object, int, short)->short::: array get and bitwise or release
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOrAcquire(Array, Object, int, short)->short::: array get and bitwise or acquire
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAnd(Array, Object, int, short)->short::: array get and bitwise and
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAndRelease(Array, Object, int, short)->short::: array get and bitwise and release
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAndAcquire(Array, Object, int, short)->short::: array get and bitwise and acquire
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXor(Array, Object, int, short)->short::: array get and bitwise xor
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXorRelease(Array, Object, int, short)->short::: array get and bitwise xor release
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXorAcquire(Array, Object, int, short)->short::: array get and bitwise xor acquire
java.lang.invoke.VolatileCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves like a volatile field of the VolatileCallSite
java.lang.invoke.VolatileCallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, as a volatile variable
java.lang.invoke.VolatileCallSite#dynamicInvoker()->MethodHandle::: volatile call site dynamic invoker
