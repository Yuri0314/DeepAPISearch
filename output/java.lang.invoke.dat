java.lang.invoke.AbstractConstantGroup#size()->int:::
java.lang.invoke.AbstractConstantGroup#get(int)->Object:::
java.lang.invoke.AbstractConstantGroup#get(int, Object)->Object:::
java.lang.invoke.AbstractConstantGroup#isPresent(int)->boolean:::
java.lang.invoke.AbstractConstantGroup#toString()->String:::Produce a string using the non-resolving list view,  where unresolved elements are presented as asterisks.
java.lang.invoke.AbstractConstantGroup.AsIterator#hasNext()->boolean:::
java.lang.invoke.AbstractConstantGroup.AsIterator#next()->Object:::
java.lang.invoke.AbstractConstantGroup.SubGroup#get(int)->Object:::
java.lang.invoke.AbstractConstantGroup.SubGroup#get(int, Object)->Object:::
java.lang.invoke.AbstractConstantGroup.SubGroup#isPresent(int)->boolean:::
java.lang.invoke.AbstractConstantGroup.SubGroup#subGroup(int, int)->ConstantGroup:::
java.lang.invoke.AbstractConstantGroup.SubGroup#asList()->List<Object>:::
java.lang.invoke.AbstractConstantGroup.SubGroup#asList(Object)->List<Object>:::
java.lang.invoke.AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int)->int:::
java.lang.invoke.AbstractConstantGroup.SubGroup#copyConstants(int, int, Object[], int, Object)->int:::
java.lang.invoke.AbstractConstantGroup.AsList#size()->int:::
java.lang.invoke.AbstractConstantGroup.AsList#get(int)->Object:::
java.lang.invoke.AbstractConstantGroup.AsList#iterator()->Iterator<Object>:::
java.lang.invoke.AbstractConstantGroup.AsList#subList(int, int)->List<Object>:::
java.lang.invoke.AbstractConstantGroup.AsList#toArray()->Object[]:::
java.lang.invoke.AbstractConstantGroup.AsList#toArray(T[])->T[]:::
java.lang.invoke.AbstractConstantGroup.WithCache#initializeCache(List<Object>, Object)->void:::
java.lang.invoke.AbstractConstantGroup.WithCache#get(int)->Object:::
java.lang.invoke.AbstractConstantGroup.WithCache#get(int, Object)->Object:::
java.lang.invoke.AbstractConstantGroup.WithCache#isPresent(int)->boolean:::
java.lang.invoke.AbstractConstantGroup.WithCache#fillCache(int)->Object:::hook for local subclasses
java.lang.invoke.AbstractConstantGroup.WithCache#wrapNull(Object)->Object:::
java.lang.invoke.AbstractConstantGroup.WithCache#unwrapNull(Object)->Object:::
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#toString()->String:::
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#bootstrapMethod()->MethodHandle:::
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#invocationName()->String:::
java.lang.invoke.AbstractConstantGroup.BSCIWithCache#invocationType()->T:::
java.lang.invoke.AbstractValidatingLambdaMetafactory#buildCallSite()->CallSite:::Build the CallSite.
java.lang.invoke.AbstractValidatingLambdaMetafactory#validateMetafactoryArgs()->void:::Check the meta-factory arguments for errors
java.lang.invoke.BootstrapCallInfo#bootstrapMethod()->MethodHandle:::Returns the bootstrap method for this call.
java.lang.invoke.BootstrapCallInfo#invocationName()->String:::Returns the method name or constant name for this call.
java.lang.invoke.BootstrapCallInfo#invocationType()->T:::Returns the method type or constant type for this call.
java.lang.invoke.BootstrapCallInfo#makeBootstrapCallInfo(MethodHandle, String, T, ConstantGroup)->BootstrapCallInfo<T>:::Make a new bootstrap call descriptor with the given components.
java.lang.invoke.BootstrapMethodInvoker#invoke(Class<T>, MethodHandle, String, Object, Object, Class<?>)->T:::Factored code for invoking a bootstrap method for invokedynamic  or a dynamic constant.
java.lang.invoke.BootstrapMethodInvoker.VM_BSCI#fillCache(int)->Object:::
java.lang.invoke.BootstrapMethodInvoker.VM_BSCI#copyConstants(int, int, Object[], int)->int:::
java.lang.invoke.BootstrapMethodInvoker.PushAdapter#pushToBootstrapMethod(MethodHandle, MethodHandles.Lookup, String, Object, Object...)->Object:::
java.lang.invoke.BootstrapMethodInvoker.PullAdapter#pullFromBootstrapMethod(MethodHandle, MethodHandles.Lookup, BootstrapCallInfo<?>)->Object:::
java.lang.invoke.BootstrapMethodInvoker#pushMePullYou(MethodHandle, boolean)->MethodHandle:::Given a push-mode BSM (taking one argument) convert it to a   pull-mode BSM (taking N pre-resolved arguments)
java.lang.invoke.BoundMethodHandle#bindSingle(MethodType, LambdaForm, BasicType, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#editor()->LambdaFormEditor:::
java.lang.invoke.BoundMethodHandle#bindSingle(MethodType, LambdaForm, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#bindArgumentL(int, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#bindArgumentI(int, int)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#bindArgumentJ(int, long)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#bindArgumentF(int, float)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#bindArgumentD(int, double)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#rebind()->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#makeReinvoker(MethodHandle)->BoundMethodHandle:::A reinvoker MH has this form:  {@code lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }}
java.lang.invoke.BoundMethodHandle#speciesData()->BoundMethodHandle.SpeciesData:::
java.lang.invoke.BoundMethodHandle#speciesDataFor(LambdaForm)->BoundMethodHandle.SpeciesData:::
java.lang.invoke.BoundMethodHandle#fieldCount()->int:::
java.lang.invoke.BoundMethodHandle#internalProperties()->Object:::
java.lang.invoke.BoundMethodHandle#internalValues()->String:::
java.lang.invoke.BoundMethodHandle#arg(int)->Object:::
java.lang.invoke.BoundMethodHandle#copyWith(MethodType, LambdaForm)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#speciesData()->SpeciesData:::
java.lang.invoke.BoundMethodHandle.Species_L#make(MethodType, LambdaForm, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWith(MethodType, LambdaForm)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWithExtendL(MethodType, LambdaForm, Object)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWithExtendI(MethodType, LambdaForm, int)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWithExtendJ(MethodType, LambdaForm, long)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWithExtendF(MethodType, LambdaForm, float)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.Species_L#copyWithExtendD(MethodType, LambdaForm, double)->BoundMethodHandle:::
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveClassName()->String:::
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveFieldTypes(String)->List<Class<?>>:::
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTypeString()->String:::
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTransformHelper(MemberName, int)->MethodHandle:::
java.lang.invoke.BoundMethodHandle.SpeciesData#deriveTransformHelperArguments(MemberName, int, List<X>, List<X>)->List<X>:::
java.lang.invoke.BoundMethodHandle.SpeciesData#extendWith(byte)->SpeciesData:::
java.lang.invoke.BoundMethodHandle.Specializer#topSpeciesKey()->String:::
java.lang.invoke.BoundMethodHandle.Specializer#newSpeciesData(String)->BoundMethodHandle.SpeciesData:::
java.lang.invoke.BoundMethodHandle.Specializer.Factory#chooseFieldName(Class<?>, int)->String:::
java.lang.invoke.BoundMethodHandle.Specializer#makeFactory()->Factory:::
java.lang.invoke.BoundMethodHandle#speciesData_L()->SpeciesData:::
java.lang.invoke.BoundMethodHandle#speciesData_LL()->SpeciesData:::
java.lang.invoke.BoundMethodHandle#speciesData_LLL()->SpeciesData:::
java.lang.invoke.BoundMethodHandle#speciesData_LLLL()->SpeciesData:::
java.lang.invoke.BoundMethodHandle#speciesData_LLLLL()->SpeciesData:::
java.lang.invoke.CallSite#type()->MethodType:::Returns the type of this call site's target
java.lang.invoke.CallSite#getTarget()->MethodHandle:::Returns the target method of the call site, according to the  behavior defined by this call site's specific class
java.lang.invoke.CallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, according to the  behavior defined by this call site's specific class
java.lang.invoke.CallSite#checkTargetChange(MethodHandle, MethodHandle)->void:::
java.lang.invoke.CallSite#dynamicInvoker()->MethodHandle:::Produces a method handle equivalent to an invokedynamic instruction  which has been linked to this call site
java.lang.invoke.CallSite#makeDynamicInvoker()->MethodHandle:::
java.lang.invoke.CallSite#setTargetNormal(MethodHandle)->void:::
java.lang.invoke.CallSite#getTargetVolatile()->MethodHandle:::
java.lang.invoke.CallSite#setTargetVolatile(MethodHandle)->void:::
java.lang.invoke.CallSite#makeSite(MethodHandle, String, MethodType, Object, Class<?>)->CallSite:::
java.lang.invoke.ClassSpecializer#topClass()->Class<T>:::Return the top type mirror, for type {@code T}
java.lang.invoke.ClassSpecializer#keyType()->Class<K>:::Return the key type mirror, for type {@code K}
java.lang.invoke.ClassSpecializer#metaType()->Class<S>:::Return the species metadata type mirror, for type {@code S}
java.lang.invoke.ClassSpecializer#baseConstructorType()->MethodType:::Report the leading arguments (if any) required by every species factory
java.lang.invoke.ClassSpecializer#topSpecies()->S:::Return the trivial species for the null sequence of arguments.
java.lang.invoke.ClassSpecializer#transformMethods()->List<MemberName>:::Return the list of transform methods originally given at creation of this specializer.
java.lang.invoke.ClassSpecializer#factory()->Factory:::Return the factory object used to build and load concrete species code.
java.lang.invoke.ClassSpecializer#reflectConstructor(Class<T>, Class<?>...)->Constructor<T>:::
java.lang.invoke.ClassSpecializer#reflectField(Class<?>, String)->Field:::
java.lang.invoke.ClassSpecializer#findSpecies(K)->S:::
java.lang.invoke.ClassSpecializer.SpeciesData#key()->K:::
java.lang.invoke.ClassSpecializer.SpeciesData#fieldTypes()->List<Class<?>>:::
java.lang.invoke.ClassSpecializer.SpeciesData#fieldCount()->int:::
java.lang.invoke.ClassSpecializer.SpeciesData#K, S> outer()->ClassSpecializer<T,:::
java.lang.invoke.ClassSpecializer.SpeciesData#isResolved()->boolean:::
java.lang.invoke.ClassSpecializer.SpeciesData#toString()->String:::
java.lang.invoke.ClassSpecializer.SpeciesData#hashCode()->int:::
java.lang.invoke.ClassSpecializer.SpeciesData#equals(Object)->boolean:::
java.lang.invoke.ClassSpecializer.SpeciesData#extends T> speciesCode()->Class<?:::Throws NPE if this species is not yet resolved.
java.lang.invoke.ClassSpecializer.SpeciesData#getter(int)->MethodHandle:::Return a {@link MethodHandle} which can get the indexed field of this species
java.lang.invoke.ClassSpecializer.SpeciesData#getterFunction(int)->LambdaForm.NamedFunction:::Return a {@link LambdaForm.Name} containing a {@link LambdaForm.NamedFunction} that  represents a MH bound to a generic invoker, which in turn forwards to the corresponding  getter.
java.lang.invoke.ClassSpecializer.SpeciesData#getterFunctions()->List<LambdaForm.NamedFunction>:::
java.lang.invoke.ClassSpecializer.SpeciesData#getters()->List<MethodHandle>:::
java.lang.invoke.ClassSpecializer.SpeciesData#factory()->MethodHandle:::
java.lang.invoke.ClassSpecializer.SpeciesData#transformHelper(int)->MethodHandle:::
java.lang.invoke.ClassSpecializer.SpeciesData#deriveFieldTypes(K)->List<Class<?>>:::Given a key, derive the list of field types, which all instances of this  species must store.
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTransformHelper(MemberName, int)->MethodHandle:::Given the index of a method in the transforms list, supply a factory  method that takes the arguments of the transform, plus the local fields,  and produce a value of the required type
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTransformHelperArguments(MemberName, int, List<X>, List<X>)->List<X>:::During code generation, this method is called once per transform to determine  what is the mix of arguments to hand to the transform-helper
java.lang.invoke.ClassSpecializer.SpeciesData#deriveClassName()->String:::Given a key, generate the name of the class which implements the species for that key
java.lang.invoke.ClassSpecializer.SpeciesData#deriveTypeString()->String:::Default implementation collects basic type characters,  plus possibly type names, if some types don't correspond  to basic types.
java.lang.invoke.ClassSpecializer.SpeciesData#extends T> deriveSuperClass()->Class<?:::Report what immediate super-class to use for the concrete class of this species
java.lang.invoke.ClassSpecializer#newSpeciesData(K)->S:::
java.lang.invoke.ClassSpecializer#topSpeciesKey()->K:::
java.lang.invoke.ClassSpecializer.Factory#loadSpecies(S)->S:::Get a concrete subclass of the top class for a given combination of bound types.
java.lang.invoke.ClassSpecializer.Factory#extends T> generateConcreteSpeciesCode(String, ClassSpecializer<T, K, S>.SpeciesData)->Class<?:::Generate a concrete subclass of the top class for a given combination of bound types
java.lang.invoke.ClassSpecializer.Factory#generateConcreteSpeciesCodeFile(String, ClassSpecializer<T, K, S>.SpeciesData)->byte[]:::
java.lang.invoke.ClassSpecializer.Factory#makeNominalGetters(List<Class<?>>, List<MethodHandle>)->List<LambdaForm.NamedFunction>:::
java.lang.invoke.ClassSpecializer.Factory#linkSpeciesDataToCode(ClassSpecializer<T, K, S>.SpeciesData, Class<? extends T>)->void:::
java.lang.invoke.ClassSpecializer.Factory#loadSpeciesDataFromCode(Class<? extends T>)->S:::
java.lang.invoke.ClassSpecializer.Factory#linkCodeToSpeciesData(Class<? extends T>, ClassSpecializer<T, K, S>.SpeciesData, boolean)->void:::
java.lang.invoke.ClassSpecializer.Factory#chooseFieldName(Class<?>, int)->String:::Field names in concrete species classes adhere to this pattern:  type + index, where type is a single character (L, I, J, F, D)
java.lang.invoke.ClassSpecializer.Factory#findFactory(Class<? extends T>, List<Class<?>>)->MethodHandle:::
java.lang.invoke.ClassSpecializer#makeFactory()->Factory:::Hook that virtualizes the Factory class, allowing subclasses to extend it.
java.lang.invoke.ClassSpecializer#methodSig(MethodType)->String:::
java.lang.invoke.ClassSpecializer#classSig(Class<?>)->String:::
java.lang.invoke.ClassSpecializer#classSig(String)->String:::
java.lang.invoke.ClassSpecializer#classBCName(Class<?>)->String:::
java.lang.invoke.ClassSpecializer#classBCName(String)->String:::
java.lang.invoke.ClassSpecializer#className(Class<?>)->String:::
java.lang.invoke.ConstantBootstraps#makeConstant(MethodHandle, String, Class<?>, Object, Class<?>)->Object:::
java.lang.invoke.ConstantBootstraps#nullConstant(MethodHandles.Lookup, String, Class<?>)->Object:::Returns a {@code null} object reference for the reference type specified  by {@code type}.
java.lang.invoke.ConstantBootstraps#primitiveClass(MethodHandles.Lookup, String, Class<?>)->Class<?>:::Returns a {@link Class} mirror for the primitive type whose type  descriptor is specified by {@code name}.
java.lang.invoke.ConstantBootstraps#enumConstant(MethodHandles.Lookup, String, Class<E>)->E:::Returns an {@code enum} constant of the type specified by {@code type}  with the name specified by {@code name}.
java.lang.invoke.ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class<?>, Class<?>)->Object:::Returns the value of a static final field.
java.lang.invoke.ConstantBootstraps#getStaticFinal(MethodHandles.Lookup, String, Class<?>)->Object:::Returns the value of a static final field declared in the class which  is the same as the field's type (or, for primitive-valued fields,  declared in the wrapper class.)  This is a simplified form of  {@link #getStaticFinal(MethodHandles.Lookup, String, Class, Class)}  for the case where a class declares distinguished constant instances of  itself.
java.lang.invoke.ConstantBootstraps#invoke(MethodHandles.Lookup, String, Class<?>, MethodHandle, Object...)->Object:::Returns the result of invoking a method handle with the provided  arguments
java.lang.invoke.ConstantBootstraps#fieldVarHandle(MethodHandles.Lookup, String, Class<VarHandle>, Class<?>, Class<?>)->VarHandle:::Finds a {@link VarHandle} for an instance field.
java.lang.invoke.ConstantBootstraps#staticFieldVarHandle(MethodHandles.Lookup, String, Class<VarHandle>, Class<?>, Class<?>)->VarHandle:::Finds a {@link VarHandle} for a static field.
java.lang.invoke.ConstantBootstraps#arrayVarHandle(MethodHandles.Lookup, String, Class<VarHandle>, Class<?>)->VarHandle:::Finds a {@link VarHandle} for an array type.
java.lang.invoke.ConstantCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves  like a {@code final} field of the {@code ConstantCallSite}
java.lang.invoke.ConstantCallSite#setTarget(MethodHandle)->void:::Always throws an {@link UnsupportedOperationException}
java.lang.invoke.ConstantCallSite#dynamicInvoker()->MethodHandle:::Returns this call site's permanent target
java.lang.invoke.ConstantGroup#size()->int:::Returns the number of constants in this group
java.lang.invoke.ConstantGroup#get(int)->Object:::Returns the selected constant, resolving it if necessary
java.lang.invoke.ConstantGroup#get(int, Object)->Object:::Returns the selected constant,  or the given sentinel value if there is none available
java.lang.invoke.ConstantGroup#isPresent(int)->boolean:::Returns an indication of whether a constant may be available
java.lang.invoke.ConstantGroup#asList()->List<Object>:::Create a view on this group as a {@link List} view
java.lang.invoke.ConstantGroup#asList(Object)->List<Object>:::Create a view on this group as a {@link List} view
java.lang.invoke.ConstantGroup#subGroup(int, int)->ConstantGroup:::Create a view on a sub-sequence of this group.
java.lang.invoke.ConstantGroup#copyConstants(int, int, Object[], int)->int:::Copy a sequence of constant values into a given buffer
java.lang.invoke.ConstantGroup#copyConstants(int, int, Object[], int, Object)->int:::Copy a sequence of constant values into a given buffer
java.lang.invoke.ConstantGroup#makeConstantGroup(List<Object>, Object, IntFunction<Object>)->ConstantGroup:::Make a new constant group with the given constants
java.lang.invoke.ConstantGroup#makeConstantGroup(List<Object>)->ConstantGroup:::Make a new constant group with the given constant values
java.lang.invoke.DelegatingMethodHandle#getTarget()->MethodHandle:::Define this to extract the delegated target which supplies the invocation behavior.
java.lang.invoke.DelegatingMethodHandle#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.DelegatingMethodHandle#internalMemberName()->MemberName:::
java.lang.invoke.DelegatingMethodHandle#isInvokeSpecial()->boolean:::
java.lang.invoke.DelegatingMethodHandle#internalCallerClass()->Class<?>:::
java.lang.invoke.DelegatingMethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DelegatingMethodHandle#internalProperties()->String:::
java.lang.invoke.DelegatingMethodHandle#rebind()->BoundMethodHandle:::
java.lang.invoke.DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, NamedFunction)->LambdaForm:::
java.lang.invoke.DelegatingMethodHandle#makeReinvokerForm(MethodHandle, int, Object, boolean, NamedFunction, NamedFunction)->LambdaForm:::Create a LF which simply reinvokes a target of the given basic type.
java.lang.invoke.DirectMethodHandle#make(byte, Class<?>, MemberName, Class<?>)->DirectMethodHandle:::
java.lang.invoke.DirectMethodHandle#make(Class<?>, MemberName)->DirectMethodHandle:::
java.lang.invoke.DirectMethodHandle#make(MemberName)->DirectMethodHandle:::
java.lang.invoke.DirectMethodHandle#rebind()->BoundMethodHandle:::
java.lang.invoke.DirectMethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle#internalProperties()->String:::
java.lang.invoke.DirectMethodHandle#internalMemberName()->MemberName:::
java.lang.invoke.DirectMethodHandle#makePreparedLambdaForm(MethodType, int)->LambdaForm:::
java.lang.invoke.DirectMethodHandle#findDirectMethodHandle(Name)->Object:::
java.lang.invoke.DirectMethodHandle#internalMemberName(Object)->Object:::Static wrapper for DirectMethodHandle.internalMemberName.
java.lang.invoke.DirectMethodHandle#internalMemberNameEnsureInit(Object)->Object:::
java.lang.invoke.DirectMethodHandle#shouldBeInitialized(MemberName)->boolean:::
java.lang.invoke.DirectMethodHandle.EnsureInitialized#computeValue(Class<?>)->WeakReference<Thread>:::
java.lang.invoke.DirectMethodHandle#ensureInitialized(Object)->void:::
java.lang.invoke.DirectMethodHandle.Special#isInvokeSpecial()->boolean:::
java.lang.invoke.DirectMethodHandle.Special#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle.Special#checkReceiver(Object)->Object:::
java.lang.invoke.DirectMethodHandle.Interface#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle.Interface#checkReceiver(Object)->Object:::
java.lang.invoke.DirectMethodHandle#checkReceiver(Object)->Object:::Used for interface receiver type checks, by Interface and Special modes.
java.lang.invoke.DirectMethodHandle.Constructor#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle#constructorMethod(Object)->Object:::
java.lang.invoke.DirectMethodHandle#allocateInstance(Object)->Object:::
java.lang.invoke.DirectMethodHandle.Accessor#checkCast(Object)->Object:::
java.lang.invoke.DirectMethodHandle.Accessor#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle#fieldOffset(Object)->long:::
java.lang.invoke.DirectMethodHandle#checkBase(Object)->Object:::
java.lang.invoke.DirectMethodHandle.StaticAccessor#checkCast(Object)->Object:::
java.lang.invoke.DirectMethodHandle.StaticAccessor#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.DirectMethodHandle#nullCheck(Object)->Object:::
java.lang.invoke.DirectMethodHandle#staticBase(Object)->Object:::
java.lang.invoke.DirectMethodHandle#staticOffset(Object)->long:::
java.lang.invoke.DirectMethodHandle#checkCast(Object, Object)->Object:::
java.lang.invoke.DirectMethodHandle#checkCast(Object)->Object:::
java.lang.invoke.DirectMethodHandle#ftypeKind(Class<?>)->int:::
java.lang.invoke.DirectMethodHandle#makePreparedFieldLambdaForm(byte, boolean, int)->LambdaForm:::
java.lang.invoke.GenerateJLIClassesHelper#generateBasicFormsClassBytes(String)->byte[]:::
java.lang.invoke.GenerateJLIClassesHelper#generateDirectMethodHandleHolderClassBytes(String, MethodType[], int[])->byte[]:::
java.lang.invoke.GenerateJLIClassesHelper#generateDelegatingMethodHandleHolderClassBytes(String, MethodType[])->byte[]:::
java.lang.invoke.GenerateJLIClassesHelper#generateInvokersHolderClassBytes(String, MethodType[], MethodType[])->byte[]:::
java.lang.invoke.GenerateJLIClassesHelper#byte[]> generateConcreteBMHClassBytes(String)->Map.Entry<String,:::
java.lang.invoke.InfoFromMemberName#getDeclaringClass()->Class<?>:::
java.lang.invoke.InfoFromMemberName#getName()->String:::
java.lang.invoke.InfoFromMemberName#getMethodType()->MethodType:::
java.lang.invoke.InfoFromMemberName#getModifiers()->int:::
java.lang.invoke.InfoFromMemberName#getReferenceKind()->int:::
java.lang.invoke.InfoFromMemberName#toString()->String:::
java.lang.invoke.InfoFromMemberName#reflectAs(Class<T>, Lookup)->T:::
java.lang.invoke.InnerClassLambdaMetafactory#buildCallSite()->CallSite:::Build the CallSite
java.lang.invoke.InnerClassLambdaMetafactory.ForwardingMethodGenerator#generate(MethodType)->void:::
java.lang.invoke.InnerClassLambdaMetafactory#getParameterSize(Class<?>)->int:::
java.lang.invoke.InnerClassLambdaMetafactory#getLoadOpcode(Class<?>)->int:::
java.lang.invoke.InnerClassLambdaMetafactory#getReturnOpcode(Class<?>)->int:::
java.lang.invoke.InvokerBytecodeGenerator#maybeDump(String, byte[])->void:::
java.lang.invoke.InvokerBytecodeGenerator.CpPatch#toString()->String:::
java.lang.invoke.InvokerBytecodeGenerator#constantPlaceholder(Object)->String:::
java.lang.invoke.InvokerBytecodeGenerator#cpPatches(byte[])->Object[]:::
java.lang.invoke.InvokerBytecodeGenerator#generateCustomizedCode(LambdaForm, MethodType)->MemberName:::Generate customized bytecode for a given LambdaForm.
java.lang.invoke.InvokerBytecodeGenerator#className(String)->String:::
java.lang.invoke.InvokerBytecodeGenerator#checkClassName(String)->boolean:::
java.lang.invoke.InvokerBytecodeGenerator#setClassWriter(ClassWriter)->void:::
java.lang.invoke.InvokerBytecodeGenerator#addMethod()->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitArrayLoad(Name)->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitArrayStore(Name)->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitArrayLength(Name)->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitArrayOp(Name, int)->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitInvoke(Name)->void:::Emit an invoke for the given name.
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(NamedFunction...)->boolean:::
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(Name)->boolean:::
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyInvocable(MemberName)->boolean:::
java.lang.invoke.InvokerBytecodeGenerator#isStaticallyNameable(Class<?>)->boolean:::
java.lang.invoke.InvokerBytecodeGenerator#emitStaticInvoke(Name)->void:::
java.lang.invoke.InvokerBytecodeGenerator#emitStaticInvoke(MemberName, Name)->void:::Emit an invoke for the given name, using the MemberName directly.
java.lang.invoke.InvokerBytecodeGenerator#emitNewArray(Name)->void:::
java.lang.invoke.InvokerBytecodeGenerator#refKindOpcode(byte)->int:::
java.lang.invoke.InvokerBytecodeGenerator#generateLambdaFormInterpreterEntryPoint(MethodType)->MemberName:::Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
java.lang.invoke.InvokerBytecodeGenerator#generateNamedFunctionInvoker(MethodTypeForm)->MemberName:::Generate bytecode for a NamedFunction invoker.
java.lang.invoke.Invokers#exactInvoker()->MethodHandle:::
java.lang.invoke.Invokers#genericInvoker()->MethodHandle:::
java.lang.invoke.Invokers#basicInvoker()->MethodHandle:::
java.lang.invoke.Invokers#varHandleMethodInvoker(VarHandle.AccessMode)->MethodHandle:::
java.lang.invoke.Invokers#varHandleMethodExactInvoker(VarHandle.AccessMode)->MethodHandle:::
java.lang.invoke.Invokers#invokeBasicMethod(MethodType)->MemberName:::
java.lang.invoke.Invokers#spreadInvoker(int)->MethodHandle:::
java.lang.invoke.Invokers#toString()->String:::
java.lang.invoke.Invokers#methodHandleInvokeLinkerMethod(String, MethodType, Object[])->MemberName:::
java.lang.invoke.Invokers#invokeHandleForm(MethodType, boolean, int)->LambdaForm:::Returns an adapter for invokeExact or generic invoke, as a MH or constant pool linker
java.lang.invoke.Invokers#varHandleInvokeLinkerMethod(VarHandle.AccessMode, MethodType)->MemberName:::
java.lang.invoke.Invokers#checkVarHandleGenericType(VarHandle, VarHandle.AccessDescriptor)->MethodHandle:::
java.lang.invoke.Invokers#checkVarHandleExactType(VarHandle, VarHandle.AccessDescriptor)->MethodHandle:::
java.lang.invoke.Invokers#newWrongMethodTypeException(MethodType, MethodType)->WrongMethodTypeException:::
java.lang.invoke.Invokers#checkExactType(MethodHandle, MethodType)->void:::
java.lang.invoke.Invokers#checkGenericType(MethodHandle, MethodType)->MethodHandle:::
java.lang.invoke.Invokers#linkToCallSiteMethod(MethodType)->MemberName:::
java.lang.invoke.Invokers#linkToTargetMethod(MethodType)->MemberName:::
java.lang.invoke.Invokers#callSiteForm(MethodType, boolean)->LambdaForm:::
java.lang.invoke.Invokers#getCallSiteTarget(CallSite)->MethodHandle:::
java.lang.invoke.Invokers#checkCustomized(MethodHandle)->void:::
java.lang.invoke.Invokers#maybeCustomize(MethodHandle)->void:::
java.lang.invoke.LambdaForm#debugNames()->boolean:::
java.lang.invoke.LambdaForm#associateWithDebugName(LambdaForm, String)->void:::
java.lang.invoke.LambdaForm#lambdaName()->String:::
java.lang.invoke.LambdaForm#customize(MethodHandle)->LambdaForm:::Customize LambdaForm for a particular MethodHandle
java.lang.invoke.LambdaForm#uncustomize()->LambdaForm:::Get uncustomized flavor of the LambdaForm
java.lang.invoke.LambdaForm#nameRefsAreLegal()->boolean:::Check that all embedded Name references are localizable to this lambda,  and are properly ordered after their corresponding definitions
java.lang.invoke.LambdaForm#returnType()->BasicType:::Report the return type.
java.lang.invoke.LambdaForm#parameterType(int)->BasicType:::Report the N-th argument type.
java.lang.invoke.LambdaForm#parameter(int)->Name:::Report the N-th argument name.
java.lang.invoke.LambdaForm#parameterConstraint(int)->Object:::Report the N-th argument type constraint.
java.lang.invoke.LambdaForm#arity()->int:::Report the arity.
java.lang.invoke.LambdaForm#expressionCount()->int:::Report the number of expressions (non-parameter names).
java.lang.invoke.LambdaForm#methodType()->MethodType:::Return the method type corresponding to my basic type signature.
java.lang.invoke.LambdaForm#basicTypeSignature()->String:::Return ABC_Z, where the ABC are parameter type characters, and Z is the return type character.
java.lang.invoke.LambdaForm#signatureArity(String)->int:::
java.lang.invoke.LambdaForm#signatureReturn(String)->BasicType:::
java.lang.invoke.LambdaForm#isValidSignature(String)->boolean:::
java.lang.invoke.LambdaForm#signatureType(String)->MethodType:::
java.lang.invoke.LambdaForm#basicMethodType(MethodType)->MethodType:::
java.lang.invoke.LambdaForm#isSelectAlternative(int)->boolean:::Check if i-th name is a call to MethodHandleImpl.selectAlternative.
java.lang.invoke.LambdaForm#isGuardWithCatch(int)->boolean:::Check if i-th name is a start of GuardWithCatch idiom.
java.lang.invoke.LambdaForm#isTryFinally(int)->boolean:::Check if i-th name is a start of the tryFinally idiom.
java.lang.invoke.LambdaForm#isLoop(int)->boolean:::Check if i-th name is a start of the loop idiom.
java.lang.invoke.LambdaForm#prepare()->void:::Make this LF directly executable, as part of a MethodHandle
java.lang.invoke.LambdaForm#compileToBytecode()->void:::Generate optimizable bytecode for this form.
java.lang.invoke.LambdaForm#interpretWithArguments(Object...)->Object:::
java.lang.invoke.LambdaForm#interpretName(Name, Object[])->Object:::
java.lang.invoke.LambdaForm#interpretWithArgumentsTracing(Object...)->Object:::
java.lang.invoke.LambdaForm#traceInterpreter(String, Object, Object...)->void:::
java.lang.invoke.LambdaForm#traceInterpreter(String, Object)->void:::
java.lang.invoke.LambdaForm#toString()->String:::
java.lang.invoke.LambdaForm#equals(Object)->boolean:::
java.lang.invoke.LambdaForm#equals(LambdaForm)->boolean:::
java.lang.invoke.LambdaForm#hashCode()->int:::
java.lang.invoke.LambdaForm#editor()->LambdaFormEditor:::
java.lang.invoke.LambdaForm#contains(Name)->boolean:::
java.lang.invoke.LambdaForm.NamedFunction#resolvedHandle()->MethodHandle:::
java.lang.invoke.LambdaForm.NamedFunction#resolve()->void:::
java.lang.invoke.LambdaForm.NamedFunction#equals(Object)->boolean:::
java.lang.invoke.LambdaForm.NamedFunction#hashCode()->int:::
java.lang.invoke.LambdaForm.NamedFunction#invokeWithArguments(Object...)->Object:::
java.lang.invoke.LambdaForm.NamedFunction#invokeWithArgumentsTracing(Object[])->Object:::
java.lang.invoke.LambdaForm.NamedFunction#methodType()->MethodType:::
java.lang.invoke.LambdaForm.NamedFunction#member()->MemberName:::
java.lang.invoke.LambdaForm.NamedFunction#memberDeclaringClassOrNull()->Class<?>:::
java.lang.invoke.LambdaForm.NamedFunction#returnType()->BasicType:::
java.lang.invoke.LambdaForm.NamedFunction#parameterType(int)->BasicType:::
java.lang.invoke.LambdaForm.NamedFunction#arity()->int:::
java.lang.invoke.LambdaForm.NamedFunction#toString()->String:::
java.lang.invoke.LambdaForm.NamedFunction#isIdentity()->boolean:::
java.lang.invoke.LambdaForm.NamedFunction#isConstantZero()->boolean:::
java.lang.invoke.LambdaForm.NamedFunction#intrinsicName()->MethodHandleImpl.Intrinsic:::
java.lang.invoke.LambdaForm#basicTypeSignature(MethodType)->String:::
java.lang.invoke.LambdaForm#shortenSignature(String)->String:::Hack to make signatures more readable when they show up in method names
java.lang.invoke.LambdaForm.Name#type()->BasicType:::
java.lang.invoke.LambdaForm.Name#index()->int:::
java.lang.invoke.LambdaForm.Name#initIndex(int)->boolean:::
java.lang.invoke.LambdaForm.Name#typeChar()->char:::
java.lang.invoke.LambdaForm.Name#resolve()->void:::
java.lang.invoke.LambdaForm.Name#newIndex(int)->Name:::
java.lang.invoke.LambdaForm.Name#cloneWithIndex(int)->Name:::
java.lang.invoke.LambdaForm.Name#withConstraint(Object)->Name:::
java.lang.invoke.LambdaForm.Name#replaceName(Name, Name)->Name:::
java.lang.invoke.LambdaForm.Name#replaceNames(Name[], Name[], int, int)->Name:::In the arguments of this Name, replace oldNames[i] pairwise by newNames[i]
java.lang.invoke.LambdaForm.Name#internArguments()->void:::
java.lang.invoke.LambdaForm.Name#isParam()->boolean:::
java.lang.invoke.LambdaForm.Name#isConstantZero()->boolean:::
java.lang.invoke.LambdaForm.Name#refersTo(Class<?>, String)->boolean:::
java.lang.invoke.LambdaForm.Name#isInvokeBasic()->boolean:::Check if MemberName is a call to MethodHandle.invokeBasic.
java.lang.invoke.LambdaForm.Name#isLinkerMethodInvoke()->boolean:::Check if MemberName is a call to MethodHandle.linkToStatic, etc.
java.lang.invoke.LambdaForm.Name#toString()->String:::
java.lang.invoke.LambdaForm.Name#debugString()->String:::
java.lang.invoke.LambdaForm.Name#paramString()->String:::
java.lang.invoke.LambdaForm.Name#exprString()->String:::
java.lang.invoke.LambdaForm.Name#lastUseIndex(Name)->int:::Return the index of the last occurrence of n in the argument array
java.lang.invoke.LambdaForm.Name#useCount(Name)->int:::Return the number of occurrences of n in the argument array
java.lang.invoke.LambdaForm.Name#contains(Name)->boolean:::
java.lang.invoke.LambdaForm.Name#equals(Name)->boolean:::
java.lang.invoke.LambdaForm.Name#equals(Object)->boolean:::
java.lang.invoke.LambdaForm.Name#hashCode()->int:::
java.lang.invoke.LambdaForm#lastUseIndex(Name)->int:::Return the index of the last name which contains n as an argument
java.lang.invoke.LambdaForm#useCount(Name)->int:::Return the number of times n is used as an argument or return value.
java.lang.invoke.LambdaForm#argument(int, BasicType)->Name:::
java.lang.invoke.LambdaForm#internArgument(Name)->Name:::
java.lang.invoke.LambdaForm#arguments(int, MethodType)->Name[]:::
java.lang.invoke.LambdaForm#identityForm(BasicType)->LambdaForm:::
java.lang.invoke.LambdaForm#zeroForm(BasicType)->LambdaForm:::
java.lang.invoke.LambdaForm#identity(BasicType)->NamedFunction:::
java.lang.invoke.LambdaForm#constantZero(BasicType)->NamedFunction:::
java.lang.invoke.LambdaFormBuffer#name(int)->Name:::
java.lang.invoke.LambdaFormBuffer#nameArray()->Name[]:::
java.lang.invoke.LambdaFormBuffer#resultIndex()->int:::
java.lang.invoke.LambdaFormBuffer#setNames(Name[])->void:::
java.lang.invoke.LambdaFormBuffer#inTrans()->boolean:::
java.lang.invoke.LambdaFormBuffer#ownedCount()->int:::
java.lang.invoke.LambdaFormBuffer#growNames(int, int)->void:::
java.lang.invoke.LambdaFormBuffer#lastIndexOf(Name)->int:::
java.lang.invoke.LambdaFormBuffer#startEdit()->void:::Create a private, writable copy of names
java.lang.invoke.LambdaFormBuffer#changeName(int, Name)->void:::
java.lang.invoke.LambdaFormBuffer#setResult(Name)->void:::Change the result name
java.lang.invoke.LambdaFormBuffer#endEdit()->LambdaForm:::Finish a transaction.
java.lang.invoke.LambdaFormBuffer#replaceFunctions(List<NamedFunction>, List<NamedFunction>, Object...)->LambdaFormBuffer:::Replace any Name whose function is in oldFns with a copy   whose function is in the corresponding position in newFns
java.lang.invoke.LambdaFormBuffer#renameParameter(int, Name)->LambdaFormBuffer:::Replace a parameter by a fresh parameter.
java.lang.invoke.LambdaFormBuffer#replaceParameterByNewExpression(int, Name)->LambdaFormBuffer:::Replace a parameter by a fresh expression.
java.lang.invoke.LambdaFormBuffer#replaceParameterByCopy(int, int)->LambdaFormBuffer:::Replace a parameter by another parameter or expression already in the form.
java.lang.invoke.LambdaFormBuffer#insertExpression(int, Name)->LambdaFormBuffer:::Insert a fresh expression.
java.lang.invoke.LambdaFormBuffer#insertParameter(int, Name)->LambdaFormBuffer:::Insert a fresh parameter.
java.lang.invoke.LambdaFormEditor#lambdaFormEditor(LambdaForm)->LambdaFormEditor:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int)->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int, int)->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int, int, int)->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int...)->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int, byte[])->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#of(byte, int, int, byte[])->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#withResult(LambdaForm)->Transform:::
java.lang.invoke.LambdaFormEditor.Transform#equals(Object)->boolean:::
java.lang.invoke.LambdaFormEditor.Transform#equals(Transform)->boolean:::
java.lang.invoke.LambdaFormEditor.Transform#hashCode()->int:::
java.lang.invoke.LambdaFormEditor.Transform#toString()->String:::
java.lang.invoke.LambdaFormEditor#bindArgumentL(BoundMethodHandle, int, Object)->BoundMethodHandle:::
java.lang.invoke.LambdaFormEditor#bindArgumentI(BoundMethodHandle, int, int)->BoundMethodHandle:::
java.lang.invoke.LambdaFormEditor#bindArgumentJ(BoundMethodHandle, int, long)->BoundMethodHandle:::
java.lang.invoke.LambdaFormEditor#bindArgumentF(BoundMethodHandle, int, float)->BoundMethodHandle:::
java.lang.invoke.LambdaFormEditor#bindArgumentD(BoundMethodHandle, int, double)->BoundMethodHandle:::
java.lang.invoke.LambdaFormEditor#bindArgumentForm(int)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#addArgumentForm(int, BasicType)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#dupArgumentForm(int, int)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#spreadArgumentsForm(int, Class<?>, int)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#collectArgumentsForm(int, MethodType)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#collectArgumentArrayForm(int, MethodHandle)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#filterArgumentForm(int, BasicType)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#filterReturnForm(BasicType, boolean)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#foldArgumentsForm(int, boolean, MethodType, int...)->LambdaForm:::
java.lang.invoke.LambdaFormEditor#permuteArgumentsForm(int, int[])->LambdaForm:::
java.lang.invoke.LambdaFormEditor#noteLoopLocalTypesForm(int, BasicType[])->LambdaForm:::
java.lang.invoke.LambdaFormEditor#permutedTypesMatch(int[], BasicType[], Name[], int)->boolean:::
java.lang.invoke.LambdaMetafactory#metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)->CallSite:::Facilitates the creation of simple "function objects" that implement one  or more interfaces by delegation to a provided {@link MethodHandle},  after appropriate type adaptation and partial evaluation of arguments
java.lang.invoke.LambdaMetafactory#altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)->CallSite:::Facilitates the creation of simple "function objects" that implement one  or more interfaces by delegation to a provided {@link MethodHandle},  after appropriate type adaptation and partial evaluation of arguments
java.lang.invoke.MemberName#getDeclaringClass()->Class<?>:::Return the declaring class of this member
java.lang.invoke.MemberName#getClassLoader()->ClassLoader:::Utility method producing the class loader of the declaring class.
java.lang.invoke.MemberName#getName()->String:::Return the simple name of this member
java.lang.invoke.MemberName#getMethodOrFieldType()->MethodType:::
java.lang.invoke.MemberName#getMethodType()->MethodType:::Return the declared type of this member, which   must be a method or constructor.
java.lang.invoke.MemberName#getMethodDescriptor()->String:::Return the descriptor of this member, which   must be a method or constructor.
java.lang.invoke.MemberName#getInvocationType()->MethodType:::Return the actual type under which this method or constructor must be invoked
java.lang.invoke.MemberName#getParameterTypes()->Class<?>[]:::Utility method producing the parameter types of the method type.
java.lang.invoke.MemberName#getReturnType()->Class<?>:::Utility method producing the return type of the method type.
java.lang.invoke.MemberName#getFieldType()->Class<?>:::Return the declared type of this member, which   must be a field or type
java.lang.invoke.MemberName#getType()->Object:::Utility method to produce either the method type or field type of this member.
java.lang.invoke.MemberName#getSignature()->String:::Utility method to produce the signature of this member,   used within the class file format to describe its type.
java.lang.invoke.MemberName#getModifiers()->int:::Return the modifier flags of this member.
java.lang.invoke.MemberName#getReferenceKind()->byte:::Return the reference kind of this member, or zero if none.
java.lang.invoke.MemberName#referenceKindIsConsistentWith(int)->boolean:::
java.lang.invoke.MemberName#isMethodHandleInvoke()->boolean:::Utility method to query if this member is a method handle invocation (invoke or invokeExact).
java.lang.invoke.MemberName#isMethodHandleInvokeName(String)->boolean:::
java.lang.invoke.MemberName#isVarHandleMethodInvoke()->boolean:::
java.lang.invoke.MemberName#isVarHandleMethodInvokeName(String)->boolean:::
java.lang.invoke.MemberName#isStatic()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isPublic()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isPrivate()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isProtected()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isFinal()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#canBeStaticallyBound()->boolean:::Utility method to query whether this member or its defining class is final.
java.lang.invoke.MemberName#isVolatile()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isAbstract()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isNative()->boolean:::Utility method to query the modifier flags of this member.
java.lang.invoke.MemberName#isBridge()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isVarargs()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isSynthetic()->boolean:::Utility method to query the modifier flags of this member; returns false if the member is not a method.
java.lang.invoke.MemberName#isInvocable()->boolean:::Utility method to query whether this member is a method or constructor.
java.lang.invoke.MemberName#isFieldOrMethod()->boolean:::Utility method to query whether this member is a method, constructor, or field.
java.lang.invoke.MemberName#isMethod()->boolean:::Query whether this member is a method.
java.lang.invoke.MemberName#isConstructor()->boolean:::Query whether this member is a constructor.
java.lang.invoke.MemberName#isField()->boolean:::Query whether this member is a field.
java.lang.invoke.MemberName#isType()->boolean:::Query whether this member is a type.
java.lang.invoke.MemberName#isPackage()->boolean:::Utility method to query whether this member is neither public, private, nor protected.
java.lang.invoke.MemberName#isCallerSensitive()->boolean:::Query whether this member has a CallerSensitive annotation.
java.lang.invoke.MemberName#isAccessibleFrom(Class<?>)->boolean:::Utility method to query whether this member is accessible from a given lookup class.
java.lang.invoke.MemberName#refersTo(Class<?>, String)->boolean:::Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
java.lang.invoke.MemberName#asSpecial()->MemberName:::
java.lang.invoke.MemberName#asConstructor()->MemberName:::If this MN is not REF_newInvokeSpecial, return a clone with that ref
java.lang.invoke.MemberName#asNormalOriginal()->MemberName:::If this MN is a REF_invokeSpecial, return a clone with the "normal" kind   REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface
java.lang.invoke.MemberName#isGetter()->boolean:::
java.lang.invoke.MemberName#isSetter()->boolean:::
java.lang.invoke.MemberName#asSetter()->MemberName:::
java.lang.invoke.MemberName#makeMethodHandleInvoke(String, MethodType)->MemberName:::Create a name for a signature-polymorphic invoker
java.lang.invoke.MemberName#makeMethodHandleInvoke(String, MethodType, int)->MemberName:::
java.lang.invoke.MemberName#makeVarHandleMethodInvoke(String, MethodType)->MemberName:::
java.lang.invoke.MemberName#makeVarHandleMethodInvoke(String, MethodType, int)->MemberName:::
java.lang.invoke.MemberName#clone()->MemberName:::
java.lang.invoke.MemberName#getDefinition()->MemberName:::Get the definition of this member name
java.lang.invoke.MemberName#hashCode()->int:::
java.lang.invoke.MemberName#equals(Object)->boolean:::
java.lang.invoke.MemberName#equals(MemberName)->boolean:::Decide if two member names have exactly the same symbolic content
java.lang.invoke.MemberName#hasReceiverTypeDispatch()->boolean:::Query whether this member name is resolved to a non-static, non-final method.
java.lang.invoke.MemberName#isResolved()->boolean:::Query whether this member name is resolved
java.lang.invoke.MemberName#initResolved(boolean)->void:::
java.lang.invoke.MemberName#checkForTypeAlias(Class<?>)->void:::
java.lang.invoke.MemberName#toString()->String:::Produce a string form of this member name
java.lang.invoke.MemberName#makeAccessException(String, Object)->IllegalAccessException:::
java.lang.invoke.MemberName#makeAccessException()->ReflectiveOperationException:::
java.lang.invoke.MemberName#getFactory()->Factory:::
java.lang.invoke.MemberName.Factory#getMembers(Class<?>, String, Object, int, Class<?>)->List<MemberName>:::
java.lang.invoke.MemberName.Factory#resolveOrFail(byte, MemberName, Class<?>, Class<NoSuchMemberException>)->MemberName:::Produce a resolved version of the given member
java.lang.invoke.MemberName.Factory#resolveOrNull(byte, MemberName, Class<?>)->MemberName:::Produce a resolved version of the given member
java.lang.invoke.MemberName.Factory#getMethods(Class<?>, boolean, Class<?>)->List<MemberName>:::Return a list of all methods defined by the given class
java.lang.invoke.MemberName.Factory#getMethods(Class<?>, boolean, String, MethodType, Class<?>)->List<MemberName>:::Return a list of matching methods defined by the given class
java.lang.invoke.MemberName.Factory#getConstructors(Class<?>, Class<?>)->List<MemberName>:::Return a list of all constructors defined by the given class
java.lang.invoke.MemberName.Factory#getFields(Class<?>, boolean, Class<?>)->List<MemberName>:::Return a list of all fields defined by the given class
java.lang.invoke.MemberName.Factory#getFields(Class<?>, boolean, String, Class<?>, Class<?>)->List<MemberName>:::Return a list of all fields defined by the given class
java.lang.invoke.MemberName.Factory#getNestedTypes(Class<?>, boolean, Class<?>)->List<MemberName>:::Return a list of all nested types defined by the given class
java.lang.invoke.MethodHandle#type()->MethodType:::Reports the type of this method handle
java.lang.invoke.MethodHandle#invokeExact(Object...)->Object:::Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match
java.lang.invoke.MethodHandle#invoke(Object...)->Object:::Invokes the method handle, allowing any caller type descriptor,  and optionally performing conversions on arguments and return values
java.lang.invoke.MethodHandle#invokeBasic(Object...)->Object:::Private method for trusted invocation of a method handle respecting simplified signatures
java.lang.invoke.MethodHandle#linkToVirtual(Object...)->Object:::Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}
java.lang.invoke.MethodHandle#linkToStatic(Object...)->Object:::Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}
java.lang.invoke.MethodHandle#linkToSpecial(Object...)->Object:::Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}
java.lang.invoke.MethodHandle#linkToInterface(Object...)->Object:::Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}
java.lang.invoke.MethodHandle#invokeWithArguments(Object...)->Object:::Performs a variable arity invocation, passing the arguments in the given array  to the method handle, as if via an inexact {@link #invoke invoke} from a call site  which mentions only the type {@code Object}, and whose actual argument count is the length  of the argument array
java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List<?>)->Object:::Performs a variable arity invocation, passing the arguments in the given list  to the method handle, as if via an inexact {@link #invoke invoke} from a call site  which mentions only the type {@code Object}, and whose actual argument count is the length  of the argument list
java.lang.invoke.MethodHandle#asType(MethodType)->MethodHandle:::Produces an adapter method handle which adapts the type of the  current method handle to a new type
java.lang.invoke.MethodHandle#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandle#asSpreader(Class<?>, int)->MethodHandle:::Makes an <em>array-spreading</em> method handle, which accepts a trailing array argument  and spreads its elements as positional arguments
java.lang.invoke.MethodHandle#asSpreader(int, Class<?>, int)->MethodHandle:::Makes an <em>array-spreading</em> method handle, which accepts an array argument at a given position and spreads  its elements as positional arguments in place of the array
java.lang.invoke.MethodHandle#withVarargs(boolean)->MethodHandle:::Adapts this method handle to be {@linkplain #asVarargsCollector variable arity}  if the boolean flag is true, else {@linkplain #asFixedArity fixed arity}
java.lang.invoke.MethodHandle#asCollector(Class<?>, int)->MethodHandle:::Makes an <em>array-collecting</em> method handle, which accepts a given number of trailing  positional arguments and collects them into an array argument
java.lang.invoke.MethodHandle#asCollector(int, Class<?>, int)->MethodHandle:::Makes an <em>array-collecting</em> method handle, which accepts a given number of positional arguments starting  at a given position, and collects them into an array argument
java.lang.invoke.MethodHandle#asCollectorChecks(Class<?>, int, int)->boolean:::
java.lang.invoke.MethodHandle#asVarargsCollector(Class<?>)->MethodHandle:::Makes a <em>variable arity</em> adapter which is able to accept  any number of trailing positional arguments and collect them  into an array argument
java.lang.invoke.MethodHandle#isVarargsCollector()->boolean:::Determines if this method handle  supports {@linkplain #asVarargsCollector variable arity} calls
java.lang.invoke.MethodHandle#asFixedArity()->MethodHandle:::Makes a <em>fixed arity</em> method handle which is otherwise  equivalent to the current method handle
java.lang.invoke.MethodHandle#bindTo(Object)->MethodHandle:::Binds a value {@code x} to the first argument of a method handle, without invoking it
java.lang.invoke.MethodHandle#toString()->String:::Returns a string representation of the method handle,  starting with the string {@code "MethodHandle"} and  ending with the string representation of the method handle's type
java.lang.invoke.MethodHandle#standardString()->String:::
java.lang.invoke.MethodHandle#debugString()->String:::Return a string with a several lines describing the method handle structure
java.lang.invoke.MethodHandle#bindArgumentL(int, Object)->BoundMethodHandle:::
java.lang.invoke.MethodHandle#setVarargs(MemberName)->MethodHandle:::
java.lang.invoke.MethodHandle#viewAsType(MethodType, boolean)->MethodHandle:::
java.lang.invoke.MethodHandle#viewAsTypeChecks(MethodType, boolean)->boolean:::
java.lang.invoke.MethodHandle#internalForm()->LambdaForm:::
java.lang.invoke.MethodHandle#internalMemberName()->MemberName:::
java.lang.invoke.MethodHandle#internalCallerClass()->Class<?>:::
java.lang.invoke.MethodHandle#intrinsicName()->MethodHandleImpl.Intrinsic:::
java.lang.invoke.MethodHandle#withInternalMemberName(MemberName, boolean)->MethodHandle:::
java.lang.invoke.MethodHandle#isInvokeSpecial()->boolean:::
java.lang.invoke.MethodHandle#internalValues()->Object:::
java.lang.invoke.MethodHandle#internalProperties()->Object:::
java.lang.invoke.MethodHandle#copyWith(MethodType, LambdaForm)->MethodHandle:::
java.lang.invoke.MethodHandle#rebind()->BoundMethodHandle:::Require this method handle to be a BMH, or else replace it with a "wrapper" BMH
java.lang.invoke.MethodHandle#updateForm(LambdaForm)->void:::
java.lang.invoke.MethodHandle#customize()->void:::
java.lang.invoke.MethodHandleImpl#makeArrayElementAccessor(Class<?>, ArrayAccess)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#unmatchedArrayAccess(ArrayAccess)->InternalError:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementI(int[], int)->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementJ(long[], int)->long:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementF(float[], int)->float:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementD(double[], int)->double:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementZ(boolean[], int)->boolean:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementB(byte[], int)->byte:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementS(short[], int)->short:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementC(char[], int)->char:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getElementL(Object[], int)->Object:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementI(int[], int, int)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementJ(long[], int, long)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementF(float[], int, float)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementD(double[], int, double)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementZ(boolean[], int, boolean)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementB(byte[], int, byte)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementS(short[], int, short)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementC(char[], int, char)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#setElementL(Object[], int, Object)->void:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthI(int[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthJ(long[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthF(float[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthD(double[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthZ(boolean[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthB(byte[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthS(short[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthC(char[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#lengthL(Object[])->int:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#name(Class<?>, ArrayAccess)->String:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#type(Class<?>, ArrayAccess)->MethodType:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#correctType(Class<?>, ArrayAccess)->MethodType:::
java.lang.invoke.MethodHandleImpl.ArrayAccessor#getAccessor(Class<?>, ArrayAccess)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean, boolean)->MethodHandle:::Create a JVM-level adapter method handle to conform the given method  handle to the similar newType, using only pairwise argument conversions
java.lang.invoke.MethodHandleImpl#makePairwiseConvertByEditor(MethodHandle, MethodType, boolean, boolean)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makePairwiseConvertIndirect(MethodHandle, MethodType, boolean, boolean)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#computeValueConversions(MethodType, MethodType, boolean, boolean)->Object[]:::
java.lang.invoke.MethodHandleImpl#makePairwiseConvert(MethodHandle, MethodType, boolean)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#valueConversion(Class<?>, Class<?>, boolean, boolean)->Object:::Find a conversion function from the given source to the given destination
java.lang.invoke.MethodHandleImpl#makeVarargsCollector(MethodHandle, Class<?>)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#isVarargsCollector()->boolean:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#getTarget()->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#asFixedArity()->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#setVarargs(MemberName)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#withVarargs(boolean)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#viewAsTypeChecks(MethodType, boolean)->boolean:::
java.lang.invoke.MethodHandleImpl.AsVarargsCollector#invokeWithArguments(Object...)->Object:::
java.lang.invoke.MethodHandleImpl#makeSpreadArguments(MethodHandle, Class<?>, int, int)->MethodHandle:::Factory method:  Spread selected argument.
java.lang.invoke.MethodHandleImpl#checkSpreadArgument(Object, int)->void:::
java.lang.invoke.MethodHandleImpl#makeCollectArguments(MethodHandle, MethodHandle, int, boolean)->MethodHandle:::Factory method:  Collect or filter selected argument(s).
java.lang.invoke.MethodHandleImpl#selectAlternative(boolean, MethodHandle, MethodHandle)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#profileBoolean(boolean, int[])->boolean:::
java.lang.invoke.MethodHandleImpl#isCompileConstant(Object)->boolean:::
java.lang.invoke.MethodHandleImpl#makeGuardWithTest(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#profile(MethodHandle)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makeBlockInliningWrapper(MethodHandle)->MethodHandle:::Block inlining during JIT-compilation of a target method handle if it hasn't been invoked enough times
java.lang.invoke.MethodHandleImpl.CountingWrapper#getTarget()->MethodHandle:::
java.lang.invoke.MethodHandleImpl.CountingWrapper#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.CountingWrapper#countDown()->boolean:::
java.lang.invoke.MethodHandleImpl.CountingWrapper#maybeStopCounting(Object)->void:::
java.lang.invoke.MethodHandleImpl#makeGuardWithTestForm(MethodType)->LambdaForm:::
java.lang.invoke.MethodHandleImpl#makeGuardWithCatch(MethodHandle, Class<? extends Throwable>, MethodHandle)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#guardWithCatch(MethodHandle, Class<? extends Throwable>, MethodHandle, Object...)->Object:::Intrinsified during LambdaForm compilation  (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).
java.lang.invoke.MethodHandleImpl#throwException(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#throwException(T)->Empty:::
java.lang.invoke.MethodHandleImpl#fakeMethodHandleInvoke(MemberName)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#fakeVarHandleInvoke(MemberName)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#bindCaller(MethodHandle, Class<?>)->MethodHandle:::Create an alias for the method handle which, when called,  appears to be called from the same class loader and protection domain  as hostClass
java.lang.invoke.MethodHandleImpl.BindCaller#bindCaller(MethodHandle, Class<?>)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.WrappedMember#internalMemberName()->MemberName:::
java.lang.invoke.MethodHandleImpl.WrappedMember#internalCallerClass()->Class<?>:::
java.lang.invoke.MethodHandleImpl.WrappedMember#isInvokeSpecial()->boolean:::
java.lang.invoke.MethodHandleImpl.WrappedMember#getTarget()->MethodHandle:::
java.lang.invoke.MethodHandleImpl.WrappedMember#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makeWrappedMember(MethodHandle, MemberName, boolean)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#getTarget()->MethodHandle:::
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#intrinsicName()->Intrinsic:::
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#asTypeUncached(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#internalProperties()->String:::
java.lang.invoke.MethodHandleImpl.IntrinsicMethodHandle#asCollector(Class<?>, int)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makeIntrinsic(MethodHandle, Intrinsic)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#makeIntrinsic(MethodType, LambdaForm, Intrinsic)->MethodHandle:::
java.lang.invoke.MethodHandleImpl#varargsArray(int)->MethodHandle:::Return a method handle that takes the indicated number of Object   arguments and returns an Object array of them, as if for varargs.
java.lang.invoke.MethodHandleImpl#identity(T[])->T[]:::
java.lang.invoke.MethodHandleImpl#varargsArray(Class<?>, int)->MethodHandle:::Return a method handle that takes the indicated number of   typed arguments and returns an array of them
java.lang.invoke.MethodHandleImpl#assertSame(Object, Object)->void:::
java.lang.invoke.MethodHandleImpl#getFunction(byte)->NamedFunction:::
java.lang.invoke.MethodHandleImpl#makeLoop(Class<?>, List<Class<?>>, List<MethodHandle>, List<MethodHandle>, List<MethodHandle>, List<MethodHandle>)->MethodHandle:::Assembles a loop method handle from the given handles and type information.
java.lang.invoke.MethodHandleImpl.LoopClauses#toString()->String:::
java.lang.invoke.MethodHandleImpl#loop(BasicType[], LoopClauses, Object...)->Object:::Intrinsified during LambdaForm compilation  (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
java.lang.invoke.MethodHandleImpl#countedLoopPredicate(int, int)->boolean:::This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,  MethodHandle) counting loops}.
java.lang.invoke.MethodHandleImpl#countedLoopStep(int, int)->int:::This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,  MethodHandle) counting loops} to increment the counter.
java.lang.invoke.MethodHandleImpl#initIterator(Iterable<?>)->Iterator<?>:::This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
java.lang.invoke.MethodHandleImpl#iteratePredicate(Iterator<?>)->boolean:::This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
java.lang.invoke.MethodHandleImpl#iterateNext(Iterator<?>)->Object:::This method is bound as the step for retrieving the current value from the iterator in {@linkplain  MethodHandles#iteratedLoop iterating loops}.
java.lang.invoke.MethodHandleImpl#makeTryFinally(MethodHandle, MethodHandle, Class<?>, List<Class<?>>)->MethodHandle:::Makes a {@code try-finally} handle that conforms to the type constraints.
java.lang.invoke.MethodHandleImpl#tryFinally(MethodHandle, MethodHandle, Object...)->Object:::Intrinsified during LambdaForm compilation  (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
java.lang.invoke.MethodHandleImpl#getConstantHandle(int)->MethodHandle:::
java.lang.invoke.MethodHandleInfo#getReferenceKind()->int:::Returns the reference kind of the cracked method handle, which in turn  determines whether the method handle's underlying member was a constructor, method, or field
java.lang.invoke.MethodHandleInfo#getDeclaringClass()->Class<?>:::Returns the class in which the cracked method handle's underlying member was defined.
java.lang.invoke.MethodHandleInfo#getName()->String:::Returns the name of the cracked method handle's underlying member
java.lang.invoke.MethodHandleInfo#getMethodType()->MethodType:::Returns the nominal type of the cracked symbolic reference, expressed as a method type
java.lang.invoke.MethodHandleInfo#reflectAs(Class<T>, Lookup)->T:::Reflects the underlying member as a method, constructor, or field object
java.lang.invoke.MethodHandleInfo#getModifiers()->int:::Returns the access modifiers of the underlying member.
java.lang.invoke.MethodHandleInfo#isVarArgs()->boolean:::
java.lang.invoke.MethodHandleInfo#referenceKindToString(int)->String:::Returns the descriptive name of the given reference kind,  as defined in the <a href="MethodHandleInfo.html#refkinds">table above</a>
java.lang.invoke.MethodHandleInfo#toString(int, Class<?>, String, MethodType)->String:::Returns a string representation for a {@code MethodHandleInfo},  given the four parts of its symbolic reference
java.lang.invoke.MethodHandleNatives#init(MemberName, Object)->void:::
java.lang.invoke.MethodHandleNatives#expand(MemberName)->void:::
java.lang.invoke.MethodHandleNatives#resolve(MemberName, Class<?>, boolean)->MemberName:::
java.lang.invoke.MethodHandleNatives#getMembers(Class<?>, String, String, int, Class<?>, int, MemberName[])->int:::
java.lang.invoke.MethodHandleNatives#objectFieldOffset(MemberName)->long:::
java.lang.invoke.MethodHandleNatives#staticFieldOffset(MemberName)->long:::
java.lang.invoke.MethodHandleNatives#staticFieldBase(MemberName)->Object:::
java.lang.invoke.MethodHandleNatives#getMemberVMInfo(MemberName)->Object:::
java.lang.invoke.MethodHandleNatives#setCallSiteTargetNormal(CallSite, MethodHandle)->void:::Tell the JVM that we need to change the target of a CallSite.
java.lang.invoke.MethodHandleNatives#setCallSiteTargetVolatile(CallSite, MethodHandle)->void:::
java.lang.invoke.MethodHandleNatives#copyOutBootstrapArguments(Class<?>, int[], int, int, Object[], int, boolean, Object)->void:::
java.lang.invoke.MethodHandleNatives.CallSiteContext#make(CallSite)->CallSiteContext:::
java.lang.invoke.MethodHandleNatives.CallSiteContext#run()->void:::
java.lang.invoke.MethodHandleNatives#refKindIsValid(int)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsField(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsGetter(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsSetter(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsMethod(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsConstructor(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindHasReceiver(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindIsStatic(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindDoesDispatch(byte)->boolean:::
java.lang.invoke.MethodHandleNatives#refKindName(byte)->String:::
java.lang.invoke.MethodHandleNatives#verifyConstants()->boolean:::
java.lang.invoke.MethodHandleNatives#linkCallSite(Object, int, Object, Object, Object, Object, Object[])->MemberName:::The JVM is linking an invokedynamic instruction
java.lang.invoke.MethodHandleNatives#linkCallSiteImpl(Class<?>, MethodHandle, String, MethodType, Object, Object[])->MemberName:::
java.lang.invoke.MethodHandleNatives#linkCallSiteTracing(Class<?>, MethodHandle, String, MethodType, Object, Object[])->MemberName:::
java.lang.invoke.MethodHandleNatives#linkDynamicConstant(Object, int, Object, Object, Object, Object)->Object:::
java.lang.invoke.MethodHandleNatives#linkDynamicConstantImpl(Class<?>, MethodHandle, String, Class<?>, Object)->Object:::
java.lang.invoke.MethodHandleNatives#linkDynamicConstantTracing(Class<?>, MethodHandle, String, Class<?>, Object)->Object:::
java.lang.invoke.MethodHandleNatives#staticArgumentsPulled(Object)->boolean:::The JVM is requesting pull-mode bootstrap when it provides   a tuple of the form int[]{ argc, vmindex }
java.lang.invoke.MethodHandleNatives#isPullModeBSM(MethodHandle)->boolean:::A BSM runs in pull-mode if and only if its sole arguments  are (Lookup, BootstrapCallInfo), or can be converted pairwise  to those types, and it is not of variable arity
java.lang.invoke.MethodHandleNatives#findMethodHandleType(Class<?>, Class<?>[])->MethodType:::The JVM wants a pointer to a MethodType
java.lang.invoke.MethodHandleNatives#linkMethod(Class<?>, int, Class<?>, String, Object, Object[])->MemberName:::The JVM wants to link a call site that requires a dynamic type check
java.lang.invoke.MethodHandleNatives#linkMethodImpl(Class<?>, int, Class<?>, String, Object, Object[])->MemberName:::
java.lang.invoke.MethodHandleNatives#linkMethodTracing(Class<?>, int, Class<?>, String, Object, Object[])->MemberName:::
java.lang.invoke.MethodHandleNatives#getVarHandleGuardMethodName(MethodType)->String:::
java.lang.invoke.MethodHandleNatives#getCharType(Class<?>)->char:::
java.lang.invoke.MethodHandleNatives#newNoSuchMethodErrorOnVarHandle(String, MethodType)->NoSuchMethodError:::
java.lang.invoke.MethodHandleNatives#linkMethodHandleConstant(Class<?>, int, Class<?>, String, Object)->MethodHandle:::The JVM is resolving a CONSTANT_MethodHandle CP entry
java.lang.invoke.MethodHandleNatives#mapLookupExceptionToError(ReflectiveOperationException)->LinkageError:::Map a reflective exception to a linkage error.
java.lang.invoke.MethodHandleNatives#initCauseFrom(E, Exception)->E:::Use best possible cause for err.initCause(), substituting the  cause for err itself if the cause has the same (or better) type.
java.lang.invoke.MethodHandleNatives#isCallerSensitive(MemberName)->boolean:::Is this method a caller-sensitive method?  I.e., does it call Reflection.getCallerClass or a similar method  to ask about the identity of its caller?
java.lang.invoke.MethodHandleNatives#canBeCalledVirtual(MemberName)->boolean:::
java.lang.invoke.MethodHandleNatives#canBeCalledVirtual(MemberName, Class<?>)->boolean:::
java.lang.invoke.MethodHandleProxies#asInterfaceInstance(Class<T>, MethodHandle)->T:::
java.lang.invoke.MethodHandleProxies#isWrapperInstance(Object)->boolean:::Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
java.lang.invoke.MethodHandleProxies#wrapperInstanceTarget(Object)->MethodHandle:::Produces or recovers a target method handle which is behaviorally  equivalent to the unique method of this wrapper instance
java.lang.invoke.MethodHandleProxies#wrapperInstanceType(Object)->Class<?>:::Recovers the unique single-method interface type for which this wrapper instance was created
java.lang.invoke.MethodHandles#lookup()->Lookup:::Returns a {@link Lookup lookup object} with  full capabilities to emulate all supported bytecode behaviors of the caller
java.lang.invoke.MethodHandles#publicLookup()->Lookup:::Returns a {@link Lookup lookup object} which is trusted minimally
java.lang.invoke.MethodHandles#privateLookupIn(Class<?>, Lookup)->Lookup:::Returns a {@link Lookup lookup object} with full capabilities to emulate all  supported bytecode behaviors, including <a href="MethodHandles.Lookup.html#privacc">  private access</a>, on a target class
java.lang.invoke.MethodHandles#reflectAs(Class<T>, MethodHandle)->T:::Performs an unchecked "crack" of a  <a href="MethodHandleInfo.html#directmh">direct method handle</a>
java.lang.invoke.MethodHandles.Lookup#lookupClass()->Class<?>:::Tells which class is performing the lookup
java.lang.invoke.MethodHandles.Lookup#lookupModes()->int:::Tells which access-protection classes of members this lookup object can produce
java.lang.invoke.MethodHandles.Lookup#in(Class<?>)->Lookup:::Creates a lookup on the specified new lookup class
java.lang.invoke.MethodHandles.Lookup#dropLookupMode(int)->Lookup:::Creates a lookup on the same lookup class which this lookup object  finds members, but with a lookup mode that has lost the given lookup mode
java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])->Class<?>:::Defines a class to the same class loader and in the same runtime package and  {@linkplain java.security.ProtectionDomain protection domain} as this lookup's  {@linkplain #lookupClass() lookup class}
java.lang.invoke.MethodHandles.Lookup#toString()->String:::Displays the name of the class from which lookups are to be made
java.lang.invoke.MethodHandles.Lookup#findStatic(Class<?>, String, MethodType)->MethodHandle:::Produces a method handle for a static method
java.lang.invoke.MethodHandles.Lookup#findVirtual(Class<?>, String, MethodType)->MethodHandle:::Produces a method handle for a virtual method
java.lang.invoke.MethodHandles.Lookup#findConstructor(Class<?>, MethodType)->MethodHandle:::Produces a method handle which creates an object and initializes it, using  the constructor of the specified type
java.lang.invoke.MethodHandles.Lookup#findClass(String)->Class<?>:::Looks up a class by name from the lookup context defined by this {@code Lookup} object
java.lang.invoke.MethodHandles.Lookup#accessClass(Class<?>)->Class<?>:::Determines if a class can be accessed from the lookup context defined by this {@code Lookup} object
java.lang.invoke.MethodHandles.Lookup#findSpecial(Class<?>, String, MethodType, Class<?>)->MethodHandle:::Produces an early-bound method handle for a virtual method
java.lang.invoke.MethodHandles.Lookup#findGetter(Class<?>, String, Class<?>)->MethodHandle:::Produces a method handle giving read access to a non-static field
java.lang.invoke.MethodHandles.Lookup#findSetter(Class<?>, String, Class<?>)->MethodHandle:::Produces a method handle giving write access to a non-static field
java.lang.invoke.MethodHandles.Lookup#findVarHandle(Class<?>, String, Class<?>)->VarHandle:::Produces a VarHandle giving access to a non-static field {@code name}  of type {@code type} declared in a class of type {@code recv}
java.lang.invoke.MethodHandles.Lookup#findStaticGetter(Class<?>, String, Class<?>)->MethodHandle:::Produces a method handle giving read access to a static field
java.lang.invoke.MethodHandles.Lookup#findStaticSetter(Class<?>, String, Class<?>)->MethodHandle:::Produces a method handle giving write access to a static field
java.lang.invoke.MethodHandles.Lookup#findStaticVarHandle(Class<?>, String, Class<?>)->VarHandle:::Produces a VarHandle giving access to a static field {@code name} of  type {@code type} declared in a class of type {@code decl}
java.lang.invoke.MethodHandles.Lookup#bind(Object, String, MethodType)->MethodHandle:::Produces an early-bound method handle for a non-static method
java.lang.invoke.MethodHandles.Lookup#unreflect(Method)->MethodHandle:::Makes a <a href="MethodHandleInfo.html#directmh">direct method handle</a>  to <i>m</i>, if the lookup class has permission
java.lang.invoke.MethodHandles.Lookup#unreflectSpecial(Method, Class<?>)->MethodHandle:::Produces a method handle for a reflected method
java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor<?>)->MethodHandle:::Produces a method handle for a reflected constructor
java.lang.invoke.MethodHandles.Lookup#unreflectGetter(Field)->MethodHandle:::Produces a method handle giving read access to a reflected field
java.lang.invoke.MethodHandles.Lookup#unreflectSetter(Field)->MethodHandle:::Produces a method handle giving write access to a reflected field
java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle(Field)->VarHandle:::Produces a VarHandle giving access to a reflected field {@code f}  of type {@code T} declared in a class of type {@code R}
java.lang.invoke.MethodHandles.Lookup#revealDirect(MethodHandle)->MethodHandleInfo:::Cracks a <a href="MethodHandleInfo.html#directmh">direct method handle</a>  created by this lookup object or a similar one
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, Class<?>, String, Class<?>)->MemberName:::
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, Class<?>, String, MethodType)->MemberName:::
java.lang.invoke.MethodHandles.Lookup#resolveOrFail(byte, MemberName)->MemberName:::
java.lang.invoke.MethodHandles.Lookup#resolveOrNull(byte, MemberName)->MemberName:::
java.lang.invoke.MethodHandles.Lookup#checkSymbolicClass(Class<?>)->void:::
java.lang.invoke.MethodHandles.Lookup#isClassAccessible(Class<?>)->boolean:::
java.lang.invoke.MethodHandles.Lookup#checkMethodName(byte, String)->void:::Check name for an illegal leading "&lt;" character.
java.lang.invoke.MethodHandles.Lookup#findBoundCallerClass(MemberName)->Class<?>:::Find my trustable caller class if m is a caller sensitive method
java.lang.invoke.MethodHandles.Lookup#hasPrivateAccess()->boolean:::Returns {@code true} if this lookup has {@code PRIVATE} access.
java.lang.invoke.MethodHandles.Lookup#checkSecurityManager(Class<?>, MemberName)->void:::Perform necessary <a href="MethodHandles.Lookup.html#secmgr">access checks</a>
java.lang.invoke.MethodHandles.Lookup#checkMethod(byte, Class<?>, MemberName)->void:::
java.lang.invoke.MethodHandles.Lookup#checkField(byte, Class<?>, MemberName)->void:::
java.lang.invoke.MethodHandles.Lookup#checkAccess(byte, Class<?>, MemberName)->void:::Check public/protected/private bits on the symbolic reference class and its member.
java.lang.invoke.MethodHandles.Lookup#accessFailedMessage(Class<?>, MemberName)->String:::
java.lang.invoke.MethodHandles.Lookup#linkMethodHandleConstant(byte, Class<?>, String, Object)->MethodHandle:::
java.lang.invoke.MethodHandles#arrayConstructor(Class<?>)->MethodHandle:::Produces a method handle constructing arrays of a desired type,  as if by the {@code anewarray} bytecode
java.lang.invoke.MethodHandles#arrayLength(Class<?>)->MethodHandle:::Produces a method handle returning the length of an array,  as if by the {@code arraylength} bytecode
java.lang.invoke.MethodHandles#arrayElementGetter(Class<?>)->MethodHandle:::Produces a method handle giving read access to elements of an array,  as if by the {@code aaload} bytecode
java.lang.invoke.MethodHandles#arrayElementSetter(Class<?>)->MethodHandle:::Produces a method handle giving write access to elements of an array,  as if by the {@code astore} bytecode
java.lang.invoke.MethodHandles#arrayElementVarHandle(Class<?>)->VarHandle:::Produces a VarHandle giving access to elements of an array of type  {@code arrayClass}
java.lang.invoke.MethodHandles#byteArrayViewVarHandle(Class<?>, ByteOrder)->VarHandle:::Produces a VarHandle giving access to elements of a {@code byte[]} array  viewed as if it were a different primitive array type, such as  {@code int[]} or {@code long[]}
java.lang.invoke.MethodHandles#byteBufferViewVarHandle(Class<?>, ByteOrder)->VarHandle:::Produces a VarHandle giving access to elements of a {@code ByteBuffer}  viewed as if it were an array of elements of a different primitive  component type to that of {@code byte}, such as {@code int[]} or  {@code long[]}
java.lang.invoke.MethodHandles#spreadInvoker(MethodType, int)->MethodHandle:::Produces a method handle which will invoke any method handle of the  given {@code type}, with a given number of trailing arguments replaced by  a single trailing {@code Object[]} array
java.lang.invoke.MethodHandles#exactInvoker(MethodType)->MethodHandle:::Produces a special <em>invoker method handle</em> which can be used to  invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}
java.lang.invoke.MethodHandles#invoker(MethodType)->MethodHandle:::Produces a special <em>invoker method handle</em> which can be used to  invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}
java.lang.invoke.MethodHandles#varHandleExactInvoker(VarHandle.AccessMode, MethodType)->MethodHandle:::Produces a special <em>invoker method handle</em> which can be used to  invoke a signature-polymorphic access mode method on any VarHandle whose  associated access mode type is compatible with the given type
java.lang.invoke.MethodHandles#varHandleInvoker(VarHandle.AccessMode, MethodType)->MethodHandle:::Produces a special <em>invoker method handle</em> which can be used to  invoke a signature-polymorphic access mode method on any VarHandle whose  associated access mode type is compatible with the given type
java.lang.invoke.MethodHandles#basicInvoker(MethodType)->MethodHandle:::
java.lang.invoke.MethodHandles#explicitCastArguments(MethodHandle, MethodType)->MethodHandle:::Produces a method handle which adapts the type of the  given method handle to a new type by pairwise argument and return type conversion
java.lang.invoke.MethodHandles#permuteArguments(MethodHandle, MethodType, int...)->MethodHandle:::Produces a method handle which adapts the calling sequence of the  given method handle to a new type, by reordering the arguments
java.lang.invoke.MethodHandles#constant(Class<?>, Object)->MethodHandle:::Produces a method handle of the requested return type which returns the given  constant value every time it is invoked
java.lang.invoke.MethodHandles#identity(Class<?>)->MethodHandle:::Produces a method handle which returns its sole argument when invoked.
java.lang.invoke.MethodHandles#zero(Class<?>)->MethodHandle:::Produces a constant method handle of the requested return type which  returns the default value for that type every time it is invoked
java.lang.invoke.MethodHandles#empty(MethodType)->MethodHandle:::Produces a method handle of the requested type which ignores any arguments, does nothing,  and returns a suitable default depending on the return type
java.lang.invoke.MethodHandles#insertArguments(MethodHandle, int, Object...)->MethodHandle:::Provides a target method handle with one or more <em>bound arguments</em>  in advance of the method handle's invocation
java.lang.invoke.MethodHandles#dropArguments(MethodHandle, int, List<Class<?>>)->MethodHandle:::Produces a method handle which will discard some dummy arguments  before calling some other specified <i>target</i> method handle
java.lang.invoke.MethodHandles#dropArguments(MethodHandle, int, Class<?>...)->MethodHandle:::Produces a method handle which will discard some dummy arguments  before calling some other specified <i>target</i> method handle
java.lang.invoke.MethodHandles#dropArgumentsToMatch(MethodHandle, int, List<Class<?>>, int)->MethodHandle:::Adapts a target method handle to match the given parameter type list
java.lang.invoke.MethodHandles#filterArguments(MethodHandle, int, MethodHandle...)->MethodHandle:::Adapts a target method handle by pre-processing  one or more of its arguments, each with its own unary filter function,  and then calling the target with each pre-processed argument  replaced by the result of its corresponding filter function
java.lang.invoke.MethodHandles#filterArgument(MethodHandle, int, MethodHandle)->MethodHandle:::
java.lang.invoke.MethodHandles#collectArguments(MethodHandle, int, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing  a sub-sequence of its arguments with a filter (another method handle)
java.lang.invoke.MethodHandles#filterReturnValue(MethodHandle, MethodHandle)->MethodHandle:::Adapts a target method handle by post-processing  its return value (if any) with a filter (another method handle)
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing  some of its arguments, and then calling the target with  the result of the pre-processing, inserted into the original  sequence of arguments
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, int, MethodHandle)->MethodHandle:::Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then  calling the target with the result of the pre-processing, inserted into the original sequence of arguments just  before the folded arguments
java.lang.invoke.MethodHandles#foldArguments(MethodHandle, int, MethodHandle, int...)->MethodHandle:::As {@see foldArguments(MethodHandle, int, MethodHandle)}, but with the  added capability of selecting the arguments from the targets parameters  to call the combiner with
java.lang.invoke.MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Makes a method handle which adapts a target method handle,  by guarding it with a test, a boolean-valued method handle
java.lang.invoke.MethodHandles#misMatchedTypes(String, T, T)->RuntimeException:::
java.lang.invoke.MethodHandles#catchException(MethodHandle, Class<? extends Throwable>, MethodHandle)->MethodHandle:::Makes a method handle which adapts a target method handle,  by running it inside an exception handler
java.lang.invoke.MethodHandles#throwException(Class<?>, Class<? extends Throwable>)->MethodHandle:::Produces a method handle which will throw exceptions of the given {@code exType}
java.lang.invoke.MethodHandles#loop(MethodHandle[]...)->MethodHandle:::Constructs a method handle representing a loop with several loop variables that are updated and checked upon each  iteration
java.lang.invoke.MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a {@code while} loop from an initializer, a body, and a predicate
java.lang.invoke.MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a {@code do-while} loop from an initializer, a body, and a predicate
java.lang.invoke.MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that runs a given number of iterations
java.lang.invoke.MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that counts over a range of numbers
java.lang.invoke.MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)->MethodHandle:::Constructs a loop that ranges over the values produced by an {@code Iterator<T>}
java.lang.invoke.MethodHandles#swapArguments(MethodHandle, int, int)->MethodHandle:::
java.lang.invoke.MethodHandles#tryFinally(MethodHandle, MethodHandle)->MethodHandle:::Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block
java.lang.invoke.MethodHandleStatics#debugEnabled()->boolean:::
java.lang.invoke.MethodHandleStatics#newInternalError(String)->InternalError:::
java.lang.invoke.MethodHandleStatics#newInternalError(String, Exception)->InternalError:::
java.lang.invoke.MethodHandleStatics#newInternalError(Exception)->InternalError:::
java.lang.invoke.MethodHandleStatics#newIllegalStateException(String)->RuntimeException:::
java.lang.invoke.MethodHandleStatics#newIllegalStateException(String, Object)->RuntimeException:::
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String)->RuntimeException:::
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String, Object)->RuntimeException:::
java.lang.invoke.MethodHandleStatics#newIllegalArgumentException(String, Object, Object)->RuntimeException:::
java.lang.invoke.MethodHandleStatics#uncaughtException(Throwable)->Error:::
java.lang.invoke.MethodHandleStatics#rangeCheck2(int, int, int)->void:::
java.lang.invoke.MethodHandleStatics#rangeCheck1(int, int)->int:::
java.lang.invoke.MethodType#form()->MethodTypeForm:::
java.lang.invoke.MethodType#rtype()->Class<?>:::
java.lang.invoke.MethodType#ptypes()->Class<?>[]:::
java.lang.invoke.MethodType#setForm(MethodTypeForm)->void:::
java.lang.invoke.MethodType#checkSlotCount(int)->void:::
java.lang.invoke.MethodType#methodType(Class<?>, Class<?>[])->MethodType:::Finds or creates an instance of the given method type.
java.lang.invoke.MethodType#methodType(Class<?>, List<Class<?>>)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class<?>, Class<?>, Class<?>...)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class<?>)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class<?>, Class<?>)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#methodType(Class<?>, MethodType)->MethodType:::Finds or creates a method type with the given components
java.lang.invoke.MethodType#makeImpl(Class<?>, Class<?>[], boolean)->MethodType:::
java.lang.invoke.MethodType#genericMethodType(int, boolean)->MethodType:::Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array
java.lang.invoke.MethodType#genericMethodType(int)->MethodType:::Finds or creates a method type whose components are all {@code Object}
java.lang.invoke.MethodType#changeParameterType(int, Class<?>)->MethodType:::Finds or creates a method type with a single different parameter type
java.lang.invoke.MethodType#insertParameterTypes(int, Class<?>...)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#appendParameterTypes(Class<?>...)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#insertParameterTypes(int, List<Class<?>>)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#appendParameterTypes(List<Class<?>>)->MethodType:::Finds or creates a method type with additional parameter types
java.lang.invoke.MethodType#replaceParameterTypes(int, int, Class<?>...)->MethodType:::
java.lang.invoke.MethodType#asSpreaderType(Class<?>, int, int)->MethodType:::
java.lang.invoke.MethodType#leadingReferenceParameter()->Class<?>:::
java.lang.invoke.MethodType#asCollectorType(Class<?>, int, int)->MethodType:::
java.lang.invoke.MethodType#dropParameterTypes(int, int)->MethodType:::Finds or creates a method type with some parameter types omitted
java.lang.invoke.MethodType#changeReturnType(Class<?>)->MethodType:::Finds or creates a method type with a different return type
java.lang.invoke.MethodType#hasPrimitives()->boolean:::Reports if this type contains a primitive argument or return value
java.lang.invoke.MethodType#hasWrappers()->boolean:::Reports if this type contains a wrapper argument or return value
java.lang.invoke.MethodType#erase()->MethodType:::Erases all reference types to {@code Object}
java.lang.invoke.MethodType#basicType()->MethodType:::
java.lang.invoke.MethodType#invokerType()->MethodType:::
java.lang.invoke.MethodType#generic()->MethodType:::Converts all types, both reference and primitive, to {@code Object}
java.lang.invoke.MethodType#isGeneric()->boolean:::
java.lang.invoke.MethodType#wrap()->MethodType:::Converts all primitive types to their corresponding wrapper types
java.lang.invoke.MethodType#unwrap()->MethodType:::Converts all wrapper types to their corresponding primitive types
java.lang.invoke.MethodType#parameterType(int)->Class<?>:::Returns the parameter type at the specified index, within this method type.
java.lang.invoke.MethodType#parameterCount()->int:::Returns the number of parameter types in this method type.
java.lang.invoke.MethodType#returnType()->Class<?>:::Returns the return type of this method type.
java.lang.invoke.MethodType#parameterList()->List<Class<?>>:::Presents the parameter types as a list (a convenience method)
java.lang.invoke.MethodType#lastParameterType()->Class<?>:::Returns the last parameter type of this method type
java.lang.invoke.MethodType#parameterArray()->Class<?>[]:::Presents the parameter types as an array (a convenience method)
java.lang.invoke.MethodType#equals(Object)->boolean:::Compares the specified object with this type for equality
java.lang.invoke.MethodType#hashCode()->int:::Returns the hash code value for this method type
java.lang.invoke.MethodType#toString()->String:::Returns a string representation of the method type,  of the form {@code "(PT0,PT1...)RT"}
java.lang.invoke.MethodType#effectivelyIdenticalParameters(int, List<Class<?>>)->boolean:::
java.lang.invoke.MethodType#isViewableAs(MethodType, boolean)->boolean:::
java.lang.invoke.MethodType#isConvertibleTo(MethodType)->boolean:::
java.lang.invoke.MethodType#explicitCastEquivalentToAsType(MethodType)->boolean:::
java.lang.invoke.MethodType#canConvert(Class<?>, Class<?>)->boolean:::
java.lang.invoke.MethodType#parameterSlotCount()->int:::
java.lang.invoke.MethodType#invokers()->Invokers:::
java.lang.invoke.MethodType#parameterSlotDepth(int)->int:::
java.lang.invoke.MethodType#returnSlotCount()->int:::
java.lang.invoke.MethodType#fromMethodDescriptorString(String, ClassLoader)->MethodType:::Finds or creates an instance of a method type, given the spelling of its bytecode descriptor
java.lang.invoke.MethodType#fromDescriptor(String, ClassLoader)->MethodType:::Same as {@link #fromMethodDescriptorString(String, ClassLoader)}, but  {@code null} ClassLoader means the bootstrap loader is used here
java.lang.invoke.MethodType#toMethodDescriptorString()->String:::Produces a bytecode descriptor representation of the method type
java.lang.invoke.MethodType#toFieldDescriptorString(Class<?>)->String:::
java.lang.invoke.MethodType.ConcurrentWeakInternSet#get(T)->T:::Get the existing interned element
java.lang.invoke.MethodType.ConcurrentWeakInternSet#add(T)->T:::Interns the element
java.lang.invoke.MethodType.ConcurrentWeakInternSet.WeakEntry#equals(Object)->boolean:::
java.lang.invoke.MethodType.ConcurrentWeakInternSet.WeakEntry#hashCode()->int:::
java.lang.invoke.MethodTypeForm#erasedType()->MethodType:::Return the type corresponding uniquely (1-1) to this MT-form
java.lang.invoke.MethodTypeForm#basicType()->MethodType:::Return the basic type derived from the erased type of this MT-form
java.lang.invoke.MethodTypeForm#cachedMethodHandle(int)->MethodHandle:::
java.lang.invoke.MethodTypeForm#setCachedMethodHandle(int, MethodHandle)->MethodHandle:::
java.lang.invoke.MethodTypeForm#cachedLambdaForm(int)->LambdaForm:::
java.lang.invoke.MethodTypeForm#setCachedLambdaForm(int, LambdaForm)->LambdaForm:::
java.lang.invoke.MethodTypeForm#parameterCount()->int:::
java.lang.invoke.MethodTypeForm#parameterSlotCount()->int:::
java.lang.invoke.MethodTypeForm#returnCount()->int:::
java.lang.invoke.MethodTypeForm#returnSlotCount()->int:::
java.lang.invoke.MethodTypeForm#primitiveParameterCount()->int:::
java.lang.invoke.MethodTypeForm#longPrimitiveParameterCount()->int:::
java.lang.invoke.MethodTypeForm#primitiveReturnCount()->int:::
java.lang.invoke.MethodTypeForm#longPrimitiveReturnCount()->int:::
java.lang.invoke.MethodTypeForm#hasPrimitives()->boolean:::
java.lang.invoke.MethodTypeForm#hasNonVoidPrimitives()->boolean:::
java.lang.invoke.MethodTypeForm#hasLongPrimitives()->boolean:::
java.lang.invoke.MethodTypeForm#parameterToArgSlot(int)->int:::
java.lang.invoke.MethodTypeForm#argSlotToParameter(int)->int:::
java.lang.invoke.MethodTypeForm#findForm(MethodType)->MethodTypeForm:::
java.lang.invoke.MethodTypeForm#canonicalize(MethodType, int, int)->MethodType:::Canonicalize the types in the given method type
java.lang.invoke.MethodTypeForm#canonicalize(Class<?>, int)->Class<?>:::Canonicalize the given return or param type
java.lang.invoke.MethodTypeForm#canonicalizeAll(Class<?>[], int)->Class<?>[]:::Canonicalize each param type in the given array
java.lang.invoke.MethodTypeForm#toString()->String:::
java.lang.invoke.MutableCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves  like a normal field of the {@code MutableCallSite}
java.lang.invoke.MutableCallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, as a normal variable
java.lang.invoke.MutableCallSite#dynamicInvoker()->MethodHandle:::{@inheritDoc}
java.lang.invoke.MutableCallSite#syncAll(MutableCallSite[])->void:::Performs a synchronization operation on each call site in the given array,  forcing all other threads to throw away any cached values previously  loaded from the target of any of the call sites
java.lang.invoke.ProxyClassesDumper#getInstance(String)->ProxyClassesDumper:::
java.lang.invoke.ProxyClassesDumper#encodeForFilename(String)->String:::
java.lang.invoke.ProxyClassesDumper#dumpClass(String, byte[])->void:::
java.lang.invoke.SerializedLambda#getCapturingClass()->String:::Get the name of the class that captured this lambda.
java.lang.invoke.SerializedLambda#getFunctionalInterfaceClass()->String:::Get the name of the invoked type to which this  lambda has been converted
java.lang.invoke.SerializedLambda#getFunctionalInterfaceMethodName()->String:::Get the name of the primary method for the functional interface  to which this lambda has been converted.
java.lang.invoke.SerializedLambda#getFunctionalInterfaceMethodSignature()->String:::Get the signature of the primary method for the functional  interface to which this lambda has been converted.
java.lang.invoke.SerializedLambda#getImplClass()->String:::Get the name of the class containing the implementation  method.
java.lang.invoke.SerializedLambda#getImplMethodName()->String:::Get the name of the implementation method.
java.lang.invoke.SerializedLambda#getImplMethodSignature()->String:::Get the signature of the implementation method.
java.lang.invoke.SerializedLambda#getImplMethodKind()->int:::Get the method handle kind (see {@link MethodHandleInfo}) of  the implementation method.
java.lang.invoke.SerializedLambda#getInstantiatedMethodType()->String:::Get the signature of the primary functional interface method  after type variables are substituted with their instantiation  from the capture site.
java.lang.invoke.SerializedLambda#getCapturedArgCount()->int:::Get the count of dynamic arguments to the lambda capture site.
java.lang.invoke.SerializedLambda#getCapturedArg(int)->Object:::Get a dynamic argument to the lambda capture site.
java.lang.invoke.SerializedLambda#toString()->String:::
java.lang.invoke.SimpleMethodHandle#make(MethodType, LambdaForm)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#speciesData()->BoundMethodHandle.SpeciesData:::
java.lang.invoke.SimpleMethodHandle#copyWith(MethodType, LambdaForm)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#internalProperties()->String:::
java.lang.invoke.SimpleMethodHandle#copyWithExtendL(MethodType, LambdaForm, Object)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#copyWithExtendI(MethodType, LambdaForm, int)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#copyWithExtendJ(MethodType, LambdaForm, long)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#copyWithExtendF(MethodType, LambdaForm, float)->BoundMethodHandle:::
java.lang.invoke.SimpleMethodHandle#copyWithExtendD(MethodType, LambdaForm, double)->BoundMethodHandle:::
java.lang.invoke.StringConcatFactory.Key#equals(Object)->boolean:::
java.lang.invoke.StringConcatFactory.Key#hashCode()->int:::
java.lang.invoke.StringConcatFactory.Recipe#getElements()->List<RecipeElement>:::
java.lang.invoke.StringConcatFactory.Recipe#equals(Object)->boolean:::
java.lang.invoke.StringConcatFactory.Recipe#hashCode()->int:::
java.lang.invoke.StringConcatFactory.RecipeElement#getValue()->String:::
java.lang.invoke.StringConcatFactory.RecipeElement#getArgPos()->int:::
java.lang.invoke.StringConcatFactory.RecipeElement#getTag()->char:::
java.lang.invoke.StringConcatFactory.RecipeElement#equals(Object)->boolean:::
java.lang.invoke.StringConcatFactory.RecipeElement#hashCode()->int:::
java.lang.invoke.StringConcatFactory#makeConcat(MethodHandles.Lookup, String, MethodType)->CallSite:::Facilitates the creation of optimized String concatenation methods, that  can be used to efficiently concatenate a known number of arguments of  known types, possibly after type adaptation and partial evaluation of  arguments
java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup, String, MethodType, String, Object...)->CallSite:::Facilitates the creation of optimized String concatenation methods, that  can be used to efficiently concatenate a known number of arguments of  known types, possibly after type adaptation and partial evaluation of  arguments
java.lang.invoke.StringConcatFactory.MethodHandleInlineCopyStrategy#generate(MethodType, Recipe)->MethodHandle:::
java.lang.invoke.StringConcatFactory.Stringifiers.StringifierMost#computeValue(Class<?>)->MethodHandle:::
java.lang.invoke.StringConcatFactory.Stringifiers.StringifierAny#computeValue(Class<?>)->MethodHandle:::
java.lang.invoke.StringConcatFactory.Stringifiers#forMost(Class<?>)->MethodHandle:::Returns a stringifier for references and floats/doubles only
java.lang.invoke.StringConcatFactory.Stringifiers#forAny(Class<?>)->MethodHandle:::Returns a stringifier for any type
java.lang.invoke.StringConcatFactory#lookupStatic(Lookup, Class<?>, String, Class<?>, Class<?>...)->MethodHandle:::
java.lang.invoke.StringConcatFactory#lookupVirtual(Lookup, Class<?>, String, Class<?>, Class<?>...)->MethodHandle:::
java.lang.invoke.StringConcatFactory#lookupConstructor(Lookup, Class<?>, Class<?>)->MethodHandle:::
java.lang.invoke.StringConcatFactory#estimateSize(Class<?>)->int:::
java.lang.invoke.StringConcatFactory#adaptToStringBuilder(Class<?>)->Class<?>:::
java.lang.invoke.SwitchPoint#hasBeenInvalidated()->boolean:::Determines if this switch point has been invalidated yet
java.lang.invoke.SwitchPoint#guardWithTest(MethodHandle, MethodHandle)->MethodHandle:::Returns a method handle which always delegates either to the target or the fallback
java.lang.invoke.SwitchPoint#invalidateAll(SwitchPoint[])->void:::Sets all of the given switch points into the invalid state
java.lang.invoke.TypeConvertingMethodAdapter#boxIfTypePrimitive(Type)->void:::
java.lang.invoke.TypeConvertingMethodAdapter#widen(Wrapper, Wrapper)->void:::
java.lang.invoke.TypeConvertingMethodAdapter#box(Wrapper)->void:::
java.lang.invoke.TypeConvertingMethodAdapter#unbox(String, Wrapper)->void:::Convert types by unboxing
java.lang.invoke.TypeConvertingMethodAdapter#cast(String, String)->void:::
java.lang.invoke.TypeConvertingMethodAdapter#convertType(Class<?>, Class<?>, Class<?>)->void:::Convert an argument of type 'arg' to be passed to 'target' assuring that it is 'functional'
java.lang.invoke.TypeConvertingMethodAdapter#iconst(int)->void:::The following method is copied from  org.objectweb.asm.commons.InstructionAdapter
java.lang.invoke.VarForm#getMethodType(int)->MethodType:::
java.lang.invoke.VarForm#getMemberName(int)->MemberName:::
java.lang.invoke.VarForm#getMethodType_V_init()->MethodType[]:::
java.lang.invoke.VarForm#getMethodType_V(int)->MethodType:::
java.lang.invoke.VarHandle#unsupported()->RuntimeException:::
java.lang.invoke.VarHandle#get(Object...)->Object:::Returns the value of a variable, with memory semantics of reading as  if the variable was declared non-{@code volatile}
java.lang.invoke.VarHandle#set(Object...)->void:::Sets the value of a variable to the {@code newValue}, with memory  semantics of setting as if the variable was declared non-{@code volatile}  and non-{@code final}
java.lang.invoke.VarHandle#getVolatile(Object...)->Object:::Returns the value of a variable, with memory semantics of reading as if  the variable was declared {@code volatile}
java.lang.invoke.VarHandle#setVolatile(Object...)->void:::Sets the value of a variable to the {@code newValue}, with memory  semantics of setting as if the variable was declared {@code volatile}
java.lang.invoke.VarHandle#getOpaque(Object...)->Object:::Returns the value of a variable, accessed in program order, but with no  assurance of memory ordering effects with respect to other threads
java.lang.invoke.VarHandle#setOpaque(Object...)->void:::Sets the value of a variable to the {@code newValue}, in program order,  but with no assurance of memory ordering effects with respect to other  threads
java.lang.invoke.VarHandle#getAcquire(Object...)->Object:::Returns the value of a variable, and ensures that subsequent loads and  stores are not reordered before this access
java.lang.invoke.VarHandle#setRelease(Object...)->void:::Sets the value of a variable to the {@code newValue}, and ensures that  prior loads and stores are not reordered after this access
java.lang.invoke.VarHandle#compareAndSet(Object...)->boolean:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #setVolatile} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#compareAndExchange(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #setVolatile} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#compareAndExchangeAcquire(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #set} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#compareAndExchangeRelease(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #setRelease} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#weakCompareAndSetPlain(Object...)->boolean:::Possibly atomically sets the value of a variable to the {@code newValue}  with the semantics of {@link #set} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#weakCompareAndSet(Object...)->boolean:::Possibly atomically sets the value of a variable to the {@code newValue}  with the memory semantics of {@link #setVolatile} if the variable's  current value, referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#weakCompareAndSetAcquire(Object...)->boolean:::Possibly atomically sets the value of a variable to the {@code newValue}  with the semantics of {@link #set} if the variable's current value,  referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#weakCompareAndSetRelease(Object...)->boolean:::Possibly atomically sets the value of a variable to the {@code newValue}  with the semantics of {@link #setRelease} if the variable's current  value, referred to as the <em>witness value</em>, {@code ==} the  {@code expectedValue}, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#getAndSet(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #setVolatile} and returns the variable's  previous value, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#getAndSetAcquire(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #set} and returns the variable's  previous value, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#getAndSetRelease(Object...)->Object:::Atomically sets the value of a variable to the {@code newValue} with the  memory semantics of {@link #setRelease} and returns the variable's  previous value, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#getAndAdd(Object...)->Object:::Atomically adds the {@code value} to the current value of a variable with  the memory semantics of {@link #setVolatile}, and returns the variable's  previous value, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#getAndAddAcquire(Object...)->Object:::Atomically adds the {@code value} to the current value of a variable with  the memory semantics of {@link #set}, and returns the variable's  previous value, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#getAndAddRelease(Object...)->Object:::Atomically adds the {@code value} to the current value of a variable with  the memory semantics of {@link #setRelease}, and returns the variable's  previous value, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#getAndBitwiseOr(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise OR between the variable's current value and the {@code mask}  with the memory semantics of {@link #setVolatile} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#getAndBitwiseOrAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise OR between the variable's current value and the {@code mask}  with the memory semantics of {@link #set} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#getAndBitwiseOrRelease(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise OR between the variable's current value and the {@code mask}  with the memory semantics of {@link #setRelease} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#getAndBitwiseAnd(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise AND between the variable's current value and the {@code mask}  with the memory semantics of {@link #setVolatile} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#getAndBitwiseAndAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise AND between the variable's current value and the {@code mask}  with the memory semantics of {@link #set} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#getAndBitwiseAndRelease(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise AND between the variable's current value and the {@code mask}  with the memory semantics of {@link #setRelease} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#getAndBitwiseXor(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise XOR between the variable's current value and the {@code mask}  with the memory semantics of {@link #setVolatile} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getVolatile}
java.lang.invoke.VarHandle#getAndBitwiseXorAcquire(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise XOR between the variable's current value and the {@code mask}  with the memory semantics of {@link #set} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #getAcquire}
java.lang.invoke.VarHandle#getAndBitwiseXorRelease(Object...)->Object:::Atomically sets the value of a variable to the result of  bitwise XOR between the variable's current value and the {@code mask}  with the memory semantics of {@link #setRelease} and returns the  variable's previous value, as accessed with the memory semantics of  {@link #get}
java.lang.invoke.VarHandle#varType()->Class<?>:::Returns the variable type of variables referenced by this VarHandle.
java.lang.invoke.VarHandle#coordinateTypes()->List<Class<?>>:::Returns the coordinate types for this VarHandle.
java.lang.invoke.VarHandle#accessModeType(AccessMode)->MethodType:::Obtains the access mode type for this VarHandle and a given access mode
java.lang.invoke.VarHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandle#isAccessModeSupported(AccessMode)->boolean:::Returns {@code true} if the given access mode is supported, otherwise  {@code false}
java.lang.invoke.VarHandle#toMethodHandle(AccessMode)->MethodHandle:::Obtains a method handle bound to this VarHandle and the given access  mode.
java.lang.invoke.VarHandle#getMethodHandle(int)->MethodHandle:::
java.lang.invoke.VarHandle#updateVarForm(VarForm)->void:::
java.lang.invoke.VarHandle#fullFence()->void:::Ensures that loads and stores before the fence will not be reordered  with  loads and stores after the fence.
java.lang.invoke.VarHandle#acquireFence()->void:::Ensures that loads before the fence will not be reordered with loads and  stores after the fence.
java.lang.invoke.VarHandle#releaseFence()->void:::Ensures that loads and stores before the fence will not be  reordered with stores after the fence.
java.lang.invoke.VarHandle#loadLoadFence()->void:::Ensures that loads before the fence will not be reordered with  loads after the fence.
java.lang.invoke.VarHandle#storeStoreFence()->void:::Ensures that stores before the fence will not be reordered with  stores after the fence.
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#get(FieldStaticReadOnly)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#set(FieldStaticReadWrite, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, boolean)->void:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBooleans.Array#get(Array, Object, int)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#set(Array, Object, int, boolean)->void:::
java.lang.invoke.VarHandleBooleans.Array#getVolatile(Array, Object, int)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#setVolatile(Array, Object, int, boolean)->void:::
java.lang.invoke.VarHandleBooleans.Array#getOpaque(Array, Object, int)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#setOpaque(Array, Object, int, boolean)->void:::
java.lang.invoke.VarHandleBooleans.Array#getAcquire(Array, Object, int)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#setRelease(Array, Object, int, boolean)->void:::
java.lang.invoke.VarHandleBooleans.Array#compareAndSet(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#compareAndExchange(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#compareAndExchangeAcquire(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#compareAndExchangeRelease(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetPlain(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSet(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetAcquire(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#weakCompareAndSetRelease(Array, Object, int, boolean, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndSet(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndSetAcquire(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndSetRelease(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOr(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOrRelease(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseOrAcquire(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAnd(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAndRelease(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseAndAcquire(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXor(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXorRelease(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleBooleans.Array#getAndBitwiseXorAcquire(Array, Object, int, boolean)->boolean:::
java.lang.invoke.VarHandleByteArrayAsChars#convEndian(boolean, char)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#get(ArrayHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#set(ArrayHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getVolatile(ArrayHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setVolatile(ArrayHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getAcquire(ArrayHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setRelease(ArrayHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#getOpaque(ArrayHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ArrayHandle#setOpaque(ArrayHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#get(ByteBufferHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#set(ByteBufferHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->char:::
java.lang.invoke.VarHandleByteArrayAsChars.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, char)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles#convEndian(boolean, double)->long:::
java.lang.invoke.VarHandleByteArrayAsDoubles#convEndian(boolean, long)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#get(ArrayHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#set(ArrayHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getVolatile(ArrayHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setVolatile(ArrayHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAcquire(ArrayHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setRelease(ArrayHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getOpaque(ArrayHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#setOpaque(ArrayHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndSet(ArrayHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSet(ArrayHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#get(ByteBufferHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#set(ByteBufferHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, double)->void:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, double, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsDoubles.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, double)->double:::
java.lang.invoke.VarHandleByteArrayAsFloats#convEndian(boolean, float)->int:::
java.lang.invoke.VarHandleByteArrayAsFloats#convEndian(boolean, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#get(ArrayHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#set(ArrayHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getVolatile(ArrayHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setVolatile(ArrayHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAcquire(ArrayHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setRelease(ArrayHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getOpaque(ArrayHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#setOpaque(ArrayHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndSet(ArrayHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSet(ArrayHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#get(ByteBufferHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#set(ByteBufferHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, float)->void:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, float, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsFloats.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, float)->float:::
java.lang.invoke.VarHandleByteArrayAsInts#convEndian(boolean, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#get(ArrayHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#set(ArrayHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getVolatile(ArrayHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setVolatile(ArrayHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAcquire(ArrayHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setRelease(ArrayHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getOpaque(ArrayHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#setOpaque(ArrayHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndSet(ArrayHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSet(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAdd(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#get(ByteBufferHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#set(ByteBufferHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, int)->void:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsInts.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, int)->int:::
java.lang.invoke.VarHandleByteArrayAsLongs#convEndian(boolean, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#get(ArrayHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#set(ArrayHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getVolatile(ArrayHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setVolatile(ArrayHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAcquire(ArrayHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setRelease(ArrayHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getOpaque(ArrayHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#setOpaque(ArrayHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndSet(ArrayHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchange(ArrayHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeAcquire(ArrayHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#compareAndExchangeRelease(ArrayHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetPlain(ArrayHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSet(ArrayHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetAcquire(ArrayHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#weakCompareAndSetRelease(ArrayHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSet(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSetAcquire(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndSetRelease(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAdd(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddAcquire(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddRelease(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndAddConvEndianWithCAS(byte[], int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOr(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrRelease(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrAcquire(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseOrConvEndianWithCAS(byte[], int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAnd(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndRelease(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndAcquire(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseAndConvEndianWithCAS(byte[], int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXor(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorRelease(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorAcquire(ArrayHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ArrayHandle#getAndBitwiseXorConvEndianWithCAS(byte[], int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#get(ByteBufferHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#set(ByteBufferHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, long)->void:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndSet(ByteBufferHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchange(ByteBufferHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeAcquire(ByteBufferHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#compareAndExchangeRelease(ByteBufferHandle, Object, int, long, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetPlain(ByteBufferHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSet(ByteBufferHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetAcquire(ByteBufferHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#weakCompareAndSetRelease(ByteBufferHandle, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSet(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetAcquire(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndSetRelease(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAdd(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddAcquire(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddRelease(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndAddConvEndianWithCAS(ByteBuffer, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOr(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrRelease(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrAcquire(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseOrConvEndianWithCAS(ByteBuffer, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAnd(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndRelease(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndAcquire(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseAndConvEndianWithCAS(ByteBuffer, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXor(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorRelease(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorAcquire(ByteBufferHandle, Object, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsLongs.ByteBufferHandle#getAndBitwiseXorConvEndianWithCAS(ByteBuffer, int, long)->long:::
java.lang.invoke.VarHandleByteArrayAsShorts#convEndian(boolean, short)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#index(byte[], int)->int:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#address(byte[], int)->long:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#get(ArrayHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#set(ArrayHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getVolatile(ArrayHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setVolatile(ArrayHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getAcquire(ArrayHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setRelease(ArrayHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#getOpaque(ArrayHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ArrayHandle#setOpaque(ArrayHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#index(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#indexRO(ByteBuffer, int)->int:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#address(ByteBuffer, int)->long:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#get(ByteBufferHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#set(ByteBufferHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getVolatile(ByteBufferHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setVolatile(ByteBufferHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getAcquire(ByteBufferHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setRelease(ByteBufferHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#getOpaque(ByteBufferHandle, Object, int)->short:::
java.lang.invoke.VarHandleByteArrayAsShorts.ByteBufferHandle#setOpaque(ByteBufferHandle, Object, int, short)->void:::
java.lang.invoke.VarHandleByteArrayBase#newIllegalStateExceptionForMisalignedAccess(int)->IllegalStateException:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#get(FieldStaticReadOnly)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#set(FieldStaticReadWrite, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, byte)->void:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleBytes.Array#get(Array, Object, int)->byte:::
java.lang.invoke.VarHandleBytes.Array#set(Array, Object, int, byte)->void:::
java.lang.invoke.VarHandleBytes.Array#getVolatile(Array, Object, int)->byte:::
java.lang.invoke.VarHandleBytes.Array#setVolatile(Array, Object, int, byte)->void:::
java.lang.invoke.VarHandleBytes.Array#getOpaque(Array, Object, int)->byte:::
java.lang.invoke.VarHandleBytes.Array#setOpaque(Array, Object, int, byte)->void:::
java.lang.invoke.VarHandleBytes.Array#getAcquire(Array, Object, int)->byte:::
java.lang.invoke.VarHandleBytes.Array#setRelease(Array, Object, int, byte)->void:::
java.lang.invoke.VarHandleBytes.Array#compareAndSet(Array, Object, int, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.Array#compareAndExchange(Array, Object, int, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#compareAndExchangeAcquire(Array, Object, int, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#compareAndExchangeRelease(Array, Object, int, byte, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetPlain(Array, Object, int, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSet(Array, Object, int, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetAcquire(Array, Object, int, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.Array#weakCompareAndSetRelease(Array, Object, int, byte, byte)->boolean:::
java.lang.invoke.VarHandleBytes.Array#getAndSet(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndSetAcquire(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndSetRelease(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndAdd(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndAddAcquire(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndAddRelease(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOr(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOrRelease(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseOrAcquire(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAnd(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAndRelease(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseAndAcquire(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXor(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXorRelease(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleBytes.Array#getAndBitwiseXorAcquire(Array, Object, int, byte)->byte:::
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, char)->void:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, char)->void:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, char)->void:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, char)->void:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#get(FieldStaticReadOnly)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#set(FieldStaticReadWrite, char)->void:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, char)->void:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, char)->void:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, char)->void:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, char, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, char, char)->boolean:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, char)->char:::
java.lang.invoke.VarHandleChars.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleChars.Array#get(Array, Object, int)->char:::
java.lang.invoke.VarHandleChars.Array#set(Array, Object, int, char)->void:::
java.lang.invoke.VarHandleChars.Array#getVolatile(Array, Object, int)->char:::
java.lang.invoke.VarHandleChars.Array#setVolatile(Array, Object, int, char)->void:::
java.lang.invoke.VarHandleChars.Array#getOpaque(Array, Object, int)->char:::
java.lang.invoke.VarHandleChars.Array#setOpaque(Array, Object, int, char)->void:::
java.lang.invoke.VarHandleChars.Array#getAcquire(Array, Object, int)->char:::
java.lang.invoke.VarHandleChars.Array#setRelease(Array, Object, int, char)->void:::
java.lang.invoke.VarHandleChars.Array#compareAndSet(Array, Object, int, char, char)->boolean:::
java.lang.invoke.VarHandleChars.Array#compareAndExchange(Array, Object, int, char, char)->char:::
java.lang.invoke.VarHandleChars.Array#compareAndExchangeAcquire(Array, Object, int, char, char)->char:::
java.lang.invoke.VarHandleChars.Array#compareAndExchangeRelease(Array, Object, int, char, char)->char:::
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetPlain(Array, Object, int, char, char)->boolean:::
java.lang.invoke.VarHandleChars.Array#weakCompareAndSet(Array, Object, int, char, char)->boolean:::
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetAcquire(Array, Object, int, char, char)->boolean:::
java.lang.invoke.VarHandleChars.Array#weakCompareAndSetRelease(Array, Object, int, char, char)->boolean:::
java.lang.invoke.VarHandleChars.Array#getAndSet(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndSetAcquire(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndSetRelease(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndAdd(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndAddAcquire(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndAddRelease(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOr(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOrRelease(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseOrAcquire(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAnd(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAndRelease(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseAndAcquire(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXor(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXorRelease(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleChars.Array#getAndBitwiseXorAcquire(Array, Object, int, char)->char:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#get(FieldStaticReadOnly)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#set(FieldStaticReadWrite, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, double)->void:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, double, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleDoubles.Array#get(Array, Object, int)->double:::
java.lang.invoke.VarHandleDoubles.Array#set(Array, Object, int, double)->void:::
java.lang.invoke.VarHandleDoubles.Array#getVolatile(Array, Object, int)->double:::
java.lang.invoke.VarHandleDoubles.Array#setVolatile(Array, Object, int, double)->void:::
java.lang.invoke.VarHandleDoubles.Array#getOpaque(Array, Object, int)->double:::
java.lang.invoke.VarHandleDoubles.Array#setOpaque(Array, Object, int, double)->void:::
java.lang.invoke.VarHandleDoubles.Array#getAcquire(Array, Object, int)->double:::
java.lang.invoke.VarHandleDoubles.Array#setRelease(Array, Object, int, double)->void:::
java.lang.invoke.VarHandleDoubles.Array#compareAndSet(Array, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.Array#compareAndExchange(Array, Object, int, double, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#compareAndExchangeAcquire(Array, Object, int, double, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#compareAndExchangeRelease(Array, Object, int, double, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetPlain(Array, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSet(Array, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetAcquire(Array, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.Array#weakCompareAndSetRelease(Array, Object, int, double, double)->boolean:::
java.lang.invoke.VarHandleDoubles.Array#getAndSet(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#getAndSetAcquire(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#getAndSetRelease(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#getAndAdd(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#getAndAddAcquire(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleDoubles.Array#getAndAddRelease(Array, Object, int, double)->double:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, float)->void:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, float)->void:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, float)->void:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, float)->void:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#get(FieldStaticReadOnly)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#set(FieldStaticReadWrite, float)->void:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, float)->void:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, float)->void:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, float)->void:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, float, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, float)->float:::
java.lang.invoke.VarHandleFloats.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleFloats.Array#get(Array, Object, int)->float:::
java.lang.invoke.VarHandleFloats.Array#set(Array, Object, int, float)->void:::
java.lang.invoke.VarHandleFloats.Array#getVolatile(Array, Object, int)->float:::
java.lang.invoke.VarHandleFloats.Array#setVolatile(Array, Object, int, float)->void:::
java.lang.invoke.VarHandleFloats.Array#getOpaque(Array, Object, int)->float:::
java.lang.invoke.VarHandleFloats.Array#setOpaque(Array, Object, int, float)->void:::
java.lang.invoke.VarHandleFloats.Array#getAcquire(Array, Object, int)->float:::
java.lang.invoke.VarHandleFloats.Array#setRelease(Array, Object, int, float)->void:::
java.lang.invoke.VarHandleFloats.Array#compareAndSet(Array, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.Array#compareAndExchange(Array, Object, int, float, float)->float:::
java.lang.invoke.VarHandleFloats.Array#compareAndExchangeAcquire(Array, Object, int, float, float)->float:::
java.lang.invoke.VarHandleFloats.Array#compareAndExchangeRelease(Array, Object, int, float, float)->float:::
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetPlain(Array, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSet(Array, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetAcquire(Array, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.Array#weakCompareAndSetRelease(Array, Object, int, float, float)->boolean:::
java.lang.invoke.VarHandleFloats.Array#getAndSet(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleFloats.Array#getAndSetAcquire(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleFloats.Array#getAndSetRelease(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleFloats.Array#getAndAdd(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleFloats.Array#getAndAddAcquire(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleFloats.Array#getAndAddRelease(Array, Object, int, float)->float:::
java.lang.invoke.VarHandleGuards#guard_L_L(VarHandle, Object, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_LL_V(VarHandle, Object, Object, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LL_L(VarHandle, Object, Object, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_LLL_Z(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LLL_L(VarHandle, Object, Object, Object, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_L_I(VarHandle, Object, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LI_V(VarHandle, Object, int, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LI_I(VarHandle, Object, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LII_Z(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LII_I(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_L_J(VarHandle, Object, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_LJ_V(VarHandle, Object, long, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LJ_J(VarHandle, Object, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_LJJ_Z(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LJJ_J(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_L_F(VarHandle, Object, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_LF_V(VarHandle, Object, float, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LF_F(VarHandle, Object, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_LFF_Z(VarHandle, Object, float, float, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LFF_F(VarHandle, Object, float, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_L_D(VarHandle, Object, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LD_V(VarHandle, Object, double, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LD_D(VarHandle, Object, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LDD_Z(VarHandle, Object, double, double, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LDD_D(VarHandle, Object, double, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard__L(VarHandle, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_L_V(VarHandle, Object, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LL_Z(VarHandle, Object, Object, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard__I(VarHandle, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_I_V(VarHandle, int, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_I_I(VarHandle, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_II_Z(VarHandle, int, int, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_II_I(VarHandle, int, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard__J(VarHandle, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_J_V(VarHandle, long, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_J_J(VarHandle, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_JJ_Z(VarHandle, long, long, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_JJ_J(VarHandle, long, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard__F(VarHandle, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_F_V(VarHandle, float, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_F_F(VarHandle, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_FF_Z(VarHandle, float, float, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_FF_F(VarHandle, float, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard__D(VarHandle, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_D_V(VarHandle, double, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_D_D(VarHandle, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_DD_Z(VarHandle, double, double, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_DD_D(VarHandle, double, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LI_L(VarHandle, Object, int, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_LIL_V(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LIL_L(VarHandle, Object, int, Object, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_LILL_Z(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LILL_L(VarHandle, Object, int, Object, Object, VarHandle.AccessDescriptor)->Object:::
java.lang.invoke.VarHandleGuards#guard_LII_V(VarHandle, Object, int, int, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LIII_Z(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LIII_I(VarHandle, Object, int, int, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LI_J(VarHandle, Object, int, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_LIJ_V(VarHandle, Object, int, long, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LIJ_J(VarHandle, Object, int, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_LIJJ_Z(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LIJJ_J(VarHandle, Object, int, long, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleGuards#guard_LI_F(VarHandle, Object, int, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_LIF_V(VarHandle, Object, int, float, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LIF_F(VarHandle, Object, int, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_LIFF_Z(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LIFF_F(VarHandle, Object, int, float, float, VarHandle.AccessDescriptor)->float:::
java.lang.invoke.VarHandleGuards#guard_LI_D(VarHandle, Object, int, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LID_V(VarHandle, Object, int, double, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LID_D(VarHandle, Object, int, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LIDD_Z(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LIDD_D(VarHandle, Object, int, double, double, VarHandle.AccessDescriptor)->double:::
java.lang.invoke.VarHandleGuards#guard_LJ_I(VarHandle, Object, long, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LJI_V(VarHandle, Object, long, int, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LJI_I(VarHandle, Object, long, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LJII_Z(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LJII_I(VarHandle, Object, long, int, int, VarHandle.AccessDescriptor)->int:::
java.lang.invoke.VarHandleGuards#guard_LJJ_V(VarHandle, Object, long, long, VarHandle.AccessDescriptor)->void:::
java.lang.invoke.VarHandleGuards#guard_LJJJ_Z(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)->boolean:::
java.lang.invoke.VarHandleGuards#guard_LJJJ_J(VarHandle, Object, long, long, long, VarHandle.AccessDescriptor)->long:::
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, int)->void:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, int)->void:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, int)->void:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, int)->void:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#get(FieldStaticReadOnly)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#set(FieldStaticReadWrite, int)->void:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, int)->void:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, int)->void:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, int)->void:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, int, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, int, int)->boolean:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, int)->int:::
java.lang.invoke.VarHandleInts.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleInts.Array#get(Array, Object, int)->int:::
java.lang.invoke.VarHandleInts.Array#set(Array, Object, int, int)->void:::
java.lang.invoke.VarHandleInts.Array#getVolatile(Array, Object, int)->int:::
java.lang.invoke.VarHandleInts.Array#setVolatile(Array, Object, int, int)->void:::
java.lang.invoke.VarHandleInts.Array#getOpaque(Array, Object, int)->int:::
java.lang.invoke.VarHandleInts.Array#setOpaque(Array, Object, int, int)->void:::
java.lang.invoke.VarHandleInts.Array#getAcquire(Array, Object, int)->int:::
java.lang.invoke.VarHandleInts.Array#setRelease(Array, Object, int, int)->void:::
java.lang.invoke.VarHandleInts.Array#compareAndSet(Array, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleInts.Array#compareAndExchange(Array, Object, int, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#compareAndExchangeAcquire(Array, Object, int, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#compareAndExchangeRelease(Array, Object, int, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetPlain(Array, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleInts.Array#weakCompareAndSet(Array, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetAcquire(Array, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleInts.Array#weakCompareAndSetRelease(Array, Object, int, int, int)->boolean:::
java.lang.invoke.VarHandleInts.Array#getAndSet(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndSetAcquire(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndSetRelease(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndAdd(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndAddAcquire(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndAddRelease(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOr(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOrRelease(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseOrAcquire(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAnd(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAndRelease(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseAndAcquire(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXor(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXorRelease(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleInts.Array#getAndBitwiseXorAcquire(Array, Object, int, int)->int:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, long)->void:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, long)->void:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, long)->void:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, long)->void:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#get(FieldStaticReadOnly)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#set(FieldStaticReadWrite, long)->void:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, long)->void:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, long)->void:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, long)->void:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, long, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, long)->long:::
java.lang.invoke.VarHandleLongs.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleLongs.Array#get(Array, Object, int)->long:::
java.lang.invoke.VarHandleLongs.Array#set(Array, Object, int, long)->void:::
java.lang.invoke.VarHandleLongs.Array#getVolatile(Array, Object, int)->long:::
java.lang.invoke.VarHandleLongs.Array#setVolatile(Array, Object, int, long)->void:::
java.lang.invoke.VarHandleLongs.Array#getOpaque(Array, Object, int)->long:::
java.lang.invoke.VarHandleLongs.Array#setOpaque(Array, Object, int, long)->void:::
java.lang.invoke.VarHandleLongs.Array#getAcquire(Array, Object, int)->long:::
java.lang.invoke.VarHandleLongs.Array#setRelease(Array, Object, int, long)->void:::
java.lang.invoke.VarHandleLongs.Array#compareAndSet(Array, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.Array#compareAndExchange(Array, Object, int, long, long)->long:::
java.lang.invoke.VarHandleLongs.Array#compareAndExchangeAcquire(Array, Object, int, long, long)->long:::
java.lang.invoke.VarHandleLongs.Array#compareAndExchangeRelease(Array, Object, int, long, long)->long:::
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetPlain(Array, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSet(Array, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetAcquire(Array, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.Array#weakCompareAndSetRelease(Array, Object, int, long, long)->boolean:::
java.lang.invoke.VarHandleLongs.Array#getAndSet(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndSetAcquire(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndSetRelease(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndAdd(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndAddAcquire(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndAddRelease(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOr(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOrRelease(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseOrAcquire(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAnd(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAndRelease(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseAndAcquire(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXor(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXorRelease(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleLongs.Array#getAndBitwiseXorAcquire(Array, Object, int, long)->long:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#get(FieldStaticReadOnly)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#set(FieldStaticReadWrite, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, Object)->void:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, Object)->Object:::
java.lang.invoke.VarHandleObjects.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleObjects.Array#runtimeTypeCheck(Array, Object[], Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#reflectiveTypeCheck(Object[], Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#get(Array, Object, int)->Object:::
java.lang.invoke.VarHandleObjects.Array#set(Array, Object, int, Object)->void:::
java.lang.invoke.VarHandleObjects.Array#getVolatile(Array, Object, int)->Object:::
java.lang.invoke.VarHandleObjects.Array#setVolatile(Array, Object, int, Object)->void:::
java.lang.invoke.VarHandleObjects.Array#getOpaque(Array, Object, int)->Object:::
java.lang.invoke.VarHandleObjects.Array#setOpaque(Array, Object, int, Object)->void:::
java.lang.invoke.VarHandleObjects.Array#getAcquire(Array, Object, int)->Object:::
java.lang.invoke.VarHandleObjects.Array#setRelease(Array, Object, int, Object)->void:::
java.lang.invoke.VarHandleObjects.Array#compareAndSet(Array, Object, int, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.Array#compareAndExchange(Array, Object, int, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#compareAndExchangeAcquire(Array, Object, int, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#compareAndExchangeRelease(Array, Object, int, Object, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetPlain(Array, Object, int, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSet(Array, Object, int, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetAcquire(Array, Object, int, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.Array#weakCompareAndSetRelease(Array, Object, int, Object, Object)->boolean:::
java.lang.invoke.VarHandleObjects.Array#getAndSet(Array, Object, int, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#getAndSetAcquire(Array, Object, int, Object)->Object:::
java.lang.invoke.VarHandleObjects.Array#getAndSetRelease(Array, Object, int, Object)->Object:::
java.lang.invoke.VarHandles#makeFieldHandle(MemberName, Class<?>, Class<?>, boolean)->VarHandle:::
java.lang.invoke.VarHandles#makeArrayElementHandle(Class<?>)->VarHandle:::
java.lang.invoke.VarHandles#byteArrayViewHandle(Class<?>, boolean)->VarHandle:::
java.lang.invoke.VarHandles#makeByteBufferViewHandle(Class<?>, boolean)->VarHandle:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#get(FieldInstanceReadOnly, Object)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getVolatile(FieldInstanceReadOnly, Object)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getOpaque(FieldInstanceReadOnly, Object)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadOnly#getAcquire(FieldInstanceReadOnly, Object)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#set(FieldInstanceReadWrite, Object, short)->void:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setVolatile(FieldInstanceReadWrite, Object, short)->void:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setOpaque(FieldInstanceReadWrite, Object, short)->void:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#setRelease(FieldInstanceReadWrite, Object, short)->void:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndSet(FieldInstanceReadWrite, Object, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchange(FieldInstanceReadWrite, Object, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeAcquire(FieldInstanceReadWrite, Object, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#compareAndExchangeRelease(FieldInstanceReadWrite, Object, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetPlain(FieldInstanceReadWrite, Object, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSet(FieldInstanceReadWrite, Object, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetAcquire(FieldInstanceReadWrite, Object, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#weakCompareAndSetRelease(FieldInstanceReadWrite, Object, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSet(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSetAcquire(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndSetRelease(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAdd(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAddAcquire(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndAddRelease(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOr(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrRelease(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseOrAcquire(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAnd(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndRelease(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseAndAcquire(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXor(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorRelease(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldInstanceReadWrite#getAndBitwiseXorAcquire(FieldInstanceReadWrite, Object, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#get(FieldStaticReadOnly)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getVolatile(FieldStaticReadOnly)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getOpaque(FieldStaticReadOnly)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadOnly#getAcquire(FieldStaticReadOnly)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#set(FieldStaticReadWrite, short)->void:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setVolatile(FieldStaticReadWrite, short)->void:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setOpaque(FieldStaticReadWrite, short)->void:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#setRelease(FieldStaticReadWrite, short)->void:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndSet(FieldStaticReadWrite, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchange(FieldStaticReadWrite, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchangeAcquire(FieldStaticReadWrite, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#compareAndExchangeRelease(FieldStaticReadWrite, short, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetPlain(FieldStaticReadWrite, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSet(FieldStaticReadWrite, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetAcquire(FieldStaticReadWrite, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#weakCompareAndSetRelease(FieldStaticReadWrite, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSet(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSetAcquire(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndSetRelease(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAdd(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAddAcquire(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndAddRelease(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOr(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrRelease(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseOrAcquire(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAnd(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndRelease(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseAndAcquire(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXor(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorRelease(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.FieldStaticReadWrite#getAndBitwiseXorAcquire(FieldStaticReadWrite, short)->short:::
java.lang.invoke.VarHandleShorts.Array#accessModeTypeUncached(AccessMode)->MethodType:::
java.lang.invoke.VarHandleShorts.Array#get(Array, Object, int)->short:::
java.lang.invoke.VarHandleShorts.Array#set(Array, Object, int, short)->void:::
java.lang.invoke.VarHandleShorts.Array#getVolatile(Array, Object, int)->short:::
java.lang.invoke.VarHandleShorts.Array#setVolatile(Array, Object, int, short)->void:::
java.lang.invoke.VarHandleShorts.Array#getOpaque(Array, Object, int)->short:::
java.lang.invoke.VarHandleShorts.Array#setOpaque(Array, Object, int, short)->void:::
java.lang.invoke.VarHandleShorts.Array#getAcquire(Array, Object, int)->short:::
java.lang.invoke.VarHandleShorts.Array#setRelease(Array, Object, int, short)->void:::
java.lang.invoke.VarHandleShorts.Array#compareAndSet(Array, Object, int, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.Array#compareAndExchange(Array, Object, int, short, short)->short:::
java.lang.invoke.VarHandleShorts.Array#compareAndExchangeAcquire(Array, Object, int, short, short)->short:::
java.lang.invoke.VarHandleShorts.Array#compareAndExchangeRelease(Array, Object, int, short, short)->short:::
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetPlain(Array, Object, int, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSet(Array, Object, int, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetAcquire(Array, Object, int, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.Array#weakCompareAndSetRelease(Array, Object, int, short, short)->boolean:::
java.lang.invoke.VarHandleShorts.Array#getAndSet(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndSetAcquire(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndSetRelease(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndAdd(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndAddAcquire(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndAddRelease(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOr(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOrRelease(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseOrAcquire(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAnd(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAndRelease(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseAndAcquire(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXor(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXorRelease(Array, Object, int, short)->short:::
java.lang.invoke.VarHandleShorts.Array#getAndBitwiseXorAcquire(Array, Object, int, short)->short:::
java.lang.invoke.VolatileCallSite#getTarget()->MethodHandle:::Returns the target method of the call site, which behaves  like a {@code volatile} field of the {@code VolatileCallSite}
java.lang.invoke.VolatileCallSite#setTarget(MethodHandle)->void:::Updates the target method of this call site, as a volatile variable
java.lang.invoke.VolatileCallSite#dynamicInvoker()->MethodHandle:::{@inheritDoc}
