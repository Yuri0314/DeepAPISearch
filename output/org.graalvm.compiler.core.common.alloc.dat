BiDirectionalTraceBuilder#computeTraces(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: bi directional trace builder compute traces:::return->new->BiDirectionalTraceBuilder->build
BiDirectionalTraceBuilder#createQueue(AbstractBlockBase[])::: bi directional trace builder create queue:::queue->Arrays->asList->new->ArrayList<>->queue->BiDirectionalTraceBuilder->compare->sort->return->new->ArrayDeque<>
BiDirectionalTraceBuilder#compare(AbstractBlockBase, AbstractBlockBase)::: bi directional trace builder compare:::return->Double->b->getRelativeFrequency->a->getRelativeFrequency->compare
BiDirectionalTraceBuilder#processed(AbstractBlockBase)::: bi directional trace builder processed:::return->processed->b->getId->get
BiDirectionalTraceBuilder#build(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: bi directional trace builder build:::try->indent->debug->logAndIndent->traces->buildTraces->return->TraceBuilderResult->create->catch->finally
BiDirectionalTraceBuilder#buildTraces(DebugContext)::: bi directional trace builder build traces:::traces->new->ArrayList<>->while->worklist->isEmpty->block->worklist->pollFirst->if->processed->trace->findTrace->new->Trace->foreach->trace->getBlocks->traceBlock->getId->trace->traces->size->setId->traces->add->return
BiDirectionalTraceBuilder#findTrace(DebugContext, AbstractBlockBase):::Build a new trace starting at block.:::trace->new->ArrayDeque<>->try->i->debug->logAndIndent->try->indentFront->debug->logAndIndent->for->block->selectPredecessor->catch->finally->blockNr->foreach->b->setLinearScanNumber->try->indentBack->debug->logAndIndent->for->block->selectSuccessor->selectSuccessor->catch->finally->catch->finally->debug->log->return
BiDirectionalTraceBuilder#addBlockToTrace(DebugContext, AbstractBlockBase)::: bi directional trace builder add block to trace:::debug->block->getRelativeFrequency->log->processed->block->getId->set
BiDirectionalTraceBuilder#selectPredecessor(AbstractBlockBase)::: bi directional trace builder select predecessor:::next->foreach->block->getPredecessors->if->processed->isBackEdge->pred->getRelativeFrequency->next->getRelativeFrequency->return
BiDirectionalTraceBuilder#isBackEdge(AbstractBlockBase, AbstractBlockBase)::: bi directional trace builder is back edge:::return->from->isLoopEnd->to->isLoopHeader->from->getLoop->to->getLoop->equals
BiDirectionalTraceBuilder#selectSuccessor(AbstractBlockBase)::: bi directional trace builder select successor:::next->foreach->block->getSuccessors->if->processed->succ->getRelativeFrequency->next->getRelativeFrequency->return
ComputeBlockOrder#computeLinearScanOrder(int, T):::Computes the block order used for the linear scan register allocator.:::order->new->ArrayList<>->visitedBlocks->new->BitSet->worklist->initializeWorklist->computeLinearScanOrder->return->order->new->AbstractBlockBase<?>Arr->toArray
ComputeBlockOrder#computeCodeEmittingOrder(int, T):::Computes the block order used for code emission.:::order->new->ArrayList<>->visitedBlocks->new->BitSet->worklist->initializeWorklist->computeCodeEmittingOrder->return->order->new->AbstractBlockBase<?>Arr->toArray
ComputeBlockOrder#computeCodeEmittingOrder(List, PriorityQueue, BitSet):::Iteratively adds paths to the code emission block order.:::while->worklist->isEmpty->nextImportantPath->worklist->poll->addPathToCodeEmittingOrder
ComputeBlockOrder#computeLinearScanOrder(List, PriorityQueue, BitSet):::Iteratively adds paths to the linear scan block order.:::while->worklist->isEmpty->nextImportantPath->worklist->poll->do->addPathToLinearScanOrder->while
ComputeBlockOrder#initializeWorklist(T, BitSet):::Initializes the priority queue used for the work list of blocks and adds the start block.:::result->new->BlockOrderComparator<>->new->PriorityQueue<>->result->add->visitedBlocks->startBlock->getId->set->return
ComputeBlockOrder#addPathToLinearScanOrder(T, List, PriorityQueue, BitSet):::Add a linear path to the linear scan order greedily following the most likely successor.:::block->order->size->setLinearScanNumber->order->add->mostLikelySuccessor->findAndMarkMostLikelySuccessor->enqueueSuccessors->if->if->mostLikelySuccessor->isLoopHeader->mostLikelySuccessor->getPredecessorCount->unscheduledSum->foreach->mostLikelySuccessor->getPredecessors->if->pred->getLinearScanNumber->pred->getRelativeFrequency->if->block->getRelativeFrequency->visitedBlocks->mostLikelySuccessor->getId->clear->return->return->return
ComputeBlockOrder#addPathToCodeEmittingOrder(T, List, PriorityQueue, BitSet):::Add a linear path to the code emission order greedily following the most likely successor.:::block->while->if->skipLoopHeader->if->block->isLoopHeader->block->setAlign->addBlock->loop->block->getLoop->if->block->isLoopEnd->loop->getHeader->skipLoopHeader->loop->getHeader->addBlock->foreach->loop->getHeader->getSuccessors->if->successor->getLoopDepth->block->getLoopDepth->successor->setAlign->mostLikelySuccessor->findAndMarkMostLikelySuccessor->enqueueSuccessors
ComputeBlockOrder#addBlock(T, List):::Adds a block to the ordering.:::order->add
ComputeBlockOrder#findAndMarkMostLikelySuccessor(T, BitSet):::Find the highest likely unvisited successor block of a given block.:::result->foreach->block->getSuccessors->if->visitedBlocks->successor->getId->get->successor->getLoopDepth->block->getLoopDepth->successor->getRelativeFrequency->result->getRelativeFrequency->if->visitedBlocks->result->getId->set->return
ComputeBlockOrder#enqueueSuccessors(T, PriorityQueue, BitSet):::Add successor blocks into the given work list if they are not already marked as visited.:::foreach->block->getSuccessors->if->visitedBlocks->successor->getId->get->visitedBlocks->successor->getId->set->worklist->add
ComputeBlockOrder#skipLoopHeader(AbstractBlockBase):::Skip the loop header block if the loop consists of more than one block and it has only a single loop end block.:::return->block->isLoopHeader->block->isLoopEnd->block->getLoop->numBackedges
ComputeBlockOrder#checkOrder(List>, int):::Checks that the ordering contains the expected number of blocks.:::return
ComputeBlockOrder.BlockOrderComparator#compare(T, T)::: block order comparator compare:::if->a->getRelativeFrequency->b->getRelativeFrequency->diff->b->getLoopDepth->a->getLoopDepth->if->return->if->a->getRelativeFrequency->b->getRelativeFrequency->return->else->return
RegisterAllocationConfig.AllocatableRegisters#verify(RegisterArray, int, int)::: allocatable registers verify:::min->max->foreach->number->if->if->return
RegisterAllocationConfig#findRegister(String, RegisterArray)::: register allocation config find register:::foreach->if->equals->return->throw->new->IllegalArgumentException
RegisterAllocationConfig#initAllocatable(RegisterArray)::: register allocation config init allocatable:::if->regs->new->RegisterArr->for->i->return->new->RegisterArray->return
RegisterAllocationConfig#getAllocatableRegisters(PlatformKind):::Gets the set of registers that can be used by the register allocator for a value of a particular kind.:::key->kind->getKey->if->categorized->containsKey->val->categorized->get->return->ret->registerConfig->getAllocatableRegisters->filterAllocatableRegisters->createAllocatableRegisters->categorized->put->return
RegisterAllocationConfig#getRegisterCategory(PlatformKind):::Gets the RegisterCategory for the given PlatformKind.:::return->getAllocatableRegisters->getRegisterCategory
RegisterAllocationConfig#createAllocatableRegisters(RegisterArray)::: register allocation config create allocatable registers:::min->max->foreach->number->if->if->return->new->AllocatableRegisters
RegisterAllocationConfig#getAllocatableRegisters():::Gets the set of registers that can be used by the register allocator.:::if->registerConfig->getAllocatableRegisters->initAllocatable->return
RegisterAllocationConfig#getRegisterConfig()::: register allocation config get register config:::return
SingleBlockTraceBuilder#computeTraces(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: single block trace builder compute traces:::return->build
SingleBlockTraceBuilder#build(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: single block trace builder build:::blockToTrace->new->TraceArr->traces->new->ArrayList<>->foreach->trace->new->AbstractBlockBase<?>Arr->new->Trace->block->getId->block->setLinearScanNumber->trace->traces->size->setId->traces->add->return->TraceBuilderResult->create
Trace#getBlocks()::: trace get blocks:::return
Trace#getSuccessors()::: trace get successors:::return
Trace#size()::: trace size:::return->getBlocks
Trace#toString()::: trace to string:::return->Arrays->toString
Trace#getId()::: trace get id:::return
Trace#setId(int)::: trace set id:::
TraceBuilderResult.TrivialTracePredicate#isTrivialTrace(Trace)::: trivial trace predicate is trivial trace:::
TraceBuilderResult#create(DebugContext, AbstractBlockBase[], ArrayList, Trace[], TrivialTracePredicate)::: trace builder result create:::connect->newTraces->reorderTraces->traceBuilderResult->new->TraceBuilderResult->traceBuilderResult->numberTraces->return
TraceBuilderResult#getTraceForBlock(AbstractBlockBase)::: trace builder result get trace for block:::return->block->getId
TraceBuilderResult#getTraces()::: trace builder result get traces:::return
TraceBuilderResult#incomingEdges(Trace)::: trace builder result incoming edges:::return->trace->getId->trace->getBlocks->incomingEdges
TraceBuilderResult#incomingSideEdges(Trace)::: trace builder result incoming side edges:::traceArr->trace->getBlocks->if->return->return->trace->getId->incomingEdges
TraceBuilderResult#incomingEdges(int, AbstractBlockBase[], int)::: trace builder result incoming edges:::for->i->return
TraceBuilderResult#verify(TraceBuilderResult, int)::: trace builder result verify:::traces->traceBuilderResult->getTraces->for->i->traces->size->return
TraceBuilderResult#verifyAllBlocksScheduled(TraceBuilderResult, int)::: trace builder result verify all blocks scheduled:::traces->traceBuilderResult->getTraces->handled->new->BitSet->foreach->foreach->trace->getBlocks->handled->block->getId->set->return->handled->cardinality
TraceBuilderResult#numberTraces()::: trace builder result number traces:::for->i->traces->size
TraceBuilderResult#connect(ArrayList, Trace[])::: trace builder result connect:::numTraces->traces->size->foreach->added->new->BitSet->successors->trace->getSuccessors->foreach->trace->getBlocks->foreach->block->getSuccessors->succTrace->succ->getId->succId->succTrace->getId->if->added->get->added->set->successors->add
TraceBuilderResult#reorderTraces(DebugContext, ArrayList, TrivialTracePredicate)::: trace builder result reorder traces:::if->return->try->indent->debug->logAndIndent->newTraces->oldTraces->size->new->ArrayList<>->for->oldTraceIdx->oldTraces->size->return->catch->finally
TraceBuilderResult#alreadyProcessed(ArrayList, Trace)::: trace builder result already processed:::currentTraceId->currentTrace->getId->return->newTraces->size->newTraces->get
TraceBuilderResult#addTrace(ArrayList, Trace)::: trace builder result add trace:::currentTrace->newTraces->size->setId->newTraces->add
TraceMap#get(Trace)::: trace map get:::return->trace->getId
TraceMap#put(Trace, T)::: trace map put:::trace->getId
TraceStatisticsPrinter#printTraceStatistics(DebugContext, TraceBuilderResult, String)::: trace statistics printer print trace statistics:::try->s->debug->scope->if->debug->isLogEnabled->print->catch->debug->handle->finally
TraceStatisticsPrinter#print(DebugContext, TraceBuilderResult, String)::: trace statistics printer print:::traces->result->getTraces->numTraces->traces->size->try->indent0->debug->logAndIndent->debug->log->try->indent1->debug->logAndIndent->printRawLine->for->i->catch->finally->debug->log->catch->finally->debug->log
TraceStatisticsPrinter#printRawLine(DebugContext, Object, Object, Object, Object, Object)::: trace statistics printer print raw line:::debug->String->tracenr->toString->totalTime->toString->minProb->toString->maxProb->toString->numBlocks->toString->join->log
TraceStatisticsPrinter#printLine(DebugContext, int, double, double, double, int)::: trace statistics printer print line:::printRawLine
UniDirectionalTraceBuilder#computeTraces(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: uni directional trace builder compute traces:::return->new->UniDirectionalTraceBuilder->build
UniDirectionalTraceBuilder#compare(AbstractBlockBase, AbstractBlockBase)::: uni directional trace builder compare:::return->Double->b->getRelativeFrequency->a->getRelativeFrequency->compare
UniDirectionalTraceBuilder#processed(AbstractBlockBase)::: uni directional trace builder processed:::return->processed->b->getId->get
UniDirectionalTraceBuilder#build(DebugContext, AbstractBlockBase, AbstractBlockBase[], TrivialTracePredicate)::: uni directional trace builder build:::try->indent->debug->logAndIndent->traces->buildTraces->return->TraceBuilderResult->create->catch->finally
UniDirectionalTraceBuilder#buildTraces(DebugContext, AbstractBlockBase)::: uni directional trace builder build traces:::traces->new->ArrayList<>->worklist->add->while->worklist->isEmpty->block->worklist->poll->if->processed->trace->findTrace->new->Trace->foreach->trace->getBlocks->traceBlock->getId->trace->traces->size->setId->traces->add->return
UniDirectionalTraceBuilder#findTrace(DebugContext, AbstractBlockBase):::Build a new trace starting at block.:::trace->new->ArrayList<>->blockNumber->try->i->debug->logAndIndent->for->block->selectNext->catch->finally->return
UniDirectionalTraceBuilder#checkPredecessorsProcessed(AbstractBlockBase)::: uni directional trace builder check predecessors processed:::foreach->block->getPredecessors->return
UniDirectionalTraceBuilder#unblock(AbstractBlockBase):::Decrease the #blocked count for all predecessors and add them to the worklist once the count reaches 0.:::foreach->block->getSuccessors->if->processed->blockCount->successor->getId->if->worklist->add
UniDirectionalTraceBuilder#selectNext(AbstractBlockBase)::: uni directional trace builder select next:::next->foreach->block->getSuccessors->if->processed->successor->getRelativeFrequency->next->getRelativeFrequency->return
