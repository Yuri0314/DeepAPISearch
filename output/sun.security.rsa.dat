MGF1#generateAndXor(byte[], int, int, int, byte[], int):::Using the specified seed bytes, generate the mask, xor the mask with the specified output buffer and store the result into the output buffer (essentially replaced in place).:::C->new->byteArr->digest->md->getDigestLength->new->byteArr->while->md->update->md->update->try->md->digest->catch->throw->e->toString->new->RuntimeException->finally->for->i->if->for->i
MGF1#getName():::Returns the name of this MGF1 instance, i.e:::return->md->getAlgorithm
RSACore#getByteLength(BigInteger):::Return the number of bytes required to store the magnitude byte[] of this BigInteger:::n->b->bitLength->return
RSACore#getByteLength(RSAKey):::Return the number of bytes required to store the modulus of this RSA key.:::return->key->getModulus->getByteLength
RSACore#rsa(byte[], RSAPublicKey):::Perform an RSA public key operation.:::return->key->getModulus->key->getPublicExponent->crypt
RSACore#rsa(byte[], RSAPrivateKey):::Perform an RSA private key operation:::return->rsa
RSACore#rsa(byte[], RSAPrivateKey, boolean):::Perform an RSA private key operation:::if->return->crtCrypt->else->return->key->getModulus->key->getPrivateExponent->priCrypt
RSAKeyFactory#toRSAKey(Key):::Static method to convert Key into an instance of RSAPublicKeyImpl or RSAPrivate(Crt)KeyImpl:::if->throw->new->InvalidKeyException->if->return->else->try->type->KeyType->key->getAlgorithm->lookup->kf->RSAKeyFactory->getInstance->return->kf->engineTranslateKey->catch->throw->new->InvalidKeyException->finally
RSAKeyFactory#checkKeyLengths(int, BigInteger, int, int):::Check the length of an RSA key modulus/exponent to make sure it is not too short or long:::if->throw->new->InvalidKeyException->maxLen->Math->min->if->throw->new->InvalidKeyException->if->exponent->bitLength->throw->new->InvalidKeyException
RSAKeyFactory#engineTranslateKey(Key):::Translate an RSA key into a SunRsaSign RSA key:::if->throw->new->InvalidKeyException->type->keyAlgo->checkKeyAlgo->if->return->if->return->translatePublicKey->else->if->return->translatePrivateKey->else->throw->new->InvalidKeyException
RSAPadding#getInstance(int, int):::Get a RSAPadding instance of the specified type:::return->new->RSAPadding
RSAPadding#getInstance(int, int, SecureRandom):::Get a RSAPadding instance of the specified type:::return->new->RSAPadding
RSAPadding#getInstance(int, int, SecureRandom, OAEPParameterSpec):::Get a RSAPadding instance of the specified type, which must be OAEP:::return->new->RSAPadding
RSAPadding#getMaxDataSize():::Return the maximum size of the plaintext data that can be processed using this object.:::return
RSAPadding#pad(byte[], int, int):::Pad the data and return the padded block.:::return->RSACore->convert->pad
RSAPadding#pad(byte[]):::Pad the data and return the padded block.:::if->throw->new->BadPaddingException->switch->return->return->padV15->return->padOAEP->throw->new->AssertionError
RSAPadding#unpad(byte[], int, int):::Unpad the padded block and return the data.:::return->RSACore->convert->unpad
RSAPadding#unpad(byte[]):::Unpad the padded block and return the data.:::if->throw->new->BadPaddingException->switch->return->return->unpadV15->return->unpadOAEP->throw->new->AssertionError
RSAPrivateCrtKeyImpl#newKey(byte[]):::Generate a new key from its encoding:::key->new->RSAPrivateCrtKeyImpl->if->key->getPublicExponent->signum->key->getPrimeExponentP->signum->key->getPrimeExponentQ->signum->key->getPrimeP->signum->key->getPrimeQ->signum->key->getCrtCoefficient->signum->return->key->getModulus->key->getPrivateExponent->new->RSAPrivateKeyImpl->else->return
RSAPrivateCrtKeyImpl#newKey(KeyType, AlgorithmParameterSpec, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger):::Generate a new key from the specified type and components:::key->rsaId->RSAUtil->createAlgorithmId->if->e->signum->p->signum->q->signum->pe->signum->qe->signum->coeff->signum->return->new->RSAPrivateKeyImpl->else->return->new->RSAPrivateCrtKeyImpl
RSAPrivateCrtKeyImpl#parseKeyBits():::Parse the key:::try->in->new->DerInputStream->derValue->in->getDerValue->if->throw->new->IOException->data->version->data->getInteger->if->throw->new->IOException->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->data->getPositiveBigInteger->if->available->throw->new->IOException->catch->throw->new->InvalidKeyException->finally
RSAPublicKeyImpl#newKey(byte[]):::Generate a new RSAPublicKey from the specified encoding:::return->new->RSAPublicKeyImpl
RSAPublicKeyImpl#newKey(KeyType, AlgorithmParameterSpec, BigInteger, BigInteger):::Generate a new RSAPublicKey from the specified type and components:::rsaId->RSAUtil->createAlgorithmId->return->new->RSAPublicKeyImpl
RSAPublicKeyImpl#parseKeyBits():::Parse the key:::try->in->getKey->toByteArray->new->DerInputStream->derValue->in->getDerValue->if->throw->new->IOException->data->data->getPositiveBigInteger->data->getPositiveBigInteger->if->available->throw->new->IOException->catch->throw->new->InvalidKeyException->finally
RSASignature#encodeSignature(ObjectIdentifier, byte[]):::Encode the digest, return the to-be-signed data:::out->new->DerOutputStream->new->AlgorithmId->encode->out->putOctetString->result->out->toByteArray->new->DerValue->return->result->toByteArray
RSASignature#decodeSignature(ObjectIdentifier, byte[]):::Decode the signature data:::in->new->DerInputStream->values->in->getSequence->if->in->available->throw->new->IOException->algId->AlgorithmId->parse->if->algId->getOID->equals->throw->algId->getOID->new->IOException->if->algId->getEncodedParams->throw->new->IOException->digest->getOctetString->return
