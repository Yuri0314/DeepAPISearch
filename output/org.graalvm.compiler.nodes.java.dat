Plugin_ArrayLengthNode_arrayLength#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ array length node_array length execute:::arg0->node->new->org.graalvm.compiler.nodes.java.ArrayLengthNode->b->addPush->return
Plugin_ArrayLengthNode_arrayLength#getSource()::: plugin_ array length node_array length get source:::return
PluginFactory_ArrayLengthNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ array length node register plugins:::plugins->new->Plugin_ArrayLengthNode_arrayLength->register
Plugin_DynamicNewArrayNode_newArray__0#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ dynamic new array node_new array__0 execute:::arg0->arg1->arg2->if->isConstant->asJavaConstant->asInt->else->return->node->new->org.graalvm.compiler.nodes.java.DynamicNewArrayNode->b->addPush->return
Plugin_DynamicNewArrayNode_newArray__0#getSource()::: plugin_ dynamic new array node_new array__0 get source:::return
Plugin_DynamicNewArrayNode_newArray__1#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ dynamic new array node_new array__1 execute:::arg0->b->getMetaAccess->arg1->arg2->arg3->if->isConstant->asJavaConstant->asInt->else->return->arg4->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.java.DynamicNewArrayNode->b->addPush->return
Plugin_DynamicNewArrayNode_newArray__1#getSource()::: plugin_ dynamic new array node_new array__1 get source:::return
PluginFactory_DynamicNewArrayNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ dynamic new array node register plugins:::plugins->new->Plugin_DynamicNewArrayNode_newArray__0->register->plugins->new->Plugin_DynamicNewArrayNode_newArray__1->register
Plugin_InstanceOfNode_doInstanceof#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ instance of node_do instanceof execute:::arg0->if->isConstant->cst->asJavaConstant->b->getConstantReflection->asJavaType->if->snippetReflection->asObject->else->return->arg1->return->intrinsify
Plugin_InstanceOfNode_doInstanceof#getSource()::: plugin_ instance of node_do instanceof get source:::return
PluginFactory_InstanceOfNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ instance of node register plugins:::plugins->new->Plugin_InstanceOfNode_doInstanceof->register
Plugin_NewArrayNode_newArray#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ new array node_new array execute:::arg0->if->isConstant->cst->asJavaConstant->b->getConstantReflection->asJavaType->if->snippetReflection->asObject->else->return->arg1->arg2->if->isConstant->asJavaConstant->asInt->else->return->node->new->org.graalvm.compiler.nodes.java.NewArrayNode->b->addPush->return
Plugin_NewArrayNode_newArray#getSource()::: plugin_ new array node_new array get source:::return
PluginFactory_NewArrayNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ new array node register plugins:::plugins->new->Plugin_NewArrayNode_newArray->register
Plugin_RegisterFinalizerNode_register#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ register finalizer node_register execute:::arg0->node->new->org.graalvm.compiler.nodes.java.RegisterFinalizerNode->b->add->return
Plugin_RegisterFinalizerNode_register#getSource()::: plugin_ register finalizer node_register get source:::return
PluginFactory_RegisterFinalizerNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ register finalizer node register plugins:::plugins->new->Plugin_RegisterFinalizerNode_register->register
AbstractCompareAndSwapNode#stateAfter()::: abstract compare and swap node state after:::return
AbstractCompareAndSwapNode#setStateAfter(FrameState)::: abstract compare and swap node set state after:::updateUsages
AbstractCompareAndSwapNode#hasSideEffect()::: abstract compare and swap node has side effect:::return
AbstractCompareAndSwapNode#getExpectedValue()::: abstract compare and swap node get expected value:::return
AbstractCompareAndSwapNode#getNewValue()::: abstract compare and swap node get new value:::return
AbstractCompareAndSwapNode#canNullCheck()::: abstract compare and swap node can null check:::return
AbstractCompareAndSwapNode#getAccessStamp()::: abstract compare and swap node get access stamp:::return->expectedValue->stamp->newValue->stamp->meet->unrestricted
AbstractNewArrayNode#length()::: abstract new array node length:::return
AbstractNewArrayNode#findLength(FindLengthMode, ConstantReflectionProvider)::: abstract new array node find length:::return
AbstractNewArrayNode#dimension(int):::The list of node which produce input for this instruction.:::return->length
AbstractNewArrayNode#dimensionCount():::The rank of the array allocated by this node, i.e:::return
AbstractNewObjectNode#fillContents()::: abstract new object node fill contents:::return
AbstractNewObjectNode#lower(LoweringTool)::: abstract new object node lower:::tool->getLowerer->lower
AbstractNewObjectNode#canDeoptimize()::: abstract new object node can deoptimize:::return
AbstractNewObjectNode#emitMemoryBarrier()::: abstract new object node emit memory barrier:::return
AbstractNewObjectNode#clearEmitMemoryBarrier()::: abstract new object node clear emit memory barrier:::
AbstractUnsafeCompareAndSwapNode#object()::: abstract unsafe compare and swap node object:::return
AbstractUnsafeCompareAndSwapNode#offset()::: abstract unsafe compare and swap node offset:::return
AbstractUnsafeCompareAndSwapNode#expected()::: abstract unsafe compare and swap node expected:::return
AbstractUnsafeCompareAndSwapNode#newValue()::: abstract unsafe compare and swap node new value:::return
AbstractUnsafeCompareAndSwapNode#getValueKind()::: abstract unsafe compare and swap node get value kind:::return
AbstractUnsafeCompareAndSwapNode#getLocationIdentity()::: abstract unsafe compare and swap node get location identity:::return
AbstractUnsafeCompareAndSwapNode#lower(LoweringTool)::: abstract unsafe compare and swap node lower:::tool->getLowerer->lower
AbstractUnsafeCompareAndSwapNode#virtualize(VirtualizerTool)::: abstract unsafe compare and swap node virtualize:::offsetAlias->tool->getAlias->if->offsetAlias->isJavaConstant->return->constantOffset->offsetAlias->asJavaConstant->asLong->objectAlias->tool->getAlias->index->if->obj->field->obj->type->expected->getStackKind->findInstanceFieldWithOffset->if->tool->getDebug->log->return->obj->fieldIndex->else->if->array->array->tool->getMetaAccess->entryIndexForOffset->else->return->if->tool->getDebug->log->return->obj->currentValue->tool->getEntry->expectedAlias->tool->getAlias->equalsNode->if->valueKind->isObject->ObjectEqualsNode->graph->virtualizeComparison->if->CompareNode->tool->getConstantReflection->createCompareNode->if->tool->getDebug->log->return->newValueAlias->tool->getAlias->fieldValue->if->getValue->else->if->tool->getDebug->log->return->ConditionalNode->create->if->tool->setVirtualEntry->tool->getDebug->log->return->tool->getDebug->log->if->equalsNode->isAlive->tool->addNode->if->fieldValue->isAlive->tool->addNode->finishVirtualize
AbstractUnsafeCompareAndSwapNode#finishVirtualize(VirtualizerTool, LogicNode, ValueNode)::: abstract unsafe compare and swap node finish virtualize:::
AccessArrayNode#array()::: access array node array:::return
AccessArrayNode#setArray(ValueNode)::: access array node set array:::updateUsages
AccessFieldNode#object()::: access field node object:::return
AccessFieldNode#field():::Gets the compiler interface field for this field access.:::return
AccessFieldNode#isStatic():::Checks whether this field access is an access to a static field.:::return->field->isStatic
AccessFieldNode#isVolatile():::Checks whether this access has volatile semantics:::return
AccessFieldNode#lower(LoweringTool)::: access field node lower:::tool->getLowerer->lower
AccessFieldNode#toString(Verbosity)::: access field node to string:::if->return->super->toString->field->getName->else->return->super->toString
AccessFieldNode#verify()::: access field node verify:::isStatic->assertTrue->return->super->verify
AccessFieldNode#estimatedNodeSize()::: access field node estimated node size:::if->isVolatile->return->return->super->estimatedNodeSize
AccessIndexedNode#index()::: access indexed node index:::return
AccessIndexedNode#getBoundsCheck()::: access indexed node get bounds check:::return
AccessIndexedNode#elementKind():::Gets the element type of the array.:::return
AccessIndexedNode#lower(LoweringTool)::: access indexed node lower:::tool->getLowerer->lower
AccessMonitorNode#canDeoptimize()::: access monitor node can deoptimize:::return
AccessMonitorNode#stateBefore()::: access monitor node state before:::return
AccessMonitorNode#setStateBefore(FrameState)::: access monitor node set state before:::updateUsages
AccessMonitorNode#object()::: access monitor node object:::return
AccessMonitorNode#setObject(ValueNode)::: access monitor node set object:::updateUsages
AccessMonitorNode#getMonitorId()::: access monitor node get monitor id:::return
ArrayLengthNode#array()::: array length node array:::return
ArrayLengthNode#getValue()::: array length node get value:::return
ArrayLengthNode#create(ValueNode, ConstantReflectionProvider)::: array length node create:::if->newArray->return->newArray->length->length->readArrayLength->if->return->return->new->ArrayLengthNode
ArrayLengthNode#canonical(CanonicalizerTool, ValueNode)::: array length node canonical:::if->forValue->isNullConstant->return->new->DeoptimizeNode->length->tool->getConstantReflection->readArrayLength->if->return->return
ArrayLengthNode#readArrayLength(ValueNode, ConstantReflectionProvider):::Gets the length of an array if possible.:::return->GraphUtil->arrayLength
ArrayLengthNode#lower(LoweringTool)::: array length node lower:::tool->getLowerer->lower
ArrayLengthNode#arrayLength(Object)::: array length node array length:::
ArrayLengthNode#virtualize(VirtualizerTool)::: array length node virtualize:::alias->tool->array->getAlias->if->virtualArray->tool->ConstantNode->virtualArray->entryCount->graph->forInt->replaceWithValue
AtomicReadAndAddNode#delta()::: atomic read and add node delta:::return
AtomicReadAndAddNode#getLocationIdentity()::: atomic read and add node get location identity:::return
AtomicReadAndAddNode#generate(NodeLIRBuilderTool)::: atomic read and add node generate:::result->gen->getLIRGeneratorTool->gen->operand->gen->getLIRGeneratorTool->getValueKind->gen->operand->emitAtomicReadAndAdd->gen->setResult
AtomicReadAndWriteNode#object()::: atomic read and write node object:::return
AtomicReadAndWriteNode#offset()::: atomic read and write node offset:::return
AtomicReadAndWriteNode#newValue()::: atomic read and write node new value:::return
AtomicReadAndWriteNode#getValueKind()::: atomic read and write node get value kind:::return
AtomicReadAndWriteNode#getLocationIdentity()::: atomic read and write node get location identity:::return
AtomicReadAndWriteNode#lower(LoweringTool)::: atomic read and write node lower:::tool->getLowerer->lower
ClassIsAssignableFromNode#getThisClass()::: class is assignable from node get this class:::return->getX
ClassIsAssignableFromNode#getOtherClass()::: class is assignable from node get other class:::return->getY
ClassIsAssignableFromNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: class is assignable from node canonical:::if->forX->isConstant->forY->isConstant->constantReflection->tool->getConstantReflection->thisType->constantReflection->forX->asJavaConstant->asJavaType->otherType->constantReflection->forY->asJavaConstant->asJavaType->if->return->LogicConstantNode->thisType->isAssignableFrom->forBoolean->return
ClassIsAssignableFromNode#lower(LoweringTool)::: class is assignable from node lower:::tool->getLowerer->lower
ClassIsAssignableFromNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: class is assignable from node get succeeding stamp for x:::return
ClassIsAssignableFromNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: class is assignable from node get succeeding stamp for y:::return
ClassIsAssignableFromNode#tryFold(Stamp, Stamp)::: class is assignable from node try fold:::return
DynamicNewArrayNode#computeStamp(JavaKind, MetaAccessProvider)::: dynamic new array node compute stamp:::if->arrayType->metaAccess->knownElementKind->toJavaClass->lookupJavaType->getArrayClass->return->StampFactory->TypeReference->createWithoutAssumptions->objectNonNull->return->StampFactory->objectNonNull
DynamicNewArrayNode#getElementType()::: dynamic new array node get element type:::return
DynamicNewArrayNode#getKnownElementKind()::: dynamic new array node get known element kind:::return
DynamicNewArrayNode#canonical(CanonicalizerTool)::: dynamic new array node canonical:::if->elementType->isConstant->if->GeneratePIC->tool->getOptions->getValue->return->type->tool->getConstantReflection->elementType->asConstant->asJavaType->if->type->getArrayClass->throwsIllegalArgumentException->return->createNewArrayNode->return
DynamicNewArrayNode#createNewArrayNode(ResolvedJavaType):::Hook for subclasses to instantiate a subclass of NewArrayNode.:::return->length->fillContents->stateBefore->new->NewArrayNode
DynamicNewArrayNode#throwsIllegalArgumentException(Class, Class)::: dynamic new array node throws illegal argument exception:::return
DynamicNewArrayNode#throwsIllegalArgumentException(ResolvedJavaType)::: dynamic new array node throws illegal argument exception:::return->elementType->getJavaKind
DynamicNewArrayNode#newArray(Class, int, boolean)::: dynamic new array node new array:::
DynamicNewArrayNode#newArray(Class, int)::: dynamic new array node new array:::return->newArray
DynamicNewArrayNode#newArray(Class, int, boolean, JavaKind)::: dynamic new array node new array:::
DynamicNewArrayNode#newArray(Class, int, JavaKind)::: dynamic new array node new array:::return->newArray
DynamicNewArrayNode#newUninitializedArray(Class, int, JavaKind)::: dynamic new array node new uninitialized array:::return->newArray
DynamicNewArrayNode#getVoidClass()::: dynamic new array node get void class:::return
DynamicNewArrayNode#setVoidClass(ValueNode)::: dynamic new array node set void class:::updateUsages
DynamicNewInstanceNode#getInstanceType()::: dynamic new instance node get instance type:::return
DynamicNewInstanceNode#canonical(CanonicalizerTool)::: dynamic new instance node canonical:::if->clazz->isConstant->if->GeneratePIC->tool->getOptions->getValue->return->type->tool->getConstantReflection->clazz->asConstant->asJavaType->if->type->isInitialized->tool->getMetaAccess->throwsInstantiationException->return->createNewInstanceNode->return
DynamicNewInstanceNode#createNewInstanceNode(ResolvedJavaType):::Hook for subclasses to instantiate a subclass of NewInstanceNode.:::return->fillContents->stateBefore->new->NewInstanceNode
DynamicNewInstanceNode#throwsInstantiationException(Class, Class)::: dynamic new instance node throws instantiation exception:::return->type->isPrimitive->type->isArray->type->isInterface->Modifier->type->getModifiers->isAbstract
DynamicNewInstanceNode#throwsInstantiationException(ResolvedJavaType, MetaAccessProvider)::: dynamic new instance node throws instantiation exception:::return->type->isPrimitive->type->isArray->type->isInterface->Modifier->type->getModifiers->isAbstract->type->metaAccess->lookupJavaType->equals
DynamicNewInstanceNode#getClassClass()::: dynamic new instance node get class class:::return
DynamicNewInstanceNode#setClassClass(ValueNode)::: dynamic new instance node set class class:::updateUsages
ExceptionObjectNode#getLocationIdentity()::: exception object node get location identity:::return->LocationIdentity->any
ExceptionObjectNode#hasSideEffect():::An exception handler is an entry point to a method from the runtime and so represents an instruction that cannot be re-executed:::return
ExceptionObjectNode#lower(LoweringTool)::: exception object node lower:::if->graph->getGuardsStage->locationsKilledByInvoke->predecessor->getLocationIdentity->entry->graph->KillingBeginNode->create->add->loadException->graph->stamp->new->LoadExceptionObjectNode->add->loadException->stateAfter->setStateAfter->replaceAtUsages->graph->replaceFixedWithFixed->entry->graph->addAfterFixed->loadException->lower
ExceptionObjectNode#verify()::: exception object node verify:::stateAfter->assertTrue->stateAfter->stackSize->stateAfter->stackAt->stamp->getStackKind->assertTrue->return->super->verify
FinalFieldBarrierNode#getValue()::: final field barrier node get value:::return
FinalFieldBarrierNode#virtualize(VirtualizerTool)::: final field barrier node virtualize:::if->tool->getAlias->tool->delete
FinalFieldBarrierNode#lower(LoweringTool)::: final field barrier node lower:::graph->graph->new->MembarNode->add->replaceFixedWithFixed
InstanceOfDynamicNode#create(Assumptions, ConstantReflectionProvider, ValueNode, ValueNode, boolean, boolean)::: instance of dynamic node create:::synonym->findSynonym->if->return->return->new->InstanceOfDynamicNode
InstanceOfDynamicNode#create(Assumptions, ConstantReflectionProvider, ValueNode, ValueNode, boolean)::: instance of dynamic node create:::return->create
InstanceOfDynamicNode#isMirror()::: instance of dynamic node is mirror:::return->getMirrorOrHub->getStackKind
InstanceOfDynamicNode#isHub()::: instance of dynamic node is hub:::return->isMirror
InstanceOfDynamicNode#lower(LoweringTool)::: instance of dynamic node lower:::tool->getLowerer->lower
InstanceOfDynamicNode#findSynonym(Assumptions, ConstantReflectionProvider, ValueNode, ValueNode, boolean, boolean)::: instance of dynamic node find synonym:::if->forMirror->isConstant->t->constantReflection->forMirror->asConstant->asJavaType->if->if->t->isPrimitive->if->return->IsNullNode->create->else->return->LogicConstantNode->contradiction->else->type->TypeReference->createExactTrusted->TypeReference->createTrusted->if->return->InstanceOfNode->createAllowNull->else->return->InstanceOfNode->create->return
InstanceOfDynamicNode#getMirrorOrHub()::: instance of dynamic node get mirror or hub:::return->this->getX
InstanceOfDynamicNode#getObject()::: instance of dynamic node get object:::return->this->getY
InstanceOfDynamicNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: instance of dynamic node canonical:::result->tool->getAssumptions->tool->getConstantReflection->findSynonym->if->return->return
InstanceOfDynamicNode#setMirror(ValueNode)::: instance of dynamic node set mirror:::this->updateUsages
InstanceOfDynamicNode#allowsNull()::: instance of dynamic node allows null:::return
InstanceOfDynamicNode#isExact()::: instance of dynamic node is exact:::return
InstanceOfDynamicNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: instance of dynamic node get succeeding stamp for x:::return
InstanceOfDynamicNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: instance of dynamic node get succeeding stamp for y:::return
InstanceOfDynamicNode#tryFold(Stamp, Stamp)::: instance of dynamic node try fold:::return
InstanceOfNode#createAllowNull(TypeReference, ValueNode, JavaTypeProfile, AnchoringNode)::: instance of node create allow null:::if->StampTool->isPointerNonNull->return->create->return->StampFactory->object->createHelper
InstanceOfNode#create(TypeReference, ValueNode)::: instance of node create:::return->create
InstanceOfNode#create(TypeReference, ValueNode, JavaTypeProfile, AnchoringNode)::: instance of node create:::return->StampFactory->objectNonNull->createHelper
InstanceOfNode#createHelper(ObjectStamp, ValueNode, JavaTypeProfile, AnchoringNode)::: instance of node create helper:::synonym->findSynonym->if->return->else->return->new->InstanceOfNode
InstanceOfNode#lower(LoweringTool)::: instance of node lower:::tool->getLowerer->lower
InstanceOfNode#canonical(CanonicalizerTool, ValueNode)::: instance of node canonical:::view->NodeView->from->synonym->findSynonym->if->return->else->return
InstanceOfNode#findSynonym(ObjectStamp, ValueNode, NodeView)::: instance of node find synonym:::inputStamp->object->stamp->joinedStamp->checkedStamp->join->if->joinedStamp->isEmpty->return->LogicConstantNode->contradiction->else->meetStamp->checkedStamp->meet->if->checkedStamp->equals->return->LogicConstantNode->tautology->else->if->checkedStamp->alwaysNull->return->IsNullNode->create->else->if->Objects->checkedStamp->type->meetStamp->type->equals->checkedStamp->isExactType->meetStamp->isExactType->checkedStamp->alwaysNull->meetStamp->alwaysNull->if->checkedStamp->nonNull->return->LogicNegationNode->IsNullNode->create->create->else->return->IsNullNode->create->return
InstanceOfNode#type():::Gets the type being tested.:::return->StampTool->typeReferenceOrNull
InstanceOfNode#profile()::: instance of node profile:::return
InstanceOfNode#virtualize(VirtualizerTool)::: instance of node virtualize:::alias->tool->getValue->getAlias->fold->alias->stamp->tryFold->if->tool->LogicConstantNode->fold->isTrue->graph->forBoolean->replaceWithValue
InstanceOfNode#getSucceedingStampForValue(boolean)::: instance of node get succeeding stamp for value:::if->return->else->return
InstanceOfNode#tryFold(Stamp)::: instance of node try fold:::if->inputStamp->joinedStamp->checkedStamp->join->if->joinedStamp->isEmpty->return->else->meetStamp->checkedStamp->meet->if->checkedStamp->equals->return->return
InstanceOfNode#allowsNull()::: instance of node allows null:::return->checkedStamp->nonNull
InstanceOfNode#setProfile(JavaTypeProfile, AnchoringNode)::: instance of node set profile:::updateUsagesInterface
InstanceOfNode#getAnchor()::: instance of node get anchor:::return
InstanceOfNode#getCheckedStamp()::: instance of node get checked stamp:::return
InstanceOfNode#doInstanceof(ResolvedJavaType, Object)::: instance of node do instanceof:::
InstanceOfNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ResolvedJavaType, ValueNode)::: instance of node intrinsify:::node->StampFactory->TypeReference->b->getAssumptions->create->objectNonNull->new->InstanceOfNode->b->add->b->ConditionalNode->create->addPush->return
InstanceOfNode#implies(boolean, LogicNode)::: instance of node implies:::if->instanceOfNode->if->instanceOfNode->getValue->getValue->if->if->this->getCheckedStamp->instanceOfNode->getCheckedStamp->meet->this->getCheckedStamp->equals->return->TriState->get->else->if->instanceOfNode->getCheckedStamp->this->getCheckedStamp->meet->instanceOfNode->getCheckedStamp->equals->return->TriState->get->return->super->implies
LoadExceptionObjectNode#lower(LoweringTool)::: load exception object node lower:::tool->getLowerer->lower
LoadFieldNode#create(Assumptions, ValueNode, ResolvedJavaField)::: load field node create:::return->field->isVolatile->create
LoadFieldNode#create(Assumptions, ValueNode, ResolvedJavaField, boolean)::: load field node create:::return->StampFactory->field->getType->forDeclaredType->new->LoadFieldNode
LoadFieldNode#create(ConstantFieldProvider, ConstantReflectionProvider, MetaAccessProvider, OptionValues, Assumptions, ValueNode, ResolvedJavaField, boolean, boolean)::: load field node create:::return->StampFactory->field->getType->forDeclaredType->canonical
LoadFieldNode#createOverrideStamp(StampPair, ValueNode, ResolvedJavaField)::: load field node create override stamp:::return->new->LoadFieldNode
LoadFieldNode#createOverrideStamp(ConstantFieldProvider, ConstantReflectionProvider, MetaAccessProvider, OptionValues, StampPair, ValueNode, ResolvedJavaField, boolean, boolean)::: load field node create override stamp:::return->canonical
LoadFieldNode#getValue()::: load field node get value:::return->object
LoadFieldNode#canonical(CanonicalizerTool, ValueNode)::: load field node canonical:::view->NodeView->from->if->tool->allUsagesAvailable->hasNoUsages->isVolatile->if->isStatic->StampTool->forObject->stamp->isPointerNonNull->return->if->graph->getGuardsStage->allowsGuardInsertion->return->new->IsNullNode->getNodeSourcePosition->new->FixedGuardNode->return->StampPair->create->tool->getConstantFieldProvider->tool->getConstantReflection->tool->getOptions->tool->getMetaAccess->tool->canonicalizeReads->tool->allUsagesAvailable->canonical
LoadFieldNode#canonical(LoadFieldNode, StampPair, ValueNode, ResolvedJavaField, ConstantFieldProvider, ConstantReflectionProvider, OptionValues, MetaAccessProvider, boolean, boolean)::: load field node canonical:::self->if->constant->asConstant->if->return->if->phi->stamp->getTrustedStamp->asPhi->if->return->if->field->isStatic->forObject->isNullConstant->return->new->DeoptimizeNode->if->new->LoadFieldNode->return
LoadFieldNode#asConstant(CanonicalizerTool, ValueNode):::Gets a constant value for this load if possible.:::return->tool->getConstantFieldProvider->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->asConstant
LoadFieldNode#asConstant(ConstantFieldProvider, ConstantReflectionProvider, MetaAccessProvider, OptionValues, ValueNode, ResolvedJavaField)::: load field node as constant:::if->field->isStatic->return->ConstantFoldUtil->tryConstantFold->else->if->forObject->isConstant->forObject->isNullConstant->return->ConstantFoldUtil->forObject->asJavaConstant->tryConstantFold->return
LoadFieldNode#asConstant(CanonicalizerTool, JavaConstant)::: load field node as constant:::return->ConstantFoldUtil->tool->getConstantFieldProvider->tool->getConstantReflection->tool->getMetaAccess->field->tool->getOptions->tryConstantFold
LoadFieldNode#asPhi(ConstantFieldProvider, ConstantReflectionProvider, MetaAccessProvider, OptionValues, ValueNode, ResolvedJavaField, Stamp)::: load field node as phi:::if->field->isStatic->field->isFinal->values->isNotA->filter->isEmpty->phi->constantNodes->phi->valueCount->new->ConstantNodeArr->for->i->phi->valueCount->return->phi->merge->new->ValuePhiNode->return
LoadFieldNode#virtualize(VirtualizerTool)::: load field node virtualize:::alias->tool->object->getAlias->if->fieldIndex->field->fieldIndex->if->entry->tool->getEntry->if->stamp->entry->stamp->isCompatible->tool->replaceWith->else
LoadFieldNode#uncheckedStamp()::: load field node unchecked stamp:::return
LoadFieldNode#setObject(ValueNode)::: load field node set object:::this->updateUsages
LoadFieldNode#estimatedNodeCycles()::: load field node estimated node cycles:::if->isVolatile->return->return->super->estimatedNodeCycles
LoadIndexedNode#create(Assumptions, ValueNode, ValueNode, GuardingNode, JavaKind, MetaAccessProvider, ConstantReflectionProvider)::: load indexed node create:::constant->tryConstantFold->if->return->return->new->LoadIndexedNode
LoadIndexedNode#createStamp(Assumptions, ValueNode, JavaKind)::: load indexed node create stamp:::type->StampTool->typeOrNull->if->type->isArray->return->StampFactory->TypeReference->type->getComponentType->createTrusted->object->else->preciseKind->determinePreciseArrayElementType->return->StampFactory->forKind
LoadIndexedNode#determinePreciseArrayElementType(ValueNode, JavaKind)::: load indexed node determine precise array element type:::if->javaType->array->stamp->type->if->javaType->isArray->javaType->getComponentType->javaType->getComponentType->getJavaKind->return->return
LoadIndexedNode#inferStamp()::: load indexed node infer stamp:::return->stamp->graph->getAssumptions->array->elementKind->createStamp->improveWith->updateStamp
LoadIndexedNode#virtualize(VirtualizerTool)::: load indexed node virtualize:::alias->tool->array->getAlias->if->virtual->indexValue->tool->index->getAlias->idx->indexValue->isConstant->indexValue->asJavaConstant->asInt->if->virtual->entryCount->entry->tool->getEntry->if->stamp->entry->stamp->isCompatible->tool->replaceWith->else
LoadIndexedNode#canonical(CanonicalizerTool)::: load indexed node canonical:::if->array->isNullConstant->return->new->DeoptimizeNode->constant->array->index->tool->getMetaAccess->tool->getConstantReflection->tryConstantFold->if->return->return
LoadIndexedNode#simplify(SimplifierTool)::: load indexed node simplify:::if->tool->allUsagesAvailable->hasNoUsages->view->NodeView->from->arrayLength->ArrayLengthNode->tool->getConstantReflection->create->boundsCheck->CompareNode->tool->getConstantReflection->createCompareNode->if->boundsCheck->isTautology->return->if->graph->getGuardsStage->allowsGuardInsertion->if->arrayLength->isAlive->graph->addOrUniqueWithInputs->if->fixedArrayLength->graph->addBeforeFixed->graph->addOrUniqueWithInputs->fixedGuard->getNodeSourcePosition->new->FixedGuardNode->graph->graph->add->replaceFixedWithFixed
LoadIndexedNode#tryConstantFold(ValueNode, ValueNode, MetaAccessProvider, ConstantReflectionProvider)::: load indexed node try constant fold:::if->array->isConstant->array->isNullConstant->index->isConstant->arrayConstant->array->asJavaConstant->if->stableDimension->getStableDimension->if->constant->constantReflection->index->asJavaConstant->asInt->readArrayElement->isDefaultStable->isDefaultStable->if->constant->isDefaultForKind->return->ConstantNode->forConstant->return
LogicCompareAndSwapNode#generate(NodeLIRBuilderTool)::: logic compare and swap node generate:::tool->gen->getLIRGeneratorTool->resultKind->tool->stamp->getLIRKind->trueResult->tool->emitConstant->falseResult->tool->emitConstant->result->tool->tool->getAccessStamp->getLIRKind->gen->getAddress->operand->gen->getExpectedValue->operand->gen->getNewValue->operand->emitLogicCompareAndSwap->gen->setResult
LoweredAtomicReadAndWriteNode#stateAfter()::: lowered atomic read and write node state after:::return
LoweredAtomicReadAndWriteNode#setStateAfter(FrameState)::: lowered atomic read and write node set state after:::updateUsages
LoweredAtomicReadAndWriteNode#hasSideEffect()::: lowered atomic read and write node has side effect:::return
LoweredAtomicReadAndWriteNode#generate(NodeLIRBuilderTool)::: lowered atomic read and write node generate:::emitted->gen->getNewValue->operand->actualKind->newValue->stamp->getStackKind->isObject->emitted->getValueKind->result->gen->getLIRGeneratorTool->gen->getAddress->operand->emitAtomicReadAndWrite->gen->setResult
LoweredAtomicReadAndWriteNode#canNullCheck()::: lowered atomic read and write node can null check:::return
LoweredAtomicReadAndWriteNode#getNewValue()::: lowered atomic read and write node get new value:::return
LoweredAtomicReadAndWriteNode#getAccessStamp()::: lowered atomic read and write node get access stamp:::return->stamp
MethodCallTargetNode#receiver():::Gets the instruction that produces the receiver object for this invocation, if any.:::return->isStatic->arguments->get
MethodCallTargetNode#isStatic():::Checks whether this is an invocation of a static method.:::return->invokeKind
MethodCallTargetNode#returnKind()::: method call target node return kind:::return->targetMethod->getSignature->getReturnKind
MethodCallTargetNode#verify()::: method call target node verify:::foreach->usages->assertTrue->if->invokeKind->isDirect->targetMethod->isConcrete->targetMethod->assertTrue->if->invokeKind->targetMethod->isStatic->targetMethod->assertTrue->else->targetMethod->isStatic->targetMethod->assertFalse->return->super->verify
MethodCallTargetNode#toString(Verbosity)::: method call target node to string:::if->return->super->toString->targetMethod->else->return->super->toString
MethodCallTargetNode#findSpecialCallTarget(InvokeKind, ValueNode, ResolvedJavaMethod, ResolvedJavaType)::: method call target node find special call target:::if->invokeKind->isDirect->return->if->targetMethod->canBeStaticallyBound->return->return->receiver->graph->getAssumptions->receiver->stamp->devirtualizeCall
MethodCallTargetNode#devirtualizeCall(InvokeKind, ResolvedJavaMethod, ResolvedJavaType, Assumptions, Stamp)::: method call target node devirtualize call:::type->StampTool->typeReferenceOrNull->if->TypeReference->targetMethod->getDeclaringClass->createTrusted->if->resolvedMethod->type->getType->resolveConcreteMethod->if->resolvedMethod->canBeStaticallyBound->type->isExact->type->getType->isArray->return->uniqueConcreteMethod->type->getType->findUniqueConcreteMethod->if->uniqueConcreteMethod->canRecordTo->uniqueConcreteMethod->recordTo->return->uniqueConcreteMethod->getResult->return
MethodCallTargetNode#simplify(SimplifierTool)::: method call target node simplify:::if->invoke->getContextMethod->return->contextType->invoke->stateAfter->invoke->stateDuring->invoke->getContextType->specialCallTarget->receiver->findSpecialCallTarget->if->this->setTargetMethod->setInvokeKind->return->assumptions->graph->getAssumptions->if->invokeKind->isIndirect->invokeKind->isInterface->receiver->receiver->declaredReceiverType->targetMethod->getDeclaringClass->if->declaredReceiverType->isInterface->singleImplementor->declaredReceiverType->getSingleImplementor->if->singleImplementor->equals->speculatedType->TypeReference->createTrusted->if->tryCheckCastSingleImplementor->return->if->uncheckedInterfaceProvider->uncheckedStamp->uncheckedInterfaceProvider->uncheckedStamp->if->speculatedType->StampTool->typeReferenceOrNull->if->tryCheckCastSingleImplementor
MethodCallTargetNode#tryCheckCastSingleImplementor(ValueNode, TypeReference)::: method call target node try check cast single implementor:::singleImplementor->speculatedType->getType->if->singleImplementorMethod->singleImplementor->targetMethod->invoke->getContextType->resolveConcreteMethod->if->anchor->BeginNode->invoke->asNode->prevBegin->condition->graph->InstanceOfNode->getProfile->create->addOrUniqueWithInputs->guard->graph->new->FixedGuardNode->add->graph->invoke->asNode->addBeforeFixed->valueNode->graph->StampFactory->objectNonNull->new->PiNode->addOrUnique->arguments->set->if->speculatedType->isExact->setInvokeKind->else->setInvokeKind->setTargetMethod->return->return
MethodCallTargetNode#getProfile()::: method call target node get profile:::return
MethodCallTargetNode#targetName()::: method call target node target name:::if->targetMethod->return->return->targetMethod->format
MethodCallTargetNode#find(StructuredGraph, ResolvedJavaMethod)::: method call target node find:::foreach->graph->getNodes->if->target->targetMethod->equals->return->return
MethodCallTargetNode#setJavaTypeProfile(JavaTypeProfile)::: method call target node set java type profile:::
MonitorEnterNode#getLocationIdentity()::: monitor enter node get location identity:::return->LocationIdentity->any
MonitorEnterNode#lower(LoweringTool)::: monitor enter node lower:::tool->getLowerer->lower
MonitorEnterNode#virtualize(VirtualizerTool)::: monitor enter node virtualize:::alias->tool->object->getAlias->if->virtual->if->virtual->hasIdentity->tool->getMonitorId->addLock->tool->delete
MonitorExitNode#clearEscapedValue():::Return value is cleared when a synchronized method graph is inlined.:::updateUsages
MonitorExitNode#getLocationIdentity()::: monitor exit node get location identity:::return->LocationIdentity->any
MonitorExitNode#lower(LoweringTool)::: monitor exit node lower:::tool->getLowerer->lower
MonitorExitNode#virtualize(VirtualizerTool)::: monitor exit node virtualize:::alias->tool->object->getAlias->if->virtual->if->virtual->hasIdentity->removedLock->tool->removeLock->tool->delete
MonitorIdNode#getLockDepth()::: monitor id node get lock depth:::return
MonitorIdNode#setLockDepth(int)::: monitor id node set lock depth:::
MonitorIdNode#isEliminated()::: monitor id node is eliminated:::return
MonitorIdNode#setEliminated()::: monitor id node set eliminated:::
MonitorIdNode#generate(NodeLIRBuilderTool)::: monitor id node generate:::
NewArrayNode#newArray(Class, int, boolean)::: new array node new array:::
NewArrayNode#newUninitializedArray(Class, int)::: new array node new uninitialized array:::return->newArray
NewArrayNode#elementType():::Gets the element type of the array.:::return
NewArrayNode#virtualize(VirtualizerTool)::: new array node virtualize:::lengthAlias->tool->length->getAlias->if->lengthAlias->asConstant->constantLength->lengthAlias->asJavaConstant->asInt->if->tool->getMaximumEntryCount->state->new->ValueNodeArr->defaultForKind->defaultElementValue->for->i->virtualObject->createVirtualArrayNode->tool->Collections->emptyList->createVirtualObject->tool->replaceWithVirtual
NewArrayNode#createVirtualArrayNode(int)::: new array node create virtual array node:::return->elementType->new->VirtualArrayNode
NewArrayNode#defaultElementValue()::: new array node default element value:::return->ConstantNode->elementType->getJavaKind->graph->defaultForKind
NewArrayNode#simplify(SimplifierTool)::: new array node simplify:::if->hasNoUsages->view->NodeView->from->lengthStamp->length->stamp->if->lengthIntegerStamp->if->lengthIntegerStamp->isPositive->GraphUtil->removeFixedWithUnusedInputs->return->if->graph->getGuardsStage->allowsFloatingGuards->try->context->this->withNodeSourcePosition->lengthNegativeCondition->CompareNode->graph->length->ConstantNode->graph->forInt->tool->getConstantReflection->createCompareNode->guard->graph->new->FixedGuardNode->add->graph->replaceFixedWithFixed->catch->finally
NewInstanceNode#instanceClass():::Gets the instance class being allocated by this node.:::return
NewInstanceNode#virtualize(VirtualizerTool)::: new instance node virtualize:::if->tool->getMetaAccess->lookupJavaType->isAssignableFrom->virtualObject->createVirtualInstanceNode->fields->virtualObject->getFields->state->new->ValueNodeArr->for->i->tool->Collections->emptyList->createVirtualObject->tool->replaceWithVirtual
NewInstanceNode#createVirtualInstanceNode(boolean)::: new instance node create virtual instance node:::return->instanceClass->new->VirtualInstanceNode
NewInstanceNode#defaultFieldValue(ResolvedJavaField)::: new instance node default field value:::return->ConstantNode->field->getType->getJavaKind->graph->defaultForKind
NewMultiArrayNode#dimension(int)::: new multi array node dimension:::return->dimensions->get
NewMultiArrayNode#dimensionCount()::: new multi array node dimension count:::return->dimensions->size
NewMultiArrayNode#dimensions()::: new multi array node dimensions:::return
NewMultiArrayNode#lower(LoweringTool)::: new multi array node lower:::tool->getLowerer->lower
NewMultiArrayNode#type()::: new multi array node type:::return
NewMultiArrayNode#canDeoptimize()::: new multi array node can deoptimize:::return
NewMultiArrayNode#findLength(FindLengthMode, ConstantReflectionProvider)::: new multi array node find length:::return->dimension
RawMonitorEnterNode#getLocationIdentity()::: raw monitor enter node get location identity:::return->LocationIdentity->any
RawMonitorEnterNode#lower(LoweringTool)::: raw monitor enter node lower:::tool->getLowerer->lower
RawMonitorEnterNode#virtualize(VirtualizerTool)::: raw monitor enter node virtualize:::alias->tool->object->getAlias->if->virtual->if->virtual->hasIdentity->tool->getMonitorId->addLock->tool->delete
RawMonitorEnterNode#getHub()::: raw monitor enter node get hub:::return
RegisterFinalizerNode#getValue()::: register finalizer node get value:::return
RegisterFinalizerNode#generate(NodeLIRBuilderTool)::: register finalizer node generate:::linkage->gen->getLIRGeneratorTool->getForeignCalls->lookupForeignCall->gen->getLIRGeneratorTool->gen->state->gen->getValue->operand->emitForeignCall
RegisterFinalizerNode#mayHaveFinalizer(ValueNode, Assumptions):::Determines if the compiler should emit code to test whether a given object has a finalizer that must be registered with the runtime upon object initialization.:::objectStamp->object->stamp->if->objectStamp->isExactType->return->objectStamp->type->hasFinalizer->else->if->objectStamp->type->result->objectStamp->type->hasFinalizableSubclass->if->result->canRecordTo->result->recordTo->return->result->getResult->return
RegisterFinalizerNode#canonical(CanonicalizerTool, ValueNode)::: register finalizer node canonical:::view->NodeView->from->if->forValue->stamp->return->if->graph->getAssumptions->mayHaveFinalizer->return->return
RegisterFinalizerNode#virtualize(VirtualizerTool)::: register finalizer node virtualize:::alias->tool->getValue->getAlias->if->type->hasFinalizer->tool->delete
RegisterFinalizerNode#canDeoptimize()::: register finalizer node can deoptimize:::return
RegisterFinalizerNode#register(Object)::: register finalizer node register:::
StoreFieldNode#stateAfter()::: store field node state after:::return
StoreFieldNode#setStateAfter(FrameState)::: store field node set state after:::updateUsages
StoreFieldNode#hasSideEffect()::: store field node has side effect:::return
StoreFieldNode#value()::: store field node value:::return
StoreFieldNode#virtualize(VirtualizerTool)::: store field node virtualize:::alias->tool->object->getAlias->if->virtual->fieldIndex->virtual->field->fieldIndex->if->tool->value->setVirtualEntry->tool->delete
StoreFieldNode#getState()::: store field node get state:::return
StoreFieldNode#estimatedNodeCycles()::: store field node estimated node cycles:::if->isVolatile->return->return->super->estimatedNodeCycles
StoreFieldNode#canonical(CanonicalizerTool)::: store field node canonical:::if->field->isStatic->object->isNullConstant->return->new->DeoptimizeNode->return
StoreIndexedNode#getStoreCheck()::: store indexed node get store check:::return
StoreIndexedNode#stateAfter()::: store indexed node state after:::return
StoreIndexedNode#setStateAfter(FrameState)::: store indexed node set state after:::updateUsages
StoreIndexedNode#hasSideEffect()::: store indexed node has side effect:::return
StoreIndexedNode#value()::: store indexed node value:::return
StoreIndexedNode#virtualize(VirtualizerTool)::: store indexed node virtualize:::alias->tool->array->getAlias->if->indexValue->tool->index->getAlias->idx->indexValue->isConstant->indexValue->asJavaConstant->asInt->virtual->if->virtual->entryCount->componentType->virtual->type->getComponentType->if->componentType->isPrimitive->StampTool->isPointerAlwaysNull->componentType->isJavaLangObject->StampTool->typeReferenceOrNull->componentType->StampTool->typeOrNull->isAssignableFrom->tool->value->setVirtualEntry->tool->delete
StoreIndexedNode#getState()::: store indexed node get state:::return
StoreIndexedNode#canonical(CanonicalizerTool)::: store indexed node canonical:::if->array->isNullConstant->return->new->DeoptimizeNode->return
TypeSwitchNode#assertKeys():::Don't allow duplicate keys.:::for->i->return
TypeSwitchNode#isSorted()::: type switch node is sorted:::return
TypeSwitchNode#keyCount()::: type switch node key count:::return
TypeSwitchNode#keyAt(int)::: type switch node key at:::return
TypeSwitchNode#equalKeys(SwitchNode)::: type switch node equal keys:::if->return->other->return->Arrays->equals
TypeSwitchNode#typeAt(int)::: type switch node type at:::return
TypeSwitchNode#generate(NodeLIRBuilderTool)::: type switch node generate:::gen->emitSwitch
TypeSwitchNode#simplify(SimplifierTool)::: type switch node simplify:::view->NodeView->from->if->value->constant->value->asConstant->survivingEdge->keyCount->keySuccessorIndex->for->i->keyCount->killOtherSuccessors->if->value->value->getValue->stamp->objectStamp->value->getValue->stamp->if->objectStamp->type->validKeys->for->i->keyCount->if->tool->defaultSuccessor->addToWorkList->graph->defaultSuccessor->removeSplitPropagate->else->if->newSuccessors->blockSuccessorCount->new->ArrayList<>->newKeys->new->ResolvedJavaTypeArr->newKeySuccessors->new->intArr->newKeyProbabilities->new->doubleArr->totalProbability->current->for->i->keyCount->if->for->i->else->for->i->oldSuccessors->new->ArrayList<>->for->i->blockSuccessorCount->successorsArray->newSuccessors->newSuccessors->size->new->AbstractBeginNodeArr->toArray->newSwitch->graph->value->tool->getConstantReflection->new->TypeSwitchNode->add->predecessor->setNext->GraphUtil->killWithUnusedFloatingInputs->for->i->oldSuccessors->size
TypeSwitchNode#getValueStampForSuccessor(AbstractBeginNode)::: type switch node get value stamp for successor:::result->if->defaultSuccessor->for->i->keyCount->return
UnsafeCompareAndExchangeNode#meetInputs(Stamp, Stamp)::: unsafe compare and exchange node meet inputs:::return->expected->unrestricted->newValue->unrestricted->meet
UnsafeCompareAndExchangeNode#finishVirtualize(VirtualizerTool, LogicNode, ValueNode)::: unsafe compare and exchange node finish virtualize:::tool->replaceWith
UnsafeCompareAndSwapNode#finishVirtualize(VirtualizerTool, LogicNode, ValueNode)::: unsafe compare and swap node finish virtualize:::result->ConditionalNode->ConstantNode->graph->forBoolean->ConstantNode->graph->forBoolean->create->if->result->isAlive->tool->addNode->tool->replaceWith
ValueCompareAndSwapNode#generate(NodeLIRBuilderTool)::: value compare and swap node generate:::tool->gen->getLIRGeneratorTool->gen->tool->tool->getAccessStamp->getLIRKind->gen->getAddress->operand->gen->getExpectedValue->operand->gen->getNewValue->operand->emitValueCompareAndSwap->setResult
