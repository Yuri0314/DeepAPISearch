AcceptSecContextToken#encode()::: accept sec context token encode:::apRepBytes->apRep->getMessage->retVal->new->byteArr->writeInt->System->arraycopy->return
CipherHelper#getSgnAlg()::: cipher helper get sgn alg:::return
CipherHelper#getSealAlg()::: cipher helper get seal alg:::return
CipherHelper#getProto()::: cipher helper get proto:::return->EType->isNewer
CipherHelper#getEType()::: cipher helper get type:::return
CipherHelper#isArcFour()::: cipher helper is arc four:::flag->if->return
CipherHelper#calculateChecksum(int, byte[], byte[], byte[], int, int, int)::: cipher helper calculate checksum:::switch->try->md5->MessageDigest->getInstance->md5->update->md5->update->if->md5->update->md5->digest->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->return->getDesCbcChecksum->buf->offset->total->if->else->new->byteArr->pos->if->System->arraycopy->System->arraycopy->if->System->arraycopy->try->answer->Des3->calculateChecksum->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->buffer->off->tot->if->else->new->byteArr->pos->if->System->arraycopy->System->arraycopy->if->System->arraycopy->try->key_usage->if->answer->ArcFourHmac->calculateChecksum->output->getChecksumLength->new->byteArr->System->arraycopy->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->throw->new->GSSException
CipherHelper#calculateChecksum(byte[], byte[], int, int, int)::: cipher helper calculate checksum:::total->buf->new->byteArr->System->arraycopy->if->System->arraycopy->switch->try->answer->Aes128->calculateChecksum->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->try->answer->Aes256->calculateChecksum->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->try->answer->Aes128Sha2->calculateChecksum->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->try->answer->Aes256Sha2->calculateChecksum->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->throw->new->GSSException
CipherHelper#encryptSeq(byte[], byte[], int, int)::: cipher helper encrypt seq:::switch->try->des->getInitializedDes->return->des->doFinal->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->iv->if->else->new->byteArr->System->arraycopy->try->return->Des3->encryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->checksum->if->else->new->byteArr->System->arraycopy->try->return->ArcFourHmac->encryptSeq->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->throw->new->GSSException
CipherHelper#decryptSeq(byte[], byte[], int, int)::: cipher helper decrypt seq:::switch->try->des->getInitializedDes->return->des->doFinal->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->iv->if->else->new->byteArr->System->arraycopy->try->return->Des3->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->checksum->if->else->new->byteArr->System->arraycopy->try->return->ArcFourHmac->decryptSeq->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->throw->new->GSSException
CipherHelper#getChecksumLength()::: cipher helper get checksum length:::switch->return->return->Des3->getChecksumLength->return->Aes128->getChecksumLength->return->Aes256->getChecksumLength->return->Aes128Sha2->getChecksumLength->return->Aes256Sha2->getChecksumLength->return->throw->new->GSSException
CipherHelper#decryptData(WrapToken, byte[], int, int, byte[], int)::: cipher helper decrypt data:::switch->getDesEncryptionKey->desCbcDecrypt->break->des3KdDecrypt->break->arcFourDecrypt->break->throw->new->GSSException
CipherHelper#decryptData(WrapToken_v2, byte[], int, int, byte[], int, int)::: cipher helper decrypt data:::switch->aes128Decrypt->break->aes256Decrypt->break->aes128Sha2Decrypt->break->aes256Sha2Decrypt->break->throw->new->GSSException
CipherHelper#decryptData(WrapToken, InputStream, int, byte[], int)::: cipher helper decrypt data:::switch->getDesEncryptionKey->desCbcDecrypt->break->ciphertext->new->byteArr->try->Krb5Token->readFully->catch->ge->new->GSSException->ge->initCause->throw->finally->des3KdDecrypt->break->ctext->new->byteArr->try->Krb5Token->readFully->catch->ge->new->GSSException->ge->initCause->throw->finally->arcFourDecrypt->break->throw->new->GSSException
CipherHelper#decryptData(WrapToken_v2, InputStream, int, byte[], int, int)::: cipher helper decrypt data:::ciphertext->new->byteArr->try->Krb5Token->readFully->catch->ge->new->GSSException->ge->initCause->throw->finally->switch->aes128Decrypt->break->aes256Decrypt->break->aes128Sha2Decrypt->break->aes256Sha2Decrypt->break->throw->new->GSSException
CipherHelper#encryptData(WrapToken, byte[], byte[], int, int, byte[], OutputStream)::: cipher helper encrypt data:::switch->des->getDesEncryptionKey->getInitializedDes->cos->new->CipherOutputStream->cos->write->cos->write->cos->write->break->ctext->des3KdEncrypt->os->write->break->ciphertext->arcFourEncrypt->os->write->break->throw->new->GSSException
CipherHelper#encryptData(WrapToken_v2, byte[], byte[], byte[], int, int, int)::: cipher helper encrypt data:::switch->return->aes128Encrypt->return->aes256Encrypt->return->aes128Sha2Encrypt->return->aes256Sha2Encrypt->throw->new->GSSException
CipherHelper#encryptData(WrapToken, byte[], byte[], int, int, byte[], byte[], int)::: cipher helper encrypt data:::switch->pos->des->getDesEncryptionKey->getInitializedDes->try->des->update->des->update->des->update->des->doFinal->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->break->ctext->des3KdEncrypt->System->arraycopy->break->ctext2->arcFourEncrypt->System->arraycopy->break->throw->new->GSSException
CipherHelper#encryptData(WrapToken_v2, byte[], byte[], byte[], int, int, byte[], int, int)::: cipher helper encrypt data:::ctext->switch->aes128Encrypt->break->aes256Encrypt->break->aes128Sha2Encrypt->break->aes256Sha2Encrypt->break->throw->new->GSSException->System->arraycopy->return
CipherHelper#getDesCbcChecksum(byte[], byte[], byte[], int, int):::Computes the DesCbc checksum based on the algorithm published in FIPS Publication 113:::des->getInitializedDes->blockSize->des->getBlockSize->finalBlock->new->byteArr->numBlocks->lastBytes->if->System->arraycopy->else->System->arraycopy->try->temp->Math->max->new->byteArr->if->des->update->for->i->retVal->new->byteArr->des->update->des->doFinal->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#getInitializedDes(boolean, byte[], byte[]):::Obtains an initialized DES cipher.:::try->iv->new->IvParameterSpec->jceKey->new->SecretKeySpec->desCipher->Cipher->getInstance->desCipher->init->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#desCbcDecrypt(WrapToken, byte[], byte[], int, int, byte[], int):::Helper routine to decrypt fromm a byte array and write the application data straight to an output array with minimal buffer copies:::try->temp->des->getInitializedDes->des->update->blockSize->des->getBlockSize->numBlocks->for->i->finalBlock->new->byteArr->des->update->des->doFinal->padSize->if->throw->new->GSSException->System->arraycopy->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#desCbcDecrypt(WrapToken, byte[], InputStream, int, byte[], int):::Helper routine to decrypt from an InputStream and write the application data straight to an output array with minimal buffer copies:::temp->des->getInitializedDes->truncatedInputStream->new->WrapTokenInputStream->cis->new->CipherInputStream->cis->read->blockSize->des->getBlockSize->numBlocks->for->i->finalBlock->new->byteArr->cis->read->try->des->doFinal->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->padSize->if->throw->new->GSSException->System->arraycopy
CipherHelper#getDesEncryptionKey(byte[])::: cipher helper get des encryption key:::if->throw->new->GSSException->retVal->new->byteArr->for->i->return
CipherHelper#des3KdDecrypt(WrapToken, byte[], int, int, byte[], int)::: cipher helper des3 kd decrypt:::ptext->try->Des3->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->padSize->if->throw->new->GSSException->len->System->arraycopy->System->arraycopy
CipherHelper#des3KdEncrypt(byte[], byte[], int, int, byte[])::: cipher helper des3 kd encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->try->answer->Des3->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#arcFourDecrypt(WrapToken, byte[], int, int, byte[], int)::: cipher helper arc four decrypt:::seqNum->token->getChecksum->token->getEncSeqNumber->decryptSeq->ptext->try->ArcFourHmac->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->padSize->if->throw->new->GSSException->len->System->arraycopy->System->arraycopy
CipherHelper#arcFourEncrypt(WrapToken, byte[], byte[], int, int, byte[])::: cipher helper arc four encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->seqNum->new->byteArr->WrapToken->token->getSequenceNumber->writeBigEndian->try->answer->ArcFourHmac->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#aes128Encrypt(byte[], byte[], byte[], int, int, int)::: cipher helper aes128 encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->try->answer->Aes128->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#aes128Sha2Encrypt(byte[], byte[], byte[], int, int, int)::: cipher helper aes128 sha2 encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->try->answer->Aes128Sha2->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#aes128Decrypt(WrapToken_v2, byte[], int, int, byte[], int, int)::: cipher helper aes128 decrypt:::ptext->try->Aes128->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->len->System->arraycopy
CipherHelper#aes128Sha2Decrypt(WrapToken_v2, byte[], int, int, byte[], int, int)::: cipher helper aes128 sha2 decrypt:::ptext->try->Aes128Sha2->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->len->System->arraycopy
CipherHelper#aes256Encrypt(byte[], byte[], byte[], int, int, int)::: cipher helper aes256 encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->try->answer->Aes256->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#aes256Sha2Encrypt(byte[], byte[], byte[], int, int, int)::: cipher helper aes256 sha2 encrypt:::all->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->try->answer->Aes256Sha2->encryptRaw->return->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally
CipherHelper#aes256Decrypt(WrapToken_v2, byte[], int, int, byte[], int, int)::: cipher helper aes256 decrypt:::ptext->try->Aes256->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->len->System->arraycopy
CipherHelper#aes256Sha2Decrypt(WrapToken_v2, byte[], int, int, byte[], int, int)::: cipher helper aes256 sha2 decrypt:::ptext->try->Aes256Sha2->decryptRaw->catch->ge->e->getMessage->new->GSSException->ge->initCause->throw->finally->len->System->arraycopy
CipherHelper.WrapTokenInputStream#read()::: wrap token input stream read:::if->return->else->is->read->if->return
CipherHelper.WrapTokenInputStream#read(byte[])::: wrap token input stream read:::if->return->else->Math->min->is->read->if->return
CipherHelper.WrapTokenInputStream#read(byte[], int, int)::: wrap token input stream read:::if->return->else->Math->min->is->read->if->return
CipherHelper.WrapTokenInputStream#skip(long)::: wrap token input stream skip:::if->return->else->Math->min->is->skip->return
CipherHelper.WrapTokenInputStream#available()::: wrap token input stream available:::return->Math->is->available->min
CipherHelper.WrapTokenInputStream#close()::: wrap token input stream close:::
InitialToken.OverloadedChecksum#useNullKey(CipherHelper)::: overloaded checksum use null key:::flag->if->ch->getProto->ch->isArcFour->return
InitialToken.OverloadedChecksum#getChecksum()::: overloaded checksum get checksum:::return->new->Checksum
InitialToken.OverloadedChecksum#getDelegatedCreds()::: overloaded checksum get delegated creds:::return
InitialToken.OverloadedChecksum#setContextFlags(Krb5Context)::: overloaded checksum set context flags:::if->context->setCredDelegState->if->context->setMutualAuthState->if->context->setReplayDetState->if->context->setSequenceDetState->if->context->setConfState->if->context->setIntegState
InitialToken#getAddrType(InetAddress)::: initial token get addr type:::addressType->if->else->if->return
InitialToken#getAddrBytes(InetAddress)::: initial token get addr bytes:::addressType->getAddrType->addressBytes->addr->getAddress->if->switch->if->throw->new->GSSException->return->if->throw->new->GSSException->return->throw->new->GSSException->return
InitialToken#computeChannelBinding(ChannelBinding)::: initial token compute channel binding:::initiatorAddress->channelBinding->getInitiatorAddress->acceptorAddress->channelBinding->getAcceptorAddress->size->initiatorAddressType->getAddrType->acceptorAddressType->getAddrType->initiatorAddressBytes->if->getAddrBytes->acceptorAddressBytes->if->getAddrBytes->appDataBytes->channelBinding->getApplicationData->if->data->new->byteArr->pos->writeLittleEndian->if->writeLittleEndian->System->arraycopy->else->writeLittleEndian->if->writeLittleEndian->System->arraycopy->else->if->writeLittleEndian->System->arraycopy->else->try->md5->MessageDigest->getInstance->return->md5->digest->catch->throw->e->getMessage->new->GSSException->finally
InitialToken#encode()::: initial token encode:::
InitSecContextToken#getKrbApReq()::: init sec context token get krb ap req:::return
InitSecContextToken#encode()::: init sec context token encode:::apReqBytes->apReq->getMessage->retVal->new->byteArr->writeInt->System->arraycopy->return
Krb5AcceptCredential#getInstance(GSSCaller, Krb5NameElement)::: krb5 accept credential get instance:::serverPrinc->name->getKrb5PrincipalName->getName->acc->AccessController->getContext->creds->try->AccessController->new->PrivilegedExceptionAction<ServiceCreds>->doPrivileged->catch->ge->new->GSSException->ge->e->getException->initCause->throw->finally->if->throw->new->GSSException->if->fullName->creds->getName->if->Krb5NameElement->getInstance->return->new->Krb5AcceptCredential
Krb5AcceptCredential#getName():::Returns the principal name for this credential:::return
Krb5AcceptCredential#getInitLifetime():::Returns the init lifetime remaining.:::return
Krb5AcceptCredential#getAcceptLifetime():::Returns the accept lifetime remaining.:::return
Krb5AcceptCredential#isInitiatorCredential()::: krb5 accept credential is initiator credential:::return
Krb5AcceptCredential#isAcceptorCredential()::: krb5 accept credential is acceptor credential:::return
Krb5AcceptCredential#getMechanism():::Returns the oid representing the underlying credential mechanism oid.:::return
Krb5AcceptCredential#getProvider()::: krb5 accept credential get provider:::return
Krb5AcceptCredential#getKrb5EncryptionKeys(PrincipalName)::: krb5 accept credential get krb5 encryption keys:::return->screds->getEKeys
Krb5AcceptCredential#dispose():::Called to invalidate this credential element.:::try->destroy->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->finally
Krb5AcceptCredential#destroy():::Destroys the locally cached EncryptionKey value and then calls destroy in the base class.:::screds->destroy
Krb5AcceptCredential#impersonate(GSSNameSpi):::Impersonation is only available on the initiator side:::cred->screds->getInitCred->if->return->Krb5InitCredential->getInstance->impersonate->else->throw->new->GSSException
Krb5Context#isTransferable():::Method to determine if the context can be exported and then re-imported.:::return
Krb5Context#getLifetime():::The lifetime remaining for this context.:::return
Krb5Context#requestLifetime(int):::Requests the desired lifetime:::if->isInitiator
Krb5Context#requestConf(boolean):::Requests that confidentiality be available.:::if->isInitiator
Krb5Context#getConfState():::Is confidentiality available?:::return
Krb5Context#requestInteg(boolean):::Requests that integrity be available.:::if->isInitiator
Krb5Context#getIntegState():::Is integrity available?:::return
Krb5Context#requestCredDeleg(boolean):::Requests that credential delegation be done during context establishment.:::if->isInitiator->if
Krb5Context#getCredDelegState():::Is credential delegation enabled?:::if->isInitiator->return->else->tryConstrainedDelegation->return
Krb5Context#requestMutualAuth(boolean):::Requests that mutual authentication be done during context establishment:::if->isInitiator
Krb5Context#getMutualAuthState():::Is mutual authentication enabled? Since this is from the client's perspective, it essentially meas that the server is being authenticated.:::return
Krb5Context#requestReplayDet(boolean):::Requests that replay detection be done on the GSS wrap and MIC tokens.:::if->isInitiator
Krb5Context#getReplayDetState():::Is replay detection enabled on the GSS wrap and MIC tokens? We enable replay detection if sequence checking is enabled.:::return
Krb5Context#requestSequenceDet(boolean):::Requests that sequence checking be done on the GSS wrap and MIC tokens.:::if->isInitiator
Krb5Context#getSequenceDetState():::Is sequence checking enabled on the GSS Wrap and MIC tokens? We enable sequence checking if replay detection is enabled.:::return
Krb5Context#requestDelegPolicy(boolean):::Requests that the deleg policy be respected.:::if->isInitiator
Krb5Context#getDelegPolicyState():::Is deleg policy respected?:::return
Krb5Context#requestAnonymity(boolean)::: krb5 context request anonymity:::
Krb5Context#getAnonymityState()::: krb5 context get anonymity state:::return
Krb5Context#getCipherHelper(EncryptionKey):::Get the context specific DESCipher instance, invoked in MessageToken.init():::cipherKey->if->getKey->getKey->new->CipherHelper->return
Krb5Context#incrementMySequenceNumber()::: krb5 context increment my sequence number:::retVal->synchronized->return
Krb5Context#resetMySequenceNumber(int)::: krb5 context reset my sequence number:::if->println->synchronized
Krb5Context#resetPeerSequenceNumber(int)::: krb5 context reset peer sequence number:::if->println->synchronized->new->TokenTracker
Krb5Context#setKey(int, EncryptionKey)::: krb5 context set key:::new->CipherHelper
Krb5Context#getKeySrc()::: krb5 context get key src:::return
Krb5Context#getKey()::: krb5 context get key:::return
Krb5Context#setDelegCred(Krb5CredElement):::Called on the acceptor side to store the delegated credentials received in the AcceptSecContextToken.:::
Krb5Context#setCredDelegState(boolean)::: krb5 context set cred deleg state:::
Krb5Context#setMutualAuthState(boolean)::: krb5 context set mutual auth state:::
Krb5Context#setReplayDetState(boolean)::: krb5 context set replay det state:::
Krb5Context#setSequenceDetState(boolean)::: krb5 context set sequence det state:::
Krb5Context#setConfState(boolean)::: krb5 context set conf state:::
Krb5Context#setIntegState(boolean)::: krb5 context set integ state:::
Krb5Context#setDelegPolicyState(boolean)::: krb5 context set deleg policy state:::
Krb5Context#setChannelBinding(ChannelBinding):::Sets the channel bindings to be used during context establishment.:::
Krb5Context#getChannelBinding()::: krb5 context get channel binding:::return
Krb5Context#getMech():::Returns the mechanism oid.:::return
Krb5Context#getSrcName():::Returns the context initiator name.:::return->isInitiator
Krb5Context#getTargName():::Returns the context acceptor.:::return->isInitiator
Krb5Context#getDelegCred():::Returns the delegated credential for the context:::if->throw->new->GSSException->if->isInitiator->throw->new->GSSException->tryConstrainedDelegation->if->throw->new->GSSException->return
Krb5Context#tryConstrainedDelegation()::: krb5 context try constrained delegation:::if->return->if->if->if->println->try->Krb5InitCredential->getInstance->new->Krb5ProxyCredential->catch->finally
Krb5Context#isInitiator():::Tests if this is the initiator side of the context.:::return
Krb5Context#isProtReady():::Tests if the context can be used for per-message service:::return
Krb5Context#initSecContext(InputStream, int):::Initiator context establishment call:::retVal->token->errorCode->if->printState->println->if->isInitiator->throw->new->GSSException->try->if->if->Krb5InitCredential->getInstance->Krb5ProxyCredential->tryImpersonation->else->if->myCred->isInitiatorCredential->throw->new->GSSException->myCred->getName->second->if->getKrb5Credentials->else->getKrb5Credentials->peerName->getKrb5PrincipalName->getName->checkPermission->acc->AccessController->getContext->if->GSSUtil->useSubjectCredsOnly->kerbTicket->try->AccessController->new->PrivilegedExceptionAction<KerberosTicket>->doPrivileged->catch->if->println->finally->if->if->println->Krb5Util->ticketToCreds->if->if->println->if->Credentials->peerName->getKrb5PrincipalName->getName->acquireServiceCreds->else->Credentials->peerName->getKrb5PrincipalName->getName->second->getName->getKrb5PrincipalName->acquireS4U2proxyCreds->if->GSSUtil->useSubjectCredsOnly->subject->AccessController->new->java.security.PrivilegedAction<Subject>->doPrivileged->if->subject->isReadOnly->kt->Krb5Util->credsToTicket->AccessController->new->java.security.PrivilegedAction<Void>->doPrivileged->else->if->println->new->InitSecContextToken->getKrbApReq->token->encode->if->getMutualAuthState->if->new->HexDumpEncoder->encodeBuffer->println->else->if->new->AcceptSecContextToken->else->if->println->catch->if->e->printStackTrace->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->return
Krb5Context#isEstablished()::: krb5 context is established:::return
Krb5Context#acceptSecContext(InputStream, int):::Acceptor's context establishment call:::retVal->if->printState->println->if->isInitiator->throw->new->GSSException->try->if->if->Krb5AcceptCredential->getInstance->else->if->myCred->isAcceptorCredential->throw->new->GSSException->myCred->getName->if->Krb5MechFactory->checkAcceptCredPermission->token->new->InitSecContextToken->clientName->token->getKrbApReq->getClient->Krb5NameElement->getInstance->if->Krb5NameElement->token->getKrbApReq->getCreds->getServer->getInstance->Krb5MechFactory->checkAcceptCredPermission->if->getMutualAuthState->token->getKrbApReq->new->AcceptSecContextToken->encode->token->getKrbApReq->getCreds->getTicket->else->if->println->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->if->e->printStackTrace->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->return
Krb5Context#getWrapSizeLimit(int, boolean, int):::Queries the context for largest data size to accommodate the specified protection and be <= maxTokSize.:::retVal->if->cipherHelper->getProto->WrapToken->getCipherHelper->getSizeLimit->else->if->cipherHelper->getProto->WrapToken_v2->getCipherHelper->getSizeLimit->return
Krb5Context#wrap(byte[], int, int, MessageProp)::: krb5 context wrap:::if->getHexBytes->println->if->throw->new->GSSException->encToken->try->if->cipherHelper->getProto->token->new->WrapToken->token->encode->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->encode->if->getHexBytes->println->return->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#wrap(byte[], int, int, byte[], int, MessageProp)::: krb5 context wrap:::if->throw->new->GSSException->retVal->try->if->cipherHelper->getProto->token->new->WrapToken->token->encode->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->encode->if->getHexBytes->println->return->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#wrap(byte[], int, int, OutputStream, MessageProp)::: krb5 context wrap:::if->throw->new->GSSException->encToken->try->if->cipherHelper->getProto->token->new->WrapToken->token->encode->if->token->encode->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->encode->if->token->encode->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->if->getHexBytes->println
Krb5Context#wrap(InputStream, OutputStream, MessageProp)::: krb5 context wrap:::data->try->is->available->new->byteArr->is->read->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->wrap
Krb5Context#unwrap(byte[], int, int, MessageProp)::: krb5 context unwrap:::if->getHexBytes->println->if->throw->new->GSSException->data->if->cipherHelper->getProto->token->new->WrapToken->token->getData->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->getData->setSequencingAndReplayProps->if->getHexBytes->println->return
Krb5Context#unwrap(byte[], int, int, byte[], int, MessageProp)::: krb5 context unwrap:::if->throw->new->GSSException->if->cipherHelper->getProto->token->new->WrapToken->token->getData->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->getData->setSequencingAndReplayProps->return
Krb5Context#unwrap(InputStream, byte[], int, MessageProp)::: krb5 context unwrap:::if->throw->new->GSSException->len->if->cipherHelper->getProto->token->new->WrapToken->token->getData->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->getData->setSequencingAndReplayProps->return
Krb5Context#unwrap(InputStream, OutputStream, MessageProp)::: krb5 context unwrap:::if->throw->new->GSSException->data->if->cipherHelper->getProto->token->new->WrapToken->token->getData->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->WrapToken_v2->token->getData->setSequencingAndReplayProps->try->os->write->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#getMIC(byte[], int, int, MessageProp)::: krb5 context get c:::micToken->try->if->cipherHelper->getProto->token->new->MicToken->token->encode->else->if->cipherHelper->getProto->token->new->MicToken_v2->token->encode->return->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#getMIC(byte[], int, int, byte[], int, MessageProp)::: krb5 context get c:::retVal->try->if->cipherHelper->getProto->token->new->MicToken->token->encode->else->if->cipherHelper->getProto->token->new->MicToken_v2->token->encode->return->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#getMIC(byte[], int, int, OutputStream, MessageProp)::: krb5 context get c:::try->if->cipherHelper->getProto->token->new->MicToken->token->encode->else->if->cipherHelper->getProto->token->new->MicToken_v2->token->encode->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally
Krb5Context#getMIC(InputStream, OutputStream, MessageProp)::: krb5 context get c:::data->try->is->available->new->byteArr->is->read->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->getMIC
Krb5Context#verifyMIC(byte[], int, int, byte[], int, int, MessageProp)::: krb5 context verify c:::if->cipherHelper->getProto->token->new->MicToken->token->verify->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->MicToken_v2->token->verify->setSequencingAndReplayProps
Krb5Context#verifyMIC(InputStream, byte[], int, int, MessageProp)::: krb5 context verify c:::if->cipherHelper->getProto->token->new->MicToken->token->verify->setSequencingAndReplayProps->else->if->cipherHelper->getProto->token->new->MicToken_v2->token->verify->setSequencingAndReplayProps
Krb5Context#verifyMIC(InputStream, InputStream, MessageProp)::: krb5 context verify c:::msg->try->msgStr->available->new->byteArr->msgStr->read->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->throw->finally->verifyMIC
Krb5Context#export():::Produces a token representing this context:::throw->new->GSSException
Krb5Context#dispose()::: krb5 context dispose:::
Krb5Context#getProvider()::: krb5 context get provider:::return
Krb5Context#setSequencingAndReplayProps(MessageToken, MessageProp):::Sets replay and sequencing information for a message token received form the peer.:::if->seqNum->token->getSequenceNumber->peerTokenTracker->getProps
Krb5Context#setSequencingAndReplayProps(MessageToken_v2, MessageProp):::Sets replay and sequencing information for a message token received form the peer.:::if->seqNum->token->getSequenceNumber->peerTokenTracker->getProps
Krb5Context#checkPermission(String, String)::: krb5 context check permission:::sm->System->getSecurityManager->if->perm->new->ServicePermission->sm->checkPermission
Krb5Context#getHexBytes(byte[], int, int)::: krb5 context get hex bytes:::sb->new->StringBuilder->for->i->return->sb->toString
Krb5Context#printState(int)::: krb5 context print state:::switch->return->return->return->return->return
Krb5Context#getCaller()::: krb5 context get caller:::return
Krb5Context.KerberosSessionKey#getAlgorithm()::: kerberos session key get algorithm:::return->Integer->key->getEType->toString
Krb5Context.KerberosSessionKey#getFormat()::: kerberos session key get format:::return
Krb5Context.KerberosSessionKey#getEncoded()::: kerberos session key get encoded:::return->key->getBytes->clone
Krb5Context.KerberosSessionKey#toString()::: kerberos session key to string:::return->key->getEType->new->HexDumpEncoder->key->getBytes->encodeBuffer
Krb5Context#inquireSecContext(String):::Return the mechanism-specific attribute associated with type.:::if->isEstablished->throw->new->GSSException->switch->return->new->KerberosSessionKey->return->key->getBytes->key->getEType->new->javax.security.auth.kerberos.EncryptionKey->return->tktFlags->clone->if->isInitiator->throw->new->GSSException->else->return->return->if->isInitiator->throw->new->GSSException->sender->myName->getKrb5PrincipalName->getName->new->KerberosPrincipal->recipient->peerName->getKrb5PrincipalName->getName->new->KerberosPrincipal->try->krbCred->new->KrbCred->getMessage->return->new->KerberosCredMessage->catch->gsse->new->GSSException->gsse->initCause->throw->finally->throw->new->GSSException
Krb5Context#setTktFlags(boolean[])::: krb5 context set tkt flags:::
Krb5Context#setAuthTime(String)::: krb5 context set auth time:::
Krb5Context#setAuthzData(AuthorizationData)::: krb5 context set authz data:::
Krb5InitCredential#getInstance(GSSCaller, Krb5NameElement, int)::: krb5 init credential get instance:::tgt->getTgt->if->throw->new->GSSException->if->fullName->tgt->getClient->getName->Krb5NameElement->getInstance->result->tgt->getEncoded->tgt->getClient->tgt->getServer->tgt->getSessionKey->getEncoded->tgt->getSessionKeyType->tgt->getFlags->tgt->getAuthTime->tgt->getStartTime->tgt->getEndTime->tgt->getRenewTill->tgt->getClientAddresses->new->Krb5InitCredential->KerberosSecrets->getJavaxSecurityAuthKerberosAccess->kerberosTicketGetProxy->return
Krb5InitCredential#getInstance(Krb5NameElement, Credentials)::: krb5 init credential get instance:::sessionKey->delegatedCred->getSessionKey->cPrinc->delegatedCred->getClient->sPrinc->delegatedCred->getServer->client->server->credName->if->fullName->cPrinc->getName->Krb5NameElement->getInstance->new->KerberosPrincipal->if->sPrinc->getName->new->KerberosPrincipal->return->delegatedCred->getEncoded->sessionKey->getBytes->sessionKey->getEType->delegatedCred->getFlags->delegatedCred->getAuthTime->delegatedCred->getStartTime->delegatedCred->getEndTime->delegatedCred->getRenewTill->delegatedCred->getClientAddresses->new->Krb5InitCredential
Krb5InitCredential#getName():::Returns the principal name for this credential:::return
Krb5InitCredential#getInitLifetime():::Returns the init lifetime remaining.:::d->getEndTime->if->return->retVal->d->getTime->System->currentTimeMillis->return
Krb5InitCredential#getAcceptLifetime():::Returns the accept lifetime remaining.:::return
Krb5InitCredential#isInitiatorCredential()::: krb5 init credential is initiator credential:::return
Krb5InitCredential#isAcceptorCredential()::: krb5 init credential is acceptor credential:::return
Krb5InitCredential#getMechanism():::Returns the oid representing the underlying credential mechanism oid.:::return
Krb5InitCredential#getProvider()::: krb5 init credential get provider:::return
Krb5InitCredential#getKrb5Credentials():::Returns a sun.security.krb5.Credentials instance so that it maybe used in that package for th Kerberos protocol.:::return
Krb5InitCredential#dispose():::Called to invalidate this credential element.:::try->destroy->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->finally
Krb5InitCredential#getTgt(GSSCaller, Krb5NameElement, int)::: krb5 init credential get tgt:::clientPrincipal->if->name->getKrb5PrincipalName->getName->else->acc->AccessController->getContext->try->realCaller->return->AccessController->new->PrivilegedExceptionAction<KerberosTicket>->doPrivileged->catch->ge->e->getMessage->new->GSSException->ge->e->getException->initCause->throw->finally
Krb5InitCredential#impersonate(GSSNameSpi)::: krb5 init credential impersonate:::try->kname->newCred->Credentials->kname->getKrb5PrincipalName->acquireS4U2selfCreds->return->newCred->getTicket->new->Krb5ProxyCredential->catch->ge->new->GSSException->ge->initCause->throw->finally
Krb5MechFactory#getCredFromSubject(GSSNameSpi, boolean)::: krb5 mech factory get cred from subject:::creds->GSSUtil->searchSubject->result->creds->isEmpty->creds->firstElement->if->if->result->getName->checkInitCredPermission->else->result->getName->checkAcceptCredPermission->return
Krb5MechFactory#getNameElement(String, Oid)::: krb5 mech factory get name element:::return->Krb5NameElement->getInstance
Krb5MechFactory#getNameElement(byte[], Oid)::: krb5 mech factory get name element:::return->Krb5NameElement->new->String->getInstance
Krb5MechFactory#getCredentialElement(GSSNameSpi, int, int, int)::: krb5 mech factory get credential element:::if->Krb5NameElement->name->toString->name->getStringNameType->getInstance->credElement->getCredFromSubject->if->if->Krb5InitCredential->getInstance->Krb5ProxyCredential->tryImpersonation->credElement->getName->checkInitCredPermission->else->if->Krb5AcceptCredential->getInstance->credElement->getName->checkAcceptCredPermission->else->throw->new->GSSException->return
Krb5MechFactory#checkInitCredPermission(Krb5NameElement)::: krb5 mech factory check init cred permission:::sm->System->getSecurityManager->if->realm->name->getKrb5PrincipalName->getRealmAsString->tgsPrincipal->new->String->perm->new->ServicePermission->try->sm->checkPermission->catch->if->e->getMessage->println->throw->finally
Krb5MechFactory#checkAcceptCredPermission(Krb5NameElement, GSSNameSpi)::: krb5 mech factory check accept cred permission:::sm->System->getSecurityManager->if->perm->name->getKrb5PrincipalName->getName->new->ServicePermission->try->sm->checkPermission->catch->if->new->SecurityException->throw->finally
Krb5MechFactory#getMechanismContext(GSSNameSpi, GSSCredentialSpi, int)::: krb5 mech factory get mechanism context:::if->Krb5NameElement->peer->toString->peer->getStringNameType->getInstance->if->getCredentialElement->return->new->Krb5Context
Krb5MechFactory#getMechanismContext(GSSCredentialSpi)::: krb5 mech factory get mechanism context:::if->getCredentialElement->return->new->Krb5Context
Krb5MechFactory#getMechanismContext(byte[])::: krb5 mech factory get mechanism context:::return->new->Krb5Context
Krb5MechFactory#getMechanismOid()::: krb5 mech factory get mechanism oid:::return
Krb5MechFactory#getProvider()::: krb5 mech factory get provider:::return
Krb5MechFactory#getNameTypes()::: krb5 mech factory get name types:::return
Krb5MechFactory#createOid(String)::: krb5 mech factory create oid:::retVal->try->new->Oid->catch->finally->return
Krb5NameElement#getInstance(String, Oid):::Instantiates a new Krb5NameElement object:::if->else->if->gssNameType->equals->gssNameType->equals->gssNameType->equals->gssNameType->equals->throw->gssNameType->toString->new->GSSException->principalName->try->if->gssNameType->equals->gssNameType->equals->new->PrincipalName->else->components->getComponents->if->gssNameType->equals->new->PrincipalName->else->hostName->service->if->principal->getHostBasedInstance->new->PrincipalName->catch->throw->e->getMessage->new->GSSException->finally->if->principalName->isRealmDeduced->sm->System->getSecurityManager->if->try->sm->principalName->getRealmAsString->new->ServicePermission->checkPermission->catch->throw->new->GSSException->finally->return->new->Krb5NameElement
Krb5NameElement#getInstance(PrincipalName)::: krb5 name element get instance:::return->principalName->getName->new->Krb5NameElement
Krb5NameElement#getComponents(String)::: krb5 name element get components:::retVal->separatorPos->gssNameStr->gssNameStr->length->lastIndexOf->if->gssNameStr->charAt->if->gssNameStr->charAt->if->serviceName->gssNameStr->substring->hostName->gssNameStr->substring->new->StringArr->else->new->StringArr->return
Krb5NameElement#getHostBasedInstance(String, String)::: krb5 name element get host based instance:::temp->new->StringBuffer->try->if->InetAddress->getLocalHost->getHostName->catch->finally->hostName->toLowerCase->temp->append->append->return->temp->toString
Krb5NameElement#getKrb5PrincipalName()::: krb5 name element get krb5 principal name:::return
Krb5NameElement#equals(GSSNameSpi):::Equal method for the GSSNameSpi objects:::if->return->if->that->return->getName->getName->equals->return
Krb5NameElement#equals(Object):::Compares this GSSNameSpi object to another Object that might be a GSSNameSpi:::if->return->try->if->return->equals->catch->finally->return
Krb5NameElement#hashCode():::Returns a hashcode value for this GSSNameSpi.:::return->krb5PrincipalName->getName->hashCode
Krb5NameElement#export():::Returns the principal name in the form user@REALM or host/service@REALM but with the following constraints that are imposed by RFC 1964:   (1) all occurrences of the characters `@`,  `/`, and `\` within   principal components or realm names shall be quoted with an   immediately-preceding `\`:::retVal->try->krb5PrincipalName->getName->getBytes->catch->finally->return
Krb5NameElement#getMechanism():::Get the mechanism type that this NameElement corresponds to.:::return
Krb5NameElement#toString():::Returns a string representation for this name:::return
Krb5NameElement#getGSSNameType():::Returns the name type oid.:::return
Krb5NameElement#getStringNameType():::Returns the oid describing the format of the printable name.:::return
Krb5NameElement#isAnonymousName():::Indicates if this name object represents an Anonymous name.:::return->gssNameType->equals
Krb5NameElement#getProvider()::: krb5 name element get provider:::return
Krb5ProxyCredential#getName()::: krb5 proxy credential get name:::return
Krb5ProxyCredential#getInitLifetime()::: krb5 proxy credential get init lifetime:::return->self->getInitLifetime
Krb5ProxyCredential#getAcceptLifetime()::: krb5 proxy credential get accept lifetime:::return
Krb5ProxyCredential#isInitiatorCredential()::: krb5 proxy credential is initiator credential:::return
Krb5ProxyCredential#isAcceptorCredential()::: krb5 proxy credential is acceptor credential:::return
Krb5ProxyCredential#getMechanism()::: krb5 proxy credential get mechanism:::return
Krb5ProxyCredential#getProvider()::: krb5 proxy credential get provider:::return
Krb5ProxyCredential#dispose()::: krb5 proxy credential dispose:::try->self->destroy->catch->gssException->e->getMessage->new->GSSException->gssException->initCause->finally
Krb5ProxyCredential#impersonate(GSSNameSpi)::: krb5 proxy credential impersonate:::throw->new->GSSException
Krb5ProxyCredential#tryImpersonation(GSSCaller, Krb5InitCredential)::: krb5 proxy credential try impersonation:::try->proxy->if->proxyCreds->Krb5Util->ticketToCreds->return->Krb5NameElement->proxyCreds->getClient->getInstance->proxyCreds->getTicket->new->Krb5ProxyCredential->else->return->catch->throw->new->GSSException->finally
Krb5Token#getTokenName(int):::Returns a strign representing the token type.:::retVal->switch->break->break->break->break->break->break->return
Krb5Util#getTicketFromSubjectAndTgs(GSSCaller, String, String, String, AccessControlContext):::Retrieve the service ticket for serverPrincipal from caller's Subject or from Subject obtained by logging in, or if not found, via the Ticket Granting Service using the TGT obtained from the Subject:::accSubj->Subject->getSubject->ticket->SubjectComber->find->if->return->loginSubj->if->GSSUtil->useSubjectCredsOnly->try->GSSUtil->login->SubjectComber->find->if->return->catch->finally->tgt->SubjectComber->find->fromAcc->if->SubjectComber->find->else->if->tgtCreds->ticketToCreds->serviceCreds->Credentials->acquireServiceCreds->if->credsToTicket->if->accSubj->isReadOnly->accSubj->getPrivateCredentials->add->return
Krb5Util#getServiceTicket(GSSCaller, String, String, AccessControlContext):::Retrieves the ticket corresponding to the client/server principal pair from the Subject in the specified AccessControlContext.:::accSubj->Subject->getSubject->ticket->SubjectComber->find->return
Krb5Util#getInitialTicket(GSSCaller, String, AccessControlContext):::Retrieves the initial TGT corresponding to the client principal from the Subject in the specified AccessControlContext:::accSubj->Subject->getSubject->ticket->SubjectComber->find->if->GSSUtil->useSubjectCredsOnly->subject->GSSUtil->login->SubjectComber->find->return
Krb5Util#getSubject(GSSCaller, AccessControlContext):::Retrieves the caller's Subject, or Subject obtained by logging in via the specified caller:::subject->Subject->getSubject->if->GSSUtil->useSubjectCredsOnly->GSSUtil->login->return
Krb5Util#getServiceCreds(GSSCaller, String, AccessControlContext):::Retrieves the ServiceCreds for the specified server principal from the Subject in the specified AccessControlContext:::accSubj->Subject->getSubject->sc->if->ServiceCreds->getInstance->if->GSSUtil->useSubjectCredsOnly->subject->GSSUtil->login->ServiceCreds->getInstance->return
Krb5Util#credsToTicket(Credentials)::: krb5 util creds to ticket:::sessionKey->serviceCreds->getSessionKey->return->serviceCreds->getEncoded->serviceCreds->getClient->getName->new->KerberosPrincipal->serviceCreds->getServer->getName->new->KerberosPrincipal->sessionKey->getBytes->sessionKey->getEType->serviceCreds->getFlags->serviceCreds->getAuthTime->serviceCreds->getStartTime->serviceCreds->getEndTime->serviceCreds->getRenewTill->serviceCreds->getClientAddresses->new->KerberosTicket
Krb5Util#ticketToCreds(KerberosTicket)::: krb5 util ticket to creds:::return->kerbTicket->getEncoded->kerbTicket->getClient->getName->kerbTicket->getServer->getName->kerbTicket->getSessionKey->getEncoded->kerbTicket->getSessionKeyType->kerbTicket->getFlags->kerbTicket->getAuthTime->kerbTicket->getStartTime->kerbTicket->getEndTime->kerbTicket->getRenewTill->kerbTicket->getClientAddresses->new->Credentials
Krb5Util#snapshotFromJavaxKeyTab(KeyTab):::A helper method to get a sun..KeyTab from a javax..KeyTab:::return->KerberosSecrets->getJavaxSecurityAuthKerberosAccess->keyTabTakeSnapshot
Krb5Util#keysFromJavaxKeyTab(KeyTab, PrincipalName):::A helper method to get EncryptionKeys from a javax..KeyTab:::return->snapshotFromJavaxKeyTab->readServiceKeys
MessageToken#getGSSHeader():::Used to obtain the GSSHeader that was at the start of this token.:::return
MessageToken#getTokenId():::Used to obtain the token id that was contained in this token.:::return
MessageToken#getEncSeqNumber():::Used to obtain the encrypted sequence number in this token.:::return
MessageToken#getChecksum():::Used to obtain the checksum that was contained in this token.:::return
MessageToken#getConfState():::Used to determine if this token contains any encrypted data.:::return
MessageToken#genSignAndSeqNumber(MessageProp, byte[], byte[], int, int, byte[]):::Generates the checksum field and the encrypted sequence number field:::qop->prop->getQOP->if->prop->setQOP->if->prop->setPrivacy->prop->getPrivacy->new->MessageTokenHeader->getChecksum->new->byteArr->if->cipherHelper->isArcFour->writeBigEndian->else->writeLittleEndian->if->cipherHelper->encryptSeq
MessageToken#verifySignAndSeqNumber(byte[], byte[], int, int, byte[]):::Verifies that the checksum field and sequence number direction bytes are valid and consistent with the application data.:::myChecksum->getChecksum->if->MessageDigest->isEqual->cipherHelper->decryptSeq->directionByte->if->if->return->return
MessageToken#getSequenceNumber()::: message token get sequence number:::sequenceNum->if->cipherHelper->isArcFour->readBigEndian->else->readLittleEndian->return
MessageToken#getChecksum(byte[], byte[], int, int, byte[]):::Computes the checksum based on the algorithm stored in the tokenHeader.:::tokenHeaderBytes->tokenHeader->getBytes->existingHeader->checksumDataHeader->if->new->byteArr->System->arraycopy->System->arraycopy->return->cipherHelper->tokenHeader->getSignAlg->calculateChecksum
MessageToken#init(int, Krb5Context)::: message token init:::context->getConfState->context->isInitiator->context->getCipherHelper
MessageToken#encode(OutputStream):::Encodes a GSSHeader and this token onto an OutputStream.:::getKrb5TokenSize->new->GSSHeader->gssHeader->encode->tokenHeader->encode->os->write->os->write
MessageToken#getKrb5TokenSize():::Obtains the size of this token:::return->getTokenSize
MessageToken#getTokenSize()::: message token get token size:::return->cipherHelper->getChecksumLength
MessageToken#getTokenSize(CipherHelper)::: message token get token size:::return->ch->getChecksumLength
MessageToken#getSealAlg(boolean, int):::Obtains the encryption algorithm that should be used in this token given the state of confidentiality the application requested:::
MessageToken.MessageTokenHeader#encode(OutputStream):::Encodes this MessageTokenHeader onto an OutputStream:::os->write
MessageToken.MessageTokenHeader#getTokenId():::Returns the token id for the message token.:::return
MessageToken.MessageTokenHeader#getSignAlg():::Returns the sign algorithm for the message token.:::return
MessageToken.MessageTokenHeader#getSealAlg():::Returns the seal algorithm for the message token.:::return
MessageToken.MessageTokenHeader#getBytes():::Returns the bytes of this header.:::return
MessageToken#getSgnAlg(int):::Determine signing algorithm based on QOP.:::return->cipherHelper->getSgnAlg
MessageToken_v2#getTokenId():::Used to obtain the token id that was contained in this token.:::return
MessageToken_v2#getKeyUsage():::Used to obtain the key_usage type for this token.:::return
MessageToken_v2#getConfState():::Used to determine if this token contains any encrypted data.:::return
MessageToken_v2#genSignAndSeqNumber(MessageProp, byte[], int, int):::Generates the checksum field and the sequence number field.:::qop->prop->getQOP->if->prop->setQOP->if->prop->setPrivacy->prop->getPrivacy->new->MessageTokenHeader->if->else->if->if->prop->getPrivacy->getChecksum->if->prop->getPrivacy->tok_header->tokenHeader->getBytes
MessageToken_v2#verifySign(byte[], int, int):::Verifies the validity of checksum field:::myChecksum->getChecksum->if->MessageDigest->isEqual->return->return
MessageToken_v2#rotate():::Rotate bytes as per the "RRC" (Right Rotation Count) received:::if->newBytes->new->byteArr->System->arraycopy->System->arraycopy
MessageToken_v2#getSequenceNumber()::: message token_v2 get sequence number:::return
MessageToken_v2#getChecksum(byte[], int, int):::Computes the checksum based on the algorithm stored in the tokenHeader.:::tokenHeaderBytes->tokenHeader->getBytes->conf_flag->if->return->cipherHelper->calculateChecksum
MessageToken_v2#init(int, Krb5Context)::: message token_v2 init:::context->getConfState->context->isInitiator->context->getKeySrc->context->getCipherHelper
MessageToken_v2#encodeHeader(OutputStream):::Encodes a MessageTokenHeader onto an OutputStream.:::tokenHeader->encode
MessageToken_v2#encode(OutputStream):::Encodes a MessageToken_v2 onto an OutputStream.:::
MessageToken_v2#getTokenHeader()::: message token_v2 get token header:::return->tokenHeader->getBytes
MessageToken_v2.MessageTokenHeader#encode(OutputStream):::Encodes this MessageTokenHeader onto an OutputStream:::os->write
MessageToken_v2.MessageTokenHeader#getTokenId():::Returns the token id for the message token.:::return
MessageToken_v2.MessageTokenHeader#getBytes():::Returns the bytes of this header.:::return
MicToken#verify(byte[], int, int)::: mic token verify:::if->verifySignAndSeqNumber->throw->new->GSSException
MicToken#verify(InputStream)::: mic token verify:::dataBytes->try->data->available->new->byteArr->data->read->catch->throw->new->GSSException->finally->verify
MicToken#getSealAlg(boolean, int)::: mic token get seal alg:::return
MicToken#encode(byte[], int)::: mic token encode:::bos->new->ByteArrayOutputStream->super->encode->token->bos->toByteArray->System->arraycopy->return
MicToken#encode()::: mic token encode:::bos->new->ByteArrayOutputStream->encode->return->bos->toByteArray
MicToken_v2#verify(byte[], int, int)::: mic token_v2 verify:::if->verifySign->throw->new->GSSException
MicToken_v2#verify(InputStream)::: mic token_v2 verify:::dataBytes->try->data->available->new->byteArr->data->read->catch->throw->new->GSSException->finally->verify
MicToken_v2#encode()::: mic token_v2 encode:::bos->new->ByteArrayOutputStream->encode->return->bos->toByteArray
MicToken_v2#encode(byte[], int)::: mic token_v2 encode:::token->encode->System->arraycopy->return
MicToken_v2#encode(OutputStream)::: mic token_v2 encode:::encodeHeader->os->write
ServiceCreds#getInstance(Subject, String):::Creates a ServiceCreds object based on info in a Subject for a given principal name (if specified).:::sc->new->ServiceCreds->subj->getPrincipals->foreach->SubjectComber->findMany->key->getPrincipal->add->if->new->KerberosPrincipal->else->if->size->hasUnbound->foreach->SubjectComber->findMany->if->ktab->isBound->break->if->iterator->next->getName->SubjectComber->findMany->SubjectComber->findMany->SubjectComber->find->if->isEmpty->isEmpty->return->return
ServiceCreds#getName()::: service creds get name:::if->throw->new->IllegalStateException->return->kp->getName
ServiceCreds#getKKeys():::Gets keys for "someone":::if->throw->new->IllegalStateException->one->if->allPrincs->isEmpty->allPrincs->iterator->next->if->foreach->pn->Krb5Util->snapshotFromJavaxKeyTab->getOneName->if->pn->getName->new->KerberosPrincipal->break->if->return->getKKeys->else->return->new->KerberosKeyArr
ServiceCreds#getKKeys(KerberosPrincipal):::Get kkeys for a principal,:::if->throw->new->IllegalStateException->keys->new->ArrayList<>->if->princ->equals->return->new->KerberosKeyArr->foreach->if->k->getPrincipal->equals->keys->add->foreach->if->ktab->getPrincipal->ktab->isBound->if->allPrincs->contains->continue->foreach->ktab->getKeys->keys->add->return->keys->keys->size->new->KerberosKeyArr->toArray
ServiceCreds#getEKeys(PrincipalName):::Gets EKeys for a principal.:::if->throw->new->IllegalStateException->kkeys->princ->getName->new->KerberosPrincipal->getKKeys->if->getKKeys->ekeys->new->EncryptionKeyArr->for->i->return
ServiceCreds#getInitCred()::: service creds get init cred:::if->throw->new->IllegalStateException->if->return->try->return->Krb5Util->ticketToCreds->catch->return->finally
ServiceCreds#destroy()::: service creds destroy:::ktabs->clear->kk->clear
SubjectComber#find(Subject, String, String, Class)::: subject comber find:::return->credClass->findAux->cast
SubjectComber#findMany(Subject, String, String, Class)::: subject comber find many:::return->findAux
SubjectComber#findAux(Subject, String, String, Class, boolean)::: subject comber find aux:::if->return->else->answer->new->ArrayList<T>->if->iterator->subject->getPrivateCredentials->iterator->while->iterator->hasNext->t->iterator->next->if->t->isBound->name->t->getPrincipal->if->if->serverPrincipal->name->getName->equals->continue->else->found->foreach->subject->getPrincipals->if->princ->getName->equals->break->if->continue->if->credClass->getSimpleName->println->if->return->else->answer->credClass->cast->add->else->if->iterator->subject->getPrivateCredentials->iterator->while->iterator->hasNext->t->iterator->next->name->t->getPrincipal->getName->if->serverPrincipal->equals->if->credClass->getSimpleName->println->if->return->else->answer->credClass->cast->add->else->if->pcs->subject->getPrivateCredentials->synchronized->iterator->pcs->iterator->while->iterator->hasNext->obj->iterator->next->if->ticket->if->ticket->getClient->ticket->getServer->ticket->getEndTime->println->if->ticket->isCurrent->if->subject->isReadOnly->iterator->remove->try->ticket->destroy->if->println->catch->if->println->finally->else->if->ticket->getServer->getName->equals->if->clientPrincipal->ticket->getClient->getName->equals->if->return->else->if->ticket->getClient->getName->if->ticket->getServer->getName->answer->credClass->cast->add->return
WrapToken#getData():::Obtains the application data that was transmitted in this WrapToken.:::temp->new->byteArr->getData->retVal->new->byteArr->System->arraycopy->return
WrapToken#getData(byte[], int):::Obtains the application data that was transmitted in this WrapToken, writing it into an application provided output array.:::if->getDataFromStream->else->getDataFromBuffer->return
WrapToken#getDataFromBuffer(byte[], int):::Helper routine to obtain the application data transmitted in this WrapToken:::gssHeader->getGSSHeader->dataPos->gssHeader->getLength->getTokenSize->if->throw->getTokenId->getTokenName->new->GSSException->new->byteArr->if->cipherHelper->decryptData->else->System->arraycopy->padSize->if->if->System->arraycopy->if->verifySignAndSeqNumber->throw->new->GSSException
WrapToken#getDataFromStream(byte[], int):::Helper routine to obtain the application data transmitted in this WrapToken:::gssHeader->getGSSHeader->new->byteArr->try->if->cipherHelper->decryptData->else->readFully->if->cipherHelper->isArcFour->readFully->else->numBlocks->offset->for->i->finalBlock->new->byteArr->readFully->padSize->System->arraycopy->catch->throw->getTokenId->getTokenName->e->getMessage->new->GSSException->finally->if->verifySignAndSeqNumber->throw->new->GSSException
WrapToken#getPadding(int):::Helper routine to pick the right padding for a certain length of application data:::padSize->if->cipherHelper->isArcFour->else->return
WrapToken#encode(OutputStream)::: wrap token encode:::super->encode->if->os->write->os->write->os->write->else->cipherHelper->encryptData
WrapToken#encode()::: wrap token encode:::bos->new->ByteArrayOutputStream->encode->return->bos->toByteArray
WrapToken#encode(byte[], int)::: wrap token encode:::bos->new->ByteArrayOutputStream->super->encode->header->bos->toByteArray->System->arraycopy->if->System->arraycopy->System->arraycopy->System->arraycopy->else->cipherHelper->encryptData->return
WrapToken#getKrb5TokenSize()::: wrap token get krb5 token size:::return->getTokenSize
WrapToken#getSealAlg(boolean, int)::: wrap token get seal alg:::if->return->return->cipherHelper->getSealAlg
WrapToken#getSizeLimit(int, boolean, int, CipherHelper)::: wrap token get size limit:::return->GSSHeader->getMaxMechTokenSize->getTokenSize
WrapToken_v2#getData():::Obtains the application data that was transmitted in this WrapToken.:::temp->new->byteArr->len->getData->return->Arrays->copyOf
WrapToken_v2#getData(byte[], int):::Obtains the application data that was transmitted in this WrapToken, writing it into an application provided output array.:::if->cipherHelper->getKeyUsage->decryptData->return->cipherHelper->getChecksumLength->else->data_length->cipherHelper->getChecksumLength->System->arraycopy->if->verifySign->throw->new->GSSException->return
WrapToken_v2#encode(OutputStream)::: wrap token_v2 encode:::encodeHeader->os->write
WrapToken_v2#encode()::: wrap token_v2 encode:::bos->new->ByteArrayOutputStream->encode->return->bos->toByteArray
WrapToken_v2#encode(byte[], int)::: wrap token_v2 encode:::token->encode->System->arraycopy->return
WrapToken_v2#getSizeLimit(int, boolean, int, CipherHelper)::: wrap token_v2 get size limit:::return->GSSHeader->getMaxMechTokenSize->ch->getChecksumLength
