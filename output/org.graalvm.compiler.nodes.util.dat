GraphUtil_OptionDescriptors#get(String)::: graph util_ option descriptors get:::switch->return->OptionDescriptor->create->return
GraphUtil_OptionDescriptors#iterator()::: graph util_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
ConstantFoldUtil#tryConstantFold(ConstantFieldProvider, ConstantReflectionProvider, MetaAccessProvider, ResolvedJavaField, JavaConstant, OptionValues)::: constant fold util try constant fold:::if->field->isStatic->if->receiver->isNull->return->return->fieldProvider->new->ConstantFieldTool<ConstantNode>->readConstantField
GraphUtil#killCFGInner(FixedNode)::: graph util kill inner:::markedNodes->EconomicSet->create->unmarkedMerges->EconomicMap->create->node->replaceAtPredecessor->markFixedNodes->fixSurvivingAffectedMerges->debug->node->getDebug->debug->node->graph->dump->markUsages->foreach->foreach->marked->inputs->if->markedNodes->contains->marked->replaceFirstInput->tryKillUnused->debug->node->graph->dump->foreach->if->marked->isAlive->marked->markDeleted
GraphUtil#markFixedNodes(FixedNode, EconomicSet, EconomicMap>)::: graph util mark fixed nodes:::workStack->new->NodeStack->workStack->push->while->workStack->isEmpty->fixedNode->workStack->pop->markedNodes->add->if->unmarkedMerges->removeKey->while->next->if->markedNodes->add->if->foreach->fixedNode->successors->workStack->push->else->if->end->merge->end->merge->if->if->if->forwardEnd->workStack->push->continue->if->markedNodes->contains->continue->endsSeen->unmarkedMerges->get->if->merge->forwardEndCount->new->ArrayList<>->unmarkedMerges->put->endsSeen->add->if->endsSeen->size->merge->forwardEndCount->workStack->push
GraphUtil#fixSurvivingAffectedMerges(EconomicSet, EconomicMap>)::: graph util fix surviving affected merges:::cursor->unmarkedMerges->getEntries->while->cursor->advance->merge->cursor->getKey->foreach->cursor->getValue->merge->removeEnd->if->merge->phiPredecessorCount->if->loopBegin->foreach->loopBegin->loopExits->snapshot->if->markedNodes->contains->loopExit->replaceFirstInput->merge->graph->reduceDegenerateLoopBegin->else->merge->graph->reduceTrivialMerge->else
GraphUtil#markUsages(EconomicSet)::: graph util mark usages:::workStack->markedNodes->size->new->NodeStack->foreach->workStack->push->while->workStack->isEmpty->marked->workStack->pop->foreach->marked->usages->if->markedNodes->contains->workStack->push->markedNodes->add
GraphUtil#killCFG(FixedNode)::: graph util kill g:::debug->node->getDebug->try->scope->debug->scope->unusedNodes->unsafeNodes->nodeEventScope->options->node->getOptions->verifyGraalGraphEdges->getValue->verifyKillCFGUnusedNodes->getValue->if->node->graph->collectUnsafeNodes->if->collectedUnusedNodes->EconomicSet->create->node->graph->new->Graph.NodeEventListener->trackNodeEvents->debug->node->graph->dump->killCFGInner->debug->node->graph->dump->if->newUnsafeNodes->node->graph->collectUnsafeNodes->newUnsafeNodes->removeAll->if->nodeEventScope->close->iterator->unusedNodes->iterator->while->iterator->hasNext->curNode->iterator->next->if->curNode->isDeleted->iterator->remove->catch->throw->debug->handle->finally
GraphUtil#collectUnsafeNodes(Graph):::Collects all node in the graph which have non-optional inputs that are null.:::unsafeNodes->EconomicSet->create->foreach->graph->getNodes->foreach->n->inputPositions->input->pos->get->if->if->pos->isInputOptional->unsafeNodes->add->return
GraphUtil#isFloatingNode(Node)::: graph util is floating node:::return
GraphUtil#checkKill(Node, boolean)::: graph util check kill:::node->assertTrue->node->node->isAlive->assertTrue->node->node->hasNoUsages->node->usages->assertTrue->node->node->predecessor->node->predecessor->assertTrue->return
GraphUtil#killWithUnusedFloatingInputs(Node)::: graph util kill with unused floating inputs:::killWithUnusedFloatingInputs
GraphUtil#killWithUnusedFloatingInputs(Node, boolean)::: graph util kill with unused floating inputs:::node->markDeleted->foreach->node->inputs->if->in->isAlive->in->removeUsage->if->in->hasNoUsages->node->maybeNotifyZeroUsages->if->isFloatingNode->if->in->hasNoUsages->if->else->killWithUnusedFloatingInputs->else->if->foreach->in->usages->if->continue->in->replaceAtUsages->killWithUnusedFloatingInputs
GraphUtil#removeNewNodes(Graph, Graph.Mark):::Removes all nodes created after the mark, assuming no "old" nodes point to "new" nodes.:::foreach->graph->getNewNodes->n->markDeleted->foreach->n->inputs->in->removeUsage
GraphUtil#checkNoOldToNewEdges(Graph, Graph.Mark)::: graph util check no old to new edges:::foreach->graph->getNodes->if->graph->isNew->break->foreach->old->successors->foreach->old->inputs->return
GraphUtil#removeFixedWithUnusedInputs(FixedWithNextNode)::: graph util remove fixed with unused inputs:::if->stateAfter->stateAfter->if->setStateAfter->if->stateAfter->hasNoUsages->killWithUnusedFloatingInputs->unlinkFixedNode->killWithUnusedFloatingInputs
GraphUtil#unlinkFixedNode(FixedWithNextNode)::: graph util unlink fixed node:::next->fixed->next->fixed->setNext->fixed->replaceAtPredecessor
GraphUtil#checkRedundantPhi(PhiNode)::: graph util check redundant phi:::if->phiNode->isDeleted->phiNode->valueCount->return->singleValue->phiNode->singleValueOrThis->if->phiUsages->phiNode->usages->filter->snapshot->proxyUsages->phiNode->usages->filter->snapshot->phiNode->replaceAtUsagesAndDelete->foreach->checkRedundantPhi->foreach->checkRedundantProxy
GraphUtil#checkRedundantProxy(ProxyNode)::: graph util check redundant proxy:::if->vpn->isDeleted->return->proxyPoint->vpn->proxyPoint->if->exit->loopBegin->exit->loopBegin->vpnValue->vpn->value->foreach->loopBegin->stateAfter->values->v2->if->loopBegin->isPhiAtMerge->loopBegin->forwardEnd->valueAt->if->phiUsages->vpn->usages->filter->snapshot->proxyUsages->vpn->usages->filter->snapshot->vpn->replaceAtUsagesAndDelete->foreach->checkRedundantPhi->foreach->checkRedundantProxy->return
GraphUtil#normalizeLoops(StructuredGraph):::Remove loop header without loop ends:::loopRemoved->foreach->graph->getNodes->if->begin->loopEnds->isEmpty->graph->reduceDegenerateLoopBegin->else->normalizeLoopBegin->if->foreach->graph->getNodes->if->checkRedundantPhi
GraphUtil#normalizeLoopBegin(LoopBeginNode)::: graph util normalize loop begin:::foreach->begin->phis->snapshot->GraphUtil->checkRedundantPhi->foreach->begin->loopExits->foreach->exit->proxies->snapshot->GraphUtil->checkRedundantProxy
GraphUtil#approxSourceStackTraceElement(Node):::Gets an approximate source code location for a node if possible.:::position->node->getNodeSourcePosition->if->return->approxSourceStackTraceElement->elements->new->ArrayList<>->n->while->if->elements->targetMethod->asStackTraceElement->add->invoke->asNode->if->state->stateAfter->elements->Arrays->approxSourceStackTraceElement->asList->addAll->break->n->predecessor->return->elements->elements->size->new->StackTraceElementArr->toArray
GraphUtil#approxSourceStackTraceElement(FrameState):::Gets an approximate source code location for frame state.:::elements->new->ArrayList<>->state->while->code->state->getCode->if->elements->code->asStackTraceElement->add->state->outerFrameState->return->elements->new->StackTraceElementArr->toArray
GraphUtil#approxSourceStackTraceElement(BytecodePosition):::Gets approximate stack trace elements for a bytecode position.:::elements->new->ArrayList<>->position->while->method->position->getMethod->if->elements->method->position->getBCI->asStackTraceElement->add->position->getCaller->return->elements->new->StackTraceElementArr->toArray
GraphUtil#approxSourceException(Node, Throwable):::Gets an approximate source code location for a node, encoded as an exception, if possible.:::elements->approxSourceStackTraceElement->return->cause->getMessage->createBailoutException
GraphUtil#createBailoutException(String, Throwable, StackTraceElement[]):::Creates a bailout exception with the given stack trace elements and message.:::return->SourceStackTraceBailoutException->create
GraphUtil#approxSourceLocation(Node):::Gets an approximate source code location for a node if possible.:::stackTraceElements->approxSourceStackTraceElement->if->top->if->top->getFileName->top->getLineNumber->return->top->getFileName->top->getLineNumber->return
GraphUtil#toString(Iterable):::Returns a string representation of the given collection of objects.:::str->new->StringBuilder->str->append->foreach->str->append->append->if->str->length->str->str->length->setLength->str->append->return->str->toString
GraphUtil#unproxify(ValueNode):::Gets the original value by iterating through all ValueProxy ValueProxies.:::if->return->unproxify->else->return
GraphUtil#unproxify(ValueProxy):::Gets the original value by iterating through all ValueProxy ValueProxies.:::if->result->value->getOriginalNode->while->getOriginalNode->return->else->return
GraphUtil#skipPi(ValueNode)::: graph util skip pi:::n->while->piNode->piNode->getOriginalNode->return
GraphUtil#skipPiWhileNonNull(ValueNode)::: graph util skip pi while non null:::n->while->piNode->originalStamp->piNode->getOriginalNode->stamp->if->originalStamp->nonNull->piNode->getOriginalNode->else->break->return
GraphUtil#arrayLength(ValueNode, FindLengthMode, ConstantReflectionProvider):::Returns the length of the array described by the value parameter, or null if it is not available:::Objects->requireNonNull->current->do->if->return->findLength->else->if->return->phiArrayLength->else->if->proxy->length->proxy->getOriginalNode->arrayLength->if->length->isConstant->proxy->proxyPoint->new->ValueProxyNode->return->else->if->getOriginalNode->else->return->while
GraphUtil#phiArrayLength(ValuePhiNode, ArrayLengthProvider.FindLengthMode, ConstantReflectionProvider)::: graph util phi array length:::if->phi->merge->return->singleLength->for->i->phi->values->count->return
GraphUtil#originalValue(ValueNode):::Tries to find an original value of the given node by traversing through proxies and unambiguous phis:::result->originalValueSimple->return
GraphUtil#originalValueSimple(ValueNode)::: graph util original value simple:::cur->originalValueForProxy->while->phi->phiSingleValue->count->phi->valueCount->for->i->return
GraphUtil#originalValueForProxy(ValueNode)::: graph util original value for proxy:::cur->while->getOriginalNode->return
GraphUtil#originalValueForComplicatedPhi(PhiNode, NodeBitMap):::Handling for complicated nestings of phi functions:::if->visited->isMarked->return->visited->mark->phiSingleValue->count->phi->valueCount->for->i->return
GraphUtil#tryKillUnused(Node)::: graph util try kill unused:::if->node->isAlive->isFloatingNode->node->hasNoUsages->killWithUnusedFloatingInputs->return->return
GraphUtil#predecessorIterable(FixedNode):::Returns an iterator that will return the given node followed by all its predecessors, up until the point where Node#predecessor() returns null.:::return->new->NodeIterable<FixedNode>
GraphUtil.DefaultSimplifierTool#getMetaAccess()::: default simplifier tool get meta access:::return
GraphUtil.DefaultSimplifierTool#getConstantReflection()::: default simplifier tool get constant reflection:::return
GraphUtil.DefaultSimplifierTool#getConstantFieldProvider()::: default simplifier tool get constant field provider:::return
GraphUtil.DefaultSimplifierTool#canonicalizeReads()::: default simplifier tool canonicalize reads:::return
GraphUtil.DefaultSimplifierTool#allUsagesAvailable()::: default simplifier tool all usages available:::return
GraphUtil.DefaultSimplifierTool#deleteBranch(Node)::: default simplifier tool delete branch:::fixedBranch->fixedBranch->predecessor->replaceFirstSuccessor->GraphUtil->killCFG
GraphUtil.DefaultSimplifierTool#removeIfUnused(Node)::: default simplifier tool remove if unused:::GraphUtil->tryKillUnused
GraphUtil.DefaultSimplifierTool#addToWorkList(Node)::: default simplifier tool add to work list:::
GraphUtil.DefaultSimplifierTool#addToWorkList(Iterable)::: default simplifier tool add to work list:::
GraphUtil.DefaultSimplifierTool#getAssumptions()::: default simplifier tool get assumptions:::return
GraphUtil.DefaultSimplifierTool#getOptions()::: default simplifier tool get options:::return
GraphUtil.DefaultSimplifierTool#smallestCompareWidth()::: default simplifier tool smallest compare width:::if->return->loweringProvider->smallestCompareWidth->else->return
GraphUtil#getDefaultSimplifier(MetaAccessProvider, ConstantReflectionProvider, ConstantFieldProvider, boolean, Assumptions, OptionValues)::: graph util get default simplifier:::return->getDefaultSimplifier
GraphUtil#getDefaultSimplifier(MetaAccessProvider, ConstantReflectionProvider, ConstantFieldProvider, boolean, Assumptions, OptionValues, LoweringProvider)::: graph util get default simplifier:::return->new->DefaultSimplifierTool
GraphUtil#foldIfConstantAndRemove(ValueNode, ValueNode)::: graph util fold if constant and remove:::if->constant->isConstant->node->replaceFirstInput->result->constant->asConstant->tryKillUnused->return->return
GraphUtil#virtualizeArrayCopy(VirtualizerTool, ValueNode, ValueNode, ValueNode, ValueNode, ResolvedJavaType, JavaKind, StructuredGraph, BiFunction):::Virtualize an array copy.:::sourceAlias->tool->getAlias->replacedSourceLength->tool->getAlias->replacedNewLength->tool->getAlias->replacedFrom->tool->getAlias->if->replacedNewLength->isConstant->replacedFrom->isConstant->replacedSourceLength->isConstant->return->fromInt->replacedFrom->asJavaConstant->asInt->newLengthInt->replacedNewLength->asJavaConstant->asInt->sourceLengthInt->replacedSourceLength->asJavaConstant->asInt->if->sourceVirtual->if->return->if->tool->getMaximumEntryCount->return->newEntryState->new->ValueNodeArr->readLength->Math->min->if->sourceVirtual->alwaysAssignable->newComponentType->getJavaKind->newComponentType->isJavaLangObject->for->i->else->sourceType->StampTool->tool->getMetaAccess->typeOrNull->if->sourceType->isArray->newComponentType->sourceType->getElementalType->isAssignableFrom->return->for->i->if->defaultValue->ConstantNode->defaultForKind->for->i->newVirtualArray->virtualArrayProvider->apply->tool->Collections->emptyList->createVirtualObject->tool->replaceWithVirtual
JavaConstantFormattable#format(JavaConstantFormatter)::: java constant formattable format:::
JavaConstantFormatter#format(JavaConstant)::: java constant formatter format:::
