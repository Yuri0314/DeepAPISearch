AbstractObjectStamp#accept(Visitor)::: abstract object stamp accept:::super->accept->v->visitObject->v->visitBoolean
AbstractObjectStamp#copyWith(ResolvedJavaType, boolean, boolean, boolean)::: abstract object stamp copy with:::
AbstractObjectStamp#copyWith(boolean, boolean)::: abstract object stamp copy with:::return->copyWith
AbstractObjectStamp#unrestricted()::: abstract object stamp unrestricted:::return->copyWith
AbstractObjectStamp#empty()::: abstract object stamp empty:::return->copyWith
AbstractObjectStamp#constant(Constant, MetaAccessProvider)::: abstract object stamp constant:::jc->constType->jc->isNull->meta->lookupJavaType->return->jc->isNonNull->jc->isNonNull->jc->isNull->copyWith
AbstractObjectStamp#hasValues()::: abstract object stamp has values:::return->isConcreteType
AbstractObjectStamp#getStackKind()::: abstract object stamp get stack kind:::return
AbstractObjectStamp#javaType(MetaAccessProvider)::: abstract object stamp java type:::if->return->return->metaAccess->lookupJavaType
AbstractObjectStamp#type()::: abstract object stamp type:::return
AbstractObjectStamp#isExactType()::: abstract object stamp is exact type:::return
AbstractObjectStamp#appendString(StringBuilder)::: abstract object stamp append string:::if->this->isEmpty->str->append->else->str->nonNull->append->append->append->type->getName->append->alwaysNull->append
AbstractObjectStamp#meet(Stamp)::: abstract object stamp meet:::if->return->other->if->isEmpty->return->else->if->other->isEmpty->return->meetType->meetExactType->meetNonNull->meetAlwaysNull->if->other->alwaysNull->type->alwaysNull->else->if->alwaysNull->other->type->other->alwaysNull->else->type->other->type->meetTypes->if->Objects->equals->Objects->equals->nonNull->other->nonNull->if->Objects->equals->nonNull->alwaysNull->return->else->if->Objects->equals->other->nonNull->other->alwaysNull->return->else->return->copyWith
AbstractObjectStamp#join(Stamp)::: abstract object stamp join:::return->join0
AbstractObjectStamp#improveWith(Stamp):::Returns the stamp representing the type of this stamp after a cast to the type represented by the to stamp:::return->join0
AbstractObjectStamp#join0(Stamp, boolean)::: abstract object stamp join0:::if->return->other->if->isEmpty->return->else->if->other->isEmpty->return->joinType->joinAlwaysNull->alwaysNull->other->alwaysNull->joinNonNull->nonNull->other->nonNull->joinExactType->if->Objects->equals->else->if->else->if->else->if->type->isAssignableFrom->if->else->if->isAssignableFrom->if->else->if->else->if->isInterfaceOrArrayOfInterface->isInterfaceOrArrayOfInterface->if->if->return->empty->if->return->empty->else->if->isConcreteType->return->empty->if->Objects->equals->nonNull->alwaysNull->return->else->if->Objects->equals->other->nonNull->other->alwaysNull->return->else->return->copyWith
AbstractObjectStamp#isInterfaceOrArrayOfInterface(ResolvedJavaType)::: abstract object stamp is interface or array of interface:::return->t->isInterface->t->isArray->t->getElementalType->isInterface
AbstractObjectStamp#isConcreteType(ResolvedJavaType)::: abstract object stamp is concrete type:::return->type->isAbstract->type->isArray
AbstractObjectStamp#meetTypes(ResolvedJavaType, ResolvedJavaType)::: abstract object stamp meet types:::if->Objects->equals->return->else->if->return->else->hashA->a->getName->hashCode->hashB->b->getName->hashCode->if->return->meetOrderedNonNullTypes->else->if->return->meetOrderedNonNullTypes->else->diff->a->getName->b->getName->compareTo->if->return->meetOrderedNonNullTypes->else->return->meetOrderedNonNullTypes
AbstractObjectStamp#meetOrderedNonNullTypes(ResolvedJavaType, ResolvedJavaType)::: abstract object stamp meet ordered non null types:::result->a->findLeastCommonAncestor->if->result->isJavaLangObject->a->isInterface->b->isInterface->interfacesA->a->getInterfaces->interfacesB->b->getInterfaces->for->i->return
AbstractObjectStamp#hashCode()::: abstract object stamp hash code:::prime->result->super->hashCode->type->isJavaLangObject->type->hashCode->return
AbstractObjectStamp#equals(Object)::: abstract object stamp equals:::if->return->if->getClass->obj->getClass->return->other->if->return->if->if->isJavaLangObject->return->else->if->if->type->isJavaLangObject->return->else->if->type->equals->return->return->super->equals
AbstractPointerStamp#accept(Visitor)::: abstract pointer stamp accept:::v->visitBoolean->v->visitBoolean
AbstractPointerStamp#nonNull()::: abstract pointer stamp non null:::return
AbstractPointerStamp#alwaysNull()::: abstract pointer stamp always null:::return
AbstractPointerStamp#copyWith(boolean, boolean)::: abstract pointer stamp copy with:::
AbstractPointerStamp#hashCode()::: abstract pointer stamp hash code:::prime->result->return
AbstractPointerStamp#defaultPointerJoin(Stamp)::: abstract pointer stamp default pointer join:::other->joinNonNull->joinAlwaysNull->if->return->empty->else->return->copyWith
AbstractPointerStamp#improveWith(Stamp)::: abstract pointer stamp improve with:::return->join
AbstractPointerStamp#meet(Stamp)::: abstract pointer stamp meet:::other->meetNonNull->meetAlwaysNull->return->copyWith
AbstractPointerStamp#unrestricted()::: abstract pointer stamp unrestricted:::return->copyWith
AbstractPointerStamp#pointerNonNull(Stamp)::: abstract pointer stamp pointer non null:::pointer->return->pointer->asNonNull
AbstractPointerStamp#pointerMaybeNull(Stamp)::: abstract pointer stamp pointer maybe null:::pointer->return->pointer->asMaybeNull
AbstractPointerStamp#pointerAlwaysNull(Stamp)::: abstract pointer stamp pointer always null:::pointer->return->pointer->asAlwaysNull
AbstractPointerStamp#asNonNull()::: abstract pointer stamp as non null:::if->isEmpty->return->return->copyWith
AbstractPointerStamp#asMaybeNull()::: abstract pointer stamp as maybe null:::if->isEmpty->return->return->copyWith
AbstractPointerStamp#asAlwaysNull()::: abstract pointer stamp as always null:::if->isEmpty->return->return->copyWith
AbstractPointerStamp#equals(Object)::: abstract pointer stamp equals:::if->return->if->getClass->obj->getClass->return->other->return
AbstractPointerStamp#asConstant()::: abstract pointer stamp as constant:::if->return->nullConstant->return->super->asConstant
AbstractPointerStamp#nullConstant()::: abstract pointer stamp null constant:::return
AbstractPointerStamp#getStackKind()::: abstract pointer stamp get stack kind:::return
ArithmeticOpTable#forStamp(Stamp)::: arithmetic op table for stamp:::if->return->getOps->else->return
ArithmeticOpTable#getBinaryOps()::: arithmetic op table get binary ops:::return->new->BinaryOp<?>Arr
ArithmeticOpTable#getUnaryOps()::: arithmetic op table get unary ops:::return->new->UnaryOp<?>Arr
ArithmeticOpTable#getShiftOps()::: arithmetic op table get shift ops:::return->new->ShiftOp<?>Arr
ArithmeticOpTable#getIntegerConvertOps()::: arithmetic op table get integer convert ops:::return->new->IntegerConvertOp<?>Arr
ArithmeticOpTable.ArithmeticOpWrapper#wrapUnaryOp(UnaryOp)::: arithmetic op wrapper wrap unary op:::
ArithmeticOpTable.ArithmeticOpWrapper#wrapBinaryOp(BinaryOp)::: arithmetic op wrapper wrap binary op:::
ArithmeticOpTable.ArithmeticOpWrapper#wrapShiftOp(ShiftOp)::: arithmetic op wrapper wrap shift op:::
ArithmeticOpTable.ArithmeticOpWrapper#wrapIntegerConvertOp(IntegerConvertOp)::: arithmetic op wrapper wrap integer convert op:::
ArithmeticOpTable.ArithmeticOpWrapper#wrapFloatConvertOp(FloatConvertOp)::: arithmetic op wrapper wrap float convert op:::
ArithmeticOpTable#wrapIfNonNull(Function, T)::: arithmetic op table wrap if non null:::if->return->else->return->wrapper->apply
ArithmeticOpTable#wrap(ArithmeticOpWrapper, ArithmeticOpTable)::: arithmetic op table wrap:::neg->wrapper->wrapUnaryOp->inner->getNeg->wrapIfNonNull->add->wrapper->wrapBinaryOp->inner->getAdd->wrapIfNonNull->sub->wrapper->wrapBinaryOp->inner->getSub->wrapIfNonNull->mul->wrapper->wrapBinaryOp->inner->getMul->wrapIfNonNull->mulHigh->wrapper->wrapBinaryOp->inner->getMulHigh->wrapIfNonNull->umulHigh->wrapper->wrapBinaryOp->inner->getUMulHigh->wrapIfNonNull->div->wrapper->wrapBinaryOp->inner->getDiv->wrapIfNonNull->rem->wrapper->wrapBinaryOp->inner->getRem->wrapIfNonNull->not->wrapper->wrapUnaryOp->inner->getNot->wrapIfNonNull->and->wrapper->wrapBinaryOp->inner->getAnd->wrapIfNonNull->or->wrapper->wrapBinaryOp->inner->getOr->wrapIfNonNull->xor->wrapper->wrapBinaryOp->inner->getXor->wrapIfNonNull->shl->wrapper->wrapShiftOp->inner->getShl->wrapIfNonNull->shr->wrapper->wrapShiftOp->inner->getShr->wrapIfNonNull->ushr->wrapper->wrapShiftOp->inner->getUShr->wrapIfNonNull->abs->wrapper->wrapUnaryOp->inner->getAbs->wrapIfNonNull->sqrt->wrapper->wrapUnaryOp->inner->getSqrt->wrapIfNonNull->zeroExtend->wrapper->wrapIntegerConvertOp->inner->getZeroExtend->wrapIfNonNull->signExtend->wrapper->wrapIntegerConvertOp->inner->getSignExtend->wrapIfNonNull->narrow->wrapper->wrapIntegerConvertOp->inner->getNarrow->wrapIfNonNull->floatConvert->CollectionsUtil->Objects->nonNull->wrapper->wrapFloatConvertOp->FloatConvertOp[]->new->filterAndMapToArray->return->new->ArithmeticOpTable
ArithmeticOpTable#hashCode()::: arithmetic op table hash code:::return
ArithmeticOpTable#getNeg():::Describes the unary negation operation.:::return
ArithmeticOpTable#getAdd():::Describes the addition operation.:::return
ArithmeticOpTable#getSub():::Describes the subtraction operation.:::return
ArithmeticOpTable#getMul():::Describes the multiplication operation.:::return
ArithmeticOpTable#getMulHigh():::Describes a signed operation that multiples the upper 32-bits of two long values.:::return
ArithmeticOpTable#getUMulHigh():::Describes an unsigned operation that multiples the upper 32-bits of two long values.:::return
ArithmeticOpTable#getDiv():::Describes the division operation.:::return
ArithmeticOpTable#getRem():::Describes the remainder operation.:::return
ArithmeticOpTable#getNot():::Describes the bitwise not operation.:::return
ArithmeticOpTable#getAnd():::Describes the bitwise and operation.:::return
ArithmeticOpTable#getOr():::Describes the bitwise or operation.:::return
ArithmeticOpTable#getXor():::Describes the bitwise xor operation.:::return
ArithmeticOpTable#getShl():::Describes the shift left operation.:::return
ArithmeticOpTable#getShr():::Describes the signed shift right operation.:::return
ArithmeticOpTable#getUShr():::Describes the unsigned shift right operation.:::return
ArithmeticOpTable#getAbs():::Describes the absolute value operation.:::return
ArithmeticOpTable#getSqrt():::Describes the square root operation.:::return
ArithmeticOpTable#getZeroExtend():::Describes the zero extend conversion.:::return
ArithmeticOpTable#getSignExtend():::Describes the sign extend conversion.:::return
ArithmeticOpTable#getNarrow():::Describes the narrowing conversion.:::return
ArithmeticOpTable#getFloatConvert(FloatConvert):::Describes integer/float/double conversions.:::return->op->ordinal
ArithmeticOpTable#toString(Op...)::: arithmetic op table to string:::return->CollectionsUtil->o->getClass->getSimpleName->mapAndJoin
ArithmeticOpTable#opsEquals(ArithmeticOpTable)::: arithmetic op table ops equals:::return->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals->Objects->equals
ArithmeticOpTable#equals(Object)::: arithmetic op table equals:::if->return->if->return->if->getClass->obj->getClass->return->that->if->opsEquals->if->Arrays->equals->return->return
ArithmeticOpTable#toString()::: arithmetic op table to string:::return->getClass->getSimpleName->toString->toString
ArithmeticOpTable.Op#toString()::: op to string:::return
ArithmeticOpTable.Op#hashCode()::: op hash code:::return->operator->hashCode
ArithmeticOpTable.Op#equals(Object)::: op equals:::if->return->if->return->if->getClass->obj->getClass->return->that->if->operator->equals->return->return
ArithmeticOpTable.UnaryOp#foldConstant(Constant):::Apply the operation to a Constant.:::
ArithmeticOpTable.UnaryOp#foldStamp(Stamp):::Apply the operation to a Stamp.:::
ArithmeticOpTable.UnaryOp#unwrap()::: unary op unwrap:::return
ArithmeticOpTable.BinaryOp#foldConstant(Constant, Constant):::Applies this operation to a and b.:::
ArithmeticOpTable.BinaryOp#foldStamp(Stamp, Stamp):::Apply the operation to two Stamp Stamps.:::
ArithmeticOpTable.BinaryOp#isAssociative():::Checks whether this operation is associative:::return
ArithmeticOpTable.BinaryOp#isCommutative():::Checks whether this operation is commutative:::return
ArithmeticOpTable.BinaryOp#isNeutral(Constant):::Check whether a Constant is a neutral element for this operation:::return
ArithmeticOpTable.BinaryOp#getZero(Stamp):::Check whether this operation has a zero {@code z == a :::return
ArithmeticOpTable.BinaryOp#unwrap()::: binary op unwrap:::return
ArithmeticOpTable.BinaryOp#hashCode()::: binary op hash code:::prime->result->super->hashCode->return
ArithmeticOpTable.BinaryOp#equals(Object)::: binary op equals:::if->return->if->super->equals->return->if->getClass->obj->getClass->return->that->if->return->if->return->return
ArithmeticOpTable.BinaryOp#toString()::: binary op to string:::if->if->return->super->toString->else->return->super->toString->else->if->return->super->toString->return->super->toString
ArithmeticOpTable.ShiftOp#foldConstant(Constant, int):::Apply the shift to a constant.:::
ArithmeticOpTable.ShiftOp#foldStamp(Stamp, IntegerStamp):::Apply the shift to a stamp.:::
ArithmeticOpTable.ShiftOp#getShiftAmountMask(Stamp):::Get the shift amount mask for a given result stamp.:::
ArithmeticOpTable.FloatConvertOp#getFloatConvert()::: float convert op get float convert:::return
ArithmeticOpTable.FloatConvertOp#unwrap()::: float convert op unwrap:::return
ArithmeticOpTable.FloatConvertOp#hashCode()::: float convert op hash code:::prime->return->super->hashCode->op->hashCode
ArithmeticOpTable.FloatConvertOp#equals(Object)::: float convert op equals:::if->return->if->super->equals->return->if->getClass->obj->getClass->return->that->if->return->return
ArithmeticOpTable.IntegerConvertOp.Narrow#invertStamp(int, int, Stamp)::: narrow invert stamp:::return
ArithmeticOpTable.IntegerConvertOp#foldConstant(int, int, Constant)::: integer convert op fold constant:::
ArithmeticOpTable.IntegerConvertOp#foldStamp(int, int, Stamp)::: integer convert op fold stamp:::
ArithmeticOpTable.IntegerConvertOp#unwrap()::: integer convert op unwrap:::return
ArithmeticOpTable.IntegerConvertOp#invertStamp(int, int, Stamp):::Computes the stamp of the input for the given output stamp.:::
ArithmeticStamp#getOps()::: arithmetic stamp get ops:::return
ArithmeticStamp#deserialize(ByteBuffer)::: arithmetic stamp deserialize:::
ArithmeticStamp#improveWith(Stamp)::: arithmetic stamp improve with:::if->this->isCompatible->return->this->join->return
ArithmeticStamp#hashCode()::: arithmetic stamp hash code:::prime->result->ops->hashCode->return
ArithmeticStamp#equals(Object)::: arithmetic stamp equals:::if->return->if->return->return
DataPointerConstant#getAlignment():::Get the minimum alignment of the data in the data section.:::return
DataPointerConstant#isDefaultForKind()::: data pointer constant is default for kind:::return
FloatStamp#unrestricted()::: float stamp unrestricted:::return->getBits->new->FloatStamp
FloatStamp#empty()::: float stamp empty:::return->getBits->new->FloatStamp
FloatStamp#constant(Constant, MetaAccessProvider)::: float stamp constant:::jc->return->StampFactory->forConstant
FloatStamp#deserialize(ByteBuffer)::: float stamp deserialize:::switch->getBits->return->JavaConstant->buffer->getFloat->forFloat->return->JavaConstant->buffer->getDouble->forDouble->throw->GraalError->shouldNotReachHere
FloatStamp#hasValues()::: float stamp has values:::return
FloatStamp#getStackKind()::: float stamp get stack kind:::if->getBits->return->else->return
FloatStamp#getLIRKind(LIRKindTool)::: float stamp get kind:::return->tool->getBits->getFloatingKind
FloatStamp#javaType(MetaAccessProvider)::: float stamp java type:::switch->getBits->return->metaAccess->lookupJavaType->return->metaAccess->lookupJavaType->throw->GraalError->shouldNotReachHere
FloatStamp#lowerBound():::The (inclusive) lower bound on the value described by this stamp.:::return
FloatStamp#upperBound():::The (inclusive) upper bound on the value described by this stamp.:::return
FloatStamp#isNonNaN():::Returns true if NaN is non included in the value described by this stamp.:::return
FloatStamp#canBeNaN():::Returns true if NaN is included in the value described by this stamp.:::return
FloatStamp#isNaN():::Returns true if this stamp represents the NaN value.:::return->Double->isNaN
FloatStamp#isUnrestricted()::: float stamp is unrestricted:::return
FloatStamp#contains(double)::: float stamp contains:::if->Double->isNaN->return->else->return
FloatStamp#toString()::: float stamp to string:::str->new->StringBuilder->str->append->str->getBits->append->if->hasValues->str->append->if->str->append->append->append->else->if->str->append->append->append->append->append->else->str->append->return->str->toString
FloatStamp#meetBounds(double, double, DoubleBinaryOperator)::: float stamp meet bounds:::if->Double->isNaN->return->else->if->Double->isNaN->return->else->return->op->applyAsDouble
FloatStamp#meet(Stamp)::: float stamp meet:::if->return->if->isEmpty->return->if->otherStamp->isEmpty->return->other->meetUpperBound->Math->max->meetBounds->meetLowerBound->Math->min->meetBounds->meetNonNaN->if->Double->compare->Double->compare->return->else->if->Double->compare->Double->compare->return->else->return->getBits->new->FloatStamp
FloatStamp#join(Stamp)::: float stamp join:::if->return->other->joinUpperBound->Math->min->joinLowerBound->Math->max->joinNonNaN->if->Double->compare->Double->compare->return->else->if->Double->compare->Double->compare->return->else->return->getBits->new->FloatStamp
FloatStamp#hashCode()::: float stamp hash code:::prime->result->temp->super->hashCode->Double->doubleToLongBits->Double->doubleToLongBits->return
FloatStamp#isCompatible(Stamp)::: float stamp is compatible:::if->return->if->other->return->getBits->other->getBits->return
FloatStamp#isCompatible(Constant)::: float stamp is compatible:::if->prim->return->prim->getJavaKind->isNumericFloat->return
FloatStamp#equals(Object)::: float stamp equals:::if->return->if->getClass->obj->getClass->super->equals->return->other->if->Double->doubleToLongBits->Double->doubleToLongBits->return->if->Double->doubleToLongBits->Double->doubleToLongBits->return->if->return->return->super->equals
FloatStamp#asConstant()::: float stamp as constant:::if->isConstant->switch->getBits->return->JavaConstant->forFloat->return->JavaConstant->forDouble->return
FloatStamp#isConstant()::: float stamp is constant:::return->Double->compare
FloatStamp#stampForConstant(Constant)::: float stamp stamp for constant:::result->value->switch->value->getJavaKind->if->Float->value->asFloat->isNaN->new->FloatStamp->else->value->asFloat->value->asFloat->Float->value->asFloat->isNaN->new->FloatStamp->break->if->Double->value->asDouble->isNaN->new->FloatStamp->else->value->asDouble->value->asDouble->Double->value->asDouble->isNaN->new->FloatStamp->break->throw->GraalError->shouldNotReachHere->if->result->isConstant->return->return
FloatStamp#maybeFoldConstant(UnaryOp, FloatStamp)::: float stamp maybe fold constant:::if->stamp->isConstant->constant->stamp->asConstant->folded->op->foldConstant->if->return->FloatStamp->stampForConstant->return
FloatStamp#maybeFoldConstant(BinaryOp, FloatStamp, FloatStamp)::: float stamp maybe fold constant:::if->stamp1->isConstant->stamp2->isConstant->constant1->stamp1->asConstant->constant2->stamp2->asConstant->folded->op->foldConstant->if->stamp->stampForConstant->if->stamp->isConstant->return->return
IllegalStamp#accept(Visitor)::: illegal stamp accept:::
IllegalStamp#getStackKind()::: illegal stamp get stack kind:::return
IllegalStamp#getLIRKind(LIRKindTool)::: illegal stamp get kind:::return
IllegalStamp#unrestricted()::: illegal stamp unrestricted:::return
IllegalStamp#isUnrestricted()::: illegal stamp is unrestricted:::return
IllegalStamp#empty()::: illegal stamp empty:::return
IllegalStamp#constant(Constant, MetaAccessProvider)::: illegal stamp constant:::return
IllegalStamp#javaType(MetaAccessProvider)::: illegal stamp java type:::throw->GraalError->shouldNotReachHere
IllegalStamp#meet(Stamp)::: illegal stamp meet:::return
IllegalStamp#join(Stamp)::: illegal stamp join:::return
IllegalStamp#isCompatible(Stamp)::: illegal stamp is compatible:::return
IllegalStamp#isCompatible(Constant)::: illegal stamp is compatible:::if->prim->return->prim->getJavaKind->return
IllegalStamp#toString()::: illegal stamp to string:::return
IllegalStamp#hasValues()::: illegal stamp has values:::return
IllegalStamp#improveWith(Stamp)::: illegal stamp improve with:::return
IllegalStamp#readConstant(MemoryAccessProvider, Constant, long)::: illegal stamp read constant:::throw->GraalError->shouldNotReachHere
IllegalStamp#getInstance()::: illegal stamp get instance:::return
IntegerStamp#create(int, long, long)::: integer stamp create:::return->CodeUtil->mask->create
IntegerStamp#create(int, long, long, long, long)::: integer stamp create:::minValue->minValueForMasks->lowerBoundTmp->Math->max->maxValue->maxValueForMasks->upperBoundTmp->Math->min->boundedDownMask->boundedUpMask->defaultMask->CodeUtil->mask->if->else->if->upperBoundLeadingZeros->Long->numberOfLeadingZeros->differentBits->sameBitCount->Long->numberOfLeadingZeros->else->if->else->lowerBoundLeadingOnes->Long->numberOfLeadingZeros->differentBits->sameBitCount->Long->numberOfLeadingZeros->return->new->IntegerStamp
IntegerStamp#significantBit(long, long)::: integer stamp significant bit:::return
IntegerStamp#minValueForMasks(int, long, long)::: integer stamp min value for masks:::if->significantBit->return->else->return
IntegerStamp#maxValueForMasks(int, long, long)::: integer stamp max value for masks:::if->significantBit->return->CodeUtil->signExtend->else->return->CodeUtil->mask
IntegerStamp#stampForMask(int, long, long)::: integer stamp stamp for mask:::return->minValueForMasks->maxValueForMasks->new->IntegerStamp
IntegerStamp#unrestricted()::: integer stamp unrestricted:::return->getBits->CodeUtil->getBits->minValue->CodeUtil->getBits->maxValue->CodeUtil->getBits->mask->new->IntegerStamp
IntegerStamp#empty()::: integer stamp empty:::return->getBits->CodeUtil->getBits->maxValue->CodeUtil->getBits->minValue->CodeUtil->getBits->mask->new->IntegerStamp
IntegerStamp#constant(Constant, MetaAccessProvider)::: integer stamp constant:::if->value->asLong->return->StampFactory->getBits->forInteger->return
IntegerStamp#deserialize(ByteBuffer)::: integer stamp deserialize:::switch->getBits->return->JavaConstant->buffer->get->forBoolean->return->JavaConstant->buffer->get->forByte->return->JavaConstant->buffer->getShort->forShort->return->JavaConstant->buffer->getInt->forInt->return->JavaConstant->buffer->getLong->forLong->throw->GraalError->shouldNotReachHere
IntegerStamp#hasValues()::: integer stamp has values:::return
IntegerStamp#getStackKind()::: integer stamp get stack kind:::if->getBits->return->else->return
IntegerStamp#getLIRKind(LIRKindTool)::: integer stamp get kind:::return->tool->getBits->getIntegerKind
IntegerStamp#javaType(MetaAccessProvider)::: integer stamp java type:::switch->getBits->return->metaAccess->lookupJavaType->return->metaAccess->lookupJavaType->return->metaAccess->lookupJavaType->return->metaAccess->lookupJavaType->return->metaAccess->lookupJavaType->throw->GraalError->shouldNotReachHere
IntegerStamp#lowerBound():::The signed inclusive lower bound on the value described by this stamp.:::return
IntegerStamp#upperBound():::The signed inclusive upper bound on the value described by this stamp.:::return
IntegerStamp#downMask():::This bit-mask describes the bits that are always set in the value described by this stamp.:::return
IntegerStamp#upMask():::This bit-mask describes the bits that can be set in the value described by this stamp.:::return
IntegerStamp#isUnrestricted()::: integer stamp is unrestricted:::return->CodeUtil->getBits->minValue->CodeUtil->getBits->maxValue->CodeUtil->getBits->mask
IntegerStamp#contains(long)::: integer stamp contains:::return->CodeUtil->getBits->mask
IntegerStamp#isPositive()::: integer stamp is positive:::return->lowerBound
IntegerStamp#isNegative()::: integer stamp is negative:::return->upperBound
IntegerStamp#isStrictlyPositive()::: integer stamp is strictly positive:::return->lowerBound
IntegerStamp#isStrictlyNegative()::: integer stamp is strictly negative:::return->upperBound
IntegerStamp#canBePositive()::: integer stamp can be positive:::return->upperBound
IntegerStamp#canBeNegative()::: integer stamp can be negative:::return->lowerBound
IntegerStamp#toString()::: integer stamp to string:::str->new->StringBuilder->str->append->str->getBits->append->if->hasValues->if->str->append->append->append->else->if->CodeUtil->getBits->minValue->CodeUtil->getBits->maxValue->str->append->append->append->append->append->if->str->append->new->Formatter->format->if->CodeUtil->getBits->mask->str->append->new->Formatter->format->else->str->append->return->str->toString
IntegerStamp#createStamp(IntegerStamp, long, long, long, long)::: integer stamp create stamp:::if->return->empty->else->if->return->else->if->return->else->return->IntegerStamp->getBits->create
IntegerStamp#meet(Stamp)::: integer stamp meet:::if->return->if->isEmpty->return->if->otherStamp->isEmpty->return->other->return->Math->max->Math->min->createStamp
IntegerStamp#join(Stamp)::: integer stamp join:::if->return->other->newDownMask->newLowerBound->Math->max->newUpperBound->Math->min->newUpMask->return->createStamp
IntegerStamp#isCompatible(Stamp)::: integer stamp is compatible:::if->return->if->other->return->getBits->other->getBits->return
IntegerStamp#isCompatible(Constant)::: integer stamp is compatible:::if->prim->return->prim->getJavaKind->isNumericInteger->return
IntegerStamp#unsignedUpperBound()::: integer stamp unsigned upper bound:::if->sameSignBounds->return->CodeUtil->upperBound->getBits->zeroExtend->return->NumUtil->getBits->maxValueUnsigned
IntegerStamp#unsignedLowerBound()::: integer stamp unsigned lower bound:::if->sameSignBounds->return->CodeUtil->lowerBound->getBits->zeroExtend->return
IntegerStamp#sameSignBounds()::: integer stamp same sign bounds:::return->NumUtil->sameSign
IntegerStamp#hashCode()::: integer stamp hash code:::prime->result->super->hashCode->return
IntegerStamp#equals(Object)::: integer stamp equals:::if->return->if->getClass->obj->getClass->super->equals->return->other->if->return->return->super->equals
IntegerStamp#upMaskFor(int, long, long)::: integer stamp up mask for:::mask->if->return->else->return->Long->numberOfLeadingZeros->CodeUtil->mask
IntegerStamp#sameSign(IntegerStamp, IntegerStamp):::Checks if the 2 stamps represent values of the same sign:::return->s1->isPositive->s2->isPositive->s1->isStrictlyNegative->s2->isStrictlyNegative
IntegerStamp#asConstant()::: integer stamp as constant:::if->switch->getBits->return->JavaConstant->forBoolean->return->JavaConstant->forByte->return->JavaConstant->forShort->return->JavaConstant->forInt->return->JavaConstant->forLong->return
IntegerStamp#addCanOverflow(IntegerStamp, IntegerStamp)::: integer stamp add can overflow:::return->a->upperBound->b->upperBound->a->getBits->addOverflowsPositively->a->lowerBound->b->lowerBound->a->getBits->addOverflowsNegatively
IntegerStamp#addOverflowsPositively(long, long, int)::: integer stamp add overflows positively:::result->if->return->else->return->CodeUtil->maxValue
IntegerStamp#addOverflowsNegatively(long, long, int)::: integer stamp add overflows negatively:::result->if->return->else->return->CodeUtil->minValue
IntegerStamp#carryBits(long, long)::: integer stamp carry bits:::return
IntegerStamp#saturate(long, int)::: integer stamp saturate:::if->max->CodeUtil->maxValue->if->return->min->CodeUtil->minValue->if->return->return
IntegerStamp#multiplicationOverflows(long, long, int)::: integer stamp multiplication overflows:::result->positive->if->if->return->else->if->return->else->if->return->else->return->else->if->return->CodeUtil->maxValue->else->return->CodeUtil->minValue
IntegerStamp#multiplicationCanOverflow(IntegerStamp, IntegerStamp)::: integer stamp multiplication can overflow:::if->a->upMask->return->else->if->b->upMask->return->if->a->isUnrestricted->return->if->b->isUnrestricted->return->bits->a->getBits->minNegA->a->lowerBound->maxNegA->Math->a->upperBound->min->minPosA->Math->a->lowerBound->max->maxPosA->a->upperBound->minNegB->b->lowerBound->maxNegB->Math->b->upperBound->min->minPosB->Math->b->lowerBound->max->maxPosB->b->upperBound->mayOverflow->if->a->canBePositive->if->b->canBePositive->IntegerStamp->multiplicationOverflows->IntegerStamp->multiplicationOverflows->if->b->canBeNegative->IntegerStamp->multiplicationOverflows->IntegerStamp->multiplicationOverflows->if->a->canBeNegative->if->b->canBePositive->IntegerStamp->multiplicationOverflows->IntegerStamp->multiplicationOverflows->if->b->canBeNegative->IntegerStamp->multiplicationOverflows->IntegerStamp->multiplicationOverflows->return
IntegerStamp#subtractionCanOverflow(IntegerStamp, IntegerStamp)::: integer stamp subtraction can overflow:::return->x->lowerBound->y->upperBound->x->getBits->subtractionOverflows->x->upperBound->y->lowerBound->x->getBits->subtractionOverflows
IntegerStamp#subtractionOverflows(long, long, int)::: integer stamp subtraction overflows:::result->if->return->return->CodeUtil->minValue->CodeUtil->maxValue
ObjectStamp#copyWith(ResolvedJavaType, boolean, boolean, boolean)::: object stamp copy with:::return->new->ObjectStamp
ObjectStamp#unrestricted()::: object stamp unrestricted:::return->StampFactory->object
ObjectStamp#toString()::: object stamp to string:::str->new->StringBuilder->str->append->appendString->return->str->toString
ObjectStamp#isCompatible(Stamp)::: object stamp is compatible:::if->return->if->return->return
ObjectStamp#isCompatible(Constant)::: object stamp is compatible:::if->return->getJavaKind->isObject->return
ObjectStamp#getLIRKind(LIRKindTool)::: object stamp get kind:::return->tool->getObjectKind
ObjectStamp#readConstant(MemoryAccessProvider, Constant, long)::: object stamp read constant:::try->return->provider->readObjectConstant->catch->return->finally
ObjectStamp#makeSymbolic():::Convert an ObjectStamp into a representation that can be resolved symbolically into the original stamp.:::if->type->return->return->new->SymbolicObjectStamp
ObjectStamp.SymbolicObjectStamp#resolve(ResolvedJavaType)::: symbolic object stamp resolve:::return->type->resolve->new->ObjectStamp
ObjectStamp.SymbolicObjectStamp#toString()::: symbolic object stamp to string:::return
PrimitiveStamp#accept(Visitor)::: primitive stamp accept:::v->visitInt
PrimitiveStamp#getBits():::The width in bits of the value described by this stamp.:::return
PrimitiveStamp#getBits(Stamp)::: primitive stamp get bits:::if->return->getBits->else->return
PrimitiveStamp#readConstant(MemoryAccessProvider, Constant, long)::: primitive stamp read constant:::try->return->provider->getStackKind->getBits->readPrimitiveConstant->catch->return->finally
PrimitiveStamp#hashCode()::: primitive stamp hash code:::prime->result->super->hashCode->return
PrimitiveStamp#equals(Object)::: primitive stamp equals:::if->return->if->return->other->if->return->return->super->equals
RawPointerStamp#getLIRKind(LIRKindTool)::: raw pointer stamp get kind:::return->tool->getWordKind
RawPointerStamp#copyWith(boolean, boolean)::: raw pointer stamp copy with:::return
RawPointerStamp#meet(Stamp)::: raw pointer stamp meet:::return
RawPointerStamp#improveWith(Stamp)::: raw pointer stamp improve with:::return
RawPointerStamp#join(Stamp)::: raw pointer stamp join:::return
RawPointerStamp#unrestricted()::: raw pointer stamp unrestricted:::return
RawPointerStamp#empty()::: raw pointer stamp empty:::return
RawPointerStamp#hasValues()::: raw pointer stamp has values:::return
RawPointerStamp#javaType(MetaAccessProvider)::: raw pointer stamp java type:::throw->GraalError->shouldNotReachHere
RawPointerStamp#constant(Constant, MetaAccessProvider)::: raw pointer stamp constant:::return
RawPointerStamp#isCompatible(Stamp)::: raw pointer stamp is compatible:::return
RawPointerStamp#isCompatible(Constant)::: raw pointer stamp is compatible:::if->return->getJavaKind->isNumericInteger->else->return
RawPointerStamp#readConstant(MemoryAccessProvider, Constant, long)::: raw pointer stamp read constant:::throw->GraalError->shouldNotReachHere
RawPointerStamp#toString()::: raw pointer stamp to string:::return
Stamp#javaType(MetaAccessProvider):::Returns the type of the stamp, guaranteed to be non-null:::
Stamp#alwaysDistinct(Stamp)::: stamp always distinct:::return->join->isEmpty
Stamp#getStackKind():::Gets a Java JavaKind that can be used to store a value of this stamp on the Java bytecode stack:::
Stamp#getLIRKind(LIRKindTool):::Gets a platform dependent LIRKind that can be used to store a value of this stamp.:::
Stamp#meet(Stamp):::Returns the union of this stamp and the given stamp:::
Stamp#join(Stamp):::Returns the intersection of this stamp and the given stamp.:::
Stamp#unrestricted():::Returns a stamp of the same kind, but allowing the full value range of the kind:::
Stamp#empty():::Returns a stamp of the same kind, but with no allowed values:::
Stamp#constant(Constant, MetaAccessProvider):::If it is possible to represent single value stamps of this kind, this method returns the stamp representing the single value c:::
Stamp#isCompatible(Stamp):::Test whether two stamps have the same base type.:::
Stamp#isCompatible(Constant):::Check that the constant other is compatible with this stamp.:::
Stamp#hasValues():::Test whether this stamp has legal values.:::
Stamp#isEmpty():::Tests whether this stamp represents an illegal value.:::return->hasValues
Stamp#isUnrestricted():::Tests whether this stamp represents all values of this kind.:::return->this->this->unrestricted->equals
Stamp#asConstant():::If this stamp represents a single value, the methods returns this single value:::return
Stamp#readConstant(MemoryAccessProvider, Constant, long):::Read a value of this stamp from memory.:::
Stamp#improveWith(Stamp):::Tries to improve this stamp with the stamp given as parameter:::
Stamp#tryImproveWith(Stamp):::Tries to improve this stamp with the stamp given as parameter:::improved->improveWith->if->improved->equals->return->return
Stamp#neverDistinct(Stamp)::: stamp never distinct:::constant->this->asConstant->if->otherConstant->other->asConstant->return->constant->equals->return
Stamp#makeSymbolic():::Convert a Stamp into a representation that can be resolved symbolically into the original stamp:::return
Stamp#toString()::: stamp to string:::
StampFactory#setCache(JavaKind, Stamp)::: stamp factory set cache:::kind->ordinal
StampFactory#setIntCache(JavaKind)::: stamp factory set int cache:::bits->kind->getStackKind->getBitCount->mask->if->kind->isUnsigned->CodeUtil->kind->getBitCount->mask->else->CodeUtil->mask->IntegerStamp->kind->getMinValue->kind->getMaxValue->create->setCache
StampFactory#setFloatCache(JavaKind)::: stamp factory set float cache:::kind->getBitCount->new->FloatStamp->setCache
StampFactory#tautology()::: stamp factory tautology:::return
StampFactory#contradiction()::: stamp factory contradiction:::return
StampFactory#forKind(JavaKind):::Return a stamp for a Java kind, as it would be represented on the bytecode stack.:::return->kind->ordinal
StampFactory#forVoid():::Return the stamp for the void type:::return->VoidStamp->getInstance
StampFactory#intValue()::: stamp factory int value:::return->forKind
StampFactory#positiveInt()::: stamp factory positive int:::return
StampFactory#empty(JavaKind)::: stamp factory empty:::return->kind->ordinal
StampFactory#forInteger(JavaKind, long, long, long, long)::: stamp factory for integer:::return->IntegerStamp->kind->getBitCount->create
StampFactory#forInteger(JavaKind, long, long)::: stamp factory for integer:::return->kind->getBitCount->forInteger
StampFactory#forIntegerWithMask(int, long, long, IntegerStamp):::Create a new stamp use newLowerBound and newUpperBound computing the appropriate IntegerStamp#upMask and IntegerStamp#downMask and incorporating any mask information from maskStamp.:::limit->StampFactory->forInteger->return->IntegerStamp->limit->downMask->maskStamp->downMask->limit->upMask->maskStamp->upMask->create
StampFactory#forIntegerWithMask(int, long, long, long, long)::: stamp factory for integer with mask:::limit->StampFactory->forInteger->return->IntegerStamp->limit->downMask->limit->upMask->create
StampFactory#forInteger(int)::: stamp factory for integer:::return->IntegerStamp->CodeUtil->minValue->CodeUtil->maxValue->CodeUtil->mask->create
StampFactory#forUnsignedInteger(int)::: stamp factory for unsigned integer:::return->NumUtil->maxValueUnsigned->CodeUtil->mask->forUnsignedInteger
StampFactory#forUnsignedInteger(int, long, long)::: stamp factory for unsigned integer:::return->CodeUtil->mask->forUnsignedInteger
StampFactory#forUnsignedInteger(int, long, long, long, long)::: stamp factory for unsigned integer:::lowerBound->signExtend->upperBound->signExtend->if->NumUtil->sameSign->CodeUtil->minValue->CodeUtil->maxValue->mask->CodeUtil->mask->return->IntegerStamp->create
StampFactory#forInteger(int, long, long)::: stamp factory for integer:::return->IntegerStamp->CodeUtil->mask->create
StampFactory#forFloat(JavaKind, double, double, boolean)::: stamp factory for float:::return->kind->getBitCount->new->FloatStamp
StampFactory#forConstant(JavaConstant)::: stamp factory for constant:::kind->value->getJavaKind->switch->mask->value->asLong->CodeUtil->kind->getBitCount->mask->return->kind->getStackKind->value->asLong->value->asLong->forInteger->return->value->asFloat->value->asFloat->Float->value->asFloat->isNaN->forFloat->return->value->asDouble->value->asDouble->Double->value->asDouble->isNaN->forFloat->return->forKind->if->value->isNull->return->alwaysNull->else->return->objectNonNull->throw->new->GraalError
StampFactory#forConstant(JavaConstant, MetaAccessProvider)::: stamp factory for constant:::if->value->getJavaKind->type->value->isNull->metaAccess->lookupJavaType->return->value->isNonNull->value->isNonNull->value->isNull->new->ObjectStamp->else->return->forConstant
StampFactory#object()::: stamp factory object:::return
StampFactory#objectNonNull()::: stamp factory object non null:::return
StampFactory#alwaysNull()::: stamp factory always null:::return
StampFactory#object(TypeReference)::: stamp factory object:::return->object
StampFactory#objectNonNull(TypeReference)::: stamp factory object non null:::return->object
StampFactory#object(TypeReference, boolean)::: stamp factory object:::if->return->new->ObjectStamp->else->return->type->getType->type->isExact->new->ObjectStamp
StampFactory#createParameterStamps(Assumptions, ResolvedJavaMethod)::: stamp factory create parameter stamps:::return->createParameterStamps
StampFactory#createParameterStamps(Assumptions, ResolvedJavaMethod, boolean)::: stamp factory create parameter stamps:::signature->method->getSignature->result->signature->method->hasReceiver->getParameterCount->new->StampArr->index->accessingClass->method->getDeclaringClass->if->method->hasReceiver->if->StampFactory->TypeReference->createTrusted->objectNonNull->else->StampFactory->TypeReference->create->objectNonNull->for->i->signature->getParameterCount->return
StampFactory#pointer()::: stamp factory pointer:::return
StampFactory#forDeclaredType(Assumptions, JavaType, boolean)::: stamp factory for declared type:::if->returnType->getJavaKind->resolvedJavaType->reference->TypeReference->create->elementalType->resolvedJavaType->getElementalType->if->elementalType->isInterface->uncheckedType->elementalImplementor->elementalType->getSingleImplementor->if->elementalType->equals->implementor->t->while->t->isArray->implementor->getArrayClass->t->getComponentType->TypeReference->createTrusted->else->TypeReference->createTrusted->return->StampPair->StampFactory->object->StampFactory->object->create->return->StampPair->StampFactory->object->createSingle->else->return->StampPair->StampFactory->returnType->getJavaKind->forKind->createSingle
StampPair#create(Stamp, Stamp)::: stamp pair create:::return->new->StampPair
StampPair#createSingle(Stamp)::: stamp pair create single:::return->new->StampPair
StampPair#getUncheckedStamp()::: stamp pair get unchecked stamp:::return
StampPair#getTrustedStamp()::: stamp pair get trusted stamp:::return
StampPair#toString()::: stamp pair to string:::if->return->trustedStamp->toString->else->return
StampPair#hashCode()::: stamp pair hash code:::return->trustedStamp->hashCode->uncheckedStamp->hashCode
StampPair#equals(Object)::: stamp pair equals:::if->return->if->other->return->trustedStamp->equals->Objects->equals->return
SymbolicJVMCIReference#resolve(ResolvedJavaType)::: symbolic reference resolve:::
TypeReference#createExactTrusted(ResolvedJavaType):::Creates an exact type reference using the given type.:::if->return->return->new->TypeReference
TypeReference#createWithoutAssumptions(ResolvedJavaType):::Creates a type reference using the given type without assumptions and without trusting interface types.:::return->create
TypeReference#createTrustedWithoutAssumptions(ResolvedJavaType):::Creates a type reference using the given type without assumptions and trusting interface types.:::return->createTrusted
TypeReference#create(Assumptions, ResolvedJavaType):::Creates a type reference using the given type with assumptions and without trusting interface types.:::return->filterInterfaceTypesOut->createTrusted
TypeReference#createTrusted(Assumptions, ResolvedJavaType):::Create a type reference using the given type with assumptions and trusting interface types.:::if->return->exactType->type->isLeaf->if->leafConcreteSubtype->type->findLeafConcreteSubtype->if->leafConcreteSubtype->canRecordTo->leafConcreteSubtype->recordTo->leafConcreteSubtype->getResult->if->return->new->TypeReference->return->new->TypeReference
TypeReference#getType():::The type this reference refers to.:::return
TypeReference#isExact()::: type reference is exact:::return
TypeReference#asExactReference()::: type reference as exact reference:::if->isExact->return->return->new->TypeReference
TypeReference#filterInterfaceTypesOut(ResolvedJavaType)::: type reference filter interface types out:::if->if->type->isArray->componentType->type->getComponentType->filterInterfaceTypesOut->if->return->componentType->getArrayClass->return->type->getSuperclass->getArrayClass->if->type->isInterface->return->return
TypeReference#toString()::: type reference to string:::return->isExact
VoidStamp#accept(Visitor)::: void stamp accept:::
VoidStamp#unrestricted()::: void stamp unrestricted:::return
VoidStamp#isUnrestricted()::: void stamp is unrestricted:::return
VoidStamp#getStackKind()::: void stamp get stack kind:::return
VoidStamp#improveWith(Stamp)::: void stamp improve with:::return
VoidStamp#getLIRKind(LIRKindTool)::: void stamp get kind:::throw->GraalError->shouldNotReachHere
VoidStamp#javaType(MetaAccessProvider)::: void stamp java type:::return->metaAccess->lookupJavaType
VoidStamp#toString()::: void stamp to string:::return
VoidStamp#alwaysDistinct(Stamp)::: void stamp always distinct:::return
VoidStamp#meet(Stamp)::: void stamp meet:::return
VoidStamp#join(Stamp)::: void stamp join:::return
VoidStamp#isCompatible(Stamp)::: void stamp is compatible:::return
VoidStamp#isCompatible(Constant)::: void stamp is compatible:::return
VoidStamp#empty()::: void stamp empty:::return
VoidStamp#hasValues()::: void stamp has values:::return
VoidStamp#readConstant(MemoryAccessProvider, Constant, long)::: void stamp read constant:::throw->GraalError->shouldNotReachHere
VoidStamp#constant(Constant, MetaAccessProvider)::: void stamp constant:::throw->GraalError->shouldNotReachHere
VoidStamp#getInstance()::: void stamp get instance:::return
