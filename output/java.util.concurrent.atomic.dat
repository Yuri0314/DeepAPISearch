java.util.concurrent.atomic.AtomicBoolean#get()->boolean:::Returns the current value,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicBoolean#compareAndSet(boolean, boolean)->boolean:::Atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSet(boolean, boolean)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetPlain(boolean, boolean)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicBoolean#set(boolean)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicBoolean#lazySet(boolean)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicBoolean#getAndSet(boolean)->boolean:::Atomically sets the value to {@code newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicBoolean#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicBoolean#getPlain()->boolean:::Returns the current value, with memory semantics of reading as  if the variable was declared non-{@code volatile}.
java.util.concurrent.atomic.AtomicBoolean#setPlain(boolean)->void:::Sets the value to {@code newValue}, with memory semantics  of setting as if the variable was declared non-{@code volatile}  and non-{@code final}.
java.util.concurrent.atomic.AtomicBoolean#getOpaque()->boolean:::Returns the current value,  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicBoolean#setOpaque(boolean)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicBoolean#getAcquire()->boolean:::Returns the current value,  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicBoolean#setRelease(boolean)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicBoolean#compareAndExchange(boolean, boolean)->boolean:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicBoolean#compareAndExchangeAcquire(boolean, boolean)->boolean:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicBoolean#compareAndExchangeRelease(boolean, boolean)->boolean:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetVolatile(boolean, boolean)->boolean:::Possibly atomically sets the value to {@code newValue} if the current  value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetAcquire(boolean, boolean)->boolean:::Possibly atomically sets the value to {@code newValue} if the current  value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetRelease(boolean, boolean)->boolean:::Possibly atomically sets the value to {@code newValue} if the current  value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicInteger#get()->int:::Returns the current value,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicInteger#set(int)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicInteger#lazySet(int)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicInteger#getAndSet(int)->int:::Atomically sets the value to {@code newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicInteger#compareAndSet(int, int)->boolean:::Atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSet(int, int)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetPlain(int, int)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicInteger#getAndIncrement()->int:::Atomically increments the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicInteger#getAndDecrement()->int:::Atomically decrements the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicInteger#getAndAdd(int)->int:::Atomically adds the given value to the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicInteger#incrementAndGet()->int:::Atomically increments the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicInteger#decrementAndGet()->int:::Atomically decrements the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicInteger#addAndGet(int)->int:::Atomically adds the given value to the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicInteger#getAndUpdate(IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the previous value
java.util.concurrent.atomic.AtomicInteger#updateAndGet(IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the updated value
java.util.concurrent.atomic.AtomicInteger#getAndAccumulate(int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the previous value
java.util.concurrent.atomic.AtomicInteger#accumulateAndGet(int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the updated value
java.util.concurrent.atomic.AtomicInteger#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicInteger#intValue()->int:::Returns the current value of this {@code AtomicInteger} as an  {@code int},  with memory effects as specified by {@link VarHandle#getVolatile}
java.util.concurrent.atomic.AtomicInteger#longValue()->long:::Returns the current value of this {@code AtomicInteger} as a  {@code long} after a widening primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicInteger#floatValue()->float:::Returns the current value of this {@code AtomicInteger} as a  {@code float} after a widening primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicInteger#doubleValue()->double:::Returns the current value of this {@code AtomicInteger} as a  {@code double} after a widening primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicInteger#getPlain()->int:::Returns the current value, with memory semantics of reading as  if the variable was declared non-{@code volatile}.
java.util.concurrent.atomic.AtomicInteger#setPlain(int)->void:::Sets the value to {@code newValue}, with memory semantics  of setting as if the variable was declared non-{@code volatile}  and non-{@code final}.
java.util.concurrent.atomic.AtomicInteger#getOpaque()->int:::Returns the current value,  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicInteger#setOpaque(int)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicInteger#getAcquire()->int:::Returns the current value,  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicInteger#setRelease(int)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicInteger#compareAndExchange(int, int)->int:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicInteger#compareAndExchangeAcquire(int, int)->int:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicInteger#compareAndExchangeRelease(int, int)->int:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetVolatile(int, int)->boolean:::Possibly atomically sets the value to {@code newValue} if  the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetAcquire(int, int)->boolean:::Possibly atomically sets the value to {@code newValue} if  the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetRelease(int, int)->boolean:::Possibly atomically sets the value to {@code newValue} if  the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicIntegerArray#length()->int:::Returns the length of the array.
java.util.concurrent.atomic.AtomicIntegerArray#get(int)->int:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicIntegerArray#set(int, int)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicIntegerArray#lazySet(int, int)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicIntegerArray#getAndSet(int, int)->int:::Atomically sets the element at index {@code i} to {@code  newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicIntegerArray#compareAndSet(int, int, int)->boolean:::Atomically sets the element at index {@code i} to {@code  newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicIntegerArray#weakCompareAndSet(int, int, int)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicIntegerArray#weakCompareAndSetPlain(int, int, int)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicIntegerArray#getAndIncrement(int)->int:::Atomically increments the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicIntegerArray#getAndDecrement(int)->int:::Atomically decrements the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicIntegerArray#getAndAdd(int, int)->int:::Atomically adds the given value to the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicIntegerArray#incrementAndGet(int)->int:::Atomically increments the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicIntegerArray#decrementAndGet(int)->int:::Atomically decrements the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicIntegerArray#addAndGet(int, int)->int:::Atomically adds the given value to the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicIntegerArray#getAndUpdate(int, IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  previous value
java.util.concurrent.atomic.AtomicIntegerArray#updateAndGet(int, IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  updated value
java.util.concurrent.atomic.AtomicIntegerArray#getAndAccumulate(int, int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the previous value
java.util.concurrent.atomic.AtomicIntegerArray#accumulateAndGet(int, int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the updated value
java.util.concurrent.atomic.AtomicIntegerArray#toString()->String:::Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicIntegerArray#getPlain(int)->int:::Returns the current value of the element at index {@code i},  with memory semantics of reading as if the variable was declared  non-{@code volatile}.
java.util.concurrent.atomic.AtomicIntegerArray#setPlain(int, int)->void:::Sets the element at index {@code i} to {@code newValue},  with memory semantics of setting as if the variable was  declared non-{@code volatile} and non-{@code final}.
java.util.concurrent.atomic.AtomicIntegerArray#getOpaque(int)->int:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicIntegerArray#setOpaque(int, int)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicIntegerArray#getAcquire(int)->int:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicIntegerArray#setRelease(int, int)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicIntegerArray#compareAndExchange(int, int, int)->int:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicIntegerArray#compareAndExchangeAcquire(int, int, int)->int:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicIntegerArray#compareAndExchangeRelease(int, int, int)->int:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicIntegerArray#weakCompareAndSetVolatile(int, int, int)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicIntegerArray#weakCompareAndSetAcquire(int, int, int)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicIntegerArray#weakCompareAndSetRelease(int, int, int)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#newUpdater(Class<U>, String)->AtomicIntegerFieldUpdater<U>:::Creates and returns an updater for objects with the given field
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#compareAndSet(T, int, int)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#weakCompareAndSet(T, int, int)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#set(T, int)->void:::Sets the field of the given object managed by this updater to the  given updated value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#lazySet(T, int)->void:::Eventually sets the field of the given object managed by this  updater to the given updated value.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#get(T)->int:::Returns the current value held in the field of the given object  managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndSet(T, int)->int:::Atomically sets the field of the given object managed by this updater  to the given value and returns the old value.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndIncrement(T)->int:::Atomically increments by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndDecrement(T)->int:::Atomically decrements by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndAdd(T, int)->int:::Atomically adds the given value to the current value of the field of  the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#incrementAndGet(T)->int:::Atomically increments by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#decrementAndGet(T)->int:::Atomically decrements by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#addAndGet(T, int)->int:::Atomically adds the given value to the current value of the field of  the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndUpdate(T, IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the previous value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#updateAndGet(T, IntUnaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the updated value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#getAndAccumulate(T, int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the previous value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater#accumulateAndGet(T, int, IntBinaryOperator)->int:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the updated value
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#compareAndSet(T, int, int)->boolean:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#weakCompareAndSet(T, int, int)->boolean:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#set(T, int)->void:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#lazySet(T, int)->void:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#get(T)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#getAndSet(T, int)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#getAndAdd(T, int)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#getAndIncrement(T)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#getAndDecrement(T)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#incrementAndGet(T)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#decrementAndGet(T)->int:::
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl#addAndGet(T, int)->int:::
java.util.concurrent.atomic.AtomicLong#get()->long:::Returns the current value,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicLong#set(long)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicLong#lazySet(long)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicLong#getAndSet(long)->long:::Atomically sets the value to {@code newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicLong#compareAndSet(long, long)->boolean:::Atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicLong#weakCompareAndSet(long, long)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetPlain(long, long)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicLong#getAndIncrement()->long:::Atomically increments the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLong#getAndDecrement()->long:::Atomically decrements the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLong#getAndAdd(long)->long:::Atomically adds the given value to the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicLong#incrementAndGet()->long:::Atomically increments the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLong#decrementAndGet()->long:::Atomically decrements the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLong#addAndGet(long)->long:::Atomically adds the given value to the current value,  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicLong#getAndUpdate(LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the previous value
java.util.concurrent.atomic.AtomicLong#updateAndGet(LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the updated value
java.util.concurrent.atomic.AtomicLong#getAndAccumulate(long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the previous value
java.util.concurrent.atomic.AtomicLong#accumulateAndGet(long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the updated value
java.util.concurrent.atomic.AtomicLong#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicLong#intValue()->int:::Returns the current value of this {@code AtomicLong} as an {@code int}  after a narrowing primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicLong#longValue()->long:::Returns the current value of this {@code AtomicLong} as a {@code long},  with memory effects as specified by {@link VarHandle#getVolatile}
java.util.concurrent.atomic.AtomicLong#floatValue()->float:::Returns the current value of this {@code AtomicLong} as a {@code float}  after a widening primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicLong#doubleValue()->double:::Returns the current value of this {@code AtomicLong} as a {@code double}  after a widening primitive conversion,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicLong#getPlain()->long:::Returns the current value, with memory semantics of reading as if the  variable was declared non-{@code volatile}.
java.util.concurrent.atomic.AtomicLong#setPlain(long)->void:::Sets the value to {@code newValue}, with memory semantics  of setting as if the variable was declared non-{@code volatile}  and non-{@code final}.
java.util.concurrent.atomic.AtomicLong#getOpaque()->long:::Returns the current value,  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicLong#setOpaque(long)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicLong#getAcquire()->long:::Returns the current value,  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicLong#setRelease(long)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicLong#compareAndExchange(long, long)->long:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicLong#compareAndExchangeAcquire(long, long)->long:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicLong#compareAndExchangeRelease(long, long)->long:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetVolatile(long, long)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetAcquire(long, long)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetRelease(long, long)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicLongArray#length()->int:::Returns the length of the array.
java.util.concurrent.atomic.AtomicLongArray#get(int)->long:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicLongArray#set(int, long)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicLongArray#lazySet(int, long)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicLongArray#getAndSet(int, long)->long:::Atomically sets the element at index {@code i} to {@code  newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicLongArray#compareAndSet(int, long, long)->boolean:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicLongArray#weakCompareAndSet(int, long, long)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicLongArray#weakCompareAndSetPlain(int, long, long)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicLongArray#getAndIncrement(int)->long:::Atomically increments the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLongArray#getAndDecrement(int)->long:::Atomically decrements the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLongArray#getAndAdd(int, long)->long:::Atomically adds the given value to the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicLongArray#incrementAndGet(int)->long:::Atomically increments the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLongArray#decrementAndGet(int)->long:::Atomically decrements the value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}
java.util.concurrent.atomic.AtomicLongArray#addAndGet(int, long)->long:::Atomically adds the given value to the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAndAdd}.
java.util.concurrent.atomic.AtomicLongArray#getAndUpdate(int, LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  previous value
java.util.concurrent.atomic.AtomicLongArray#updateAndGet(int, LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  updated value
java.util.concurrent.atomic.AtomicLongArray#getAndAccumulate(int, long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the previous value
java.util.concurrent.atomic.AtomicLongArray#accumulateAndGet(int, long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the updated value
java.util.concurrent.atomic.AtomicLongArray#toString()->String:::Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicLongArray#getPlain(int)->long:::Returns the current value of the element at index {@code i},  with memory semantics of reading as if the variable was declared  non-{@code volatile}.
java.util.concurrent.atomic.AtomicLongArray#setPlain(int, long)->void:::Sets the element at index {@code i} to {@code newValue},  with memory semantics of setting as if the variable was  declared non-{@code volatile} and non-{@code final}.
java.util.concurrent.atomic.AtomicLongArray#getOpaque(int)->long:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicLongArray#setOpaque(int, long)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicLongArray#getAcquire(int)->long:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicLongArray#setRelease(int, long)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicLongArray#compareAndExchange(int, long, long)->long:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicLongArray#compareAndExchangeAcquire(int, long, long)->long:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicLongArray#compareAndExchangeRelease(int, long, long)->long:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicLongArray#weakCompareAndSetVolatile(int, long, long)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicLongArray#weakCompareAndSetAcquire(int, long, long)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicLongArray#weakCompareAndSetRelease(int, long, long)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicLongFieldUpdater#newUpdater(Class<U>, String)->AtomicLongFieldUpdater<U>:::Creates and returns an updater for objects with the given field
java.util.concurrent.atomic.AtomicLongFieldUpdater#compareAndSet(T, long, long)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicLongFieldUpdater#weakCompareAndSet(T, long, long)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicLongFieldUpdater#set(T, long)->void:::Sets the field of the given object managed by this updater to the  given updated value
java.util.concurrent.atomic.AtomicLongFieldUpdater#lazySet(T, long)->void:::Eventually sets the field of the given object managed by this  updater to the given updated value.
java.util.concurrent.atomic.AtomicLongFieldUpdater#get(T)->long:::Returns the current value held in the field of the given object  managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndSet(T, long)->long:::Atomically sets the field of the given object managed by this updater  to the given value and returns the old value.
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndIncrement(T)->long:::Atomically increments by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndDecrement(T)->long:::Atomically decrements by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndAdd(T, long)->long:::Atomically adds the given value to the current value of the field of  the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#incrementAndGet(T)->long:::Atomically increments by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#decrementAndGet(T)->long:::Atomically decrements by one the current value of the field of the  given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#addAndGet(T, long)->long:::Atomically adds the given value to the current value of the field of  the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndUpdate(T, LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the previous value
java.util.concurrent.atomic.AtomicLongFieldUpdater#updateAndGet(T, LongUnaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the updated value
java.util.concurrent.atomic.AtomicLongFieldUpdater#getAndAccumulate(T, long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the previous value
java.util.concurrent.atomic.AtomicLongFieldUpdater#accumulateAndGet(T, long, LongBinaryOperator)->long:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the updated value
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#compareAndSet(T, long, long)->boolean:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#weakCompareAndSet(T, long, long)->boolean:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#set(T, long)->void:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#lazySet(T, long)->void:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#get(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#getAndSet(T, long)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#getAndAdd(T, long)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#getAndIncrement(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#getAndDecrement(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#incrementAndGet(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#decrementAndGet(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.CASUpdater#addAndGet(T, long)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.LockedUpdater#compareAndSet(T, long, long)->boolean:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.LockedUpdater#weakCompareAndSet(T, long, long)->boolean:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.LockedUpdater#set(T, long)->void:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.LockedUpdater#lazySet(T, long)->void:::
java.util.concurrent.atomic.AtomicLongFieldUpdater.LockedUpdater#get(T)->long:::
java.util.concurrent.atomic.AtomicLongFieldUpdater#isAncestor(ClassLoader, ClassLoader)->boolean:::Returns true if the second classloader can be found in the first  classloader's delegation chain
java.util.concurrent.atomic.AtomicLongFieldUpdater#isSamePackage(Class<?>, Class<?>)->boolean:::Returns true if the two classes have the same class loader and  package qualifier
java.util.concurrent.atomic.AtomicMarkableReference.Pair#of(T, boolean)->Pair<T>:::
java.util.concurrent.atomic.AtomicMarkableReference#getReference()->V:::Returns the current value of the reference.
java.util.concurrent.atomic.AtomicMarkableReference#isMarked()->boolean:::Returns the current value of the mark.
java.util.concurrent.atomic.AtomicMarkableReference#get(boolean[])->V:::Returns the current values of both the reference and the mark
java.util.concurrent.atomic.AtomicMarkableReference#weakCompareAndSet(V, V, boolean, boolean)->boolean:::Atomically sets the value of both the reference and mark  to the given update values if the  current reference is {@code ==} to the expected reference  and the current mark is equal to the expected mark
java.util.concurrent.atomic.AtomicMarkableReference#compareAndSet(V, V, boolean, boolean)->boolean:::Atomically sets the value of both the reference and mark  to the given update values if the  current reference is {@code ==} to the expected reference  and the current mark is equal to the expected mark.
java.util.concurrent.atomic.AtomicMarkableReference#set(V, boolean)->void:::Unconditionally sets the value of both the reference and mark.
java.util.concurrent.atomic.AtomicMarkableReference#attemptMark(V, boolean)->boolean:::Atomically sets the value of the mark to the given update value  if the current reference is {@code ==} to the expected  reference
java.util.concurrent.atomic.AtomicReference#get()->V:::Returns the current value,  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicReference#set(V)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicReference#lazySet(V)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicReference#compareAndSet(V, V)->boolean:::Atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicReference#weakCompareAndSet(V, V)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetPlain(V, V)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicReference#getAndSet(V)->V:::Atomically sets the value to {@code newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicReference#getAndUpdate(UnaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the previous value
java.util.concurrent.atomic.AtomicReference#updateAndGet(UnaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function, returning the updated value
java.util.concurrent.atomic.AtomicReference#getAndAccumulate(V, BinaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the previous value
java.util.concurrent.atomic.AtomicReference#accumulateAndGet(V, BinaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the current value with the results of  applying the given function to the current and given values,  returning the updated value
java.util.concurrent.atomic.AtomicReference#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicReference#getPlain()->V:::Returns the current value, with memory semantics of reading as  if the variable was declared non-{@code volatile}.
java.util.concurrent.atomic.AtomicReference#setPlain(V)->void:::Sets the value to {@code newValue}, with memory semantics  of setting as if the variable was declared non-{@code volatile}  and non-{@code final}.
java.util.concurrent.atomic.AtomicReference#getOpaque()->V:::Returns the current value,  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicReference#setOpaque(V)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicReference#getAcquire()->V:::Returns the current value,  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicReference#setRelease(V)->void:::Sets the value to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicReference#compareAndExchange(V, V)->V:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicReference#compareAndExchangeAcquire(V, V)->V:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicReference#compareAndExchangeRelease(V, V)->V:::Atomically sets the value to {@code newValue} if the current value,  referred to as the <em>witness value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetVolatile(V, V)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetAcquire(V, V)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetRelease(V, V)->boolean:::Possibly atomically sets the value to {@code newValue}  if the current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicReferenceArray#length()->int:::Returns the length of the array.
java.util.concurrent.atomic.AtomicReferenceArray#get(int)->E:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getVolatile}.
java.util.concurrent.atomic.AtomicReferenceArray#set(int, E)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setVolatile}.
java.util.concurrent.atomic.AtomicReferenceArray#lazySet(int, E)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicReferenceArray#getAndSet(int, E)->E:::Atomically sets the element at index {@code i} to {@code  newValue} and returns the old value,  with memory effects as specified by {@link VarHandle#getAndSet}.
java.util.concurrent.atomic.AtomicReferenceArray#compareAndSet(int, E, E)->boolean:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#compareAndSet}.
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSet(int, E, E)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetPlain(int, E, E)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
java.util.concurrent.atomic.AtomicReferenceArray#getAndUpdate(int, UnaryOperator<E>)->E:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  previous value
java.util.concurrent.atomic.AtomicReferenceArray#updateAndGet(int, UnaryOperator<E>)->E:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function, returning the  updated value
java.util.concurrent.atomic.AtomicReferenceArray#getAndAccumulate(int, E, BinaryOperator<E>)->E:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the previous value
java.util.concurrent.atomic.AtomicReferenceArray#accumulateAndGet(int, E, BinaryOperator<E>)->E:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the element at index {@code i} with  the results of applying the given function to the current and  given values, returning the updated value
java.util.concurrent.atomic.AtomicReferenceArray#toString()->String:::Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicReferenceArray#getPlain(int)->E:::Returns the current value of the element at index {@code i},  with memory semantics of reading as if the variable was declared  non-{@code volatile}.
java.util.concurrent.atomic.AtomicReferenceArray#setPlain(int, E)->void:::Sets the element at index {@code i} to {@code newValue},  with memory semantics of setting as if the variable was  declared non-{@code volatile} and non-{@code final}.
java.util.concurrent.atomic.AtomicReferenceArray#getOpaque(int)->E:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getOpaque}.
java.util.concurrent.atomic.AtomicReferenceArray#setOpaque(int, E)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setOpaque}.
java.util.concurrent.atomic.AtomicReferenceArray#getAcquire(int)->E:::Returns the current value of the element at index {@code i},  with memory effects as specified by {@link VarHandle#getAcquire}.
java.util.concurrent.atomic.AtomicReferenceArray#setRelease(int, E)->void:::Sets the element at index {@code i} to {@code newValue},  with memory effects as specified by {@link VarHandle#setRelease}.
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchange(int, E, E)->E:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchange}.
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchangeAcquire(int, E, E)->E:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeAcquire}.
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchangeRelease(int, E, E)->E:::Atomically sets the element at index {@code i} to {@code newValue}  if the element's current value, referred to as the <em>witness  value</em>, {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#compareAndExchangeRelease}.
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetVolatile(int, E, E)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSet}.
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetAcquire(int, E, E)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetAcquire}.
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetRelease(int, E, E)->boolean:::Possibly atomically sets the element at index {@code i} to  {@code newValue} if the element's current value {@code == expectedValue},  with memory effects as specified by  {@link VarHandle#weakCompareAndSetRelease}.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#W> newUpdater(Class<U>, Class<W>, String)->AtomicReferenceFieldUpdater<U,:::Creates and returns an updater for objects with the given field
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#compareAndSet(T, V, V)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#weakCompareAndSet(T, V, V)->boolean:::Atomically sets the field of the given object managed by this updater  to the given updated value if the current value {@code ==} the  expected value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#set(T, V)->void:::Sets the field of the given object managed by this updater to the  given updated value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#lazySet(T, V)->void:::Eventually sets the field of the given object managed by this  updater to the given updated value.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#get(T)->V:::Returns the current value held in the field of the given object  managed by this updater.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#getAndSet(T, V)->V:::Atomically sets the field of the given object managed by this updater  to the given value and returns the old value.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#getAndUpdate(T, UnaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the previous value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#updateAndGet(T, UnaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given  function, returning the updated value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#getAndAccumulate(T, V, BinaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the previous value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater#accumulateAndGet(T, V, BinaryOperator<V>)->V:::Atomically updates (with memory effects as specified by {@link  VarHandle#compareAndSet}) the field of the given object managed  by this updater with the results of applying the given function  to the current and given values, returning the updated value
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#throwCCE()->void:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#compareAndSet(T, V, V)->boolean:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#weakCompareAndSet(T, V, V)->boolean:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#set(T, V)->void:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#lazySet(T, V)->void:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#get(T)->V:::
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl#getAndSet(T, V)->V:::
java.util.concurrent.atomic.AtomicStampedReference.Pair#of(T, int)->Pair<T>:::
java.util.concurrent.atomic.AtomicStampedReference#getReference()->V:::Returns the current value of the reference.
java.util.concurrent.atomic.AtomicStampedReference#getStamp()->int:::Returns the current value of the stamp.
java.util.concurrent.atomic.AtomicStampedReference#get(int[])->V:::Returns the current values of both the reference and the stamp
java.util.concurrent.atomic.AtomicStampedReference#weakCompareAndSet(V, V, int, int)->boolean:::Atomically sets the value of both the reference and stamp  to the given update values if the  current reference is {@code ==} to the expected reference  and the current stamp is equal to the expected stamp
java.util.concurrent.atomic.AtomicStampedReference#compareAndSet(V, V, int, int)->boolean:::Atomically sets the value of both the reference and stamp  to the given update values if the  current reference is {@code ==} to the expected reference  and the current stamp is equal to the expected stamp.
java.util.concurrent.atomic.AtomicStampedReference#set(V, int)->void:::Unconditionally sets the value of both the reference and stamp.
java.util.concurrent.atomic.AtomicStampedReference#attemptStamp(V, int)->boolean:::Atomically sets the value of the stamp to the given update value  if the current reference is {@code ==} to the expected  reference
java.util.concurrent.atomic.DoubleAccumulator#accumulate(double)->void:::Updates with the given value.
java.util.concurrent.atomic.DoubleAccumulator#get()->double:::Returns the current value
java.util.concurrent.atomic.DoubleAccumulator#reset()->void:::Resets variables maintaining updates to the identity value
java.util.concurrent.atomic.DoubleAccumulator#getThenReset()->double:::Equivalent in effect to {@link #get} followed by {@link  #reset}
java.util.concurrent.atomic.DoubleAccumulator#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.DoubleAccumulator#doubleValue()->double:::Equivalent to {@link #get}.
java.util.concurrent.atomic.DoubleAccumulator#longValue()->long:::Returns the {@linkplain #get current value} as a {@code long}  after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAccumulator#intValue()->int:::Returns the {@linkplain #get current value} as an {@code int}  after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAccumulator#floatValue()->float:::Returns the {@linkplain #get current value} as a {@code float}  after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder#add(double)->void:::Adds the given value.
java.util.concurrent.atomic.DoubleAdder#sum()->double:::Returns the current sum
java.util.concurrent.atomic.DoubleAdder#reset()->void:::Resets variables maintaining the sum to zero
java.util.concurrent.atomic.DoubleAdder#sumThenReset()->double:::Equivalent in effect to {@link #sum} followed by {@link  #reset}
java.util.concurrent.atomic.DoubleAdder#toString()->String:::Returns the String representation of the {@link #sum}.
java.util.concurrent.atomic.DoubleAdder#doubleValue()->double:::Equivalent to {@link #sum}.
java.util.concurrent.atomic.DoubleAdder#longValue()->long:::Returns the {@link #sum} as a {@code long} after a  narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder#intValue()->int:::Returns the {@link #sum} as an {@code int} after a  narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder#floatValue()->float:::Returns the {@link #sum} as a {@code float}  after a narrowing primitive conversion.
java.util.concurrent.atomic.LongAccumulator#accumulate(long)->void:::Updates with the given value.
java.util.concurrent.atomic.LongAccumulator#get()->long:::Returns the current value
java.util.concurrent.atomic.LongAccumulator#reset()->void:::Resets variables maintaining updates to the identity value
java.util.concurrent.atomic.LongAccumulator#getThenReset()->long:::Equivalent in effect to {@link #get} followed by {@link  #reset}
java.util.concurrent.atomic.LongAccumulator#toString()->String:::Returns the String representation of the current value.
java.util.concurrent.atomic.LongAccumulator#longValue()->long:::Equivalent to {@link #get}.
java.util.concurrent.atomic.LongAccumulator#intValue()->int:::Returns the {@linkplain #get current value} as an {@code int}  after a narrowing primitive conversion.
java.util.concurrent.atomic.LongAccumulator#floatValue()->float:::Returns the {@linkplain #get current value} as a {@code float}  after a widening primitive conversion.
java.util.concurrent.atomic.LongAccumulator#doubleValue()->double:::Returns the {@linkplain #get current value} as a {@code double}  after a widening primitive conversion.
java.util.concurrent.atomic.LongAdder#add(long)->void:::Adds the given value.
java.util.concurrent.atomic.LongAdder#increment()->void:::Equivalent to {@code add(1)}.
java.util.concurrent.atomic.LongAdder#decrement()->void:::Equivalent to {@code add(-1)}.
java.util.concurrent.atomic.LongAdder#sum()->long:::Returns the current sum
java.util.concurrent.atomic.LongAdder#reset()->void:::Resets variables maintaining the sum to zero
java.util.concurrent.atomic.LongAdder#sumThenReset()->long:::Equivalent in effect to {@link #sum} followed by {@link  #reset}
java.util.concurrent.atomic.LongAdder#toString()->String:::Returns the String representation of the {@link #sum}.
java.util.concurrent.atomic.LongAdder#longValue()->long:::Equivalent to {@link #sum}.
java.util.concurrent.atomic.LongAdder#intValue()->int:::Returns the {@link #sum} as an {@code int} after a narrowing  primitive conversion.
java.util.concurrent.atomic.LongAdder#floatValue()->float:::Returns the {@link #sum} as a {@code float}  after a widening primitive conversion.
java.util.concurrent.atomic.LongAdder#doubleValue()->double:::Returns the {@link #sum} as a {@code double} after a widening  primitive conversion.
java.util.concurrent.atomic.Striped64.Cell#cas(long, long)->boolean:::
java.util.concurrent.atomic.Striped64.Cell#reset()->void:::
java.util.concurrent.atomic.Striped64.Cell#reset(long)->void:::
java.util.concurrent.atomic.Striped64.Cell#getAndSet(long)->long:::
java.util.concurrent.atomic.Striped64#casBase(long, long)->boolean:::CASes the base field.
java.util.concurrent.atomic.Striped64#getAndSetBase(long)->long:::
java.util.concurrent.atomic.Striped64#casCellsBusy()->boolean:::CASes the cellsBusy field from 0 to 1 to acquire lock.
java.util.concurrent.atomic.Striped64#getProbe()->int:::Returns the probe value for the current thread
java.util.concurrent.atomic.Striped64#advanceProbe(int)->int:::Pseudo-randomly advances and records the given probe value for the  given thread
java.util.concurrent.atomic.Striped64#longAccumulate(long, LongBinaryOperator, boolean)->void:::Handles cases of updates involving initialization, resizing,  creating new Cells, and/or contention
java.util.concurrent.atomic.Striped64#doubleAccumulate(double, DoubleBinaryOperator, boolean)->void:::Same as longAccumulate, but injecting long/double conversions  in too many places to sensibly merge with long version, given  the low-overhead requirements of this class
