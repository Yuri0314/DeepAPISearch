ActivatableRef#getStub(ActivationDesc, ActivationID):::Returns the stub for the remote object whose class is specified in the activation descriptor:::className->desc->getClassName->try->cl->RMIClassLoader->desc->getLocation->loadClass->clientRef->new->ActivatableRef->return->Util->createProxy->catch->throw->new->StubNotFoundException->throw->new->StubNotFoundException->throw->new->StubNotFoundException->finally
ActivatableRef#invoke(Remote, java.lang.reflect.Method, Object[], long):::Invoke method on remote object:::force->localRef->exception->synchronized->if->activate->else->for->retries->throw
ActivatableRef#newCall(RemoteObject, Operation[], int, long):::This call is used by the old 1.1 stub protocol and is unsupported since activation requires 1.2 stubs.:::throw->new->UnsupportedOperationException
ActivatableRef#invoke(RemoteCall):::This call is used by the old 1.1 stub protocol and is unsupported since activation requires 1.2 stubs.:::throw->new->UnsupportedOperationException
ActivatableRef#done(RemoteCall):::This call is used by the old 1.1 stub protocol and is unsupported since activation requires 1.2 stubs.:::throw->new->UnsupportedOperationException
ActivatableRef#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized:::return
ActivatableRef#writeExternal(ObjectOutput):::Write out external representation for remote ref.:::localRef->out->writeObject->if->out->writeUTF->else->out->localRef->getRefClass->writeUTF->localRef->writeExternal
ActivatableRef#readExternal(ObjectInput):::Read in external representation for remote ref.:::in->readObject->className->in->readUTF->if->className->equals->return->try->refClass->Class->forName->refClass->newInstance->ref->readExternal->catch->throw->new->UnmarshalException->throw->new->UnmarshalException->finally
ActivatableRef#remoteToString():::Method from object, forward from RemoteObject:::return->Util->getClass->getUnqualifiedName
ActivatableRef#remoteHashCode():::default implementation of hashCode for remote objects:::return->id->hashCode
ActivatableRef#remoteEquals(RemoteRef):::default implementation of equals for remote objects:::if->return->id->equals->return
ActivatableServerRef#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized:::return
ActivatableServerRef#getClientRef():::Return the client remote reference for this remoteRef:::return->new->UnicastRef2->new->ActivatableRef
ActivatableServerRef#writeExternal(ObjectOutput):::Prevents serialization (because deserializaion is impossible).:::throw->new->NotSerializableException
Activation.ActivationSystemImpl#shutdown():::Shutdown the activation system:::lock->if->synchronized->synchronized->if->new->Shutdown->start
Activation.DefaultExecPolicy#checkConfiguration():::Prints warning message if installed Policy is the default Policy implementation and globally granted permissions do not include AllPermission or any ExecPermissions/ExecOptionPermissions.:::policy->AccessController->new->PrivilegedAction<Policy>->doPrivileged->if->return->perms->getExecPermissions->for->e->perms->elements->e->hasMoreElements->getTextResource->println
Activation#main(String[]):::Main program to start the activation system:::stop->if->System->getSecurityManager->System->new->SecurityManager->setSecurityManager->try->port->ssf->inheritedChannel->AccessController->new->PrivilegedExceptionAction<Channel>->doPrivileged->if->AccessController->new->PrivilegedExceptionAction<Void>->doPrivileged->serverSocket->socket->serverSocket->getLocalPort->new->ActivationServerSocketFactory->new->Date->println->getTextResource->println->log->childArgs->new->ArrayList<>->for->i->if->if->getTextResource->bomb->else->AccessController->Boolean->getBoolean->doPrivileged->execPolicyClassName->AccessController->System->getProperty->doPrivileged->if->if->DefaultExecPolicy->checkConfiguration->if->execPolicyClassName->equals->if->execPolicyClassName->equals->execPolicyClassName->equals->getName->try->execPolicyClass->getRMIClass->tmp->execPolicyClass->newInstance->execPolicyClass->getMethod->catch->if->getTextResource->println->e->printStackTrace->getTextResource->bomb->finally->if->finalPort->AccessController->new->PrivilegedAction<Void>->doPrivileged->system->ActivationGroup->getSystem->system->shutdown->System->exit->childArgs->childArgs->size->new->StringArr->toArray->startActivation->while->try->Thread->sleep->catch->finally->catch->MessageFormat->getTextResource->format->println->e->printStackTrace->finally->System->exit
PipeWriter#run():::Create a thread to listen and read from input stream, in:::buf->new->byteArr->count->try->while->in->read->write->lastInBuffer->bufOut->toString->bufOut->reset->if->lastInBuffer->length->out->createAnnotation->println->out->flush->catch->finally
PipeWriter#plugTogetherPair(InputStream, OutputStream, InputStream, OutputStream):::Allow plugging together two pipes at a time, to associate output from an execed process:::inThread->outThread->nExecs->getNumExec->AccessController->new->PipeWriter->new->NewThreadAction->doPrivileged->AccessController->new->PipeWriter->new->NewThreadAction->doPrivileged->inThread->start->outThread->start
ActivationGroupImpl#newInstance(ActivationID, ActivationDesc):::Creates a new instance of an activatable remote object:::RegistryImpl->checkAccess->if->groupID->desc->getGroupID->equals->throw->new->ActivationException->try->acquireLock->synchronized->if->throw->new->InactiveGroupException->entry->active->get->if->return->className->desc->getClassName->cl->RMIClassLoader->desc->getLocation->loadClass->asSubclass->impl->t->Thread->currentThread->savedCcl->t->getContextClassLoader->objcl->cl->getClassLoader->ccl->covers->try->AccessController->new->PrivilegedExceptionAction<Remote>->doPrivileged->catch->e->pae->getException->if->throw->else->if->throw->else->if->throw->else->if->throw->else->if->throw->else->if->throw->finally->new->ActiveEntry->active->put->return->catch->throw->new->ActivationException->throw->e->getTargetException->new->ActivationException->throw->new->ActivationException->finally->releaseLock->checkInactiveGroup
ActivationGroupImpl#inactiveObject(ActivationID):::The group's inactiveObject method is called indirectly via a call to the Activatable.inactive method:::try->acquireLock->synchronized->if->throw->new->ActivationException->entry->active->get->if->throw->new->UnknownObjectException->try->if->Activatable->unexportObject->return->catch->finally->try->super->inactiveObject->catch->finally->active->remove->catch->finally->releaseLock->checkInactiveGroup->return
ActivationGroupImpl#activeObject(ActivationID, Remote):::The group's activeObject method is called when an object is exported (either by Activatable object construction or an explicit call to Activatable.exportObject:::try->acquireLock->synchronized->if->throw->new->ActivationException->if->active->contains->entry->new->ActiveEntry->active->put->try->super->activeObject->catch->finally->catch->finally->releaseLock->checkInactiveGroup
ActivationGroupInit#main(String[]):::Main program to start a VM for an activation group.:::try->if->System->getSecurityManager->System->new->SecurityManager->setSecurityManager->in->new->MarshalInputStream->id->in->readObject->desc->in->readObject->incarnation->in->readLong->ActivationGroup->createGroup->catch->println->e->printStackTrace->finally->try->close->catch->finally
DeserializationChecker#check(Method, ObjectStreamClass, int, int):::Will be called to check a descriptor:::
DeserializationChecker#checkProxyClass(Method, String[], int, int):::Will be called to validate a Proxy interfaces from a remote user before loading it.:::
DeserializationChecker#end(int):::Inform of the completion of parameter deserialisation for a method invocation:::
Dispatcher#dispatch(Remote, RemoteCall):::Call to dispatch to the remote object (on the server side):::
LoaderHandler#loadClass(String, String, ClassLoader):::Load a class from a network location (one or more URLs), but first try to resolve the named class through the given "default loader".:::if->loaderLog->isLoggable->loaderLog->log->urls->if->pathToURLs->else->getDefaultCodebaseURLs->if->try->c->loadClassForName->if->loaderLog->isLoggable->loaderLog->c->getClassLoader->log->return->catch->finally->return->loadClass
LoaderHandler#getClassAnnotation(Class):::Returns the class annotation (representing the location for a class) that RMI will use to annotate the call stream when marshalling objects of the given class.:::name->cl->getName->nameLength->name->length->if->name->charAt->i->while->name->charAt->if->name->charAt->return->loader->cl->getClassLoader->if->codebaseLoaders->containsKey->return->annotation->if->getClassAnnotation->else->if->try->urls->getURLs->if->sm->System->getSecurityManager->if->perms->new->Permissions->for->i->urlsToPath->catch->finally->if->return->else->return
LoaderHandler#getClassLoader(String):::Returns a classloader that loads classes from the given codebase URL path:::parent->getRMIContextClassLoader->urls->if->pathToURLs->else->getDefaultCodebaseURLs->sm->System->getSecurityManager->if->sm->new->RuntimePermission->checkPermission->else->return->loader->lookupLoader->if->loader->checkPermissions->return
LoaderHandler#getSecurityContext(ClassLoader):::Return the security context of the given class loader.:::if->urls->getURLs->if->return->return
LoaderHandler#registerCodebaseLoader(ClassLoader):::Register a class loader as one whose classes should always be annotated with the value of the "java.rmi.server.codebase" property.:::codebaseLoaders->put
LoaderHandler#loadProxyClass(String, String[], ClassLoader):::Define and return a dynamic proxy class in a class loader with URLs supplied in the given location:::if->loaderLog->isLoggable->loaderLog->Arrays->asList->log->parent->getRMIContextClassLoader->if->loaderLog->isLoggable->loaderLog->log->urls->if->pathToURLs->else->getDefaultCodebaseURLs->sm->System->getSecurityManager->if->try->c->loadProxyClass->if->loaderLog->isLoggable->loaderLog->c->getClassLoader->log->return->catch->if->loaderLog->isLoggable->loaderLog->log->throw->e->getMessage->e->getException->new->ClassNotFoundException->finally->loader->lookupLoader->try->if->loader->checkPermissions->catch->try->c->loadProxyClass->if->loaderLog->isLoggable->loaderLog->c->getClassLoader->log->return->catch->if->loaderLog->isLoggable->loaderLog->log->throw->new->ClassNotFoundException->finally->finally->try->c->loadProxyClass->if->loaderLog->isLoggable->loaderLog->c->getClassLoader->log->return->catch->if->loaderLog->isLoggable->loaderLog->log->throw->finally
MarshalInputStream#getDoneCallback(Object):::Returns a callback previously registered via the setDoneCallback method with given key, or null if no callback has yet been registered with that key.:::return->doneCallbacks->get
MarshalInputStream#setDoneCallback(Object, Runnable):::Registers a callback to make when this stream's done() method is invoked, along with a key for retrieving the same callback instance subsequently from the getDoneCallback method.:::doneCallbacks->put
MarshalInputStream#done():::Indicates that the user of this MarshalInputStream is done reading objects from it, so all callbacks registered with the setDoneCallback method should now be (synchronously) executed:::iter->doneCallbacks->values->iterator->while->iter->hasNext->callback->iter->next->callback->run->doneCallbacks->clear
MarshalInputStream#close():::Closes this stream, implicitly invoking done() first.:::done->super->close
MarshalInputStream#resolveClass(ObjectStreamClass):::resolveClass is extended to acquire (if present) the location from which to load the specified class:::annotation->readLocation->className->classDesc->getName->defaultLoader->latestUserDefinedLoader->codebase->if->try->return->RMIClassLoader->loadClass->catch->return->checkSunClass->try->if->Character->className->charAt->isLowerCase->className->indexOf->return->super->resolveClass->catch->finally->throw->finally
MarshalInputStream#resolveProxyClass(String[]):::resolveProxyClass is extended to acquire (if present) the location to determine the class loader to define the proxy class in.:::annotation->readLocation->defaultLoader->latestUserDefinedLoader->codebase->if->return->RMIClassLoader->loadProxyClass
MarshalInputStream#readLocation():::Return the location for the class in the stream:::return->readObject
MarshalInputStream#skipDefaultResolveClass():::Set a flag to indicate that the superclass's default resolveClass() implementation should not be invoked by our resolveClass().:::
MarshalInputStream#useCodebaseOnly():::Disable code downloading except from the URL specified by the "java.rmi.server.codebase" property.:::
MarshalOutputStream#replaceObject(Object):::Checks for objects that are instances of java.rmi.Remote that need to be serialized as proxy objects.:::if->target->ObjectTable->getTarget->if->return->target->getStub->return
MarshalOutputStream#annotateClass(Class):::Serializes a location from which to load the specified class.:::getClassAnnotation->writeLocation
MarshalOutputStream#annotateProxyClass(Class):::Serializes a location from which to load the specified class.:::annotateClass
MarshalOutputStream#writeLocation(String):::Writes the location for the class into the stream:::writeObject
UnicastRef#getLiveRef():::Returns the current value of this UnicastRef's underlying LiveRef:::return
UnicastRef#invoke(Remote, Method, Object[], long):::Invoke a method:::if->clientRefLog->isLoggable->clientRefLog->log->if->clientCallLog->isLoggable->logClientCall->conn->ref->getChannel->newConnection->call->reuse->alreadyFreed->try->if->clientRefLog->isLoggable->clientRefLog->log->ref->getObjID->new->StreamRemoteCall->try->out->call->getOutputStream->marshalCustomCallData->types->method->getParameterTypes->for->i->catch->clientRefLog->log->throw->new->MarshalException->finally->call->executeCall->try->rtype->method->getReturnType->if->return->in->call->getInputStream->returnValue->unmarshalValue->clientRefLog->log->ref->getChannel->free->return->catch->discardPendingRefs->clientRefLog->e->getClass->getName->log->throw->new->UnmarshalException->finally->try->call->done->catch->finally->catch->if->getServerException->throw->throw->throw->finally->if->if->clientRefLog->isLoggable->clientRefLog->log->ref->getChannel->free
UnicastRef#marshalValue(Class, Object, ObjectOutput):::Marshal value to an ObjectOutput sink using RMI's serialization format for parameters or return values.:::if->type->isPrimitive->if->out->intValue->writeInt->else->if->out->booleanValue->writeBoolean->else->if->out->byteValue->writeByte->else->if->out->charValue->writeChar->else->if->out->shortValue->writeShort->else->if->out->longValue->writeLong->else->if->out->floatValue->writeFloat->else->if->out->doubleValue->writeDouble->else->throw->new->Error->else->out->writeObject
UnicastRef#unmarshalValue(Class, ObjectInput):::Unmarshal value from an ObjectInput source using RMI's serialization format for parameters or return values.:::if->type->isPrimitive->if->return->Integer->in->readInt->valueOf->else->if->return->Boolean->in->readBoolean->valueOf->else->if->return->Byte->in->readByte->valueOf->else->if->return->Character->in->readChar->valueOf->else->if->return->Short->in->readShort->valueOf->else->if->return->Long->in->readLong->valueOf->else->if->return->Float->in->readFloat->valueOf->else->if->return->Double->in->readDouble->valueOf->else->throw->new->Error->else->if->return->SharedSecrets->getJavaObjectInputStreamReadString->readString->else->return->in->readObject
UnicastRef#newCall(RemoteObject, Operation[], int, long):::Create an appropriate call object for a new call on this object:::clientRefLog->log->conn->ref->getChannel->newConnection->try->clientRefLog->log->if->clientCallLog->isLoggable->logClientCall->call->ref->getObjID->new->StreamRemoteCall->try->call->getOutputStream->marshalCustomCallData->catch->throw->new->MarshalException->finally->return->catch->ref->getChannel->free->throw->finally
UnicastRef#invoke(RemoteCall):::Invoke makes the remote call present in the RemoteCall object:::try->clientRefLog->log->call->executeCall->catch->clientRefLog->log->free->throw->clientRefLog->log->free->throw->clientRefLog->log->free->throw->clientRefLog->log->free->throw->finally
UnicastRef#done(RemoteCall):::Done should only be called if the invoke returns successfully (non-exceptionally) to the stub:::clientRefLog->log->free->try->call->done->catch->finally
UnicastRef#logClientCall(Object, Object):::Log the details of an outgoing call:::clientCallLog->obj->getClass->getName->ref->getObjID->toString->log
UnicastRef#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized:::return
UnicastRef#writeExternal(ObjectOutput):::Write out external representation for remote ref.:::ref->write
UnicastRef#readExternal(ObjectInput):::Read in external representation for remote ref.:::LiveRef->read
UnicastRef#remoteToString():::Method from object, forward from RemoteObject:::return->Util->getClass->getUnqualifiedName
UnicastRef#remoteHashCode():::default implementation of hashCode for remote objects:::return->ref->hashCode
UnicastRef#remoteEquals(RemoteRef):::default implementation of equals for remote objects:::if->return->ref->remoteEquals->return
UnicastRef2#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized:::return
UnicastRef2#writeExternal(ObjectOutput):::Write out external representation for remote ref.:::ref->write
UnicastRef2#readExternal(ObjectInput):::Read in external representation for remote ref.:::LiveRef->read
UnicastServerRef#exportObject(Remote, Object):::With the addition of support for dynamic proxies as stubs, this method is obsolete because it returns RemoteStub instead of the more general Remote:::return->exportObject
UnicastServerRef#exportObject(Remote, Object, boolean):::Export this object, create the skeleton and stubs for this dispatcher:::implClass->impl->getClass->stub->try->Util->getClientRef->createProxy->catch->throw->new->ExportException->finally->if->setSkeleton->target->ref->getObjID->new->Target->ref->exportObject->hashToMethod_Maps->get->return
UnicastServerRef#getClientHost():::Return the hostname of the current client:::return->TCPTransport->getClientHost
UnicastServerRef#setSkeleton(Remote):::Discovers and sets the appropriate skeleton for the impl.:::if->withoutSkeletons->impl->getClass->containsKey->try->Util->createSkeleton->catch->withoutSkeletons->impl->getClass->put->finally
UnicastServerRef#dispatch(Remote, RemoteCall):::Call to dispatch to the remote object (on the server side):::num->op->try->in->try->call->getInputStream->in->readInt->catch->throw->new->UnmarshalException->finally->if->oldDispatch->return->else->if->throw->new->UnmarshalException->try->in->readLong->catch->throw->new->UnmarshalException->finally->marshalStream->marshalStream->skipDefaultResolveClass->method->hashToMethod_Map->get->if->throw->new->UnmarshalException->logCall->types->method->getParameterTypes->params->new->ObjectArr->try->unmarshalCustomCallData->for->i->catch->discardPendingRefs->throw->discardPendingRefs->throw->new->UnmarshalException->finally->call->releaseInputStream->result->try->method->invoke->catch->throw->e->getTargetException->finally->try->out->call->getResultStream->rtype->method->getReturnType->if->marshalValue->catch->throw->new->MarshalException->finally->catch->origEx->logCallException->out->call->getResultStream->if->new->ServerError->else->if->new->ServerException->if->clearStackTraces->out->writeObject->if->throw->new->IOException->finally->call->releaseInputStream->call->releaseOutputStream
UnicastServerRef#unmarshalCustomCallData(ObjectInput):::Sets a filter for invocation arguments, if a filter has been set:::if->ois->AccessController->ois->setObjectInputFilter->return->doPrivileged
UnicastServerRef#clearStackTraces(Throwable):::Clear the stack trace of the given Throwable by replacing it with an empty StackTraceElement array, and do the same for all of its chained causative exceptions.:::empty->new->StackTraceElementArr->while->t->setStackTrace->t->getCause
UnicastServerRef#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized.:::return
UnicastServerRef#getClientRef():::Return the client remote reference for this remoteRef:::return->new->UnicastRef
UnicastServerRef#writeExternal(ObjectOutput):::Write out external representation for remote ref.:::
UnicastServerRef#readExternal(ObjectInput):::Read in external representation for remote ref.:::
UnicastServerRef2#getRefClass(ObjectOutput):::Returns the class of the ref type to be serialized:::return
UnicastServerRef2#getClientRef():::Return the client remote reference for this remoteRef:::return->new->UnicastRef2
Util#createProxy(Class, RemoteRef, boolean):::Returns a proxy for the specified implClass:::remoteClass->try->getRemoteClass->catch->throw->implClass->getName->new->StubNotFoundException->finally->if->stubClassExists->return->createStub->loader->implClass->getClassLoader->interfaces->getRemoteInterfaces->handler->new->RemoteObjectInvocationHandler->try->return->AccessController->new->PrivilegedAction<Remote>->doPrivileged->catch->throw->new->StubNotFoundException->finally
Util#createSkeleton(Remote):::Locate and return the Skeleton for the specified remote object:::cl->try->object->getClass->getRemoteClass->catch->throw->object->getClass->getName->new->SkeletonNotFoundException->finally->skelname->cl->getName->try->skelcl->Class->cl->getClassLoader->forName->return->skelcl->newInstance->catch->throw->new->SkeletonNotFoundException->throw->new->SkeletonNotFoundException->throw->new->SkeletonNotFoundException->throw->new->SkeletonNotFoundException->finally
Util#computeMethodHash(Method):::Compute the "method hash" of a remote method:::hash->sink->new->ByteArrayOutputStream->try->md->MessageDigest->getInstance->out->new->DigestOutputStream->new->DataOutputStream->s->getMethodNameAndDescriptor->if->serverRefLog->isLoggable->serverRefLog->log->out->writeUTF->out->flush->hasharray->md->digest->for->i->Math->min->catch->throw->complain->getMessage->new->SecurityException->finally->return
Util#getUnqualifiedName(Class):::Returns the binary name of the given type without package qualification:::binaryName->c->getName->return->binaryName->binaryName->lastIndexOf->substring
