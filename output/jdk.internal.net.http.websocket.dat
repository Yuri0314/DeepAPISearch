BuilderImpl#header(String, String)::: builder impl header:::requireNonNull->requireNonNull->headers->pair->add->return
BuilderImpl#subprotocols(String, String...)::: builder impl subprotocols:::requireNonNull->requireNonNull->subprotocols->new->LinkedList<>->subprotocols->add->for->i->clear->addAll->return
BuilderImpl#connectTimeout(Duration)::: builder impl connect timeout:::requireNonNull->return
BuilderImpl#buildAsync(URI, Listener)::: builder impl build async:::requireNonNull->requireNonNull->copy->immutableCopy->return->WebSocketImpl->newInstanceAsync
BuilderImpl#getClient()::: builder impl get client:::return
BuilderImpl#getUri()::: builder impl get uri:::return
BuilderImpl#getListener()::: builder impl get listener:::return
BuilderImpl#getHeaders()::: builder impl get headers:::return
BuilderImpl#getSubprotocols()::: builder impl get subprotocols:::return
BuilderImpl#getConnectTimeout()::: builder impl get connect timeout:::return
BuilderImpl#getProxySelector()::: builder impl get proxy selector:::return
BuilderImpl#immutableCopy()::: builder impl immutable copy:::copy->List->new->PairArr->toArray->of->List->new->StringArr->toArray->of->new->BuilderImpl->return
FailWebSocketException#getStatusCode()::: fail web socket exception get status code:::return
FailWebSocketException#initCause(Throwable)::: fail web socket exception init cause:::return->super->initCause
Frame.Masker#transferMasking(ByteBuffer, ByteBuffer, int)::: masker transfer masking:::if->src->remaining->dst->remaining->throw->dump->new->IllegalArgumentException->new->Masker->mask->transferMasking
Frame.Masker#mask(int)::: masker mask:::acc->clear->putInt->putInt->flip->for->i->acc->getLong->return
Frame.Masker#transferMasking(ByteBuffer, ByteBuffer)::: masker transfer masking:::begin->loop->end->return
Frame.Masker#begin(ByteBuffer, ByteBuffer)::: masker begin:::if->return->i->src->position->j->dst->position->srcLim->src->limit->dstLim->dst->limit->for->src->position->dst->position
Frame.Masker#loop(ByteBuffer, ByteBuffer)::: masker loop:::i->src->position->j->dst->position->srcLongLim->src->limit->dstLongLim->dst->limit->for->if->src->limit->src->position->else->src->position->if->dst->limit->dst->position->else->dst->position
Frame.Masker#end(ByteBuffer, ByteBuffer)::: masker end:::srcLim->src->limit->dstLim->dst->limit->i->src->position->j->dst->position->for->src->position->dst->position
Frame.HeaderWriter#fin(boolean)::: header writer fin:::if->else->return
Frame.HeaderWriter#rsv1(boolean)::: header writer rsv1:::if->else->return
Frame.HeaderWriter#rsv2(boolean)::: header writer rsv2:::if->else->return
Frame.HeaderWriter#rsv3(boolean)::: header writer rsv3:::if->else->return
Frame.HeaderWriter#opcode(Opcode)::: header writer opcode:::return
Frame.HeaderWriter#payloadLen(long)::: header writer payload len:::if->throw->new->IllegalArgumentException->if->else->if->else->return
Frame.HeaderWriter#mask(int)::: header writer mask:::return
Frame.HeaderWriter#noMask()::: header writer no mask:::return
Frame.HeaderWriter#write(ByteBuffer)::: header writer write:::buffer->putChar->if->if->buffer->putChar->else->buffer->putLong->if->buffer->putInt
Frame.Consumer#fin(boolean)::: consumer fin:::
Frame.Consumer#rsv1(boolean)::: consumer rsv1:::
Frame.Consumer#rsv2(boolean)::: consumer rsv2:::
Frame.Consumer#rsv3(boolean)::: consumer rsv3:::
Frame.Consumer#opcode(Opcode)::: consumer opcode:::
Frame.Consumer#mask(boolean)::: consumer mask:::
Frame.Consumer#payloadLen(long)::: consumer payload len:::
Frame.Consumer#maskingKey(int)::: consumer masking key:::
Frame.Consumer#payloadData(ByteBuffer)::: consumer payload data:::
Frame.Consumer#endFrame()::: consumer end frame:::
Frame.Reader#readFrame(ByteBuffer, Consumer)::: reader read frame:::while->b->switch->if->input->hasRemaining->break->input->get->consumer->fin->consumer->rsv1->consumer->rsv2->consumer->rsv3->consumer->ofCode->opcode->continue->if->input->hasRemaining->break->input->get->consumer->mask->p1->if->consumer->payloadLen->else->if->else->continue->if->input->hasRemaining->break->input->get->if->accumulator->put->position->continue->accumulator->flip->getChar->if->throw->notMinimalEncoding->consumer->payloadLen->accumulator->clear->continue->if->input->hasRemaining->break->input->get->if->accumulator->put->position->continue->accumulator->flip->getLong->if->throw->negativePayload->else->if->throw->notMinimalEncoding->consumer->payloadLen->accumulator->clear->continue->if->input->hasRemaining->break->input->get->if->accumulator->put->position->continue->consumer->accumulator->flip->getInt->maskingKey->accumulator->clear->continue->deliverable->Math->input->remaining->min->oldLimit->input->limit->input->input->position->limit->if->consumer->payloadData->consumed->input->remaining->if->throw->new->InternalError->input->limit->if->consumer->endFrame->break->throw->String->valueOf->new->InternalError
Frame.Reader#negativePayload(long)::: reader negative payload:::return->new->FailWebSocketException
Frame.Reader#notMinimalEncoding(long)::: reader not minimal encoding:::return->new->FailWebSocketException
MessageDecoder#getOutput()::: message decoder get output:::return
MessageDecoder#fin(boolean)::: message decoder fin:::if->debug->on->debug->log
MessageDecoder#rsv1(boolean)::: message decoder rsv1:::if->debug->on->debug->log->if->throw->new->FailWebSocketException
MessageDecoder#rsv2(boolean)::: message decoder rsv2:::if->debug->on->debug->log->if->throw->new->FailWebSocketException
MessageDecoder#rsv3(boolean)::: message decoder rsv3:::if->debug->on->debug->log->if->throw->new->FailWebSocketException
MessageDecoder#opcode(Opcode)::: message decoder opcode:::if->debug->on->debug->log->if->if->throw->new->FailWebSocketException->else->if->if->throw->format->new->FailWebSocketException->if->else->if->if->throw->format->new->FailWebSocketException->else->throw->new->FailWebSocketException
MessageDecoder#mask(boolean)::: message decoder mask:::if->debug->on->debug->log->if->throw->new->FailWebSocketException
MessageDecoder#payloadLen(long)::: message decoder payload len:::if->debug->on->debug->log->if->opcode->isControl->if->throw->format->new->FailWebSocketException->if->throw->new->FailWebSocketException
MessageDecoder#maskingKey(int)::: message decoder masking key:::throw->new->InternalError
MessageDecoder#payloadData(ByteBuffer)::: message decoder payload data:::if->debug->on->debug->log->data->remaining->lastPayloadChunk->if->opcode->isControl->if->binaryData->put->else->if->remaining->data->remaining->ByteBuffer->allocate->put->else->ByteBuffer->data->remaining->allocate->put->else->last->text->if->output->data->slice->onBinary->data->data->limit->position->else->binaryNonEmpty->data->hasRemaining->textData->try->decoder->decode->catch->throw->new->FailWebSocketException->initCause->finally->if->textData->hasRemaining->output->onText
MessageDecoder#endFrame()::: message decoder end frame:::if->debug->on->debug->log->if->opcode->isControl->binaryData->flip->switch->statusCode->reason->if->len->binaryData->remaining->binaryData->getChar->if->isLegalToReceiveFromServer->throw->new->FailWebSocketException->try->UTF_8->newDecoder->decode->toString->catch->throw->new->FailWebSocketException->initCause->finally->output->onClose->break->output->onPing->break->output->onPong->break->if->break
MessageEncoder#createIntermediateBuffer(int)::: message encoder create intermediate buffer:::capacity->Utils->getIntegerNetProperty->return->ByteBuffer->Math->max->allocate
MessageEncoder#reset()::: message encoder reset:::
MessageEncoder#encodeText(CharBuffer, boolean, ByteBuffer)::: message encoder encode text:::if->debug->on->debug->src->position->src->limit->src->capacity->log->if->throw->new->IOException->if->if->throw->new->IllegalStateException->headerBuffer->position->limit->intermediateBuffer->position->limit->charsetEncoder->reset->while->if->debug->on->debug->log->if->putAvailable->return->if->debug->on->debug->log->if->maskAvailable->return->if->debug->on->debug->log->if->return->intermediateBuffer->clear->r->if->charsetEncoder->encode->if->r->isUnderflow->if->charsetEncoder->flush->if->r->isUnderflow->if->r->isError->try->r->throwException->catch->throw->new->IOException->finally->if->debug->on->debug->log->intermediateBuffer->flip->opcode->fin->intermediateBuffer->remaining->setupHeader
MessageEncoder#putAvailable(ByteBuffer, ByteBuffer)::: message encoder put available:::available->dst->remaining->if->src->remaining->dst->put->return->else->lim->src->limit->src->src->position->limit->dst->put->src->limit->return
MessageEncoder#encodeBinary(ByteBuffer, boolean, ByteBuffer)::: message encoder encode binary:::if->debug->on->debug->log->if->throw->new->IOException->if->if->throw->new->IllegalStateException->src->remaining->opcode->setupHeader->if->putAvailable->return->count->maskAvailable->Math->abs->if->throw->new->IOException->return
MessageEncoder#maskAvailable(ByteBuffer, ByteBuffer)::: message encoder mask available:::r0->dst->remaining->payloadMasker->transferMasking->masked->dst->remaining->return->src->hasRemaining
MessageEncoder#encodePing(ByteBuffer, ByteBuffer)::: message encoder encode ping:::if->debug->on->debug->log->if->throw->new->IOException->if->src->remaining->if->throw->new->IllegalArgumentException->setupHeader->if->putAvailable->return->count->maskAvailable->Math->abs->if->throw->new->IOException->return
MessageEncoder#encodePong(ByteBuffer, ByteBuffer)::: message encoder encode pong:::if->debug->on->debug->log->if->throw->new->IOException->if->src->remaining->if->throw->new->IllegalArgumentException->setupHeader->if->putAvailable->return->count->maskAvailable->Math->abs->if->throw->new->IOException->return
MessageEncoder#encodeClose(int, CharBuffer, ByteBuffer)::: message encoder encode close:::if->debug->on->debug->reason->position->reason->limit->reason->capacity->log->if->throw->new->IOException->if->if->debug->on->debug->reason->position->reason->limit->reason->capacity->log->intermediateBuffer->position->limit->intermediateBuffer->putChar->r->charsetEncoder->reset->encode->if->r->isUnderflow->if->debug->on->debug->log->charsetEncoder->flush->if->debug->on->debug->log->if->r->isError->try->r->throwException->catch->throw->new->IOException->finally->else->if->r->isOverflow->throw->new->IOException->else->if->r->isUnderflow->throw->new->InternalError->intermediateBuffer->flip->intermediateBuffer->remaining->setupHeader->if->debug->on->debug->log->if->putAvailable->return->return->maskAvailable
MessageEncoder#setupHeader(Opcode, boolean, long)::: message encoder setup header:::if->debug->on->debug->log->headerBuffer->clear->mask->maskingKeySource->nextInt->headerWriter->fin->opcode->payloadLen->mask->write->headerBuffer->flip->payloadMasker->mask
MessageQueue#effectiveCapacityOf(int)::: message queue effective capacity of:::return->pow2Size
MessageQueue#addText(CharBuffer, boolean, T, BiConsumer, CompletableFuture)::: message queue add text:::add
MessageQueue#add(Type, Supplier, ByteBuffer, CharBuffer, boolean, int, T, BiConsumer, CompletableFuture)::: message queue add:::h->currentTail->newTail->do->tail->get->if->throw->new->IOException->while->tail->compareAndSet->t->if->throw->new->InternalError
MessageQueue#addBinary(ByteBuffer, boolean, T, BiConsumer, CompletableFuture)::: message queue add binary:::add
MessageQueue#addPing(ByteBuffer, T, BiConsumer, CompletableFuture)::: message queue add ping:::add
MessageQueue#addPong(ByteBuffer, T, BiConsumer, CompletableFuture)::: message queue add pong:::add
MessageQueue#addPong(Supplier, T, BiConsumer, CompletableFuture)::: message queue add pong:::add
MessageQueue#addClose(int, CharBuffer, T, BiConsumer, CompletableFuture)::: message queue add close:::add
MessageQueue#peek(QueueCallback)::: message queue peek:::h->if->return->callback->onEmpty->type->switch->try->return->callback->onText->catch->throw->finally->try->return->callback->onBinary->catch->throw->finally->try->return->callback->onPing->catch->throw->finally->try->if->return->callback->onPong->else->return->callback->onPong->catch->throw->finally->try->return->callback->onClose->catch->throw->finally->throw->String->valueOf->new->InternalError
MessageQueue#isEmpty()::: message queue is empty:::return
MessageQueue#remove()::: message queue remove:::currentHead->h->if->throw->new->InternalError
MessageQueue.QueueCallback#onText(CharBuffer, boolean, T, BiConsumer, CompletableFuture)::: queue callback on text:::
MessageQueue.QueueCallback#onBinary(ByteBuffer, boolean, T, BiConsumer, CompletableFuture)::: queue callback on binary:::
MessageQueue.QueueCallback#onPing(ByteBuffer, T, BiConsumer, CompletableFuture)::: queue callback on ping:::
MessageQueue.QueueCallback#onPong(ByteBuffer, T, BiConsumer, CompletableFuture)::: queue callback on pong:::
MessageQueue.QueueCallback#onPong(Supplier, T, BiConsumer, CompletableFuture)::: queue callback on pong:::
MessageQueue.QueueCallback#onClose(int, CharBuffer, T, BiConsumer, CompletableFuture)::: queue callback on close:::
MessageQueue.QueueCallback#onEmpty()::: queue callback on empty:::
MessageStreamConsumer#onText(CharSequence, boolean)::: message stream consumer on text:::
MessageStreamConsumer#onBinary(ByteBuffer, boolean)::: message stream consumer on binary:::
MessageStreamConsumer#onPing(ByteBuffer)::: message stream consumer on ping:::
MessageStreamConsumer#onPong(ByteBuffer)::: message stream consumer on pong:::
MessageStreamConsumer#onClose(int, CharSequence)::: message stream consumer on close:::
MessageStreamConsumer#onComplete()::: message stream consumer on complete:::
MessageStreamConsumer#onError(Throwable)::: message stream consumer on error:::
OpeningHandshake#createRequestSubprotocols(Collection)::: opening handshake create request subprotocols:::sp->subprotocols->size->new->LinkedHashSet<>->foreach->if->s->trim->isEmpty->isValidName->throw->illegal->if->sp->add->throw->illegal->return->Collections->unmodifiableCollection
OpeningHandshake#createRequestURI(URI)::: opening handshake create request i:::s->uri->getScheme->scheme->equalsIgnoreCase->try->return->uri->getUserInfo->uri->getHost->uri->getPort->uri->getPath->uri->getQuery->new->URI->catch->throw->new->InternalError->finally
OpeningHandshake#send()::: opening handshake send:::pa->client->BodyHandlers->discarding->sendAsync->this->resultFrom->thenCompose->return->AccessController->doPrivileged
OpeningHandshake#resultFrom(HttpResponse)::: opening handshake result from:::result->exception->try->handleResponse->catch->new->WebSocketHandshakeException->initCause->finally->if->return->MinimalFuture->completedFuture->try->rawChannel->close->catch->exception->addSuppressed->finally->return->MinimalFuture->failedFuture
OpeningHandshake#handleResponse(HttpResponse)::: opening handshake handle response:::c->response->statusCode->if->throw->checkFailed->headers->response->headers->upgrade->requireSingle->if->upgrade->equalsIgnoreCase->throw->checkFailed->connection->requireSingle->if->connection->equalsIgnoreCase->throw->checkFailed->version->requireAtMostOne->if->version->isPresent->version->get->equals->throw->checkFailed->requireAbsent->x->x->getBytes->update->expected->Base64->getEncoder->digest->encodeToString->actual->requireSingle->if->actual->trim->equals->throw->checkFailed->subprotocol->checkAndReturnSubprotocol->channel->rawChannel->return->new->TransportFactoryImpl->new->Result
OpeningHandshake#checkAndReturnSubprotocol(HttpHeaders)::: opening handshake check and return subprotocol:::opt->responseHeaders->firstValue->if->opt->isPresent->return->s->requireSingle->if->contains->return->else->throw->checkFailed
OpeningHandshake#requireAbsent(HttpHeaders, String)::: opening handshake require absent:::values->responseHeaders->allValues->if->values->isEmpty->throw->stringOf->format->checkFailed
OpeningHandshake#requireAtMostOne(HttpHeaders, String)::: opening handshake require at most one:::values->responseHeaders->allValues->if->values->size->throw->stringOf->format->checkFailed->return->values->stream->findFirst
OpeningHandshake#requireSingle(HttpHeaders, String)::: opening handshake require single:::values->responseHeaders->allValues->if->values->isEmpty->throw->checkFailed->else->if->values->size->throw->stringOf->format->checkFailed->return->values->get
OpeningHandshake#createNonce()::: opening handshake create nonce:::bytes->new->byteArr->nextBytes->return->Base64->getEncoder->encodeToString
OpeningHandshake#checkFailed(String)::: opening handshake check failed:::throw->new->CheckFailedException
OpeningHandshake#checkURI(URI)::: opening handshake check i:::scheme->uri->getScheme->if->equalsIgnoreCase->equalsIgnoreCase->throw->illegal->if->uri->getHost->throw->illegal->if->uri->getFragment->throw->illegal->return
OpeningHandshake#illegal(String)::: opening handshake illegal:::return->new->IllegalArgumentException
OpeningHandshake#proxyFor(Optional, URI):::Returns the proxy for the given URI when sent through the given client, or null if none is required or applicable.:::if->selector->isPresent->return->requestURI->createRequestURI->pl->selector->get->select->if->pl->isEmpty->return->proxy->pl->get->if->proxy->type->return->return
OpeningHandshake#checkPermissions(BuilderImpl, Proxy):::Performs the necessary security permissions checks to connect ( possibly through a proxy ) to the builders WebSocket URI.:::sm->System->getSecurityManager->if->return->headers->b->getHeaders->stream->map->distinct->perm1->Utils->b->getUri->permissionForServer->sm->checkPermission->if->return->perm2->proxy->address->permissionForProxy->if->sm->checkPermission
RawChannel.Provider#rawChannel()::: provider raw channel:::
RawChannel.RawEvent#interestOps()::: raw event interest ops:::
RawChannel.RawEvent#handle()::: raw event handle:::
RawChannel#registerEvent(RawEvent)::: raw channel register event:::
RawChannel#initialByteBuffer():::Hands over the initial bytes:::
RawChannel#read()::: raw channel read:::
RawChannel#write(ByteBuffer[], int, int)::: raw channel write:::
RawChannel#shutdownInput():::Shutdown the connection for reading without closing the channel:::
RawChannel#shutdownOutput():::Shutdown the connection for writing without closing the channel:::
RawChannel#close():::Closes this channel.:::
StatusCodes#isLegalToSendFromClient(int)::: status codes is legal to send from client:::if->isLegal->return->if->return->switch->return->return
StatusCodes#isLegalToReceiveFromServer(int)::: status codes is legal to receive from server:::if->isLegal->return->return
StatusCodes#isLegal(int)::: status codes is legal:::if->return->if->return->switch->return->return
Transport#sendText(CharSequence, boolean, T, BiConsumer)::: transport send text:::
Transport#sendBinary(ByteBuffer, boolean, T, BiConsumer)::: transport send binary:::
Transport#sendPing(ByteBuffer, T, BiConsumer)::: transport send ping:::
Transport#sendPong(ByteBuffer, T, BiConsumer)::: transport send pong:::
Transport#sendPong(Supplier, T, BiConsumer)::: transport send pong:::
Transport#sendClose(int, String, T, BiConsumer)::: transport send close:::
Transport#request(long)::: transport request:::
Transport#acknowledgeReception()::: transport acknowledge reception:::
Transport#closeOutput()::: transport close output:::
Transport#closeInput()::: transport close input:::
TransportFactory#createTransport(MessageQueue, MessageStreamConsumer)::: transport factory create transport:::
TransportFactoryImpl#createTransport(MessageQueue, MessageStreamConsumer)::: transport factory impl create transport:::return->new->TransportImpl
TransportImpl#createWriteBuffer()::: transport impl create write buffer:::name->capacity->Utils->getIntegerNetProperty->if->debug->on->debug->log->return->ByteBuffer->allocate
TransportImpl#write()::: transport impl write:::if->debug->on->debug->log->count->channel->write->if->debug->on->debug->log->foreach->if->b->hasRemaining->return->return
TransportImpl#sendText(CharSequence, boolean, T, BiConsumer)::: transport impl send text:::id->if->debug->on->counter->incrementAndGet->debug->message->length->log->text->CharBuffer->wrap->f->new->MinimalFuture<>->try->queue->addText->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#sendBinary(ByteBuffer, boolean, T, BiConsumer)::: transport impl send binary:::id->if->debug->on->counter->incrementAndGet->debug->message->remaining->log->f->new->MinimalFuture<>->try->queue->addBinary->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#sendPing(ByteBuffer, T, BiConsumer)::: transport impl send ping:::id->if->debug->on->counter->incrementAndGet->debug->message->remaining->log->f->new->MinimalFuture<>->try->queue->addPing->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#sendPong(ByteBuffer, T, BiConsumer)::: transport impl send pong:::id->if->debug->on->counter->incrementAndGet->debug->message->remaining->log->f->new->MinimalFuture<>->try->queue->addPong->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#sendPong(Supplier, T, BiConsumer)::: transport impl send pong:::id->if->debug->on->counter->incrementAndGet->debug->log->f->new->MinimalFuture<>->try->queue->addPong->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#sendClose(int, String, T, BiConsumer)::: transport impl send close:::id->if->debug->on->counter->incrementAndGet->debug->reason->length->log->f->new->MinimalFuture<>->try->queue->CharBuffer->wrap->addClose->sendScheduler->runOrSchedule->catch->action->accept->f->completeExceptionally->finally->if->debug->on->debug->log->return
TransportImpl#request(long)::: transport impl request:::if->debug->on->debug->log->if->demand->increase->receiveScheduler->runOrSchedule
TransportImpl#acknowledgeReception()::: transport impl acknowledge reception:::decremented->demand->tryDecrement->if->throw->new->InternalError
TransportImpl#closeOutput()::: transport impl close output:::if->debug->on->debug->log->synchronized->if->try->channel->shutdownOutput->catch->finally->if->channel->close->writeState->set->sendScheduler->runOrSchedule
TransportImpl#closeInput()::: transport impl close input:::if->debug->on->debug->log->synchronized->if->try->receiveScheduler->stop->channel->shutdownInput->catch->finally->if->channel->close
TransportImpl.SendTask#run()::: send task run:::if->debug->on->debug->log->while->queue->isEmpty->try->if->dst->hasRemaining->if->debug->on->debug->dst->remaining->log->if->tryCompleteWrite->break->else->if->if->queue->peek->if->debug->on->debug->log->dst->clear->queue->peek->dst->flip->if->tryCompleteWrite->break->else->encoder->reset->removeAndComplete->catch->if->debug->on->debug->log->dst->dst->limit->position->encoder->reset->removeAndComplete->finally->if->debug->on->debug->log
TransportImpl.SendTask#tryCompleteWrite()::: send task try complete write:::if->debug->on->debug->log->finished->while->ws->writeState->get->if->debug->on->debug->log->switch->break->if->debug->on->debug->log->channel->registerEvent->writeState->compareAndSet->if->debug->on->debug->log->break->written->write->if->if->debug->on->debug->log->break->else->writeState->compareAndSet->continue->throw->new->IOException->throw->String->valueOf->new->InternalError->if->debug->on->debug->log->return
TransportImpl.SendTask#removeAndComplete(Throwable)::: send task remove and complete:::if->debug->on->debug->log->queue->remove->if->try->action->accept->catch->finally->future->completeExceptionally->else->try->action->accept->catch->finally->future->complete
TransportImpl.ReceiveTask#run()::: receive task run:::if->debug->on->debug->log->while->receiveScheduler->isStopped->rs->if->data->hasRemaining->if->debug->on->debug->data->remaining->log->if->demand->isFulfilled->try->oldPos->data->position->reader->readFrame->newPos->data->position->catch->receiveScheduler->stop->messageConsumer->onError->finally->if->data->hasRemaining->continue->break->if->debug->on->debug->log->switch->break->try->channel->registerEvent->catch->receiveScheduler->stop->messageConsumer->onError->finally->break->try->channel->read->catch->receiveScheduler->stop->messageConsumer->onError->break->finally->if->receiveScheduler->stop->messageConsumer->onComplete->break->else->if->data->hasRemaining->continue->throw->String->valueOf->new->InternalError->if->debug->on->debug->log
TransportImpl.WriteEvent#interestOps()::: write event interest ops:::return
TransportImpl.WriteEvent#handle()::: write event handle:::if->debug->on->debug->log->s->do->writeState->get->if->if->debug->on->debug->log->break->while->writeState->compareAndSet->sendScheduler->runOrSchedule
TransportImpl.ReadEvent#interestOps()::: read event interest ops:::return
TransportImpl.ReadEvent#handle()::: read event handle:::if->debug->on->debug->log->receiveScheduler->runOrSchedule
UTF8AccumulatingDecoder#decode(ByteBuffer, boolean)::: f8 accumulating decoder decode:::b->rem->leftovers->remaining->if->ByteBuffer->in->remaining->allocate->b->put->put->flip->else->out->CharBuffer->b->remaining->allocate->r->decoder->decode->if->r->isError->r->throwException->if->b->hasRemaining->ByteBuffer->b->remaining->allocate->put->flip->else->if->leftovers->remaining->Log->leftovers->remaining->logError->b->b->limit->position->if->decoder->flush->decoder->reset->if->r->isOverflow->throw->new->InternalError->return->out->flip
WebSocketImpl#newInstanceAsync(BuilderImpl)::: web socket impl new instance async:::newWebSocket->ws->b->getUri->b->getListener->newInstance->Reference->reachabilityFence->return->h->try->new->OpeningHandshake->catch->return->failedFuture->finally->return->h->send->thenApply
WebSocketImpl#newInstance(URI, String, Listener, TransportFactory)::: web socket impl new instance:::ws->new->WebSocketImpl->ws->signalOpen->return
WebSocketImpl#sendText(CharSequence, boolean)::: web socket impl send text:::Objects->requireNonNull->id->if->debug->on->sendCounter->incrementAndGet->debug->message->length->log->result->if->setPendingTextOrBinary->new->IllegalStateException->failedFuture->else->transport->clearPendingTextOrBinary->sendText->if->debug->on->debug->log->return->replaceNull
WebSocketImpl#sendBinary(ByteBuffer, boolean)::: web socket impl send binary:::Objects->requireNonNull->id->if->debug->on->sendCounter->incrementAndGet->debug->log->result->if->setPendingTextOrBinary->new->IllegalStateException->failedFuture->else->transport->clearPendingTextOrBinary->sendBinary->if->debug->on->debug->log->return->replaceNull
WebSocketImpl#clearPendingTextOrBinary()::: web socket impl clear pending text or binary:::pendingTextOrBinary->set
WebSocketImpl#setPendingTextOrBinary()::: web socket impl set pending text or binary:::return->pendingTextOrBinary->compareAndSet
WebSocketImpl#replaceNull(CompletableFuture)::: web socket impl replace null:::if->return->else->return
WebSocketImpl#sendPing(ByteBuffer)::: web socket impl send ping:::Objects->requireNonNull->id->if->debug->on->sendCounter->incrementAndGet->debug->log->result->if->setPendingPingOrPong->new->IllegalStateException->failedFuture->else->transport->clearPendingPingOrPong->sendPing->if->debug->on->debug->log->return->replaceNull
WebSocketImpl#sendPong(ByteBuffer)::: web socket impl send pong:::Objects->requireNonNull->id->if->debug->on->sendCounter->incrementAndGet->debug->log->result->if->setPendingPingOrPong->new->IllegalStateException->failedFuture->else->transport->clearPendingPingOrPong->sendPong->if->debug->on->debug->log->return->replaceNull
WebSocketImpl#setPendingPingOrPong()::: web socket impl set pending ping or pong:::return->pendingPingOrPong->compareAndSet
WebSocketImpl#clearPendingPingOrPong()::: web socket impl clear pending ping or pong:::pendingPingOrPong->set
WebSocketImpl#sendClose(int, String)::: web socket impl send close:::Objects->requireNonNull->id->if->debug->on->sendCounter->incrementAndGet->debug->reason->length->log->result->if->isLegalToSendFromClient->new->IllegalArgumentException->failedFuture->else->if->isLegalReason->new->IllegalArgumentException->failedFuture->else->if->outputClosed->compareAndSet->new->IOException->failedFuture->else->sendClose0->if->debug->on->debug->log->return->replaceNull
WebSocketImpl#isLegalReason(String)::: web socket impl is legal reason:::if->reason->length->return->encoder->newEncoder->onMalformedInput->onUnmappableCharacter->bytes->try->encoder->CharBuffer->wrap->encode->catch->return->finally->return->bytes->remaining
WebSocketImpl#sendClose0(int, String)::: web socket impl send close0:::return->transport->processCloseError->sendClose
WebSocketImpl#processCloseError(Throwable)::: web socket impl process close error:::if->debug->log->else->debug->log->outputClosed->set->try->transport->closeOutput->catch->finally
WebSocketImpl#request(long)::: web socket impl request:::if->debug->on->debug->log->if->demand->increase->receiveScheduler->runOrSchedule
WebSocketImpl#getSubprotocol()::: web socket impl get subprotocol:::return
WebSocketImpl#isOutputClosed()::: web socket impl is output closed:::return->outputClosed->get
WebSocketImpl#isInputClosed()::: web socket impl is input closed:::return
WebSocketImpl#abort()::: web socket impl abort:::if->debug->on->debug->log->outputClosed->set->receiveScheduler->stop->close
WebSocketImpl#toString()::: web socket impl to string:::return->super->toString->subprotocol->isEmpty
WebSocketImpl.ReceiveTask#run()::: receive task run:::if->debug->on->debug->log->while->receiveScheduler->isStopped->s->state->get->if->debug->on->debug->log->try->switch->processOpen->tryChangeState->break->processText->tryChangeState->break->processBinary->tryChangeState->break->processPing->tryChangeState->break->processPong->tryChangeState->break->processClose->break->processError->break->if->demand->tryDecrement->tryChangeState->transport->request->break->break->throw->String->valueOf->new->InternalError->catch->signalError->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processError()::: receive task process error:::if->debug->on->debug->log->transport->closeInput->receiveScheduler->stop->err->error->get->if->code1->getStatusCode->new->ProtocolException->initCause->if->debug->on->debug->log->sendCloseSilently->id->if->debug->on->receiveCounter->incrementAndGet->debug->log->try->listener->onError->catch->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processClose()::: receive task process close:::debug->log->transport->closeInput->receiveScheduler->stop->cs->id->if->debug->on->receiveCounter->incrementAndGet->debug->reason->length->log->try->listener->onClose->catch->finally->debug->log->if->code->if->debug->log->else->cs->if->debug->on->debug->log->sendCloseSilently->whenComplete
WebSocketImpl.ReceiveTask#processPong()::: receive task process pong:::id->if->debug->on->receiveCounter->incrementAndGet->debug->log->cs->try->listener->onPong->catch->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processPing()::: receive task process ping:::if->debug->on->debug->log->slice->binaryData->slice->if->outputClosed->get->copy->ByteBuffer->binaryData->remaining->allocate->put->flip->if->trySwapAutomaticPong->reporter->if->Utils->getCompletionCause->signalError->transport->WebSocketImpl.this->clearAutomaticPong->sendPong->id->if->debug->on->receiveCounter->incrementAndGet->debug->log->cs->try->listener->onPing->catch->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processBinary()::: receive task process binary:::id->if->debug->on->receiveCounter->incrementAndGet->debug->log->cs->try->listener->onBinary->catch->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processText()::: receive task process text:::id->if->debug->on->receiveCounter->incrementAndGet->debug->text->length->log->cs->try->listener->onText->catch->finally->if->debug->on->debug->log
WebSocketImpl.ReceiveTask#processOpen()::: receive task process open:::id->if->debug->on->receiveCounter->incrementAndGet->debug->log->try->listener->onOpen->catch->finally->if->debug->on->debug->log
WebSocketImpl#sendCloseSilently(int)::: web socket impl send close silently:::sendClose0->if->if->debug->on->debug->log->whenComplete
WebSocketImpl#clearAutomaticPong()::: web socket impl clear automatic pong:::data->do->lastAutomaticPong->get->if->throw->new->InternalError->while->lastAutomaticPong->compareAndSet->return
WebSocketImpl#trySwapAutomaticPong(ByteBuffer)::: web socket impl try swap automatic pong:::message->swapped->while->lastAutomaticPong->get->if->if->lastAutomaticPong->compareAndSet->throw->new->InternalError->break->else->if->lastAutomaticPong->compareAndSet->break->if->debug->on->debug->log->return
WebSocketImpl#signalOpen()::: web socket impl signal open:::debug->log->receiveScheduler->runOrSchedule
WebSocketImpl#signalError(Throwable)::: web socket impl signal error:::if->debug->on->debug->log->outputClosed->set->if->compareAndSet->trySetState->if->debug->on->debug->log->Log->logError->else->close
WebSocketImpl#close()::: web socket impl close:::if->debug->on->debug->log->first->try->transport->closeInput->catch->finally->second->try->transport->closeOutput->catch->finally->e->if->first->addSuppressed->else->if->else->if->if->if->debug->on->debug->log
WebSocketImpl#signalClose(int, String)::: web socket impl signal close:::managed->trySetState->if->debug->on->debug->reason->length->log->if->try->transport->closeInput->catch->if->debug->on->debug->log->finally
WebSocketImpl.SignallingMessageConsumer#onText(CharSequence, boolean)::: signalling message consumer on text:::transport->acknowledgeReception->tryChangeState
WebSocketImpl.SignallingMessageConsumer#onBinary(ByteBuffer, boolean)::: signalling message consumer on binary:::transport->acknowledgeReception->tryChangeState
WebSocketImpl.SignallingMessageConsumer#onPing(ByteBuffer)::: signalling message consumer on ping:::transport->acknowledgeReception->tryChangeState
WebSocketImpl.SignallingMessageConsumer#onPong(ByteBuffer)::: signalling message consumer on pong:::transport->acknowledgeReception->tryChangeState
WebSocketImpl.SignallingMessageConsumer#onClose(int, CharSequence)::: signalling message consumer on close:::transport->acknowledgeReception->reason->toString->signalClose
WebSocketImpl.SignallingMessageConsumer#onComplete()::: signalling message consumer on complete:::transport->acknowledgeReception->signalClose
WebSocketImpl.SignallingMessageConsumer#onError(Throwable)::: signalling message consumer on error:::signalError
WebSocketImpl#trySetState(State)::: web socket impl try set state:::currentState->success->while->state->get->if->break->else->if->state->compareAndSet->receiveScheduler->runOrSchedule->break->if->debug->on->debug->log->return
WebSocketImpl#tryChangeState(State, State)::: web socket impl try change state:::witness->state->compareAndExchange->success->if->receiveScheduler->runOrSchedule->else->if->throw->new->InternalError->if->debug->on->debug->log->return
WebSocketImpl#transport()::: web socket impl transport:::return
WebSocketRequest#isWebSocket(boolean)::: web socket request is web socket:::
WebSocketRequest#setSystemHeader(String, String)::: web socket request set system header:::
WebSocketRequest#setProxy(Proxy)::: web socket request set proxy:::
