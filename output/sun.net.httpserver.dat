AuthFilter#doFilter(HttpExchange, Filter.Chain):::The filter's implementation, which is invoked by the server:::if->r->authenticator->authenticate->if->s->e->ExchangeImpl->get->e->s->getPrincipal->setPrincipal->chain->doFilter->else->if->ry->consumeInput->t->ry->getResponseCode->sendResponseHeaders->else->if->f->consumeInput->t->f->getResponseCode->sendResponseHeaders->else->chain->doFilter
ChunkedInputStream#available():::returns the number of bytes available to read in the current chunk which may be less than the real amount, but we'll live with that limitation for the moment:::if->return->n->in->available->return
ExchangeImpl#getConnection():::PP:::return
HttpContextImpl#getHandler():::returns the handler for this context:::return
HttpContextImpl#getPath():::returns the path this context was created with:::return
HttpContextImpl#getServer():::returns the server this context was created with:::return->server->getWrapper
HttpContextImpl#getProtocol():::returns the protocol this context was created with:::return
HttpContextImpl#getAttributes():::returns a mutable Map, which can be used to pass configuration and other data to Filter modules and to the context's exchange handler:::return
LeftOverInputStream#isDataBuffered():::if bytes are left over buffered on *the UNDERLYING* stream:::return->super->available
LeftOverInputStream#drain(long):::read and discard up to l bytes or "eof" occurs, (whichever is first):::bufSize->db->new->byteArr->while->if->server->isFinishing->break->len->readImpl->if->return->else->return
Request#requestLine():::returns the request line (first line of a request):::return
SSLStreams#close():::cleanup resources allocated inside this object:::wrapper->close
SSLStreams#getInputStream():::return the SSL InputStream:::if->new->InputStream->return
SSLStreams#getOutputStream():::return the SSL OutputStream:::if->new->OutputStream->return
SSLStreams#beginHandshake():::request the engine to repeat the handshake on this session the handshake must be driven by reads/writes on the streams Normally, not necessary to call this.:::engine->beginHandshake
SSLStreams#sendData(ByteBuffer):::send the data in the given ByteBuffer:::r->while->src->remaining->wrapper->wrapAndSend->status->getStatus->if->doClosure->return->hs_status->getHandshakeStatus->if->doHandshake->return
SSLStreams#recvData(ByteBuffer):::read data thru the engine into the given ByteBuffer:::r->while->dst->position->wrapper->recvAndUnwrap->status->getStatus->if->doClosure->return->hs_status->getHandshakeStatus->if->doHandshake->dst->flip->return
SSLStreams.InputStream#close():::close the SSL connection:::engine->closeInbound
