BasicType#toString():::Convert enumeration value to a String.:::return
BasicType#intValue():::Convert enumeration to an integer value.:::return
BasicType#toBasicType(int):::Map an integer value to its corresponding BasicType object.:::for->j->return
PerfDataBuffer#buildMonitorMap(Map)::: perf data buffer build monitor map:::buffer->rewind->buildPseudoMonitors->buffer->prologue->getSize->position->buffer->position->used->prologue->getUsed->modificationTime->prologue->getModificationTimeStamp->m->getNextMonitorEntry->while->map->m->getName->put->getNextMonitorEntry->synchWithTarget->kludge->map->values->new->ArrayList<Monitor>
PerfDataBuffer#getNewMonitors(Map)::: perf data buffer get new monitors:::used->prologue->getUsed->modificationTime->prologue->getModificationTimeStamp->if->monitor->getNextMonitorEntry->while->name->monitor->getName->if->map->containsKey->map->put->if->insertedMonitors->add->getNextMonitorEntry
PerfDataBuffer#getMonitorStatus(Map)::: perf data buffer get monitor status:::getNewMonitors->removed->inserted->new->ArrayList<Monitor>->return->new->MonitorStatus
PerfDataBuffer#buildPseudoMonitors(Map):::Build the pseudo monitors used to map the prolog data into counters.:::monitor->name->ib->prologue->majorVersionBuffer->new->PerfIntegerMonitor->map->put->prologue->minorVersionBuffer->new->PerfIntegerMonitor->map->put->prologue->sizeBuffer->new->PerfIntegerMonitor->map->put->prologue->usedBuffer->new->PerfIntegerMonitor->map->put->prologue->overflowBuffer->new->PerfIntegerMonitor->map->put->lb->prologue->modificationTimeStampBuffer->new->PerfLongMonitor->map->put
PerfDataBuffer#synchWithTarget(Map):::Method to provide a gross level of synchronization with the target monitored jvm:::timeLimit->System->currentTimeMillis->name->ticks->pollFor->while->ticks->longValue->try->Thread->sleep->catch->finally->if->System->currentTimeMillis->throw->new->MonitorException
PerfDataBuffer#pollFor(Map, String, long):::Method to poll the instrumentation memory for a counter with the given name:::monitor->while->map->get->try->Thread->sleep->catch->finally->t->System->currentTimeMillis->if->overflow->intValue->throw->new->MonitorException->getNewMonitors->return
PerfDataBuffer#kludge(Map):::method to make adjustments for known counter problems:::if->Boolean->getBoolean->return->name->jvm_version->map->get->if->findByAlias->jvm_name->map->get->if->findByAlias->args->map->get->if->findByAlias->if->jvm_name->stringValue->indexOf->if->jvm_version->stringValue->startsWith->kludgeMantis
PerfDataBuffer#kludgeMantis(Map, StringMonitor):::method to repair the 1.4.2 parallel scavenge counters that are incorrectly initialized by the JVM when UseAdaptiveSizePolicy is set:::cname->collector->map->get->if->collector->stringValue->compareTo->adaptiveSizePolicy->flags->map->get->allArgs->flags->stringValue->args->stringValue->ahi->allArgs->lastIndexOf->aspi->allArgs->lastIndexOf->if->if->else->if->if->eden_size->s0_size->s1_size->map->remove->map->remove->map->remove->new_max_name->new_max->map->get->monitor->lb->LongBuffer->allocate->lb->new_max->longValue->put->new->PerfLongMonitor->map->put->new->PerfLongMonitor->map->put->new->PerfLongMonitor->map->put
PerfDataBuffer#getNextMonitorEntry():::method to extract the next monitor entry from the instrumentation memory:::monitor->if->throw->new->MonitorStructureException->if->buffer->limit->throw->buffer->limit->new->MonitorStructureException->if->buffer->limit->return->buffer->position->entryStart->buffer->position->entryLength->buffer->getInt->if->buffer->limit->throw->new->MonitorStructureException->if->buffer->limit->throw->buffer->limit->new->MonitorStructureException->if->return->nameLength->buffer->getInt->vectorLength->buffer->getInt->dataType->buffer->get->flags->buffer->get->u->Units->buffer->get->toUnits->v->Variability->buffer->get->toVariability->supported->if->throw->new->MonitorStructureException->if->throw->new->MonitorStructureException->nameBytes->new->byteArr->for->i->name->new->String->if->throw->new->MonitorDataException->if->throw->new->MonitorDataException->offset->if->if->intValue->buffer->position->lb->buffer->asLongBuffer->lb->limit->new->PerfLongMonitor->else->throw->new->MonitorTypeException->else->if->intValue->if->throw->new->MonitorTypeException->buffer->position->bb->buffer->slice->bb->limit->bb->position->if->new->PerfStringConstantMonitor->else->if->new->PerfStringVariableMonitor->else->throw->new->MonitorDataException->else->throw->new->MonitorTypeException->return
PerfDataBufferPrologue#supportsAccessible()::: perf data buffer prologue supports accessible:::return
PerfDataBufferPrologue#isAccessible()::: perf data buffer prologue is accessible:::return
PerfDataBufferPrologue#getUsed():::Get the utilization of the instrumentation memory buffer.:::byteBuffer->position->return->byteBuffer->getInt
PerfDataBufferPrologue#getBufferSize():::Get the size of the instrumentation memory buffer.:::return->byteBuffer->capacity
PerfDataBufferPrologue#getOverflow():::Get the buffer overflow amount:::byteBuffer->position->return->byteBuffer->getInt
PerfDataBufferPrologue#getModificationTimeStamp():::Get the time of last modification for the instrumentation memory buffer:::byteBuffer->position->return->byteBuffer->getLong
PerfDataBufferPrologue#getSize()::: perf data buffer prologue get size:::return
PerfDataBufferPrologue#usedBuffer():::Return an IntBuffer that accesses the used value:::byteBuffer->position->ib->byteBuffer->asIntBuffer->ib->limit->return
PerfDataBufferPrologue#sizeBuffer():::Return an IntBuffer that accesses the size value:::ib->IntBuffer->allocate->ib->byteBuffer->capacity->put->return
PerfDataBufferPrologue#overflowBuffer():::Return an IntBuffer that accesses the overflow value:::byteBuffer->position->ib->byteBuffer->asIntBuffer->ib->limit->return
PerfDataBufferPrologue#modificationTimeStampBuffer():::Return an LongBuffer that accesses the modification timestamp value:::byteBuffer->position->lb->byteBuffer->asLongBuffer->lb->limit->return
