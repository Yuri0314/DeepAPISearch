AArch64LIRGenerator#canStoreConstant(JavaConstant):::Checks whether the supplied constant can be used without loading it into a register for store operations, i.e., on the right hand side of a memory access.:::return
AArch64LIRGenerator#moveSp(AllocatableValue):::If val denotes the stackpointer, move it to another location:::if->getRegister->equals->return->emitMove->return
AArch64LIRGenerator#toRegisterKind(K):::AArch64 cannot use anything smaller than a word in any instruction other than load and store.:::switch->kind->getPlatformKind->return->kind->changeType->return
AArch64LIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double):::Branches to label if (left & right) == 0:::getArithmetic->LIRKind->combine->emitBinary->new->AArch64ControlFlow.BranchOp->append
AArch64LIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value):::Conditionally move trueValue into new variable if cond + unorderedIsTrue is true, else falseValue.:::arithLir->actualRight->if->isJavaConstant->arithLir->asJavaConstant->mustReplaceNullWithNullRegister->arithLir->getNullRegisterValue->mirrored->emitCompare->finalCondition->cond->mirror->finalUnorderedIsTrue->cmpCondition->isInteger->toConditionFlag->result->trueValue->getValueKind->newVariable->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->if->isIntConstant->isIntConstant->cmpCondition->negate->new->CondSetOp->append->else->loadReg->loadReg->new->CondMoveOp->append->return
AArch64LIRGenerator#emitCompare(PlatformKind, Value, Value, Condition, boolean):::This method emits the compare instruction, and may reorder the operands:::left->right->mirrored->kind->if->kind->isInteger->aExt->bExt->compareBytes->cmpKind->getSizeInBytes->if->a->getPlatformKind->getSizeInBytes->arithmeticLIRGen->emitSignExtend->if->b->getPlatformKind->getSizeInBytes->arithmeticLIRGen->emitSignExtend->if->LIRValueUtil->isVariable->load->loadNonConst->else->load->loadNonConst->loadNonCompareConst->new->AArch64Compare.CompareOp->append->else->if->kind->isSIMD->if->isFloatCmpConstant->load->else->if->isFloatCmpConstant->load->else->load->loadReg->asAllocatable->new->AArch64Compare.FloatCompareOp->append->else->throw->GraalError->shouldNotReachHere->return
AArch64LIRGenerator#loadNonCompareConst(Value):::If value is a constant that cannot be used directly with a gpCompare instruction load it into a register and return the register, otherwise return constant value unchanged.:::if->isCompareConstant->return->loadReg->return
AArch64LIRGenerator#isCompareConstant(Value):::Checks whether value can be used directly with a gpCompare instruction:::if->isJavaConstant->constant->asJavaConstant->if->longValue->constant->asLong->maskedValue->switch->constant->getJavaKind->break->break->break->break->throw->GraalError->shouldNotReachHere->return->AArch64MacroAssembler->isArithmeticImmediate->else->return->constant->isDefaultForKind->return
AArch64LIRGenerator#emitIntegerTestMove(Value, Value, Value, Value):::Moves trueValue into result if (left & right) == 0, else falseValue.:::getArithmetic->left->getValueKind->emitBinary->result->trueValue->getValueKind->newVariable->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->load->load->new->CondMoveOp->append->return
AArch64LIRGenerator#loadReg(Value):::Loads value into virtual register:::if->return->emitMove->return
AArch64NodeMatchRules#testBitAndBranch(IfNode, ValueNode, ConstantNode):::((x & (1 << n)) == 0) -> tbz/tbnz n label.:::if->value->getStackKind->isNumericInteger->constant->a->asJavaConstant->asLong->if->Long->bitCount->return->root->trueSuccessor->root->falseSuccessor->root->getTrueSuccessorProbability->Long->numberOfTrailingZeros->emitBitTestAndBranch->return
AArch64NodeMatchRules#checkNegativeAndBranch(IfNode, IntegerLessThanNode, ValueNode, ConstantNode):::if x < 0 <=> tbz x, sizeOfBits(x) - 1, label.:::xKind->x->getStackKind->if->y->isJavaConstant->y->asJavaConstant->asLong->lessNode->condition->equals->return->root->falseSuccessor->root->trueSuccessor->root->getTrueSuccessorProbability->xKind->getBitCount->emitBitTestAndBranch->return
AArch64ReadNode#replace(ReadNode):::replace a ReadNode with an AArch64-specific variant which knows how to merge a downstream zero or sign extend into the read operation.:::usage->readNode->usages->first->isSigned->accessStamp->readNode->getAccessStamp->address->readNode->getAddress->location->readNode->getLocationIdentity->stamp->usage->stamp->guard->readNode->getGuard->barrierType->readNode->getBarrierType->nullCheck->readNode->getNullCheck->stateBefore->readNode->stateBefore->clone->new->AArch64ReadNode->graph->readNode->graph->graph->add->usage->replaceAtUsagesAndDelete->graph->replaceFixedWithFixed
