AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_testBitAndBranch#match(NodeMatchRules, Object...)::: match generator_test bit and branch match:::return->testBitAndBranch
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_testBitAndBranch#getName()::: match generator_test bit and branch get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_logicShift#match(NodeMatchRules, Object...)::: match generator_logic shift match:::return->logicShift
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_logicShift#getName()::: match generator_logic shift get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_addSubShift#match(NodeMatchRules, Object...)::: match generator_add sub shift match:::return->addSubShift
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_addSubShift#getName()::: match generator_add sub shift get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_multiplyNegate#match(NodeMatchRules, Object...)::: match generator_multiply negate match:::return->multiplyNegate
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_multiplyNegate#getName()::: match generator_multiply negate get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_checkNegativeAndBranch#match(NodeMatchRules, Object...)::: match generator_check negative and branch match:::return->checkNegativeAndBranch
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_checkNegativeAndBranch#getName()::: match generator_check negative and branch get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_unsignedBitField#match(NodeMatchRules, Object...)::: match generator_unsigned bit field match:::return->unsignedBitField
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_unsignedBitField#getName()::: match generator_unsigned bit field get name:::return
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_multiplyAddSub#match(NodeMatchRules, Object...)::: match generator_multiply add sub match:::return->multiplyAddSub
AArch64NodeMatchRules_MatchStatementSet.MatchGenerator_multiplyAddSub#getName()::: match generator_multiply add sub get name:::return
AArch64NodeMatchRules_MatchStatementSet#forClass()::: arch64 node match rules_ match statement set for class:::return
AArch64NodeMatchRules_MatchStatementSet#statements()::: arch64 node match rules_ match statement set statements:::OrNode_positions->MatchRuleRegistry->new->StringArr->findPositions->NegateNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IfNode_positions->MatchRuleRegistry->new->StringArr->findPositions->MulNode_positions->MatchRuleRegistry->new->StringArr->findPositions->AndNode_positions->MatchRuleRegistry->new->StringArr->findPositions->AddNode_positions->MatchRuleRegistry->new->StringArr->findPositions->LeftShiftNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerLessThanNode_positions->MatchRuleRegistry->new->StringArr->findPositions->UnsignedRightShiftNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerTestNode_positions->MatchRuleRegistry->new->StringArr->findPositions->SubNode_positions->MatchRuleRegistry->new->StringArr->findPositions->NotNode_positions->MatchRuleRegistry->new->StringArr->findPositions->RightShiftNode_positions->MatchRuleRegistry->new->StringArr->findPositions->XorNode_positions->MatchRuleRegistry->new->StringArr->findPositions->statements->Collections->Arrays->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->asList->unmodifiableList->return
AArch64AddressLoweringByUse#lower(ValueNode, Stamp, AddressNode)::: arch64 address lowering by use lower:::if->offsetAddress->return->offsetAddress->getBase->offsetAddress->getOffset->doLower->else->return
AArch64AddressLoweringByUse#lower(AddressNode)::: arch64 address lowering by use lower:::return->lower
AArch64AddressLoweringByUse#doLower(Stamp, ValueNode, ValueNode)::: arch64 address lowering by use do lower:::ret->new->AArch64AddressNode->aarch64Kind->getAArch64Kind->changed->do->improve->while->return->base->graph->unique
AArch64AddressLoweringByUse#improve(AArch64Kind, AArch64AddressNode)::: arch64 address lowering by use improve:::mode->ret->getAddressingMode->if->isDisplacementMode->isBaseOnlyMode->return->base->ret->getBase->index->ret->getIndex->if->ret->setBase->ret->setIndex->return->if->base->isJavaConstant->base->asJavaConstant->getJavaKind->isNumericInteger->index->isJavaConstant->ret->setBase->ret->setIndex->return->if->add->ret->add->getX->setBase->ret->add->getY->setIndex->return->if->index->isJavaConstant->javaConstant->index->asJavaConstant->if->javaConstant->getJavaKind->isNumericInteger->disp->javaConstant->asLong->immediateMode->if->isDisplacementMode->tryNextBase->while->add->child->add->getX->if->child->isJavaConstant->child->asJavaConstant->getJavaKind->isNumericInteger->newDisp->child->asJavaConstant->asLong->newMode->immediateMode->if->add->getY->ret->setBase->else->add->getY->if->child->isJavaConstant->child->asJavaConstant->getJavaKind->isNumericInteger->newDisp->child->asJavaConstant->asLong->newMode->immediateMode->if->add->getX->ret->setBase->if->ret->setIndex->scaleFactor->computeScaleFactor->ret->setDisplacement->else->ret->setIndex->ret->setDisplacement->return->return
AArch64AddressLoweringByUse#getAArch64Kind(Stamp)::: arch64 address lowering by use get arch64 kind:::lirKind->stamp->getLIRKind->if->lirKind->isValue->if->lirKind->isReference->lirKind->getReferenceCount->return->return->lirKind->getPlatformKind
AArch64AddressLoweringByUse#immediateMode(AArch64Kind, long)::: arch64 address lowering by use immediate mode:::if->size->kind->getSizeInBytes->if->encodedValue->if->NumUtil->isUnsignedNbit->return->if->NumUtil->isSignedNbit->return->return
AArch64AddressLoweringByUse#computeScaleFactor(AArch64Kind, AArch64Address.AddressingMode)::: arch64 address lowering by use compute scale factor:::if->return->kind->getSizeInBytes->return
AArch64AddressLoweringByUse#isBaseOnlyMode(AArch64Address.AddressingMode)::: arch64 address lowering by use is base only mode:::return
AArch64AddressLoweringByUse#isDisplacementMode(AArch64Address.AddressingMode)::: arch64 address lowering by use is displacement mode:::switch->return->return
AArch64AddressNode#generate(NodeLIRBuilderTool)::: arch64 address node generate:::tool->gen->getLIRGeneratorTool->baseValue->tool->gen->operand->asAllocatable->indexValue->tool->gen->operand->asAllocatable->baseReference->LIRKind->derivedBaseFromValue->indexReference->if->else->if->addressingMode->equals->LIRKind->derivedBaseFromValue->else->if->LIRKind->indexValue->getValueKind->isValue->else->kind->LIRKind->tool->stamp->getLIRKind->combineDerived->gen->new->AArch64AddressValue->setResult
AArch64AddressNode#getBase()::: arch64 address node get base:::return
AArch64AddressNode#setBase(ValueNode)::: arch64 address node set base:::if->isAlive->updateUsages
AArch64AddressNode#getIndex()::: arch64 address node get index:::return
AArch64AddressNode#setIndex(ValueNode)::: arch64 address node set index:::if->isAlive->updateUsages
AArch64AddressNode#getDisplacement()::: arch64 address node get displacement:::return
AArch64AddressNode#setDisplacement(long, int, AArch64Address.AddressingMode)::: arch64 address node set displacement:::
AArch64AddressNode#getMaxConstantDisplacement()::: arch64 address node get max constant displacement:::return
AArch64AddressNode#getAddressingMode()::: arch64 address node get addressing mode:::return
AArch64ArithmeticLIRGenerator#getLIRGen()::: arch64 arithmetic generator get gen:::return->super->getLIRGen
AArch64ArithmeticLIRGenerator#mustReplaceNullWithNullRegister(JavaConstant)::: arch64 arithmetic generator must replace null with null register:::return->equals
AArch64ArithmeticLIRGenerator#getNullRegisterValue()::: arch64 arithmetic generator get null register value:::return
AArch64ArithmeticLIRGenerator#isNumericInteger(PlatformKind)::: arch64 arithmetic generator is numeric integer:::return->isInteger
AArch64ArithmeticLIRGenerator#emitAdd(LIRKind, Value, Value, boolean)::: arch64 arithmetic generator emit add:::if->a->getPlatformKind->isNumericInteger->op->return->emitBinary->else->return->emitBinary
AArch64ArithmeticLIRGenerator#emitSub(LIRKind, Value, Value, boolean)::: arch64 arithmetic generator emit sub:::if->a->getPlatformKind->isNumericInteger->op->return->emitBinary->else->return->emitBinary
AArch64ArithmeticLIRGenerator#emitExtendMemory(boolean, AArch64Kind, int, AArch64AddressValue, LIRFrameState)::: arch64 arithmetic generator emit extend memory:::result->getLIRGen->LIRKind->value->newVariable->targetSize->switch->getLIRGen->memoryKind->getSizeInBytes->new->AArch64Unary.MemoryOp->append->break->throw->GraalError->shouldNotReachHere->return
AArch64ArithmeticLIRGenerator#emitMul(Value, Value, boolean)::: arch64 arithmetic generator emit mul:::intOp->return->LIRKind->combine->getOpCode->emitBinary
AArch64ArithmeticLIRGenerator#emitMulHigh(Value, Value)::: arch64 arithmetic generator emit mul high:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitUMulHigh(Value, Value)::: arch64 arithmetic generator emit mul high:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitMNeg(Value, Value)::: arch64 arithmetic generator emit neg:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitDiv(Value, Value, LIRFrameState)::: arch64 arithmetic generator emit div:::return->LIRKind->combine->getOpCode->asAllocatable->asAllocatable->emitBinary
AArch64ArithmeticLIRGenerator#emitRem(Value, Value, LIRFrameState)::: arch64 arithmetic generator emit rem:::return->LIRKind->combine->getOpCode->asAllocatable->asAllocatable->emitBinary
AArch64ArithmeticLIRGenerator#emitUDiv(Value, Value, LIRFrameState)::: arch64 arithmetic generator emit div:::return->LIRKind->combine->asAllocatable->asAllocatable->emitBinary
AArch64ArithmeticLIRGenerator#emitURem(Value, Value, LIRFrameState)::: arch64 arithmetic generator emit rem:::return->LIRKind->combine->asAllocatable->asAllocatable->emitBinary
AArch64ArithmeticLIRGenerator#emitAnd(Value, Value)::: arch64 arithmetic generator emit and:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitOr(Value, Value)::: arch64 arithmetic generator emit or:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitXor(Value, Value)::: arch64 arithmetic generator emit xor:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitShl(Value, Value)::: arch64 arithmetic generator emit shl:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitShr(Value, Value)::: arch64 arithmetic generator emit shr:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitUShr(Value, Value)::: arch64 arithmetic generator emit shr:::return->LIRKind->combine->emitBinary
AArch64ArithmeticLIRGenerator#emitFloatConvert(FloatConvert, Value)::: arch64 arithmetic generator emit float convert:::resultPlatformKind->getFloatConvertResultKind->resultLirKind->LIRKind->combine->changeType->result->getLIRGen->newVariable->getLIRGen->asAllocatable->new->AArch64FloatConvertOp->append->return
AArch64ArithmeticLIRGenerator#emitMAdd(Value, Value, Value)::: arch64 arithmetic generator emit add:::return->emitMultiplyAddSub
AArch64ArithmeticLIRGenerator#emitMSub(Value, Value, Value)::: arch64 arithmetic generator emit sub:::return->emitMultiplyAddSub
AArch64ArithmeticLIRGenerator#emitMultiplyAddSub(AArch64ArithmeticOp, Value, Value, Value)::: arch64 arithmetic generator emit multiply add sub:::result->getLIRGen->LIRKind->combine->newVariable->x->asAllocatable->moveSp->y->asAllocatable->moveSp->z->asAllocatable->moveSp->getLIRGen->new->AArch64ArithmeticOp.MultiplyAddSubOp->append->return
AArch64ArithmeticLIRGenerator#getFloatConvertResultKind(FloatConvert)::: arch64 arithmetic generator get float convert result kind:::switch->return->return->return->return->throw->GraalError->shouldNotReachHere
AArch64ArithmeticLIRGenerator#emitReinterpret(LIRKind, Value)::: arch64 arithmetic generator emit reinterpret:::from->inputVal->getValueKind->if->to->equals->return->result->getLIRGen->newVariable->getLIRGen->asAllocatable->new->AArch64ReinterpretOp->append->return
AArch64ArithmeticLIRGenerator#emitNarrow(Value, int)::: arch64 arithmetic generator emit narrow:::if->inputVal->getPlatformKind->resultKind->getResultLirKind->mask->NumUtil->getNbitNumberLong->maskValue->JavaConstant->forLong->new->ConstantValue->return->emitBinary->else->return
AArch64ArithmeticLIRGenerator#emitZeroExtend(Value, int, int)::: arch64 arithmetic generator emit zero extend:::if->return->resultKind->getResultLirKind->mask->NumUtil->getNbitNumberLong->maskValue->JavaConstant->forLong->new->ConstantValue->return->emitBinary
AArch64ArithmeticLIRGenerator#emitSignExtend(Value, int, int)::: arch64 arithmetic generator emit sign extend:::resultKind->getResultLirKind->if->return->else->if->isJavaConstant->javaConstant->asJavaConstant->constant->if->javaConstant->isNull->else->javaConstant->asLong->shiftCount->QWORD->getSizeInBytes->return->JavaConstant->forLong->new->ConstantValue->result->getLIRGen->newVariable->getLIRGen->asAllocatable->new->AArch64SignExtendOp->append->return
AArch64ArithmeticLIRGenerator#getResultLirKind(int, Value...)::: arch64 arithmetic generator get result lir kind:::if->return->LIRKind->combine->changeType->else->return->LIRKind->combine->changeType
AArch64ArithmeticLIRGenerator#emitBinary(ValueKind, AArch64ArithmeticOp, boolean, Value, Value)::: arch64 arithmetic generator emit binary:::result->getLIRGen->newVariable->if->isValidBinaryConstant->asAllocatable->asJavaConstant->emitBinaryConst->else->if->isValidBinaryConstant->asAllocatable->asJavaConstant->emitBinaryConst->else->asAllocatable->asAllocatable->emitBinaryVar->return
AArch64ArithmeticLIRGenerator#emitBinaryVar(Variable, AArch64ArithmeticOp, AllocatableValue, AllocatableValue)::: arch64 arithmetic generator emit binary var:::x->moveSp->y->moveSp->switch->getLIRGen->new->AArch64ArithmeticOp.BinaryCompositeOp->append->break->getLIRGen->new->AArch64ArithmeticOp.BinaryOp->append->break
AArch64ArithmeticLIRGenerator#emitBinaryConst(Variable, AArch64ArithmeticOp, AllocatableValue, JavaConstant)::: arch64 arithmetic generator emit binary const:::x->moveSp->getLIRGen->new->AArch64ArithmeticOp.BinaryConstOp->append
AArch64ArithmeticLIRGenerator#isValidBinaryConstant(AArch64ArithmeticOp, Value, Value)::: arch64 arithmetic generator is valid binary constant:::if->isJavaConstant->return->constValue->asJavaConstant->switch->return->isLogicalConstant->return->isArithmeticConstant->return->return->throw->GraalError->shouldNotReachHere
AArch64ArithmeticLIRGenerator#isLogicalConstant(JavaConstant)::: arch64 arithmetic generator is logical constant:::switch->constValue->getJavaKind->return->AArch64MacroAssembler->constValue->asInt->isLogicalImmediate->return->AArch64MacroAssembler->constValue->asLong->isLogicalImmediate->return
AArch64ArithmeticLIRGenerator#isArithmeticConstant(JavaConstant)::: arch64 arithmetic generator is arithmetic constant:::switch->constValue->getJavaKind->return->AArch64MacroAssembler->constValue->asLong->isArithmeticImmediate->return->constValue->isNull->return
AArch64ArithmeticLIRGenerator#emitNegate(Value)::: arch64 arithmetic generator emit negate:::return->getOpCode->emitUnary
AArch64ArithmeticLIRGenerator#emitNot(Value)::: arch64 arithmetic generator emit not:::return->emitUnary
AArch64ArithmeticLIRGenerator#emitMathAbs(Value)::: arch64 arithmetic generator emit math abs:::return->getOpCode->emitUnary
AArch64ArithmeticLIRGenerator#emitMathSqrt(Value)::: arch64 arithmetic generator emit math sqrt:::return->emitUnary
AArch64ArithmeticLIRGenerator#emitBitScanForward(Value)::: arch64 arithmetic generator emit bit scan forward:::throw->GraalError->unimplemented
AArch64ArithmeticLIRGenerator#emitBitCount(Value)::: arch64 arithmetic generator emit bit count:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->getLIRGen->asAllocatable->new->AArch64BitManipulationOp->append->return
AArch64ArithmeticLIRGenerator#emitBitScanReverse(Value)::: arch64 arithmetic generator emit bit scan reverse:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->getLIRGen->asAllocatable->new->AArch64BitManipulationOp->append->return
AArch64ArithmeticLIRGenerator#emitCountLeadingZeros(Value)::: arch64 arithmetic generator emit count leading zeros:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->getLIRGen->asAllocatable->new->AArch64BitManipulationOp->append->return
AArch64ArithmeticLIRGenerator#emitCountTrailingZeros(Value)::: arch64 arithmetic generator emit count trailing zeros:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->getLIRGen->asAllocatable->new->AArch64BitManipulationOp->append->return
AArch64ArithmeticLIRGenerator#emitUnary(AArch64ArithmeticOp, Value)::: arch64 arithmetic generator emit unary:::input->asAllocatable->result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->new->AArch64ArithmeticOp.UnaryOp->append->return
AArch64ArithmeticLIRGenerator#moveSp(AllocatableValue)::: arch64 arithmetic generator move sp:::return->getLIRGen->moveSp
AArch64ArithmeticLIRGenerator#getOpCode(Value, AArch64ArithmeticOp, AArch64ArithmeticOp):::Returns the opcode depending on the platform kind of val.:::return->val->getPlatformKind->isNumericInteger
AArch64ArithmeticLIRGenerator#emitLoad(LIRKind, Value, LIRFrameState)::: arch64 arithmetic generator emit load:::loadAddress->getLIRGen->asAddressValue->result->getLIRGen->getLIRGen->toRegisterKind->newVariable->getLIRGen->kind->getPlatformKind->new->LoadOp->append->return
AArch64ArithmeticLIRGenerator#emitStore(ValueKind, Value, Value, LIRFrameState)::: arch64 arithmetic generator emit store:::storeAddress->getLIRGen->asAddressValue->kind->lirKind->getPlatformKind->if->isJavaConstant->kind->isInteger->c->asJavaConstant->if->c->isDefaultForKind->getLIRGen->new->StoreConstantOp->append->return->input->asAllocatable->getLIRGen->new->StoreOp->append
AArch64ArithmeticLIRGenerator#emitRound(Value, RoundingMode)::: arch64 arithmetic generator emit round:::op->switch->break->break->break->throw->GraalError->shouldNotReachHere->return->emitUnary
AArch64FloatConvertOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: arch64 float convert op emit code:::fromSize->inputValue->getPlatformKind->getSizeInBytes->toSize->resultValue->getPlatformKind->getSizeInBytes->result->asRegister->input->asRegister->switch->masm->fcvtzs->break->masm->scvtf->break->masm->fcvt->break->throw->GraalError->shouldNotReachHere
AArch64LIRGenerator#canStoreConstant(JavaConstant):::Checks whether the supplied constant can be used without loading it into a register for store operations, i.e., on the right hand side of a memory access.:::return
AArch64LIRGenerator#moveSp(AllocatableValue):::If val denotes the stackpointer, move it to another location:::if->getRegister->equals->return->emitMove->return
AArch64LIRGenerator#toRegisterKind(K):::AArch64 cannot use anything smaller than a word in any instruction other than load and store.:::switch->kind->getPlatformKind->return->kind->changeType->return
AArch64LIRGenerator#emitNullCheck(Value, LIRFrameState)::: arch64 generator emit null check:::asAddressValue->new->AArch64Move.NullCheckOp->append
AArch64LIRGenerator#emitAddress(AllocatableValue)::: arch64 generator emit address:::result->LIRKind->target->getWordKind->value->newVariable->new->AArch64Move.StackLoadAddressOp->append->return
AArch64LIRGenerator#asAddressValue(Value)::: arch64 generator as address value:::if->return->else->return->address->getValueKind->asAllocatable->new->AArch64AddressValue
AArch64LIRGenerator#emitLogicCompareAndSwap(LIRKind, Value, Value, Value, Value, Value)::: arch64 generator emit logic compare and swap:::prevValue->expectedValue->getValueKind->newVariable->scratch->LIRKind->value->newVariable->loadReg->loadReg->asAllocatable->new->CompareAndSwapOp->append->result->trueValue->getValueKind->newVariable->asAllocatable->asAllocatable->new->CondMoveOp->append->return
AArch64LIRGenerator#emitValueCompareAndSwap(LIRKind, Value, Value, Value)::: arch64 generator emit value compare and swap:::result->newValue->getValueKind->newVariable->scratch->LIRKind->value->newVariable->loadReg->loadReg->asAllocatable->new->CompareAndSwapOp->append->return
AArch64LIRGenerator#emitAtomicReadAndWrite(Value, ValueKind, Value)::: arch64 generator emit atomic read and write:::result->newVariable->scratch->newVariable->kind->getPlatformKind->asAllocatable->asAllocatable->asAllocatable->asAllocatable->new->AtomicReadAndWriteOp->append->return
AArch64LIRGenerator#emitAtomicReadAndAdd(Value, ValueKind, Value)::: arch64 generator emit atomic read and add:::result->newVariable->if->AArch64LIRFlagsVersioned->target->useLSE->kind->getPlatformKind->asAllocatable->asAllocatable->asAllocatable->new->AtomicReadAndAddLSEOp->append->else->kind->getPlatformKind->asAllocatable->asAllocatable->new->AtomicReadAndAddOp->append->return
AArch64LIRGenerator#emitMembar(int)::: arch64 generator emit membar:::necessaryBarriers->target->requiredBarriers->if->target->new->MembarOp->append
AArch64LIRGenerator#emitJump(LabelRef)::: arch64 generator emit jump:::new->StandardOp.JumpOp->append
AArch64LIRGenerator#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)::: arch64 generator emit overflow check branch:::new->AArch64ControlFlow.BranchOp->append
AArch64LIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double):::Branches to label if (left & right) == 0:::getArithmetic->LIRKind->combine->emitBinary->new->AArch64ControlFlow.BranchOp->append
AArch64LIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value):::Conditionally move trueValue into new variable if cond + unorderedIsTrue is true, else falseValue.:::arithLir->actualRight->if->isJavaConstant->arithLir->asJavaConstant->mustReplaceNullWithNullRegister->arithLir->getNullRegisterValue->mirrored->emitCompare->finalCondition->cond->mirror->finalUnorderedIsTrue->cmpCondition->isInteger->toConditionFlag->result->trueValue->getValueKind->newVariable->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->if->isIntConstant->isIntConstant->cmpCondition->negate->new->CondSetOp->append->else->loadReg->loadReg->new->CondMoveOp->append->return
AArch64LIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)::: arch64 generator emit compare branch:::actualRight->if->arithLir->if->LIRValueUtil->isNullConstant->rightConstant->asJavaConstant->if->arithLir->mustReplaceNullWithNullRegister->arithLir->getNullRegisterValue->else->asAllocatable->new->CompareBranchZeroOp->append->return->kind->if->kind->isInteger->if->isIntConstant->asAllocatable->new->CompareBranchZeroOp->append->return->else->if->isIntConstant->asAllocatable->new->CompareBranchZeroOp->append->return->mirrored->emitCompare->finalCondition->cond->mirror->finalUnorderedIsTrue->cmpCondition->isInteger->toConditionFlag->new->BranchOp->append
AArch64LIRGenerator#toConditionFlag(boolean, Condition, boolean)::: arch64 generator to condition flag:::return->toIntConditionFlag->toFloatConditionFlag
AArch64LIRGenerator#toFloatConditionFlag(Condition, boolean):::Takes a Condition and unorderedIsTrue flag and returns the correct Aarch64 specific ConditionFlag:::switch->return->return->return->return->return->return->throw->GraalError->shouldNotReachHere
AArch64LIRGenerator#toIntConditionFlag(Condition):::Takes a Condition and returns the correct Aarch64 specific ConditionFlag.:::switch->return->return->return->return->return->return->return->return->return->return->throw->GraalError->shouldNotReachHere
AArch64LIRGenerator#emitCompare(PlatformKind, Value, Value, Condition, boolean):::This method emits the compare instruction, and may reorder the operands:::left->right->mirrored->kind->if->kind->isInteger->aExt->bExt->compareBytes->cmpKind->getSizeInBytes->if->a->getPlatformKind->getSizeInBytes->arithmeticLIRGen->emitSignExtend->if->b->getPlatformKind->getSizeInBytes->arithmeticLIRGen->emitSignExtend->if->LIRValueUtil->isVariable->load->loadNonConst->else->load->loadNonConst->loadNonCompareConst->new->AArch64Compare.CompareOp->append->else->if->kind->isSIMD->if->isFloatCmpConstant->load->else->if->isFloatCmpConstant->load->else->load->loadReg->asAllocatable->new->AArch64Compare.FloatCompareOp->append->else->throw->GraalError->shouldNotReachHere->return
AArch64LIRGenerator#loadNonCompareConst(Value):::If value is a constant that cannot be used directly with a gpCompare instruction load it into a register and return the register, otherwise return constant value unchanged.:::if->isCompareConstant->return->loadReg->return
AArch64LIRGenerator#isCompareConstant(Value):::Checks whether value can be used directly with a gpCompare instruction:::if->isJavaConstant->constant->asJavaConstant->if->longValue->constant->asLong->maskedValue->switch->constant->getJavaKind->break->break->break->break->throw->GraalError->shouldNotReachHere->return->AArch64MacroAssembler->isArithmeticImmediate->else->return->constant->isDefaultForKind->return
AArch64LIRGenerator#emitIntegerTestMove(Value, Value, Value, Value):::Moves trueValue into result if (left & right) == 0, else falseValue.:::getArithmetic->left->getValueKind->emitBinary->result->trueValue->getValueKind->newVariable->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->if->isIntConstant->isIntConstant->new->CondSetOp->append->else->load->load->new->CondMoveOp->append->return
AArch64LIRGenerator#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)::: arch64 generator emit strategy switch:::key->getValueKind->newVariable->AArch64LIRGenerator->toIntConditionFlag->createStrategySwitchOp->append
AArch64LIRGenerator#createStrategySwitchOp(SwitchStrategy, LabelRef[], LabelRef, Variable, AllocatableValue, Function)::: arch64 generator create strategy switch op:::return->new->StrategySwitchOp
AArch64LIRGenerator#emitTableSwitch(int, LabelRef, LabelRef[], Value)::: arch64 generator emit table switch:::LIRKind->target->getWordKind->value->newVariable->key->getValueKind->newVariable->new->TableSwitchOp->append
AArch64LIRGenerator#emitByteSwap(Value)::: arch64 generator emit byte swap:::result->LIRKind->combine->newVariable->new->AArch64ByteSwapOp->append->return
AArch64LIRGenerator#emitArrayCompareTo(JavaKind, JavaKind, Value, Value, Value, Value)::: arch64 generator emit array compare to:::resultKind->LIRKind->value->res->asValue->cnt1->length1->getValueKind->asValue->cnt2->length2->getValueKind->asValue->emitMove->emitMove->new->AArch64ArrayCompareToOp->append->result->newVariable->emitMove->return
AArch64LIRGenerator#emitArrayEquals(JavaKind, Value, Value, Value, int, boolean)::: arch64 generator emit array equals:::result->LIRKind->value->newVariable->asAllocatable->new->AArch64ArrayEqualsOp->append->return
AArch64LIRGenerator#zapValueForKind(PlatformKind)::: arch64 generator zap value for kind:::dead->switch->return->JavaConstant->forByte->return->JavaConstant->forShort->return->JavaConstant->forInt->return->JavaConstant->forLong->return->JavaConstant->Float->intBitsToFloat->forFloat->return->JavaConstant->Double->longBitsToDouble->forDouble->throw->GraalError->shouldNotReachHere
AArch64LIRGenerator#loadReg(Value):::Loads value into virtual register:::if->return->emitMove->return
AArch64LIRGenerator#emitPause()::: arch64 generator emit pause:::new->AArch64PauseOp->append
AArch64LIRGenerator#emitCCall(long, CallingConvention, Value[])::: arch64 generator emit call:::
AArch64LIRGenerator#emitSpeculationFence()::: arch64 generator emit speculation fence:::new->AArch64SpeculativeBarrier->append
AArch64LIRKindTool#getIntegerKind(int)::: arch64 kind tool get integer kind:::if->return->LIRKind->value->else->if->return->LIRKind->value->else->if->return->LIRKind->value->else->return->LIRKind->value
AArch64LIRKindTool#getFloatingKind(int)::: arch64 kind tool get floating kind:::switch->return->LIRKind->value->return->LIRKind->value->throw->GraalError->shouldNotReachHere
AArch64LIRKindTool#getObjectKind()::: arch64 kind tool get object kind:::return->LIRKind->reference
AArch64LIRKindTool#getWordKind()::: arch64 kind tool get word kind:::return->LIRKind->value
AArch64LIRKindTool#getNarrowOopKind()::: arch64 kind tool get narrow oop kind:::return->LIRKind->compressedReference
AArch64LIRKindTool#getNarrowPointerKind()::: arch64 kind tool get narrow pointer kind:::return->LIRKind->value
AArch64LoweringProviderMixin#smallestCompareWidth()::: arch64 lowering provider mixin smallest compare width:::return
AArch64LoweringProviderMixin#supportBulkZeroing()::: arch64 lowering provider mixin support bulk zeroing:::return
AArch64MoveFactory#createMove(AllocatableValue, Value)::: arch64 move factory create move:::srcIsSlot->isStackSlotValue->dstIsSlot->isStackSlotValue->if->isConstantValue->return->asConstant->createLoad->else->if->return->new->LoadAddressOp->else->if->throw->GraalError->src->getClass->dst->getClass->shouldNotReachHere->else->return->new->AArch64Move.Move
AArch64MoveFactory#createStackMove(AllocatableValue, AllocatableValue)::: arch64 move factory create stack move:::return->new->AArch64Move.Move
AArch64MoveFactory#createLoad(AllocatableValue, Constant)::: arch64 move factory create load:::if->javaConstant->if->canInlineConstant->return->new->AArch64Move.LoadInlineConstant->else->return->new->AArch64Move.LoadInlineConstant->else->if->return->new->AArch64Move.LoadDataOp->else->throw->GraalError->unimplemented
AArch64MoveFactory#createStackLoad(AllocatableValue, Constant)::: arch64 move factory create stack load:::return->createLoad
AArch64MoveFactory#canInlineConstant(Constant)::: arch64 move factory can inline constant:::if->c->switch->c->getJavaKind->return->AArch64MacroAssembler->c->asInt->isMovableImmediate->return->AArch64MacroAssembler->c->asLong->isMovableImmediate->return->c->isNull->return->return
AArch64MoveFactory#allowConstantToStackMove(Constant)::: arch64 move factory allow constant to stack move:::return
AArch64NodeLIRBuilder#peephole(ValueNode)::: arch64 node builder peephole:::return
AArch64NodeLIRBuilder#getLIRGeneratorTool()::: arch64 node builder get generator tool:::return->super->getLIRGeneratorTool
AArch64NodeLIRBuilder#emitPrologue(StructuredGraph)::: arch64 node builder emit prologue:::super->emitPrologue
AArch64NodeMatchRules#getState(Access)::: arch64 node match rules get state:::if->return->state->return
AArch64NodeMatchRules#getMemoryKind(Access)::: arch64 node match rules get memory kind:::return->gen->access->asNode->stamp->getLIRKind->getPlatformKind
AArch64NodeMatchRules#moveSp(AllocatableValue)::: arch64 node match rules move sp:::return->getLIRGeneratorTool->moveSp
AArch64NodeMatchRules#emitBitField(AArch64BitFieldOp.BitFieldOpCode, ValueNode, int, int)::: arch64 node match rules emit bit field:::return->a->operand->result->gen->LIRKind->combine->newVariable->src->gen->asAllocatable->moveSp->gen->new->AArch64BitFieldOp->append->return
AArch64NodeMatchRules#emitBinaryShift(AArch64ArithmeticOp, ValueNode, BinaryNode, boolean)::: arch64 node match rules emit binary shift:::shiftType->shiftTypeMap->shift->getClass->get->return->a->operand->b->shift->getX->operand->result->gen->LIRKind->combine->newVariable->x->gen->asAllocatable->moveSp->y->gen->asAllocatable->moveSp->shiftAmount->shift->getY->asJavaConstant->asInt->gen->new->AArch64ArithmeticOp.BinaryShiftOp->append->return
AArch64NodeMatchRules#emitBitTestAndBranch(FixedNode, FixedNode, ValueNode, double, int)::: arch64 node match rules emit bit test and branch:::return->trueDestination->getLIRBlock->falseDestination->getLIRBlock->src->gen->operand->asAllocatable->moveSp->gen->new->AArch64ControlFlow.BitTestAndBranchOp->append->return
AArch64NodeMatchRules#unsignedBitField(BinaryNode, ValueNode, ConstantNode, ConstantNode)::: arch64 node match rules unsigned bit field:::srcKind->a->getStackKind->op->bitFieldOpMap->shift->getClass->get->distance->b->asJavaConstant->asInt->mask->c->asJavaConstant->asLong->if->CodeUtil->isPowerOf2->return->width->CodeUtil->log2->srcBits->srcKind->getBitCount->if->return->if->return->return->emitBitField
AArch64NodeMatchRules#addSubShift(BinaryNode, ValueNode, BinaryNode)::: arch64 node match rules add sub shift:::op->nodeOpMap->binary->getClass->get->return->emitBinaryShift
AArch64NodeMatchRules#logicShift(BinaryNode, ValueNode, BinaryNode)::: arch64 node match rules logic shift:::op->nodeOpMap->binary->getClass->get->operand->binary->getX->binary->getY->binary->getX->isShiftNot->return->emitBinaryShift
AArch64NodeMatchRules#multiplyNegate(ValueNode, ValueNode)::: arch64 node match rules multiply negate:::if->a->getStackKind->isNumericInteger->b->getStackKind->isNumericInteger->return->getArithmeticLIRGenerator->operand->operand->emitMNeg->return
AArch64NodeMatchRules#multiplyAddSub(BinaryNode, ValueNode, ValueNode, ValueNode)::: arch64 node match rules multiply add sub:::kindA->a->getStackKind->kindB->b->getStackKind->kindC->c->getStackKind->if->kindA->isNumericInteger->kindB->isNumericInteger->kindC->isNumericInteger->return->if->return->getArithmeticLIRGenerator->operand->operand->operand->emitMAdd->return->getArithmeticLIRGenerator->operand->operand->operand->emitMSub
AArch64NodeMatchRules#testBitAndBranch(IfNode, ValueNode, ConstantNode):::((x & (1 << n)) == 0) -> tbz/tbnz n label.:::if->value->getStackKind->isNumericInteger->constant->a->asJavaConstant->asLong->if->Long->bitCount->return->root->trueSuccessor->root->falseSuccessor->root->getTrueSuccessorProbability->Long->numberOfTrailingZeros->emitBitTestAndBranch->return
AArch64NodeMatchRules#checkNegativeAndBranch(IfNode, IntegerLessThanNode, ValueNode, ConstantNode):::if x < 0 <=> tbz x, sizeOfBits(x) - 1, label.:::xKind->x->getStackKind->if->y->isJavaConstant->y->asJavaConstant->asLong->lessNode->condition->equals->return->root->falseSuccessor->root->trueSuccessor->root->getTrueSuccessorProbability->xKind->getBitCount->emitBitTestAndBranch->return
AArch64NodeMatchRules#getLIRGeneratorTool()::: arch64 node match rules get generator tool:::return
AArch64NodeMatchRules#getArithmeticLIRGenerator()::: arch64 node match rules get arithmetic generator:::return->getLIRGeneratorTool->getArithmetic
AArch64ReadNode#generate(NodeLIRBuilderTool)::: arch64 read node generate:::lirgen->gen->getLIRGeneratorTool->arithgen->lirgen->getArithmetic->readKind->lirgen->getLIRKind->getPlatformKind->resultBits->stamp->getBits->gen->arithgen->gen->getAddress->operand->gen->state->emitExtendMemory->setResult
AArch64ReadNode#replace(ReadNode):::replace a ReadNode with an AArch64-specific variant which knows how to merge a downstream zero or sign extend into the read operation.:::usage->readNode->usages->first->isSigned->accessStamp->readNode->getAccessStamp->address->readNode->getAddress->location->readNode->getLocationIdentity->stamp->usage->stamp->guard->readNode->getGuard->barrierType->readNode->getBarrierType->nullCheck->readNode->getNullCheck->stateBefore->readNode->stateBefore->clone->new->AArch64ReadNode->graph->readNode->graph->graph->add->usage->replaceAtUsagesAndDelete->graph->replaceFixedWithFixed
AArch64ReadReplacementPhase#run(StructuredGraph)::: arch64 read replacement phase run:::foreach->graph->getNodes->if->continue->if->readNode->if->readNode->hasExactlyOneUsage->usage->readNode->usages->first->if->AArch64ReadNode->replace
AArch64SuitesCreator#createSuites(OptionValues)::: arch64 suites creator create suites:::suites->super->createSuites->findPhase->foreach->suites->getLowTier->findPhase->if->while->PhaseSuite->findNextPhase->findPhase->previous->break->if->findPhase->new->AArch64ReadReplacementPhase->add->else->throw->GraalError->shouldNotReachHere->return
