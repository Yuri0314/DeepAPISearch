org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules_MatchStatementSet#forClass()->Class::: arch64 node match rules_ match statement set for class
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules_MatchStatementSet#statements()->List::: arch64 node match rules_ match statement set statements
org.graalvm.compiler.core.aarch64.AArch64AddressLoweringByUse#lower(ValueNode, Stamp, AddressNode)->AddressNode::: arch64 address lowering by use lower
org.graalvm.compiler.core.aarch64.AArch64AddressLoweringByUse#lower(AddressNode)->AddressNode::: arch64 address lowering by use lower
org.graalvm.compiler.core.aarch64.AArch64AddressLoweringByUse#improve(AArch64Kind, AArch64AddressNode)->boolean::: arch64 address lowering by use improve
org.graalvm.compiler.core.aarch64.AArch64AddressLoweringByUse#isBaseOnlyMode(AArch64Address.AddressingMode)->boolean::: arch64 address lowering by use is base only mode
org.graalvm.compiler.core.aarch64.AArch64AddressNode#generate(NodeLIRBuilderTool)->void::: arch64 address node generate
org.graalvm.compiler.core.aarch64.AArch64AddressNode#getBase()->ValueNode::: arch64 address node get base
org.graalvm.compiler.core.aarch64.AArch64AddressNode#setBase(ValueNode)->void::: arch64 address node set base
org.graalvm.compiler.core.aarch64.AArch64AddressNode#getIndex()->ValueNode::: arch64 address node get index
org.graalvm.compiler.core.aarch64.AArch64AddressNode#setIndex(ValueNode)->void::: arch64 address node set index
org.graalvm.compiler.core.aarch64.AArch64AddressNode#getDisplacement()->long::: arch64 address node get displacement
org.graalvm.compiler.core.aarch64.AArch64AddressNode#setDisplacement(long, int, AArch64Address.AddressingMode)->void::: arch64 address node set displacement
org.graalvm.compiler.core.aarch64.AArch64AddressNode#getMaxConstantDisplacement()->long::: arch64 address node get max constant displacement
org.graalvm.compiler.core.aarch64.AArch64AddressNode#getAddressingMode()->AddressingMode::: arch64 address node get addressing mode
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#getLIRGen()->AArch64LIRGenerator::: arch64 arithmetic generator get gen
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#mustReplaceNullWithNullRegister(JavaConstant)->boolean::: arch64 arithmetic generator must replace null with null register
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#getNullRegisterValue()->AllocatableValue::: arch64 arithmetic generator get null register value
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#isNumericInteger(PlatformKind)->boolean::: arch64 arithmetic generator is numeric integer
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitAdd(LIRKind, Value, Value, boolean)->Variable::: arch64 arithmetic generator emit add
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitSub(LIRKind, Value, Value, boolean)->Variable::: arch64 arithmetic generator emit sub
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitExtendMemory(boolean, AArch64Kind, int, AArch64AddressValue, LIRFrameState)->Value::: arch64 arithmetic generator emit extend memory
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMul(Value, Value, boolean)->Value::: arch64 arithmetic generator emit mul
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMulHigh(Value, Value)->Value::: arch64 arithmetic generator emit mul high
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitUMulHigh(Value, Value)->Value::: arch64 arithmetic generator emit mul high
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMNeg(Value, Value)->Value::: arch64 arithmetic generator emit neg
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitDiv(Value, Value, LIRFrameState)->Value::: arch64 arithmetic generator emit div
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitRem(Value, Value, LIRFrameState)->Value::: arch64 arithmetic generator emit rem
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitUDiv(Value, Value, LIRFrameState)->Value::: arch64 arithmetic generator emit div
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitURem(Value, Value, LIRFrameState)->Value::: arch64 arithmetic generator emit rem
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitAnd(Value, Value)->Value::: arch64 arithmetic generator emit and
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitOr(Value, Value)->Value::: arch64 arithmetic generator emit or
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitXor(Value, Value)->Value::: arch64 arithmetic generator emit xor
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitShl(Value, Value)->Value::: arch64 arithmetic generator emit shl
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitShr(Value, Value)->Value::: arch64 arithmetic generator emit shr
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitUShr(Value, Value)->Value::: arch64 arithmetic generator emit shr
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitFloatConvert(FloatConvert, Value)->Value::: arch64 arithmetic generator emit float convert
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMAdd(Value, Value, Value)->Value::: arch64 arithmetic generator emit add
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMSub(Value, Value, Value)->Value::: arch64 arithmetic generator emit sub
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitReinterpret(LIRKind, Value)->Value::: arch64 arithmetic generator emit reinterpret
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitNarrow(Value, int)->Value::: arch64 arithmetic generator emit narrow
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitZeroExtend(Value, int, int)->Value::: arch64 arithmetic generator emit zero extend
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitSignExtend(Value, int, int)->Value::: arch64 arithmetic generator emit sign extend
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitBinary(ValueKind, AArch64ArithmeticOp, boolean, Value, Value)->Variable::: arch64 arithmetic generator emit binary
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#isArithmeticConstant(JavaConstant)->boolean::: arch64 arithmetic generator is arithmetic constant
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitNegate(Value)->Value::: arch64 arithmetic generator emit negate
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitNot(Value)->Value::: arch64 arithmetic generator emit not
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMathAbs(Value)->Value::: arch64 arithmetic generator emit math abs
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitMathSqrt(Value)->Value::: arch64 arithmetic generator emit math sqrt
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitBitScanForward(Value)->Variable::: arch64 arithmetic generator emit bit scan forward
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitBitCount(Value)->Value::: arch64 arithmetic generator emit bit count
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitBitScanReverse(Value)->Value::: arch64 arithmetic generator emit bit scan reverse
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitCountLeadingZeros(Value)->Value::: arch64 arithmetic generator emit count leading zeros
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitCountTrailingZeros(Value)->Value::: arch64 arithmetic generator emit count trailing zeros
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitLoad(LIRKind, Value, LIRFrameState)->Variable::: arch64 arithmetic generator emit load
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitStore(ValueKind, Value, Value, LIRFrameState)->void::: arch64 arithmetic generator emit store
org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator#emitRound(Value, RoundingMode)->Value::: arch64 arithmetic generator emit round
org.graalvm.compiler.core.aarch64.AArch64FloatConvertOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 float convert op emit code
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#canStoreConstant(JavaConstant)->boolean:::Checks whether the supplied constant can be used without loading it into a register for store operations, i.e., on the right hand side of a memory access.
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#moveSp(AllocatableValue)->AllocatableValue:::If val denotes the stackpointer, move it to another location
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#toRegisterKind(K)->K:::AArch64 cannot use anything smaller than a word in any instruction other than load and store.
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitNullCheck(Value, LIRFrameState)->void::: arch64 generator emit null check
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitAddress(AllocatableValue)->Variable::: arch64 generator emit address
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#asAddressValue(Value)->AArch64AddressValue::: arch64 generator as address value
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitLogicCompareAndSwap(LIRKind, Value, Value, Value, Value, Value)->Variable::: arch64 generator emit logic compare and swap
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitValueCompareAndSwap(LIRKind, Value, Value, Value)->Variable::: arch64 generator emit value compare and swap
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitAtomicReadAndWrite(Value, ValueKind, Value)->Value::: arch64 generator emit atomic read and write
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitAtomicReadAndAdd(Value, ValueKind, Value)->Value::: arch64 generator emit atomic read and add
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitMembar(int)->void::: arch64 generator emit membar
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitJump(LabelRef)->void::: arch64 generator emit jump
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)->void::: arch64 generator emit overflow check branch
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double)->void:::Branches to label if (left & right) == 0
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value)->Variable:::Conditionally move trueValue into new variable if cond + unorderedIsTrue is true, else falseValue.
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)->void::: arch64 generator emit compare branch
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitCompare(PlatformKind, Value, Value, Condition, boolean)->boolean:::This method emits the compare instruction, and may reorder the operands
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#loadNonCompareConst(Value)->Value:::If value is a constant that cannot be used directly with a gpCompare instruction load it into a register and return the register, otherwise return constant value unchanged.
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#isCompareConstant(Value)->boolean:::Checks whether value can be used directly with a gpCompare instruction
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitIntegerTestMove(Value, Value, Value, Value)->Variable:::Moves trueValue into result if (left & right) == 0, else falseValue.
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)->void::: arch64 generator emit strategy switch
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#createStrategySwitchOp(SwitchStrategy, LabelRef[], LabelRef, Variable, AllocatableValue, Function)->StrategySwitchOp::: arch64 generator create strategy switch op
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitTableSwitch(int, LabelRef, LabelRef[], Value)->void::: arch64 generator emit table switch
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitByteSwap(Value)->Variable::: arch64 generator emit byte swap
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitArrayCompareTo(JavaKind, JavaKind, Value, Value, Value, Value)->Variable::: arch64 generator emit array compare to
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitArrayEquals(JavaKind, Value, Value, Value, int, boolean)->Variable::: arch64 generator emit array equals
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#zapValueForKind(PlatformKind)->JavaConstant::: arch64 generator zap value for kind
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#loadReg(Value)->AllocatableValue:::Loads value into virtual register
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitPause()->void::: arch64 generator emit pause
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitCCall(long, CallingConvention, Value[])->void::: arch64 generator emit call
org.graalvm.compiler.core.aarch64.AArch64LIRGenerator#emitSpeculationFence()->void::: arch64 generator emit speculation fence
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getIntegerKind(int)->LIRKind::: arch64 kind tool get integer kind
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getFloatingKind(int)->LIRKind::: arch64 kind tool get floating kind
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getObjectKind()->LIRKind::: arch64 kind tool get object kind
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getWordKind()->LIRKind::: arch64 kind tool get word kind
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getNarrowOopKind()->LIRKind::: arch64 kind tool get narrow oop kind
org.graalvm.compiler.core.aarch64.AArch64LIRKindTool#getNarrowPointerKind()->LIRKind::: arch64 kind tool get narrow pointer kind
org.graalvm.compiler.core.aarch64.AArch64LoweringProviderMixin#smallestCompareWidth()->Integer::: arch64 lowering provider mixin smallest compare width
org.graalvm.compiler.core.aarch64.AArch64LoweringProviderMixin#supportBulkZeroing()->boolean::: arch64 lowering provider mixin support bulk zeroing
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#createMove(AllocatableValue, Value)->LIRInstruction::: arch64 move factory create move
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#createStackMove(AllocatableValue, AllocatableValue)->LIRInstruction::: arch64 move factory create stack move
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#createLoad(AllocatableValue, Constant)->AArch64LIRInstruction::: arch64 move factory create load
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#createStackLoad(AllocatableValue, Constant)->LIRInstruction::: arch64 move factory create stack load
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#canInlineConstant(Constant)->boolean::: arch64 move factory can inline constant
org.graalvm.compiler.core.aarch64.AArch64MoveFactory#allowConstantToStackMove(Constant)->boolean::: arch64 move factory allow constant to stack move
org.graalvm.compiler.core.aarch64.AArch64NodeLIRBuilder#peephole(ValueNode)->boolean::: arch64 node builder peephole
org.graalvm.compiler.core.aarch64.AArch64NodeLIRBuilder#getLIRGeneratorTool()->AArch64LIRGenerator::: arch64 node builder get generator tool
org.graalvm.compiler.core.aarch64.AArch64NodeLIRBuilder#emitPrologue(StructuredGraph)->void::: arch64 node builder emit prologue
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#getState(Access)->LIRFrameState::: arch64 node match rules get state
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#getMemoryKind(Access)->AArch64Kind::: arch64 node match rules get memory kind
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#unsignedBitField(BinaryNode, ValueNode, ConstantNode, ConstantNode)->ComplexMatchResult::: arch64 node match rules unsigned bit field
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#addSubShift(BinaryNode, ValueNode, BinaryNode)->ComplexMatchResult::: arch64 node match rules add sub shift
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#logicShift(BinaryNode, ValueNode, BinaryNode)->ComplexMatchResult::: arch64 node match rules logic shift
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#multiplyNegate(ValueNode, ValueNode)->ComplexMatchResult::: arch64 node match rules multiply negate
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#multiplyAddSub(BinaryNode, ValueNode, ValueNode, ValueNode)->ComplexMatchResult::: arch64 node match rules multiply add sub
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#testBitAndBranch(IfNode, ValueNode, ConstantNode)->ComplexMatchResult:::((x & (1 << n)) == 0) -> tbz/tbnz n label.
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#checkNegativeAndBranch(IfNode, IntegerLessThanNode, ValueNode, ConstantNode)->ComplexMatchResult:::if x < 0 <=> tbz x, sizeOfBits(x) - 1, label.
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#getLIRGeneratorTool()->AArch64LIRGenerator::: arch64 node match rules get generator tool
org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules#getArithmeticLIRGenerator()->AArch64ArithmeticLIRGenerator::: arch64 node match rules get arithmetic generator
org.graalvm.compiler.core.aarch64.AArch64ReadNode#generate(NodeLIRBuilderTool)->void::: arch64 read node generate
org.graalvm.compiler.core.aarch64.AArch64ReadNode#replace(ReadNode)->void:::replace a ReadNode with an AArch64-specific variant which knows how to merge a downstream zero or sign extend into the read operation.
org.graalvm.compiler.core.aarch64.AArch64ReadReplacementPhase#run(StructuredGraph)->void::: arch64 read replacement phase run
org.graalvm.compiler.core.aarch64.AArch64SuitesCreator#createSuites(OptionValues)->Suites::: arch64 suites creator create suites
