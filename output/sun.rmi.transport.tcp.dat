TCPChannel#getEndpoint():::Return the endpoint for this channel.:::return
TCPChannel#checkConnectPermission():::Checks if the current caller has sufficient privilege to make a connection to the remote endpoint.:::security->System->getSecurityManager->if->return->if->new->WeakHashMap<AccessControlContext,Reference<AccessControlContext>>->ctx->AccessController->getContext->if->okContext->equals->authcache->containsKey->security->ep->getHost->ep->getPort->checkConnect->authcache->new->SoftReference<AccessControlContext>->put
TCPChannel#newConnection():::Supplies a connection to the endpoint of the address space for which this is a channel:::conn->do->synchronized->elementPos->freeList->size->if->checkConnectPermission->freeList->get->freeList->remove->if->if->conn->isDead->log->return->this->free->while->return->createConnection
TCPChannel#createConnection():::Create a new connection to the remote endpoint of this channel:::conn->log->sock->ep->newSocket->new->TCPConnection->try->out->conn->getOutputStream->new->DataOutputStream->writeTransportHeader->if->conn->isReusable->out->writeByte->else->out->writeByte->out->flush->originalSoTimeout->try->sock->getSoTimeout->sock->setSoTimeout->catch->finally->in->conn->getInputStream->new->DataInputStream->ack->in->readByte->if->throw->new->ConnectIOException->suggestedHost->in->readUTF->suggestedPort->in->readInt->if->isLoggable->log->TCPEndpoint->setLocalHost->localEp->TCPEndpoint->getLocalEndpoint->out->localEp->getHost->writeUTF->out->localEp->getPort->writeInt->if->isLoggable->localEp->getHost->localEp->getPort->log->try->sock->setSoTimeout->catch->finally->out->flush->catch->try->conn->close->catch->finally->if->throw->else->throw->new->ConnectIOException->finally->return
TCPChannel#free(Connection, boolean):::Free the connection generated by this channel.:::if->return->if->conn->isReusable->lastuse->System->currentTimeMillis->tcpConnection->log->synchronized->freeList->add->if->log->scheduler->new->Runnable->scheduleWithFixedDelay->tcpConnection->setLastUseTime->tcpConnection->setExpiration->else->log->try->conn->close->catch->finally
TCPChannel#writeTransportHeader(DataOutputStream):::Send transport header over stream.:::try->dataOut->new->DataOutputStream->dataOut->writeInt->dataOut->writeShort->catch->throw->new->ConnectIOException->finally
TCPChannel#shedCache():::Closes all the connections in the cache, whether timed out or not.:::conn->synchronized->freeList->freeList->size->new->ConnectionArr->toArray->freeList->clear->for->i
TCPChannel#freeCachedConnections()::: channel free cached connections:::synchronized->size->freeList->size->if->time->System->currentTimeMillis->iter->freeList->listIterator->while->iter->hasPrevious->conn->iter->previous->if->conn->expired->log->try->conn->close->catch->finally->iter->remove->if->freeList->isEmpty->reaper->cancel
ConnectionAcceptor#startNewAcceptor():::Start a new thread to accept connections.:::t->AccessController->new->NewThreadAction->doPrivileged->t->start
ConnectionAcceptor#accept(Connection):::Add connection to queue of connections to be accepted.:::synchronized->queue->add->queue->notify
ConnectionAcceptor#run():::Give transport next accepted connection, when available.:::conn->synchronized->while->queue->size->try->queue->wait->catch->finally->startNewAcceptor->queue->remove->transport->handleMessages
TCPConnection#getOutputStream():::Gets the output stream for this connection:::if->socket->getOutputStream->new->BufferedOutputStream->return
TCPConnection#releaseOutputStream():::Release the output stream for this connection.:::if->out->flush
TCPConnection#getInputStream():::Gets the input stream for this connection.:::if->socket->getInputStream->new->BufferedInputStream->return
TCPConnection#releaseInputStream():::Release the input stream for this connection.:::
TCPConnection#isReusable():::Determine if this connection can be used for multiple operations:::return
TCPConnection#setExpiration(long):::Set the expiration time of this connection.:::
TCPConnection#setLastUseTime(long):::Set the timestamp at which this connection was last used successfully:::
TCPConnection#expired(long):::Returns true if the timeout has expired on this connection; otherwise returns false.:::return
TCPConnection#isDead():::Probes the connection to see if it still alive and connected to a responsive server:::i->o->start->System->currentTimeMillis->if->return->try->getInputStream->getOutputStream->catch->return->finally->response->try->o->write->o->flush->i->read->catch->log->log->return->finally->if->System->currentTimeMillis->return->if->isLoggable->log->return
TCPConnection#close():::Close the connection.:::log->if->socket->close->else->in->close->out->close
TCPConnection#getChannel():::Returns the channel for this connection.:::return
TCPDirectSocketFactory#createSocket(String, int)::: direct socket factory create socket:::return->new->Socket
TCPDirectSocketFactory#createServerSocket(int)::: direct socket factory create server socket:::return->new->ServerSocket
TCPEndpoint#getInt(String, int)::: endpoint get int:::return->AccessController->Integer->getInteger->doPrivileged
TCPEndpoint#getBoolean(String)::: endpoint get boolean:::return->AccessController->Boolean->getBoolean->doPrivileged
TCPEndpoint#getHostnameProperty():::Returns the value of the java.rmi.server.hostname property.:::return->AccessController->System->getProperty->doPrivileged
TCPEndpoint#getLocalEndpoint(int):::Get an endpoint for the local address space on specified port:::return->getLocalEndpoint
TCPEndpoint#getLocalEndpoint(int, RMIClientSocketFactory, RMIServerSocketFactory)::: endpoint get local endpoint:::ep->synchronized->endpointKey->new->TCPEndpoint->epList->localEndpoints->get->localHost->resampleLocalHost->if->new->TCPEndpoint->new->LinkedList<TCPEndpoint>->epList->add->new->TCPTransport->localEndpoints->put->if->isLoggable->log->else->synchronized->epList->getLast->lastHost->lastPort->lastTransport->if->localHost->equals->if->epList->clear->new->TCPEndpoint->epList->add->return
TCPEndpoint#resampleLocalHost():::Resamples the local hostname and returns the possibly-updated local hostname.:::hostnameProperty->getHostnameProperty->synchronized->if->if->setLocalHost->else->if->hostnameProperty->equals->if->isLoggable->log->return
TCPEndpoint#setLocalHost(String):::Set the local host name, if currently unknown.:::synchronized->if->if->isLoggable->log->foreach->localEndpoints->values->synchronized->foreach
TCPEndpoint#setDefaultPort(int, RMIClientSocketFactory, RMIServerSocketFactory):::Set the port of the (shared) default endpoint object:::endpointKey->new->TCPEndpoint->synchronized->epList->localEndpoints->get->synchronized->size->epList->size->lastEp->epList->getLast->foreach->if->epList->clear->epList->add->newEndpointKey->new->TCPEndpoint->localEndpoints->put->if->isLoggable->log
TCPEndpoint#getOutboundTransport():::Returns transport for making connections to remote endpoints; (here, the default transport at port 0 is used).:::localEndpoint->getLocalEndpoint->return
TCPEndpoint#allKnownTransports():::Returns the current list of known transports:::s->synchronized->localEndpoints->size->new->HashSet<TCPTransport>->foreach->localEndpoints->values->ep->epList->getFirst->s->add->return
TCPEndpoint#shedConnectionCaches():::Release idle outbound connections to reduce demand on I/O resources:::foreach->allKnownTransports->transport->shedConnectionCaches
TCPEndpoint#exportObject(Target):::Export the object to accept incoming calls.:::transport->exportObject
TCPEndpoint#getChannel():::Returns a channel for this (remote) endpoint.:::return->getOutboundTransport->getChannel
TCPEndpoint#getHost():::Returns address for endpoint:::return
TCPEndpoint#getPort():::Returns the port for this endpoint:::return
TCPEndpoint#getListenPort():::Returns the port that this endpoint's inbound transport listens on, if this endpoint was created as a server endpoint (using getLocalEndpoint):::return
TCPEndpoint#getInboundTransport():::Returns the transport for incoming connections to this endpoint, if this endpoint was created as a server endpoint (using getLocalEndpoint).:::return
TCPEndpoint#getClientSocketFactory():::Get the client socket factory associated with this endpoint.:::return
TCPEndpoint#getServerSocketFactory():::Get the server socket factory associated with this endpoint.:::return
TCPEndpoint#toString():::Return string representation for endpoint.:::return
TCPEndpoint#hashCode()::: endpoint hash code:::return
TCPEndpoint#equals(Object)::: endpoint equals:::if->ep->if->host->equals->return->if->return->if->csf->getClass->getClass->csf->equals->return->if->ssf->getClass->getClass->ssf->equals->return->return->else->return
TCPEndpoint#write(ObjectOutput):::Write endpoint to output stream.:::if->out->writeByte->out->writeUTF->out->writeInt->else->out->writeByte->out->writeUTF->out->writeInt->out->writeObject
TCPEndpoint#read(ObjectInput):::Get the endpoint from the input stream.:::host->port->csf->format->in->readByte->switch->in->readUTF->in->readInt->break->in->readUTF->in->readInt->in->readObject->if->Proxy->csf->getClass->isProxyClass->throw->new->IOException->break->throw->new->IOException->return->new->TCPEndpoint
TCPEndpoint#writeHostPortFormat(DataOutput):::Write endpoint to output stream in older format used by UnicastRef for JDK1.1 compatibility.:::if->throw->new->InternalError->out->writeUTF->out->writeInt
TCPEndpoint#readHostPortFormat(DataInput):::Create a new endpoint from input stream data.:::host->in->readUTF->port->in->readInt->return->new->TCPEndpoint
TCPEndpoint#chooseFactory()::: endpoint choose factory:::sf->RMISocketFactory->getSocketFactory->if->return
TCPEndpoint#newSocket():::Open and return new client socket connection to endpoint.:::if->isLoggable->log->socket->try->clientFactory->if->chooseFactory->clientFactory->createSocket->catch->throw->new->java.rmi.UnknownHostException->throw->new->java.rmi.ConnectException->try->TCPEndpoint->shedConnectionCaches->catch->finally->throw->new->ConnectIOException->finally->try->socket->setTcpNoDelay->catch->finally->try->socket->setKeepAlive->catch->finally->return
TCPEndpoint#newServerSocket():::Return new server socket to listen for connections on this endpoint.:::if->isLoggable->log->serverFactory->if->chooseFactory->server->serverFactory->createServerSocket->if->server->getLocalPort->setDefaultPort->return
TCPEndpoint.FQDN#attemptFQDN(InetAddress):::Do our best to obtain a fully qualified hostname for the local host:::hostName->localAddr->getHostName->if->hostName->indexOf->hostAddress->localAddr->getHostAddress->f->new->FQDN->nameServiceTimeOut->TCPEndpoint->getInt->try->synchronized->f->getFQDN->f->wait->catch->Thread->currentThread->interrupt->finally->f->getHost->if->hostName->equals->hostName->indexOf->return
TCPEndpoint.FQDN#getFQDN():::Method that that will start a thread to wait to retrieve a fully qualified domain name from a name service:::t->AccessController->new->NewThreadAction->doPrivileged->t->start
TCPEndpoint.FQDN#getHost()::: n get host:::return
TCPEndpoint.FQDN#run():::thread to query a name service for the fqdn of this host.:::name->try->InetAddress->getByName->getHostName->catch->finally->synchronized->this->notify
TCPTransport#shedConnectionCaches():::Closes all cached connections in every channel subordinated to this transport:::channels->synchronized->channelTable->values->size->new->ArrayList<TCPChannel>->foreach->channelTable->values->ch->ref->get->if->channels->add->foreach->channel->shedCache
TCPTransport#getChannel(Endpoint):::Returns a Channel that generates connections to the endpoint ep:::ch->if->synchronized->ref->channelTable->get->if->ref->get->if->tcpEndpoint->new->TCPChannel->channelTable->new->WeakReference<TCPChannel>->put->return
TCPTransport#free(Endpoint):::Removes the Channel that generates connections to the endpoint ep.:::if->synchronized->ref->channelTable->remove->if->channel->ref->get->if->channel->shedCache
TCPTransport#exportObject(Target):::Export the object so that it can accept incoming calls.:::synchronized->listen->ok->try->super->exportObject->catch->finally->if->synchronized->decrementExportCount
TCPTransport#targetUnexported()::: transport target unexported:::decrementExportCount
TCPTransport#decrementExportCount():::Decrements the count of exported objects, closing the current server socket if the count reaches zero.:::if->getEndpoint->getListenPort->ss->try->ss->close->catch->finally
TCPTransport#checkAcceptPermission(AccessControlContext):::Verify that the current access control context has permission to accept the connection being dispatched by the current thread.:::sm->System->getSecurityManager->if->return->h->threadConnectionHandler->get->if->throw->new->Error->h->checkAcceptPermission
TCPTransport#getEndpoint()::: transport get endpoint:::synchronized->return->epList->getLast
TCPTransport#listen():::Listen on transport's endpoint.:::ep->getEndpoint->port->ep->getPort->if->if->tcpLog->isLoggable->tcpLog->log->try->ep->newServerSocket->t->AccessController->new->AcceptLoop->new->NewThreadAction->doPrivileged->t->start->catch->throw->new->ExportException->throw->new->ExportException->finally->else->sm->System->getSecurityManager->if->sm->checkListen
TCPTransport.AcceptLoop#run()::: accept loop run:::try->executeAcceptLoop->catch->finally->try->serverSocket->close->catch->finally
TCPTransport.AcceptLoop#executeAcceptLoop():::Accepts connections from the server socket and executes handlers for them in the thread pool.:::if->tcpLog->isLoggable->tcpLog->getEndpoint->getPort->log->while->socket->try->serverSocket->accept->clientAddr->socket->getInetAddress->clientHost->clientAddr->getHostAddress->try->connectionThreadPool->new->ConnectionHandler->execute->catch->closeSocket->tcpLog->log->finally->catch->try->if->serverSocket->isClosed->break->try->if->tcpLog->isLoggable->tcpLog->log->catch->finally->catch->finally->if->closeSocket->if->try->TCPEndpoint->shedConnectionCaches->catch->finally->if->if->continueAfterAcceptFailure->return->else->if->throw->else->throw->new->UndeclaredThrowableException->finally
TCPTransport.AcceptLoop#continueAfterAcceptFailure(Throwable):::Returns true if the accept loop should continue after the specified exception has been caught, or false if the accept loop should terminate (closing the server socket):::fh->RMISocketFactory->getFailureHandler->if->return->fh->new->InvocationTargetException->failure->else->throttleLoopOnException->return
TCPTransport.AcceptLoop#throttleLoopOnException():::Throttles the accept loop after an exception has been caught: if a burst of 10 exceptions in 5 seconds occurs, then wait for 10 seconds to curb busy CPU usage.:::now->System->currentTimeMillis->if->else->if->try->Thread->sleep->catch->finally
TCPTransport#closeSocket(Socket):::close socket and eat exception:::try->sock->close->catch->finally
TCPTransport#handleMessages(Connection, boolean):::handleMessages decodes transport operations and handles messages appropriately:::port->getEndpoint->getPort->try->in->conn->getInputStream->new->DataInputStream->do->op->in->read->if->if->tcpLog->isLoggable->tcpLog->log->break->if->tcpLog->isLoggable->tcpLog->log->switch->call->new->StreamRemoteCall->if->serviceCall->return->break->out->conn->getOutputStream->new->DataOutputStream->out->writeByte->conn->releaseOutputStream->break->DGCAckHandler->UID->read->received->break->throw->new->IOException->while->catch->if->tcpLog->isLoggable->tcpLog->log->finally->try->conn->close->catch->finally
TCPTransport#getClientHost():::Returns the client host for the current thread's connection:::h->threadConnectionHandler->get->if->return->h->getClientHost->else->throw->new->ServerNotActiveException
TCPTransport.ConnectionHandler#getClientHost()::: connection handler get client host:::return
TCPTransport.ConnectionHandler#checkAcceptPermission(SecurityManager, AccessControlContext):::Verify that the given AccessControlContext has permission to accept this connection.:::if->new->WeakHashMap<AccessControlContext,Reference<AccessControlContext>>->if->acc->equals->authCache->containsKey->return->addr->socket->getInetAddress->host->addr->getHostAddress->sm->socket->getPort->checkAccept->authCache->new->SoftReference<AccessControlContext>->put
TCPTransport.ConnectionHandler#run()::: connection handler run:::t->Thread->currentThread->name->t->getName->try->t->connectionCount->incrementAndGet->setName->AccessController->run0->return->doPrivileged->catch->finally->t->setName
TCPTransport.ConnectionHandler#run0()::: connection handler run0:::endpoint->getEndpoint->port->endpoint->getPort->threadConnectionHandler->set->try->socket->setTcpNoDelay->catch->finally->try->if->socket->setSoTimeout->catch->finally->try->sockIn->socket->getInputStream->bufIn->sockIn->markSupported->new->BufferedInputStream->in->new->DataInputStream->magic->in->readInt->version->in->readShort->if->closeSocket->return->sockOut->socket->getOutputStream->bufOut->new->BufferedOutputStream->out->new->DataOutputStream->remotePort->socket->getPort->if->tcpLog->isLoggable->tcpLog->log->ep->ch->conn->protocol->in->readByte->switch->socket->getLocalPort->endpoint->getClientSocketFactory->endpoint->getServerSocketFactory->new->TCPEndpoint->new->TCPChannel->new->TCPConnection->handleMessages->break->out->writeByte->if->tcpLog->isLoggable->tcpLog->log->out->writeUTF->out->writeInt->out->flush->clientHost->in->readUTF->clientPort->in->readInt->if->tcpLog->isLoggable->tcpLog->log->socket->getLocalPort->endpoint->getClientSocketFactory->endpoint->getServerSocketFactory->new->TCPEndpoint->new->TCPChannel->new->TCPConnection->handleMessages->break->if->tcpLog->isLoggable->tcpLog->log->out->writeByte->out->flush->break->catch->tcpLog->log->finally->closeSocket
