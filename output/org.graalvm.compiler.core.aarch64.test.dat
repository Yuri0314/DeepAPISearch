AArch64AddSubShiftTest#testAddShiftInt():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for add operation with int type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#testAddShiftLong():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for add operation with long type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#testSubShiftInt():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for sub operation with int type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#testSubShiftLong():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for sub operation with long type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64BitFieldTest#extractInt(int):::unsigned bit field extract int.:::return
AArch64BitFieldTest#invalidExtractInt(int):::unsigned bit field extract int (negative cases).:::result->return
AArch64BitFieldTest#extractLong(long):::unsigned bit field extract long.:::return
AArch64BitFieldTest#invalidExtractLong(long):::unsigned bit field extract long (negative cases).:::result->return
AArch64BitFieldTest#insertInt(int):::unsigned bit field insert int.:::return
AArch64BitFieldTest#invalidInsertInt(int):::unsigned bit field insert int (negative cases).:::result->return
AArch64BitFieldTest#insertLong(long):::unsigned bit field insert long.:::return
AArch64BitFieldTest#invalidInsertLong(long):::unsigned bit field insert long (negative cases).:::result->return
AArch64ConditionalSetTest#conditionalSetEQZero(int):::conditionalSet test for integer tests condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetEQ(int, int):::conditionalSet test for integer equals condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetLT(int, int):::conditionalSet test for integer less than condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetBT(int, int):::conditionalSet test for integer below condition.:::return->UnsignedMath->belowThan
AArch64ConditionalSetTest#conditionalSetFPEQ(float, float):::conditionalSet test for float point equals condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetFPLT(float, float):::conditionalSet test for float point less than condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetObjectEQ(Integer, Integer):::conditionalSet test for object equals condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetIsNull(Object):::conditionalSet test for null check condition.:::if->return->return
AArch64ConditionalSetTest#conditionalSetSwap(int, int):::conditionalSet test when trueValue and falseValue need to be exchanged.:::if->return->return
AArch64ConditionalSetTest#conditionalSetLong(int, int):::conditionalSet test for result with long type.:::if->return->return
AArch64LogicShiftTest#andShiftInt(int, int):::logicShift match rule test for instruction "and" with int type.:::value->return
AArch64LogicShiftTest#andShiftLong(long, long):::logicShift match rule test for instruction "and" with long type.:::value->return
AArch64LogicShiftTest#orrShiftInt(int, int):::logicShift match rule test for instruction "orr" with int type.:::value->return
AArch64LogicShiftTest#orrShiftLong(long, long):::logicShift match rule test for instruction "orr" with long type.:::value->return
AArch64LogicShiftTest#eorShiftInt(int, int):::logicShift match rule test for instruction "eor" with int type.:::value->return
AArch64LogicShiftTest#eorShiftLong(long, long):::logicShift match rule test for instruction "eor" with long type.:::value->return
AArch64LogicShiftTest#bicShiftInt(int, int):::logicShift match rule test for instruction "bic" with int type.:::value->return
AArch64LogicShiftTest#bicShiftLong(long, long):::logicShift match rule test for instruction "bic" with long type.:::value->return
AArch64LogicShiftTest#ornShiftInt(int, int):::logicShift match rule test for instruction "orn" with int type.:::value->return
AArch64LogicShiftTest#ornShiftLong(long, long):::logicShift match rule test for instruction "orn" with long type.:::value->return
AArch64LogicShiftTest#eonShiftInt(int, int):::logicShift match rule test for instruction "eon" with int type.:::value->return
AArch64LogicShiftTest#eonShiftLong(long, long):::logicShift match rule test for instruction "eon" with long type.:::value->return
AArch64MNegTest#multiplyNegateNoMatch(int, int):::check the case that mneg rule does not work at the reason of multi-use.:::return->mulNegInt->mulZeroSubInt->mulSubZeroInt
AArch64MultiplyAddSubTest#mulAddInt(int, int, int):::multiplyAddSub match rule test for add operation with int type.:::return
AArch64MultiplyAddSubTest#mulAddLong(long, long, long):::multiplyAddSub match rule test for add operation with long type.:::return
AArch64MultiplyAddSubTest#mulSubInt(int, int, int):::multiplyAddSub match rule test for sub operation with int type.:::return
AArch64MultiplyAddSubTest#mulSubLong(long, long, long):::multiplyAddSub match rule test for sub operation with long type.:::return
AArch64TestBitAndBranchTest#testBitTestAndBranchSingleSnippet(int):::Tests the graceful case, where the estimation for CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int) holds.:::res->if->fillOps->else->fillOps->return->GraalDirectives->opaque
AArch64TestBitAndBranchTest#testBitTestAndBranchFourSnippet(int):::Tests the case, where the estimation for CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int) does not hold and the code generation must be redone with large branches.:::res->if->fillOps->else->fillOps->return->GraalDirectives->opaque
