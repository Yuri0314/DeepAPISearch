AArch64AddSubShiftTest#addLeftShiftInt(int):::addSubShift match rule test for add operation with int type.:::output->return
AArch64AddSubShiftTest#addRightShiftInt(int)::: arch64 add sub shift test add right shift int:::output->return
AArch64AddSubShiftTest#addUnsignedRightShiftInt(int)::: arch64 add sub shift test add unsigned right shift int:::output->return
AArch64AddSubShiftTest#addShiftInt(int)::: arch64 add sub shift test add shift int:::return->addLeftShiftInt->addRightShiftInt->addUnsignedRightShiftInt
AArch64AddSubShiftTest#testAddShiftInt():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for add operation with int type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#addLeftShiftLong(long):::addSubShift match rule test for add operation with long type.:::output->return
AArch64AddSubShiftTest#addRightShiftLong(long)::: arch64 add sub shift test add right shift long:::output->return
AArch64AddSubShiftTest#addUnsignedRightShiftLong(long)::: arch64 add sub shift test add unsigned right shift long:::output->return
AArch64AddSubShiftTest#addShiftLong(long)::: arch64 add sub shift test add shift long:::return->addLeftShiftLong->addRightShiftLong->addUnsignedRightShiftLong
AArch64AddSubShiftTest#testAddShiftLong():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for add operation with long type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#subLeftShiftInt(int, int):::addSubShift match rule test for sub operation with int type.:::return
AArch64AddSubShiftTest#subRightShiftInt(int, int)::: arch64 add sub shift test sub right shift int:::return
AArch64AddSubShiftTest#subUnsignedRightShiftInt(int, int)::: arch64 add sub shift test sub unsigned right shift int:::return
AArch64AddSubShiftTest#subShiftInt(int, int)::: arch64 add sub shift test sub shift int:::return->subLeftShiftInt->subRightShiftInt->subUnsignedRightShiftInt
AArch64AddSubShiftTest#testSubShiftInt():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for sub operation with int type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64AddSubShiftTest#subLeftShiftLong(long, long):::addSubShift match rule test for sub operation with long type.:::return
AArch64AddSubShiftTest#subRightShiftLong(long, long)::: arch64 add sub shift test sub right shift long:::return
AArch64AddSubShiftTest#subUnsignedRightShiftLong(long, long)::: arch64 add sub shift test sub unsigned right shift long:::return
AArch64AddSubShiftTest#subShiftLong(long, long)::: arch64 add sub shift test sub shift long:::return->subLeftShiftLong->subRightShiftLong->subUnsignedRightShiftLong
AArch64AddSubShiftTest#testSubShiftLong():::Check whether the addSubShift match rule in AArch64NodeMatchRules does work for sub operation with long type and check if the expected LIR instructions show up.:::test->checkLIR
AArch64BitFieldTest#testAndCheckLIR(String, String, Object)::: arch64 bit field test test and check r:::test->checkLIR->test->checkLIR
AArch64BitFieldTest#extractInt(int):::unsigned bit field extract int.:::return
AArch64BitFieldTest#invalidExtractInt(int):::unsigned bit field extract int (negative cases).:::result->return
AArch64BitFieldTest#testExtractInt()::: arch64 bit field test test extract int:::testAndCheckLIR
AArch64BitFieldTest#extractLong(long):::unsigned bit field extract long.:::return
AArch64BitFieldTest#invalidExtractLong(long):::unsigned bit field extract long (negative cases).:::result->return
AArch64BitFieldTest#testExtractLong()::: arch64 bit field test test extract long:::testAndCheckLIR
AArch64BitFieldTest#insertInt(int):::unsigned bit field insert int.:::return
AArch64BitFieldTest#invalidInsertInt(int):::unsigned bit field insert int (negative cases).:::result->return
AArch64BitFieldTest#testInsertInt()::: arch64 bit field test test insert int:::testAndCheckLIR
AArch64BitFieldTest#insertLong(long):::unsigned bit field insert long.:::return
AArch64BitFieldTest#invalidInsertLong(long):::unsigned bit field insert long (negative cases).:::result->return
AArch64BitFieldTest#testInsertLong()::: arch64 bit field test test insert long:::testAndCheckLIR
AArch64CbzTest#equalsTo(int)::: arch64 cbz test equals to:::if->return->else->return
AArch64CbzTest#notEqualsTo(int)::: arch64 cbz test not equals to:::if->return->else->return
AArch64CbzTest#isNull(String)::: arch64 cbz test is null:::if->return->else->return
AArch64CbzTest#isNotNull(String)::: arch64 cbz test is not null:::if->return->else->return
AArch64CbzTest#objectEqualsNull(String, String)::: arch64 cbz test object equals null:::if->s1->equals->return->else->return
AArch64CbzTest#objectEquals(String, String)::: arch64 cbz test object equals:::if->s1->equals->return->else->return
AArch64CbzTest#testEqualsTo()::: arch64 cbz test test equals to:::test->test->checkLIR
AArch64CbzTest#testNotEqualsTo()::: arch64 cbz test test not equals to:::test->test->checkLIR
AArch64CbzTest#testIsNull()::: arch64 cbz test test is null:::new->ObjectArr->test->test->checkLIR
AArch64CbzTest#testIsNotNull()::: arch64 cbz test test is not null:::new->ObjectArr->test->test->checkLIR
AArch64CbzTest#testObjectEqualsNull()::: arch64 cbz test test object equals null:::test->test->checkLIR
AArch64CbzTest#testObjectEquals()::: arch64 cbz test test object equals:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetEQZero(int):::conditionalSet test for integer tests condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetEQZero()::: arch64 conditional set test test conditional set zero:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetEQ(int, int):::conditionalSet test for integer equals condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetEQ()::: arch64 conditional set test test conditional set q:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetLT(int, int):::conditionalSet test for integer less than condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetLT()::: arch64 conditional set test test conditional set t:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetBT(int, int):::conditionalSet test for integer below condition.:::return->UnsignedMath->belowThan
AArch64ConditionalSetTest#testConditionalSetBT()::: arch64 conditional set test test conditional set t:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetFPEQ(float, float):::conditionalSet test for float point equals condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetFPEQ()::: arch64 conditional set test test conditional set q:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetFPLT(float, float):::conditionalSet test for float point less than condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetFPLT()::: arch64 conditional set test test conditional set t:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetObjectEQ(Integer, Integer):::conditionalSet test for object equals condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetObjectEQ()::: arch64 conditional set test test conditional set object q:::Integer->valueOf->Integer->valueOf->test->Integer->valueOf->Integer->valueOf->test->checkLIR
AArch64ConditionalSetTest#conditionalSetIsNull(Object):::conditionalSet test for null check condition.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetIsNull()::: arch64 conditional set test test conditional set is null:::obj->test->Integer->valueOf->test->checkLIR
AArch64ConditionalSetTest#conditionalSetSwap(int, int):::conditionalSet test when trueValue and falseValue need to be exchanged.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetSwap()::: arch64 conditional set test test conditional set swap:::test->test->checkLIR
AArch64ConditionalSetTest#conditionalSetLong(int, int):::conditionalSet test for result with long type.:::if->return->return
AArch64ConditionalSetTest#testConditionalSetLong()::: arch64 conditional set test test conditional set long:::test->test->checkLIR
AArch64LogicShiftTest#andShiftInt(int, int):::logicShift match rule test for instruction "and" with int type.:::value->return
AArch64LogicShiftTest#testAndShiftInt()::: arch64 logic shift test test and shift int:::test->checkLIR
AArch64LogicShiftTest#andShiftLong(long, long):::logicShift match rule test for instruction "and" with long type.:::value->return
AArch64LogicShiftTest#testAndShiftLong()::: arch64 logic shift test test and shift long:::test->checkLIR
AArch64LogicShiftTest#orrShiftInt(int, int):::logicShift match rule test for instruction "orr" with int type.:::value->return
AArch64LogicShiftTest#testOrrShiftInt()::: arch64 logic shift test test orr shift int:::test->checkLIR
AArch64LogicShiftTest#orrShiftLong(long, long):::logicShift match rule test for instruction "orr" with long type.:::value->return
AArch64LogicShiftTest#testOrrShiftLong()::: arch64 logic shift test test orr shift long:::test->checkLIR
AArch64LogicShiftTest#eorShiftInt(int, int):::logicShift match rule test for instruction "eor" with int type.:::value->return
AArch64LogicShiftTest#testEorShiftInt()::: arch64 logic shift test test eor shift int:::test->checkLIR
AArch64LogicShiftTest#eorShiftLong(long, long):::logicShift match rule test for instruction "eor" with long type.:::value->return
AArch64LogicShiftTest#testEorShiftLong()::: arch64 logic shift test test eor shift long:::test->checkLIR
AArch64LogicShiftTest#bicShiftInt(int, int):::logicShift match rule test for instruction "bic" with int type.:::value->return
AArch64LogicShiftTest#testBicShiftInt()::: arch64 logic shift test test bic shift int:::test->checkLIR
AArch64LogicShiftTest#bicShiftLong(long, long):::logicShift match rule test for instruction "bic" with long type.:::value->return
AArch64LogicShiftTest#testBicShiftLong()::: arch64 logic shift test test bic shift long:::test->checkLIR
AArch64LogicShiftTest#ornShiftInt(int, int):::logicShift match rule test for instruction "orn" with int type.:::value->return
AArch64LogicShiftTest#testOrnShiftInt()::: arch64 logic shift test test orn shift int:::test->checkLIR
AArch64LogicShiftTest#ornShiftLong(long, long):::logicShift match rule test for instruction "orn" with long type.:::value->return
AArch64LogicShiftTest#testOrnShiftLong()::: arch64 logic shift test test orn shift long:::test->checkLIR
AArch64LogicShiftTest#eonShiftInt(int, int):::logicShift match rule test for instruction "eon" with int type.:::value->return
AArch64LogicShiftTest#testEonShiftInt()::: arch64 logic shift test test eon shift int:::test->checkLIR
AArch64LogicShiftTest#eonShiftLong(long, long):::logicShift match rule test for instruction "eon" with long type.:::value->return
AArch64LogicShiftTest#testEonShiftLong()::: arch64 logic shift test test eon shift long:::test->checkLIR
AArch64MatchRuleTest#checkAArch64()::: arch64 match rule test check arch64:::getTarget->assumeTrue
AArch64MembarOpTest#stub()::: arch64 membar op test stub:::
AArch64MembarOpTest#checkAArch64()::: arch64 membar op test check arch64:::JVMCI->getRuntime->getHostJVMCIBackend->getTarget->assumeTrue
AArch64MembarOpTest#runNormalMembarTests()::: arch64 membar op test run normal membar tests:::cases->new->ArrayList<>->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->cases->Pair->create->add->foreach->c->getLeft->new->MembarOpActual->providers->getTarget->new->AArch64MacroAssembler->emit->c->getRight->new->MembarOpExpected->providers->getTarget->new->AArch64MacroAssembler->emit->assertArrayEquals
AArch64MembarOpTest#runExceptionalTests()::: arch64 membar op test run exceptional tests:::new->MembarOpActual->providers->getTarget->new->AArch64MacroAssembler->emit
AArch64MembarOpTest.MembarOpActual#emit(AArch64MacroAssembler)::: membar op actual emit:::op->emitCode->return->masm->close
AArch64MembarOpTest.MembarOpExpected#emit(AArch64MacroAssembler)::: membar op expected emit:::masm->dmb->return->masm->close
AArch64MNegTest#testAndCheckLIR(String, int, Object...)::: arch64 neg test test and check r:::test->checkLIR
AArch64MNegTest#mulNegInt(int, int):::mneg rule test with int type.:::return
AArch64MNegTest#mulZeroSubInt(int, int)::: arch64 neg test mul zero sub int:::return
AArch64MNegTest#mulSubZeroInt(int, int)::: arch64 neg test mul sub zero int:::return
AArch64MNegTest#multiplyNegateInt(int, int)::: arch64 neg test multiply negate int:::return->mulNegInt->mulZeroSubInt->mulSubZeroInt
AArch64MNegTest#testMultiplyNegateInt()::: arch64 neg test test multiply negate int:::testAndCheckLIR
AArch64MNegTest#negMulInt(int, int)::: arch64 neg test neg mul int:::return
AArch64MNegTest#testNegateMultiplyInt()::: arch64 neg test test negate multiply int:::testAndCheckLIR
AArch64MNegTest#mulNegLong(long, long):::mneg rule test with long type.:::return
AArch64MNegTest#mulZeroSubLong(long, long)::: arch64 neg test mul zero sub long:::return
AArch64MNegTest#mulSubZeroLong(long, long)::: arch64 neg test mul sub zero long:::return
AArch64MNegTest#multiplyNegateLong(long, long)::: arch64 neg test multiply negate long:::return->mulNegLong->mulZeroSubLong->mulSubZeroLong
AArch64MNegTest#testMultiplyNegateLong()::: arch64 neg test test multiply negate long:::testAndCheckLIR
AArch64MNegTest#negMulLong(long, long)::: arch64 neg test neg mul long:::return
AArch64MNegTest#testNegateMultiplyLong()::: arch64 neg test test negate multiply long:::testAndCheckLIR
AArch64MNegTest#multiplyNegateNoMatch(int, int):::check the case that mneg rule does not work at the reason of multi-use.:::return->mulNegInt->mulZeroSubInt->mulSubZeroInt
AArch64MNegTest#testMultiplyNegateNoMatch()::: arch64 neg test test multiply negate no match:::testAndCheckLIR
AArch64MNegTest#mulNegFloat(float, float):::check the case that mneg rule does not work at the reason of data type.:::return
AArch64MNegTest#mulZeroSubFloat(float, float)::: arch64 neg test mul zero sub float:::return
AArch64MNegTest#mulSubZeroFloat(float, float)::: arch64 neg test mul sub zero float:::return
AArch64MNegTest#multiplyNegateFloat(float, float)::: arch64 neg test multiply negate float:::return->mulNegFloat->mulZeroSubFloat->mulSubZeroFloat
AArch64MNegTest#testMultiplyNegateFloat()::: arch64 neg test test multiply negate float:::testAndCheckLIR
AArch64MultiplyAddSubTest#mulAddInt(int, int, int):::multiplyAddSub match rule test for add operation with int type.:::return
AArch64MultiplyAddSubTest#testMultiplyAddInt()::: arch64 multiply add sub test test multiply add int:::test->test->test->checkLIR
AArch64MultiplyAddSubTest#mulAddLong(long, long, long):::multiplyAddSub match rule test for add operation with long type.:::return
AArch64MultiplyAddSubTest#testMultiplyAddLong()::: arch64 multiply add sub test test multiply add long:::test->test->test->checkLIR
AArch64MultiplyAddSubTest#mulSubInt(int, int, int):::multiplyAddSub match rule test for sub operation with int type.:::return
AArch64MultiplyAddSubTest#testMultiplySubInt()::: arch64 multiply add sub test test multiply sub int:::test->test->test->checkLIR
AArch64MultiplyAddSubTest#mulSubLong(long, long, long):::multiplyAddSub match rule test for sub operation with long type.:::return
AArch64MultiplyAddSubTest#testMultiplySubLong()::: arch64 multiply add sub test test multiply sub long:::test->test->test->checkLIR
AArch64TestBitAndBranchTest#checkAArch64()::: arch64 test bit and branch test check arch64:::getTarget->assumeTrue
AArch64TestBitAndBranchTest#testBit42Snippet(long, long, long)::: arch64 test bit and branch test test bit42 snippet:::if->return->else->return
AArch64TestBitAndBranchTest#testBit42()::: arch64 test bit and branch test test bit42:::test->test->checkLIR
AArch64TestBitAndBranchTest#testBitTestAndBranchSingleSnippet(int):::Tests the graceful case, where the estimation for CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int) holds.:::res->if->fillOps->else->fillOps->return->GraalDirectives->opaque
AArch64TestBitAndBranchTest#testBitTestAndBranchSingle()::: arch64 test bit and branch test test bit test and branch single:::runTest->checkLIR
AArch64TestBitAndBranchTest#testBitTestAndBranchFourSnippet(int):::Tests the case, where the estimation for CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int) does not hold and the code generation must be redone with large branches.:::res->if->fillOps->else->fillOps->return->GraalDirectives->opaque
AArch64TestBitAndBranchTest#testBitTestAndBranchFour()::: arch64 test bit and branch test test bit test and branch four:::runTest->checkLIR
AArch64TestBitAndBranchTest#testLessThanZeroSnippet(long, long)::: arch64 test bit and branch test test less than zero snippet:::if->return->else->return
AArch64TestBitAndBranchTest#testLessThanZero()::: arch64 test bit and branch test test less than zero:::test->test->test->checkLIR
AArch64TestBitAndBranchTest#testLessThanEqualZeroSnippet(long)::: arch64 test bit and branch test test less than equal zero snippet:::if->return->else->return
AArch64TestBitAndBranchTest#testLessThanEqualZero()::: arch64 test bit and branch test test less than equal zero:::test->test->test->checkLIR
AArch64TestBitAndBranchTest#testGreaterThanZeroSnippet(int)::: arch64 test bit and branch test test greater than zero snippet:::if->return->else->return
AArch64TestBitAndBranchTest#testGreaterThanZero()::: arch64 test bit and branch test test greater than zero:::test->test->test->checkLIR
AArch64TestBitAndBranchTest#testGreaterThanEqualZeroSnippet(int)::: arch64 test bit and branch test test greater than equal zero snippet:::if->return->else->return
AArch64TestBitAndBranchTest#testGreaterThanEqualZero()::: arch64 test bit and branch test test greater than equal zero:::test->test->test->checkLIR
AArch64TestBitAndBranchTest.LargeOpSpec#generate(LIRGeneratorTool, Value)::: large op spec generate:::for->i->setResult
AArch64TestBitAndBranchTest.NoOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)::: no op emit code:::for->i
AArch64TestBitAndBranchTest#fillOps(LargeOpSpec, int)::: arch64 test bit and branch test fill ops:::return
AArch64TestBitAndBranchTest#createLIRSuites(OptionValues)::: arch64 test bit and branch test create suites:::suites->super->createLIRSuites->suites->getPreAllocationOptimizationStage->new->CheckPhase->appendPhase->return
AArch64TestBitAndBranchTest.CheckPhase#run(TargetDescription, LIRGenerationResult, PreAllocationOptimizationContext)::: check phase run:::lirGenRes->getLIR
AArch64TestBitAndBranchTest#checkLIR(String, Predicate, int)::: arch64 test bit and branch test check r:::getResolvedJavaMethod->compile->actualOpNum->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->predicate->test->Assert->assertEquals
