BinaryArithmeticNode#reassociate(BinaryArithmeticNode, NodePredicate, ValueNode, ValueNode, NodeView):::Tries to re-associate values which satisfy the criterion:::match1->findReassociate->if->return->otherValue->match1->getOtherValue->addSub->subAdd->if->otherValue->getClass->node->getClass->if->else->if->else->return->other->match2->findReassociate->if->return->invertA->aSub->invertM1->invertM2->if->else->if->else->if->m1->match1->getValue->m2->match2->getValue->a->match2->getOtherValue->if->associated->if->BinaryArithmeticNode->sub->else->if->BinaryArithmeticNode->sub->else->BinaryArithmeticNode->add->if->return->BinaryArithmeticNode->sub->if->return->BinaryArithmeticNode->sub->return->BinaryArithmeticNode->add->else->if->return->BinaryArithmeticNode->AddNode->mul->mul->else->if->return->new->AndNode->new->AndNode->else->if->return->new->OrNode->new->OrNode->else->if->return->new->XorNode->new->XorNode->else->throw->GraalError->shouldNotReachHere
BinaryArithmeticNode#maybeCommuteInputs():::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results:::if->y->isConstant->x->isConstant->x->getId->y->getId->tmp->if->graph->duplicate->graph->findDuplicate->if->return->return
BinaryArithmeticNode#shouldSwapInputs(NodeValueMap):::Determines if it would be better to swap the inputs in order to produce better assembly code:::xHasOtherUsages->getX->hasUsagesOtherThan->yHasOtherUsages->getY->hasUsagesOtherThan->if->getY->isConstant->if->return->getY->getY->inputs->contains->else->return->return
BinaryNode#foldStamp(Stamp, Stamp):::Compute an improved for this node using the passed in stamps:::
CompareNode#condition():::Gets the condition (comparison operation) for this instruction.:::return
CompareNode#unorderedIsTrue():::Checks whether unordered inputs mean true or false (only applies to float operations).:::return
CompareNode#isIdentityComparison():::Does this operation represent an identity check such that for x == y, x is exactly the same thing as y:::return
ConvertNode#mayNullCheckSkipConversion():::Checks whether a null check may skip the conversion:::
ConvertNode#isLossless():::Check whether a conversion is lossless.:::
ConvertNode#preservesOrder(CanonicalCondition):::Check whether a conversion preserves comparison order.:::return->isLossless
ConvertNode#preservesOrder(CanonicalCondition, Constant, ConstantReflectionProvider):::Check whether a conversion preserves comparison order against a particular constant value.:::return->preservesOrder
IntegerLowerThanNode.LowerOp#canonicalizeRangeFlip(ValueNode, ValueNode, int, boolean, NodeView):::Exploit the fact that adding the (signed) MIN_VALUE on both side flips signed and unsigned comparison:::min->CodeUtil->minValue->xResidue->left->leftCst->if->xAdd->if->xAdd->getY->isJavaConstant->xAdd->getY->asJavaConstant->isDefaultForKind->xCst->xAdd->getY->asJavaConstant->asLong->xAdd->getX->else->if->forX->isJavaConstant->forX->asJavaConstant->if->return->yResidue->right->rightCst->if->yAdd->if->yAdd->getY->isJavaConstant->yAdd->getY->asJavaConstant->isDefaultForKind->yCst->yAdd->getY->asJavaConstant->asLong->yAdd->getX->else->if->forY->isJavaConstant->forY->asJavaConstant->if->return->if->if->ConstantNode->leftCst->asLong->forIntegerBits->else->if->AddNode->ConstantNode->forIntegerBits->create->if->ConstantNode->rightCst->asLong->forIntegerBits->else->if->AddNode->ConstantNode->forIntegerBits->create->if->return->new->IntegerBelowNode->else->return->new->IntegerLessThanNode->return
NarrowableArithmeticNode#isNarrowable(int):::Check whether this operation can be narrowed to resultBits bit without loss of precision.:::return
TernaryNode#foldStamp(Stamp, Stamp, Stamp):::Compute an improved stamp for this node using the passed in stamps:::
UnaryNode#foldStamp(Stamp):::Compute an improved for this node using the passed in stamp:::return->stamp
