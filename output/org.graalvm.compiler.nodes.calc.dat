AbsNode#create(ValueNode, NodeView)::: abs node create:::synonym->findSynonym->if->return->return->new->NegateNode
AbsNode#findSynonym(ValueNode, NodeView)::: abs node find synonym:::absOp->ArithmeticOpTable->forValue->stamp->forStamp->getAbs->synonym->UnaryArithmeticNode->findSynonym->if->return->return
AbsNode#canonical(CanonicalizerTool, ValueNode)::: abs node canonical:::ret->super->canonical->if->return->if->return->return
AbsNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: abs node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->emitMathAbs->setResult
AddNode#create(ValueNode, ValueNode, NodeView)::: add node create:::op->ArithmeticOpTable->x->stamp->forStamp->getAdd->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->if->x->isConstant->y->isConstant->return->canonical->else->return->canonical
AddNode#canonical(AddNode, BinaryOp, ValueNode, ValueNode, NodeView)::: add node canonical:::self->associative->op->isAssociative->if->if->sub->if->sub->getY->return->sub->getX->if->sub->if->sub->getY->return->sub->getX->if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->reassociated->ValueNode->isConstantPredicate->reassociate->if->return->if->integerConvertNode->valueNode->integerConvertNode->getValue->constant->asLong->if->addBeforeExtend->if->addBeforeExtend->getY->isConstant->beforeExtendStamp->addBeforeExtend->stamp->bits->beforeExtendStamp->getBits->if->CodeUtil->minValue->CodeUtil->maxValue->narrowConstantStamp->IntegerStamp->create->if->IntegerStamp->addCanOverflow->constantNode->ConstantNode->forIntegerStamp->if->return->SignExtendNode->AddNode->create->integerConvertNode->getResultBits->create->else->crossesZeroPoint->if->if->beforeExtendStamp->lowerBound->beforeExtendStamp->upperBound->else->if->beforeExtendStamp->lowerBound->beforeExtendStamp->upperBound->if->return->ZeroExtendNode->AddNode->create->integerConvertNode->getResultBits->create->if->return->BinaryArithmeticNode->getValue->sub->else->if->return->BinaryArithmeticNode->getValue->sub->if->new->AddNode->maybeCommuteInputs->return
AddNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: add node canonical:::ret->super->canonical->if->return->if->forX->isConstant->forY->isConstant->improvement->canonical->if->return->return->new->AddNode->op->getOp->view->NodeView->from->return->canonical
AddNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: add node generate:::op1->nodeValueMap->getX->operand->op2->nodeValueMap->getY->operand->if->shouldSwapInputs->tmp->nodeValueMap->gen->emitAdd->setResult
AndNode#create(ValueNode, ValueNode, NodeView)::: and node create:::op->ArithmeticOpTable->x->stamp->forStamp->getAnd->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
AndNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: and node canonical:::ret->super->canonical->if->return->view->NodeView->from->return->getOp->stamp->canonical
AndNode#canonical(AndNode, BinaryOp, Stamp, ValueNode, ValueNode, NodeView)::: and node canonical:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->if->forX->isConstant->forY->isConstant->return->new->AndNode->if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->getJavaKind->isNumericInteger->rawY->asLong->mask->CodeUtil->PrimitiveStamp->getBits->mask->if->return->ConstantNode->forIntegerStamp->if->ext->if->ext->getInputBits->return->ext->getValue->ext->getResultBits->new->ZeroExtendNode->xStamp->forX->stamp->if->xStamp->upMask->xStamp->downMask->return->return->new->AndNode->maybeCommuteInputs->ValueNode->isConstantPredicate->reassociate->if->return->OrNode->getValue->getValue->create->new->NotNode->return->new->AndNode->maybeCommuteInputs
AndNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: and node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitAnd->setResult
BinaryArithmeticNode#getOp(ValueNode, ValueNode)::: binary arithmetic node get op:::table->ArithmeticOpTable->forX->stamp->forStamp->return->getOp->apply
BinaryArithmeticNode#getArithmeticOp()::: binary arithmetic node get arithmetic op:::return->getX->getY->getOp
BinaryArithmeticNode#isAssociative()::: binary arithmetic node is associative:::return->getArithmeticOp->isAssociative
BinaryArithmeticNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: binary arithmetic node canonical:::view->NodeView->from->result->getOp->stamp->tryConstantFold->if->return->if->forY->isConstant->forX->hasExactlyOneUsage->conditionalNode->arithmeticOp->getArithmeticOp->trueConstant->conditionalNode->trueValue->this->stamp->tryConstantFold->if->falseConstant->conditionalNode->falseValue->this->stamp->tryConstantFold->if->return->ConditionalNode->create->return
BinaryArithmeticNode#tryConstantFold(BinaryOp, ValueNode, ValueNode, Stamp, NodeView)::: binary arithmetic node try constant fold:::if->forX->isConstant->forY->isConstant->ret->op->forX->asConstant->forY->asConstant->foldConstant->if->return->ConstantNode->forPrimitive->return
BinaryArithmeticNode#foldStamp(Stamp, Stamp)::: binary arithmetic node fold stamp:::return->getArithmeticOp->foldStamp
BinaryArithmeticNode#add(StructuredGraph, ValueNode, ValueNode, NodeView)::: binary arithmetic node add:::return->graph->AddNode->create->addOrUniqueWithInputs
BinaryArithmeticNode#add(ValueNode, ValueNode, NodeView)::: binary arithmetic node add:::return->AddNode->create
BinaryArithmeticNode#add(ValueNode, ValueNode)::: binary arithmetic node add:::return->add
BinaryArithmeticNode#mul(StructuredGraph, ValueNode, ValueNode, NodeView)::: binary arithmetic node mul:::return->graph->MulNode->create->addOrUniqueWithInputs
BinaryArithmeticNode#mul(ValueNode, ValueNode, NodeView)::: binary arithmetic node mul:::return->MulNode->create
BinaryArithmeticNode#mul(ValueNode, ValueNode)::: binary arithmetic node mul:::return->mul
BinaryArithmeticNode#sub(StructuredGraph, ValueNode, ValueNode, NodeView)::: binary arithmetic node sub:::return->graph->SubNode->create->addOrUniqueWithInputs
BinaryArithmeticNode#sub(ValueNode, ValueNode, NodeView)::: binary arithmetic node sub:::return->SubNode->create
BinaryArithmeticNode#sub(ValueNode, ValueNode)::: binary arithmetic node sub:::return->sub
BinaryArithmeticNode#branchlessMin(ValueNode, ValueNode, NodeView)::: binary arithmetic node branchless min:::if->v1->isDefaultConstant->v2->isDefaultConstant->return->branchlessMin->bits->v1->stamp->getBits->t1->sub->t2->RightShiftNode->create->t3->AndNode->create->return->add
BinaryArithmeticNode#branchlessMax(ValueNode, ValueNode, NodeView)::: binary arithmetic node branchless max:::if->v1->isDefaultConstant->v2->isDefaultConstant->return->branchlessMax->bits->v1->stamp->getBits->if->v2->isDefaultConstant->return->AndNode->NotNode->RightShiftNode->create->create->create->else->t1->sub->t2->RightShiftNode->create->t3->AndNode->create->return->sub
BinaryArithmeticNode#findReassociate(BinaryNode, NodePredicate)::: binary arithmetic node find reassociate:::resultX->criterion->binary->getX->apply->resultY->criterion->binary->getY->apply->if->return->if->return->return
BinaryArithmeticNode#reassociate(BinaryArithmeticNode, NodePredicate, ValueNode, ValueNode, NodeView):::Tries to re-associate values which satisfy the criterion:::match1->findReassociate->if->return->otherValue->match1->getOtherValue->addSub->subAdd->if->otherValue->getClass->node->getClass->if->else->if->else->return->other->match2->findReassociate->if->return->invertA->aSub->invertM1->invertM2->if->else->if->else->if->m1->match1->getValue->m2->match2->getValue->a->match2->getOtherValue->if->associated->if->BinaryArithmeticNode->sub->else->if->BinaryArithmeticNode->sub->else->BinaryArithmeticNode->add->if->return->BinaryArithmeticNode->sub->if->return->BinaryArithmeticNode->sub->return->BinaryArithmeticNode->add->else->if->return->BinaryArithmeticNode->AddNode->mul->mul->else->if->return->new->AndNode->new->AndNode->else->if->return->new->OrNode->new->OrNode->else->if->return->new->XorNode->new->XorNode->else->throw->GraalError->shouldNotReachHere
BinaryArithmeticNode#maybeCommuteInputs():::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results:::if->y->isConstant->x->isConstant->x->getId->y->getId->tmp->if->graph->duplicate->graph->findDuplicate->if->return->return
BinaryArithmeticNode#shouldSwapInputs(NodeValueMap):::Determines if it would be better to swap the inputs in order to produce better assembly code:::xHasOtherUsages->getX->hasUsagesOtherThan->yHasOtherUsages->getY->hasUsagesOtherThan->if->getY->isConstant->if->return->getY->getY->inputs->contains->else->return->return
BinaryNode#getX()::: binary node get x:::return
BinaryNode#getY()::: binary node get y:::return
BinaryNode#setX(ValueNode)::: binary node set x:::updateUsages
BinaryNode#setY(ValueNode)::: binary node set y:::updateUsages
BinaryNode#inferStamp()::: binary node infer stamp:::return->getX->stamp->getY->stamp->foldStamp->updateStamp
BinaryNode#foldStamp(Stamp, Stamp):::Compute an improved for this node using the passed in stamps:::
CompareNode#condition():::Gets the condition (comparison operation) for this instruction.:::return
CompareNode#unorderedIsTrue():::Checks whether unordered inputs mean true or false (only applies to float operations).:::return
CompareNode#tryConstantFold(CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, boolean)::: compare node try constant fold:::if->forX->isConstant->forY->isConstant->forX->asConstant->return->LogicConstantNode->condition->forX->asConstant->forY->asConstant->foldCondition->forBoolean->return
CompareNode#tryConstantFoldPrimitive(CanonicalCondition, ValueNode, ValueNode, boolean, NodeView)::: compare node try constant fold primitive:::if->forX->asConstant->forY->asConstant->return->LogicConstantNode->condition->forX->asConstant->forY->asConstant->foldCondition->forBoolean->return
CompareNode#isIdentityComparison():::Does this operation represent an identity check such that for x == y, x is exactly the same thing as y:::return
CompareNode.CompareOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: compare op canonical:::constantCondition->tryConstantFold->if->return->result->if->forX->isConstant->if->forX->asConstant->canonicalizeSymmetricConstant->return->else->if->forY->isConstant->if->forY->asConstant->canonicalizeSymmetricConstant->return->else->if->convertX->convertY->if->convertX->preservesOrder->convertY->preservesOrder->convertX->getValue->stamp->convertY->getValue->stamp->isCompatible->supported->if->convertX->getValue->stamp->intStamp->convertX->getValue->stamp->isConversionCompatible->convertX->getClass->convertY->getClass->intStamp->getBits->if->xValue->convertX->getValue->yValue->convertY->getValue->if->introducedUsages->eliminatedNodes->if->convertX->asNode->hasExactlyOneUsage->else->if->xValue->hasExactlyOneUsage->if->convertY->asNode->hasExactlyOneUsage->else->if->yValue->hasExactlyOneUsage->if->return->return->convertX->getValue->convertY->getValue->duplicateModified->return
CompareNode.CompareOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)::: compare op canonicalize symmetric constant:::if->realCondition->condition->asCondition->if->realCondition->mirror->return->optimizeConditional->else->if->return->optimizeNormalizeCompare->else->if->convert->multiUsage->convert->asNode->hasMoreThanOneUsage->convert->getValue->hasExactlyOneUsage->if->return->supported->if->convert->getValue->stamp->intStamp->convert->getValue->stamp->intStamp->getBits->if->newConstant->canonicalConvertConstant->if->if->return->convert->getValue->duplicateModified->else->return->convert->getValue->duplicateModified->return
CompareNode.CompareOp#canonicalConvertConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, CanonicalCondition, ConvertNode, Constant, NodeView)::: compare op canonical convert constant:::if->convert->preservesOrder->reverseConverted->convert->reverse->if->convert->convert->equals->if->GeneratePIC->getValue->return->return->ConstantNode->convert->getValue->stamp->forConstant->return
CompareNode.CompareOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)::: compare op optimize normalize compare:::throw->new->PermanentBailoutException
CompareNode.CompareOp#optimizeConditional(Constant, ConditionalNode, ConstantReflectionProvider, Condition, boolean)::: compare op optimize conditional:::trueConstant->conditionalNode->trueValue->asConstant->falseConstant->conditionalNode->falseValue->asConstant->if->trueResult->cond->foldCondition->falseResult->cond->foldCondition->if->return->LogicConstantNode->forBoolean->else->if->return->conditionalNode->condition->else->return->LogicNegationNode->conditionalNode->condition->create->return
CompareNode.CompareOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: compare op duplicate modified:::
CompareNode#createCompareNode(StructuredGraph, CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, NodeView)::: compare node create compare node:::result->createCompareNode->return->result->graph->graph->addOrUniqueWithInputs
CompareNode#createCompareNode(CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, NodeView)::: compare node create compare node:::comparison->if->if->x->stamp->ObjectEqualsNode->create->else->if->x->stamp->PointerEqualsNode->create->else->IntegerEqualsNode->create->else->if->IntegerLessThanNode->create->else->IntegerBelowNode->create->return
CompareNode#createCompareNode(StructuredGraph, ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, ValueNode, ValueNode, NodeView)::: compare node create compare node:::result->createCompareNode->return->result->graph->graph->addOrUniqueWithInputs
CompareNode#createCompareNode(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, ValueNode, ValueNode, NodeView)::: compare node create compare node:::comparison->if->if->x->stamp->ObjectEqualsNode->create->else->if->x->stamp->PointerEqualsNode->create->else->IntegerEqualsNode->create->else->if->IntegerLessThanNode->create->else->IntegerBelowNode->create->return
ConditionalNode#condition()::: conditional node condition:::return
ConditionalNode#create(LogicNode, NodeView)::: conditional node create:::return->ConstantNode->condition->graph->forInt->ConstantNode->condition->graph->forInt->create
ConditionalNode#create(LogicNode, ValueNode, ValueNode, NodeView)::: conditional node create:::synonym->findSynonym->if->return->result->trueValue->stamp->falseValue->stamp->meet->canonicalizeConditional->if->return->return->new->ConditionalNode
ConditionalNode#inferStamp()::: conditional node infer stamp:::valueStamp->trueValue->stamp->falseValue->stamp->meet->if->lessThan->if->lessThan->getX->lessThan->getY->constant->lessThan->getX->asJavaConstant->if->lessThan->getY->asJavaConstant->if->bounds->StampFactory->constant->getJavaKind->constant->getJavaKind->getMinValue->constant->asLong->forInteger->valueStamp->join->else->if->lessThan->getX->lessThan->getY->constant->lessThan->getX->asJavaConstant->if->lessThan->getY->asJavaConstant->if->bounds->StampFactory->constant->getJavaKind->constant->asLong->constant->getJavaKind->getMaxValue->forInteger->valueStamp->join->return->updateStamp
ConditionalNode#trueValue()::: conditional node true value:::return
ConditionalNode#falseValue()::: conditional node false value:::return
ConditionalNode#canonical(CanonicalizerTool)::: conditional node canonical:::view->NodeView->from->synonym->trueValue->falseValue->findSynonym->if->return->result->trueValue->falseValue->canonicalizeConditional->if->return->return
ConditionalNode#canonicalizeConditional(LogicNode, ValueNode, ValueNode, Stamp, NodeView)::: conditional node canonicalize conditional:::if->return->if->isIdentityComparison->compare->if->compare->getX->compare->getY->compare->getX->compare->getY->return->if->trueValue->stamp->if->lessThan->falseValueStamp->falseValue->stamp->trueValueStamp->trueValue->stamp->if->lessThan->getX->lessThan->getY->if->trueValueStamp->upperBound->falseValueStamp->lowerBound->return->else->if->lessThan->getX->lessThan->getY->if->falseValueStamp->upperBound->trueValueStamp->lowerBound->return->if->trueValue->isConstant->falseValue->isConstant->constTrueValue->trueValue->asJavaConstant->asLong->constFalseValue->falseValue->asJavaConstant->asLong->if->equals->if->equals->getY->isConstant->equals->getX->stamp->equalsXStamp->equals->getX->stamp->if->equalsXStamp->upMask->equalsY->equals->getY->asJavaConstant->asLong->if->if->return->IntegerConvertNode->equals->getX->convertUnsigned->else->if->return->IntegerConvertNode->XorNode->equals->getX->ConstantNode->equals->getX->stamp->forIntegerStamp->create->convertUnsigned->else->if->if->return->IntegerConvertNode->equals->getX->convertUnsigned->else->if->return->IntegerConvertNode->XorNode->equals->getX->ConstantNode->equals->getX->stamp->forIntegerStamp->create->convertUnsigned->else->if->integerTestNode->if->integerTestNode->getY->isConstant->testY->integerTestNode->getY->asJavaConstant->asLong->if->return->IntegerConvertNode->AndNode->integerTestNode->getX->integerTestNode->getY->create->convertUnsigned->if->lt->if->lt->getY->isDefaultConstant->if->lt->getX->if->add->if->add->getX->bits->trueValue->stamp->getBits->shift->lt->getX->ConstantNode->forIntegerBits->new->RightShiftNode->and->add->getY->new->AndNode->return->add->getX->new->AddNode->return
ConditionalNode#findSynonym(ValueNode, ValueNode, ValueNode, NodeView)::: conditional node find synonym:::if->negated->return->ConditionalNode->negated->getValue->create->if->c->if->c->getValue->return->else->return->return
ConditionalNode#generate(NodeLIRBuilderTool)::: conditional node generate:::generator->emitConditional
ConvertNode#getValue()::: convert node get value:::
ConvertNode#convert(Constant, ConstantReflectionProvider)::: convert node convert:::
ConvertNode#reverse(Constant, ConstantReflectionProvider)::: convert node reverse:::
ConvertNode#mayNullCheckSkipConversion():::Checks whether a null check may skip the conversion:::
ConvertNode#isLossless():::Check whether a conversion is lossless.:::
ConvertNode#preservesOrder(CanonicalCondition):::Check whether a conversion preserves comparison order.:::return->isLossless
ConvertNode#preservesOrder(CanonicalCondition, Constant, ConstantReflectionProvider):::Check whether a conversion preserves comparison order against a particular constant value.:::return->preservesOrder
FixedBinaryNode#getX()::: fixed binary node get x:::return
FixedBinaryNode#getY()::: fixed binary node get y:::return
FloatConvertNode#create(FloatConvert, ValueNode, NodeView)::: float convert node create:::synonym->ArithmeticOpTable->input->stamp->forStamp->getFloatConvert->findSynonym->if->return->return->new->FloatConvertNode
FloatConvertNode#getFloatConvert()::: float convert node get float convert:::return
FloatConvertNode#convert(Constant, ConstantReflectionProvider)::: float convert node convert:::return->getArithmeticOp->foldConstant
FloatConvertNode#reverse(Constant, ConstantReflectionProvider)::: float convert node reverse:::reverse->ArithmeticOpTable->stamp->forStamp->op->reverse->getFloatConvert->return->reverse->foldConstant
FloatConvertNode#isLossless()::: float convert node is lossless:::switch->getFloatConvert->return->return
FloatConvertNode#canonical(CanonicalizerTool, ValueNode)::: float convert node canonical:::ret->super->canonical->if->return->if->other->if->other->isLossless->reverse->return->other->getValue->return
FloatConvertNode#lower(LoweringTool)::: float convert node lower:::tool->getLowerer->lower
FloatConvertNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: float convert node generate:::nodeValueMap->gen->getFloatConvert->nodeValueMap->getValue->operand->emitFloatConvert->setResult
FloatConvertNode#mayNullCheckSkipConversion()::: float convert node may null check skip conversion:::return
FloatDivNode#create(ValueNode, ValueNode, NodeView)::: float div node create:::op->ArithmeticOpTable->x->stamp->forStamp->getDiv->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
FloatDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: float div node canonical:::ret->super->canonical->if->return->return->getOp->canonical
FloatDivNode#canonical(FloatDivNode, BinaryOp, ValueNode, ValueNode)::: float div node canonical:::if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->return->new->FloatDivNode
FloatDivNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: float div node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitDiv->setResult
FloatEqualsNode#create(ValueNode, ValueNode, NodeView)::: float equals node create:::result->CompareNode->tryConstantFoldPrimitive->if->return->else->return->new->FloatEqualsNode->maybeCommuteInputs
FloatEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)::: float equals node create:::value->OP->canonical->if->return->return->create
FloatEqualsNode#isIdentityComparison()::: float equals node is identity comparison:::xStamp->x->stamp->yStamp->y->stamp->return->xStamp->contains->yStamp->contains
FloatEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: float equals node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->canonical->if->return->return
FloatEqualsNode.FloatEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: float equals op canonical:::result->super->canonical->if->return->xStampGeneric->forX->stamp->yStampGeneric->forY->stamp->if->xStamp->yStamp->if->GraphUtil->unproxify->GraphUtil->unproxify->xStamp->isNonNaN->yStamp->isNonNaN->return->LogicConstantNode->tautology->else->if->xStamp->alwaysDistinct->return->LogicConstantNode->contradiction->return
FloatEqualsNode.FloatEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: float equals op duplicate modified:::if->newX->stamp->newY->stamp->return->new->FloatEqualsNode->else->if->newX->stamp->newY->stamp->return->new->IntegerEqualsNode->throw->GraalError->shouldNotReachHere
FloatEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: float equals node get succeeding stamp for x:::if->return->xStamp->join->return
FloatEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: float equals node get succeeding stamp for y:::if->return->xStamp->join->return
FloatEqualsNode#tryFold(Stamp, Stamp)::: float equals node try fold:::if->xStamp->yStamp->if->xStamp->alwaysDistinct->return->else->if->xStamp->neverDistinct->return->return
FloatingNode#asNode()::: floating node as node:::return
FloatLessThanNode#create(ValueNode, ValueNode, boolean, NodeView)::: float less than node create:::result->CompareNode->tryConstantFoldPrimitive->if->return->return->new->FloatLessThanNode
FloatLessThanNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, boolean, NodeView)::: float less than node create:::result->OP->canonical->if->return->return->create
FloatLessThanNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: float less than node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->canonical->if->return->return
FloatLessThanNode.FloatLessThanOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: float less than op canonical:::result->super->canonical->if->return->if->GraphUtil->unproxify->GraphUtil->unproxify->return->LogicConstantNode->contradiction->return
FloatLessThanNode.FloatLessThanOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: float less than op duplicate modified:::if->newX->stamp->newY->stamp->return->new->FloatLessThanNode->else->if->newX->stamp->newY->stamp->return->new->IntegerLessThanNode->throw->GraalError->shouldNotReachHere
FloatLessThanNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: float less than node get succeeding stamp for x:::return
FloatLessThanNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: float less than node get succeeding stamp for y:::return
FloatLessThanNode#tryFold(Stamp, Stamp)::: float less than node try fold:::return
IntegerBelowNode#create(ValueNode, ValueNode, NodeView)::: integer below node create:::return->OP->create
IntegerBelowNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)::: integer below node create:::value->OP->OP->getCondition->canonical->if->return->return->create
IntegerBelowNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: integer below node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->OP->getCondition->canonical->if->return->return
IntegerBelowNode.BelowOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: below op duplicate modified:::return->new->IntegerBelowNode
IntegerBelowNode.BelowOp#findSynonym(ValueNode, ValueNode, NodeView)::: below op find synonym:::result->super->findSynonym->if->return->if->forX->stamp->bits->forX->stamp->getBits->logic->canonicalizeRangeFlip->if->return->return
IntegerBelowNode.BelowOp#upperBound(IntegerStamp)::: below op upper bound:::return->stamp->unsignedUpperBound
IntegerBelowNode.BelowOp#lowerBound(IntegerStamp)::: below op lower bound:::return->stamp->unsignedLowerBound
IntegerBelowNode.BelowOp#compare(long, long)::: below op compare:::return->Long->compareUnsigned
IntegerBelowNode.BelowOp#min(long, long)::: below op min:::return->NumUtil->minUnsigned
IntegerBelowNode.BelowOp#max(long, long)::: below op max:::return->NumUtil->maxUnsigned
IntegerBelowNode.BelowOp#cast(long, int)::: below op cast:::return->CodeUtil->zeroExtend
IntegerBelowNode.BelowOp#minValue(int)::: below op min value:::return
IntegerBelowNode.BelowOp#maxValue(int)::: below op max value:::return->NumUtil->maxValueUnsigned
IntegerBelowNode.BelowOp#forInteger(int, long, long)::: below op for integer:::return->StampFactory->forUnsignedInteger
IntegerBelowNode.BelowOp#getCondition()::: below op get condition:::return
IntegerBelowNode.BelowOp#createNode(ValueNode, ValueNode)::: below op create node:::return->new->IntegerBelowNode
IntegerBelowNode#implies(boolean, LogicNode)::: integer below node implies:::if->result->getValue->implies->if->result->isKnown->return->TriState->result->toBoolean->get->if->if->integerLessThanNode->stampL->this->getY->stamp->if->stampL->isPositive->if->this->getX->integerLessThanNode->getX->if->this->getY->integerLessThanNode->getY->return->if->integerLessThanNode->getY->isConstant->getAdd->integerLessThanNode->getY->asConstant->isNeutral->return->return->super->implies
IntegerConvertNode#getInputBits()::: integer convert node get input bits:::return
IntegerConvertNode#getResultBits()::: integer convert node get result bits:::return
IntegerConvertNode#getOp(ValueNode)::: integer convert node get op:::return->getOp->ArithmeticOpTable->forValue->stamp->forStamp->apply
IntegerConvertNode#getArithmeticOp()::: integer convert node get arithmetic op:::return->getValue->getOp
IntegerConvertNode#convert(Constant, ConstantReflectionProvider)::: integer convert node convert:::return->getArithmeticOp->getInputBits->getResultBits->foldConstant
IntegerConvertNode#reverse(Constant, ConstantReflectionProvider)::: integer convert node reverse:::reverse->getReverseOp->ArithmeticOpTable->stamp->forStamp->apply->return->reverse->getResultBits->getInputBits->foldConstant
IntegerConvertNode#foldStamp(Stamp)::: integer convert node fold stamp:::return->getArithmeticOp->foldStamp
IntegerConvertNode#canonical(CanonicalizerTool, ValueNode)::: integer convert node canonical:::synonym->getOp->stamp->findSynonym->if->return->return
IntegerConvertNode#findSynonym(IntegerConvertOp, ValueNode, int, int, Stamp)::: integer convert node find synonym:::if->return->else->if->value->isConstant->return->ConstantNode->operation->value->asConstant->foldConstant->forPrimitive->return
IntegerConvertNode#convert(ValueNode, Stamp, NodeView)::: integer convert node convert:::return->convert
IntegerConvertNode#convert(ValueNode, Stamp, StructuredGraph, NodeView)::: integer convert node convert:::convert->convert->if->convert->isAlive->graph->addOrUniqueWithInputs->return
IntegerConvertNode#convertUnsigned(ValueNode, Stamp, NodeView)::: integer convert node convert unsigned:::return->convert
IntegerConvertNode#convertUnsigned(ValueNode, Stamp, StructuredGraph, NodeView)::: integer convert node convert unsigned:::convert->convert->if->convert->isAlive->graph->addOrUniqueWithInputs->return
IntegerConvertNode#convert(ValueNode, Stamp, boolean, NodeView)::: integer convert node convert:::fromStamp->input->stamp->toStamp->result->if->toStamp->getBits->fromStamp->getBits->else->if->toStamp->getBits->fromStamp->getBits->fromStamp->getBits->toStamp->getBits->new->NarrowNode->else->if->ZeroExtendNode->toStamp->getBits->create->else->SignExtendNode->toStamp->getBits->create->resultStamp->result->stamp->return
IntegerConvertNode#invertStamp(Stamp)::: integer convert node invert stamp:::return->getArithmeticOp->invertStamp
IntegerDivRemNode#getZeroCheck()::: integer div rem node get zero check:::return
IntegerDivRemNode#getOp()::: integer div rem node get op:::return
IntegerDivRemNode#getType()::: integer div rem node get type:::return
IntegerDivRemNode#lower(LoweringTool)::: integer div rem node lower:::tool->getLowerer->lower
IntegerDivRemNode#canDeoptimize()::: integer div rem node can deoptimize:::return
IntegerEqualsNode#create(ValueNode, ValueNode, NodeView)::: integer equals node create:::result->CompareNode->tryConstantFoldPrimitive->if->return->if->conditionalNode->if->conditionalNode->trueValue->return->conditionalNode->condition->if->conditionalNode->falseValue->return->LogicNegationNode->conditionalNode->condition->create->else->if->conditionalNode->if->conditionalNode->trueValue->return->conditionalNode->condition->if->conditionalNode->falseValue->return->LogicNegationNode->conditionalNode->condition->create->return->new->IntegerEqualsNode->maybeCommuteInputs
IntegerEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)::: integer equals node create:::value->OP->canonical->if->return->return->create
IntegerEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: integer equals node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->canonical->if->return->return
IntegerEqualsNode.IntegerEqualsOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)::: integer equals op optimize normalize compare:::primitive->a->normalizeNode->getX->b->normalizeNode->getY->cst->primitive->asLong->if->if->normalizeNode->getX->getStackKind->normalizeNode->getX->getStackKind->return->FloatEqualsNode->create->else->return->IntegerEqualsNode->create->else->if->if->normalizeNode->getX->getStackKind->normalizeNode->getX->getStackKind->return->FloatLessThanNode->create->else->return->IntegerLessThanNode->create->else->if->if->normalizeNode->getX->getStackKind->normalizeNode->getX->getStackKind->return->FloatLessThanNode->create->else->return->IntegerLessThanNode->create->else->return->LogicConstantNode->contradiction
IntegerEqualsNode.IntegerEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: integer equals op duplicate modified:::if->newX->stamp->newY->stamp->return->new->FloatEqualsNode->else->if->newX->stamp->newY->stamp->return->new->IntegerEqualsNode->else->if->newX->stamp->newY->stamp->return->new->IntegerEqualsNode->throw->GraalError->shouldNotReachHere
IntegerEqualsNode.IntegerEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: integer equals op canonical:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->LogicConstantNode->tautology->else->if->forX->stamp->forY->stamp->alwaysDistinct->return->LogicConstantNode->contradiction->if->addX->addY->v1->v2->if->addX->getX->addY->getX->addX->getY->addY->getY->else->if->addX->getX->addY->getY->addX->getY->addY->getX->else->if->addX->getY->addY->getX->addX->getX->addY->getY->else->if->addX->getY->addY->getY->addX->getX->addY->getX->if->return->create->if->subX->subY->v1->v2->if->subX->getX->subY->getX->subX->getY->subY->getY->else->if->subX->getY->subY->getY->subX->getX->subY->getX->if->return->create->if->addNode->if->addNode->getX->return->addNode->getY->ConstantNode->view->stamp->forIntegerStamp->create->else->if->addNode->getY->return->addNode->getX->ConstantNode->view->stamp->forIntegerStamp->create->if->addNode->if->addNode->getX->return->addNode->getY->ConstantNode->view->stamp->forIntegerStamp->create->else->if->addNode->getY->return->addNode->getX->ConstantNode->view->stamp->forIntegerStamp->create->if->subNode->if->subNode->getX->return->subNode->getY->ConstantNode->view->stamp->forIntegerStamp->create->if->subNode->if->subNode->getX->return->subNode->getY->ConstantNode->view->stamp->forIntegerStamp->create->return->super->canonical
IntegerEqualsNode.IntegerEqualsOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)::: integer equals op canonicalize symmetric constant:::if->primitiveConstant->nonConstantStamp->nonConstant->stamp->if->primitiveConstant->asLong->nonConstantStamp->upperBound->nonConstantStamp->lowerBound->primitiveConstant->asLong->nonConstantStamp->upperBound->nonConstantStamp->lowerBound->return->LogicNegationNode->IntegerEqualsNode->ConstantNode->forIntegerStamp->create->create->else->if->primitiveConstant->asLong->if->andNode->return->andNode->getX->andNode->getY->new->IntegerTestNode->else->if->subNode->return->IntegerEqualsNode->subNode->getX->subNode->getY->create->else->if->nonConstant->stamp->if->shift->if->shift->getY->isConstant->mask->shift->getShiftAmountMask->amount->shift->getY->asJavaConstant->asInt->if->shift->getX->getStackKind->return->shift->getX->ConstantNode->forInt->new->IntegerTestNode->else->return->shift->getX->ConstantNode->forLong->new->IntegerTestNode->else->if->shift->if->shift->getY->isConstant->shift->getX->stamp->isPositive->mask->shift->getShiftAmountMask->amount->shift->getY->asJavaConstant->asInt->if->shift->getX->getStackKind->return->shift->getX->ConstantNode->forInt->new->IntegerTestNode->else->return->shift->getX->ConstantNode->forLong->new->IntegerTestNode->else->if->shift->if->shift->getY->isConstant->mask->shift->getShiftAmountMask->amount->shift->getY->asJavaConstant->asInt->if->shift->getX->getStackKind->return->shift->getX->ConstantNode->forInt->new->IntegerTestNode->else->return->shift->getX->ConstantNode->forLong->new->IntegerTestNode->if->addNode->if->addNode->getY->isJavaConstant->return->addNode->getX->ConstantNode->primitiveConstant->asLong->addNode->getY->asJavaConstant->asLong->forIntegerStamp->new->IntegerEqualsNode->if->andNode->if->Long->asLong->bitCount->andNode->getY->isConstant->andNode->getY->asJavaConstant->equals->return->andNode->getX->andNode->getY->new->IntegerTestNode->new->LogicNegationNode->if->nonConstant->stamp->xorNode->if->xorNode->getY->isJavaConstant->xorNode->getY->asJavaConstant->asLong->xorNode->getX->stamp->upMask->return->xorNode->getX->ConstantNode->xorNode->getX->stamp->primitiveConstant->asLong->forIntegerStamp->new->IntegerEqualsNode->return->super->canonicalizeSymmetricConstant
IntegerEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: integer equals node get succeeding stamp for x:::if->return->xStamp->join->return
IntegerEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: integer equals node get succeeding stamp for y:::if->return->xStamp->join->return
IntegerEqualsNode#tryFold(Stamp, Stamp)::: integer equals node try fold:::if->xStamp->yStamp->if->xStamp->alwaysDistinct->return->else->if->xStamp->neverDistinct->return->return
IntegerEqualsNode#implies(boolean, LogicNode)::: integer equals node implies:::if->otherX->getX->otherY->getY->if->getX->getY->getX->getY->return->return->super->implies
IntegerLessThanNode#create(ValueNode, ValueNode, NodeView)::: integer less than node create:::return->OP->create
IntegerLessThanNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)::: integer less than node create:::value->OP->OP->getCondition->canonical->if->return->return->create
IntegerLessThanNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: integer less than node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->OP->getCondition->canonical->if->return->return
IntegerLessThanNode#subtractMayUnderflow(long, long, long)::: integer less than node subtract may underflow:::r->return
IntegerLessThanNode#subtractMayOverflow(long, long, long)::: integer less than node subtract may overflow:::r->return
IntegerLessThanNode.LessThanOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: less than op duplicate modified:::if->newX->stamp->newY->stamp->return->new->FloatLessThanNode->else->if->newX->stamp->newY->stamp->return->new->IntegerLessThanNode->throw->GraalError->shouldNotReachHere
IntegerLessThanNode.LessThanOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)::: less than op optimize normalize compare:::primitive->a->normalizeNode->getY->normalizeNode->getX->b->normalizeNode->getX->normalizeNode->getY->cst->primitive->asLong->primitive->asLong->if->if->normalizeNode->getX->getStackKind->normalizeNode->getX->getStackKind->return->FloatLessThanNode->create->else->return->IntegerLessThanNode->create->else->if->compare->if->normalizeNode->getX->getStackKind->normalizeNode->getX->getStackKind->FloatLessThanNode->create->else->IntegerLessThanNode->create->return->LogicNegationNode->create->else->if->return->LogicConstantNode->contradiction->else->return->LogicConstantNode->tautology
IntegerLessThanNode.LessThanOp#findSynonym(ValueNode, ValueNode, NodeView)::: less than op find synonym:::result->super->findSynonym->if->return->if->forX->stamp->forY->stamp->if->IntegerStamp->forX->stamp->forY->stamp->sameSign->return->new->IntegerBelowNode->if->forY->isConstant->if->sub->xx->yy->negate->if->forY->asConstant->isDefaultForKind->sub->getX->sub->getY->else->if->forY->isJavaConstant->forY->asJavaConstant->asLong->sub->getY->sub->getX->if->xStamp->sub->getX->stamp->yStamp->sub->getY->stamp->minValue->CodeUtil->xStamp->getBits->minValue->maxValue->CodeUtil->xStamp->getBits->maxValue->if->xStamp->lowerBound->yStamp->upperBound->subtractMayUnderflow->xStamp->upperBound->yStamp->lowerBound->subtractMayOverflow->logic->new->IntegerLessThanNode->if->LogicNegationNode->create->return->else->if->addNode->if->addNode->getY->isJavaConstant->xStamp->addNode->getX->stamp->if->IntegerStamp->addNode->getY->stamp->addCanOverflow->minValue->CodeUtil->xStamp->getBits->minValue->maxValue->CodeUtil->xStamp->getBits->maxValue->yConstant->forY->asJavaConstant->asLong->xConstant->addNode->getY->asJavaConstant->asLong->if->subtractMayUnderflow->subtractMayOverflow->newConstant->return->IntegerLessThanNode->addNode->getX->ConstantNode->forIntegerStamp->create->if->forX->stamp->bits->forX->stamp->getBits->logic->canonicalizeRangeFlip->if->return->return
IntegerLessThanNode.LessThanOp#getCondition()::: less than op get condition:::return
IntegerLessThanNode.LessThanOp#createNode(ValueNode, ValueNode)::: less than op create node:::return->new->IntegerLessThanNode
IntegerLessThanNode.LessThanOp#upperBound(IntegerStamp)::: less than op upper bound:::return->stamp->upperBound
IntegerLessThanNode.LessThanOp#lowerBound(IntegerStamp)::: less than op lower bound:::return->stamp->lowerBound
IntegerLessThanNode.LessThanOp#compare(long, long)::: less than op compare:::return->Long->compare
IntegerLessThanNode.LessThanOp#min(long, long)::: less than op min:::return->Math->min
IntegerLessThanNode.LessThanOp#max(long, long)::: less than op max:::return->Math->max
IntegerLessThanNode.LessThanOp#cast(long, int)::: less than op cast:::return->CodeUtil->signExtend
IntegerLessThanNode.LessThanOp#minValue(int)::: less than op min value:::return->NumUtil->minValue
IntegerLessThanNode.LessThanOp#maxValue(int)::: less than op max value:::return->NumUtil->maxValue
IntegerLessThanNode.LessThanOp#forInteger(int, long, long)::: less than op for integer:::return->StampFactory->cast->cast->forInteger
IntegerLessThanNode#implies(boolean, LogicNode)::: integer less than node implies:::if->if->otherX->getX->otherY->getY->if->getX->getY->return->if->otherX->getX->otherY->getY->if->getX->getY->getX->getY->return->return->super->implies
IntegerLowerThanNode#getOp()::: integer lower than node get op:::return
IntegerLowerThanNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: integer lower than node get succeeding stamp for x:::return->getX->getY->getSucceedingStampForX
IntegerLowerThanNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: integer lower than node get succeeding stamp for y:::return->getY->getX->getSucceedingStampForX
IntegerLowerThanNode#getSucceedingStampForX(boolean, boolean, Stamp, Stamp, ValueNode, ValueNode)::: integer lower than node get succeeding stamp for x:::s->getSucceedingStampForX->if->s->isUnrestricted->if->xStamp->addNode->aStamp->if->addNode->getX->addNode->getY->stamp->addNode->getY->stamp->else->if->addNode->getY->addNode->getX->stamp->addNode->getX->stamp->if->result->getOp->getSucceedingStampForXLowerXPlusA->xStamp->tryImproveWith->if->if->s->improveWith->else->return
IntegerLowerThanNode#getSucceedingStampForX(boolean, boolean, Stamp, Stamp)::: integer lower than node get succeeding stamp for x:::if->xStamp->if->yStamp->s->getOp->getSucceedingStampForX->if->return->return
IntegerLowerThanNode#tryFold(Stamp, Stamp)::: integer lower than node try fold:::return->getOp->tryFold
IntegerLowerThanNode.LowerOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: lower op canonical:::result->super->canonical->if->return->synonym->findSynonym->if->return->return
IntegerLowerThanNode.LowerOp#upperBound(IntegerStamp)::: lower op upper bound:::
IntegerLowerThanNode.LowerOp#lowerBound(IntegerStamp)::: lower op lower bound:::
IntegerLowerThanNode.LowerOp#compare(long, long)::: lower op compare:::
IntegerLowerThanNode.LowerOp#min(long, long)::: lower op min:::
IntegerLowerThanNode.LowerOp#max(long, long)::: lower op max:::
IntegerLowerThanNode.LowerOp#min(long, long, int)::: lower op min:::return->cast->cast->min
IntegerLowerThanNode.LowerOp#max(long, long, int)::: lower op max:::return->cast->cast->max
IntegerLowerThanNode.LowerOp#cast(long, int)::: lower op cast:::
IntegerLowerThanNode.LowerOp#minValue(int)::: lower op min value:::
IntegerLowerThanNode.LowerOp#maxValue(int)::: lower op max value:::
IntegerLowerThanNode.LowerOp#forInteger(int, long, long)::: lower op for integer:::
IntegerLowerThanNode.LowerOp#getCondition()::: lower op get condition:::
IntegerLowerThanNode.LowerOp#createNode(ValueNode, ValueNode)::: lower op create node:::
IntegerLowerThanNode.LowerOp#create(ValueNode, ValueNode, NodeView)::: lower op create:::result->CompareNode->getCondition->tryConstantFoldPrimitive->if->return->else->findSynonym->if->return->return->createNode
IntegerLowerThanNode.LowerOp#findSynonym(ValueNode, ValueNode, NodeView)::: lower op find synonym:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->LogicConstantNode->contradiction->xStampGeneric->forX->stamp->fold->forY->stamp->tryFold->if->fold->isTrue->return->LogicConstantNode->tautology->else->if->fold->isFalse->return->LogicConstantNode->contradiction->if->forY->stamp->yStamp->forY->stamp->xStamp->bits->yStamp->getBits->if->forX->isJavaConstant->forY->isConstant->xValue->forX->asJavaConstant->asLong->if->maxValue->return->LogicNegationNode->ConstantNode->forIntegerStamp->create->create->if->forY->isJavaConstant->yValue->forY->asJavaConstant->asLong->if->maxValue->return->LogicNegationNode->IntegerEqualsNode->create->create->if->minValue->return->IntegerEqualsNode->ConstantNode->minValue->forIntegerStamp->create->if->minValue->xStamp->lowerBound->getCondition->return->IntegerEqualsNode->ConstantNode->forIntegerStamp->create->else->if->addNode->canonical->canonicalizeXLowerXPlusA->if->return->if->addNode->canonical->canonicalizeXLowerXPlusA->if->return->return
IntegerLowerThanNode.LowerOp#canonicalizeRangeFlip(ValueNode, ValueNode, int, boolean, NodeView):::Exploit the fact that adding the (signed) MIN_VALUE on both side flips signed and unsigned comparison:::min->CodeUtil->minValue->xResidue->left->leftCst->if->xAdd->if->xAdd->getY->isJavaConstant->xAdd->getY->asJavaConstant->isDefaultForKind->xCst->xAdd->getY->asJavaConstant->asLong->xAdd->getX->else->if->forX->isJavaConstant->forX->asJavaConstant->if->return->yResidue->right->rightCst->if->yAdd->if->yAdd->getY->isJavaConstant->yAdd->getY->asJavaConstant->isDefaultForKind->yCst->yAdd->getY->asJavaConstant->asLong->yAdd->getX->else->if->forY->isJavaConstant->forY->asJavaConstant->if->return->if->if->ConstantNode->leftCst->asLong->forIntegerBits->else->if->AddNode->ConstantNode->forIntegerBits->create->if->ConstantNode->rightCst->asLong->forIntegerBits->else->if->AddNode->ConstantNode->forIntegerBits->create->if->return->new->IntegerBelowNode->else->return->new->IntegerLessThanNode->return
IntegerLowerThanNode.LowerOp#canonicalizeXLowerXPlusA(ValueNode, AddNode, boolean, boolean, NodeView)::: lower op canonicalize lower plus a:::xStamp->forX->stamp->succeedingXStamp->exact->if->addNode->getX->addNode->getY->stamp->aStamp->addNode->getY->stamp->getSucceedingStampForXLowerXPlusA->aStamp->lowerBound->aStamp->upperBound->else->if->addNode->getY->addNode->getX->stamp->aStamp->addNode->getX->stamp->getSucceedingStampForXLowerXPlusA->aStamp->lowerBound->aStamp->upperBound->else->return->if->succeedingXStamp->forX->stamp->join->isEmpty->return->LogicConstantNode->contradiction->else->if->succeedingXStamp->isEmpty->bits->succeedingXStamp->getBits->if->lowerBound->minValue->compare->return->LogicNegationNode->ConstantNode->lowerBound->forIntegerStamp->create->create->else->if->upperBound->maxValue->compare->return->LogicNegationNode->ConstantNode->upperBound->forIntegerStamp->create->create->return
IntegerLowerThanNode.LowerOp#tryFold(Stamp, Stamp)::: lower op try fold:::if->xStamp->yStamp->if->upperBound->lowerBound->compare->return->if->lowerBound->upperBound->compare->return->return
IntegerLowerThanNode.LowerOp#getSucceedingStampForX(IntegerStamp, IntegerStamp, boolean, boolean)::: lower op get succeeding stamp for x:::bits->xStamp->getBits->if->low->lowerBound->if->if->maxValue->return->if->lowerBound->compare->upperBound->xStamp->upperBound->xStamp->getBits->mask->return->upperBound->forInteger->else->low->upperBound->if->if->minValue->return->if->upperBound->compare->lowerBound->xStamp->lowerBound->xStamp->getBits->mask->return->lowerBound->forInteger->return
IntegerLowerThanNode.LowerOp#getSucceedingStampForXLowerXPlusA(boolean, boolean, IntegerStamp, IntegerStamp)::: lower op get succeeding stamp for lower plus a:::bits->aStamp->getBits->min->minValue->max->maxValue->if->if->aStamp->contains->return->aStamp->unrestricted->return->aStamp->lowerBound->aStamp->upperBound->min->upperBound->min->forInteger->else->aLower->aStamp->lowerBound->aUpper->aStamp->upperBound->if->if->if->if->return->aStamp->empty->if->return->aStamp->unrestricted->return->max->forInteger
IntegerMulHighNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: integer mul high node generate:::a->nodeValueMap->getX->operand->b->nodeValueMap->getY->operand->nodeValueMap->gen->emitMulHigh->setResult
IntegerMulHighNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: integer mul high node canonical:::ret->super->canonical->if->return->if->forX->isConstant->forY->isConstant->improvement->canonical->if->return->return->new->IntegerMulHighNode->return->canonical
IntegerMulHighNode#canonical(IntegerMulHighNode, ValueNode)::: integer mul high node canonical:::if->forY->isConstant->c->forY->asConstant->if->getJavaKind->isNumericInteger->i->asLong->if->return->ConstantNode->self->stamp->forIntegerStamp->return
IntegerTestNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: integer test node canonical:::view->NodeView->from->if->forX->isConstant->forY->isConstant->return->LogicConstantNode->forX->asJavaConstant->asLong->forY->asJavaConstant->asLong->forBoolean->if->forX->stamp->forY->stamp->xStamp->forX->stamp->yStamp->forY->stamp->if->xStamp->upMask->yStamp->upMask->return->LogicConstantNode->tautology->else->if->xStamp->downMask->yStamp->downMask->return->LogicConstantNode->contradiction->return
IntegerTestNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: integer test node get succeeding stamp for x:::return->getSucceedingStamp
IntegerTestNode#getSucceedingStamp(boolean, Stamp, Stamp)::: integer test node get succeeding stamp:::if->xStamp->otherStamp->if->if->Long->otherStamp->upMask->bitCount->newDownMask->xStamp->downMask->otherStamp->upMask->if->xStamp->downMask->return->IntegerStamp->xStamp->getBits->xStamp->upMask->stampForMask->join->else->restrictedUpMask->otherStamp->downMask->xStamp->upMask->if->xStamp->upMask->return->IntegerStamp->xStamp->getBits->xStamp->downMask->stampForMask->join->return
IntegerTestNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: integer test node get succeeding stamp for y:::return->getSucceedingStamp
IntegerTestNode#tryFold(Stamp, Stamp)::: integer test node try fold:::if->xStamp->yStamp->if->xStamp->upMask->yStamp->upMask->return->else->if->xStamp->downMask->yStamp->downMask->return->return
IsNullNode#nullConstant()::: is null node null constant:::return
IsNullNode#create(ValueNode)::: is null node create:::assertNonNarrow->return->canonicalized
IsNullNode#create(ValueNode, JavaConstant)::: is null node create:::return->canonicalized
IsNullNode#assertNonNarrow(ValueNode)::: is null node assert non narrow:::
IsNullNode#generate(NodeLIRBuilderTool)::: is null node generate:::
IsNullNode#verify()::: is null node verify:::getValue->assertTrue->getValue->stamp->getValue->stamp->assertTrue->return->super->verify
IsNullNode#canonical(CanonicalizerTool, ValueNode)::: is null node canonical:::return->canonicalized
IsNullNode#canonicalized(IsNullNode, ValueNode, JavaConstant)::: is null node canonicalized:::nullConstant->value->while->if->StampTool->isPointerAlwaysNull->return->LogicConstantNode->tautology->else->if->StampTool->isPointerNonNull->return->LogicConstantNode->contradiction->if->convertNode->if->convertNode->mayNullCheckSkipConversion->convertNode->getValue->continue->if->compressionNode->compressionNode->nullConstant->compressionNode->getValue->continue->return->new->IsNullNode
IsNullNode#virtualize(VirtualizerTool)::: is null node virtualize:::alias->tool->getValue->getAlias->fold->alias->stamp->tryFold->if->tool->LogicConstantNode->fold->isTrue->graph->forBoolean->replaceWithValue
IsNullNode#getSucceedingStampForValue(boolean)::: is null node get succeeding stamp for value:::pointerStamp->getValue->stamp->unrestricted->return->pointerStamp->asNonNull->pointerStamp->asAlwaysNull
IsNullNode#tryFold(Stamp)::: is null node try fold:::if->objectStamp->if->objectStamp->alwaysNull->return->else->if->objectStamp->nonNull->return->return
LeftShiftNode#create(ValueNode, ValueNode, NodeView)::: left shift node create:::op->ArithmeticOpTable->x->stamp->forStamp->getShl->stamp->op->x->stamp->y->stamp->foldStamp->value->ShiftNode->canonical->if->return->return->canonical
LeftShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: left shift node canonical:::ret->super->canonical->if->return->return->getArithmeticOp->stamp->canonical
LeftShiftNode#canonical(LeftShiftNode, ArithmeticOpTable.ShiftOp, Stamp, ValueNode, ValueNode)::: left shift node canonical:::self->if->forY->isConstant->amount->forY->asJavaConstant->asInt->originalAmount->mask->op->getShiftAmountMask->if->return->if->other->if->other->getY->isConstant->otherAmount->other->getY->asJavaConstant->asInt->if->total->if->return->ConstantNode->stamp->getStackKind->forIntegerKind->return->other->getX->ConstantNode->forInt->new->LeftShiftNode->else->if->if->stamp->getStackKind->return->other->getX->ConstantNode->forLong->new->AndNode->else->return->other->getX->ConstantNode->forInt->new->AndNode->if->return->ConstantNode->forInt->new->LeftShiftNode->if->new->LeftShiftNode->return
LeftShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: left shift node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitShl->setResult
MulNode#create(ValueNode, ValueNode, NodeView)::: mul node create:::op->ArithmeticOpTable->x->stamp->forStamp->getMul->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
MulNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: mul node canonical:::ret->super->canonical->if->return->if->forX->isConstant->forY->isConstant->improvement->canonical->if->return->return->new->MulNode->op->getOp->view->NodeView->from->return->stamp->canonical
MulNode#canonical(MulNode, BinaryOp, Stamp, ValueNode, ValueNode, NodeView)::: mul node canonical:::if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->getJavaKind->isNumericInteger->i->asLong->result->canonical->if->return->if->op->isAssociative->return->new->MulNode->maybeCommuteInputs->ValueNode->isConstantPredicate->reassociate->return->new->MulNode->maybeCommuteInputs
MulNode#canonical(Stamp, ValueNode, long, NodeView)::: mul node canonical:::if->return->ConstantNode->forIntegerStamp->else->if->return->else->if->return->NegateNode->create->else->if->if->CodeUtil->isPowerOf2->return->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->else->if->CodeUtil->isPowerOf2->return->AddNode->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->create->else->if->CodeUtil->isPowerOf2->return->SubNode->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->create->else->bitCount->Long->bitCount->highestBitValue->Long->highestOneBit->if->lowerBitValue->left->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->right->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->return->AddNode->create->else->shiftToRoundUpToPowerOf2->CodeUtil->log2->subValue->if->CodeUtil->isPowerOf2->getBits->left->ConstantNode->forInt->new->LeftShiftNode->right->ConstantNode->CodeUtil->log2->forInt->new->LeftShiftNode->return->SubNode->create->else->if->if->CodeUtil->isPowerOf2->return->NegateNode->LeftShiftNode->ConstantNode->CodeUtil->log2->forInt->create->create->return
MulNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: mul node generate:::op1->nodeValueMap->getX->operand->op2->nodeValueMap->getY->operand->if->shouldSwapInputs->tmp->nodeValueMap->gen->emitMul->setResult
NarrowableArithmeticNode#isNarrowable(int):::Check whether this operation can be narrowed to resultBits bit without loss of precision.:::return
NarrowNode#create(ValueNode, int, NodeView)::: narrow node create:::return->PrimitiveStamp->input->stamp->getBits->create
NarrowNode#create(ValueNode, int, int, NodeView)::: narrow node create:::signExtend->ArithmeticOpTable->input->stamp->forStamp->getNarrow->synonym->signExtend->input->stamp->foldStamp->findSynonym->if->return->else->return->new->NarrowNode
NarrowNode#isLossless()::: narrow node is lossless:::return
NarrowNode#canonical(CanonicalizerTool, ValueNode)::: narrow node canonical:::view->NodeView->from->ret->super->canonical->if->return->if->other->return->other->getValue->other->getInputBits->getResultBits->new->NarrowNode->else->if->other->if->other->getValue->hasExactlyOneUsage->other->hasMoreThanOneUsage->return->if->getResultBits->other->getInputBits->return->other->getValue->else->if->getResultBits->other->getInputBits->return->other->getValue->other->getInputBits->getResultBits->new->NarrowNode->else->if->return->SignExtendNode->other->getValue->other->getInputBits->getResultBits->create->else->if->return->other->getValue->other->getInputBits->getResultBits->isInputAlwaysPositive->new->ZeroExtendNode->else->if->andNode->yStamp->andNode->getY->stamp->xStamp->andNode->getX->stamp->relevantMask->CodeUtil->this->getResultBits->mask->if->yStamp->downMask->return->andNode->getX->this->getResultBits->create->else->if->xStamp->downMask->return->andNode->getY->this->getResultBits->create->return
NarrowNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: narrow node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->getResultBits->emitNarrow->setResult
NarrowNode#mayNullCheckSkipConversion()::: narrow node may null check skip conversion:::return
NegateNode#create(ValueNode, NodeView)::: negate node create:::synonym->findSynonym->if->return->return->new->NegateNode
NegateNode#canonical(CanonicalizerTool, ValueNode)::: negate node canonical:::synonym->getOp->findSynonym->if->return->return
NegateNode#findSynonym(ValueNode, NodeView)::: negate node find synonym:::negOp->ArithmeticOpTable->forValue->stamp->forStamp->getNeg->synonym->UnaryArithmeticNode->findSynonym->if->return->if->return->getValue->if->forValue->stamp->sub->return->SubNode->sub->getY->sub->getX->create->return
NegateNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: negate node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->emitNegate->setResult
NegateNode#invertStamp(Stamp)::: negate node invert stamp:::return->getArithmeticOp->foldStamp
NormalizeCompareNode#create(ValueNode, ValueNode, boolean, JavaKind, ConstantReflectionProvider)::: normalize compare node create:::result->tryConstantFold->if->return->return->new->NormalizeCompareNode
NormalizeCompareNode#tryConstantFold(ValueNode, ValueNode, boolean, JavaKind, ConstantReflectionProvider)::: normalize compare node try constant fold:::result->CompareNode->tryConstantFold->if->logicConstantNode->resultLT->CompareNode->tryConstantFold->if->logicConstantNodeLT->if->logicConstantNodeLT->getValue->return->ConstantNode->forIntegerKind->else->if->logicConstantNode->getValue->return->ConstantNode->forIntegerKind->else->return->ConstantNode->forIntegerKind->return
NormalizeCompareNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: normalize compare node canonical:::view->NodeView->from->result->stamp->getStackKind->tool->getConstantReflection->tryConstantFold->if->return->return
NormalizeCompareNode#inferStamp()::: normalize compare node infer stamp:::return
NormalizeCompareNode#foldStamp(Stamp, Stamp)::: normalize compare node fold stamp:::return->stamp
NormalizeCompareNode#isUnorderedLess()::: normalize compare node is unordered less:::return
NotNode#create(ValueNode)::: not node create:::return->canonicalize
NotNode#canonical(CanonicalizerTool, ValueNode)::: not node canonical:::ret->super->canonical->if->return->return->canonicalize
NotNode#canonicalize(NotNode, ValueNode)::: not node canonicalize:::if->return->getValue->if->return->return->new->NotNode
NotNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: not node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->emitNot->setResult
NotNode#invertStamp(Stamp)::: not node invert stamp:::return->getArithmeticOp->foldStamp
ObjectEqualsNode#create(ValueNode, ValueNode, ConstantReflectionProvider, NodeView)::: object equals node create:::result->CompareNode->tryConstantFold->if->return->else->findSynonym->if->return->return->new->ObjectEqualsNode
ObjectEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, ValueNode, ValueNode, NodeView)::: object equals node create:::result->OP->canonical->if->return->return->create
ObjectEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: object equals node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->canonical->if->return->return
ObjectEqualsNode.ObjectEqualsOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)::: object equals op canonicalize symmetric constant:::type->constantReflection->asJavaType->if->getClassNode->object->getClassNode->getObject->if->type->isPrimitive->type->isConcrete->type->isArray->return->InstanceOfNode->TypeReference->createExactTrusted->create->return->LogicConstantNode->forBoolean->return->super->canonicalizeSymmetricConstant
ObjectEqualsNode.ObjectEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: object equals op duplicate modified:::if->newX->stamp->newY->stamp->return->new->ObjectEqualsNode->else->if->newX->stamp->newY->stamp->return->new->PointerEqualsNode->throw->GraalError->shouldNotReachHere
ObjectEqualsNode#virtualizeNonVirtualComparison(VirtualObjectNode, ValueNode, StructuredGraph, VirtualizerTool)::: object equals node virtualize non virtual comparison:::if->other->isConstant->virtualBoxingNode->if->virtualBoxingNode->getBoxingKind->otherUnboxed->tool->getConstantReflection->other->asJavaConstant->unboxPrimitive->if->otherUnboxed->getJavaKind->expectedValue->otherUnboxed->asBoolean->return->virtualBoxingNode->getBoxedValue->ConstantNode->forInt->new->IntegerEqualsNode->else->return->LogicConstantNode->contradiction->if->virtual->hasIdentity->return->LogicConstantNode->contradiction->return
ObjectEqualsNode#virtualizeComparison(ValueNode, ValueNode, StructuredGraph, VirtualizerTool)::: object equals node virtualize comparison:::xAlias->tool->getAlias->yAlias->tool->getAlias->xVirtual->yVirtual->if->return->virtualizeNonVirtualComparison->else->if->return->virtualizeNonVirtualComparison->else->if->if->xVirtual->hasIdentity->yVirtual->hasIdentity->return->LogicConstantNode->contradiction->else->if->xVirtual->hasIdentity->yVirtual->hasIdentity->type->xVirtual->type->if->type->yVirtual->type->equals->metaAccess->tool->getMetaAccess->if->type->metaAccess->lookupJavaType->equals->type->metaAccess->lookupJavaType->equals->return->tool->getEntry->tool->getEntry->new->IntegerEqualsNode->else->return->LogicConstantNode->forBoolean->return
ObjectEqualsNode#virtualize(VirtualizerTool)::: object equals node virtualize:::node->getX->getY->graph->virtualizeComparison->if->return->if->node->isAlive->tool->addNode->tool->replaceWithValue
OrNode#create(ValueNode, ValueNode, NodeView)::: or node create:::op->ArithmeticOpTable->x->stamp->forStamp->getOr->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
OrNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: or node canonical:::view->NodeView->from->ret->super->canonical->if->return->return->getOp->stamp->canonical
OrNode#canonical(OrNode, BinaryOp, Stamp, ValueNode, ValueNode, NodeView)::: or node canonical:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->if->forX->isConstant->forY->isConstant->return->new->OrNode->if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->getJavaKind->isNumericInteger->rawY->asLong->mask->CodeUtil->PrimitiveStamp->getBits->mask->if->return->ConstantNode->forIntegerStamp->return->new->OrNode->maybeCommuteInputs->ValueNode->isConstantPredicate->reassociate->if->return->AndNode->getValue->getValue->create->new->NotNode->return->new->OrNode->maybeCommuteInputs
OrNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: or node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitOr->setResult
PointerEqualsNode#create(ValueNode, ValueNode, NodeView)::: pointer equals node create:::result->findSynonym->if->return->return->new->PointerEqualsNode
PointerEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: pointer equals node canonical:::view->NodeView->from->value->OP->tool->getConstantReflection->tool->getMetaAccess->tool->getOptions->tool->smallestCompareWidth->canonical->if->return->return
PointerEqualsNode.PointerEqualsOp#isAlwaysFailingVirtualDispatchTest(CanonicalCondition, ValueNode, ValueNode):::Determines if this is a comparison used to determine whether dispatching on a receiver could select a certain method and if so, returns true if the answer is guaranteed to be false:::if->forY->isConstant->if->lm->if->lm->getMethod->getEncoding->forY->asConstant->equals->if->lm->getHub->object->lm->getHub->getValue->type->StampTool->typeOrNull->declaringClass->lm->getMethod->getDeclaringClass->if->type->equals->declaringClass->isAssignableFrom->override->type->lm->getMethod->lm->getCallerType->resolveMethod->if->override->lm->getMethod->equals->return->return
PointerEqualsNode.PointerEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)::: pointer equals op canonical:::result->findSynonym->if->return->if->isAlwaysFailingVirtualDispatchTest->return->LogicConstantNode->contradiction->return->super->canonical
PointerEqualsNode.PointerEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)::: pointer equals op duplicate modified:::return->new->PointerEqualsNode
PointerEqualsNode#findSynonym(ValueNode, ValueNode, NodeView)::: pointer equals node find synonym:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->LogicConstantNode->tautology->else->if->forX->stamp->forY->stamp->alwaysDistinct->return->LogicConstantNode->contradiction->else->if->forX->stamp->alwaysNull->return->nullSynonym->else->if->forY->stamp->alwaysNull->return->nullSynonym->else->return
PointerEqualsNode#nullSynonym(ValueNode, ValueNode)::: pointer equals node null synonym:::if->nullValue->isConstant->return->IsNullNode->nullValue->asJavaConstant->create->else->return->IsNullNode->create
PointerEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: pointer equals node get succeeding stamp for x:::if->newStamp->xStamp->join->if->newStamp->equals->return->return
PointerEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: pointer equals node get succeeding stamp for y:::if->newStamp->yStamp->join->if->newStamp->equals->return->return
PointerEqualsNode#tryFold(Stamp, Stamp)::: pointer equals node try fold:::if->xStamp->yStamp->if->xStamp->alwaysDistinct->return->else->if->xStamp->neverDistinct->return->return
ReinterpretNode#create(JavaKind, ValueNode, NodeView)::: reinterpret node create:::return->StampFactory->forKind->create
ReinterpretNode#create(Stamp, ValueNode, NodeView)::: reinterpret node create:::return->canonical
ReinterpretNode#evalConst(Stamp, SerializableConstant)::: reinterpret node eval const:::buffer->ByteBuffer->c->getSerializedSize->new->byteArr->wrap->ByteOrder->nativeOrder->order->c->serialize->BufferUtil->asBaseBuffer->rewind->ret->deserialize->return
ReinterpretNode#canonical(CanonicalizerTool, ValueNode)::: reinterpret node canonical:::view->NodeView->from->return->this->stamp->canonical
ReinterpretNode#canonical(ReinterpretNode, Stamp, ValueNode, NodeView)::: reinterpret node canonical:::if->forValue->isConstant->return->ConstantNode->forValue->asConstant->evalConst->forConstant->if->forStamp->forValue->stamp->isCompatible->return->if->reinterpret->return->reinterpret->getValue->new->ReinterpretNode->return->new->ReinterpretNode
ReinterpretNode#floatToInt(FloatStamp):::Compute the IntegerStamp from a FloatStamp, losing as little information as possible:::bits->stamp->getBits->signBit->exponentMask->if->Double->doubleToRawLongBits->else->Float->floatToRawIntBits->positiveInfinity->negativeInfinity->CodeUtil->signExtend->negativeZero->CodeUtil->signExtend->if->stamp->isNaN->return->IntegerStamp->CodeUtil->maxValue->CodeUtil->mask->create->upperBound->if->stamp->isNonNaN->if->stamp->upperBound->if->stamp->lowerBound->else->else->if->stamp->upperBound->else->if->stamp->upperBound->else->else->CodeUtil->maxValue->lowerBound->if->stamp->lowerBound->if->stamp->isNonNaN->else->else->if->stamp->upperBound->else->if->stamp->upperBound->else->return->StampFactory->forInteger
ReinterpretNode#intToFloat(IntegerStamp):::Compute the IntegerStamp from a FloatStamp, losing as little information as possible:::bits->stamp->getBits->minPositive->maxPositive->signBit->exponentMask->if->Double->doubleToRawLongBits->else->Float->floatToRawIntBits->significandMask->CodeUtil->mask->positiveInfinity->negativeInfinity->CodeUtil->signExtend->negativeZero->CodeUtil->signExtend->if->stamp->downMask->stamp->downMask->return->new->FloatStamp->upperBound->if->stamp->upperBound->if->stamp->lowerBound->else->else->if->stamp->upperBound->if->stamp->lowerBound->return->new->FloatStamp->else->if->stamp->lowerBound->else->if->stamp->lowerBound->else->else->if->stamp->upperBound->else->if->stamp->upperBound->else->lowerBound->if->stamp->lowerBound->return->new->FloatStamp->else->if->stamp->lowerBound->else->if->stamp->lowerBound->else->if->stamp->lowerBound->else->nonNaN->if->stamp->upMask->else->negativeNaNBlock->stamp->lowerBound->stamp->upperBound->positiveNaNBlock->stamp->upperBound->return->new->FloatStamp
ReinterpretNode#getReinterpretStamp(Stamp, Stamp)::: reinterpret node get reinterpret stamp:::if->return->floatToInt->else->if->return->intToFloat->else->return
ReinterpretNode#inferStamp()::: reinterpret node infer stamp:::return->stamp->getValue->stamp->getReinterpretStamp->updateStamp
ReinterpretNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: reinterpret node generate:::kind->builder->getLIRGeneratorTool->stamp->getLIRKind->builder->gen->builder->getValue->operand->emitReinterpret->setResult
ReinterpretNode#reinterpret(JavaKind, ValueNode)::: reinterpret node reinterpret:::return->value->graph->new->ReinterpretNode->unique
RemNode#create(ValueNode, ValueNode, NodeView)::: rem node create:::op->ArithmeticOpTable->forX->stamp->forStamp->getRem->stamp->op->forX->stamp->forY->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->new->RemNode
RemNode#lower(LoweringTool)::: rem node lower:::tool->getLowerer->lower
RemNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: rem node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitRem->setResult
RightShiftNode#create(ValueNode, int, NodeView)::: right shift node create:::if->return->return->ConstantNode->forInt->create
RightShiftNode#create(ValueNode, ValueNode, NodeView)::: right shift node create:::op->ArithmeticOpTable->x->stamp->forStamp->getShr->stamp->op->x->stamp->y->stamp->foldStamp->value->ShiftNode->canonical->if->return->return->canonical
RightShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: right shift node canonical:::view->NodeView->from->ret->super->canonical->if->return->return->getArithmeticOp->stamp->canonical
RightShiftNode#canonical(RightShiftNode, ArithmeticOpTable.ShiftOp, Stamp, ValueNode, ValueNode, NodeView)::: right shift node canonical:::self->if->forX->stamp->forX->stamp->isPositive->return->new->UnsignedRightShiftNode->xStampGeneric->forX->stamp->if->xStamp->if->xStamp->lowerBound->xStamp->upperBound->return->if->forY->isConstant->amount->forY->asJavaConstant->asInt->originalAmout->mask->op->getShiftAmountMask->if->return->if->xStamp->if->xStamp->lowerBound->xStamp->upperBound->return->ConstantNode->stamp->getStackKind->xStamp->lowerBound->forIntegerKind->if->other->if->other->getY->isConstant->otherAmount->other->getY->asJavaConstant->asInt->if->total->if->istamp->other->getX->stamp->if->istamp->isPositive->return->ConstantNode->stamp->getStackKind->forIntegerKind->if->istamp->isStrictlyNegative->return->ConstantNode->stamp->getStackKind->forIntegerKind->return->other->getX->ConstantNode->forInt->new->RightShiftNode->return->other->getX->ConstantNode->forInt->new->RightShiftNode->if->return->ConstantNode->forInt->new->RightShiftNode->if->new->RightShiftNode->return
RightShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: right shift node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitShr->setResult
RightShiftNode#isNarrowable(int)::: right shift node is narrowable:::if->super->isNarrowable->inputStamp->getX->stamp->return->CodeUtil->minValue->inputStamp->lowerBound->inputStamp->upperBound->CodeUtil->maxValue->else->return
ShiftNode#getOp(ValueNode)::: shift node get op:::return->getOp->ArithmeticOpTable->forValue->stamp->forStamp->apply
ShiftNode#getArithmeticOp()::: shift node get arithmetic op:::return->getX->getOp
ShiftNode#foldStamp(Stamp, Stamp)::: shift node fold stamp:::return->getArithmeticOp->foldStamp
ShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: shift node canonical:::view->NodeView->from->valueNode->getOp->stamp->canonical->if->return->return
ShiftNode#canonical(ShiftOp, Stamp, ValueNode, ValueNode, NodeView)::: shift node canonical:::if->forX->isConstant->forY->isConstant->amount->forY->asJavaConstant->return->ConstantNode->op->forX->asConstant->amount->asInt->foldConstant->forPrimitive->return
ShiftNode#getShiftAmountMask()::: shift node get shift amount mask:::return->getArithmeticOp->stamp->getShiftAmountMask
ShiftNode#isNarrowable(int)::: shift node is narrowable:::narrowMask->wideMask->getShiftAmountMask->yStamp->getY->stamp->return->yStamp->upMask
SignedDivNode#create(ValueNode, ValueNode, GuardingNode, NodeView)::: signed div node create:::return->canonical
SignedDivNode#inferStamp()::: signed div node infer stamp:::return->getDiv->getX->stamp->getY->stamp->foldStamp->updateStamp
SignedDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: signed div node canonical:::view->NodeView->from->return->getZeroCheck->canonical
SignedDivNode#canonical(SignedDivNode, ValueNode, ValueNode, GuardingNode, NodeView)::: signed div node canonical:::predictedStamp->getDiv->forX->stamp->forY->stamp->foldStamp->stamp->self->stamp->if->forX->isConstant->forY->isConstant->y->forY->asJavaConstant->asLong->if->return->new->SignedDivNode->return->ConstantNode->forX->asJavaConstant->asLong->forIntegerStamp->else->if->forY->isConstant->c->forY->asJavaConstant->asLong->v->canonical->if->return->if->integerSubNode->if->integerSubNode->getY->integerRemNode->integerSubNode->getY->if->integerSubNode->stamp->isCompatible->integerRemNode->stamp->isCompatible->integerSubNode->getX->integerRemNode->getX->integerRemNode->getY->sd->integerSubNode->getX->new->SignedDivNode->return->if->self->next->nodeClass->self->getNodeClass->if->self->next->getClass->self->getClass->nodeClass->self->next->equalInputs->self->self->next->valueEquals->return->self->next->return->new->SignedDivNode
SignedDivNode#canonical(ValueNode, long, NodeView)::: signed div node canonical:::if->return->if->return->NegateNode->create->abs->Math->abs->if->CodeUtil->isPowerOf2->forX->stamp->stampX->forX->stamp->dividend->log2->CodeUtil->log2->if->stampX->canBeNegative->stampX->upMask->bits->PrimitiveStamp->forX->stamp->getBits->sign->ConstantNode->forInt->new->RightShiftNode->round->ConstantNode->forInt->new->UnsignedRightShiftNode->BinaryArithmeticNode->add->shift->ConstantNode->forInt->new->RightShiftNode->if->return->NegateNode->create->return->return
SignedDivNode#generate(NodeLIRBuilderTool)::: signed div node generate:::gen->gen->getLIRGeneratorTool->getArithmetic->gen->getX->operand->gen->getY->operand->gen->state->emitDiv->setResult
SignedRemNode#create(ValueNode, ValueNode, GuardingNode, NodeView)::: signed rem node create:::stamp->getRem->x->stamp->y->stamp->foldStamp->return->canonical
SignedRemNode#inferStamp()::: signed rem node infer stamp:::return->getRem->getX->stamp->getY->stamp->foldStamp->updateStamp
SignedRemNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: signed rem node canonical:::view->NodeView->from->return->getZeroCheck->stamp->canonical
SignedRemNode#canonical(SignedRemNode, ValueNode, ValueNode, GuardingNode, Stamp, NodeView, CanonicalizerTool)::: signed rem node canonical:::if->forX->isConstant->forY->isConstant->y->forY->asJavaConstant->asLong->if->return->new->SignedRemNode->return->ConstantNode->forX->asJavaConstant->asLong->forIntegerStamp->else->if->forY->isConstant->forX->stamp->forY->stamp->constY->forY->asJavaConstant->asLong->xStamp->forX->stamp->yStamp->forY->stamp->if->CodeUtil->yStamp->getBits->minValue->newStamp->getRem->forX->stamp->forY->stamp->foldStamp->return->ConstantNode->forIntegerStamp->canonical->if->return->ConstantNode->forIntegerStamp->else->if->CodeUtil->isPowerOf2->tool->allUsagesAvailable->if->allUsagesCompareAgainstZero->return->ConstantNode->forIntegerStamp->new->AndNode->else->if->xStamp->isPositive->return->ConstantNode->forIntegerStamp->new->AndNode->else->if->xStamp->isNegative->return->new->NegateNode->ConstantNode->forIntegerStamp->new->AndNode->new->NegateNode->if->return->else->return->new->SignedRemNode
SignedRemNode#allUsagesCompareAgainstZero(SignedRemNode)::: signed rem node all usages compare against zero:::if->return->foreach->self->usages->if->equalsNode->node->equalsNode->getY->if->equalsNode->getX->if->constantNode->constant->constantNode->asConstant->if->asLong->continue->return->return
SignedRemNode#generate(NodeLIRBuilderTool)::: signed rem node generate:::gen->gen->getLIRGeneratorTool->getArithmetic->gen->getX->operand->gen->getY->operand->gen->state->emitRem->setResult
SignExtendNode#create(ValueNode, int, NodeView)::: sign extend node create:::return->PrimitiveStamp->input->stamp->getBits->create
SignExtendNode#create(ValueNode, int, int, NodeView)::: sign extend node create:::signExtend->ArithmeticOpTable->input->stamp->forStamp->getSignExtend->synonym->signExtend->input->stamp->foldStamp->findSynonym->if->return->return->canonical
SignExtendNode#isLossless()::: sign extend node is lossless:::return
SignExtendNode#canonical(CanonicalizerTool, ValueNode)::: sign extend node canonical:::view->NodeView->from->ret->super->canonical->if->return->return->getInputBits->getResultBits->canonical
SignExtendNode#canonical(SignExtendNode, ValueNode, int, int, NodeView)::: sign extend node canonical:::if->other->return->SignExtendNode->other->getValue->other->getInputBits->create->else->if->other->if->other->getResultBits->other->getInputBits->return->ZeroExtendNode->other->getValue->other->getInputBits->other->isInputAlwaysPositive->create->if->forValue->stamp->inputStamp->forValue->stamp->if->inputStamp->upMask->return->ZeroExtendNode->create->if->narrow->inputStamp->narrow->getValue->stamp->if->istamp->mask->CodeUtil->PrimitiveStamp->narrow->stamp->getBits->mask->if->istamp->lowerBound->istamp->upperBound->if->istamp->getBits->return->narrow->getValue->create->else->if->istamp->getBits->return->NarrowNode->narrow->getValue->create->else->return->narrow->getValue->return->new->SignExtendNode
SignExtendNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: sign extend node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->getInputBits->getResultBits->emitSignExtend->setResult
SignExtendNode#mayNullCheckSkipConversion()::: sign extend node may null check skip conversion:::return
SqrtNode#create(ValueNode, NodeView)::: sqrt node create:::if->x->isConstant->op->ArithmeticOpTable->x->stamp->forStamp->getSqrt->return->ConstantNode->op->x->stamp->foldStamp->op->x->asConstant->foldConstant->forPrimitive->return->new->SqrtNode
SqrtNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: sqrt node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->emitMathSqrt->setResult
SubNode#create(ValueNode, ValueNode, NodeView)::: sub node create:::op->ArithmeticOpTable->x->stamp->forStamp->getSub->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
SubNode#canonical(SubNode, BinaryOp, Stamp, ValueNode, ValueNode, NodeView)::: sub node canonical:::self->if->GraphUtil->unproxify->GraphUtil->unproxify->zero->op->forX->stamp->getZero->if->return->ConstantNode->forPrimitive->associative->op->isAssociative->if->if->x->if->x->getY->return->x->getX->if->x->getX->return->x->getY->else->if->x->if->x->getX->return->NegateNode->x->getY->create->if->y->if->y->getX->return->NegateNode->y->getY->create->if->y->getY->return->NegateNode->y->getX->create->else->if->y->if->y->getX->return->y->getY->if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->reassociated->ValueNode->isConstantPredicate->reassociate->if->return->if->getJavaKind->isNumericInteger->i->asLong->if->StampFactory->forY->getStackKind->forKind->contains->return->BinaryArithmeticNode->ConstantNode->forIntegerStamp->add->else->if->forX->isConstant->c->forX->asConstant->if->ArithmeticOpTable->forStamp->getAdd->isNeutral->return->NegateNode->create->if->return->ValueNode->isConstantPredicate->reassociate->if->return->BinaryArithmeticNode->getValue->add->return->new->SubNode
SubNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: sub node canonical:::view->NodeView->from->ret->super->canonical->if->return->op->getOp->return->canonical
SubNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: sub node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitSub->setResult
TernaryNode#getX()::: ternary node get x:::return
TernaryNode#getY()::: ternary node get y:::return
TernaryNode#getZ()::: ternary node get z:::return
TernaryNode#setX(ValueNode)::: ternary node set x:::updateUsages
TernaryNode#setY(ValueNode)::: ternary node set y:::updateUsages
TernaryNode#setZ(ValueNode)::: ternary node set z:::updateUsages
TernaryNode#inferStamp()::: ternary node infer stamp:::return->getX->stamp->getY->stamp->getZ->stamp->foldStamp->updateStamp
TernaryNode#foldStamp(Stamp, Stamp, Stamp):::Compute an improved stamp for this node using the passed in stamps:::
UnaryArithmeticNode#getOp(ValueNode)::: unary arithmetic node get op:::return->getOp->ArithmeticOpTable->forValue->stamp->forStamp->apply
UnaryArithmeticNode#getArithmeticOp()::: unary arithmetic node get arithmetic op:::return->getValue->getOp
UnaryArithmeticNode#foldStamp(Stamp)::: unary arithmetic node fold stamp:::return->getValue->getOp->foldStamp
UnaryArithmeticNode#canonical(CanonicalizerTool, ValueNode)::: unary arithmetic node canonical:::synonym->getOp->findSynonym->if->return->return
UnaryArithmeticNode#findSynonym(ValueNode, UnaryOp)::: unary arithmetic node find synonym:::if->forValue->isConstant->return->ConstantNode->op->forValue->stamp->foldStamp->op->forValue->asConstant->foldConstant->forPrimitive->return
UnaryNode#getValue()::: unary node get value:::return
UnaryNode#setValue(ValueNode)::: unary node set value:::updateUsages
UnaryNode#inferStamp()::: unary node infer stamp:::return->value->stamp->foldStamp->updateStamp
UnaryNode#foldStamp(Stamp):::Compute an improved for this node using the passed in stamp:::return->stamp
UnpackEndianHalfNode#create(ValueNode, boolean, NodeView)::: unpack endian half node create:::if->value->isConstant->value->asConstant->isDefaultForKind->return->ConstantNode->defaultForKind->return->new->UnpackEndianHalfNode
UnpackEndianHalfNode#isFirstHalf()::: unpack endian half node is first half:::return
UnpackEndianHalfNode#canonical(CanonicalizerTool, ValueNode)::: unpack endian half node canonical:::if->forValue->isDefaultConstant->return->ConstantNode->stamp->getStackKind->defaultForKind->return
UnpackEndianHalfNode#lower(LoweringTool)::: unpack endian half node lower:::tool->getLowerer->lower
UnpackEndianHalfNode#lower(ByteOrder)::: unpack endian half node lower:::result->if->value->getStackKind->graph->new->ReinterpretNode->unique->if->graph->ConstantNode->graph->forInt->new->UnsignedRightShiftNode->unique->IntegerConvertNode->StampFactory->forKind->graph->convert->replaceAtUsagesAndDelete
UnsignedDivNode#create(ValueNode, ValueNode, GuardingNode, NodeView)::: unsigned div node create:::stamp->x->stamp->unrestricted->return->canonical
UnsignedDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: unsigned div node canonical:::view->NodeView->from->return->getZeroCheck->stamp->canonical
UnsignedDivNode#canonical(UnsignedDivNode, ValueNode, ValueNode, GuardingNode, Stamp, NodeView)::: unsigned div node canonical:::bits->getBits->if->forX->isConstant->forY->isConstant->yConst->CodeUtil->forY->asJavaConstant->asLong->zeroExtend->if->return->new->UnsignedDivNode->return->ConstantNode->Long->CodeUtil->forX->asJavaConstant->asLong->zeroExtend->divideUnsigned->forIntegerStamp->else->if->forY->isConstant->c->CodeUtil->forY->asJavaConstant->asLong->zeroExtend->if->return->if->CodeUtil->isPowerOf2->return->ConstantNode->CodeUtil->log2->forInt->new->UnsignedRightShiftNode->return->new->UnsignedDivNode
UnsignedDivNode#generate(NodeLIRBuilderTool)::: unsigned div node generate:::gen->gen->getLIRGeneratorTool->getArithmetic->gen->getX->operand->gen->getY->operand->gen->state->emitUDiv->setResult
UnsignedRemNode#create(ValueNode, ValueNode, GuardingNode, NodeView)::: unsigned rem node create:::stamp->x->stamp->unrestricted->return->canonical
UnsignedRemNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: unsigned rem node canonical:::view->NodeView->from->return->getZeroCheck->stamp->canonical
UnsignedRemNode#canonical(UnsignedRemNode, ValueNode, ValueNode, GuardingNode, Stamp, NodeView)::: unsigned rem node canonical:::bits->getBits->if->forX->isConstant->forY->isConstant->yConst->CodeUtil->forY->asJavaConstant->asLong->zeroExtend->if->return->new->UnsignedRemNode->return->ConstantNode->Long->CodeUtil->forX->asJavaConstant->asLong->zeroExtend->remainderUnsigned->forIntegerStamp->else->if->forY->isConstant->c->CodeUtil->forY->asJavaConstant->asLong->zeroExtend->if->return->ConstantNode->forIntegerStamp->else->if->CodeUtil->isPowerOf2->return->ConstantNode->forIntegerStamp->new->AndNode->return->new->UnsignedRemNode
UnsignedRemNode#generate(NodeLIRBuilderTool)::: unsigned rem node generate:::gen->gen->getLIRGeneratorTool->getArithmetic->gen->getX->operand->gen->getY->operand->gen->state->emitURem->setResult
UnsignedRightShiftNode#create(ValueNode, ValueNode, NodeView)::: unsigned right shift node create:::op->ArithmeticOpTable->x->stamp->forStamp->getUShr->stamp->op->x->stamp->y->stamp->foldStamp->value->ShiftNode->canonical->if->return->return->canonical
UnsignedRightShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: unsigned right shift node canonical:::view->NodeView->from->ret->super->canonical->if->return->return->this->getArithmeticOp->this->stamp->canonical
UnsignedRightShiftNode#canonical(UnsignedRightShiftNode, ArithmeticOpTable.ShiftOp, Stamp, ValueNode, ValueNode, NodeView)::: unsigned right shift node canonical:::if->forY->isConstant->amount->forY->asJavaConstant->asInt->originalAmout->mask->op->getShiftAmountMask->if->return->xStampGeneric->forX->stamp->if->xStamp->xMask->CodeUtil->xStamp->getBits->mask->xLowerBound->xStamp->lowerBound->xUpperBound->xStamp->upperBound->if->return->ConstantNode->stamp->getStackKind->forIntegerKind->if->xStamp->getBits->xStamp->lowerBound->xStamp->upperBound->return->NegateNode->create->if->other->if->other->getY->isConstant->otherAmount->other->getY->asJavaConstant->asInt->if->total->if->return->ConstantNode->stamp->getStackKind->forIntegerKind->return->other->getX->ConstantNode->forInt->new->UnsignedRightShiftNode->else->if->if->stamp->getStackKind->return->other->getX->ConstantNode->forLong->new->AndNode->else->return->other->getX->ConstantNode->forInt->new->AndNode->if->return->ConstantNode->forInt->new->UnsignedRightShiftNode->if->return->return->new->UnsignedRightShiftNode
UnsignedRightShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: unsigned right shift node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitUShr->setResult
UnsignedRightShiftNode#isNarrowable(int)::: unsigned right shift node is narrowable:::if->super->isNarrowable->inputStamp->getX->stamp->return->inputStamp->upMask->else->return
XorNode#create(ValueNode, ValueNode, NodeView)::: xor node create:::op->ArithmeticOpTable->x->stamp->forStamp->getXor->stamp->op->x->stamp->y->stamp->foldStamp->tryConstantFold->tryConstantFold->if->return->return->canonical
XorNode#canonical(CanonicalizerTool, ValueNode, ValueNode)::: xor node canonical:::ret->super->canonical->if->return->view->NodeView->from->return->getOp->stamp->canonical
XorNode#canonical(XorNode, BinaryOp, Stamp, ValueNode, ValueNode, NodeView)::: xor node canonical:::if->GraphUtil->unproxify->GraphUtil->unproxify->return->ConstantNode->op->forX->stamp->getZero->forPrimitive->if->forX->isConstant->forY->isConstant->return->new->XorNode->if->forY->isConstant->c->forY->asConstant->if->op->isNeutral->return->if->getJavaKind->isNumericInteger->rawY->asLong->mask->CodeUtil->PrimitiveStamp->getBits->mask->if->return->new->NotNode->return->new->XorNode->maybeCommuteInputs->ValueNode->isConstantPredicate->reassociate->return->new->XorNode->maybeCommuteInputs
XorNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: xor node generate:::nodeValueMap->gen->nodeValueMap->getX->operand->nodeValueMap->getY->operand->emitXor->setResult
ZeroExtendNode#create(ValueNode, int, NodeView)::: zero extend node create:::return->PrimitiveStamp->input->stamp->getBits->create
ZeroExtendNode#create(ValueNode, int, int, NodeView)::: zero extend node create:::return->create
ZeroExtendNode#create(ValueNode, int, int, NodeView, boolean)::: zero extend node create:::signExtend->ArithmeticOpTable->input->stamp->forStamp->getZeroExtend->synonym->signExtend->input->stamp->foldStamp->findSynonym->if->return->return->canonical
ZeroExtendNode#isLossless()::: zero extend node is lossless:::return
ZeroExtendNode#isInputAlwaysPositive()::: zero extend node is input always positive:::return
ZeroExtendNode#preservesOrder(CanonicalCondition)::: zero extend node preserves order:::switch->return->return
ZeroExtendNode#canonical(CanonicalizerTool, ValueNode)::: zero extend node canonical:::view->NodeView->from->ret->super->canonical->if->return->return->getInputBits->getResultBits->canonical
ZeroExtendNode#canonical(ZeroExtendNode, ValueNode, int, int, NodeView, boolean)::: zero extend node canonical:::self->if->other->return->other->getValue->other->getInputBits->other->isInputAlwaysPositive->new->ZeroExtendNode->if->narrow->inputStamp->narrow->getValue->stamp->if->istamp->mask->CodeUtil->PrimitiveStamp->narrow->stamp->getBits->mask->if->istamp->upMask->if->istamp->getBits->return->narrow->getValue->create->else->if->istamp->getBits->return->NarrowNode->narrow->getValue->create->else->return->narrow->getValue->if->new->ZeroExtendNode->return
ZeroExtendNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)::: zero extend node generate:::nodeValueMap->gen->nodeValueMap->getValue->operand->getInputBits->getResultBits->emitZeroExtend->setResult
ZeroExtendNode#mayNullCheckSkipConversion()::: zero extend node may null check skip conversion:::return
