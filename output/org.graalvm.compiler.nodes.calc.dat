org.graalvm.compiler.nodes.calc.AbsNode#create(ValueNode, NodeView)->ValueNode::: abs node create
org.graalvm.compiler.nodes.calc.AbsNode#findSynonym(ValueNode, NodeView)->ValueNode::: abs node find synonym
org.graalvm.compiler.nodes.calc.AbsNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: abs node canonical
org.graalvm.compiler.nodes.calc.AbsNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: abs node generate
org.graalvm.compiler.nodes.calc.AddNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: add node create
org.graalvm.compiler.nodes.calc.AddNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: add node canonical
org.graalvm.compiler.nodes.calc.AddNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: add node generate
org.graalvm.compiler.nodes.calc.AndNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: and node create
org.graalvm.compiler.nodes.calc.AndNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: and node canonical
org.graalvm.compiler.nodes.calc.AndNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: and node generate
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#getOp(ValueNode, ValueNode)->BinaryOp::: binary arithmetic node get op
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#getArithmeticOp()->BinaryOp::: binary arithmetic node get arithmetic op
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#isAssociative()->boolean::: binary arithmetic node is associative
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: binary arithmetic node canonical
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#tryConstantFold(BinaryOp, ValueNode, ValueNode, Stamp, NodeView)->ConstantNode::: binary arithmetic node try constant fold
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#foldStamp(Stamp, Stamp)->Stamp::: binary arithmetic node fold stamp
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#add(StructuredGraph, ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node add
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#add(ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node add
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#add(ValueNode, ValueNode)->ValueNode::: binary arithmetic node add
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#mul(StructuredGraph, ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node mul
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#mul(ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node mul
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#mul(ValueNode, ValueNode)->ValueNode::: binary arithmetic node mul
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#sub(StructuredGraph, ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node sub
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#sub(ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node sub
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#sub(ValueNode, ValueNode)->ValueNode::: binary arithmetic node sub
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#branchlessMin(ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node branchless min
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#branchlessMax(ValueNode, ValueNode, NodeView)->ValueNode::: binary arithmetic node branchless max
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#reassociate(BinaryArithmeticNode, NodePredicate, ValueNode, ValueNode, NodeView)->ValueNode:::Tries to re-associate values which satisfy the criterion
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#maybeCommuteInputs()->BinaryNode:::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results
org.graalvm.compiler.nodes.calc.BinaryArithmeticNode#shouldSwapInputs(NodeValueMap)->boolean:::Determines if it would be better to swap the inputs in order to produce better assembly code
org.graalvm.compiler.nodes.calc.BinaryNode#getX()->ValueNode::: binary node get x
org.graalvm.compiler.nodes.calc.BinaryNode#getY()->ValueNode::: binary node get y
org.graalvm.compiler.nodes.calc.BinaryNode#setX(ValueNode)->void::: binary node set x
org.graalvm.compiler.nodes.calc.BinaryNode#setY(ValueNode)->void::: binary node set y
org.graalvm.compiler.nodes.calc.BinaryNode#inferStamp()->boolean::: binary node infer stamp
org.graalvm.compiler.nodes.calc.BinaryNode#foldStamp(Stamp, Stamp)->Stamp:::Compute an improved for this node using the passed in stamps
org.graalvm.compiler.nodes.calc.CompareNode#condition()->CanonicalCondition:::Gets the condition (comparison operation) for this instruction.
org.graalvm.compiler.nodes.calc.CompareNode#unorderedIsTrue()->boolean:::Checks whether unordered inputs mean true or false (only applies to float operations).
org.graalvm.compiler.nodes.calc.CompareNode#tryConstantFold(CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, boolean)->LogicNode::: compare node try constant fold
org.graalvm.compiler.nodes.calc.CompareNode#tryConstantFoldPrimitive(CanonicalCondition, ValueNode, ValueNode, boolean, NodeView)->LogicNode::: compare node try constant fold primitive
org.graalvm.compiler.nodes.calc.CompareNode#isIdentityComparison()->boolean:::Does this operation represent an identity check such that for x == y, x is exactly the same thing as y
org.graalvm.compiler.nodes.calc.CompareNode.CompareOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: compare op canonical
org.graalvm.compiler.nodes.calc.CompareNode.CompareOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)->LogicNode::: compare op canonicalize symmetric constant
org.graalvm.compiler.nodes.calc.CompareNode.CompareOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)->LogicNode::: compare op optimize normalize compare
org.graalvm.compiler.nodes.calc.CompareNode.CompareOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->LogicNode::: compare op duplicate modified
org.graalvm.compiler.nodes.calc.CompareNode#createCompareNode(StructuredGraph, CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, NodeView)->LogicNode::: compare node create compare node
org.graalvm.compiler.nodes.calc.CompareNode#createCompareNode(CanonicalCondition, ValueNode, ValueNode, ConstantReflectionProvider, NodeView)->LogicNode::: compare node create compare node
org.graalvm.compiler.nodes.calc.CompareNode#createCompareNode(StructuredGraph, ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, ValueNode, ValueNode, NodeView)->LogicNode::: compare node create compare node
org.graalvm.compiler.nodes.calc.CompareNode#createCompareNode(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, ValueNode, ValueNode, NodeView)->LogicNode::: compare node create compare node
org.graalvm.compiler.nodes.calc.ConditionalNode#condition()->LogicNode::: conditional node condition
org.graalvm.compiler.nodes.calc.ConditionalNode#create(LogicNode, NodeView)->ValueNode::: conditional node create
org.graalvm.compiler.nodes.calc.ConditionalNode#create(LogicNode, ValueNode, ValueNode, NodeView)->ValueNode::: conditional node create
org.graalvm.compiler.nodes.calc.ConditionalNode#inferStamp()->boolean::: conditional node infer stamp
org.graalvm.compiler.nodes.calc.ConditionalNode#trueValue()->ValueNode::: conditional node true value
org.graalvm.compiler.nodes.calc.ConditionalNode#falseValue()->ValueNode::: conditional node false value
org.graalvm.compiler.nodes.calc.ConditionalNode#canonical(CanonicalizerTool)->ValueNode::: conditional node canonical
org.graalvm.compiler.nodes.calc.ConditionalNode#canonicalizeConditional(LogicNode, ValueNode, ValueNode, Stamp, NodeView)->ValueNode::: conditional node canonicalize conditional
org.graalvm.compiler.nodes.calc.ConditionalNode#generate(NodeLIRBuilderTool)->void::: conditional node generate
org.graalvm.compiler.nodes.calc.ConvertNode#getValue()->ValueNode::: convert node get value
org.graalvm.compiler.nodes.calc.ConvertNode#convert(Constant, ConstantReflectionProvider)->Constant::: convert node convert
org.graalvm.compiler.nodes.calc.ConvertNode#reverse(Constant, ConstantReflectionProvider)->Constant::: convert node reverse
org.graalvm.compiler.nodes.calc.ConvertNode#mayNullCheckSkipConversion()->boolean:::Checks whether a null check may skip the conversion
org.graalvm.compiler.nodes.calc.ConvertNode#isLossless()->boolean:::Check whether a conversion is lossless.
org.graalvm.compiler.nodes.calc.ConvertNode#preservesOrder(CanonicalCondition)->boolean:::Check whether a conversion preserves comparison order.
org.graalvm.compiler.nodes.calc.ConvertNode#preservesOrder(CanonicalCondition, Constant, ConstantReflectionProvider)->boolean:::Check whether a conversion preserves comparison order against a particular constant value.
org.graalvm.compiler.nodes.calc.FixedBinaryNode#getX()->ValueNode::: fixed binary node get x
org.graalvm.compiler.nodes.calc.FixedBinaryNode#getY()->ValueNode::: fixed binary node get y
org.graalvm.compiler.nodes.calc.FloatConvertNode#create(FloatConvert, ValueNode, NodeView)->ValueNode::: float convert node create
org.graalvm.compiler.nodes.calc.FloatConvertNode#getFloatConvert()->FloatConvert::: float convert node get float convert
org.graalvm.compiler.nodes.calc.FloatConvertNode#convert(Constant, ConstantReflectionProvider)->Constant::: float convert node convert
org.graalvm.compiler.nodes.calc.FloatConvertNode#reverse(Constant, ConstantReflectionProvider)->Constant::: float convert node reverse
org.graalvm.compiler.nodes.calc.FloatConvertNode#isLossless()->boolean::: float convert node is lossless
org.graalvm.compiler.nodes.calc.FloatConvertNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: float convert node canonical
org.graalvm.compiler.nodes.calc.FloatConvertNode#lower(LoweringTool)->void::: float convert node lower
org.graalvm.compiler.nodes.calc.FloatConvertNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: float convert node generate
org.graalvm.compiler.nodes.calc.FloatConvertNode#mayNullCheckSkipConversion()->boolean::: float convert node may null check skip conversion
org.graalvm.compiler.nodes.calc.FloatDivNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: float div node create
org.graalvm.compiler.nodes.calc.FloatDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: float div node canonical
org.graalvm.compiler.nodes.calc.FloatDivNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: float div node generate
org.graalvm.compiler.nodes.calc.FloatEqualsNode#create(ValueNode, ValueNode, NodeView)->LogicNode::: float equals node create
org.graalvm.compiler.nodes.calc.FloatEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)->LogicNode::: float equals node create
org.graalvm.compiler.nodes.calc.FloatEqualsNode#isIdentityComparison()->boolean::: float equals node is identity comparison
org.graalvm.compiler.nodes.calc.FloatEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: float equals node canonical
org.graalvm.compiler.nodes.calc.FloatEqualsNode.FloatEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: float equals op canonical
org.graalvm.compiler.nodes.calc.FloatEqualsNode.FloatEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: float equals op duplicate modified
org.graalvm.compiler.nodes.calc.FloatEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: float equals node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.FloatEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: float equals node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.FloatEqualsNode#tryFold(Stamp, Stamp)->TriState::: float equals node try fold
org.graalvm.compiler.nodes.calc.FloatingNode#asNode()->FloatingNode::: floating node as node
org.graalvm.compiler.nodes.calc.FloatLessThanNode#create(ValueNode, ValueNode, boolean, NodeView)->LogicNode::: float less than node create
org.graalvm.compiler.nodes.calc.FloatLessThanNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, boolean, NodeView)->LogicNode::: float less than node create
org.graalvm.compiler.nodes.calc.FloatLessThanNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: float less than node canonical
org.graalvm.compiler.nodes.calc.FloatLessThanNode.FloatLessThanOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: float less than op canonical
org.graalvm.compiler.nodes.calc.FloatLessThanNode.FloatLessThanOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: float less than op duplicate modified
org.graalvm.compiler.nodes.calc.FloatLessThanNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: float less than node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.FloatLessThanNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: float less than node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.FloatLessThanNode#tryFold(Stamp, Stamp)->TriState::: float less than node try fold
org.graalvm.compiler.nodes.calc.IntegerBelowNode#create(ValueNode, ValueNode, NodeView)->LogicNode::: integer below node create
org.graalvm.compiler.nodes.calc.IntegerBelowNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)->LogicNode::: integer below node create
org.graalvm.compiler.nodes.calc.IntegerBelowNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: integer below node canonical
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: below op duplicate modified
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#findSynonym(ValueNode, ValueNode, NodeView)->LogicNode::: below op find synonym
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#upperBound(IntegerStamp)->long::: below op upper bound
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#lowerBound(IntegerStamp)->long::: below op lower bound
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#compare(long, long)->int::: below op compare
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#min(long, long)->long::: below op min
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#max(long, long)->long::: below op max
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#cast(long, int)->long::: below op cast
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#minValue(int)->long::: below op min value
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#maxValue(int)->long::: below op max value
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#forInteger(int, long, long)->IntegerStamp::: below op for integer
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#getCondition()->CanonicalCondition::: below op get condition
org.graalvm.compiler.nodes.calc.IntegerBelowNode.BelowOp#createNode(ValueNode, ValueNode)->IntegerLowerThanNode::: below op create node
org.graalvm.compiler.nodes.calc.IntegerBelowNode#implies(boolean, LogicNode)->TriState::: integer below node implies
org.graalvm.compiler.nodes.calc.IntegerConvertNode#getInputBits()->int::: integer convert node get input bits
org.graalvm.compiler.nodes.calc.IntegerConvertNode#getResultBits()->int::: integer convert node get result bits
org.graalvm.compiler.nodes.calc.IntegerConvertNode#getOp(ValueNode)->IntegerConvertOp::: integer convert node get op
org.graalvm.compiler.nodes.calc.IntegerConvertNode#getArithmeticOp()->IntegerConvertOp::: integer convert node get arithmetic op
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convert(Constant, ConstantReflectionProvider)->Constant::: integer convert node convert
org.graalvm.compiler.nodes.calc.IntegerConvertNode#reverse(Constant, ConstantReflectionProvider)->Constant::: integer convert node reverse
org.graalvm.compiler.nodes.calc.IntegerConvertNode#foldStamp(Stamp)->Stamp::: integer convert node fold stamp
org.graalvm.compiler.nodes.calc.IntegerConvertNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: integer convert node canonical
org.graalvm.compiler.nodes.calc.IntegerConvertNode#findSynonym(IntegerConvertOp, ValueNode, int, int, Stamp)->ValueNode::: integer convert node find synonym
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convert(ValueNode, Stamp, NodeView)->ValueNode::: integer convert node convert
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convert(ValueNode, Stamp, StructuredGraph, NodeView)->ValueNode::: integer convert node convert
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convertUnsigned(ValueNode, Stamp, NodeView)->ValueNode::: integer convert node convert unsigned
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convertUnsigned(ValueNode, Stamp, StructuredGraph, NodeView)->ValueNode::: integer convert node convert unsigned
org.graalvm.compiler.nodes.calc.IntegerConvertNode#convert(ValueNode, Stamp, boolean, NodeView)->ValueNode::: integer convert node convert
org.graalvm.compiler.nodes.calc.IntegerConvertNode#invertStamp(Stamp)->Stamp::: integer convert node invert stamp
org.graalvm.compiler.nodes.calc.IntegerDivRemNode#getZeroCheck()->GuardingNode::: integer div rem node get zero check
org.graalvm.compiler.nodes.calc.IntegerDivRemNode#getOp()->Op::: integer div rem node get op
org.graalvm.compiler.nodes.calc.IntegerDivRemNode#getType()->Type::: integer div rem node get type
org.graalvm.compiler.nodes.calc.IntegerDivRemNode#lower(LoweringTool)->void::: integer div rem node lower
org.graalvm.compiler.nodes.calc.IntegerDivRemNode#canDeoptimize()->boolean::: integer div rem node can deoptimize
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#create(ValueNode, ValueNode, NodeView)->LogicNode::: integer equals node create
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)->LogicNode::: integer equals node create
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: integer equals node canonical
org.graalvm.compiler.nodes.calc.IntegerEqualsNode.IntegerEqualsOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)->LogicNode::: integer equals op optimize normalize compare
org.graalvm.compiler.nodes.calc.IntegerEqualsNode.IntegerEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: integer equals op duplicate modified
org.graalvm.compiler.nodes.calc.IntegerEqualsNode.IntegerEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: integer equals op canonical
org.graalvm.compiler.nodes.calc.IntegerEqualsNode.IntegerEqualsOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)->LogicNode::: integer equals op canonicalize symmetric constant
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: integer equals node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: integer equals node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#tryFold(Stamp, Stamp)->TriState::: integer equals node try fold
org.graalvm.compiler.nodes.calc.IntegerEqualsNode#implies(boolean, LogicNode)->TriState::: integer equals node implies
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#create(ValueNode, ValueNode, NodeView)->LogicNode::: integer less than node create
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, ValueNode, ValueNode, NodeView)->LogicNode::: integer less than node create
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: integer less than node canonical
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#subtractMayUnderflow(long, long, long)->boolean::: integer less than node subtract may underflow
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#subtractMayOverflow(long, long, long)->boolean::: integer less than node subtract may overflow
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: less than op duplicate modified
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#optimizeNormalizeCompare(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, Constant, NormalizeCompareNode, boolean, NodeView)->LogicNode::: less than op optimize normalize compare
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#findSynonym(ValueNode, ValueNode, NodeView)->LogicNode::: less than op find synonym
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#getCondition()->CanonicalCondition::: less than op get condition
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#createNode(ValueNode, ValueNode)->IntegerLowerThanNode::: less than op create node
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#upperBound(IntegerStamp)->long::: less than op upper bound
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#lowerBound(IntegerStamp)->long::: less than op lower bound
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#compare(long, long)->int::: less than op compare
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#min(long, long)->long::: less than op min
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#max(long, long)->long::: less than op max
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#cast(long, int)->long::: less than op cast
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#minValue(int)->long::: less than op min value
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#maxValue(int)->long::: less than op max value
org.graalvm.compiler.nodes.calc.IntegerLessThanNode.LessThanOp#forInteger(int, long, long)->IntegerStamp::: less than op for integer
org.graalvm.compiler.nodes.calc.IntegerLessThanNode#implies(boolean, LogicNode)->TriState::: integer less than node implies
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode#getOp()->LowerOp::: integer lower than node get op
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: integer lower than node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: integer lower than node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode#tryFold(Stamp, Stamp)->TriState::: integer lower than node try fold
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: lower op canonical
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#upperBound(IntegerStamp)->long::: lower op upper bound
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#lowerBound(IntegerStamp)->long::: lower op lower bound
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#compare(long, long)->int::: lower op compare
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#min(long, long)->long::: lower op min
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#max(long, long)->long::: lower op max
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#min(long, long, int)->long::: lower op min
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#max(long, long, int)->long::: lower op max
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#cast(long, int)->long::: lower op cast
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#minValue(int)->long::: lower op min value
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#maxValue(int)->long::: lower op max value
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#forInteger(int, long, long)->IntegerStamp::: lower op for integer
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#getCondition()->CanonicalCondition::: lower op get condition
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#createNode(ValueNode, ValueNode)->IntegerLowerThanNode::: lower op create node
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#create(ValueNode, ValueNode, NodeView)->LogicNode::: lower op create
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#findSynonym(ValueNode, ValueNode, NodeView)->LogicNode::: lower op find synonym
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#canonicalizeRangeFlip(ValueNode, ValueNode, int, boolean, NodeView)->LogicNode:::Exploit the fact that adding the (signed) MIN_VALUE on both side flips signed and unsigned comparison
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#tryFold(Stamp, Stamp)->TriState::: lower op try fold
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#getSucceedingStampForX(IntegerStamp, IntegerStamp, boolean, boolean)->IntegerStamp::: lower op get succeeding stamp for x
org.graalvm.compiler.nodes.calc.IntegerLowerThanNode.LowerOp#getSucceedingStampForXLowerXPlusA(boolean, boolean, IntegerStamp, IntegerStamp)->IntegerStamp::: lower op get succeeding stamp for lower plus a
org.graalvm.compiler.nodes.calc.IntegerMulHighNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: integer mul high node generate
org.graalvm.compiler.nodes.calc.IntegerMulHighNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: integer mul high node canonical
org.graalvm.compiler.nodes.calc.IntegerTestNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: integer test node canonical
org.graalvm.compiler.nodes.calc.IntegerTestNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: integer test node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.IntegerTestNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: integer test node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.IntegerTestNode#tryFold(Stamp, Stamp)->TriState::: integer test node try fold
org.graalvm.compiler.nodes.calc.IsNullNode#nullConstant()->JavaConstant::: is null node null constant
org.graalvm.compiler.nodes.calc.IsNullNode#create(ValueNode)->LogicNode::: is null node create
org.graalvm.compiler.nodes.calc.IsNullNode#create(ValueNode, JavaConstant)->LogicNode::: is null node create
org.graalvm.compiler.nodes.calc.IsNullNode#generate(NodeLIRBuilderTool)->void::: is null node generate
org.graalvm.compiler.nodes.calc.IsNullNode#verify()->boolean::: is null node verify
org.graalvm.compiler.nodes.calc.IsNullNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: is null node canonical
org.graalvm.compiler.nodes.calc.IsNullNode#virtualize(VirtualizerTool)->void::: is null node virtualize
org.graalvm.compiler.nodes.calc.IsNullNode#getSucceedingStampForValue(boolean)->Stamp::: is null node get succeeding stamp for value
org.graalvm.compiler.nodes.calc.IsNullNode#tryFold(Stamp)->TriState::: is null node try fold
org.graalvm.compiler.nodes.calc.LeftShiftNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: left shift node create
org.graalvm.compiler.nodes.calc.LeftShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: left shift node canonical
org.graalvm.compiler.nodes.calc.LeftShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: left shift node generate
org.graalvm.compiler.nodes.calc.MulNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: mul node create
org.graalvm.compiler.nodes.calc.MulNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: mul node canonical
org.graalvm.compiler.nodes.calc.MulNode#canonical(Stamp, ValueNode, long, NodeView)->ValueNode::: mul node canonical
org.graalvm.compiler.nodes.calc.MulNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: mul node generate
org.graalvm.compiler.nodes.calc.NarrowableArithmeticNode#isNarrowable(int)->boolean:::Check whether this operation can be narrowed to resultBits bit without loss of precision.
org.graalvm.compiler.nodes.calc.NarrowNode#create(ValueNode, int, NodeView)->ValueNode::: narrow node create
org.graalvm.compiler.nodes.calc.NarrowNode#create(ValueNode, int, int, NodeView)->ValueNode::: narrow node create
org.graalvm.compiler.nodes.calc.NarrowNode#isLossless()->boolean::: narrow node is lossless
org.graalvm.compiler.nodes.calc.NarrowNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: narrow node canonical
org.graalvm.compiler.nodes.calc.NarrowNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: narrow node generate
org.graalvm.compiler.nodes.calc.NarrowNode#mayNullCheckSkipConversion()->boolean::: narrow node may null check skip conversion
org.graalvm.compiler.nodes.calc.NegateNode#create(ValueNode, NodeView)->ValueNode::: negate node create
org.graalvm.compiler.nodes.calc.NegateNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: negate node canonical
org.graalvm.compiler.nodes.calc.NegateNode#findSynonym(ValueNode, NodeView)->ValueNode::: negate node find synonym
org.graalvm.compiler.nodes.calc.NegateNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: negate node generate
org.graalvm.compiler.nodes.calc.NegateNode#invertStamp(Stamp)->Stamp::: negate node invert stamp
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#create(ValueNode, ValueNode, boolean, JavaKind, ConstantReflectionProvider)->ValueNode::: normalize compare node create
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#tryConstantFold(ValueNode, ValueNode, boolean, JavaKind, ConstantReflectionProvider)->ValueNode::: normalize compare node try constant fold
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: normalize compare node canonical
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#inferStamp()->boolean::: normalize compare node infer stamp
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#foldStamp(Stamp, Stamp)->Stamp::: normalize compare node fold stamp
org.graalvm.compiler.nodes.calc.NormalizeCompareNode#isUnorderedLess()->boolean::: normalize compare node is unordered less
org.graalvm.compiler.nodes.calc.NotNode#create(ValueNode)->ValueNode::: not node create
org.graalvm.compiler.nodes.calc.NotNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: not node canonical
org.graalvm.compiler.nodes.calc.NotNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: not node generate
org.graalvm.compiler.nodes.calc.NotNode#invertStamp(Stamp)->Stamp::: not node invert stamp
org.graalvm.compiler.nodes.calc.ObjectEqualsNode#create(ValueNode, ValueNode, ConstantReflectionProvider, NodeView)->LogicNode::: object equals node create
org.graalvm.compiler.nodes.calc.ObjectEqualsNode#create(ConstantReflectionProvider, MetaAccessProvider, OptionValues, ValueNode, ValueNode, NodeView)->LogicNode::: object equals node create
org.graalvm.compiler.nodes.calc.ObjectEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: object equals node canonical
org.graalvm.compiler.nodes.calc.ObjectEqualsNode.ObjectEqualsOp#canonicalizeSymmetricConstant(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, Constant, ValueNode, boolean, boolean, NodeView)->LogicNode::: object equals op canonicalize symmetric constant
org.graalvm.compiler.nodes.calc.ObjectEqualsNode.ObjectEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: object equals op duplicate modified
org.graalvm.compiler.nodes.calc.ObjectEqualsNode#virtualizeComparison(ValueNode, ValueNode, StructuredGraph, VirtualizerTool)->LogicNode::: object equals node virtualize comparison
org.graalvm.compiler.nodes.calc.ObjectEqualsNode#virtualize(VirtualizerTool)->void::: object equals node virtualize
org.graalvm.compiler.nodes.calc.OrNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: or node create
org.graalvm.compiler.nodes.calc.OrNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: or node canonical
org.graalvm.compiler.nodes.calc.OrNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: or node generate
org.graalvm.compiler.nodes.calc.PointerEqualsNode#create(ValueNode, ValueNode, NodeView)->LogicNode::: pointer equals node create
org.graalvm.compiler.nodes.calc.PointerEqualsNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->Node::: pointer equals node canonical
org.graalvm.compiler.nodes.calc.PointerEqualsNode.PointerEqualsOp#canonical(ConstantReflectionProvider, MetaAccessProvider, OptionValues, Integer, CanonicalCondition, boolean, ValueNode, ValueNode, NodeView)->LogicNode::: pointer equals op canonical
org.graalvm.compiler.nodes.calc.PointerEqualsNode.PointerEqualsOp#duplicateModified(ValueNode, ValueNode, boolean, NodeView)->CompareNode::: pointer equals op duplicate modified
org.graalvm.compiler.nodes.calc.PointerEqualsNode#findSynonym(ValueNode, ValueNode, NodeView)->LogicNode::: pointer equals node find synonym
org.graalvm.compiler.nodes.calc.PointerEqualsNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: pointer equals node get succeeding stamp for x
org.graalvm.compiler.nodes.calc.PointerEqualsNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: pointer equals node get succeeding stamp for y
org.graalvm.compiler.nodes.calc.PointerEqualsNode#tryFold(Stamp, Stamp)->TriState::: pointer equals node try fold
org.graalvm.compiler.nodes.calc.ReinterpretNode#create(JavaKind, ValueNode, NodeView)->ValueNode::: reinterpret node create
org.graalvm.compiler.nodes.calc.ReinterpretNode#create(Stamp, ValueNode, NodeView)->ValueNode::: reinterpret node create
org.graalvm.compiler.nodes.calc.ReinterpretNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: reinterpret node canonical
org.graalvm.compiler.nodes.calc.ReinterpretNode#canonical(ReinterpretNode, Stamp, ValueNode, NodeView)->ValueNode::: reinterpret node canonical
org.graalvm.compiler.nodes.calc.ReinterpretNode#inferStamp()->boolean::: reinterpret node infer stamp
org.graalvm.compiler.nodes.calc.ReinterpretNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: reinterpret node generate
org.graalvm.compiler.nodes.calc.ReinterpretNode#reinterpret(JavaKind, ValueNode)->ValueNode::: reinterpret node reinterpret
org.graalvm.compiler.nodes.calc.RemNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: rem node create
org.graalvm.compiler.nodes.calc.RemNode#lower(LoweringTool)->void::: rem node lower
org.graalvm.compiler.nodes.calc.RemNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: rem node generate
org.graalvm.compiler.nodes.calc.RightShiftNode#create(ValueNode, int, NodeView)->ValueNode::: right shift node create
org.graalvm.compiler.nodes.calc.RightShiftNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: right shift node create
org.graalvm.compiler.nodes.calc.RightShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: right shift node canonical
org.graalvm.compiler.nodes.calc.RightShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: right shift node generate
org.graalvm.compiler.nodes.calc.RightShiftNode#isNarrowable(int)->boolean::: right shift node is narrowable
org.graalvm.compiler.nodes.calc.ShiftNode#getOp(ValueNode)->ShiftOp::: shift node get op
org.graalvm.compiler.nodes.calc.ShiftNode#getArithmeticOp()->ShiftOp::: shift node get arithmetic op
org.graalvm.compiler.nodes.calc.ShiftNode#foldStamp(Stamp, Stamp)->Stamp::: shift node fold stamp
org.graalvm.compiler.nodes.calc.ShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: shift node canonical
org.graalvm.compiler.nodes.calc.ShiftNode#canonical(ShiftOp, Stamp, ValueNode, ValueNode, NodeView)->ValueNode::: shift node canonical
org.graalvm.compiler.nodes.calc.ShiftNode#getShiftAmountMask()->int::: shift node get shift amount mask
org.graalvm.compiler.nodes.calc.ShiftNode#isNarrowable(int)->boolean::: shift node is narrowable
org.graalvm.compiler.nodes.calc.SignedDivNode#create(ValueNode, ValueNode, GuardingNode, NodeView)->ValueNode::: signed div node create
org.graalvm.compiler.nodes.calc.SignedDivNode#inferStamp()->boolean::: signed div node infer stamp
org.graalvm.compiler.nodes.calc.SignedDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: signed div node canonical
org.graalvm.compiler.nodes.calc.SignedDivNode#canonical(SignedDivNode, ValueNode, ValueNode, GuardingNode, NodeView)->ValueNode::: signed div node canonical
org.graalvm.compiler.nodes.calc.SignedDivNode#canonical(ValueNode, long, NodeView)->ValueNode::: signed div node canonical
org.graalvm.compiler.nodes.calc.SignedDivNode#generate(NodeLIRBuilderTool)->void::: signed div node generate
org.graalvm.compiler.nodes.calc.SignedRemNode#create(ValueNode, ValueNode, GuardingNode, NodeView)->ValueNode::: signed rem node create
org.graalvm.compiler.nodes.calc.SignedRemNode#inferStamp()->boolean::: signed rem node infer stamp
org.graalvm.compiler.nodes.calc.SignedRemNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: signed rem node canonical
org.graalvm.compiler.nodes.calc.SignedRemNode#generate(NodeLIRBuilderTool)->void::: signed rem node generate
org.graalvm.compiler.nodes.calc.SignExtendNode#create(ValueNode, int, NodeView)->ValueNode::: sign extend node create
org.graalvm.compiler.nodes.calc.SignExtendNode#create(ValueNode, int, int, NodeView)->ValueNode::: sign extend node create
org.graalvm.compiler.nodes.calc.SignExtendNode#isLossless()->boolean::: sign extend node is lossless
org.graalvm.compiler.nodes.calc.SignExtendNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: sign extend node canonical
org.graalvm.compiler.nodes.calc.SignExtendNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: sign extend node generate
org.graalvm.compiler.nodes.calc.SignExtendNode#mayNullCheckSkipConversion()->boolean::: sign extend node may null check skip conversion
org.graalvm.compiler.nodes.calc.SqrtNode#create(ValueNode, NodeView)->ValueNode::: sqrt node create
org.graalvm.compiler.nodes.calc.SqrtNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: sqrt node generate
org.graalvm.compiler.nodes.calc.SubNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: sub node create
org.graalvm.compiler.nodes.calc.SubNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: sub node canonical
org.graalvm.compiler.nodes.calc.SubNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: sub node generate
org.graalvm.compiler.nodes.calc.TernaryNode#getX()->ValueNode::: ternary node get x
org.graalvm.compiler.nodes.calc.TernaryNode#getY()->ValueNode::: ternary node get y
org.graalvm.compiler.nodes.calc.TernaryNode#getZ()->ValueNode::: ternary node get z
org.graalvm.compiler.nodes.calc.TernaryNode#setX(ValueNode)->void::: ternary node set x
org.graalvm.compiler.nodes.calc.TernaryNode#setY(ValueNode)->void::: ternary node set y
org.graalvm.compiler.nodes.calc.TernaryNode#setZ(ValueNode)->void::: ternary node set z
org.graalvm.compiler.nodes.calc.TernaryNode#inferStamp()->boolean::: ternary node infer stamp
org.graalvm.compiler.nodes.calc.TernaryNode#foldStamp(Stamp, Stamp, Stamp)->Stamp:::Compute an improved stamp for this node using the passed in stamps
org.graalvm.compiler.nodes.calc.UnaryArithmeticNode#getOp(ValueNode)->UnaryOp::: unary arithmetic node get op
org.graalvm.compiler.nodes.calc.UnaryArithmeticNode#getArithmeticOp()->UnaryOp::: unary arithmetic node get arithmetic op
org.graalvm.compiler.nodes.calc.UnaryArithmeticNode#foldStamp(Stamp)->Stamp::: unary arithmetic node fold stamp
org.graalvm.compiler.nodes.calc.UnaryArithmeticNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: unary arithmetic node canonical
org.graalvm.compiler.nodes.calc.UnaryArithmeticNode#findSynonym(ValueNode, UnaryOp)->ValueNode::: unary arithmetic node find synonym
org.graalvm.compiler.nodes.calc.UnaryNode#getValue()->ValueNode::: unary node get value
org.graalvm.compiler.nodes.calc.UnaryNode#setValue(ValueNode)->void::: unary node set value
org.graalvm.compiler.nodes.calc.UnaryNode#inferStamp()->boolean::: unary node infer stamp
org.graalvm.compiler.nodes.calc.UnaryNode#foldStamp(Stamp)->Stamp:::Compute an improved for this node using the passed in stamp
org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode#create(ValueNode, boolean, NodeView)->ValueNode::: unpack endian half node create
org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode#isFirstHalf()->boolean::: unpack endian half node is first half
org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode#canonical(CanonicalizerTool, ValueNode)->Node::: unpack endian half node canonical
org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode#lower(LoweringTool)->void::: unpack endian half node lower
org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode#lower(ByteOrder)->void::: unpack endian half node lower
org.graalvm.compiler.nodes.calc.UnsignedDivNode#create(ValueNode, ValueNode, GuardingNode, NodeView)->ValueNode::: unsigned div node create
org.graalvm.compiler.nodes.calc.UnsignedDivNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: unsigned div node canonical
org.graalvm.compiler.nodes.calc.UnsignedDivNode#generate(NodeLIRBuilderTool)->void::: unsigned div node generate
org.graalvm.compiler.nodes.calc.UnsignedRemNode#create(ValueNode, ValueNode, GuardingNode, NodeView)->ValueNode::: unsigned rem node create
org.graalvm.compiler.nodes.calc.UnsignedRemNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: unsigned rem node canonical
org.graalvm.compiler.nodes.calc.UnsignedRemNode#canonical(UnsignedRemNode, ValueNode, ValueNode, GuardingNode, Stamp, NodeView)->ValueNode::: unsigned rem node canonical
org.graalvm.compiler.nodes.calc.UnsignedRemNode#generate(NodeLIRBuilderTool)->void::: unsigned rem node generate
org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: unsigned right shift node create
org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: unsigned right shift node canonical
org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: unsigned right shift node generate
org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode#isNarrowable(int)->boolean::: unsigned right shift node is narrowable
org.graalvm.compiler.nodes.calc.XorNode#create(ValueNode, ValueNode, NodeView)->ValueNode::: xor node create
org.graalvm.compiler.nodes.calc.XorNode#canonical(CanonicalizerTool, ValueNode, ValueNode)->ValueNode::: xor node canonical
org.graalvm.compiler.nodes.calc.XorNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: xor node generate
org.graalvm.compiler.nodes.calc.ZeroExtendNode#create(ValueNode, int, NodeView)->ValueNode::: zero extend node create
org.graalvm.compiler.nodes.calc.ZeroExtendNode#create(ValueNode, int, int, NodeView)->ValueNode::: zero extend node create
org.graalvm.compiler.nodes.calc.ZeroExtendNode#create(ValueNode, int, int, NodeView, boolean)->ValueNode::: zero extend node create
org.graalvm.compiler.nodes.calc.ZeroExtendNode#isLossless()->boolean::: zero extend node is lossless
org.graalvm.compiler.nodes.calc.ZeroExtendNode#isInputAlwaysPositive()->boolean::: zero extend node is input always positive
org.graalvm.compiler.nodes.calc.ZeroExtendNode#preservesOrder(CanonicalCondition)->boolean::: zero extend node preserves order
org.graalvm.compiler.nodes.calc.ZeroExtendNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: zero extend node canonical
org.graalvm.compiler.nodes.calc.ZeroExtendNode#generate(NodeLIRBuilderTool, ArithmeticLIRGeneratorTool)->void::: zero extend node generate
org.graalvm.compiler.nodes.calc.ZeroExtendNode#mayNullCheckSkipConversion()->boolean::: zero extend node may null check skip conversion
