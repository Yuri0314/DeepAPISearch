SPARCDeoptimizeOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: deoptimize op emit code:::SPARCCall->lookupForeignCall->directCall
SPARCHotSpotBackend.SizeEstimateStatistics#add(Class, int, DebugContext)::: size estimate statistics add:::name->getSimpleName->c->getSimpleName->m->counters->DebugContext->counter->computeIfAbsent->m->add
SPARCHotSpotBackend#newFrameMapBuilder(RegisterConfig)::: hot spot backend new frame map builder:::registerConfigNonNull->getCodeCache->getRegisterConfig->frameMap->getCodeCache->new->SPARCFrameMap->return->getCodeCache->new->SPARCFrameMapBuilder
SPARCHotSpotBackend#newLIRGenerator(LIRGenerationResult)::: hot spot backend new generator:::return->getProviders->getRuntime->getVMConfig->new->SPARCHotSpotLIRGenerator
SPARCHotSpotBackend#newLIRGenerationResult(CompilationIdentifier, LIR, RegisterConfig, StructuredGraph, Object)::: hot spot backend new generation result:::return->newFrameMapBuilder->makeCallingConvention->config->graph->getMethods->requiresReservedStackCheck->new->HotSpotLIRGenerationResult
SPARCHotSpotBackend#newNodeLIRBuilder(StructuredGraph, LIRGeneratorTool)::: hot spot backend new node builder:::return->new->SPARCNodeMatchRules->new->SPARCHotSpotNodeLIRBuilder
SPARCHotSpotBackend#bangStackWithOffset(CompilationResultBuilder, int)::: hot spot backend bang stack with offset:::masm->address->new->SPARCAddress->if->SPARCAssembler->address->getDisplacement->isSimm13->masm->stx->else->try->sc->masm->getScratchRegister->scratch->sc->getRegister->masm->address->getDisplacement->setx->masm->new->SPARCAddress->stx->catch->finally
SPARCHotSpotBackend.HotSpotFrameContext#hasFrame()::: hot spot frame context has frame:::return
SPARCHotSpotBackend.HotSpotFrameContext#enter(CompilationResultBuilder)::: hot spot frame context enter:::frameSize->totalFrameSize->stackpointerChange->masm->if->emitStackOverflowCheck->if->SPARCAssembler->isSimm13->masm->save->else->try->sc->masm->getScratchRegister->scratch->sc->getRegister->masm->setx->masm->save->catch->finally->if->ZapStackOnMethodEntry->crb->getOptions->getValue->slotSize->for->i
SPARCHotSpotBackend.HotSpotFrameContext#leave(CompilationResultBuilder)::: hot spot frame context leave:::masm->masm->restoreWindow
SPARCHotSpotBackend#newCompilationResultBuilder(LIRGenerationResult, FrameMap, CompilationResult, CompilationResultBuilderFactory)::: hot spot backend new compilation result builder:::gen->lir->gen->getLIR->stub->gen->getStub->masm->getTarget->new->SPARCMacroAssembler->frameContext->new->HotSpotFrameContext->dataBuilder->getCodeCache->getTarget->new->HotSpotDataBuilder->options->lir->getOptions->debug->lir->getDebug->crb->factory->getProviders->getCodeCache->getProviders->getForeignCalls->createBuilder->crb->frameMap->totalFrameSize->setTotalFrameSize->crb->gen->getMaxInterpreterFrameSize->setMaxInterpreterFrameSize->deoptimizationRescueSlot->gen->getDeoptimizationRescueSlot->if->setCustomStackAreaOffset->if->destroyedCallerRegisters->gatherDestroyedCallerRegisters->calleeSaveInfo->gen->getCalleeSaveInfo->updateStub->return
SPARCHotSpotBackend#registerSizePredictionValidator(CompilationResultBuilder, DebugContext):::Registers a verifier which checks if the LIRInstructions estimate of constants size is greater or equal to the actual one.:::state->new->ValidationState->crb->state->before->state->after->setOpCallback->return
SPARCHotSpotBackend#calculateDataSectionSize(DataSection)::: hot spot backend calculate data section size:::sum->foreach->d->getSize->return
SPARCHotSpotBackend#emitCode(CompilationResultBuilder, LIR, ResolvedJavaMethod)::: hot spot backend emit code:::masm->stuffDelayedControlTransfers->constantSize->calculateConstantSize->canUseImmediateConstantLoad->masm->setImmediateConstantLoad->frameMap->regConfig->frameMap->getRegisterConfig->unverifiedStub->installedCodeOwner->isStatic->new->Label->for->i->profileInstructions->frameContext->foreignCalls->getProviders->getForeignCalls->if->crb->recordMark->SPARCCall->foreignCalls->lookupForeignCall->directCall->crb->recordMark->SPARCCall->foreignCalls->lookupForeignCall->directCall->else->if->masm->bind->try->sc->masm->getScratchRegister->scratch->sc->getRegister->SPARCCall->foreignCalls->lookupForeignCall->indirectJmp->catch->finally->masm->peephole
SPARCHotSpotBackend#calculateConstantSize(LIR)::: hot spot backend calculate constant size:::size->foreach->lir->codeEmittingOrder->if->continue->foreach->lir->getLIRforBlock->if->pred->estimateSize->if->return
SPARCHotSpotBackend#resetDelayedControlTransfers(LIR)::: hot spot backend reset delayed control transfers:::foreach->lir->codeEmittingOrder->if->continue->foreach->lir->getLIRforBlock->if->resetState
SPARCHotSpotBackend#stuffDelayedControlTransfers(LIR):::Fix-up over whole LIR.:::foreach->l->codeEmittingOrder->if->stuffDelayedControlTransfers
SPARCHotSpotBackend#stuffDelayedControlTransfers(LIR, AbstractBlockBase):::Tries to put DelayedControlTransfer instructions and DelayableLIRInstructions together:::instructions->l->getLIRforBlock->if->instructions->size->acc->new->LIRDependencyAccumulator->delayedTransfer->delayTransferPosition->for->i->instructions->size
SPARCHotSpotBackend#leavesRegisterWindow(LIRInstruction)::: hot spot backend leaves register window:::return->leavesRegisterWindow
SPARCHotSpotBackend.LIRDependencyAccumulator#start(LIRInstruction)::: dependency accumulator start:::inputs->clear->initial->visitEachInput->initial->visitEachTemp->initial->visitEachAlive
SPARCHotSpotBackend.LIRDependencyAccumulator#add(LIRInstruction):::Adds the inputs of lir instruction to the accumulator and returns, true if there was any overlap of parameters.:::inst->visitEachOutput->inst->visitEachTemp->inst->visitEachInput->inst->visitEachAlive->return
SPARCHotSpotBackend#newRegisterAllocationConfig(RegisterConfig, String[])::: hot spot backend new register allocation config:::registerConfigNonNull->getCodeCache->getRegisterConfig->return->new->SPARCHotSpotRegisterAllocationConfig
SPARCHotSpotBackend#translateToCallerRegisters(EconomicSet)::: hot spot backend translate to caller registers:::callerRegisters->EconomicSet->calleeRegisters->size->create->foreach->if->else->if->else->if->callerRegisters->translateInputToOutputRegister->add->else->callerRegisters->add->return
SPARCHotSpotBackend#translateInputToOutputRegister(Register)::: hot spot backend translate input to output register:::return->getTarget->getRegisters->get
SPARCHotSpotBackendFactory#getName()::: hot spot backend factory get name:::return
SPARCHotSpotBackendFactory#getArchitecture()::: hot spot backend factory get architecture:::return
SPARCHotSpotBackendFactory#createBackend(HotSpotGraalRuntimeProvider, CompilerConfiguration, HotSpotJVMCIRuntime, HotSpotBackend)::: hot spot backend factory create backend:::config->runtime->getVMConfig->jvmci->jvmciRuntime->getHostJVMCIBackend->registers->createRegisters->metaAccess->jvmci->getMetaAccess->codeCache->jvmci->getCodeCache->target->codeCache->getTarget->constantReflection->jvmci->getConstantReflection->constantFieldProvider->createConstantFieldProvider->nativeABICallerSaveRegisters->codeCache->getRegisterConfig->createNativeABICallerSaveRegisters->wordTypes->createWordTypes->foreignCalls->new->SPARCHotSpotForeignCallsProvider->lowerer->createLowerer->stampProvider->createStampProvider->gc->createGCProvider->p->new->Providers->snippetReflection->createSnippetReflection->bytecodeProvider->createBytecodeProvider->replacements->createReplacements->plugins->runtime->getOptions->createGraphBuilderPlugins->replacements->setGraphBuilderPlugins->suites->createSuites->providers->new->HotSpotProviders->replacements->setProviders->return->createBackend
SPARCHotSpotBackendFactory#createGraphBuilderPlugins(CompilerConfiguration, GraalHotSpotVMConfig, HotSpotMetaAccessProvider, HotSpotConstantReflectionProvider, HotSpotForeignCallsProvider, HotSpotSnippetReflectionProvider, HotSpotReplacementsImpl, HotSpotWordTypes, OptionValues)::: hot spot backend factory create graph builder plugins:::plugins->HotSpotGraphBuilderPlugins->create->SPARCGraphBuilderPlugins->replacements->getDefaultReplacementBytecodeProvider->register->return
SPARCHotSpotBackendFactory#createSuites(GraalHotSpotVMConfig, HotSpotGraalRuntimeProvider, CompilerConfiguration, Plugins, Replacements)::: hot spot backend factory create suites:::return->new->SPARCSuitesCreator->new->SPARCAddressLowering->new->AddressLoweringPhase->new->AddressLoweringHotSpotSuitesProvider
SPARCHotSpotBackendFactory#createBackend(GraalHotSpotVMConfig, HotSpotGraalRuntimeProvider, HotSpotProviders)::: hot spot backend factory create backend:::return->new->SPARCHotSpotBackend
SPARCHotSpotBackendFactory#createLowerer(HotSpotGraalRuntimeProvider, HotSpotMetaAccessProvider, HotSpotForeignCallsProvider, HotSpotRegistersProvider, HotSpotConstantReflectionProvider, TargetDescription)::: hot spot backend factory create lowerer:::return->new->SPARCHotSpotLoweringProvider
SPARCHotSpotBackendFactory#createRegisters()::: hot spot backend factory create registers:::return->new->HotSpotRegisters
SPARCHotSpotBackendFactory#createNativeABICallerSaveRegisters(GraalHotSpotVMConfig, RegisterConfig)::: hot spot backend factory create native caller save registers:::callerSavedRegisters->new->HashSet<>->addTo->addTo->callerSavedRegisters->add->callerSavedRegisters->add->callerSavedRegisters->add->nativeABICallerSaveRegisters->callerSavedRegisters->size->new->ValueArr->i->foreach->reg->asValue->return
SPARCHotSpotBackendFactory#toString()::: hot spot backend factory to string:::return
SPARCHotSpotCounterOp#emitCode(CompilationResultBuilder)::: hot spot counter op emit code:::masm->target->countersArrayAddr->new->SPARCAddress->try->scratch->masm->getScratchRegister->countersArrayReg->scratch->getRegister->masm->ldx->emitter->new->IncrementEmitter->forEachCounter->catch->finally
SPARCHotSpotCounterOp#emitIncrement(int, SPARCMacroAssembler, SPARCAddress, Value)::: hot spot counter op emit increment:::try->scratch->masm->getScratchRegister->counterReg->scratch->getRegister->masm->ldx->masm->position->if->isJavaConstant->masm->asJavaConstant->asInt->add->else->masm->asRegister->add->masm->stx->catch->finally
SPARCHotSpotCounterOp#patchCounterIncrement(Assembler, int[]):::Patches the increment value in the instruction emitted by the #emitIncrement(int, SPARCMacroAssembler, SPARCAddress, Value) method:::for->i
SPARCHotSpotCounterOp#getCounterPatchOffsets()::: hot spot counter op get counter patch offsets:::return
SPARCHotSpotCounterOp.IncrementEmitter#apply(int, Value, int)::: increment emitter apply:::counterAddr->relativeDisplacement->if->isSimm13->new->SPARCAddress->else->try->scratch->masm->getScratchRegister->tempOffsetRegister->scratch->getRegister->masm->setx->masm->add->catch->finally->new->SPARCAddress->emitIncrement
SPARCHotSpotCRuntimeCallEpilogueOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot runtime call epilogue op emit code:::SPARCMove->thread->LIRKind->value->asValue->move->masm->new->SPARCAddress->stx->masm->new->SPARCAddress->stx->masm->new->SPARCAddress->stw
SPARCHotSpotCRuntimeCallPrologueOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot runtime call prologue op emit code:::scratchRegister->asRegister->masm->add->masm->new->SPARCAddress->stx->SPARCMove->thread->LIRKind->value->asValue->getDelayedControlTransfer->move
SPARCHotSpotDeoptimizeCallerOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot deoptimize caller op emit code:::leaveFrame->try->sc->masm->getScratchRegister->scratch->sc->getRegister->SPARCCall->lookupForeignCall->indirectJmp->catch->finally
SPARCHotspotDirectStaticCallOp#emitCallPrefixCode(CompilationResultBuilder, SPARCMacroAssembler)::: hotspot direct static call op emit call prefix code:::crb->recordMark
SPARCHotspotDirectVirtualCallOp#emitCallPrefixCode(CompilationResultBuilder, SPARCMacroAssembler)::: hotspot direct virtual call op emit call prefix code:::crb->recordMark->scratchRegister->masm->setx
SPARCHotSpotEpilogueOp#leaveFrame(CompilationResultBuilder)::: hot spot epilogue op leave frame:::leave
SPARCHotSpotForeignCallsProvider#initialize(HotSpotProviders, OptionValues)::: hot spot foreign calls provider initialize:::config->runtime->getVMConfig->target->providers->getCodeCache->getTarget->word->getWordKind->outgoingException->o0->LIRKind->fromJavaKind->asValue->outgoingExceptionPc->o1->LIRKind->value->asValue->incomingException->i0->LIRKind->fromJavaKind->asValue->incomingExceptionPc->i1->LIRKind->value->asValue->outgoingExceptionCc->new->CallingConvention->incomingExceptionCc->new->CallingConvention->any->new->HotSpotForeignCallLinkageImpl->register->any->new->HotSpotForeignCallLinkageImpl->register->if->any->registerForeignCall->if->any->registerForeignCall->super->initialize
SPARCHotSpotForeignCallsProvider#getNativeABICallerSaveRegisters()::: hot spot foreign calls provider get native caller save registers:::return
SPARCHotSpotJumpToExceptionHandlerInCallerOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot jump to exception handler in caller op emit code:::dst->new->SPARCAddress->try->scratch->masm->getScratchRegister->scratchReg->scratch->getRegister->masm->lduw->masm->cmp->masm->movcc->catch->finally->masm->asRegister->jmpl->leaveFrame
SPARCHotSpotJumpToExceptionHandlerOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot jump to exception handler op emit code:::addrRegister->asRegister->masm->jmp->masm->restoreWindow
SPARCHotSpotLeaveCurrentStackFrameOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot leave current stack frame op emit code:::masm->mov->masm->mov->masm->mov->masm->mov->masm->mov->leave
SPARCHotSpotLeaveCurrentStackFrameOp#leavesRegisterWindow()::: hot spot leave current stack frame op leaves register window:::return
SPARCHotSpotLeaveDeoptimizedStackFrameOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot leave deoptimized stack frame op emit code:::masm->mov->masm->mov->masm->mov->masm->mov->masm->mov->masm->restoreWindow
SPARCHotSpotLeaveDeoptimizedStackFrameOp#leavesRegisterWindow()::: hot spot leave deoptimized stack frame op leaves register window:::return
SPARCHotSpotLIRGenerator#getProviders()::: hot spot generator get providers:::return->super->getProviders
SPARCHotSpotLIRGenerator#getLockSlot(int)::: hot spot generator get lock slot:::return->getLockStack->makeLockSlot
SPARCHotSpotLIRGenerator#getLockStack()::: hot spot generator get lock stack:::return->debugInfoBuilder->lockStack
SPARCHotSpotLIRGenerator#needOnlyOopMaps()::: hot spot generator need only oop maps:::return->getStub
SPARCHotSpotLIRGenerator#getStub()::: hot spot generator get stub:::return->getResult->getStub
SPARCHotSpotLIRGenerator#getResult()::: hot spot generator get result:::return->super->getResult
SPARCHotSpotLIRGenerator#beforeRegisterAllocation()::: hot spot generator before register allocation:::super->beforeRegisterAllocation->hasDebugInfo->getResult->getLIR->hasDebugInfo->if->getResult->getResult->getFrameMapBuilder->allocateDeoptimizationRescueSlot->setDeoptimizationRescueSlot->getResult->debugInfoBuilder->maxInterpreterFrameSize->setMaxInterpreterFrameSize
SPARCHotSpotLIRGenerator#emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...)::: hot spot generator emit foreign call:::hotspotLinkage->result->debugInfo->if->hotspotLinkage->needsDebugInfo->if->linkage->destroysRegisters->hotspotLinkage->needsJavaFrameAnchor->registers->getProviders->getRegisters->thread->registers->getThreadRegister->threadTemp->LIRKind->value->newVariable->stackPointer->registers->getStackPointerRegister->spScratch->LIRKind->target->getWordKind->value->newVariable->config->threadLastJavaSpOffset->new->SPARCHotSpotCRuntimeCallPrologueOp->append->super->emitForeignCall->config->threadLastJavaSpOffset->config->threadLastJavaPcOffset->config->threadJavaFrameAnchorFlagsOffset->new->SPARCHotSpotCRuntimeCallEpilogueOp->append->else->super->emitForeignCall->return
SPARCHotSpotLIRGenerator#emitReturn(JavaKind, Value)::: hot spot generator emit return:::operand->if->input->getValueKind->resultOperandFor->emitMove->thread->getProviders->getRegisters->getThreadRegister->getStub->getSafepointAddressValue->getResult->requiresReservedStackAccessCheck->new->SPARCHotSpotReturnOp->append
SPARCHotSpotLIRGenerator#emitTailcall(Value[], Value)::: hot spot generator emit tailcall:::throw->GraalError->unimplemented
SPARCHotSpotLIRGenerator#emitUnwind(Value)::: hot spot generator emit unwind:::linkage->getForeignCalls->lookupForeignCall->linkageCc->linkage->getOutgoingCallingConvention->exceptionParameter->linkageCc->getArgument->emitMove->new->SPARCHotSpotUnwindOp->append
SPARCHotSpotLIRGenerator#moveDeoptValuesToThread(Value, Value)::: hot spot generator move deopt values to thread:::moveValueToThread->moveValueToThread
SPARCHotSpotLIRGenerator#moveValueToThread(Value, int)::: hot spot generator move value to thread:::wordKind->LIRKind->target->getWordKind->value->thread->getProviders->getRegisters->getThreadRegister->asValue->pendingDeoptAddress->new->SPARCImmediateAddressValue->v->getPlatformKind->load->new->StoreOp->append
SPARCHotSpotLIRGenerator#emitDeoptimize(Value, Value, LIRFrameState)::: hot spot generator emit deoptimize:::moveDeoptValuesToThread->target->getWordKind->new->SPARCDeoptimizeOp->append
SPARCHotSpotLIRGenerator#emitDeoptimizeCaller(DeoptimizationAction, DeoptimizationReason)::: hot spot generator emit deoptimize caller:::actionAndReason->getMetaAccess->encodeDeoptActionAndReason->emitJavaConstant->speculation->getMetaAccess->encodeSpeculation->emitJavaConstant->moveDeoptValuesToThread->new->SPARCHotSpotDeoptimizeCallerOp->append
SPARCHotSpotLIRGenerator#emitLogicCompareAndSwap(LIRKind, Value, Value, Value, Value, Value)::: hot spot generator emit logic compare and swap:::kind->newValue->getValueKind->memKind->kind->getPlatformKind->result->newValue->getValueKind->newVariable->asAllocatable->asAllocatable->asAllocatable->new->CompareAndSwapOp->append->return->emitConditionalMove
SPARCHotSpotLIRGenerator#emitValueCompareAndSwap(LIRKind, Value, Value, Value)::: hot spot generator emit value compare and swap:::kind->newValue->getValueKind->result->newValue->getValueKind->newVariable->asAllocatable->asAllocatable->asAllocatable->new->CompareAndSwapOp->append->return
SPARCHotSpotLIRGenerator#emitPrefetchAllocate(Value)::: hot spot generator emit prefetch allocate:::addr->asAddressValue->new->SPARCPrefetchOp->append
SPARCHotSpotLIRGenerator#getDeoptimizationRescueSlot()::: hot spot generator get deoptimization rescue slot:::return
SPARCHotSpotLIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)::: hot spot generator emit compare branch:::localX->localY->if->load->if->load->super->emitCompareBranch
SPARCHotSpotLIRGenerator#emitCompare(SPARCKind, Value, Value)::: hot spot generator emit compare:::localA->localB->if->isConstantValue->c->asConstant->if->equals->LIRKind->value->asValue->else->if->load->if->isConstantValue->c->asConstant->if->equals->LIRKind->value->asValue->else->if->load->return->super->emitCompare
SPARCHotSpotLIRGenerator#emitCompress(Value, CompressEncoding, boolean)::: hot spot generator emit compress:::inputKind->pointer->getValueKind->if->inputKind->isReference->result->LIRKind->compressedReference->newVariable->asAllocatable->getProviders->getRegisters->getHeapBaseRegister->asValue->new->SPARCHotSpotMove.CompressPointer->append->return->else->result->LIRKind->value->newVariable->base->if->encoding->hasBase->LIRKind->value->JavaConstant->encoding->getBase->forLong->emitLoadConstant->asAllocatable->new->SPARCHotSpotMove.CompressPointer->append->return
SPARCHotSpotLIRGenerator#emitUncompress(Value, CompressEncoding, boolean)::: hot spot generator emit uncompress:::inputKind->pointer->getValueKind->if->inputKind->isReference->result->LIRKind->reference->newVariable->asAllocatable->getProviders->getRegisters->getHeapBaseRegister->asValue->new->SPARCHotSpotMove.UncompressPointer->append->return->else->result->LIRKind->value->newVariable->base->if->encoding->hasBase->LIRKind->value->JavaConstant->encoding->getBase->forLong->emitLoadConstant->asAllocatable->new->SPARCHotSpotMove.UncompressPointer->append->return
SPARCHotSpotLIRGenerator#emitSaveRegisters(Register[], AllocatableValue[], boolean)::: hot spot generator emit save registers:::save->new->SPARCSaveRegistersOp->append->return
SPARCHotSpotLIRGenerator#emitNullCheck(Value, LIRFrameState)::: hot spot generator emit null check:::kind->address->getPlatformKind->if->encoding->config->getOopEncoding->uncompressed->emitUncompress->asAddressValue->new->NullCheckOp->append->else->super->emitNullCheck
SPARCHotSpotLIRGenerator#createBenchmarkCounter(String, String, Value)::: hot spot generator create benchmark counter:::if->return->getProviders->getRegisters->new->SPARCHotSpotCounterOp->throw->GraalError->shouldNotReachHere
SPARCHotSpotLIRGenerator#createMultiBenchmarkCounter(String[], String[], Value[])::: hot spot generator create multi benchmark counter:::if->return->getProviders->getRegisters->new->SPARCHotSpotCounterOp->throw->GraalError->shouldNotReachHere
SPARCHotSpotLIRGenerator#getSafepointAddressValue()::: hot spot generator get safepoint address value:::if->SPARCHotSpotSafepointOp->getSafepointAddressValue->return
SPARCHotSpotLIRGenerator#createStrategySwitchOp(AllocatableValue, SwitchStrategy, LabelRef[], LabelRef, Variable, Variable)::: hot spot generator create strategy switch op:::return->new->SPARCHotSpotStrategySwitchOp
SPARCHotSpotLIRGenerator#setDebugInfoBuilder(HotSpotDebugInfoBuilder)::: hot spot generator set debug info builder:::
SPARCHotSpotLIRGenerator#createZapRegisters(Register[], JavaConstant[])::: hot spot generator create zap registers:::throw->GraalError->unimplemented
SPARCHotSpotLIRGenerator#createZapArgumentSpace(StackSlot[], JavaConstant[])::: hot spot generator create zap argument space:::throw->GraalError->unimplemented
SPARCHotSpotLoweringProvider#lower(Node, LoweringTool)::: hot spot lowering provider lower:::if->else->super->lower
SPARCHotSpotMove.LoadHotSpotObjectConstantInline#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load hot spot object constant inline emit code:::crb->recordInlineDataInCode->if->constant->isCompressed->masm->asRegister->setw->else->masm->asRegister->setx
SPARCHotSpotMove.LoadHotSpotObjectConstantInline#getResult()::: load hot spot object constant inline get result:::return
SPARCHotSpotMove.LoadHotSpotObjectConstantInline#getConstant()::: load hot spot object constant inline get constant:::return
SPARCHotSpotMove.LoadHotSpotObjectConstantFromTable#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load hot spot object constant from table emit code:::try->scratch->masm->getScratchRegister->isStack->ValueUtil->isStackSlot->register->if->scratch->getRegister->else->asRegister->bytes->asRegister->loadFromConstantTable->if->masm->crb->asAddress->st->catch->finally
SPARCHotSpotMove.CompressPointer#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: compress pointer emit code:::inputRegister->asRegister->resReg->asRegister->if->encoding->hasBase->baseReg->asRegister->if->done->new->Label->if->inputRegister->equals->BPR->emit->masm->sub->masm->bind->if->encoding->getShift->masm->encoding->getShift->srlx->else->BPR->emit->masm->mov->masm->sub->if->encoding->getShift->masm->encoding->getShift->srlx->masm->bind->else->masm->sub->if->encoding->getShift->masm->encoding->getShift->srlx->else->if->encoding->getShift->masm->encoding->getShift->srlx
SPARCHotSpotMove.UncompressPointer#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: uncompress pointer emit code:::inputRegister->asRegister->resReg->asRegister->baseReg->encoding->hasBase->asRegister->encoding->getShift->emitUncompressCode
SPARCHotSpotMove.UncompressPointer#emitUncompressCode(SPARCMacroAssembler, Register, Register, Register, int, boolean)::: uncompress pointer emit uncompress code:::secondaryInput->if->masm->sllx->else->if->if->masm->add->else->done->new->Label->BPR->emit->masm->add->masm->bind
SPARCHotSpotMoveFactory#canInlineConstant(Constant)::: hot spot move factory can inline constant:::if->equals->return->else->if->return->else->return->super->canInlineConstant
SPARCHotSpotMoveFactory#createLoad(AllocatableValue, Constant)::: hot spot move factory create load:::usedSource->if->COMPRESSED_NULL->equals->else->if->isNull->else->if->constant->if->constant->isCompressed->return->new->SPARCHotSpotMove.LoadHotSpotObjectConstantInline->else->return->constantTableBaseProvider->getConstantTableBase->new->SPARCHotSpotMove.LoadHotSpotObjectConstantFromTable->else->return->super->createLoad
SPARCHotSpotNodeLIRBuilder#createDebugInfoBuilder(StructuredGraph, NodeValueMap)::: hot spot node builder create debug info builder:::lockStack->gen->getResult->getFrameMapBuilder->LIRKind->value->new->HotSpotLockStack->return->new->HotSpotDebugInfoBuilder
SPARCHotSpotNodeLIRBuilder#getGen()::: hot spot node builder get gen:::return
SPARCHotSpotNodeLIRBuilder#visitSafepointNode(SafepointNode)::: hot spot node builder visit safepoint node:::info->state->thread->getGen->getProviders->getRegisters->getThreadRegister->getGen->new->SPARCHotSpotSafepointOp->append
SPARCHotSpotNodeLIRBuilder#emitDirectCall(DirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: hot spot node builder emit direct call:::invokeKind->invokeKind->if->invokeKind->isIndirect->callTarget->targetMethod->getGen->new->SPARCHotspotDirectVirtualCallOp->append->else->resolvedMethod->callTarget->targetMethod->callTarget->targetMethod->getGen->new->SPARCHotspotDirectStaticCallOp->append
SPARCHotSpotNodeLIRBuilder#emitIndirectCall(IndirectCallTargetNode, Value, Value[], Value[], LIRFrameState)::: hot spot node builder emit indirect call:::metaspaceMethodSrc->metaspaceMethod->operand->metaspaceMethod->g5->metaspaceMethodSrc->getValueKind->asValue->gen->emitMove->targetAddressSrc->callTarget->computedAddress->operand->targetAddress->o7->targetAddressSrc->getValueKind->asValue->gen->emitMove->callTarget->targetMethod->getGen->new->SPARCIndirectCallOp->append
SPARCHotSpotNodeLIRBuilder#emitPatchReturnAddress(ValueNode)::: hot spot node builder emit patch return address:::gen->operand->load->new->SPARCHotSpotPatchReturnAddressOp->append
SPARCHotSpotNodeLIRBuilder#emitJumpToExceptionHandler(ValueNode)::: hot spot node builder emit jump to exception handler:::gen->operand->load->new->SPARCHotSpotJumpToExceptionHandlerOp->append
SPARCHotSpotNodeLIRBuilder#emitJumpToExceptionHandlerInCaller(ValueNode, ValueNode, ValueNode)::: hot spot node builder emit jump to exception handler in caller:::handler->gen->operand->load->linkage->gen->getForeignCalls->lookupForeignCall->linkageCc->linkage->getOutgoingCallingConvention->exceptionFixed->linkageCc->getArgument->exceptionPcFixed->linkageCc->getArgument->gen->operand->emitMove->gen->operand->emitMove->thread->getGen->getProviders->getRegisters->getThreadRegister->op->getGen->new->SPARCHotSpotJumpToExceptionHandlerInCallerOp->append
SPARCHotSpotNodeLIRBuilder#emitPrologue(StructuredGraph)::: hot spot node builder emit prologue:::super->emitPrologue->SPARCHotSpotSafepointOp->getGen->emitPrologue
SPARCHotSpotNodeLIRBuilder#visitFullInfopointNode(FullInfopointNode)::: hot spot node builder visit full infopoint node:::if->i->getState->i->getState->i->getDebug->log->else->super->visitFullInfopointNode
SPARCHotSpotNodeLIRBuilder#visitBreakpointNode(BreakpointNode)::: hot spot node builder visit breakpoint node:::sig->node->arguments->size->new->JavaTypeArr->for->i->parameters->gen->getRegisterConfig->getCallingConvention->node->arguments->visitInvokeArguments->new->SPARCBreakpointOp->append
SPARCHotSpotPatchReturnAddressOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot patch return address op emit code:::addrRegister->asRegister->masm->sub
SPARCHotSpotPushInterpreterFrameOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot push interpreter frame op emit code:::frameSizeRegister->asRegister->framePcRegister->asRegister->senderSpRegister->asRegister->masm->mov->masm->neg->masm->save->masm->mov->masm->mov->masm->mov->masm->mov->masm->mov->masm->mov
SPARCHotSpotPushInterpreterFrameOp#leavesRegisterWindow()::: hot spot push interpreter frame op leaves register window:::return
SPARCHotSpotRegisterAllocationConfig#initAllocatable(RegisterArray)::: hot spot register allocation config init allocatable:::regMap->registerConfig->getAllocatableRegisters->size->new->BitSet->foreach->regMap->set->allocatableRegisters->registers->size->new->ArrayList<>->foreach->if->regMap->get->allocatableRegisters->add->return->super->new->RegisterArray->initAllocatable
SPARCHotSpotReturnOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot return op emit code:::if->if->try->sc->masm->getScratchRegister->foreignCalls->noReserved->new->Label->scratch->sc->getRegister->masm->new->SPARCAddress->ldx->masm->compareBranch->enableStackReservedZone->foreignCalls->lookupForeignCall->cc->enableStackReservedZone->getOutgoingCallingConvention->arg0->cc->getArgument->getRegister->masm->mov->SPARCCall->directCall->masm->restoreWindow->SPARCCall->foreignCalls->lookupForeignCall->indirectJmp->masm->bind->catch->finally->SPARCHotSpotSafepointOp->emitCode->ReturnOp->emitCodeHelper
SPARCHotSpotSafepointOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot safepoint op emit code:::emitCode
SPARCHotSpotSafepointOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler, GraalHotSpotVMConfig, boolean, LIRFrameState, Register, Value)::: hot spot safepoint op emit code:::if->emitThreadLocalPoll->else->asRegister->emitGlobalPoll
SPARCHotSpotSafepointOp#emitGlobalPoll(CompilationResultBuilder, SPARCMacroAssembler, GraalHotSpotVMConfig, boolean, LIRFrameState, Register):::Emit a global safepoint poll.:::crb->recordMark->if->pos->masm->position->crb->recordInfopoint->masm->new->SPARCAddress->ldx
SPARCHotSpotSafepointOp#emitThreadLocalPoll(CompilationResultBuilder, SPARCMacroAssembler, GraalHotSpotVMConfig, boolean, LIRFrameState, Register):::Emit a thread-local safepoint poll.:::try->scratchReg->masm->getScratchRegister->scratch->scratchReg->getRegister->masm->new->SPARCAddress->ldx->crb->recordMark->if->pos->masm->position->crb->recordInfopoint->masm->new->SPARCAddress->ldx->catch->finally
SPARCHotSpotSafepointOp#getSafepointAddressValue(SPARCHotSpotLIRGenerator)::: hot spot safepoint op get safepoint address value:::if->return->else->return->gen->LIRKind->gen->target->getWordKind->value->newVariable
SPARCHotSpotSafepointOp#emitPrologue(SPARCHotSpotNodeLIRBuilder, SPARCHotSpotLIRGenerator)::: hot spot safepoint op emit prologue:::if->var->gen->getSafepointAddressValue->lir->new->SPARCHotSpotSafepointOp.SPARCLoadSafepointPollAddress->append->gen->lir->getDebugInfoBuilder->lockStack->append
SPARCHotSpotSafepointOp.SPARCLoadSafepointPollAddress#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: load safepoint poll address emit code:::masm->ValueUtil->asRegister->setx
SPARCHotSpotStrategySwitchOp.HotSpotSwitchClosure#conditionalJump(int, Condition, Label)::: hot spot switch closure conditional jump:::if->constant->conditionCode->constant->isCompressed->conditionFlag->SPARCControlFlow->fromCondition->hint->requestHint->cbCondPosition->masm->position->canUseShortBranch->masm->hasFeature->SPARCControlFlow->isShortBranch->scratchRegister->asRegister->asRegister->loadFromConstantTable->if->CBCOND->emit->else->masm->cmp->BPCC->emit->masm->nop->else->super->conditionalJump
SPARCHotSpotStrategySwitchOp#estimateEmbeddedSize(Constant)::: hot spot strategy switch op estimate embedded size:::if->return->isCompressed->else->return->super->estimateEmbeddedSize
SPARCHotSpotStrategySwitchOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot strategy switch op emit code:::keyRegister->asRegister->constantBaseRegister->equals->asRegister->strategy->new->HotSpotSwitchClosure->run
SPARCHotSpotUnwindOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: hot spot unwind op emit code:::masm->mov->leaveFrame->linkage->lookupForeignCall->cc->linkage->getOutgoingCallingConvention->returnAddress->cc->getArgument->asRegister->masm->add->scratch->SPARCCall->indirectJmp
SPARCIndirectCallOp#emitCode(CompilationResultBuilder, SPARCMacroAssembler)::: indirect call op emit code:::crb->recordMark->callReg->asRegister->SPARCCall->indirectCall
SPARCIndirectCallOp#verify()::: indirect call op verify:::super->verify
