ASCIIReader#read():::Read a single character:::b0->fInputStream->read->if->throw->new->ObjectArr->Integer->toString->new->MalformedByteSequenceException->return
ASCIIReader#read(char[], int, int):::Read characters into a portion of an array:::if->count->fInputStream->read->for->i->return
ASCIIReader#skip(long):::Skip characters:::return->fInputStream->skip
ASCIIReader#ready():::Tell whether this stream is ready to be read.:::return
ASCIIReader#markSupported():::Tell whether this stream supports the mark() operation.:::return->fInputStream->markSupported
ASCIIReader#mark(int):::Mark the present position in the stream:::fInputStream->mark
ASCIIReader#reset():::Reset the stream:::fInputStream->reset
ASCIIReader#close():::Close the stream:::ba->ThreadLocalBufferAllocator->getBufferAllocator->ba->returnByteBuffer->fInputStream->close
Latin1Reader#read():::Read a single character:::return->fInputStream->read
Latin1Reader#read(char[], int, int):::Read characters into a portion of an array:::if->count->fInputStream->read->for->i->return
Latin1Reader#skip(long):::Skip characters:::return->fInputStream->skip
Latin1Reader#ready():::Tell whether this stream is ready to be read.:::return
Latin1Reader#markSupported():::Tell whether this stream supports the mark() operation.:::return->fInputStream->markSupported
Latin1Reader#mark(int):::Mark the present position in the stream:::fInputStream->mark
Latin1Reader#reset():::Reset the stream:::fInputStream->reset
Latin1Reader#close():::Close the stream:::fInputStream->close
MalformedByteSequenceException#getDomain():::Returns the error domain of the error message.:::return
MalformedByteSequenceException#getKey():::Returns the key of the error message.:::return
MalformedByteSequenceException#getArguments():::Returns the replacement arguments for the error message or null if none exist.:::return
MalformedByteSequenceException#getMessage():::Returns the localized message for this exception.:::if->fFormatter->formatMessage->return
UCSReader#read():::Read a single character:::b0->fInputStream->read->if->return->b1->fInputStream->read->if->return->if->b2->fInputStream->read->if->return->b3->fInputStream->read->if->return->println->if->return->else->return->else->if->return->else->return
UCSReader#read(char[], int, int):::Read characters into a portion of an array:::byteLength->if->count->fInputStream->read->if->return->if->numToRead->for->i->else->numToRead->if->charRead->fInputStream->read->if->else->numChars->curPos->for->i->return
UCSReader#skip(long):::Skip characters:::charWidth->bytesSkipped->fInputStream->skip->if->return->return
UCSReader#ready():::Tell whether this stream is ready to be read.:::return
UCSReader#markSupported():::Tell whether this stream supports the mark() operation.:::return->fInputStream->markSupported
UCSReader#mark(int):::Mark the present position in the stream:::fInputStream->mark
UCSReader#reset():::Reset the stream:::fInputStream->reset
UCSReader#close():::Close the stream:::ba->ThreadLocalBufferAllocator->getBufferAllocator->ba->returnByteBuffer->fInputStream->close
UTF16Reader#read():::Read a single character:::b0->fInputStream->read->if->return->b1->fInputStream->read->if->expectedTwoBytes->if->return->return
UTF16Reader#read(char[], int, int):::Read characters into a portion of an array:::byteLength->if->byteCount->fInputStream->read->if->return->if->b->fInputStream->read->if->expectedTwoBytes->charCount->if->processBE->else->processLE->return
UTF16Reader#skip(long):::Skip characters:::bytesSkipped->fInputStream->skip->if->b->fInputStream->read->if->expectedTwoBytes->return
UTF16Reader#ready():::Tell whether this stream is ready to be read.:::return
UTF16Reader#markSupported():::Tell whether this stream supports the mark() operation.:::return
UTF16Reader#mark(int):::Mark the present position in the stream:::throw->fFormatter->new->ObjectArr->formatMessage->new->IOException
UTF16Reader#reset():::Reset the stream:::
UTF16Reader#close():::Close the stream:::fInputStream->close
UTF16Reader#processBE(char[], int, int):::Decodes UTF-16BE *:::curPos->for->i
UTF16Reader#processLE(char[], int, int):::Decodes UTF-16LE *:::curPos->for->i
UTF16Reader#expectedTwoBytes():::Throws an exception for expected byte.:::throw->new->ObjectArr->new->MalformedByteSequenceException
UTF8Reader#read():::Read a single character:::c->if->index->b0->fInputStream->read->if->return->if->else->if->b1->fInputStream->read->if->expectedByte->if->invalidByte->else->if->b1->fInputStream->read->if->expectedByte->if->invalidByte->b2->fInputStream->read->if->expectedByte->if->invalidByte->else->if->b1->fInputStream->read->if->expectedByte->if->invalidByte->b2->fInputStream->read->if->expectedByte->if->invalidByte->b3->fInputStream->read->if->expectedByte->if->invalidByte->uuuuu->if->invalidSurrogate->wwww->hs->ls->else->invalidByte->else->if->Integer->toHexString->println->return
UTF8Reader#read(char[], int, int):::Read characters into a portion of an array:::out->if->count->if->if->fInputStream->read->if->return->else->total->in->byte1->byte0->for->for->if->println->return
UTF8Reader#skip(long):::Skip characters:::remaining->ch->new->charArr->do->length->count->read->if->else->break->while->skipped->return
UTF8Reader#ready():::Tell whether this stream is ready to be read.:::return
UTF8Reader#markSupported():::Tell whether this stream supports the mark() operation.:::return
UTF8Reader#mark(int):::Mark the present position in the stream:::throw->fFormatter->new->ObjectArr->formatMessage->new->IOException
UTF8Reader#reset():::Reset the stream:::
UTF8Reader#close():::Close the stream:::ba->ThreadLocalBufferAllocator->getBufferAllocator->ba->returnByteBuffer->fInputStream->close
UTF8Reader#expectedByte(int, int):::Throws an exception for expected byte.:::throw->new->ObjectArr->Integer->toString->Integer->toString->new->MalformedByteSequenceException
UTF8Reader#invalidByte(int, int, int):::Throws an exception for invalid byte.:::throw->new->ObjectArr->Integer->toString->Integer->toString->new->MalformedByteSequenceException
UTF8Reader#invalidSurrogate(int):::Throws an exception for invalid surrogate bits.:::throw->new->ObjectArr->Integer->toHexString->new->MalformedByteSequenceException
