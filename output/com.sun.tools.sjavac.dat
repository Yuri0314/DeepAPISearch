BuildState#lookupModule(String):::Lookup a module from a name:::m->modules->get->if->new->Module->modules->put->return
BuildState#findModuleFromPackageName(String):::Find a module from a given package name:::cp->pkg->indexOf->Assert->check->mod->pkg->substring->return->lookupModule
BuildState#flattenPackagesSourcesAndArtifacts(Map):::Store references to all packages, sources and artifacts for all modules into the build state:::foreach->modules->values->foreach->i->packages->entrySet->p->packages->j->getKey->get->Assert->j->getValue->check->if->j->getValue->packages->j->getKey->j->getValue->put->foreach->p->sources->entrySet->s->sources->k->getKey->get->Assert->k->getValue->check->if->k->getValue->sources->k->getKey->k->getValue->put->foreach->p->artifacts->entrySet->f->artifacts->g->getKey->get->Assert->g->getValue->check->if->g->getValue->artifacts->g->getKey->g->getValue->put
BuildState#flattenArtifacts(Map):::Store references to all artifacts found in the module tree into the maps stored in the build state.:::foreach->modules->values->foreach->i->packages->entrySet->p->packages->j->getKey->get->Assert->j->getValue->check->j->getValue->packages->j->getKey->j->getValue->put->foreach->p->artifacts->entrySet->f->artifacts->g->getKey->get->Assert->g->getValue->check->artifacts->g->getKey->g->getValue->put
BuildState#calculateDependents():::Calculate the package dependents (ie the reverse of the dependencies).:::new->HashMap<>->foreach->packages->keySet->p->packages->get->deps->p->typeDependencies->values->stream->Collections->emptySet->Util->union->reduce->foreach->depPkgStr->dep->dep->lastIndexOf->substring->dependents->Collections->singleton->Util->union->merge->dp->packages->get->if->dp->p->name->addDependent
BuildState#checkInternalState(String, boolean, Map):::Verify that the setModules method above did the right thing when running through the module->package->source structure.:::baad->original->new->HashMap<>->calculated->new->HashMap<>->foreach->sources->keySet->ss->sources->get->if->ss->isLinkedOnly->calculated->put->foreach->srcs->keySet->ss->srcs->get->if->ss->isLinkedOnly->original->put->if->original->size->calculated->size->Log->error->if->original->keySet->calculated->keySet->equals->Log->error->if->foreach->original->keySet->s1->original->get->s2->calculated->get->if->s1->equals->Log->error->if->foreach->original->keySet->ss->original->get->sss->calculated->get->if->Log->error->foreach->calculated->keySet->ss->calculated->get->sss->original->get->if->Log->error
BuildState#loadModule(String):::Load a module from the javac state file.:::m->Module->load->modules->m->name->put->return
BuildState#loadPackage(Module, String):::Load a package from the javac state file.:::p->Package->load->lastModule->addPackage->packages->p->name->put->return
BuildState#loadSource(Package, String, boolean):::Load a source from the javac state file.:::s->Source->load->lastPackage->addSource->sources->s->name->put->return
BuildState#copyPackagesExcept(BuildState, Set, Set):::During an incremental compile we need to copy the old javac state information about packages that were not recompiled.:::foreach->prev->packages->keySet->if->recompiled->contains->removed->contains->continue->mnew->findModuleFromPackageName->pprev->prev->packages->get->if->packages->containsKey->pprev->PubApi->pprev->getPubApi->packages->get->getPubApi->mergeTypes->setPubapi->mnew->addPackage->packages->put
CompileJavaPackages#createCompileChunks(Map>, Map>, int, int):::Split up the sources into compile chunks:::compileChunks->new->CompileChunkArr->for->i->ci->packageNames->pkgSrcs->keySet->new->StringArr->toArray->Arrays->sort->from->foreach->cc->s->pkgSrcs->get->if->size->s->size->addAll->justPkgName->Util->justPackageName->ss->oldPackageDependents->get->if->ss->size->if->from->trim->equals->s->size->append->Arrays->sort->return
JavacState#removeArgsNotAffectingState(String[]):::Remove args not affecting the state.:::out->new->StringArr->j->for->i->ret->new->StringArr->System->arraycopy->return
JavacState#setVisibleSources(Map):::Specify which sources are visible to the compiler through -sourcepath.:::new->HashSet<>->foreach->vs->keySet->src->vs->get->visibleSrcs->src->file->toURI->add
JavacState#isIncremental():::Returns true if this is an incremental build.:::return->prev->sources->isEmpty
JavacState#findAllArtifacts():::Find all artifacts that exists on disk.:::findAllFiles->findAllFiles->findAllFiles
JavacState#deleteClassArtifactsInTaintedPackages():::Delete all prev artifacts in the currently tainted packages.:::foreach->arts->fetchPrevArtifacts->foreach->arts->values->if->f->exists->f->getName->endsWith->f->delete
JavacState#save():::Save the javac_state file.:::if->return->try->out->new->FileWriter->b->new->StringBuilder->millisNow->System->currentTimeMillis->d->new->Date->df->new->SimpleDateFormat->b->df->format->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->b->append->append->append->now->new->HashSet<String>->copyPackagesExcept->Module->now->modules->saveModules->s->b->toString->out->s->length->write->catch->finally
JavacState#load(Options):::Load a javac_state file.:::db->new->JavacState->lastModule->lastPackage->lastSource->noFileFound->foundCorrectVerNr->newCommandLine->syntaxError->Log->debug->try->in->new->FileReader->new->BufferedReader->for->catch->Log->warn->new->JavacState->finally->if->Log->debug->new->JavacState->else->if->Log->debug->new->JavacState->else->if->Log->warn->new->JavacState->calculateDependents->return
JavacState#taintPackage(String, String):::Mark a java package as tainted, ie it needs recompilation.:::if->taintedPackages->contains->if->Log->Util->justPackageName->debug->taintedPackages->add->needsSaving->nowp->now->packages->get->if->foreach->nowp->dependents->taintPackage
JavacState#taintedPackages():::This packages need recompilation.:::return
JavacState#clearTaintedPackages():::Clean out the tainted package set, used after the first round of compiles, prior to propagating dependencies.:::new->HashSet<>
JavacState#checkSourceStatus(boolean):::Go through all sources and check which have been removed, added or modified and taint the corresponding packages.:::calculateRemovedSources->foreach->if->s->isGenerated->s->pkg->name->s->name->taintPackage->calculateAddedSources->foreach->msg->if->isIncremental->s->name->if->s->isGenerated->s->pkg->name->taintPackage->calculateModifiedSources->foreach->if->s->isGenerated->s->pkg->name->s->name->taintPackage
JavacState#getJavaSuffixRule():::Acquire the compile_java_packages suffix rule for .java files.:::sr->new->HashMap<>->sr->put->return
JavacState#taintPackagesThatMissArtifacts():::If artifacts have gone missing, force a recompile of the packages they belong to.:::foreach->prev->packages->values->foreach->pkg->artifacts->values->if->f->exists->pkg->name->taintPackage
JavacState#taintPackagesDependingOnChangedPackages(Set, Set):::Propagate recompilation through the dependency chains:::foreach->prev->packages->values->new->HashSet<>->deps->pkg->typeDependencies->values->stream->Collection->stream->flatMap->Collectors->toSet->collect->foreach->depPkg->dep->dep->lastIndexOf->substring->if->depPkg->pkg->name->equals->continue->if->pkgsWithChangedPubApi->contains->recentlyCompiled->pkg->name->contains->pkg->name->taintPackage
JavacState#taintPackagesDependingOnChangedClasspathPackages():::Compare the javac_state recorded public apis of packages on the classpath with the actual public apis on the classpath.:::fqDependencies->new->HashSet<>->foreach->prev->packages->values->if->pkg->sources->isEmpty->continue->pkg->typeClasspathDependencies->values->fqDependencies->addAll->forEach->pubApiExtractor->new->PubApiExtractor->onDiskPubApi->new->HashMap<>->foreach->onDiskPubApi->pubApiExtractor->getPubApi->put->pubApiExtractor->close->foreach->prev->packages->values->if->pkg->sources->isEmpty->continue->cpDepsOfThisPkg->new->HashSet<>->foreach->pkg->typeClasspathDependencies->values->cpDepsOfThisPkg->addAll->foreach->depPkg->fqDep->fqDep->lastIndexOf->substring->prevPkgApi->prev->packages->get->getPubApi->prevDepApi->get->currentDepApi->onDiskPubApi->get->get->if->currentDepApi->isBackwardCompatibleWith->apiDiff->currentDepApi->diff->pkg->name->String->join->taintPackage->continue
JavacState#removeUnidentifiedArtifacts():::Scan all output dirs for artifacts and remove those files (artifacts?) that are not recognized as such, in the javac_state file.:::allKnownArtifacts->new->HashSet<>->foreach->prev->packages->values->foreach->pkg->artifacts->values->allKnownArtifacts->add->allKnownArtifacts->add->foreach->if->allKnownArtifacts->contains->options->f->getAbsolutePath->isUnidentifiedArtifactPermitted->Log->f->getPath->debug->f->delete->foreach->if->allKnownArtifacts->contains->Log->f->getPath->debug->f->delete->foreach->if->allKnownArtifacts->contains->Log->f->getPath->debug->f->delete
JavacState#removeSuperfluousArtifacts(Set):::Remove artifacts that are no longer produced when compiling!:::if->recentlyCompiled->size->return->foreach->now->packages->keySet->if->recentlyCompiled->contains->continue->arts->now->artifacts->values->foreach->fetchPrevArtifacts->values->if->arts->contains->Log->f->getPath->debug->if->f->exists->f->delete
JavacState#performCopying(File, Map):::Run the copy translator only.:::sr->new->HashMap<>->foreach->suffixRules->entrySet->if->e->getValue->getClass->equals->sr->e->getKey->e->getValue->put->perform
JavacState#performTranslation(File, Map):::Run all the translators that translate into java source code:::sr->new->HashMap<>->foreach->suffixRules->entrySet->trClass->e->getValue->getClass->if->continue->sr->e->getKey->e->getValue->put->perform
JavacState#performJavaCompilations(CompilationService, Options, Set, boolean[]):::Compile all the java sources:::suffixRules->new->HashMap<>->suffixRules->put->compileJavaPackages->setExtra->perform->recentlyCompiled->taintedPackages->addAll->clearTaintedPackages->again->packagesWithChangedPublicApis->isEmpty->taintPackagesDependingOnChangedPackages->new->HashSet<>->return
JavacState#compareWithMakefileList(File):::Compare the calculate source list, with an explicit list, usually supplied from the makefile:::mightNeedRewriting->if->return->calculatedSources->new->HashSet<>->listedSources->new->HashSet<>->foreach->now->sources->values->if->s->isLinkedOnly->path->s->file->getPath->if->Util->normalizeDriveLetter->calculatedSources->add->try->in->new->FileReader->new->BufferedReader->for->catch->throw->makefileSourceList->getPath->new->ProblemException->throw->makefileSourceList->getPath->new->ProblemException->finally->foreach->if->calculatedSources->contains->throw->new->ProblemException->foreach->if->listedSources->contains->throw->new->ProblemException
Package#existsInJavacState():::Check if we have knowledge in the javac state that describe the results of compiling this package before.:::return->artifacts->size->pubApi->isEmpty
Package#deleteArtifacts():::Always clean out a tainted package before it is recompiled.:::foreach->artifacts->values->a->delete
Source#scanRoot(File, Set, List, List, Map, Map, Module, boolean, boolean, boolean):::Recurse into the directory root and find all files matchine the excl/incl/exclfiles/inclfiles rules:::if->return->fs->root->toPath->getFileSystem->if->includes->isEmpty->Collections->singletonList->includeMatchers->createPathMatchers->excludeMatchers->createPathMatchers->Files->root->toPath->new->SimpleFileVisitor<Path>->walkFileTree
Transformer#transform(CompilationService, Map>, Set, Map>, URI, Map>, Map>>, Map>>, Map, Map, int, boolean, int):::The transform method takes a set of package names, mapped to their source files and to the pubapis of the packages:::
Util#pkgNameOfClassName(String):::Extract the package name from a fully qualified class name:::i->fqClassName->lastIndexOf->pkg->fqClassName->substring->return
Util#cleanSubOptions(Set, String):::Clean out unwanted sub options supplied inside a primary option:::sb->new->StringBuilder->st->new->StringTokenizer->while->st->hasMoreTokens->o->st->nextToken->p->o->indexOf->if->key->o->substring->val->o->substring->if->allowedSubOptions->contains->if->sb->length->sb->append->sb->append->return->sb->toString
Util#set(String...):::Convenience method to create a set with strings.:::set->new->HashSet<>->set->Arrays->asList->addAll->return
Util#normalizeDriveLetter(String):::Normalize windows drive letter paths to upper case to enable string comparison.:::if->file->length->file->charAt->return->Character->file->charAt->toUpperCase->file->substring->else->if->file->length->file->charAt->file->charAt->return->file->substring->Character->file->charAt->toUpperCase->file->substring->return
Util#findServerSettings(String[]):::Locate the setting for the server properties.:::foreach->if->s->startsWith->return->return
