AbstractSaslImpl#isComplete():::Determines whether this mechanism has completed.:::return
AbstractSaslImpl#getNegotiatedProperty(String):::Retrieves the negotiated property.:::if->throw->new->IllegalStateException->switch->if->return->else->if->return->else->return->return->Integer->toString->return->Integer->toString->return->Integer->toString->return
AbstractSaslImpl#combineMasks(byte[])::: abstract sasl impl combine masks:::answer->for->i->return
AbstractSaslImpl#findPreferredMask(byte, byte[])::: abstract sasl impl find preferred mask:::for->i->return
AbstractSaslImpl#parseQop(String)::: abstract sasl impl parse qop:::return->parseQop
AbstractSaslImpl#parseQop(String, String[], boolean)::: abstract sasl impl parse qop:::if->return->return->parseProp
AbstractSaslImpl#parseStrength(String)::: abstract sasl impl parse strength:::if->return->return->parseProp
AbstractSaslImpl#parseProp(String, String, String[], byte[], String[], boolean)::: abstract sasl impl parse prop:::parser->new->StringTokenizer->token->answer->new->byteArr->i->found->while->parser->hasMoreTokens->parser->nextToken->for->j->if->throw->new->SaslException->for->j->return
AbstractSaslImpl#traceOutput(String, String, String, byte[]):::Outputs a byte array:::traceOutput
AbstractSaslImpl#traceOutput(String, String, String, byte[], int, int)::: abstract sasl impl trace output:::try->origlen->lev->if->logger->isLoggable->Math->min->else->content->if->out->new->ByteArrayOutputStream->new->HexDumpEncoder->new->ByteArrayInputStream->encodeBuffer->out->toString->else->logger->new->ObjectArr->logp->catch->logger->logp->finally
AbstractSaslImpl#networkByteOrderToInt(byte[], int, int):::Returns the integer represented by  4 bytes in network byte order.:::if->throw->new->IllegalArgumentException->answer->for->i->return
AbstractSaslImpl#intToNetworkByteOrder(int, byte[], int, int):::Encodes an integer into 4 bytes in network byte order in the buffer supplied.:::if->throw->new->IllegalArgumentException->for->i
PolicyUtils#checkPolicy(int, Map):::Determines whether a mechanism's characteristics, as defined in flags, fits the security policy properties found in props.:::if->return->if->props->get->equalsIgnoreCase->return->if->props->get->equalsIgnoreCase->return->if->props->get->equalsIgnoreCase->return->if->props->get->equalsIgnoreCase->return->if->props->get->equalsIgnoreCase->return->if->props->get->equalsIgnoreCase->return->return
PolicyUtils#filterMechs(String[], int[], Map):::Given a list of mechanisms and their characteristics, select the subset that conforms to the policies defined in props:::if->return->mechs->clone->passed->new->booleanArr->count->for->i->answer->new->StringArr->for->i->j->return
