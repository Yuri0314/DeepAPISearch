AOTInliningPolicy_OptionDescriptors#get(String)::: inlining policy_ option descriptors get:::switch->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return
AOTInliningPolicy_OptionDescriptors#iterator()::: inlining policy_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
AOTInliningPolicy#maxInliningSize(int, OptionValues)::: inlining policy max inlining size:::return->Math->getValue->getValue->getValue->max
AOTInliningPolicy#isWorthInlining(Replacements, MethodInvocation, InlineInfo, int, boolean)::: inlining policy is worth inlining:::options->calleeInfo->graph->getOptions->isTracing->getValue->info->invocation->callee->for->i->info->numberOfMethods->probability->invocation->probability->relevance->invocation->relevance->if->InlineEverything->getValue->InliningUtil->traceInlinedMethod->return->withReason->if->isIntrinsic->InliningUtil->traceInlinedMethod->return->withReason->if->info->shouldInline->InliningUtil->traceInlinedMethod->return->withReason->inliningBonus->getInliningBonus->nodes->info->determineNodeCount->if->TrivialInliningSize->getValue->InliningUtil->traceInlinedMethod->return->withReason->maximumNodes->maxInliningSize->computeMaximumSize->if->InliningUtil->traceInlinedMethod->return->withReason->InliningUtil->traceNotInlinedMethod->return->withReason
EliminateRedundantInitializationPhase#removeInitsAtStaticCalls(StructuredGraph):::Find each Invoke that has a corresponding InitializeKlassNode:::foreach->graph->getInvokes->classInit->invoke->classInit->if->classInit->replaceAtUsages->graph->removeFixed
EliminateRedundantInitializationPhase#removeRedundantInits(StructuredGraph):::Remove redundant InitializeKlassNode or ResolveConstantNode instances from the graph.:::redundantNodes->findRedundantInits->foreach->graph->removeFixed
EliminateRedundantInitializationPhase#findRedundantInits(StructuredGraph):::Find InitializeKlassNode and ResolveConstantNode instances that can be removed because there is an existing dominating node.:::i->graph->start->new->InitializedTypes->new->EliminateRedundantInitializationIterator->i->apply->return->i->getRedundantNodes
EliminateRedundantInitializationPhase.InitializedTypes#clone()::: initialized types clone:::return->EconomicSet->create->new->InitializedTypes
EliminateRedundantInitializationPhase.InitializedTypes#contains(ResolvedJavaType)::: initialized types contains:::if->type->isInterface->type->isArray->return->types->contains->return->type->isAssignableFrom->anyMatch
EliminateRedundantInitializationPhase.InitializedTypes#add(ResolvedJavaType)::: initialized types add:::types->add
EliminateRedundantInitializationPhase.InitializedTypes#merge(ResolvedJavaType, ResolvedJavaType):::Merge two given types:::if->a->isInterface->b->isInterface->a->isArray->b->isArray->if->a->equals->return->else->return->else->c->a->findLeastCommonAncestor->if->c->isJavaLangObject->return->return
EliminateRedundantInitializationPhase.InitializedTypes#merge(EconomicSet, EconomicSet):::Merge two sets of types:::c->EconomicSet->create->foreach->foreach->tc->merge->if->c->add->if->tc->isInterface->tc->isArray->break->return
EliminateRedundantInitializationPhase.InitializedTypes#merge(AbstractMergeNode, List)::: initialized types merge:::foreach->merge->return
EliminateRedundantInitializationPhase.InitializedTypes#toString(EconomicSet)::: initialized types to string:::b->new->StringBuilder->b->append->i->types->iterator->while->i->hasNext->t->i->next->b->t->toString->append->if->i->hasNext->b->append->b->append->return->b->toString
EliminateRedundantInitializationPhase.InitializedTypes#toString()::: initialized types to string:::return->toString
EliminateRedundantInitializationPhase.EliminateRedundantInitializationIterator#getRedundantNodes()::: eliminate redundant initialization iterator get redundant nodes:::return
EliminateRedundantInitializationPhase.EliminateRedundantInitializationIterator#processType(FixedWithNextNode, Constant)::: eliminate redundant initialization iterator process type:::klass->t->klass->asResolvedJavaType->if->if->state->contains->redundantNodes->add->else->state->add
EliminateRedundantInitializationPhase.EliminateRedundantInitializationIterator#node(FixedNode)::: eliminate redundant initialization iterator node:::if->i->if->i->value->isConstant->i->value->asConstant->processType->else->if->r->if->r->hasNoUsages->if->r->value->isConstant->r->value->asConstant->processType
EliminateRedundantInitializationPhase#run(StructuredGraph, CoreProviders)::: eliminate redundant initialization phase run:::removeInitsAtStaticCalls->removeRedundantInits
ReplaceConstantNodesPhase#isReplacementNode(Node)::: replace constant nodes phase is replacement node:::return
ReplaceConstantNodesPhase#anyUsagesNeedReplacement(ConstantNode)::: replace constant nodes phase any usages need replacement:::return->node->usages->isReplacementNode->filter->isNotEmpty
ReplaceConstantNodesPhase#anyUsagesNeedReplacement(LoadMethodCountersNode)::: replace constant nodes phase any usages need replacement:::return->node->usages->filter->isNotEmpty
ReplaceConstantNodesPhase#checkForBadFingerprint(HotSpotResolvedJavaType)::: replace constant nodes phase check for bad fingerprint:::if->type->isArray->if->type->getElementalType->isPrimitive->return->return->type->getElementalType->getFingerprint->return->getFingerprint
ReplaceConstantNodesPhase#insertReplacement(StructuredGraph, FrameStateMapperClosure, FloatingNode, FixedWithNextNode):::Insert the replacement node into the graph:::insertionPoint->findInsertionPoint->graph->addAfterFixed->stateMapper->stateMapper->getState->addState
ReplaceConstantNodesPhase#findInsertionPoint(StructuredGraph, FrameStateMapperClosure, FloatingNode):::Find a good place to insert a stateful fixed node that is above the given node:::fixed->findFixedBeforeFloating->result->findFixedWithValidState->return
ReplaceConstantNodesPhase#findFixedBeforeFloating(StructuredGraph, FloatingNode):::Find the first FixedWithNextNode that is currently scheduled before the given floating node.:::schedule->graph->getLastSchedule->nodeToBlock->schedule->getNodeToBlockMap->block->nodeToBlock->get->blockToNodes->schedule->getBlockToNodesMap->result->foreach->blockToNodes->get->if->n->equals->break->if->return
ReplaceConstantNodesPhase#findFixedWithValidState(StructuredGraph, FrameStateMapperClosure, FixedWithNextNode):::Find first dominating FixedWithNextNode that has a valid state reaching it starting from the given node.:::schedule->graph->getLastSchedule->nodeToBlock->schedule->getNodeToBlockMap->block->nodeToBlock->get->n->do->if->isFixedWithValidState->return->while->block->getBeginNode->n->predecessor->if->isFixedWithValidState->return->block->getDominator->if->block->getEndNode->while->return->graph->start
ReplaceConstantNodesPhase#isFixedWithValidState(FrameStateMapperClosure, Node)::: replace constant nodes phase is fixed with valid state:::if->fixed->if->BytecodeFrame->stateMapper->getState->isPlaceholderBci->return->return
ReplaceConstantNodesPhase.FrameStateMapperClosure#processNode(FixedNode, FrameState)::: frame state mapper closure process node:::currentState->if->stateSplit->stateAfter->stateSplit->stateAfter->if->reachingStates->put->return
ReplaceConstantNodesPhase.FrameStateMapperClosure#merge(AbstractMergeNode, List)::: frame state mapper closure merge:::singleFrameState->singleFrameState->currentState->merge->stateAfter->reachingStates->put->return
ReplaceConstantNodesPhase.FrameStateMapperClosure#afterSplit(AbstractBeginNode, FrameState)::: frame state mapper closure after split:::return
ReplaceConstantNodesPhase.FrameStateMapperClosure#processLoop(LoopBeginNode, FrameState)::: frame state mapper closure process loop:::return->ReentrantNodeIterator->processLoop
ReplaceConstantNodesPhase.FrameStateMapperClosure#singleFrameState(List)::: frame state mapper closure single frame state:::singleState->states->get->for->i->states->size->return
ReplaceConstantNodesPhase.FrameStateMapperClosure#getState(Node)::: frame state mapper closure get state:::return->reachingStates->get
ReplaceConstantNodesPhase.FrameStateMapperClosure#addState(Node, FrameState)::: frame state mapper closure add state:::reachingStates->setAndGrow
ReplaceConstantNodesPhase#tryToReplaceWithExisting(StructuredGraph, ConstantNode):::Try to find dominating node doing the resolution that can be reused.:::schedule->graph->getLastSchedule->nodeToBlock->schedule->getNodeToBlockMap->blockToNodes->schedule->getBlockToNodesMap->blockToExisting->EconomicMap->create->foreach->node->usages->isReplacementNode->filter->blockToExisting->nodeToBlock->get->put->foreach->node->usages->isReplacementNode->filter->snapshot->replaced->b->nodeToBlock->get->e->blockToExisting->get->if->foreach->blockToNodes->get->if->n->equals->break->if->n->equals->use->replaceFirstInput->break->if->foreach->blockToExisting->getKeys->if->strictlyDominates->use->blockToExisting->get->replaceFirstInput->break
ReplaceConstantNodesPhase#replaceWithResolution(StructuredGraph, FrameStateMapperClosure, ConstantNode, ClassInfo):::Replace the uses of a constant with either LoadConstantIndirectlyNode or ResolveConstantNode.:::metaspaceConstant->node->asConstant->type->metaspaceConstant->asResolvedJavaType->topMethodHolder->graph->method->getDeclaringClass->replacement->if->type->isArray->type->getComponentType->isPrimitive->graph->new->LoadConstantIndirectlyNode->addOrUnique->else->if->type->equals->type->isAssignableFrom->type->isInterface->graph->new->LoadConstantIndirectlyNode->addOrUnique->else->fixedReplacement->if->contains->graph->new->ResolveConstantNode->add->else->graph->new->ResolveConstantNode->add->insertReplacement->node->isReplacementNode->replaceAtUsages
ReplaceConstantNodesPhase#handleHotSpotMetaspaceConstant(StructuredGraph, FrameStateMapperClosure, ConstantNode, ClassInfo):::Replace ConstantNode containing a HotSpotResolvedJavaType with indirection.:::metaspaceConstant->node->asConstant->type->metaspaceConstant->asResolvedJavaType->if->if->checkForBadFingerprint->throw->new->GraalError->tryToReplaceWithExisting->if->anyUsagesNeedReplacement->replaceWithResolution->else->throw->new->GraalError
ReplaceConstantNodesPhase#handleHotSpotObjectConstant(StructuredGraph, FrameStateMapperClosure, ConstantNode, ClassInfo):::Replace an object constant with an indirect load ResolveConstantNode:::constant->node->asJavaConstant->type->constant->getType->if->type->equals->replacement->graph->new->ResolveConstantNode->add->insertReplacement->node->replaceAtUsages->else->throw->new->GraalError
ReplaceConstantNodesPhase#handleLoadMethodCounters(StructuredGraph, FrameStateMapperClosure, LoadMethodCountersNode, CoreProviders):::Replace LoadMethodCountersNode with indirect load ResolveMethodAndLoadCountersNode, expose a klass constant of the holder.:::type->node->getMethod->getDeclaringClass->hubStamp->context->getStampProvider->StampFactory->objectNonNull->createHubStamp->constantReflection->context->getConstantReflection->klassHint->ConstantNode->constantReflection->asObjectHub->context->getMetaAccess->forConstant->replacement->graph->node->getMethod->new->ResolveMethodAndLoadCountersNode->add->insertReplacement->node->replaceAtUsages
ReplaceConstantNodesPhase#replaceLoadMethodCounters(StructuredGraph, FrameStateMapperClosure, CoreProviders):::Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass constants.:::new->SchedulePhase->apply->foreach->getLoadMethodCountersNodes->if->anyUsagesNeedReplacement->handleLoadMethodCounters
ReplaceConstantNodesPhase#replaceKlassesAndObjects(StructuredGraph, FrameStateMapperClosure, ClassInfo):::Replace object and klass constants with resolution nodes or reuse preceding initializations.:::new->SchedulePhase->apply->foreach->getConstantNodes->constant->node->asConstant->if->anyUsagesNeedReplacement->handleHotSpotMetaspaceConstant->else->if->anyUsagesNeedReplacement->handleHotSpotObjectConstant
ReplaceConstantNodesPhase#run(StructuredGraph, CoreProviders)::: replace constant nodes phase run:::stateMapper->new->FrameStateMapperClosure->ReentrantNodeIterator->graph->start->apply->replaceLoadMethodCounters->context->getMetaAccess->new->ClassInfo->replaceKlassesAndObjects
ReplaceConstantNodesPhase#checkContract()::: replace constant nodes phase check contract:::return
