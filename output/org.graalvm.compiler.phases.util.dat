BlockWorkList#add(AbstractMergeNode):::Adds a block to this list in an unsorted fashion, like a stack.:::if->allocate->else->if->grow
BlockWorkList#addSorted(AbstractMergeNode, int):::Adds a block to this list, sorted by the supplied number:::if->allocate->else->if->grow->i->for
BlockWorkList#removeFromWorkList():::Removes the next block from this work list:::if->return->return
BlockWorkList#isEmpty():::Checks whether the list is empty.:::return
BlockWorkList#allocate()::: block work list allocate:::new->AbstractMergeNodeArr->new->intArr
BlockWorkList#grow()::: block work list grow:::prevLength->nworkList->new->AbstractMergeNodeArr->System->arraycopy->nworkListNumbers->new->intArr->System->arraycopy
GraphOrder#assertNonCyclicGraph(StructuredGraph):::Quick (and imprecise) assertion that there are no (invalid) cycles in the given graph:::order->createOrder->visited->graph->createNodeBitMap->visited->clearAll->foreach->if->merge->else->foreach->node->inputs->if->visited->isMarked->if->else->visited->mark->return
GraphOrder#createOrder(StructuredGraph)::: graph order create order:::nodes->new->ArrayList<>->visited->graph->createNodeBitMap->graph->start->new->StatelessPostOrderNodeIterator->apply->return
GraphOrder#visitForward(ArrayList, NodeBitMap, Node, boolean)::: graph order visit forward:::try->if->visited->isMarked->if->throw->new->GraalError->visited->mark->stateAfter->if->stateAfter->foreach->node->inputs->if->visitForward->if->end->foreach->end->merge->phis->phi->valueAt->visitForward->nodes->add->if->foreach->phis->visited->mark->nodes->add->if->visitForward->catch->throw->GraalGraphError->transformAndAddContext->finally
GraphOrder#assertSchedulableGraph(StructuredGraph):::This method schedules the graph and makes sure that, for every node, all inputs are available at the position where it is scheduled:::try->s->graph->getDebug->scope->schedulePhase->new->SchedulePhase->loopEntryStates->EconomicMap->create->schedulePhase->apply->schedule->graph->getLastSchedule->closure->new->BlockIteratorClosure<NodeBitMap>->ReentrantBlockIterator->schedule->getCFG->getStartBlock->apply->catch->graph->getDebug->handle->finally->return
MethodDebugValueName#createString()::: method debug value name create string:::return->method->getName
Providers#getCodeCache()::: providers get code cache:::return
Providers#copyWith(MetaAccessProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(CodeCacheProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(ConstantReflectionProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(ConstantFieldProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(ForeignCallsProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(LoweringProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(Replacements)::: providers copy with:::return->new->Providers
Providers#copyWith(StampProvider)::: providers copy with:::return->new->Providers
Providers#copyWith(GCProvider)::: providers copy with:::return->new->Providers
ValueMergeUtil#mergeReturns(AbstractMergeNode, List)::: value merge util merge returns:::return->returnNode->result->mergeValueProducers
ValueMergeUtil#mergeValueProducers(AbstractMergeNode, List, Function, Function)::: value merge util merge value producers:::singleResult->phiResult->foreach->result->valueFunction->apply->if->if->else->if->merge->graph->result->stamp->unrestricted->new->ValuePhiNode->addWithoutUnique->for->i->merge->forwardEndCount->phiResult->addInput->else->phiResult->addInput->endNode->merge->graph->new->EndNode->add->merge->addForwardEnd->if->replaceAndDelete->else->lastInstr->lastInstrFunction->apply->lastInstr->setNext->if->phiResult->inferStamp->return->else->return
