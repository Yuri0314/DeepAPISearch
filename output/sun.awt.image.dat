BufferedImageDevice#getType():::Returns the type of this GraphicsDevice.:::return
BufferedImageDevice#getIDstring():::Returns the identification string associated with this GraphicsDevice.:::return
BufferedImageDevice#getConfigurations():::Returns all of the GraphicsConfiguration objects associated with this GraphicsDevice.:::return->new->GraphicsConfigurationArr
BufferedImageDevice#getDefaultConfiguration():::Returns the default GraphicsConfiguration associated with this GraphicsDevice.:::return
BufferedImageGraphicsConfig#getConfig(BufferedImage)::: buffered image graphics config get config:::return->getConfig
BufferedImageGraphicsConfig#getConfig(BufferedImage, double, double)::: buffered image graphics config get config:::ret->type->bImg->getType->configs->if->if->return->new->BufferedImageGraphicsConfig->if->return
BufferedImageGraphicsConfig#getDevice():::Return the graphics device associated with this configuration.:::return
BufferedImageGraphicsConfig#createCompatibleImage(int, int):::Returns a BufferedImage with channel layout and color model compatible with this graphics configuration:::wr->raster->createCompatibleWritableRaster->return->model->isAlphaPremultiplied->new->BufferedImage
BufferedImageGraphicsConfig#getColorModel():::Returns the color model associated with this configuration.:::return
BufferedImageGraphicsConfig#getColorModel(int):::Returns the color model associated with this configuration that supports the specified transparency.:::if->model->getTransparency->return->switch->return->new->DirectColorModel->return->new->DirectColorModel->return->ColorModel->getRGBdefault->return
BufferedImageGraphicsConfig#getDefaultTransform():::Returns the default Transform for this configuration:::return->AffineTransform->getScaleInstance
BufferedImageGraphicsConfig#getNormalizingTransform():::Returns a Transform that can be composed with the default Transform of a Graphics2D so that 72 units in user space will equal 1 inch in device space:::return->new->AffineTransform
BufferedImageGraphicsConfig#getBounds()::: buffered image graphics config get bounds:::return->new->Rectangle
BufImgSurfaceData#initIDs(Class, Class)::: buf img surface data init ds:::
BufImgSurfaceData#createData(BufferedImage)::: buf img surface data create data:::return->createData
BufImgSurfaceData#createData(BufferedImage, double, double)::: buf img surface data create data:::if->throw->new->NullPointerException->sData->cm->bufImg->getColorModel->type->bufImg->getType->switch->createDataIC->break->createDataIC->break->createDataIC->break->createDataIC->break->createDataBC->break->createDataBC->break->createDataBC->break->createDataSC->break->createDataSC->break->sType->switch->cm->getTransparency->if->isOpaqueGray->else->break->break->break->throw->new->InternalError->createDataBC->break->createDataBC->break->createDataSC->break->sType->sm->bufImg->getRaster->getSampleModel->switch->sm->getSampleSize->break->break->break->throw->new->InternalError->createDataBP->break->raster->bufImg->getRaster->numBands->raster->getNumBands->if->raster->getNumDataElements->getPixelStride->sType->if->dcm->aMask->dcm->getAlphaMask->rMask->dcm->getRedMask->gMask->dcm->getGreenMask->bMask->dcm->getBlueMask->if->else->if->else->createDataIC->break->else->if->raster->getNumDataElements->getPixelStride->sType->icm->if->dcm->aMask->dcm->getAlphaMask->rMask->dcm->getRedMask->gMask->dcm->getGreenMask->bMask->dcm->getBlueMask->if->else->if->else->if->if->icm->getPixelSize->if->isOpaqueGray->else->else->createDataSC->break->raster->getDataBuffer->new->BufImgSurfaceData->break->initSolidLoops->return
BufImgSurfaceData#createData(Raster, ColorModel)::: buf img surface data create data:::throw->new->InternalError
BufImgSurfaceData#createDataIC(BufferedImage, SurfaceType, double, double)::: buf img surface data create data c:::icRaster->bImg->getRaster->bisd->icRaster->getDataBuffer->new->BufImgSurfaceData->bisd->icRaster->getDataStorage->icRaster->getDataOffset->icRaster->getWidth->icRaster->getHeight->icRaster->getPixelStride->icRaster->getScanlineStride->initRaster->return
BufImgSurfaceData#createDataSC(BufferedImage, SurfaceType, IndexColorModel, double, double)::: buf img surface data create data c:::scRaster->bImg->getRaster->bisd->scRaster->getDataBuffer->new->BufImgSurfaceData->bisd->scRaster->getDataStorage->scRaster->getDataOffset->scRaster->getWidth->scRaster->getHeight->scRaster->getPixelStride->scRaster->getScanlineStride->initRaster->return
BufImgSurfaceData#createDataBC(BufferedImage, SurfaceType, int, double, double)::: buf img surface data create data c:::bcRaster->bImg->getRaster->bisd->bcRaster->getDataBuffer->new->BufImgSurfaceData->cm->bImg->getColorModel->icm->bisd->bcRaster->getDataStorage->bcRaster->getDataOffset->bcRaster->getWidth->bcRaster->getHeight->bcRaster->getPixelStride->bcRaster->getScanlineStride->initRaster->return
BufImgSurfaceData#createDataBP(BufferedImage, SurfaceType, double, double)::: buf img surface data create data p:::bpRaster->bImg->getRaster->bisd->bpRaster->getDataBuffer->new->BufImgSurfaceData->cm->bImg->getColorModel->icm->bisd->bpRaster->getDataStorage->bpRaster->getDataBitOffset->bpRaster->getDataBitOffset->bpRaster->getWidth->bpRaster->getHeight->bpRaster->getScanlineStride->initRaster->return
BufImgSurfaceData#getRenderLoops(SunGraphics2D)::: buf img surface data get render loops:::if->return->return->super->getRenderLoops
BufImgSurfaceData#getRaster(int, int, int, int)::: buf img surface data get raster:::return->bufImg->getRaster
BufImgSurfaceData#initRaster(Object, int, int, int, int, int, int, IndexColorModel):::Initializes the native Ops pointer.:::
BufImgSurfaceData#initSolidLoops()::: buf img surface data init solid loops:::getSurfaceType->getSolidLoops
BufImgSurfaceData#getSolidLoops(SurfaceType)::: buf img surface data get solid loops:::for->i->l->makeRenderLoops->System->arraycopy->System->arraycopy->return
BufImgSurfaceData#getReplacement()::: buf img surface data get replacement:::return->restoreContents
BufImgSurfaceData#getDeviceConfiguration()::: buf img surface data get device configuration:::if->BufferedImageGraphicsConfig->getConfig->return
BufImgSurfaceData#getBounds()::: buf img surface data get bounds:::return->bufImg->getWidth->bufImg->getHeight->new->Rectangle
BufImgSurfaceData#checkCustomComposite()::: buf img surface data check custom composite:::
BufImgSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
BufImgSurfaceData#getDefaultScaleX()::: buf img surface data get default scale x:::return
BufImgSurfaceData#getDefaultScaleY()::: buf img surface data get default scale y:::return
BufImgSurfaceManager#getPrimarySurfaceData()::: buf img surface manager get primary surface data:::return
BufImgSurfaceManager#restoreContents():::Called from platform-specific SurfaceData objects to attempt to auto-restore the contents of an accelerated surface that has been lost.:::return
BufImgVolatileSurfaceManager#isAccelerationEnabled():::Returns false to indicate that this surface manager cannot accelerate the image.:::return
BufImgVolatileSurfaceManager#initAcceleratedSurface():::Returns null to indicate failure in creating the accelerated surface:::return
ByteArrayImageSource#checkSecurity(Object, boolean)::: byte array image source check security:::return
ByteArrayImageSource#getDecoder()::: byte array image source get decoder:::is->new->ByteArrayInputStream->new->BufferedInputStream->return->getDecoder
ByteBandedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteBandedRaster#getDataOffset(int):::Returns data offset for the specified band:::return
ByteBandedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteBandedRaster#getPixelStride():::Returns the pixel stride, which is always equal to one for a Raster with a BandedSampleModel.:::return
ByteBandedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
ByteBandedRaster#getDataStorage(int):::Returns a reference to the specific band data array.:::return
ByteBandedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteBandedRaster#getDataElements(int, int, int, int, Object):::Returns an  array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->yoff->for->c->return
ByteBandedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array  of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->if->System->arraycopy->else->off->for->ystart->return
ByteBandedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->for->c->return
ByteBandedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteBandedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteBandedRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->for->startY
ByteBandedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->for->c->markDirty
ByteBandedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->System->arraycopy->else->for->markDirty
ByteBandedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->for->c->markDirty
ByteBandedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteBandedRaster
ByteBandedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
ByteBandedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteBandedRaster
ByteBandedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ByteBandedRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->for->i->for->i->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->maxIndex->index->for->i->if->if->throw->new->RasterFormatException->else->for->i
ByteBandedRaster#toString()::: byte banded raster to string:::return->new->String
ByteComponentRaster#initIDs()::: byte component raster init ds:::
ByteComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteComponentRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ByteComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements between two samples for the same band on the same scanline.:::return
ByteComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
ByteComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->yoff->xoff->off->xstart->ystart->for->return
ByteComponentRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ByteComponentRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->for->return
ByteComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteComponentRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->if->bct->bdata->bct->getDataStorage->if->toff->bct->getDataOffset->tss->bct->getScanlineStride->srcOffset->dstOffset->if->bct->getPixelStride->for->tmpY->markDirty->return->for->startY
ByteComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->if->srcOffset->dstOffset->for->markDirty->return->for->markDirty
ByteComponentRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ByteComponentRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->if->System->arraycopy->else->for->else->for->else->for->markDirty
ByteComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ByteComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteComponentRaster
ByteComponentRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteComponentRaster
ByteComponentRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ByteComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->for->i->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
ByteComponentRaster#toString()::: byte component raster to string:::return->new->String
ByteInterleavedRaster#isInterleaved(ComponentSampleModel):::Analyzes a ComponentSampleModel to determine if it can function as a PixelInterleavedSampleModel:::numBands->sampleModel->getNumBands->if->return->bankIndices->sm->getBankIndices->for->i->bandOffsets->sm->getBandOffsets->minOffset->maxOffset->for->i->if->sm->getPixelStride->return->return
ByteInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteInterleavedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ByteInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements between two samples for the same band on the same scanline.:::return
ByteInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
ByteInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array of data elements from the specified rectangular region:::return->getByteData
ByteInterleavedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ByteInterleavedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->rowBytes->if->System->arraycopy->else->for->else->if->for->else->if->d1->for->else->if->d1->d2->for->else->if->d1->d2->d3->for->else->for->return
ByteInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->dstOffX->dstOffY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteInterleavedRaster#setDataElements(int, int, int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->if->bct->bdata->bct->getDataStorage->if->toff->bct->getDataOffset->tss->bct->getScanlineStride->tps->bct->getPixelStride->srcOffset->dstOffset->nbytes->for->tmpY->markDirty->return->for->startY
ByteInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::putByteData
ByteInterleavedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ByteInterleavedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->rowBytes->if->System->arraycopy->else->for->else->if->for->else->if->d1->for->else->if->d1->d2->for->else->if->d1->d2->d3->for->else->for->markDirty
ByteInterleavedRaster#getSample(int, int, int)::: byte interleaved raster get sample:::if->throw->new->ArrayIndexOutOfBoundsException->if->offset->sample->return->else->offset->return
ByteInterleavedRaster#setSample(int, int, int, int)::: byte interleaved raster set sample:::if->throw->new->ArrayIndexOutOfBoundsException->if->offset->bitMask->value->else->offset->markDirty
ByteInterleavedRaster#getSamples(int, int, int, int, int, int[])::: byte interleaved raster get samples:::if->throw->new->ArrayIndexOutOfBoundsException->samples->if->else->new->intArr->lineOffset->dstOffset->if->bitMask->bitOffset->for->j->else->for->j->return
ByteInterleavedRaster#setSamples(int, int, int, int, int, int[])::: byte interleaved raster set samples:::if->throw->new->ArrayIndexOutOfBoundsException->lineOffset->srcOffset->if->bitMask->for->j->else->for->i->markDirty
ByteInterleavedRaster#getPixels(int, int, int, int, int[])::: byte interleaved raster get pixels:::if->throw->new->ArrayIndexOutOfBoundsException->pixels->if->else->new->intArr->lineOffset->dstOffset->if->for->j->else->d0->if->for->j->else->if->d1->for->j->else->if->d1->d2->for->j->else->if->d1->d2->d3->for->j->else->for->j->return
ByteInterleavedRaster#setPixels(int, int, int, int, int[])::: byte interleaved raster set pixels:::if->throw->new->ArrayIndexOutOfBoundsException->lineOffset->srcOffset->if->for->j->else->d0->if->for->j->else->if->d1->for->j->else->if->d1->d2->for->j->else->if->d1->d2->d3->for->j->else->for->j->markDirty
ByteInterleavedRaster#setRect(int, int, Raster)::: byte interleaved raster set rect:::if->super->setRect->return->width->srcRaster->getWidth->height->srcRaster->getHeight->srcOffX->srcRaster->getMinX->srcOffY->srcRaster->getMinY->dstOffX->dstOffY->if->skipX->if->skipY->if->if->setDataElements
ByteInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ByteInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteInterleavedRaster
ByteInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteInterleavedRaster
ByteInterleavedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ByteInterleavedRaster#toString()::: byte interleaved raster to string:::return->new->String
BytePackedRaster#initIDs()::: byte packed raster init ds:::
BytePackedRaster#getDataBitOffset():::Returns the data bit offset for the Raster:::return
BytePackedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
BytePackedRaster#getPixelBitStride():::Returns pixel bit stride -- the number of bits between two samples on the same scanline.:::return
BytePackedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
BytePackedRaster#getDataElements(int, int, Object):::Returns the data element at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->bitnum->element->shift->return
BytePackedRaster#getDataElements(int, int, int, int, Object):::Returns the pixel data for the specified rectangle of pixels in a primitive array of type TransferType:::return->getByteData
BytePackedRaster#getPixelData(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array containing the specified data elements from the data array:::return->getByteData
BytePackedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array containing the specified data elements from the data array:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#setDataElements(int, int, Object):::Stores the data elements at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->bitnum->index->shift->element->markDirty
BytePackedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::if->super->setDataElements->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->dstOffX->dstOffY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
BytePackedRaster#setDataElements(int, int, int, int, int, int, BytePackedRaster):::Stores the Raster data at the specified location.:::if->return->inData->outData->inscan->outscan->inbit->outbit->copybits->if->bitpos->if->bits->inbyte->outbyte->mask->if->for->j->if->inbyte->outbyte->copybytes->if->System->arraycopy->else->for->j->bits->if->inbyte->outbyte->mask->for->j->else->bitpos->if->bits->inbyte->outbyte->lshift->rshift->mask->if->lastByte->for->j->if->inbyte->outbyte->copybytes->lshift->rshift->for->j->bits->if->inbyte->outbyte->mask->lshift->rshift->lastByte->for->j->markDirty
BytePackedRaster#setRect(int, int, Raster):::Copies pixels from Raster srcRaster to this WritableRaster:::if->super->setRect->return->width->srcRaster->getWidth->height->srcRaster->getHeight->srcOffX->srcRaster->getMinX->srcOffY->srcRaster->getMinY->dstOffX->dstOffY->if->skipX->if->skipY->if->if->setDataElements
BytePackedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::putByteData
BytePackedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::putByteData
BytePackedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->return->pixbits->scanbit->index->outindex->data->for->j->markDirty
BytePackedRaster#getPixels(int, int, int, int, int[]):::Returns an int array containing all samples for a rectangle of pixels, one sample per array element:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->intArr->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#setPixels(int, int, int, int, int[]):::Sets all samples for a rectangle of pixels from an int array containing one sample per array element:::if->throw->new->ArrayIndexOutOfBoundsException->pixbits->scanbit->index->outindex->data->for->j->markDirty
BytePackedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
BytePackedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->BytePackedRaster
BytePackedRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->BytePackedRaster
BytePackedRaster#createCompatibleWritableRaster():::Creates a raster with the same layout and the same width and height, and with new zeroed data arrays.:::return->createCompatibleWritableRaster
BytePackedRaster#verify(boolean):::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastbit->if->throw->new->RasterFormatException->if->if->if->throw->new->RasterFormatException
BytePackedRaster#toString()::: byte packed raster to string:::return->new->String
DataBufferNative#getElem(int, int, SurfaceData)::: data buffer native get elem:::
DataBufferNative#getElem(int, int):::getElem returns the pixel value for a given index into the dataBuffer array:::return->getElem
DataBufferNative#setElem(int, int, int, SurfaceData)::: data buffer native set elem:::
DataBufferNative#setElem(int, int, int):::setElem sets the pixel value of a given index into the dataBuffer array:::setElem
FileImageSource#checkSecurity(Object, boolean)::: file image source check security:::return
FileImageSource#getDecoder()::: file image source get decoder:::if->return->is->try->new->FileInputStream->new->BufferedInputStream->catch->return->finally->return->getDecoder
GifImageDecoder#error(String):::An error has occurred:::throw->new->ImageFormatException
GifImageDecoder#readBytes(byte[], int, int):::Read a number of bytes into a buffer.:::while->try->n->input->read->if->break->catch->break->finally->return
GifImageDecoder#ExtractByte(byte[], int)::: gif image decoder  extract byte:::return
GifImageDecoder#ExtractWord(byte[], int)::: gif image decoder  extract word:::return
GifImageDecoder#produceImage():::produce an image from the stream.:::try->readHeader->totalframes->frameno->nloops->disposal_method->delay->loopsRead->isAnimation->while->code->switch->input->read->switch->input->read->buf->new->byteArr->if->readBytes->return->if->return->ExtractWord->if->ImageFetcher->startingAnimation->if->ExtractByte->else->break->loop_tag->comment->while->n->input->read->if->break->buf->new->byteArr->if->readBytes->return->if->new->String->else->if->if->if->if->ExtractWord->else->ExtractWord->else->if->new->String->equals->if->props->put->if->ImageFetcher->startingAnimation->break->return->break->if->input->mark->try->if->readImage->return->catch->if->e->printStackTrace->return->finally->break->if->if->println->else->println->if->return->if->try->if->curframe->dispose->input->reset->break->catch->return->finally->if->println->imageComplete->return->catch->finally->close
GifImageDecoder#readHeader():::Read Image header:::buf->new->byteArr->if->readBytes->throw->new->IOException->if->error->ExtractWord->ExtractWord->ch->ExtractByte->if->new->byteArr->else->ExtractByte->if->props->ExtractByte->put->new->byteArr->if->readBytes->throw->new->IOException->input->mark
GifImageDecoder#initIDs()::: gif image decoder init ds:::
GifImageDecoder#parseImage(int, int, int, int, boolean, int, byte[], byte[], IndexColorModel)::: gif image decoder parse image:::
GifImageDecoder#sendPixels(int, int, int, int, byte[], ColorModel)::: gif image decoder send pixels:::rasbeg->rasend->x2->if->if->if->return->if->else->if->if->return->off->save->if->if->model->equals->for->i->else->runstart->count->for->i->if->setPixels->return->else->if->System->arraycopy->count->setPixels->return
GifImageDecoder#readImage(boolean, int, int):::Read Image data:::if->curframe->dispose->abort->return->tm->if->System->currentTimeMillis->block->new->byteArr->if->readBytes->throw->new->IOException->x->ExtractWord->y->ExtractWord->width->ExtractWord->height->ExtractWord->if->if->interlace->model->if->num_local_colors->local_colormap->new->byteArr->if->readBytes->throw->new->IOException->if->readBytes->throw->new->IOException->if->grow_colormap->new->IndexColorModel->else->if->model->getTransparentPixel->if->grow_colormap->new->IndexColorModel->if->if->if->setDimensions->setProperties->setColorModel->headerComplete->if->new->byteArr->if->tpix->model->getTransparentPixel->if->trans_rasline->new->byteArr->for->i->setPixels->setPixels->hints->setHints->new->GifFrame->rasline->new->byteArr->if->print->initCodeSize->ExtractByte->if->if->println->return->ret->parseImage->if->abort->if->System->currentTimeMillis->println->return
GifImageDecoder#grow_colormap(byte[], int)::: gif image decoder grow_colormap:::newcm->new->byteArr->System->arraycopy->return
GifFrame#setPixels(int, int, int, int, ColorModel, byte[], int, int)::: gif frame set pixels:::decoder->setPixels
GifFrame#dispose()::: gif frame dispose:::if->decoder->imageComplete->return->else->if->try->if->println->Thread->sleep->catch->return->finally->else->Thread->yield->if->println->global_width->global_height->if->if->if->else->if->if->if->switch->saved_image->saved_model->if->setPixels->break->tpix->if->model->getTransparentPixel->else->model->getTransparentPixel->rasline->new->byteArr->if->for->i->if->for->i->setPixels->break->break->return
ImageCache#getInstance()::: image cache get instance:::return->AppContext->new->ImageCache->getSoftReferenceValue
ImageCache#flush()::: image cache flush:::lock->writeLock->lock->try->map->clear->catch->finally->lock->writeLock->unlock
ImageCache#getImage(PixelsKey)::: image cache get image:::ref->lock->readLock->lock->try->map->get->catch->finally->lock->readLock->unlock->return->ref->get
ImageCache#setImage(PixelsKey, Image):::Sets the cached image for the specified constraints.:::lock->writeLock->lock->try->ref->map->get->if->if->ref->get->return->key->getPixelCount->map->remove->newPixelCount->key->getPixelCount->if->while->referenceQueue->poll->map->remove->getPixelCount->if->mapIter->map->entrySet->iterator->while->mapIter->hasNext->entry->mapIter->next->mapIter->remove->img->entry->getValue->get->if->img->flush->entry->getValue->getPixelCount->map->new->ImageSoftReference->put->catch->finally->lock->writeLock->unlock
ImageCache.PixelsKey#getPixelCount()::: pixels key get pixel count:::
ImageConsumerQueue#removeConsumer(ImageConsumerQueue, ImageConsumer, boolean)::: image consumer queue remove consumer:::cqprev->for->cq->return
ImageConsumerQueue#isConsumer(ImageConsumerQueue, ImageConsumer)::: image consumer queue is consumer:::for->cq->return
ImageConsumerQueue#toString()::: image consumer queue to string:::return
ImageDecoder#isConsumer(ImageConsumer)::: image decoder is consumer:::return->ImageConsumerQueue->isConsumer
ImageDecoder#removeConsumer(ImageConsumer)::: image decoder remove consumer:::ImageConsumerQueue->removeConsumer->if->abort
ImageDecoder#nextConsumer(ImageConsumerQueue)::: image decoder next consumer:::synchronized->if->return->while->if->return->return
ImageDecoder#setDimensions(int, int)::: image decoder set dimensions:::cq->count->while->nextConsumer->setDimensions->return
ImageDecoder#setProperties(Hashtable)::: image decoder set properties:::cq->count->while->nextConsumer->setProperties->return
ImageDecoder#setColorModel(ColorModel)::: image decoder set color model:::cq->count->while->nextConsumer->setColorModel->return
ImageDecoder#setHints(int)::: image decoder set hints:::cq->count->while->nextConsumer->setHints->return
ImageDecoder#headerComplete()::: image decoder header complete:::feeder->setPriority
ImageDecoder#setPixels(int, int, int, int, ColorModel, byte[], int, int)::: image decoder set pixels:::source->latchConsumers->cq->count->while->nextConsumer->setPixels->return
ImageDecoder#setPixels(int, int, int, int, ColorModel, int[], int, int)::: image decoder set pixels:::source->latchConsumers->cq->count->while->nextConsumer->setPixels->return
ImageDecoder#imageComplete(int, boolean)::: image decoder image complete:::source->latchConsumers->if->source->doneDecoding->cq->count->while->nextConsumer->imageComplete->return
ImageDecoder#produceImage()::: image decoder produce image:::
ImageDecoder#abort()::: image decoder abort:::source->doneDecoding->close->new->java.security.PrivilegedAction<Object>->doPrivileged
ImageDecoder#close()::: image decoder close:::if->try->input->close->catch->finally
ImageFetchable#doFetch():::This method is called by one of the ImageFetcher threads to start the flow of information from the ImageProducer to the ImageConsumer.:::
ImageFetcher#add(ImageFetchable):::Adds an ImageFetchable to the queue of items to fetch:::info->FetcherInfo->getFetcherInfo->synchronized->if->contains->addElement->if->createFetchers->if->notify->else->removeElement->return->return
ImageFetcher#remove(ImageFetchable):::Removes an ImageFetchable from the queue of items to fetch.:::info->FetcherInfo->getFetcherInfo->synchronized->if->contains->removeElement
ImageFetcher#isFetcher(Thread):::Checks to see if the given thread is one of the ImageFetchers.:::info->FetcherInfo->getFetcherInfo->synchronized->for->i->return
ImageFetcher#amFetcher():::Checks to see if the current thread is one of the ImageFetchers.:::return->Thread->currentThread->isFetcher
ImageFetcher#nextImage():::Returns the next ImageFetchable to be processed:::info->FetcherInfo->getFetcherInfo->synchronized->src->end->System->currentTimeMillis->while->while->size->now->System->currentTimeMillis->if->return->try->wait->catch->return->finally->elementAt->removeElement->return
ImageFetcher#run():::The main run() method of an ImageFetcher Thread:::info->FetcherInfo->getFetcherInfo->try->fetchloop->catch->e->printStackTrace->finally->synchronized->me->Thread->currentThread->for->i
ImageFetcher#fetchloop():::The main ImageFetcher loop:::me->Thread->currentThread->while->isFetcher->Thread->interrupted->me->setPriority->src->nextImage->if->return->try->src->doFetch->catch->println->e->printStackTrace->finally->stoppingAnimation
ImageFetcher#startingAnimation():::Recycles this ImageFetcher thread as an image animator thread:::info->FetcherInfo->getFetcherInfo->me->Thread->currentThread->synchronized->for->i->me->setPriority->me->setName
ImageFetcher#stoppingAnimation(Thread):::Returns this image animator thread back to service as an ImageFetcher if possible:::info->FetcherInfo->getFetcherInfo->synchronized->index->for->i->if->me->setName->return
ImageFetcher#createFetchers(FetcherInfo):::Create and start ImageFetcher threads in the appropriate ThreadGroup.:::appContext->AppContext->getAppContext->threadGroup->appContext->getThreadGroup->fetcherThreadGroup->try->if->threadGroup->getParent->else->Thread->currentThread->getThreadGroup->parent->threadGroup->getParent->while->parent->getParent->threadGroup->getParent->catch->appContext->getThreadGroup->finally->fetcherGroup->new->java.security.PrivilegedAction<Object>->doPrivileged->return
FetcherInfo#getFetcherInfo()::: fetcher info get fetcher info:::appContext->AppContext->getAppContext->synchronized->info->appContext->get->if->new->FetcherInfo->appContext->put->return
ImageRepresentation#initIDs()::: image representation init ds:::
ImageRepresentation#reconstruct(int)::: image representation reconstruct:::if->src->checkSecurity->missinginfo->if->try->startProduction->while->try->wait->catch->Thread->currentThread->interrupt->return->finally->catch->finally->decrementWaiters
ImageRepresentation#setDimensions(int, int)::: image representation set dimensions:::if->src->checkSecurity->image->setDimensions->newInfo->if->imageComplete->return->if
ImageRepresentation#getWidth()::: image representation get width:::return
ImageRepresentation#getHeight()::: image representation get height:::return
ImageRepresentation#getColorModel()::: image representation get color model:::return
ImageRepresentation#getBufferedImage()::: image representation get buffered image:::return
ImageRepresentation#createImage(ColorModel, WritableRaster, boolean, Hashtable):::Returns the BufferedImage that will be used as the representation of the pixel data:::bi->new->BufferedImage->bi->image->getAccelerationPriority->setAccelerationPriority->return
ImageRepresentation#setProperties(Hashtable)::: image representation set properties:::if->src->checkSecurity->image->setProperties->newInfo
ImageRepresentation#setColorModel(ColorModel)::: image representation set color model:::if->src->checkSecurity->if->if->model->getTransparency->ColorModel->getRGBdefault->else->icm->icm->getMapSize->Math->max->new->intArr->icm->getRGBs->icm->getTransparentPixel->else->if->else->if->dcm->if->dcm->getRedMask->dcm->getGreenMask->dcm->getBlueMask
ImageRepresentation#createBufferedImage()::: image representation create buffered image:::try->cmodel->createCompatibleWritableRaster->cmodel->isAlphaPremultiplied->createImage->catch->ColorModel->getRGBdefault->cmodel->createCompatibleWritableRaster->createImage->finally->type->bimage->getType->if->ColorModel->getRGBdefault->else->if->dcm->if->dcm->getRedMask->dcm->getGreenMask->dcm->getBlueMask
ImageRepresentation#convertToRGB()::: image representation convert to b:::w->bimage->getWidth->h->bimage->getHeight->size->dbi->new->DataBufferInt->newpixels->SunWritableRaster->stealData->if->biRaster->getNumDataElements->bct->data->bct->getDataStorage->coff->bct->getDataOffset->for->i->else->srcpixels->off->for->y->SunWritableRaster->markDirty->ColorModel->getRGBdefault->bandMasks->Raster->createPackedRaster->cmodel->isAlphaPremultiplied->createImage
ImageRepresentation#setHints(int)::: image representation set hints:::if->src->checkSecurity
ImageRepresentation#setICMpixels(int, int, int, int, int[], byte[], int, int, IntegerComponentRaster)::: image representation set mpixels:::
ImageRepresentation#setDiffICM(int, int, int, int, int[], int, int, IndexColorModel, byte[], int, int, ByteComponentRaster, int)::: image representation set diff m:::
ImageRepresentation#setPixels(int, int, int, int, ColorModel, byte[], int, int)::: image representation set pixels:::lineOff->poff->newLUT->if->src->checkSecurity->synchronized->if->if->createBufferedImage->if->return->biWidth->biRaster->getWidth->biHeight->biRaster->getHeight->x1->y1->if->else->if->if->else->if->if->if->if->return->if->throw->new->ArrayIndexOutOfBoundsException->remainder->if->throw->new->ArrayIndexOutOfBoundsException->num->if->else->if->else->if->throw->new->ArrayIndexOutOfBoundsException->if->icm->bct->numlut->if->bct->getDataOffset->setDiffICM->convertToRGB->else->bct->markDirty->if->hasAlpha->icm->hasAlpha->if->nbits->icm->getPixelSize->new->IndexColorModel->createImage->return->if->pixel->iraster->if->if->getRGBs->if->if->setICMpixels->iraster->markDirty->else->abort->return->else->storage->new->intArr->soff->for->yoff->iraster->setDataElements->else->storage->new->intArr->for->yoff->else->if->biRaster->getNumDataElements->bt->if->bt->putByteData->else->bpix->new->byteArr->for->yoff->else->for->yoff->if->newInfo
ImageRepresentation#setPixels(int, int, int, int, ColorModel, int[], int, int)::: image representation set pixels:::lineOff->poff->if->src->checkSecurity->synchronized->if->if->createBufferedImage->storage->new->intArr->yoff->pixel->if->convertToRGB->if->iraster->if->iraster->setDataElements->else->for->else->if->model->getTransparency->cmodel->getTransparency->convertToRGB->if->iraster->data->iraster->getDataStorage->if->cmodel->equals->sstride->iraster->getScanlineStride->doff->for->iraster->markDirty->else->for->else->tmp->for->if->newInfo
ImageRepresentation#getOpaqueRGBImage()::: image representation get opaque image:::if->bimage->getType->w->bimage->getWidth->h->bimage->getHeight->size->db->biRaster->getDataBuffer->pixels->SunWritableRaster->stealData->for->i->opModel->new->DirectColorModel->bandmasks->opRaster->Raster->createPackedRaster->try->opImage->createImage->return->catch->return->finally->return
ImageRepresentation#imageComplete(int)::: image representation image complete:::if->src->checkSecurity->done->info->switch->break->image->addInfo->dispose->break->break->break->synchronized->if->image->getSource->removeConsumer->if->getOpaqueRGBImage->notifyAll->newInfo->image->infoDone
ImageRepresentation#startProduction()::: image representation start production:::if->image->getSource->startProduction
ImageRepresentation#checkConsumption()::: image representation check consumption:::if->isWatcherListEmpty->dispose
ImageRepresentation#notifyWatcherListEmpty()::: image representation notify watcher list empty:::checkConsumption
ImageRepresentation#decrementWaiters()::: image representation decrement waiters:::checkConsumption
ImageRepresentation#prepare(ImageObserver)::: image representation prepare:::if->src->checkSecurity->if->if->iw->imageUpdate->return->done->if->addWatcher->startProduction->return
ImageRepresentation#check(ImageObserver)::: image representation check:::if->src->checkSecurity->if->addWatcher->return
ImageRepresentation#drawToBufImage(Graphics, ToolkitImage, int, int, Color, ImageObserver)::: image representation draw to buf image:::if->src->checkSecurity->if->if->iw->imageUpdate->return->done->abort->if->addWatcher->startProduction->if->g->drawImage->return
ImageRepresentation#drawToBufImage(Graphics, ToolkitImage, int, int, int, int, Color, ImageObserver)::: image representation draw to buf image:::if->src->checkSecurity->if->if->iw->imageUpdate->return->done->abort->if->addWatcher->startProduction->if->g->drawImage->return
ImageRepresentation#drawToBufImage(Graphics, ToolkitImage, int, int, int, int, int, int, int, int, Color, ImageObserver)::: image representation draw to buf image:::if->src->checkSecurity->if->if->iw->imageUpdate->return->done->abort->if->addWatcher->startProduction->if->g->drawImage->return
ImageRepresentation#drawToBufImage(Graphics, ToolkitImage, AffineTransform, ImageObserver)::: image representation draw to buf image:::g2->if->src->checkSecurity->if->if->iw->imageUpdate->return->done->abort->if->addWatcher->startProduction->if->g2->drawImage->return
ImageRepresentation#abort()::: image representation abort:::image->getSource->removeConsumer->newInfo
ImageRepresentation#dispose()::: image representation dispose:::image->getSource->removeConsumer
ImageRepresentation#setAccelerationPriority(float)::: image representation set acceleration priority:::if->bimage->setAccelerationPriority
ImageWatched.Link#isWatcher(ImageObserver)::: link is watcher:::return
ImageWatched.Link#removeWatcher(ImageObserver)::: link remove watcher:::return
ImageWatched.Link#newInfo(Image, int, int, int, int, int)::: link new info:::return
ImageWatched.WeakLink#isWatcher(ImageObserver)::: weak link is watcher:::return->myref->get->next->isWatcher
ImageWatched.WeakLink#removeWatcher(ImageObserver)::: weak link remove watcher:::myiw->myref->get->if->return->next->removeWatcher->if->return->next->removeWatcher->return
ImageWatched.WeakLink#update(ImageObserver, AccessControlContext, Image, int, int, int, int, int)::: weak link update:::if->System->getSecurityManager->return->AccessController->return->iw->imageUpdate->doPrivileged->return
ImageWatched.WeakLink#newInfo(Image, int, int, int, int, int)::: weak link new info:::ret->next->newInfo->myiw->myref->get->if->else->if->update->myref->clear->return
ImageWatched#addWatcher(ImageObserver)::: image watched add watcher:::if->isWatcher->new->WeakLink->watcherList->removeWatcher
ImageWatched#isWatcher(ImageObserver)::: image watched is watcher:::return->watcherList->isWatcher
ImageWatched#removeWatcher(ImageObserver)::: image watched remove watcher:::synchronized->watcherList->removeWatcher->if->notifyWatcherListEmpty
ImageWatched#isWatcherListEmpty()::: image watched is watcher list empty:::synchronized->watcherList->removeWatcher->return
ImageWatched#newInfo(Image, int, int, int, int, int)::: image watched new info:::if->watcherList->newInfo->removeWatcher
ImageWatched#notifyWatcherListEmpty()::: image watched notify watcher list empty:::
ImagingLib#init():::Returned value indicates whether the library initailization was succeded:::
ImagingLib#transformBI(BufferedImage, BufferedImage, double[], int)::: imaging lib transform i:::
ImagingLib#transformRaster(Raster, Raster, double[], int)::: imaging lib transform raster:::
ImagingLib#convolveBI(BufferedImage, BufferedImage, Kernel, int)::: imaging lib convolve i:::
ImagingLib#convolveRaster(Raster, Raster, Kernel, int)::: imaging lib convolve raster:::
ImagingLib#lookupByteBI(BufferedImage, BufferedImage, byte[][])::: imaging lib lookup byte i:::
ImagingLib#lookupByteRaster(Raster, Raster, byte[][])::: imaging lib lookup byte raster:::
ImagingLib#getNativeOpIndex(Class)::: imaging lib get native op index:::opIndex->for->i->return
ImagingLib#filter(RasterOp, Raster, WritableRaster)::: imaging lib filter:::if->return->if->op->createCompatibleDestRaster->retRaster->switch->op->getClass->getNativeOpIndex->table->getTable->if->table->getOffset->return->if->bt->if->bt->getTable->lookupByteRaster->break->bOp->matrix->new->doubleArr->bOp->getTransform->getMatrix->if->bOp->getInterpolationType->transformRaster->break->cOp->if->cOp->getKernel->cOp->getEdgeCondition->convolveRaster->break->break->if->SunWritableRaster->markDirty->return
ImagingLib#filter(BufferedImageOp, BufferedImage, BufferedImage)::: imaging lib filter:::if->println->if->return->if->op->createCompatibleDestImage->retBI->switch->op->getClass->getNativeOpIndex->table->getTable->if->table->getOffset->return->if->bt->if->bt->getTable->lookupByteBI->break->bOp->matrix->new->doubleArr->xform->bOp->getTransform->bOp->getTransform->getMatrix->if->bOp->getInterpolationType->transformBI->break->cOp->if->cOp->getKernel->cOp->getEdgeCondition->convolveBI->break->break->if->SunWritableRaster->markDirty->return
InputStreamImageSource#checkSecurity(Object, boolean)::: input stream image source check security:::
InputStreamImageSource#countConsumers(ImageConsumerQueue)::: input stream image source count consumers:::i->while->return
InputStreamImageSource#countConsumers()::: input stream image source count consumers:::id->i->countConsumers->while->countConsumers->return
InputStreamImageSource#addConsumer(ImageConsumer)::: input stream image source add consumer:::addConsumer
InputStreamImageSource#printQueue(ImageConsumerQueue, String)::: input stream image source print queue:::while->println
InputStreamImageSource#printQueues(String)::: input stream image source print queues:::println->printQueue->for->id->println
InputStreamImageSource#addConsumer(ImageConsumer, boolean)::: input stream image source add consumer:::checkSecurity->for->id->cq->while->if->new->ImageConsumerQueue->else->if->context->security->System->getSecurityManager->if->security->getSecurityContext->if->else->if->equals->errorConsumer->throw->new->SecurityException->if->startProduction
InputStreamImageSource#isConsumer(ImageConsumer)::: input stream image source is consumer:::for->id->return->ImageConsumerQueue->isConsumer
InputStreamImageSource#errorAllConsumers(ImageConsumerQueue, boolean)::: input stream image source error all consumers:::while->if->errorConsumer
InputStreamImageSource#errorConsumer(ImageConsumerQueue, boolean)::: input stream image source error consumer:::imageComplete->if->flush->removeConsumer
InputStreamImageSource#removeConsumer(ImageConsumer)::: input stream image source remove consumer:::for->id->ImageConsumerQueue->removeConsumer
InputStreamImageSource#startProduction(ImageConsumer)::: input stream image source start production:::addConsumer
InputStreamImageSource#startProduction()::: input stream image source start production:::if->if->ImageFetcher->add->else->cq->errorAllConsumers
InputStreamImageSource#stopProduction()::: input stream image source stop production:::if->ImageFetcher->remove
InputStreamImageSource#requestTopDownLeftRightResend(ImageConsumer)::: input stream image source request top down left right resend:::
InputStreamImageSource#getDecoder()::: input stream image source get decoder:::
InputStreamImageSource#decoderForType(InputStream, String)::: input stream image source decoder for type:::return
InputStreamImageSource#getDecoder(InputStream)::: input stream image source get decoder:::if->is->markSupported->new->BufferedInputStream->try->is->mark->c1->is->read->c2->is->read->c3->is->read->c4->is->read->c5->is->read->c6->is->read->c7->is->read->c8->is->read->is->reset->is->mark->if->return->new->GifImageDecoder->else->if->return->new->JPEGImageDecoder->else->if->return->new->XbmImageDecoder->else->if->return->new->PNGImageDecoder->catch->finally->return
InputStreamImageSource#doFetch()::: input stream image source do fetch:::synchronized->if->return->imgd->getDecoder->if->badDecoder->else->setDecoder->try->imgd->produceImage->catch->e->printStackTrace->e->printStackTrace->finally->removeDecoder->if->Thread->currentThread->isInterrupted->Thread->currentThread->isAlive->errorAllConsumers->else->errorAllConsumers
InputStreamImageSource#badDecoder()::: input stream image source bad decoder:::cq->synchronized->errorAllConsumers
InputStreamImageSource#setDecoder(ImageDecoder)::: input stream image source set decoder:::cq->synchronized->while->if->if->checkSecurity->errorConsumer
InputStreamImageSource#removeDecoder(ImageDecoder)::: input stream image source remove decoder:::doneDecoding->idprev->for->id
InputStreamImageSource#doneDecoding(ImageDecoder)::: input stream image source done decoding:::if->if->startProduction
InputStreamImageSource#latchConsumers(ImageDecoder)::: input stream image source latch consumers:::doneDecoding
InputStreamImageSource#flush()::: input stream image source flush:::
IntegerComponentRaster#initIDs()::: integer component raster init ds:::
IntegerComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
IntegerComponentRaster#getDataOffset(int):::Returns data offset for the specified band:::return
IntegerComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
IntegerComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
IntegerComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
IntegerComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->intArr->else->off->for->band->return
IntegerComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->else->new->intArr->yoff->xoff->off->xstart->ystart->for->return
IntegerComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
IntegerComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
IntegerComponentRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->if->ict->if->ict->getNumDataElements->throw->new->ArrayIndexOutOfBoundsException->ict->getDataStorage->tss->ict->getScanlineStride->toff->ict->getDataOffset->srcOffset->dstOffset->if->ict->getPixelStride->for->startY->markDirty->return->odata->for->startY
IntegerComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
IntegerComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->IntegerComponentRaster
IntegerComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
IntegerComponentRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same band layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->IntegerComponentRaster
IntegerComponentRaster#createCompatibleWritableRaster():::Creates a raster with the same data layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
IntegerComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
IntegerComponentRaster#toString()::: integer component raster to string:::return->new->String
IntegerInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
IntegerInterleavedRaster#getDataOffset(int):::Returns data offset for the specified band:::return
IntegerInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
IntegerInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
IntegerInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
IntegerInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->intArr->else->off->return
IntegerInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->else->new->intArr->yoff->off->for->ystart->return
IntegerInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->markDirty
IntegerInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
IntegerInterleavedRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->if->ict->ict->getDataStorage->tss->ict->getScanlineStride->toff->ict->getDataOffset->srcOffset->dstOffset->for->startY->markDirty->return->odata->for->startY
IntegerInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->off->for->ystart->markDirty
IntegerInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->IntegerInterleavedRaster
IntegerInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
IntegerInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same band layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->IntegerInterleavedRaster
IntegerInterleavedRaster#createCompatibleWritableRaster():::Creates a raster with the same data layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
IntegerInterleavedRaster#toString()::: integer interleaved raster to string:::return->new->String
JPEGImageDecoder#initIDs(Class)::: image decoder init ds:::
JPEGImageDecoder#readImage(InputStream, byte[])::: image decoder read image:::
JPEGImageDecoder#error(String):::An error has occurred:::throw->new->ImageFormatException
JPEGImageDecoder#sendHeaderInfo(int, int, boolean, boolean, boolean)::: image decoder send header info:::setDimensions->setProperties->if->else->if->else->setColorModel->flags->if->setHints->headerComplete->return
JPEGImageDecoder#sendPixels(int[], int)::: image decoder send pixels:::count->setPixels->if->return
JPEGImageDecoder#sendPixels(byte[], int)::: image decoder send pixels:::count->setPixels->if->return
JPEGImageDecoder#produceImage():::produce an image from the stream.:::try->new->byteArr->readImage->if->imageComplete->catch->if->throw->finally->close
MultiResolutionCachedImage#getResolutionVariant(double, double)::: multi resolution cached image get resolution variant:::checkSize->width->Math->ceil->height->Math->ceil->cache->ImageCache->getInstance->key->new->ImageCacheKey->resolutionVariant->cache->getImage->if->mapper->apply->cache->setImage->preload->return
MultiResolutionCachedImage#checkSize(double, double)::: multi resolution cached image check size:::if->throw->String->format->new->IllegalArgumentException->if->Double->isFinite->Double->isFinite->throw->String->format->new->IllegalArgumentException
MultiResolutionCachedImage#getResolutionVariants()::: multi resolution cached image get resolution variants:::return->Arrays->stream->size->getWidth->size->getHeight->getResolutionVariant->map->Collectors->toList->collect
MultiResolutionCachedImage#map(Function)::: multi resolution cached image map:::return->mapper->getResolutionVariant->apply->new->MultiResolutionCachedImage
MultiResolutionCachedImage#map(MultiResolutionImage, Function)::: multi resolution cached image map:::if->mrtImage->return->MultiResolutionToolkitImage->map->sizeMapper->mapper->mrImage->getResolutionVariant->apply->if->mrcImage->return->new->MultiResolutionCachedImage->image->width->image->getWidth->height->image->getHeight->return->new->MultiResolutionCachedImage
MultiResolutionCachedImage#getWidth(ImageObserver)::: multi resolution cached image get width:::updateInfo->return
MultiResolutionCachedImage#getHeight(ImageObserver)::: multi resolution cached image get height:::updateInfo->return
MultiResolutionCachedImage#getProperty(String, ImageObserver)::: multi resolution cached image get property:::updateInfo->return
MultiResolutionCachedImage#getScaledInstance(int, int, int)::: multi resolution cached image get scaled instance:::return->getResolutionVariant
MultiResolutionCachedImage#getBaseImage()::: multi resolution cached image get base image:::return->getResolutionVariant
MultiResolutionCachedImage#updateInfo(ImageObserver, int)::: multi resolution cached image update info:::
MultiResolutionCachedImage#getInfo(Image)::: multi resolution cached image get info:::if->return->getImageRep->check->return
MultiResolutionCachedImage#preload(Image, int)::: multi resolution cached image preload:::if->new->ImageObserver->preload
MultiResolutionCachedImage.ImageCacheKey#getPixelCount()::: image cache key get pixel count:::return
MultiResolutionCachedImage.ImageCacheKey#hash()::: image cache key hash:::hash->baseImage->hashCode->return
MultiResolutionCachedImage.ImageCacheKey#hashCode()::: image cache key hash code:::return
MultiResolutionCachedImage.ImageCacheKey#equals(Object)::: image cache key equals:::if->key->return->return
MultiResolutionToolkitImage#getResolutionVariant(double, double)::: multi resolution toolkit image get resolution variant:::checkSize->return->getWidth->getHeight
MultiResolutionToolkitImage#map(MultiResolutionToolkitImage, Function)::: multi resolution toolkit image map:::baseImage->mapper->apply->rvImage->mapper->apply->return->new->MultiResolutionToolkitImage
MultiResolutionToolkitImage#checkSize(double, double)::: multi resolution toolkit image check size:::if->throw->String->format->new->IllegalArgumentException->if->Double->isFinite->Double->isFinite->throw->String->format->new->IllegalArgumentException
MultiResolutionToolkitImage#getResolutionVariant()::: multi resolution toolkit image get resolution variant:::return
MultiResolutionToolkitImage#getResolutionVariants()::: multi resolution toolkit image get resolution variants:::return->Arrays->asList
MultiResolutionToolkitImage#getResolutionVariantObserver(Image, ImageObserver, int, int, int, int)::: multi resolution toolkit image get resolution variant observer:::return->getResolutionVariantObserver
MultiResolutionToolkitImage#getResolutionVariantObserver(Image, ImageObserver, int, int, int, int, boolean)::: multi resolution toolkit image get resolution variant observer:::if->return->synchronized->o->get->if->if->if->if->if->getImageRep->check->return->observer->imageUpdate->put->return
NativeLibLoader#loadLibraries():::This is copied from java.awt.Toolkit since we need the library loaded in sun.awt.image also:  WARNING: This is a temporary workaround for a problem in the way the AWT loads native libraries:::new->java.security.PrivilegedAction<Void>->doPrivileged
OffScreenImage#getGraphics()::: off screen image get graphics:::return->createGraphics
OffScreenImage#createGraphics()::: off screen image create graphics:::if->env->GraphicsEnvironment->getLocalGraphicsEnvironment->return->env->createGraphics->bg->c->getBackground->if->fg->c->getForeground->if->font->c->getFont->if->if->new->Font->return->SurfaceData->getPrimarySurfaceData->new->SunGraphics2D
OffScreenImage#initSurface(int, int)::: off screen image init surface:::g2->createGraphics->try->g2->clearRect->catch->finally->g2->dispose
OffScreenImage#getSource()::: off screen image get source:::if->new->OffScreenImageSource->return
OffScreenImageSource#addConsumer(ImageConsumer)::: off screen image source add consumer:::produce
OffScreenImageSource#isConsumer(ImageConsumer)::: off screen image source is consumer:::return
OffScreenImageSource#removeConsumer(ImageConsumer)::: off screen image source remove consumer:::if
OffScreenImageSource#startProduction(ImageConsumer)::: off screen image source start production:::addConsumer
OffScreenImageSource#requestTopDownLeftRightResend(ImageConsumer)::: off screen image source request top down left right resend:::
OffScreenImageSource#sendPixels()::: off screen image source send pixels:::cm->image->getColorModel->raster->image->getRaster->numDataElements->raster->getNumDataElements->dataType->raster->getDataBuffer->getDataType->scanline->new->intArr->needToCvt->if->pixels->new->byteArr->theConsumer->setColorModel->if->for->y->else->if->for->y->else->if->for->y->else->if->theConsumer->setColorModel->switch->for->y->break->bscanline->new->byteArr->for->y->break->sscanline->new->shortArr->for->y->break->if->newcm->ColorModel->getRGBdefault->theConsumer->setColorModel->for->y
OffScreenImageSource#produce()::: off screen image source produce:::try->theConsumer->image->getWidth->image->getHeight->setDimensions->theConsumer->setProperties->sendPixels->theConsumer->imageComplete->if->try->theConsumer->imageComplete->catch->e->printStackTrace->finally->catch->e->printStackTrace->if->theConsumer->imageComplete->finally
PixelConverter#rgbToPixel(int, ColorModel)::: pixel converter rgb to pixel:::obj->cm->getDataElements->switch->cm->getTransferType->bytearr->pix->switch->return->shortarr->return->return->return
PixelConverter#pixelToRgb(int, ColorModel)::: pixel converter pixel to rgb:::return
PixelConverter#getAlphaMask()::: pixel converter get alpha mask:::return
PixelConverter.Rgbx#rgbToPixel(int, ColorModel)::: rgbx rgb to pixel:::return
PixelConverter.Rgbx#pixelToRgb(int, ColorModel)::: rgbx pixel to rgb:::return
PixelConverter.Xrgb#rgbToPixel(int, ColorModel)::: xrgb rgb to pixel:::return
PixelConverter.Xrgb#pixelToRgb(int, ColorModel)::: xrgb pixel to rgb:::return
PixelConverter.Argb#rgbToPixel(int, ColorModel)::: argb rgb to pixel:::return
PixelConverter.Argb#pixelToRgb(int, ColorModel)::: argb pixel to rgb:::return
PixelConverter.Ushort565Rgb#rgbToPixel(int, ColorModel)::: ushort565 rgb rgb to pixel:::return
PixelConverter.Ushort565Rgb#pixelToRgb(int, ColorModel)::: ushort565 rgb pixel to rgb:::r->g->b->return
PixelConverter.Ushort555Rgbx#rgbToPixel(int, ColorModel)::: ushort555 rgbx rgb to pixel:::return
PixelConverter.Ushort555Rgbx#pixelToRgb(int, ColorModel)::: ushort555 rgbx pixel to rgb:::r->g->b->return
PixelConverter.Ushort555Rgb#rgbToPixel(int, ColorModel)::: ushort555 rgb rgb to pixel:::return
PixelConverter.Ushort555Rgb#pixelToRgb(int, ColorModel)::: ushort555 rgb pixel to rgb:::r->g->b->return
PixelConverter.Ushort4444Argb#rgbToPixel(int, ColorModel)::: ushort4444 argb rgb to pixel:::a->r->g->b->return
PixelConverter.Ushort4444Argb#pixelToRgb(int, ColorModel)::: ushort4444 argb pixel to rgb:::a->r->g->b->return
PixelConverter.Xbgr#rgbToPixel(int, ColorModel)::: xbgr rgb to pixel:::return
PixelConverter.Xbgr#pixelToRgb(int, ColorModel)::: xbgr pixel to rgb:::return
PixelConverter.Bgrx#rgbToPixel(int, ColorModel)::: bgrx rgb to pixel:::return
PixelConverter.Bgrx#pixelToRgb(int, ColorModel)::: bgrx pixel to rgb:::return
PixelConverter.Rgba#rgbToPixel(int, ColorModel)::: rgba rgb to pixel:::return
PixelConverter.Rgba#pixelToRgb(int, ColorModel)::: rgba pixel to rgb:::return
PixelConverter.RgbaPre#rgbToPixel(int, ColorModel)::: rgba pre rgb to pixel:::if->return->a->r->g->b->a2->return
PixelConverter.RgbaPre#pixelToRgb(int, ColorModel)::: rgba pre pixel to rgb:::a->if->return->r->g->b->return
PixelConverter.ArgbPre#rgbToPixel(int, ColorModel)::: argb pre rgb to pixel:::if->return->a->r->g->b->a2->return
PixelConverter.ArgbPre#pixelToRgb(int, ColorModel)::: argb pre pixel to rgb:::a->if->return->r->g->b->return
PixelConverter.ArgbBm#rgbToPixel(int, ColorModel)::: argb bm rgb to pixel:::return
PixelConverter.ArgbBm#pixelToRgb(int, ColorModel)::: argb bm pixel to rgb:::return
PixelConverter.ByteGray#rgbToPixel(int, ColorModel)::: byte gray rgb to pixel:::red->grn->blu->return
PixelConverter.ByteGray#pixelToRgb(int, ColorModel)::: byte gray pixel to rgb:::return
PixelConverter.UshortGray#rgbToPixel(int, ColorModel)::: ushort gray rgb to pixel:::red->grn->blu->return
PixelConverter.UshortGray#pixelToRgb(int, ColorModel)::: ushort gray pixel to rgb:::return
PNGImageDecoder#property(String, Object)::: image decoder property:::if->return->if->new->java.util.Hashtable<>->properties->put
PNGImageDecoder#property(String, float)::: image decoder property:::Float->valueOf->property
PNGImageDecoder#pngassert(boolean)::: image decoder pngassert:::if->e->new->PNGException->e->printStackTrace->throw
PNGImageDecoder#handleChunk(int, byte[], int, int)::: image decoder handle chunk:::switch->c->switch->pngassert->new->Color->break->pngassert->ix->pngassert->new->Color->break->pngassert->t->new->Color->break->if->property->break->getInt->getInt->getInt->getInt->getInt->getInt->getInt->getInt->new->Chromaticities->property->break->if->throw->new->PNGException->getInt->if->property->break->break->return->break->if->getInt->getInt->throw->new->PNGException->getByte->getByte->getByte->getByte->getByte->break->tsize->new->byteArr->new->byteArr->new->byteArr->for->i->j->break->break->break->klen->while->if->tkey->new->String->tvalue->new->String->property->break->getShort->getByte->getByte->getByte->getByte->getByte->new->GregorianCalendar->getTime->property->break->switch->alen->if->new->byteArr->System->arraycopy->while->break->pngassert->if->new->byteArr->for->i->else->getShort->getShort->getShort->break->pngassert->t->getShort->break->break->break->return
PNGImageDecoder#produceImage()::: image decoder produce image:::try->for->i->is->new->Inflater->new->InflaterInputStream->new->BufferedInputStream->getData->bPixels->wPixels->pixSize->rowStride->logDepth->switch->break->break->break->break->break->throw->new->PNGException->if->else->combinedType->bitMask->switch->if->throw->new->PNGException->if->new->IndexColorModel->else->new->IndexColorModel->new->byteArr->break->llog->if->size->ramp->new->byteArr->for->i->if->new->IndexColorModel->else->new->IndexColorModel->new->byteArr->break->ColorModel->getRGBdefault->new->intArr->break->throw->new->PNGException->setDimensions->setColorModel->flags->setHints->headerComplete->samplesPerPixel->bitsPerPixel->bytesPerPixel->pass->passLimit->if->else->while->row->rowInc->colInc->bWidth->bHeight->sCol->rowPixelWidth->rowByteWidth->if->continue->pixelBufferInc->rowOffset->firstRow->rowByteBuffer->new->byteArr->prevRowByteBuffer->new->byteArr->while->rowFilter->is->read->for->rowFillPos->filterRow->col->spos->pixel->while->if->switch->break->break->if->break->isTransparent->for->i->if->break->tx->break->tx->break->throw->new->PNGException->else->switch->break->break->break->break->break->throw->new->PNGException->if->if->sendPixels->else->sendPixels->T->if->if->sendPixels->else->sendPixels->imageComplete->catch->if->property->imageComplete->throw->finally->try->close->catch->finally
PNGImageDecoder#sendPixels(int, int, int, int, int[], int, int)::: image decoder send pixels:::count->setPixels->if->return
PNGImageDecoder#sendPixels(int, int, int, int, byte[], int, int)::: image decoder send pixels:::count->setPixels->if->return
PNGImageDecoder#filterRow(byte[], byte[], int, int, int)::: image decoder filter row:::x->switch->break->for->break->if->for->break->if->for->for->else->for->break->if->for->for->else->for->break->throw->new->PNGException
PNGImageDecoder#fill()::: image decoder fill:::if->if->System->arraycopy->else->if->bsize->while->n->underlyingInputStream->read->if->break
PNGImageDecoder#need(int)::: image decoder need:::if->return->fill->if->return->if->return->nin->new->byteArr->System->arraycopy->fill->return
PNGImageDecoder#getInt(int)::: image decoder get int:::return
PNGImageDecoder#getShort(int)::: image decoder get short:::return
PNGImageDecoder#getByte(int)::: image decoder get byte:::return
PNGImageDecoder#getChunk()::: image decoder get chunk:::if->need->return->getInt->getInt->if->throw->new->PNGException->if->need->return->getInt->calcCRC->crc->if->throw->new->PNGException->return
PNGImageDecoder#readAll()::: image decoder read all:::while->getChunk->handleChunk
PNGImageDecoder#getData()::: image decoder get data:::while->getChunk->if->handleChunk->return
PNGImageDecoder#getCheckCRC()::: image decoder get check c:::return
PNGImageDecoder#setCheckCRC(boolean)::: image decoder set check c:::
PNGImageDecoder#wrc(int)::: image decoder wrc:::if->write
PNGImageDecoder#wrk(int)::: image decoder wrk:::wrc->wrc->wrc->wrc
PNGImageDecoder#print()::: image decoder print:::wrk->print
PNGImageDecoder#update_crc(int, byte[], int, int)::: image decoder update_crc:::c->while->return
PNGImageDecoder#crc(byte[], int, int)::: image decoder crc:::return->update_crc
PNGImageDecoder.Chromaticities#toString()::: chromaticities to string:::return
PNGFilterInputStream#available()::: filter input stream available:::return->in->available
PNGFilterInputStream#markSupported()::: filter input stream mark supported:::return
PNGFilterInputStream#read()::: filter input stream read:::if->if->owner->getData->return->return
PNGFilterInputStream#read(byte[])::: filter input stream read:::return->read
PNGFilterInputStream#read(byte[], int, int)::: filter input stream read:::if->if->owner->getData->return->if->System->arraycopy->return
PNGFilterInputStream#skip(long)::: filter input stream skip:::i->for->read->return
ShortBandedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortBandedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortBandedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ShortBandedRaster#getPixelStride():::Returns the pixel stride, which is always equal to one for a Raster with a BandedSampleModel.:::return
ShortBandedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
ShortBandedRaster#getDataStorage(int):::Returns a reference to the specific band data array.:::return
ShortBandedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortBandedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->for->c->return
ShortBandedRaster#getShortData(int, int, int, int, int, short[]):::Returns a short array  of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->if->System->arraycopy->else->off->for->ystart->return
ShortBandedRaster#getShortData(int, int, int, int, short[]):::Returns a short array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->for->c->return
ShortBandedRaster#setDataElements(int, int, Object):::Stores the data element for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortBandedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortBandedRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->for->startY
ShortBandedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->for->c->markDirty
ShortBandedRaster#putShortData(int, int, int, int, int, short[]):::Stores a short array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->System->arraycopy->else->for->markDirty
ShortBandedRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->for->c->markDirty
ShortBandedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortBandedRaster
ShortBandedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
ShortBandedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortBandedRaster
ShortBandedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ShortBandedRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->for->i->for->i->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->maxIndex->index->for->i->for->i
ShortBandedRaster#toString()::: short banded raster to string:::return->new->String
ShortComponentRaster#initIDs()::: short component raster init ds:::
ShortComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortComponentRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the same sample in the same column of the next row.:::return
ShortComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
ShortComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
ShortComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->xoff->off->xstart->ystart->for->return
ShortComponentRaster#getShortData(int, int, int, int, int, short[]):::Returns a short integer array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ShortComponentRaster#getShortData(int, int, int, int, short[]):::Returns a short integer array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->for->return
ShortComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortComponentRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->for->startY
ShortComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
ShortComponentRaster#putShortData(int, int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ShortComponentRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->for->markDirty
ShortComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ShortComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortComponentRaster
ShortComponentRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortComponentRaster
ShortComponentRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ShortComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->for->i->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
ShortComponentRaster#toString()::: short component raster to string:::return->new->String
ShortInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortInterleavedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the same sample in the same column of the next row.:::return
ShortInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
ShortInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
ShortInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->xoff->off->xstart->ystart->for->return
ShortInterleavedRaster#getShortData(int, int, int, int, int, short[]):::Returns a short integer array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ShortInterleavedRaster#getShortData(int, int, int, int, short[]):::Returns a short integer array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->for->return
ShortInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortInterleavedRaster#setDataElements(int, int, int, int, Raster):::Stores the Raster data at the specified location.:::if->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->tdata->for->startY
ShortInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
ShortInterleavedRaster#putShortData(int, int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ShortInterleavedRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->for->markDirty
ShortInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ShortInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortInterleavedRaster
ShortInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortInterleavedRaster
ShortInterleavedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ShortInterleavedRaster#toString()::: short interleaved raster to string:::return->new->String
SunVolatileImage#getWidth()::: sun volatile image get width:::return
SunVolatileImage#getHeight()::: sun volatile image get height:::return
SunVolatileImage#getGraphicsConfig()::: sun volatile image get graphics config:::return
SunVolatileImage#updateGraphicsConfig()::: sun volatile image update graphics config:::if->gc->comp->getGraphicsConfiguration->if
SunVolatileImage#getComponent()::: sun volatile image get component:::return
SunVolatileImage#getForcedAccelSurfaceType()::: sun volatile image get forced accel surface type:::return
SunVolatileImage#createSurfaceManager(Object, ImageCapabilities)::: sun volatile image create surface manager:::if->caps->isAccelerated->return->new->BufImgVolatileSurfaceManager->smf->SurfaceManagerFactory->getInstance->return->smf->createVolatileManager
SunVolatileImage#getForeground()::: sun volatile image get foreground:::if->return->comp->getForeground->else->return
SunVolatileImage#getBackground()::: sun volatile image get background:::if->return->comp->getBackground->else->return
SunVolatileImage#getFont()::: sun volatile image get font:::if->return->comp->getFont->else->if->new->Font->return
SunVolatileImage#createGraphics()::: sun volatile image create graphics:::return->volSurfaceManager->getPrimarySurfaceData->getForeground->getBackground->getFont->new->SunGraphics2D
SunVolatileImage#getProperty(String, ImageObserver)::: sun volatile image get property:::if->throw->new->NullPointerException->return
SunVolatileImage#getWidth(ImageObserver)::: sun volatile image get width:::return->getWidth
SunVolatileImage#getHeight(ImageObserver)::: sun volatile image get height:::return->getHeight
SunVolatileImage#getBackupImage():::This method creates a BufferedImage intended for use as a "snapshot" or a backup surface.:::return->getBackupImage
SunVolatileImage#getBackupImage(double, double):::This method creates a BufferedImage intended for use as a "snapshot" or a backup surface with the given horizontal and vertical scale factors.:::w->Region->getWidth->clipRound->h->Region->getHeight->clipRound->return->graphicsConfig->getTransparency->createCompatibleImage
SunVolatileImage#getSnapshot()::: sun volatile image get snapshot:::bi->getBackupImage->g->bi->createGraphics->g->setComposite->g->drawImage->g->dispose->return
SunVolatileImage#validate(GraphicsConfiguration)::: sun volatile image validate:::return->volSurfaceManager->validate
SunVolatileImage#contentsLost()::: sun volatile image contents lost:::return->volSurfaceManager->contentsLost
SunVolatileImage#getCapabilities()::: sun volatile image get capabilities:::return->volSurfaceManager->getCapabilities
SunVolatileImage#getDestSurface()::: sun volatile image get dest surface:::return->volSurfaceManager->getPrimarySurfaceData
SunWritableRaster.DataStealer#getData(DataBufferByte, int)::: data stealer get data:::
SunWritableRaster.DataStealer#getData(DataBufferUShort, int)::: data stealer get data:::
SunWritableRaster.DataStealer#getData(DataBufferInt, int)::: data stealer get data:::
SunWritableRaster.DataStealer#getTrackable(DataBuffer)::: data stealer get trackable:::
SunWritableRaster.DataStealer#setTrackable(DataBuffer, StateTrackableDelegate)::: data stealer set trackable:::
SunWritableRaster#setDataStealer(DataStealer)::: sun writable raster set data stealer:::if->throw->new->InternalError
SunWritableRaster#stealData(DataBufferByte, int)::: sun writable raster steal data:::return->stealer->getData
SunWritableRaster#stealData(DataBufferUShort, int)::: sun writable raster steal data:::return->stealer->getData
SunWritableRaster#stealData(DataBufferInt, int)::: sun writable raster steal data:::return->stealer->getData
SunWritableRaster#stealTrackable(DataBuffer)::: sun writable raster steal trackable:::return->stealer->getTrackable
SunWritableRaster#setTrackable(DataBuffer, StateTrackableDelegate)::: sun writable raster set trackable:::stealer->setTrackable
SunWritableRaster#makeTrackable(DataBuffer)::: sun writable raster make trackable:::stealer->StateTrackableDelegate->createInstance->setTrackable
SunWritableRaster#markDirty(DataBuffer)::: sun writable raster mark dirty:::stealer->getTrackable->markDirty
SunWritableRaster#markDirty(WritableRaster)::: sun writable raster mark dirty:::if->markDirty->else->wr->getDataBuffer->markDirty
SunWritableRaster#markDirty(Image)::: sun writable raster mark dirty:::SurfaceData->getPrimarySurfaceData->markDirty
SunWritableRaster#markDirty():::Mark the TrackableDelegate of the associated DataBuffer dirty.:::theTrackable->markDirty
SurfaceManager.ImageAccessor#getSurfaceManager(Image)::: image accessor get surface manager:::
SurfaceManager.ImageAccessor#setSurfaceManager(Image, SurfaceManager)::: image accessor set surface manager:::
SurfaceManager#setImageAccessor(ImageAccessor)::: surface manager set image accessor:::if->throw->new->InternalError
SurfaceManager#getManager(Image):::Returns the SurfaceManager object contained within the given Image.:::sMgr->imgaccessor->getSurfaceManager->if->try->bi->new->BufImgSurfaceManager->setManager->catch->throw->new->IllegalArgumentException->finally->return
SurfaceManager#setManager(Image, SurfaceManager)::: surface manager set manager:::imgaccessor->setSurfaceManager
SurfaceManager#getCacheData(Object):::Return an arbitrary cached object for an arbitrary cache key:::return->cacheMap->get
SurfaceManager#setCacheData(Object, Object):::Store an arbitrary cached object for an arbitrary cache key:::if->synchronized->if->new->ConcurrentHashMap<>->cacheMap->put
SurfaceManager#getPrimarySurfaceData():::Returns the main SurfaceData object that "owns" the pixels for this SurfaceManager:::
SurfaceManager#restoreContents():::Restores the primary surface being managed, and then returns the replacement surface:::
SurfaceManager#acceleratedSurfaceLost():::Notification that any accelerated surfaces associated with this manager have been "lost", which might mean that they need to be manually restored or recreated:::
SurfaceManager#getCapabilities(GraphicsConfiguration):::Returns an ImageCapabilities object which can be inquired as to the specific capabilities of this Image:::return->new->ImageCapabilitiesGc
SurfaceManager.ImageCapabilitiesGc#isAccelerated()::: image capabilities gc is accelerated:::tmpGc->if->GraphicsEnvironment->getLocalGraphicsEnvironment->getDefaultScreenDevice->getDefaultConfiguration->if->proxyKey->getProxyKey->if->sdp->getCacheData->return->sdp->isAccelerated->return
SurfaceManager.ProxiedGraphicsConfig#getProxyKey():::Return the key that destination surfaces created on the given GraphicsConfiguration use to store SurfaceDataProxy objects for their cached copies.:::
SurfaceManager#flush():::Releases system resources in use by ancillary SurfaceData objects, such as surfaces cached in accelerated memory:::flush
SurfaceManager#flush(boolean)::: surface manager flush:::if->i->cacheMap->values->iterator->while->i->hasNext->o->i->next->if->if->flush->i->remove
SurfaceManager.FlushableCacheData#flush(boolean):::Flush all cached resources:::
SurfaceManager#setAccelerationPriority(float):::Called when image's acceleration priority is changed:::if->flush
SurfaceManager#getImageScaleX(Image):::Returns a horizontal scale factor of the image:::if->return->sm->getManager->return->sm->getPrimarySurfaceData->getDefaultScaleX
SurfaceManager#getImageScaleY(Image):::Returns a vertical scale factor of the image:::if->return->sm->getManager->return->sm->getPrimarySurfaceData->getDefaultScaleY
ToolkitImage#getSource()::: toolkit image get source:::if->src->checkSecurity->return
ToolkitImage#getWidth():::Return the width of the original image source:::if->src->checkSecurity->if->reconstruct->return
ToolkitImage#getWidth(ImageObserver):::Return the width of the original image source:::if->src->checkSecurity->if->addWatcher->if->return->return
ToolkitImage#getHeight():::Return the height of the original image source:::if->src->checkSecurity->if->reconstruct->return
ToolkitImage#getHeight(ImageObserver):::Return the height of the original image source:::if->src->checkSecurity->if->addWatcher->if->return->return
ToolkitImage#getProperty(String, ImageObserver):::Return a property of the image by name:::if->throw->new->NullPointerException->if->src->checkSecurity->if->addWatcher->if->return->o->properties->get->if->return
ToolkitImage#hasError()::: toolkit image has error:::if->src->checkSecurity->return
ToolkitImage#check(ImageObserver)::: toolkit image check:::if->src->checkSecurity->if->addWatcher->return
ToolkitImage#preload(ImageObserver)::: toolkit image preload:::if->src->checkSecurity->if->addWatcher
ToolkitImage#addWatcher(ImageObserver, boolean)::: toolkit image add watcher:::if->if->iw->imageUpdate->return->ir->getImageRep->ir->addWatcher->if->ir->startProduction
ToolkitImage#reconstruct(int)::: toolkit image reconstruct:::if->if->return->ir->getImageRep->ir->startProduction->while->try->wait->catch->Thread->currentThread->interrupt->return->finally->if->return
ToolkitImage#addInfo(int)::: toolkit image add info:::notifyAll
ToolkitImage#setDimensions(int, int)::: toolkit image set dimensions:::addInfo
ToolkitImage#setProperties(Hashtable)::: toolkit image set properties:::if->new->Hashtable<String,Object>->addInfo
ToolkitImage#infoDone(int)::: toolkit image info done:::if->addInfo->else->if->setProperties
ToolkitImage#flush()::: toolkit image flush:::if->src->checkSecurity->ir->synchronized->if->ir->abort->if->src->flush
ToolkitImage#makeImageRep()::: toolkit image make image rep:::return->ColorModel->getRGBdefault->new->ImageRepresentation
ToolkitImage#getImageRep()::: toolkit image get image rep:::if->src->checkSecurity->if->makeImageRep->return
ToolkitImage#getGraphics()::: toolkit image get graphics:::throw->new->UnsupportedOperationException
ToolkitImage#getColorModel()::: toolkit image get color model:::imageRep->getImageRep->return->imageRep->getColorModel
ToolkitImage#getBufferedImage()::: toolkit image get buffered image:::imageRep->getImageRep->return->imageRep->getBufferedImage
ToolkitImage#setAccelerationPriority(float)::: toolkit image set acceleration priority:::super->setAccelerationPriority->imageRep->getImageRep->imageRep->setAccelerationPriority
URLImageSource#checkSecurity(Object, boolean)::: image source check security:::if->try->security->System->getSecurityManager->if->security->checkConnect->catch->if->throw->return->finally->return
URLImageSource#getConnection()::: image source get connection:::c->if->else->url->openConnection->return
URLImageSource#getDecoder()::: image source get decoder:::is->type->c->try->getConnection->c->getInputStream->c->getContentType->u->c->getURL->if->u->getHost->url->getHost->equals->u->getPort->url->getPort->if->actualHost->u->getHost->equals->u->getPort->throw->new->SecurityException->u->getHost->u->getPort->catch->if->try->is->close->catch->finally->else->if->disconnect->return->finally->id->decoderForType->if->getDecoder->if->if->try->is->close->catch->finally->else->if->disconnect->return
VolatileSurfaceManager#initialize():::This init function is separate from the constructor because the things we are doing here necessitate the object's existence:::if->isAccelerationEnabled->initAcceleratedSurface->if->if->vImg->getForcedAccelSurfaceType->getBackupSurface
VolatileSurfaceManager#getPrimarySurfaceData()::: volatile surface manager get primary surface data:::return
VolatileSurfaceManager#isAccelerationEnabled():::Returns true if acceleration is enabled:::
VolatileSurfaceManager#validate(GraphicsConfiguration):::Get the image ready for rendering:::returnCode->lostSurfaceTmp->if->isAccelerationEnabled->if->isConfigValid->else->if->initAcceleratedSurface->if->else->getBackupSurface->else->if->sdAccel->isSurfaceLost->try->restoreAcceleratedSurface->sdAccel->setSurfaceLost->catch->getBackupSurface->finally->else->if->else->if->getBackupSurface->else->if->if->if->initContents->return
VolatileSurfaceManager#contentsLost():::Returns true if rendering data was lost since the last validate call.:::return
VolatileSurfaceManager#initAcceleratedSurface():::Creates a new accelerated surface that is compatible with the current GraphicsConfiguration:::
VolatileSurfaceManager#getBackupSurface():::Creates a software-based surface (of type BufImgSurfaceData):::if->gc->vImg->getGraphicsConfig->tx->gc->getDefaultTransform->scaleX->tx->getScaleX->scaleY->tx->getScaleY->bImg->vImg->getBackupImage->SunWritableRaster->bImg->getRaster->getDataBuffer->stealTrackable->setUntrackable->BufImgSurfaceData->createData->return
VolatileSurfaceManager#initContents():::Set contents of the current SurfaceData to default state (i.e:::if->g->vImg->createGraphics->g->vImg->getWidth->vImg->getHeight->clearRect->g->dispose
VolatileSurfaceManager#restoreContents():::Called from a SurfaceData object, indicating that our accelerated surface has been lost and should be restored (perhaps using a backup system memory surface):::return->getBackupSurface
VolatileSurfaceManager#acceleratedSurfaceLost():::If the accelerated surface is the current SurfaceData for this manager, sets the variable lostSurface to true, which indicates that something happened to the image under management:::if->isAccelerationEnabled
VolatileSurfaceManager#restoreAcceleratedSurface():::Restore sdAccel in case it was lost:::
VolatileSurfaceManager#displayChanged():::Called from SunGraphicsEnv when there has been a display mode change:::if->oldData->oldData->invalidate->getBackupSurface->vImg->updateGraphicsConfig->atUpdated->vImg->getGraphicsConfig->getDefaultTransform->if->isAccelerationEnabled->if->atUpdated->equals->getBackupSurface->else
VolatileSurfaceManager#paletteChanged():::When device palette changes, need to force a new copy of the image into our hardware cache to update the color indices of the pixels (indexed mode only).:::
VolatileSurfaceManager#isConfigValid(GraphicsConfiguration):::Called by validate() to see whether the GC passed in is ok for rendering to:::return->gc->getDevice->vImg->getGraphicsConfig->getDevice
VolatileSurfaceManager#getCapabilities(GraphicsConfiguration)::: volatile surface manager get capabilities:::if->isConfigValid->return->isAccelerationEnabled->new->AcceleratedImageCapabilities->new->ImageCapabilities->return->super->getCapabilities
VolatileSurfaceManager.AcceleratedImageCapabilities#isAccelerated()::: accelerated image capabilities is accelerated:::return
VolatileSurfaceManager.AcceleratedImageCapabilities#isTrueVolatile()::: accelerated image capabilities is true volatile:::return->isAccelerated
VolatileSurfaceManager#flush():::Releases any associated hardware memory for this image by calling flush on sdAccel:::oldSD->if->oldSD->flush
VSyncedBSManager#getInstance(boolean)::: synced manager get instance:::if->new->SingleVSyncedBSMgr->new->NoLimitVSyncBSMgr->return
VSyncedBSManager#checkAllowed(BufferStrategy)::: synced manager check allowed:::
VSyncedBSManager#relinquishVsync(BufferStrategy)::: synced manager relinquish vsync:::
VSyncedBSManager#vsyncAllowed(BufferStrategy):::Returns true if the buffer strategy is allowed to be created v-synced.:::bsm->getInstance->return->bsm->checkAllowed
VSyncedBSManager#releaseVsync(BufferStrategy):::Lets the manager know that this buffer strategy is no longer interested in being v-synced.:::bsm->getInstance->if->bsm->relinquishVsync
VSyncedBSManager.NoLimitVSyncBSMgr#checkAllowed(BufferStrategy)::: no limit sync mgr check allowed:::return
VSyncedBSManager.NoLimitVSyncBSMgr#relinquishVsync(BufferStrategy)::: no limit sync mgr relinquish vsync:::
VSyncedBSManager.SingleVSyncedBSMgr#checkAllowed(BufferStrategy)::: single synced mgr check allowed:::if->current->strategy->get->if->return->new->WeakReference<BufferStrategy>->return
VSyncedBSManager.SingleVSyncedBSMgr#relinquishVsync(BufferStrategy)::: single synced mgr relinquish vsync:::if->b->strategy->get->if->strategy->clear
WritableRasterNative#createNativeRaster(SampleModel, DataBuffer)::: writable raster native create native raster:::return->new->WritableRasterNative
WritableRasterNative#createNativeRaster(ColorModel, SurfaceData, int, int)::: writable raster native create native raster:::smHw->dataType->scanStride->switch->cm->getPixelSize->if->cm->getPixelSize->else->bandOffsets->new->intArr->new->PixelInterleavedSampleModel->break->bitMasks->new->intArr->dcm->dcm->getRedMask->dcm->getGreenMask->dcm->getBlueMask->new->SinglePixelPackedSampleModel->break->new->intArr->dcm->getRedMask->dcm->getGreenMask->dcm->getBlueMask->new->SinglePixelPackedSampleModel->break->throw->cm->getPixelSize->new->InternalError->dbn->new->DataBufferNative->return->new->WritableRasterNative
XbmImageDecoder#error(String):::An error has occurred:::throw->new->ImageFormatException
XbmImageDecoder#produceImage():::produce an image from the stream.:::nm->new->charArr->c->i->state->H->W->x->y->start->raster->model->while->input->read->if->if->else->if->nc->if->if->error->if->else->if->else->if->n->for->p->for->mask->if->if->setPixels->return->if->break->else->n->for->p->if->if->else->if->else->new->IndexColorModel->setDimensions->setColorModel->setHints->headerComplete->new->byteArr->input->close->imageComplete
