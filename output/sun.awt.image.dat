BufferedImageDevice#getType():::Returns the type of this GraphicsDevice.:::return
BufferedImageDevice#getIDstring():::Returns the identification string associated with this GraphicsDevice.:::return
BufferedImageDevice#getConfigurations():::Returns all of the GraphicsConfiguration objects associated with this GraphicsDevice.:::return->new->GraphicsConfigurationArr
BufferedImageDevice#getDefaultConfiguration():::Returns the default GraphicsConfiguration associated with this GraphicsDevice.:::return
BufferedImageGraphicsConfig#getDevice():::Return the graphics device associated with this configuration.:::return
BufferedImageGraphicsConfig#createCompatibleImage(int, int):::Returns a BufferedImage with channel layout and color model compatible with this graphics configuration:::wr->raster->createCompatibleWritableRaster->return->model->isAlphaPremultiplied->new->BufferedImage
BufferedImageGraphicsConfig#getColorModel():::Returns the color model associated with this configuration.:::return
BufferedImageGraphicsConfig#getColorModel(int):::Returns the color model associated with this configuration that supports the specified transparency.:::if->model->getTransparency->return->switch->return->new->DirectColorModel->return->new->DirectColorModel->return->ColorModel->getRGBdefault->return
BufferedImageGraphicsConfig#getDefaultTransform():::Returns the default Transform for this configuration:::return->AffineTransform->getScaleInstance
BufferedImageGraphicsConfig#getNormalizingTransform():::Returns a Transform that can be composed with the default Transform of a Graphics2D so that 72 units in user space will equal 1 inch in device space:::return->new->AffineTransform
BufImgSurfaceData#initRaster(Object, int, int, int, int, int, int, IndexColorModel):::Initializes the native Ops pointer.:::
BufImgSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
BufImgSurfaceManager#restoreContents():::Called from platform-specific SurfaceData objects to attempt to auto-restore the contents of an accelerated surface that has been lost.:::return
BufImgVolatileSurfaceManager#isAccelerationEnabled():::Returns false to indicate that this surface manager cannot accelerate the image.:::return
BufImgVolatileSurfaceManager#initAcceleratedSurface():::Returns null to indicate failure in creating the accelerated surface:::return
ByteBandedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteBandedRaster#getDataOffset(int):::Returns data offset for the specified band:::return
ByteBandedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteBandedRaster#getPixelStride():::Returns the pixel stride, which is always equal to one for a Raster with a BandedSampleModel.:::return
ByteBandedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
ByteBandedRaster#getDataStorage(int):::Returns a reference to the specific band data array.:::return
ByteBandedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteBandedRaster#getDataElements(int, int, int, int, Object):::Returns an  array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->yoff->for->c->return
ByteBandedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array  of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->if->System->arraycopy->else->off->for->ystart->return
ByteBandedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->for->c->return
ByteBandedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteBandedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteBandedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->for->c->markDirty
ByteBandedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->System->arraycopy->else->for->markDirty
ByteBandedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->for->c->markDirty
ByteBandedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteBandedRaster
ByteBandedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
ByteBandedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteBandedRaster
ByteBandedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ByteComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteComponentRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ByteComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements between two samples for the same band on the same scanline.:::return
ByteComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
ByteComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->yoff->xoff->off->xstart->ystart->for->return
ByteComponentRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ByteComponentRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->for->return
ByteComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->if->srcOffset->dstOffset->for->markDirty->return->for->markDirty
ByteComponentRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ByteComponentRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->if->System->arraycopy->else->for->else->for->else->for->markDirty
ByteComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ByteComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteComponentRaster
ByteComponentRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteComponentRaster
ByteComponentRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ByteComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->for->i->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
ByteInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ByteInterleavedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ByteInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ByteInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements between two samples for the same band on the same scanline.:::return
ByteInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
ByteInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->off->for->band->return
ByteInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array of data elements from the specified rectangular region:::return->getByteData
ByteInterleavedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ByteInterleavedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->yoff->xoff->off->xstart->ystart->if->rowBytes->if->System->arraycopy->else->for->else->if->for->else->if->d1->for->else->if->d1->d2->for->else->if->d1->d2->d3->for->else->for->return
ByteInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ByteInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->dstOffX->dstOffY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ByteInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::putByteData
ByteInterleavedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ByteInterleavedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->rowBytes->if->System->arraycopy->else->for->else->if->for->else->if->d1->for->else->if->d1->d2->for->else->if->d1->d2->d3->for->else->for->markDirty
ByteInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ByteInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ByteInterleavedRaster
ByteInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ByteInterleavedRaster
ByteInterleavedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
BytePackedRaster#getDataBitOffset():::Returns the data bit offset for the Raster:::return
BytePackedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
BytePackedRaster#getPixelBitStride():::Returns pixel bit stride -- the number of bits between two samples on the same scanline.:::return
BytePackedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
BytePackedRaster#getDataElements(int, int, Object):::Returns the data element at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->bitnum->element->shift->return
BytePackedRaster#getDataElements(int, int, int, int, Object):::Returns the pixel data for the specified rectangle of pixels in a primitive array of type TransferType:::return->getByteData
BytePackedRaster#getPixelData(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->byteArr->else->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#getByteData(int, int, int, int, int, byte[]):::Returns a byte array containing the specified data elements from the data array:::return->getByteData
BytePackedRaster#getByteData(int, int, int, int, byte[]):::Returns a byte array containing the specified data elements from the data array:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->byteArr->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#setDataElements(int, int, Object):::Stores the data elements at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->bitnum->index->shift->element->markDirty
BytePackedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::if->super->setDataElements->return->srcOffX->inRaster->getMinX->srcOffY->inRaster->getMinY->dstOffX->dstOffY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
BytePackedRaster#setRect(int, int, Raster):::Copies pixels from Raster srcRaster to this WritableRaster:::if->super->setRect->return->width->srcRaster->getWidth->height->srcRaster->getHeight->srcOffX->srcRaster->getMinX->srcOffY->srcRaster->getMinY->dstOffX->dstOffY->if->skipX->if->skipY->if->if->setDataElements
BytePackedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::putByteData
BytePackedRaster#putByteData(int, int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::putByteData
BytePackedRaster#putByteData(int, int, int, int, byte[]):::Stores a byte array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->return->pixbits->scanbit->index->outindex->data->for->j->markDirty
BytePackedRaster#getPixels(int, int, int, int, int[]):::Returns an int array containing all samples for a rectangle of pixels, one sample per array element:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->intArr->pixbits->scanbit->index->outindex->data->for->j->return
BytePackedRaster#setPixels(int, int, int, int, int[]):::Sets all samples for a rectangle of pixels from an int array containing one sample per array element:::if->throw->new->ArrayIndexOutOfBoundsException->pixbits->scanbit->index->outindex->data->for->j->markDirty
BytePackedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
BytePackedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->BytePackedRaster
BytePackedRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->BytePackedRaster
BytePackedRaster#createCompatibleWritableRaster():::Creates a raster with the same layout and the same width and height, and with new zeroed data arrays.:::return->createCompatibleWritableRaster
DataBufferNative#getElem(int, int):::getElem returns the pixel value for a given index into the dataBuffer array:::return->getElem
DataBufferNative#setElem(int, int, int):::setElem sets the pixel value of a given index into the dataBuffer array:::setElem
GifImageDecoder#produceImage():::produce an image from the stream.:::try->readHeader->totalframes->frameno->nloops->disposal_method->delay->loopsRead->isAnimation->while->code->switch->input->read->switch->input->read->buf->new->byteArr->if->readBytes->return->if->return->ExtractWord->if->ImageFetcher->startingAnimation->if->ExtractByte->else->break->loop_tag->comment->while->n->input->read->if->break->buf->new->byteArr->if->readBytes->return->if->new->String->else->if->if->if->if->ExtractWord->else->ExtractWord->else->if->new->String->equals->if->props->put->if->ImageFetcher->startingAnimation->break->return->break->if->input->mark->try->if->readImage->return->catch->if->e->printStackTrace->return->finally->break->if->if->println->else->println->if->return->if->try->if->curframe->dispose->input->reset->break->catch->return->finally->if->println->imageComplete->return->catch->finally->close
ImageCache#setImage(PixelsKey, Image):::Sets the cached image for the specified constraints.:::lock->writeLock->lock->try->ref->map->get->if->if->ref->get->return->key->getPixelCount->map->remove->newPixelCount->key->getPixelCount->if->while->referenceQueue->poll->map->remove->getPixelCount->if->mapIter->map->entrySet->iterator->while->mapIter->hasNext->entry->mapIter->next->mapIter->remove->img->entry->getValue->get->if->img->flush->entry->getValue->getPixelCount->map->new->ImageSoftReference->put->catch->finally->lock->writeLock->unlock
ImageFetchable#doFetch():::This method is called by one of the ImageFetcher threads to start the flow of information from the ImageProducer to the ImageConsumer.:::
ImageFetcher#add(ImageFetchable):::Adds an ImageFetchable to the queue of items to fetch:::info->FetcherInfo->getFetcherInfo->synchronized->if->contains->addElement->if->createFetchers->if->notify->else->removeElement->return->return
ImageFetcher#remove(ImageFetchable):::Removes an ImageFetchable from the queue of items to fetch.:::info->FetcherInfo->getFetcherInfo->synchronized->if->contains->removeElement
ImageFetcher#isFetcher(Thread):::Checks to see if the given thread is one of the ImageFetchers.:::info->FetcherInfo->getFetcherInfo->synchronized->for->i->return
ImageFetcher#amFetcher():::Checks to see if the current thread is one of the ImageFetchers.:::return->Thread->currentThread->isFetcher
ImageFetcher#run():::The main run() method of an ImageFetcher Thread:::info->FetcherInfo->getFetcherInfo->try->fetchloop->catch->e->printStackTrace->finally->synchronized->me->Thread->currentThread->for->i
ImageFetcher#startingAnimation():::Recycles this ImageFetcher thread as an image animator thread:::info->FetcherInfo->getFetcherInfo->me->Thread->currentThread->synchronized->for->i->me->setPriority->me->setName
ImageRepresentation#createImage(ColorModel, WritableRaster, boolean, Hashtable):::Returns the BufferedImage that will be used as the representation of the pixel data:::bi->new->BufferedImage->bi->image->getAccelerationPriority->setAccelerationPriority->return
IntegerComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
IntegerComponentRaster#getDataOffset(int):::Returns data offset for the specified band:::return
IntegerComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
IntegerComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
IntegerComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
IntegerComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->intArr->else->off->for->band->return
IntegerComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->else->new->intArr->yoff->xoff->off->xstart->ystart->for->return
IntegerComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
IntegerComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
IntegerComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
IntegerComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->IntegerComponentRaster
IntegerComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
IntegerComponentRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same band layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->IntegerComponentRaster
IntegerComponentRaster#createCompatibleWritableRaster():::Creates a raster with the same data layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
IntegerComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
IntegerInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
IntegerInterleavedRaster#getDataOffset(int):::Returns data offset for the specified band:::return
IntegerInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row.:::return
IntegerInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
IntegerInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
IntegerInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->intArr->else->off->return
IntegerInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->else->new->intArr->yoff->off->for->ystart->return
IntegerInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->markDirty
IntegerInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
IntegerInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->off->for->ystart->markDirty
IntegerInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->IntegerInterleavedRaster
IntegerInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
IntegerInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a raster with the same band layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->IntegerInterleavedRaster
IntegerInterleavedRaster#createCompatibleWritableRaster():::Creates a raster with the same data layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
JPEGImageDecoder#produceImage():::produce an image from the stream.:::try->new->byteArr->readImage->if->imageComplete->catch->if->throw->finally->close
NativeLibLoader#loadLibraries():::This is copied from java.awt.Toolkit since we need the library loaded in sun.awt.image also:  WARNING: This is a temporary workaround for a problem in the way the AWT loads native libraries:::new->java.security.PrivilegedAction<Void>->doPrivileged
ShortBandedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortBandedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortBandedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the sample in the same column of the next row in the same band.:::return
ShortBandedRaster#getPixelStride():::Returns the pixel stride, which is always equal to one for a Raster with a BandedSampleModel.:::return
ShortBandedRaster#getDataStorage():::Returns a reference to the entire data array.:::return
ShortBandedRaster#getDataStorage(int):::Returns a reference to the specific band data array.:::return
ShortBandedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortBandedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->for->c->return
ShortBandedRaster#getShortData(int, int, int, int, int, short[]):::Returns a short array  of data elements from the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->if->System->arraycopy->else->off->for->ystart->return
ShortBandedRaster#getShortData(int, int, int, int, short[]):::Returns a short array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->for->c->return
ShortBandedRaster#setDataElements(int, int, Object):::Stores the data element for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortBandedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortBandedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->for->c->markDirty
ShortBandedRaster#putShortData(int, int, int, int, int, short[]):::Stores a short array of data elements into the specified rectangular region for the specified band:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->System->arraycopy->else->for->markDirty
ShortBandedRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->for->c->markDirty
ShortBandedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortBandedRaster
ShortBandedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::return->createWritableChild
ShortBandedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortBandedRaster
ShortBandedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ShortComponentRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortComponentRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortComponentRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the same sample in the same column of the next row.:::return
ShortComponentRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
ShortComponentRaster#getDataStorage():::Returns a reference to the data array.:::return
ShortComponentRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortComponentRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->xoff->off->xstart->ystart->for->return
ShortComponentRaster#getShortData(int, int, int, int, int, short[]):::Returns a short integer array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ShortComponentRaster#getShortData(int, int, int, int, short[]):::Returns a short integer array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->for->return
ShortComponentRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortComponentRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortComponentRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
ShortComponentRaster#putShortData(int, int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ShortComponentRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->for->markDirty
ShortComponentRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ShortComponentRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortComponentRaster
ShortComponentRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortComponentRaster
ShortComponentRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
ShortComponentRaster#verify():::Verify that the layout parameters are consistent with the data:::if->throw->new->RasterFormatException->for->i->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->if->throw->new->RasterFormatException->lastScanOffset->if->throw->new->RasterFormatException->lastPixelOffset->if->throw->new->RasterFormatException->index->maxIndex->for->i->if->throw->new->RasterFormatException
ShortInterleavedRaster#getDataOffsets():::Returns a copy of the data offsets array:::return->dataOffsets->clone
ShortInterleavedRaster#getDataOffset(int):::Returns the data offset for the specified band:::return
ShortInterleavedRaster#getScanlineStride():::Returns the scanline stride -- the number of data array elements between a given sample and the same sample in the same column of the next row.:::return
ShortInterleavedRaster#getPixelStride():::Returns pixel stride -- the number of data array elements  between two samples for the same band on the same scanline.:::return
ShortInterleavedRaster#getDataStorage():::Returns a reference to the data array.:::return
ShortInterleavedRaster#getDataElements(int, int, Object):::Returns the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->off->for->band->return
ShortInterleavedRaster#getDataElements(int, int, int, int, Object):::Returns an array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->outData->if->new->shortArr->else->yoff->xoff->off->xstart->ystart->for->return
ShortInterleavedRaster#getShortData(int, int, int, int, int, short[]):::Returns a short integer array of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->return
ShortInterleavedRaster#getShortData(int, int, int, int, short[]):::Returns a short integer array  of data elements from the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->if->new->shortArr->yoff->xoff->off->xstart->ystart->for->return
ShortInterleavedRaster#setDataElements(int, int, Object):::Stores the data elements for all bands at the specified location:::if->throw->new->ArrayIndexOutOfBoundsException->inData->off->for->i->markDirty
ShortInterleavedRaster#setDataElements(int, int, Raster):::Stores the Raster data at the specified location:::dstOffX->inRaster->getMinX->dstOffY->inRaster->getMinY->width->inRaster->getWidth->height->inRaster->getHeight->if->throw->new->ArrayIndexOutOfBoundsException->setDataElements
ShortInterleavedRaster#setDataElements(int, int, int, int, Object):::Stores an array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->inData->yoff->xoff->off->xstart->ystart->for->markDirty
ShortInterleavedRaster#putShortData(int, int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->if->if->System->arraycopy->else->for->else->for->markDirty
ShortInterleavedRaster#putShortData(int, int, int, int, short[]):::Stores a short integer array of data elements into the specified rectangular region:::if->throw->new->ArrayIndexOutOfBoundsException->yoff->xoff->off->xstart->ystart->for->markDirty
ShortInterleavedRaster#createChild(int, int, int, int, int, int, int[]):::Creates a subraster given a region of the raster:::newRaster->createWritableChild->return
ShortInterleavedRaster#createWritableChild(int, int, int, int, int, int, int[]):::Creates a Writable subRaster given a region of the Raster:::if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->if->throw->new->RasterFormatException->sm->if->sampleModel->createSubsetSampleModel->else->deltaX->deltaY->return->new->Rectangle->new->Point->new->ShortInterleavedRaster
ShortInterleavedRaster#createCompatibleWritableRaster(int, int):::Creates a Raster with the same layout but using a different width and height, and with new zeroed data arrays.:::if->throw->new->RasterFormatException->sm->sampleModel->createCompatibleSampleModel->return->new->Point->new->ShortInterleavedRaster
ShortInterleavedRaster#createCompatibleWritableRaster():::Creates a Raster with the same layout and the same width and height, and with new zeroed data arrays:::return->createCompatibleWritableRaster
SunVolatileImage#getBackupImage():::This method creates a BufferedImage intended for use as a "snapshot" or a backup surface.:::return->getBackupImage
SunVolatileImage#getBackupImage(double, double):::This method creates a BufferedImage intended for use as a "snapshot" or a backup surface with the given horizontal and vertical scale factors.:::w->Region->getWidth->clipRound->h->Region->getHeight->clipRound->return->graphicsConfig->getTransparency->createCompatibleImage
SunWritableRaster#markDirty():::Mark the TrackableDelegate of the associated DataBuffer dirty.:::theTrackable->markDirty
SurfaceManager#getManager(Image):::Returns the SurfaceManager object contained within the given Image.:::sMgr->imgaccessor->getSurfaceManager->if->try->bi->new->BufImgSurfaceManager->setManager->catch->throw->new->IllegalArgumentException->finally->return
SurfaceManager#getCacheData(Object):::Return an arbitrary cached object for an arbitrary cache key:::return->cacheMap->get
SurfaceManager#setCacheData(Object, Object):::Store an arbitrary cached object for an arbitrary cache key:::if->synchronized->if->new->ConcurrentHashMap<>->cacheMap->put
SurfaceManager#getPrimarySurfaceData():::Returns the main SurfaceData object that "owns" the pixels for this SurfaceManager:::
SurfaceManager#restoreContents():::Restores the primary surface being managed, and then returns the replacement surface:::
SurfaceManager#acceleratedSurfaceLost():::Notification that any accelerated surfaces associated with this manager have been "lost", which might mean that they need to be manually restored or recreated:::
SurfaceManager#getCapabilities(GraphicsConfiguration):::Returns an ImageCapabilities object which can be inquired as to the specific capabilities of this Image:::return->new->ImageCapabilitiesGc
SurfaceManager.ProxiedGraphicsConfig#getProxyKey():::Return the key that destination surfaces created on the given GraphicsConfiguration use to store SurfaceDataProxy objects for their cached copies.:::
SurfaceManager#flush():::Releases system resources in use by ancillary SurfaceData objects, such as surfaces cached in accelerated memory:::flush
SurfaceManager.FlushableCacheData#flush(boolean):::Flush all cached resources:::
SurfaceManager#setAccelerationPriority(float):::Called when image's acceleration priority is changed:::if->flush
SurfaceManager#getImageScaleX(Image):::Returns a horizontal scale factor of the image:::if->return->sm->getManager->return->sm->getPrimarySurfaceData->getDefaultScaleX
SurfaceManager#getImageScaleY(Image):::Returns a vertical scale factor of the image:::if->return->sm->getManager->return->sm->getPrimarySurfaceData->getDefaultScaleY
ToolkitImage#getWidth():::Return the width of the original image source:::if->src->checkSecurity->if->reconstruct->return
ToolkitImage#getWidth(ImageObserver):::Return the width of the original image source:::if->src->checkSecurity->if->addWatcher->if->return->return
ToolkitImage#getHeight():::Return the height of the original image source:::if->src->checkSecurity->if->reconstruct->return
ToolkitImage#getHeight(ImageObserver):::Return the height of the original image source:::if->src->checkSecurity->if->addWatcher->if->return->return
ToolkitImage#getProperty(String, ImageObserver):::Return a property of the image by name:::if->throw->new->NullPointerException->if->src->checkSecurity->if->addWatcher->if->return->o->properties->get->if->return
VolatileSurfaceManager#initialize():::This init function is separate from the constructor because the things we are doing here necessitate the object's existence:::if->isAccelerationEnabled->initAcceleratedSurface->if->if->vImg->getForcedAccelSurfaceType->getBackupSurface
VolatileSurfaceManager#isAccelerationEnabled():::Returns true if acceleration is enabled:::
VolatileSurfaceManager#validate(GraphicsConfiguration):::Get the image ready for rendering:::returnCode->lostSurfaceTmp->if->isAccelerationEnabled->if->isConfigValid->else->if->initAcceleratedSurface->if->else->getBackupSurface->else->if->sdAccel->isSurfaceLost->try->restoreAcceleratedSurface->sdAccel->setSurfaceLost->catch->getBackupSurface->finally->else->if->else->if->getBackupSurface->else->if->if->if->initContents->return
VolatileSurfaceManager#contentsLost():::Returns true if rendering data was lost since the last validate call.:::return
VolatileSurfaceManager#initAcceleratedSurface():::Creates a new accelerated surface that is compatible with the current GraphicsConfiguration:::
VolatileSurfaceManager#getBackupSurface():::Creates a software-based surface (of type BufImgSurfaceData):::if->gc->vImg->getGraphicsConfig->tx->gc->getDefaultTransform->scaleX->tx->getScaleX->scaleY->tx->getScaleY->bImg->vImg->getBackupImage->SunWritableRaster->bImg->getRaster->getDataBuffer->stealTrackable->setUntrackable->BufImgSurfaceData->createData->return
VolatileSurfaceManager#initContents():::Set contents of the current SurfaceData to default state (i.e:::if->g->vImg->createGraphics->g->vImg->getWidth->vImg->getHeight->clearRect->g->dispose
VolatileSurfaceManager#restoreContents():::Called from a SurfaceData object, indicating that our accelerated surface has been lost and should be restored (perhaps using a backup system memory surface):::return->getBackupSurface
VolatileSurfaceManager#acceleratedSurfaceLost():::If the accelerated surface is the current SurfaceData for this manager, sets the variable lostSurface to true, which indicates that something happened to the image under management:::if->isAccelerationEnabled
VolatileSurfaceManager#restoreAcceleratedSurface():::Restore sdAccel in case it was lost:::
VolatileSurfaceManager#displayChanged():::Called from SunGraphicsEnv when there has been a display mode change:::if->oldData->oldData->invalidate->getBackupSurface->vImg->updateGraphicsConfig->atUpdated->vImg->getGraphicsConfig->getDefaultTransform->if->isAccelerationEnabled->if->atUpdated->equals->getBackupSurface->else
VolatileSurfaceManager#paletteChanged():::When device palette changes, need to force a new copy of the image into our hardware cache to update the color indices of the pixels (indexed mode only).:::
VolatileSurfaceManager#isConfigValid(GraphicsConfiguration):::Called by validate() to see whether the GC passed in is ok for rendering to:::return->gc->getDevice->vImg->getGraphicsConfig->getDevice
VolatileSurfaceManager#flush():::Releases any associated hardware memory for this image by calling flush on sdAccel:::oldSD->if->oldSD->flush
VSyncedBSManager#vsyncAllowed(BufferStrategy):::Returns true if the buffer strategy is allowed to be created v-synced.:::bsm->getInstance->return->bsm->checkAllowed
VSyncedBSManager#releaseVsync(BufferStrategy):::Lets the manager know that this buffer strategy is no longer interested in being v-synced.:::bsm->getInstance->if->bsm->relinquishVsync
XbmImageDecoder#produceImage():::produce an image from the stream.:::nm->new->charArr->c->i->state->H->W->x->y->start->raster->model->while->input->read->if->if->else->if->nc->if->if->error->if->else->if->else->if->n->for->p->for->mask->if->if->setPixels->return->if->break->else->n->for->p->if->if->else->if->else->new->IndexColorModel->setDimensions->setColorModel->setHints->headerComplete->new->byteArr->input->close->imageComplete
