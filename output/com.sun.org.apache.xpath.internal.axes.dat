AttributeIterator#getNextNode():::Get the next node via getFirstAttribute && getNextAttribute.:::m_cdtm->getFirstAttribute->m_cdtm->getNextAttribute->return
AttributeIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
AxesWalker#init(Compiler, int, int):::Initialize an AxesWalker during the parse of the XPath expression.:::initPredicateInfo
AxesWalker#clone():::Get a cloned AxesWalker.:::clone->super->clone->return
AxesWalker#cloneDeep(WalkingIterator, List):::Do a deep clone of this walker, including next and previous walkers:::clone->findClone->if->return->this->clone->clone->setLocPathIterator->if->cloneList->add->cloneList->add->if->wi->if->m_nextWalker->cloneDeep->if->if->m_prevWalker->cloneDeep->else->if->return
AxesWalker#findClone(AxesWalker, List):::Find a clone that corresponds to the key argument.:::if->n->cloneList->size->for->i->return
AxesWalker#detach():::Detaches the walker from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::
AxesWalker#getRoot():::The root node of the TreeWalker, as specified in setRoot(int root):::return
AxesWalker#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::axis->getAxis->bit->WalkerFactory->getAnalysisBitFromAxes->return
AxesWalker#setRoot(int):::Set the root node of the TreeWalker:::xctxt->wi->getXPathContext->xctxt->getDTM->m_dtm->getAxisTraverser->if->throw->XSLMessages->createXPATHMessage->new->RuntimeException->resetProximityPositions
AxesWalker#getCurrentNode():::The node at which the TreeWalker is currently positioned:::return
AxesWalker#setNextWalker(AxesWalker):::Set the next walker in the location step chain.:::
AxesWalker#getNextWalker():::Get the next walker in the location step chain.:::return
AxesWalker#setPrevWalker(AxesWalker):::Set or clear the previous walker reference in the location step chain.:::
AxesWalker#getPrevWalker():::Get the previous walker reference in the location step chain.:::return
AxesWalker#getNextNode():::Get the next node in document order on the axes.:::if->return->if->m_traverser->first->else->if->m_traverser->next->if->return
AxesWalker#nextNode()::: Moves the TreeWalker to the next visible node in document order relative to the current node, and returns the new node:::nextNode->walker->wi->getLastUsedWalker->while->if->break->walker->getNextNode->if->else->if->walker->acceptNode->continue->if->wi->setLastUsedWalker->break->else->prev->walker->setRoot->continue->return
AxesWalker#getLastPos(XPathContext):::Get the index of the last node that can be itterated to.:::pos->getProximityPosition->walker->try->clone->catch->return->finally->walker->setPredicateCount->walker->setNextWalker->walker->setPrevWalker->lpi->wi->savedWalker->lpi->getLastUsedWalker->try->lpi->setLastUsedWalker->next->while->walker->nextNode->catch->finally->lpi->setLastUsedWalker->return
AxesWalker#setDefaultDTM(DTM):::Set the DTM for this walker.:::
AxesWalker#getDTM(int):::Get the DTM for this walker.:::return->wi->getXPathContext->getDTM
AxesWalker#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order:::return
AxesWalker#getAxis():::Returns the axis being iterated, if it is known.:::return
AxesWalker#callVisitors(ExpressionOwner, XPathVisitor):::This will traverse the heararchy, calling the visitor for each member:::if->visitor->visitStep->callPredicateVisitors->if->m_nextWalker->callVisitors
BasicTestIterator#getNextNode():::Get the next node via getNextXXX:::
BasicTestIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->if->resetProximityPositions->next->vars->savedStart->if->m_execContext->getVarStack->vars->getStackFrame->vars->setStackFrame->else->try->do->getNextNode->if->if->acceptNode->break->else->continue->else->break->while->if->return->else->return->catch->finally->if->vars->setStackFrame
BasicTestIterator#cloneWithReset()::: Get a cloned Iterator that is reset to the beginning  of the query.:::clone->super->cloneWithReset->clone->resetProximityPositions->return
ChildIterator#asNode(XPathContext):::Return the first node out of the nodeset, if this expression is a nodeset expression:::current->xctxt->getCurrentNode->dtm->xctxt->getDTM->return->dtm->getFirstChild
ChildIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->next->m_cdtm->getFirstChild->m_cdtm->getNextSibling->if->return->else->return
ChildIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
ChildTestIterator#getNextNode():::Get the next node via getNextXXX:::if->m_traverser->first->m_traverser->next->return
ChildTestIterator#cloneWithReset()::: Get a cloned Iterator that is reset to the beginning  of the query.:::clone->super->cloneWithReset->return
ChildTestIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->m_cdtm->getAxisTraverser
ChildTestIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
ChildTestIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->super->detach
ContextNodeList#getCurrentNode():::Get the current node.:::
ContextNodeList#getCurrentPos():::Get the current position, which is one less than the next nextNode() call will retrieve:::
ContextNodeList#reset():::Reset the iterator.:::
ContextNodeList#setShouldCacheNodes(boolean):::If setShouldCacheNodes(true) is called, then nodes will be cached:::
ContextNodeList#runTo(int):::If an index is requested, NodeSetDTM will call this method to run the iterator to the index:::
ContextNodeList#setCurrentPos(int):::Set the current position in the node set.:::
ContextNodeList#size():::Get the length of the list.:::
ContextNodeList#isFresh():::Tells if this NodeSetDTM is "fresh", in other words, if the first nextNode() that is called will return the first node in the set.:::
ContextNodeList#cloneWithReset():::Get a cloned Iterator that is reset to the start of the iteration.:::
ContextNodeList#clone():::Get a clone of this iterator:::
ContextNodeList#getLast():::Get the index of the last node in this list.:::
ContextNodeList#setLast(int):::Set the index of the last node in this list.:::
DescendantIterator#cloneWithReset()::: Get a cloned Iterator that is reset to the beginning  of the query.:::clone->super->cloneWithReset->clone->resetProximityPositions->return
DescendantIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->if->resetProximityPositions->next->vars->savedStart->if->m_execContext->getVarStack->vars->getStackFrame->vars->setStackFrame->else->try->do->if->m_traverser->first->m_traverser->next->else->m_traverser->first->m_traverser->next->if->if->acceptNode->break->else->continue->else->break->while->if->return->else->return->catch->finally->if->vars->setStackFrame
DescendantIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->m_cdtm->getAxisTraverser->localName->getLocalName->namespace->getNamespace->what->if->equals->equals->else->type->getNodeTypeTest->m_cdtm->getExpandedTypeID
DescendantIterator#asNode(XPathContext):::Return the first node out of the nodeset, if this expression is a nodeset expression:::if->getPredicateCount->return->super->asNode->current->xctxt->getCurrentNode->dtm->xctxt->getDTM->traverser->dtm->getAxisTraverser->localName->getLocalName->namespace->getNamespace->what->if->return->traverser->first->else->type->getNodeTypeTest->extendedType->dtm->getExpandedTypeID->return->traverser->first
DescendantIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->super->detach
DescendantIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
FilterExprIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->FilterExprIteratorSimple->getPrefixResolver->getIsTopLevel->executeFilterExpr
FilterExprIterator#getNextNode():::Get the next node via getNextXXX:::if->m_exprObj->nextNode->else->return
FilterExprIterator#detach():::Detaches the walker from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::super->detach->m_exprObj->detach
FilterExprIterator#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::super->fixupVariables->m_expr->fixupVariables
FilterExprIterator#getInnerExpression():::Get the inner contained expression of this filter.:::return
FilterExprIterator#setInnerExpression(Expression):::Set the inner contained expression of this filter.:::expr->exprSetParent
FilterExprIterator#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::if->return->getAnalysisBits->return
FilterExprIterator#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order:::return->m_exprObj->isDocOrdered
FilterExprIterator#callPredicateVisitors(XPathVisitor):::This will traverse the heararchy, calling the visitor for each member:::m_expr->new->filterExprOwner->callVisitors->super->callPredicateVisitors
FilterExprIteratorSimple#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->getPrefixResolver->getIsTopLevel->executeFilterExpr
FilterExprIteratorSimple#executeFilterExpr(int, XPathContext, PrefixResolver, boolean, int, Expression):::Execute the expression:::savedResolver->xctxt->getNamespaceContext->result->try->xctxt->pushCurrentNode->xctxt->setNamespaceContext->if->vars->xctxt->getVarStack->savedStart->vars->getStackFrame->vars->setStackFrame->expr->execute->result->setShouldCacheNodes->vars->setStackFrame->else->expr->execute->catch->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally->xctxt->popCurrentNode->xctxt->setNamespaceContext->return
FilterExprIteratorSimple#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->next->if->m_exprObj->nextNode->else->if->return->else->return
FilterExprIteratorSimple#detach():::Detaches the walker from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::if->super->detach->m_exprObj->detach
FilterExprIteratorSimple#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::super->fixupVariables->m_expr->fixupVariables
FilterExprIteratorSimple#getInnerExpression():::Get the inner contained expression of this filter.:::return
FilterExprIteratorSimple#setInnerExpression(Expression):::Set the inner contained expression of this filter.:::expr->exprSetParent
FilterExprIteratorSimple#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::if->return->getAnalysisBits->return
FilterExprIteratorSimple#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order:::return->m_exprObj->isDocOrdered
FilterExprIteratorSimple#callPredicateVisitors(XPathVisitor):::This will traverse the heararchy, calling the visitor for each member:::m_expr->new->filterExprOwner->callVisitors->super->callPredicateVisitors
FilterExprIteratorSimple#getAxis():::Returns the axis being iterated, if it is known.:::if->return->m_exprObj->getAxis->else->return
FilterExprWalker#init(Compiler, int, int):::Init a FilterExprWalker.:::super->init->switch->compiler->compileExpression->m_expr->exprSetParent->if->break->compiler->compileExpression->m_expr->exprSetParent
FilterExprWalker#detach():::Detaches the walker from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::super->detach->if->m_exprObj->detach
FilterExprWalker#setRoot(int)::: Set the root node of the TreeWalker.:::super->setRoot->FilterExprIteratorSimple->m_lpi->getXPathContext->m_lpi->getPrefixResolver->m_lpi->getIsTopLevel->executeFilterExpr
FilterExprWalker#clone():::Get a cloned FilterExprWalker.:::clone->super->clone->if->m_exprObj->clone->return
FilterExprWalker#acceptNode(int):::This method needs to override AxesWalker.acceptNode because FilterExprWalkers don't need to, and shouldn't, do a node test.:::try->if->getPredicateCount->countProximityPosition->if->m_lpi->getXPathContext->executePredicates->return->return->catch->throw->se->getMessage->new->RuntimeException->finally
FilterExprWalker#getNextNode()::: Moves the TreeWalker to the next visible node in document order relative to the current node, and returns the new node:::if->next->m_exprObj->nextNode->return->else->return
FilterExprWalker#getLastPos(XPathContext):::Get the index of the last node that can be itterated to.:::return->m_exprObj->getLength
FilterExprWalker#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::super->fixupVariables->m_expr->fixupVariables
FilterExprWalker#getInnerExpression():::Get the inner contained expression of this filter.:::return
FilterExprWalker#setInnerExpression(Expression):::Set the inner contained expression of this filter.:::expr->exprSetParent
FilterExprWalker#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::if->return->getAnalysisBits->return
FilterExprWalker#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order:::return->m_exprObj->isDocOrdered
FilterExprWalker#getAxis():::Returns the axis being iterated, if it is known.:::return->m_exprObj->getAxis
FilterExprWalker#callPredicateVisitors(XPathVisitor):::This will traverse the heararchy, calling the visitor for each member:::m_expr->new->filterExprOwner->callVisitors->super->callPredicateVisitors
HasPositionalPredChecker#check(LocPathIterator):::Process the LocPathIterator to see if it contains variables or functions that may make it context dependent.:::hppc->new->HasPositionalPredChecker->path->callVisitors->return
HasPositionalPredChecker#visitFunction(ExpressionOwner, Function):::Visit a function.:::if->return
HasPositionalPredChecker#visitPredicate(ExpressionOwner, Expression):::Visit a predicate within a location path:::if->if->else->pred->callVisitors->return
IteratorPool#getInstanceOrThrow():::Get an instance of the given object in this pool:::if->m_freeStack->isEmpty->return->m_orig->clone->else->result->m_freeStack->m_freeStack->size->remove->return
IteratorPool#getInstance():::Get an instance of the given object in this pool:::if->m_freeStack->isEmpty->try->return->m_orig->clone->catch->throw->new->WrappedRuntimeException->finally->else->result->m_freeStack->m_freeStack->size->remove->return
IteratorPool#freeInstance(DTMIterator):::Add an instance of the given object to the pool:::m_freeStack->add
LocPathIterator#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::axis->getAxis->bit->WalkerFactory->getAnalysisBitFromAxes->return
LocPathIterator#setEnvironment(Object):::Set the environment in which this iterator operates, which should provide: a node (the context node..:::
LocPathIterator#getDTM(int):::Get an instance of a DTM that "owns" a node handle:::return->m_execContext->getDTM
LocPathIterator#getDTMManager():::Get an instance of the DTMManager:::return->m_execContext->getDTMManager
LocPathIterator#execute(XPathContext):::Execute this iterator, meaning create a clone that can store state, and initialize it for fast execution from the current runtime state:::iter->m_clones->getInstance->new->XNodeSet->iter->xctxt->getCurrentNode->setRoot->return
LocPathIterator#executeCharsToContentHandler(XPathContext, org.xml.sax.ContentHandler):::Execute an expression in the XPath runtime context, and return the result of the expression.:::clone->m_clones->getInstance->current->xctxt->getCurrentNode->clone->setRoot->node->clone->nextNode->dtm->clone->getDTM->clone->detach->if->dtm->dispatchCharactersEvents
LocPathIterator#asIterator(XPathContext, int):::Given an select expression and a context, evaluate the XPath and return the resulting iterator.:::iter->m_clones->getInstance->new->XNodeSet->iter->setRoot->return
LocPathIterator#isNodesetExpr():::Tell if the expression is a nodeset expression.:::return
LocPathIterator#asNode(XPathContext):::Return the first node out of the nodeset, if this expression is a nodeset expression:::iter->m_clones->getInstance->current->xctxt->getCurrentNode->iter->setRoot->next->iter->nextNode->iter->detach->return
LocPathIterator#boolean bool(XPathContext):::Evaluate this operation directly to a boolean.:::return->asNode
LocPathIterator#setIsTopLevel(boolean):::Set if this is an iterator at the upper level of the XPath.:::
LocPathIterator#getIsTopLevel():::Get if this is an iterator at the upper level of the XPath.:::return
LocPathIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::xctxt->xctxt->getDTM->if->xctxt->getNamespaceContext->if->xctxt->getVarStack->getStackFrame
LocPathIterator#setNextPosition(int):::Set the next position index of this iterator.:::assertion
LocPathIterator#getCurrentPos():::Get the current position, which is one less than the next nextNode() call will retrieve:::return
LocPathIterator#setShouldCacheNodes(boolean):::If setShouldCacheNodes(true) is called, then nodes will be cached:::assertion
LocPathIterator#isMutable():::Tells if this iterator can have nodes added to it or set via the setItem(int node, int index) method.:::return
LocPathIterator#setCurrentPos(int):::Set the current position in the node set.:::assertion
LocPathIterator#incrementCurrentPos():::Increment the current position in the node set.:::
LocPathIterator#size():::Get the length of the cached nodes:::assertion->return
LocPathIterator#item(int)::: Returns the index th item in the collection:::assertion->return
LocPathIterator#setItem(int, int):::Sets the node at the specified index of this vector to be the specified node:::assertion
LocPathIterator#getLength()::: The number of nodes in the list:::isPredicateTest->m_execContext->getSubContextList->predCount->getPredicateCount->if->return->if->return->pos->getProximityPosition->clone->try->clone->catch->return->finally->if->next->while->clone->nextNode->if->return
LocPathIterator#isFresh():::Tells if this NodeSetDTM is "fresh", in other words, if the first nextNode() that is called will return the first node in the set.:::return
LocPathIterator#previousNode()::: Returns the previous node in the set and moves the position of the iterator backwards in the set.:::throw->XSLMessages->createXPATHMessage->new->RuntimeException
LocPathIterator#getWhatToShow():::This attribute determines which node types are presented via the iterator:::return
LocPathIterator#getFilter()::: The filter used to screen nodes:::return
LocPathIterator#getRoot():::The root node of the Iterator, as specified when it was created.:::return
LocPathIterator#getExpandEntityReferences()::: The value of this flag determines whether the children of entity reference nodes are visible to the iterator:::return
LocPathIterator#allowDetachToRelease(boolean):::Specify if it's OK for detach to release the iterator for reuse.:::
LocPathIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->m_clones->freeInstance
LocPathIterator#reset():::Reset the iterator.:::assertion
LocPathIterator#cloneWithReset():::Get a cloned Iterator that is reset to the beginning of the query.:::clone->m_clones->getInstanceOrThrow->return
LocPathIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::
LocPathIterator#returnNextNode(int):::Bottleneck the return of a next node, to make returns easier from nextNode().:::if->if->return
LocPathIterator#getCurrentNode():::Return the last fetched node:::return
LocPathIterator#runTo(int):::If an index is requested, NodeSetDTM will call this method to run the iterator to the index:::if->getCurrentPos->return->n->if->while->nextNode->else->while->nextNode->if->getCurrentPos->break
LocPathIterator#getFoundLast():::Tells if we've found the last node yet.:::return
LocPathIterator#getXPathContext():::The XPath execution context we are operating on.:::return
LocPathIterator#getContext():::The node context for the iterator.:::return
LocPathIterator#getCurrentContextNode():::The node context from where the expression is being executed from (i.e:::return
LocPathIterator#setCurrentContextNode(int):::Set the current context node for this iterator.:::
LocPathIterator#getPrefixResolver():::Return the saved reference to the prefix resolver that was in effect when this iterator was created.:::if->getExpressionOwner->return
LocPathIterator#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order.:::return
LocPathIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
MatchPatternIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->m_cdtm->getAxisTraverser
MatchPatternIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->super->detach
MatchPatternIterator#getNextNode():::Get the next node via getNextXXX:::m_traverser->first->m_traverser->next->return
MatchPatternIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->next->vars->savedStart->if->m_execContext->getVarStack->vars->getStackFrame->vars->setStackFrame->else->try->if->m_pattern->toString->println->do->getNextNode->if->if->acceptNode->break->else->continue->else->break->while->if->if->println->m_cdtm->getNodeName->println->incrementCurrentPos->return->else->return->catch->finally->if->vars->setStackFrame
MatchPatternIterator#acceptNode(int, XPathContext)::: Test whether a specified node is visible in the logical view of a TreeWalker or NodeIterator:::try->xctxt->pushCurrentNode->xctxt->pushIteratorRoot->if->println->print->m_cdtm->getNodeName->println->m_pattern->toString->println->NodeTest->m_pattern->getWhatToShow->debugWhatToShow->score->m_pattern->execute->if->println->println->return->catch->throw->se->getMessage->new->RuntimeException->finally->xctxt->popCurrentNode->xctxt->popIteratorRoot
NodeSequence#getVector():::If this iterator needs to cache nodes that are fetched, they are stored in the Vector in the generic object.:::nv->m_cache->getVector->return
NodeSequence#SetVector(NodeVector):::Set the vector where nodes will be cached.:::setObject
NodeSequence#hasCache():::If the iterator needs to cache nodes as they are fetched, then this method returns true.:::nv->getVector->return
NodeSequence#setIter(DTMIterator):::Set the functional iterator that fetches nodes.:::
NodeSequence#getContainedIter():::Get the functional iterator that fetches nodes.:::return
NodeSequence#allowDetachToRelease(boolean):::Calling this with a value of false will cause the nodeset to be cached.:::if->hasCache->setShouldCacheNodes->if->m_iter->allowDetachToRelease->super->allowDetachToRelease
NodeSequence#cloneWithReset():::Note: Not a deep clone.:::seq->super->clone->if->m_cache->increaseUseCount->return
NodeSequence#clone():::Get a clone of this iterator, but don't reset the iteration in the process, so that it may be used from the current position:::clone->super->clone->if->m_iter->clone->if->m_cache->increaseUseCount->return
NodeSequence#addNodeInDocOrder(int):::Add the node into a vector of nodes where it should occur in document order.:::hasCache->assertion->insertIndex->vec->getVector->size->vec->size->i->for->if->vec->insertElementAt->return
NodeSequence#setObject(Object):::It used to be that many locations in the code simply did an assignment to this.m_obj directly, rather than calling the setObject(Object) method:::if->super->setObject->v->if->m_cache->setVector->else->if->new->IteratorCache->m_cache->setVector->else->if->cache->m_cache->increaseUseCount->super->cache->getVector->setObject->else->super->setObject
NodeSequence#getIteratorCache():::Get the cached list of nodes appended with values obtained from the iterator as a NodeSequence is walked when its nextNode() method is called.:::return
OneStepIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->if->m_cdtm->getAxisIterator->m_iterator->setStartNode
OneStepIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->if->super->detach
OneStepIterator#getNextNode():::Get the next node via getFirstAttribute && getNextAttribute.:::return->m_iterator->next
OneStepIterator#clone():::Get a cloned iterator.:::clone->super->clone->if->m_iterator->cloneIterator->return
OneStepIterator#cloneWithReset()::: Get a cloned Iterator that is reset to the beginning  of the query.:::clone->super->cloneWithReset->return
OneStepIterator#isReverseAxes():::Tells if this is a reverse axes:::return->m_iterator->isReverse
OneStepIterator#getProximityPosition(int):::Get the current sub-context position:::if->isReverseAxes->return->super->getProximityPosition->if->return->if->xctxt->getXPathContext->try->clone->this->clone->root->getRoot->xctxt->pushCurrentNode->clone->setRoot->count->next->while->clone->nextNode->catch->finally->xctxt->popCurrentNode->return
OneStepIterator#getLength()::: The number of nodes in the list:::if->isReverseAxes->return->super->getLength->isPredicateTest->m_execContext->getSubContextList->predCount->getPredicateCount->if->return->count->xctxt->getXPathContext->try->clone->this->cloneWithReset->root->getRoot->xctxt->pushCurrentNode->clone->setRoot->next->while->clone->nextNode->catch->finally->xctxt->popCurrentNode->if->return
OneStepIterator#countProximityPosition(int):::Count backwards one proximity position.:::if->isReverseAxes->super->countProximityPosition->else->if
OneStepIterator#reset():::Reset the iterator.:::super->reset->if->m_iterator->reset
OneStepIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
OneStepIteratorForward#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->m_cdtm->getAxisTraverser
OneStepIteratorForward#getNextNode():::Get the next node via getFirstAttribute && getNextAttribute.:::m_traverser->first->m_traverser->next->return
OneStepIteratorForward#getAxis():::Returns the axis being iterated, if it is known.:::return
PathComponent#getAnalysisBits():::Get the analysis bits for this path component, as defined in the WalkerFactory.:::
PredicatedNodeTest#clone():::Get a cloned PrdicatedNodeTest.:::clone->super->clone->if->new->intArr->System->arraycopy->if->return
PredicatedNodeTest#getPredicateCount():::Get the number of predicates that this walker has.:::if->return->else->return
PredicatedNodeTest#setPredicateCount(int):::Set the number of predicates that this walker has:::if->newPredicates->new->ExpressionArr->for->i->else
PredicatedNodeTest#initPredicateInfo(Compiler, int):::Init predicate info.:::pos->compiler->getFirstPredicateOpPos->if->compiler->getCompiledPredicates->if->for->i
PredicatedNodeTest#getPredicate(int):::Get a predicate expression at the given index.:::return
PredicatedNodeTest#getProximityPosition():::Get the current sub-context position.:::return->getProximityPosition
PredicatedNodeTest#getProximityPosition(XPathContext):::Get the current sub-context position.:::return->getProximityPosition
PredicatedNodeTest#getLastPos(XPathContext):::Get the index of the last node that can be itterated to.:::
PredicatedNodeTest#getProximityPosition(int):::Get the current sub-context position.:::return
PredicatedNodeTest#resetProximityPositions():::Reset the proximity positions counts.:::nPredicates->getPredicateCount->if->if->new->intArr->for->i
PredicatedNodeTest#initProximityPosition(int):::Init the proximity position to zero for a forward axes.:::
PredicatedNodeTest#countProximityPosition(int):::Count forward one proximity position.:::pp->if
PredicatedNodeTest#isReverseAxes():::Tells if this is a reverse axes.:::return
PredicatedNodeTest#getPredicateIndex():::Get which predicate is executing.:::return
PredicatedNodeTest#executePredicates(int, XPathContext):::Process the predicates.:::nPredicates->getPredicateCount->if->return->savedResolver->xctxt->getNamespaceContext->try->xctxt->pushSubContextList->xctxt->m_lpi->getPrefixResolver->pushNamespaceContext->xctxt->pushCurrentNode->for->i->catch->finally->xctxt->popCurrentNode->xctxt->popNamespaceContext->xctxt->popSubContextList->return
PredicatedNodeTest#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::super->fixupVariables->nPredicates->getPredicateCount->for->i
PredicatedNodeTest#nodeToString(int):::Diagnostics.:::if->dtm->m_lpi->getXPathContext->getDTM->return->dtm->getNodeName->else->return
PredicatedNodeTest#acceptNode(int)::: Test whether a specified node is visible in the logical view of a TreeWalker or NodeIterator:::xctxt->m_lpi->getXPathContext->try->xctxt->pushCurrentNode->score->execute->if->if->getPredicateCount->countProximityPosition->if->executePredicates->return->return->catch->throw->se->getMessage->new->RuntimeException->finally->xctxt->popCurrentNode->return
PredicatedNodeTest#getLocPathIterator():::Get the owning location path iterator.:::return
PredicatedNodeTest#setLocPathIterator(LocPathIterator):::Set the location path iterator owner for this walker:::if->li->exprSetParent
PredicatedNodeTest#canTraverseOutsideSubtree():::Tell if this expression or it's subexpressions can traverse outside the current subtree.:::n->getPredicateCount->for->i->return
PredicatedNodeTest#callPredicateVisitors(XPathVisitor):::This will traverse the heararchy, calling the visitor for each member:::if->n->for->i
ReverseAxesWalker#setRoot(int):::Set the root node of the TreeWalker:::super->setRoot->getDTM->getAxisIterator->m_iterator->setStartNode
ReverseAxesWalker#detach():::Detaches the walker from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state.:::super->detach
ReverseAxesWalker#getNextNode():::Get the next node in document order on the axes.:::if->return->next->m_iterator->next->if->if->return
ReverseAxesWalker#isReverseAxes():::Tells if this is a reverse axes:::return
ReverseAxesWalker#getProximityPosition(int):::Get the current sub-context position:::if->return->count->if->savedWalker->wi->getLastUsedWalker->try->clone->this->clone->clone->this->getRoot->setRoot->clone->setPredicateCount->clone->setPrevWalker->clone->setNextWalker->wi->setLastUsedWalker->next->while->clone->nextNode->catch->finally->wi->setLastUsedWalker->return
ReverseAxesWalker#countProximityPosition(int):::Count backwards one proximity position.:::if
ReverseAxesWalker#getLastPos(XPathContext):::Get the number of nodes in this node list:::count->savedWalker->wi->getLastUsedWalker->try->clone->this->clone->clone->this->getRoot->setRoot->clone->this->getPredicateCount->setPredicateCount->clone->setPrevWalker->clone->setNextWalker->wi->setLastUsedWalker->next->while->clone->nextNode->catch->finally->wi->setLastUsedWalker->return
ReverseAxesWalker#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order:::return
SelfIteratorNoPredicate#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->next->dtm->if->return->else->return
SelfIteratorNoPredicate#asNode(XPathContext):::Return the first node out of the nodeset, if this expression is a nodeset expression:::return->xctxt->getCurrentNode
SelfIteratorNoPredicate#getLastPos(XPathContext):::Get the index of the last node that can be itterated to:::return
SubContextList#getLastPos(XPathContext):::Get the number of nodes in the node list, which, in the XSLT 1 based counting system, is the last index position.:::
SubContextList#getProximityPosition(XPathContext):::Get the current sub-context position.:::
UnionChildIterator#addNodeTest(PredicatedNodeTest):::Add a node test to the union list.:::if->new->PredicatedNodeTestArr->else->tests->len->new->PredicatedNodeTestArr->System->arraycopy->test->exprSetParent
UnionChildIterator#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::super->fixupVariables->if->for->i
UnionChildIterator#acceptNode(int):::Test whether a specified node is visible in the logical view of a TreeWalker or NodeIterator:::xctxt->getXPathContext->try->xctxt->pushCurrentNode->for->i->catch->throw->se->getMessage->new->RuntimeException->finally->xctxt->popCurrentNode->return
UnionPathIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->try->if->n->newIters->new->DTMIteratorArr->for->i->catch->throw->new->com.sun.org.apache.xml.internal.utils.WrappedRuntimeException->finally
UnionPathIterator#addIterator(DTMIterator):::Add an iterator to the union list.:::if->new->DTMIteratorArr->else->exprs->len->new->DTMIteratorArr->System->arraycopy->expr->nextNode->if->exprSetParent
UnionPathIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->n->for->i
UnionPathIterator#createUnionIterator(Compiler, int):::This will return an iterator capable of handling the union of paths given.:::upi->new->UnionPathIterator->nPaths->isAllChildIterators->for->i->if->uci->new->UnionChildIterator->for->i->return->else->return
UnionPathIterator#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::bits->if->n->for->i->return
UnionPathIterator#clone():::Get a cloned LocPathIterator that holds the same position as this iterator.:::clone->super->clone->if->n->new->DTMIteratorArr->for->i->return
UnionPathIterator#createDTMIterator(Compiler, int):::Create a new location path iterator.:::lpi->WalkerFactory->compiler->getLocationPathDepth->newDTMIterator->return
UnionPathIterator#loadLocationPaths(Compiler, int, int):::Initialize the location path iterators:::steptype->compiler->getOp->if->compiler->getNextOpPos->loadLocationPaths->createDTMIterator->exprSetParent->else->switch->compiler->getNextOpPos->loadLocationPaths->iter->compiler->getNamespaceContext->new->WalkingIterator->iter->exprSetParent->if->compiler->getLocationPathDepth->iter->setIsTopLevel->new->com.sun.org.apache.xpath.internal.axes.FilterExprWalker->init->break->new->LocPathIteratorArr
UnionPathIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->earliestNode->if->n->iteratorUsed->for->i->if->nextNode->incrementCurrentPos->else->return
UnionPathIterator#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::for->i
UnionPathIterator#getAxis():::Returns the axis being iterated, if it is known.:::return
WalkerFactory#loadOneWalker(WalkingIterator, Compiler, int):::This method is for building an array of possible levels where the target element(s) could be found for a match.:::firstWalker->stepType->compiler->getOp->if->createDefaultWalker->firstWalker->init->return
WalkerFactory#loadWalkers(WalkingIterator, Compiler, int, int):::This method is for building an array of possible levels where the target element(s) could be found for a match.:::stepType->firstWalker->walker->prevWalker->analysis->analyze->while->compiler->getOp->createDefaultWalker->walker->init->walker->exprSetParent->if->else->prevWalker->setNextWalker->walker->setPrevWalker->compiler->getNextStepPos->if->break->return
WalkerFactory#newDTMIterator(Compiler, int, boolean):::Create a new LocPathIterator iterator:::firstStepPos->OpMap->getFirstChildPos->analysis->analyze->isOneStep->isOneStep->iter->if->walksSelfOnly->isWild->hasPredicate->if->diagnoseIterator->new->SelfIteratorNoPredicate->else->if->walksChildrenOnly->if->isWild->hasPredicate->if->diagnoseIterator->new->ChildIterator->else->if->diagnoseIterator->new->ChildTestIterator->else->if->walksAttributes->if->diagnoseIterator->new->AttributeIterator->else->if->walksFilteredList->if->walksNamespaces->walksInDocOrder->isSet->if->diagnoseIterator->new->OneStepIteratorForward->else->if->diagnoseIterator->new->OneStepIterator->else->if->isOptimizableForDescendantIterator->if->diagnoseIterator->new->DescendantIterator->else->if->isNaturalDocOrder->if->diagnoseIterator->new->WalkingIterator->else->if->diagnoseIterator->new->WalkingIteratorSorted->if->setIsTopLevel->return
WalkerFactory#getAxisFromStep(Compiler, int):::Special purpose function to see if we can optimize the pattern for a DescendantIterator.:::stepType->compiler->getOp->switch->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->throw->XSLMessages->new->ObjectArr->Integer->toString->createXPATHMessage->new->RuntimeException
WalkerFactory#getAnalysisBitFromAxes(int):::Get a corresponding BIT_XXX from an axis.:::switch->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return
WalkerFactory#mightBeProximate(Compiler, int, int):::Tell if the predicates need to have proximity knowledge.:::mightBeProximate->argLen->switch->compiler->getArgLength->break->compiler->getArgLengthOfStep->predPos->compiler->getFirstPredicateOpPos->count->while->compiler->getOp->innerExprOpPos->predOp->compiler->getOp->switch->return->break->return->isProx->functionProximateOrContainsProximate->if->return->break->leftPos->OpMap->getFirstChildPos->rightPos->compiler->getNextOpPos->isProximateInnerExpr->if->return->isProximateInnerExpr->if->return->break->return->compiler->getNextOpPos->return
WalkerFactory#isDownwardAxisOfMany(int):::Tell if the given axis goes downword:::return
WalkerFactory#loadSteps(MatchPatternIterator, Compiler, int, int):::Read a LocationPath as a generalized match pattern:::if->println->compiler->getPatternString->println->stepType->step->firstStep->prevStep->analysis->analyze->while->compiler->getOp->createDefaultStepPattern->if->else->step->setRelativePathPattern->compiler->getNextStepPos->if->break->axis->paxis->tail->for->pat->pat->getRelativePathPattern->if->selfPattern->new->ContextMatchStepPattern->score->tail->getStaticScore->tail->setRelativePathPattern->tail->setStaticScore->selfPattern->setStaticScore->if->step->toString->println->println->return
WalkerFactory#analyzePredicate(Compiler, int, int):::Analyze a step and give information about it's predicates:::argLen->switch->compiler->getArgLength->break->compiler->getArgLengthOfStep->pos->compiler->getFirstPredicateOpPos->nPredicates->compiler->countPredicates->return
WalkerFactory#isNaturalDocOrder(int):::Tell if the pattern can be 'walked' with the iteration steps in natural document order, without duplicates.:::if->canCrissCross->isSet->walksFilteredList->return->if->walksInDocOrder->return->return
WalkingIterator#getAnalysisBits():::Get the analysis bits for this walker, as defined in the WalkerFactory.:::bits->if->walker->while->bit->walker->getAnalysisBits->walker->getNextWalker->return
WalkingIterator#clone():::Get a cloned WalkingIterator that holds the same position as this iterator.:::clone->super->clone->if->m_firstWalker->cloneDeep->return
WalkingIterator#reset():::Reset the iterator.:::super->reset->if->m_firstWalker->setRoot
WalkingIterator#setRoot(int, Object):::Initialize the context values for this expression after it is cloned.:::super->setRoot->if->m_firstWalker->setRoot
WalkingIterator#nextNode()::: Returns the next node in the set and advances the position of the iterator in the set:::if->return->if->return->m_firstWalker->nextNode->returnNextNode->else->vars->m_execContext->getVarStack->savedStart->vars->getStackFrame->vars->setStackFrame->n->m_firstWalker->nextNode->returnNextNode->vars->setStackFrame->return
WalkingIterator#getFirstWalker():::Get the head of the walker list.:::return
WalkingIterator#setFirstWalker(AxesWalker):::Set the head of the walker list.:::
WalkingIterator#setLastUsedWalker(AxesWalker):::Set the last used walker.:::
WalkingIterator#getLastUsedWalker():::Get the last used walker.:::return
WalkingIterator#detach()::: Detaches the iterator from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state:::if->walker->while->walker->detach->walker->getNextWalker->super->detach
WalkingIterator#fixupVariables(List, int):::This function is used to fixup variables from QNames to stack frame indexes at stylesheet build time.:::walker->while->walker->fixupVariables->walker->getNextWalker
WalkingIteratorSorted#isDocOrdered():::Returns true if all the nodes in the iteration well be returned in document order.:::return
WalkingIteratorSorted#canBeWalkedInNaturalDocOrderStatic():::Tell if the nodeset can be walked in doc order, via static analysis.:::if->walker->prevAxis->prevIsSimpleDownAxis->for->i->return->return
WalkingIteratorSorted#fixupVariables(List, int):::This function is used to perform some extra analysis of the iterator.:::super->fixupVariables->analysis->getAnalysisBits->if->WalkerFactory->isNaturalDocOrder->else
