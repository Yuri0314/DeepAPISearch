Analyser#compile()::: analyser compile:::if->getBegin->getEnd->new->String->println->reset->parse->if->println->println->setupTree->if->if->println->root->new->HashSet<Node>->verifyTree->println->if->isFindCondition->bsAll->else->regex->clearOptimizeInfo->if->setOptimizedInfoFromTree->new->ArrayCompiler->compile->if->else->if->else->if->println->if->print->new->ByteCodePrinter->byteCodeListToString->println
Analyser#swap(Node, Node)::: analyser swap:::a->swap->if->else->if
Analyser#quantifiersMemoryInfo(Node)::: analyser quantifiers memory info:::info->switch->node->getType->can->do->v->quantifiersMemoryInfo->if->while->break->qn->if->quantifiersMemoryInfo->break->en->switch->return->quantifiersMemoryInfo->break->break->break->break->return
Analyser#getMinMatchLength(Node)::: analyser get min match length:::min->switch->node->getType->br->if->br->isRecursion->break->if->throw->new->ValueException->getMinMatchLength->break->can->do->getMinMatchLength->while->break->y->do->x->tmin->getMinMatchLength->if->else->if->while->break->length->break->break->break->qn->if->getMinMatchLength->MinMaxLen->distanceMultiply->break->en->switch->if->en->isMinFixed->else->getMinMatchLength->en->setMinFixed->break->getMinMatchLength->break->break->break->break->return
Analyser#getMaxMatchLength(Node)::: analyser get max match length:::max->switch->node->getType->ln->do->tmax->getMaxMatchLength->MinMaxLen->distanceAdd->while->break->an->do->tmax->getMaxMatchLength->if->while->break->length->break->break->break->br->if->br->isRecursion->break->if->throw->new->ValueException->tmax->getMaxMatchLength->if->break->qn->if->getMaxMatchLength->if->if->isRepeatInfinite->MinMaxLen->distanceMultiply->else->break->en->switch->if->en->isMaxFixed->else->getMaxMatchLength->en->setMaxFixed->break->getMaxMatchLength->break->break->break->break->return
Analyser#getCharLengthTree(Node)::: analyser get char length tree:::return->getCharLengthTree
Analyser#getCharLengthTree(Node, int)::: analyser get char length tree:::level->len->switch->node->getType->ln->do->tlen->getCharLengthTree->if->MinMaxLen->distanceAdd->while->break->an->varLen->tlen->getCharLengthTree->while->tlen2->getCharLengthTree->if->if->if->if->if->else->else->break->sn->sn->length->break->qn->if->getCharLengthTree->if->MinMaxLen->distanceMultiply->else->break->break->en->switch->if->en->isCLenFixed->else->getCharLengthTree->if->en->setCLenFixed->break->getCharLengthTree->break->break->break->break->return
Analyser#isNotIncluded(Node, Node)::: analyser is not included:::x->y->tmp->while->yType->y->getType->switch->x->getType->switch->continue->continue->break->break->xc->switch->yc->for->i->if->xc->isNot->yc->isNot->return->return->continue->break->break->xs->if->xs->length->break->switch->cc->code->return->cc->isCodeInCC->ys->len->xs->length->if->ys->length->ys->length->if->xs->isAmbig->ys->isAmbig->return->for->i->pt->q->break->break->break->break->break->return
Analyser#getHeadValueNode(Node, boolean)::: analyser get head value node:::n->switch->node->getType->break->if->break->getHeadValueNode->break->sn->if->break->if->sn->isRaw->isIgnoreCase->else->break->qn->if->if->else->getHeadValueNode->break->en->switch->options->getHeadValueNode->break->getHeadValueNode->break->break->break->an->if->getHeadValueNode->break->break->return
Analyser#checkTypeTree(Node, int, int, int)::: analyser check type tree:::if->node->getType2Bit->return->invalid->switch->node->getType->can->do->checkTypeTree->while->break->checkTypeTree->break->en->if->return->checkTypeTree->break->an->if->return->if->checkTypeTree->break->break->return
Analyser#divideLookBehindAlternatives(Node)::: analyser divide look behind alternatives:::node->an->anchorType->head->np->swap->tmp->setCar->setTarget->while->insert->new->AnchorNode->insert->setTarget->setCar->if->do->toListNode->while->return
Analyser#setupLookBehind(Node)::: analyser setup look behind:::an->len->getCharLengthTree->switch->break->throw->new->SyntaxException->if->syntax->differentLengthAltLookBehind->return->divideLookBehindAlternatives->throw->new->SyntaxException->break->return
Analyser#nextSetup(Node, Node)::: analyser next setup:::node->while->type->node->getType->if->qn->if->isRepeatInfinite->if->n->getHeadValueNode->if->if->if->isSimple->x->getHeadValueNode->if->y->getHeadValueNode->if->isNotIncluded->en->new->EncloseNode->en->setStopBtSimpleRepeat->swap->en->setTarget->else->if->en->if->en->isMemory->continue->break
Analyser#updateStringNodeCaseFoldMultiByte(StringNode)::: analyser update string node case fold multi byte:::ch->end->sp->buf->while->ovalue->EncodingHelper->toLowerCase->if->sbuf->sn->length->new->charArr->System->arraycopy->while->EncodingHelper->toLowerCase->if->tmp->new->charArr->System->arraycopy->sn->set->return
Analyser#updateStringNodeCaseFold(Node)::: analyser update string node case fold:::sn->updateStringNodeCaseFoldMultiByte
Analyser#expandCaseFoldMakeRemString(char[], int, int)::: analyser expand case fold make rem string:::node->new->StringNode->updateStringNodeCaseFold->node->setAmbig->node->setDontGetOptInfo->return
Analyser#expandCaseFoldStringAlt(int, char[], char[], int, int, int, ObjPtr)::: analyser expand case fold string alt:::altNode->newAltNode->snode->new->StringNode->altNode->setCar->for->i->return
Analyser#expandCaseFoldString(Node)::: analyser expand case fold string:::sn->if->sn->isAmbig->sn->length->return->chars1->pt->end->altNum->topRoot->r->prevNode->new->ObjPtr<Node>->stringNode->while->items->EncodingHelper->caseFoldCodesByString->if->if->if->ConsAltNode->listAdd->new->StringNode->if->ConsAltNode->listAdd->stringNode->cat->else->if->break->if->ConsAltNode->listAdd->expandCaseFoldStringAlt->if->ConsAltNode->listAdd->if->srem->expandCaseFoldMakeRemString->if->ConsAltNode->listAdd->if->else->ConsAltNode->listAdd->xnode->swap->return
Analyser#setupTree(Node, int)::: analyser setup tree:::node->state->while->switch->node->getType->lin->prev->do->setupTree->if->nextSetup->while->break->aln->do->setupTree->while->break->break->if->isIgnoreCase->isRaw->expandCaseFoldString->break->break->br->if->throw->new->ValueException->bsOnAt->bsOnAt->setMemBackrefed->break->qn->target->if->qn->setInRepeat->if->isRepeatInfinite->d->getMinMatchLength->if->if->info->quantifiersMemoryInfo->if->if->setupTree->if->target->getType->if->isRepeatInfinite->sn->len->sn->length->if->str->qn->convertToString->n->for->i->break->if->if->if->target->getType->tqn->if->else->getHeadValueNode->break->en->switch->options->setupTree->break->if->bsOnAt->setupTree->break->setupTree->if->getType->tqn->if->isRepeatInfinite->if->isSimple->en->setStopBtSimpleRepeat->break->break->break->an->switch->setupTree->break->setupTree->break->if->checkTypeTree->throw->new->SyntaxException->setupLookBehind->if->node->getType->continue->setupTree->break->if->checkTypeTree->throw->new->SyntaxException->setupLookBehind->if->node->getType->continue->setupTree->break->break->break->break->return
Analyser#optimizeNodeLeft(Node, NodeOptInfo, OptEnvironment)::: analyser optimize node left:::opt->clear->opt->setBoundNode->switch->node->getType->nenv->new->OptEnvironment->nopt->new->NodeOptInfo->nenv->copy->lin->do->optimizeNodeLeft->add->opt->concatLeftNode->while->break->nopt->new->NodeOptInfo->aln->do->optimizeNodeLeft->if->opt->copy->else->opt->altMerge->while->break->sn->slen->sn->length->if->sn->isAmbig->sn->isRaw->concatStr->if->addChar->set->else->max->if->sn->isDontGetOptInfo->sn->length->else->sn->isRaw->concatStr->if->addCharAmb->set->if->break->cc->if->cc->isNot->set->else->for->i->set->break->set->break->an->switch->add->break->nopt->new->NodeOptInfo->optimizeNodeLeft->if->copy->else->if->copy->if->copy->break->break->break->break->br->if->br->isRecursion->set->break->nodes->min->getMinMatchLength->max->getMaxMatchLength->set->break->nopt->new->NodeOptInfo->qn->optimizeNodeLeft->if->isRepeatInfinite->if->getType->if->isMultiline->add->else->add->else->if->opt->copy->if->if->i->for->isFull->if->if->if->min->MinMaxLen->distanceMultiply->max->if->isRepeatInfinite->else->MinMaxLen->distanceMultiply->set->break->en->switch->save->optimizeNodeLeft->break->if->min->max->if->en->isMinFixed->if->en->isMaxFixed->set->else->optimizeNodeLeft->if->isSet->if->bsAt->remove->break->optimizeNodeLeft->break->break->break->throw->new->InternalException
Analyser#setOptimizedInfoFromTree(Node)::: analyser set optimized info from tree:::opt->new->NodeOptInfo->oenv->new->OptEnvironment->clear->optimizeNodeLeft->if->if->select->if->compare->regex->setOptimizeMapInfo->regex->setSubAnchor->else->regex->setExactInfo->regex->setSubAnchor->else->if->regex->setOptimizeMapInfo->regex->setSubAnchor->else->if->if->regex->optimizeInfoToString->println
ApplyCaseFold#apply(int, int, Object)::: apply case fold apply:::arg->env->cc->bs->inCC->cc->isCodeInCC->if->if->cc->isNot->cc->isNot->if->cc->addCodeRange->else->bs->set->else->if->if->if->cc->isNot->cc->clearNotFlag->cc->addCodeRange->else->if->cc->isNot->bs->clear->else->bs->set
ArrayCompiler#prepare()::: array compiler prepare:::codeSize->analyser->getEnd->analyser->getBegin->new->intArr
ArrayCompiler#finish()::: array compiler finish:::addOpcode->addOpcode
ArrayCompiler#compileAltNode(ConsAltNode)::: array compiler compile alt node:::aln->len->do->compileLengthTree->if->while->pos->do->compileLengthTree->if->addOpcodeRelAddr->compileTree->if->addOpcodeRelAddr->while
ArrayCompiler#isNeedStrLenOpExact(int)::: array compiler is need str len op exact:::return
ArrayCompiler#opTemplated(int)::: array compiler op templated:::return->isNeedStrLenOpExact
ArrayCompiler#selectStrOpcode(int, boolean)::: array compiler select str opcode:::op->if->switch->break->break->else->switch->break->break->break->break->break->break->return
ArrayCompiler#compileTreeEmptyCheck(Node, int)::: array compiler compile tree empty check:::savedNumNullCheck->if->addOpcode->addMemNum->compileTree->if->switch->addOpcode->break->addOpcode->break->break->addMemNum
ArrayCompiler#addCompileStringlength(char[], int, int, boolean)::: array compiler add compile stringlength:::op->selectStrOpcode->len->if->opTemplated->else->if->isNeedStrLenOpExact->return
ArrayCompiler#addCompileString(char[], int, int, boolean)::: array compiler add compile string:::op->selectStrOpcode->addOpcode->if->isNeedStrLenOpExact->addLength->if->opTemplated->addInt->addInt->addTemplate->else->addChars
ArrayCompiler#compileLengthStringNode(Node)::: array compiler compile length string node:::sn->if->sn->length->return->ambig->sn->isAmbig->p->prev->end->chars->slen->rlen->while->r->addCompileStringlength->return
ArrayCompiler#compileLengthStringRawNode(StringNode)::: array compiler compile length string raw node:::if->sn->length->return->return->sn->length->addCompileStringlength
ArrayCompiler#addMultiByteCClass(CodeRangeBuffer)::: array compiler add multi byte class:::addLength->addInts
ArrayCompiler#compileLengthCClassNode(CClassNode)::: array compiler compile length class node:::if->cc->isShare->return->len->if->else->if->isEmpty->else->return
ArrayCompiler#compileCClassNode(CClassNode)::: array compiler compile class node:::if->cc->isShare->addOpcode->addPointer->return->if->if->cc->isNot->addOpcode->else->addOpcode->addInts->else->if->isEmpty->if->cc->isNot->addOpcode->else->addOpcode->addMultiByteCClass->else->if->cc->isNot->addOpcode->else->addOpcode->addInts->addMultiByteCClass
ArrayCompiler#compileAnyCharNode()::: array compiler compile any char node:::if->isMultiline->addOpcode->else->addOpcode
ArrayCompiler#compileBackrefNode(BackRefNode)::: array compiler compile backref node:::if->isIgnoreCase->addOpcode->addMemNum->else->switch->addOpcode->break->addOpcode->break->addOpcode->addOpcode->break
ArrayCompiler#entryRepeatRange(int, int, int)::: array compiler entry repeat range:::if->new->intArr->new->intArr->else->if->tmp->new->intArr->System->arraycopy->new->intArr->System->arraycopy->isRepeatInfinite
ArrayCompiler#compileRangeRepeatNode(QuantifierNode, int, int)::: array compiler compile range repeat node:::numRepeat->addOpcode->addMemNum->addRelAddr->entryRepeatRange->compileTreeEmptyCheck->if->qn->isInRepeat->addOpcode->else->addOpcode->addMemNum
ArrayCompiler#cknOn(int)::: array compiler ckn on:::return
ArrayCompiler#compileNonCECLengthQuantifierNode(QuantifierNode)::: array compiler compile non length quantifier node:::infinite->isRepeatInfinite->emptyInfo->tlen->compileLengthTree->if->getType->if->if->return->return->modTLen->if->else->len->if->if->else->if->if->else->if->else->else->else->if->else->if->else->if->else->return
ArrayCompiler#compileNonCECQuantifierNode(QuantifierNode)::: array compiler compile non quantifier node:::infinite->isRepeatInfinite->emptyInfo->tlen->compileLengthTree->if->qn->isAnyCharStar->compileTreeNTimes->if->if->isMultiline->addOpcode->else->addOpcode->sn->addChars->return->if->isMultiline->addOpcode->else->addOpcode->return->modTLen->if->else->if->if->if->if->addOpcodeRelAddr->else->if->addOpcodeRelAddr->else->addOpcodeRelAddr->else->addOpcodeRelAddr->else->compileTreeNTimes->if->if->addOpcodeRelAddr->sn->addChars->compileTreeEmptyCheck->addOpcodeRelAddr->else->if->addOpcodeRelAddr->sn->addChars->compileTreeEmptyCheck->addOpcodeRelAddr->else->addOpcodeRelAddr->compileTreeEmptyCheck->addOpcodeRelAddr->else->addOpcodeRelAddr->compileTreeEmptyCheck->addOpcodeRelAddr->else->if->addOpcodeRelAddr->compileTree->else->if->n->compileTreeNTimes->for->i->else->if->addOpcodeRelAddr->addOpcodeRelAddr->compileTree->else->compileRangeRepeatNode
ArrayCompiler#compileLengthOptionNode(EncloseNode)::: array compiler compile length option node:::prev->tlen->compileLengthTree->if->isDynamic->return->return
ArrayCompiler#compileOptionNode(EncloseNode)::: array compiler compile option node:::prev->if->isDynamic->addOpcodeOption->addOpcodeOption->addOpcode->compileTree->if->isDynamic->addOpcodeOption
ArrayCompiler#compileLengthEncloseNode(EncloseNode)::: array compiler compile length enclose node:::if->node->isOption->return->compileLengthOptionNode->tlen->if->compileLengthTree->else->len->switch->if->bsAt->else->bsAt->break->if->node->isStopBtSimpleRepeat->qn->compileLengthTree->else->break->newInternalException->return->return
ArrayCompiler#compileEncloseNode(EncloseNode)::: array compiler compile enclose node:::len->switch->if->bsAt->addOpcode->else->addOpcode->addMemNum->compileTree->if->bsAt->addOpcode->else->addOpcode->addMemNum->break->if->node->isStopBtSimpleRepeat->qn->compileTreeNTimes->compileLengthTree->addOpcodeRelAddr->compileTree->addOpcode->addOpcodeRelAddr->else->addOpcode->compileTree->addOpcode->break->newInternalException->break
ArrayCompiler#compileLengthAnchorNode(AnchorNode)::: array compiler compile length anchor node:::tlen->if->compileLengthTree->else->len->switch->break->break->break->break->break->return
ArrayCompiler#compileAnchorNode(AnchorNode)::: array compiler compile anchor node:::len->n->switch->addOpcode->break->addOpcode->break->addOpcode->break->addOpcode->break->addOpcode->break->addOpcode->break->addOpcode->break->addOpcode->break->if->addOpcode->break->if->addOpcode->break->addOpcode->compileTree->addOpcode->break->compileLengthTree->addOpcodeRelAddr->compileTree->addOpcode->break->addOpcode->if->analyser->getCharLengthTree->if->newSyntaxException->else->addLength->compileTree->break->compileLengthTree->addOpcodeRelAddr->if->analyser->getCharLengthTree->if->newSyntaxException->else->addLength->compileTree->addOpcode->break->newInternalException
ArrayCompiler#compileLengthTree(Node)::: array compiler compile length tree:::len->switch->node->getType->lin->do->compileLengthTree->while->break->aln->n->do->compileLengthTree->while->break->sn->if->sn->isRaw->compileLengthStringRawNode->else->compileLengthStringNode->break->compileLengthCClassNode->break->break->br->isIgnoreCase->break->compileNonCECLengthQuantifierNode->break->compileLengthEncloseNode->break->compileLengthAnchorNode->break->newInternalException->return
ArrayCompiler#ensure(int)::: array compiler ensure:::if->length->while->tmp->new->intArr->System->arraycopy
ArrayCompiler#addInt(int)::: array compiler add int:::if->tmp->new->intArr->System->arraycopy
ArrayCompiler#setInt(int, int)::: array compiler set int:::ensure
ArrayCompiler#addObject(Object)::: array compiler add object:::if->new->ObjectArr->else->if->tmp->new->ObjectArr->System->arraycopy->addInt
ArrayCompiler#addChars(char[], int, int)::: array compiler add chars:::ensure->p->end->while
ArrayCompiler#addInts(int[], int)::: array compiler add ints:::ensure->System->arraycopy
ArrayCompiler#addOpcode(int)::: array compiler add opcode:::addInt->switch->break->break
ArrayCompiler#addStateCheckNum(int)::: array compiler add state check num:::addInt
ArrayCompiler#addRelAddr(int)::: array compiler add rel addr:::addInt
ArrayCompiler#addAbsAddr(int)::: array compiler add abs addr:::addInt
ArrayCompiler#addLength(int)::: array compiler add length:::addInt
ArrayCompiler#addMemNum(int)::: array compiler add mem num:::addInt
ArrayCompiler#addPointer(Object)::: array compiler add pointer:::addObject
ArrayCompiler#addOption(int)::: array compiler add option:::addInt
ArrayCompiler#addOpcodeRelAddr(int, int)::: array compiler add opcode rel addr:::addOpcode->addRelAddr
ArrayCompiler#addOpcodeOption(int, int)::: array compiler add opcode option:::addOpcode->addOption
ArrayCompiler#addTemplate(char[])::: array compiler add template:::if->new->charArrs->else->if->tmp->new->charArrs->System->arraycopy
BitSet#toString()::: bit set to string:::buffer->new->StringBuilder->buffer->append->for->i->return->buffer->toString
BitSet#at(int)::: bit set at:::return->bit
BitSet#set(int)::: bit set set:::bit
BitSet#clear(int)::: bit set clear:::bit
BitSet#clear()::: bit set clear:::for->i
BitSet#isEmpty()::: bit set is empty:::for->i->return
BitSet#setRange(int, int)::: bit set set range:::for->i
BitSet#invert()::: bit set invert:::for->i
BitSet#invertTo(BitSet)::: bit set invert to:::for->i
BitSet#and(BitSet)::: bit set and:::for->i
BitSet#or(BitSet)::: bit set or:::for->i
BitSet#copy(BitSet)::: bit set copy:::System->arraycopy
BitSet#numOn()::: bit set num on:::num->for->i->return
BitSet#bit(int)::: bit set bit:::return
BitSet#log2(int)::: bit set log2:::log->n->while->return
BitStatus#bsClear()::: bit status bs clear:::return
BitStatus#bsAll()::: bit status bs all:::return
BitStatus#bsAt(int, int)::: bit status bs at:::return
BitStatus#bsOnAt(int, int)::: bit status bs on at:::stats->if->else->return
BitStatus#bsOnOff(int, int, boolean)::: bit status bs on off:::return
ByteCodeMachine#stringCmpIC(int, int, IntHolder, int, int)::: byte code machine string cmp c:::s1->s2->end1->while->c1->EncodingHelper->toLowerCase->c2->EncodingHelper->toLowerCase->if->return->return
ByteCodeMachine#debugMatchBegin()::: byte code machine debug match begin:::println->println
ByteCodeMachine#debugMatchLoop()::: byte code machine debug match loop:::if->printf->print->q->i->for->string->string->length->print->for->sb->new->StringBuilder->new->ByteCodePrinter->compiledByteCodeToString->sb->toString->println
ByteCodeMachine#matchAt(int, int, int)::: byte code machine match at:::if->debugMatchBegin->init->c->while->if->debugMatchLoop->switch->if->opEnd->return->finish->break->opExact1->break->opExact2->continue->opExact3->continue->opExact4->continue->opExact5->continue->opExactN->continue->opExact1IC->break->opExactNIC->continue->opCClass->break->opCClassMB->break->opCClassMIX->break->opCClassNot->break->opCClassMBNot->break->opCClassMIXNot->break->opCClassNode->break->opAnyChar->break->opAnyCharML->break->opAnyCharStar->break->opAnyCharMLStar->break->opAnyCharStarPeekNext->break->opAnyCharMLStarPeekNext->break->opWord->break->opNotWord->break->opWordBound->continue->opNotWordBound->continue->opWordBegin->continue->opWordEnd->continue->opBeginBuf->continue->opEndBuf->continue->opBeginLine->continue->opEndLine->continue->opSemiEndBuf->continue->opBeginPosition->continue->opMemoryStartPush->continue->opMemoryStart->continue->opMemoryEndPush->continue->opMemoryEnd->continue->opMemoryEndPushRec->continue->opMemoryEndRec->continue->opBackRef1->continue->opBackRef2->continue->opBackRefN->continue->opBackRefNIC->continue->opBackRefMulti->continue->opBackRefMultiIC->continue->opBackRefAtLevel->continue->opNullCheckStart->continue->opNullCheckEnd->continue->opNullCheckEndMemST->continue->opJump->continue->opPush->continue->opPop->continue->opPushOrJumpExact1->continue->opPushIfPeekNext->continue->opRepeat->continue->opRepeatNG->continue->opRepeatInc->continue->opRepeatIncSG->continue->opRepeatIncNG->continue->opRepeatIncNGSG->continue->opPushPos->continue->opPopPos->continue->opPushPosNot->continue->opFailPos->continue->opPushStopBT->continue->opPopStopBT->continue->opLookBehind->continue->opPushLookBehindNot->continue->opFailLookBehindNot->continue->return->finish->opFail->continue->throw->new->InternalException
ByteCodeMachine#opEnd()::: byte code machine op end:::n->if->if->if->isFindLongest->if->else->return->endBestLength->region->if->for->i->else->else->region->if->if->isPosixRegion->if->region->clear->else->else->if->region->clear->else->return->endBestLength
ByteCodeMachine#endBestLength()::: byte code machine end best length:::if->isFindCondition->if->isFindNotEmpty->opFail->return->if->isFindLongest->opFail->return->return
ByteCodeMachine#opExact1()::: byte code machine op exact1:::if->opFail->return
ByteCodeMachine#opExact2()::: byte code machine op exact2:::if->opFail->return->if->opFail->return->if->opFail->return
ByteCodeMachine#opExact3()::: byte code machine op exact3:::if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return
ByteCodeMachine#opExact4()::: byte code machine op exact4:::if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return
ByteCodeMachine#opExact5()::: byte code machine op exact5:::if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return->if->opFail->return
ByteCodeMachine#opExactN()::: byte code machine op exact n:::tlen->if->opFail->return->if->bs->ps->while->if->opFail->return->else->while->if->opFail->return
ByteCodeMachine#opExact1IC()::: byte code machine op exact1 c:::if->EncodingHelper->toLowerCase->opFail->return
ByteCodeMachine#opExactNIC()::: byte code machine op exact c:::tlen->if->opFail->return->if->bs->ps->while->if->EncodingHelper->toLowerCase->opFail->return->else->while->if->EncodingHelper->toLowerCase->opFail->return
ByteCodeMachine#isInBitSet()::: byte code machine is in bit set:::c->return
ByteCodeMachine#opCClass()::: byte code machine op class:::if->isInBitSet->opFail->return
ByteCodeMachine#isInClassMB()::: byte code machine is in class b:::tlen->if->return->ss->c->if->EncodingHelper->isInCodeRange->return->return
ByteCodeMachine#opCClassMB()::: byte code machine op class b:::if->opFail->return->if->isInClassMB->opFail->return
ByteCodeMachine#opCClassMIX()::: byte code machine op class x:::if->opFail->return->if->if->isInClassMB->opFail->return->else->if->isInBitSet->opFail->return->tlen
ByteCodeMachine#opCClassNot()::: byte code machine op class not:::if->isInBitSet->opFail->return
ByteCodeMachine#isNotInClassMB()::: byte code machine is not in class b:::tlen->if->if->return->return->ss->c->if->EncodingHelper->isInCodeRange->return->return
ByteCodeMachine#opCClassMBNot()::: byte code machine op class not:::if->opFail->return->if->tlen->return->if->isNotInClassMB->opFail->return
ByteCodeMachine#opCClassMIXNot()::: byte code machine op class not:::if->opFail->return->if->if->isNotInClassMB->opFail->return->else->if->isInBitSet->opFail->return->tlen
ByteCodeMachine#opCClassNode()::: byte code machine op class node:::if->opFail->return->cc->ss->c->if->cc->isCodeInCCLength->opFail->return
ByteCodeMachine#opAnyChar()::: byte code machine op any char:::if->opFail->return->if->isNewLine->opFail->return
ByteCodeMachine#opAnyCharML()::: byte code machine op any char l:::if->opFail->return
ByteCodeMachine#opAnyCharStar()::: byte code machine op any char star:::ch->while->pushAlt->if->isNewLine->opFail->return
ByteCodeMachine#opAnyCharMLStar()::: byte code machine op any char star:::while->pushAlt
ByteCodeMachine#opAnyCharStarPeekNext()::: byte code machine op any char star peek next:::c->ch->while->b->if->pushAlt->if->isNewLine->opFail->return
ByteCodeMachine#opAnyCharMLStarPeekNext()::: byte code machine op any char star peek next:::c->ch->while->if->pushAlt
ByteCodeMachine#opWord()::: byte code machine op word:::if->EncodingHelper->isWord->opFail->return
ByteCodeMachine#opNotWord()::: byte code machine op not word:::if->EncodingHelper->isWord->opFail->return
ByteCodeMachine#opWordBound()::: byte code machine op word bound:::if->if->EncodingHelper->isWord->opFail->return->else->if->if->EncodingHelper->isWord->opFail->return->else->if->EncodingHelper->isWord->EncodingHelper->isWord->opFail->return
ByteCodeMachine#opNotWordBound()::: byte code machine op not word bound:::if->if->EncodingHelper->isWord->opFail->return->else->if->if->EncodingHelper->isWord->opFail->return->else->if->EncodingHelper->isWord->EncodingHelper->isWord->opFail->return
ByteCodeMachine#opWordBegin()::: byte code machine op word begin:::if->EncodingHelper->isWord->if->EncodingHelper->isWord->return->opFail
ByteCodeMachine#opWordEnd()::: byte code machine op word end:::if->EncodingHelper->isWord->if->EncodingHelper->isWord->return->opFail
ByteCodeMachine#opBeginBuf()::: byte code machine op begin buf:::if->opFail
ByteCodeMachine#opEndBuf()::: byte code machine op end buf:::if->opFail
ByteCodeMachine#opBeginLine()::: byte code machine op begin line:::if->if->isNotBol->opFail->return->else->if->isNewLine->return->opFail
ByteCodeMachine#opEndLine()::: byte code machine op end line:::if->if->if->isNewLine->if->isNotEol->opFail->return->if->isNotEol->opFail->return->else->if->isNewLine->return->opFail
ByteCodeMachine#opSemiEndBuf()::: byte code machine op semi end buf:::if->if->if->isNewLine->if->isNotEol->opFail->return->if->isNotEol->opFail->return->else->if->isNewLine->return->opFail
ByteCodeMachine#opBeginPosition()::: byte code machine op begin position:::if->opFail
ByteCodeMachine#opMemoryStartPush()::: byte code machine op memory start push:::mem->pushMemStart
ByteCodeMachine#opMemoryStart()::: byte code machine op memory start:::mem
ByteCodeMachine#opMemoryEndPush()::: byte code machine op memory end push:::mem->pushMemEnd
ByteCodeMachine#opMemoryEnd()::: byte code machine op memory end:::mem
ByteCodeMachine#opMemoryEndPushRec()::: byte code machine op memory end push rec:::mem->stkp->getMemStart->pushMemEnd
ByteCodeMachine#opMemoryEndRec()::: byte code machine op memory end rec:::mem->stkp->getMemStart->if->BitStatus->bsAt->else->getMemPStr->pushMemEndMark
ByteCodeMachine#backrefInvalid(int)::: byte code machine backref invalid:::return
ByteCodeMachine#backrefStart(int)::: byte code machine backref start:::return->bsAt->getMemPStr
ByteCodeMachine#backrefEnd(int)::: byte code machine backref end:::return->bsAt->getMemPStr
ByteCodeMachine#backref(int)::: byte code machine backref:::if->backrefInvalid->opFail->return->pstart->backrefStart->pend->backrefEnd->n->if->opFail->return->while->if->opFail->return->if->while
ByteCodeMachine#opBackRef1()::: byte code machine op back ref1:::backref
ByteCodeMachine#opBackRef2()::: byte code machine op back ref2:::backref
ByteCodeMachine#opBackRefN()::: byte code machine op back ref n:::backref
ByteCodeMachine#opBackRefNIC()::: byte code machine op back ref c:::mem->if->backrefInvalid->opFail->return->pstart->backrefStart->pend->backrefEnd->n->if->opFail->return->if->stringCmpIC->opFail->return->while
ByteCodeMachine#opBackRefMulti()::: byte code machine op back ref multi:::tlen->i->for->if->opFail->return
ByteCodeMachine#opBackRefMultiIC()::: byte code machine op back ref multi c:::tlen->i->for->if->opFail->return
ByteCodeMachine#memIsInMemp(int, int, int)::: byte code machine mem is in memp:::for->i->memp->return
ByteCodeMachine#backrefMatchAtNestedLevel(boolean, int, int, int, int)::: byte code machine backref match at nested level:::pend->level->k->while->e->if->else->if->else->if->if->if->e->getMemNum->memIsInMemp->pstart->e->getMemPStr->if->if->return->p->if->if->stringCmpIC->return->else->while->if->return->return->else->if->if->e->getMemNum->memIsInMemp->e->getMemPStr->return
ByteCodeMachine#opBackRefAtLevel()::: byte code machine op back ref at level:::ic->level->tlen->if->backrefMatchAtNestedLevel->while->else->opFail->return
ByteCodeMachine#opNullCheckStart()::: byte code machine op null check start:::mem->pushNullCheckStart
ByteCodeMachine#nullCheckFound()::: byte code machine null check found:::switch->break->break->throw->new->InternalException
ByteCodeMachine#opNullCheckEnd()::: byte code machine op null check end:::mem->isNull->nullCheck->if->if->println->nullCheckFound
ByteCodeMachine#opNullCheckEndMemST()::: byte code machine op null check end mem t:::mem->isNull->nullCheckMemSt->if->if->println->if->opFail->return->nullCheckFound
ByteCodeMachine#opJump()::: byte code machine op jump:::
ByteCodeMachine#opPush()::: byte code machine op push:::addr->pushAlt
ByteCodeMachine#opPop()::: byte code machine op pop:::popOne
ByteCodeMachine#opPushOrJumpExact1()::: byte code machine op push or jump exact1:::addr->if->pushAlt->return
ByteCodeMachine#opPushIfPeekNext()::: byte code machine op push if peek next:::addr->if->pushAlt->return
ByteCodeMachine#opRepeat()::: byte code machine op repeat:::mem->addr->pushRepeat->if->pushAlt
ByteCodeMachine#opRepeatNG()::: byte code machine op repeat g:::mem->addr->pushRepeat->if->pushAlt
ByteCodeMachine#repeatInc(int, int)::: byte code machine repeat inc:::e->e->increaseRepeatCount->if->e->getRepeatCount->else->if->e->getRepeatCount->pushAlt->e->getRepeatPCode->else->e->getRepeatPCode->pushRepeatInc
ByteCodeMachine#opRepeatInc()::: byte code machine op repeat inc:::mem->si->repeatInc
ByteCodeMachine#opRepeatIncSG()::: byte code machine op repeat inc g:::mem->si->getRepeat->repeatInc
ByteCodeMachine#repeatIncNG(int, int)::: byte code machine repeat inc g:::e->e->increaseRepeatCount->if->e->getRepeatCount->if->e->getRepeatCount->pcode->e->getRepeatPCode->pushRepeatInc->pushAlt->else->e->getRepeatPCode->pushRepeatInc->else->if->e->getRepeatCount->pushRepeatInc
ByteCodeMachine#opRepeatIncNG()::: byte code machine op repeat inc g:::mem->si->repeatIncNG
ByteCodeMachine#opRepeatIncNGSG()::: byte code machine op repeat inc g:::mem->si->getRepeat->repeatIncNG
ByteCodeMachine#opPushPos()::: byte code machine op push pos:::pushPos
ByteCodeMachine#opPopPos()::: byte code machine op pop pos:::e->posEnd->e->getStatePStr->e->getStatePStrPrev
ByteCodeMachine#opPushPosNot()::: byte code machine op push pos not:::addr->pushPosNot
ByteCodeMachine#opFailPos()::: byte code machine op fail pos:::popTilPosNot->opFail
ByteCodeMachine#opPushStopBT()::: byte code machine op push stop t:::pushStopBT
ByteCodeMachine#opPopStopBT()::: byte code machine op pop stop t:::stopBtEnd
ByteCodeMachine#opLookBehind()::: byte code machine op look behind:::tlen->EncodingHelper->stepBack->if->opFail->return->EncodingHelper->prevCharHead
ByteCodeMachine#opPushLookBehindNot()::: byte code machine op push look behind not:::addr->tlen->q->EncodingHelper->stepBack->if->else->pushLookBehindNot->EncodingHelper->prevCharHead
ByteCodeMachine#opFailLookBehindNot()::: byte code machine op fail look behind not:::popTilLookBehindNot->opFail
ByteCodeMachine#opFail()::: byte code machine op fail:::if->return->e->pop->e->getStatePCode->e->getStatePStr->e->getStatePStrPrev
ByteCodeMachine#finish()::: byte code machine finish:::return
ByteCodePrinter#byteCodeListToString()::: byte code printer byte code list to string:::return->compiledByteCodeListToString
ByteCodePrinter#pString(StringBuilder, int, int)::: byte code printer p string:::sb->append->sb->new->String->append
ByteCodePrinter#pLenString(StringBuilder, int, int)::: byte code printer p len string:::sb->append->append->append->sb->new->String->append
ByteCodePrinter#pLenStringFromTemplate(StringBuilder, int, char[], int)::: byte code printer p len string from template:::sb->append->append->append->sb->append
ByteCodePrinter#compiledByteCodeToString(StringBuilder, int)::: byte code printer compiled byte code to string:::len->n->mem->addr->scn->cod->bs->cc->tm->idx->bp->sb->append->append->argType->ip->if->switch->break->sb->append->append->append->break->sb->append->append->append->break->sb->append->append->break->sb->append->append->break->sb->append->append->break->sb->append->append->break->else->switch->pString->break->pString->break->pString->break->pString->break->pString->break->if->pLenStringFromTemplate->else->pLenString->break->pString->break->if->pLenStringFromTemplate->else->pLenString->break->new->BitSet->System->arraycopy->bs->numOn->sb->append->append->break->new->BitSet->System->arraycopy->bs->numOn->sb->append->append->break->sb->append->append->append->append->break->new->BitSet->System->arraycopy->bs->numOn->sb->append->append->append->append->append->append->break->numOn->sb->append->append->append->append->break->sb->append->append->break->sb->append->for->i->break->option->sb->append->append->level->sb->append->append->sb->append->for->i->break->sb->append->append->append->append->break->sb->append->append->append->pString->break->sb->append->append->break->sb->append->append->append->append->append->break->sb->append->append->append->append->append->break->throw->new->InternalException->sb->append->if->sb->append->append->append->append->append->return
ByteCodePrinter#compiledByteCodeListToString()::: byte code printer compiled byte code list to string:::sb->new->StringBuilder->sb->append->append->append->ncode->bp->end->while->if->sb->append->compiledByteCodeToString->sb->append->return->sb->toString
CodeRangeBuffer#isInCodeRange(int)::: code range buffer is in code range:::low->n->high->while->x->if->else->return
CodeRangeBuffer#toString()::: code range buffer to string:::buf->new->StringBuilder->buf->append->buf->append->append->buf->append->append->buf->append->for->i->return->buf->toString
CodeRangeBuffer#rangeNumToString(int)::: code range buffer range num to string:::return->Integer->toString
CodeRangeBuffer#expand(int)::: code range buffer expand:::length->do->while->tmp->new->intArr->System->arraycopy
CodeRangeBuffer#ensureSize(int)::: code range buffer ensure size:::length->while->if->tmp->new->intArr->System->arraycopy
CodeRangeBuffer#moveRight(int, int, int)::: code range buffer move right:::if->expand->System->arraycopy->if
CodeRangeBuffer#moveLeft(int, int, int)::: code range buffer move left:::System->arraycopy
CodeRangeBuffer#moveLeftAndReduce(int, int)::: code range buffer move left and reduce:::System->arraycopy
CodeRangeBuffer#writeCodePoint(int, int)::: code range buffer write code point:::u->if->expand->if
CodeRangeBuffer#clone()::: code range buffer clone:::return->new->CodeRangeBuffer
CodeRangeBuffer#addCodeRangeToBuff(CodeRangeBuffer, int, int)::: code range buffer add code range to buff:::from->to->pbuf->if->n->if->new->CodeRangeBuffer->p->n->low->bound->while->x->if->else->high->while->x->if->else->incN->if->throw->new->ValueException->if->if->if->if->fromPos->toPos->size->if->pbuf->moveRight->else->pbuf->moveLeftAndReduce->pos->pbuf->writeCodePoint->pbuf->writeCodePoint->pbuf->writeCodePoint->return
CodeRangeBuffer#addCodeRange(CodeRangeBuffer, ScanEnvironment, int, int)::: code range buffer add code range:::if->if->allowEmptyRangeInCC->return->throw->new->ValueException->return->addCodeRangeToBuff
CodeRangeBuffer#setAllMultiByteRange(CodeRangeBuffer)::: code range buffer set all multi byte range:::return->EncodingHelper->mbcodeStartPosition->addCodeRangeToBuff
CodeRangeBuffer#addAllMultiByteRange(CodeRangeBuffer)::: code range buffer add all multi byte range:::return->setAllMultiByteRange
CodeRangeBuffer#notCodeRangeBuff(CodeRangeBuffer)::: code range buffer not code range buff:::pbuf->if->return->setAllMultiByteRange->p->n->if->return->setAllMultiByteRange->pre->EncodingHelper->mbcodeStartPosition->from->to->for->i->if->addCodeRangeToBuff->return
CodeRangeBuffer#orCodeRangeBuff(CodeRangeBuffer, boolean, CodeRangeBuffer, boolean)::: code range buffer or code range buff:::pbuf->bbuf1->bbuf2->not1->not2->if->if->return->setAllMultiByteRange->return->if->tbuf->tnot->if->if->return->setAllMultiByteRange->if->return->bbuf2->clone->return->notCodeRangeBuff->if->tbuf->tnot->if->bbuf2->clone->else->if->notCodeRangeBuff->p1->n1->for->i->return
CodeRangeBuffer#andCodeRange1(CodeRangeBuffer, int, int, int[], int)::: code range buffer and code range1:::pbuf->from1->to1->for->i->if->addCodeRangeToBuff->return
CodeRangeBuffer#andCodeRangeBuff(CodeRangeBuffer, boolean, CodeRangeBuffer, boolean)::: code range buffer and code range buff:::pbuf->bbuf1->bbuf2->not1->not2->if->if->return->bbuf2->clone->return->else->if->if->return->bbuf1->clone->return->if->tbuf->tnot->p1->n1->p2->n2->if->for->i->else->if->for->i->return
Compiler#compile()::: compiler compile:::prepare->compileTree->finish
Compiler#prepare()::: compiler prepare:::
Compiler#finish()::: compiler finish:::
Compiler#compileAltNode(ConsAltNode)::: compiler compile alt node:::
Compiler#compileStringRawNode(StringNode)::: compiler compile string raw node:::if->sn->length->return->sn->length->addCompileString
Compiler#compileStringNode(StringNode)::: compiler compile string node:::sn->if->sn->length->return->ambig->sn->isAmbig->p->prev->end->chars->slen->while->addCompileString
Compiler#addCompileString(char[], int, int, boolean)::: compiler add compile string:::
Compiler#compileCClassNode(CClassNode)::: compiler compile class node:::
Compiler#compileAnyCharNode()::: compiler compile any char node:::
Compiler#compileBackrefNode(BackRefNode)::: compiler compile backref node:::
Compiler#compileNonCECQuantifierNode(QuantifierNode)::: compiler compile non quantifier node:::
Compiler#compileOptionNode(EncloseNode)::: compiler compile option node:::
Compiler#compileEncloseNode(EncloseNode)::: compiler compile enclose node:::
Compiler#compileAnchorNode(AnchorNode)::: compiler compile anchor node:::
Compiler#compileTree(Node)::: compiler compile tree:::switch->node->getType->lin->do->compileTree->while->break->compileAltNode->break->sn->if->sn->isRaw->compileStringRawNode->else->compileStringNode->break->compileCClassNode->break->compileAnyCharNode->break->compileBackrefNode->break->compileNonCECQuantifierNode->break->enode->if->enode->isOption->compileOptionNode->else->compileEncloseNode->break->compileAnchorNode->break->newInternalException
Compiler#compileTreeNTimes(Node, int)::: compiler compile tree times:::for->i
Compiler#newSyntaxException(String)::: compiler new syntax exception:::throw->new->SyntaxException
Compiler#newInternalException(String)::: compiler new internal exception:::throw->new->InternalException
EncodingHelper#digitVal(int)::: encoding helper digit val:::return
EncodingHelper#odigitVal(int)::: encoding helper odigit val:::return->digitVal
EncodingHelper#isXDigit(int)::: encoding helper is digit:::return->Character->isDigit
EncodingHelper#xdigitVal(int)::: encoding helper xdigit val:::if->Character->isDigit->return->else->if->return->else->return
EncodingHelper#isDigit(int)::: encoding helper is digit:::return
EncodingHelper#isWord(int)::: encoding helper is word:::return->Character->getType
EncodingHelper#isNewLine(int)::: encoding helper is new line:::return
EncodingHelper#isNewLine(char[], int, int)::: encoding helper is new line:::return->isNewLine
EncodingHelper#prevCharHead(int, int)::: encoding helper prev char head:::return
EncodingHelper#rightAdjustCharHeadWithPrev(int, IntHolder)::: encoding helper right adjust char head with prev:::if->return
EncodingHelper#stepBack(int, int, int)::: encoding helper step back:::s->n->while->if->return->return
EncodingHelper#mbcodeStartPosition()::: encoding helper mbcode start position:::return
EncodingHelper#caseFoldCodesByString(int, char)::: encoding helper case fold codes by string:::codes->upper->toUpperCase->if->toLowerCase->count->ch->do->u->toUpperCase->if->new->charArr->Arrays->copyOf->while->return
EncodingHelper#applyAllCaseFold(int, ApplyCaseFold, Object)::: encoding helper apply all case fold:::for->c->for->c
EncodingHelper#toLowerCase(char)::: encoding helper to lower case:::return->toLowerCase
EncodingHelper#toLowerCase(int)::: encoding helper to lower case:::if->return->lower->Character->toLowerCase->return
EncodingHelper#toUpperCase(char)::: encoding helper to upper case:::return->toUpperCase
EncodingHelper#toUpperCase(int)::: encoding helper to upper case:::if->return->upper->Character->toUpperCase->return
EncodingHelper#ctypeCodeRange(int, IntHolder)::: encoding helper ctype code range:::range->if->if->new->intArr->rangeCount->lastCode->for->code->if->Arrays->copyOf->return
EncodingHelper#isInCodeRange(int[], int, int)::: encoding helper is in code range:::low->n->high->while->x->if->else->return
EncodingHelper#isCodeCType(int, int)::: encoding helper is code type:::type->switch->return->isNewLine->return->Character->getType->return->Character->getType->Character->getType->return->return->EncodingHelper->isDigit->switch->return->Character->getType->return->return->Character->isLowerCase->Character->getType->return->return->Character->getType->switch->return->return->Character->getType->return->Character->isUpperCase->return->EncodingHelper->isXDigit->return->Character->getType->return->Character->getType->return->throw->new->RuntimeException
Lexer#fetchRangeQuantifier()::: lexer fetch range quantifier:::mark->synAllow->syntax->allowInvalidInterval->if->left->if->return->throw->new->SyntaxException->if->peek->if->throw->new->SyntaxException->low->scanUnsignedNumber->if->throw->new->SyntaxException->if->throw->new->SyntaxException->nonLow->if->if->syntax->allowIntervalLowAbbrev->else->return->invalidRangeQuantifier->if->left->return->invalidRangeQuantifier->fetch->up->ret->if->prev->scanUnsignedNumber->if->throw->new->ValueException->if->throw->new->ValueException->if->if->return->invalidRangeQuantifier->else->if->return->invalidRangeQuantifier->unfetch->if->left->return->invalidRangeQuantifier->fetch->if->syntax->opEscBraceInterval->if->return->invalidRangeQuantifier->fetch->if->return->invalidRangeQuantifier->if->isRepeatInfinite->throw->new->ValueException->token->setRepeatLower->token->setRepeatUpper->return
Lexer#invalidRangeQuantifier(boolean)::: lexer invalid range quantifier:::if->restore->return->throw->new->SyntaxException
Lexer#fetchEscapedValue()::: lexer fetch escaped value:::if->left->throw->new->SyntaxException->fetch->switch->if->syntax->op2EscCapitalMBarMeta->if->left->throw->new->SyntaxException->fetch->if->throw->new->SyntaxException->if->left->throw->new->SyntaxException->fetch->if->fetchEscapedValue->else->fetchEscapedValueBackSlash->break->if->syntax->op2EscCapitalCBarControl->if->left->throw->new->SyntaxException->fetch->if->throw->new->SyntaxException->fetchEscapedValueControl->else->fetchEscapedValueBackSlash->break->if->syntax->opEscCControl->fetchEscapedValueControl->fetchEscapedValueBackSlash->return
Lexer#fetchEscapedValueBackSlash()::: lexer fetch escaped value back slash:::env->convertBackslashValue
Lexer#fetchEscapedValueControl()::: lexer fetch escaped value control:::if->left->throw->new->SyntaxException->fetch->if->else->if->fetchEscapedValue
Lexer#fetchTokenInCCFor_charType(boolean, int)::: lexer fetch token in for_char type:::token->setPropCType->token->setPropNot
Lexer#fetchTokenInCCFor_x()::: lexer fetch token in for_x:::if->left->return->last->if->peekIs->syntax->opEscXBraceHex8->inc->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->left->c2->peek->if->EncodingHelper->isXDigit->throw->new->ValueException->if->left->peekIs->inc->token->setCode->else->else->if->syntax->opEscXHex2->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->token->setC
Lexer#fetchTokenInCCFor_u()::: lexer fetch token in for_u:::if->left->return->last->if->syntax->op2EscUHex4->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->token->setCode
Lexer#fetchTokenInCCFor_digit()::: lexer fetch token in for_digit:::if->syntax->opEscOctal3->unfetch->last->num->scanUnsignedOctalNumber->if->throw->new->ValueException->if->token->setC
Lexer#fetchTokenInCCFor_and()::: lexer fetch token in for_and:::if->syntax->op2CClassSetOp->left->peekIs->inc
Lexer#fetchTokenInCC()::: lexer fetch token in c:::if->left->return->fetch->token->setC->if->else->if->else->if->if->syntax->backSlashEscapeInCC->return->if->left->throw->new->SyntaxException->fetch->token->setC->switch->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_charType->break->if->syntax->op2EscHXDigit->fetchTokenInCCFor_charType->break->if->syntax->op2EscHXDigit->fetchTokenInCCFor_charType->break->fetchTokenInCCFor_x->break->fetchTokenInCCFor_u->break->fetchTokenInCCFor_digit->break->unfetch->num->fetchEscapedValue->if->token->getC->token->setCode->break->else->if->fetchTokenInCCFor_and->return
Lexer#fetchTokenFor_repeat(int, int)::: lexer fetch token for_repeat:::token->setRepeatLower->token->setRepeatUpper->greedyCheck
Lexer#fetchTokenFor_openBrace()::: lexer fetch token for_open brace:::switch->fetchRangeQuantifier->greedyCheck->break->if->syntax->fixedIntervalIsGreedyOnly->possessiveCheck->else->greedyCheck->break
Lexer#fetchTokenFor_anchor(int)::: lexer fetch token for_anchor:::token->setAnchor
Lexer#fetchTokenFor_xBrace()::: lexer fetch token for_x brace:::if->left->return->last->if->peekIs->syntax->opEscXBraceHex8->inc->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->left->if->EncodingHelper->peek->isXDigit->throw->new->ValueException->if->left->peekIs->inc->token->setCode->else->else->if->syntax->opEscXHex2->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->token->setC
Lexer#fetchTokenFor_uHex()::: lexer fetch token for_u hex:::if->left->return->last->if->syntax->op2EscUHex4->num->scanUnsignedHexadecimalNumber->if->throw->new->ValueException->if->token->setCode
Lexer#fetchTokenFor_digit()::: lexer fetch token for_digit:::unfetch->last->num->scanUnsignedNumber->if->else->if->syntax->opDecimalBackref->if->syntax->strictCheckBackref->if->throw->new->ValueException->token->setBackrefRef->return->if->inc->return->fetchTokenFor_zero
Lexer#fetchTokenFor_zero()::: lexer fetch token for_zero:::if->syntax->opEscOctal3->last->num->scanUnsignedOctalNumber->if->throw->new->ValueException->if->token->setC->else->if->inc
Lexer#fetchTokenFor_metaChars()::: lexer fetch token for_meta chars:::if->else->if->fetchTokenFor_repeat->else->if->fetchTokenFor_repeat->else->if->fetchTokenFor_repeat->else->if
Lexer#fetchToken()::: lexer fetch token:::while->if->left->return->fetch->if->syntax->op2IneffectiveEscape->if->left->throw->new->SyntaxException->fetch->token->setC->switch->if->syntax->opEscAsteriskZeroInf->fetchTokenFor_repeat->break->if->syntax->opEscPlusOneInf->fetchTokenFor_repeat->break->if->syntax->opEscQMarkZeroOne->fetchTokenFor_repeat->break->if->syntax->opEscBraceInterval->fetchTokenFor_openBrace->break->if->syntax->opEscVBarAlt->break->if->syntax->opEscLParenSubexp->break->if->syntax->opEscLParenSubexp->break->if->syntax->opEscWWord->fetchTokenInCCFor_charType->break->if->syntax->opEscWWord->fetchTokenInCCFor_charType->break->if->syntax->opEscBWordBound->fetchTokenFor_anchor->break->if->syntax->opEscBWordBound->fetchTokenFor_anchor->break->if->syntax->opEscLtGtWordBeginEnd->fetchTokenFor_anchor->break->if->syntax->opEscLtGtWordBeginEnd->fetchTokenFor_anchor->break->if->syntax->opEscSWhiteSpace->fetchTokenInCCFor_charType->break->if->syntax->opEscSWhiteSpace->fetchTokenInCCFor_charType->break->if->syntax->opEscDDigit->fetchTokenInCCFor_charType->break->if->syntax->opEscDDigit->fetchTokenInCCFor_charType->break->if->syntax->op2EscHXDigit->fetchTokenInCCFor_charType->break->if->syntax->op2EscHXDigit->fetchTokenInCCFor_charType->break->if->syntax->opEscAZBufAnchor->fetchTokenFor_anchor->break->if->syntax->opEscAZBufAnchor->fetchTokenFor_anchor->break->if->syntax->opEscAZBufAnchor->fetchTokenFor_anchor->break->if->syntax->opEscCapitalGBeginAnchor->fetchTokenFor_anchor->break->if->syntax->op2EscGnuBufAnchor->fetchTokenFor_anchor->break->if->syntax->op2EscGnuBufAnchor->fetchTokenFor_anchor->break->fetchTokenFor_xBrace->break->fetchTokenFor_uHex->break->fetchTokenFor_digit->break->fetchTokenFor_zero->break->unfetch->num->fetchEscapedValue->if->token->getC->token->setCode->else->break->else->token->setC->if->syntax->opVariableMetaCharacters->fetchTokenFor_metaChars->break->switch->if->syntax->opDotAnyChar->break->if->syntax->opAsteriskZeroInf->fetchTokenFor_repeat->break->if->syntax->opPlusOneInf->fetchTokenFor_repeat->break->if->syntax->opQMarkZeroOne->fetchTokenFor_repeat->break->if->syntax->opBraceInterval->fetchTokenFor_openBrace->break->if->syntax->opVBarAlt->break->if->peekIs->syntax->op2QMarkGroupEffect->inc->if->peekIs->fetch->while->if->left->throw->new->SyntaxException->fetch->if->if->left->fetch->else->if->break->continue->unfetch->if->syntax->opLParenSubexp->break->if->syntax->opLParenSubexp->break->if->syntax->opLineAnchor->isSingleline->fetchTokenFor_anchor->break->if->syntax->opLineAnchor->isSingleline->fetchTokenFor_anchor->break->if->syntax->opBracketCC->break->break->if->Option->isExtend->while->left->fetch->if->EncodingHelper->isNewLine->break->continue->break->if->Option->isExtend->continue->break->break->break->return
Lexer#greedyCheck()::: lexer greedy check:::if->left->peekIs->syntax->opQMarkNonGreedy->fetch->token->setRepeatGreedy->token->setRepeatPossessive->else->possessiveCheck
Lexer#possessiveCheck()::: lexer possessive check:::if->left->peekIs->syntax->op2PlusPossessiveRepeat->syntax->op2PlusPossessiveInterval->fetch->token->setRepeatGreedy->token->setRepeatPossessive->else->token->setRepeatGreedy->token->setRepeatPossessive
Lexer#syntaxWarn(String, char)::: lexer syntax warn:::message->Character->toString->replace->syntaxWarn
Lexer#syntaxWarn(String)::: lexer syntax warn:::if->getBegin->getEnd->new->String->warn
Matcher#matchAt(int, int, int)::: matcher match at:::
Matcher#getRegion()::: matcher get region:::return
Matcher#getBegin()::: matcher get begin:::return
Matcher#getEnd()::: matcher get end:::return
Matcher#msaInit(int, int)::: matcher msa init:::if
Matcher#match(int, int, int)::: matcher match:::msaInit->prev->EncodingHelper->prevCharHead->if->return->matchAt->return->matchAt
Matcher#forwardSearchRange(char[], int, int, int, int, IntHolder)::: matcher forward search range:::pprev->p->if->println->if->while->search->if->if->continue->if->switch->if->prev->EncodingHelper->prevCharHead->if->EncodingHelper->isNewLine->continue->break->if->if->prev->EncodingHelper->prevCharHead->if->EncodingHelper->isNewLine->continue->else->if->EncodingHelper->isNewLine->continue->break->break->if->if->if->EncodingHelper->prevCharHead->else->EncodingHelper->prevCharHead->else->if->if->EncodingHelper->rightAdjustCharHeadWithPrev->if->EncodingHelper->prevCharHead->else->if->EncodingHelper->prevCharHead->if->println->return->return
Matcher#backwardSearchRange(char[], int, int, int, int, int)::: matcher backward search range:::r->p->while->searchBackward->if->if->switch->if->prev->EncodingHelper->prevCharHead->if->EncodingHelper->isNewLine->continue->break->if->if->prev->EncodingHelper->prevCharHead->if->return->if->EncodingHelper->isNewLine->continue->else->if->EncodingHelper->isNewLine->EncodingHelper->prevCharHead->if->return->continue->break->break->if->if->println->return->if->println->return
Matcher#matchCheck(int, int, int)::: matcher match check:::if->if->if->matchAt->if->isFindLongest->return->else->if->matchAt->return->else->if->if->matchAt->if->isFindLongest->return->else->if->matchAt->return->return
Matcher#search(int, int, int)::: matcher search:::start->range->s->prev->origStart->origRange->if->println->if->return->if->minSemiEnd->maxSemiEnd->if->if->else->else->if->if->if->return->else->if->else->return->else->if->if->endBuf->return->else->if->preEnd->EncodingHelper->stepBack->if->EncodingHelper->isNewLine->if->if->endBuf->return->else->if->endBuf->return->else->if->if->else->else->if->if->println->if->msaInit->if->matchCheck->return->match->return->mismatch->return->if->println->msaInit->if->if->EncodingHelper->prevCharHead->else->if->schRange->if->if->else->if->if->return->mismatch->if->do->if->forwardSearchRange->return->mismatch->if->while->if->matchCheck->return->match->while->if->forwardSearchRange->return->mismatch->if->do->if->matchCheck->return->match->while->return->mismatch->do->if->matchCheck->return->match->while->if->if->matchCheck->return->match->else->if->if->if->adjrange->if->else->if->do->schStart->if->if->backwardSearchRange->return->mismatch->if->while->EncodingHelper->prevCharHead->if->matchCheck->return->match->while->return->mismatch->if->return->mismatch->schStart->if->if->else->if->if->backwardSearchRange->return->mismatch->do->EncodingHelper->prevCharHead->if->matchCheck->return->match->while->return->mismatch
Matcher#endBuf(int, int, int, int)::: matcher end buf:::start->range->if->return->if->if->if->EncodingHelper->prevCharHead->if->if->return->else->if->if->if->return->return
Matcher#match(int)::: matcher match:::return
Matcher#mismatch()::: matcher mismatch:::if->if->s->return->match->return
MatcherFactory#create(Regex, char[], int, int)::: matcher factory create:::
MinMaxLen#distanceValue()::: min max len distance value:::if->return->d->return
MinMaxLen#compareDistanceValue(MinMaxLen, int, int)::: min max len compare distance value:::v1->v2->if->return->if->return->distanceValue->other->distanceValue->if->return->if->return->if->return->if->return->return
MinMaxLen#equal(MinMaxLen)::: min max len equal:::return
MinMaxLen#set(int, int)::: min max len set:::
MinMaxLen#clear()::: min max len clear:::
MinMaxLen#copy(MinMaxLen)::: min max len copy:::
MinMaxLen#add(MinMaxLen)::: min max len add:::distanceAdd->distanceAdd
MinMaxLen#addLength(int)::: min max len add length:::distanceAdd->distanceAdd
MinMaxLen#altMerge(MinMaxLen)::: min max len alt merge:::if->if
MinMaxLen#distanceAdd(int, int)::: min max len distance add:::if->return->if->return->return
MinMaxLen#distanceMultiply(int, int)::: min max len distance multiply:::if->return->if->return->return
MinMaxLen#distanceRangeToString(int, int)::: min max len distance range to string:::s->if->else->if->else->return
NodeOptInfo#setBoundNode(MinMaxLen)::: node opt info set bound node:::copy->copy->copy
NodeOptInfo#clear()::: node opt info clear:::length->clear->anchor->clear->exb->clear->exm->clear->expr->clear->map->clear
NodeOptInfo#copy(NodeOptInfo)::: node opt info copy:::length->copy->anchor->copy->exb->copy->exm->copy->expr->copy->map->copy
NodeOptInfo#concatLeftNode(NodeOptInfo)::: node opt info concat left node:::tanchor->new->OptAnchorInfo->tanchor->concat->anchor->copy->if->tanchor->concat->copy->if->if->exbReach->exmReach->if->if->if->exb->concat->clear->else->if->exm->concat->clear->exm->select->exm->select->if->if->otherLengthMax->if->if->if->exb->select->else->exm->select->else->if->expr->copy->map->select->length->add
NodeOptInfo#altMerge(NodeOptInfo, OptEnvironment)::: node opt info alt merge:::anchor->altMerge->exb->altMerge->exm->altMerge->expr->altMerge->map->altMerge->length->altMerge
NodeOptInfo#setBound(MinMaxLen)::: node opt info set bound:::copy->copy->copy
OptAnchorInfo#clear()::: opt anchor info clear:::
OptAnchorInfo#copy(OptAnchorInfo)::: opt anchor info copy:::
OptAnchorInfo#concat(OptAnchorInfo, OptAnchorInfo, int, int)::: opt anchor info concat:::if->if
OptAnchorInfo#isSet(int)::: opt anchor info is set:::if->return->return
OptAnchorInfo#add(int)::: opt anchor info add:::if->isLeftAnchor->else
OptAnchorInfo#remove(int)::: opt anchor info remove:::if->isLeftAnchor->else
OptAnchorInfo#altMerge(OptAnchorInfo)::: opt anchor info alt merge:::
OptAnchorInfo#isLeftAnchor(int)::: opt anchor info is left anchor:::return
OptAnchorInfo#anchorToString(int)::: opt anchor info anchor to string:::s->new->StringBuffer->if->s->append->if->s->append->if->s->append->if->s->append->if->s->append->if->s->append->if->s->append->if->s->append->s->append->return->s->toString
OptEnvironment#copy(OptEnvironment)::: opt environment copy:::mmd->copy
OptExactInfo#isFull()::: opt exact info is full:::return
OptExactInfo#clear()::: opt exact info clear:::mmd->clear->anchor->clear
OptExactInfo#copy(OptExactInfo)::: opt exact info copy:::mmd->copy->anchor->copy->System->arraycopy
OptExactInfo#concat(OptExactInfo)::: opt exact info concat:::if->if->return->p->end->i->for->tmp->new->OptAnchorInfo->tmp->concat->if->anchor->copy
OptExactInfo#concatStr(char[], int, int, boolean)::: opt exact info concat str:::i->p->for
OptExactInfo#altMerge(OptExactInfo, OptEnvironment)::: opt exact info alt merge:::if->clear->return->if->mmd->equal->clear->return->i->for->if->anchor->altMerge->if
OptExactInfo#select(OptExactInfo)::: opt exact info select:::v1->v2->if->return->else->if->copy->return->else->if->OptMapInfo->positionValue->OptMapInfo->positionValue->if->if->if->if->if->mmd->compareDistanceValue->copy
OptExactInfo#compare(OptMapInfo)::: opt exact info compare:::if->return->ve->vm->return->mmd->compareDistanceValue
Option#toString(int)::: option to string:::options->if->isIgnoreCase->if->isExtend->if->isMultiline->if->isSingleline->if->isFindLongest->if->isFindNotEmpty->if->isNegateSingleline->if->isDontCaptureGroup->if->isCaptureGroup->if->isNotBol->if->isNotEol->if->isPosixRegion->return
Option#isIgnoreCase(int)::: option is ignore case:::return
Option#isExtend(int)::: option is extend:::return
Option#isSingleline(int)::: option is singleline:::return
Option#isMultiline(int)::: option is multiline:::return
Option#isFindLongest(int)::: option is find longest:::return
Option#isFindNotEmpty(int)::: option is find not empty:::return
Option#isFindCondition(int)::: option is find condition:::return
Option#isNegateSingleline(int)::: option is negate singleline:::return
Option#isDontCaptureGroup(int)::: option is dont capture group:::return
Option#isCaptureGroup(int)::: option is capture group:::return
Option#isNotBol(int)::: option is not bol:::return
Option#isNotEol(int)::: option is not eol:::return
Option#isPosixRegion(int)::: option is posix region:::return
Option#isDynamic(int)::: option is dynamic:::return
OptMapInfo#clear()::: opt map info clear:::mmd->clear->anchor->clear->for->i
OptMapInfo#copy(OptMapInfo)::: opt map info copy:::mmd->copy->anchor->copy->System->arraycopy
OptMapInfo#addChar(int)::: opt map info add char:::c_->if->positionValue
OptMapInfo#addCharAmb(char[], int, int, int)::: opt map info add char amb:::addChar->items->EncodingHelper->caseFoldCodesByString->for->i
OptMapInfo#select(OptMapInfo)::: opt map info select:::if->return->if->copy->return->v1->v2->if->mmd->compareDistanceValue->copy
OptMapInfo#altMerge(OptMapInfo)::: opt map info alt merge:::if->return->if->clear->return->mmd->altMerge->val->for->i->anchor->altMerge
OptMapInfo#positionValue(int)::: opt map info position value:::if->return->return
Parser#parse()::: parser parse:::parseRegexp->return
Parser#codeExistCheck(int, boolean)::: parser code exist check:::mark->inEsc->while->left->if->else->fetch->if->restore->return->if->restore->return
Parser#parseCharClass()::: parser parse char class:::fetchTokenInCC->neg->if->token->getC->fetchTokenInCC->else->if->if->codeExistCheck->throw->new->SyntaxException->env->ccEscWarn->cc->new->CClassNode->prevCC->workCC->arg->new->CCStateArg->andStart->while->fetched->switch->if->token->getC->else->token->getC->parseCharClassValEntry2->break->token->getC->parseCharClassValEntry2->break->token->getCode->parseCharClassValEntry->break->cc->token->getPropCType->token->getPropNot->addCType->cc->nextStateClass->break->if->fetchTokenInCC->if->parseCharClassRangeEndVal->break->else->if->env->ccEscWarn->parseCharClassRangeEndVal->break->else->if->token->getC->fetchTokenInCC->if->env->ccEscWarn->parseCharClassValEntry->break->else->if->env->ccEscWarn->parseCharClassSbChar->break->else->fetchTokenInCC->if->parseCharClassRangeEndVal->break->else->if->env->ccEscWarn->parseCharClassRangeEndVal->break->if->syntax->allowDoubleRangeOpInCC->env->ccEscWarn->parseCharClassValEntry2->break->throw->new->SyntaxException->break->acc->parseCharClass->cc->or->break->if->cc->nextStateValue->if->prevCC->and->else->if->new->CClassNode->cc->clear->break->throw->new->SyntaxException->throw->new->InternalException->if->fetchTokenInCC->if->cc->nextStateValue->if->prevCC->and->if->cc->setNot->else->cc->clearNot->if->cc->isNot->syntax->notNewlineInNegativeCC->if->cc->isEmpty->NEW_LINE->if->EncodingHelper->isNewLine->set->return
Parser#parseCharClassSbChar(CClassNode, CCStateArg)::: parser parse char class sb char:::token->getC->parseCharClassValEntry2
Parser#parseCharClassRangeEndVal(CClassNode, CCStateArg)::: parser parse char class range end val:::parseCharClassValEntry
Parser#parseCharClassValEntry(CClassNode, CCStateArg)::: parser parse char class val entry:::parseCharClassValEntry2
Parser#parseCharClassValEntry2(CClassNode, CCStateArg)::: parser parse char class val entry2:::cc->nextStateValue
Parser#parseEnclose(TokenType)::: parser parse enclose:::node->if->left->throw->new->SyntaxException->option->if->peekIs->syntax->op2QMarkGroupEffect->inc->if->left->throw->new->SyntaxException->fetch->switch->fetchToken->parseSubExp->return->new->AnchorNode->break->new->AnchorNode->break->new->EncloseNode->break->break->fetch->if->new->AnchorNode->else->if->new->AnchorNode->else->throw->new->SyntaxException->break->if->syntax->op2AtMarkCaptureHistory->en->new->EncloseNode->num->env->addMemEntry->if->throw->new->ValueException->else->throw->new->SyntaxException->break->neg->while->switch->break->break->bsOnOff->break->bsOnOff->break->if->syntax->op2OptionPerl->bsOnOff->else->throw->new->SyntaxException->break->if->syntax->op2OptionPerl->bsOnOff->else->if->syntax->op2OptionRuby->bsOnOff->else->throw->new->SyntaxException->break->throw->new->SyntaxException->if->en->new->EncloseNode->return->else->if->prev->fetchToken->target->parseSubExp->en->new->EncloseNode->en->setTarget->return->if->left->throw->new->SyntaxException->fetch->throw->new->SyntaxException->else->if->isDontCaptureGroup->fetchToken->parseSubExp->return->en->new->EncloseNode->num->env->addMemEntry->fetchToken->target->parseSubExp->if->node->getType->an->an->setTarget->else->en->en->setTarget->if->env->setMemNode->return
Parser#parseExp(TokenType)::: parser parse exp:::if->return->StringNode->createEmpty->node->group->switch->return->StringNode->createEmpty->parseEnclose->if->else->if->prev->en->fetchToken->target->parseSubExp->en->setTarget->return->break->if->syntax->allowUnmatchedCloseSubexp->throw->new->SyntaxException->if->return->parseExpTkRawByte->return->parseExpTkByte->return->parseExpTkByte->return->parseExpTkRawByte->buf->new->charArr->token->getCode->new->StringNode->break->switch->token->getPropCType->if->cc->new->CClassNode->cc->token->getPropCType->addCType->if->token->getPropNot->cc->setNot->break->ccn->new->CClassNode->ccn->token->getPropCType->addCType->if->token->getPropNot->ccn->setNot->break->throw->new->InternalException->break->cc->parseCharClass->if->isIgnoreCase->arg->new->ApplyCaseFoldArg->EncodingHelper->applyAllCaseFold->if->ConsAltNode->newAltNode->break->new->AnyCharNode->break->new->AnyCharNode->qn->new->QuantifierNode->qn->setTarget->break->backRef->token->getBackrefRef->new->BackRefNode->break->token->getAnchor->new->AnchorNode->break->if->syntax->contextIndepRepeatOps->if->syntax->contextInvalidRepeatOps->throw->new->SyntaxException->StringNode->createEmpty->else->return->parseExpTkByte->break->throw->new->InternalException->fetchToken->return->parseExpRepeat
Parser#parseExpTkByte(boolean)::: parser parse exp tk byte:::node->new->StringNode->while->fetchToken->if->break->if->else->node->cat->return->parseExpRepeat
Parser#parseExpTkRawByte(boolean)::: parser parse exp tk raw byte:::node->token->getC->new->StringNode->node->setRaw->fetchToken->node->clearRaw->return->parseExpRepeat
Parser#parseExpRepeat(Node, boolean)::: parser parse exp repeat:::target->while->if->target->isInvalidQuantifier->throw->new->SyntaxException->qtfr->token->getRepeatLower->token->getRepeatUpper->new->QuantifierNode->token->getRepeatGreedy->ret->qtfr->getBegin->getEnd->setQuantifier->qn->if->token->getRepeatPossessive->en->new->EncloseNode->en->setTarget->if->else->if->ConsAltNode->newListNode->tmp->ConsAltNode->newListNode->setCdr->fetchToken->return->parseExpRepeatForCar->fetchToken->return
Parser#parseExpRepeatForCar(Node, ConsAltNode, boolean)::: parser parse exp repeat for car:::while->if->isInvalidQuantifier->throw->new->SyntaxException->qtfr->token->getRepeatLower->token->getRepeatUpper->new->QuantifierNode->token->getRepeatGreedy->ret->qtfr->getBegin->getEnd->setQuantifier->qn->if->token->getRepeatPossessive->en->new->EncloseNode->en->setTarget->if->target->setCar->else->if->fetchToken->return
Parser#parseBranch(TokenType)::: parser parse branch:::node->parseExp->if->return->top->ConsAltNode->newListNode->t->while->parseExp->if->node->getType->t->setCdr->while->else->t->ConsAltNode->newListNode->setCdr->return
Parser#parseSubExp(TokenType)::: parser parse sub exp:::node->parseBranch->if->return->else->if->top->ConsAltNode->newAltNode->t->while->fetchToken->parseBranch->t->ConsAltNode->newAltNode->setCdr->if->parseSubExpError->return->else->parseSubExpError->return
Parser#parseSubExpError(TokenType)::: parser parse sub exp error:::if->throw->new->SyntaxException->throw->new->InternalException
Parser#parseRegexp()::: parser parse regexp:::fetchToken->return->parseSubExp
Regex#matcher(char[])::: regex matcher:::return->matcher
Regex#matcher(char[], int, int)::: regex matcher:::return->factory->create
Regex#getWarnings()::: regex get warnings:::return
Regex#numberOfCaptures()::: regex number of captures:::return
Regex#setupBMSkipMap()::: regex setup skip map:::chars->p->end->len->if->if->new->byteArr->for->i->for->i->else->if->new->intArr->for->i
Regex#setExactInfo(OptExactInfo)::: regex set exact info:::if->return->if->new->SearchAlgorithm.SLOW_IC->else->if->setupBMSkipMap->else->if
Regex#setOptimizeMapInfo(OptMapInfo)::: regex set optimize map info:::if
Regex#setSubAnchor(OptAnchorInfo)::: regex set sub anchor:::
Regex#clearOptimizeInfo()::: regex clear optimize info:::
Regex#optimizeInfoToString()::: regex optimize info to string:::s->new->StringBuilder->s->append->searchAlgorithm->getName->append->append->s->append->OptAnchorInfo->anchorToString->append->if->s->MinMaxLen->distanceRangeToString->append->s->append->if->s->append->OptAnchorInfo->anchorToString->append->append->s->append->append->append->append->append->s->append->append->append->if->s->append->append->append->append->append->else->if->n->for->i->s->append->append->append->if->c->s->append->for->i->s->append->return->s->toString
Regex#getOptions()::: regex get options:::return
Regex#dumpTree()::: regex dump tree:::return->toString
Regex#dumpByteCode()::: regex dump byte code:::return->new->ByteCodePrinter->byteCodeListToString
Region#toString()::: region to string:::sb->new->StringBuilder->sb->append->for->i->return->sb->toString
Region#clear()::: region clear:::for->i
ScanEnvironment#clear()::: scan environment clear:::bsClear->bsClear->bsClear->bsClear
ScanEnvironment#addMemEntry()::: scan environment add mem entry:::if->throw->new->InternalException->if->new->NodeArr->else->if->tmp->new->NodeArr->System->arraycopy->return
ScanEnvironment#setMemNode(int, Node)::: scan environment set mem node:::if->else->throw->new->InternalException
ScanEnvironment#convertBackslashValue(int)::: scan environment convert backslash value:::if->syntax->opEscControlChars->switch->return->return->return->return->return->return->return->if->syntax->op2EscVVtab->return->break->break->return
ScanEnvironment#ccEscWarn(String)::: scan environment cc esc warn:::if->if->syntax->warnCCOpNotEscaped->syntax->backSlashEscapeInCC->warn
ScannerSupport#getBegin()::: scanner support get begin:::return
ScannerSupport#getEnd()::: scanner support get end:::return
ScannerSupport#scanUnsignedNumber()::: scanner support scan unsigned number:::last->num->while->left->fetch->if->Character->isDigit->onum->EncodingHelper->digitVal->if->return->else->unfetch->break->return
ScannerSupport#scanUnsignedHexadecimalNumber(int)::: scanner support scan unsigned hexadecimal number:::last->num->ml->while->left->fetch->if->EncodingHelper->isXDigit->onum->val->EncodingHelper->xdigitVal->if->return->else->unfetch->break->return
ScannerSupport#scanUnsignedOctalNumber(int)::: scanner support scan unsigned octal number:::last->num->ml->while->left->fetch->if->Character->isDigit->onum->val->EncodingHelper->odigitVal->if->return->else->unfetch->break->return
ScannerSupport#reset()::: scanner support reset:::
ScannerSupport#mark()::: scanner support mark:::
ScannerSupport#restore()::: scanner support restore:::
ScannerSupport#inc()::: scanner support inc:::
ScannerSupport#fetch()::: scanner support fetch:::
ScannerSupport#fetchTo()::: scanner support fetch to:::return
ScannerSupport#unfetch()::: scanner support unfetch:::
ScannerSupport#peek()::: scanner support peek:::return
ScannerSupport#peekIs(int)::: scanner support peek is:::return->peek
ScannerSupport#left()::: scanner support left:::return
SearchAlgorithm#getName()::: search algorithm get name:::
SearchAlgorithm#search(Regex, char[], int, int, int)::: search algorithm search:::
SearchAlgorithm#searchBackward(Regex, char[], int, int, int, int, int, int)::: search algorithm search backward:::
SearchAlgorithm.SLOW_IC#getName()::: w_ c get name:::return
SearchAlgorithm.SLOW_IC#search(Regex, char[], int, int, int)::: w_ c search:::target->targetP->targetEnd->end->if->s->while->if->lowerCaseMatch->return->return
SearchAlgorithm.SLOW_IC#searchBackward(Regex, char[], int, int, int, int, int, int)::: w_ c search backward:::target->targetP->targetEnd->s->if->while->if->lowerCaseMatch->return->EncodingHelper->prevCharHead->return
SearchAlgorithm.SLOW_IC#lowerCaseMatch(char[], int, int, char[], int, int)::: w_ c lower case match:::for->tP->p->return
StackEntry#setStatePCode(int)::: stack entry set state code:::
StackEntry#getStatePCode()::: stack entry get state code:::return
StackEntry#setStatePStr(int)::: stack entry set state str:::
StackEntry#getStatePStr()::: stack entry get state str:::return
StackEntry#setStatePStrPrev(int)::: stack entry set state str prev:::
StackEntry#getStatePStrPrev()::: stack entry get state str prev:::return
StackEntry#setStateCheck(int)::: stack entry set state check:::
StackEntry#getStateCheck()::: stack entry get state check:::return
StackEntry#setRepeatCount(int)::: stack entry set repeat count:::
StackEntry#getRepeatCount()::: stack entry get repeat count:::return
StackEntry#decreaseRepeatCount()::: stack entry decrease repeat count:::
StackEntry#increaseRepeatCount()::: stack entry increase repeat count:::
StackEntry#setRepeatPCode(int)::: stack entry set repeat code:::
StackEntry#getRepeatPCode()::: stack entry get repeat code:::return
StackEntry#setRepeatNum(int)::: stack entry set repeat num:::
StackEntry#getRepeatNum()::: stack entry get repeat num:::return
StackEntry#setSi(int)::: stack entry set si:::
StackEntry#getSi()::: stack entry get si:::return
StackEntry#setMemNum(int)::: stack entry set mem num:::
StackEntry#getMemNum()::: stack entry get mem num:::return
StackEntry#setMemPstr(int)::: stack entry set mem pstr:::
StackEntry#getMemPStr()::: stack entry get mem str:::return
StackEntry#setMemStart(int)::: stack entry set mem start:::
StackEntry#getMemStart()::: stack entry get mem start:::return
StackEntry#setMemEnd(int)::: stack entry set mem end:::
StackEntry#getMemEnd()::: stack entry get mem end:::return
StackEntry#setNullCheckNum(int)::: stack entry set null check num:::
StackEntry#getNullCheckNum()::: stack entry get null check num:::return
StackEntry#setNullCheckPStr(int)::: stack entry set null check str:::
StackEntry#getNullCheckPStr()::: stack entry get null check str:::return
StackEntry#setCallFrameRetAddr(int)::: stack entry set call frame ret addr:::
StackEntry#getCallFrameRetAddr()::: stack entry get call frame ret addr:::return
StackEntry#setCallFrameNum(int)::: stack entry set call frame num:::
StackEntry#getCallFrameNum()::: stack entry get call frame num:::return
StackEntry#setCallFramePStr(int)::: stack entry set call frame str:::
StackEntry#getCallFramePStr()::: stack entry get call frame str:::return
StackMachine#allocateStack()::: stack machine allocate stack:::stack->new->StackEntryArr->new->StackEntry->return
StackMachine#doubleStack()::: stack machine double stack:::newStack->new->StackEntryArr->System->arraycopy
StackMachine#fetchStack()::: stack machine fetch stack:::ref->stacks->get->stack->ref->get->if->allocateStack->new->WeakReference<StackEntry[]>->stacks->set->return
StackMachine#init()::: stack machine init:::if->pushEnsured->if->for->i
StackMachine#ensure1()::: stack machine ensure1:::if->doubleStack->e->if->new->StackEntry->return
StackMachine#pushType(int)::: stack machine push type:::ensure1
StackMachine#push(int, int, int, int)::: stack machine push:::e->ensure1->e->setStatePCode->e->setStatePStr->e->setStatePStrPrev
StackMachine#pushEnsured(int, int)::: stack machine push ensured:::e->e->setStatePCode
StackMachine#pushAlt(int, int, int)::: stack machine push alt:::push
StackMachine#pushPos(int, int)::: stack machine push pos:::push
StackMachine#pushPosNot(int, int, int)::: stack machine push pos not:::push
StackMachine#pushStopBT()::: stack machine push stop t:::pushType
StackMachine#pushLookBehindNot(int, int, int)::: stack machine push look behind not:::push
StackMachine#pushRepeat(int, int)::: stack machine push repeat:::e->ensure1->e->setRepeatNum->e->setRepeatPCode->e->setRepeatCount
StackMachine#pushRepeatInc(int)::: stack machine push repeat inc:::e->ensure1->e->setSi
StackMachine#pushMemStart(int, int)::: stack machine push mem start:::e->ensure1->e->setMemNum->e->setMemPstr->e->setMemStart->e->setMemEnd
StackMachine#pushMemEnd(int, int)::: stack machine push mem end:::e->ensure1->e->setMemNum->e->setMemPstr->e->setMemStart->e->setMemEnd
StackMachine#pushMemEndMark(int)::: stack machine push mem end mark:::e->ensure1->e->setMemNum
StackMachine#getMemStart(int)::: stack machine get mem start:::level->stkp->while->e->if->e->getMemNum->else->if->e->getMemNum->if->break->return
StackMachine#pushNullCheckStart(int, int)::: stack machine push null check start:::e->ensure1->e->setNullCheckNum->e->setNullCheckPStr
StackMachine#pushNullCheckEnd(int)::: stack machine push null check end:::e->ensure1->e->setNullCheckNum
StackMachine#popOne()::: stack machine pop one:::
StackMachine#pop()::: stack machine pop:::switch->return->popFree->return->popMemStart->return->popDefault
StackMachine#popFree()::: stack machine pop free:::while->e->if->return
StackMachine#popMemStart()::: stack machine pop mem start:::while->e->if->return->else->if->e->getMemStart->e->getMemNum->e->getMemEnd->e->getMemNum
StackMachine#popDefault()::: stack machine pop default:::while->e->if->return->else->if->e->getMemStart->e->getMemNum->e->getMemEnd->e->getMemNum->else->if->e->getSi->decreaseRepeatCount->else->if->e->getMemStart->e->getMemNum->e->getMemEnd->e->getMemNum
StackMachine#popTilPosNot()::: stack machine pop til pos not:::while->e->if->break->else->if->e->getMemStart->e->getMemNum->e->getMemStart->e->getMemNum->else->if->e->getSi->decreaseRepeatCount->else->if->e->getMemStart->e->getMemNum->e->getMemStart->e->getMemNum
StackMachine#popTilLookBehindNot()::: stack machine pop til look behind not:::while->e->if->break->else->if->e->getMemStart->e->getMemNum->e->getMemEnd->e->getMemNum->else->if->e->getSi->decreaseRepeatCount->else->if->e->getMemStart->e->getMemNum->e->getMemEnd->e->getMemNum
StackMachine#posEnd()::: stack machine pos end:::k->while->e->if->else->if->break->return
StackMachine#stopBtEnd()::: stack machine stop bt end:::k->while->e->if->else->if->break
StackMachine#nullCheck(int, int)::: stack machine null check:::k->while->e->if->if->e->getNullCheckNum->return->e->getNullCheckPStr
StackMachine#nullCheckMemSt(int, int)::: stack machine null check mem st:::return->nullCheck
StackMachine#getRepeat(int)::: stack machine get repeat:::level->k->while->e->if->if->if->e->getRepeatNum->return->else->if->else->if
StackMachine#sreturn()::: stack machine sreturn:::level->k->while->e->if->if->return->e->getCallFrameRetAddr->else->if
Syntax#isOp(int)::: syntax is op:::return
Syntax#opVariableMetaCharacters()::: syntax op variable meta characters:::return->isOp
Syntax#opDotAnyChar()::: syntax op dot any char:::return->isOp
Syntax#opAsteriskZeroInf()::: syntax op asterisk zero inf:::return->isOp
Syntax#opEscAsteriskZeroInf()::: syntax op esc asterisk zero inf:::return->isOp
Syntax#opPlusOneInf()::: syntax op plus one inf:::return->isOp
Syntax#opEscPlusOneInf()::: syntax op esc plus one inf:::return->isOp
Syntax#opQMarkZeroOne()::: syntax op mark zero one:::return->isOp
Syntax#opEscQMarkZeroOne()::: syntax op esc mark zero one:::return->isOp
Syntax#opBraceInterval()::: syntax op brace interval:::return->isOp
Syntax#opEscBraceInterval()::: syntax op esc brace interval:::return->isOp
Syntax#opVBarAlt()::: syntax op bar alt:::return->isOp
Syntax#opEscVBarAlt()::: syntax op esc bar alt:::return->isOp
Syntax#opLParenSubexp()::: syntax op paren subexp:::return->isOp
Syntax#opEscLParenSubexp()::: syntax op esc paren subexp:::return->isOp
Syntax#opEscAZBufAnchor()::: syntax op esc buf anchor:::return->isOp
Syntax#opEscCapitalGBeginAnchor()::: syntax op esc capital begin anchor:::return->isOp
Syntax#opDecimalBackref()::: syntax op decimal backref:::return->isOp
Syntax#opBracketCC()::: syntax op bracket c:::return->isOp
Syntax#opEscWWord()::: syntax op esc word:::return->isOp
Syntax#opEscLtGtWordBeginEnd()::: syntax op esc lt gt word begin end:::return->isOp
Syntax#opEscBWordBound()::: syntax op esc word bound:::return->isOp
Syntax#opEscSWhiteSpace()::: syntax op esc white space:::return->isOp
Syntax#opEscDDigit()::: syntax op esc digit:::return->isOp
Syntax#opLineAnchor()::: syntax op line anchor:::return->isOp
Syntax#opPosixBracket()::: syntax op posix bracket:::return->isOp
Syntax#opQMarkNonGreedy()::: syntax op mark non greedy:::return->isOp
Syntax#opEscControlChars()::: syntax op esc control chars:::return->isOp
Syntax#opEscCControl()::: syntax op esc control:::return->isOp
Syntax#opEscOctal3()::: syntax op esc octal3:::return->isOp
Syntax#opEscXHex2()::: syntax op esc hex2:::return->isOp
Syntax#opEscXBraceHex8()::: syntax op esc brace hex8:::return->isOp
Syntax#isOp2(int)::: syntax is op2:::return
Syntax#op2EscCapitalQQuote()::: syntax op2 esc capital quote:::return->isOp2
Syntax#op2QMarkGroupEffect()::: syntax op2 mark group effect:::return->isOp2
Syntax#op2OptionPerl()::: syntax op2 option perl:::return->isOp2
Syntax#op2OptionRuby()::: syntax op2 option ruby:::return->isOp2
Syntax#op2PlusPossessiveRepeat()::: syntax op2 plus possessive repeat:::return->isOp2
Syntax#op2PlusPossessiveInterval()::: syntax op2 plus possessive interval:::return->isOp2
Syntax#op2CClassSetOp()::: syntax op2 class set op:::return->isOp2
Syntax#op2QMarkLtNamedGroup()::: syntax op2 mark lt named group:::return->isOp2
Syntax#op2EscKNamedBackref()::: syntax op2 esc named backref:::return->isOp2
Syntax#op2EscGSubexpCall()::: syntax op2 esc subexp call:::return->isOp2
Syntax#op2AtMarkCaptureHistory()::: syntax op2 at mark capture history:::return->isOp2
Syntax#op2EscCapitalCBarControl()::: syntax op2 esc capital bar control:::return->isOp2
Syntax#op2EscCapitalMBarMeta()::: syntax op2 esc capital bar meta:::return->isOp2
Syntax#op2EscVVtab()::: syntax op2 esc vtab:::return->isOp2
Syntax#op2EscUHex4()::: syntax op2 esc hex4:::return->isOp2
Syntax#op2EscGnuBufAnchor()::: syntax op2 esc gnu buf anchor:::return->isOp2
Syntax#op2EscPBraceCharProperty()::: syntax op2 esc brace char property:::return->isOp2
Syntax#op2EscPBraceCircumflexNot()::: syntax op2 esc brace circumflex not:::return->isOp2
Syntax#op2EscHXDigit()::: syntax op2 esc digit:::return->isOp2
Syntax#op2IneffectiveEscape()::: syntax op2 ineffective escape:::return->isOp2
Syntax#isBehavior(int)::: syntax is behavior:::return
Syntax#contextIndepRepeatOps()::: syntax context indep repeat ops:::return->isBehavior
Syntax#contextInvalidRepeatOps()::: syntax context invalid repeat ops:::return->isBehavior
Syntax#allowUnmatchedCloseSubexp()::: syntax allow unmatched close subexp:::return->isBehavior
Syntax#allowInvalidInterval()::: syntax allow invalid interval:::return->isBehavior
Syntax#allowIntervalLowAbbrev()::: syntax allow interval low abbrev:::return->isBehavior
Syntax#strictCheckBackref()::: syntax strict check backref:::return->isBehavior
Syntax#differentLengthAltLookBehind()::: syntax different length alt look behind:::return->isBehavior
Syntax#captureOnlyNamedGroup()::: syntax capture only named group:::return->isBehavior
Syntax#allowMultiplexDefinitionName()::: syntax allow multiplex definition name:::return->isBehavior
Syntax#fixedIntervalIsGreedyOnly()::: syntax fixed interval is greedy only:::return->isBehavior
Syntax#notNewlineInNegativeCC()::: syntax not newline in negative c:::return->isBehavior
Syntax#backSlashEscapeInCC()::: syntax back slash escape in c:::return->isBehavior
Syntax#allowEmptyRangeInCC()::: syntax allow empty range in c:::return->isBehavior
Syntax#allowDoubleRangeOpInCC()::: syntax allow double range op in c:::return->isBehavior
Syntax#warnCCOpNotEscaped()::: syntax warn op not escaped:::return->isBehavior
Syntax#warnReduntantNestedRepeat()::: syntax warn reduntant nested repeat:::return->isBehavior
Token#getC()::: token get c:::return
Token#setC(int)::: token set c:::
Token#getCode()::: token get code:::return
Token#setCode(int)::: token set code:::
Token#getAnchor()::: token get anchor:::return
Token#setAnchor(int)::: token set anchor:::
Token#getRepeatLower()::: token get repeat lower:::return
Token#setRepeatLower(int)::: token set repeat lower:::
Token#getRepeatUpper()::: token get repeat upper:::return
Token#setRepeatUpper(int)::: token set repeat upper:::
Token#getRepeatGreedy()::: token get repeat greedy:::return
Token#setRepeatGreedy(boolean)::: token set repeat greedy:::
Token#getRepeatPossessive()::: token get repeat possessive:::return
Token#setRepeatPossessive(boolean)::: token set repeat possessive:::
Token#getBackrefRef()::: token get backref ref:::return
Token#setBackrefRef(int)::: token set backref ref:::
Token#getPropCType()::: token get prop type:::return
Token#setPropCType(int)::: token set prop type:::
Token#getPropNot()::: token get prop not:::return
Token#setPropNot(boolean)::: token set prop not:::
WarnCallback#warn(String)::: warn callback warn:::
