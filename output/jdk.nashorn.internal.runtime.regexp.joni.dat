jdk.nashorn.internal.runtime.regexp.joni.Analyser#compile()->void::: analyser compile
jdk.nashorn.internal.runtime.regexp.joni.Analyser#getCharLengthTree(Node)->int::: analyser get char length tree
jdk.nashorn.internal.runtime.regexp.joni.Analyser#setupTree(Node, int)->Node::: analyser setup tree
jdk.nashorn.internal.runtime.regexp.joni.Analyser#setOptimizedInfoFromTree(Node)->void::: analyser set optimized info from tree
jdk.nashorn.internal.runtime.regexp.joni.ApplyCaseFold#apply(int, int, Object)->void::: apply case fold apply
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#prepare()->void::: array compiler prepare
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#finish()->void::: array compiler finish
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileAltNode(ConsAltNode)->void::: array compiler compile alt node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#addCompileString(char[], int, int, boolean)->void::: array compiler add compile string
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileCClassNode(CClassNode)->void::: array compiler compile class node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileAnyCharNode()->void::: array compiler compile any char node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileBackrefNode(BackRefNode)->void::: array compiler compile backref node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileNonCECQuantifierNode(QuantifierNode)->void::: array compiler compile non quantifier node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileOptionNode(EncloseNode)->void::: array compiler compile option node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileEncloseNode(EncloseNode)->void::: array compiler compile enclose node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#compileAnchorNode(AnchorNode)->void::: array compiler compile anchor node
jdk.nashorn.internal.runtime.regexp.joni.ArrayCompiler#setInt(int, int)->void::: array compiler set int
jdk.nashorn.internal.runtime.regexp.joni.BitSet#toString()->String::: bit set to string
jdk.nashorn.internal.runtime.regexp.joni.BitSet#at(int)->boolean::: bit set at
jdk.nashorn.internal.runtime.regexp.joni.BitSet#set(int)->void::: bit set set
jdk.nashorn.internal.runtime.regexp.joni.BitSet#clear(int)->void::: bit set clear
jdk.nashorn.internal.runtime.regexp.joni.BitSet#clear()->void::: bit set clear
jdk.nashorn.internal.runtime.regexp.joni.BitSet#isEmpty()->boolean::: bit set is empty
jdk.nashorn.internal.runtime.regexp.joni.BitSet#setRange(int, int)->void::: bit set set range
jdk.nashorn.internal.runtime.regexp.joni.BitSet#invert()->void::: bit set invert
jdk.nashorn.internal.runtime.regexp.joni.BitSet#invertTo(BitSet)->void::: bit set invert to
jdk.nashorn.internal.runtime.regexp.joni.BitSet#and(BitSet)->void::: bit set and
jdk.nashorn.internal.runtime.regexp.joni.BitSet#or(BitSet)->void::: bit set or
jdk.nashorn.internal.runtime.regexp.joni.BitSet#copy(BitSet)->void::: bit set copy
jdk.nashorn.internal.runtime.regexp.joni.BitSet#numOn()->int::: bit set num on
jdk.nashorn.internal.runtime.regexp.joni.BitSet#bit(int)->int::: bit set bit
jdk.nashorn.internal.runtime.regexp.joni.BitStatus#bsClear()->int::: bit status bs clear
jdk.nashorn.internal.runtime.regexp.joni.BitStatus#bsAll()->int::: bit status bs all
jdk.nashorn.internal.runtime.regexp.joni.BitStatus#bsAt(int, int)->boolean::: bit status bs at
jdk.nashorn.internal.runtime.regexp.joni.BitStatus#bsOnAt(int, int)->int::: bit status bs on at
jdk.nashorn.internal.runtime.regexp.joni.BitStatus#bsOnOff(int, int, boolean)->int::: bit status bs on off
jdk.nashorn.internal.runtime.regexp.joni.ByteCodeMachine#matchAt(int, int, int)->int::: byte code machine match at
jdk.nashorn.internal.runtime.regexp.joni.ByteCodePrinter#byteCodeListToString()->String::: byte code printer byte code list to string
jdk.nashorn.internal.runtime.regexp.joni.ByteCodePrinter#compiledByteCodeToString(StringBuilder, int)->int::: byte code printer compiled byte code to string
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#isInCodeRange(int)->boolean::: code range buffer is in code range
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#toString()->String::: code range buffer to string
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#expand(int)->void::: code range buffer expand
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#ensureSize(int)->void::: code range buffer ensure size
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#moveLeft(int, int, int)->void::: code range buffer move left
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#writeCodePoint(int, int)->void::: code range buffer write code point
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#clone()->CodeRangeBuffer::: code range buffer clone
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#addCodeRangeToBuff(CodeRangeBuffer, int, int)->CodeRangeBuffer::: code range buffer add code range to buff
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#addCodeRange(CodeRangeBuffer, ScanEnvironment, int, int)->CodeRangeBuffer::: code range buffer add code range
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#setAllMultiByteRange(CodeRangeBuffer)->CodeRangeBuffer::: code range buffer set all multi byte range
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#addAllMultiByteRange(CodeRangeBuffer)->CodeRangeBuffer::: code range buffer add all multi byte range
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#notCodeRangeBuff(CodeRangeBuffer)->CodeRangeBuffer::: code range buffer not code range buff
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#orCodeRangeBuff(CodeRangeBuffer, boolean, CodeRangeBuffer, boolean)->CodeRangeBuffer::: code range buffer or code range buff
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#andCodeRange1(CodeRangeBuffer, int, int, int[], int)->CodeRangeBuffer::: code range buffer and code range1
jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer#andCodeRangeBuff(CodeRangeBuffer, boolean, CodeRangeBuffer, boolean)->CodeRangeBuffer::: code range buffer and code range buff
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compile()->void::: compiler compile
jdk.nashorn.internal.runtime.regexp.joni.Compiler#prepare()->void::: compiler prepare
jdk.nashorn.internal.runtime.regexp.joni.Compiler#finish()->void::: compiler finish
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileAltNode(ConsAltNode)->void::: compiler compile alt node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#addCompileString(char[], int, int, boolean)->void::: compiler add compile string
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileCClassNode(CClassNode)->void::: compiler compile class node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileAnyCharNode()->void::: compiler compile any char node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileBackrefNode(BackRefNode)->void::: compiler compile backref node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileNonCECQuantifierNode(QuantifierNode)->void::: compiler compile non quantifier node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileOptionNode(EncloseNode)->void::: compiler compile option node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileEncloseNode(EncloseNode)->void::: compiler compile enclose node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileAnchorNode(AnchorNode)->void::: compiler compile anchor node
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileTree(Node)->void::: compiler compile tree
jdk.nashorn.internal.runtime.regexp.joni.Compiler#compileTreeNTimes(Node, int)->void::: compiler compile tree times
jdk.nashorn.internal.runtime.regexp.joni.Compiler#newSyntaxException(String)->void::: compiler new syntax exception
jdk.nashorn.internal.runtime.regexp.joni.Compiler#newInternalException(String)->void::: compiler new internal exception
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#digitVal(int)->int::: encoding helper digit val
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#odigitVal(int)->int::: encoding helper odigit val
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isXDigit(int)->boolean::: encoding helper is digit
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#xdigitVal(int)->int::: encoding helper xdigit val
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isDigit(int)->boolean::: encoding helper is digit
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isWord(int)->boolean::: encoding helper is word
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isNewLine(int)->boolean::: encoding helper is new line
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isNewLine(char[], int, int)->boolean::: encoding helper is new line
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#prevCharHead(int, int)->int::: encoding helper prev char head
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#rightAdjustCharHeadWithPrev(int, IntHolder)->int::: encoding helper right adjust char head with prev
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#stepBack(int, int, int)->int::: encoding helper step back
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#mbcodeStartPosition()->int::: encoding helper mbcode start position
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#caseFoldCodesByString(int, char)->char[]::: encoding helper case fold codes by string
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#applyAllCaseFold(int, ApplyCaseFold, Object)->void::: encoding helper apply all case fold
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#toLowerCase(char)->char::: encoding helper to lower case
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#toLowerCase(int)->int::: encoding helper to lower case
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#toUpperCase(char)->char::: encoding helper to upper case
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#toUpperCase(int)->int::: encoding helper to upper case
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#ctypeCodeRange(int, IntHolder)->int[]::: encoding helper ctype code range
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isInCodeRange(int[], int, int)->boolean::: encoding helper is in code range
jdk.nashorn.internal.runtime.regexp.joni.EncodingHelper#isCodeCType(int, int)->boolean::: encoding helper is code type
jdk.nashorn.internal.runtime.regexp.joni.Lexer#fetchTokenInCC()->TokenType::: lexer fetch token in c
jdk.nashorn.internal.runtime.regexp.joni.Lexer#fetchToken()->TokenType::: lexer fetch token
jdk.nashorn.internal.runtime.regexp.joni.Lexer#syntaxWarn(String, char)->void::: lexer syntax warn
jdk.nashorn.internal.runtime.regexp.joni.Lexer#syntaxWarn(String)->void::: lexer syntax warn
jdk.nashorn.internal.runtime.regexp.joni.Matcher#matchAt(int, int, int)->int::: matcher match at
jdk.nashorn.internal.runtime.regexp.joni.Matcher#getRegion()->Region::: matcher get region
jdk.nashorn.internal.runtime.regexp.joni.Matcher#getBegin()->int::: matcher get begin
jdk.nashorn.internal.runtime.regexp.joni.Matcher#getEnd()->int::: matcher get end
jdk.nashorn.internal.runtime.regexp.joni.Matcher#msaInit(int, int)->void::: matcher msa init
jdk.nashorn.internal.runtime.regexp.joni.Matcher#match(int, int, int)->int::: matcher match
jdk.nashorn.internal.runtime.regexp.joni.Matcher#search(int, int, int)->int::: matcher search
jdk.nashorn.internal.runtime.regexp.joni.MatcherFactory#create(Regex, char[], int, int)->Matcher::: matcher factory create
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#distanceValue()->int::: min max len distance value
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#compareDistanceValue(MinMaxLen, int, int)->int::: min max len compare distance value
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#equal(MinMaxLen)->boolean::: min max len equal
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#set(int, int)->void::: min max len set
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#clear()->void::: min max len clear
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#copy(MinMaxLen)->void::: min max len copy
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#add(MinMaxLen)->void::: min max len add
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#addLength(int)->void::: min max len add length
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#altMerge(MinMaxLen)->void::: min max len alt merge
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#distanceAdd(int, int)->int::: min max len distance add
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#distanceMultiply(int, int)->int::: min max len distance multiply
jdk.nashorn.internal.runtime.regexp.joni.MinMaxLen#distanceRangeToString(int, int)->String::: min max len distance range to string
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#setBoundNode(MinMaxLen)->void::: node opt info set bound node
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#clear()->void::: node opt info clear
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#copy(NodeOptInfo)->void::: node opt info copy
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#concatLeftNode(NodeOptInfo)->void::: node opt info concat left node
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#altMerge(NodeOptInfo, OptEnvironment)->void::: node opt info alt merge
jdk.nashorn.internal.runtime.regexp.joni.NodeOptInfo#setBound(MinMaxLen)->void::: node opt info set bound
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#clear()->void::: opt anchor info clear
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#copy(OptAnchorInfo)->void::: opt anchor info copy
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#concat(OptAnchorInfo, OptAnchorInfo, int, int)->void::: opt anchor info concat
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#isSet(int)->boolean::: opt anchor info is set
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#add(int)->void::: opt anchor info add
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#remove(int)->void::: opt anchor info remove
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#altMerge(OptAnchorInfo)->void::: opt anchor info alt merge
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#isLeftAnchor(int)->boolean::: opt anchor info is left anchor
jdk.nashorn.internal.runtime.regexp.joni.OptAnchorInfo#anchorToString(int)->String::: opt anchor info anchor to string
jdk.nashorn.internal.runtime.regexp.joni.OptEnvironment#copy(OptEnvironment)->void::: opt environment copy
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#isFull()->boolean::: opt exact info is full
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#clear()->void::: opt exact info clear
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#copy(OptExactInfo)->void::: opt exact info copy
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#concat(OptExactInfo)->void::: opt exact info concat
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#concatStr(char[], int, int, boolean)->void::: opt exact info concat str
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#altMerge(OptExactInfo, OptEnvironment)->void::: opt exact info alt merge
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#select(OptExactInfo)->void::: opt exact info select
jdk.nashorn.internal.runtime.regexp.joni.OptExactInfo#compare(OptMapInfo)->int::: opt exact info compare
jdk.nashorn.internal.runtime.regexp.joni.Option#toString(int)->String::: option to string
jdk.nashorn.internal.runtime.regexp.joni.Option#isIgnoreCase(int)->boolean::: option is ignore case
jdk.nashorn.internal.runtime.regexp.joni.Option#isExtend(int)->boolean::: option is extend
jdk.nashorn.internal.runtime.regexp.joni.Option#isSingleline(int)->boolean::: option is singleline
jdk.nashorn.internal.runtime.regexp.joni.Option#isMultiline(int)->boolean::: option is multiline
jdk.nashorn.internal.runtime.regexp.joni.Option#isFindLongest(int)->boolean::: option is find longest
jdk.nashorn.internal.runtime.regexp.joni.Option#isFindNotEmpty(int)->boolean::: option is find not empty
jdk.nashorn.internal.runtime.regexp.joni.Option#isFindCondition(int)->boolean::: option is find condition
jdk.nashorn.internal.runtime.regexp.joni.Option#isNegateSingleline(int)->boolean::: option is negate singleline
jdk.nashorn.internal.runtime.regexp.joni.Option#isDontCaptureGroup(int)->boolean::: option is dont capture group
jdk.nashorn.internal.runtime.regexp.joni.Option#isCaptureGroup(int)->boolean::: option is capture group
jdk.nashorn.internal.runtime.regexp.joni.Option#isNotBol(int)->boolean::: option is not bol
jdk.nashorn.internal.runtime.regexp.joni.Option#isNotEol(int)->boolean::: option is not eol
jdk.nashorn.internal.runtime.regexp.joni.Option#isPosixRegion(int)->boolean::: option is posix region
jdk.nashorn.internal.runtime.regexp.joni.Option#isDynamic(int)->boolean::: option is dynamic
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#clear()->void::: opt map info clear
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#copy(OptMapInfo)->void::: opt map info copy
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#addChar(int)->void::: opt map info add char
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#addCharAmb(char[], int, int, int)->void::: opt map info add char amb
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#select(OptMapInfo)->void::: opt map info select
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#altMerge(OptMapInfo)->void::: opt map info alt merge
jdk.nashorn.internal.runtime.regexp.joni.OptMapInfo#positionValue(int)->int::: opt map info position value
jdk.nashorn.internal.runtime.regexp.joni.Parser#parse()->Node::: parser parse
jdk.nashorn.internal.runtime.regexp.joni.Regex#matcher(char[])->Matcher::: regex matcher
jdk.nashorn.internal.runtime.regexp.joni.Regex#matcher(char[], int, int)->Matcher::: regex matcher
jdk.nashorn.internal.runtime.regexp.joni.Regex#getWarnings()->WarnCallback::: regex get warnings
jdk.nashorn.internal.runtime.regexp.joni.Regex#numberOfCaptures()->int::: regex number of captures
jdk.nashorn.internal.runtime.regexp.joni.Regex#setupBMSkipMap()->void::: regex setup skip map
jdk.nashorn.internal.runtime.regexp.joni.Regex#setExactInfo(OptExactInfo)->void::: regex set exact info
jdk.nashorn.internal.runtime.regexp.joni.Regex#setOptimizeMapInfo(OptMapInfo)->void::: regex set optimize map info
jdk.nashorn.internal.runtime.regexp.joni.Regex#setSubAnchor(OptAnchorInfo)->void::: regex set sub anchor
jdk.nashorn.internal.runtime.regexp.joni.Regex#clearOptimizeInfo()->void::: regex clear optimize info
jdk.nashorn.internal.runtime.regexp.joni.Regex#optimizeInfoToString()->String::: regex optimize info to string
jdk.nashorn.internal.runtime.regexp.joni.Regex#getOptions()->int::: regex get options
jdk.nashorn.internal.runtime.regexp.joni.Regex#dumpTree()->String::: regex dump tree
jdk.nashorn.internal.runtime.regexp.joni.Regex#dumpByteCode()->String::: regex dump byte code
jdk.nashorn.internal.runtime.regexp.joni.Region#toString()->String::: region to string
jdk.nashorn.internal.runtime.regexp.joni.Region#clear()->void::: region clear
jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment#clear()->void::: scan environment clear
jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment#addMemEntry()->int::: scan environment add mem entry
jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment#setMemNode(int, Node)->void::: scan environment set mem node
jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment#convertBackslashValue(int)->int::: scan environment convert backslash value
jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment#ccEscWarn(String)->void::: scan environment cc esc warn
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#getBegin()->int::: scanner support get begin
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#getEnd()->int::: scanner support get end
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#scanUnsignedNumber()->int::: scanner support scan unsigned number
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#scanUnsignedHexadecimalNumber(int)->int::: scanner support scan unsigned hexadecimal number
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#scanUnsignedOctalNumber(int)->int::: scanner support scan unsigned octal number
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#reset()->void::: scanner support reset
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#mark()->void::: scanner support mark
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#restore()->void::: scanner support restore
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#inc()->void::: scanner support inc
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#fetch()->void::: scanner support fetch
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#fetchTo()->int::: scanner support fetch to
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#unfetch()->void::: scanner support unfetch
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#peek()->int::: scanner support peek
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#peekIs(int)->boolean::: scanner support peek is
jdk.nashorn.internal.runtime.regexp.joni.ScannerSupport#left()->boolean::: scanner support left
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm#getName()->String::: search algorithm get name
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm#search(Regex, char[], int, int, int)->int::: search algorithm search
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm#searchBackward(Regex, char[], int, int, int, int, int, int)->int::: search algorithm search backward
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm.SLOW_IC#getName()->String::: w_ c get name
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm.SLOW_IC#search(Regex, char[], int, int, int)->int::: w_ c search
jdk.nashorn.internal.runtime.regexp.joni.SearchAlgorithm.SLOW_IC#searchBackward(Regex, char[], int, int, int, int, int, int)->int::: w_ c search backward
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setStatePCode(int)->void::: stack entry set state code
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getStatePCode()->int::: stack entry get state code
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setStatePStr(int)->void::: stack entry set state str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getStatePStr()->int::: stack entry get state str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setStatePStrPrev(int)->void::: stack entry set state str prev
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getStatePStrPrev()->int::: stack entry get state str prev
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setStateCheck(int)->void::: stack entry set state check
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getStateCheck()->int::: stack entry get state check
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setRepeatCount(int)->void::: stack entry set repeat count
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getRepeatCount()->int::: stack entry get repeat count
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#decreaseRepeatCount()->void::: stack entry decrease repeat count
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#increaseRepeatCount()->void::: stack entry increase repeat count
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setRepeatPCode(int)->void::: stack entry set repeat code
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getRepeatPCode()->int::: stack entry get repeat code
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setRepeatNum(int)->void::: stack entry set repeat num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getRepeatNum()->int::: stack entry get repeat num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setSi(int)->void::: stack entry set si
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getSi()->int::: stack entry get si
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setMemNum(int)->void::: stack entry set mem num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getMemNum()->int::: stack entry get mem num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setMemPstr(int)->void::: stack entry set mem pstr
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getMemPStr()->int::: stack entry get mem str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setMemStart(int)->void::: stack entry set mem start
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getMemStart()->int::: stack entry get mem start
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setMemEnd(int)->void::: stack entry set mem end
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getMemEnd()->int::: stack entry get mem end
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setNullCheckNum(int)->void::: stack entry set null check num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getNullCheckNum()->int::: stack entry get null check num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setNullCheckPStr(int)->void::: stack entry set null check str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getNullCheckPStr()->int::: stack entry get null check str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setCallFrameRetAddr(int)->void::: stack entry set call frame ret addr
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getCallFrameRetAddr()->int::: stack entry get call frame ret addr
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setCallFrameNum(int)->void::: stack entry set call frame num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getCallFrameNum()->int::: stack entry get call frame num
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#setCallFramePStr(int)->void::: stack entry set call frame str
jdk.nashorn.internal.runtime.regexp.joni.StackEntry#getCallFramePStr()->int::: stack entry get call frame str
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#init()->void::: stack machine init
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#ensure1()->StackEntry::: stack machine ensure1
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushType(int)->void::: stack machine push type
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushEnsured(int, int)->void::: stack machine push ensured
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushAlt(int, int, int)->void::: stack machine push alt
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushPos(int, int)->void::: stack machine push pos
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushPosNot(int, int, int)->void::: stack machine push pos not
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushStopBT()->void::: stack machine push stop t
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushLookBehindNot(int, int, int)->void::: stack machine push look behind not
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushRepeat(int, int)->void::: stack machine push repeat
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushRepeatInc(int)->void::: stack machine push repeat inc
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushMemStart(int, int)->void::: stack machine push mem start
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushMemEnd(int, int)->void::: stack machine push mem end
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushMemEndMark(int)->void::: stack machine push mem end mark
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#getMemStart(int)->int::: stack machine get mem start
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushNullCheckStart(int, int)->void::: stack machine push null check start
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pushNullCheckEnd(int)->void::: stack machine push null check end
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#popOne()->void::: stack machine pop one
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#pop()->StackEntry::: stack machine pop
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#popTilPosNot()->void::: stack machine pop til pos not
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#popTilLookBehindNot()->void::: stack machine pop til look behind not
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#posEnd()->int::: stack machine pos end
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#stopBtEnd()->void::: stack machine stop bt end
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#nullCheck(int, int)->int::: stack machine null check
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#nullCheckMemSt(int, int)->int::: stack machine null check mem st
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#getRepeat(int)->int::: stack machine get repeat
jdk.nashorn.internal.runtime.regexp.joni.StackMachine#sreturn()->int::: stack machine sreturn
jdk.nashorn.internal.runtime.regexp.joni.Syntax#isOp(int)->boolean::: syntax is op
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opVariableMetaCharacters()->boolean::: syntax op variable meta characters
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opDotAnyChar()->boolean::: syntax op dot any char
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opAsteriskZeroInf()->boolean::: syntax op asterisk zero inf
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscAsteriskZeroInf()->boolean::: syntax op esc asterisk zero inf
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opPlusOneInf()->boolean::: syntax op plus one inf
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscPlusOneInf()->boolean::: syntax op esc plus one inf
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opQMarkZeroOne()->boolean::: syntax op mark zero one
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscQMarkZeroOne()->boolean::: syntax op esc mark zero one
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opBraceInterval()->boolean::: syntax op brace interval
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscBraceInterval()->boolean::: syntax op esc brace interval
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opVBarAlt()->boolean::: syntax op bar alt
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscVBarAlt()->boolean::: syntax op esc bar alt
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opLParenSubexp()->boolean::: syntax op paren subexp
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscLParenSubexp()->boolean::: syntax op esc paren subexp
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscAZBufAnchor()->boolean::: syntax op esc buf anchor
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscCapitalGBeginAnchor()->boolean::: syntax op esc capital begin anchor
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opDecimalBackref()->boolean::: syntax op decimal backref
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opBracketCC()->boolean::: syntax op bracket c
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscWWord()->boolean::: syntax op esc word
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscLtGtWordBeginEnd()->boolean::: syntax op esc lt gt word begin end
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscBWordBound()->boolean::: syntax op esc word bound
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscSWhiteSpace()->boolean::: syntax op esc white space
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscDDigit()->boolean::: syntax op esc digit
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opLineAnchor()->boolean::: syntax op line anchor
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opPosixBracket()->boolean::: syntax op posix bracket
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opQMarkNonGreedy()->boolean::: syntax op mark non greedy
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscControlChars()->boolean::: syntax op esc control chars
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscCControl()->boolean::: syntax op esc control
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscOctal3()->boolean::: syntax op esc octal3
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscXHex2()->boolean::: syntax op esc hex2
jdk.nashorn.internal.runtime.regexp.joni.Syntax#opEscXBraceHex8()->boolean::: syntax op esc brace hex8
jdk.nashorn.internal.runtime.regexp.joni.Syntax#isOp2(int)->boolean::: syntax is op2
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscCapitalQQuote()->boolean::: syntax op2 esc capital quote
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2QMarkGroupEffect()->boolean::: syntax op2 mark group effect
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2OptionPerl()->boolean::: syntax op2 option perl
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2OptionRuby()->boolean::: syntax op2 option ruby
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2PlusPossessiveRepeat()->boolean::: syntax op2 plus possessive repeat
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2PlusPossessiveInterval()->boolean::: syntax op2 plus possessive interval
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2CClassSetOp()->boolean::: syntax op2 class set op
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2QMarkLtNamedGroup()->boolean::: syntax op2 mark lt named group
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscKNamedBackref()->boolean::: syntax op2 esc named backref
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscGSubexpCall()->boolean::: syntax op2 esc subexp call
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2AtMarkCaptureHistory()->boolean::: syntax op2 at mark capture history
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscCapitalCBarControl()->boolean::: syntax op2 esc capital bar control
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscCapitalMBarMeta()->boolean::: syntax op2 esc capital bar meta
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscVVtab()->boolean::: syntax op2 esc vtab
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscUHex4()->boolean::: syntax op2 esc hex4
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscGnuBufAnchor()->boolean::: syntax op2 esc gnu buf anchor
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscPBraceCharProperty()->boolean::: syntax op2 esc brace char property
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscPBraceCircumflexNot()->boolean::: syntax op2 esc brace circumflex not
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2EscHXDigit()->boolean::: syntax op2 esc digit
jdk.nashorn.internal.runtime.regexp.joni.Syntax#op2IneffectiveEscape()->boolean::: syntax op2 ineffective escape
jdk.nashorn.internal.runtime.regexp.joni.Syntax#isBehavior(int)->boolean::: syntax is behavior
jdk.nashorn.internal.runtime.regexp.joni.Syntax#contextIndepRepeatOps()->boolean::: syntax context indep repeat ops
jdk.nashorn.internal.runtime.regexp.joni.Syntax#contextInvalidRepeatOps()->boolean::: syntax context invalid repeat ops
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowUnmatchedCloseSubexp()->boolean::: syntax allow unmatched close subexp
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowInvalidInterval()->boolean::: syntax allow invalid interval
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowIntervalLowAbbrev()->boolean::: syntax allow interval low abbrev
jdk.nashorn.internal.runtime.regexp.joni.Syntax#strictCheckBackref()->boolean::: syntax strict check backref
jdk.nashorn.internal.runtime.regexp.joni.Syntax#differentLengthAltLookBehind()->boolean::: syntax different length alt look behind
jdk.nashorn.internal.runtime.regexp.joni.Syntax#captureOnlyNamedGroup()->boolean::: syntax capture only named group
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowMultiplexDefinitionName()->boolean::: syntax allow multiplex definition name
jdk.nashorn.internal.runtime.regexp.joni.Syntax#fixedIntervalIsGreedyOnly()->boolean::: syntax fixed interval is greedy only
jdk.nashorn.internal.runtime.regexp.joni.Syntax#notNewlineInNegativeCC()->boolean::: syntax not newline in negative c
jdk.nashorn.internal.runtime.regexp.joni.Syntax#backSlashEscapeInCC()->boolean::: syntax back slash escape in c
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowEmptyRangeInCC()->boolean::: syntax allow empty range in c
jdk.nashorn.internal.runtime.regexp.joni.Syntax#allowDoubleRangeOpInCC()->boolean::: syntax allow double range op in c
jdk.nashorn.internal.runtime.regexp.joni.Syntax#warnCCOpNotEscaped()->boolean::: syntax warn op not escaped
jdk.nashorn.internal.runtime.regexp.joni.Syntax#warnReduntantNestedRepeat()->boolean::: syntax warn reduntant nested repeat
jdk.nashorn.internal.runtime.regexp.joni.Token#getC()->int::: token get c
jdk.nashorn.internal.runtime.regexp.joni.Token#setC(int)->void::: token set c
jdk.nashorn.internal.runtime.regexp.joni.Token#getCode()->int::: token get code
jdk.nashorn.internal.runtime.regexp.joni.Token#setCode(int)->void::: token set code
jdk.nashorn.internal.runtime.regexp.joni.Token#getAnchor()->int::: token get anchor
jdk.nashorn.internal.runtime.regexp.joni.Token#setAnchor(int)->void::: token set anchor
jdk.nashorn.internal.runtime.regexp.joni.Token#getRepeatLower()->int::: token get repeat lower
jdk.nashorn.internal.runtime.regexp.joni.Token#setRepeatLower(int)->void::: token set repeat lower
jdk.nashorn.internal.runtime.regexp.joni.Token#getRepeatUpper()->int::: token get repeat upper
jdk.nashorn.internal.runtime.regexp.joni.Token#setRepeatUpper(int)->void::: token set repeat upper
jdk.nashorn.internal.runtime.regexp.joni.Token#getRepeatGreedy()->boolean::: token get repeat greedy
jdk.nashorn.internal.runtime.regexp.joni.Token#setRepeatGreedy(boolean)->void::: token set repeat greedy
jdk.nashorn.internal.runtime.regexp.joni.Token#getRepeatPossessive()->boolean::: token get repeat possessive
jdk.nashorn.internal.runtime.regexp.joni.Token#setRepeatPossessive(boolean)->void::: token set repeat possessive
jdk.nashorn.internal.runtime.regexp.joni.Token#getBackrefRef()->int::: token get backref ref
jdk.nashorn.internal.runtime.regexp.joni.Token#setBackrefRef(int)->void::: token set backref ref
jdk.nashorn.internal.runtime.regexp.joni.Token#getPropCType()->int::: token get prop type
jdk.nashorn.internal.runtime.regexp.joni.Token#setPropCType(int)->void::: token set prop type
jdk.nashorn.internal.runtime.regexp.joni.Token#getPropNot()->boolean::: token get prop not
jdk.nashorn.internal.runtime.regexp.joni.Token#setPropNot(boolean)->void::: token set prop not
jdk.nashorn.internal.runtime.regexp.joni.WarnCallback#warn(String)->void::: warn callback warn
