CompositeGuardingDynamicLinker#getGuardedInvocation(LinkRequest, LinkerServices):::Delegates the call to its component linkers:::foreach->invocation->linker->getGuardedInvocation->if->return->return
CompositeTypeBasedGuardingDynamicLinker.ClassToLinker#computeValue(Class)::: class to linker compute value:::list->for->i->return
CompositeTypeBasedGuardingDynamicLinker#canLinkType(Class):::Returns true if at least one of the composite linkers returns true from TypeBasedGuardingDynamicLinker#canLinkType(Class) for the type.:::return->classToLinker->get->isEmpty
CompositeTypeBasedGuardingDynamicLinker#getGuardedInvocation(LinkRequest, LinkerServices)::: composite type based guarding dynamic linker get guarded invocation:::obj->linkRequest->getReceiver->if->return->foreach->classToLinker->obj->getClass->get->invocation->linker->getGuardedInvocation->if->return->return
CompositeTypeBasedGuardingDynamicLinker#optimize(Iterable):::Optimizes a list of type-based linkers:::llinkers->new->LinkedList<>->tblinkers->new->LinkedList<>->foreach->Objects->requireNonNull->if->tblinkers->add->else->addTypeBased->llinkers->add->addTypeBased->return
CompositeTypeBasedGuardingDynamicLinker#addTypeBased(List, List)::: composite type based guarding dynamic linker add type based:::switch->tblinkers->size->break->llinkers->addAll->tblinkers->clear->break->llinkers->new->CompositeTypeBasedGuardingDynamicLinker->add->tblinkers->clear->break
DefaultInternalObjectFilter#transform(MethodHandle)::: default internal object filter transform:::filters->type->target->type->isVarArg->target->isVarargsCollector->paramCount->type->parameterCount->paramsFiltered->if->firstFilter->for->i->MethodHandles->filterArguments->else->returnFiltered->type->returnType->MethodHandles->filterReturnValue->return->returnFiltered->isVarargsCollector->returnFiltered->type->parameterType->asVarargsCollector
DefaultInternalObjectFilter#checkHandle(MethodHandle, String)::: default internal object filter check handle:::if->objectObjectType->MethodType->methodType->if->handle->type->equals->throw->new->IllegalArgumentException->return
DefaultInternalObjectFilter#filterVarArgs(MethodHandle, Object[])::: default internal object filter filter var args:::newArgs->for->i->return
Guards#isOfClass(Class, MethodType):::Creates a guard method handle with arguments of a specified type, but with boolean return value:::declaredType->type->parameterType->if->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->getClassBoundArgumentTest
Guards#isInstance(Class, MethodType):::Creates a method handle with arguments of a specified type, but with boolean return value:::return->isInstance
Guards#isInstance(Class, int, MethodType):::Creates a method handle with arguments of a specified type, but with boolean return value:::declaredType->type->parameterType->if->clazz->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->getClassBoundArgumentTest
Guards#isArray(int, MethodType):::Creates a method handle that returns true if the argument in the specified position is a Java array.:::declaredType->type->parameterType->if->declaredType->isArray->LOG->new->ObjectArr->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->asType
Guards#getClassBoundArgumentTest(MethodHandle, Class, int, MethodType)::: guards get class bound argument test:::return->test->bindTo->asType
Guards#asType(MethodHandle, MethodType):::Takes a method handle intended to be used as a guard, and adapts it to the requested type, but returning a boolean:::return->test->getTestType->asType
Guards#asType(LinkerServices, MethodHandle, MethodType):::Takes a method handle intended to be used as a guard, and adapts it to the requested type, but returning a boolean:::return->linkerServices->getTestType->asType
Guards#getTestType(MethodHandle, MethodType)::: guards get test type:::return->type->test->type->parameterCount->type->parameterCount->dropParameterTypes->changeReturnType
Guards#asType(MethodHandle, int, MethodType)::: guards as type:::return->MethodHandles->test->test->type->type->parameterType->changeParameterType->asType->type->changeReturnType->new->intArr->permuteArguments
Guards#getClassGuard(Class):::Creates a guard method that tests its only argument for being of an exact particular class.:::return->IS_OF_CLASS->bindTo
Guards#getInstanceOfGuard(Class):::Creates a guard method that tests its only argument for being an instance of a particular class.:::return->IS_INSTANCE->bindTo
Guards#getIdentityGuard(Object):::Creates a guard method that tests its only argument for being referentially identical to another object:::return->IS_IDENTICAL->bindTo
Guards#isNull():::Returns a guard that tests whether the first argument is null.:::return
Guards#isNotNull():::Returns a guard that tests whether the first argument is not null.:::return
Guards#isNull(Object)::: guards is null:::return
Guards#isNotNull(Object)::: guards is not null:::return
Guards#isArray(Object)::: guards is array:::return->o->getClass->isArray
Guards#isOfClass(Class, Object)::: guards is of class:::return->o->getClass
Guards#isIdentical(Object, Object)::: guards is identical:::return
Guards#constantTrue(MethodType)::: guards constant true:::return->constantBoolean
Guards#constantFalse(MethodType)::: guards constant false:::return->constantBoolean
Guards#constantBoolean(Boolean, MethodType)::: guards constant boolean:::return->MethodHandles->MethodHandles->constant->type->changeReturnType->permuteArguments
Lookup#unreflect(Method):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflect(Method), converting any encountered IllegalAccessException into an IllegalAccessError.:::return->unreflect
Lookup#unreflect(MethodHandles.Lookup, Method):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflect(Method), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflect->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#unreflectGetter(Field):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectGetter(Field), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectGetter->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#findGetter(Class, String, Class):::Performs a java.lang.invoke.MethodHandles.Lookup#findGetter(Class, String, Class), converting any encountered IllegalAccessException into an IllegalAccessError and NoSuchFieldException into a NoSuchFieldError.:::try->return->lookup->findGetter->catch->ee->refc->getName->type->getName->new->IllegalAccessError->ee->initCause->throw->ee->refc->getName->type->getName->new->NoSuchFieldError->ee->initCause->throw->finally
Lookup#unreflectSetter(Field):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectSetter(Field), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectSetter->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#unreflectConstructor(Constructor):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor), converting any encountered IllegalAccessException into an IllegalAccessError.:::return->unreflectConstructor
Lookup#unreflectConstructor(MethodHandles.Lookup, Constructor):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectConstructor->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#findSpecial(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class) on the underlying lookup:::try->return->lookup->findSpecial->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#methodDescription(Class, String, MethodType)::: lookup method description:::return->declaringClass->getName
Lookup#findStatic(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findStatic(Class, String, MethodType) on the underlying lookup:::try->return->lookup->findStatic->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#findVirtual(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findVirtual(Class, String, MethodType) on the underlying lookup:::try->return->lookup->findVirtual->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#findOwnSpecial(MethodHandles.Lookup, String, Class, Class...):::Given a lookup, finds using #findSpecial(Class, String, MethodType) a method on that lookup's class:::return->new->Lookup->findOwnSpecial
Lookup#findOwnSpecial(String, Class, Class...):::Finds using #findSpecial(Class, String, MethodType) a method on that lookup's class:::return->lookup->lookupClass->MethodType->methodType->findSpecial
Lookup#findOwnStatic(MethodHandles.Lookup, String, Class, Class...):::Given a lookup, finds using #findStatic(Class, String, MethodType) a method on that lookup's class:::return->new->Lookup->findOwnStatic
Lookup#findOwnStatic(String, Class, Class...):::Finds using #findStatic(Class, String, MethodType) a method on that lookup's class:::return->lookup->lookupClass->MethodType->methodType->findStatic
SimpleLinkRequest#getArguments()::: simple link request get arguments:::return->arguments->clone
SimpleLinkRequest#getReceiver()::: simple link request get receiver:::return
SimpleLinkRequest#getCallSiteDescriptor()::: simple link request get call site descriptor:::return
SimpleLinkRequest#isCallSiteUnstable()::: simple link request is call site unstable:::return
SimpleLinkRequest#replaceArguments(CallSiteDescriptor, Object...)::: simple link request replace arguments:::return->new->SimpleLinkRequest
TypeUtilities#createWrapperTypes()::: type utilities create wrapper types:::wrapperTypes->new->IdentityHashMap<>->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->wrapperTypes->put->return->Collections->unmodifiableMap
TypeUtilities#createClassNameMapping(Collection>)::: type utilities create class name mapping:::map->new->HashMap<>->foreach->map->clazz->getName->put->return
TypeUtilities#invertMap(Map)::: type utilities invert map:::inverted->map->size->new->IdentityHashMap<>->foreach->map->entrySet->inverted->entry->getValue->entry->getKey->put->return->Collections->unmodifiableMap
TypeUtilities#isMethodInvocationConvertible(Class, Class):::Determines whether one type can be converted to another type using a method invocation conversion, as per JLS 5.3 "Method Invocation Conversion":::if->targetType->isAssignableFrom->return->if->sourceType->isPrimitive->if->targetType->isPrimitive->return->isProperPrimitiveSubtype->return->isBoxingAndWideningReferenceConversion->if->targetType->isPrimitive->unboxedCallSiteType->getPrimitiveType->return->isProperPrimitiveSubtype->return
TypeUtilities#isBoxingAndWideningReferenceConversion(Class, Class)::: type utilities is boxing and widening reference conversion:::wrapperType->getWrapperType->return->targetType->isAssignableFrom
TypeUtilities#isConvertibleWithoutLoss(Class, Class):::Determines whether a type can be converted to another without losing any precision:::if->targetType->isAssignableFrom->return->if->sourceType->isPrimitive->if->return->if->targetType->isPrimitive->return->isProperPrimitiveLosslessSubtype->return->isBoxingAndWideningReferenceConversion->return
TypeUtilities#isSubtype(Class, Class):::Determines whether one type is a subtype of another type, as per JLS 4.10 "Subtyping":::if->superType->isAssignableFrom->return->if->superType->isPrimitive->subType->isPrimitive->return->isProperPrimitiveSubtype->return
TypeUtilities#isProperPrimitiveSubtype(Class, Class):::Returns true if a supposed primitive subtype is a proper subtype ( meaning, subtype and not identical) of the supposed primitive supertype:::if->return->if->return->if->return->if->return->if->return->if->return->if->return->return
TypeUtilities#isProperPrimitiveLosslessSubtype(Class, Class):::Similar to #isProperPrimitiveSubtype(Class, Class), except it disallows conversions from int and long to float, and from long to double, as those can lose precision:::if->return->if->return->if->return->if->return->if->return->if->return->return
TypeUtilities#getPrimitiveTypeByName(String):::Given a name of a primitive type returns the class representing it:::return->PRIMITIVE_TYPES_BY_NAME->get
TypeUtilities#getPrimitiveType(Class):::When passed a class representing a wrapper for a primitive type, returns the class representing the corresponding primitive type:::return->PRIMITIVE_TYPES->get
TypeUtilities#getWrapperType(Class):::When passed a class representing a primitive type, returns the class representing the corresponding wrapper type:::return->WRAPPER_TYPES->get
TypeUtilities#isWrapperType(Class):::Returns true if the passed type is a wrapper for a primitive type.:::return->PRIMITIVE_TYPES->containsKey
