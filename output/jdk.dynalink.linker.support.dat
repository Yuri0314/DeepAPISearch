CompositeGuardingDynamicLinker#getGuardedInvocation(LinkRequest, LinkerServices):::Delegates the call to its component linkers:::foreach->invocation->linker->getGuardedInvocation->if->return->return
CompositeTypeBasedGuardingDynamicLinker#canLinkType(Class):::Returns true if at least one of the composite linkers returns true from TypeBasedGuardingDynamicLinker#canLinkType(Class) for the type.:::return->classToLinker->get->isEmpty
CompositeTypeBasedGuardingDynamicLinker#optimize(Iterable):::Optimizes a list of type-based linkers:::llinkers->new->LinkedList<>->tblinkers->new->LinkedList<>->foreach->Objects->requireNonNull->if->tblinkers->add->else->addTypeBased->llinkers->add->addTypeBased->return
Guards#isOfClass(Class, MethodType):::Creates a guard method handle with arguments of a specified type, but with boolean return value:::declaredType->type->parameterType->if->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->getClassBoundArgumentTest
Guards#isInstance(Class, MethodType):::Creates a method handle with arguments of a specified type, but with boolean return value:::return->isInstance
Guards#isInstance(Class, int, MethodType):::Creates a method handle with arguments of a specified type, but with boolean return value:::declaredType->type->parameterType->if->clazz->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->clazz->getName->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->getClassBoundArgumentTest
Guards#isArray(int, MethodType):::Creates a method handle that returns true if the argument in the specified position is a Java array.:::declaredType->type->parameterType->if->declaredType->isArray->LOG->new->ObjectArr->DynamicLinker->getLinkedCallSiteLocation->log->return->constantTrue->if->declaredType->isAssignableFrom->LOG->new->ObjectArr->DynamicLinker->getLinkedCallSiteLocation->log->return->constantFalse->return->asType
Guards#asType(MethodHandle, MethodType):::Takes a method handle intended to be used as a guard, and adapts it to the requested type, but returning a boolean:::return->test->getTestType->asType
Guards#asType(LinkerServices, MethodHandle, MethodType):::Takes a method handle intended to be used as a guard, and adapts it to the requested type, but returning a boolean:::return->linkerServices->getTestType->asType
Guards#getClassGuard(Class):::Creates a guard method that tests its only argument for being of an exact particular class.:::return->IS_OF_CLASS->bindTo
Guards#getInstanceOfGuard(Class):::Creates a guard method that tests its only argument for being an instance of a particular class.:::return->IS_INSTANCE->bindTo
Guards#getIdentityGuard(Object):::Creates a guard method that tests its only argument for being referentially identical to another object:::return->IS_IDENTICAL->bindTo
Guards#isNull():::Returns a guard that tests whether the first argument is null.:::return
Guards#isNotNull():::Returns a guard that tests whether the first argument is not null.:::return
Lookup#unreflect(Method):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflect(Method), converting any encountered IllegalAccessException into an IllegalAccessError.:::return->unreflect
Lookup#unreflect(MethodHandles.Lookup, Method):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflect(Method), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflect->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#unreflectGetter(Field):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectGetter(Field), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectGetter->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#findGetter(Class, String, Class):::Performs a java.lang.invoke.MethodHandles.Lookup#findGetter(Class, String, Class), converting any encountered IllegalAccessException into an IllegalAccessError and NoSuchFieldException into a NoSuchFieldError.:::try->return->lookup->findGetter->catch->ee->refc->getName->type->getName->new->IllegalAccessError->ee->initCause->throw->ee->refc->getName->type->getName->new->NoSuchFieldError->ee->initCause->throw->finally
Lookup#unreflectSetter(Field):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectSetter(Field), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectSetter->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#unreflectConstructor(Constructor):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor), converting any encountered IllegalAccessException into an IllegalAccessError.:::return->unreflectConstructor
Lookup#unreflectConstructor(MethodHandles.Lookup, Constructor):::Performs a java.lang.invoke.MethodHandles.Lookup#unreflectConstructor(Constructor), converting any encountered IllegalAccessException into an IllegalAccessError.:::try->return->lookup->unreflectConstructor->catch->ee->new->IllegalAccessError->ee->initCause->throw->finally
Lookup#findSpecial(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class) on the underlying lookup:::try->return->lookup->findSpecial->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#findStatic(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findStatic(Class, String, MethodType) on the underlying lookup:::try->return->lookup->findStatic->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#findVirtual(Class, String, MethodType):::Performs a java.lang.invoke.MethodHandles.Lookup#findVirtual(Class, String, MethodType) on the underlying lookup:::try->return->lookup->findVirtual->catch->ee->methodDescription->new->IllegalAccessError->ee->initCause->throw->ee->methodDescription->new->NoSuchMethodError->ee->initCause->throw->finally
Lookup#findOwnSpecial(MethodHandles.Lookup, String, Class, Class...):::Given a lookup, finds using #findSpecial(Class, String, MethodType) a method on that lookup's class:::return->new->Lookup->findOwnSpecial
Lookup#findOwnSpecial(String, Class, Class...):::Finds using #findSpecial(Class, String, MethodType) a method on that lookup's class:::return->lookup->lookupClass->MethodType->methodType->findSpecial
Lookup#findOwnStatic(MethodHandles.Lookup, String, Class, Class...):::Given a lookup, finds using #findStatic(Class, String, MethodType) a method on that lookup's class:::return->new->Lookup->findOwnStatic
Lookup#findOwnStatic(String, Class, Class...):::Finds using #findStatic(Class, String, MethodType) a method on that lookup's class:::return->lookup->lookupClass->MethodType->methodType->findStatic
TypeUtilities#isMethodInvocationConvertible(Class, Class):::Determines whether one type can be converted to another type using a method invocation conversion, as per JLS 5.3 "Method Invocation Conversion":::if->targetType->isAssignableFrom->return->if->sourceType->isPrimitive->if->targetType->isPrimitive->return->isProperPrimitiveSubtype->return->isBoxingAndWideningReferenceConversion->if->targetType->isPrimitive->unboxedCallSiteType->getPrimitiveType->return->isProperPrimitiveSubtype->return
TypeUtilities#isConvertibleWithoutLoss(Class, Class):::Determines whether a type can be converted to another without losing any precision:::if->targetType->isAssignableFrom->return->if->sourceType->isPrimitive->if->return->if->targetType->isPrimitive->return->isProperPrimitiveLosslessSubtype->return->isBoxingAndWideningReferenceConversion->return
TypeUtilities#isSubtype(Class, Class):::Determines whether one type is a subtype of another type, as per JLS 4.10 "Subtyping":::if->superType->isAssignableFrom->return->if->superType->isPrimitive->subType->isPrimitive->return->isProperPrimitiveSubtype->return
TypeUtilities#getPrimitiveTypeByName(String):::Given a name of a primitive type returns the class representing it:::return->PRIMITIVE_TYPES_BY_NAME->get
TypeUtilities#getPrimitiveType(Class):::When passed a class representing a wrapper for a primitive type, returns the class representing the corresponding primitive type:::return->PRIMITIVE_TYPES->get
TypeUtilities#getWrapperType(Class):::When passed a class representing a primitive type, returns the class representing the corresponding wrapper type:::return->WRAPPER_TYPES->get
TypeUtilities#isWrapperType(Class):::Returns true if the passed type is a wrapper for a primitive type.:::return->PRIMITIVE_TYPES->containsKey
