AbsoluteLocationPath#setParser(Parser)::: absolute location path set parser:::super->setParser->if->_path->setParser
AbsoluteLocationPath#getPath()::: absolute location path get path:::return
AbsoluteLocationPath#toString()::: absolute location path to string:::return->_path->toString
AbsoluteLocationPath#typeCheck(SymbolTable)::: absolute location path type check:::if->ptype->_path->typeCheck->if->new->CastExpr->return
AbsoluteLocationPath#translate(ClassGenerator, MethodGenerator)::: absolute location path translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->initAI->cpg->addMethodref->_path->translate->relPathIterator->methodGen->Util->getJCRefType->addLocalVariable->relPathIterator->il->relPathIterator->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->relPathIterator->il->relPathIterator->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append->else->gitr->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->INVOKEINTERFACE->append
AbsolutePathPattern#setParser(Parser)::: absolute path pattern set parser:::super->setParser->if->_left->setParser
AbsolutePathPattern#typeCheck(SymbolTable)::: absolute path pattern type check:::return->_left->typeCheck
AbsolutePathPattern#isWildcard()::: absolute path pattern is wildcard:::return
AbsolutePathPattern#getKernelPattern()::: absolute path pattern get kernel pattern:::return->_left->getKernelPattern
AbsolutePathPattern#reduceKernelPattern()::: absolute path pattern reduce kernel pattern:::_left->reduceKernelPattern
AbsolutePathPattern#translate(ClassGenerator, MethodGenerator)::: absolute path pattern translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->if->local->methodGen->Util->getJCRefType->addLocalVariable2->il->append->local->il->local->getIndex->new->ISTORE->append->setStart->_left->translate->il->methodGen->loadDOM->append->local->il->local->getIndex->new->ILOAD->append->setEnd->methodGen->removeLocalVariable->else->_left->translate->getParent->cpg->addInterfaceMethodref->getType->cpg->addInterfaceMethodref->begin->il->methodGen->loadDOM->append->il->append->il->new->INVOKEINTERFACE->append->if->il->methodGen->loadDOM->append->il->append->il->new->INVOKEINTERFACE->append->il->new->PUSH->append->skip->il->new->IF_ICMPEQ->append->_falseList->il->new->GOTO_W->append->add->skip->il->append->setTarget->if->_left->backPatchTrueList->if->ancestor->_falseList->ancestor->getLoopHandle->backPatch->_falseList->append
AbsolutePathPattern#toString()::: absolute path pattern to string:::return->_left->toString
AlternativePattern#setParser(Parser)::: alternative pattern set parser:::super->setParser->_left->setParser->_right->setParser
AlternativePattern#getLeft()::: alternative pattern get left:::return
AlternativePattern#getRight()::: alternative pattern get right:::return
AlternativePattern#typeCheck(SymbolTable):::The type of an '|' is not really defined, hence null is returned.:::_left->typeCheck->_right->typeCheck->return
AlternativePattern#getPriority()::: alternative pattern get priority:::left->_left->getPriority->right->_right->getPriority->if->return->else->return
AlternativePattern#toString()::: alternative pattern to string:::return
AlternativePattern#translate(ClassGenerator, MethodGenerator)::: alternative pattern translate:::il->methodGen->getInstructionList->_left->translate->gotot->il->new->GOTO->append->il->methodGen->loadContextNode->append->_right->translate->backPatch->gotot->getNext->backPatch->_trueList->add->append->_falseList->append
AncestorPattern#getLoopHandle()::: ancestor pattern get loop handle:::return
AncestorPattern#setParser(Parser)::: ancestor pattern set parser:::super->setParser->if->_left->setParser->_right->setParser
AncestorPattern#isWildcard()::: ancestor pattern is wildcard:::return
AncestorPattern#getKernelPattern()::: ancestor pattern get kernel pattern:::return->_right->getKernelPattern
AncestorPattern#reduceKernelPattern()::: ancestor pattern reduce kernel pattern:::_right->reduceKernelPattern
AncestorPattern#typeCheck(SymbolTable)::: ancestor pattern type check:::if->_left->typeCheck->return->_right->typeCheck
AncestorPattern#translate(ClassGenerator, MethodGenerator)::: ancestor pattern translate:::parent->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->local->methodGen->Util->getJCRefType->il->getEnd->addLocalVariable2->loadLocal->local->getIndex->new->ILOAD->storeLocal->local->getIndex->new->ISTORE->if->il->append->il->append->_right->translate->il->methodGen->loadDOM->append->il->append->else->_right->translate->if->il->methodGen->loadDOM->append->il->append->if->getParent->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->append->il->append->_falseList->il->new->IFLT->append->add->il->append->_left->translate->p->getParent->if->else->il->append->exit->il->new->GOTO->append->il->methodGen->loadDOM->append->il->append->local->setEnd->il->new->GOTO->append->exit->il->append->setTarget->_left->backPatchFalseList->_trueList->append->else->il->append->if->ancestor->_falseList->ancestor->getLoopHandle->backPatch->_trueList->append->_falseList->append
AncestorPattern#toString()::: ancestor pattern to string:::return
ApplyImports#display(int)::: apply imports display:::indent->Util->println->indent->if->indent->Util->println
ApplyImports#hasWithParams():::Returns true if this <xsl:apply-imports/> element has parameters:::return->hasContents
ApplyImports#getMinPrecedence(int):::Determine the lowest import precedence for any stylesheet imported or included by the stylesheet in which this <xsl:apply-imports/> element occured:::includeRoot->getStylesheet->while->return->includeRoot->getMinimumDescendantPrecedence
ApplyImports#parseContents(Parser):::Parse the attributes and contents of an <xsl:apply-imports/> element.:::stylesheet->getStylesheet->stylesheet->setTemplateInlining->template->getTemplate->template->getModeName->template->getImportPrecedence->parser->getTopLevelStylesheet->parseChildren
ApplyImports#typeCheck(SymbolTable):::Type-check the attributes/contents of an <xsl:apply-imports/> element.:::typeCheckContents->return
ApplyImports#translate(ClassGenerator, MethodGenerator):::Translate call-template:::stylesheet->classGen->getStylesheet->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->current->methodGen->getLocalIndex->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->if->stylesheet->hasLocalParams->il->classGen->loadTranslet->append->pushFrame->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->maxPrecedence->minPrecedence->getMinPrecedence->mode->stylesheet->getMode->functionName->mode->functionName->className->classGen->getStylesheet->getClassName->signature->classGen->getApplyTemplatesSigForImport->applyTemplates->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->if->stylesheet->hasLocalParams->il->classGen->loadTranslet->append->pushFrame->cpg->addMethodref->il->new->INVOKEVIRTUAL->append
ApplyTemplates#display(int)::: apply templates display:::indent->Util->println->indent->Util->_select->toString->println->if->indent->Util->println
ApplyTemplates#hasWithParams()::: apply templates has with params:::return->hasContents
ApplyTemplates#parseContents(Parser)::: apply templates parse contents:::select->getAttribute->mode->getAttribute->if->select->length->parser->parseExpression->if->mode->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->parser->getTopLevelStylesheet->getMode->functionName->parseChildren
ApplyTemplates#typeCheck(SymbolTable)::: apply templates type check:::if->_select->typeCheck->if->new->CastExpr->if->typeCheckContents->return->throw->new->TypeCheckError->else->typeCheckContents->return
ApplyTemplates#translate(ClassGenerator, MethodGenerator):::Translate call-template:::setStartNodeCalled->stylesheet->classGen->getStylesheet->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->current->methodGen->getLocalIndex->sortObjects->new->ArrayList<>->foreach->getContents->if->sortObjects->add->if->stylesheet->hasLocalParams->hasContents->il->classGen->loadTranslet->append->pushFrame->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->translateContents->il->classGen->loadTranslet->append->if->if->sortObjects->size->err->new->ErrorMsg->getParser->reportError->_select->translate->_type->translateTo->else->il->methodGen->loadDOM->append->if->sortObjects->size->Sort->translateSortIterator->setStartNode->cpg->addInterfaceMethodref->il->methodGen->loadCurrentNode->append->il->new->INVOKEINTERFACE->append->else->if->Mode->compileGetChildren->else->_select->translate->if->_select->startIterator->className->classGen->getStylesheet->getClassName->il->methodGen->loadHandler->append->applyTemplatesSig->classGen->getApplyTemplatesSig->applyTemplates->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->foreach->getContents->if->releaseResultTree->if->stylesheet->hasLocalParams->hasContents->il->classGen->loadTranslet->append->popFrame->cpg->addMethodref->il->new->INVOKEVIRTUAL->append
ArgumentList#toString()::: argument list to string:::return->_arg->toString->_arg->toString->_rest->toString
Attribute#display(int)::: attribute display:::indent->Util->println->displayContents
Attribute#parseContents(Parser)::: attribute parse contents:::parser->getAttribute->getQName->parseChildren
AttributeSet#getName():::Returns the QName of this attribute set:::return
AttributeSet#getMethodName():::Returns the method name of this attribute set:::return
AttributeSet#ignore():::Call this method to prevent a method for being compiled for this set:::
AttributeSet#parseContents(Parser):::Parse the contents of this attribute set:::name->getAttribute->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->if->_name->equals->msg->new->ErrorMsg->parser->reportError->useSets->getAttribute->if->useSets->length->if->Util->isValidQNames->err->new->ErrorMsg->parser->reportError->new->UseAttributeSets->contents->getContents->count->contents->size->for->i->parser->getSymbolTable->setCurrentNode
AttributeSet#typeCheck(SymbolTable):::Type check the contents of this element:::if->return->stable->addAttributeSet->getXSLTC->nextAttributeSetSerial->if->_useSets->typeCheck->typeCheckContents->return
AttributeSet#translate(ClassGenerator, MethodGenerator):::Compile a method that outputs the attributes in this set:::if->return->new->AttributeSetMethodGenerator->if->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->methodName->_mergeSet->getMethodName->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->method->cpg->classGen->getClassName->addMethodref->il->new->INVOKESPECIAL->append->if->_useSets->translate->attributes->elements->while->attributes->hasNext->element->attributes->next->if->attribute->attribute->translate->il->methodGen->getInstructionList->il->append->classGen->addMethod
AttributeSet#toString()::: attribute set to string:::buf->new->StringBuffer->attributes->elements->while->attributes->hasNext->attribute->attributes->next->buf->append->return->buf->toString
AttributeValue#create(SyntaxTreeNode, String, Parser)::: attribute value create:::result->if->text->indexOf->new->AttributeValueTemplate->else->if->text->indexOf->new->AttributeValueTemplate->else->new->SimpleAttributeValue->result->setParser->result->setParent->return
AttributeValueTemplate#parseAVTemplate(String, Parser):::Two-pass parsing of ATVs:::tokenizer->new->StringTokenizer->t->lookahead->buffer->new->StringBuilder->state->while->tokenizer->hasMoreTokens->if->else->tokenizer->nextToken->if->t->length->switch->t->charAt->switch->tokenizer->nextToken->if->lookahead->equals->buffer->append->else->buffer->append->break->getParent->reportError->break->break->switch->tokenizer->nextToken->if->lookahead->equals->buffer->append->else->getParent->reportError->break->buffer->append->break->buffer->append->break->break->switch->break->break->break->buffer->append->break->switch->break->break->break->buffer->append->break->buffer->append->break->else->buffer->append->if->getParent->reportError->buffer->toString->new->StringTokenizer->while->tokenizer->hasMoreTokens->tokenizer->nextToken->if->t->equals->parser->tokenizer->nextToken->parseExpression->addElement->tokenizer->nextToken->else->new->LiteralExpr->addElement
AttributeValueTemplate#typeCheck(SymbolTable)::: attribute value template type check:::contents->getContents->n->contents->size->for->i->return
AttributeValueTemplate#toString()::: attribute value template to string:::buffer->new->StringBuilder->count->elementCount->for->i->return->buffer->append->toString
AttributeValueTemplate#translate(ClassGenerator, MethodGenerator)::: attribute value template translate:::if->elementCount->exp->elementAt->exp->translate->else->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->initBuffer->cpg->addMethodref->append->cpg->addMethodref->new->INVOKEVIRTUAL->toString->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->new->INVOKESPECIAL->append->elements->elements->while->elements->hasNext->exp->elements->next->exp->translate->il->append->il->new->INVOKEVIRTUAL->append
BinOpExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::if->_left->hasPositionCall->return->if->_right->hasPositionCall->return->return
BinOpExpr#hasLastCall():::Returns true if this expressions contains a call to last():::return->_left->hasLastCall->_right->hasLastCall
BinOpExpr#setParser(Parser)::: bin op expr set parser:::super->setParser->_left->setParser->_right->setParser
BinOpExpr#typeCheck(SymbolTable)::: bin op expr type check:::tleft->_left->typeCheck->tright->_right->typeCheck->ptype->new->MethodType->lookupPrimop->if->arg1->ptype->argsType->get->if->arg1->identicalTo->new->CastExpr->arg2->ptype->argsType->get->if->arg2->identicalTo->new->CastExpr->return->ptype->resultType->throw->new->TypeCheckError
BinOpExpr#translate(ClassGenerator, MethodGenerator)::: bin op expr translate:::il->methodGen->getInstructionList->_left->translate->_right->translate->switch->il->_type->ADD->append->break->il->_type->SUB->append->break->il->_type->MUL->append->break->il->_type->DIV->append->break->il->_type->REM->append->break->msg->new->ErrorMsg->getParser->reportError
BinOpExpr#toString()::: bin op expr to string:::return
BooleanCall#typeCheck(SymbolTable)::: boolean call type check:::_arg->typeCheck->return
BooleanCall#translate(ClassGenerator, MethodGenerator)::: boolean call translate:::_arg->translate->targ->_arg->getType->if->targ->identicalTo->_arg->startIterator->targ->translateTo
BooleanExpr#typeCheck(SymbolTable)::: boolean expr type check:::return
BooleanExpr#toString()::: boolean expr to string:::return
BooleanExpr#getValue()::: boolean expr get value:::return
BooleanExpr#contextDependent()::: boolean expr context dependent:::return
BooleanExpr#translate(ClassGenerator, MethodGenerator)::: boolean expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
BooleanExpr#translateDesynthesized(ClassGenerator, MethodGenerator)::: boolean expr translate desynthesized:::il->methodGen->getInstructionList->if->il->append->else->_falseList->il->new->GOTO->append->add
CallTemplate#display(int)::: call template display:::indent->print->Util->println->displayContents
CallTemplate#hasWithParams()::: call template has with params:::return->elementCount
CallTemplate#parseContents(Parser)::: call template parse contents:::name->getAttribute->if->name->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->else->reportError->parseChildren
CallTemplate#typeCheck(SymbolTable):::Verify that a template with this name exists.:::template->stable->lookupTemplate->if->typeCheckContents->else->err->new->ErrorMsg->throw->new->TypeCheckError->return
CallTemplate#translate(ClassGenerator, MethodGenerator)::: call template translate:::stylesheet->classGen->getStylesheet->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->stylesheet->hasLocalParams->hasContents->getCalleeTemplate->if->buildParameterList->else->push->cpg->addMethodref->il->classGen->loadTranslet->append->il->new->INVOKEVIRTUAL->append->translateContents->className->stylesheet->getClassName->methodName->Util->_name->toString->escape->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->methodSig->new->StringBuffer->if->numParams->for->i->methodSig->append->il->cpg->methodSig->toString->addMethodref->new->INVOKEVIRTUAL->append->if->for->i->if->stylesheet->hasLocalParams->hasContents->pop->cpg->addMethodref->il->classGen->loadTranslet->append->il->new->INVOKEVIRTUAL->append
CallTemplate#getCalleeTemplate():::Return the simple named template which this CallTemplate calls:::foundTemplate->getXSLTC->getParser->getSymbolTable->lookupTemplate->return->foundTemplate->isSimpleNamedTemplate
CallTemplate#buildParameterList():::Build the list of effective parameters in this CallTemplate:::defaultParams->_calleeTemplate->getParameters->numParams->defaultParams->size->new->SyntaxTreeNodeArr->for->i->count->elementCount->for->i
CastCall#typeCheck(SymbolTable):::Type check the two parameters for this function:::if->argumentCount->throw->getName->new->ErrorMsg->new->TypeCheckError->exp->argument->if->getValue->Type->newObjectType->else->throw->getName->new->ErrorMsg->new->TypeCheckError->argument->tright->_right->typeCheck->if->throw->new->ErrorMsg->new->TypeCheckError->return
CastCall#translate(ClassGenerator, MethodGenerator)::: cast call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_right->translate->il->cpg->addClass->new->CHECKCAST->append
CastExpr#getExpr()::: cast expr get expr:::return
CastExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::return->_left->hasPositionCall
CastExpr#hasLastCall()::: cast expr has last call:::return->_left->hasLastCall
CastExpr#toString()::: cast expr to string:::return
CastExpr#typeCheck(SymbolTable):::Type checking a cast expression amounts to verifying that the type conversion is legal:::tleft->_left->getType->if->_left->typeCheck->if->else->if->if->InternalTypeMap->maps->return->throw->tleft->toString->_type->toString->new->ErrorMsg->new->TypeCheckError
CastExpr#translateDesynthesized(ClassGenerator, MethodGenerator)::: cast expr translate desynthesized:::fl->ltype->_left->getType->if->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->idx->cpg->addInterfaceMethodref->il->getNodeType->new->SIPUSH->append->il->methodGen->loadDOM->append->il->methodGen->loadContextNode->append->il->new->INVOKEINTERFACE->append->_falseList->il->new->IF_ICMPNE->append->add->else->_left->translate->if->_left->startIterator->if->ltype->translateToDesynthesized->if->_falseList->append->else->ltype->translateTo
CastExpr#translate(ClassGenerator, MethodGenerator)::: cast expr translate:::ltype->_left->getType->_left->translate->if->_type->identicalTo->_left->startIterator->ltype->translateTo
CeilingCall#translate(ClassGenerator, MethodGenerator)::: ceiling call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->argument->translate->il->cpg->addMethodref->new->INVOKESTATIC->append
Choose#display(int):::Display the element contents (a lot of when's and an otherwise):::indent->Util->println->indent->displayContents
Choose#translate(ClassGenerator, MethodGenerator):::Translate this Choose element:::whenElements->new->ArrayList<>->otherwise->elements->elements->error->line->getLineNumber->while->elements->hasNext->element->elements->next->if->whenElements->add->else->if->if->else->new->ErrorMsg->getParser->reportError->else->if->ignore->else->new->ErrorMsg->getParser->reportError->if->whenElements->size->new->ErrorMsg->getParser->reportError->return->il->methodGen->getInstructionList->nextElement->exitHandles->new->ArrayList<>->exit->whens->Collections->enumeration->while->whens->hasMoreElements->when->whens->nextElement->test->when->getTest->truec->il->getEnd->if->nextElement->il->append->setTarget->test->translateDesynthesized->if->call->try->type->call->getParser->getSymbolTable->typeCheck->if->il->new->IFEQ->append->add->catch->finally->il->getEnd->if->when->ignore->when->translateContents->exitHandles->il->new->GOTO->append->add->if->whens->hasMoreElements->il->new->GOTO->append->test->backPatchFalseList->else->test->il->append->backPatchFalseList->test->truec->getNext->backPatchTrueList->if->nextElement->il->append->setTarget->otherwise->translateContents->il->append->exitGotos->Collections->enumeration->while->exitGotos->hasMoreElements->gotoExit->exitGotos->nextElement->gotoExit->setTarget
Closure#inInnerClass():::Returns true if this closure is compiled in an inner class (i.e:::
Closure#getParentClosure():::Returns a reference to its parent closure or null if outermost.:::
Closure#getInnerClassName():::Returns the name of the auxiliary class or null if this predicate is compiled inside the Translet.:::
Closure#addVariable(VariableRefBase):::Add new variable to the closure.:::
Comment#parseContents(Parser)::: comment parse contents:::parseChildren
Comment#typeCheck(SymbolTable)::: comment type check:::typeCheckContents->return
Comment#translate(ClassGenerator, MethodGenerator)::: comment translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->rawText->if->elementCount->content->elementAt->if->if->il->methodGen->loadHandler->append->if->rawText->canLoadAsArrayOffsetLength->rawText->loadAsArrayOffsetLength->comment->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->else->il->rawText->getText->new->PUSH->append->comment->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->else->il->methodGen->loadHandler->append->il->append->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->methodGen->storeHandler->append->translateContents->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->comment->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->methodGen->storeHandler->append
CompilerException#getMessage()::: compiler exception get message:::col->_msg->indexOf->if->return->_msg->substring->else->return
ConcatCall#typeCheck(SymbolTable)::: concat call type check:::for->i->argumentCount->return
ConcatCall#translate(ClassGenerator, MethodGenerator):::translate leaves a String on the stack:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->nArgs->argumentCount->switch->il->new->PUSH->append->break->argument->translate->break->initBuffer->cpg->addMethodref->append->cpg->addMethodref->new->INVOKEVIRTUAL->toString->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->new->INVOKESPECIAL->append->for->i->il->new->INVOKEVIRTUAL->append
ContainsCall#isBoolean():::This XPath function returns true/false values:::return
ContainsCall#typeCheck(SymbolTable):::Type check the two parameters for this function:::if->argumentCount->throw->getName->new->TypeCheckError->argument->baseType->_base->typeCheck->if->new->CastExpr->argument->tokenType->_token->typeCheck->if->new->CastExpr->return
ContainsCall#translate(ClassGenerator, MethodGenerator):::Compile the expression - leave boolean expression on stack:::translateDesynthesized->synthesize
ContainsCall#translateDesynthesized(ClassGenerator, MethodGenerator):::Compile expression and update true/false-lists:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_base->translate->_token->translate->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->_falseList->il->new->IFLT->append->add
Copy#parseContents(Parser)::: copy parse contents:::useSets->getAttribute->if->useSets->length->if->Util->isValidQNames->err->new->ErrorMsg->parser->reportError->new->UseAttributeSets->parseChildren
Copy#display(int)::: copy display:::indent->Util->println->indent->displayContents
Copy#typeCheck(SymbolTable)::: copy type check:::if->_useSets->typeCheck->typeCheckContents->return
Copy#translate(ClassGenerator, MethodGenerator)::: copy translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->name->methodGen->Util->getJCRefType->addLocalVariable2->length->methodGen->Util->getJCRefType->addLocalVariable2->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->methodGen->loadHandler->append->cpy->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->append->name->il->name->getIndex->new->ASTORE->append->setStart->ifBlock1->il->new->IFNULL->append->il->name->getIndex->new->ALOAD->append->lengthMethod->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->il->append->length->il->length->getIndex->new->ISTORE->append->setStart->ifBlock4->il->new->IFEQ->append->if->parent->getParent->if->_useSets->translate->else->il->length->getIndex->new->ILOAD->append->ifBlock2->il->new->IFEQ->append->_useSets->translate->ifBlock2->il->append->setTarget->ifBlock4->il->append->setTarget->translateContents->length->il->length->getIndex->new->ILOAD->append->setEnd->ifBlock3->il->new->IFEQ->append->il->methodGen->loadHandler->append->name->il->name->getIndex->new->ALOAD->append->setEnd->il->methodGen->endElement->append->end->il->append->ifBlock1->setTarget->ifBlock3->setTarget->methodGen->removeLocalVariable->methodGen->removeLocalVariable
CopyOf#display(int)::: copy of display:::indent->Util->println->indent->Util->_select->toString->println
CopyOf#parseContents(Parser)::: copy of parse contents:::parser->parseExpression->if->_select->isDummy->reportError->return
CopyOf#typeCheck(SymbolTable)::: copy of type check:::tselect->_select->typeCheck->if->else->new->CastExpr->return
CopyOf#translate(ClassGenerator, MethodGenerator)::: copy of translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->tselect->_select->getType->CPY1_SIG->cpy1->cpg->addInterfaceMethodref->CPY2_SIG->cpy2->cpg->addInterfaceMethodref->getDoc_SIG->getDoc->cpg->addInterfaceMethodref->if->il->methodGen->loadDOM->append->_select->translate->_select->startIterator->il->methodGen->loadHandler->append->il->new->INVOKEINTERFACE->append->else->if->il->methodGen->loadDOM->append->_select->translate->il->methodGen->loadHandler->append->il->new->INVOKEINTERFACE->append->else->if->_select->translate->il->append->il->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->il->new->INVOKEINTERFACE->append->else->if->_select->translate->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->il->methodGen->loadDOM->append->copy->cpg->addMethodref->il->new->INVOKESTATIC->append->else->il->classGen->loadTranslet->append->_select->translate->il->methodGen->loadHandler->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append
CurrentCall#translate(ClassGenerator, MethodGenerator)::: current call translate:::methodGen->getInstructionList->methodGen->loadCurrentNode->append
DecimalFormatting#typeCheck(SymbolTable):::No type check needed for the <xsl:decimal-formatting/> element:::return
DecimalFormatting#parseContents(Parser):::Parse the name of the <xsl:decimal-formatting/> element:::name->getAttribute->if->name->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->if->parser->getQNameIgnoreDefaultNs->stable->parser->getSymbolTable->if->stable->getDecimalFormatting->_name->toString->reportWarning->else->stable->addDecimalFormatting
DecimalFormatting#translate(ClassGenerator, MethodGenerator):::This method is called when the constructor is compiled in Stylesheet.compileConstructor() and not as the syntax tree is traversed.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->init->cpg->addMethodref->il->classGen->loadTranslet->append->il->_name->toString->new->PUSH->append->il->cpg->addClass->new->NEW->append->il->append->il->cpg->addFieldref->new->GETSTATIC->append->il->new->INVOKESPECIAL->append->tmp->getAttribute->if->tmp->equals->nan->cpg->addMethodref->il->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->getAttribute->if->tmp->equals->inf->cpg->addMethodref->il->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->nAttributes->_attributes->getLength->for->i->put->cpg->addMethodref->il->new->INVOKEVIRTUAL->append
DecimalFormatting#translateDefaultDFS(ClassGenerator, MethodGenerator):::Creates the default, nameless, DecimalFormat object in AbstractTranslet's format_symbols hashtable:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->init->cpg->addMethodref->il->classGen->loadTranslet->append->il->new->PUSH->append->il->cpg->addClass->new->NEW->append->il->append->il->cpg->addFieldref->new->GETSTATIC->append->il->new->INVOKESPECIAL->append->nan->cpg->addMethodref->il->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->inf->cpg->addMethodref->il->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->put->cpg->addMethodref->il->new->INVOKEVIRTUAL->append
DocumentCall#typeCheck(SymbolTable):::Type checks the arguments passed to the document() function:::ac->argumentCount->if->msg->new->ErrorMsg->throw->new->TypeCheckError->if->getStylesheet->msg->new->ErrorMsg->throw->new->TypeCheckError->argument->if->msg->new->ErrorMsg->throw->new->TypeCheckError->_arg1->typeCheck->if->new->CastExpr->if->argument->if->msg->new->ErrorMsg->throw->new->TypeCheckError->arg2Type->_arg2->typeCheck->if->arg2Type->identicalTo->new->CastExpr->else->if->arg2Type->identicalTo->else->msg->new->ErrorMsg->throw->new->TypeCheckError->return
DocumentCall#translate(ClassGenerator, MethodGenerator):::Translates the document() function call to a call to LoadDocument()'s static method document().:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->ac->argumentCount->domField->cpg->classGen->getClassName->addFieldref->docParamList->if->else->docIdx->cpg->addMethodref->_arg1->translate->if->_arg1->startIterator->if->_arg2->translate->_arg2->startIterator->il->getStylesheet->getSystemId->new->PUSH->append->il->classGen->loadTranslet->append->il->append->il->new->GETFIELD->append->il->new->INVOKESTATIC->append
ElementAvailableCall#typeCheck(SymbolTable):::Force the argument to this function to be a literal string.:::if->argument->return->err->new->ErrorMsg->throw->new->TypeCheckError
ElementAvailableCall#evaluateAtCompileTime():::Returns an object representing the compile-time evaluation of an expression:::return->getResult
ElementAvailableCall#getResult():::Returns the result that this function will return:::try->arg->argument->qname->arg->getValue->index->qname->indexOf->localName->qname->substring->return->getParser->arg->getNamespace->elementSupported->catch->return->finally
ElementAvailableCall#translate(ClassGenerator, MethodGenerator):::Calls to 'element-available' are resolved at compile time since the namespaces declared in the stylsheet are not available at run time:::cpg->classGen->getConstantPool->result->getResult->methodGen->getInstructionList->new->PUSH->append
EqualityExpr#setParser(Parser)::: equality expr set parser:::super->setParser->_left->setParser->_right->setParser
EqualityExpr#toString()::: equality expr to string:::return->Operators->getOpNames
EqualityExpr#getLeft()::: equality expr get left:::return
EqualityExpr#getRight()::: equality expr get right:::return
EqualityExpr#getOp()::: equality expr get op:::return
EqualityExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::if->_left->hasPositionCall->return->if->_right->hasPositionCall->return->return
EqualityExpr#hasLastCall()::: equality expr has last call:::if->_left->hasLastCall->return->if->_right->hasLastCall->return->return
EqualityExpr#swapArguments()::: equality expr swap arguments:::temp
EqualityExpr#typeCheck(SymbolTable):::Typing rules: see XSLT Reference by M:::tleft->_left->typeCheck->tright->_right->typeCheck->if->tleft->isSimple->tright->isSimple->if->if->new->CastExpr->else->if->new->CastExpr->else->if->new->CastExpr->new->CastExpr->else->new->CastExpr->new->CastExpr->else->if->new->CastExpr->else->if->new->CastExpr->else->if->new->CastExpr->else->if->new->CastExpr->else->if->new->CastExpr->new->CastExpr->else->if->else->if->swapArguments->else->if->new->CastExpr->if->new->CastExpr->if->tleft->isSimple->swapArguments->if->_right->getType->new->CastExpr->return
EqualityExpr#translateDesynthesized(ClassGenerator, MethodGenerator)::: equality expr translate desynthesized:::tleft->_left->getType->il->methodGen->getInstructionList->if->_left->translate->_right->translate->_falseList->il->new->IF_ICMPNE->new->IF_ICMPEQ->append->add->else->if->_left->translate->_right->translate->if->il->append->_falseList->il->new->IFNE->new->IFEQ->append->add->else->_falseList->il->new->IF_ICMPNE->new->IF_ICMPEQ->append->add->else->translate->desynthesize
EqualityExpr#translate(ClassGenerator, MethodGenerator)::: equality expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->tleft->_left->getType->tright->_right->getType->if->translateDesynthesized->synthesize->return->if->equals->cpg->addMethodref->_left->translate->_right->translate->il->new->INVOKEVIRTUAL->append->if->il->append->il->append->return->truec->falsec->if->if->_right->translate->if->il->append->il->append->return->if->_left->translate->tleft->translateTo->_right->translate->il->append->il->new->IFNE->new->IFEQ->append->il->append->il->new->GOTO->append->falsec->il->append->setTarget->truec->il->append->setTarget->return->_left->translate->tleft->translateTo->_right->translate->if->tright->translateTo->equals->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->if->il->append->il->append->return->if->_left->translate->_left->startIterator->translateTo->_right->translate->il->append->if->il->append->il->append->return->if->_left->translate->_left->startIterator->_right->translate->il->new->PUSH->append->il->methodGen->loadDOM->append->cmp->cpg->tleft->toSignature->tright->toSignature->addMethodref->il->new->INVOKESTATIC->append->return->_left->translate->_left->startIterator->_right->translate->_right->startIterator->if->tright->translateTo->il->new->PUSH->append->il->methodGen->loadDOM->append->compare->cpg->tleft->toSignature->tright->toSignature->addMethodref->il->new->INVOKESTATIC->append
Expression#getType()::: expression get type:::return
Expression#toString()::: expression to string:::
Expression#hasPositionCall()::: expression has position call:::return
Expression#hasLastCall()::: expression has last call:::return
Expression#evaluateAtCompileTime():::Returns an object representing the compile-time evaluation of an expression:::return
Expression#typeCheck(SymbolTable):::Type check all the children of this node.:::return->typeCheckContents
Expression#translate(ClassGenerator, MethodGenerator):::Translate this node into JVM bytecodes.:::msg->getClass->new->ErrorMsg->getParser->reportError
Expression#compile(ClassGenerator, MethodGenerator):::Translate this node into a fresh instruction list:::result->save->methodGen->getInstructionList->methodGen->new->InstructionList->setInstructionList->translate->methodGen->setInstructionList->return
Expression#translateDesynthesized(ClassGenerator, MethodGenerator):::Redefined by expressions of type boolean that use flow lists.:::translate->if->desynthesize
Expression#startIterator(ClassGenerator, MethodGenerator):::If this expression is of type node-set and it is not a variable reference, then call setStartNode() passing the context node.:::if->return->expr->if->getExpr->if->il->methodGen->getInstructionList->il->methodGen->loadContextNode->append->il->methodGen->setStartNode->append
Expression#synthesize(ClassGenerator, MethodGenerator):::Synthesize a boolean expression, i.e., either push a 0 or 1 onto the operand stack for the next statement to succeed:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_trueList->il->append->backPatch->truec->il->new->GOTO_W->append->_falseList->il->append->backPatch->truec->il->append->setTarget
Expression#desynthesize(ClassGenerator, MethodGenerator)::: expression desynthesize:::il->methodGen->getInstructionList->_falseList->il->new->IFEQ->append->add
Expression#getFalseList()::: expression get false list:::return
Expression#getTrueList()::: expression get true list:::return
Expression#backPatchFalseList(InstructionHandle)::: expression back patch false list:::_falseList->backPatch
Expression#backPatchTrueList(InstructionHandle)::: expression back patch true list:::_trueList->backPatch
Expression#lookupPrimop(SymbolTable, String, MethodType):::Search for a primop in the symbol table that matches the method type ctype:::result->primop->stable->lookupPrimop->if->n->primop->size->minDistance->for->i->return
Fallback#typeCheck(SymbolTable):::This element never produces any data on the stack:::if->return->typeCheckContents->else->return
Fallback#activate():::Activate this fallback element:::
Fallback#toString()::: fallback to string:::return
Fallback#parseContents(Parser):::Parse contents only if this fallback element is put in place of some unsupported element or non-XSLTC extension element:::if->parseChildren
Fallback#translate(ClassGenerator, MethodGenerator):::Translate contents only if this fallback element is put in place of some unsupported element or non-XSLTC extension element:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->translateContents
FilteredAbsoluteLocationPath#setParser(Parser)::: filtered absolute location path set parser:::super->setParser->if->_path->setParser
FilteredAbsoluteLocationPath#getPath()::: filtered absolute location path get path:::return
FilteredAbsoluteLocationPath#toString()::: filtered absolute location path to string:::return->_path->toString
FilteredAbsoluteLocationPath#typeCheck(SymbolTable)::: filtered absolute location path type check:::if->ptype->_path->typeCheck->if->new->CastExpr->return
FilteredAbsoluteLocationPath#translate(ClassGenerator, MethodGenerator)::: filtered absolute location path translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->initDFI->cpg->addMethodref->pathTemp->methodGen->Util->getJCRefType->addLocalVariable->_path->translate->pathTemp->il->pathTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->pathTemp->il->pathTemp->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append->else->git->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->INVOKEINTERFACE->append
FilterExpr#getExpr()::: filter expr get expr:::if->return->getExpr->else->return
FilterExpr#setParser(Parser)::: filter expr set parser:::super->setParser->_primary->setParser->if->n->_predicates->size->for->i
FilterExpr#toString()::: filter expr to string:::return
FilterExpr#typeCheck(SymbolTable):::Type check a FilterParentPath:::ptype->_primary->typeCheck->canOptimize->if->if->new->CastExpr->else->throw->new->TypeCheckError->n->_predicates->size->for->i->return
FilterExpr#translate(ClassGenerator, MethodGenerator):::Translate a filter expression by pushing the appropriate iterator onto the stack.:::_predicates->size->translateFilterExpr
FilterExpr#translateFilterExpr(ClassGenerator, MethodGenerator, int)::: filter expr translate filter expr:::if->translatePredicates->else->_primary->translate
FilterExpr#translatePredicates(ClassGenerator, MethodGenerator, int):::Translate a sequence of predicates:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->translateFilterExpr->else->predicate->_predicates->get->translatePredicates->if->predicate->isNthPositionFilter->nthIteratorIdx->cpg->addMethodref->iteratorTemp->methodGen->Util->getJCRefType->addLocalVariable->iteratorTemp->il->iteratorTemp->getIndex->new->ASTORE->append->setStart->predicate->translate->predicateValueTemp->methodGen->Util->getJCRefType->addLocalVariable->predicateValueTemp->il->predicateValueTemp->getIndex->new->ISTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->iteratorTemp->il->iteratorTemp->getIndex->new->ALOAD->append->setEnd->predicateValueTemp->il->predicateValueTemp->getIndex->new->ILOAD->append->setEnd->il->new->INVOKESPECIAL->append->else->initCNLI->cpg->addMethodref->nodeIteratorTemp->methodGen->Util->getJCRefType->addLocalVariable->nodeIteratorTemp->il->nodeIteratorTemp->getIndex->new->ASTORE->append->setStart->predicate->translate->filterTemp->methodGen->Util->getJCRefType->addLocalVariable->filterTemp->il->filterTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->nodeIteratorTemp->il->nodeIteratorTemp->getIndex->new->ALOAD->append->setEnd->il->append->filterTemp->il->filterTemp->getIndex->new->ALOAD->append->setEnd->il->methodGen->loadCurrentNode->append->il->classGen->loadTranslet->append->il->new->INVOKESPECIAL->append
FilterParentPath#setParser(Parser)::: filter parent path set parser:::super->setParser->_filterExpr->setParser->_path->setParser
FilterParentPath#toString()::: filter parent path to string:::return
FilterParentPath#setDescendantAxis()::: filter parent path set descendant axis:::
FilterParentPath#typeCheck(SymbolTable):::Type check a FilterParentPath:::ftype->_filterExpr->typeCheck->if->if->new->CastExpr->else->if->new->CastExpr->else->throw->new->TypeCheckError->ptype->_path->typeCheck->if->new->CastExpr->return
FilterParentPath#translate(ClassGenerator, MethodGenerator)::: filter parent path translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->initSI->cpg->addMethodref->_filterExpr->translate->filterTemp->methodGen->Util->getJCRefType->addLocalVariable->filterTemp->il->filterTemp->getIndex->new->ASTORE->append->setStart->_path->translate->pathTemp->methodGen->Util->getJCRefType->addLocalVariable->pathTemp->il->pathTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->filterTemp->il->filterTemp->getIndex->new->ALOAD->append->setEnd->pathTemp->il->pathTemp->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append->if->incl->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->parent->getParent->parentAlreadyOrdered->if->order->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->methodGen->loadContextNode->append->il->new->INVOKEINTERFACE->append
FloorCall#translate(ClassGenerator, MethodGenerator)::: floor call translate:::argument->translate->methodGen->getInstructionList->classGen->getConstantPool->addMethodref->new->INVOKESTATIC->append
FlowList#add(InstructionHandle)::: flow list add:::if->new->ArrayList<>->_elements->add->return
FlowList#append(FlowList)::: flow list append:::if->else->temp->if->n->temp->size->for->i->return
FlowList#backPatch(InstructionHandle):::Back patch a flow list:::if->n->_elements->size->for->i->_elements->clear
FlowList#copyAndRedirect(InstructionList, InstructionList):::Redirect the handles from oldList to newList:::result->new->FlowList->if->return->n->_elements->size->oldIter->oldList->iterator->newIter->newList->iterator->while->oldIter->hasNext->oldIh->oldIter->next->newIh->newIter->next->for->i->return
ForEach#display(int)::: for each display:::indent->Util->println->indent->Util->_select->toString->println->displayContents
ForEach#parseContents(Parser)::: for each parse contents:::parser->parseExpression->parseChildren->if->_select->isDummy->reportError
ForEach#typeCheck(SymbolTable)::: for each type check:::_select->typeCheck->if->new->CastExpr->typeCheckContents->return->if->typeCheckContents->return->throw->new->TypeCheckError
ForEach#translate(ClassGenerator, MethodGenerator)::: for each translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->methodGen->loadCurrentNode->append->il->methodGen->loadIterator->append->sortObjects->new->ArrayList<>->children->elements->while->children->hasNext->child->children->next->if->sortObjects->add->if->il->methodGen->loadDOM->append->if->sortObjects->size->msg->new->ErrorMsg->getParser->reportError->_select->translate->_type->translateTo->il->append->il->methodGen->storeDOM->append->else->if->sortObjects->size->Sort->translateSortIterator->else->_select->translate->if->il->methodGen->loadContextNode->append->il->methodGen->setStartNode->append->il->methodGen->storeIterator->append->initializeVariables->nextNode->il->new->GOTO->append->loop->il->append->translateContents->nextNode->il->methodGen->loadIterator->append->setTarget->il->methodGen->nextNode->append->il->append->il->methodGen->storeCurrentNode->append->il->new->IFGT->append->if->il->methodGen->storeDOM->append->il->methodGen->storeIterator->append->il->methodGen->storeCurrentNode->append
ForEach#initializeVariables(ClassGenerator, MethodGenerator):::The code that is generated by nested for-each loops can appear to some JVMs as if it is accessing un-initialized variables:::n->elementCount->for->i
FormatNumberCall#typeCheck(SymbolTable)::: format number call type check:::getStylesheet->numberFormattingUsed->tvalue->_value->typeCheck->if->new->CastExpr->tformat->_format->typeCheck->if->new->CastExpr->if->argumentCount->tname->_name->typeCheck->if->literal->getParser->literal->getValue->getQNameIgnoreDefaultNs->else->if->new->CastExpr->return
FormatNumberCall#translate(ClassGenerator, MethodGenerator)::: format number call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_value->translate->_format->translate->fn3arg->cpg->addMethodref->get->cpg->addMethodref->il->classGen->loadTranslet->append->if->il->new->PUSH->append->else->if->il->_resolvedQName->toString->new->PUSH->append->else->_name->translate->il->new->INVOKEVIRTUAL->append->il->new->INVOKESTATIC->append
FunctionAvailableCall#typeCheck(SymbolTable):::Argument of function-available call must be literal, typecheck returns the type of function-available to be boolean.:::if->return->if->return->err->new->ErrorMsg->throw->new->TypeCheckError
FunctionAvailableCall#evaluateAtCompileTime():::Returns an object representing the compile-time evaluation of an expression:::return->getResult
FunctionAvailableCall#hasMethods():::for external java functions only: reports on whether or not the specified method is found in the specifed class.:::className->getClassNameFromUri->methodName->colonIndex->_nameOfFunct->indexOf->if->functionName->_nameOfFunct->substring->lastDotIndex->functionName->lastIndexOf->if->functionName->substring->if->className->length->functionName->substring->else->functionName->substring->else->else->if->return->if->methodName->indexOf->replaceDash->try->clazz->ObjectFactory->findProviderClass->if->return->methods->clazz->getMethods->for->i->catch->return->finally->return
FunctionAvailableCall#getResult():::Reports on whether the function specified in the argument to xslt function 'function-available' was found.:::if->return->if->isInternalNamespace->parser->getParser->parser->Util->getLocalName->functionSupported->return
FunctionAvailableCall#isInternalNamespace():::Return true if the namespace uri is null or it is the XSLTC translet uri.:::return->_namespaceOfFunct->equals->_namespaceOfFunct->equals
FunctionAvailableCall#translate(ClassGenerator, MethodGenerator):::Calls to 'function-available' are resolved at compile time since the namespaces declared in the stylsheet are not available at run time:::cpg->classGen->getConstantPool->methodGen->getInstructionList->getResult->new->PUSH->append
FunctionCall.JavaType#hashCode()::: java type hash code:::return->Objects->hashCode
FunctionCall.JavaType#equals(Object)::: java type equals:::if->return->if->query->getClass->isAssignableFrom->return->equals->else->return->query->equals
FunctionCall#getName()::: function call get name:::return->_fname->toString
FunctionCall#setParser(Parser)::: function call set parser:::super->setParser->if->n->_arguments->size->for->i
FunctionCall#getClassNameFromUri(String)::: function call get class name from uri:::className->EXTENSIONNAMESPACE->get->if->return->else->if->uri->startsWith->length->JAVA_EXT_XSLTC->length->return->uri->length->uri->substring->else->if->uri->startsWith->length->JAVA_EXT_XALAN->length->return->uri->length->uri->substring->else->if->uri->startsWith->length->JAVA_EXT_XALAN_OLD->length->return->uri->length->uri->substring->else->index->uri->lastIndexOf->return->uri->substring
FunctionCall#typeCheck(SymbolTable):::Type check a function call:::if->return->namespace->_fname->getNamespace->local->_fname->getLocalPart->if->isExtension->new->QName->return->typeCheckStandard->else->if->isStandard->return->typeCheckStandard->else->try->getClassNameFromUri->pos->local->lastIndexOf->if->if->_className->length->local->substring->else->local->substring->local->substring->new->QName->else->if->_className->length->try->ObjectFactory->findProviderClass->catch->finally->else->if->local->indexOf->replaceDash->extFunction->EXTENSIONFUNCTION->get->if->new->QName->return->typeCheckStandard->else->new->QName->return->typeCheckExternal->catch->errorMsg->e->getErrorMsg->if->name->_fname->getLocalPart->new->ErrorMsg->getParser->reportError->return->finally
FunctionCall#typeCheckStandard(SymbolTable):::Type check a call to a standard function:::_fname->clearNamespace->n->_arguments->size->argsType->typeCheckArgs->args->new->MethodType->ptype->_fname->getLocalPart->lookupPrimop->if->for->i->return->ptype->resultType->throw->new->TypeCheckError
FunctionCall#typeCheckConstructor(SymbolTable)::: function call type check constructor:::constructors->findConstructors->if->throw->new->TypeCheckError->nConstructors->constructors->size->nArgs->_arguments->size->argsType->typeCheckArgs->bestConstrDistance->for->j->i->if->return->throw->getMethodSignature->new->TypeCheckError
FunctionCall#typeCheckExternal(SymbolTable):::Type check a call to an external (Java) method:::nArgs->_arguments->size->name->_fname->getLocalPart->if->_fname->getLocalPart->equals->return->typeCheckConstructor->else->hasThisArgument->if->if->if->firstArg->_arguments->get->firstArgType->firstArg->typeCheck->if->_clazz->getJavaClass->isAssignableFrom->if->_arguments->get->_arguments->remove->if->getJavaClassName->else->throw->new->TypeCheckError->else->if->_className->length->parser->getParser->if->_fname->toString->reportWarning->return->methods->findMethods->if->throw->new->TypeCheckError->extType->nMethods->methods->size->argsType->typeCheckArgs->bestMethodDistance->for->j->i->if->Modifier->_chosenMethod->getModifiers->isStatic->throw->getMethodSignature->new->TypeCheckError->if->if->getXSLTC->setMultiDocument->return->throw->getMethodSignature->new->TypeCheckError
FunctionCall#typeCheckArgs(SymbolTable):::Type check the actual arguments of this function call.:::result->new->ArrayList<>->foreach->result->exp->typeCheck->add->return
FunctionCall#argument(int)::: function call argument:::return->_arguments->get
FunctionCall#argument()::: function call argument:::return->argument
FunctionCall#argumentCount()::: function call argument count:::return->_arguments->size
FunctionCall#setArgument(int, Expression)::: function call set argument:::_arguments->set
FunctionCall#translateDesynthesized(ClassGenerator, MethodGenerator):::Compile the function call and treat as an expression Update true/false-lists.:::type->if->_chosenMethodType->resultType->il->methodGen->getInstructionList->translate->if->_falseList->il->new->IFEQ->append->add
FunctionCall#translate(ClassGenerator, MethodGenerator):::Translate a function call:::n->argumentCount->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->isSecureProcessing->classGen->getParser->getXSLTC->isSecureProcessing->isExtensionFunctionEnabled->classGen->getParser->getXSLTC->getFeature->index->if->isStandard->isExtension->for->i->name->_fname->toString->replace->args->if->name->equals->il->methodGen->loadDOM->append->else->if->name->equals->if->_chosenMethodType->toSignature->equals->il->methodGen->loadContextNode->append->il->methodGen->loadDOM->append->cpg->_chosenMethodType->toSignature->addMethodref->il->new->INVOKESTATIC->append->else->if->cpg->addMethodref->il->_fname->toString->new->PUSH->append->il->new->INVOKESTATIC->append->else->if->if->translateUnallowedExtension->clazz->_chosenConstructor->getDeclaringClass->getName->generateAddReads->paramTypes->_chosenConstructor->getParameterTypes->paramTemp->new->LocalVariableGenArr->for->i->il->cpg->addClass->new->NEW->append->il->append->for->i->buffer->new->StringBuffer->buffer->append->for->i->buffer->append->buffer->append->cpg->buffer->toString->addMethodref->il->new->INVOKESPECIAL->append->_chosenConstructor->getDeclaringClass->translateFrom->else->if->translateUnallowedExtension->clazz->_chosenMethod->getDeclaringClass->getName->paramTypes->_chosenMethod->getParameterTypes->generateAddReads->if->_thisArgument->translate->for->i->buffer->new->StringBuffer->buffer->append->for->i->buffer->append->buffer->_chosenMethod->getReturnType->getSignature->append->if->_clazz->isInterface->cpg->_fname->getLocalPart->buffer->toString->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->else->cpg->_fname->getLocalPart->buffer->toString->addMethodref->il->new->INVOKEVIRTUAL->new->INVOKESTATIC->append->_type->_chosenMethod->getReturnType->translateFrom
FunctionCall#generateAddReads(ClassGenerator, MethodGenerator, String)::: function call generate add reads:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->methodGen->markChunkStart->index->cpg->addMethodref->index2->cpg->addMethodref->il->cpg->classGen->getClassName->addString->new->LDC->append->il->new->INVOKESTATIC->append->il->new->INVOKEVIRTUAL->append->il->cpg->addString->new->LDC->append->il->new->INVOKESTATIC->append->il->new->INVOKEVIRTUAL->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->il->append->methodGen->markChunkEnd
FunctionCall#toString()::: function call to string:::return
FunctionCall#isStandard()::: function call is standard:::namespace->_fname->getNamespace->return->namespace->equals
FunctionCall#isExtension()::: function call is extension:::namespace->_fname->getNamespace->return->namespace->equals
FunctionCall#findMethods():::Returns a vector with all methods named _fname after stripping its namespace or null if no such methods exist.:::result->namespace->_fname->getNamespace->if->_className->length->nArgs->_arguments->size->try->if->isSecureProcessing->getXSLTC->isSecureProcessing->isExtensionFunctionEnabled->getXSLTC->getFeature->if->namespace->startsWith->namespace->startsWith->namespace->startsWith->namespace->startsWith->getXSLTC->loadExternalFunction->else->ObjectFactory->findProviderClass->if->msg->new->ErrorMsg->getParser->reportError->methodName->_fname->getLocalPart->methods->_clazz->getMethods->for->i->catch->msg->new->ErrorMsg->getParser->reportError->finally->return
FunctionCall#findConstructors():::Returns a vector with all constructors named _fname after stripping its namespace or null if no such methods exist.:::result->nArgs->_arguments->size->try->if->ObjectFactory->findProviderClass->if->msg->new->ErrorMsg->getParser->reportError->constructors->_clazz->getConstructors->foreach->mods->constructor->getModifiers->if->Modifier->isPublic->constructor->getParameterTypes->if->new->ArrayList<>->result->add->catch->msg->new->ErrorMsg->getParser->reportError->finally->return
FunctionCall#getSignature(Class):::Compute the JVM signature for the class.:::if->clazz->isArray->sb->new->StringBuffer->cl->while->cl->isArray->sb->append->cl->getComponentType->sb->getSignature->append->return->sb->toString->else->if->clazz->isPrimitive->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->name->clazz->toString->err->new->ErrorMsg->throw->err->toString->new->Error->else->return->clazz->getName->replace
FunctionCall#getSignature(Method):::Compute the JVM method descriptor for the method.:::sb->new->StringBuffer->sb->append->params->meth->getParameterTypes->for->j->return->sb->append->meth->getReturnType->getSignature->append->toString
FunctionCall#getSignature(Constructor):::Compute the JVM constructor descriptor for the constructor.:::sb->new->StringBuffer->sb->append->params->cons->getParameterTypes->for->j->return->sb->append->toString
FunctionCall#getMethodSignature(List):::Return the signature of the current method:::buf->new->StringBuffer->buf->append->_fname->getLocalPart->append->append->nArgs->argsType->size->for->i->buf->append->return->buf->toString
FunctionCall#replaceDash(String):::To support EXSLT extensions, convert names with dash to allowable Java names: e.g., convert abc-xyz to abcXyz:::dash->buff->new->StringBuilder->for->i->name->length->return->buff->toString
FunctionCall#translateUnallowedExtension(ConstantPoolGen, InstructionList):::Translate code to call the BasisLibrary.unallowed_extensionF(String) method.:::index->cpg->addMethodref->il->_fname->toString->new->PUSH->append->il->new->INVOKESTATIC->append
GenerateIdCall#translate(ClassGenerator, MethodGenerator)::: generate id call translate:::il->methodGen->getInstructionList->if->argumentCount->il->methodGen->loadContextNode->append->else->argument->translate->cpg->classGen->getConstantPool->il->cpg->addMethodref->new->INVOKESTATIC->append
IdKeyPattern#getIndexName()::: id key pattern get index name:::return
IdKeyPattern#typeCheck(SymbolTable)::: id key pattern type check:::return
IdKeyPattern#isWildcard()::: id key pattern is wildcard:::return
IdKeyPattern#setLeft(RelativePathPattern)::: id key pattern set left:::
IdKeyPattern#getKernelPattern()::: id key pattern get kernel pattern:::return
IdKeyPattern#reduceKernelPattern()::: id key pattern reduce kernel pattern:::
IdKeyPattern#toString()::: id key pattern to string:::return
IdKeyPattern#translate(ClassGenerator, MethodGenerator):::This method is called when the constructor is compiled in Stylesheet.compileConstructor() and not as the syntax tree is traversed.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getKeyIndex->cpg->addMethodref->lookupId->cpg->addMethodref->lookupKey->cpg->addMethodref->getNodeIdent->cpg->addInterfaceMethodref->il->classGen->loadTranslet->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->il->append->il->new->PUSH->append->if->il->new->INVOKEVIRTUAL->append->else->il->new->INVOKEVIRTUAL->append->_trueList->il->new->IFNE->append->add->_falseList->il->new->GOTO->append->add
If#display(int):::Display the contents of this element:::indent->Util->println->indent->print->Util->_test->toString->println->displayContents
If#parseContents(Parser):::Parse the "test" expression and contents of this element.:::parser->parseExpression->if->_test->isDummy->reportError->return->result->_test->evaluateAtCompileTime->if->booleanValue->parseChildren
If#typeCheck(SymbolTable):::Type-check the "test" expression and contents of this element:::if->_test->typeCheck->new->CastExpr->if->typeCheckContents->return
If#translate(ClassGenerator, MethodGenerator):::Translate the "test" expression and contents of this element:::il->methodGen->getInstructionList->_test->translateDesynthesized->truec->il->getEnd->if->translateContents->_test->il->append->backPatchFalseList->_test->truec->getNext->backPatchTrueList
Import#getImportedStylesheet()::: import get imported stylesheet:::return
Import#parseContents(Parser)::: import parse contents:::xsltc->parser->getXSLTC->context->parser->getCurrentStylesheet->try->docToLoad->getAttribute->if->context->checkForLoop->msg->new->ErrorMsg->parser->reportError->return->input->reader->currLoadedDoc->context->getSystemId->loader->context->getSourceLoader->if->loader->loadSource->if->input->getSystemId->xsltc->getXMLReader->else->if->parser->errorsFound->return->if->SystemIDResolver->getAbsoluteURI->accessError->SecuritySupport->xsltc->getProperty->checkAccess->if->msg->SecuritySupport->sanitizePath->new->ErrorMsg->parser->reportError->return->new->InputSource->if->msg->new->ErrorMsg->parser->reportError->return->root->if->parser->parse->else->parser->parse->if->return->parser->makeStylesheet->if->return->_imported->setSourceLoader->_imported->setSystemId->_imported->setParentStylesheet->_imported->setImportingStylesheet->_imported->context->getTemplateInlining->setTemplateInlining->currPrecedence->parser->getCurrentImportPrecedence->nextPrecedence->parser->getNextImportPrecedence->_imported->setImportPrecedence->context->setImportPrecedence->parser->setCurrentStylesheet->_imported->parseContents->elements->_imported->elements->topStylesheet->parser->getTopLevelStylesheet->while->elements->hasNext->element->elements->next->if->if->topStylesheet->addVariable->else->if->topStylesheet->addParam->else->topStylesheet->addElement->catch->e->printStackTrace->finally->parser->setCurrentStylesheet
Import#typeCheck(SymbolTable)::: import type check:::return
Import#translate(ClassGenerator, MethodGenerator)::: import translate:::
Include#getIncludedStylesheet()::: include get included stylesheet:::return
Include#parseContents(Parser)::: include parse contents:::xsltc->parser->getXSLTC->context->parser->getCurrentStylesheet->docToLoad->getAttribute->try->if->context->checkForLoop->msg->new->ErrorMsg->parser->reportError->return->input->reader->currLoadedDoc->context->getSystemId->loader->context->getSourceLoader->if->loader->loadSource->if->input->getSystemId->xsltc->getXMLReader->else->if->parser->errorsFound->return->if->SystemIDResolver->getAbsoluteURI->accessError->SecuritySupport->xsltc->getProperty->checkAccess->if->msg->SecuritySupport->sanitizePath->new->ErrorMsg->parser->reportError->return->new->InputSource->if->msg->new->ErrorMsg->parser->reportError->return->root->if->parser->parse->else->parser->parse->if->return->parser->makeStylesheet->if->return->_included->setSourceLoader->_included->setSystemId->_included->setParentStylesheet->_included->setIncludingStylesheet->_included->context->getTemplateInlining->setTemplateInlining->precedence->context->getImportPrecedence->_included->setImportPrecedence->parser->setCurrentStylesheet->_included->parseContents->elements->_included->elements->topStylesheet->parser->getTopLevelStylesheet->while->elements->hasNext->element->elements->next->if->if->topStylesheet->addVariable->else->if->topStylesheet->addParam->else->topStylesheet->addElement->catch->e->printStackTrace->finally->parser->setCurrentStylesheet
Include#typeCheck(SymbolTable)::: include type check:::return
Include#translate(ClassGenerator, MethodGenerator)::: include translate:::
Instruction#typeCheck(SymbolTable):::Type check all the children of this node.:::return->typeCheckContents
Instruction#translate(ClassGenerator, MethodGenerator):::Translate this node into JVM bytecodes.:::msg->getClass->new->ErrorMsg->getParser->reportError
IntExpr#typeCheck(SymbolTable)::: int expr type check:::return
IntExpr#toString()::: int expr to string:::return
IntExpr#translate(ClassGenerator, MethodGenerator)::: int expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
Key#parseContents(Parser):::Parse the <xsl:key> element and attributes:::name->getAttribute->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->getSymbolTable->addKey->parser->parsePattern->parser->parseExpression->if->reportError->return->if->_match->isDummy->reportError->return->if->_use->isDummy->reportError->return
Key#getName():::Returns a String-representation of this key's name:::return->_name->toString
Key#typeCheck(SymbolTable)::: key type check:::_match->typeCheck->_use->typeCheck->if->new->CastExpr->return
Key#traverseNodeSet(ClassGenerator, MethodGenerator, int):::This method is called if the "use" attribute of the key contains a node set:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getNodeValue->cpg->addInterfaceMethodref->getNodeIdent->cpg->addInterfaceMethodref->keyDom->cpg->addMethodref->parentNode->methodGen->Util->getJCRefType->addLocalVariable->parentNode->il->parentNode->getIndex->new->ISTORE->append->setStart->il->methodGen->loadCurrentNode->append->il->methodGen->loadIterator->append->_use->translate->_use->startIterator->il->methodGen->storeIterator->append->nextNode->il->new->GOTO->append->loop->il->append->il->classGen->loadTranslet->append->il->_name->toString->new->PUSH->append->parentNode->il->parentNode->getIndex->new->ILOAD->append->setEnd->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->new->INVOKEINTERFACE->append->il->new->INVOKEVIRTUAL->append->il->classGen->loadTranslet->append->il->getName->new->PUSH->append->il->methodGen->loadDOM->append->il->new->INVOKEVIRTUAL->append->nextNode->il->methodGen->loadIterator->append->setTarget->il->methodGen->nextNode->append->il->append->il->methodGen->storeCurrentNode->append->il->new->IFGE->append->il->methodGen->storeIterator->append->il->methodGen->storeCurrentNode->append
Key#translate(ClassGenerator, MethodGenerator):::Gather all nodes that match the expression in the attribute "match" and add one (or more) entries in this key's index.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->current->methodGen->getLocalIndex->key->cpg->addMethodref->keyDom->cpg->addMethodref->getNodeIdent->cpg->addInterfaceMethodref->git->cpg->addInterfaceMethodref->il->methodGen->loadCurrentNode->append->il->methodGen->loadIterator->append->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->il->methodGen->loadCurrentNode->append->il->methodGen->setStartNode->append->il->methodGen->storeIterator->append->nextNode->il->new->GOTO->append->loop->il->append->il->methodGen->loadCurrentNode->append->_match->translate->_match->synthesize->skipNode->il->new->IFEQ->append->if->il->methodGen->loadCurrentNode->append->traverseNodeSet->else->il->classGen->loadTranslet->append->il->append->il->_name->toString->new->PUSH->append->il->append->il->methodGen->loadCurrentNode->append->_use->translate->il->new->INVOKEVIRTUAL->append->il->methodGen->loadDOM->append->il->new->INVOKEVIRTUAL->append->skip->il->append->il->methodGen->loadIterator->append->il->methodGen->nextNode->append->il->append->il->methodGen->storeCurrentNode->append->il->new->IFGT->append->il->methodGen->storeIterator->append->il->methodGen->storeCurrentNode->append->nextNode->setTarget->skipNode->setTarget
KeyCall#addParentDependency():::If this call to key() is in a top-level element like  another variable or param, add a dependency between that top-level element and the referenced key:::if->return->node->while->node->getParent->parent->if->parent->getSymbolTable->getKey->addDependency
KeyCall#typeCheck(SymbolTable):::Type check the parameters for the id() or key() function:::returnType->super->typeCheck->if->nameType->_name->typeCheck->if->literal->getParser->literal->getValue->getQNameIgnoreDefaultNs->else->if->new->CastExpr->_value->typeCheck->if->new->CastExpr->_value->typeCheck->addParentDependency->return
KeyCall#translate(ClassGenerator, MethodGenerator):::This method is called when the constructor is compiled in Stylesheet.compileConstructor() and not as the syntax tree is traversed:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getKeyIndex->cpg->addMethodref->keyDom->cpg->addMethodref->getKeyIterator->cpg->_valueType->toSignature->addMethodref->il->classGen->loadTranslet->append->if->il->new->PUSH->append->else->if->il->_resolvedQName->toString->new->PUSH->append->else->_name->translate->il->new->INVOKEVIRTUAL->append->il->append->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->new->INVOKEVIRTUAL->append->_value->translate->il->append->il->new->INVOKEVIRTUAL->append
LangCall#typeCheck(SymbolTable)::: lang call type check:::_lang->typeCheck->if->new->CastExpr->return
LangCall#getType()::: lang call get type:::return
LangCall#translate(ClassGenerator, MethodGenerator):::This method is called when the constructor is compiled in Stylesheet.compileConstructor() and not as the syntax tree is traversed.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->tst->cpg->addMethodref->_lang->translate->il->methodGen->loadDOM->append->if->il->new->ILOAD->append->else->il->methodGen->loadContextNode->append->il->new->INVOKESTATIC->append
LastCall#hasPositionCall()::: last call has position call:::return
LastCall#hasLastCall()::: last call has last call:::return
LastCall#translate(ClassGenerator, MethodGenerator)::: last call translate:::il->methodGen->getInstructionList->if->il->loadLastNode->append->else->if->il->new->ILOAD->append->else->cpg->classGen->getConstantPool->getLast->cpg->addInterfaceMethodref->il->methodGen->loadIterator->append->il->new->INVOKEINTERFACE->append
LiteralAttribute#display(int)::: literal attribute display:::indent->Util->println
LiteralAttribute#typeCheck(SymbolTable)::: literal attribute type check:::_value->typeCheck->typeCheckContents->return
LiteralAttribute#contextDependent()::: literal attribute context dependent:::return->_value->contextDependent
LiteralAttribute#translate(ClassGenerator, MethodGenerator)::: literal attribute translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->methodGen->loadHandler->append->il->new->PUSH->append->_value->translate->parent->getParent->if->allAttributesUnique->flags->isHTMLAttrEmpty->elemDesc->getElemDesc->if->if->elemDesc->isAttrFlagSet->else->if->elemDesc->isAttrFlagSet->if->attrValue->toString->if->hasBadChars->il->new->PUSH->append->il->methodGen->uniqueAttribute->append->else->il->methodGen->attribute->append
LiteralAttribute#hasBadChars(String):::Return true if at least one character in the String is considered to be a "bad" character:::chars->value->toCharArray->size->for->i->return
LiteralAttribute#getName():::Return the name of the attribute:::return
LiteralAttribute#getValue():::Return the value of the attribute:::return
LiteralElement#getName():::Returns the QName for this literal element:::return
LiteralElement#display(int):::Displays the contents of this literal element:::indent->Util->println->displayContents
LiteralElement#accessedNamespace(String):::Returns the namespace URI for which a prefix is pointing to:::if->result->_literalElemParent->accessedNamespace->if->return->return->_accessedPrefixes->get
LiteralElement#registerNamespace(String, String, SymbolTable, boolean):::Method used to keep track of what namespaces that are references by this literal element and its attributes:::if->parentUri->_literalElemParent->accessedNamespace->if->parentUri->equals->return->if->new->Hashtable<>->else->if->old->_accessedPrefixes->get->if->if->old->equals->return->else->stable->generateNamespacePrefix->if->prefix->equals->_accessedPrefixes->put
LiteralElement#translateQName(QName, SymbolTable):::Translates the prefix of a QName according to the rules set in the attributes of xsl:stylesheet:::localname->qname->getLocalPart->prefix->qname->getPrefix->if->else->if->prefix->equals->return->alternative->stable->lookupPrefixAlias->if->stable->excludeNamespaces->uri->lookupNamespace->if->return->registerNamespace->if->return->else->return
LiteralElement#addAttribute(SyntaxTreeNode):::Add an attribute to this element:::if->new->ArrayList<>->_attributeElements->add
LiteralElement#setFirstAttribute(SyntaxTreeNode):::Set the first attribute of this element:::if->new->ArrayList<>->_attributeElements->add
LiteralElement#typeCheck(SymbolTable):::Type-check the contents of this element:::if->foreach->node->typeCheck->typeCheckContents->return
LiteralElement#getNamespaceScope(SyntaxTreeNode):::This method starts at a given node, traverses all namespace mappings, and assembles a list of all prefixes that (for the given node) maps to _ANY_ namespace URI:::all->new->HashMap<>->while->mapping->node->getPrefixMapping->if->mapping->entrySet->stream->all->entry->getKey->entry->getValue->putIfAbsent->forEach->node->getParent->return->all->entrySet
LiteralElement#parseContents(Parser):::Determines the final QName for the element and its attributes:::stable->parser->getSymbolTable->stable->setCurrentNode->parent->getParent->if->translateQName->count->_attributes->getLength->for->i->include->getNamespaceScope->foreach->prefix->entry->getKey->if->prefix->equals->uri->lookupNamespace->if->stable->isExcludedNamespace->registerNamespace->parseChildren->for->i
LiteralElement#contextDependent()::: literal element context dependent:::return->dependentContents
LiteralElement#translate(ClassGenerator, MethodGenerator):::Compiles code that emits the literal element to the output handler, first the start tag, then namespace declaration, then attributes, then the element contents, and then the element end tag:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->checkAttributesUnique->il->methodGen->loadHandler->append->il->new->PUSH->append->il->append->il->methodGen->startElement->append->j->while->elementCount->item->elementAt->if->item->translate->if->foreach->_accessedPrefixes->entrySet->prefix->entry->getKey->uri->entry->getValue->il->methodGen->loadHandler->append->il->new->PUSH->append->il->new->PUSH->append->il->methodGen->namespace->append->if->foreach->if->node->translate->translateContents->il->methodGen->endElement->append
LiteralElement#isHTMLOutput():::Return true if the output method is html.:::return->getStylesheet->getOutputMethod
LiteralElement#getElemDesc():::Return the ElemDesc object for an HTML element:::if->isHTMLOutput->return->ToHTMLStream->getElemDesc->else->return
LiteralElement#allAttributesUnique():::Return true if all attributes of this LRE have unique names.:::return
LiteralElement#checkAttributesUnique():::Check whether all attributes are unique.:::hasHiddenXslAttribute->canProduceAttributeNodes->if->return->if->numAttrs->_attributeElements->size->attrsTable->for->i->return
LiteralElement#canProduceAttributeNodes(SyntaxTreeNode, boolean):::Return true if the instructions under the given SyntaxTreeNode can produce attribute nodes to an element:::contents->node->getContents->foreach->if->text->if->text->isIgnore->continue->else->return->else->if->return->else->if->if->continue->else->return->else->if->return->else->if->canProduceAttributeNodes->return->else->if->chooseContents->child->getContents->foreach->if->if->canProduceAttributeNodes->return->return
LiteralExpr#typeCheck(SymbolTable)::: literal expr type check:::return
LiteralExpr#toString()::: literal expr to string:::return
LiteralExpr#contextDependent()::: literal expr context dependent:::return
LiteralExpr#getValue()::: literal expr get value:::return
LiteralExpr#getNamespace()::: literal expr get namespace:::return
LiteralExpr#translate(ClassGenerator, MethodGenerator)::: literal expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
LocalNameCall#translate(ClassGenerator, MethodGenerator):::This method is called when the constructor is compiled in Stylesheet.compileConstructor() and not as the syntax tree is traversed.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getNodeName->cpg->addInterfaceMethodref->getLocalName->cpg->addMethodref->super->translate->il->new->INVOKEINTERFACE->append->il->new->INVOKESTATIC->append
LocationPathPattern#typeCheck(SymbolTable)::: location path pattern type check:::return
LocationPathPattern#translate(ClassGenerator, MethodGenerator)::: location path pattern translate:::
LocationPathPattern#setTemplate(Template)::: location path pattern set template:::template->getPriority->template->getImportPrecedence->template->getPosition
LocationPathPattern#getTemplate()::: location path pattern get template:::return
LocationPathPattern#getPriority()::: location path pattern get priority:::return->Double->isNaN->getDefaultPriority
LocationPathPattern#getDefaultPriority()::: location path pattern get default priority:::return
LocationPathPattern#noSmallerThan(LocationPathPattern):::This method is used by the Mode class to prioritise patterns and template:::if->return->else->if->if->return->else->if->if->return->return
LocationPathPattern#getKernelPattern()::: location path pattern get kernel pattern:::
LocationPathPattern#reduceKernelPattern()::: location path pattern reduce kernel pattern:::
LocationPathPattern#isWildcard()::: location path pattern is wildcard:::
LocationPathPattern#getAxis()::: location path pattern get axis:::sp->getKernelPattern->return->sp->getAxis
LocationPathPattern#toString()::: location path pattern to string:::return
LogicalExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::return->_left->hasPositionCall->_right->hasPositionCall
LogicalExpr#hasLastCall():::Returns true if this expressions contains a call to last():::return->_left->hasLastCall->_right->hasLastCall
LogicalExpr#evaluateAtCompileTime():::Returns an object representing the compile-time evaluation of an expression:::leftb->_left->evaluateAtCompileTime->rightb->_right->evaluateAtCompileTime->if->return->if->return->else->return
LogicalExpr#getOp():::Returns this logical expression's operator - OR or AND represented by 0 and 1 respectively.:::return
LogicalExpr#setParser(Parser):::Override the SyntaxTreeNode.setParser() method to make sure that the parser is set for sub-expressions:::super->setParser->_left->setParser->_right->setParser
LogicalExpr#toString():::Returns a string describing this expression:::return
LogicalExpr#typeCheck(SymbolTable):::Type-check this expression, and possibly child expressions.:::tleft->_left->typeCheck->tright->_right->typeCheck->wantType->new->MethodType->haveType->lookupPrimop->if->arg1->haveType->argsType->get->if->arg1->identicalTo->new->CastExpr->arg2->haveType->argsType->get->if->arg2->identicalTo->new->CastExpr->return->haveType->resultType->throw->new->TypeCheckError
LogicalExpr#translate(ClassGenerator, MethodGenerator):::Compile the expression - leave boolean expression on stack:::translateDesynthesized->synthesize
LogicalExpr#translateDesynthesized(ClassGenerator, MethodGenerator):::Compile expression and update true/false-lists:::il->methodGen->getInstructionList->parent->getParent->if->_left->translateDesynthesized->middle->il->append->_right->translateDesynthesized->after->il->append->_falseList->append->append->if->getOp->_left->backPatchTrueList->else->if->_left->backPatchTrueList->else->_trueList->append->if->getOp->_right->backPatchTrueList->else->if->_right->backPatchTrueList->else->_trueList->append->else->_left->translateDesynthesized->ih->il->new->GOTO->append->_right->translateDesynthesized->backPatch->ih->getNext->backPatch->_falseList->append->_trueList->add->append
Message#parseContents(Parser)::: message parse contents:::termstr->getAttribute->if->termstr->equals->parseChildren
Message#typeCheck(SymbolTable)::: message type check:::typeCheckContents->return
Message#translate(ClassGenerator, MethodGenerator)::: message translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->classGen->loadTranslet->append->switch->elementCount->il->new->PUSH->append->break->child->elementAt->if->il->getText->new->PUSH->append->break->il->methodGen->loadHandler->append->il->cpg->addClass->new->NEW->append->il->methodGen->storeHandler->append->il->cpg->addClass->new->NEW->append->il->append->il->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->il->methodGen->loadHandler->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->il->methodGen->loadHandler->append->il->append->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->il->new->PUSH->append->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->il->append->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append->translateContents->il->methodGen->loadHandler->append->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->il->append->il->methodGen->storeHandler->append->break->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->if->einit->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->new->PUSH->append->il->new->INVOKESPECIAL->append->il->append
Mode#functionName():::Returns the name of the method (_not_ function) that will be compiled for this mode:::return
Mode#functionName(int, int)::: mode function name:::if->new->HashMap<>->_importLevels->put->return
Mode#getClassName():::Shortcut to get the class compiled for this mode (will be inlined).:::return->_stylesheet->getClassName
Mode#getStylesheet()::: mode get stylesheet:::return
Mode#addTemplate(Template)::: mode add template:::_templates->add
Mode#quicksort(List, int, int)::: mode quicksort:::if->q->partition->quicksort->quicksort->return
Mode#partition(List, int, int)::: mode partition:::x->templates->get->i->j->while->while->x->templates->get->compareTo->while->x->templates->get->compareTo->if->templates->templates->templates->get->set->set->else->return
Mode#processPatterns(Map):::Process all the test patterns in this mode:::_templates->size->quicksort->foreach->if->template->isNamed->template->disabled->_namedTemplates->put->pattern->template->getPattern->if->flattenAlternative->prepareTestSequences
Mode#flattenAlternative(Pattern, Template, Map):::This method will break up alternative patterns (ie:::if->idkey->idkey->setTemplate->if->new->ArrayList<>->_idxGroup->add->else->if->alt->alt->getLeft->flattenAlternative->alt->getRight->flattenAlternative->else->if->lpp->lpp->setTemplate->addPatternToGroup
Mode#addPatternToGroup(LocationPathPattern):::Group patterns by NodeTests of their last Step Keep them sorted by priority within group:::if->addPattern->else->kernel->lpp->getKernelPattern->if->kernel->getNodeType->addPattern->else->if->lpp->noSmallerThan
Mode#addPattern(int, LocationPathPattern):::Adds a pattern to a pattern group:::oldLength->if->newGroups->new->ArrayListArr->System->arraycopy->patterns->if->if->pattern->getAxis->new->ArrayList<>->else->new->ArrayList<>->else->new->ArrayList<>->if->patterns->size->patterns->add->else->inserted->for->i->patterns->size->if->patterns->add
Mode#completeTestSequences(int, List):::Complete test sequences of a given type by adding all patterns from a given group.:::if->if->else->m->patterns->size->for->j
Mode#prepareTestSequences():::Build test sequences:::starGroup->atStarGroup->completeTestSequences->completeTestSequences->completeTestSequences->completeTestSequences->completeTestSequences->names->_stylesheet->getXSLTC->getNamesIndex->if->n->for->i->names->size->new->TestSeqArr->n->for->i->if->_childNodeGroup->size->new->TestSeq->_childNodeTestSeq->reduce->_childNodeTestSeq->findTemplates->if->_idxGroup->size->new->TestSeq->_idxTestSeq->reduce->_idxTestSeq->findTemplates->if->_neededTemplates->_rootPattern->getTemplate->put
Mode#compileNamedTemplate(Template, ClassGenerator)::: mode compile named template:::cpg->classGen->getConstantPool->il->new->InstructionList->methodName->Util->template->getName->toString->escape->numParams->if->template->isSimpleNamedTemplate->parameters->template->getParameters->parameters->size->types->new->com.sun.org.apache.bcel.internal.generic.TypeArr->names->new->StringArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->for->i->methodGen->getClassName->new->NamedMethodGenerator->il->template->compile->append->il->append->classGen->addMethod
Mode#compileTemplates(ClassGenerator, MethodGenerator, InstructionHandle)::: mode compile templates:::templates->_namedTemplates->keySet->foreach->compileNamedTemplate->_neededTemplates->keySet->foreach->if->template->hasContents->til->template->compile->til->new->GOTO_W->append->_templateILs->put->_templateIHs->til->getStart->put->else->_templateIHs->put
Mode#appendTemplateCode(InstructionList)::: mode append template code:::foreach->_neededTemplates->keySet->iList->_templateILs->get->if->body->append
Mode#appendTestSequences(InstructionList)::: mode append test sequences:::n->for->i
Mode#compileGetChildren(ClassGenerator, MethodGenerator, int)::: mode compile get children:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->git->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->ILOAD->append->il->new->INVOKEINTERFACE->append
Mode#compileDefaultRecursion(ClassGenerator, MethodGenerator, InstructionHandle):::Compiles the default handling for DOM elements: traverse all children:::cpg->classGen->getConstantPool->il->new->InstructionList->applyTemplatesSig->classGen->getApplyTemplatesSig->git->cpg->addInterfaceMethodref->applyTemplates->cpg->getClassName->functionName->addMethodref->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadDOM->append->il->new->ILOAD->append->il->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->il->new->INVOKEVIRTUAL->append->il->new->GOTO_W->append->return
Mode#compileDefaultText(ClassGenerator, MethodGenerator, InstructionHandle):::Compiles the default action for DOM text nodes and attribute nodes: output the node's text value:::cpg->classGen->getConstantPool->il->new->InstructionList->chars->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->ILOAD->append->il->methodGen->loadHandler->append->il->new->INVOKEINTERFACE->append->il->new->GOTO_W->append->return
Mode#compileNamespaces(ClassGenerator, MethodGenerator, boolean[], boolean[], boolean, InstructionHandle)::: mode compile namespaces:::xsltc->classGen->getParser->getXSLTC->cpg->classGen->getConstantPool->namespaces->xsltc->getNamespaceIndex->names->xsltc->getNamesIndex->namespaceCount->namespaces->size->namesCount->names->size->il->new->InstructionList->types->new->intArr->targets->new->InstructionHandleArr->if->compiled->for->i->for->i->if->return->getNS->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->ILOAD->append->il->new->INVOKEINTERFACE->append->il->new->SWITCH->append->return->else->return
Mode#compileApplyTemplates(ClassGenerator):::Compiles the applyTemplates() method and adds it to the translet:::xsltc->classGen->getParser->getXSLTC->cpg->classGen->getConstantPool->names->xsltc->getNamesIndex->argTypes->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->new->StringArr->mainIL->new->InstructionList->methodGen->functionName->getClassName->classGen->getConstantPool->new->MethodGenerator->methodGen->addException->mainIL->append->current->methodGen->addLocalVariable2->current->getIndex->body->new->InstructionList->body->append->ilLoop->new->InstructionList->ilLoop->methodGen->loadIterator->append->ilLoop->methodGen->nextNode->append->ilLoop->append->ilLoop->new->ISTORE->append->ifeq->ilLoop->new->IFLT->append->loop->ilLoop->new->GOTO_W->append->ifeq->ilLoop->append->setTarget->ihLoop->ilLoop->getStart->current->mainIL->new->GOTO_W->append->setStart->current->setEnd->ilRecurse->compileDefaultRecursion->ihRecurse->ilRecurse->getStart->ilText->compileDefaultText->ihText->ilText->getStart->types->names->size->new->intArr->for->i->isAttribute->new->booleanArr->isNamespace->new->booleanArr->for->i->names->size->compileTemplates->elemTest->ihElem->if->elemTest->compile->attrTest->ihAttr->if->attrTest->compile->ilKey->if->loop->_idxTestSeq->body->getStart->compile->setTarget->_idxTestSeq->getInstructionList->else->loop->body->getStart->setTarget->if->nodePrio->_childNodeTestSeq->getPriority->nodePos->_childNodeTestSeq->getPosition->elemPrio->elemPos->if->elemTest->getPriority->elemTest->getPosition->if->_childNodeTestSeq->compile->textTest->textPrio->textPos->if->textTest->getPriority->textTest->getPosition->if->_childNodeTestSeq->compile->elemNamespaceHandle->nsElem->compileNamespaces->if->nsElem->getStart->attrNamespaceHandle->nsAttr->compileNamespaces->if->nsAttr->getStart->targets->new->InstructionHandleArr->for->i->_rootPattern->getTemplate->getTemplateInstructionHandle->_rootPattern->getTemplate->getTemplateInstructionHandle->compile->ihPI->if->if->compile->else->ihComment->if->compile->for->i->if->body->insert->getType->cpg->addInterfaceMethodref->body->methodGen->loadDOM->append->body->new->ILOAD->append->body->new->INVOKEINTERFACE->append->disp->body->new->SWITCH->append->appendTestSequences->appendTemplateCode->if->body->append->if->body->append->body->append->body->append->mainIL->append->mainIL->append->peepHoleOptimization->classGen->addMethod->if->foreach->_importLevels->entrySet->entry->getValue->entry->getKey->compileApplyImports
Mode#compileTemplateCalls(ClassGenerator, MethodGenerator, InstructionHandle, int, int)::: mode compile template calls:::_neededTemplates->keySet->stream->prec->template->getImportPrecedence->if->if->template->hasContents->til->template->compile->til->new->GOTO_W->append->_templateILs->put->_templateIHs->til->getStart->put->else->_templateIHs->put->forEach
Mode#compileApplyImports(ClassGenerator, int, int)::: mode compile apply imports:::xsltc->classGen->getParser->getXSLTC->cpg->classGen->getConstantPool->names->xsltc->getNamesIndex->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->ArrayListArr->oldTemplates->new->ArrayList<>->foreach->prec->template->getImportPrecedence->if->addTemplate->processPatterns->argTypes->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->new->StringArr->mainIL->new->InstructionList->methodGen->functionName->getClassName->classGen->getConstantPool->new->MethodGenerator->methodGen->addException->current->methodGen->addLocalVariable2->current->getIndex->mainIL->methodGen->getLocalIndex->new->ILOAD->append->current->mainIL->new->ISTORE->append->setStart->body->new->InstructionList->body->append->ilLoop->new->InstructionList->ilLoop->append->ihLoop->ilLoop->getStart->ilRecurse->compileDefaultRecursion->ihRecurse->ilRecurse->getStart->ilText->compileDefaultText->ihText->ilText->getStart->types->names->size->new->intArr->for->i->isAttribute->new->booleanArr->isNamespace->new->booleanArr->for->i->names->size->compileTemplateCalls->elemTest->ihElem->if->elemTest->compile->attrTest->ihAttr->if->attrTest->compile->ilKey->if->_idxTestSeq->getInstructionList->if->nodePrio->_childNodeTestSeq->getPriority->nodePos->_childNodeTestSeq->getPosition->elemPrio->elemPos->if->elemTest->getPriority->elemTest->getPosition->if->_childNodeTestSeq->compile->textTest->textPrio->textPos->if->textTest->getPriority->textTest->getPosition->if->_childNodeTestSeq->compile->elemNamespaceHandle->nsElem->compileNamespaces->if->nsElem->getStart->nsAttr->compileNamespaces->attrNamespaceHandle->if->nsAttr->getStart->targets->new->InstructionHandleArr->for->i->_rootPattern->getTemplate->getTemplateInstructionHandle->_rootPattern->getTemplate->getTemplateInstructionHandle->compile->ihPI->if->if->compile->else->ihComment->if->compile->for->i->if->body->insert->getType->cpg->addInterfaceMethodref->body->methodGen->loadDOM->append->body->new->ILOAD->append->body->new->INVOKEINTERFACE->append->disp->body->new->SWITCH->append->appendTestSequences->appendTemplateCode->if->body->append->if->body->append->body->append->body->append->mainIL->append->current->body->getEnd->setEnd->mainIL->append->peepHoleOptimization->classGen->addMethod
Mode#peepHoleOptimization(MethodGenerator):::Peephole optimization.:::il->methodGen->getInstructionList->find->new->InstructionFinder->ih->pattern->for->iter->find->search->iter->hasNext->for->iter->find->search->iter->hasNext->for->iter->find->search->iter->hasNext->for->iter->find->search->iter->hasNext
Mode#getTemplateInstructionHandle(Template)::: mode get template instruction handle:::return->_templateIHs->get
Mode#isAttributeName(String):::Auxiliary method to determine if a qname is an attribute.:::col->qname->lastIndexOf->return->qname->charAt
Mode#isNamespaceName(String):::Auxiliary method to determine if a qname is a namespace qualified "*".:::col->qname->lastIndexOf->return->qname->qname->length->charAt
NameBase#typeCheck(SymbolTable):::Check that we either have no parameters or one parameter that is either a node or a node-set.:::switch->argumentCount->break->_param->typeCheck->break->throw->new->TypeCheckError->if->throw->new->TypeCheckError->return
NameBase#getType()::: name base get type:::return
NameBase#translate(ClassGenerator, MethodGenerator):::Translate the code required for getting the node for which the QName, local-name or namespace URI should be extracted.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->methodGen->loadDOM->append->if->argumentCount->il->methodGen->loadContextNode->append->else->if->_param->translate->else->if->_param->translate->il->cpg->addMethodref->new->INVOKESTATIC->append->il->methodGen->nextNode->append->else->_param->translate->_param->startIterator->il->methodGen->nextNode->append
NameCall#translate(ClassGenerator, MethodGenerator):::Translate code that leaves a node's QName (as a String) on the stack:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getName->cpg->addInterfaceMethodref->super->translate->il->new->INVOKEINTERFACE->append
NamespaceAlias#parseContents(Parser)::: namespace alias parse contents:::getAttribute->getAttribute->parser->getSymbolTable->addPrefixAlias
NamespaceAlias#typeCheck(SymbolTable)::: namespace alias type check:::return
NamespaceAlias#translate(ClassGenerator, MethodGenerator)::: namespace alias translate:::
NamespaceUriCall#translate(ClassGenerator, MethodGenerator):::Translate code that leaves a node's namespace URI (as a String) on the stack:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->getNamespace->cpg->addInterfaceMethodref->super->translate->il->new->INVOKEINTERFACE->append
NotCall#translate(ClassGenerator, MethodGenerator)::: not call translate:::il->methodGen->getInstructionList->argument->translate->il->append->il->append
NotCall#translateDesynthesized(ClassGenerator, MethodGenerator)::: not call translate desynthesized:::il->methodGen->getInstructionList->exp->argument->exp->translateDesynthesized->gotoh->il->new->GOTO->append->_falseList->add
Number#inInnerClass():::Returns true if this closure is compiled in an inner class (i.e:::return
Number#getParentClosure():::Returns a reference to its parent closure or null if outermost.:::return
Number#getInnerClassName():::Returns the name of the auxiliary class or null if this predicate is compiled inside the Translet.:::return
Number#addVariable(VariableRefBase):::Add new variable to the closure.:::if->new->ArrayList<>->if->_closureVars->contains->_closureVars->add
Number#parseContents(Parser)::: number parse contents:::count->_attributes->getLength->for->i
Number#typeCheck(SymbolTable)::: number type check:::if->tvalue->_value->typeCheck->if->new->CastExpr->if->_count->typeCheck->if->_from->typeCheck->if->_format->typeCheck->if->_lang->typeCheck->if->_letterValue->typeCheck->if->_groupingSeparator->typeCheck->if->_groupingSize->typeCheck->return
Number#hasValue():::True if the has specified a value for this instance of number.:::return
Number#isDefault():::Returns <tt>true</tt> if this instance of number has neither a from nor a count pattern.:::return
Number#compileDefault(ClassGenerator, MethodGenerator)::: number compile default:::index->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->fieldIndexes->getXSLTC->getNumberFieldIndexes->if->defaultNode->cpg->addUtf8->cpg->addUtf8->cpg->getConstantPool->new->Field->classGen->addField->cpg->classGen->getClassName->addFieldref->il->classGen->loadTranslet->append->il->new->GETFIELD->append->ifBlock1->il->new->IFNONNULL->append->cpg->addMethodref->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->new->INVOKESTATIC->append->il->append->il->classGen->loadTranslet->append->il->append->il->new->PUTFIELD->append->ifBlock2->il->new->GOTO->append->ifBlock1->il->classGen->loadTranslet->append->setTarget->il->new->GETFIELD->append->ifBlock2->il->append->setTarget
Number#compileConstructor(ClassGenerator):::Compiles a constructor for the class <tt>_className</tt> that inherits from {Any,Single,Multiple}NodeCounter:::cons->il->new->InstructionList->cpg->classGen->getConstantPool->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->new->StringArr->new->MethodGenerator->il->append->il->append->il->append->il->new->ALOAD->append->il->new->ILOAD->append->index->cpg->addMethodref->il->new->INVOKESPECIAL->append->il->append->classGen->addMethod
Number#compileLocals(NodeCounterGenerator, MatchGenerator, InstructionList):::This method compiles code that is common to matchesFrom() and matchesCount() in the auxillary class.:::field->local->cpg->nodeCounterGen->getConstantPool->matchGen->Util->getJCRefType->addLocalVariable->cpg->addFieldref->il->append->il->new->GETFIELD->append->local->il->local->getIndex->new->ASTORE->append->setStart->matchGen->local->getIndex->setIteratorIndex->matchGen->Util->getJCRefType->addLocalVariable->cpg->addFieldref->il->append->il->new->GETFIELD->append->il->cpg->addClass->new->CHECKCAST->append->local->il->local->getIndex->new->ASTORE->append->setStart->nodeCounterGen->local->getIndex->setTransletIndex->matchGen->Util->getJCRefType->addLocalVariable->cpg->addFieldref->il->append->il->new->GETFIELD->append->local->il->local->getIndex->new->ASTORE->append->setStart->matchGen->local->getIndex->setDomIndex
Number#compilePatterns(ClassGenerator, MethodGenerator)::: number compile patterns:::current->field->local->matchGen->nodeCounterGen->getXSLTC->getHelperClassName->toString->classGen->getStylesheet->new->NodeCounterGenerator->il->cpg->nodeCounterGen->getConstantPool->closureLen->_closureVars->size->for->i->compileConstructor->if->new->InstructionList->new->com.sun.org.apache.bcel.internal.generic.TypeArr->new->StringArr->new->MatchGenerator->compileLocals->il->matchGen->loadContextNode->append->_from->translate->_from->synthesize->il->append->nodeCounterGen->addMethod->if->new->InstructionList->new->com.sun.org.apache.bcel.internal.generic.TypeArr->new->StringArr->new->MatchGenerator->compileLocals->il->matchGen->loadContextNode->append->_count->translate->_count->synthesize->il->append->nodeCounterGen->addMethod->getXSLTC->nodeCounterGen->getJavaClass->dumpClass->classGen->getConstantPool->methodGen->getInstructionList->index->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->append->il->new->INVOKESPECIAL->append->for->i
Number#translate(ClassGenerator, MethodGenerator)::: number translate:::index->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->classGen->loadTranslet->append->if->hasValue->compileDefault->_value->translate->il->new->PUSH->append->il->append->cpg->addMethodref->il->new->INVOKESTATIC->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->else->if->isDefault->compileDefault->else->compilePatterns->if->hasValue->il->methodGen->loadContextNode->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->if->if->_format->translate->else->il->new->PUSH->append->if->_lang->translate->else->il->new->PUSH->append->if->_letterValue->translate->else->il->new->PUSH->append->if->_groupingSeparator->translate->else->il->new->PUSH->append->if->_groupingSize->translate->else->il->new->PUSH->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->else->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->il->methodGen->loadHandler->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append
NumberCall#typeCheck(SymbolTable)::: number call type check:::if->argumentCount->argument->typeCheck->return
NumberCall#translate(ClassGenerator, MethodGenerator)::: number call translate:::il->methodGen->getInstructionList->targ->if->argumentCount->il->methodGen->loadContextNode->append->else->arg->argument->arg->translate->arg->startIterator->arg->getType->if->targ->identicalTo->targ->translateTo
Otherwise#display(int)::: otherwise display:::indent->Util->println->indent->displayContents
Otherwise#typeCheck(SymbolTable)::: otherwise type check:::typeCheckContents->return
Otherwise#translate(ClassGenerator, MethodGenerator)::: otherwise translate:::parser->getParser->err->new->ErrorMsg->parser->reportError
Output#display(int):::Displays the contents of this element (for debugging):::indent->Util->println
Output#disable():::Disables this <xsl:output> element in case where there are some other <xsl:output> element (from a different imported/included stylesheet) with higher precedence.:::
Output#enabled()::: output enabled:::return
Output#getCdata()::: output get cdata:::return
Output#getOutputMethod()::: output get output method:::return
Output#transferAttribute(Output, String)::: output transfer attribute:::if->hasAttribute->previous->hasAttribute->previous->getAttribute->addAttribute
Output#mergeOutput(Output)::: output merge output:::transferAttribute->transferAttribute->transferAttribute->transferAttribute->transferAttribute->transferAttribute->transferAttribute->transferAttribute->transferAttribute->if->previous->hasAttribute->previous->getAttribute->getAttribute->addAttribute->prefix->lookupPrefix->if->transferAttribute->lookupPrefix->if->transferAttribute
Output#parseContents(Parser):::Scans the attribute list for the xsl:output instruction:::outputProperties->new->Properties->parser->setOutput->if->return->attrib->getAttribute->if->_version->equals->else->outputProperties->setProperty->getAttribute->if->_method->equals->if->_method->toLowerCase->if->_method->equals->_method->equals->_method->equals->XML11Char->isXML11ValidQName->_method->indexOf->outputProperties->setProperty->else->reportError->getAttribute->if->_encoding->equals->else->try->canonicalEncoding->Encodings->convertMime2JavaEncoding->writer->new->OutputStreamWriter->catch->msg->new->ErrorMsg->parser->reportError->finally->outputProperties->setProperty->getAttribute->if->attrib->equals->if->attrib->equals->outputProperties->setProperty->getAttribute->if->_standalone->equals->else->outputProperties->setProperty->getAttribute->if->_doctypeSystem->equals->else->outputProperties->setProperty->getAttribute->if->_doctypePublic->equals->else->outputProperties->setProperty->getAttribute->if->_cdata->equals->else->expandedNames->new->StringBuffer->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->qname->tokens->nextToken->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->expandedNames->parser->getQName->toString->append->append->expandedNames->toString->outputProperties->setProperty->getAttribute->if->attrib->equals->if->attrib->equals->outputProperties->setProperty->else->if->_method->equals->lookupPrefix->getAttribute->if->_indentamount->equals->lookupPrefix->getAttribute->if->_indentamount->equals->outputProperties->setProperty->getAttribute->if->_mediaType->equals->else->outputProperties->setProperty->if->if->_method->equals->if->if->else->if->_method->equals->if->parser->getCurrentStylesheet->setOutputProperties
Output#translate(ClassGenerator, MethodGenerator):::Compile code that passes the information in this <xsl:output> element to the appropriate fields in the translet:::if->return->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->field->il->classGen->loadTranslet->append->if->_version->equals->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->cpg->addFieldref->il->append->il->new->PUSH->append->il->new->PUTFIELD->append->if->_indentamount->equals->cpg->addFieldref->il->append->il->Integer->parseInt->new->PUSH->append->il->new->PUTFIELD->append->if->index->cpg->addMethodref->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->il->append->il->tokens->nextToken->new->PUSH->append->il->new->INVOKEVIRTUAL->append->il->append
Param#toString():::Display variable as single string:::return
Param#setLoadInstruction(Instruction):::Set the instruction for loading the value of this variable onto the JVM stack and returns the old instruction.:::tmp->return
Param#setStoreInstruction(Instruction):::Set the instruction for storing a value from the stack into this variable and returns the old instruction.:::tmp->return
Param#display(int):::Display variable in a full AST dump:::indent->println->if->indent->_select->toString->println->displayContents
Param#parseContents(Parser):::Parse the contents of the <xsl:param> element:::super->parseContents->parent->getParent->if->param->parser->getSymbolTable->lookupParam->if->us->this->getImportPrecedence->them->param->getImportPrecedence->if->name->_name->toString->reportError->else->if->copyReferences->return->else->param->copyReferences->param->disable->addParam->parser->getSymbolTable->addParam->else->if->template->template->addParameter->if->template->isSimpleNamedTemplate
Param#typeCheck(SymbolTable):::Type-checks the parameter:::if->_select->typeCheck->if->new->CastExpr->else->if->hasContents->typeCheckContents->return
Param#translate(ClassGenerator, MethodGenerator)::: param translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->return->name->BasisLibrary->_name->toString->mapQNameToJavaName->signature->_type->toSignature->className->_type->getClassName->if->isLocal->if->il->loadInstruction->append->ifBlock->il->new->IFNONNULL->append->translateValue->il->storeInstruction->append->ifBlock->il->append->setTarget->return->il->classGen->loadTranslet->append->il->new->PUSH->append->translateValue->il->new->PUSH->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->if->il->cpg->addClass->new->CHECKCAST->append->_type->translateUnBox->if->_refs->isEmpty->il->_type->POP->append->else->methodGen->_type->toJCType->il->getEnd->addLocalVariable2->il->_type->_local->getIndex->STORE->append->else->if->classGen->containsField->classGen->cpg->addUtf8->cpg->addUtf8->cpg->getConstantPool->new->Field->addField->il->classGen->loadTranslet->append->il->append->il->new->PUSH->append->translateValue->il->new->PUSH->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->_type->translateUnBox->if->il->cpg->addClass->new->CHECKCAST->append->il->cpg->classGen->getClassName->addFieldref->new->PUTFIELD->append
ParameterRef#toString()::: parameter ref to string:::return->_variable->getName->_variable->getType
ParameterRef#translate(ClassGenerator, MethodGenerator)::: parameter ref translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->name->BasisLibrary->_name->toString->mapQNameToJavaName->signature->_type->toSignature->if->_variable->isLocal->if->classGen->isExternal->variableClosure->while->if->variableClosure->inInnerClass->break->variableClosure->getParentClosure->if->il->append->il->cpg->variableClosure->getInnerClassName->addFieldref->new->GETFIELD->append->else->il->_variable->loadInstruction->append->else->il->_variable->loadInstruction->append->else->className->classGen->getClassName->il->classGen->loadTranslet->append->if->classGen->isExternal->il->cpg->addClass->new->CHECKCAST->append->il->cpg->addFieldref->new->GETFIELD->append->if->_variable->getType->clone->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append
ParentLocationPath#setAxis(int)::: parent location path set axis:::_path->setAxis
ParentLocationPath#getAxis()::: parent location path get axis:::return->_path->getAxis
ParentLocationPath#getPath()::: parent location path get path:::return
ParentLocationPath#getStep()::: parent location path get step:::return
ParentLocationPath#setParser(Parser)::: parent location path set parser:::super->setParser->_step->setParser->_path->setParser
ParentLocationPath#toString()::: parent location path to string:::return
ParentLocationPath#typeCheck(SymbolTable)::: parent location path type check:::_step->typeCheck->_path->typeCheck->if->enableNodeOrdering->return
ParentLocationPath#enableNodeOrdering()::: parent location path enable node ordering:::parent->getParent->if->enableNodeOrdering->else
ParentLocationPath#checkAxisMismatch():::This method is used to determine if this parent location path is a combination of two step's with axes that will create duplicate or unordered nodes.:::left->_path->getAxis->right->getAxis->if->return->if->return->if->return->if->return->if->return->if->if->type->getNodeType->if->return->return
ParentLocationPath#translate(ClassGenerator, MethodGenerator)::: parent location path translate:::_path->translate->translateStep
ParentLocationPath#translateStep(ClassGenerator, MethodGenerator)::: parent location path translate step:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->pathTemp->methodGen->Util->getJCRefType->addLocalVariable->pathTemp->il->pathTemp->getIndex->new->ASTORE->append->setStart->_step->translate->stepTemp->methodGen->Util->getJCRefType->addLocalVariable->stepTemp->il->stepTemp->getIndex->new->ASTORE->append->setStart->initSI->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->pathTemp->il->pathTemp->getIndex->new->ALOAD->append->setEnd->stepTemp->il->stepTemp->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append->stp->if->getStep->if->path->getAxis->step->getAxis->if->incl->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->if->order->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->methodGen->loadContextNode->append->il->new->INVOKEINTERFACE->append
ParentPattern#setParser(Parser)::: parent pattern set parser:::super->setParser->_left->setParser->_right->setParser
ParentPattern#isWildcard()::: parent pattern is wildcard:::return
ParentPattern#getKernelPattern()::: parent pattern get kernel pattern:::return->_right->getKernelPattern
ParentPattern#reduceKernelPattern()::: parent pattern reduce kernel pattern:::_right->reduceKernelPattern
ParentPattern#typeCheck(SymbolTable)::: parent pattern type check:::_left->typeCheck->return->_right->typeCheck
ParentPattern#translate(ClassGenerator, MethodGenerator)::: parent pattern translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->local->methodGen->Util->getJCRefType->addLocalVariable2->loadLocal->local->getIndex->new->ILOAD->storeLocal->local->getIndex->new->ISTORE->if->_right->isWildcard->il->methodGen->loadDOM->append->il->append->else->if->il->append->local->il->append->setStart->_right->translate->il->methodGen->loadDOM->append->local->il->append->setEnd->else->_right->translate->if->il->methodGen->loadDOM->append->il->append->getParent->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->p->getParent->if->_left->translate->else->il->append->storeInst->il->append->if->local->getStart->local->setStart->_left->translate->il->methodGen->loadDOM->append->local->il->append->setEnd->methodGen->removeLocalVariable->if->ancestor->_left->ancestor->getLoopHandle->backPatchFalseList->_trueList->append->append->_falseList->append->append
ParentPattern#toString()::: parent pattern to string:::return
Parser#init()::: parser init:::new->HashMap<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->HashMap<>->new->ArrayList<>->new->ArrayList<>->new->SymbolTable->new->XPathParser->initStdClasses->initInstructionAttrs->initExtClasses->initSymbolTable->getQName->getQName->getQName
Parser#setOutput(Output)::: parser set output:::if->if->_output->getImportPrecedence->output->getImportPrecedence->output->mergeOutput->_output->disable->else->output->disable->else
Parser#getOutput()::: parser get output:::return
Parser#getOutputProperties()::: parser get output properties:::return->getTopLevelStylesheet->getOutputProperties
Parser#addVariable(Variable)::: parser add variable:::addVariableOrParam
Parser#addParameter(Param)::: parser add parameter:::addVariableOrParam
Parser#addVariableOrParam(VariableBase)::: parser add variable or param:::existing->_variableScope->var->getName->getStringRep->get->if->if->stack->stack->push->else->if->stack->new->Stack<>->stack->push->stack->push->_variableScope->var->getName->getStringRep->put->else->_variableScope->var->getName->getStringRep->put
Parser#removeVariable(QName)::: parser remove variable:::existing->_variableScope->name->getStringRep->get->if->stack->if->stack->isEmpty->stack->pop->if->stack->isEmpty->return->_variableScope->name->getStringRep->remove
Parser#lookupVariable(QName)::: parser lookup variable:::existing->_variableScope->name->getStringRep->get->if->return->else->if->stack->return->stack->peek->return
Parser#setXSLTC(XSLTC)::: parser set c:::
Parser#getXSLTC()::: parser get c:::return
Parser#getCurrentImportPrecedence()::: parser get current import precedence:::return
Parser#getNextImportPrecedence()::: parser get next import precedence:::return
Parser#setCurrentStylesheet(Stylesheet)::: parser set current stylesheet:::
Parser#getCurrentStylesheet()::: parser get current stylesheet:::return
Parser#getTopLevelStylesheet()::: parser get top level stylesheet:::return->_xsltc->getStylesheet
Parser#getQNameSafe(String)::: parser get name safe:::colon->stringRep->lastIndexOf->if->prefix->stringRep->substring->localname->stringRep->substring->namespace->if->prefix->equals->_symbolTable->lookupNamespace->if->return->getQName->else->uri->stringRep->equals->_symbolTable->lookupNamespace->return->getQName
Parser#getQName(String)::: parser get name:::return->getQName
Parser#getQNameIgnoreDefaultNs(String)::: parser get name ignore default ns:::return->getQName
Parser#getQName(String, boolean)::: parser get name:::return->getQName
Parser#getQName(String, boolean, boolean)::: parser get name:::colon->stringRep->lastIndexOf->if->prefix->stringRep->substring->localname->stringRep->substring->namespace->if->prefix->equals->_symbolTable->lookupNamespace->if->line->getLineNumber->err->new->ErrorMsg->reportError->return->getQName->else->if->stringRep->equals->defURI->_symbolTable->lookupNamespace->return->getQName
Parser#getQName(String, String, String)::: parser get name:::if->namespace->equals->name->_qNames->get->if->new->QName->_qNames->put->return->else->space->_namespaces->get->lexicalQName->prefix->length->if->name->new->QName->_namespaces->new->HashMap<>->put->space->put->return->else->name->space->get->if->new->QName->space->put->return
Parser#getQName(String, String)::: parser get name:::return->getQName
Parser#getQName(QName, QName)::: parser get name:::return->scope->toString->name->toString->getQName
Parser#getUseAttributeSets()::: parser get use attribute sets:::return
Parser#getExtensionElementPrefixes()::: parser get extension element prefixes:::return
Parser#getExcludeResultPrefixes()::: parser get exclude result prefixes:::return
Parser#makeStylesheet(SyntaxTreeNode):::Create an instance of the Stylesheet class, and then parse, typecheck and compile the instance:::try->stylesheet->if->else->new->Stylesheet->stylesheet->setSimplified->stylesheet->addElement->stylesheet->element->getAttributes->setAttributes->if->element->lookupNamespace->element->addPrefixMapping->stylesheet->setParser->return->catch->err->new->ErrorMsg->throw->err->toString->new->CompilerException->finally
Parser#createAST(Stylesheet):::Instanciates a SAX2 parser and generate the AST from the input.:::try->if->stylesheet->parseContents->elements->stylesheet->elements->while->elements->hasNext->child->elements->next->if->l->getLineNumber->err->new->ErrorMsg->reportError->if->errorsFound->stylesheet->typeCheck->catch->new->ErrorMsg->reportError->finally
Parser#parse(XMLReader, InputSource):::Parses a stylesheet and builds the internal abstract syntax tree:::try->reader->setContentHandler->reader->parse->return->getStylesheet->catch->if->_xsltc->debug->e->printStackTrace->new->ErrorMsg->reportError->ex->e->getException->if->_xsltc->debug->e->printStackTrace->if->ex->printStackTrace->new->ErrorMsg->reportError->if->_xsltc->debug->e->printStackTrace->new->ErrorMsg->reportError->if->_xsltc->debug->e->printStackTrace->new->ErrorMsg->reportError->finally->return
Parser#parse(InputSource):::Parses a stylesheet and builds the internal abstract syntax tree:::try->reader->JdkXmlUtils->_xsltc->isSecureProcessing->getXMLReader->JdkXmlUtils->_xsltc->getProperty->setXMLReaderPropertyIfSupport->supportCatalog->useCatalog->_xsltc->getFeature->try->reader->setFeature->catch->finally->if->try->cf->_xsltc->getProperty->if->foreach->values->reader->f->getPropertyName->cf->get->setProperty->catch->finally->lastProperty->try->securityManager->_xsltc->getProperty->foreach->values->limit->apiProperty->reader->securityManager->getLimitValueAsString->setProperty->if->securityManager->printEntityCountInfo->reader->setProperty->catch->XMLSecurityManager->reader->getClass->getName->printWarning->finally->JdkXmlUtils->_xsltc->getProperty->setXMLReaderPropertyIfSupport->return->parse->catch->e->getMessage->new->ErrorMsg->reportError->finally->return
Parser#getDocumentRoot()::: parser get document root:::return
Parser#setPIParameters(String, String, String):::Set the parameters to use to locate the correct <?xml-stylesheet ...?> processing instruction in the case where the input document is an XML document with one or more references to a stylesheet.:::
Parser#getStylesheet(SyntaxTreeNode):::Extracts the DOM for the stylesheet:::if->if->msg->new->ErrorMsg->throw->msg->toString->new->CompilerException->return->if->_target->charAt->element->_target->substring->findStylesheet->if->msg->new->ErrorMsg->throw->msg->toString->new->CompilerException->return->else->try->path->if->path->indexOf->SystemIDResolver->getAbsoluteURI->accessError->SecuritySupport->_xsltc->getProperty->checkAccess->if->msg->SecuritySupport->sanitizePath->new->ErrorMsg->throw->msg->toString->new->CompilerException->catch->throw->new->CompilerException->finally->return->loadExternalStylesheet
Parser#findStylesheet(SyntaxTreeNode, String):::Find a Stylesheet element with a specific ID attribute value:::if->return->if->id->root->getAttribute->if->id->equals->return->children->root->getContents->if->count->children->size->for->i->return
Parser#loadExternalStylesheet(String):::For embedded stylesheets: Load an external file with stylesheet:::source->if->new->File->exists->new->InputSource->else->new->InputSource->external->parse->return
Parser#initAttrTable(String, String[])::: parser init attr table:::_instructionAttrs->getQName->getStringRep->put
Parser#initInstructionAttrs()::: parser init instruction attrs:::new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable->new->StringArr->initAttrTable
Parser#initStdClasses():::Initialize the _instructionClasses map, which maps XSL element names to Java classes in this package.:::initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass->initStdClass
Parser#initStdClass(String, String)::: parser init std class:::_instructionClasses->getQName->getStringRep->put
Parser#elementSupported(String, String)::: parser element supported:::return->_instructionClasses->getQName->getStringRep->get
Parser#functionSupported(String)::: parser function supported:::return->_symbolTable->lookupPrimop
Parser#initExtClasses()::: parser init ext classes:::initExtClass->initExtClass
Parser#initExtClass(String, String)::: parser init ext class:::_instructionClasses->getQName->getStringRep->put
Parser#initExtClass(String, String, String)::: parser init ext class:::_instructionClasses->getQName->getStringRep->put
Parser#initSymbolTable():::Add primops and base functions to the symbol table.:::I_V->new->MethodType->I_R->new->MethodType->I_S->new->MethodType->I_D->new->MethodType->R_I->new->MethodType->R_V->new->MethodType->R_R->new->MethodType->R_D->new->MethodType->R_O->new->MethodType->I_I->new->MethodType->D_O->new->MethodType->D_V->new->MethodType->D_S->new->MethodType->D_D->new->MethodType->A_V->new->MethodType->S_V->new->MethodType->S_S->new->MethodType->S_A->new->MethodType->S_D->new->MethodType->S_O->new->MethodType->B_O->new->MethodType->B_V->new->MethodType->B_B->new->MethodType->B_S->new->MethodType->D_X->new->MethodType->R_RR->new->MethodType->I_II->new->MethodType->B_RR->new->MethodType->B_II->new->MethodType->S_SS->new->MethodType->S_DS->new->MethodType->S_SR->new->MethodType->O_SO->new->MethodType->D_SS->new->MethodType->D_SD->new->MethodType->B_BB->new->MethodType->B_SS->new->MethodType->S_SD->new->MethodType->S_DSS->new->MethodType->S_SRR->new->MethodType->S_SSS->new->MethodType->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop->_symbolTable->addPrimop
Parser#getSymbolTable()::: parser get symbol table:::return
Parser#getTemplate()::: parser get template:::return
Parser#setTemplate(Template)::: parser set template:::
Parser#getTemplateIndex()::: parser get template index:::return
Parser#makeInstance(String, String, String, Attributes)::: parser make instance:::node->qname->getQName->className->_instructionClasses->qname->getStringRep->get->if->try->clazz->ObjectFactory->findProviderClass->clazz->getDeclaredConstructor->newInstance->node->setQName->node->setParser->if->node->getLineNumber->setLineNumber->if->_xsltc->setStylesheet->checkForSuperfluousAttributes->catch->err->new->ErrorMsg->reportError->err->e->getMessage->new->ErrorMsg->reportError->finally->else->if->if->uri->equals->new->UnsupportedElement->element->msg->getLineNumber->new->ErrorMsg->element->setErrorMessage->if->reportError->else->if->uri->equals->new->UnsupportedElement->element->msg->getLineNumber->new->ErrorMsg->element->setErrorMessage->else->sheet->_xsltc->getStylesheet->if->sheet->isExtension->if->_parentStack->peek->new->UnsupportedElement->elem->msg->getLineNumber->new->ErrorMsg->elem->setErrorMessage->if->new->LiteralElement->node->getLineNumber->setLineNumber->if->setQName->return
Parser#checkForSuperfluousAttributes(SyntaxTreeNode, Attributes):::checks the list of attributes against a list of allowed attributes for a particular element node.:::qname->node->getQName->isStylesheet->legal->_instructionAttrs->qname->getStringRep->get->if->j->n->attrs->getLength->for->i
Parser#parseExpression(SyntaxTreeNode, String):::Parse an XPath expression::::return->parseTopLevel
Parser#parseExpression(SyntaxTreeNode, String, String):::Parse an XPath expression::::exp->parent->getAttribute->if->exp->length->return->parseTopLevel
Parser#parsePattern(SyntaxTreeNode, String):::Parse an XPath pattern::::return->parseTopLevel
Parser#parsePattern(SyntaxTreeNode, String, String):::Parse an XPath pattern::::pattern->parent->getAttribute->if->pattern->length->return->parseTopLevel
Parser#parseTopLevel(SyntaxTreeNode, String, String):::Parse an XPath expression or pattern using the generated XPathParser The method will return a Dummy node if the XPath parser fails.:::line->getLineNumber->try->_xpathParser->new->StringReader->new->XPathLexer->setScanner->result->_xpathParser->parse->if->node->if->node->setParser->node->setParent->node->setLineNumber->return->new->ErrorMsg->reportError->catch->if->_xsltc->debug->e->printStackTrace->new->ErrorMsg->reportError->finally->setParser->return
Parser#errorsFound():::Returns true if there were any errors during compilation:::return->_errors->size
Parser#printErrors():::Prints all compile-time errors:::size->_errors->size->if->new->ErrorMsg->println->for->i
Parser#printWarnings():::Prints all compile-time warnings:::size->_warnings->size->if->new->ErrorMsg->println->for->i
Parser#reportError(int, ErrorMsg):::Common error/warning message handler:::switch->_errors->add->break->_errors->add->break->_errors->add->break->_errors->add->break->_warnings->add->break
Parser#getErrors()::: parser get errors:::return
Parser#getWarnings()::: parser get warnings:::return
Parser#startDocument():::SAX2: Receive notification of the beginning of a document.:::new->Stack<>
Parser#endDocument():::SAX2: Receive notification of the end of a document.:::
Parser#startPrefixMapping(String, String):::SAX2: Begin the scope of a prefix-URI Namespace mapping:::if->new->HashMap<>->_prefixMapping->put
Parser#endPrefixMapping(String):::SAX2: End the scope of a prefix-URI Namespace mapping:::
Parser#startElement(String, String, String, Attributes):::SAX2: Receive notification of the beginning of an element:::col->qname->lastIndexOf->prefix->qname->substring->element->makeInstance->if->err->new->ErrorMsg->throw->err->toString->new->SAXException->if->if->_prefixMapping->containsValue->else->else->parent->_parentStack->peek->if->element->getClass->isAssignableFrom->parent->notTypeOf->err->new->ErrorMsg->throw->err->toString->new->SAXException->parent->addElement->element->setParent->element->new->AttributesImpl->setAttributes->element->setPrefixMapping->if->getSymbolTable->setCurrentNode->declareExtensionPrefixes->_parentStack->push
Parser#endElement(String, String, String):::SAX2: Receive notification of the end of an element.:::_parentStack->pop
Parser#characters(char[], int, int):::SAX2: Receive notification of character data.:::string->new->String->parent->_parentStack->peek->if->string->length->return->if->setText->return->if->return->bro->parent->lastChild->if->text->if->text->isTextElement->if->text->setText->return->parent->new->Text->addElement
Parser#getTokenValue(String)::: parser get token value:::start->token->indexOf->stop->token->lastIndexOf->return->token->substring
Parser#processingInstruction(String, String):::SAX2: Receive notification of a processing instruction:::if->name->equals->href->media->title->charset->tokens->new->StringTokenizer->while->tokens->hasMoreElements->token->tokens->nextElement->if->token->startsWith->getTokenValue->else->if->token->startsWith->getTokenValue->else->if->token->startsWith->getTokenValue->else->if->token->startsWith->getTokenValue->if->_PImedia->equals->_PImedia->equals->_PImedia->equals
Parser#ignorableWhitespace(char[], int, int):::IGNORED - all ignorable whitespace is ignored:::
Parser#skippedEntity(String):::IGNORED - we do not have to do anything with skipped entities:::
Parser#setDocumentLocator(Locator):::Store the document locator to later retrieve line numbers of all elements from the stylesheet:::
Parser#getLineNumber():::Get the line number, or zero if there is no _locator.:::line->if->_locator->getLineNumber->return
Pattern#typeCheck(SymbolTable):::Returns the type of a pattern, which is always a NodeType:::
Pattern#translate(ClassGenerator, MethodGenerator):::Translate this node into JVM bytecodes:::
Pattern#getPriority():::Returns the priority of this pattern (section 5.5 in the XSLT spec).:::
PositionCall#hasPositionCall()::: position call has position call:::return
PositionCall#translate(ClassGenerator, MethodGenerator)::: position call translate:::il->methodGen->getInstructionList->if->il->loadCurrentNode->append->else->if->il->new->ILOAD->append->else->cpg->classGen->getConstantPool->index->cpg->addInterfaceMethodref->il->methodGen->loadIterator->append->il->new->INVOKEINTERFACE->append
Predicate#setParser(Parser):::Set the parser for this expression.:::super->setParser->_exp->setParser
Predicate#isNthPositionFilter():::Returns a boolean value indicating if the nth position optimization is on:::return
Predicate#isNthDescendant():::Returns a boolean value indicating if the nth descendant optimization is on:::return
Predicate#dontOptimize():::Turns off all optimizations for this predicate.:::
Predicate#hasPositionCall():::Returns true if the expression in this predicate contains a call to position().:::return->_exp->hasPositionCall
Predicate#hasLastCall():::Returns true if the expression in this predicate contains a call to last().:::return->_exp->hasLastCall
Predicate#inInnerClass():::Returns true if this closure is compiled in an inner class (i.e:::return
Predicate#getParentClosure():::Returns a reference to its parent closure or null if outermost.:::if->node->getParent->do->if->break->if->break->node->getParent->while->return
Predicate#getInnerClassName():::Returns the name of the auxiliary class or null if this predicate is compiled inside the Translet.:::return
Predicate#addVariable(VariableRefBase):::Add new variable to the closure.:::if->new->ArrayList<>->if->_closureVars->contains->_closureVars->add->parentClosure->getParentClosure->if->parentClosure->addVariable
Predicate#getPosType():::Returns the node type of the expression owning this predicate:::if->parent->getParent->if->getNodeType->else->if->path->exp->path->getPath->if->getNodeType->else->if->ref->var->ref->getVariable->exp->var->getExpression->if->getNodeType->else->if->getNodeType->return
Predicate#parentIsPattern()::: predicate parent is pattern:::return->getParent
Predicate#getExpr()::: predicate get expr:::return
Predicate#toString()::: predicate to string:::return
Predicate#typeCheck(SymbolTable):::Type check a predicate expression:::texp->_exp->typeCheck->if->new->CastExpr->if->new->CastExpr->new->CastExpr->_exp->typeCheck->if->if->new->CastExpr->if->_exp->hasLastCall->_exp->hasPositionCall->if->parent->getParent->parent->getParent->return->position->getParser->getQNameIgnoreDefaultNs->positionCall->new->PositionCall->positionCall->getParser->setParser->positionCall->setParent->new->EqualityExpr->if->_exp->typeCheck->new->CastExpr->return->else->if->new->CastExpr->return
Predicate#compileFilter(ClassGenerator, MethodGenerator):::Create a new "Filter" class implementing CurrentNodeListFilter:::testGen->local->filterGen->getXSLTC->getHelperClassName->toString->new->StringArr->classGen->getStylesheet->new->FilterGenerator->cpg->filterGen->getConstantPool->length->_closureVars->size->for->i->il->new->InstructionList->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->new->StringArr->new->TestGenerator->testGen->Util->getJCRefType->addLocalVariable->className->classGen->getClassName->il->filterGen->loadTranslet->append->il->cpg->addClass->new->CHECKCAST->append->il->cpg->addFieldref->new->GETFIELD->append->local->il->local->getIndex->new->ASTORE->append->setStart->testGen->local->getIndex->setDomIndex->_exp->translate->il->append->filterGen->addEmptyConstructor->filterGen->addMethod->getXSLTC->filterGen->getJavaClass->dumpClass
Predicate#isBooleanTest():::Returns true if the predicate is a test for the existance of an element or attribute:::return
Predicate#isNodeValueTest():::Method to see if we can optimise the predicate by using a specialised iterator for expressions like '/foo/bar[@attr = $var]', which are very common in many stylesheets:::if->return->return->getStep->getCompareValue
Predicate#getStep():::Returns the step in an expression of the form 'step = value':::if->return->if->return->if->exp->left->exp->getLeft->right->exp->getRight->if->getExpr->if->if->getExpr->if->return
Predicate#getCompareValue():::Returns the value in an expression of the form 'step = value':::if->return->if->return->if->exp->left->exp->getLeft->right->exp->getRight->if->return->if->left->getType->return->if->return->if->right->getType->return->return
Predicate#translateFilter(ClassGenerator, MethodGenerator):::Translate a predicate expression:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->compileFilter->il->cpg->addClass->new->NEW->append->il->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->length->_closureVars->size->for->i
Predicate#translate(ClassGenerator, MethodGenerator):::Translate a predicate expression:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->_exp->translate->else->if->isNodeValueTest->getParent->_value->translate->il->cpg->addClass->new->CHECKCAST->append->il->getOp->new->PUSH->append->else->translateFilter
ProcessingInstruction#parseContents(Parser)::: processing instruction parse contents:::name->getAttribute->if->name->length->Util->isLiteral->if->if->XML11Char->isXML11ValidNCName->err->new->ErrorMsg->parser->reportError->AttributeValue->create->else->reportError->if->name->equals->reportError->parseChildren
ProcessingInstruction#typeCheck(SymbolTable)::: processing instruction type check:::_name->typeCheck->typeCheckContents->return
ProcessingInstruction#translate(ClassGenerator, MethodGenerator)::: processing instruction translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->nameValue->methodGen->Util->getJCRefType->addLocalVariable2->_name->translate->nameValue->il->nameValue->getIndex->new->ASTORE->append->setStart->il->nameValue->getIndex->new->ALOAD->append->check->cpg->addMethodref->il->new->INVOKESTATIC->append->il->methodGen->loadHandler->append->il->append->nameValue->il->nameValue->getIndex->new->ALOAD->append->setEnd->else->il->methodGen->loadHandler->append->il->append->_name->translate->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->methodGen->storeHandler->append->translateContents->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->processingInstruction->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->methodGen->storeHandler->append
ProcessingInstructionPattern#getDefaultPriority()::: processing instruction pattern get default priority:::return
ProcessingInstructionPattern#toString()::: processing instruction pattern to string:::if->return->else->return
ProcessingInstructionPattern#reduceKernelPattern()::: processing instruction pattern reduce kernel pattern:::
ProcessingInstructionPattern#isWildcard()::: processing instruction pattern is wildcard:::return
ProcessingInstructionPattern#typeCheck(SymbolTable)::: processing instruction pattern type check:::if->hasPredicates->n->_predicates->size->for->i->return
ProcessingInstructionPattern#translate(ClassGenerator, MethodGenerator)::: processing instruction pattern translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->gname->cpg->addInterfaceMethodref->cmp->cpg->addMethodref->il->methodGen->loadCurrentNode->append->il->append->il->methodGen->storeCurrentNode->append->if->il->methodGen->loadCurrentNode->append->getType->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->new->INVOKEINTERFACE->append->il->new->PUSH->append->_falseList->il->new->IF_ICMPEQ->append->add->il->new->PUSH->append->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->new->INVOKEINTERFACE->append->il->new->INVOKEVIRTUAL->append->_falseList->il->new->IFEQ->append->add->if->hasPredicates->n->_predicates->size->for->i->restore->il->methodGen->storeCurrentNode->append->backPatchTrueList->skipFalse->il->new->GOTO->append->il->methodGen->storeCurrentNode->append->backPatchFalseList->_falseList->il->new->GOTO->append->add->skipFalse->il->append->setTarget
QName#clearNamespace()::: name clear namespace:::
QName#toString()::: name to string:::return
QName#getStringRep()::: name get string rep:::return
QName#equals(Object)::: name equals:::return->_stringRep->getStringRep->equals
QName#getLocalPart()::: name get local part:::return
QName#getNamespace()::: name get namespace:::return
QName#getPrefix()::: name get prefix:::return
QName#hashCode()::: name hash code:::return
QName#dump()::: name dump:::return
RealExpr#typeCheck(SymbolTable)::: real expr type check:::return
RealExpr#toString()::: real expr to string:::return
RealExpr#translate(ClassGenerator, MethodGenerator)::: real expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
RelationalExpr#setParser(Parser)::: relational expr set parser:::super->setParser->_left->setParser->_right->setParser
RelationalExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::if->_left->hasPositionCall->return->if->_right->hasPositionCall->return->return
RelationalExpr#hasLastCall():::Returns true if this expressions contains a call to last():::return->_left->hasLastCall->_right->hasLastCall
RelationalExpr#hasReferenceArgs()::: relational expr has reference args:::return->_left->getType->_right->getType
RelationalExpr#hasNodeArgs()::: relational expr has node args:::return->_left->getType->_right->getType
RelationalExpr#hasNodeSetArgs()::: relational expr has node set args:::return->_left->getType->_right->getType
RelationalExpr#typeCheck(SymbolTable)::: relational expr type check:::tleft->_left->typeCheck->tright->_right->typeCheck->if->new->CastExpr->new->CastExpr->return->if->hasReferenceArgs->type->typeL->typeR->if->if->ref->var->ref->getVariable->var->getType->if->if->ref->var->ref->getVariable->var->getType->if->else->if->else->if->new->CastExpr->new->CastExpr->return->if->hasNodeSetArgs->if->temp->_right->getType->if->new->CastExpr->if->new->CastExpr->if->new->CastExpr->return->if->hasNodeArgs->if->new->CastExpr->if->new->CastExpr->ptype->Operators->getOpNames->new->MethodType->lookupPrimop->if->arg1->ptype->argsType->get->if->arg1->identicalTo->new->CastExpr->arg2->ptype->argsType->get->if->arg2->identicalTo->new->CastExpr->return->ptype->resultType->throw->new->TypeCheckError
RelationalExpr#translate(ClassGenerator, MethodGenerator)::: relational expr translate:::if->hasNodeSetArgs->hasReferenceArgs->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_left->translate->_left->startIterator->_right->translate->_right->startIterator->il->new->PUSH->append->il->methodGen->loadDOM->append->index->cpg->_left->getType->toSignature->_right->getType->toSignature->addMethodref->il->new->INVOKESTATIC->append->else->translateDesynthesized->synthesize
RelationalExpr#translateDesynthesized(ClassGenerator, MethodGenerator)::: relational expr translate desynthesized:::if->hasNodeSetArgs->hasReferenceArgs->translate->desynthesize->else->bi->il->methodGen->getInstructionList->_left->translate->_right->translate->tozero->tleft->_left->getType->if->il->tleft->CMP->append->switch->tleft->GE->break->tleft->LE->break->tleft->GT->break->tleft->LT->break->msg->new->ErrorMsg->getParser->reportError->_falseList->il->append->add
RelationalExpr#toString()::: relational expr to string:::return->Operators->getOpNames
RelativeLocationPath#getAxis()::: relative location path get axis:::
RelativeLocationPath#setAxis(int)::: relative location path set axis:::
RoundCall#translate(ClassGenerator, MethodGenerator)::: round call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->argument->translate->il->cpg->addMethodref->new->INVOKESTATIC->append
SimpleAttributeValue#typeCheck(SymbolTable):::Returns this attribute value's type (String).:::return
SimpleAttributeValue#toString()::: simple attribute value to string:::return
SimpleAttributeValue#contextDependent()::: simple attribute value context dependent:::return
SimpleAttributeValue#translate(ClassGenerator, MethodGenerator):::Translate this attribute value into JVM bytecodes that pushes the attribute value onto the JVM's stack.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
Sort#inInnerClass():::Returns true if this closure is compiled in an inner class (i.e:::return
Sort#getParentClosure():::Returns a reference to its parent closure or null if outermost.:::return
Sort#getInnerClassName():::Returns the name of the auxiliary class or null if this predicate is compiled inside the Translet.:::return
Sort#addVariable(VariableRefBase):::Add new variable to the closure.:::if->new->ArrayList<>->if->_closureVars->contains->_closureVars->add
Sort#setInnerClassName(String)::: sort set inner class name:::
Sort#parseContents(Parser):::Parse the attributes of the xsl:sort element:::parent->getParent->if->reportError->return->parser->parseExpression->val->getAttribute->if->val->length->AttributeValue->create->getAttribute->if->val->length->try->type->_select->parser->getSymbolTable->typeCheck->if->else->catch->finally->AttributeValue->create->getAttribute->AttributeValue->create->getAttribute->AttributeValue->create
Sort#typeCheck(SymbolTable):::Run type checks on the attributes; expression must return a string which we will use as a sort key:::tselect->_select->typeCheck->if->new->CastExpr->_order->typeCheck->_caseOrder->typeCheck->_dataType->typeCheck->_lang->typeCheck->return
Sort#translateSortType(ClassGenerator, MethodGenerator):::These two methods are needed in the static methods that compile the overloaded NodeSortRecord.compareType() and NodeSortRecord.sortOrder():::_dataType->translate
Sort#translateSortOrder(ClassGenerator, MethodGenerator)::: sort translate sort order:::_order->translate
Sort#translateCaseOrder(ClassGenerator, MethodGenerator)::: sort translate case order:::_caseOrder->translate
Sort#translateLang(ClassGenerator, MethodGenerator)::: sort translate lang:::_lang->translate
Sort#translateSelect(ClassGenerator, MethodGenerator):::This method compiles code for the select expression for this xsl:sort element:::_select->translate
Sort#translate(ClassGenerator, MethodGenerator):::This method should not produce any code:::
Sort#translateSortIterator(ClassGenerator, MethodGenerator, Expression, List):::Compiles code that instantiates a SortingIterator object:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->init->cpg->addMethodref->nodesTemp->methodGen->Util->getJCRefType->addLocalVariable->sortRecordFactoryTemp->methodGen->Util->getJCRefType->addLocalVariable->if->children->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->else->nodeSet->translate->nodesTemp->il->nodesTemp->getIndex->new->ASTORE->append->setStart->compileSortRecordFactory->sortRecordFactoryTemp->il->sortRecordFactoryTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->nodesTemp->il->nodesTemp->getIndex->new->ALOAD->append->setEnd->sortRecordFactoryTemp->il->sortRecordFactoryTemp->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append
Sort#compileSortRecordFactory(List, ClassGenerator, MethodGenerator):::Compiles code that instantiates a NodeSortRecordFactory object which will produce NodeSortRecord objects of a specific type.:::sortRecordClass->compileSortRecord->needsSortRecordFactory->nsorts->sortObjects->size->for->i->sortRecordFactoryClass->if->compileSortRecordFactory->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->sortOrderTemp->methodGen->Util->getJCRefType->addLocalVariable->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->for->level->sortOrderTemp->il->sortOrderTemp->getIndex->new->ASTORE->append->setStart->sortTypeTemp->methodGen->Util->getJCRefType->addLocalVariable->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->for->level->sortTypeTemp->il->sortTypeTemp->getIndex->new->ASTORE->append->setStart->sortLangTemp->methodGen->Util->getJCRefType->addLocalVariable->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->for->level->sortLangTemp->il->sortLangTemp->getIndex->new->ASTORE->append->setStart->sortCaseOrderTemp->methodGen->Util->getJCRefType->addLocalVariable->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->for->level->sortCaseOrderTemp->il->sortCaseOrderTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->il->methodGen->loadDOM->append->il->new->PUSH->append->il->classGen->loadTranslet->append->sortOrderTemp->il->sortOrderTemp->getIndex->new->ALOAD->append->setEnd->sortTypeTemp->il->sortTypeTemp->getIndex->new->ALOAD->append->setEnd->sortLangTemp->il->sortLangTemp->getIndex->new->ALOAD->append->setEnd->sortCaseOrderTemp->il->sortCaseOrderTemp->getIndex->new->ALOAD->append->setEnd->il->cpg->addMethodref->new->INVOKESPECIAL->append->dups->new->ArrayList<>->for->j
Sort#compileSortRecordFactory(List, ClassGenerator, MethodGenerator, String)::: sort compile sort record factory:::xsltc->sortObjects->get->getXSLTC->className->xsltc->getHelperClassName->sortRecordFactory->new->StringArr->classGen->getStylesheet->new->NodeSortRecordFactGenerator->cpg->sortRecordFactory->getConstantPool->nsorts->sortObjects->size->dups->new->ArrayList<>->for->j->argTypes->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->new->StringArr->il->new->InstructionList->constructor->new->MethodGenerator->il->append->il->append->il->append->il->new->ALOAD->append->il->new->ALOAD->append->il->new->ALOAD->append->il->new->ALOAD->append->il->new->ALOAD->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->il->append->new->InstructionList->makeNodeSortRecord->Util->getJCRefType->new->com.sun.org.apache.bcel.internal.generic.TypeArr->new->StringArr->new->MethodGenerator->il->append->il->append->il->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->il->append->il->cpg->addClass->new->CHECKCAST->append->ndups->dups->size->for->i->il->append->il->append->constructor->setMaxLocals->constructor->setMaxStack->sortRecordFactory->addMethod->makeNodeSortRecord->setMaxLocals->makeNodeSortRecord->setMaxStack->sortRecordFactory->addMethod->xsltc->sortRecordFactory->getJavaClass->dumpClass->return
Sort#compileSortRecord(List, ClassGenerator, MethodGenerator):::Create a new auxillary class extending NodeSortRecord.:::xsltc->sortObjects->get->getXSLTC->className->xsltc->getHelperClassName->sortRecord->new->StringArr->classGen->getStylesheet->new->NodeSortRecordGenerator->cpg->sortRecord->getConstantPool->nsorts->sortObjects->size->dups->new->ArrayList<>->for->j->init->compileInit->extract->compileExtract->sortRecord->addMethod->sortRecord->addMethod->xsltc->sortRecord->getJavaClass->dumpClass->return
Sort#compileInit(NodeSortRecordGenerator, ConstantPoolGen, String):::Create a constructor for the new class:::il->new->InstructionList->init->new->MethodGenerator->il->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->il->append->return
Sort#compileExtract(List, NodeSortRecordGenerator, ConstantPoolGen, String):::Compiles a method that overloads NodeSortRecord.extractValueFromDOM():::il->new->InstructionList->extractMethod->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->new->StringArr->new->CompareGenerator->levels->sortObjects->size->match->new->intArr->target->new->InstructionHandleArr->tblswitch->if->il->extractMethod->getLocalIndex->new->ILOAD->append->il->new->NOP->append->for->level->if->defaultTarget->il->new->PUSH->append->il->new->TABLESWITCH->insert->il->append->return
SourceLoader#loadSource(String, String, XSLTC):::This interface is used to plug external document loaders into XSLTC (used with the <xsl:include> and <xsl:import> elements.:::
StartsWithCall#typeCheck(SymbolTable):::Type check the two parameters for this function:::if->argumentCount->err->getName->new->ErrorMsg->throw->new->TypeCheckError->argument->baseType->_base->typeCheck->if->new->CastExpr->argument->tokenType->_token->typeCheck->if->new->CastExpr->return
StartsWithCall#translate(ClassGenerator, MethodGenerator):::Compile the expression - leave boolean expression on stack:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->_base->translate->_token->translate->il->cpg->addMethodref->new->INVOKEVIRTUAL->append
Step#setParser(Parser):::Set the parser for this element and all child predicates:::super->setParser->if->n->_predicates->size->for->i
Step#getAxis():::Define the axis (defined in Axis class) for this step:::return
Step#setAxis(int):::Get the axis (defined in Axis class) for this step:::
Step#getNodeType():::Returns the node-type for this step:::return
Step#getPredicates():::Returns the vector containing all predicates for this step.:::return
Step#addPredicates(List):::Returns the vector containing all predicates for this step.:::if->else->_predicates->addAll
Step#hasParentPattern():::Returns 'true' if this step has a parent pattern:::parent->getParent->return
Step#hasParentLocationPath():::Returns 'true' if this step has a parent location path.:::return->getParent
Step#hasPredicates():::Returns 'true' if this step has any predicates:::return->_predicates->size
Step#isPredicate():::Returns 'true' if this step is used within a predicate:::parent->while->parent->getParent->if->return->return
Step#isAbbreviatedDot():::True if this step is the abbreviated step '.':::return
Step#isAbbreviatedDDot():::True if this step is the abbreviated step '..':::return
Step#typeCheck(SymbolTable):::Type check this step:::hasPredicates->if->isAbbreviatedDot->hasParentPattern->hasPredicates->hasParentLocationPath->else->if->foreach->pred->typeCheck->return
Step#translate(ClassGenerator, MethodGenerator):::Translate a step by pushing the appropriate iterator onto the stack:::hasPredicates->_predicates->size->translateStep
Step#translateStep(ClassGenerator, MethodGenerator, int)::: step translate step:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->translatePredicates->else->star->name->xsltc->getParser->getXSLTC->if->ni->xsltc->getNamesIndex->ni->get->name->lastIndexOf->if->hasParentPattern->iter->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->return->parent->getParent->if->isAbbreviatedDot->if->il->methodGen->loadContextNode->append->else->if->init->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->methodGen->loadContextNode->append->il->new->INVOKESPECIAL->append->else->git->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->return->if->parent->getParent->if->switch->git->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->break->if->namespace->if->name->substring->else->name->substring->nsType->xsltc->registerNamespace->ns->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->break->ty->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->new->PUSH->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->break
Step#translatePredicates(ClassGenerator, MethodGenerator, int):::Translate a sequence of predicates:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->idx->if->translateStep->else->predicate->_predicates->get->if->predicate->isNodeValueTest->step->predicate->getStep->il->methodGen->loadDOM->append->if->step->isAbbreviatedDot->translateStep->il->new->ICONST->append->else->path->new->ParentLocationPath->try->path->getParser->getSymbolTable->typeCheck->catch->finally->translateStep->path->translateStep->il->new->ICONST->append->predicate->translate->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->else->if->predicate->isNthDescendant->il->methodGen->loadDOM->append->il->predicate->getPosType->new->PUSH->append->predicate->translate->il->new->ICONST->append->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->else->if->predicate->isNthPositionFilter->cpg->addMethodref->translatePredicates->iteratorTemp->methodGen->Util->getJCRefType->addLocalVariable->iteratorTemp->il->iteratorTemp->getIndex->new->ASTORE->append->setStart->predicate->translate->predicateValueTemp->methodGen->Util->getJCRefType->addLocalVariable->predicateValueTemp->il->predicateValueTemp->getIndex->new->ISTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->iteratorTemp->il->iteratorTemp->getIndex->new->ALOAD->append->setEnd->predicateValueTemp->il->predicateValueTemp->getIndex->new->ILOAD->append->setEnd->il->new->INVOKESPECIAL->append->else->cpg->addMethodref->translatePredicates->iteratorTemp->methodGen->Util->getJCRefType->addLocalVariable->iteratorTemp->il->iteratorTemp->getIndex->new->ASTORE->append->setStart->predicate->translateFilter->filterTemp->methodGen->Util->getJCRefType->addLocalVariable->filterTemp->il->filterTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->iteratorTemp->il->iteratorTemp->getIndex->new->ALOAD->append->setEnd->filterTemp->il->filterTemp->getIndex->new->ALOAD->append->setEnd->il->methodGen->loadCurrentNode->append->il->classGen->loadTranslet->append->if->classGen->isExternal->className->classGen->getClassName->il->cpg->addClass->new->CHECKCAST->append->il->new->INVOKESPECIAL->append
Step#toString():::Returns a string representation of this step.:::buffer->new->StringBuffer->buffer->Axis->getNames->append->append->append->if->foreach->buffer->append->pred->toString->append->return->buffer->append->toString
StepPattern#setParser(Parser)::: step pattern set parser:::super->setParser->if->foreach->exp->setParser->exp->setParent
StepPattern#getNodeType()::: step pattern get node type:::return
StepPattern#setPriority(double)::: step pattern set priority:::
StepPattern#getKernelPattern()::: step pattern get kernel pattern:::return
StepPattern#isWildcard()::: step pattern is wildcard:::return->hasPredicates
StepPattern#setPredicates(List)::: step pattern set predicates:::return
StepPattern#hasPredicates()::: step pattern has predicates:::return->_predicates->size
StepPattern#getDefaultPriority()::: step pattern get default priority:::if->return->if->hasPredicates->return->else->switch->return->return->return
StepPattern#getAxis()::: step pattern get axis:::return
StepPattern#reduceKernelPattern()::: step pattern reduce kernel pattern:::
StepPattern#toString()::: step pattern to string:::buffer->new->StringBuffer->buffer->Axis->getNames->append->append->Integer->toString->Integer->toString->append->if->buffer->append->_predicates->toString->append->return->buffer->append->toString
StepPattern#analyzeCases()::: step pattern analyze cases:::noContext->n->_predicates->size->for->i->if->return->else->if->return->return
StepPattern#getNextFieldName()::: step pattern get next field name:::return->getXSLTC->nextStepPatternSerial
StepPattern#typeCheck(SymbolTable)::: step pattern type check:::if->hasPredicates->foreach->pred->typeCheck->analyzeCases->step->if->pred->_predicates->get->if->pred->isNthPositionFilter->new->Step->else->new->Step->else->if->foreach->pred->dontOptimize->new->Step->if->step->getParser->setParser->step->typeCheck->return
StepPattern#translateKernel(ClassGenerator, MethodGenerator)::: step pattern translate kernel:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->check->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->new->INVOKEINTERFACE->append->icmp->il->new->IFNE->append->_falseList->il->new->GOTO_W->append->add->icmp->il->append->setTarget->else->if->check->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->new->INVOKEINTERFACE->append->icmp->il->new->IFNE->append->_falseList->il->new->GOTO_W->append->add->icmp->il->append->setTarget->else->getEType->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->new->INVOKEINTERFACE->append->il->new->PUSH->append->icmp->il->new->IF_ICMPEQ->append->_falseList->il->new->GOTO_W->append->add->icmp->il->append->setTarget
StepPattern#translateNoContext(ClassGenerator, MethodGenerator)::: step pattern translate no context:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->methodGen->loadCurrentNode->append->il->append->il->methodGen->storeCurrentNode->append->if->il->methodGen->loadCurrentNode->append->translateKernel->foreach->exp->pred->getExpr->exp->translateDesynthesized->_trueList->append->_falseList->append->restore->il->methodGen->storeCurrentNode->append->backPatchTrueList->skipFalse->il->new->GOTO->append->il->methodGen->storeCurrentNode->append->backPatchFalseList->_falseList->il->new->GOTO->append->add->skipFalse->il->append->setTarget
StepPattern#translateSimpleContext(ClassGenerator, MethodGenerator)::: step pattern translate simple context:::index->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->match->methodGen->Util->getJCRefType->addLocalVariable->match->il->match->getIndex->new->ISTORE->append->setStart->if->il->match->getIndex->new->ILOAD->append->translateKernel->il->methodGen->loadCurrentNode->append->il->methodGen->loadIterator->append->cpg->addMethodref->_step->translate->stepIteratorTemp->methodGen->Util->getJCRefType->addLocalVariable->stepIteratorTemp->il->stepIteratorTemp->getIndex->new->ASTORE->append->setStart->il->cpg->addClass->new->NEW->append->il->append->il->match->getIndex->new->ILOAD->append->stepIteratorTemp->il->stepIteratorTemp->getIndex->new->ALOAD->append->setEnd->il->new->INVOKESPECIAL->append->il->methodGen->loadDOM->append->il->match->getIndex->new->ILOAD->append->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->methodGen->setStartNode->append->il->methodGen->storeIterator->append->match->il->match->getIndex->new->ILOAD->append->setEnd->il->methodGen->storeCurrentNode->append->pred->_predicates->get->exp->pred->getExpr->exp->translateDesynthesized->restore->il->methodGen->storeIterator->append->il->methodGen->storeCurrentNode->append->exp->backPatchTrueList->skipFalse->il->new->GOTO->append->il->methodGen->storeIterator->append->il->methodGen->storeCurrentNode->append->exp->backPatchFalseList->_falseList->il->new->GOTO->append->add->skipFalse->il->append->setTarget
StepPattern#translateGeneralContext(ClassGenerator, MethodGenerator)::: step pattern translate general context:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->iteratorIndex->ifBlock->iter->node->node2->iteratorName->getNextFieldName->methodGen->Util->getJCRefType->addLocalVariable->node->il->node->getIndex->new->ISTORE->append->setStart->methodGen->Util->getJCRefType->addLocalVariable->if->classGen->isExternal->iterator->cpg->addUtf8->cpg->addUtf8->cpg->getConstantPool->new->Field->classGen->addField->cpg->classGen->getClassName->addFieldref->il->classGen->loadTranslet->append->il->new->GETFIELD->append->il->append->iter->il->iter->getIndex->new->ASTORE->append->setStart->il->new->IFNONNULL->append->il->classGen->loadTranslet->append->_step->translate->iterStore->il->iter->getIndex->new->ASTORE->append->if->classGen->isExternal->il->iter->getIndex->new->ALOAD->append->il->new->PUTFIELD->append->ifBlock->il->append->setTarget->else->iter->setStart->il->methodGen->loadDOM->append->il->node->getIndex->new->ILOAD->append->index->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->iter->getIndex->new->ALOAD->append->il->append->il->methodGen->setStartNode->append->skipNext->begin->next->methodGen->Util->getJCRefType->addLocalVariable->il->new->GOTO->append->il->iter->getIndex->new->ALOAD->append->node2->setStart->il->methodGen->nextNode->append->il->append->il->node2->getIndex->new->ISTORE->append->_falseList->il->new->IFLT->append->add->il->node2->getIndex->new->ILOAD->append->il->node->getIndex->new->ILOAD->append->iter->il->new->IF_ICMPLT->append->setEnd->node2->il->node2->getIndex->new->ILOAD->append->setEnd->node->il->node->getIndex->new->ILOAD->append->setEnd->_falseList->il->new->IF_ICMPNE->append->add->skipNext->setTarget
StepPattern#translate(ClassGenerator, MethodGenerator)::: step pattern translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->hasPredicates->switch->translateNoContext->break->translateSimpleContext->break->translateGeneralContext->break->else->if->isWildcard->il->append->else->translateKernel
StringCall#typeCheck(SymbolTable)::: string call type check:::argc->argumentCount->if->err->new->ErrorMsg->throw->new->TypeCheckError->if->argument->typeCheck->return
StringCall#translate(ClassGenerator, MethodGenerator)::: string call translate:::il->methodGen->getInstructionList->targ->if->argumentCount->il->methodGen->loadContextNode->append->else->arg->argument->arg->translate->arg->startIterator->arg->getType->if->targ->identicalTo->targ->translateTo
StringLengthCall#translate(ClassGenerator, MethodGenerator)::: string length call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->argumentCount->argument->translate->else->il->methodGen->loadContextNode->append->translateTo->il->cpg->addMethodref->new->INVOKESTATIC->append
Stylesheet#getOutputMethod():::Return the output method:::return
Stylesheet#checkOutputMethod():::Check and set the output method:::if->method->_lastOutputElement->getOutputMethod->if->if->method->equals->else->if->method->equals->else->if->method->equals
Stylesheet#getTemplateInlining()::: stylesheet get template inlining:::return
Stylesheet#setTemplateInlining(boolean)::: stylesheet set template inlining:::
Stylesheet#isSimplified()::: stylesheet is simplified:::return
Stylesheet#setSimplified()::: stylesheet set simplified:::
Stylesheet#setHasIdCall(boolean)::: stylesheet set has id call:::
Stylesheet#setOutputProperty(String, String)::: stylesheet set output property:::if->new->Properties->_outputProperties->setProperty
Stylesheet#setOutputProperties(Properties)::: stylesheet set output properties:::
Stylesheet#getOutputProperties()::: stylesheet get output properties:::return
Stylesheet#getLastOutputElement()::: stylesheet get last output element:::return
Stylesheet#setMultiDocument(boolean)::: stylesheet set multi document:::
Stylesheet#isMultiDocument()::: stylesheet is multi document:::return
Stylesheet#setCallsNodeset(boolean)::: stylesheet set calls nodeset:::if->setMultiDocument
Stylesheet#callsNodeset()::: stylesheet calls nodeset:::return
Stylesheet#numberFormattingUsed()::: stylesheet number formatting used:::parent->getParentStylesheet->if->parent->numberFormattingUsed
Stylesheet#setImportPrecedence(int)::: stylesheet set import precedence:::elements->elements->while->elements->hasNext->child->elements->next->if->included->getIncludedStylesheet->if->included->setImportPrecedence->if->if->_importedFrom->getImportPrecedence->parser->getParser->nextPrecedence->parser->getNextImportPrecedence->_importedFrom->setImportPrecedence->else->if->if->_includedFrom->getImportPrecedence->_includedFrom->setImportPrecedence
Stylesheet#getImportPrecedence()::: stylesheet get import precedence:::return
Stylesheet#getMinimumDescendantPrecedence():::Get the minimum of the precedence of this stylesheet, any stylesheet imported by this stylesheet and any include/import descendant of this stylesheet.:::if->min->getImportPrecedence->inclImpCount->_includedStylesheets->size->for->i->return
Stylesheet#checkForLoop(String)::: stylesheet check for loop:::if->_systemId->equals->return->if->return->_parentStylesheet->checkForLoop->return
Stylesheet#setParser(Parser)::: stylesheet set parser:::super->setParser->makeStylesheetName
Stylesheet#setParentStylesheet(Stylesheet)::: stylesheet set parent stylesheet:::
Stylesheet#getParentStylesheet()::: stylesheet get parent stylesheet:::return
Stylesheet#setImportingStylesheet(Stylesheet)::: stylesheet set importing stylesheet:::parent->addIncludedStylesheet
Stylesheet#setIncludingStylesheet(Stylesheet)::: stylesheet set including stylesheet:::parent->addIncludedStylesheet
Stylesheet#addIncludedStylesheet(Stylesheet)::: stylesheet add included stylesheet:::if->new->ArrayList<>->_includedStylesheets->add
Stylesheet#setSystemId(String)::: stylesheet set system id:::if->SystemIDResolver->getAbsoluteURI
Stylesheet#getSystemId()::: stylesheet get system id:::return
Stylesheet#setSourceLoader(SourceLoader)::: stylesheet set source loader:::
Stylesheet#getSourceLoader()::: stylesheet get source loader:::return
Stylesheet#makeStylesheetName(String)::: stylesheet make stylesheet name:::return->getParser->getXSLTC->nextStylesheetSerial->getQName
Stylesheet#hasGlobals():::Returns true if this stylesheet has global vars or params.:::return->_globals->size
Stylesheet#hasLocalParams():::Returns true if at least one template in the stylesheet has params defined:::if->templates->getAllValidTemplates->n->templates->size->for->i->return->else->return->_hasLocalParams->booleanValue
Stylesheet#addPrefixMapping(String, String):::Adds a single prefix mapping to this syntax tree node.:::if->prefix->equals->uri->equals->return->super->addPrefixMapping
Stylesheet#extensionURI(String, SymbolTable):::Store extension URIs:::if->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->prefix->tokens->nextToken->uri->lookupNamespace->if->_extensions->put
Stylesheet#isExtension(String)::: stylesheet is extension:::return->_extensions->get
Stylesheet#declareExtensionPrefixes(Parser)::: stylesheet declare extension prefixes:::stable->parser->getSymbolTable->extensionPrefixes->getAttribute->extensionURI
Stylesheet#parseContents(Parser):::Parse the version and uri fields of the stylesheet and add an entry to the symbol table mapping the name <tt>__stylesheet_</tt> to an instance of this class.:::stable->parser->getSymbolTable->addPrefixMapping->sheet->stable->addStylesheet->if->err->new->ErrorMsg->parser->reportError->if->stable->excludeURI->template->new->Template->template->parseSimplified->else->parseOwnChildren
Stylesheet#parseOwnChildren(Parser):::Parse all direct children of the <xsl:stylesheet/> element.:::stable->parser->getSymbolTable->excludePrefixes->getAttribute->extensionPrefixes->getAttribute->stable->pushExcludedNamespacesContext->stable->excludeURI->stable->excludeNamespaces->stable->excludeNamespaces->contents->getContents->count->contents->size->for->i->for->i->stable->popExcludedNamespacesContext
Stylesheet#processModes()::: stylesheet process modes:::if->new->Mode->_defaultMode->processPatterns->_modes->values->stream->mode->processPatterns->forEach
Stylesheet#compileModes(ClassGenerator)::: stylesheet compile modes:::_defaultMode->compileApplyTemplates->_modes->values->stream->mode->compileApplyTemplates->forEach
Stylesheet#getMode(QName)::: stylesheet get mode:::if->if->new->Mode->return->else->mode->_modes->modeName->getStringRep->get->if->suffix->Integer->toString->_modes->modeName->getStringRep->new->Mode->put->return
Stylesheet#typeCheck(SymbolTable):::Type check all the children of this node.:::count->_globals->size->for->i->return->typeCheckContents
Stylesheet#translate(ClassGenerator, MethodGenerator):::Translate the stylesheet into JVM bytecodes.:::translate
Stylesheet#addDOMField(ClassGenerator)::: stylesheet add field:::fgen->Util->getJCRefType->classGen->getConstantPool->new->FieldGen->classGen->fgen->getField->addField
Stylesheet#addStaticField(ClassGenerator, String, String):::Add a static field:::fgen->Util->getJCRefType->classGen->getConstantPool->new->FieldGen->classGen->fgen->getField->addField
Stylesheet#translate():::Translate the stylesheet into JVM bytecodes.:::getXSLTC->getClassName->classGen->new->ClassGenerator->addDOMField->compileTransform->elements->elements->while->elements->hasNext->element->elements->next->if->template->template->getModeName->getMode->addTemplate->else->if->translate->else->if->output->if->output->enabled->else->checkOutputMethod->processModes->compileModes->compileStaticInitializer->compileConstructor->if->getParser->errorsFound->getXSLTC->classGen->getJavaClass->dumpClass
Stylesheet#compileStaticInitializer(ClassGenerator):::Compile the namesArray, urisArray and typesArray into the static initializer:::cpg->classGen->getConstantPool->il->new->InstructionList->staticConst->new->MethodGenerator->addStaticField->addStaticField->addStaticField->addStaticField->charDataFieldCount->getXSLTC->getCharacterDataCount->for->i->namesIndex->getXSLTC->getNamesIndex->size->namesIndex->size->namesArray->new->StringArr->urisArray->new->StringArr->typesArray->new->intArr->index->for->i->staticConst->markChunkStart->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->namesArrayRef->cpg->addFieldref->il->new->PUTSTATIC->append->staticConst->markChunkEnd->for->i->staticConst->markChunkStart->il->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->urisArrayRef->cpg->addFieldref->il->new->PUTSTATIC->append->staticConst->markChunkEnd->for->i->staticConst->markChunkStart->il->new->PUSH->append->il->new->NEWARRAY->append->typesArrayRef->cpg->addFieldref->il->new->PUTSTATIC->append->staticConst->markChunkEnd->for->i->namespaces->getXSLTC->getNamespaceIndex->staticConst->markChunkStart->il->namespaces->size->new->PUSH->append->il->cpg->addClass->new->ANEWARRAY->append->namespaceArrayRef->cpg->addFieldref->il->new->PUTSTATIC->append->staticConst->markChunkEnd->for->i->namespaces->size->charDataCount->getXSLTC->getCharacterDataCount->toCharArray->cpg->addMethodref->for->i->il->append->classGen->addMethod
Stylesheet#compileConstructor(ClassGenerator, Output):::Compile the translet's constructor:::cpg->classGen->getConstantPool->il->new->InstructionList->constructor->new->MethodGenerator->il->classGen->loadTranslet->append->il->cpg->addMethodref->new->INVOKESPECIAL->append->constructor->markChunkStart->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETSTATIC->append->il->cpg->addFieldref->new->PUTFIELD->append->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETSTATIC->append->il->cpg->addFieldref->new->PUTFIELD->append->constructor->markChunkEnd->constructor->markChunkStart->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETSTATIC->append->il->cpg->addFieldref->new->PUTFIELD->append->constructor->markChunkEnd->constructor->markChunkStart->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETSTATIC->append->il->cpg->addFieldref->new->PUTFIELD->append->constructor->markChunkEnd->constructor->markChunkStart->il->classGen->loadTranslet->append->il->new->PUSH->append->il->cpg->addFieldref->new->PUTFIELD->append->constructor->markChunkEnd->if->constructor->markChunkStart->il->classGen->loadTranslet->append->il->new->PUSH->append->il->cpg->addFieldref->new->PUTFIELD->append->constructor->markChunkEnd->if->constructor->markChunkStart->output->translate->constructor->markChunkEnd->if->constructor->markChunkStart->DecimalFormatting->translateDefaultDFS->constructor->markChunkEnd->il->append->classGen->addMethod
Stylesheet#compileTopLevel(ClassGenerator):::Compile a topLevel() method into the output class:::cpg->classGen->getConstantPool->argTypes->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->il->new->InstructionList->toplevel->classGen->getConstantPool->new->MethodGenerator->toplevel->addException->current->toplevel->addLocalVariable->setFilter->cpg->addInterfaceMethodref->gitr->cpg->addInterfaceMethodref->il->toplevel->loadDOM->append->il->new->INVOKEINTERFACE->append->il->toplevel->nextNode->append->current->il->current->getIndex->new->ISTORE->append->setStart->varDepElements->new->ArrayList<>->elements->elements->while->elements->hasNext->element->elements->next->if->varDepElements->add->resolveDependencies->count->varDepElements->size->for->i->whitespaceRules->new->ArrayList<>->elements->while->elements->hasNext->element->elements->next->if->translate->else->if->whitespaceRules->getRules->addAll->if->whitespaceRules->size->Whitespace->translateRules->if->classGen->containsMethod->il->toplevel->loadDOM->append->il->classGen->loadTranslet->append->il->new->INVOKEINTERFACE->append->il->append->classGen->addMethod->return
Stylesheet#resolveDependencies(List):::This method returns a vector with variables/params and keys in the order in which they are to be compiled for initialization:::result->new->ArrayList<>->while->input->size->changed->for->i->input->size->if->err->input->toString->new->ErrorMsg->getParser->reportError->return->return
Stylesheet#compileBuildKeys(ClassGenerator):::Compile a buildKeys() method into the output class:::cpg->classGen->getConstantPool->argTypes->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->il->new->InstructionList->buildKeys->classGen->getConstantPool->new->MethodGenerator->buildKeys->addException->elements->elements->while->elements->hasNext->element->elements->next->if->key->key->translate->_keys->key->getName->put->il->append->buildKeys->stripAttributes->buildKeys->setMaxLocals->buildKeys->setMaxStack->buildKeys->removeNOPs->classGen->buildKeys->getMethod->addMethod->return
Stylesheet#compileTransform(ClassGenerator):::Compile transform() into the output class:::cpg->classGen->getConstantPool->argTypes->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->Util->getJCRefType->Util->getJCRefType->argNames->new->StringArr->il->new->InstructionList->transf->classGen->getConstantPool->new->MethodGenerator->transf->addException->check->cpg->addMethodref->il->new->INVOKESTATIC->append->current->transf->addLocalVariable->applyTemplatesSig->classGen->getApplyTemplatesSig->applyTemplates->cpg->getClassName->addMethodref->domField->cpg->getClassName->addFieldref->il->classGen->loadTranslet->append->if->isMultiDocument->il->cpg->addClass->new->NEW->append->il->append->il->classGen->loadTranslet->append->il->transf->loadDOM->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->if->isMultiDocument->init->cpg->addMethodref->il->new->INVOKESPECIAL->append->il->new->PUTFIELD->append->gitr->cpg->addInterfaceMethodref->il->transf->loadDOM->append->il->new->INVOKEINTERFACE->append->il->transf->nextNode->append->current->il->current->getIndex->new->ISTORE->append->setStart->il->classGen->loadTranslet->append->il->transf->loadHandler->append->index->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->keySig->compileBuildKeys->keyIdx->cpg->getClassName->addMethodref->toplevel->elements->if->_globals->size->toplevel->hasNext->topLevelSig->compileTopLevel->topLevelIdx->cpg->getClassName->addMethodref->il->classGen->loadTranslet->append->il->classGen->loadTranslet->append->il->new->GETFIELD->append->il->transf->loadIterator->append->il->transf->loadHandler->append->il->new->INVOKEVIRTUAL->append->il->transf->loadHandler->append->il->transf->startDocument->append->il->classGen->loadTranslet->append->il->classGen->loadTranslet->append->il->new->GETFIELD->append->il->transf->loadIterator->append->il->transf->loadHandler->append->il->new->INVOKEVIRTUAL->append->il->transf->loadHandler->append->il->transf->endDocument->append->il->append->classGen->addMethod
Stylesheet#peepHoleOptimization(MethodGenerator):::Peephole optimization: Remove sequences of [ALOAD, POP].:::pattern->il->methodGen->getInstructionList->find->new->InstructionFinder->for->iter->find->search->iter->hasNext
Stylesheet#addParam(Param)::: stylesheet add param:::_globals->add->return->_globals->size
Stylesheet#addVariable(Variable)::: stylesheet add variable:::_globals->add->return->_globals->size
Stylesheet#display(int)::: stylesheet display:::indent->Util->println->displayContents
Stylesheet#getNamespace(String)::: stylesheet get namespace:::return->lookupNamespace
Stylesheet#getClassName()::: stylesheet get class name:::return
Stylesheet#getTemplates()::: stylesheet get templates:::return
Stylesheet#getAllValidTemplates()::: stylesheet get all valid templates:::if->return->if->templates->new->ArrayList<>->templates->addAll->foreach->templates->included->getAllValidTemplates->addAll->if->return->return
Stylesheet#addTemplate(Template)::: stylesheet add template:::_templates->add
SymbolTable#getDecimalFormatting(QName)::: symbol table get decimal formatting:::if->return->return->_decimalFormats->name->getStringRep->get
SymbolTable#addDecimalFormatting(QName, DecimalFormatting)::: symbol table add decimal formatting:::if->new->HashMap<>->_decimalFormats->name->getStringRep->put
SymbolTable#getKey(QName)::: symbol table get key:::if->return->return->_keys->name->getStringRep->get
SymbolTable#addKey(QName, Key)::: symbol table add key:::if->new->HashMap<>->_keys->name->getStringRep->put
SymbolTable#addStylesheet(QName, Stylesheet)::: symbol table add stylesheet:::return->_stylesheets->name->getStringRep->put
SymbolTable#lookupStylesheet(QName)::: symbol table lookup stylesheet:::return->_stylesheets->name->getStringRep->get
SymbolTable#addTemplate(Template)::: symbol table add template:::name->template->getName->if->new->HashMap<>->return->_templates->name->getStringRep->put
SymbolTable#lookupTemplate(QName)::: symbol table lookup template:::if->return->return->_templates->name->getStringRep->get
SymbolTable#addVariable(Variable)::: symbol table add variable:::if->new->HashMap<>->name->variable->getName->getStringRep->return->_variables->put
SymbolTable#addParam(Param)::: symbol table add param:::if->new->HashMap<>->name->parameter->getName->getStringRep->return->_variables->put
SymbolTable#lookupVariable(QName)::: symbol table lookup variable:::if->return->name->qname->getStringRep->obj->_variables->get->return
SymbolTable#lookupParam(QName)::: symbol table lookup param:::if->return->name->qname->getStringRep->obj->_variables->get->return
SymbolTable#lookupName(QName)::: symbol table lookup name:::if->return->name->qname->getStringRep->return->_variables->get
SymbolTable#addAttributeSet(AttributeSet)::: symbol table add attribute set:::if->new->HashMap<>->return->_attributeSets->atts->getName->getStringRep->put
SymbolTable#lookupAttributeSet(QName)::: symbol table lookup attribute set:::if->return->return->_attributeSets->name->getStringRep->get
SymbolTable#addPrimop(String, MethodType):::Add a primitive operator or function to the symbol table:::methods->_primops->get->if->_primops->new->ArrayList<>->put->methods->add
SymbolTable#lookupPrimop(String):::Lookup a primitive operator or function in the symbol table by prepending the prefix <tt>PrimopPrefix</tt>.:::return->_primops->get
SymbolTable#generateNamespacePrefix()::: symbol table generate namespace prefix:::return
SymbolTable#setCurrentNode(SyntaxTreeNode)::: symbol table set current node:::
SymbolTable#lookupNamespace(String)::: symbol table lookup namespace:::if->return->return->_current->lookupNamespace
SymbolTable#addPrefixAlias(String, String):::Adds an alias for a namespace prefix:::if->new->HashMap<>->_aliases->put
SymbolTable#lookupPrefixAlias(String):::Retrieves any alias for a given namespace prefix:::if->return->return->_aliases->get
SymbolTable#excludeURI(String):::Register a namespace URI so that it will not be declared in the output unless it is actually referenced in the output.:::if->return->if->new->HashMap<>->refcnt->_excludedURI->get->if->else->_excludedURI->put
SymbolTable#excludeNamespaces(String):::Exclude a series of namespaces given by a list of whitespace separated namespace prefixes.:::if->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->prefix->tokens->nextToken->uri->if->prefix->equals->lookupNamespace->else->lookupNamespace->if->excludeURI
SymbolTable#isExcludedNamespace(String):::Check if a namespace should not be declared in the output (unless used):::if->refcnt->_excludedURI->get->return->return
SymbolTable#unExcludeNamespaces(String):::Turn of namespace declaration exclusion:::if->return->if->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->prefix->tokens->nextToken->uri->if->prefix->equals->lookupNamespace->else->lookupNamespace->refcnt->_excludedURI->get->if->_excludedURI->put
SymbolTable#pushExcludedNamespacesContext():::Exclusion of namespaces by a stylesheet does not extend to any stylesheet imported or included by the stylesheet:::if->new->Stack<>->_excludedURIStack->push
SymbolTable#popExcludedNamespacesContext():::Exclusion of namespaces by a stylesheet does not extend to any stylesheet imported or included by the stylesheet:::_excludedURIStack->pop->if->_excludedURIStack->isEmpty
SyntaxTreeNode#setLineNumber(int):::Set the source file line number for this element:::
SyntaxTreeNode#getLineNumber():::Get the source file line number for this element:::if->return->parent->getParent->return->parent->getLineNumber
SyntaxTreeNode#setQName(QName):::Set the QName for the syntax tree node.:::
SyntaxTreeNode#setQName(String, String, String):::Set the QName for the SyntaxTreeNode:::new->QName
SyntaxTreeNode#getQName():::Set the QName for the SyntaxTreeNode:::return
SyntaxTreeNode#setAttributes(AttributesImpl):::Set the attributes for this SyntaxTreeNode.:::
SyntaxTreeNode#getAttribute(String):::Returns a value for an attribute from the source element.:::if->return->value->_attributes->getValue->return->value->equals
SyntaxTreeNode#getAttribute(String, String)::: syntax tree node get attribute:::return->getAttribute
SyntaxTreeNode#hasAttribute(String)::: syntax tree node has attribute:::return->_attributes->getValue
SyntaxTreeNode#addAttribute(String, String)::: syntax tree node add attribute:::index->_attributes->getIndex->if->_attributes->Util->getLocalName->setAttribute->else->_attributes->Util->getLocalName->addAttribute
SyntaxTreeNode#getAttributes():::Returns a list of all attributes declared for the element represented by this syntax tree node.:::return
SyntaxTreeNode#setPrefixMapping(Map):::Sets the prefix mapping for the namespaces that were declared in this element:::
SyntaxTreeNode#getPrefixMapping():::Returns a Map containing the prefix mappings that were declared for this element:::return
SyntaxTreeNode#addPrefixMapping(String, String):::Adds a single prefix mapping to this syntax tree node.:::if->new->HashMap<>->_prefixMapping->put
SyntaxTreeNode#lookupNamespace(String):::Returns any namespace URI that is in scope for a given prefix:::uri->if->_prefixMapping->get->if->_parent->lookupNamespace->if->return
SyntaxTreeNode#lookupPrefix(String):::Returns any namespace prefix that is mapped to a prefix in the current scope:::prefix->if->_prefixMapping->containsValue->foreach->_prefixMapping->entrySet->entry->getKey->mapsTo->entry->getValue->if->mapsTo->equals->return->else->if->_parent->lookupPrefix->if->return
SyntaxTreeNode#setParser(Parser):::Set this node's parser:::
SyntaxTreeNode#getParser():::Returns this node's XSLT parser.:::return
SyntaxTreeNode#setParent(SyntaxTreeNode):::Set this syntax tree node's parent node, if unset:::if
SyntaxTreeNode#getParent():::Returns this syntax tree node's parent node.:::return
SyntaxTreeNode#isDummy():::Returns 'true' if this syntax tree node is the Sentinal node.:::return
SyntaxTreeNode#getImportPrecedence():::Get the import precedence of this element:::stylesheet->getStylesheet->if->return->return->stylesheet->getImportPrecedence
SyntaxTreeNode#getStylesheet():::Get the Stylesheet node that represents the <xsl:stylesheet/> element that this node occured under.:::if->parent->while->if->return->parent->getParent->return
SyntaxTreeNode#getTemplate():::Get the Template node that represents the <xsl:template/> element that this node occured under:::if->parent->while->parent->getParent->return
SyntaxTreeNode#getXSLTC():::Returns a reference to the XSLTC (XSLT compiler) in use.:::return->_parser->getXSLTC
SyntaxTreeNode#getSymbolTable():::Returns the XSLT parser's symbol table.:::return->_parser->getSymbolTable
SyntaxTreeNode#parseContents(Parser):::Parse the contents of this syntax tree nodes (child nodes, XPath expressions, patterns and functions):::parseChildren
SyntaxTreeNode#parseChildren(Parser):::Parse all children of this syntax tree node:::locals->foreach->parser->getSymbolTable->setCurrentNode->child->parseContents->varOrParamName->updateScope->if->if->new->ArrayList<>->locals->add->parser->getSymbolTable->setCurrentNode->if->foreach->parser->removeVariable
SyntaxTreeNode#updateScope(Parser, SyntaxTreeNode):::Add a node to the current scope and return name of a variable or parameter if the node represents a variable or a parameter.:::if->var->parser->addVariable->return->var->getName->else->if->param->parser->addParameter->return->param->getName->else->return
SyntaxTreeNode#typeCheck(SymbolTable):::Type check the children of this node:::
SyntaxTreeNode#typeCheckContents(SymbolTable):::Call typeCheck() on all child syntax tree nodes.:::foreach->item->typeCheck->return
SyntaxTreeNode#translate(ClassGenerator, MethodGenerator):::Translate this abstract syntax tree node into JVM bytecodes.:::
SyntaxTreeNode#translateContents(ClassGenerator, MethodGenerator):::Call translate() on all child syntax tree nodes.:::n->elementCount->foreach->methodGen->markChunkStart->item->translate->methodGen->markChunkEnd->for->i
SyntaxTreeNode#notTypeOf(Class):::Checks whether any children of this node is not of the specified type.:::if->_contents->size->foreach->if->item->getClass->isAssignableFrom->return->return
SyntaxTreeNode#isSimpleRTF(SyntaxTreeNode):::Return true if the node represents a simple RTF:::contents->node->getContents->if->contents->stream->isTextElement->noneMatch->return->return
SyntaxTreeNode#isAdaptiveRTF(SyntaxTreeNode):::Return true if the node represents an adaptive RTF:::contents->node->getContents->foreach->if->isTextElement->return->return
SyntaxTreeNode#isTextElement(SyntaxTreeNode, boolean):::Return true if the node only produces Text content:::if->return->else->if->return->isAdaptiveRTF->isSimpleRTF->else->if->contents->node->getContents->foreach->if->isAdaptiveRTF->isSimpleRTF->continue->else->return->return->else->if->return->else->return
SyntaxTreeNode#compileResultTree(ClassGenerator, MethodGenerator):::Utility method used by parameters and variables to store result trees:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->stylesheet->classGen->getStylesheet->isSimple->isSimpleRTF->isAdaptive->if->isAdaptiveRTF->rtfType->il->methodGen->loadHandler->append->DOM_CLASS->classGen->getDOMClass->il->methodGen->loadDOM->append->index->cpg->addInterfaceMethodref->il->new->PUSH->append->il->new->PUSH->append->il->stylesheet->callsNodeset->new->PUSH->append->il->new->INVOKEINTERFACE->append->il->append->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append->il->append->il->methodGen->storeHandler->append->il->methodGen->startDocument->append->translateContents->il->methodGen->loadHandler->append->il->methodGen->endDocument->append->if->stylesheet->callsNodeset->DOM_CLASS->equals->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->new->DUP_X1->append->il->append->if->stylesheet->callsNodeset->il->new->ICONST->append->il->cpg->addClass->new->ANEWARRAY->append->il->append->il->append->il->new->ICONST->append->il->new->NEWARRAY->append->il->append->il->new->INVOKESPECIAL->append->else->il->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->cpg->addFieldref->new->GETFIELD->append->il->new->INVOKESPECIAL->append->il->append->il->methodGen->loadDOM->append->il->cpg->classGen->getDOMClass->addClass->new->CHECKCAST->append->il->append->cpg->addMethodref->il->new->INVOKEVIRTUAL->append->il->append->il->append->il->methodGen->storeHandler->append
SyntaxTreeNode#contextDependent():::Returns true if this expression/instruction depends on the context:::return
SyntaxTreeNode#dependentContents():::Return true if any of the expressions/instructions in the contents of this node is context dependent.:::foreach->if->item->contextDependent->return->return
SyntaxTreeNode#addElement(SyntaxTreeNode):::Adds a child node to this syntax tree node.:::_contents->add->element->setParent
SyntaxTreeNode#setFirstElement(SyntaxTreeNode):::Inserts the first child node of this syntax tree node:::_contents->add->element->setParent
SyntaxTreeNode#removeElement(SyntaxTreeNode):::Removed a child node of this syntax tree node.:::_contents->remove->element->setParent
SyntaxTreeNode#getContents():::Returns a List containing all the child nodes of this node.:::return
SyntaxTreeNode#hasContents():::Tells you if this node has any child nodes.:::return->elementCount
SyntaxTreeNode#elementCount():::Returns the number of children this node has.:::return->_contents->size
SyntaxTreeNode#elements():::Returns an Iterator of all child nodes of this node.:::return->_contents->iterator
SyntaxTreeNode#elementAt(int):::Returns a child node at a given position.:::return->_contents->get
SyntaxTreeNode#lastChild():::Returns this element's last child:::if->_contents->isEmpty->return->return->_contents->_contents->size->get
SyntaxTreeNode#display(int):::Displays the contents of this syntax tree node (to stdout):::displayContents
SyntaxTreeNode#displayContents(int):::Displays the contents of this syntax tree node (to stdout):::foreach->item->display
SyntaxTreeNode#indent(int):::Set the indentation level for debug output.:::new->String->print
SyntaxTreeNode#reportError(SyntaxTreeNode, Parser, String, String):::Report an error to the parser.:::error->new->ErrorMsg->parser->reportError
SyntaxTreeNode#reportWarning(SyntaxTreeNode, Parser, String, String):::Report a recoverable error to the parser.:::error->new->ErrorMsg->parser->reportError
Template#hasParams()::: template has params:::return->_parameters->size
Template#isSimplified()::: template is simplified:::return
Template#setSimplified()::: template set simplified:::
Template#isSimpleNamedTemplate()::: template is simple named template:::return
Template#addParameter(Param)::: template add parameter:::_parameters->add
Template#getParameters()::: template get parameters:::return
Template#disable()::: template disable:::
Template#disabled()::: template disabled:::return
Template#getPriority()::: template get priority:::return
Template#getPosition()::: template get position:::return
Template#isNamed()::: template is named:::return
Template#getPattern()::: template get pattern:::return
Template#getName()::: template get name:::return
Template#setName(QName)::: template set name:::if
Template#getModeName()::: template get mode name:::return
Template#compareTo(Object):::Compare this template to another:::other->if->return->else->if->return->else->if->return->else->if->return->else->return
Template#display(int)::: template display:::Util->println->indent->if->indent->Util->println->else->if->indent->Util->_pattern->toString->println->if->indent->Util->println->displayContents
Template#resolveNamedTemplates(Template, Parser)::: template resolve named templates:::if->return->stable->parser->getSymbolTable->us->this->getImportPrecedence->them->other->getImportPrecedence->if->other->disable->return->else->if->stable->addTemplate->this->disable->return->else->return
Template#getStylesheet()::: template get stylesheet:::return
Template#parseContents(Parser)::: template parse contents:::name->getAttribute->mode->getAttribute->match->getAttribute->priority->getAttribute->super->getStylesheet->if->name->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->if->mode->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->if->match->length->parser->parsePattern->if->priority->length->Double->parseDouble->else->if->_pattern->getPriority->else->parser->getTemplateIndex->if->other->parser->getSymbolTable->addTemplate->if->resolveNamedTemplates->err->new->ErrorMsg->parser->reportError->if->if->addTemplate->parser->setTemplate->parseChildren->parser->setTemplate
Template#parseSimplified(Stylesheet, Parser):::When the parser realises that it is dealign with a simplified stylesheet it will create an empty Stylesheet object with the root element of the stylesheet (a LiteralElement object) as its only child:::setParent->parser->parsePattern->contents->_stylesheet->getContents->root->contents->get->if->addElement->root->setParent->contents->set->parser->setTemplate->root->parseContents->parser->setTemplate
Template#typeCheck(SymbolTable)::: template type check:::if->_pattern->typeCheck->return->typeCheckContents
Template#translate(ClassGenerator, MethodGenerator)::: template translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->return->className->classGen->getClassName->if->isNamed->methodName->Util->_name->toString->escape->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->return->if->return->if->numParams->_parameters->size->namedMethodGen->for->i->translateContents->il->setPositions
TestSeq#toString():::Returns a string representation of this test sequence:::count->_patterns->size->result->new->StringBuffer->for->i->return->result->toString
TestSeq#getInstructionList():::Returns the instruction list for this test sequence:::return
TestSeq#getPriority():::Return the highest priority for a pattern in this test sequence:::template->_patterns->isEmpty->_patterns->get->getTemplate->return->template->getPriority
TestSeq#getPosition():::Returns the position of the highest priority pattern in this test sequence.:::template->_patterns->isEmpty->_patterns->get->getTemplate->return->template->getPosition
TestSeq#reduce():::Reduce the patterns in this test sequence:::newPatterns->new->ArrayList<>->foreach->pattern->reduceKernelPattern->if->pattern->isWildcard->pattern->getTemplate->break->else->newPatterns->add
TestSeq#findTemplates(Map):::Returns, by reference, the templates that are included in this test sequence:::if->templates->put->foreach->templates->pattern->getTemplate->put
TestSeq#getTemplateHandle(Template):::Get the instruction handle to a template's code:::return->_mode->getTemplateInstructionHandle
TestSeq#getPattern(int):::Returns pattern n in this test sequence:::return->_patterns->get
TestSeq#compile(ClassGenerator, MethodGenerator, InstructionHandle):::Compile the code for this test sequence:::if->return->count->_patterns->size->if->return->getTemplateHandle->fail->getTemplateHandle->for->n->return
Text#getText():::Returns the text wrapped inside this node:::return
Text#setText(String):::Set the text for this node:::if->else
Text#display(int)::: text display:::indent->Util->println->indent->Util->println
Text#parseContents(Parser)::: text parse contents:::str->getAttribute->if->str->equals->parseChildren->if->if->else->else->if->if->_text->length->else->if->getParent->element->getParent->space->element->getAttribute->if->space->equals->i->textLength->_text->length->for->if->else->i->textLength->_text->length->for->if
Text#ignore()::: text ignore:::
Text#isIgnore()::: text is ignore:::return
Text#isTextElement()::: text is text element:::return
Text#contextDependent()::: text context dependent:::return
Text#isWhitespace(char)::: text is whitespace:::return
Text#translate(ClassGenerator, MethodGenerator)::: text translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->esc->cpg->addInterfaceMethodref->if->il->methodGen->loadHandler->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->il->methodGen->loadHandler->append->if->canLoadAsArrayOffsetLength->characters->cpg->addInterfaceMethodref->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->else->characters->cpg->addInterfaceMethodref->loadAsArrayOffsetLength->il->new->INVOKEINTERFACE->append->if->il->methodGen->loadHandler->append->il->append->il->new->INVOKEINTERFACE->append->il->append->translateContents
Text#canLoadAsArrayOffsetLength():::Check whether this Text node can be stored in a char[] in the translet:::return->_text->length
Text#loadAsArrayOffsetLength(ClassGenerator, MethodGenerator):::Generates code that loads the array that will contain the character data represented by this Text node, followed by the offset of the data from the start of the array, and then the length of the data:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->xsltc->classGen->getParser->getXSLTC->offset->xsltc->addCharacterData->length->_text->length->charDataFieldName->xsltc->getCharacterDataCount->il->cpg->xsltc->getClassName->addFieldref->new->GETSTATIC->append->il->new->PUSH->append->il->_text->length->new->PUSH->append
TopLevelElement#typeCheck(SymbolTable):::Type check all the children of this node.:::return->typeCheckContents
TopLevelElement#translate(ClassGenerator, MethodGenerator):::Translate this node into JVM bytecodes.:::msg->getClass->new->ErrorMsg->getParser->reportError
TopLevelElement#compile(ClassGenerator, MethodGenerator):::Translate this node into a fresh instruction list:::result->save->methodGen->getInstructionList->methodGen->new->InstructionList->setInstructionList->translate->methodGen->setInstructionList->return
TopLevelElement#display(int)::: top level element display:::indent->Util->println->displayContents
TopLevelElement#addDependency(TopLevelElement):::Add a dependency with other top-level elements like variables, parameters or keys.:::if->new->ArrayList<>->if->_dependencies->contains->_dependencies->add
TopLevelElement#getDependencies():::Get the list of dependencies with other top-level elements like variables, parameteres or keys.:::return
TransletOutput#display(int):::Displays the contents of this <xsltc:output> element.:::indent->Util->println
TransletOutput#parseContents(Parser):::Parse the contents of this <xsltc:output> element:::filename->getAttribute->append->getAttribute->if->filename->equals->reportError->AttributeValue->create->if->append->toLowerCase->equals->append->toLowerCase->equals->else->parseChildren
TransletOutput#typeCheck(SymbolTable):::Type checks the 'file' attribute (must be able to convert it to a str).:::type->_filename->typeCheck->if->new->CastExpr->typeCheckContents->return
TransletOutput#translate(ClassGenerator, MethodGenerator):::Compile code that opens the give file for output, dumps the contents of the element to the file, then closes the file.:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->isSecureProcessing->classGen->getParser->getXSLTC->isSecureProcessing->isExtensionFunctionEnabled->classGen->getParser->getXSLTC->getFeature->if->index->cpg->addMethodref->il->new->PUSH->append->il->new->INVOKESTATIC->append->return->il->methodGen->loadHandler->append->open->cpg->addMethodref->close->cpg->addMethodref->il->classGen->loadTranslet->append->_filename->translate->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->il->methodGen->storeHandler->append->translateContents->il->classGen->loadTranslet->append->il->methodGen->loadHandler->append->il->new->INVOKEVIRTUAL->append->il->methodGen->storeHandler->append
UnaryOpExpr#hasPositionCall():::Returns true if this expressions contains a call to position():::return->_left->hasPositionCall
UnaryOpExpr#hasLastCall():::Returns true if this expressions contains a call to last():::return->_left->hasLastCall
UnaryOpExpr#setParser(Parser)::: unary op expr set parser:::super->setParser->_left->setParser
UnaryOpExpr#typeCheck(SymbolTable)::: unary op expr type check:::tleft->_left->typeCheck->ptype->new->MethodType->lookupPrimop->if->arg1->ptype->argsType->get->if->arg1->identicalTo->new->CastExpr->return->ptype->resultType->throw->new->TypeCheckError
UnaryOpExpr#toString()::: unary op expr to string:::return
UnaryOpExpr#translate(ClassGenerator, MethodGenerator)::: unary op expr translate:::il->methodGen->getInstructionList->_left->translate->il->_type->NEG->append
UnionPathExpr#setParser(Parser)::: union path expr set parser:::super->setParser->components->new->ArrayList<>->flatten->size->components->size->components->new->ExpressionArr->toArray->for->i->if->getParent
UnionPathExpr#typeCheck(SymbolTable)::: union path expr type check:::length->for->i->return
UnionPathExpr#toString()::: union path expr to string:::return
UnionPathExpr#flatten(List)::: union path expr flatten:::components->add->if->if->flatten->else->components->add
UnionPathExpr#translate(ClassGenerator, MethodGenerator)::: union path expr translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->init->cpg->addMethodref->iter->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->methodGen->loadDOM->append->il->new->INVOKESPECIAL->append->length->for->i->if->order->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->il->append->il->methodGen->loadContextNode->append->il->new->INVOKEINTERFACE->append
UnparsedEntityUriCall#typeCheck(SymbolTable)::: unparsed entity uri call type check:::entity->_entity->typeCheck->if->new->CastExpr->return
UnparsedEntityUriCall#translate(ClassGenerator, MethodGenerator)::: unparsed entity uri call translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->methodGen->loadDOM->append->_entity->translate->il->cpg->addInterfaceMethodref->new->INVOKEINTERFACE->append
UnresolvedRef#getName()::: unresolved ref get name:::return
UnresolvedRef#reportError()::: unresolved ref report error:::err->new->ErrorMsg->getParser->reportError->return
UnresolvedRef#resolve(Parser, SymbolTable)::: unresolved ref resolve:::ref->parser->lookupVariable->if->stable->lookupName->if->reportError->return->addParentDependency->if->return->new->VariableRef->else->if->return->new->ParameterRef->return
UnresolvedRef#typeCheck(SymbolTable)::: unresolved ref type check:::if->name->_variableName->toString->err->new->ErrorMsg->if->getParser->resolve->return->_ref->typeCheck->throw->reportError->new->TypeCheckError
UnresolvedRef#translate(ClassGenerator, MethodGenerator)::: unresolved ref translate:::if->_ref->translate->else->reportError
UnresolvedRef#toString()::: unresolved ref to string:::return
UnsupportedElement#setErrorMessage(ErrorMsg):::There are different categories of unsupported elements (believe it or not): there are elements within the XSLT namespace (these would be elements that are not yet implemented), there are extensions of other XSLT processors and there are unrecognised extension elements of this XSLT processor:::
UnsupportedElement#display(int):::Displays the contents of this element:::indent->Util->_qname->getNamespace->_qname->getLocalPart->println->displayContents
UnsupportedElement#processFallbacks(Parser):::Scan and process all fallback children of the unsupported element.:::children->getContents->if->count->children->size->for->i
UnsupportedElement#parseContents(Parser):::Find any fallback in the descendant nodes; then activate & parse it:::processFallbacks
UnsupportedElement#typeCheck(SymbolTable):::Run type check on the fallback element (if any).:::if->count->_fallbacks->size->for->i->return
UnsupportedElement#translate(ClassGenerator, MethodGenerator):::Translate the fallback element (if any).:::if->count->_fallbacks->size->for->i->else->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->unsupportedElem->cpg->addMethodref->il->getQName->toString->new->PUSH->append->il->new->PUSH->append->il->new->INVOKESTATIC->append
UseAttributeSets#addAttributeSets(String):::This method is made public to enable an AttributeSet object to merge itself with another AttributeSet (including any other AttributeSets the two may inherit from).:::if->setNames->equals->tokens->new->StringTokenizer->while->tokens->hasMoreTokens->qname->getParser->tokens->nextToken->getQNameIgnoreDefaultNs->_sets->add
UseAttributeSets#typeCheck(SymbolTable):::Do nada.:::return
UseAttributeSets#translate(ClassGenerator, MethodGenerator):::Generate a call to the method compiled for this attribute set:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->symbolTable->getParser->getSymbolTable->foreach->attrs->symbolTable->lookupAttributeSet->if->methodName->attrs->getMethodName->il->classGen->loadTranslet->append->il->methodGen->loadDOM->append->il->methodGen->loadIterator->append->il->methodGen->loadHandler->append->il->methodGen->loadCurrentNode->append->method->cpg->classGen->getClassName->addMethodref->il->new->INVOKESPECIAL->append->else->parser->getParser->atrs->name->toString->reportError
ValueOf#display(int)::: value of display:::indent->Util->println->indent->Util->_select->toString->println
ValueOf#parseContents(Parser)::: value of parse contents:::parser->parseExpression->if->_select->isDummy->reportError->return->str->getAttribute->if->str->equals
ValueOf#typeCheck(SymbolTable)::: value of type check:::type->_select->typeCheck->if->type->identicalTo->if->type->identicalTo->new->CastExpr->else->if->type->identicalTo->new->CastExpr->return
ValueOf#translate(ClassGenerator, MethodGenerator)::: value of translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->setEscaping->cpg->addInterfaceMethodref->if->il->methodGen->loadHandler->append->il->new->PUSH->append->il->new->INVOKEINTERFACE->append->if->characters->cpg->addMethodref->il->classGen->loadTranslet->append->_select->translate->il->methodGen->loadHandler->append->il->new->INVOKEVIRTUAL->append->else->characters->cpg->addInterfaceMethodref->il->methodGen->loadDOM->append->_select->translate->il->methodGen->loadHandler->append->il->new->INVOKEINTERFACE->append->if->il->methodGen->loadHandler->append->il->append->il->new->INVOKEINTERFACE->append->il->append
Variable#getIndex()::: variable get index:::return->_local->getIndex
Variable#parseContents(Parser):::Parse the contents of the variable:::super->parseContents->parent->getParent->if->var->parser->getSymbolTable->lookupVariable->if->us->this->getImportPrecedence->them->var->getImportPrecedence->if->name->_name->toString->reportError->else->if->copyReferences->return->else->var->copyReferences->var->disable->addVariable->parser->getSymbolTable->addVariable->else
Variable#typeCheck(SymbolTable):::Runs a type check on either the variable element body or the expression in the 'select' attribute:::if->_select->typeCheck->else->if->hasContents->typeCheckContents->else->return
Variable#initialize(ClassGenerator, MethodGenerator):::This method is part of a little trick that is needed to use local variables inside nested for-each loops:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->isLocal->_refs->isEmpty->if->methodGen->getEscapedName->_type->toJCType->addLocalVariable2->if->il->new->ICONST->append->else->if->il->new->DCONST->append->else->il->new->ACONST_NULL->append->_local->il->_type->_local->getIndex->STORE->append->setStart
Variable#translate(ClassGenerator, MethodGenerator)::: variable translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->_refs->isEmpty->if->return->name->getEscapedName->if->isLocal->translateValue->createLocal->if->mapRegister->storeInst->il->_type->_local->getIndex->STORE->append->if->_local->setStart->else->signature->_type->toSignature->if->classGen->containsField->classGen->cpg->addUtf8->cpg->addUtf8->cpg->getConstantPool->new->Field->addField->il->classGen->loadTranslet->append->translateValue->il->cpg->classGen->getClassName->addFieldref->new->PUTFIELD->append
VariableBase#disable():::Disable this variable/parameter:::
VariableBase#addReference(VariableRefBase):::Add a reference to this variable:::_refs->add
VariableBase#copyReferences(VariableBase):::When a variable is overriden by another, e.g:::size->_refs->size->for->i
VariableBase#mapRegister(MethodGenerator):::Map this variable to a register:::if->il->methodGen->getInstructionList->name->getEscapedName->varType->_type->toJCType->methodGen->il->getEnd->addLocalVariable2
VariableBase#unmapRegister(ClassGenerator, MethodGenerator):::Remove the mapping of this variable to a register:::if->if->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->classGen->getStylesheet->callsNodeset->classGen->getDOMClass->equals->removeDA->cpg->addMethodref->il->methodGen->loadDOM->append->il->cpg->addClass->new->CHECKCAST->append->il->loadInstruction->append->il->cpg->addClass->new->CHECKCAST->append->il->new->INVOKEVIRTUAL->append->release->cpg->addInterfaceMethodref->il->loadInstruction->append->il->new->INVOKEINTERFACE->append->_local->methodGen->getInstructionList->getEnd->setEnd->methodGen->removeLocalVariable
VariableBase#loadInstruction():::Returns an instruction for loading the value of this variable onto the JVM stack.:::if->_type->_local->getIndex->LOAD->return
VariableBase#storeInstruction():::Returns an instruction for storing a value from the JVM stack into this variable.:::if->_type->_local->getIndex->STORE->return
VariableBase#getExpression():::Returns the expression from this variable's select attribute (if any):::return
VariableBase#toString():::Display variable as single string:::return
VariableBase#display(int):::Display variable in a full AST dump:::indent->println->if->indent->_select->toString->println->displayContents
VariableBase#getType():::Returns the type of the variable:::return
VariableBase#getName():::Returns the name of the variable or parameter as it will occur in the compiled translet.:::return
VariableBase#getEscapedName():::Returns the escaped qname of the variable or parameter:::return
VariableBase#setName(QName):::Set the name of the variable or paremeter:::Util->name->getStringRep->escape
VariableBase#isLocal():::Returns the true if the variable is local:::return
VariableBase#parseContents(Parser):::Parse the contents of the <xsl:decimal-format> element.:::name->getAttribute->if->name->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->setName->else->reportError->other->parser->lookupVariable->if->other->getParent->getParent->reportError->getAttribute->if->select->length->getParser->parseExpression->if->_select->isDummy->reportError->return->parseChildren
VariableBase#translateValue(ClassGenerator, MethodGenerator):::Compile the value of the variable, which is either in an expression in a 'select' attribute, or in the variable elements body:::if->_select->translate->if->_select->getType->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->initCNI->cpg->addMethodref->il->cpg->addClass->new->NEW->append->il->append->il->append->il->new->INVOKESPECIAL->append->_select->startIterator->else->if->hasContents->compileResultTree->else->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
VariableRef#translate(ClassGenerator, MethodGenerator)::: variable ref translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->_type->implementedAsMethod->return->name->_variable->getEscapedName->signature->_type->toSignature->if->_variable->isLocal->if->classGen->isExternal->variableClosure->while->if->variableClosure->inInnerClass->break->variableClosure->getParentClosure->if->il->append->il->cpg->variableClosure->getInnerClassName->addFieldref->new->GETFIELD->append->else->il->_variable->loadInstruction->append->else->il->_variable->loadInstruction->append->else->className->classGen->getClassName->il->classGen->loadTranslet->append->if->classGen->isExternal->il->cpg->addClass->new->CHECKCAST->append->il->cpg->addFieldref->new->GETFIELD->append->if->_variable->getType->clone->cpg->addInterfaceMethodref->il->new->INVOKEINTERFACE->append
VariableRefBase#getVariable():::Returns a reference to the associated variable:::return
VariableRefBase#addParentDependency():::If this variable reference is in a top-level element like another variable, param or key, add a dependency between that top-level element and the referenced variable:::node->while->node->getParent->parent->if->var->if->if->parent->getSymbolTable->lookupVariable->else->if->parent->getSymbolTable->lookupParam->parent->addDependency
VariableRefBase#equals(Object):::Two variable references are deemed equal if they refer to the same variable.:::return
VariableRefBase#hashCode()::: variable ref base hash code:::return->Objects->hashCode
VariableRefBase#toString():::Returns a string representation of this variable reference on the format 'variable-ref(<var-name>)'.:::return->_variable->getName->_variable->getType
VariableRefBase#typeCheck(SymbolTable)::: variable ref base type check:::if->return->if->_variable->isLocal->node->getParent->do->if->break->if->break->node->getParent->while->if->_closure->addVariable->_variable->getType->if->_variable->typeCheck->_variable->getType->addParentDependency->return
When#display(int)::: when display:::indent->Util->println->indent->print->Util->_test->toString->println->displayContents
When#getTest()::: when get test:::return
When#ignore()::: when ignore:::return
When#parseContents(Parser)::: when parse contents:::parser->parseExpression->result->_test->evaluateAtCompileTime->if->booleanValue->parseChildren->if->_test->isDummy->reportError
When#typeCheck(SymbolTable):::Type-check this when element:::if->_test->typeCheck->new->CastExpr->if->typeCheckContents->return
When#translate(ClassGenerator, MethodGenerator):::This method should never be called:::msg->new->ErrorMsg->getParser->reportError
Whitespace.WhitespaceRule#compareTo(WhitespaceRule):::For sorting rules depending on priority:::return
Whitespace.WhitespaceRule#getAction()::: whitespace rule get action:::return
Whitespace.WhitespaceRule#getStrength()::: whitespace rule get strength:::return
Whitespace.WhitespaceRule#getPriority()::: whitespace rule get priority:::return
Whitespace.WhitespaceRule#getElement()::: whitespace rule get element:::return
Whitespace.WhitespaceRule#getNamespace()::: whitespace rule get namespace:::return
Whitespace#parseContents(Parser):::Parse the attributes of the xsl:strip/preserve-space element:::_qname->getLocalPart->endsWith->parser->getCurrentImportPrecedence->getAttribute->if->_elementList->length->reportError->return->stable->parser->getSymbolTable->list->new->StringTokenizer->elements->new->StringBuffer->while->list->hasMoreElements->token->list->nextToken->prefix->namespace->col->token->indexOf->if->token->substring->lookupNamespace->if->elements->append->append->token->substring->append->else->elements->append->else->elements->append->if->list->hasMoreElements->elements->append->elements->toString
Whitespace#getRules():::De-tokenize the elements listed in the 'elements' attribute and instanciate a set of strip/preserve rules.:::rules->new->ArrayList<>->list->new->StringTokenizer->while->list->hasMoreElements->rules->list->nextToken->new->WhitespaceRule->add->return
Whitespace#findContradictingRule(List, WhitespaceRule):::Scans through the rules vector and looks for a rule of higher priority that contradicts the current rule.:::foreach->if->return->switch->currentRule->getStrength->return->if->rule->getElement->currentRule->getElement->equals->break->if->rule->getNamespace->currentRule->getNamespace->equals->return->break->return
Whitespace#prioritizeRules(List):::Orders a set or rules by priority, removes redundant rules and rules that are shadowed by stronger, contradicting rules.:::currentRule->defaultAction->rules->size->quicksort->strip->for->i->rules->size->if->rules->clear->return->for->idx->rules->size->if->rules->isEmpty->return->do->rules->rules->size->get->if->currentRule->getAction->rules->rules->size->remove->else->break->while->rules->size->return
Whitespace#compileStripSpace(BranchHandle[], int, InstructionList)::: whitespace compile strip space:::target->il->append->il->append->for->i
Whitespace#compilePreserveSpace(BranchHandle[], int, InstructionList)::: whitespace compile preserve space:::target->il->append->il->append->for->i
Whitespace#compilePredicate(List, int, ClassGenerator):::Compiles the predicate method:::cpg->classGen->getConstantPool->il->new->InstructionList->xsltc->classGen->getParser->getXSLTC->stripSpace->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->new->StringArr->classGen->getClassName->new->MethodGenerator->classGen->addInterface->paramDom->stripSpace->getLocalIndex->paramCurrent->stripSpace->getLocalIndex->paramType->stripSpace->getLocalIndex->strip->rules->size->new->BranchHandleArr->preserve->rules->size->new->BranchHandleArr->sCount->pCount->for->i->rules->size->if->compileStripSpace->compilePreserveSpace->else->compilePreserveSpace->compileStripSpace->classGen->addMethod
Whitespace#compileDefault(int, ClassGenerator):::Compiles the predicate method:::cpg->classGen->getConstantPool->il->new->InstructionList->xsltc->classGen->getParser->getXSLTC->stripSpace->new->com.sun.org.apache.bcel.internal.generic.TypeArr->Util->getJCRefType->new->StringArr->classGen->getClassName->new->MethodGenerator->classGen->addInterface->if->il->append->else->il->append->il->append->classGen->addMethod
Whitespace#translateRules(List, ClassGenerator):::Takes a vector of WhitespaceRule objects and generates a predicate method:::defaultAction->prioritizeRules->if->rules->size->compileDefault->return->compilePredicate->return
Whitespace#quicksort(List, int, int):::Sorts a range of rules with regard to PRIORITY only:::while->q->partition->quicksort
Whitespace#partition(List, int, int):::Used with quicksort method above:::x->rules->get->i->j->while->while->x->rules->get->compareTo->while->x->rules->get->compareTo->if->tmp->rules->get->rules->rules->get->set->rules->set->else->return
Whitespace#typeCheck(SymbolTable):::Type-check contents/attributes - nothing to do...:::return
Whitespace#translate(ClassGenerator, MethodGenerator):::This method should not produce any code:::
WithParam#display(int):::Displays the contents of this element:::indent->Util->println->if->indent->Util->_select->toString->println->displayContents
WithParam#getEscapedName():::Returns the escaped qname of the parameter:::return
WithParam#getName():::Return the name of this WithParam.:::return
WithParam#setName(QName):::Set the name of the variable or paremeter:::Util->name->getStringRep->escape
WithParam#setDoParameterOptimization(boolean):::Set the do parameter optimization flag:::
WithParam#parseContents(Parser):::The contents of a <xsl:with-param> elements are either in the element's 'select' attribute (this has precedence) or in the element body.:::name->getAttribute->if->name->length->if->XML11Char->isXML11ValidQName->err->new->ErrorMsg->parser->reportError->parser->getQNameIgnoreDefaultNs->setName->else->reportError->select->getAttribute->if->select->length->parser->parseExpression->parseChildren
WithParam#typeCheck(SymbolTable):::Type-check either the select attribute or the element body, depending on which is in use.:::if->tselect->_select->typeCheck->if->new->CastExpr->else->typeCheckContents->return
WithParam#translateValue(ClassGenerator, MethodGenerator):::Compile the value of the parameter, which is either in an expression in a 'select' attribute, or in the with-param element's body:::if->_select->translate->_select->startIterator->else->if->hasContents->il->methodGen->getInstructionList->compileResultTree->methodGen->toJCType->il->getEnd->addLocalVariable2->il->append->il->_domAdapter->getIndex->new->ASTORE->append->else->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->il->new->PUSH->append
WithParam#translate(ClassGenerator, MethodGenerator):::This code generates a sequence of bytecodes that call the addParameter() method in AbstractTranslet:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->translateValue->return->name->Util->getEscapedName->escape->il->classGen->loadTranslet->append->il->new->PUSH->append->translateValue->il->new->PUSH->append->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->il->append
WithParam#releaseResultTree(ClassGenerator, MethodGenerator):::Release the compiled result tree.:::if->cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->classGen->getStylesheet->callsNodeset->classGen->getDOMClass->equals->removeDA->cpg->addMethodref->il->methodGen->loadDOM->append->il->cpg->addClass->new->CHECKCAST->append->il->_domAdapter->getIndex->new->ALOAD->append->il->cpg->addClass->new->CHECKCAST->append->il->new->INVOKEVIRTUAL->append->release->cpg->addInterfaceMethodref->il->_domAdapter->getIndex->new->ALOAD->append->il->new->INVOKEINTERFACE->append->_domAdapter->il->getEnd->setEnd->methodGen->removeLocalVariable
XPathLexer#initialize()::: path lexer initialize:::
XPathLexer#isWhitespace(int)::: path lexer is whitespace:::return
XPathLexer#disambiguateAxisOrFunction(int):::If symbol is not followed by '::' or '(', then treat it as a name instead of an axis or function (Jira-1912).:::index->while->isWhitespace->if->return->new->Symbol->return->newSymbol->yytext->newSymbol
XPathLexer#disambiguateOperator(int):::If symbol is first token or if it follows any of the operators listed in http://www.w3.org/TR/xpath#exprlex then treat as a name instead of a keyword (Jira-1912):::switch->if->break->return->yytext->newSymbol->return->newSymbol
XPathLexer#newSymbol(int)::: path lexer new symbol:::return->new->Symbol
XPathLexer#newSymbol(int, String)::: path lexer new symbol:::return->new->Symbol
XPathLexer#newSymbol(int, Long)::: path lexer new symbol:::return->new->Symbol
XPathLexer#newSymbol(int, Double)::: path lexer new symbol:::return->new->Symbol
XPathLexer#yybegin(int)::: path lexer yybegin:::
XPathLexer#yy_advance()::: path lexer yy_advance:::next_read->i->j->if->return->if->while->yy_reader->read->if->return->while->if->yy_double->yy_reader->read->if->return->return
XPathLexer#yy_move_end()::: path lexer yy_move_end:::if->if
XPathLexer#yy_mark_start()::: path lexer yy_mark_start:::
XPathLexer#yy_mark_end()::: path lexer yy_mark_end:::
XPathLexer#yy_to_mark()::: path lexer yy_to_mark:::
XPathLexer#yytext()::: path lexer yytext:::return->new->java.lang.String
XPathLexer#yylength()::: path lexer yylength:::return
XPathLexer#yy_double(char[])::: path lexer yy_double:::i->newbuf->new->charArr->for->return
XPathLexer#yy_error(int, boolean)::: path lexer yy_error:::print->flush->if->throw->new->Error
XPathLexer#unpackFromString(int, int, String)::: path lexer unpack from string:::colonIndex->lengthString->sequenceLength->sequenceInteger->commaIndex->workString->res->new->intArrs->for->i->return
XPathLexer#next_token()::: path lexer next_token:::yy_lookahead->yy_anchor->yy_state->yy_next_state->yy_last_accept_state->yy_initial->yy_this_accept->yy_mark_start->if->yy_mark_end->while->if->else->yy_advance->if->return->newSymbol->if->if->yy_mark_end->else->if->throw->new->Error->else->if->yy_move_end->yy_to_mark->switch->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->yytext->newSymbol->break->throw->yytext->new->Exception->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->break->return->newSymbol->break->return->newSymbol->break->return->Long->yytext->valueOf->newSymbol->break->return->newSymbol->break->return->disambiguateAxisOrFunction->break->return->disambiguateOperator->break->return->newSymbol->break->return->yytext->newSymbol->break->return->newSymbol->break->return->Double->yytext->valueOf->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->newSymbol->break->return->yytext->yytext->length->substring->newSymbol->break->return->yytext->yytext->length->substring->newSymbol->break->return->Double->yytext->valueOf->newSymbol->break->return->disambiguateOperator->break->return->yytext->newSymbol->break->return->disambiguateOperator->break->return->disambiguateAxisOrFunction->break->return->disambiguateOperator->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->newSymbol->break->return->newSymbol->break->return->disambiguateAxisOrFunction->break->return->newSymbol->break->return->newSymbol->break->return->disambiguateAxisOrFunction->break->initialize->return->new->Symbol->break->return->disambiguateAxisOrFunction->break->return->newSymbol->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->newSymbol->break->initialize->return->new->Symbol->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->disambiguateAxisOrFunction->break->return->newSymbol->break->return->newSymbol->break->return->yytext->newSymbol->break->throw->yytext->new->Exception->break->return->Long->yytext->valueOf->newSymbol->break->return->Double->yytext->valueOf->newSymbol->break->return->yytext->newSymbol->break->throw->yytext->new->Exception->break->return->yytext->newSymbol->break->throw->yytext->new->Exception->break->return->yytext->newSymbol->break->throw->yytext->new->Exception->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->return->yytext->newSymbol->break->yy_error->yy_mark_start->if->yy_mark_end
XPathParser#production_table():::Access to production table.:::return
XPathParser#action_table():::Access to parse-action table.:::return
XPathParser#reduce_table():::Access to reduce_goto table.:::return
XPathParser#init_actions():::Action encapsulation object initializer.:::new->parser_actions
XPathParser#do_action(int, lr_parser, Stack, int):::Invoke a user supplied parse action.:::return->action_obj->parser_do_action
XPathParser#start_state():::Indicates start state.:::return
XPathParser#start_production():::Indicates start production.:::return
XPathParser#EOF_sym():::EOF Symbol index.:::return
XPathParser#error_sym():::error Symbol index.:::return
XPathParser#getLineNumber()::: path parser get line number:::return
XPathParser#getQNameIgnoreDefaultNs(String)::: path parser get name ignore default ns:::return->_parser->getQNameIgnoreDefaultNs
XPathParser#getQName(String, String, String)::: path parser get name:::return->_parser->getQName
XPathParser#setMultiDocument(boolean)::: path parser set multi document:::_xsltc->setMultiDocument
XPathParser#setCallsNodeset(boolean)::: path parser set calls nodeset:::_xsltc->setCallsNodeset
XPathParser#setHasIdCall(boolean)::: path parser set has id call:::_xsltc->setHasIdCall
XPathParser#createStepPattern(int, Object, List):::This method is similar to findNodeType(int, Object) except that it creates a StepPattern instead of just returning a node type:::nodeType->if->return->new->StepPattern->else->if->return->new->StepPattern->else->name->setPriority->if->name->toString->equals->_xsltc->registerNamespacePrefix->else->uri->name->getNamespace->local->name->getLocalPart->namespace_uri->_parser->getQNameIgnoreDefaultNs->if->local->equals->local->equals->if->new->ArrayList<>->predicates->size->predicates->new->NamespaceUriCall->new->LiteralExpr->new->EqualityExpr->new->Predicate->add->if->local->equals->else->if->local->equals->else->_xsltc->registerAttribute->_xsltc->registerElement->result->new->StepPattern->if->result->setPriority->return
XPathParser#findNodeType(int, Object)::: path parser find node type:::if->return->else->if->return->else->name->if->return->name->toString->equals->_xsltc->registerNamespacePrefix->if->name->getNamespace->local->name->getLocalPart->if->local->equals->return->else->if->local->equals->return->return->_xsltc->registerAttribute->_xsltc->registerElement
XPathParser#parse(String, int):::Parse the expression passed to the current scanner:::try->return->super->parse->catch->err->e->getMessage->new->ErrorMsg->_parser->reportError->finally->return
XPathParser#lookupName(QName):::Lookup a variable or parameter in the symbol table given its name.:::result->_parser->lookupVariable->if->return->else->return->_symbolTable->lookupName
XPathParser#addError(ErrorMsg)::: path parser add error:::_parser->reportError
XPathParser#report_error(String, Object)::: path parser report_error:::err->new->ErrorMsg->_parser->reportError
XPathParser#report_fatal_error(String, Object)::: path parser report_fatal_error:::
XPathParser#insertStep(Step, RelativeLocationPath)::: path parser insert step:::if->return->new->ParentLocationPath->else->if->plp->newrlp->plp->getPath->insertStep->return->plp->getStep->new->ParentLocationPath->else->new->ErrorMsg->addError->return
XPathParser#isElementAxis(int):::Returns true if the axis applies to elements only:::return
parser_actions#parser_do_action(int, lr_parser, Stack, int):::Method with the actual generated action code.:::parser_result->switch->start_val->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->parser_parser->done_parsing->return->pattern->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->expr->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->lpp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->lpp->parser_stack->get->p->parser_stack->get->result->new->AlternativePattern->parser_stack->get->parser_stack->get->new->Symbol->return->result->new->AbsolutePathPattern->parser_stack->get->parser_stack->get->new->Symbol->return->rpp->parser_stack->get->result->new->AbsolutePathPattern->parser_stack->get->parser_stack->get->new->Symbol->return->ikp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ikp->parser_stack->get->rpp->parser_stack->get->result->new->ParentPattern->parser_stack->get->parser_stack->get->new->Symbol->return->ikp->parser_stack->get->rpp->parser_stack->get->result->new->AncestorPattern->parser_stack->get->parser_stack->get->new->Symbol->return->rpp->parser_stack->get->result->new->AncestorPattern->parser_stack->get->parser_stack->get->new->Symbol->return->rpp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->l->parser_stack->get->result->new->IdPattern->parser->setHasIdCall->parser_stack->get->parser_stack->get->new->Symbol->return->l1->parser_stack->get->l2->parser_stack->get->result->new->KeyPattern->parser_stack->get->parser_stack->get->new->Symbol->return->l->parser_stack->get->result->new->ProcessingInstructionPattern->parser_stack->get->parser_stack->get->new->Symbol->return->sp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->sp->parser_stack->get->rpp->parser_stack->get->result->new->ParentPattern->parser_stack->get->parser_stack->get->new->Symbol->return->sp->parser_stack->get->rpp->parser_stack->get->result->new->AncestorPattern->parser_stack->get->parser_stack->get->new->Symbol->return->nt->parser_stack->get->result->parser->createStepPattern->parser_stack->get->parser_stack->get->new->Symbol->return->nt->parser_stack->get->pp->parser_stack->get->result->parser->createStepPattern->parser_stack->get->parser_stack->get->new->Symbol->return->pip->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->pip->parser_stack->get->pp->parser_stack->get->result->pip->setPredicates->parser_stack->get->parser_stack->get->new->Symbol->return->axis->parser_stack->get->nt->parser_stack->get->result->parser->createStepPattern->parser_stack->get->parser_stack->get->new->Symbol->return->axis->parser_stack->get->nt->parser_stack->get->pp->parser_stack->get->result->parser->createStepPattern->parser_stack->get->parser_stack->get->new->Symbol->return->pip->parser_stack->get->result->parser_stack->get->parser_stack->get->new->Symbol->return->pip->parser_stack->get->pp->parser_stack->get->result->pip->setPredicates->parser_stack->get->parser_stack->get->new->Symbol->return->nt->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->qn->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->p->parser_stack->get->temp->new->ArrayList<>->temp->add->parser_stack->get->parser_stack->get->new->Symbol->return->p->parser_stack->get->pp->parser_stack->get->pp->add->parser_stack->get->parser_stack->get->new->Symbol->return->e->parser_stack->get->result->new->Predicate->parser_stack->get->parser_stack->get->new->Symbol->return->ex->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ae->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->oe->parser_stack->get->ae->parser_stack->get->result->new->LogicalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->e->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ae->parser_stack->get->ee->parser_stack->get->result->new->LogicalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->re->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ee->parser_stack->get->re->parser_stack->get->result->new->EqualityExpr->parser_stack->get->parser_stack->get->new->Symbol->return->ee->parser_stack->get->re->parser_stack->get->result->new->EqualityExpr->parser_stack->get->parser_stack->get->new->Symbol->return->ae->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->re->parser_stack->get->ae->parser_stack->get->result->new->RelationalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->re->parser_stack->get->ae->parser_stack->get->result->new->RelationalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->re->parser_stack->get->ae->parser_stack->get->result->new->RelationalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->re->parser_stack->get->ae->parser_stack->get->result->new->RelationalExpr->parser_stack->get->parser_stack->get->new->Symbol->return->me->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ae->parser_stack->get->me->parser_stack->get->result->new->BinOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->ae->parser_stack->get->me->parser_stack->get->result->new->BinOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->ue->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->me->parser_stack->get->ue->parser_stack->get->result->new->BinOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->me->parser_stack->get->ue->parser_stack->get->result->new->BinOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->me->parser_stack->get->ue->parser_stack->get->result->new->BinOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->ue->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ue->parser_stack->get->result->new->UnaryOpExpr->parser_stack->get->parser_stack->get->new->Symbol->return->pe->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->pe->parser_stack->get->rest->parser_stack->get->result->new->UnionPathExpr->parser_stack->get->parser_stack->get->new->Symbol->return->lp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->fexp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->fexp->parser_stack->get->rlp->parser_stack->get->result->new->FilterParentPath->parser_stack->get->parser_stack->get->new->Symbol->return->fexp->parser_stack->get->rlp->parser_stack->get->nodeType->if->parser->getAxis->isElementAxis->step->new->Step->fpp->new->FilterParentPath->new->FilterParentPath->if->fpp->setDescendantAxis->parser_stack->get->parser_stack->get->new->Symbol->return->rlp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->alp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->step->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->rlp->parser_stack->get->step->parser_stack->get->if->isAbbreviatedDot->else->if->isAbbreviatedDot->else->new->ParentLocationPath->parser_stack->get->parser_stack->get->new->Symbol->return->arlp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->new->AbsoluteLocationPath->parser_stack->get->parser_stack->get->new->Symbol->return->rlp->parser_stack->get->result->new->AbsoluteLocationPath->parser_stack->get->parser_stack->get->new->Symbol->return->aalp->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->rlp->parser_stack->get->step->parser_stack->get->right->axis->right->getAxis->type->right->getNodeType->predicates->right->getPredicates->if->if->right->setAxis->if->isAbbreviatedDot->else->left->new->ParentLocationPath->else->if->isAbbreviatedDot->left->new->Step->new->ParentLocationPath->else->left->mid->new->Step->ppl->new->ParentLocationPath->new->ParentLocationPath->else->if->left->middle->new->Step->ppl->new->ParentLocationPath->new->ParentLocationPath->else->left->middle->new->Step->ppl->new->ParentLocationPath->new->ParentLocationPath->parser_stack->get->parser_stack->get->new->Symbol->return->rlp->parser_stack->get->nodeType->if->parser->getAxis->isElementAxis->step->new->Step->result->parser->insertStep->new->AbsoluteLocationPath->parser_stack->get->parser_stack->get->new->Symbol->return->result->ntest->parser_stack->get->if->else->parser->findNodeType->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->result->ntest->parser_stack->get->pp->parser_stack->get->if->step->step->addPredicates->else->parser->findNodeType->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->axis->parser_stack->get->ntest->parser_stack->get->pp->parser_stack->get->result->parser->findNodeType->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->axis->parser_stack->get->ntest->parser_stack->get->result->parser->findNodeType->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->abbrev->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->an->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->result->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->primary->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->primary->parser_stack->get->pp->parser_stack->get->result->new->FilterExpr->parser_stack->get->parser_stack->get->new->Symbol->return->vr->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ex->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->string->parser_stack->get->namespace->index->string->lastIndexOf->if->prefix->string->substring->lookupNamespace->result->new->LiteralExpr->new->LiteralExpr->parser_stack->get->parser_stack->get->new->Symbol->return->result->num->parser_stack->get->if->new->RealExpr->else->if->num->doubleValue->num->doubleValue->new->RealExpr->else->if->num->intValue->num->intValue->new->IntExpr->else->if->num->doubleValue->num->doubleValue->new->RealExpr->else->num->intValue->new->IntExpr->parser_stack->get->parser_stack->get->new->Symbol->return->num->parser_stack->get->result->new->RealExpr->parser_stack->get->parser_stack->get->new->Symbol->return->fc->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->varName->parser_stack->get->node->parser->lookupName->if->if->new->VariableRef->else->if->new->ParameterRef->else->new->UnresolvedRef->if->new->UnresolvedRef->parser_stack->get->parser_stack->get->new->Symbol->return->result->fname->parser_stack->get->if->parser->getQNameIgnoreDefaultNs->new->CurrentCall->else->if->parser->getQNameIgnoreDefaultNs->new->NumberCall->else->if->parser->getQNameIgnoreDefaultNs->new->StringCall->else->if->parser->getQNameIgnoreDefaultNs->new->ConcatCall->else->if->parser->getQNameIgnoreDefaultNs->new->BooleanExpr->else->if->parser->getQNameIgnoreDefaultNs->new->BooleanExpr->else->if->parser->getQNameIgnoreDefaultNs->new->NameCall->else->if->parser->getQNameIgnoreDefaultNs->new->GenerateIdCall->else->if->parser->getQNameIgnoreDefaultNs->new->StringLengthCall->else->if->parser->getQNameIgnoreDefaultNs->new->PositionCall->else->if->parser->getQNameIgnoreDefaultNs->new->LastCall->else->if->parser->getQNameIgnoreDefaultNs->new->LocalNameCall->else->if->parser->getQNameIgnoreDefaultNs->new->NamespaceUriCall->else->new->FunctionCall->parser_stack->get->parser_stack->get->new->Symbol->return->result->fname->parser_stack->get->argl->parser_stack->get->if->parser->getQNameIgnoreDefaultNs->new->ConcatCall->else->if->parser->getQNameIgnoreDefaultNs->new->NumberCall->else->if->parser->getQNameIgnoreDefaultNs->parser->setMultiDocument->new->DocumentCall->else->if->parser->getQNameIgnoreDefaultNs->new->StringCall->else->if->parser->getQNameIgnoreDefaultNs->new->BooleanCall->else->if->parser->getQNameIgnoreDefaultNs->new->NameCall->else->if->parser->getQNameIgnoreDefaultNs->new->GenerateIdCall->else->if->parser->getQNameIgnoreDefaultNs->new->NotCall->else->if->parser->getQNameIgnoreDefaultNs->new->FormatNumberCall->else->if->parser->getQNameIgnoreDefaultNs->new->UnparsedEntityUriCall->else->if->parser->getQNameIgnoreDefaultNs->new->KeyCall->else->if->parser->getQNameIgnoreDefaultNs->new->KeyCall->parser->setHasIdCall->else->if->parser->getQNameIgnoreDefaultNs->new->CeilingCall->else->if->parser->getQNameIgnoreDefaultNs->new->RoundCall->else->if->parser->getQNameIgnoreDefaultNs->new->FloorCall->else->if->parser->getQNameIgnoreDefaultNs->new->ContainsCall->else->if->parser->getQNameIgnoreDefaultNs->new->StringLengthCall->else->if->parser->getQNameIgnoreDefaultNs->new->StartsWithCall->else->if->parser->getQNameIgnoreDefaultNs->new->FunctionAvailableCall->else->if->parser->getQNameIgnoreDefaultNs->new->ElementAvailableCall->else->if->parser->getQNameIgnoreDefaultNs->new->LocalNameCall->else->if->parser->getQNameIgnoreDefaultNs->new->LangCall->else->if->parser->getQNameIgnoreDefaultNs->new->NamespaceUriCall->else->if->parser->getQName->new->CastCall->else->if->fname->getLocalPart->equals->fname->getLocalPart->equals->parser->setCallsNodeset->new->FunctionCall->else->new->FunctionCall->parser_stack->get->parser_stack->get->new->Symbol->return->arg->parser_stack->get->temp->new->ArrayList<>->temp->add->parser_stack->get->parser_stack->get->new->Symbol->return->arg->parser_stack->get->argl->parser_stack->get->argl->add->parser_stack->get->parser_stack->get->new->Symbol->return->fname->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->vname->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->ex->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->nt->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->l->parser_stack->get->name->parser->getQNameIgnoreDefaultNs->exp->new->NameCall->new->LiteralExpr->new->EqualityExpr->predicates->new->ArrayList<>->predicates->new->Predicate->add->result->new->Step->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser_stack->get->parser_stack->get->new->Symbol->return->qn->parser_stack->get->parser_stack->get->parser_stack->get->new->Symbol->return->qname->parser_stack->get->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->result->parser->getQNameIgnoreDefaultNs->parser_stack->get->parser_stack->get->new->Symbol->return->throw->new->Exception
XslAttribute#getName():::Returns the name of the attribute:::return
XslAttribute#display(int):::Displays the contents of the attribute:::indent->Util->println->displayContents
XslAttribute#parseContents(Parser):::Parses the attribute's contents:::generated->stable->parser->getSymbolTable->name->getAttribute->namespace->getAttribute->qname->parser->getQName->prefix->qname->getPrefix->if->prefix->equals->name->equals->reportError->return->Util->isLiteral->if->if->XML11Char->isXML11ValidQName->reportError->return->parent->getParent->siblings->parent->getContents->for->i->parent->elementCount->if->lookupPrefix->new->AttributeValueTemplate->else->if->lookupNamespace->if->new->AttributeValueTemplate->if->if->if->else->stable->generateNamespacePrefix->else->if->prefix->equals->qname->getLocalPart->if->registerNamespace->if->addAttribute->AttributeValue->create->parseChildren
XslAttribute#typeCheck(SymbolTable)::: xsl attribute type check:::if->_name->typeCheck->if->_namespace->typeCheck->typeCheckContents->return
XslAttribute#translate(ClassGenerator, MethodGenerator)::: xsl attribute translate:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->return->if->il->methodGen->loadHandler->append->il->new->PUSH->append->_namespace->translate->il->methodGen->namespace->append->if->nameValue->methodGen->Util->getJCRefType->addLocalVariable2->_name->translate->nameValue->il->nameValue->getIndex->new->ASTORE->append->setStart->il->nameValue->getIndex->new->ALOAD->append->check->cpg->addMethodref->il->new->INVOKESTATIC->append->il->methodGen->loadHandler->append->il->append->nameValue->il->nameValue->getIndex->new->ALOAD->append->setEnd->else->il->methodGen->loadHandler->append->il->append->_name->translate->if->elementCount->elementAt->il->elementAt->getText->new->PUSH->append->else->il->classGen->loadTranslet->append->il->cpg->addFieldref->new->GETFIELD->append->il->append->il->methodGen->storeHandler->append->translateContents->il->cpg->addMethodref->new->INVOKEVIRTUAL->append->parent->getParent->if->allAttributesUnique->flags->elemDesc->getElemDesc->if->attrName->toString->if->elemDesc->isAttrFlagSet->else->if->elemDesc->isAttrFlagSet->il->new->PUSH->append->il->methodGen->uniqueAttribute->append->else->il->methodGen->attribute->append->il->methodGen->storeHandler->append
XslElement#display(int):::Displays the contents of the element:::indent->Util->println->displayContents
XslElement#parseContents(Parser)::: xsl element parse contents:::stable->parser->getSymbolTable->name->getAttribute->if->msg->new->ErrorMsg->parser->reportError->parseChildren->return->namespace->getAttribute->Util->isLiteral->if->if->XML11Char->isXML11ValidQName->msg->new->ErrorMsg->parser->reportError->parseChildren->return->qname->parser->getQNameSafe->prefix->qname->getPrefix->local->qname->getLocalPart->if->if->hasAttribute->lookupNamespace->if->err->new->ErrorMsg->parser->reportError->parseChildren->return->new->AttributeValueTemplate->else->if->if->Util->isLiteral->lookupPrefix->if->stable->generateNamespacePrefix->newName->new->StringBuffer->if->newName->append->newName->append->toString->new->AttributeValueTemplate->else->new->AttributeValueTemplate->new->AttributeValueTemplate->useSets->getAttribute->if->useSets->length->if->Util->isValidQNames->err->new->ErrorMsg->parser->reportError->new->UseAttributeSets->setFirstElement->parseChildren
XslElement#typeCheck(SymbolTable):::Run type check on element name & contents:::if->_name->typeCheck->if->_namespace->typeCheck->typeCheckContents->return
XslElement#translateLiteral(ClassGenerator, MethodGenerator):::This method is called when the name of the element is known at compile time:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->il->methodGen->loadHandler->append->_name->translate->il->append->il->methodGen->startElement->append->if->il->methodGen->loadHandler->append->il->new->PUSH->append->_namespace->translate->il->methodGen->namespace->append->translateContents->if->il->methodGen->endElement->append
XslElement#translate(ClassGenerator, MethodGenerator):::At runtime the compilation of xsl:element results in code that: (i) evaluates the avt for the name, (ii) checks for a prefix in the name (iii) generates a new prefix and create a new qname when necessary (iv) calls startElement() on the handler (v) looks up a uri in the XML when the prefix is not known at compile time (vi) calls namespace() on the handler (vii) evaluates the contents (viii) calls endElement().:::cpg->classGen->getConstantPool->il->methodGen->getInstructionList->if->translateLiteral->return->if->nameValue->methodGen->Util->getJCRefType->addLocalVariable2->_name->translate->nameValue->il->nameValue->getIndex->new->ASTORE->append->setStart->il->nameValue->getIndex->new->ALOAD->append->check->cpg->addMethodref->il->new->INVOKESTATIC->append->il->methodGen->loadHandler->append->nameValue->il->nameValue->getIndex->new->ALOAD->append->setEnd->if->_namespace->translate->else->il->append->il->methodGen->loadHandler->append->il->methodGen->loadDOM->append->il->methodGen->loadCurrentNode->append->il->cpg->addMethodref->new->INVOKESTATIC->append->translateContents->if->il->methodGen->endElement->append
XslElement#translateContents(ClassGenerator, MethodGenerator):::Override this method to make sure that xsl:attributes are not copied to output if this xsl:element is to be ignored:::n->elementCount->for->i
XSLTC#setSecureProcessing(boolean):::Set the state of the secure processing feature.:::
XSLTC#isSecureProcessing():::Return the state of the secure processing feature.:::return
XSLTC#getFeature(JdkXmlFeatures.XmlFeature):::Return the value of the specified feature:::return->_xmlFeatures->getFeature
XSLTC#getProperty(String):::Return allowed protocols for accessing external stylesheet.:::if->name->equals->return->else->if->name->equals->return->else->if->name->equals->return->else->if->name->equals->return->else->if->equals->return->else->if->equals->return->return
XSLTC#setProperty(String, Object):::Set allowed protocols for accessing external stylesheet.:::if->name->equals->else->if->name->equals->else->if->name->equals->else->if->name->equals->_externalExtensionFunctions->clear->else->if->equals->else->if->equals->Integer->parseInt
XSLTC#getParser():::Only for user by the internal TrAX implementation.:::return
XSLTC#setOutputType(int):::Only for user by the internal TrAX implementation.:::
XSLTC#getOutputProperties():::Only for user by the internal TrAX implementation.:::return->_parser->getOutputProperties
XSLTC#init():::Initializes the compiler to compile a new stylesheet:::reset->new->ArrayList<>->new->ArrayList<>
XSLTC#setExternalExtensionFunctions(String, Class)::: c set external extension functions:::if->_externalExtensionFunctions->containsKey->_externalExtensionFunctions->put
XSLTC#loadExternalFunction(String)::: c load external function:::loaded->if->_externalExtensionFunctions->containsKey->_externalExtensionFunctions->get->else->if->Class->forName->setExternalExtensionFunctions->if->throw->new->ClassNotFoundException->return
XSLTC#getExternalExtensionFunctions()::: c get external extension functions:::return->Collections->unmodifiableMap
XSLTC#reset():::Initializes the compiler to produce a new translet:::new->HashMap<>->new->HashMap<>->new->HashMap<>->_namespaces->put->new->ArrayList<>->new->ArrayList<>->new->HashMap<>->_parser->init->new->intArr->_externalExtensionFunctions->clear
XSLTC#setSourceLoader(SourceLoader):::Defines an external SourceLoader to provide the compiler with documents referenced in xsl:include/import:::
XSLTC#setTemplateInlining(boolean):::Set a flag indicating if templates are to be inlined or not:::
XSLTC#getTemplateInlining():::Return the state of the template inlining feature.:::return
XSLTC#setPIParameters(String, String, String):::Set the parameters to use to locate the correct <?xml-stylesheet ...?> processing instruction in the case where the input document to the compiler (and parser) is an XML document.:::_parser->setPIParameters
XSLTC#compile(URL):::Compiles an XSL stylesheet pointed to by a URL:::try->stream->url->openStream->input->new->InputSource->input->url->toString->setSystemId->return->compile->catch->_parser->new->ErrorMsg->reportError->return->finally
XSLTC#compile(URL, String):::Compiles an XSL stylesheet pointed to by a URL:::try->stream->url->openStream->input->new->InputSource->input->url->toString->setSystemId->return->compile->catch->_parser->new->ErrorMsg->reportError->return->finally
XSLTC#compile(InputStream, String):::Compiles an XSL stylesheet passed in through an InputStream:::input->new->InputSource->input->setSystemId->return->compile
XSLTC#compile(InputSource, String):::Compiles an XSL stylesheet passed in through an InputStream:::try->reset->systemId->if->input->getSystemId->if->if->setClassName->else->if->systemId->equals->Util->baseName->setClassName->if->_className->length->setClassName->element->if->_parser->parse->else->_parser->parse->if->_parser->errorsFound->_parser->makeStylesheet->_stylesheet->setSourceLoader->_stylesheet->setSystemId->_stylesheet->setParentStylesheet->_stylesheet->setTemplateInlining->_parser->setCurrentStylesheet->_parser->createAST->if->_parser->errorsFound->_stylesheet->setCallsNodeset->_stylesheet->setMultiDocument->_stylesheet->setHasIdCall->synchronized->getClass->_stylesheet->translate->catch->e->printStackTrace->_parser->new->ErrorMsg->reportError->if->e->printStackTrace->_parser->new->ErrorMsg->reportError->finally->return->_parser->errorsFound
XSLTC#compile(List):::Compiles a set of stylesheets pointed to by a List of URLs:::count->stylesheets->size->if->return->if->return->stylesheets->get->compile->else->foreach->if->compile->return->return
XSLTC#getBytecodes():::Returns an array of bytecode arrays generated by a compilation.:::count->_classes->size->result->new->byteArrs->for->i->return
XSLTC#compile(String, InputSource, int):::Compiles a stylesheet pointed to by a URL:::if->compile->return->getBytecodes->else->return
XSLTC#compile(String, InputSource):::Compiles a stylesheet pointed to by a URL:::return->compile
XSLTC#setXMLReader(XMLReader):::Set the XMLReader to use for parsing the next input stylesheet:::
XSLTC#getXMLReader():::Get the XMLReader to use for parsing the next input stylesheet:::return
XSLTC#getErrors():::Get a list of all compile error messages:::return->_parser->getErrors
XSLTC#getWarnings():::Get a list of all compile warning messages:::return->_parser->getWarnings
XSLTC#printErrors():::Print all compile error messages to standard output:::_parser->printErrors
XSLTC#printWarnings():::Print all compile warning messages to standard output:::_parser->printWarnings
XSLTC#setMultiDocument(boolean):::This method is called by the XPathParser when it encounters a call to the document() function:::
XSLTC#isMultiDocument()::: c is multi document:::return
XSLTC#setCallsNodeset(boolean):::This method is called by the XPathParser when it encounters a call to the nodeset() extension function:::if->setMultiDocument
XSLTC#callsNodeset()::: c calls nodeset:::return
XSLTC#setHasIdCall(boolean)::: c set has id call:::
XSLTC#hasIdCall()::: c has id call:::return
XSLTC#setClassName(String):::Set the class name for the generated translet:::base->Util->baseName->noext->Util->noExtName->name->Util->toJavaName->if->else
XSLTC#getClassName():::Get the class name for the generated translet.:::return
XSLTC#classFileName(String):::Convert for Java class name of local system file name:::return->className->replace
XSLTC#getOutputFile(String):::Generate an output File object to send the translet to:::if->return->classFileName->new->File->else->return->classFileName->new->File
XSLTC#setDestDirectory(String):::Set the destination directory for the translet:::dir->new->File->if->SecuritySupport->doesFileExist->dir->mkdirs->return->else->return
XSLTC#setPackageName(String):::Set an optional package name for the translet and auxiliary classes:::Objects->requireNonNull->if->setClassName
XSLTC#setJarFileName(String):::Set the name of an optional JAR-file to dump the translet and auxiliary classes to:::JAR_EXT->if->jarFileName->endsWith->else
XSLTC#getJarFileName()::: c get jar file name:::return
XSLTC#setStylesheet(Stylesheet):::Set the top-level stylesheet:::if
XSLTC#getStylesheet():::Returns the top-level stylesheet:::return
XSLTC#registerAttribute(QName):::Registers an attribute and gives it a type so that it can be mapped to DOM attribute types at run-time.:::code->_attributes->name->toString->get->if->_attributes->name->toString->put->uri->name->getNamespace->local->name->getLocalPart->if->uri->equals->_namesIndex->add->else->_namesIndex->add->if->name->getLocalPart->equals->name->getNamespace->registerNamespace->return->code->intValue
XSLTC#registerElement(QName):::Registers an element and gives it a type so that it can be mapped to DOM element types at run-time.:::code->_elements->name->toString->get->if->_elements->name->toString->put->_namesIndex->name->toString->add->if->name->getLocalPart->equals->name->getNamespace->registerNamespace->return->code->intValue
XSLTC#registerNamespacePrefix(QName)::: c register namespace prefix:::code->_namespacePrefixes->name->toString->get->if->_namespacePrefixes->name->toString->put->uri->name->getNamespace->if->uri->equals->_namesIndex->add->else->_namesIndex->name->getLocalPart->add->return->code->intValue
XSLTC#registerNamespace(String):::Registers a namespace and gives it a type so that it can be mapped to DOM namespace types at run-time.:::code->_namespaces->get->if->_namespaces->put->_namespaceIndex->add->return
XSLTC#nextModeSerial()::: c next mode serial:::return
XSLTC#nextStylesheetSerial()::: c next stylesheet serial:::return
XSLTC#nextStepPatternSerial()::: c next step pattern serial:::return
XSLTC#getNumberFieldIndexes()::: c get number field indexes:::return
XSLTC#nextHelperClassSerial()::: c next helper class serial:::return
XSLTC#nextAttributeSetSerial()::: c next attribute set serial:::return
XSLTC#getNamesIndex()::: c get names index:::return
XSLTC#getNamespaceIndex()::: c get namespace index:::return
XSLTC#getHelperClassName():::Returns a unique name for every helper class needed to execute a translet.:::return->getClassName
XSLTC#dumpClass(JavaClass)::: c dump class:::if->outFile->clazz->getClassName->getOutputFile->parentDir->outFile->getParent->if->parentFile->new->File->if->SecuritySupport->doesFileExist->parentFile->mkdirs->try->switch->_bcelClasses->add->break->out->new->ByteArrayOutputStream->clazz->dump->_classes->add->if->clazz->clazz->getClassName->getOutputFile->dump->else->if->_bcelClasses->add->break->catch->e->printStackTrace->finally
XSLTC#entryName(File):::File separators are converted to forward slashes for ZIP files.:::return->f->getName->replace
XSLTC#outputToJar():::Generate output JAR-file and packages:::manifest->new->Manifest->atrs->manifest->getMainAttributes->atrs->put->map->manifest->getEntries->now->new->Date->toString->dateAttr->new->java.util.jar.Attributes.Name->jarFile->new->File->jos->new->FileOutputStream->new->JarOutputStream->foreach->className->clazz->getClassName->replace->attr->new->java.util.jar.Attributes->attr->put->map->put->jos->new->JarEntry->putNextEntry->out->new->ByteArrayOutputStream->clazz->dump->out->writeTo->jos->close
XSLTC#setDebug(boolean):::Turn debugging messages on/off:::
XSLTC#debug():::Get current debugging message setting:::return
XSLTC#getCharacterData(int):::Retrieve a string representation of the character data to be stored in the translet as a char[]:::return->m_characterData->get->toString
XSLTC#getCharacterDataCount():::Get the number of char[] arrays, thus far, that will be created to store literal text in the stylesheet.:::return->m_characterData->size
XSLTC#addCharacterData(String):::Add literal text to char arrays that will be used to store character data in the stylesheet.:::currData->if->new->ArrayList<>->new->StringBuilder->m_characterData->add->else->m_characterData->m_characterData->size->get->if->newData->length->currData->length->new->StringBuilder->m_characterData->add->newDataOffset->currData->length->currData->append->return
