DataFlavorUtil#getCharsetComparator()::: data flavor util get charset comparator:::return
DataFlavorUtil#getDataFlavorComparator()::: data flavor util get data flavor comparator:::return
DataFlavorUtil#getIndexOrderComparator(Map)::: data flavor util get index order comparator:::return->new->IndexOrderComparator
DataFlavorUtil#getTextFlavorComparator()::: data flavor util get text flavor comparator:::return
DataFlavorUtil.StandardEncodingsHolder#load()::: standard encodings holder load:::tempSet->getCharsetComparator->reversed->new->TreeSet<>->tempSet->add->tempSet->add->tempSet->add->tempSet->add->tempSet->add->tempSet->add->tempSet->Charset->defaultCharset->name->add->return->Collections->unmodifiableSortedSet
DataFlavorUtil#standardEncodings():::Returns a SortedSet of Strings which are a total order of the standard character sets supported by the JRE:::return
DataFlavorUtil#canonicalName(String):::Converts an arbitrary text encoding to its canonical name.:::if->return->try->return->Charset->forName->name->catch->return->return->finally
DataFlavorUtil#doesSubtypeSupportCharset(DataFlavor):::Tests only whether the flavor's MIME type supports the charset parameter:::subType->flavor->getSubType->if->return->support->textMIMESubtypeCharsetSupport->get->if->return->ret_val->flavor->getParameter->textMIMESubtypeCharsetSupport->put->return
DataFlavorUtil#doesSubtypeSupportCharset(String, String)::: data flavor util does subtype support charset:::support->textMIMESubtypeCharsetSupport->get->if->return->ret_val->textMIMESubtypeCharsetSupport->put->return
DataFlavorUtil#isFlavorCharsetTextType(DataFlavor):::Returns whether this flavor is a text type which supports the 'charset' parameter.:::if->equals->return->if->flavor->getPrimaryType->equals->doesSubtypeSupportCharset->return->rep_class->flavor->getRepresentationClass->if->flavor->isRepresentationClassReader->equals->flavor->isRepresentationClassCharBuffer->equals->return->if->flavor->isRepresentationClassInputStream->flavor->isRepresentationClassByteBuffer->equals->return->charset->flavor->getParameter->return->isEncodingSupported
DataFlavorUtil#isFlavorNoncharsetTextType(DataFlavor):::Returns whether this flavor is a text type which does not support the 'charset' parameter.:::if->flavor->getPrimaryType->equals->doesSubtypeSupportCharset->return->return->flavor->isRepresentationClassInputStream->flavor->isRepresentationClassByteBuffer->flavor->getRepresentationClass->equals
DataFlavorUtil#getTextCharset(DataFlavor):::If the specified flavor is a text flavor which supports the "charset" parameter, then this method returns that parameter, or the default charset if no such parameter was specified at construction:::if->isFlavorCharsetTextType->return->encoding->flavor->getParameter->return->Charset->defaultCharset->name
DataFlavorUtil#isEncodingSupported(String):::Determines whether this JRE can both encode and decode text in the specified encoding.:::if->return->try->return->Charset->isSupported->catch->return->finally
DataFlavorUtil#compareIndices(Map, T, T, Integer):::Helper method to compare two objects by their Integer indices in the given map:::index1->indexMap->getOrDefault->index2->indexMap->getOrDefault->return->index1->compareTo
DataFlavorUtil.CharsetComparator#compare(String, String):::Compares charsets:::getEncoding->getEncoding->comp->compareIndices->if->return->charset2->compareTo->return
DataFlavorUtil.CharsetComparator#getEncoding(String):::Returns encoding for the specified charset according to the following rules: <ul> <li>If the charset is null, then null will be     returned</li> <li>Iff the charset specifies an encoding unsupported by this JRE,     UNSUPPORTED_CHARSET will be returned</li> <li>If the charset specifies an alias name, the corresponding     canonical name will be returned iff the charset is a known     Unicode, ASCII, or default charset</li> </ul>:::if->return->else->if->isEncodingSupported->return->else->canonicalName->canonicalName->return->charsets->containsKey
DataFlavorUtil.DataFlavorComparator#compare(DataFlavor, DataFlavor)::: data flavor comparator compare:::if->flavor1->equals->return->comp->primaryType1->flavor1->getPrimaryType->subType1->flavor1->getSubType->mimeType1->class1->flavor1->getRepresentationClass->primaryType2->flavor2->getPrimaryType->subType2->flavor2->getSubType->mimeType2->class2->flavor2->getRepresentationClass->if->flavor1->isFlavorTextType->flavor2->isFlavorTextType->compareIndices->if->return->if->doesSubtypeSupportCharset->compareIndices->if->return->getTextCharset->getTextCharset->compare->if->return->compareIndices->if->return->else->if->flavor1->isFlavorTextType->return->if->flavor2->isFlavorTextType->return->compareIndices->if->return->compareIndices->if->return->compareIndices->if->return->return->flavor1->getMimeType->flavor2->getMimeType->compareTo
DataFlavorUtil.IndexOrderComparator#compare(Long, Long)::: index order comparator compare:::return->compareIndices
DataFlavorUtil.TextFlavorComparator#compare(DataFlavor, DataFlavor):::Compares two DataFlavor objects:::if->flavor1->isFlavorTextType->if->flavor2->isFlavorTextType->return->super->compare->else->return->else->if->flavor2->isFlavorTextType->return->else->return
DataFlavorUtil.DefaultDesktopDatatransferService#getDesktopService()::: default desktop datatransfer service get desktop service:::loader->ServiceLoader->load->iterator->loader->iterator->if->iterator->hasNext->return->iterator->next->else->return->new->DefaultDesktopDatatransferService
DataFlavorUtil.DefaultDesktopDatatransferService#invokeOnEventThread(Runnable)::: default desktop datatransfer service invoke on event thread:::r->run
DataFlavorUtil.DefaultDesktopDatatransferService#getDefaultUnicodeEncoding()::: default desktop datatransfer service get default unicode encoding:::return->name
DataFlavorUtil.DefaultDesktopDatatransferService#getFlavorMap(Supplier)::: default desktop datatransfer service get flavor map:::map->if->synchronized->if->supplier->get->return
DataFlavorUtil.DefaultDesktopDatatransferService#isDesktopPresent()::: default desktop datatransfer service is desktop present:::return
DataFlavorUtil.DefaultDesktopDatatransferService#getPlatformMappingsForNative(String)::: default desktop datatransfer service get platform mappings for native:::return->new->LinkedHashSet<>
DataFlavorUtil.DefaultDesktopDatatransferService#getPlatformMappingsForFlavor(DataFlavor)::: default desktop datatransfer service get platform mappings for flavor:::return->new->LinkedHashSet<>
DataFlavorUtil.DefaultDesktopDatatransferService#registerTextFlavorProperties(String, String, String, String)::: default desktop datatransfer service register text flavor properties:::
DataFlavorUtil#getDesktopService()::: data flavor util get desktop service:::return
DataFlavorUtil.RMI#getClass(String)::: i get class:::try->return->Class->forName->catch->return->finally
DataFlavorUtil.RMI#getConstructor(Class, Class...)::: i get constructor:::try->return->c->getDeclaredConstructor->catch->throw->new->AssertionError->finally
DataFlavorUtil.RMI#getMethod(Class, String, Class...)::: i get method:::try->return->c->getMethod->catch->throw->new->AssertionError->finally
DataFlavorUtil.RMI#remoteClass():::Returns java.rmi.Remote.class if RMI is present; otherwise null.:::return
DataFlavorUtil.RMI#isRemote(Class):::Returns true if the given class is java.rmi.Remote.:::return->remoteClass->isAssignableFrom
DataFlavorUtil.RMI#newMarshalledObject(Object):::Returns a new MarshalledObject containing the serialized representation of the given object.:::try->return->marshallCtor->newInstance->catch->throw->new->AssertionError->cause->x->getCause->if->throw->throw->new->AssertionError->finally
DataFlavorUtil.RMI#getMarshalledObject(Object):::Returns a new copy of the contained marshalled object.:::try->return->marshallGet->invoke->catch->throw->new->AssertionError->cause->x->getCause->if->throw->if->throw->throw->new->AssertionError->finally
DesktopDatatransferService#invokeOnEventThread(Runnable):::If desktop is present - invokes a Runnable on the event dispatch thread:::
DesktopDatatransferService#getDefaultUnicodeEncoding():::Get a platform-dependent default unicode encoding to use in datatransfer system.:::
DesktopDatatransferService#getFlavorMap(Supplier):::Takes an appropriate FlavorMap from the desktop:::
DesktopDatatransferService#isDesktopPresent():::Checks if desktop is present.:::
DesktopDatatransferService#getPlatformMappingsForNative(String):::Returns platform-specific mappings for the specified native format:::
DesktopDatatransferService#getPlatformMappingsForFlavor(DataFlavor):::Returns platform-specific mappings for the specified flavor:::
DesktopDatatransferService#registerTextFlavorProperties(String, String, String, String):::This method is called for text flavor mappings established while parsing the default flavor mappings file:::
