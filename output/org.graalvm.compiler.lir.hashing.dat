Hasher#forKeys(JavaConstant[], double):::Tries to find a hash function without conflicts for the provided keys.:::if->return->Optional->empty->else->maxCardinality->Math->round->candidates->new->Comparator<Hasher>->new->TreeSet<>->min->asInt->foreach->HashFunction->instances->for->cardinality->if->candidates->isEmpty->return->Optional->empty->else->return->Optional->candidates->first->of
Hasher#checkKeyKind(JavaConstant[])::: hasher check key kind:::for->i->return
Hasher#checkIfSorted(JavaConstant[])::: hasher check if sorted:::for->i->return
Hasher#isValid(JavaConstant[], int, HashFunction, int)::: hasher is valid:::seen->new->HashSet<>->foreach->hash->function->key->asInt->apply->if->seen->add->return->return
Hasher#hash(int):::Applies the hash function.:::return->function->apply
Hasher#hash(Value, ArithmeticLIRGenerator):::Applies the hash function to a lir value.:::h->function->gen->getLIRGen->JavaConstant->forInt->emitJavaConstant->gen->return->gen->gen->getLIRGen->JavaConstant->forInt->emitJavaConstant->emitAnd
Hasher#effort()::: hasher effort:::return->function->effort
Hasher#cardinality()::: hasher cardinality:::return
Hasher#function()::: hasher function:::return
Hasher#toString()::: hasher to string:::return->effort
HashFunction#apply(int, int):::Applies the hash function.:::
HashFunction#gen(Value, Value, ArithmeticLIRGenerator):::Generates LIR that implements the hash function in terms of value and min.:::
HashFunction#effort():::Returns an estimate of number of CPU cycles necessary to apply the hash function.:::
HashFunction#instances()::: hash function instances:::return->Collections->unmodifiableList
HashFunction#add(String, int, BiFunction, Function>)::: hash function add:::instances->new->HashFunction->add
HashFunction#addWithPrimes(String, int, Function>, BiFunction>)::: hash function add with primes:::foreach->f->apply->gen->g->getLIRGen->JavaConstant->forInt->emitJavaConstant->apply->add
