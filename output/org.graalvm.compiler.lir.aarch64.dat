org.graalvm.compiler.lir.aarch64.AArch64AddressValue#getBase()->AllocatableValue::: arch64 address value get base
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#getOffset()->AllocatableValue::: arch64 address value get offset
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#getDisplacement()->int::: arch64 address value get displacement
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#isScaled()->boolean::: arch64 address value is scaled
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#getScaleFactor()->int::: arch64 address value get scale factor
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#getAddressingMode()->AddressingMode::: arch64 address value get addressing mode
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#toAddress()->AArch64Address::: arch64 address value to address
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#forEachComponent(LIRInstruction, LIRInstruction.OperandMode, InstructionValueProcedure)->CompositeValue::: arch64 address value for each component
org.graalvm.compiler.lir.aarch64.AArch64AddressValue#visitEachComponent(LIRInstruction, LIRInstruction.OperandMode, InstructionValueConsumer)->void::: arch64 address value visit each component
org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool#emitCountLeadingZeros(Value)->Value::: arch64 arithmetic generator tool emit count leading zeros
org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool#emitCountTrailingZeros(Value)->Value::: arch64 arithmetic generator tool emit count trailing zeros
org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool#emitRound(Value, RoundingMode)->Value::: arch64 arithmetic generator tool emit round
org.graalvm.compiler.lir.aarch64.AArch64ArrayCompareToOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 array compare to op emit code
org.graalvm.compiler.lir.aarch64.AArch64ArrayEqualsOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 array equals op emit code
org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.CompareAndSwapOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: compare and swap op emit code
org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: atomic read and add op emit code
org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddLSEOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: atomic read and add op emit code
org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndWriteOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: atomic read and write op emit code
org.graalvm.compiler.lir.aarch64.AArch64BitFieldOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 bit field op emit code
org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 bit manipulation op emit code
org.graalvm.compiler.lir.aarch64.AArch64BlockEndOp#emitCode(CompilationResultBuilder)->void::: arch64 block end op emit code
org.graalvm.compiler.lir.aarch64.AArch64BlockEndOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 block end op emit code
org.graalvm.compiler.lir.aarch64.AArch64BreakpointOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 breakpoint op emit code
org.graalvm.compiler.lir.aarch64.AArch64ByteSwapOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 byte swap op emit code
org.graalvm.compiler.lir.aarch64.AArch64Call.CallOp#destroysCallerSavedRegisters()->boolean::: call op destroys caller saved registers
org.graalvm.compiler.lir.aarch64.AArch64Call.IndirectCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: indirect call op emit code
org.graalvm.compiler.lir.aarch64.AArch64Call.IndirectCallOp#verify()->void::: indirect call op verify
org.graalvm.compiler.lir.aarch64.AArch64Call.DirectCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: direct call op emit code
org.graalvm.compiler.lir.aarch64.AArch64Call.ForeignCallOp#destroysCallerSavedRegisters()->boolean::: foreign call op destroys caller saved registers
org.graalvm.compiler.lir.aarch64.AArch64Call.ForeignCallOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: foreign call op emit code
org.graalvm.compiler.lir.aarch64.AArch64Call.ForeignCallOp#emitCall(CompilationResultBuilder, AArch64MacroAssembler)->void::: foreign call op emit call
org.graalvm.compiler.lir.aarch64.AArch64Call.ForeignCallOp#getLabel()->Label::: foreign call op get label
org.graalvm.compiler.lir.aarch64.AArch64Call.DirectNearForeignCallOp#emitCall(CompilationResultBuilder, AArch64MacroAssembler)->void::: direct near foreign call op emit call
org.graalvm.compiler.lir.aarch64.AArch64Call.DirectFarForeignCallOp#emitCall(CompilationResultBuilder, AArch64MacroAssembler)->void::: direct far foreign call op emit call
org.graalvm.compiler.lir.aarch64.AArch64Call#isNearCall(ForeignCallLinkage)->boolean:::Tests whether linkage can be called directly under all circumstances without the need for a scratch register
org.graalvm.compiler.lir.aarch64.AArch64Call#directCall(CompilationResultBuilder, AArch64MacroAssembler, InvokeTarget, Register, LIRFrameState)->void::: arch64 call direct call
org.graalvm.compiler.lir.aarch64.AArch64Call#directCall(CompilationResultBuilder, AArch64MacroAssembler, InvokeTarget, Register, LIRFrameState, Label)->void::: arch64 call direct call
org.graalvm.compiler.lir.aarch64.AArch64Call#indirectCall(CompilationResultBuilder, AArch64MacroAssembler, Register, InvokeTarget, LIRFrameState)->void::: arch64 call indirect call
org.graalvm.compiler.lir.aarch64.AArch64Call#directJmp(CompilationResultBuilder, AArch64MacroAssembler, InvokeTarget)->void::: arch64 call direct jmp
org.graalvm.compiler.lir.aarch64.AArch64Call#indirectJmp(CompilationResultBuilder, AArch64MacroAssembler, Register, InvokeTarget)->void::: arch64 call indirect jmp
org.graalvm.compiler.lir.aarch64.AArch64Call#directConditionalJmp(CompilationResultBuilder, AArch64MacroAssembler, InvokeTarget, AArch64Assembler.ConditionFlag)->void::: arch64 call direct conditional jmp
org.graalvm.compiler.lir.aarch64.AArch64CCall#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 call emit code
org.graalvm.compiler.lir.aarch64.AArch64CCall#destroysCallerSavedRegisters()->boolean::: arch64 call destroys caller saved registers
org.graalvm.compiler.lir.aarch64.AArch64Compare.CompareOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: compare op emit code
org.graalvm.compiler.lir.aarch64.AArch64Compare#gpCompare(AArch64MacroAssembler, Value, Value)->void:::Compares integer values x and y.
org.graalvm.compiler.lir.aarch64.AArch64Compare.FloatCompareOp#isFloatCmpConstant(Value, Condition, boolean)->boolean:::Checks if val can be used as a constant for the gpCompare operation or not.
org.graalvm.compiler.lir.aarch64.AArch64Compare.FloatCompareOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: float compare op emit code
org.graalvm.compiler.lir.aarch64.AArch64Compare.FloatCompareOp#verify()->void::: float compare op verify
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.ReturnOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: return op emit code
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.AbstractBranchOp#emitBranch(CompilationResultBuilder, AArch64MacroAssembler, LabelRef, boolean)->void::: abstract branch op emit branch
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.AbstractBranchOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: abstract branch op emit code
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.BranchOp#emitBranch(CompilationResultBuilder, AArch64MacroAssembler, LabelRef, boolean)->void::: branch op emit branch
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CompareBranchZeroOp#emitBranch(CompilationResultBuilder, AArch64MacroAssembler, LabelRef, boolean)->void::: compare branch zero op emit branch
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.BitTestAndBranchOp#emitBranch(CompilationResultBuilder, AArch64MacroAssembler, LabelRef, boolean)->void::: bit test and branch op emit branch
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondMoveOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: cond move op emit code
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondSetOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: cond set op emit code
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: strategy switch op emit code
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp.SwitchClosure#emitComparison(Constant)->void::: switch closure emit comparison
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition, Label)->void::: switch closure conditional jump
org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.TableSwitchOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: table switch op emit code
org.graalvm.compiler.lir.aarch64.AArch64FrameMap#totalFrameSize()->int::: arch64 frame map total frame size
org.graalvm.compiler.lir.aarch64.AArch64FrameMap#currentFrameSize()->int::: arch64 frame map current frame size
org.graalvm.compiler.lir.aarch64.AArch64FrameMap#allocateDeoptimizationRescueSlot()->StackSlot::: arch64 frame map allocate deoptimization rescue slot
org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder#allocateDeoptimizationRescueSlot()->StackSlot::: arch64 frame map builder allocate deoptimization rescue slot
org.graalvm.compiler.lir.aarch64.AArch64LIRFlagsVersioned#useLSE(Architecture)->boolean::: arch64 flags versioned use e
org.graalvm.compiler.lir.aarch64.AArch64LIRInstruction#emitCode(CompilationResultBuilder)->void::: arch64 instruction emit code
org.graalvm.compiler.lir.aarch64.AArch64LIRInstruction#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 instruction emit code
org.graalvm.compiler.lir.aarch64.AArch64MathIntrinsicBinaryOp#registersToValues(Register[])->Value[]::: arch64 math intrinsic binary op registers to values
org.graalvm.compiler.lir.aarch64.AArch64MathIntrinsicBinaryOp#emitLIRWrapper(LIRGenerator, Value, Value)->Variable::: arch64 math intrinsic binary op emit wrapper
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadInlineConstant#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: load inline constant emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadInlineConstant#getConstant()->Constant::: load inline constant get constant
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadInlineConstant#getResult()->AllocatableValue::: load inline constant get result
org.graalvm.compiler.lir.aarch64.AArch64Move.Move#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: move emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.Move#getInput()->AllocatableValue::: move get input
org.graalvm.compiler.lir.aarch64.AArch64Move.Move#getResult()->AllocatableValue::: move get result
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadAddressOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: load address op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadDataOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: load data op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.StackLoadAddressOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: stack load address op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.MembarOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: membar op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.MemOp#emitMemAccess(CompilationResultBuilder, AArch64MacroAssembler)->void::: mem op emit mem access
org.graalvm.compiler.lir.aarch64.AArch64Move.MemOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: mem op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.MemOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: mem op make null check for
org.graalvm.compiler.lir.aarch64.AArch64Move.LoadOp#emitMemAccess(CompilationResultBuilder, AArch64MacroAssembler)->void::: load op emit mem access
org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp#emitMemAccess(CompilationResultBuilder, AArch64MacroAssembler)->void::: store op emit mem access
org.graalvm.compiler.lir.aarch64.AArch64Move.StoreConstantOp#emitMemAccess(CompilationResultBuilder, AArch64MacroAssembler)->void::: store constant op emit mem access
org.graalvm.compiler.lir.aarch64.AArch64Move.NullCheckOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: null check op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.NullCheckOp#getCheckedValue()->Value::: null check op get checked value
org.graalvm.compiler.lir.aarch64.AArch64Move.NullCheckOp#getState()->LIRFrameState::: null check op get state
org.graalvm.compiler.lir.aarch64.AArch64Move#move(CompilationResultBuilder, AArch64MacroAssembler, AllocatableValue, Value)->void::: arch64 move move
org.graalvm.compiler.lir.aarch64.AArch64Move#reg2stack(CompilationResultBuilder, AArch64MacroAssembler, AllocatableValue, AllocatableValue)->void::: arch64 move reg2stack
org.graalvm.compiler.lir.aarch64.AArch64Move#stack2reg(CompilationResultBuilder, AArch64MacroAssembler, AllocatableValue, AllocatableValue)->void::: arch64 move stack2reg
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#hasBase(OptionValues, CompressEncoding)->boolean::: pointer compression op has base
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#getInput()->Value::: pointer compression op get input
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#getResult()->AllocatableValue::: pointer compression op get result
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#getResultRegister()->Register::: pointer compression op get result register
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#getBaseRegister(CompilationResultBuilder)->Register::: pointer compression op get base register
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#getShift()->int::: pointer compression op get shift
org.graalvm.compiler.lir.aarch64.AArch64Move.PointerCompressionOp#move(CompilationResultBuilder, AArch64MacroAssembler)->void::: pointer compression op move
org.graalvm.compiler.lir.aarch64.AArch64Move.CompressPointerOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: compress pointer op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.UncompressPointerOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: uncompress pointer op emit code
org.graalvm.compiler.lir.aarch64.AArch64Move.ConvertNullToZeroOp#emitConversion(Register, Register, Register, AArch64MacroAssembler)->void::: convert null to zero op emit conversion
org.graalvm.compiler.lir.aarch64.AArch64Move.ConvertZeroToNullOp#emitConversion(Register, Register, Register, AArch64MacroAssembler)->void::: convert zero to null op emit conversion
org.graalvm.compiler.lir.aarch64.AArch64PauseOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 pause op emit code
org.graalvm.compiler.lir.aarch64.AArch64PrefetchOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 prefetch op emit code
org.graalvm.compiler.lir.aarch64.AArch64ReinterpretOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 reinterpret op emit code
org.graalvm.compiler.lir.aarch64.AArch64RestoreRegistersOp#getSavedRegisters()->Register[]::: arch64 restore registers op get saved registers
org.graalvm.compiler.lir.aarch64.AArch64RestoreRegistersOp#restoreRegister(CompilationResultBuilder, AArch64MacroAssembler, Register, StackSlot)->void::: arch64 restore registers op restore register
org.graalvm.compiler.lir.aarch64.AArch64RestoreRegistersOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 restore registers op emit code
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#saveRegister(CompilationResultBuilder, AArch64MacroAssembler, StackSlot, Register)->void::: arch64 save registers op save register
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 save registers op emit code
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#getSlots()->AllocatableValue[]::: arch64 save registers op get slots
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#supportsRemove()->boolean::: arch64 save registers op supports remove
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#remove(EconomicSet)->int::: arch64 save registers op remove
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#prune(EconomicSet, Register[])->int::: arch64 save registers op prune
org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp#getMap(FrameMap)->RegisterSaveLayout::: arch64 save registers op get map
org.graalvm.compiler.lir.aarch64.AArch64SignExtendOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 sign extend op emit code
org.graalvm.compiler.lir.aarch64.AArch64SpeculativeBarrier#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: arch64 speculative barrier emit code
org.graalvm.compiler.lir.aarch64.AArch64Unary.MemoryOp#emitCode(CompilationResultBuilder, AArch64MacroAssembler)->void::: memory op emit code
org.graalvm.compiler.lir.aarch64.AArch64Unary.MemoryOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory op make null check for
