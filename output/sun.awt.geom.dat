sun.awt.geom.AreaOp.CAGOp#newRow()->void::: op new row
sun.awt.geom.AreaOp.CAGOp#classify(Edge)->int::: op classify
sun.awt.geom.AreaOp.CAGOp#getState()->int::: op get state
sun.awt.geom.AreaOp.CAGOp#newClassification(boolean, boolean)->boolean::: op new classification
sun.awt.geom.AreaOp.AddOp#newClassification(boolean, boolean)->boolean::: add op new classification
sun.awt.geom.AreaOp.SubOp#newClassification(boolean, boolean)->boolean::: sub op new classification
sun.awt.geom.AreaOp.IntOp#newClassification(boolean, boolean)->boolean::: int op new classification
sun.awt.geom.AreaOp.XorOp#newClassification(boolean, boolean)->boolean::: xor op new classification
sun.awt.geom.AreaOp.NZWindOp#newRow()->void::: wind op new row
sun.awt.geom.AreaOp.NZWindOp#classify(Edge)->int::: wind op classify
sun.awt.geom.AreaOp.NZWindOp#getState()->int::: wind op get state
sun.awt.geom.AreaOp.EOWindOp#newRow()->void::: wind op new row
sun.awt.geom.AreaOp.EOWindOp#classify(Edge)->int::: wind op classify
sun.awt.geom.AreaOp.EOWindOp#getState()->int::: wind op get state
sun.awt.geom.AreaOp#newRow()->void::: area op new row
sun.awt.geom.AreaOp#classify(Edge)->int::: area op classify
sun.awt.geom.AreaOp#getState()->int::: area op get state
sun.awt.geom.AreaOp#calculate(Vector, Vector)->Vector::: area op calculate
sun.awt.geom.AreaOp#finalizeSubCurves(Vector, Vector)->void::: area op finalize sub curves
sun.awt.geom.AreaOp#resolveLinks(Vector, Vector, Vector)->void::: area op resolve links
sun.awt.geom.AreaOp#obstructs(double, double, int)->boolean::: area op obstructs
sun.awt.geom.ChainEnd#getChain()->CurveLink::: chain end get chain
sun.awt.geom.ChainEnd#setOtherEnd(ChainEnd)->void::: chain end set other end
sun.awt.geom.ChainEnd#getPartner()->ChainEnd::: chain end get partner
sun.awt.geom.ChainEnd#linkTo(ChainEnd)->CurveLink::: chain end link to
sun.awt.geom.ChainEnd#addLink(CurveLink)->void::: chain end add link
sun.awt.geom.ChainEnd#getX()->double::: chain end get x
sun.awt.geom.Crossings#getXLo()->double::: crossings get lo
sun.awt.geom.Crossings#getYLo()->double::: crossings get lo
sun.awt.geom.Crossings#getXHi()->double::: crossings get hi
sun.awt.geom.Crossings#getYHi()->double::: crossings get hi
sun.awt.geom.Crossings#record(double, double, int)->void::: crossings record
sun.awt.geom.Crossings#print()->void::: crossings print
sun.awt.geom.Crossings#isEmpty()->boolean::: crossings is empty
sun.awt.geom.Crossings#covers(double, double)->boolean::: crossings covers
sun.awt.geom.Crossings#findCrossings(Vector, double, double, double, double)->Crossings::: crossings find crossings
sun.awt.geom.Crossings#findCrossings(PathIterator, double, double, double, double)->Crossings::: crossings find crossings
sun.awt.geom.Crossings#accumulateLine(double, double, double, double)->boolean::: crossings accumulate line
sun.awt.geom.Crossings#accumulateLine(double, double, double, double, int)->boolean::: crossings accumulate line
sun.awt.geom.Crossings#accumulateQuad(double, double, double[])->boolean::: crossings accumulate quad
sun.awt.geom.Crossings#accumulateCubic(double, double, double[])->boolean::: crossings accumulate cubic
sun.awt.geom.Crossings.EvenOdd#covers(double, double)->boolean::: even odd covers
sun.awt.geom.Crossings.EvenOdd#record(double, double, int)->void::: even odd record
sun.awt.geom.Crossings.NonZero#covers(double, double)->boolean::: non zero covers
sun.awt.geom.Crossings.NonZero#remove(int)->void::: non zero remove
sun.awt.geom.Crossings.NonZero#insert(int, double, double, int)->void::: non zero insert
sun.awt.geom.Crossings.NonZero#record(double, double, int)->void::: non zero record
sun.awt.geom.Curve#insertMove(Vector, double, double)->void::: curve insert move
sun.awt.geom.Curve#insertLine(Vector, double, double, double, double)->void::: curve insert line
sun.awt.geom.Curve#insertQuad(Vector, double, double, double[])->void::: curve insert quad
sun.awt.geom.Curve#insertCubic(Vector, double, double, double[])->void::: curve insert cubic
sun.awt.geom.Curve#pointCrossingsForPath(PathIterator, double, double)->int:::Calculates the number of times the given path crosses the ray extending to the right from (px,py)
sun.awt.geom.Curve#pointCrossingsForLine(double, double, double, double, double, double)->int:::Calculates the number of times the line from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py)
sun.awt.geom.Curve#pointCrossingsForQuad(double, double, double, double, double, double, double, double, int)->int:::Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py)
sun.awt.geom.Curve#pointCrossingsForCubic(double, double, double, double, double, double, double, double, double, double, int)->int:::Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py)
sun.awt.geom.Curve#rectCrossingsForPath(PathIterator, double, double, double, double)->int:::Accumulate the number of times the path crosses the shadow extending to the right of the rectangle
sun.awt.geom.Curve#rectCrossingsForLine(int, double, double, double, double, double, double, double, double)->int:::Accumulate the number of times the line crosses the shadow extending to the right of the rectangle
sun.awt.geom.Curve#rectCrossingsForQuad(int, double, double, double, double, double, double, double, double, double, double, int)->int:::Accumulate the number of times the quad crosses the shadow extending to the right of the rectangle
sun.awt.geom.Curve#rectCrossingsForCubic(int, double, double, double, double, double, double, double, double, double, double, double, double, int)->int:::Accumulate the number of times the cubic crosses the shadow extending to the right of the rectangle
sun.awt.geom.Curve#getDirection()->int::: curve get direction
sun.awt.geom.Curve#getWithDirection(int)->Curve::: curve get with direction
sun.awt.geom.Curve#round(double)->double::: curve round
sun.awt.geom.Curve#orderof(double, double)->int::: curve orderof
sun.awt.geom.Curve#signeddiffbits(double, double)->long::: curve signeddiffbits
sun.awt.geom.Curve#diffbits(double, double)->long::: curve diffbits
sun.awt.geom.Curve#prev(double)->double::: curve prev
sun.awt.geom.Curve#next(double)->double::: curve next
sun.awt.geom.Curve#toString()->String::: curve to string
sun.awt.geom.Curve#controlPointString()->String::: curve control point string
sun.awt.geom.Curve#getOrder()->int::: curve get order
sun.awt.geom.Curve#getXTop()->double::: curve get top
sun.awt.geom.Curve#getYTop()->double::: curve get top
sun.awt.geom.Curve#getXBot()->double::: curve get bot
sun.awt.geom.Curve#getYBot()->double::: curve get bot
sun.awt.geom.Curve#getXMin()->double::: curve get min
sun.awt.geom.Curve#getXMax()->double::: curve get max
sun.awt.geom.Curve#getX0()->double::: curve get x0
sun.awt.geom.Curve#getY0()->double::: curve get y0
sun.awt.geom.Curve#getX1()->double::: curve get x1
sun.awt.geom.Curve#getY1()->double::: curve get y1
sun.awt.geom.Curve#XforY(double)->double::: curve  xfor y
sun.awt.geom.Curve#TforY(double)->double::: curve  tfor y
sun.awt.geom.Curve#XforT(double)->double::: curve  xfor t
sun.awt.geom.Curve#YforT(double)->double::: curve  yfor t
sun.awt.geom.Curve#dXforT(double, int)->double::: curve d xfor t
sun.awt.geom.Curve#dYforT(double, int)->double::: curve d yfor t
sun.awt.geom.Curve#nextVertical(double, double)->double::: curve next vertical
sun.awt.geom.Curve#crossingsFor(double, double)->int::: curve crossings for
sun.awt.geom.Curve#accumulateCrossings(Crossings)->boolean::: curve accumulate crossings
sun.awt.geom.Curve#enlarge(Rectangle2D)->void::: curve enlarge
sun.awt.geom.Curve#getSubCurve(double, double)->Curve::: curve get sub curve
sun.awt.geom.Curve#getReversedCurve()->Curve::: curve get reversed curve
sun.awt.geom.Curve#getSubCurve(double, double, int)->Curve::: curve get sub curve
sun.awt.geom.Curve#compareTo(Curve, double[])->int::: curve compare to
sun.awt.geom.Curve#findIntersect(Curve, double[], double, int, int, double, double, double, double, double, double, double, double, double, double, double, double)->boolean::: curve find intersect
sun.awt.geom.Curve#refineTforY(double, double, double)->double::: curve refine tfor y
sun.awt.geom.Curve#fairlyClose(double, double)->boolean::: curve fairly close
sun.awt.geom.Curve#getSegment(double[])->int::: curve get segment
sun.awt.geom.CurveLink#absorb(CurveLink)->boolean::: curve link absorb
sun.awt.geom.CurveLink#absorb(Curve, double, double, int)->boolean::: curve link absorb
sun.awt.geom.CurveLink#isEmpty()->boolean::: curve link is empty
sun.awt.geom.CurveLink#getCurve()->Curve::: curve link get curve
sun.awt.geom.CurveLink#getSubCurve()->Curve::: curve link get sub curve
sun.awt.geom.CurveLink#getMoveto()->Curve::: curve link get moveto
sun.awt.geom.CurveLink#getXTop()->double::: curve link get top
sun.awt.geom.CurveLink#getYTop()->double::: curve link get top
sun.awt.geom.CurveLink#getXBot()->double::: curve link get bot
sun.awt.geom.CurveLink#getYBot()->double::: curve link get bot
sun.awt.geom.CurveLink#getX()->double::: curve link get x
sun.awt.geom.CurveLink#getEdgeTag()->int::: curve link get edge tag
sun.awt.geom.CurveLink#setNext(CurveLink)->void::: curve link set next
sun.awt.geom.CurveLink#getNext()->CurveLink::: curve link get next
sun.awt.geom.Edge#getCurve()->Curve::: edge get curve
sun.awt.geom.Edge#getCurveTag()->int::: edge get curve tag
sun.awt.geom.Edge#getEdgeTag()->int::: edge get edge tag
sun.awt.geom.Edge#setEdgeTag(int)->void::: edge set edge tag
sun.awt.geom.Edge#getEquivalence()->int::: edge get equivalence
sun.awt.geom.Edge#setEquivalence(int)->void::: edge set equivalence
sun.awt.geom.Edge#compareTo(Edge, double[])->int::: edge compare to
sun.awt.geom.Edge#record(double, int)->void::: edge record
sun.awt.geom.Edge#isActiveFor(double, int)->boolean::: edge is active for
sun.awt.geom.Edge#toString()->String::: edge to string
sun.awt.geom.Order0#getOrder()->int::: order0 get order
sun.awt.geom.Order0#getXTop()->double::: order0 get top
sun.awt.geom.Order0#getYTop()->double::: order0 get top
sun.awt.geom.Order0#getXBot()->double::: order0 get bot
sun.awt.geom.Order0#getYBot()->double::: order0 get bot
sun.awt.geom.Order0#getXMin()->double::: order0 get min
sun.awt.geom.Order0#getXMax()->double::: order0 get max
sun.awt.geom.Order0#getX0()->double::: order0 get x0
sun.awt.geom.Order0#getY0()->double::: order0 get y0
sun.awt.geom.Order0#getX1()->double::: order0 get x1
sun.awt.geom.Order0#getY1()->double::: order0 get y1
sun.awt.geom.Order0#XforY(double)->double::: order0  xfor y
sun.awt.geom.Order0#TforY(double)->double::: order0  tfor y
sun.awt.geom.Order0#XforT(double)->double::: order0  xfor t
sun.awt.geom.Order0#YforT(double)->double::: order0  yfor t
sun.awt.geom.Order0#dXforT(double, int)->double::: order0 d xfor t
sun.awt.geom.Order0#dYforT(double, int)->double::: order0 d yfor t
sun.awt.geom.Order0#nextVertical(double, double)->double::: order0 next vertical
sun.awt.geom.Order0#crossingsFor(double, double)->int::: order0 crossings for
sun.awt.geom.Order0#accumulateCrossings(Crossings)->boolean::: order0 accumulate crossings
sun.awt.geom.Order0#enlarge(Rectangle2D)->void::: order0 enlarge
sun.awt.geom.Order0#getSubCurve(double, double, int)->Curve::: order0 get sub curve
sun.awt.geom.Order0#getReversedCurve()->Curve::: order0 get reversed curve
sun.awt.geom.Order0#getSegment(double[])->int::: order0 get segment
sun.awt.geom.Order1#getOrder()->int::: order1 get order
sun.awt.geom.Order1#getXTop()->double::: order1 get top
sun.awt.geom.Order1#getYTop()->double::: order1 get top
sun.awt.geom.Order1#getXBot()->double::: order1 get bot
sun.awt.geom.Order1#getYBot()->double::: order1 get bot
sun.awt.geom.Order1#getXMin()->double::: order1 get min
sun.awt.geom.Order1#getXMax()->double::: order1 get max
sun.awt.geom.Order1#getX0()->double::: order1 get x0
sun.awt.geom.Order1#getY0()->double::: order1 get y0
sun.awt.geom.Order1#getX1()->double::: order1 get x1
sun.awt.geom.Order1#getY1()->double::: order1 get y1
sun.awt.geom.Order1#XforY(double)->double::: order1  xfor y
sun.awt.geom.Order1#TforY(double)->double::: order1  tfor y
sun.awt.geom.Order1#XforT(double)->double::: order1  xfor t
sun.awt.geom.Order1#YforT(double)->double::: order1  yfor t
sun.awt.geom.Order1#dXforT(double, int)->double::: order1 d xfor t
sun.awt.geom.Order1#dYforT(double, int)->double::: order1 d yfor t
sun.awt.geom.Order1#nextVertical(double, double)->double::: order1 next vertical
sun.awt.geom.Order1#accumulateCrossings(Crossings)->boolean::: order1 accumulate crossings
sun.awt.geom.Order1#enlarge(Rectangle2D)->void::: order1 enlarge
sun.awt.geom.Order1#getSubCurve(double, double, int)->Curve::: order1 get sub curve
sun.awt.geom.Order1#getReversedCurve()->Curve::: order1 get reversed curve
sun.awt.geom.Order1#compareTo(Curve, double[])->int::: order1 compare to
sun.awt.geom.Order1#getSegment(double[])->int::: order1 get segment
sun.awt.geom.Order2#insert(Vector, double[], double, double, double, double, double, double, int)->void::: order2 insert
sun.awt.geom.Order2#addInstance(Vector, double, double, double, double, double, double, int)->void::: order2 add instance
sun.awt.geom.Order2#getHorizontalParams(double, double, double, double[])->int::: order2 get horizontal params
sun.awt.geom.Order2#split(double[], int, double)->void::: order2 split
sun.awt.geom.Order2#getOrder()->int::: order2 get order
sun.awt.geom.Order2#getXTop()->double::: order2 get top
sun.awt.geom.Order2#getYTop()->double::: order2 get top
sun.awt.geom.Order2#getXBot()->double::: order2 get bot
sun.awt.geom.Order2#getYBot()->double::: order2 get bot
sun.awt.geom.Order2#getXMin()->double::: order2 get min
sun.awt.geom.Order2#getXMax()->double::: order2 get max
sun.awt.geom.Order2#getX0()->double::: order2 get x0
sun.awt.geom.Order2#getY0()->double::: order2 get y0
sun.awt.geom.Order2#getCX0()->double::: order2 get x0
sun.awt.geom.Order2#getCY0()->double::: order2 get y0
sun.awt.geom.Order2#getX1()->double::: order2 get x1
sun.awt.geom.Order2#getY1()->double::: order2 get y1
sun.awt.geom.Order2#XforY(double)->double::: order2  xfor y
sun.awt.geom.Order2#TforY(double)->double::: order2  tfor y
sun.awt.geom.Order2#TforY(double, double, double, double)->double::: order2  tfor y
sun.awt.geom.Order2#XforT(double)->double::: order2  xfor t
sun.awt.geom.Order2#YforT(double)->double::: order2  yfor t
sun.awt.geom.Order2#dXforT(double, int)->double::: order2 d xfor t
sun.awt.geom.Order2#dYforT(double, int)->double::: order2 d yfor t
sun.awt.geom.Order2#nextVertical(double, double)->double::: order2 next vertical
sun.awt.geom.Order2#enlarge(Rectangle2D)->void::: order2 enlarge
sun.awt.geom.Order2#getSubCurve(double, double, int)->Curve::: order2 get sub curve
sun.awt.geom.Order2#getReversedCurve()->Curve::: order2 get reversed curve
sun.awt.geom.Order2#getSegment(double[])->int::: order2 get segment
sun.awt.geom.Order2#controlPointString()->String::: order2 control point string
sun.awt.geom.Order3#insert(Vector, double[], double, double, double, double, double, double, double, double, int)->void::: order3 insert
sun.awt.geom.Order3#addInstance(Vector, double, double, double, double, double, double, double, double, int)->void::: order3 add instance
sun.awt.geom.Order3#getHorizontalParams(double, double, double, double, double[])->int::: order3 get horizontal params
sun.awt.geom.Order3#split(double[], int, double)->void::: order3 split
sun.awt.geom.Order3#getOrder()->int::: order3 get order
sun.awt.geom.Order3#getXTop()->double::: order3 get top
sun.awt.geom.Order3#getYTop()->double::: order3 get top
sun.awt.geom.Order3#getXBot()->double::: order3 get bot
sun.awt.geom.Order3#getYBot()->double::: order3 get bot
sun.awt.geom.Order3#getXMin()->double::: order3 get min
sun.awt.geom.Order3#getXMax()->double::: order3 get max
sun.awt.geom.Order3#getX0()->double::: order3 get x0
sun.awt.geom.Order3#getY0()->double::: order3 get y0
sun.awt.geom.Order3#getCX0()->double::: order3 get x0
sun.awt.geom.Order3#getCY0()->double::: order3 get y0
sun.awt.geom.Order3#getCX1()->double::: order3 get x1
sun.awt.geom.Order3#getCY1()->double::: order3 get y1
sun.awt.geom.Order3#getX1()->double::: order3 get x1
sun.awt.geom.Order3#getY1()->double::: order3 get y1
sun.awt.geom.Order3#TforY(double)->double::: order3  tfor y
sun.awt.geom.Order3#refine(double, double, double, double, double)->double::: order3 refine
sun.awt.geom.Order3#XforY(double)->double::: order3  xfor y
sun.awt.geom.Order3#XforT(double)->double::: order3  xfor t
sun.awt.geom.Order3#YforT(double)->double::: order3  yfor t
sun.awt.geom.Order3#dXforT(double, int)->double::: order3 d xfor t
sun.awt.geom.Order3#dYforT(double, int)->double::: order3 d yfor t
sun.awt.geom.Order3#nextVertical(double, double)->double::: order3 next vertical
sun.awt.geom.Order3#enlarge(Rectangle2D)->void::: order3 enlarge
sun.awt.geom.Order3#getSubCurve(double, double, int)->Curve::: order3 get sub curve
sun.awt.geom.Order3#getReversedCurve()->Curve::: order3 get reversed curve
sun.awt.geom.Order3#getSegment(double[])->int::: order3 get segment
sun.awt.geom.Order3#controlPointString()->String::: order3 control point string
sun.awt.geom.PathConsumer2D#moveTo(float, float)->void::: path consumer2 d move to
sun.awt.geom.PathConsumer2D#lineTo(float, float)->void::: path consumer2 d line to
sun.awt.geom.PathConsumer2D#quadTo(float, float, float, float)->void::: path consumer2 d quad to
sun.awt.geom.PathConsumer2D#curveTo(float, float, float, float, float, float)->void::: path consumer2 d curve to
sun.awt.geom.PathConsumer2D#closePath()->void::: path consumer2 d close path
sun.awt.geom.PathConsumer2D#pathDone()->void:::Called after the last segment of the last subpath when the iteration of the path segments is completely done
sun.awt.geom.PathConsumer2D#getNativeConsumer()->long:::If a given PathConsumer performs all or most of its work natively then it can return a (non-zero) pointer to a native function vector that defines C functions for all of the above methods
