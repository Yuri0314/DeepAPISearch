AreaOp.CAGOp#newRow()::: op new row:::
AreaOp.CAGOp#classify(Edge)::: op classify:::if->e->getCurveTag->else->newClass->newClassification->if->return->return
AreaOp.CAGOp#getState()::: op get state:::return
AreaOp.CAGOp#newClassification(boolean, boolean)::: op new classification:::
AreaOp.AddOp#newClassification(boolean, boolean)::: add op new classification:::return
AreaOp.SubOp#newClassification(boolean, boolean)::: sub op new classification:::return
AreaOp.IntOp#newClassification(boolean, boolean)::: int op new classification:::return
AreaOp.XorOp#newClassification(boolean, boolean)::: xor op new classification:::return
AreaOp.NZWindOp#newRow()::: wind op new row:::
AreaOp.NZWindOp#classify(Edge)::: wind op classify:::newCount->type->e->getCurve->getDirection->return
AreaOp.NZWindOp#getState()::: wind op get state:::return
AreaOp.EOWindOp#newRow()::: wind op new row:::
AreaOp.EOWindOp#classify(Edge)::: wind op classify:::newInside->return
AreaOp.EOWindOp#getState()::: wind op get state:::return
AreaOp#newRow()::: area op new row:::
AreaOp#classify(Edge)::: area op classify:::
AreaOp#getState()::: area op get state:::
AreaOp#calculate(Vector, Vector)::: area op calculate:::edges->new->Vector<>->addEdges->addEdges->curves->pruneEdges->if->println->numcurves->curves->size->curvelist->curves->new->CurveArr->toArray->for->i->return
AreaOp#addEdges(Vector, Vector, int)::: area op add edges:::enum_->curves->elements->while->enum_->hasMoreElements->c->enum_->nextElement->if->c->getOrder->edges->new->Edge->add
AreaOp#pruneEdges(Vector)::: area op prune edges:::numedges->edges->size->if->return->new->Vector<>->edgelist->edges->new->EdgeArr->toArray->Arrays->sort->if->println->for->i->e->left->right->cur->next->yrange->new->doubleArr->subcurves->new->Vector<>->chains->new->Vector<>->links->new->Vector<>->while->y->for->if->if->break->getCurve->getYTop->if->finalizeSubCurves->while->if->e->getCurve->getYTop->break->getCurve->getYBot->if->getCurve->getYTop->if->if->println->for->nexteq->for->if->println->for->newRow->ystart->yend->for->if->getState->println->println->links->size->println->println->if->getCurve->getYTop->println->else->println->for->if->println->for->i->links->size->resolveLinks->links->clear->finalizeSubCurves->ret->new->Vector<>->enum_->subcurves->elements->while->enum_->hasMoreElements->link->enum_->nextElement->ret->link->getMoveto->add->nextlink->while->nextlink->getNext->if->link->absorb->ret->link->getSubCurve->add->ret->link->getSubCurve->add->return
AreaOp#finalizeSubCurves(Vector, Vector)::: area op finalize sub curves:::numchains->chains->size->if->return->if->throw->new->InternalError->endlist->new->ChainEndArr->chains->toArray->for->i->chains->clear
AreaOp#resolveLinks(Vector, Vector, Vector)::: area op resolve links:::numlinks->links->size->linklist->if->else->if->throw->new->InternalError->new->CurveLinkArr->links->toArray->numchains->chains->size->endlist->if->else->if->throw->new->InternalError->new->ChainEndArr->chains->toArray->curchain->curlink->chains->clear->chain->nextchain->link->nextlink->while->connectchains->connectlinks->if->chain->getX->nextchain->getX->link->getX->nextlink->getX->if->cx->chain->getX->lx->link->getX->nextchain->getX->obstructs->nextlink->getX->obstructs->if->subcurve->chain->linkTo->if->subcurves->add->if->openend->new->ChainEnd->closeend->new->ChainEnd->openend->setOtherEnd->chains->add->chains->add->if->chain->addLink->chains->add->if->chains->size->println
AreaOp#obstructs(double, double, int)::: area op obstructs:::return
ChainEnd#getChain()::: chain end get chain:::return
ChainEnd#setOtherEnd(ChainEnd)::: chain end set other end:::
ChainEnd#getPartner()::: chain end get partner:::return
ChainEnd#linkTo(ChainEnd)::: chain end link to:::if->throw->new->InternalError->if->throw->new->InternalError->enter->exit->if->else->setNext->if->return->otherenter->otherexit->if->getYTop->getYTop->setNext->else->setNext->return
ChainEnd#addLink(CurveLink)::: chain end add link:::if->tail->setNext->else->newlink->setNext
ChainEnd#getX()::: chain end get x:::if->return->tail->getXBot->else->return->head->getXBot
Crossings#getXLo()::: crossings get lo:::return
Crossings#getYLo()::: crossings get lo:::return
Crossings#getXHi()::: crossings get hi:::return
Crossings#getYHi()::: crossings get hi:::return
Crossings#record(double, double, int)::: crossings record:::
Crossings#print()::: crossings print:::println->println->for->i->println
Crossings#isEmpty()::: crossings is empty:::return
Crossings#covers(double, double)::: crossings covers:::
Crossings#findCrossings(Vector, double, double, double, double)::: crossings find crossings:::cross->new->EvenOdd->enum_->curves->elements->while->enum_->hasMoreElements->c->enum_->nextElement->if->c->accumulateCrossings->return->if->cross->print->return
Crossings#findCrossings(PathIterator, double, double, double, double)::: crossings find crossings:::cross->if->pi->getWindingRule->new->EvenOdd->else->new->NonZero->coords->new->doubleArr->movx->movy->curx->cury->newx->newy->while->pi->isDone->type->pi->currentSegment->switch->if->cross->accumulateLine->return->break->if->cross->accumulateLine->return->break->if->cross->accumulateQuad->return->break->if->cross->accumulateCubic->return->break->if->cross->accumulateLine->return->break->pi->next->if->if->cross->accumulateLine->return->if->cross->print->return
Crossings#accumulateLine(double, double, double, double)::: crossings accumulate line:::if->return->accumulateLine->else->return->accumulateLine
Crossings#accumulateLine(double, double, double, double, int)::: crossings accumulate line:::if->return->if->return->if->return->xstart->ystart->xend->yend->dx->dy->if->else->if->else->if->return->if->return->record->return
Crossings#accumulateQuad(double, double, double[])::: crossings accumulate quad:::if->return->if->return->if->return->if->if->Math->max->Math->min->record->else->if->Math->max->Math->min->record->return->Curve->insertQuad->enum_->tmp->elements->while->enum_->hasMoreElements->c->enum_->nextElement->if->c->accumulateCrossings->return->tmp->clear->return
Crossings#accumulateCubic(double, double, double[])::: crossings accumulate cubic:::if->return->if->return->if->return->if->if->Math->max->Math->min->record->else->Math->max->Math->min->record->return->Curve->insertCubic->enum_->tmp->elements->while->enum_->hasMoreElements->c->enum_->nextElement->if->c->accumulateCrossings->return->tmp->clear->return
Crossings.EvenOdd#covers(double, double)::: even odd covers:::return
Crossings.EvenOdd#record(double, double, int)::: even odd record:::if->return->from->while->to->while->yrlo->yrhi->if->continue->yll->ylh->yhl->yhh->if->else->if->else->if->else->if->if->if->break->if->System->arraycopy->if->if->newranges->new->doubleArr->System->arraycopy
Crossings.NonZero#covers(double, double)::: non zero covers:::i->while->ylo->yhi->if->continue->if->return->if->return->return
Crossings.NonZero#remove(int)::: non zero remove:::rem->if->System->arraycopy->System->arraycopy
Crossings.NonZero#insert(int, double, double, int)::: non zero insert:::rem->oldranges->oldcounts->if->new->doubleArr->System->arraycopy->new->intArr->System->arraycopy->if->System->arraycopy->System->arraycopy
Crossings.NonZero#record(double, double, int)::: non zero record:::if->return->cur->while->if->rdir->yrlo->yrhi->if->if->return->remove->if->insert->return->if->return->if->insert->else->if->insert->newdir->newend->Math->min->if->remove->else->if->insert->if->insert
Curve#insertMove(Vector, double, double)::: curve insert move:::curves->new->Order0->add
Curve#insertLine(Vector, double, double, double, double)::: curve insert line:::if->curves->new->Order1->add->else->if->curves->new->Order1->add->else
Curve#insertQuad(Vector, double, double, double[])::: curve insert quad:::y1->if->Order2->insert->else->if->return->else->Order2->insert
Curve#insertCubic(Vector, double, double, double[])::: curve insert cubic:::y1->if->Order3->insert->else->if->return->else->Order3->insert
Curve#pointCrossingsForPath(PathIterator, double, double):::Calculates the number of times the given path crosses the ray extending to the right from (px,py):::if->pi->isDone->return->coords->new->doubleArr->if->pi->currentSegment->throw->new->IllegalPathStateException->pi->next->movx->movy->curx->cury->endx->endy->crossings->while->pi->isDone->switch->pi->currentSegment->if->pointCrossingsForLine->break->pointCrossingsForLine->break->pointCrossingsForQuad->break->pointCrossingsForCubic->break->if->pointCrossingsForLine->break->pi->next->if->pointCrossingsForLine->return
Curve#pointCrossingsForLine(double, double, double, double, double, double):::Calculates the number of times the line from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py):::if->return->if->return->if->return->if->return->xintercept->if->return->return
Curve#pointCrossingsForQuad(double, double, double, double, double, double, double, double, int):::Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py):::if->return->if->return->if->return->if->if->if->return->else->if->return->return->if->return->pointCrossingsForLine->x0c->y0c->xc1->yc1->if->Double->isNaN->Double->isNaN->return->return->pointCrossingsForQuad->pointCrossingsForQuad
Curve#pointCrossingsForCubic(double, double, double, double, double, double, double, double, double, double, int):::Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses the ray extending to the right from (px,py):::if->return->if->return->if->return->if->if->if->return->else->if->return->return->if->return->pointCrossingsForLine->xmid->ymid->xc0m->yc0m->xmc1->ymc1->if->Double->isNaN->Double->isNaN->return->return->pointCrossingsForCubic->pointCrossingsForCubic
Curve#rectCrossingsForPath(PathIterator, double, double, double, double):::Accumulate the number of times the path crosses the shadow extending to the right of the rectangle:::if->return->if->pi->isDone->return->coords->new->doubleArr->if->pi->currentSegment->throw->new->IllegalPathStateException->pi->next->curx->cury->movx->movy->endx->endy->crossings->while->pi->isDone->switch->pi->currentSegment->if->rectCrossingsForLine->break->rectCrossingsForLine->break->rectCrossingsForQuad->break->rectCrossingsForCubic->break->if->rectCrossingsForLine->break->pi->next->if->rectCrossingsForLine->return
Curve#rectCrossingsForLine(int, double, double, double, double, double, double, double, double):::Accumulate the number of times the line crosses the shadow extending to the right of the rectangle:::if->return->if->return->if->return->if->if->if->if->else->if->if->if->return->if->return->xi0->if->else->if->xi1->if->else->if->if->return->if->if->if->if->else->if->if->if->return->return
Curve#rectCrossingsForQuad(int, double, double, double, double, double, double, double, double, double, double, int):::Accumulate the number of times the quad crosses the shadow extending to the right of the rectangle:::if->return->if->return->if->return->if->if->if->if->else->if->if->if->return->if->return->if->return->rectCrossingsForLine->x0c->y0c->xc1->yc1->if->Double->isNaN->Double->isNaN->return->rectCrossingsForQuad->if->rectCrossingsForQuad->return
Curve#rectCrossingsForCubic(int, double, double, double, double, double, double, double, double, double, double, double, double, int):::Accumulate the number of times the cubic crosses the shadow extending to the right of the rectangle:::if->return->if->return->if->return->if->if->if->if->else->if->if->if->return->if->return->if->return->rectCrossingsForLine->xmid->ymid->xc0m->yc0m->xmc1->ymc1->if->Double->isNaN->Double->isNaN->return->rectCrossingsForCubic->if->rectCrossingsForCubic->return
Curve#getDirection()::: curve get direction:::return
Curve#getWithDirection(int)::: curve get with direction:::return->getReversedCurve
Curve#round(double)::: curve round:::return
Curve#orderof(double, double)::: curve orderof:::if->return->if->return->return
Curve#signeddiffbits(double, double)::: curve signeddiffbits:::return->Double->doubleToLongBits->Double->doubleToLongBits
Curve#diffbits(double, double)::: curve diffbits:::return->Math->Double->doubleToLongBits->Double->doubleToLongBits->abs
Curve#prev(double)::: curve prev:::return->Double->Double->doubleToLongBits->longBitsToDouble
Curve#next(double)::: curve next:::return->Double->Double->doubleToLongBits->longBitsToDouble
Curve#toString()::: curve to string:::return->getOrder->getX0->round->getY0->round->controlPointString->getX1->round->getY1->round
Curve#controlPointString()::: curve control point string:::return
Curve#getOrder()::: curve get order:::
Curve#getXTop()::: curve get top:::
Curve#getYTop()::: curve get top:::
Curve#getXBot()::: curve get bot:::
Curve#getYBot()::: curve get bot:::
Curve#getXMin()::: curve get min:::
Curve#getXMax()::: curve get max:::
Curve#getX0()::: curve get x0:::
Curve#getY0()::: curve get y0:::
Curve#getX1()::: curve get x1:::
Curve#getY1()::: curve get y1:::
Curve#XforY(double)::: curve  xfor y:::
Curve#TforY(double)::: curve  tfor y:::
Curve#XforT(double)::: curve  xfor t:::
Curve#YforT(double)::: curve  yfor t:::
Curve#dXforT(double, int)::: curve d xfor t:::
Curve#dYforT(double, int)::: curve d yfor t:::
Curve#nextVertical(double, double)::: curve next vertical:::
Curve#crossingsFor(double, double)::: curve crossings for:::if->getYTop->getYBot->if->getXMax->getXMin->XforY->return->return
Curve#accumulateCrossings(Crossings)::: curve accumulate crossings:::xhi->c->getXHi->if->getXMin->return->xlo->c->getXLo->ylo->c->getYLo->yhi->c->getYHi->y0->getYTop->y1->getYBot->tstart->ystart->tend->yend->if->if->return->TforY->else->if->return->if->TforY->else->hitLo->hitHi->while->x->XforT->if->if->return->else->if->return->if->break->nextVertical->if->c->record->return
Curve#enlarge(Rectangle2D)::: curve enlarge:::
Curve#getSubCurve(double, double)::: curve get sub curve:::return->getSubCurve
Curve#getReversedCurve()::: curve get reversed curve:::
Curve#getSubCurve(double, double, int)::: curve get sub curve:::
Curve#compareTo(Curve, double[])::: curve compare to:::y0->y1->Math->Math->this->getYBot->min->that->getYBot->min->if->println->println->println->throw->new->InternalError->if->this->getXMax->that->getXMin->if->this->getXMin->that->getXMax->return->return->if->this->getXMin->that->getXMax->return->s0->this->TforY->ys0->this->YforT->if->refineTforY->this->YforT->s1->this->TforY->if->this->YforT->this->YforT->refineTforY->t0->that->TforY->yt0->that->YforT->if->that->refineTforY->that->YforT->t1->that->TforY->if->that->YforT->that->that->YforT->refineTforY->xs0->this->XforT->xt0->that->XforT->scale->Math->Math->abs->Math->abs->max->ymin->Math->max->if->fairlyClose->bump->maxbump->Math->min->y->while->if->this->XforY->that->XforY->fairlyClose->if->else->while->newy->if->break->if->this->XforY->that->XforY->fairlyClose->break->if->if->return->if->println->while->sh->this->nextVertical->xsh->this->XforT->ysh->this->YforT->th->that->nextVertical->xth->that->XforT->yth->that->YforT->try->if->findIntersect->break->catch->println->println->println->println->println->return->finally->if->if->if->break->else->if->if->break->ymid->return->this->XforY->that->XforY->orderof
Curve#findIntersect(Curve, double[], double, int, int, double, double, double, double, double, double, double, double, double, double, double, double)::: curve find intersect:::if->return->if->Math->min->Math->max->Math->max->Math->min->return->if->s->xs->this->XforT->ys->this->YforT->if->println->println->throw->new->InternalError->if->t->xt->that->XforT->yt->that->YforT->if->println->println->throw->new->InternalError->if->if->findIntersect->return->if->if->findIntersect->return->if->if->findIntersect->return->if->if->findIntersect->return->else->if->if->findIntersect->return->if->if->findIntersect->return->else->if->t->xt->that->XforT->yt->that->YforT->if->println->println->throw->new->InternalError->if->if->findIntersect->return->if->if->findIntersect->return->else->xlk->ylk->xnm->ynm->xmk->ymk->det->if->detinv->s->t->if->if->println->y->this->YforT->that->YforT->if->return->return
Curve#refineTforY(double, double, double)::: curve refine tfor y:::t1->while->th->if->return->y->YforT->if->else->if->else->return
Curve#fairlyClose(double, double)::: curve fairly close:::return->Math->abs->Math->Math->abs->Math->abs->max
Curve#getSegment(double[])::: curve get segment:::
CurveLink#absorb(CurveLink)::: curve link absorb:::return->absorb
CurveLink#absorb(Curve, double, double, int)::: curve link absorb:::if->return->if->curve->getYTop->curve->getYBot->throw->new->InternalError->Math->min->Math->max->return
CurveLink#isEmpty()::: curve link is empty:::return
CurveLink#getCurve()::: curve link get curve:::return
CurveLink#getSubCurve()::: curve link get sub curve:::if->curve->getYTop->curve->getYBot->return->curve->getWithDirection->return->curve->getSubCurve
CurveLink#getMoveto()::: curve link get moveto:::return->getXTop->getYTop->new->Order0
CurveLink#getXTop()::: curve link get top:::return->curve->XforY
CurveLink#getYTop()::: curve link get top:::return
CurveLink#getXBot()::: curve link get bot:::return->curve->XforY
CurveLink#getYBot()::: curve link get bot:::return
CurveLink#getX()::: curve link get x:::return->curve->XforY
CurveLink#getEdgeTag()::: curve link get edge tag:::return
CurveLink#setNext(CurveLink)::: curve link set next:::
CurveLink#getNext()::: curve link get next:::return
Edge#getCurve()::: edge get curve:::return
Edge#getCurveTag()::: edge get curve tag:::return
Edge#getEdgeTag()::: edge get edge tag:::return
Edge#setEdgeTag(int)::: edge set edge tag:::
Edge#getEquivalence()::: edge get equivalence:::return
Edge#setEquivalence(int)::: edge set equivalence:::
Edge#compareTo(Edge, double[])::: edge compare to:::if->if->return->if->if->return->ret->curve->compareTo->return
Edge#record(double, int)::: edge record:::
Edge#isActiveFor(double, int)::: edge is active for:::return
Edge#toString()::: edge to string:::return
Order0#getOrder()::: order0 get order:::return
Order0#getXTop()::: order0 get top:::return
Order0#getYTop()::: order0 get top:::return
Order0#getXBot()::: order0 get bot:::return
Order0#getYBot()::: order0 get bot:::return
Order0#getXMin()::: order0 get min:::return
Order0#getXMax()::: order0 get max:::return
Order0#getX0()::: order0 get x0:::return
Order0#getY0()::: order0 get y0:::return
Order0#getX1()::: order0 get x1:::return
Order0#getY1()::: order0 get y1:::return
Order0#XforY(double)::: order0  xfor y:::return
Order0#TforY(double)::: order0  tfor y:::return
Order0#XforT(double)::: order0  xfor t:::return
Order0#YforT(double)::: order0  yfor t:::return
Order0#dXforT(double, int)::: order0 d xfor t:::return
Order0#dYforT(double, int)::: order0 d yfor t:::return
Order0#nextVertical(double, double)::: order0 next vertical:::return
Order0#crossingsFor(double, double)::: order0 crossings for:::return
Order0#accumulateCrossings(Crossings)::: order0 accumulate crossings:::return->c->getXLo->c->getXHi->c->getYLo->c->getYHi
Order0#enlarge(Rectangle2D)::: order0 enlarge:::r->add
Order0#getSubCurve(double, double, int)::: order0 get sub curve:::return
Order0#getReversedCurve()::: order0 get reversed curve:::return
Order0#getSegment(double[])::: order0 get segment:::return
Order1#getOrder()::: order1 get order:::return
Order1#getXTop()::: order1 get top:::return
Order1#getYTop()::: order1 get top:::return
Order1#getXBot()::: order1 get bot:::return
Order1#getYBot()::: order1 get bot:::return
Order1#getXMin()::: order1 get min:::return
Order1#getXMax()::: order1 get max:::return
Order1#getX0()::: order1 get x0:::return
Order1#getY0()::: order1 get y0:::return
Order1#getX1()::: order1 get x1:::return
Order1#getY1()::: order1 get y1:::return
Order1#XforY(double)::: order1  xfor y:::if->return->if->return->return
Order1#TforY(double)::: order1  tfor y:::if->return->if->return->return
Order1#XforT(double)::: order1  xfor t:::return
Order1#YforT(double)::: order1  yfor t:::return
Order1#dXforT(double, int)::: order1 d xfor t:::switch->return->return->return
Order1#dYforT(double, int)::: order1 d yfor t:::switch->return->return->return
Order1#nextVertical(double, double)::: order1 next vertical:::return
Order1#accumulateCrossings(Crossings)::: order1 accumulate crossings:::xlo->c->getXLo->ylo->c->getYLo->xhi->c->getXHi->yhi->c->getYHi->if->return->xstart->ystart->xend->yend->if->if->return->XforY->else->if->return->if->XforY->else->if->return->if->return->c->record->return
Order1#enlarge(Rectangle2D)::: order1 enlarge:::r->add->r->add
Order1#getSubCurve(double, double, int)::: order1 get sub curve:::if->return->getWithDirection->if->return->new->Order1->num->denom->xstart->xend->return->new->Order1
Order1#getReversedCurve()::: order1 get reversed curve:::return->new->Order1
Order1#compareTo(Curve, double[])::: order1 compare to:::if->return->super->compareTo->c1->if->throw->new->InternalError->Math->Math->min->min->if->throw->new->InternalError->if->return->if->return->dxa->dya->dxb->dyb->denom->y->if->num->if->Math->min->else->if->Math->max->else->Math->max->return->XforY->c1->XforY->orderof
Order1#getSegment(double[])::: order1 get segment:::if->else->return
Order2#insert(Vector, double[], double, double, double, double, double, double, int)::: order2 insert:::numparams->getHorizontalParams->if->addInstance->return->t->split->i0->i1->addInstance->addInstance
Order2#addInstance(Vector, double, double, double, double, double, double, int)::: order2 add instance:::if->curves->new->Order2->add->else->if->curves->new->Order2->add
Order2#getHorizontalParams(double, double, double, double[])::: order2 get horizontal params:::if->return->denom->if->return->t->if->return->return
Order2#split(double[], int, double)::: order2 split:::x0->y0->cx->cy->x1->y1
Order2#getOrder()::: order2 get order:::return
Order2#getXTop()::: order2 get top:::return
Order2#getYTop()::: order2 get top:::return
Order2#getXBot()::: order2 get bot:::return
Order2#getYBot()::: order2 get bot:::return
Order2#getXMin()::: order2 get min:::return
Order2#getXMax()::: order2 get max:::return
Order2#getX0()::: order2 get x0:::return
Order2#getY0()::: order2 get y0:::return
Order2#getCX0()::: order2 get x0:::return
Order2#getCY0()::: order2 get y0:::return
Order2#getX1()::: order2 get x1:::return
Order2#getY1()::: order2 get y1:::return
Order2#XforY(double)::: order2  xfor y:::if->return->if->return->return->TforY->XforT
Order2#TforY(double)::: order2  tfor y:::if->return->if->return->return->TforY
Order2#TforY(double, double, double, double)::: order2  tfor y:::if->root->if->return->else->d->if->Math->sqrt->if->q->root->if->return->if->if->return->y0->y1->return
Order2#XforT(double)::: order2  xfor t:::return
Order2#YforT(double)::: order2  yfor t:::return
Order2#dXforT(double, int)::: order2 d xfor t:::switch->return->return->return->return
Order2#dYforT(double, int)::: order2 d yfor t:::switch->return->return->return->return
Order2#nextVertical(double, double)::: order2 next vertical:::t->if->return->return
Order2#enlarge(Rectangle2D)::: order2 enlarge:::r->add->t->if->r->XforT->YforT->add->r->add
Order2#getSubCurve(double, double, int)::: order2 get sub curve:::t0->t1->if->if->return->getWithDirection->else->TforY->if->else->TforY->eqn->new->doubleArr->if->split->i->if->else->split->return->new->Order2
Order2#getReversedCurve()::: order2 get reversed curve:::return->new->Order2
Order2#getSegment(double[])::: order2 get segment:::if->else->return
Order2#controlPointString()::: order2 control point string:::return->round->round
Order3#insert(Vector, double[], double, double, double, double, double, double, double, double, int)::: order3 insert:::numparams->getHorizontalParams->if->addInstance->return->t->if->split->if->split->index->if->while->addInstance->if->else
Order3#addInstance(Vector, double, double, double, double, double, double, double, double, int)::: order3 add instance:::if->curves->new->Order3->add->else->if->curves->new->Order3->add
Order3#getHorizontalParams(double, double, double, double, double[])::: order3 get horizontal params:::if->return->numroots->QuadCurve2D->solveQuadratic->j->for->i->return
Order3#split(double[], int, double)::: order3 split:::x0->y0->cx0->cy0->cx1->cy1->x1->y1
Order3#getOrder()::: order3 get order:::return
Order3#getXTop()::: order3 get top:::return
Order3#getYTop()::: order3 get top:::return
Order3#getXBot()::: order3 get bot:::return
Order3#getYBot()::: order3 get bot:::return
Order3#getXMin()::: order3 get min:::return
Order3#getXMax()::: order3 get max:::return
Order3#getX0()::: order3 get x0:::return
Order3#getY0()::: order3 get y0:::return
Order3#getCX0()::: order3 get x0:::return
Order3#getCY0()::: order3 get y0:::return
Order3#getCX1()::: order3 get x1:::return
Order3#getCY1()::: order3 get y1:::return
Order3#getX1()::: order3 get x1:::return
Order3#getY1()::: order3 get y1:::return
Order3#TforY(double)::: order3  tfor y:::if->return->if->return->if->return->if->return->if->return->if->return->Order2->TforY->a->b->c->roots->Q->R->R2->Q3->a_3->t->if->theta->Math->Math->sqrt->acos->Math->sqrt->Math->cos->refine->if->Math->cos->refine->if->Math->cos->refine->else->neg->S->Math->sqrt->if->A->Math->pow->if->B->refine->if->t0->t1->while->if->break->yt->YforT->if->else->if->else->break->if->return
Order3#refine(double, double, double, double, double)::: order3 refine:::if->return->y->YforT->t0->t1->if->else->origt->origy->useslope->while->if->t2->if->break->else->slope->dYforT->if->continue->t2->if->continue->YforT->if->else->if->else->break->verbose->if->YforT->tdiff->diffbits->ydiff->diffbits->yerr->diffbits->if->println->println->println->println->println->println->tlow->prev->ylow->YforT->thi->next->yhi->YforT->if->Math->abs->Math->abs->Math->abs->Math->abs->println->return
Order3#XforY(double)::: order3  xfor y:::if->return->if->return->return->TforY->XforT
Order3#XforT(double)::: order3  xfor t:::return
Order3#YforT(double)::: order3  yfor t:::return
Order3#dXforT(double, int)::: order3 d xfor t:::switch->return->return->return->return->return
Order3#dYforT(double, int)::: order3 d yfor t:::switch->return->return->return->return->return
Order3#nextVertical(double, double)::: order3 next vertical:::eqn->numroots->QuadCurve2D->solveQuadratic->for->i->return
Order3#enlarge(Rectangle2D)::: order3 enlarge:::r->add->eqn->numroots->QuadCurve2D->solveQuadratic->for->i->r->add
Order3#getSubCurve(double, double, int)::: order3 get sub curve:::if->return->getWithDirection->eqn->new->doubleArr->t0->t1->TforY->TforY->if->t->if->split->i->if->else->split->return->new->Order3
Order3#getReversedCurve()::: order3 get reversed curve:::return->new->Order3
Order3#getSegment(double[])::: order3 get segment:::if->else->return
Order3#controlPointString()::: order3 control point string:::return->getCX0->round->getCY0->round->getCX1->round->getCY1->round
PathConsumer2D#moveTo(float, float)::: path consumer2 d move to:::
PathConsumer2D#lineTo(float, float)::: path consumer2 d line to:::
PathConsumer2D#quadTo(float, float, float, float)::: path consumer2 d quad to:::
PathConsumer2D#curveTo(float, float, float, float, float, float)::: path consumer2 d curve to:::
PathConsumer2D#closePath()::: path consumer2 d close path:::
PathConsumer2D#pathDone():::Called after the last segment of the last subpath when the iteration of the path segments is completely done:::
PathConsumer2D#getNativeConsumer():::If a given PathConsumer performs all or most of its work natively then it can return a (non-zero) pointer to a native function vector that defines C functions for all of the above methods:::
