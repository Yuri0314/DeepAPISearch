DatatypeFactoryImpl#newDuration(String):::Obtain a new instance of a Duration specifying the Duration as its string representation, "PnYnMnDTnHnMnS", as defined in XML Schema 1.0 section 3.2.6.1.  XML Schema Part 2: Datatypes, 3.2.6 duration, defines duration as:  duration represents a duration of time:::return->new->DurationImpl
DatatypeFactoryImpl#newDuration(long):::Obtain a new instance of a Duration specifying the Duration as milliseconds.  XML Schema Part 2: Datatypes, 3.2.6 duration, defines duration as:  duration represents a duration of time:::return->new->DurationImpl
DatatypeFactoryImpl#newDuration(boolean, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, BigDecimal):::Obtain a new instance of a Duration specifying the Duration as isPositive, years, months, days, hours, minutes, seconds.  The XML Schema specification states that values can be of an arbitrary size:::return->new->DurationImpl
DatatypeFactoryImpl#newDurationYearMonth(boolean, BigInteger, BigInteger):::Create a Duration of type xdt:yearMonthDuration using the specified year and month as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration.  The XML Schema specification states that values can be of an arbitrary size:::return->new->DurationYearMonthImpl
DatatypeFactoryImpl#newDurationYearMonth(boolean, int, int):::Create a Duration of type xdt:yearMonthDuration using the specified year and month as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration.  A DatatypeConstants#FIELD_UNDEFINED value indicates that field is not set.:::return->new->DurationYearMonthImpl
DatatypeFactoryImpl#newDurationYearMonth(String):::Create a Duration of type xdt:yearMonthDuration by parsing its String representation, "PnYnM",    XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration.  The datatype xdt:yearMonthDuration is a subtype of xs:duration whose lexical representation contains only year and month components:::return->new->DurationYearMonthImpl
DatatypeFactoryImpl#newDurationYearMonth(long):::Create a Duration of type xdt:yearMonthDuration using the specified milliseconds as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:yearMonthDuration.  The datatype xdt:yearMonthDuration is a subtype of xs:duration whose lexical representation contains only year and month components:::return->new->DurationYearMonthImpl
DatatypeFactoryImpl#newDurationDayTime(String):::Create a Duration of type xdt:dayTimeDuration by parsing its String representation, "PnDTnHnMnS",    XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration.  The datatype xdt:dayTimeDuration is a subtype of xs:duration whose lexical representation contains only day, hour, minute, and second components:::if->throw->new->NullPointerException->return->new->DurationDayTimeImpl
DatatypeFactoryImpl#newDurationDayTime(long):::Create a Duration of type xdt:dayTimeDuration using the specified milliseconds as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration.  The datatype xdt:dayTimeDuration is a subtype of xs:duration whose lexical representation contains only day, hour, minute, and second components:::return->new->DurationDayTimeImpl
DatatypeFactoryImpl#newDurationDayTime(boolean, BigInteger, BigInteger, BigInteger, BigInteger):::Create a Duration of type xdt:dayTimeDuration using the specified day, hour, minute and second as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration.  The datatype xdt:dayTimeDuration is a subtype of xs:duration whose lexical representation contains only day, hour, minute, and second components:::return->new->BigDecimal->new->DurationDayTimeImpl
DatatypeFactoryImpl#newDurationDayTime(boolean, int, int, int, int):::Create a Duration of type xdt:dayTimeDuration using the specified day, hour, minute and second as defined in    XQuery 1.0 and XPath 2.0 Data Model, xdt:dayTimeDuration.  The datatype xdt:dayTimeDuration is a subtype of xs:duration whose lexical representation contains only day, hour, minute, and second components:::return->new->DurationDayTimeImpl
DatatypeFactoryImpl#newXMLGregorianCalendar():::Create a new instance of an XMLGregorianCalendar.  All date/time datatype fields set to DatatypeConstants#FIELD_UNDEFINED or null.:::return->new->XMLGregorianCalendarImpl
DatatypeFactoryImpl#newXMLGregorianCalendar(String):::Create a new XMLGregorianCalendar by parsing the String as a lexical representation.  Parsing the lexical string representation is defined in XML Schema 1.0 Part 2, Section 3.2.[7-14].1, Lexical Representation.  The string representation may not have any leading and trailing whitespaces.  The parsing is done field by field so that the following holds for any lexically correct String x:  newXMLGregorianCalendar(x).toXMLFormat().equals(x)  Except for the noted lexical/canonical representation mismatches listed in  XML Schema 1.0 errata, Section 3.2.7.2.:::return->new->XMLGregorianCalendarImpl
DatatypeFactoryImpl#newXMLGregorianCalendar(GregorianCalendar):::Create an XMLGregorianCalendar from a GregorianCalendar.  <table border="2" rules="all" cellpadding="2">   <thead>     <tr>       <th align="center" colspan="2">          Field by Field Conversion from          GregorianCalendar to an XMLGregorianCalendar       </th>     </tr>     <tr>        <th>java.util.GregorianCalendar field</th>        <th>javax.xml.datatype.XMLGregorianCalendar field</th>     </tr>   </thead>   <tbody>     <tr>       <td>ERA == GregorianCalendar.BC ? -YEAR : YEAR</td>       <td>XMLGregorianCalendar#setYear(int year)</td>     </tr>     <tr>       <td>MONTH + 1</td>       <td>XMLGregorianCalendar#setMonth(int month)</td>     </tr>     <tr>       <td>DAY_OF_MONTH</td>       <td>XMLGregorianCalendar#setDay(int day)</td>     </tr>     <tr>       <td>HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND</td>       <td>XMLGregorianCalendar#setTime(int hour, int minute, int second, BigDecimal fractional)</td>     </tr>     <tr>       <td>         (ZONE_OFFSET + DST_OFFSET) / (60*1000)<br/>         (in minutes)       </td>       <td>XMLGregorianCalendar#setTimezone(int offset)^*       </td>     </tr>   </tbody> </table> *conversion loss of information:::return->new->XMLGregorianCalendarImpl
DatatypeFactoryImpl#newXMLGregorianCalendar(BigInteger, int, int, int, int, int, BigDecimal, int):::Constructor allowing for complete value spaces allowed by W3C XML Schema 1.0 recommendation for xsd:dateTime and related builtin datatypes:::return->new->XMLGregorianCalendarImpl
DurationDayTimeImpl#getValue():::The value space of xs:dayTimeDuration is the set of fractional second values.:::sec->seconds->floatValue->return->getDays->getHours->getMinutes
DurationDayTimeImpl#convertToCanonicalDayTime()::: duration day time impl convert to canonical day time:::while->getSeconds->seconds->BigDecimal->valueOf->subtract->BigInteger->getMinutes->valueOf->add->while->getMinutes->minutes->BigInteger->valueOf->subtract->BigInteger->getHours->valueOf->add->while->getHours->hours->BigInteger->valueOf->subtract->BigInteger->getDays->valueOf->add
DurationImpl#getSign():::Returns the sign of this duration in -1,0, or 1.:::return
DurationImpl#calcSignum(boolean):::Determine the sign of the duration.:::if->years->signum->months->signum->days->signum->hours->signum->minutes->signum->seconds->signum->return->if->return->else->return
DurationImpl#testNonNegative(BigInteger, DatatypeConstants.Field):::Makes sure that the given number is non-negative:::if->n->signum->throw->DatatypeMessageFormatter->new->ObjectArr->f->toString->formatMessage->new->IllegalArgumentException
DurationImpl#testNonNegative(BigDecimal, DatatypeConstants.Field):::Makes sure that the given number is non-negative:::if->n->signum->throw->DatatypeMessageFormatter->new->ObjectArr->f->toString->formatMessage->new->IllegalArgumentException
DurationImpl#wrap(int):::TODO: Javadoc:::if->return->return->BigInteger->valueOf
DurationImpl#isDigit(char):::TODO: Javadoc:::return
DurationImpl#isDigitOrPeriod(char):::TODO: Javadoc:::return->isDigit
DurationImpl#parsePiece(String, int[]):::TODO: Javadoc:::start->while->whole->length->whole->charAt->isDigitOrPeriod->if->whole->length->throw->new->IllegalArgumentException->return->whole->substring
DurationImpl#organizeParts(String, String[], int[], int, String):::TODO: Javadoc.:::idx->tokens->length->for->i->for
DurationImpl#parseBigInteger(String, String, int):::TODO: Javadoc:::if->return->part->part->length->substring->return->new->BigInteger
DurationImpl#parseBigDecimal(String, String, int):::TODO: Javadoc.:::if->return->part->part->length->substring->return->new->BigDecimal
DurationImpl#compare(Duration):::Partial order relation comparison with this Duration instance.  Comparison result must be in accordance with W3C XML Schema 1.0 Part 2, Section 3.2.7.6.2, Order relation on duration.  Return: <ul>   <li>DatatypeConstants#LESSER if this Duration is shorter than duration parameter</li>   <li>DatatypeConstants#EQUAL if this Duration is equal to duration parameter</li>   <li>DatatypeConstants#GREATER if this Duration is longer than duration parameter</li>   <li>DatatypeConstants#INDETERMINATE if a conclusive partial order relation cannot be determined</li> </ul>:::foreach->getField->checkMaxValue->rhs->getField->checkMaxValue->return->compareDates
DurationImpl#checkMaxValue(Number, DatatypeConstants.Field):::Check if a field exceeds the maximum value:::fieldValue->if->else->rhsSecondsAsBigDecimal->if->rhsSecondsAsBigDecimal->toBigInteger->if->fieldValue->compareTo->throw->DatatypeMessageFormatter->new->ObjectArr->this->getClass->getName->field->toString->formatMessage->new->UnsupportedOperationException
DurationImpl#compareDates(Duration, Duration):::Compares 2 given durations:::resultA->resultB->tempA->clone->tempB->clone->tempA->add->tempB->add->tempA->compare->if->return->clone->clone->tempA->add->tempB->add->tempA->compare->compareResults->if->return->clone->clone->tempA->add->tempB->add->tempA->compare->compareResults->if->return->clone->clone->tempA->add->tempB->add->tempA->compare->compareResults->return
DurationImpl#compareResults(int, int)::: duration impl compare results:::if->return->else->if->return->return
DurationImpl#hashCode():::Returns a hash code consistent with the definition of the equals method.:::cal->toGregorianCalendar->this->addTo->return->getCalendarTimeInMillis
DurationImpl#toString():::Returns a string representation of this duration object:::buf->new->StringBuffer->if->buf->append->buf->append->if->buf->append->append->if->buf->append->append->if->buf->append->append->if->buf->append->if->buf->append->append->if->buf->append->append->if->buf->toString->append->append->return->buf->toString
DurationImpl#toString(BigDecimal):::Turns BigDecimal to a string representation.  Due to a behavior change in the BigDecimal#toString() method in JDK1.5, this had to be implemented here.:::intString->bd->unscaledValue->toString->scale->bd->scale->if->return->buf->insertionPoint->intString->length->if->return->else->if->new->StringBuffer->buf->insert->else->intString->length->new->StringBuffer->buf->append->for->i->buf->append->return->buf->toString
DurationImpl#isSet(DatatypeConstants.Field):::Checks if a field is set:::if->methodName->throw->DatatypeMessageFormatter->new->ObjectArr->formatMessage->new->NullPointerException->if->return->if->return->if->return->if->return->if->return->if->return->methodName->throw->DatatypeMessageFormatter->new->ObjectArr->field->toString->formatMessage->new->IllegalArgumentException
DurationImpl#getField(DatatypeConstants.Field):::Gets the value of a field:::if->methodName->throw->DatatypeMessageFormatter->new->ObjectArr->formatMessage->new->NullPointerException->if->return->if->return->if->return->if->return->if->return->if->return->methodName->throw->DatatypeMessageFormatter->new->ObjectArr->field->toString->formatMessage->new->IllegalArgumentException
DurationImpl#getYears():::Obtains the value of the YEARS field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getMonths():::Obtains the value of the MONTHS field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getDays():::Obtains the value of the DAYS field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getHours():::Obtains the value of the HOURS field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getMinutes():::Obtains the value of the MINUTES field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getSeconds():::Obtains the value of the SECONDS field as an integer value, or 0 if not present:::return->getInt
DurationImpl#getInt(DatatypeConstants.Field):::Return the requested field value as an int.  If field is not set, i.e:::n->getField->if->return->else->return->n->intValue
DurationImpl#getTimeInMillis(Calendar):::Returns the length of the duration in milli-seconds.  If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any Calendar value x,  new Duration("PT10.00099S").getTimeInMills(x) == 10000:::cal->startInstant->clone->addTo->return->getCalendarTimeInMillis->getCalendarTimeInMillis
DurationImpl#getTimeInMillis(Date):::Returns the length of the duration in milli-seconds.  If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any Date value x,  new Duration("PT10.00099S").getTimeInMills(x) == 10000:::cal->new->GregorianCalendar->cal->setTime->this->addTo->return->getCalendarTimeInMillis->startInstant->getTime
DurationImpl#normalizeWith(Calendar):::Converts the years and months fields into the days field by using a specific time instant as the reference point.  For example, duration of one month normalizes to 31 days given the start time instance "July 8th 2003, 17:40:32".  Formally, the computation is done as follows: <ol>  <li>The given Calendar object is cloned:::c->startTimeInstant->clone->c->getYears->add->c->getMonths->add->c->getDays->add->diff->getCalendarTimeInMillis->getCalendarTimeInMillis->days->return->Math->abs->wrap->getField->getField->getField->new->DurationImpl
DurationImpl#multiply(int):::Computes a new duration whose value is factor times longer than the value of this duration.  This method is provided for the convenience:::return->BigDecimal->valueOf->multiply
DurationImpl#multiply(BigDecimal):::Computes a new duration whose value is factor times longer than the value of this duration:::carry->factorSign->factor->signum->factor->abs->buf->new->BigDecimalArr->for->i->if->seconds->multiply->add->else->return->toBigInteger->toBigInteger->toBigInteger->toBigInteger->toBigInteger->signum->new->DurationImpl
DurationImpl#getFieldAsBigDecimal(DatatypeConstants.Field):::Gets the value of the field as a BigDecimal.  If the field is unset, return 0.:::if->if->return->else->return->else->bi->getField->if->return->else->return->new->BigDecimal
DurationImpl#toBigInteger(BigDecimal, boolean):::BigInteger value of BigDecimal value.:::if->value->signum->return->else->return->value->unscaledValue
DurationImpl#add(Duration):::Computes a new duration whose value is this+rhs.  For example,  "1 day" + "-3 days" = "-2 days" "1 year" + "1 day" = "1 year and 1 day" "-(1 hour,50 minutes)" + "-20 minutes" = "-(1 hours,70 minutes)" "15 hours" + "-3 days" = "-(2 days,9 hours)" "1 year" + "-1 day" = IllegalStateException   Since there's no way to meaningfully subtract 1 day from 1 month, there are cases where the operation fails in IllegalStateException.   Formally, the computation is defined as follows.  Firstly, we can assume that two Durations to be added are both positive without losing generality (i.e., (-X)+Y=Y-X, X+(-Y)=X-Y, (-X)+(-Y)=-(X+Y))   Addition of two positive Durations are simply defined as field by field addition where missing fields are treated as 0:::lhs->buf->new->BigDecimalArr->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->lhs->getField->lhs->getSign->sanitize->rhs->getField->rhs->getSign->sanitize->add->alignSigns->alignSigns->s->for->i->return->sanitize->lhs->getField->rhs->getField->toBigInteger->sanitize->lhs->getField->rhs->getField->toBigInteger->sanitize->lhs->getField->rhs->getField->toBigInteger->sanitize->lhs->getField->rhs->getField->toBigInteger->sanitize->lhs->getField->rhs->getField->toBigInteger->signum->lhs->getField->rhs->getField->sanitize->new->DurationImpl
DurationImpl#alignSigns(BigDecimal[], int, int)::: duration impl align signs:::touched->do->s->for->i->while
DurationImpl#sanitize(BigInteger, int):::Compute value*signum where value==null is treated as value==0.:::if->return->if->return->new->BigDecimal->return->value->negate->new->BigDecimal
DurationImpl#sanitize(BigDecimal, int):::Compute value*signum where value==null is treated as value==0.:::if->return->if->return->return->value->negate
DurationImpl#subtract(Duration):::Computes a new duration whose value is this-rhs.  For example:  "1 day" - "-3 days" = "4 days" "1 year" - "1 day" = IllegalStateException "-(1 hour,50 minutes)" - "-20 minutes" = "-(1hours,30 minutes)" "15 hours" - "-3 days" = "3 days and 15 hours" "1 year" - "-1 day" = "1 year and 1 day"   Since there's no way to meaningfully subtract 1 day from 1 month, there are cases where the operation fails in IllegalStateException.  Formally the computation is defined as follows:::return->rhs->negate->add
DurationImpl#negate():::Returns a new Duration object whose value is -this:::return->new->DurationImpl
DurationImpl#signum():::Returns the sign of this duration in -1,0, or 1.:::return
DurationImpl#addTo(Calendar):::Adds this duration to a Calendar object:::calendar->getYears->add->calendar->getMonths->add->calendar->getDays->add->calendar->getHours->add->calendar->getMinutes->add->calendar->getSeconds->add->if->fraction->seconds->seconds->setScale->subtract->millisec->fraction->movePointRight->intValue->calendar->add
DurationImpl#addTo(Date):::Adds this duration to a Date object:::cal->new->GregorianCalendar->cal->setTime->this->addTo->date->getCalendarTimeInMillis->setTime
DurationImpl#getCalendarTimeInMillis(Calendar):::Returns time value in milliseconds:::return->cal->getTimeInMillis
DurationImpl#writeReplace():::Writes Duration as a lexical representation for maximum future compatibility.:::return->this->toString->new->DurationStream
DurationImpl.DurationStream#readResolve()::: duration stream read resolve:::return->new->DurationImpl
DurationYearMonthImpl#getValue():::The value space of xs:yearMonthDuration is the set of xs:integer month values.:::return->getYears->getMonths
DurationYearMonthImpl#convertToCanonicalYearMonth()::: duration year month impl convert to canonical year month:::while->getMonths->months->BigInteger->valueOf->subtract->BigInteger->getYears->valueOf->add
XMLGregorianCalendarImpl#save():::save original values:::
XMLGregorianCalendarImpl#createDateTime(BigInteger, int, int, int, int, int, BigDecimal, int):::Create a Java representation of XML Schema builtin datatype dateTime:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createDateTime(int, int, int, int, int, int):::Create a Java instance of XML Schema builtin datatype dateTime.:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createDateTime(int, int, int, int, int, int, int, int):::Create a Java representation of XML Schema builtin datatype dateTime:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createDate(int, int, int, int):::Create a Java representation of XML Schema builtin datatype date or g*.  For example, an instance of gYear can be created invoking this factory with month and day parameters set to DatatypeConstants#FIELD_UNDEFINED.:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createTime(int, int, int, int):::Create a Java instance of XML Schema builtin datatype time.:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createTime(int, int, int, BigDecimal, int):::Create a Java instance of XML Schema builtin datatype time.:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#createTime(int, int, int, int, int):::Create a Java instance of XML Schema builtin datatype time.:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#getEon():::Return high order component for XML Schema 1.0 dateTime datatype field for year:::return
XMLGregorianCalendarImpl#getYear():::Return low order component for XML Schema 1.0 dateTime datatype field for year or DatatypeConstants#FIELD_UNDEFINED.  Value constraints for this value are summarized in year field of date/time field mapping table.:::return
XMLGregorianCalendarImpl#getEonAndYear():::Return XML Schema 1.0 dateTime datatype field for year.  Value constraints for this value are summarized in year field of date/time field mapping table.:::if->return->eon->BigInteger->valueOf->add->if->return->BigInteger->valueOf->return
XMLGregorianCalendarImpl#getMonth():::Return number of month or DatatypeConstants#FIELD_UNDEFINED.  Value constraints for this value are summarized in month field of date/time field mapping table.:::return
XMLGregorianCalendarImpl#getDay():::Return day in month or DatatypeConstants#FIELD_UNDEFINED.  Value constraints for this value are summarized in day field of date/time field mapping table.:::return
XMLGregorianCalendarImpl#getTimezone():::Return timezone offset in minutes or DatatypeConstants#FIELD_UNDEFINED if this optional field is not defined:::return
XMLGregorianCalendarImpl#getHour():::Return hours or DatatypeConstants#FIELD_UNDEFINED:::return
XMLGregorianCalendarImpl#getMinute():::Return minutes or DatatypeConstants#FIELD_UNDEFINED.<\p> Returns DatatypeConstants#FIELD_UNDEFINED if this field is not defined:::return
XMLGregorianCalendarImpl#getSecond():::Return seconds or DatatypeConstants#FIELD_UNDEFINED.<\p>  Returns DatatypeConstants#FIELD_UNDEFINED if this field is not defined:::return
XMLGregorianCalendarImpl#getSeconds()::: gregorian calendar impl get seconds:::if->return->result->BigDecimal->valueOf->if->return->result->add->else->return
XMLGregorianCalendarImpl#getMillisecond():::Return millisecond precision of #getFractionalSecond().<\p>  This method represents a convenience accessor to infinite precision fractional second value returned by #getFractionalSecond():::if->return->else->return->fractionalSecond->movePointRight->intValue
XMLGregorianCalendarImpl#getFractionalSecond():::Return fractional seconds.  null is returned when this optional field is not defined.  Value constraints are detailed in second field of date/time field mapping table.  This optional field can only have a defined value when the xs:dateTime second field, represented by (#getSecond(), does not return DatatypeConstants#FIELD_UNDEFINED).:::return
XMLGregorianCalendarImpl#setYear(BigInteger):::Set low and high order component of XSD dateTime year field.  Unset this field by invoking the setter with a parameter value of null.:::if->else->temp->year->remainder->temp->intValue->year->subtract->setEon
XMLGregorianCalendarImpl#setYear(int):::Set year of XSD dateTime year field.  Unset this field by invoking the setter with a parameter value of DatatypeConstants#FIELD_UNDEFINED.  Note: if the absolute value of the year parameter is less than 10^9, the eon component of the XSD year field is set to null by this method.:::if->else->if->Math->abs->else->theYear->BigInteger->valueOf->remainder->theYear->remainder->remainder->intValue->theYear->subtract->setEon
XMLGregorianCalendarImpl#setEon(BigInteger):::Set high order part of XSD dateTime year field.  Unset this field by invoking the setter with a parameter value of null.:::if->eon->compareTo->else
XMLGregorianCalendarImpl#setMonth(int):::Set month.  Unset this field by invoking the setter with a parameter value of DatatypeConstants#FIELD_UNDEFINED.:::if->if->invalidFieldValue
XMLGregorianCalendarImpl#setDay(int):::Set days in month.  Unset this field by invoking the setter with a parameter value of DatatypeConstants#FIELD_UNDEFINED.:::if->if->invalidFieldValue
XMLGregorianCalendarImpl#setTimezone(int):::Set the number of minutes in the timezone offset.  Unset this field by invoking the setter with a parameter value of DatatypeConstants#FIELD_UNDEFINED.:::if->if->invalidFieldValue
XMLGregorianCalendarImpl#setTime(int, int, int):::Set time as one unit.:::setTime
XMLGregorianCalendarImpl#invalidFieldValue(int, int)::: gregorian calendar impl invalid field value:::throw->DatatypeMessageFormatter->new->ObjectArr->formatMessage->new->IllegalArgumentException
XMLGregorianCalendarImpl#testHour()::: gregorian calendar impl test hour:::if->getHour->if->getMinute->getSecond->getHour->invalidFieldValue->setHour->new->DurationImpl->add
XMLGregorianCalendarImpl#setHour(int)::: gregorian calendar impl set hour:::setHour
XMLGregorianCalendarImpl#setHour(int, boolean)::: gregorian calendar impl set hour:::if->if->invalidFieldValue->if->testHour
XMLGregorianCalendarImpl#setMinute(int)::: gregorian calendar impl set minute:::if->if->invalidFieldValue
XMLGregorianCalendarImpl#setSecond(int)::: gregorian calendar impl set second:::if->if->invalidFieldValue
XMLGregorianCalendarImpl#setTime(int, int, int, BigDecimal):::Set time as one unit, including the optional infinite precison fractional seconds.:::setHour->setMinute->if->setSecond->else->if->setSecond->else->invalidFieldValue->setFractionalSecond->testHour
XMLGregorianCalendarImpl#setTime(int, int, int, int):::Set time as one unit, including optional milliseconds.:::setHour->setMinute->if->setSecond->else->if->setSecond->else->invalidFieldValue->setMillisecond->testHour
XMLGregorianCalendarImpl#compare(XMLGregorianCalendar):::Compare two instances of W3C XML Schema 1.0 date/time datatypes according to partial order relation defined in W3C XML Schema 1.0 Part 2, Section 3.2.7.3, Order relation on dateTime.  xsd:dateTime datatype field mapping to accessors of this class are defined in date/time field mapping table.:::lhs->result->P->Q->if->P->getTimezone->Q->getTimezone->return->internalCompare->else->if->P->getTimezone->Q->getTimezone->P->normalize->Q->normalize->return->internalCompare->else->if->P->getTimezone->if->P->getTimezone->P->normalize->MinQ->Q->normalizeToTimezone->internalCompare->if->return->MaxQ->Q->normalizeToTimezone->internalCompare->if->return->else->return->else->if->Q->getTimezone->Q->Q->getTimezone->normalizeToTimezone->MaxP->P->normalizeToTimezone->internalCompare->if->return->MinP->P->normalizeToTimezone->internalCompare->if->return->else->return
XMLGregorianCalendarImpl#normalize():::Normalize this instance to UTC.  2000-03-04T23:00:00+03:00 normalizes to 2000-03-04T20:00:00Z Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).:::normalized->normalizeToTimezone->if->getTimezone->normalized->setTimezone->if->getMillisecond->normalized->setMillisecond->return
XMLGregorianCalendarImpl#normalizeToTimezone(int):::Normalize this instance to UTC.  2000-03-04T23:00:00+03:00 normalizes to 2000-03-04T20:00:00Z Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).:::minutes->result->this->clone->d->new->DurationImpl->result->add->result->setTimezone->return
XMLGregorianCalendarImpl#internalCompare(XMLGregorianCalendar, XMLGregorianCalendar)::: Implements Step B from http://www.w3.org/TR/xmlschema-2/#dateTime-order :::result->if->P->getEon->Q->getEon->P->getYear->Q->getYear->compareField->if->return->else->P->getEonAndYear->Q->getEonAndYear->compareField->if->return->P->getMonth->Q->getMonth->compareField->if->return->P->getDay->Q->getDay->compareField->if->return->P->getHour->Q->getHour->compareField->if->return->P->getMinute->Q->getMinute->compareField->if->return->P->getSecond->Q->getSecond->compareField->if->return->P->getFractionalSecond->Q->getFractionalSecond->compareField->return
XMLGregorianCalendarImpl#compareField(int, int):::Implement Step B from http://www.w3.org/TR/xmlschema-2/#dateTime-order.:::if->return->else->if->return->else->return
XMLGregorianCalendarImpl#compareField(BigInteger, BigInteger)::: gregorian calendar impl compare field:::if->return->if->return->return->Pfield->compareTo
XMLGregorianCalendarImpl#compareField(BigDecimal, BigDecimal)::: gregorian calendar impl compare field:::if->return->if->if->return->Pfield->compareTo
XMLGregorianCalendarImpl#equals(Object):::Indicates whether parameter obj is "equal to" this one.:::if->return->if->return->return->compare
XMLGregorianCalendarImpl#hashCode():::Returns a hash code consistent with the definition of the equals method.:::timezone->getTimezone->if->gc->if->this->getTimezone->normalizeToTimezone->return->gc->getYear->gc->getMonth->gc->getDay->gc->getHour->gc->getMinute->gc->getSecond
XMLGregorianCalendarImpl#parse(String):::Constructs a new XMLGregorianCalendar object by parsing its lexical string representation as defined in XML Schema 1.0 Part 2, Section 3.2.[7-14].1, Lexical Representation.  The string representation may not have any leading and trailing whitespaces.  The parsing is done field by field so that the following holds for any lexically correct string x:  new XMLGregorianCalendar(x).toXMLFormat().equals(x)  Except for the noted lexical/canonical representation mismatches listed in  XML Schema 1.0 errata, Section 3.2.7.2:::return->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#toXMLFormat():::Return the lexical representation of this instance:::typekind->getXMLSchemaType->formatString->if->else->if->else->if->else->if->else->if->else->if->else->if->else->if->return->format
XMLGregorianCalendarImpl#getXMLSchemaType():::Return the name of the XML Schema date/time type that this instance maps to:::mask->switch->return->return->return->return->return->return->return->return->throw->this->getClass->getName->DatatypeMessageFormatter->formatMessage->new->IllegalStateException
XMLGregorianCalendarImpl#isValid():::Validate instance by getXMLSchemaType() constraints.:::if->if->if->if->maximumDayInMonthFor->return->else->if->getEonAndYear->maximumDayInMonthFor->return->else->if->maximumDayInMonthFor->return->if->fractionalSecond->compareTo->return->if->return->return
XMLGregorianCalendarImpl#add(Duration):::Add duration to this instance.<\p>  The computation is specified in XML Schema 1.0 Part 2, Appendix E, Adding durations to dateTimes>:::fieldUndefined->signum->duration->getSign->startMonth->getMonth->if->dMonths->duration->getField->sanitize->temp->BigInteger->valueOf->add->temp->subtract->mod->intValue->setMonth->carry->temp->subtract->new->BigDecimal->divide->toBigInteger->startYear->getEonAndYear->if->dYears->duration->getField->sanitize->endYear->startYear->add->add->setYear->startSeconds->if->getSecond->else->getSeconds->dSeconds->DurationImpl->duration->getField->sanitize->tempBD->startSeconds->add->fQuotient->tempBD->toBigInteger->new->BigDecimal->divide->toBigInteger->new->BigDecimal->endSeconds->tempBD->fQuotient->multiply->subtract->fQuotient->toBigInteger->endSeconds->intValue->setSecond->tempFracSeconds->endSeconds->BigInteger->getSecond->valueOf->new->BigDecimal->subtract->if->tempFracSeconds->compareTo->DECIMAL_ONE->add->setFractionalSecond->if->getSecond->setSecond->carry->subtract->else->getSecond->setSecond->else->setFractionalSecond->startMinutes->getMinute->if->dMinutes->duration->getField->sanitize->BigInteger->valueOf->add->add->temp->mod->intValue->setMinute->new->BigDecimal->divide->toBigInteger->startHours->getHour->if->dHours->duration->getField->sanitize->BigInteger->valueOf->add->add->temp->mod->intValue->setHour->new->BigDecimal->divide->toBigInteger->tempDays->startDay->getDay->if->dDays->duration->getField->sanitize->maxDayInMonth->getEonAndYear->getMonth->maximumDayInMonthFor->if->BigInteger->valueOf->else->if->else->BigInteger->valueOf->endDays->tempDays->add->add->monthCarry->intTemp->while->if->endDays->compareTo->mdimf->if->BigInteger->getEonAndYear->getMonth->maximumDayInMonthFor->valueOf->else->BigInteger->getEonAndYear->subtract->maximumDayInMonthFor->valueOf->endDays->add->else->if->endDays->BigInteger->getEonAndYear->getMonth->maximumDayInMonthFor->valueOf->compareTo->endDays->BigInteger->getEonAndYear->getMonth->maximumDayInMonthFor->valueOf->add->else->break->getMonth->endMonth->quotient->if->BigDecimal->valueOf->divide->intValue->else->setMonth->if->getEonAndYear->BigInteger->valueOf->add->setYear->endDays->intValue->setDay->for->i
XMLGregorianCalendarImpl#maximumDayInMonthFor(BigInteger, int)::: gregorian calendar impl maximum day in month for:::if->return->else->if->year->mod->equals->year->mod->equals->year->mod->equals->return->else->return
XMLGregorianCalendarImpl#maximumDayInMonthFor(int, int)::: gregorian calendar impl maximum day in month for:::if->return->else->if->return->else->return
XMLGregorianCalendarImpl#toGregorianCalendar():::Convert this to java.util.GregorianCalendar.  When this instance has an undefined field, this conversion relies on the java.util.GregorianCalendar default for its corresponding field:::result->DEFAULT_TIMEZONE_OFFSET->tz->getTimeZone->locale->getDefaultLocale->new->GregorianCalendar->result->clear->result->setGregorianChange->if->if->result->set->result->Math->abs->set->else->eonAndYear->getEonAndYear->result->eonAndYear->signum->set->result->eonAndYear->abs->intValue->set->if->result->set->if->result->set->if->result->set->if->result->set->if->result->set->if->result->getMillisecond->set->return
XMLGregorianCalendarImpl#getDefaultLocale()::: gregorian calendar impl get default locale:::lang->SecuritySupport->getSystemProperty->country->SecuritySupport->getSystemProperty->variant->SecuritySupport->getSystemProperty->locale->if->if->if->new->Locale->else->new->Locale->else->new->Locale->if->Locale->getDefault->return
XMLGregorianCalendarImpl#toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar):::Convert this along with provided parameters to java.util.GregorianCalendar instance.   Since XML Schema 1.0 date/time datetypes has no concept of timezone ids or daylight savings timezone ids, this conversion operation allows the user to explicitly specify one with timezone parameter.  To compute the return value's TimeZone field, <ul> <li>when parameter timeZone is non-null, it is the timezone field.</li> <li>else when this.getTimezone() != DatatypeConstants.FIELD_UNDEFINED, create a java.util.TimeZone with a custom timezone id using the this.getTimezone().</li> <li>else when defaults.getTimezone() != DatatypeConstants.FIELD_UNDEFINED, create a java.util.TimeZone with a custom timezone id using defaults.getTimezone().</li> <li>else use the GregorianCalendar default timezone value for the host is definedas specified by java.util.TimeZone.getDefault().</li>  To ensure consistency in conversion implementations, the new GregorianCalendar should be instantiated in following manner:::result->tz->if->defaultZoneoffset->if->defaults->getTimezone->getTimeZone->if->Locale->getDefault->new->GregorianCalendar->result->clear->result->setGregorianChange->if->if->result->set->result->Math->abs->set->else->eonAndYear->getEonAndYear->result->eonAndYear->signum->set->result->eonAndYear->abs->intValue->set->else->if->defaultYear->defaults->getYear->if->if->defaults->getEon->result->set->result->Math->abs->set->else->defaultEonAndYear->defaults->getEonAndYear->result->defaultEonAndYear->signum->set->result->defaultEonAndYear->abs->intValue->set->if->result->set->else->defaultMonth->defaults->getMonth->if->result->set->if->result->set->else->defaultDay->defaults->getDay->if->result->set->if->result->set->else->defaultHour->defaults->getHour->if->result->set->if->result->set->else->defaultMinute->defaults->getMinute->if->result->set->if->result->set->else->defaultSecond->defaults->getSecond->if->result->set->if->result->getMillisecond->set->else->defaultFractionalSecond->defaults->getFractionalSecond->if->result->defaults->getMillisecond->set->return
XMLGregorianCalendarImpl#getTimeZone(int):::Returns a java.util.TimeZone for this class.  If timezone field is defined for this instance, returns TimeZone initialized with custom timezone id of zoneoffset:::result->zoneoffset->getTimezone->if->if->TimeZone->getDefault->else->sign->if->hour->minutes->customTimezoneId->new->StringBuffer->customTimezoneId->append->customTimezoneId->append->customTimezoneId->append->if->if->customTimezoneId->append->customTimezoneId->append->TimeZone->customTimezoneId->toString->getTimeZone->return
XMLGregorianCalendarImpl#clone():::Creates and returns a copy of this object.:::return->getEonAndYear->new->XMLGregorianCalendarImpl
XMLGregorianCalendarImpl#clear():::Unset all fields to undefined.  Set all int fields to DatatypeConstants#FIELD_UNDEFINED and reference fields to null.:::
XMLGregorianCalendarImpl#setMillisecond(int)::: gregorian calendar impl set millisecond:::if->else->if->if->invalidFieldValue->BigDecimal->valueOf
XMLGregorianCalendarImpl#setFractionalSecond(BigDecimal)::: gregorian calendar impl set fractional second:::if->if->fractional->compareTo->fractional->compareTo->throw->DatatypeMessageFormatter->new->ObjectArr->fractional->toString->formatMessage->new->IllegalArgumentException
XMLGregorianCalendarImpl.Parser#parse():::Parse a formated String into an XMLGregorianCalendar.  If String is not formated as a legal XMLGregorianCalendar value, an IllegalArgumentException is thrown.:::while->fch->format->charAt->if->skip->continue->switch->format->charAt->parseYear->break->parseInt->setMonth->break->parseInt->setDay->break->parseInt->setHour->break->parseInt->setMinute->break->parseInt->setSecond->if->peek->parseBigDecimal->setFractionalSecond->break->vch->peek->if->setTimezone->else->if->h->parseInt->skip->m->parseInt->setTimezone->break->throw->new->InternalError->if->throw->new->IllegalArgumentException->testHour
XMLGregorianCalendarImpl.Parser#peek()::: parser peek:::if->return->return->value->charAt
XMLGregorianCalendarImpl.Parser#read()::: parser read:::if->throw->new->IllegalArgumentException->return->value->charAt
XMLGregorianCalendarImpl.Parser#skip(char)::: parser skip:::if->read->throw->new->IllegalArgumentException
XMLGregorianCalendarImpl.Parser#parseInt(int, int)::: parser parse int:::n->ch->vstart->while->peek->isDigit->if->throw->new->IllegalArgumentException->return
XMLGregorianCalendarImpl.Parser#parseYear()::: parser parse year:::vstart->sign->if->peek->while->peek->isDigit->digits->if->throw->new->IllegalArgumentException->yearString->value->substring->if->Integer->parseInt->setYear->else->new->BigInteger->setYear
XMLGregorianCalendarImpl.Parser#parseBigDecimal()::: parser parse big decimal:::vstart->if->peek->else->throw->new->IllegalArgumentException->while->peek->isDigit->return->value->substring->new->BigDecimal
XMLGregorianCalendarImpl#isDigit(char)::: gregorian calendar impl is digit:::return
XMLGregorianCalendarImpl#format(String):::Prints this object according to the format specification:::buf->new->StringBuilder->fidx->flen->format->length->while->fch->format->charAt->if->buf->append->continue->switch->format->charAt->if->absYear->if->buf->append->printNumber->else->getEonAndYear->printNumber->break->getMonth->printNumber->break->getDay->printNumber->break->getHour->printNumber->break->getMinute->printNumber->break->getSecond->printNumber->if->getFractionalSecond->frac->getFractionalSecond->toPlainString->buf->frac->frac->length->substring->append->break->offset->getTimezone->if->buf->append->else->if->if->buf->append->else->buf->append->printNumber->buf->append->printNumber->break->throw->new->InternalError->return->buf->toString
XMLGregorianCalendarImpl#printNumber(StringBuilder, int, int):::Prints an integer as a String.:::s->String->valueOf->for->i->s->length->out->append
XMLGregorianCalendarImpl#printNumber(StringBuilder, BigInteger, int):::Prints an BigInteger as a String.:::s->number->toString->for->i->s->length->out->append
XMLGregorianCalendarImpl#sanitize(Number, int):::Compute value*signum where value==null is treated as value==0.:::if->return->return->negate
XMLGregorianCalendarImpl#reset():::reset() is designed to allow the reuse of existing XMLGregorianCalendars thus saving resources associated  with the creation of new XMLGregorianCalendars.:::
XMLGregorianCalendarImpl#readObject(ObjectInputStream):::Deserialize Calendar.:::ois->defaultReadObject->save
