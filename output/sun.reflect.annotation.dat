AnnotatedTypeFactory#buildAnnotatedType(Type, LocationInfo, TypeAnnotation[], TypeAnnotation[], AnnotatedElement):::Create an AnnotatedType.:::if->return->if->isArray->return->new->AnnotatedArrayTypeImpl->if->return->new->AnnotatedTypeBaseImpl->else->if->return->new->AnnotatedTypeVariableImpl->else->if->return->new->AnnotatedParameterizedTypeImpl->else->if->return->new->AnnotatedWildcardTypeImpl->throw->new->AssertionError
AnnotatedTypeFactory#nestingForType(Type, LocationInfo)::: annotated type factory nesting for type:::if->isArray->return->if->clz->if->clz->getEnclosingClass->return->if->Modifier->clz->getModifiers->isStatic->return->clz->getEnclosingClass->nestingForType->return->clz->getEnclosingClass->addTo->pushInner->nestingForType->else->if->t->if->t->getOwnerType->return->return->t->getOwnerType->addTo->pushInner->nestingForType->return
AnnotatedTypeFactory#isArray(Type)::: annotated type factory is array:::if->c->if->c->isArray->return->else->if->return->return
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getAnnotations()::: annotated type base impl get annotations:::return->getDeclaredAnnotations
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getAnnotation(Class)::: annotated type base impl get annotation:::return->getDeclaredAnnotation
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getAnnotationsByType(Class)::: annotated type base impl get annotations by type:::return->getDeclaredAnnotationsByType
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getDeclaredAnnotations()::: annotated type base impl get declared annotations:::return->annotations->values->new->AnnotationArr->toArray
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getDeclaredAnnotation(Class)::: annotated type base impl get declared annotation:::return->annotations->get
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getDeclaredAnnotationsByType(Class)::: annotated type base impl get declared annotations by type:::return->AnnotationSupport->getDirectlyAndIndirectlyPresent
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getType()::: annotated type base impl get type:::return
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getAnnotatedOwnerType()::: annotated type base impl get annotated owner type:::if->throw->new->IllegalStateException->inner->owner->inner->getDeclaringClass->if->return->if->inner->isPrimitive->return->outerLoc->getLocation->popAllLocations->nestingForType->all->getTypeAnnotations->l->new->ArrayList<>->foreach->if->t->getLocationInfo->isSameLocationInfo->l->add->return->l->toArray->getDecl->buildAnnotatedType
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getLocation()::: annotated type base impl get location:::return
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getTypeAnnotations()::: annotated type base impl get type annotations:::return
AnnotatedTypeFactory.AnnotatedTypeBaseImpl#getDecl()::: annotated type base impl get decl:::return
AnnotatedTypeFactory.AnnotatedArrayTypeImpl#getAnnotatedGenericComponentType()::: annotated array type impl get annotated generic component type:::t->getComponentType->return->AnnotatedTypeFactory->getLocation->pushArray->nestingForType->getTypeAnnotations->getTypeAnnotations->getDecl->buildAnnotatedType
AnnotatedTypeFactory.AnnotatedArrayTypeImpl#getAnnotatedOwnerType()::: annotated array type impl get annotated owner type:::return
AnnotatedTypeFactory.AnnotatedArrayTypeImpl#getComponentType()::: annotated array type impl get component type:::t->getType->if->c->return->c->getComponentType->return->getGenericComponentType
AnnotatedTypeFactory.AnnotatedTypeVariableImpl#getAnnotatedBounds()::: annotated type variable impl get annotated bounds:::return->getTypeVariable->getAnnotatedBounds
AnnotatedTypeFactory.AnnotatedTypeVariableImpl#getAnnotatedOwnerType()::: annotated type variable impl get annotated owner type:::return
AnnotatedTypeFactory.AnnotatedTypeVariableImpl#getTypeVariable()::: annotated type variable impl get type variable:::return->getType
AnnotatedTypeFactory.AnnotatedParameterizedTypeImpl#getAnnotatedActualTypeArguments()::: annotated parameterized type impl get annotated actual type arguments:::arguments->getParameterizedType->getActualTypeArguments->res->new->AnnotatedTypeArr->Arrays->fill->initialCapacity->getTypeAnnotations->for->i->return
AnnotatedTypeFactory.AnnotatedParameterizedTypeImpl#getAnnotatedOwnerType()::: annotated parameterized type impl get annotated owner type:::owner->getParameterizedType->getOwnerType->if->return->outerLoc->getLocation->popAllLocations->nestingForType->all->getTypeAnnotations->l->new->ArrayList<>->foreach->if->t->getLocationInfo->isSameLocationInfo->l->add->return->l->toArray->getDecl->buildAnnotatedType
AnnotatedTypeFactory.AnnotatedParameterizedTypeImpl#getParameterizedType()::: annotated parameterized type impl get parameterized type:::return->getType
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#getAnnotatedUpperBounds()::: annotated wildcard type impl get annotated upper bounds:::if->hasUpperBounds->return->new->AnnotatedTypeArr->buildAnnotatedType->return->getWildcardType->getUpperBounds->getAnnotatedBounds
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#getAnnotatedLowerBounds()::: annotated wildcard type impl get annotated lower bounds:::if->return->new->AnnotatedTypeArr->return->getWildcardType->getLowerBounds->getAnnotatedBounds
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#getAnnotatedOwnerType()::: annotated wildcard type impl get annotated owner type:::return
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#getAnnotatedBounds(Type[])::: annotated wildcard type impl get annotated bounds:::res->new->AnnotatedTypeArr->Arrays->fill->initialCapacity->getTypeAnnotations->for->i->return
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#getWildcardType()::: annotated wildcard type impl get wildcard type:::return->getType
AnnotatedTypeFactory.AnnotatedWildcardTypeImpl#hasUpperBounds()::: annotated wildcard type impl has upper bounds:::return
AnnotationInvocationHandler#invoke(Object, Method, Object[])::: annotation invocation handler invoke:::member->method->getName->parameterCount->method->getParameterCount->if->method->getParameterTypes->return->equalsImpl->if->throw->new->AssertionError->if->return->toStringImpl->else->if->return->hashCodeImpl->else->if->return->result->memberValues->get->if->throw->new->IncompleteAnnotationException->if->throw->generateException->if->result->getClass->isArray->Array->getLength->cloneArray->return
AnnotationInvocationHandler#cloneArray(Object):::This method, which clones its array argument, would not be necessary if Cloneable had a public clone method.:::type->array->getClass->if->byteArray->return->byteArray->clone->if->charArray->return->charArray->clone->if->doubleArray->return->doubleArray->clone->if->floatArray->return->floatArray->clone->if->intArray->return->intArray->clone->if->longArray->return->longArray->clone->if->shortArray->return->shortArray->clone->if->booleanArray->return->booleanArray->clone->objectArray->return->objectArray->clone
AnnotationInvocationHandler#toStringImpl():::Implementation of dynamicProxy.toString():::result->new->StringBuilder->result->append->result->type->getName->append->result->append->firstMember->foreach->memberValues->entrySet->if->else->result->append->result->e->getKey->append->result->append->result->e->getValue->memberValueToString->append->result->append->return->result->toString
AnnotationInvocationHandler#memberValueToString(Object):::Translates a member value (in "dynamic proxy return form") into a string.:::type->value->getClass->if->type->isArray->if->return->toSourceString->else->if->return->toSourceString->if->return->toSourceString->else->if->return->toSourceString->else->if->return->toSourceString->else->if->return->toSourceString->else->return->value->toString->else->stringStream->if->convert->else->if->convert->else->if->DoubleStream->of->AnnotationInvocationHandler->toSourceString->mapToObj->else->if->convert->else->if->IntStream->of->String->valueOf->mapToObj->else->if->LongStream->of->AnnotationInvocationHandler->toSourceString->mapToObj->else->if->convert->else->if->convert->else->if->Arrays->stream->AnnotationInvocationHandler->toSourceString->map->else->if->Arrays->stream->AnnotationInvocationHandler->toSourceString->map->else->Arrays->stream->Objects->toString->map->return->stringStreamToString
AnnotationInvocationHandler#toSourceString(Class):::Translates a Class value to a form suitable for use in the string representation of an annotation.:::finalComponent->arrayBackets->new->StringBuilder->while->finalComponent->isArray->finalComponent->getComponentType->arrayBackets->append->return->finalComponent->getName->arrayBackets->toString
AnnotationInvocationHandler#toSourceString(float)::: annotation invocation handler to source string:::if->Float->isFinite->return->Float->toString->else->if->Float->isInfinite->return->else->return
AnnotationInvocationHandler#toSourceString(double)::: annotation invocation handler to source string:::if->Double->isFinite->return->Double->toString->else->if->Double->isInfinite->return->else->return
AnnotationInvocationHandler#toSourceString(char)::: annotation invocation handler to source string:::sb->new->StringBuilder->sb->append->if->sb->append->else->sb->append->return->sb->append->toString
AnnotationInvocationHandler#toSourceString(long)::: annotation invocation handler to source string:::str->String->valueOf->return
AnnotationInvocationHandler#toSourceString(String):::Return a string suitable for use in the string representation of an annotation.:::sb->new->StringBuilder->sb->append->sb->s->replace->append->sb->append->return->sb->toString
AnnotationInvocationHandler#convert(byte[])::: annotation invocation handler convert:::list->new->ArrayList<>->foreach->list->Byte->toString->add->return->list->stream
AnnotationInvocationHandler#convert(char[])::: annotation invocation handler convert:::list->new->ArrayList<>->foreach->list->toSourceString->add->return->list->stream
AnnotationInvocationHandler#convert(float[])::: annotation invocation handler convert:::list->new->ArrayList<>->foreach->list->toSourceString->add->return->list->stream
AnnotationInvocationHandler#convert(short[])::: annotation invocation handler convert:::list->new->ArrayList<>->foreach->list->Short->toString->add->return->list->stream
AnnotationInvocationHandler#convert(boolean[])::: annotation invocation handler convert:::list->new->ArrayList<>->foreach->list->Boolean->toString->add->return->list->stream
AnnotationInvocationHandler#stringStreamToString(Stream)::: annotation invocation handler string stream to string:::return->stream->Collectors->joining->collect
AnnotationInvocationHandler#equalsImpl(Object, Object):::Implementation of dynamicProxy.equals(Object o):::if->return->if->type->isInstance->return->foreach->getMemberMethods->member->memberMethod->getName->ourValue->memberValues->get->hisValue->hisHandler->asOneOfUs->if->get->else->try->memberMethod->invoke->catch->return->throw->new->AssertionError->finally->if->memberValueEquals->return->return
AnnotationInvocationHandler#asOneOfUs(Object):::Returns an object's invocation handler if that object is a dynamic proxy with a handler of type AnnotationInvocationHandler:::if->Proxy->o->getClass->isProxyClass->handler->Proxy->getInvocationHandler->if->return->return
AnnotationInvocationHandler#memberValueEquals(Object, Object):::Returns true iff the two member values in "dynamic proxy return form" are equal using the appropriate equality function depending on the member type:::type->v1->getClass->if->type->isArray->return->v1->equals->if->return->Arrays->equals->if->v2->getClass->return->if->return->Arrays->equals->if->return->Arrays->equals->if->return->Arrays->equals->if->return->Arrays->equals->if->return->Arrays->equals->if->return->Arrays->equals->if->return->Arrays->equals->return->Arrays->equals
AnnotationInvocationHandler#getMemberMethods():::Returns the member methods for our annotation type:::value->if->computeMemberMethods->return
AnnotationInvocationHandler#computeMemberMethods()::: annotation invocation handler compute member methods:::return->AccessController->new->PrivilegedAction<Method[]>->doPrivileged
AnnotationInvocationHandler#validateAnnotationMethods(Method[]):::Validates that a method is structurally appropriate for an annotation type:::valid->foreach->if->method->getModifiers->method->isDefault->method->getParameterCount->method->getExceptionTypes->break->returnType->method->getReturnType->if->returnType->isArray->returnType->getComponentType->if->returnType->isArray->break->if->returnType->isPrimitive->returnType->isEnum->returnType->isAnnotation->break->methodName->method->getName->if->methodName->equals->methodName->equals->methodName->equals->break->if->return->else->throw->new->AnnotationFormatError
AnnotationInvocationHandler#hashCodeImpl():::Implementation of dynamicProxy.hashCode():::result->foreach->memberValues->entrySet->e->getKey->hashCode->e->getValue->memberValueHashCode->return
AnnotationInvocationHandler#memberValueHashCode(Object):::Computes hashCode of a member value (in "dynamic proxy return form"):::type->value->getClass->if->type->isArray->return->value->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->return->Arrays->hashCode
AnnotationInvocationHandler#readObject(java.io.ObjectInputStream)::: annotation invocation handler read object:::fields->s->readFields->t->fields->get->streamVals->fields->get->annotationType->try->AnnotationType->getInstance->catch->throw->new->java.io.InvalidObjectException->finally->memberTypes->annotationType->memberTypes->mv->new->LinkedHashMap<>->foreach->streamVals->entrySet->name->memberValue->getKey->value->memberType->memberTypes->get->if->memberValue->getValue->if->memberType->isInstance->value->getClass->new->AnnotationTypeMismatchExceptionProxy->annotationType->members->get->setMember->mv->put->UnsafeAccessor->setType->UnsafeAccessor->setMemberValues
AnnotationInvocationHandler.UnsafeAccessor#setType(AnnotationInvocationHandler, Class)::: unsafe accessor set type:::unsafe->putObject
AnnotationInvocationHandler.UnsafeAccessor#setMemberValues(AnnotationInvocationHandler, Map)::: unsafe accessor set member values:::unsafe->putObject
AnnotationParser#parseAnnotations(byte[], ConstantPool, Class):::Parses the annotations described by the specified byte array:::if->return->Collections->emptyMap->try->return->parseAnnotations2->catch->throw->new->AnnotationFormatError->throw->new->AnnotationFormatError->finally
AnnotationParser#parseSelectAnnotations(byte[], ConstantPool, Class, Class...):::Like #parseAnnotations(byte[], sun.reflect.ConstantPool, Class) with an additional parameter selectAnnotationClasses which selects the annotation types to parse (other than selected are quickly skipped). This method is only used to parse select meta annotations in the construction phase of AnnotationType instances to prevent infinite recursion.:::if->return->Collections->emptyMap->try->return->parseAnnotations2->catch->throw->new->AnnotationFormatError->throw->new->AnnotationFormatError->finally
AnnotationParser#parseAnnotations2(byte[], ConstantPool, Class, Class[])::: annotation parser parse annotations2:::result->new->LinkedHashMap<Class<? extends Annotation>,Annotation>->buf->ByteBuffer->wrap->numAnnotations->buf->getShort->for->i->return
AnnotationParser#parseParameterAnnotations(byte[], ConstantPool, Class):::Parses the parameter annotations described by the specified byte array:::try->return->parseParameterAnnotations2->catch->throw->new->AnnotationFormatError->throw->new->AnnotationFormatError->finally
AnnotationParser#parseParameterAnnotations2(byte[], ConstantPool, Class)::: annotation parser parse parameter annotations2:::buf->ByteBuffer->wrap->numParameters->buf->get->result->new->AnnotationArrs->for->i->return
AnnotationParser#parseAnnotation(ByteBuffer, ConstantPool, Class, boolean):::Parses the annotation at the current position in the specified byte buffer, resolving constant references in the specified constant pool:::return->parseAnnotation2
AnnotationParser#parseAnnotation2(ByteBuffer, ConstantPool, Class, boolean, Class[])::: annotation parser parse annotation2:::typeIndex->buf->getShort->annotationClass->sig->try->try->constPool->getUTF8At->parseSig->catch->constPool->getClassAt->finally->catch->if->throw->new->TypeNotPresentException->skipAnnotation->return->if->throw->skipAnnotation->return->finally->if->contains->skipAnnotation->return->type->try->AnnotationType->getInstance->catch->skipAnnotation->return->finally->memberTypes->type->memberTypes->memberValues->type->memberDefaults->new->LinkedHashMap<String,Object>->numMembers->buf->getShort->for->i->return->annotationForMap
AnnotationParser#annotationForMap(Class, Map):::Returns an annotation of the given type backed by the given member -> value map.:::return->AccessController->new->PrivilegedAction<Annotation>->doPrivileged
AnnotationParser#parseMemberValue(Class, ByteBuffer, ConstantPool, Class):::Parses the annotation member value at the current position in the specified byte buffer, resolving constant references in the specified constant pool:::result->tag->buf->get->switch->return->parseEnumValue->parseClassValue->break->parseAnnotation->break->return->parseArray->parseConst->if->memberType->isInstance->result->getClass->new->AnnotationTypeMismatchExceptionProxy->return
AnnotationParser#parseConst(int, ByteBuffer, ConstantPool):::Parses the primitive or String annotation member value indicated by the specified tag byte at the current position in the specified byte buffer, resolving constant reference in the specified constant pool:::constIndex->buf->getShort->switch->return->Byte->constPool->getIntAt->valueOf->return->Character->constPool->getIntAt->valueOf->return->Double->constPool->getDoubleAt->valueOf->return->Float->constPool->getFloatAt->valueOf->return->Integer->constPool->getIntAt->valueOf->return->Long->constPool->getLongAt->valueOf->return->Short->constPool->getIntAt->valueOf->return->Boolean->constPool->getIntAt->valueOf->return->constPool->getUTF8At->throw->new->AnnotationFormatError
AnnotationParser#parseClassValue(ByteBuffer, ConstantPool, Class):::Parses the Class member value at the current position in the specified byte buffer, resolving constant references in the specified constant pool:::classIndex->buf->getShort->try->try->sig->constPool->getUTF8At->return->parseSig->catch->return->constPool->getClassAt->finally->catch->return->new->TypeNotPresentExceptionProxy->return->e->typeName->e->getCause->new->TypeNotPresentExceptionProxy->finally
AnnotationParser#parseSig(String, Class)::: annotation parser parse sig:::if->sig->equals->return->parser->SignatureParser->make->typeSig->parser->parseTypeSig->factory->CoreReflectionFactory->ClassScope->make->make->reify->Reifier->make->typeSig->accept->result->reify->getResult->return->toClass
AnnotationParser#toClass(Type)::: annotation parser to class:::if->return->Array->getGenericComponentType->toClass->newInstance->getClass->return
AnnotationParser#parseEnumValue(Class, ByteBuffer, ConstantPool, Class):::Parses the enum constant member value at the current position in the specified byte buffer, resolving constant references in the specified constant pool:::typeNameIndex->buf->getShort->typeName->constPool->getUTF8At->constNameIndex->buf->getShort->constName->constPool->getUTF8At->if->typeName->endsWith->if->enumType->getName->equals->return->new->AnnotationTypeMismatchExceptionProxy->else->if->parseSig->return->new->AnnotationTypeMismatchExceptionProxy->try->return->Enum->valueOf->catch->return->new->EnumConstantNotPresentExceptionProxy->finally
AnnotationParser#parseArray(Class, ByteBuffer, ConstantPool, Class):::Parses the array value at the current position in the specified byte buffer, resolving constant references in the specified constant pool:::length->buf->getShort->componentType->arrayType->getComponentType->if->return->parseByteArray->else->if->return->parseCharArray->else->if->return->parseDoubleArray->else->if->return->parseFloatArray->else->if->return->parseIntArray->else->if->return->parseLongArray->else->if->return->parseShortArray->else->if->return->parseBooleanArray->else->if->return->parseStringArray->else->if->return->parseClassArray->else->if->componentType->isEnum->return->parseEnumArray->else->return->parseAnnotationArray
AnnotationParser#parseByteArray(int, ByteBuffer, ConstantPool)::: annotation parser parse byte array:::result->new->byteArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseCharArray(int, ByteBuffer, ConstantPool)::: annotation parser parse char array:::result->new->charArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseDoubleArray(int, ByteBuffer, ConstantPool)::: annotation parser parse double array:::result->new->doubleArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseFloatArray(int, ByteBuffer, ConstantPool)::: annotation parser parse float array:::result->new->floatArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseIntArray(int, ByteBuffer, ConstantPool)::: annotation parser parse int array:::result->new->intArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseLongArray(int, ByteBuffer, ConstantPool)::: annotation parser parse long array:::result->new->longArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseShortArray(int, ByteBuffer, ConstantPool)::: annotation parser parse short array:::result->new->shortArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseBooleanArray(int, ByteBuffer, ConstantPool)::: annotation parser parse boolean array:::result->new->booleanArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseStringArray(int, ByteBuffer, ConstantPool)::: annotation parser parse string array:::result->new->StringArr->typeMismatch->tag->for->i->return->exceptionProxy
AnnotationParser#parseClassArray(int, ByteBuffer, ConstantPool, Class)::: annotation parser parse class array:::return->new->Class<?>Arr->parseClassValue->parseArrayElements
AnnotationParser#parseEnumArray(int, Class>, ByteBuffer, ConstantPool, Class)::: annotation parser parse enum array:::return->Array->newInstance->parseEnumValue->parseArrayElements
AnnotationParser#parseAnnotationArray(int, Class, ByteBuffer, ConstantPool, Class)::: annotation parser parse annotation array:::return->Array->newInstance->parseAnnotation->parseArrayElements
AnnotationParser#parseArrayElements(Object[], ByteBuffer, int, Supplier)::: annotation parser parse array elements:::exceptionProxy->for->i->return
AnnotationParser#exceptionProxy(int):::Returns an appropriate exception proxy for a mismatching array annotation where the erroneous array has the specified tag.:::return->new->AnnotationTypeMismatchExceptionProxy
AnnotationParser#skipAnnotation(ByteBuffer, boolean):::Skips the annotation at the current position in the specified byte buffer:::if->buf->getShort->numMembers->buf->getShort->for->i
AnnotationParser#skipMemberValue(ByteBuffer):::Skips the annotation member value at the current position in the specified byte buffer:::tag->buf->get->skipMemberValue
AnnotationParser#skipMemberValue(int, ByteBuffer):::Skips the annotation member value at the current position in the specified byte buffer:::switch->buf->getInt->break->skipAnnotation->break->skipArray->break->buf->getShort
AnnotationParser#skipArray(ByteBuffer):::Skips the array value at the current position in the specified byte buffer:::length->buf->getShort->for->i
AnnotationParser#contains(Object[], Object):::Searches for given element in given array by identity:::foreach->if->return->return
AnnotationParser#toArray(Map, Annotation>)::: annotation parser to array:::return->annotations->values->toArray
AnnotationParser#getEmptyAnnotationArray()::: annotation parser get empty annotation array:::return
AnnotationSupport#getDirectlyAndIndirectlyPresent(Map, Annotation>, Class):::Finds and returns all annotations in annotations matching the given annoClass:::result->new->ArrayList<>->direct->annotations->get->if->result->add->indirect->getIndirectlyPresent->if->indirectFirst->containerBeforeContainee->result->Arrays->asList->addAll->arr->Array->result->size->newInstance->return->result->toArray
AnnotationSupport#getIndirectlyPresent(Map, Annotation>, Class):::Finds and returns all annotations matching the given annoClass indirectly present in annotations.:::repeatable->annoClass->getDeclaredAnnotation->if->return->containerClass->repeatable->value->container->annotations->get->if->return->valueArray->getValueArray->checkTypes->return
AnnotationSupport#containerBeforeContainee(Map, Annotation>, Class):::Figures out if container class comes before containee class among the keys of the given map.:::containerClass->annoClass->getDeclaredAnnotation->value->foreach->annotations->keySet->if->return->if->return->return
AnnotationSupport#getAssociatedAnnotations(Map, Annotation>, Class, Class):::Finds and returns all associated annotations matching the given class:::Objects->requireNonNull->result->getDirectlyAndIndirectlyPresent->if->AnnotationType->getInstance->isInherited->superDecl->decl->getSuperclass->while->LANG_ACCESS->getDeclaredAnnotationMap->getDirectlyAndIndirectlyPresent->superDecl->getSuperclass->return
AnnotationSupport#getValueArray(Annotation)::: annotation support get value array:::try->containerClass->container->annotationType->annoType->AnnotationType->getInstance->if->throw->invalidContainerException->m->annoType->members->get->if->throw->invalidContainerException->if->Proxy->container->getClass->isProxyClass->handler->Proxy->getInvocationHandler->try->values->handler->invoke->return->catch->throw->invalidContainerException->finally->else->iface->m->getDeclaringClass->if->iface->isAnnotation->throw->new->UnsupportedOperationException->if->Modifier->m->getModifiers->isPublic->throw->new->UnsupportedOperationException->toInvoke->if->Modifier->iface->getModifiers->isPublic->if->System->getSecurityManager->AccessController->new->PrivilegedAction<Method>->doPrivileged->else->ReflectionFactory->getReflectionFactory->leafCopyMethod->toInvoke->setAccessible->else->values->toInvoke->invoke->return->catch->throw->invalidContainerException->finally
AnnotationSupport#invalidContainerException(Annotation, Throwable)::: annotation support invalid container exception:::return->new->AnnotationFormatError
AnnotationSupport#checkTypes(A[], Annotation, Class)::: annotation support check types:::foreach->if->annoClass->isInstance->throw->String->format->new->AnnotationFormatError
AnnotationType#getInstance(Class):::Returns an AnnotationType instance for the specified annotation type.:::jla->SharedSecrets->getJavaLangAccess->result->jla->getAnnotationType->if->new->AnnotationType->if->jla->casAnnotationType->jla->getAnnotationType->return
AnnotationType#invocationHandlerReturnType(Class):::Returns the type that must be returned by the invocation handler of a dynamic proxy in order to have the dynamic proxy return the specified type (which is assumed to be a legal member type for an annotation).:::if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->return
AnnotationType#memberTypes():::Returns member types for this annotation type (member name -> type mapping).:::return
AnnotationType#members():::Returns members of this annotation type (member name -> associated Method object mapping).:::return
AnnotationType#memberDefaults():::Returns the default values for this annotation type (Member name -> default value mapping).:::return
AnnotationType#retention():::Returns the retention policy for this annotation type.:::return
AnnotationType#isInherited():::Returns true if this annotation type is inherited.:::return
AnnotationType#toString():::For debugging.:::return
AnnotationTypeMismatchExceptionProxy#setMember(Method)::: annotation type mismatch exception proxy set member:::return
AnnotationTypeMismatchExceptionProxy#generateException()::: annotation type mismatch exception proxy generate exception:::return->new->AnnotationTypeMismatchException
AnnotationTypeMismatchExceptionProxy#toString()::: annotation type mismatch exception proxy to string:::return
EnumConstantNotPresentExceptionProxy#generateException()::: enum constant not present exception proxy generate exception:::return->new->EnumConstantNotPresentException
EnumConstantNotPresentExceptionProxy#toString()::: enum constant not present exception proxy to string:::return
ExceptionProxy#generateException()::: exception proxy generate exception:::
TypeAnnotation#getTargetInfo()::: type annotation get target info:::return
TypeAnnotation#getAnnotation()::: type annotation get annotation:::return
TypeAnnotation#getBaseDeclaration()::: type annotation get base declaration:::return
TypeAnnotation#getLocationInfo()::: type annotation get location info:::return
TypeAnnotation#filter(TypeAnnotation[], TypeAnnotationTarget)::: type annotation filter:::typeAnnos->new->ArrayList<>->foreach->if->t->getTargetInfo->getTarget->typeAnnos->add->typeAnnos->trimToSize->return
TypeAnnotation.TypeAnnotationTargetInfo#getTarget()::: type annotation target info get target:::return
TypeAnnotation.TypeAnnotationTargetInfo#getCount()::: type annotation target info get count:::return
TypeAnnotation.TypeAnnotationTargetInfo#getSecondaryIndex()::: type annotation target info get secondary index:::return
TypeAnnotation.TypeAnnotationTargetInfo#toString()::: type annotation target info to string:::return
TypeAnnotation.LocationInfo#parseLocationInfo(ByteBuffer)::: location info parse location info:::depth->buf->get->if->return->locations->new->LocationArr->for->i->return->new->LocationInfo
TypeAnnotation.LocationInfo#pushArray()::: location info push array:::return->pushLocation
TypeAnnotation.LocationInfo#pushInner()::: location info push inner:::return->pushLocation
TypeAnnotation.LocationInfo#pushWildcard()::: location info push wildcard:::return->pushLocation
TypeAnnotation.LocationInfo#pushTypeArg(short)::: location info push type arg:::return->pushLocation
TypeAnnotation.LocationInfo#pushLocation(byte, short)::: location info push location:::newDepth->res->new->LocationArr->System->arraycopy->new->Location->return->new->LocationInfo
TypeAnnotation.LocationInfo#popAllLocations(byte):::Pop a series of locations matching tag:::l->newDepth->while->if->res->new->LocationArr->System->arraycopy->return->new->LocationInfo->else->return
TypeAnnotation.LocationInfo#filter(TypeAnnotation[])::: location info filter:::l->new->ArrayList<>->foreach->if->t->getLocationInfo->isSameLocationInfo->l->add->return->l->toArray
TypeAnnotation.LocationInfo#isSameLocationInfo(LocationInfo)::: location info is same location info:::if->return->for->i->return
TypeAnnotation.LocationInfo.Location#isSameLocation(Location)::: location is same location:::return
TypeAnnotation#toString()::: type annotation to string:::return->annotation->toString->targetInfo->toString->baseDeclaration->toString
TypeAnnotationParser#buildAnnotatedType(byte[], ConstantPool, AnnotatedElement, Class, Type, TypeAnnotationTarget):::Build an AnnotatedType from the parameters supplied:::tas->parseTypeAnnotations->l->new->ArrayList<>->foreach->ti->t->getTargetInfo->if->ti->getTarget->l->add->typeAnnotations->l->toArray->return->AnnotatedTypeFactory->AnnotatedTypeFactory->nestingForType->buildAnnotatedType
TypeAnnotationParser#buildAnnotatedTypes(byte[], ConstantPool, AnnotatedElement, Class, Type[], TypeAnnotationTarget):::Build an array of AnnotatedTypes from the parameters supplied:::size->result->new->AnnotatedTypeArr->Arrays->fill->l->new->ArrayListArr->tas->parseTypeAnnotations->foreach->ti->t->getTargetInfo->if->ti->getTarget->pos->ti->getCount->if->tmp->new->ArrayList<>->tmp->tmp->add->offset->if->ctor->declaringClass->ctor->getDeclaringClass->if->declaringClass->isEnum->declaringClass->isMemberClass->declaringClass->getModifiers->for->i->return
TypeAnnotationParser#buildAnnotatedSuperclass(byte[], ConstantPool, Class):::Build an AnnotatedType for the class decl's supertype.:::supertype->decl->getGenericSuperclass->if->return->return->buildAnnotatedType
TypeAnnotationParser#buildAnnotatedInterfaces(byte[], ConstantPool, Class):::Build an array of AnnotatedTypes for the class decl's implemented interfaces.:::if->decl->isArray->decl->isPrimitive->return->return->decl->getGenericInterfaces->buildAnnotatedTypes
TypeAnnotationParser#parseTypeVariableAnnotations(D, int):::Parse regular annotations on a TypeVariable declared on genericDecl:::decl->predicate->if->else->if->else->throw->new->AssertionError->typeVarAnnos->TypeAnnotation->parseAllTypeAnnotations->filter->res->typeVarAnnos->size->new->ArrayList<>->foreach->if->t->getTargetInfo->getCount->res->t->getAnnotation->add->return->res->new->AnnotationArr->toArray
TypeAnnotationParser#parseAnnotatedBounds(Type[], D, int):::Build an array of AnnotatedTypes for the declaration decl's bounds.:::return->parseAnnotatedBounds
TypeAnnotationParser#parseAnnotatedBounds(Type[], D, int, LocationInfo)::: type annotation parser parse annotated bounds:::candidates->fetchBounds->if->startIndex->res->new->AnnotatedTypeArr->if->b0->if->else->c->if->c->isInterface->for->i->return->return->new->AnnotatedTypeArr
TypeAnnotationParser#fetchBounds(D)::: type annotation parser fetch bounds:::boundsDecl->target->if->else->return->TypeAnnotation->TypeAnnotationParser->parseAllTypeAnnotations->filter
TypeAnnotationParser#parseAllTypeAnnotations(AnnotatedElement)::: type annotation parser parse all type annotations:::container->rawBytes->javaLangAccess->SharedSecrets->getJavaLangAccess->if->javaLangAccess->getRawClassTypeAnnotations->else->if->getDeclaringClass->javaLangAccess->getRawExecutableTypeAnnotations->else->return->return->javaLangAccess->getConstantPool->parseTypeAnnotations
TypeAnnotationParser#parseTypeAnnotations(byte[], ConstantPool, AnnotatedElement, Class)::: type annotation parser parse type annotations:::if->return->buf->ByteBuffer->wrap->annotationCount->buf->getShort->typeAnnotations->new->ArrayList<>->for->i->return->typeAnnotations->toArray
TypeAnnotationParser#mapTypeAnnotations(TypeAnnotation[])::: type annotation parser map type annotations:::result->new->LinkedHashMap<>->foreach->a->t->getAnnotation->if->klass->a->annotationType->type->AnnotationType->getInstance->if->type->retention->result->put->throw->new->AnnotationFormatError->return
TypeAnnotationParser#parseTypeAnnotation(ByteBuffer, ConstantPool, AnnotatedElement, Class)::: type annotation parser parse type annotation:::try->ti->parseTargetInfo->locationInfo->LocationInfo->parseLocationInfo->a->AnnotationParser->parseAnnotation->if->return->return->new->TypeAnnotation->catch->throw->new->AnnotationFormatError->finally
TypeAnnotationParser#parseTargetInfo(ByteBuffer)::: type annotation parser parse target info:::posCode->buf->get->switch->index->buf->get->res->if->new->TypeAnnotationTargetInfo->else->new->TypeAnnotationTargetInfo->return->index->buf->getShort->if->return->new->TypeAnnotationTargetInfo->else->if->res->new->TypeAnnotationTargetInfo->return->break->return->parse2ByteTarget->return->parse2ByteTarget->return->new->TypeAnnotationTargetInfo->return->new->TypeAnnotationTargetInfo->return->new->TypeAnnotationTargetInfo->index->buf->get->return->new->TypeAnnotationTargetInfo->return->parseShortTarget->length->buf->getShort->for->i->return->index->buf->get->return->offset->buf->getShort->return->offset->buf->getShort->index->buf->get->return->break->throw->new->AnnotationFormatError
TypeAnnotationParser#parseShortTarget(TypeAnnotationTarget, ByteBuffer)::: type annotation parser parse short target:::index->buf->getShort->return->new->TypeAnnotationTargetInfo
TypeAnnotationParser#parse2ByteTarget(TypeAnnotationTarget, ByteBuffer)::: type annotation parser parse2 byte target:::count->buf->get->secondaryIndex->buf->get->return->new->TypeAnnotationTargetInfo
TypeNotPresentExceptionProxy#generateException()::: type not present exception proxy generate exception:::return->new->TypeNotPresentException
TypeNotPresentExceptionProxy#typeName()::: type not present exception proxy type name:::return
TypeNotPresentExceptionProxy#getCause()::: type not present exception proxy get cause:::return
TypeNotPresentExceptionProxy#toString()::: type not present exception proxy to string:::return
