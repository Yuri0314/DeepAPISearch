jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#getType()->int::: anchor node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#setChild(Node)->void::: anchor node set child
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#getChild()->Node::: anchor node get child
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#setTarget(Node)->void::: anchor node set target
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#getName()->String::: anchor node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#toString(int)->String::: anchor node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.AnchorNode#typeToString()->String::: anchor node type to string
jdk.nashorn.internal.runtime.regexp.joni.ast.AnyCharNode#getType()->int::: any char node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.AnyCharNode#getName()->String::: any char node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.AnyCharNode#toString(int)->String::: any char node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.BackRefNode#getType()->int::: back ref node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.BackRefNode#getName()->String::: back ref node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.BackRefNode#toString(int)->String::: back ref node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#clear()->void::: class node clear
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#getType()->int::: class node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#getName()->String::: class node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#equals(Object)->boolean::: class node equals
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#hashCode()->int::: class node hash code
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#toString(int)->String::: class node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#flagsToString()->String::: class node flags to string
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#isEmpty()->boolean::: class node is empty
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#addCodeRangeToBuf(int, int)->void::: class node add code range to buf
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#addCodeRange(ScanEnvironment, int, int)->void::: class node add code range
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#addAllMultiByteRange()->void::: class node add all multi byte range
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#clearNotFlag()->void::: class node clear not flag
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#and(CClassNode)->void::: class node and
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#or(CClassNode)->void::: class node or
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#addCTypeByRange(int, boolean, int, int[])->void::: class node add type by range
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#addCType(int, boolean, ScanEnvironment, IntHolder)->void::: class node add type
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#nextStateClass(CCStateArg, ScanEnvironment)->void::: class node next state class
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#nextStateValue(CCStateArg, ScanEnvironment)->void::: class node next state value
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#isCodeInCCLength(int)->boolean::: class node is code in length
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#isCodeInCC(int)->boolean::: class node is code in c
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#setNot()->void::: class node set not
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#clearNot()->void::: class node clear not
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#isNot()->boolean::: class node is not
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#setShare()->void::: class node set share
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#clearShare()->void::: class node clear share
jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode#isShare()->boolean::: class node is share
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#newAltNode(Node, ConsAltNode)->ConsAltNode::: cons alt node new alt node
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#newListNode(Node, ConsAltNode)->ConsAltNode::: cons alt node new list node
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#listAdd(ConsAltNode, Node)->ConsAltNode::: cons alt node list add
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#toListNode()->void::: cons alt node to list node
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#toAltNode()->void::: cons alt node to alt node
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#getType()->int::: cons alt node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#setChild(Node)->void::: cons alt node set child
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#getChild()->Node::: cons alt node get child
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#swap(Node)->void::: cons alt node swap
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#verifyTree(Set, WarnCallback)->void::: cons alt node verify tree
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#setCar(Node)->Node::: cons alt node set car
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#setCdr(ConsAltNode)->ConsAltNode::: cons alt node set cdr
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#getName()->String::: cons alt node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.ConsAltNode#toString(int)->String::: cons alt node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#getType()->int::: enclose node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#setChild(Node)->void::: enclose node set child
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#getChild()->Node::: enclose node get child
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#setTarget(Node)->void::: enclose node set target
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#getName()->String::: enclose node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#toString(int)->String::: enclose node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#typeToString()->String::: enclose node type to string
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#isMemory()->boolean::: enclose node is memory
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#isOption()->boolean::: enclose node is option
jdk.nashorn.internal.runtime.regexp.joni.ast.EncloseNode#isStopBacktrack()->boolean::: enclose node is stop backtrack
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#getType()->int::: node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#getType2Bit()->int::: node get type2 bit
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#setChild(Node)->void::: node set child
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#getChild()->Node::: node get child
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#swap(Node)->void::: node swap
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#verifyTree(Set, WarnCallback)->void::: node verify tree
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#getName()->String::: node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#toString(int)->String::: node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#getAddressName()->String::: node get address name
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#toString()->String::: node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#pad(Object, int)->String::: node pad
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#isInvalidQuantifier()->boolean::: node is invalid quantifier
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#isAllowedInLookBehind()->boolean::: node is allowed in look behind
jdk.nashorn.internal.runtime.regexp.joni.ast.Node#isSimple()->boolean::: node is simple
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#getType()->int::: quantifier node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#setChild(Node)->void::: quantifier node set child
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#getChild()->Node::: quantifier node get child
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#setTarget(Node)->void::: quantifier node set target
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#convertToString(int)->StringNode::: quantifier node convert to string
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#getName()->String::: quantifier node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#toString(int)->String::: quantifier node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#isAnyCharStar()->boolean::: quantifier node is any char star
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#popularNum()->int::: quantifier node popular num
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#set(QuantifierNode)->void::: quantifier node set
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#reduceNestedQuantifier(QuantifierNode)->void::: quantifier node reduce nested quantifier
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#setQuantifier(Node, boolean, ScanEnvironment, char[], int, int)->int::: quantifier node set quantifier
jdk.nashorn.internal.runtime.regexp.joni.ast.QuantifierNode#isRepeatInfinite(int)->boolean::: quantifier node is repeat infinite
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#toString(int)->String::: state node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#stateToString()->String::: state node state to string
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isMinFixed()->boolean::: state node is min fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setMinFixed()->void::: state node set min fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isMaxFixed()->boolean::: state node is max fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setMaxFixed()->void::: state node set max fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isCLenFixed()->boolean::: state node is len fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setCLenFixed()->void::: state node set len fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isMark1()->boolean::: state node is mark1
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setMark1()->void::: state node set mark1
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isMark2()->boolean::: state node is mark2
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setMark2()->void::: state node set mark2
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#clearMark2()->void::: state node clear mark2
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isMemBackrefed()->boolean::: state node is mem backrefed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setMemBackrefed()->void::: state node set mem backrefed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isStopBtSimpleRepeat()->boolean::: state node is stop bt simple repeat
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setStopBtSimpleRepeat()->void::: state node set stop bt simple repeat
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isRecursion()->boolean::: state node is recursion
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setRecursion()->void::: state node set recursion
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isCalled()->boolean::: state node is called
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setCalled()->void::: state node set called
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isAddrFixed()->boolean::: state node is addr fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setAddrFixed()->void::: state node set addr fixed
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isInRepeat()->boolean::: state node is in repeat
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setInRepeat()->void::: state node set in repeat
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isNestLevel()->boolean::: state node is nest level
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setNestLevel()->void::: state node set nest level
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#isByNumber()->boolean::: state node is by number
jdk.nashorn.internal.runtime.regexp.joni.ast.StateNode#setByNumber()->void::: state node set by number
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#createEmpty()->StringNode:::Create a new empty StringNode.
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#ensure(int)->void::: string node ensure
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#getType()->int::: string node get type
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#getName()->String::: string node get name
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#toString(int)->String::: string node to string
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#length()->int::: string node length
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#splitLastChar()->StringNode::: string node split last char
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#canBeSplit()->boolean::: string node can be split
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#set(char[], int, int)->void::: string node set
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#cat(char[], int, int)->void::: string node cat
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#cat(char)->void::: string node cat
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#catCode(int)->void::: string node cat code
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#clear()->void::: string node clear
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#setRaw()->void::: string node set raw
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#clearRaw()->void::: string node clear raw
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#isRaw()->boolean::: string node is raw
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#setAmbig()->void::: string node set ambig
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#clearAmbig()->void::: string node clear ambig
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#isAmbig()->boolean::: string node is ambig
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#setDontGetOptInfo()->void::: string node set dont get opt info
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#clearDontGetOptInfo()->void::: string node clear dont get opt info
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#isDontGetOptInfo()->boolean::: string node is dont get opt info
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#setShared()->void::: string node set shared
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#clearShared()->void::: string node clear shared
jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode#isShared()->boolean::: string node is shared
