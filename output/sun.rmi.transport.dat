Channel#newConnection():::Generates a new connection to the endpoint of the address space for which this is a channel.:::
Channel#getEndpoint():::Returns the endpoint of the address space for which this is a channel.:::
Channel#free(Connection, boolean):::Free the connection generated by this channel.:::
Connection#getInputStream():::Gets the input stream for this connection.:::
Connection#getOutputStream():::Gets the output stream for this connection:::
Connection#isReusable():::Return true if channel can be used for multiple operations.:::
Connection#close():::Close connection.:::
Connection#getChannel():::Returns the channel for this connection.:::
ConnectionInputStream#saveRef(LiveRef):::Save reference in order to send "dirty" call after all args/returns have been unmarshaled:::ep->ref->getEndpoint->refList->incomingRefTable->get->if->new->ArrayList<LiveRef>->incomingRefTable->put->refList->add
ConnectionInputStream#discardRefs():::Discard the saved incoming refs so there is nothing to register when registerRefs is called.:::incomingRefTable->clear
ConnectionInputStream#registerRefs():::Add references to DGC table (and possibly send dirty call):::if->incomingRefTable->isEmpty->foreach->incomingRefTable->entrySet->DGCClient->entry->getKey->entry->getValue->registerRefs
ConnectionInputStream#setAckNeeded():::Indicate that an ack is required to the distributed collector.:::
ConnectionInputStream#done(Connection):::Done with input stream for remote call:::if->conn->ch->reuse->log->try->c->getChannel->ch->newConnection->out->conn->getOutputStream->new->DataOutputStream->out->writeByte->if->new->UID->ackID->write->conn->releaseOutputStream->conn->getInputStream->available->conn->releaseInputStream->catch->finally->try->if->ch->free->catch->finally
ConnectionOutputStream#isResultStream():::Returns true if this output stream is used to marshal return results; otherwise returns false.:::return
ConnectionOutputStream#saveObject(Object):::Saves a reference to the specified object in this stream's DGCAckHandler.:::if->new->DGCAckHandler->dgcAckHandler->add
ConnectionOutputStream#getDGCAckHandler():::Returns this stream's DGCAckHandler, or null if it doesn't have one (saveObject was not invoked):::return
DGCAckHandler#add(Object):::Adds the specified reference to this DGCAckHandler.:::if->objList->add
DGCAckHandler#startTimer():::Starts the timer for this DGCAckHandler:::if->scheduler->new->Runnable->schedule
DGCAckHandler#release():::Releases the references held by this DGCAckHandler.:::if->task->cancel
DGCAckHandler#received(UID):::Causes the DGCAckHandler associated with the specified UID to release its references.:::h->idTable->remove->if->h->release
DGCClient#registerRefs(Endpoint, List):::Register the LiveRef instances in the supplied list to participate in distributed garbage collection:::epEntry->do->EndpointEntry->lookup->while->epEntry->registerRefs
DGCImpl#getDGCImpl():::Return the remote implementation of the DGC interface for this VM.:::return
DGCImpl#dirty(ObjID[], long, Lease):::The dirty call adds the VMID "vmid" to the set of clients that hold references to the object associated with the ObjID id:::vmid->lease->getVMID->duration->if->dgcLog->isLoggable->dgcLog->log->if->new->VMID->if->dgcLog->isLoggable->clientHost->try->RemoteServer->getClientHost->catch->finally->dgcLog->log->new->Lease->synchronized->info->leaseTable->get->if->leaseTable->new->LeaseInfo->put->if->scheduler->new->Runnable->scheduleWithFixedDelay->else->info->renew->foreach->if->dgcLog->isLoggable->dgcLog->log->ObjectTable->referenced->return
DGCImpl#clean(ObjID[], long, VMID, boolean):::The clean call removes the VMID from the set of clients that hold references to the object associated with the LiveRef ref:::foreach->if->dgcLog->isLoggable->dgcLog->log->ObjectTable->unreferenced
DGCImpl#registerTarget(VMID, Target):::Register interest in receiving a callback when this VMID becomes inaccessible.:::synchronized->info->leaseTable->get->if->target->vmidDead->else->add
DGCImpl#unregisterTarget(VMID, Target):::Remove notification request.:::synchronized->info->leaseTable->get->if->remove
Endpoint#getChannel():::Return a channel that generates connections to the remote endpoint.:::
Endpoint#exportObject(Target):::Export the object so that it can accept incoming calls at the endpoint.:::
Endpoint#getInboundTransport():::Returns the transport for incoming connections to this endpoint.:::
Endpoint#getOutboundTransport():::Returns transport for making connections to remote endpoints.:::
GC#maxObjectInspectionAge():::Returns the maximum object-inspection age, which is the number of real-time milliseconds that have elapsed since the least-recently-inspected heap object was last inspected by the garbage collector:::
GC.LatencyRequest#cancel():::Cancels this latency request.:::synchronized->if->throw->new->IllegalStateException->if->requests->remove->throw->new->InternalError->if->requests->isEmpty->adjustLatencyIfNeeded
GC#requestLatency(long):::Makes a new request for a garbage-collection latency of the given number of real-time milliseconds:::return->new->LatencyRequest
GC#currentLatencyTarget():::Returns the current smallest garbage-collection latency request, or zero if there are no active requests.:::t->return
LiveRef#clone():::Return a shallow copy of this ref.:::try->newRef->super->clone->return->catch->throw->e->toString->new->InternalError->finally
LiveRef#getPort():::Return the port number associated with this ref.:::return->getPort
LiveRef#getClientSocketFactory():::Return the client socket factory associated with this ref:::return->getClientSocketFactory
LiveRef#getServerSocketFactory():::Return the server socket factory associated with this ref.:::return->getServerSocketFactory
LiveRef#exportObject(Target):::Export the object to accept incoming calls.:::ep->exportObject
ObjectEndpoint#equals(Object):::Compares the specified object with this object endpoint for equality:::if->oe->return->id->equals->else->return
ObjectEndpoint#hashCode():::Returns the hash code value for this object endpoint.:::return->id->hashCode->transport->hashCode
ObjectEndpoint#toString():::Returns a string representation for this object endpoint.:::return->id->toString
ObjectTable#getTarget(ObjectEndpoint):::Returns the target associated with the object id.:::synchronized->return->objTable->get
ObjectTable#getTarget(Remote):::Returns the target associated with the remote object:::synchronized->return->implTable->new->WeakRef->get
ObjectTable#getStub(Remote):::Returns the stub for the remote object obj passed as a parameter:::target->getTarget->if->throw->new->NoSuchObjectException->else->return->target->getStub
ObjectTable#unexportObject(Remote, boolean):::Remove the remote object, obj, from the RMI runtime:::synchronized->target->getTarget->if->throw->new->NoSuchObjectException->else->if->target->unexport->removeTarget->return->else->return
ObjectTable#putTarget(Target):::Add target to object table:::oe->target->getObjectEndpoint->weakImpl->target->getWeakImpl->if->isLoggable->log->synchronized->if->target->getImpl->if->objTable->containsKey->throw->new->ExportException->else->if->implTable->containsKey->throw->new->ExportException->objTable->put->implTable->put->if->target->isPermanent->incrementKeepAliveCount
ObjectTable#referenced(ObjID, long, VMID):::Process client VM signalling reference for given ObjID: forward to corresponding Target entry:::synchronized->oe->Transport->currentTransport->new->ObjectEndpoint->target->objTable->get->if->target->referenced
ObjectTable#unreferenced(ObjID, long, VMID, boolean):::Process client VM dropping reference for given ObjID: forward to corresponding Target entry:::synchronized->oe->Transport->currentTransport->new->ObjectEndpoint->target->objTable->get->if->target->unreferenced
ObjectTable#incrementKeepAliveCount():::Increments the "keep-alive count":::synchronized->if->AccessController->new->Reaper->new->NewThreadAction->doPrivileged->reaper->start->if->GC->requestLatency
ObjectTable#decrementKeepAliveCount():::Decrements the "keep-alive count":::synchronized->if->if->throw->new->AssertionError->AccessController->new->PrivilegedAction<Void>->doPrivileged->gcLatencyRequest->cancel
StreamRemoteCall#getConnection():::Return the connection associated with this call.:::return
StreamRemoteCall#getOutputStream():::Return the output stream the stub/skeleton should put arguments/results into.:::return->getOutputStream
StreamRemoteCall#releaseOutputStream():::Release the outputStream  Currently, will not complain if the output stream is released more than once.:::try->if->try->out->flush->catch->finally->out->done->conn->releaseOutputStream->catch->finally
StreamRemoteCall#getInputStream():::Get the InputStream the stub/skeleton should get results/arguments from.:::if->log->conn->getInputStream->new->ConnectionInputStream->if->AccessController->in->setObjectInputFilter->return->doPrivileged->return
StreamRemoteCall#releaseInputStream():::Release the input stream, this would allow some transports to release the channel early.:::try->if->try->in->done->catch->finally->in->registerRefs->in->done->conn->releaseInputStream->catch->finally
StreamRemoteCall#discardPendingRefs():::Discard any post-processing of refs the InputStream.:::in->discardRefs
StreamRemoteCall#getResultStream(boolean):::Returns an output stream (may put out header information relating to the success of the call).:::if->throw->new->StreamCorruptedException->else->wr->conn->getOutputStream->new->DataOutputStream->wr->writeByte->getOutputStream->if->out->writeByte->else->out->writeByte->out->writeID->return
StreamRemoteCall#executeCall():::Do whatever it takes to execute the call.:::returnType->ackHandler->try->if->out->getDGCAckHandler->releaseOutputStream->rd->conn->getInputStream->new->DataInputStream->op->rd->readByte->if->if->isLoggable->log->throw->new->UnmarshalException->getInputStream->in->readByte->in->readID->catch->throw->throw->new->UnmarshalException->finally->if->ackHandler->release->switch->break->ex->try->in->readObject->catch->discardPendingRefs->throw->new->UnmarshalException->finally->if->exceptionReceivedFromServer->else->discardPendingRefs->throw->new->UnmarshalException->if->isLoggable->log->throw->new->UnmarshalException
StreamRemoteCall#exceptionReceivedFromServer(Exception):::Routine that causes the stack traces of remote exceptions to be filled in with the current stack trace on the client:::serverTrace->ex->getStackTrace->clientTrace->new->Throwable->getStackTrace->combinedTrace->new->StackTraceElementArr->System->arraycopy->System->arraycopy->ex->setStackTrace->if->isLoggable->ep->conn->getChannel->getEndpoint->ep->getHost->ep->getPort->log->throw
Target#getStub():::Get the stub (proxy) object for this target:::return
Target#getObjectEndpoint():::Returns the object endpoint for the target.:::return->new->ObjectEndpoint
Target#getWeakImpl():::Get the weak reference for the Impl of this target.:::return
Target#getDispatcher():::Returns the dispatcher for this remote object target.:::return
Target#getImpl():::Get the impl for this target:::return->weakImpl->get
Target#isPermanent():::Returns true if the target is permanent.:::return
Target#pinImpl():::Pin impl in target:::weakImpl->pin
Target#unpinImpl():::Unpin impl in target:::if->refSet->isEmpty->weakImpl->unpin
Target#setExportedTransport(Transport):::Enable the transport through which remote calls to this target are allowed to be set if it has not already been set.:::if
Target#referenced(long, VMID):::Add an endpoint to the remembered set:::entry->sequenceTable->get->if->sequenceTable->new->SequenceEntry->put->else->if->entry->update->else->return->if->refSet->contains->pinImpl->if->getImpl->return->if->isLoggable->log->refSet->addElement->DGCImpl->getDGCImpl->registerTarget
Target#unreferenced(long, VMID, boolean):::Remove endpoint from remembered set:::entry->sequenceTable->get->if->return->else->if->entry->retain->else->if->sequenceTable->remove->if->isLoggable->log->refSetRemove
Target#unexport(boolean):::Mark this target as not accepting new calls if any of the following conditions exist: a) the force parameter is true, b) the target's call count is zero, or c) the object is already not accepting calls:::if->unpinImpl->dgc->DGCImpl->getDGCImpl->enum_->refSet->elements->while->enum_->hasMoreElements->vmid->enum_->nextElement->dgc->unregisterTarget->return->else->return
Target#markRemoved():::Mark this target as having been removed from the object table.:::if->throw->new->AssertionError->if->ObjectTable->decrementKeepAliveCount->if->exportedTransport->targetUnexported
Target#incrementCallCount():::Increment call count.:::if->else->throw->new->NoSuchObjectException
Target#decrementCallCount():::Decrement call count.:::if->throw->new->Error->if->ObjectTable->decrementKeepAliveCount
Target#isEmpty():::Returns true if remembered set is empty; otherwise returns false:::return->refSet->isEmpty
Target#vmidDead(VMID):::This method is called if the address space associated with the vmid dies:::if->isLoggable->log->sequenceTable->remove->refSetRemove
Transport#getChannel(Endpoint):::Returns a Channel that generates connections to the endpoint ep:::
Transport#free(Endpoint):::Removes the Channel that generates connections to the endpoint ep.:::
Transport#exportObject(Target):::Export the object so that it can accept incoming calls.:::target->setExportedTransport->ObjectTable->putTarget
Transport#targetUnexported():::Invoked when an object that was exported on this transport has become unexported, either by being garbage collected or by being explicitly unexported.:::
Transport#currentTransport():::Returns the current transport if a call is being serviced, otherwise returns null.:::return->currentTransport->get
Transport#checkAcceptPermission(AccessControlContext):::Verify that the current access control context has permission to accept the connection being dispatched by the current thread:::
Transport#serviceCall(RemoteCall):::Service an incoming remote call:::try->impl->id->try->ObjID->call->getInputStream->read->catch->throw->new->MarshalException->finally->transport->id->equals->target->ObjectTable->new->ObjectEndpoint->getTarget->if->target->getImpl->throw->new->NoSuchObjectException->disp->target->getDispatcher->target->incrementCallCount->try->transportLog->log->acc->target->getAccessControlContext->ccl->target->getContextClassLoader->savedCcl->Thread->currentThread->getContextClassLoader->try->setContextClassLoader->currentTransport->set->try->new->java.security.PrivilegedExceptionAction<Void>->doPrivileged->catch->throw->pae->getException->finally->catch->finally->setContextClassLoader->currentTransport->set->catch->transportLog->log->return->finally->target->decrementCallCount->catch->if->isLoggable->clientHost->try->RemoteServer->getClientHost->catch->finally->message->log->try->out->call->getResultStream->UnicastServerRef->clearStackTraces->out->writeObject->call->releaseOutputStream->catch->transportLog->log->return->finally->finally->return
WeakRef#pin():::Pin the contained reference (make this a strong reference).:::if->get->if->isLoggable->log
WeakRef#unpin():::Unpin the contained reference (make this a weak reference).:::if->if->isLoggable->log
WeakRef#hashCode():::Always return the "identity" hash code of the original referent.:::return
WeakRef#equals(Object):::Return true if "obj" is this identical WeakRef object, or, if the contained reference has not been cleared, if "obj" is another WeakRef object with the identical non-null referent:::if->if->return->referent->get->return->get->else->return
