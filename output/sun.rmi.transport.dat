Channel#newConnection():::Generates a new connection to the endpoint of the address space for which this is a channel.:::
Channel#getEndpoint():::Returns the endpoint of the address space for which this is a channel.:::
Channel#free(Connection, boolean):::Free the connection generated by this channel.:::
Connection#getInputStream():::Gets the input stream for this connection.:::
Connection#releaseInputStream()::: connection release input stream:::
Connection#getOutputStream():::Gets the output stream for this connection:::
Connection#releaseOutputStream()::: connection release output stream:::
Connection#isReusable():::Return true if channel can be used for multiple operations.:::
Connection#close():::Close connection.:::
Connection#getChannel():::Returns the channel for this connection.:::
ConnectionInputStream#readID()::: connection input stream read d:::UID->read
ConnectionInputStream#saveRef(LiveRef):::Save reference in order to send "dirty" call after all args/returns have been unmarshaled:::ep->ref->getEndpoint->refList->incomingRefTable->get->if->new->ArrayList<LiveRef>->incomingRefTable->put->refList->add
ConnectionInputStream#discardRefs():::Discard the saved incoming refs so there is nothing to register when registerRefs is called.:::incomingRefTable->clear
ConnectionInputStream#registerRefs():::Add references to DGC table (and possibly send dirty call):::if->incomingRefTable->isEmpty->foreach->incomingRefTable->entrySet->DGCClient->entry->getKey->entry->getValue->registerRefs
ConnectionInputStream#setAckNeeded():::Indicate that an ack is required to the distributed collector.:::
ConnectionInputStream#done(Connection):::Done with input stream for remote call:::if->conn->ch->reuse->log->try->c->getChannel->ch->newConnection->out->conn->getOutputStream->new->DataOutputStream->out->writeByte->if->new->UID->ackID->write->conn->releaseOutputStream->conn->getInputStream->available->conn->releaseInputStream->catch->finally->try->if->ch->free->catch->finally
ConnectionOutputStream#writeID()::: connection output stream write d:::ackID->write
ConnectionOutputStream#isResultStream():::Returns true if this output stream is used to marshal return results; otherwise returns false.:::return
ConnectionOutputStream#saveObject(Object):::Saves a reference to the specified object in this stream's DGCAckHandler.:::if->new->DGCAckHandler->dgcAckHandler->add
ConnectionOutputStream#getDGCAckHandler():::Returns this stream's DGCAckHandler, or null if it doesn't have one (saveObject was not invoked):::return
ConnectionOutputStream#done()::: connection output stream done:::if->dgcAckHandler->startTimer
DGCAckHandler#add(Object):::Adds the specified reference to this DGCAckHandler.:::if->objList->add
DGCAckHandler#startTimer():::Starts the timer for this DGCAckHandler:::if->scheduler->new->Runnable->schedule
DGCAckHandler#release():::Releases the references held by this DGCAckHandler.:::if->task->cancel
DGCAckHandler#received(UID):::Causes the DGCAckHandler associated with the specified UID to release its references.:::h->idTable->remove->if->h->release
DGCClient#registerRefs(Endpoint, List):::Register the LiveRef instances in the supplied list to participate in distributed garbage collection:::epEntry->do->EndpointEntry->lookup->while->epEntry->registerRefs
DGCClient#getNextSequenceNum():::Get the next sequence number to be used for a dirty or clean operation from this VM:::return
DGCClient#computeRenewTime(long, long):::Given the length of a lease and the time that it was granted, compute the absolute time at which it should be renewed, giving room for reasonable computational and communication delays.:::return
DGCClient.EndpointEntry#lookup(Endpoint):::Look up the EndpointEntry for the given Endpoint:::synchronized->entry->endpointTable->get->if->new->EndpointEntry->endpointTable->put->if->GC->requestLatency->return
DGCClient.EndpointEntry#registerRefs(List):::Register the LiveRef instances in the supplied list to participate in distributed garbage collection:::refsToDirty->sequenceNum->synchronized->if->return->iter->refs->iterator->while->iter->hasNext->ref->iter->next->refEntry->refTable->get->if->refClone->ref->clone->new->RefEntry->refTable->put->if->new->HashSet<>->refsToDirty->add->refEntry->addInstanceToRefSet->if->return->refsToDirty->addAll->invalidRefs->clear->getNextSequenceNum->makeDirtyCall->return
DGCClient.EndpointEntry#removeRefEntry(RefEntry):::Remove the given RefEntry from the ref table:::refTable->refEntry->getRef->remove->invalidRefs->remove->if->refTable->isEmpty->synchronized->endpointTable->remove->transport->endpoint->getOutboundTransport->transport->free->if->endpointTable->isEmpty->gcLatencyRequest->cancel
DGCClient.EndpointEntry#makeDirtyCall(Set, long):::Make a DGC dirty call to this entry's endpoint, for the ObjIDs corresponding to the given set of refs and with the given sequence number:::ids->if->createObjIDArray->else->startTime->System->currentTimeMillis->try->lease->dgc->new->Lease->dirty->duration->lease->getValue->newRenewTime->computeRenewTime->newExpirationTime->synchronized->setRenewTime->catch->endTime->System->currentTimeMillis->synchronized->if->e->getCause->log->return->if->setRenewTime->else->n->if->Math->max->newRenewTime->if->setRenewTime->else->setRenewTime->if->invalidRefs->addAll->iter->refEntries->iterator->while->iter->hasNext->refEntry->iter->next->refEntry->markDirtyFailed->if->invalidRefs->refTable->values->addAll->finally
DGCClient.EndpointEntry#setRenewTime(long):::Set the absolute time at which the lease for this entry should be renewed:::if->if->AccessController->new->PrivilegedAction<Void>->doPrivileged->else
DGCClient.EndpointEntry.RenewCleanThread#run()::: renew clean thread run:::do->timeToWait->phantom->needRenewal->refsToDirty->sequenceNum->synchronized->timeUntilRenew->System->currentTimeMillis->Math->max->if->pendingCleans->isEmpty->Math->min->try->refQueue->remove->catch->finally->synchronized->Thread->interrupted->if->processPhantomRefs->currentTime->System->currentTimeMillis->if->if->invalidRefs->isEmpty->new->HashSet<>->getNextSequenceNum->needRenewal_->refsToDirty_->sequenceNum_->AccessController->if->makeDirtyCall->if->pendingCleans->isEmpty->makeCleanCalls->return->doPrivileged->while->pendingCleans->isEmpty
DGCClient.EndpointEntry#processPhantomRefs(RefEntry.PhantomLiveRef):::Process the notification of the given phantom reference and any others that are on this entry's reference queue:::strongCleans->normalCleans->do->refEntry->phantom->getRefEntry->refEntry->removeInstanceFromRefSet->if->refEntry->isRefSetEmpty->if->refEntry->hasDirtyFailed->if->new->HashSet<>->strongCleans->add->else->if->new->HashSet<>->normalCleans->add->removeRefEntry->while->refQueue->poll->if->pendingCleans->createObjIDArray->getNextSequenceNum->new->CleanRequest->add->if->pendingCleans->createObjIDArray->getNextSequenceNum->new->CleanRequest->add
DGCClient.EndpointEntry#makeCleanCalls():::Make all of the clean calls described by the clean requests in this entry's set of "pending cleans":::iter->pendingCleans->iterator->while->iter->hasNext->request->iter->next->try->dgc->clean->iter->remove->catch->if->iter->remove->finally
DGCClient.EndpointEntry#createObjIDArray(Set):::Create an array of ObjIDs (needed for the DGC remote calls) from the ids in the given set of refs.:::ids->refEntries->size->new->ObjIDArr->iter->refEntries->iterator->for->i->return
DGCClient.EndpointEntry.RefEntry#getRef():::Return the LiveRef value for this entry (not a registered instance).:::return
DGCClient.EndpointEntry.RefEntry#addInstanceToRefSet(LiveRef):::Add a LiveRef to the set of registered instances for this entry:::refSet->new->PhantomLiveRef->add
DGCClient.EndpointEntry.RefEntry#removeInstanceFromRefSet(PhantomLiveRef):::Remove a PhantomLiveRef from the set of registered instances:::refSet->remove
DGCClient.EndpointEntry.RefEntry#isRefSetEmpty():::Return true if there are no registered LiveRef instances for this entry still reachable in this VM:::return->refSet->size
DGCClient.EndpointEntry.RefEntry#markDirtyFailed():::Record that a dirty call that explicitly contained this entry's ref has failed:::
DGCClient.EndpointEntry.RefEntry#hasDirtyFailed():::Return true if a dirty call that explicitly contained this entry's ref has failed (and therefore a clean call for this ref needs to be marked "strong"):::return
DGCClient.EndpointEntry.RefEntry.PhantomLiveRef#getRefEntry()::: phantom live ref get ref entry:::return
DGCImpl#getDGCImpl():::Return the remote implementation of the DGC interface for this VM.:::return
DGCImpl#initDgcFilter():::Initialize the dgcFilter from the security properties or system property; if any:::filter->props->System->getProperty->if->Security->getProperty->if->createFilter->if->dgcLog->isLoggable->dgcLog->log->return
DGCImpl#dirty(ObjID[], long, Lease):::The dirty call adds the VMID "vmid" to the set of clients that hold references to the object associated with the ObjID id:::vmid->lease->getVMID->duration->if->dgcLog->isLoggable->dgcLog->log->if->new->VMID->if->dgcLog->isLoggable->clientHost->try->RemoteServer->getClientHost->catch->finally->dgcLog->log->new->Lease->synchronized->info->leaseTable->get->if->leaseTable->new->LeaseInfo->put->if->scheduler->new->Runnable->scheduleWithFixedDelay->else->info->renew->foreach->if->dgcLog->isLoggable->dgcLog->log->ObjectTable->referenced->return
DGCImpl#clean(ObjID[], long, VMID, boolean):::The clean call removes the VMID from the set of clients that hold references to the object associated with the LiveRef ref:::foreach->if->dgcLog->isLoggable->dgcLog->log->ObjectTable->unreferenced
DGCImpl#registerTarget(VMID, Target):::Register interest in receiving a callback when this VMID becomes inaccessible.:::synchronized->info->leaseTable->get->if->target->vmidDead->else->add
DGCImpl#unregisterTarget(VMID, Target):::Remove notification request.:::synchronized->info->leaseTable->get->if->remove
DGCImpl#checkLeases():::Check if leases have expired:::time->System->currentTimeMillis->toUnregister->new->ArrayList<>->synchronized->iter->leaseTable->values->iterator->while->iter->hasNext->info->iter->next->if->info->expired->toUnregister->add->iter->remove->if->leaseTable->isEmpty->checker->cancel->foreach->foreach->target->vmidDead
DGCImpl#checkInput(ObjectInputFilter.FilterInfo):::ObjectInputFilter to filter DGC input objects:::if->status->dgcFilter->checkInput->if->return->if->filterInfo->depth->return->clazz->filterInfo->serialClass->if->while->clazz->isArray->if->filterInfo->arrayLength->filterInfo->arrayLength->return->clazz->getComponentType->if->clazz->isPrimitive->return->return->return
DGCImpl.LeaseInfo#renew(long)::: lease info renew:::newExpiration->System->currentTimeMillis->if
DGCImpl.LeaseInfo#expired(long)::: lease info expired:::if->if->dgcLog->isLoggable->dgcLog->vmid->toString->log->return->else->return
DGCImpl_Skel#getOperations()::: impl_ skel get operations:::return->operations->clone
DGCImpl_Skel#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)::: impl_ skel dispatch:::if->throw->new->java.rmi.server.SkeletonMismatchException->server->call->switch->$param_arrayOf_ObjID_1->$param_long_2->$param_VMID_3->$param_boolean_4->try->in->call->getInputStream->in->readObject->in->readLong->in->readObject->in->readBoolean->catch->call->discardPendingRefs->throw->new->java.rmi.UnmarshalException->finally->call->releaseInputStream->server->clean->try->call->getResultStream->catch->throw->new->java.rmi.MarshalException->finally->break->$param_arrayOf_ObjID_1->$param_long_2->$param_Lease_3->try->in->call->getInputStream->in->readObject->in->readLong->in->readObject->catch->call->discardPendingRefs->throw->new->java.rmi.UnmarshalException->finally->call->releaseInputStream->$result->server->dirty->try->out->call->getResultStream->out->writeObject->catch->throw->new->java.rmi.MarshalException->finally->break->throw->new->java.rmi.UnmarshalException
DGCImpl_Stub#clean(java.rmi.server.ObjID[], long, java.rmi.dgc.VMID, boolean)::: impl_ stub clean:::try->call->ref->newCall->call->DGCImpl_Stub->leaseFilter->setObjectInputFilter->try->out->call->getOutputStream->out->writeObject->out->writeLong->out->writeObject->out->writeBoolean->catch->throw->new->java.rmi.MarshalException->finally->ref->invoke->ref->done->catch->throw->throw->throw->new->java.rmi.UnexpectedException->finally
DGCImpl_Stub#dirty(java.rmi.server.ObjID[], long, java.rmi.dgc.Lease)::: impl_ stub dirty:::try->call->ref->newCall->call->DGCImpl_Stub->leaseFilter->setObjectInputFilter->try->out->call->getOutputStream->out->writeObject->out->writeLong->out->writeObject->catch->throw->new->java.rmi.MarshalException->finally->ref->invoke->$result->connection->call->getConnection->try->in->call->getInputStream->in->readObject->catch->if->getChannel->free->call->discardPendingRefs->throw->new->java.rmi.UnmarshalException->finally->ref->done->return->catch->throw->throw->throw->new->java.rmi.UnexpectedException->finally
DGCImpl_Stub#leaseFilter(ObjectInputFilter.FilterInfo):::ObjectInputFilter to filter DGCClient return value (a Lease):::if->filterInfo->depth->return->clazz->filterInfo->serialClass->if->while->clazz->isArray->if->filterInfo->arrayLength->filterInfo->arrayLength->return->clazz->getComponentType->if->clazz->isPrimitive->return->return->isAssignableFrom->getModule->clazz->getModule->getModule->clazz->getModule->clazz->getName->equals->return
Endpoint#getChannel():::Return a channel that generates connections to the remote endpoint.:::
Endpoint#exportObject(Target):::Export the object so that it can accept incoming calls at the endpoint.:::
Endpoint#getInboundTransport():::Returns the transport for incoming connections to this endpoint.:::
Endpoint#getOutboundTransport():::Returns transport for making connections to remote endpoints.:::
GC#maxObjectInspectionAge():::Returns the maximum object-inspection age, which is the number of real-time milliseconds that have elapsed since the least-recently-inspected heap object was last inspected by the garbage collector:::
GC.Daemon#run()::: daemon run:::for
GC.Daemon#create()::: daemon create:::pa->new->PrivilegedAction<Void>->AccessController->doPrivileged
GC#setLatencyTarget(long)::: c set latency target:::if->Daemon->create->else->lock->notify
GC.LatencyRequest#adjustLatencyIfNeeded()::: latency request adjust latency if needed:::if->requests->isEmpty->if->setLatencyTarget->else->r->requests->first->if->setLatencyTarget
GC.LatencyRequest#cancel():::Cancels this latency request.:::synchronized->if->throw->new->IllegalStateException->if->requests->remove->throw->new->InternalError->if->requests->isEmpty->adjustLatencyIfNeeded
GC.LatencyRequest#compareTo(LatencyRequest)::: latency request compare to:::d->if->return
GC.LatencyRequest#toString()::: latency request to string:::return->getName
GC#requestLatency(long):::Makes a new request for a garbage-collection latency of the given number of real-time milliseconds:::return->new->LatencyRequest
GC#currentLatencyTarget():::Returns the current smallest garbage-collection latency request, or zero if there are no active requests.:::t->return
LiveRef#clone():::Return a shallow copy of this ref.:::try->newRef->super->clone->return->catch->throw->e->toString->new->InternalError->finally
LiveRef#getPort():::Return the port number associated with this ref.:::return->getPort
LiveRef#getClientSocketFactory():::Return the client socket factory associated with this ref:::return->getClientSocketFactory
LiveRef#getServerSocketFactory():::Return the server socket factory associated with this ref.:::return->getServerSocketFactory
LiveRef#exportObject(Target):::Export the object to accept incoming calls.:::ep->exportObject
LiveRef#getChannel()::: live ref get channel:::if->ep->getChannel->return
LiveRef#getObjID()::: live ref get obj d:::return
LiveRef#getEndpoint()::: live ref get endpoint:::return
LiveRef#toString()::: live ref to string:::type->if->else->return
LiveRef#hashCode()::: live ref hash code:::return->id->hashCode
LiveRef#equals(Object)::: live ref equals:::if->ref->return->ep->equals->id->equals->else->return
LiveRef#remoteEquals(Object)::: live ref remote equals:::if->ref->thisEp->refEp->thisClientFactory->thisEp->getClientSocketFactory->refClientFactory->refEp->getClientSocketFactory->if->thisEp->getPort->refEp->getPort->thisEp->getHost->refEp->getHost->equals->return->if->return->if->thisClientFactory->getClass->refClientFactory->getClass->thisClientFactory->equals->return->return->id->equals->else->return
LiveRef#write(ObjectOutput, boolean)::: live ref write:::isResultStream->if->stream->stream->isResultStream->if->oe->ep->getInboundTransport->new->ObjectEndpoint->target->ObjectTable->getTarget->if->impl->target->getImpl->if->stream->saveObject->else->stream->saveObject->if->write->else->writeHostPortFormat->id->write->out->writeBoolean
LiveRef#read(ObjectInput, boolean)::: live ref read:::ep->id->if->TCPEndpoint->read->else->TCPEndpoint->readHostPortFormat->ObjID->read->isResultStream->in->readBoolean->ref->new->LiveRef->if->stream->stream->saveRef->if->stream->setAckNeeded->else->DGCClient->Arrays->new->LiveRefArr->asList->registerRefs->return
ObjectEndpoint#equals(Object):::Compares the specified object with this object endpoint for equality:::if->oe->return->id->equals->else->return
ObjectEndpoint#hashCode():::Returns the hash code value for this object endpoint.:::return->id->hashCode->transport->hashCode
ObjectEndpoint#toString():::Returns a string representation for this object endpoint.:::return->id->toString
ObjectTable#getTarget(ObjectEndpoint):::Returns the target associated with the object id.:::synchronized->return->objTable->get
ObjectTable#getTarget(Remote):::Returns the target associated with the remote object:::synchronized->return->implTable->new->WeakRef->get
ObjectTable#getStub(Remote):::Returns the stub for the remote object obj passed as a parameter:::target->getTarget->if->throw->new->NoSuchObjectException->else->return->target->getStub
ObjectTable#unexportObject(Remote, boolean):::Remove the remote object, obj, from the RMI runtime:::synchronized->target->getTarget->if->throw->new->NoSuchObjectException->else->if->target->unexport->removeTarget->return->else->return
ObjectTable#putTarget(Target):::Add target to object table:::oe->target->getObjectEndpoint->weakImpl->target->getWeakImpl->if->isLoggable->log->synchronized->if->target->getImpl->if->objTable->containsKey->throw->new->ExportException->else->if->implTable->containsKey->throw->new->ExportException->objTable->put->implTable->put->if->target->isPermanent->incrementKeepAliveCount
ObjectTable#removeTarget(Target):::Remove target from object table:::oe->target->getObjectEndpoint->weakImpl->target->getWeakImpl->if->isLoggable->log->objTable->remove->implTable->remove->target->markRemoved
ObjectTable#referenced(ObjID, long, VMID):::Process client VM signalling reference for given ObjID: forward to corresponding Target entry:::synchronized->oe->Transport->currentTransport->new->ObjectEndpoint->target->objTable->get->if->target->referenced
ObjectTable#unreferenced(ObjID, long, VMID, boolean):::Process client VM dropping reference for given ObjID: forward to corresponding Target entry:::synchronized->oe->Transport->currentTransport->new->ObjectEndpoint->target->objTable->get->if->target->unreferenced
ObjectTable#incrementKeepAliveCount():::Increments the "keep-alive count":::synchronized->if->AccessController->new->Reaper->new->NewThreadAction->doPrivileged->reaper->start->if->GC->requestLatency
ObjectTable#decrementKeepAliveCount():::Decrements the "keep-alive count":::synchronized->if->if->throw->new->AssertionError->AccessController->new->PrivilegedAction<Void>->doPrivileged->gcLatencyRequest->cancel
ObjectTable.Reaper#run()::: reaper run:::try->do->weakImpl->reapQueue->remove->synchronized->target->implTable->get->if->if->target->isEmpty->throw->new->Error->else->if->target->isPermanent->throw->new->Error->removeTarget->while->Thread->interrupted->catch->finally
StreamRemoteCall#getConnection():::Return the connection associated with this call.:::return
StreamRemoteCall#getOutputStream():::Return the output stream the stub/skeleton should put arguments/results into.:::return->getOutputStream
StreamRemoteCall#getOutputStream(boolean)::: stream remote call get output stream:::if->log->new->ConnectionOutputStream->return
StreamRemoteCall#releaseOutputStream():::Release the outputStream  Currently, will not complain if the output stream is released more than once.:::try->if->try->out->flush->catch->finally->out->done->conn->releaseOutputStream->catch->finally
StreamRemoteCall#setObjectInputFilter(ObjectInputFilter)::: stream remote call set object input filter:::if->throw->new->IllegalStateException
StreamRemoteCall#getInputStream():::Get the InputStream the stub/skeleton should get results/arguments from.:::if->log->conn->getInputStream->new->ConnectionInputStream->if->AccessController->in->setObjectInputFilter->return->doPrivileged->return
StreamRemoteCall#releaseInputStream():::Release the input stream, this would allow some transports to release the channel early.:::try->if->try->in->done->catch->finally->in->registerRefs->in->done->conn->releaseInputStream->catch->finally
StreamRemoteCall#discardPendingRefs():::Discard any post-processing of refs the InputStream.:::in->discardRefs
StreamRemoteCall#getResultStream(boolean):::Returns an output stream (may put out header information relating to the success of the call).:::if->throw->new->StreamCorruptedException->else->wr->conn->getOutputStream->new->DataOutputStream->wr->writeByte->getOutputStream->if->out->writeByte->else->out->writeByte->out->writeID->return
StreamRemoteCall#executeCall():::Do whatever it takes to execute the call.:::returnType->ackHandler->try->if->out->getDGCAckHandler->releaseOutputStream->rd->conn->getInputStream->new->DataInputStream->op->rd->readByte->if->if->isLoggable->log->throw->new->UnmarshalException->getInputStream->in->readByte->in->readID->catch->throw->throw->new->UnmarshalException->finally->if->ackHandler->release->switch->break->ex->try->in->readObject->catch->discardPendingRefs->throw->new->UnmarshalException->finally->if->exceptionReceivedFromServer->else->discardPendingRefs->throw->new->UnmarshalException->if->isLoggable->log->throw->new->UnmarshalException
StreamRemoteCall#exceptionReceivedFromServer(Exception):::Routine that causes the stack traces of remote exceptions to be filled in with the current stack trace on the client:::serverTrace->ex->getStackTrace->clientTrace->new->Throwable->getStackTrace->combinedTrace->new->StackTraceElementArr->System->arraycopy->System->arraycopy->ex->setStackTrace->if->isLoggable->ep->conn->getChannel->getEndpoint->ep->getHost->ep->getPort->log->throw
StreamRemoteCall#getServerException()::: stream remote call get server exception:::return
StreamRemoteCall#done()::: stream remote call done:::releaseInputStream
Target#checkLoaderAncestry(ClassLoader, ClassLoader):::Return true if the first class loader is a child of (or identical to) the second class loader:::if->return->else->if->return->else->for->parent->parent->getParent->return
Target#getStub():::Get the stub (proxy) object for this target:::return
Target#getObjectEndpoint():::Returns the object endpoint for the target.:::return->new->ObjectEndpoint
Target#getWeakImpl():::Get the weak reference for the Impl of this target.:::return
Target#getDispatcher():::Returns the dispatcher for this remote object target.:::return
Target#getAccessControlContext()::: target get access control context:::return
Target#getContextClassLoader()::: target get context class loader:::return
Target#getImpl():::Get the impl for this target:::return->weakImpl->get
Target#isPermanent():::Returns true if the target is permanent.:::return
Target#pinImpl():::Pin impl in target:::weakImpl->pin
Target#unpinImpl():::Unpin impl in target:::if->refSet->isEmpty->weakImpl->unpin
Target#setExportedTransport(Transport):::Enable the transport through which remote calls to this target are allowed to be set if it has not already been set.:::if
Target#referenced(long, VMID):::Add an endpoint to the remembered set:::entry->sequenceTable->get->if->sequenceTable->new->SequenceEntry->put->else->if->entry->update->else->return->if->refSet->contains->pinImpl->if->getImpl->return->if->isLoggable->log->refSet->addElement->DGCImpl->getDGCImpl->registerTarget
Target#unreferenced(long, VMID, boolean):::Remove endpoint from remembered set:::entry->sequenceTable->get->if->return->else->if->entry->retain->else->if->sequenceTable->remove->if->isLoggable->log->refSetRemove
Target#refSetRemove(VMID):::Remove endpoint from the reference set.:::DGCImpl->getDGCImpl->unregisterTarget->if->refSet->removeElement->refSet->isEmpty->if->isLoggable->log->obj->getImpl->if->unrefObj->AccessController->Thread->currentThread->setContextClassLoader->AccessController->unrefObj->unreferenced->return->doPrivileged->new->NewThreadAction->doPrivileged->start->unpinImpl
Target#unexport(boolean):::Mark this target as not accepting new calls if any of the following conditions exist: a) the force parameter is true, b) the target's call count is zero, or c) the object is already not accepting calls:::if->unpinImpl->dgc->DGCImpl->getDGCImpl->enum_->refSet->elements->while->enum_->hasMoreElements->vmid->enum_->nextElement->dgc->unregisterTarget->return->else->return
Target#markRemoved():::Mark this target as having been removed from the object table.:::if->throw->new->AssertionError->if->ObjectTable->decrementKeepAliveCount->if->exportedTransport->targetUnexported
Target#incrementCallCount():::Increment call count.:::if->else->throw->new->NoSuchObjectException
Target#decrementCallCount():::Decrement call count.:::if->throw->new->Error->if->ObjectTable->decrementKeepAliveCount
Target#isEmpty():::Returns true if remembered set is empty; otherwise returns false:::return->refSet->isEmpty
Target#vmidDead(VMID):::This method is called if the address space associated with the vmid dies:::if->isLoggable->log->sequenceTable->remove->refSetRemove
SequenceEntry#retain(long)::: sequence entry retain:::
SequenceEntry#update(long)::: sequence entry update:::
Transport#getLogLevel()::: transport get log level:::return->System->getProperty->doPrivileged
Transport#getChannel(Endpoint):::Returns a Channel that generates connections to the endpoint ep:::
Transport#free(Endpoint):::Removes the Channel that generates connections to the endpoint ep.:::
Transport#exportObject(Target):::Export the object so that it can accept incoming calls.:::target->setExportedTransport->ObjectTable->putTarget
Transport#targetUnexported():::Invoked when an object that was exported on this transport has become unexported, either by being garbage collected or by being explicitly unexported.:::
Transport#currentTransport():::Returns the current transport if a call is being serviced, otherwise returns null.:::return->currentTransport->get
Transport#checkAcceptPermission(AccessControlContext):::Verify that the current access control context has permission to accept the connection being dispatched by the current thread:::
Transport#setContextClassLoader(ClassLoader):::Sets the context class loader for the current thread.:::AccessController->Thread->currentThread->setContextClassLoader->return->doPrivileged
Transport#serviceCall(RemoteCall):::Service an incoming remote call:::try->impl->id->try->ObjID->call->getInputStream->read->catch->throw->new->MarshalException->finally->transport->id->equals->target->ObjectTable->new->ObjectEndpoint->getTarget->if->target->getImpl->throw->new->NoSuchObjectException->disp->target->getDispatcher->target->incrementCallCount->try->transportLog->log->acc->target->getAccessControlContext->ccl->target->getContextClassLoader->savedCcl->Thread->currentThread->getContextClassLoader->try->setContextClassLoader->currentTransport->set->try->new->java.security.PrivilegedExceptionAction<Void>->doPrivileged->catch->throw->pae->getException->finally->catch->finally->setContextClassLoader->currentTransport->set->catch->transportLog->log->return->finally->target->decrementCallCount->catch->if->isLoggable->clientHost->try->RemoteServer->getClientHost->catch->finally->message->log->try->out->call->getResultStream->UnicastServerRef->clearStackTraces->out->writeObject->call->releaseOutputStream->catch->transportLog->log->return->finally->finally->return
WeakRef#pin():::Pin the contained reference (make this a strong reference).:::if->get->if->isLoggable->log
WeakRef#unpin():::Unpin the contained reference (make this a weak reference).:::if->if->isLoggable->log
WeakRef#setHashValue(Object)::: weak ref set hash value:::if->System->identityHashCode->else
WeakRef#hashCode():::Always return the "identity" hash code of the original referent.:::return
WeakRef#equals(Object):::Return true if "obj" is this identical WeakRef object, or, if the contained reference has not been cleared, if "obj" is another WeakRef object with the identical non-null referent:::if->if->return->referent->get->return->get->else->return
