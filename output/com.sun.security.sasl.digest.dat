DigestMD5Base#getMechanismName():::Retrieves the SASL mechanism IANA name.:::return
DigestMD5Base#unwrap(byte[], int, int):::Unwrap the incoming message using the wrap method of the secCtx object instance.:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->return->secCtx->unwrap
DigestMD5Base#wrap(byte[], int, int):::Wrap outgoing bytes using the wrap method of the secCtx object instance.:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->return->secCtx->wrap
DigestMD5Base#dispose()::: digest d5 base dispose:::if
DigestMD5Base#getNegotiatedProperty(String)::: digest d5 base get negotiated property:::if->if->propName->equals->return->else->if->propName->equals->return->digestUri->digestUri->indexOf->substring->else->return->super->getNegotiatedProperty->else->throw->new->IllegalStateException
DigestMD5Base#generateNonce()::: digest d5 base generate nonce:::random->new->Random->randomData->new->byteArr->random->nextBytes->nonce->new->byteArr->a->b->c->j->for->i->return
DigestMD5Base#writeQuotedStringValue(ByteArrayOutputStream, byte[]):::Checks if a byte[] contains characters that must be quoted and write the resulting, possibly escaped, characters to out.:::len->ch->for->i
DigestMD5Base#needEscape(String)::: digest d5 base need escape:::len->str->length->for->i->return
DigestMD5Base#needEscape(char)::: digest d5 base need escape:::return
DigestMD5Base#quotedStringValue(String)::: digest d5 base quoted string value:::if->needEscape->len->str->length->buf->new->charArr->j->ch->for->i->return->new->String->else->return
DigestMD5Base#binaryToHex(byte[]):::Convert a byte array to hexadecimal string.:::digestString->new->StringBuilder->for->i->return->digestString->toString->getBytes
DigestMD5Base#stringToByte_8859_1(String):::Used to convert username-value, passwd or realm to 8859_1 encoding if all chars in string are within the 8859_1 (Latin 1) encoding range.:::buffer->str->toCharArray->try->if->for->i->return->str->getBytes->catch->throw->new->SaslException->finally
DigestMD5Base#getPlatformCiphers()::: digest d5 base get platform ciphers:::ciphers->new->byteArr->for->i->if->return
DigestMD5Base#generateResponseValue(String, String, String, String, String, char[], byte[], byte[], int, byte[]):::Assembles response-value for digest-response.:::md5->MessageDigest->getInstance->hexA1->hexA2->A2->beginA1->A1->KD->new->ByteArrayOutputStream->A2->getBytes->write->if->qopValue->equals->qopValue->equals->logger->log->A2->SECURITY_LAYER_MARKER->getBytes->write->if->logger->isLoggable->logger->A2->toString->log->md5->A2->toByteArray->update->digest->md5->digest->binaryToHex->if->logger->isLoggable->logger->new->String->log->new->ByteArrayOutputStream->beginA1->stringToByte_8859_1->write->beginA1->write->beginA1->stringToByte_8859_1->write->beginA1->write->beginA1->new->String->stringToByte_8859_1->write->md5->beginA1->toByteArray->update->md5->digest->if->logger->isLoggable->logger->new->ObjectArr->beginA1->toString->binaryToHex->new->String->log->new->ByteArrayOutputStream->A1->write->A1->write->A1->write->A1->write->A1->write->if->A1->write->A1->write->md5->A1->toByteArray->update->md5->digest->binaryToHex->if->logger->isLoggable->logger->new->String->log->new->ByteArrayOutputStream->KD->write->KD->write->KD->write->KD->write->KD->nonceCountToHex->getBytes->write->KD->write->KD->write->KD->write->KD->qopValue->getBytes->write->KD->write->KD->write->if->logger->isLoggable->logger->KD->toString->log->md5->KD->toByteArray->update->md5->digest->answer->binaryToHex->if->logger->isLoggable->logger->new->String->log->return
DigestMD5Base#nonceCountToHex(int):::Takes 'nonceCount' value and returns HEX value of the value.:::str->Integer->toHexString->pad->new->StringBuilder->if->str->length->for->i->str->length->return->pad->toString
DigestMD5Base#parseDirectives(byte[], String[], List, int):::Parses digest-challenge string, extracting each token and value(s):::valueTable->new->byteArrs->key->new->ByteArrayOutputStream->value->new->ByteArrayOutputStream->gettingKey->gettingQuotedValue->expectSeparator->bch->i->skipLws->while->if->if->if->key->size->throw->new->SaslException->skipLws->else->if->if->key->size->throw->new->SaslException->skipLws->if->if->else->throw->key->toString->new->SaslException->else->if->isLws->skipLws->if->if->throw->key->toString->new->SaslException->else->throw->key->toString->new->SaslException->else->key->write->else->if->if->if->value->write->else->throw->key->toString->value->toString->new->SaslException->else->if->else->value->write->else->if->isLws->key->toString->value->toByteArray->extractDirective->key->reset->value->reset->skipLws->else->if->throw->value->toString->new->SaslException->else->value->write->if->throw->key->toString->value->toString->new->SaslException->if->key->size->key->toString->value->toByteArray->extractDirective->return
DigestMD5Base#isLws(byte)::: digest d5 base is lws:::switch->return->return
DigestMD5Base#skipLws(byte[], int)::: digest d5 base skip lws:::i->for->return
DigestMD5Base#extractDirective(String, byte[], String[], byte[][], List, int):::Processes directive/value pairs from the digest-challenge and fill out the challengeVal array.:::for->i
DigestMD5Base.DigestIntegrity#generateIntegrityKeyPair(boolean):::Generate client-server, server-client key pairs for DIGEST-MD5 integrity checking.:::cimagic->CLIENT_INT_MAGIC->getBytes->simagic->SVR_INT_MAGIC->getBytes->md5->MessageDigest->getInstance->keyBuffer->new->byteArr->System->arraycopy->System->arraycopy->md5->update->Kic->md5->digest->System->arraycopy->md5->update->Kis->md5->digest->if->logger->isLoggable->traceOutput->traceOutput->if->else
DigestMD5Base.DigestIntegrity#wrap(byte[], int, int):::Append MAC onto outgoing message.:::if->return->wrapped->new->byteArr->System->arraycopy->incrementSeqNum->mac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->return
DigestMD5Base.DigestIntegrity#unwrap(byte[], int, int):::Return verified message without MAC - only if the received MAC and re-generated MAC are the same.:::if->return->mac->new->byteArr->msg->new->byteArr->msgType->new->byteArr->seqNum->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->System->arraycopy->expectedMac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->traceOutput->traceOutput->if->Arrays->equals->logger->log->return->if->networkByteOrderToInt->throw->networkByteOrderToInt->new->SaslException->if->Arrays->equals->throw->networkByteOrderToInt->new->SaslException->return
DigestMD5Base.DigestIntegrity#getHMAC(byte[], byte[], byte[], int, int):::Generates MAC to be appended onto out-going messages.:::seqAndMsg->new->byteArr->System->arraycopy->System->arraycopy->try->keyKi->new->SecretKeySpec->m->Mac->getInstance->m->init->m->update->hMAC_MD5->m->doFinal->macBuffer->new->byteArr->System->arraycopy->return->catch->throw->new->SaslException->throw->new->SaslException->finally
DigestMD5Base.DigestIntegrity#incrementSeqNum():::Increment own sequence number and set answer in NBO sequenceNum field.:::intToNetworkByteOrder
DigestMD5Base.DigestPrivacy#generatePrivacyKeyPair(boolean):::Generates client-server and server-client keys to encrypt and decrypt messages:::ccmagic->CLIENT_CONF_MAGIC->getBytes->scmagic->SVR_CONF_MAGIC->getBytes->md5->MessageDigest->getInstance->n->if->negotiatedCipher->equals->else->if->negotiatedCipher->equals->else->keyBuffer->new->byteArr->System->arraycopy->System->arraycopy->md5->update->Kcc->md5->digest->System->arraycopy->md5->update->Kcs->md5->digest->if->logger->isLoggable->traceOutput->traceOutput->myKc->peerKc->if->else->try->encKey->decKey->if->negotiatedCipher->indexOf->Cipher->getInstance->Cipher->getInstance->new->SecretKeySpec->new->SecretKeySpec->encCipher->init->decCipher->init->else->if->negotiatedCipher->equals->negotiatedCipher->equals->cipherFullname->cipherShortname->if->negotiatedCipher->equals->else->Cipher->getInstance->Cipher->getInstance->makeDesKeys->makeDesKeys->encIv->new->IvParameterSpec->decIv->new->IvParameterSpec->encCipher->init->decCipher->init->if->logger->isLoggable->encIv->getIV->traceOutput->decIv->getIV->traceOutput->encKey->getEncoded->traceOutput->decKey->getEncoded->traceOutput->catch->throw->new->SaslException->throw->new->SaslException->throw->new->SaslException->throw->new->SaslException->finally
DigestMD5Base.DigestPrivacy#wrap(byte[], int, int):::Encrypt out-going message.:::if->return->incrementSeqNum->mac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->bs->encCipher->getBlockSize->padding->if->pad->new->byteArr->for->i->else->toBeEncrypted->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->cipherBlock->try->encCipher->update->if->throw->new->IllegalBlockSizeException->catch->throw->new->SaslException->finally->wrapped->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->return
DigestMD5Base.DigestPrivacy#unwrap(byte[], int, int)::: digest privacy unwrap:::if->return->encryptedMsg->new->byteArr->msgType->new->byteArr->seqNum->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->logger->log->traceOutput->decryptedMsg->try->decCipher->update->if->throw->new->IllegalBlockSizeException->catch->throw->new->SaslException->finally->msgWithPadding->new->byteArr->mac->new->byteArr->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->traceOutput->msgLength->blockSize->decCipher->getBlockSize->if->if->if->logger->isLoggable->logger->log->return->expectedMac->getHMAC->if->logger->isLoggable->traceOutput->if->Arrays->equals->logger->log->return->if->networkByteOrderToInt->throw->networkByteOrderToInt->new->SaslException->if->Arrays->equals->throw->networkByteOrderToInt->new->SaslException->if->return->else->clearMsg->new->byteArr->System->arraycopy->return
DigestMD5Base#setParityBit(byte[]):::Sets the parity bit (0th bit) in each byte so that each byte contains an odd number of 1's.:::for->i
DigestMD5Base#addDesParity(byte[], int, int):::Expands a 7-byte array into an 8-byte array that contains parity bits The binary format of a cryptographic key is:     (B1,B2,...,B7,P1,B8,...B14,P2,B15,...,B49,P7,B50,...,B56,P8) where (B1,B2,...,B56) are the independent bits of a DES key and (PI,P2,...,P8) are reserved for parity bits computed on the preceding seven independent bits and set so that the parity of the octet is odd, i.e., there is an odd number of "1" bits in the octet.:::if->throw->new->IllegalArgumentException->raw->new->byteArr->System->arraycopy->result->new->byteArr->in->new->BigInteger->for->i->setParityBit->return
DigestMD5Base#makeDesKeys(byte[], String):::Create parity-adjusted keys suitable for DES / DESede encryption.:::subkey1->addDesParity->spec->desFactory->SecretKeyFactory->getInstance->switch->new->DESKeySpec->if->logger->isLoggable->traceOutput->traceOutput->getKey->traceOutput->logger->Boolean->DESKeySpec->isParityAdjusted->valueOf->log->break->subkey2->addDesParity->ede->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->new->DESedeKeySpec->if->logger->isLoggable->traceOutput->traceOutput->getKey->traceOutput->logger->Boolean->DESedeKeySpec->isParityAdjusted->valueOf->log->break->throw->new->IllegalArgumentException->return->desFactory->generateSecret
DigestMD5Client#hasInitialResponse():::DIGEST-MD5 has no initial response:::return
DigestMD5Client#evaluateChallenge(byte[]):::Process the challenge data:::if->throw->new->SaslException->challengeVal->switch->realmChoices->new->ArrayList<byte[]>->parseDirectives->try->processChallenge->checkQopSupport->return->generateClientResponse->catch->clearPassword->throw->clearPassword->throw->new->SaslException->finally->try->parseDirectives->validateResponseValue->if->new->DigestPrivacy->else->if->new->DigestIntegrity->return->catch->finally->clearPassword->throw->new->SaslException
DigestMD5Client#processChallenge(byte[][], List):::Record information from the challengeVal array into variables/fields:::if->if->new->String->equals->throw->new->String->new->SaslException->else->if->throw->new->SaslException->else->if->new->String->equals->throw->new->SaslException->if->throw->new->SaslException->else->try->realmTokens->if->if->realmChoices->size->new->String->else->realmChoices->size->new->StringArr->for->i->ncb->new->NameCallback->new->NameCallback->pcb->new->PasswordCallback->if->tcb->new->RealmCallback->new->RealmCallback->cbh->new->CallbackArr->handle->tcb->getText->if->else->ccb->new->RealmChoiceCallback->cbh->new->CallbackArr->handle->selected->ccb->getSelectedIndexes->if->throw->new->SaslException->pcb->getPassword->pcb->clearPassword->ncb->getName->catch->throw->throw->new->SaslException->throw->new->SaslException->finally->if->throw->new->SaslException->srvMaxBufSize->Integer->new->String->parseInt->Math->min
DigestMD5Client#checkQopSupport(byte[], byte[]):::Parses the 'qop' directive:::qopOptions->if->else->new->String->serverQopTokens->new->StringArr->serverQop->parseQop->serverAllQop->combineMasks->switch->findPreferredMask->throw->new->SaslException->break->break->checkStrengthSupport->break->if->logger->isLoggable->logger->log
DigestMD5Client#checkStrengthSupport(byte[]):::Processes the 'cipher' digest-challenge directive:::if->throw->new->SaslException->cipherOptions->new->String->parser->new->StringTokenizer->tokenCount->parser->countTokens->token->serverCiphers->serverCipherStrs->new->StringArr->for->i->clntCiphers->getPlatformCiphers->inter->for->i->if->throw->new->SaslException->findCipherAndStrength->if->throw->new->SaslException->logger->log
DigestMD5Client#findCipherAndStrength(byte[], String[]):::Steps through the ordered 'strength' array, and compares it with the 'supportedCiphers' array:::s->for->i->return
DigestMD5Client#generateClientResponse(byte[]):::Returns digest-response suitable for an initial authentication:::digestResp->new->ByteArrayOutputStream->if->digestResp->getBytes->write->digestResp->write->digestResp->write->digestResp->quotedStringValue->getBytes->write->if->negotiatedRealm->length->digestResp->quotedStringValue->getBytes->write->digestResp->getBytes->write->writeQuotedStringValue->digestResp->write->digestResp->write->getNonceCount->digestResp->nonceCountToHex->getBytes->write->generateNonce->digestResp->getBytes->write->writeQuotedStringValue->digestResp->getBytes->write->digestResp->getBytes->write->digestResp->getBytes->write->digestResp->String->valueOf->getBytes->write->digestResp->write->try->digestResp->getBytes->write->digestResp->generateResponseValue->write->digestResp->write->catch->throw->new->SaslException->finally->digestResp->getBytes->write->if->digestResp->getBytes->write->if->digestResp->getBytes->write->writeQuotedStringValue->digestResp->getBytes->write->if->digestResp->size->throw->digestResp->size->new->SaslException->return->digestResp->toByteArray
DigestMD5Client#validateResponseValue(byte[]):::From RFC 2831, Section 2.1.3: Step Three [Server] sends a message formatted as follows:     response-auth = "rspauth" "=" response-value where response-value is calculated as above, using the values sent in step two, except that if qop is "auth", then A2 is   A2 = { ":", digest-uri-value }  And if qop is "auth-int" or "auth-conf" then A2 is   A2 = { ":", digest-uri-value, ":00000000000000000000000000000000" }:::if->throw->new->SaslException->try->expected->generateResponseValue->if->Arrays->equals->throw->new->SaslException->catch->throw->new->SaslException->throw->new->SaslException->finally
DigestMD5Client#getNonceCount(byte[]):::Returns the number of requests (including current request) that the client has sent in response to nonceValue:::return
DigestMD5Client#clearPassword()::: digest d5 client clear password:::if->for->i
DigestMD5Server#evaluateResponse(byte[])::: digest d5 server evaluate response:::if->throw->new->SaslException->challenge->switch->if->throw->new->SaslException->supportedCiphers->if->getPlatformCiphers->sb->new->StringBuilder->for->i->sb->toString->try->generateChallenge->return->catch->throw->new->SaslException->throw->new->SaslException->finally->try->responseVal->parseDirectives->validateClientResponse->catch->throw->throw->new->SaslException->finally->if->new->DigestPrivacy->else->if->new->DigestIntegrity->return->throw->new->SaslException
DigestMD5Server#generateChallenge(List, String, String):::Generates challenge to be sent to client:::out->new->ByteArrayOutputStream->for->i->realms->size->out->getBytes->write->generateNonce->writeQuotedStringValue->out->write->out->write->if->out->getBytes->write->qopStr->getBytes->writeQuotedStringValue->out->write->out->write->if->out->getBytes->write->if->out->UTF8_DIRECTIVE->getBytes->write->if->out->getBytes->write->cipherStr->getBytes->writeQuotedStringValue->out->write->out->write->out->ALGORITHM_DIRECTIVE->getBytes->write->return->out->toByteArray
DigestMD5Server#validateClientResponse(byte[][]):::Validates client's response:::if->if->new->String->equals->throw->new->String->new->SaslException->clntMaxBufSize->Integer->new->String->parseInt->Math->min->username->if->new->String->logger->log->else->throw->new->SaslException->new->String->logger->log->if->serverRealms->contains->throw->new->SaslException->if->throw->new->SaslException->nonceFromClient->if->Arrays->equals->throw->new->SaslException->if->throw->new->SaslException->cnonce->if->Integer->new->String->parseInt->throw->new->String->new->SaslException->new->String->logger->log->cQop->switch->break->break->break->throw->new->SaslException->if->throw->new->SaslException->if->new->String->if->throw->new->SaslException->foundCipher->logger->log->for->j->if->throw->new->SaslException->if->else->if->else->logger->log->digestUriFromResponse->new->String->if->logger->log->if->uriMatches->else->throw->new->SaslException->responseFromClient->if->throw->new->SaslException->authzidBytes->authzidFromClient->new->String->if->logger->new->String->log->passwd->try->rcb->new->RealmCallback->ncb->new->NameCallback->pcb->new->PasswordCallback->cbh->new->CallbackArr->handle->pcb->getPassword->pcb->clearPassword->catch->throw->new->SaslException->throw->new->SaslException->finally->if->throw->new->SaslException->try->expectedResponse->try->generateResponseValue->catch->throw->new->SaslException->throw->new->SaslException->finally->if->Arrays->equals->throw->new->SaslException->try->acb->new->AuthorizeCallback->cbh->new->CallbackArr->handle->if->acb->isAuthorized->acb->getAuthorizedID->else->throw->new->SaslException->catch->throw->throw->new->SaslException->throw->new->SaslException->finally->return->generateResponseAuth->catch->finally->for->i
DigestMD5Server#uriMatches(String, String)::: digest d5 server uri matches:::if->thisUri->equalsIgnoreCase->return->if->thisUri->endsWith->protoAndSlash->thisUri->length->thisProtoAndSlash->thisUri->substring->incomingProtoAndSlash->incomingUri->substring->return->thisProtoAndSlash->equalsIgnoreCase->return
DigestMD5Server#generateResponseAuth(String, char[], byte[], int, byte[]):::Server sends a message formatted as follows:    response-auth = "rspauth" "=" response-value   where response-value is calculated as above, using the values sent in   step two, except that if qop is "auth", then A2 is        A2 = { ":", digest-uri-value }    And if qop is "auth-int" or "auth-conf" then A2 is        A2 = { ":", digest-uri-value, ":00000000000000000000000000000000" }  Clears password afterwards.:::try->responseValue->generateResponseValue->challenge->new->byteArr->System->getBytes->arraycopy->System->arraycopy->return->catch->throw->new->SaslException->throw->new->SaslException->finally
DigestMD5Server#getAuthorizationID()::: digest d5 server get authorization d:::if->return->else->throw->new->IllegalStateException
FactoryImpl#createSaslClient(String[], String, String, String, Map, CallbackHandler):::Returns a new instance of the DIGEST-MD5 SASL client mechanism.:::for->i->return
FactoryImpl#createSaslServer(String, String, String, Map, CallbackHandler):::Returns a new instance of the DIGEST-MD5 SASL server mechanism.:::if->mech->equals->PolicyUtils->checkPolicy->if->throw->new->SaslException->return->new->DigestMD5Server->return
FactoryImpl#getMechanismNames(Map):::Returns the authentication mechanisms that this factory can produce.:::return->PolicyUtils->filterMechs
SecurityCtx#wrap(byte[], int, int):::Wrap out-going message and return wrapped message:::
SecurityCtx#unwrap(byte[], int, int):::Unwrap incoming message and return original message:::
