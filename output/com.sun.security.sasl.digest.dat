DigestMD5Base#getMechanismName():::Retrieves the SASL mechanism IANA name.:::return
DigestMD5Base#unwrap(byte[], int, int):::Unwrap the incoming message using the wrap method of the secCtx object instance.:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->return->secCtx->unwrap
DigestMD5Base#wrap(byte[], int, int):::Wrap outgoing bytes using the wrap method of the secCtx object instance.:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->return->secCtx->wrap
DigestMD5Base#writeQuotedStringValue(ByteArrayOutputStream, byte[]):::Checks if a byte[] contains characters that must be quoted and write the resulting, possibly escaped, characters to out.:::len->ch->for->i
DigestMD5Base#binaryToHex(byte[]):::Convert a byte array to hexadecimal string.:::digestString->new->StringBuilder->for->i->return->digestString->toString->getBytes
DigestMD5Base#stringToByte_8859_1(String):::Used to convert username-value, passwd or realm to 8859_1 encoding if all chars in string are within the 8859_1 (Latin 1) encoding range.:::buffer->str->toCharArray->try->if->for->i->return->str->getBytes->catch->throw->new->SaslException->finally
DigestMD5Base#generateResponseValue(String, String, String, String, String, char[], byte[], byte[], int, byte[]):::Assembles response-value for digest-response.:::md5->MessageDigest->getInstance->hexA1->hexA2->A2->beginA1->A1->KD->new->ByteArrayOutputStream->A2->getBytes->write->if->qopValue->equals->qopValue->equals->logger->log->A2->SECURITY_LAYER_MARKER->getBytes->write->if->logger->isLoggable->logger->A2->toString->log->md5->A2->toByteArray->update->digest->md5->digest->binaryToHex->if->logger->isLoggable->logger->new->String->log->new->ByteArrayOutputStream->beginA1->stringToByte_8859_1->write->beginA1->write->beginA1->stringToByte_8859_1->write->beginA1->write->beginA1->new->String->stringToByte_8859_1->write->md5->beginA1->toByteArray->update->md5->digest->if->logger->isLoggable->logger->new->ObjectArr->beginA1->toString->binaryToHex->new->String->log->new->ByteArrayOutputStream->A1->write->A1->write->A1->write->A1->write->A1->write->if->A1->write->A1->write->md5->A1->toByteArray->update->md5->digest->binaryToHex->if->logger->isLoggable->logger->new->String->log->new->ByteArrayOutputStream->KD->write->KD->write->KD->write->KD->write->KD->nonceCountToHex->getBytes->write->KD->write->KD->write->KD->write->KD->qopValue->getBytes->write->KD->write->KD->write->if->logger->isLoggable->logger->KD->toString->log->md5->KD->toByteArray->update->md5->digest->answer->binaryToHex->if->logger->isLoggable->logger->new->String->log->return
DigestMD5Base#nonceCountToHex(int):::Takes 'nonceCount' value and returns HEX value of the value.:::str->Integer->toHexString->pad->new->StringBuilder->if->str->length->for->i->str->length->return->pad->toString
DigestMD5Base#parseDirectives(byte[], String[], List, int):::Parses digest-challenge string, extracting each token and value(s):::valueTable->new->byteArrs->key->new->ByteArrayOutputStream->value->new->ByteArrayOutputStream->gettingKey->gettingQuotedValue->expectSeparator->bch->i->skipLws->while->if->if->if->key->size->throw->new->SaslException->skipLws->else->if->if->key->size->throw->new->SaslException->skipLws->if->if->else->throw->key->toString->new->SaslException->else->if->isLws->skipLws->if->if->throw->key->toString->new->SaslException->else->throw->key->toString->new->SaslException->else->key->write->else->if->if->if->value->write->else->throw->key->toString->value->toString->new->SaslException->else->if->else->value->write->else->if->isLws->key->toString->value->toByteArray->extractDirective->key->reset->value->reset->skipLws->else->if->throw->value->toString->new->SaslException->else->value->write->if->throw->key->toString->value->toString->new->SaslException->if->key->size->key->toString->value->toByteArray->extractDirective->return
DigestMD5Base.DigestIntegrity#wrap(byte[], int, int):::Append MAC onto outgoing message.:::if->return->wrapped->new->byteArr->System->arraycopy->incrementSeqNum->mac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->return
DigestMD5Base.DigestIntegrity#unwrap(byte[], int, int):::Return verified message without MAC - only if the received MAC and re-generated MAC are the same.:::if->return->mac->new->byteArr->msg->new->byteArr->msgType->new->byteArr->seqNum->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->System->arraycopy->expectedMac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->traceOutput->traceOutput->if->Arrays->equals->logger->log->return->if->networkByteOrderToInt->throw->networkByteOrderToInt->new->SaslException->if->Arrays->equals->throw->networkByteOrderToInt->new->SaslException->return
DigestMD5Base.DigestIntegrity#getHMAC(byte[], byte[], byte[], int, int):::Generates MAC to be appended onto out-going messages.:::seqAndMsg->new->byteArr->System->arraycopy->System->arraycopy->try->keyKi->new->SecretKeySpec->m->Mac->getInstance->m->init->m->update->hMAC_MD5->m->doFinal->macBuffer->new->byteArr->System->arraycopy->return->catch->throw->new->SaslException->throw->new->SaslException->finally
DigestMD5Base.DigestIntegrity#incrementSeqNum():::Increment own sequence number and set answer in NBO sequenceNum field.:::intToNetworkByteOrder
DigestMD5Base.DigestPrivacy#wrap(byte[], int, int):::Encrypt out-going message.:::if->return->incrementSeqNum->mac->getHMAC->if->logger->isLoggable->traceOutput->traceOutput->traceOutput->bs->encCipher->getBlockSize->padding->if->pad->new->byteArr->for->i->else->toBeEncrypted->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->cipherBlock->try->encCipher->update->if->throw->new->IllegalBlockSizeException->catch->throw->new->SaslException->finally->wrapped->new->byteArr->System->arraycopy->System->arraycopy->System->arraycopy->if->logger->isLoggable->traceOutput->return
DigestMD5Client#hasInitialResponse():::DIGEST-MD5 has no initial response:::return
DigestMD5Client#evaluateChallenge(byte[]):::Process the challenge data:::if->throw->new->SaslException->challengeVal->switch->realmChoices->new->ArrayList<byte[]>->parseDirectives->try->processChallenge->checkQopSupport->return->generateClientResponse->catch->clearPassword->throw->clearPassword->throw->new->SaslException->finally->try->parseDirectives->validateResponseValue->if->new->DigestPrivacy->else->if->new->DigestIntegrity->return->catch->finally->clearPassword->throw->new->SaslException
FactoryImpl#createSaslClient(String[], String, String, String, Map, CallbackHandler):::Returns a new instance of the DIGEST-MD5 SASL client mechanism.:::for->i->return
FactoryImpl#createSaslServer(String, String, String, Map, CallbackHandler):::Returns a new instance of the DIGEST-MD5 SASL server mechanism.:::if->mech->equals->PolicyUtils->checkPolicy->if->throw->new->SaslException->return->new->DigestMD5Server->return
FactoryImpl#getMechanismNames(Map):::Returns the authentication mechanisms that this factory can produce.:::return->PolicyUtils->filterMechs
SecurityCtx#wrap(byte[], int, int):::Wrap out-going message and return wrapped message:::
SecurityCtx#unwrap(byte[], int, int):::Unwrap incoming message and return original message:::
