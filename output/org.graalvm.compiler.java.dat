BytecodeParserOptions_OptionDescriptors#get(String)::: bytecode parser options_ option descriptors get:::switch->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return->OptionDescriptor->create->return
BytecodeParserOptions_OptionDescriptors#iterator()::: bytecode parser options_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
BciBlockMapping.BciBlock.JSRData#copy()::: data copy:::try->return->this->clone->catch->return->finally
BciBlockMapping.BciBlock#getStartBci()::: bci block get start bci:::return
BciBlockMapping.BciBlock#getEndBci()::: bci block get end bci:::return
BciBlockMapping.BciBlock#getLoops()::: bci block get loops:::return
BciBlockMapping.BciBlock#exceptionDispatchBlock()::: bci block exception dispatch block:::if->successors->size->successors->successors->size->get->return->successors->successors->size->get->return
BciBlockMapping.BciBlock#getId()::: bci block get id:::return
BciBlockMapping.BciBlock#getPredecessorCount()::: bci block get predecessor count:::return
BciBlockMapping.BciBlock#numNormalSuccessors()::: bci block num normal successors:::if->exceptionDispatchBlock->return->successors->size->return->successors->size
BciBlockMapping.BciBlock#copy()::: bci block copy:::try->block->super->clone->if->copy->new->ArrayList<>->return->catch->throw->new->RuntimeException->finally
BciBlockMapping.BciBlock#toString()::: bci block to string:::sb->new->StringBuilder->getId->append->sb->append->append->append->append->if->sb->append->if->sb->append->if->sb->append->else->if->sb->append->sb->append->return->sb->toString
BciBlockMapping.BciBlock#getLoopDepth()::: bci block get loop depth:::return->Long->bitCount
BciBlockMapping.BciBlock#isLoopHeader()::: bci block is loop header:::return
BciBlockMapping.BciBlock#isExceptionEntry()::: bci block is exception entry:::return
BciBlockMapping.BciBlock#getSuccessor(int)::: bci block get successor:::return->successors->get
BciBlockMapping.BciBlock#getLoopId():::Get the loop id of the inner most loop.:::l->if->return->pos->for->lMask->return
BciBlockMapping.BciBlock#loopIdIterable():::Iterate over loop ids.:::return->new->Iterable<Integer>
BciBlockMapping.BciBlock#idIterator(long)::: bci block id iterator:::return->new->Iterator<Integer>
BciBlockMapping.BciBlock#probability()::: bci block probability:::return
BciBlockMapping.BciBlock#getPostdominator()::: bci block get postdominator:::return
BciBlockMapping.BciBlock#getOrCreateJSRData()::: bci block get or create data:::if->new->JSRData->return
BciBlockMapping.BciBlock#setEndsWithRet()::: bci block set ends with ret:::getOrCreateJSRData
BciBlockMapping.BciBlock#getJsrScope()::: bci block get jsr scope:::if->return->else->return
BciBlockMapping.BciBlock#endsWithRet()::: bci block ends with ret:::if->return->else->return
BciBlockMapping.BciBlock#setRetSuccessor(BciBlock)::: bci block set ret successor:::this->getOrCreateJSRData
BciBlockMapping.BciBlock#getRetSuccessor()::: bci block get ret successor:::if->return->else->return
BciBlockMapping.BciBlock#getJsrSuccessor()::: bci block get jsr successor:::if->return->else->return
BciBlockMapping.BciBlock#getJsrReturnBci()::: bci block get jsr return bci:::if->return->else->return
BciBlockMapping.BciBlock#getJsrAlternatives()::: bci block get jsr alternatives:::if->return->else->return
BciBlockMapping.BciBlock#initJsrAlternatives()::: bci block init jsr alternatives:::data->this->getOrCreateJSRData->if->EconomicMap->create
BciBlockMapping.BciBlock#setJsrScope(JsrScope)::: bci block set jsr scope:::this->getOrCreateJSRData
BciBlockMapping.BciBlock#setJsrSuccessor(BciBlock)::: bci block set jsr successor:::this->getOrCreateJSRData
BciBlockMapping.BciBlock#setJsrReturnBci(int)::: bci block set jsr return bci:::this->getOrCreateJSRData
BciBlockMapping.BciBlock#getSuccessorCount()::: bci block get successor count:::return->successors->size
BciBlockMapping.BciBlock#getSuccessors()::: bci block get successors:::return
BciBlockMapping.BciBlock#setId(int)::: bci block set id:::
BciBlockMapping.BciBlock#addSuccessor(BciBlock)::: bci block add successor:::successors->add
BciBlockMapping.BciBlock#clearSucccessors()::: bci block clear succcessors:::foreach->successors->clear
BciBlockMapping.BciBlock#isExceptionDispatch()::: bci block is exception dispatch:::return
BciBlockMapping.ExceptionDispatchBlock#isExceptionDispatch()::: exception dispatch block is exception dispatch:::return
BciBlockMapping#getBlocks()::: bci block mapping get blocks:::return
BciBlockMapping#build(BytecodeStream, OptionValues):::Builds the block map and conservative CFG and numbers blocks.:::codeSize->code->getCodeSize->blockMap->new->BciBlockArr->makeExceptionEntries->iterateOverBytecodes->if->if->SupportJsrBytecodes->getValue->throw->new->JsrNotSupportedBailout->createJsrAlternatives->if->debug->isLogEnabled->this->log->computeBlockOrder->fixLoopBits->if->debug->isLogEnabled->this->log
BciBlockMapping#verify()::: bci block mapping verify:::foreach->for->i->block->getSuccessorCount->return
BciBlockMapping#makeExceptionEntries(BciBlock[])::: bci block mapping make exception entries:::foreach->xhandler->h->getHandlerBCI->makeBlock
BciBlockMapping#iterateOverBytecodes(BciBlock[], BytecodeStream)::: bci block mapping iterate over bytecodes:::current->stream->setBCI->while->stream->currentBC->bci->stream->currentBCI->if->b->makeBlock->if->addSuccessor->switch->stream->currentBC->break->handler->handleExceptions->if->addSuccessor->break->stream->readBranchDest->makeBlock->addSuccessor->stream->nextBCI->makeBlock->addSuccessor->break->stream->readBranchDest->makeBlock->addSuccessor->break->new->BytecodeTableSwitch->addSwitchSuccessors->break->new->BytecodeLookupSwitch->addSwitchSuccessors->break->target->stream->readBranchDest->if->throw->new->JsrNotSupportedBailout->b1->makeBlock->current->setJsrSuccessor->current->stream->nextBCI->setJsrReturnBci->addSuccessor->break->current->setEndsWithRet->break->stream->nextBCI->makeBlock->addSuccessor->handler->handleExceptions->if->addSuccessor->break->handler->handleExceptions->if->stream->nextBCI->makeBlock->addSuccessor->addSuccessor->stream->next
BciBlockMapping#makeBlock(BciBlock[], int)::: bci block mapping make block:::oldBlock->if->newBlock->new->BciBlock->return->else->if->newBlock->new->BciBlock->foreach->oldBlock->getSuccessors->newBlock->addSuccessor->oldBlock->clearSucccessors->oldBlock->addSuccessor->for->i->return->else->return
BciBlockMapping#addSwitchSuccessors(BciBlock[], int, BytecodeSwitch)::: bci block mapping add switch successors:::targets->new->TreeSet<>->for->i->bswitch->numberOfCases->targets->bswitch->defaultTarget->add->foreach->makeBlock->addSuccessor
BciBlockMapping#addSuccessor(BciBlock[], int, BciBlock)::: bci block mapping add successor:::predecessor->if->throw->new->PermanentBailoutException->predecessor->addSuccessor
BciBlockMapping#createJsrAlternatives(BciBlock[], BciBlock)::: bci block mapping create jsr alternatives:::jsrVisited->add->scope->block->getJsrScope->if->block->endsWithRet->block->scope->nextReturnAddress->setRetSuccessor->block->block->getRetSuccessor->addSuccessor->debug->block->getSuccessors->block->getJsrSuccessor->block->getRetSuccessor->block->getJsrScope->log->if->block->getJsrSuccessor->scope->isEmpty->for->i->block->getSuccessorCount->foreach->block->getSuccessors->if->jsrVisited->contains->createJsrAlternatives
BciBlockMapping#handleExceptions(BciBlock[], int)::: bci block mapping handle exceptions:::lastHandler->dispatchBlocks->for->i->return
BciBlockMapping#fixLoopBits(BciBlock[])::: bci block mapping fix loop bits:::do->foreach->loop->fixLoopBits->if->throw->new->PermanentBailoutException->while
BciBlockMapping#computeBlockOrder(BciBlock[])::: bci block mapping compute block order:::maxBlocks->new->BciBlockArr->loop->computeBlockOrder->if->throw->new->PermanentBailoutException->blockCount->newBlocks->new->BciBlockArr->next->for->i->unwindBlock->new->ExceptionDispatchBlock->unwindBlock->setId
BciBlockMapping#handleLoopHeader(BciBlock[], int, int, BciBlock)::: bci block mapping handle loop header:::next->endOfLoop->for->j->return
BciBlockMapping#log(BciBlock[], String)::: bci block mapping log:::if->debug->isLogEnabled->debug->debug->getCurrentScopeName->toString->log
BciBlockMapping#toString(BciBlock[], BciBlock[])::: bci block mapping to string:::sb->new->StringBuilder->foreach->if->continue->sb->append->b->getId->append->append->append->append->append->append->if->sb->append->if->sb->append->if->sb->append->if->isEmpty->sb->append->foreach->b->getSuccessors->if->sb->sb->length->charAt->sb->append->sb->append->s->getId->append->sb->append->if->sb->append->foreach->b->loopIdIterable->if->sb->sb->length->charAt->sb->append->sb->append->getId->append->sb->append->sb->System->lineSeparator->append->return->sb->toString
BciBlockMapping#toString()::: bci block mapping to string:::return->toString
BciBlockMapping#getLoopHeader(int):::Get the header block for a loop index.:::return
BciBlockMapping#makeLoopHeader(BciBlock):::Mark the block as a loop header, using the next available loop number:::if->if->throw->new->PermanentBailoutException->if->throw->new->PermanentBailoutException->debug->log->if->new->BciBlockArr->else->if->Arrays->copyOf
BciBlockMapping#computeBlockOrder(BciBlock):::Non-recursive depth-first traversal of the control flow graph:::workStack->new->ArrayDeque<>->workStack->new->TraversalStep->push->while->step->workStack->peek->block->if->else->successor->block->getSuccessor->if->if->size->successor->block->getSuccessors->get->if->if->makeLoopHeader->else->if->else->else->workStack->new->TraversalStep->push->else->debug->log->if->workStack->pop->if->workStack->isEmpty->workStack->peek->else->return
BciBlockMapping#fixLoopBits(BciBlock)::: bci block mapping fix loop bits:::workStack->new->ArrayDeque<>->workStack->new->TraversalStep->push->while->step->workStack->peek->block->if->if->block->getSuccessors->size->successor->block->getSuccessors->get->if->if->else->else->workStack->new->TraversalStep->push->else->if->debug->log->if->workStack->pop->if->workStack->isEmpty->workStack->peek->else->return
BciBlockMapping#create(BytecodeStream, Bytecode, OptionValues, DebugContext)::: bci block mapping create:::map->new->BciBlockMapping->map->build->if->debug->isDumpEnabled->debug->code->getMethod->format->dump->return
BciBlockMapping#getLoopHeaders()::: bci block mapping get loop headers:::return
BciBlockMapping#getStartBlock()::: bci block mapping get start block:::return
BciBlockMapping#getUnwindBlock()::: bci block mapping get unwind block:::return
BciBlockMapping#getLoopCount()::: bci block mapping get loop count:::return
BciBlockMapping#getBlockCount()::: bci block mapping get block count:::return
BytecodeParser.InliningScope#close()::: inlining scope close:::processPlaceholderFrameStates
BytecodeParser.InliningScope#processPlaceholderFrameStates(boolean):::Fixes up the BytecodeFrame#isPlaceholderBci(int) placeholder frame states added to the graph while parsing/inlining the intrinsic for which this object exists.:::graph->parser->getGraph->graph->getDebug->dump->foreach->graph->getNewNodes->if->frameState->if->BytecodeFrame->isPlaceholderBci->if->if->parser->getInvokeReturnType->newFrameState->graph->new->FrameState->add->frameState->replaceAndDelete->else->returnKind->parser->getInvokeReturnType->getJavaKind->frameStateBuilder->if->frameState->stackSize->returnVal->frameState->stackAt->if->ReturnToCallerData->containsReturnValue->throw->new->GraalError->tos->frameStateBuilder->pop->newFrameState->frameStateBuilder->nextBCI->parser->getNonIntrinsicAncestor->new->JavaKindArr->new->ValueNodeArr->create->frameState->replaceAndDelete->newFrameState->frameState->getNodeSourcePosition->setNodeSourcePosition->frameStateBuilder->push->else->if->handleReturnMismatch->else->newFrameState->frameStateBuilder->nextBCI->create->newFrameState->frameState->getNodeSourcePosition->setNodeSourcePosition->frameState->replaceAndDelete->else->if->if->graph->start->stateAfter->if->frameState->replaceAndDelete->else->if->callee->isSynchronized->exceptionValue->frameState->stackAt->dispatchState->copy->dispatchState->clearStack->dispatchState->push->dispatchState->setRethrowException->foreach->frameState->usages->newFrameState->dispatchState->parser->bci->create->frameState->replaceAndDelete->newFrameState->frameState->getNodeSourcePosition->setNodeSourcePosition->else->if->if->graph->getGuardsStage->allowsFloatingGuards->throw->GraalError->shouldNotReachHere->else->graph->getDebug->dump
BytecodeParser.InliningScope#handleReturnMismatch(StructuredGraph, FrameState)::: inlining scope handle return mismatch:::throw->GraalError->shouldNotReachHere
BytecodeParser.IntrinsicScope#close()::: intrinsic scope close:::intrinsic->isRootCompilation->if->if->intrinsic->isPostParseInlined->return->intrinsic->isCompilationRoot->else->processPlaceholderFrameStates->if->returnKind->parser->getInvokeReturnType->getJavaKind->returnValue->pop->if->invalidStateUsers->size->invalidStateUsers->get->invalidStateUsers->get->updateSplitFrameState->else->if->returnValues->merge->if->merge->if->invalidStateUsers->remove->updateSplitFrameState->foreach->merge->cfgPredecessors->lastPred->pred->predecessor->if->invalidStateUsers->remove->predReturnValue->if->index->merge->phiPredecessorIndex->valueAt->updateSplitFrameState->if->invalidStateUsers->size->throw->new->GraalError->else->throw->new->GraalError->push
BytecodeParser.IntrinsicScope#updateSplitFrameState(StateSplit, JavaKind, ValueNode)::: intrinsic scope update split frame state:::push->oldState->split->stateAfter->split->parser->nextBCI->createFrameState->setStateAfter->pop->if->oldState->hasNoUsages->oldState->safeDelete
BytecodeParser.IntrinsicScope#handleReturnMismatch(StructuredGraph, FrameState)::: intrinsic scope handle return mismatch:::if->new->ArrayList<>->foreach->fs->usages->if->throw->new->GraalError->invalidStateUsers->add
BytecodeParser.ReturnToCallerData#containsReturnValue(List, ValueNode)::: return to caller data contains return value:::foreach->if->return->return
BytecodeParser#refineTraceLevel(int)::: bytecode parser refine trace level:::tmethod->graph->method->if->filterValue->getValue->if->filters->MethodFilter->parse->if->MethodFilter->matches->return->return
BytecodeParser#getGraphBuilderInstance()::: bytecode parser get graph builder instance:::return
BytecodeParser#getUnwindValue()::: bytecode parser get unwind value:::return
BytecodeParser#getBeforeUnwindNode()::: bytecode parser get before unwind node:::return
BytecodeParser#buildRootMethod()::: bytecode parser build root method:::startFrameState->graphBuilderConfig->retainLocalVariables->new->FrameStateBuilder->startFrameState->graph->getAssumptions->graphBuilderConfig->eagerResolving->graphBuilderConfig->getPlugins->initializeForMethodStart->try->s->new->IntrinsicScope->graph->start->build->catch->finally->cleanupFinalGraph->ComputeLoopFrequenciesClosure->compute
BytecodeParser#build(FixedWithNextNode, FrameStateBuilder)::: bytecode parser build:::if->PrintProfilingInformation->getValue->TTY->method->format->println->TTY->Util->profilingInfo->toString->indent->println->try->indent->debug->logAndIndent->if->bytecodeProvider->shouldRecordMethodDependencies->graph->recordMethod->newMapping->BciBlockMapping->graph->getDebug->create->blockMap->getBlockCount->new->FixedWithNextNodeArr->blockMap->getBlockCount->new->FrameStateBuilderArr->if->method->isStatic->startFrameState->loadLocal->try->s->debug->scope->maxLocals->method->getMaxLocals->LocalLiveness->blockMap->getBlocks->blockMap->getLoopCount->compute->catch->throw->debug->handle->finally->this->setCurrentFrameState->stream->setBCI->startBlock->blockMap->getStartBlock->if->startNode->graph->start->if->method->isSynchronized->startNode->createFrameState->setStateAfter->else->if->parsingIntrinsic->if->graph->method->graph->method->isJavaLangObjectInit->else->frameState->clearNonLiveLocals->startNode->bci->createFrameState->setStateAfter->else->if->startNode->stateAfter->stateAfterStart->createStateAfterStartOfReplacementGraph->startNode->setStateAfter->try->context->openNodeContext->if->method->isSynchronized->finishPrepare->synchronizedObject->frameState->clearNonLiveLocals->bci->genMonitorEnter->profilingPlugin->getPlugins->getProfilingPlugin->if->profilingPlugin->shouldProfile->stateBefore->createCurrentFrameState->profilingPlugin->profileInvoke->finishPrepare->genInfoPointNode->catch->finally->blockMap->getStartBlock->setEntryState->if->startBlock->isLoopHeader->appendGoto->else->setFirstInstruction->blocks->blockMap->getBlocks->foreach->processBlock->catch->finally
BytecodeParser#computeKindVerification(FrameStateBuilder)::: bytecode parser compute kind verification:::if->startFrameState->disableKindVerification->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->canChangeStackKind->startFrameState->disableKindVerification->return
BytecodeParser#finishPrepare(FixedWithNextNode, int, FrameStateBuilder):::Hook for subclasses to modify synthetic code (start nodes and unwind nodes).:::
BytecodeParser#cleanupFinalGraph()::: bytecode parser cleanup final graph:::GraphUtil->normalizeLoops->foreach->graph->getNodes->if->param->hasNoUsages->param->safeDelete->foreach->graph->getNodes->predecessor->beginNode->predecessor->if->else->if->beginNode->hasUsages->GraphUtil->unlinkFixedNode->beginNode->safeDelete->if->graph->isOSR->getParent->graph->getNodes->filter->isEmpty->throw->new->RetryableBailoutException
BytecodeParser#createStateAfterStartOfReplacementGraph():::Creates the frame state after the start node of a graph for an IntrinsicContext intrinsic that is the parse root (either for root compiling or for post-parse inlining).:::stateAfterStart->if->intrinsicContext->isPostParseInlined->graph->new->FrameState->add->else->original->intrinsicContext->getOriginalMethod->locals->if->original->getMaxLocals->frameState->localsSize->original->isNative->original->getMaxLocals->new->ValueNodeArr->for->i->else->original->getMaxLocals->new->ValueNodeArr->parameterCount->original->getSignature->original->isStatic->getParameterCount->for->i->stack->stackSize->locks->monitorIds->Collections->emptyList->graph->new->ResolvedJavaMethodBytecode->new->FrameState->add->return
BytecodeParser#handleUnresolvedLoadConstant(JavaType)::: bytecode parser handle unresolved load constant:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedCheckCast(JavaType, ValueNode)::: bytecode parser handle unresolved check cast:::graph->IsNullNode->create->addOrUniqueWithInputs->new->FixedGuardNode->append->frameState->appendConstant->push
BytecodeParser#handleUnresolvedInstanceOf(JavaType, ValueNode)::: bytecode parser handle unresolved instance of:::successor->graph->new->BeginNode->add->deopt->graph->new->DeoptimizeNode->add->deopt->createBytecodePosition->updateNodeSourcePosition->graph->IsNullNode->create->addOrUniqueWithInputs->new->IfNode->append->frameState->appendConstant->push
BytecodeParser#handleUnresolvedNewInstance(JavaType)::: bytecode parser handle unresolved new instance:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleIllegalNewInstance(JavaType)::: bytecode parser handle illegal new instance:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedNewObjectArray(JavaType, ValueNode)::: bytecode parser handle unresolved new object array:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedNewMultiArray(JavaType, ValueNode[])::: bytecode parser handle unresolved new multi array:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedLoadField(JavaField, ValueNode)::: bytecode parser handle unresolved load field:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedStoreField(JavaField, ValueNode, ValueNode)::: bytecode parser handle unresolved store field:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedExceptionType(JavaType)::: bytecode parser handle unresolved exception type:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleUnresolvedInvoke(JavaMethod, InvokeKind)::: bytecode parser handle unresolved invoke:::deopt->new->DeoptimizeNode->append->deopt->createBytecodePosition->updateNodeSourcePosition
BytecodeParser#handleException(ValueNode, int, boolean)::: bytecode parser handle exception:::currentLastInstr->debug->profilingInfo->getExceptionSeen->log->dispatchState->frameState->copy->dispatchState->clearStack->dispatchBegin->if->newExceptionObject->graph->getMetaAccess->new->ExceptionObjectNode->add->dispatchState->push->dispatchState->setRethrowException->newExceptionObject->dispatchState->create->setStateAfter->else->graph->new->BeginNode->add->dispatchState->push->dispatchState->setRethrowException->afterExceptionLoaded->finishInstruction->if->deoptimizeNode->graph->new->DeoptimizeNode->add->afterExceptionLoaded->BeginNode->begin->setNext->else->createHandleExceptionTarget->return
BytecodeParser#createHandleExceptionTarget(FixedWithNextNode, int, FrameStateBuilder)::: bytecode parser create handle exception target:::afterInstrumentation->foreach->graphBuilderConfig->getPlugins->getNodePlugins->plugin->instrumentExceptionDispatch->dispatchBlock->currentBlock->exceptionDispatchBlock->if->blockMap->getUnwindBlock->target->createTarget->afterInstrumentation->setNext
BytecodeParser#genLoadIndexed(ValueNode, ValueNode, GuardingNode, JavaKind)::: bytecode parser gen load indexed:::return->LoadIndexedNode->graph->getAssumptions->getMetaAccess->getConstantReflection->create
BytecodeParser#genStoreIndexed(ValueNode, ValueNode, GuardingNode, GuardingNode, JavaKind, ValueNode)::: bytecode parser gen store indexed:::new->StoreIndexedNode->add
BytecodeParser#genIntegerAdd(ValueNode, ValueNode)::: bytecode parser gen integer add:::return->AddNode->create
BytecodeParser#genIntegerSub(ValueNode, ValueNode)::: bytecode parser gen integer sub:::return->SubNode->create
BytecodeParser#genIntegerMul(ValueNode, ValueNode)::: bytecode parser gen integer mul:::return->MulNode->create
BytecodeParser#genFloatAdd(ValueNode, ValueNode)::: bytecode parser gen float add:::return->AddNode->create
BytecodeParser#genFloatSub(ValueNode, ValueNode)::: bytecode parser gen float sub:::return->SubNode->create
BytecodeParser#genFloatMul(ValueNode, ValueNode)::: bytecode parser gen float mul:::return->MulNode->create
BytecodeParser#genFloatDiv(ValueNode, ValueNode)::: bytecode parser gen float div:::return->FloatDivNode->create
BytecodeParser#genFloatRem(ValueNode, ValueNode)::: bytecode parser gen float rem:::return->RemNode->create
BytecodeParser#genIntegerDiv(ValueNode, ValueNode, GuardingNode)::: bytecode parser gen integer div:::return->SignedDivNode->create
BytecodeParser#genIntegerRem(ValueNode, ValueNode, GuardingNode)::: bytecode parser gen integer rem:::return->SignedRemNode->create
BytecodeParser#genNegateOp(ValueNode)::: bytecode parser gen negate op:::return->NegateNode->create
BytecodeParser#genLeftShift(ValueNode, ValueNode)::: bytecode parser gen left shift:::return->LeftShiftNode->create
BytecodeParser#genRightShift(ValueNode, ValueNode)::: bytecode parser gen right shift:::return->RightShiftNode->create
BytecodeParser#genUnsignedRightShift(ValueNode, ValueNode)::: bytecode parser gen unsigned right shift:::return->UnsignedRightShiftNode->create
BytecodeParser#genAnd(ValueNode, ValueNode)::: bytecode parser gen and:::return->AndNode->create
BytecodeParser#genOr(ValueNode, ValueNode)::: bytecode parser gen or:::return->OrNode->create
BytecodeParser#genXor(ValueNode, ValueNode)::: bytecode parser gen xor:::return->XorNode->create
BytecodeParser#genNormalizeCompare(ValueNode, ValueNode, boolean)::: bytecode parser gen normalize compare:::return->NormalizeCompareNode->getConstantReflection->create
BytecodeParser#genFloatConvert(FloatConvert, ValueNode)::: bytecode parser gen float convert:::return->FloatConvertNode->create
BytecodeParser#genNarrow(ValueNode, int)::: bytecode parser gen narrow:::return->NarrowNode->create
BytecodeParser#genSignExtend(ValueNode, int)::: bytecode parser gen sign extend:::return->SignExtendNode->create
BytecodeParser#genZeroExtend(ValueNode, int)::: bytecode parser gen zero extend:::return->ZeroExtendNode->create
BytecodeParser#genGoto()::: bytecode parser gen goto:::profilingPlugin->getPlugins->getProfilingPlugin->if->profilingPlugin->shouldProfile->stateBefore->createCurrentFrameState->targetBci->currentBlock->getSuccessor->profilingPlugin->bci->profileGoto->currentBlock->getSuccessor->appendGoto
BytecodeParser#genObjectEquals(ValueNode, ValueNode)::: bytecode parser gen object equals:::return->ObjectEqualsNode->getConstantReflection->getMetaAccess->create
BytecodeParser#genIntegerEquals(ValueNode, ValueNode)::: bytecode parser gen integer equals:::return->IntegerEqualsNode->getConstantReflection->getMetaAccess->create
BytecodeParser#genIntegerLessThan(ValueNode, ValueNode)::: bytecode parser gen integer less than:::return->IntegerLessThanNode->getConstantReflection->getMetaAccess->create
BytecodeParser#genUnique(ValueNode)::: bytecode parser gen unique:::return->graph->addOrUniqueWithInputs
BytecodeParser#genUnique(LogicNode)::: bytecode parser gen unique:::return->graph->addOrUniqueWithInputs
BytecodeParser#genIfNode(LogicNode, FixedNode, FixedNode, double)::: bytecode parser gen if node:::return->new->IfNode
BytecodeParser#genThrow()::: bytecode parser gen throw:::genInfoPointNode->exception->frameState->pop->maybeEmitExplicitNullCheck->if->StampTool->exception->stamp->isPointerNonNull->nullCheck->graph->IsNullNode->create->addOrUniqueWithInputs->new->FixedGuardNode->append->graph->PiNode->exception->stamp->objectNonNull->join->create->maybeAddOrUnique->lastInstr->bci->handleException->setNext
BytecodeParser#createInstanceOf(TypeReference, ValueNode)::: bytecode parser create instance of:::return->InstanceOfNode->create
BytecodeParser#createAnchor(JavaTypeProfile)::: bytecode parser create anchor:::if->profile->getNotRecordedProbability->return->else->return->BeginNode->prevBegin
BytecodeParser#createInstanceOf(TypeReference, ValueNode, JavaTypeProfile)::: bytecode parser create instance of:::return->InstanceOfNode->createAnchor->create
BytecodeParser#createInstanceOfAllowNull(TypeReference, ValueNode, JavaTypeProfile)::: bytecode parser create instance of allow null:::return->InstanceOfNode->createAnchor->createAllowNull
BytecodeParser#genConditional(ValueNode)::: bytecode parser gen conditional:::return->ConditionalNode->create
BytecodeParser#createNewInstance(ResolvedJavaType, boolean)::: bytecode parser create new instance:::return->new->NewInstanceNode
BytecodeParser#createNewArray(ResolvedJavaType, ValueNode, boolean)::: bytecode parser create new array:::return->new->NewArrayNode
BytecodeParser#createNewMultiArray(ResolvedJavaType, ValueNode[])::: bytecode parser create new multi array:::return->new->NewMultiArrayNode
BytecodeParser#genLoadField(ValueNode, ResolvedJavaField)::: bytecode parser gen load field:::stamp->graphBuilderConfig->getPlugins->field->getType->getOverridingStamp->if->return->LoadFieldNode->getConstantFieldProvider->getConstantReflection->getMetaAccess->getOptions->getAssumptions->create->else->return->LoadFieldNode->getConstantFieldProvider->getConstantReflection->getMetaAccess->getOptions->createOverrideStamp
BytecodeParser#genVolatileFieldReadProxy(ValueNode)::: bytecode parser gen volatile field read proxy:::return->new->StateSplitProxyNode
BytecodeParser#maybeEmitExplicitNullCheck(ValueNode)::: bytecode parser maybe emit explicit null check:::if->StampTool->receiver->stamp->isPointerNonNull->needsExplicitNullCheckException->return->condition->IsNullNode->create->genUnique->passingSuccessor->emitBytecodeExceptionCheck->return->PiNode->objectNonNull->create->genUnique
BytecodeParser#maybeEmitExplicitBoundsCheck(ValueNode, ValueNode)::: bytecode parser maybe emit explicit bounds check:::if->needsExplicitBoundsCheckException->return->length->genArrayLength->append->condition->IntegerBelowNode->getConstantReflection->getMetaAccess->create->genUnique->return->emitBytecodeExceptionCheck
BytecodeParser#maybeEmitExplicitStoreCheck(ValueNode, JavaKind, ValueNode)::: bytecode parser maybe emit explicit store check:::if->StampTool->isPointerAlwaysNull->needsExplicitStoreCheckException->return->arrayClass->LoadHubNode->getStampProvider->getMetaAccess->getConstantReflection->create->genUnique->componentHub->LoadArrayComponentHubNode->getStampProvider->getMetaAccess->getConstantReflection->create->append->condition->InstanceOfDynamicNode->graph->getAssumptions->getConstantReflection->create->genUnique->return->emitBytecodeExceptionCheck
BytecodeParser#maybeEmitExplicitDivisionByZeroCheck(ValueNode)::: bytecode parser maybe emit explicit division by zero check:::if->y->stamp->contains->needsExplicitDivisionByZeroException->return->zero->ConstantNode->y->getStackKind->defaultForKind->condition->IntegerEqualsNode->getConstantReflection->getMetaAccess->create->genUnique->return->emitBytecodeExceptionCheck
BytecodeParser#emitBytecodeExceptionCheck(LogicNode, boolean, BytecodeExceptionKind, ValueNode...)::: bytecode parser emit bytecode exception check:::if->condition->isTautology->condition->isContradiction->return->exception->graph->getMetaAccess->new->BytecodeExceptionNode->add->passingSuccessor->graph->new->BeginNode->add->trueSuccessor->falseSuccessor->new->IfNode->append->exception->bci->createFrameState->setStateAfter->exception->bci->handleException->setNext->EXPLICIT_EXCEPTIONS->increment->return
BytecodeParser#genArrayLength(ValueNode)::: bytecode parser gen array length:::return->ArrayLengthNode->getConstantReflection->create
BytecodeParser#genStoreField(ValueNode, ResolvedJavaField, ValueNode)::: bytecode parser gen store field:::storeFieldNode->field->getJavaKind->maskSubWordValue->new->StoreFieldNode->append->storeFieldNode->this->stream->nextBCI->createFrameState->setStateAfter
BytecodeParser#callTargetIsResolved(JavaMethod):::Ensure that concrete classes are at least linked before generating an invoke:::if->resolvedTarget->resolvedType->resolvedTarget->getDeclaringClass->return->resolvedType->isInterface->resolvedType->isLinked->return
BytecodeParser#typeIsResolved(JavaType):::Check if a type is resolved:::return
BytecodeParser#genInvokeStatic(int, int)::: bytecode parser gen invoke static:::target->lookupMethod->genInvokeStatic
BytecodeParser#genInvokeStatic(JavaMethod)::: bytecode parser gen invoke static:::if->callTargetIsResolved->resolvedTarget->holder->resolvedTarget->getDeclaringClass->maybeEagerlyInitialize->classInitializationPlugin->graphBuilderConfig->getPlugins->getClassInitializationPlugin->if->holder->isInitialized->handleUnresolvedInvoke->return->classInit->if->classInitializationPlugin->resolvedTarget->getDeclaringClass->this->createCurrentFrameState->apply->args->frameState->resolvedTarget->getSignature->getParameterCount->popArguments->invoke->appendInvoke->if->invoke->setClassInit->else->handleUnresolvedInvoke
BytecodeParser#createCurrentFrameState():::Creates a frame state for the current parse position.:::return->frameState->bci->getNonIntrinsicAncestor->create
BytecodeParser#genInvokeInterface(int, int)::: bytecode parser gen invoke interface:::target->lookupMethod->genInvokeInterface
BytecodeParser#genInvokeInterface(JavaMethod)::: bytecode parser gen invoke interface:::if->callTargetIsResolved->args->frameState->target->getSignature->getParameterCount->popArguments->appendInvoke->else->handleUnresolvedInvoke
BytecodeParser#genInvokeDynamic(int, int)::: bytecode parser gen invoke dynamic:::target->lookupMethod->genInvokeDynamic
BytecodeParser#genInvokeDynamic(JavaMethod)::: bytecode parser gen invoke dynamic:::if->stream->readCPI4->genDynamicInvokeHelper->handleUnresolvedInvoke
BytecodeParser#genInvokeVirtual(int, int)::: bytecode parser gen invoke virtual:::target->lookupMethod->if->callTargetIsResolved->genInvokeVirtual->else->handleUnresolvedInvoke
BytecodeParser#genInvokeVirtual(ResolvedJavaMethod)::: bytecode parser gen invoke virtual:::cpi->stream->readCPI->if->genDynamicInvokeHelper->return->args->frameState->resolvedTarget->getSignature->getParameterCount->popArguments->appendInvoke
BytecodeParser#genDynamicInvokeHelper(ResolvedJavaMethod, int, int)::: bytecode parser gen dynamic invoke helper:::invokeDynamicPlugin->graphBuilderConfig->getPlugins->getInvokeDynamicPlugin->if->invokeDynamicPlugin->isResolvedDynamicInvoke->return->if->GeneratePIC->getValue->invokeDynamicPlugin->supportsDynamicInvoke->new->DeoptimizeNode->append->return->appendix->constantPool->lookupAppendix->appendixNode->if->if->invokeDynamicPlugin->recordDynamicMethod->stateBefore->createCurrentFrameState->invokeDynamicPlugin->genAppendixNode->else->ConstantNode->getMetaAccess->forConstant->frameState->push->else->if->GeneratePIC->getValue->new->DeoptimizeNode->append->return->hasReceiver->target->isStatic->args->frameState->target->getSignature->getParameterCount->popArguments->if->appendInvoke->else->appendInvoke->return
BytecodeParser#genInvokeSpecial(int, int)::: bytecode parser gen invoke special:::target->lookupMethod->genInvokeSpecial
BytecodeParser#genInvokeSpecial(JavaMethod)::: bytecode parser gen invoke special:::if->callTargetIsResolved->args->frameState->target->getSignature->getParameterCount->popArguments->appendInvoke->else->handleUnresolvedInvoke
BytecodeParser#getInvokeKind()::: bytecode parser get invoke kind:::return
BytecodeParser#getInvokeReturnType()::: bytecode parser get invoke return type:::return
BytecodeParser#handleReplacedInvoke(InvokeKind, ResolvedJavaMethod, ValueNode[], boolean)::: bytecode parser handle replaced invoke:::previous->try->return->appendInvoke->catch->finally
BytecodeParser#handleReplacedInvoke(CallTargetNode, JavaKind)::: bytecode parser handle replaced invoke:::intrinsicCallSiteParser->getNonIntrinsicAncestor->exceptionEdgeAction->getActionForInvokeExceptionEdge->intrinsicCallSiteParser->getActionForInvokeExceptionEdge->bci->createNonInlinedInvoke
BytecodeParser#appendInvoke(InvokeKind, ResolvedJavaMethod, ValueNode[])::: bytecode parser append invoke:::targetMethod->invokeKind->if->initialInvokeKind->isIndirect->contextType->getMethod->getDeclaringClass->specialCallTarget->MethodCallTargetNode->findSpecialCallTarget->if->resultType->targetMethod->getSignature->getReturnKind->if->parsingIntrinsic->DeoptALot->getValue->new->DeoptimizeNode->append->frameState->ConstantNode->defaultForKind->pushReturn->return->returnType->targetMethod->getSignature->method->getDeclaringClass->getReturnType->targetMethod->getDeclaringClass->maybeEagerlyResolve->if->invokeKind->hasReceiver->maybeEmitExplicitNullCheck->if->targetMethod->isConstructor->emitCheckForInvokeSuperSpecial->else->if->targetMethod->isPrivate->targetMethod->getDeclaringClass->emitCheckForDeclaringClassChange->inlineInfo->try->new->CurrentInvoke->if->tryNodePluginForInvocation->if->TraceParserPlugins->getValue->targetMethod->format->traceWithContext->return->if->invokeKind->hasReceiver->isNullConstant->new->DeoptimizeNode->append->return->if->invokeKind->isIndirect->if->tryInvocationPlugin->if->TraceParserPlugins->getValue->targetMethod->format->traceWithContext->return->if->invokeKind->isDirect->tryInline->if->return->catch->finally->invokeBci->bci->profile->getProfileForInvoke->edgeAction->getActionForInvokeExceptionEdge->partialIntrinsicExit->if->intrinsicContext->isCallToOriginal->originalMethod->intrinsicContext->getOriginalMethod->intrinsicCallSiteParser->getNonIntrinsicAncestor->if->intrinsicCallSiteParser->bci->intrinsicCallSiteParser->getProfileForInvoke->intrinsicCallSiteParser->getActionForInvokeExceptionEdge->else->graph->method->getAnnotation->if->originalMethod->isStatic->else->sig->originalMethod->getSignature->sig->method->getDeclaringClass->getReturnType->sig->getReturnKind->invoke->createNonInlinedInvoke->graph->getInliningLog->addDecision->if->invoke->setUseForInlining->return
BytecodeParser#emitCheckForDeclaringClassChange(ResolvedJavaType, ValueNode[]):::Checks that the class of the receiver of an Bytecodes#INVOKEINTERFACE invocation of a private method is assignable to the interface that declared the method:::receiver->checkedType->TypeReference->graph->getAssumptions->createTrusted->condition->createInstanceOf->genUnique->fixedGuard->new->FixedGuardNode->append->PiNode->StampFactory->object->create->append
BytecodeParser#emitCheckForInvokeSuperSpecial(ValueNode[]):::Checks that the class of the receiver of an Bytecodes#INVOKESPECIAL in a method declared in an interface (i.e., a default method) is assignable to the interface:::callingClass->method->getDeclaringClass->if->callingClass->getHostClass->callingClass->getHostClass->if->callingClass->isInterface->receiver->checkedType->TypeReference->graph->getAssumptions->createTrusted->condition->createInstanceOf->genUnique->fixedGuard->new->FixedGuardNode->append->PiNode->StampFactory->object->create->append
BytecodeParser#getProfileForInvoke(InvokeKind)::: bytecode parser get profile for invoke:::if->invokeKind->isIndirect->getOptions->useTypeCheckHints->return->profilingInfo->bci->getTypeProfile->return
BytecodeParser#checkPartialIntrinsicExit(ValueNode[], ValueNode[]):::A partial intrinsic exits by (effectively) calling the intrinsified method:::if->for->i->else->for->i->return
BytecodeParser#createNonInlinedInvoke(ExceptionEdgeAction, int, ValueNode[], ResolvedJavaMethod, InvokeKind, JavaKind, JavaType, JavaTypeProfile)::: bytecode parser create non inlined invoke:::returnStamp->graphBuilderConfig->getPlugins->getOverridingStamp->if->StampFactory->graph->getAssumptions->forDeclaredType->callTarget->graph->createMethodCallTarget->add->invoke->createNonInlinedInvoke->foreach->graphBuilderConfig->getPlugins->getInlineInvokePlugins->plugin->notifyNotInlined->return
BytecodeParser#createNonInlinedInvoke(ExceptionEdgeAction, int, CallTargetNode, JavaKind)::: bytecode parser create non inlined invoke:::if->return->createInvoke->else->invoke->createInvokeWithException->beginNode->graph->KillingBeginNode->LocationIdentity->any->create->add->invoke->setNext->return
BytecodeParser#getActionForInvokeExceptionEdge(InlineInfo)::: bytecode parser get action for invoke exception edge:::if->return->else->if->return->else->if->return->else->if->graphBuilderConfig->getBytecodeExceptionMode->return->else->if->graphBuilderConfig->getBytecodeExceptionMode->return->else->if->graphBuilderConfig->getBytecodeExceptionMode->return->else->if->StressInvokeWithExceptionNode->getValue->if->optimisticOpts->getOptions->useExceptionProbability->if->exceptionSeen->profilingInfo->bci->getExceptionSeen->if->return->return
BytecodeParser.InvocationPluginAssertions#error(String, Object...)::: invocation plugin assertions error:::return->String->format->String->plugin->getMetaAccess->getApplySourceLocation->format
BytecodeParser.InvocationPluginAssertions#check(boolean)::: invocation plugin assertions check:::if->expectedStackSize->resultType->getSlotCount->newNodes->graph->getNewNodes->foreach->if->stateSplit->try->graphBuilderConfig->getPlugins->getInvocationPlugins->checkNewNodes->catch->throw->error->new->AssertionError->finally->else->return
BytecodeParser#tryInvocationPlugin(InvokeKind, ValueNode[], ResolvedJavaMethod, JavaKind)::: bytecode parser try invocation plugin:::plugin->graphBuilderConfig->getPlugins->getInvocationPlugins->lookupInvocation->if->if->intrinsicContext->isCallToOriginal->return->pluginReceiver->invocationPluginReceiver->init->assertions->Assertions->assertionsEnabled->new->InvocationPluginAssertions->try->context->openNodeContext->if->plugin->execute->return->plugin->isDecorator->else->catch->finally->return
BytecodeParser#tryNodePluginForInvocation(ValueNode[], ResolvedJavaMethod)::: bytecode parser try node plugin for invocation:::foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleInvoke->return->return
BytecodeParser#tryInline(ValueNode[], ResolvedJavaMethod):::Try to inline a method:::canBeInlined->parsingIntrinsic->targetMethod->canBeInlined->if->return->if->if->inline->return->else->return->foreach->graphBuilderConfig->getPlugins->getInlineInvokePlugins->inlineInfo->plugin->shouldInlineInvoke->if->if->inlineInfo->allowsInlining->if->inlineInfo->getMethodToInline->inlineInfo->getIntrinsicBytecodeProvider->inline->return->return->if->parsingIntrinsic->if->inline->return->return
BytecodeParser#tryFastInlineAccessor(ValueNode[], ResolvedJavaMethod):::Tries to inline targetMethod if it is an instance field accessor:::bytecode->targetMethod->getCode->if->Bytes->beU1->Bytes->beU1->b4->Bytes->beU1->if->cpi->Bytes->beU2->field->targetMethod->getConstantPool->lookupField->if->receiver->invocationPluginReceiver->init->get->resolvedField->try->context->openNodeContext->genGetField->notifyBeforeInline->printInlining->notifyAfterInline->catch->finally->return->return
BytecodeParser#intrinsify(ResolvedJavaMethod, StructuredGraph, InvocationPlugin.Receiver, ValueNode[]):::Inline a method substitution graph:::if->receiver->get->withException->replacee->try->a->debug->scope->entryPointNode->substituteGraph->start->firstCFGNode->entryPointNode->next->replaceeGraph->replacee->graph->mark->replaceeGraph->getMark->try->inlineScope->new->IntrinsicScope->replacementsMap->EconomicMap->create->foreach->substituteGraph->getNodes->filter->replacementsMap->param->index->put->replacementsMap->AbstractBeginNode->prevBegin->put->debug->substituteGraph->method->dump->duplicates->inlineMethodSubstitution->firstCFGNodeDuplicate->duplicates->get->replacee->setNext->debug->substituteGraph->method->dump->foreach->graph->getNewNodes->if->invoke->if->invoke->bci->invoke->bci->replaceBci->if->intrinsicCallSiteParser->getNonIntrinsicAncestor->if->intrinsicCallSiteParser->getActionForInvokeExceptionEdge->newInvoke->graph->new->InvokeNode->add->newInvoke->withException->stateDuring->setStateDuring->newInvoke->withException->stateAfter->setStateAfter->withException->killExceptionEdge->next->withException->killKillingBegin->pred->withException->predecessor->pred->setNext->withException->setNext->newInvoke->setNext->withException->replaceAndDelete->else->withException->killExceptionEdge->else->if->call->if->call->getBci->call->bci->setBci->if->call->stateAfter->call->stateAfter->call->setStateAfter->calleeReturnDataList->new->ArrayList<>->foreach->substituteGraph->getNodes->filter->returnNode->duplicates->get->predecessor->returnNode->predecessor->calleeReturnDataList->returnNode->result->new->ReturnToCallerData->add->predecessor->setNext->returnNode->safeDelete->processCalleeReturn->catch->finally->if->withException->isAlive->exceptionEdge->bci->handleException->withException->setExceptionEdge->debug->dump->return->catch->throw->debug->handle->finally
BytecodeParser#inlineMethodSubstitution(StructuredGraph, StructuredGraph, EconomicMap)::: bytecode parser inline method substitution:::try->scope->replaceeGraph->getInliningLog->log->replaceeGraph->getInliningLog->if->log->trackNewCallsite->openUpdateScope->entryPointNode->snippet->start->nodes->snippet->getNodeCount->new->ArrayList<>->foreach->snippet->getNodes->if->entryPointNode->stateAfter->nodes->add->duplicates->replaceeGraph->snippet->getNodeCount->addDuplicates->if->replaceeGraph->getInliningLog->snippet->getInliningLog->addLog->return->catch->finally
BytecodeParser#intrinsify(BytecodeProvider, ResolvedJavaMethod, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: bytecode parser intrinsify:::if->receiver->get->res->inline->return
BytecodeParser#inline(ResolvedJavaMethod, ResolvedJavaMethod, BytecodeProvider, ValueNode[])::: bytecode parser inline:::try->scope->graph->getInliningLog->bci->openRootScope->intrinsic->if->graphBuilderConfig->insertFullInfopoints->targetMethod->equals->targetMethod->getModifiers->tryFastInlineAccessor->return->if->intrinsic->isCallToOriginal->if->intrinsic->isCompilationRoot->new->DeoptimizeNode->append->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->return->else->if->intrinsic->getOriginalMethod->isNative->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->return->if->canInlinePartialIntrinsicExit->notifyBeforeInline->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->intrinsic->getOriginalMethod->parseAndInlineCallee->notifyAfterInline->return->else->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->return->else->isIntrinsic->if->new->IntrinsicContext->if->inlinedMethod->hasBytecodes->notifyBeforeInline->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->parseAndInlineCallee->notifyAfterInline->else->printInlining->if->graph->getInliningLog->scope->getInvoke->addDecision->return->return->catch->finally
BytecodeParser#notifyBeforeInline(ResolvedJavaMethod)::: bytecode parser notify before inline:::foreach->graphBuilderConfig->getPlugins->getInlineInvokePlugins->plugin->notifyBeforeInline
BytecodeParser#notifyAfterInline(ResolvedJavaMethod)::: bytecode parser notify after inline:::foreach->graphBuilderConfig->getPlugins->getInlineInvokePlugins->plugin->notifyAfterInline
BytecodeParser#canInlinePartialIntrinsicExit():::Determines if a partial intrinsic exit (i.e., a call to the original method within an intrinsic) can be inlined.:::return->InlinePartialIntrinsicExitDuringParsing->getValue->method->getAnnotation
BytecodeParser#printInlining(ResolvedJavaMethod, ResolvedJavaMethod, boolean, String)::: bytecode parser print inlining:::if->if->TraceInlineDuringParsing->getValue->TraceParserPlugins->getValue->if->targetMethod->equals->inlinedMethod->format->traceWithContext->else->inlinedMethod->format->targetMethod->format->traceWithContext->if->HotSpotPrintInlining->getValue->if->targetMethod->equals->Util->bci->getDepth->printInlining->else->Util->bci->getDepth->targetMethod->format->printInlining
BytecodeParser#traceWithContext(String, Object...)::: bytecode parser trace with context:::where->code->bci->asStackTraceElement->s->getDepth->nSpaces->method->isConstructor->method->format->method->getName->where->getFileName->where->getLineNumber->format->format->TTY->println
BytecodeParser#throwParserError(Throwable)::: bytecode parser throw parser error:::if->throw->bp->res->new->BytecodeParserError->while->res->bp->bci->asStackTraceElement->addContext->throw
BytecodeParser#parseAndInlineCallee(ResolvedJavaMethod, ValueNode[], IntrinsicContext)::: bytecode parser parse and inline callee:::calleeBeforeUnwindNode->calleeUnwindValue->try->s->parsingIntrinsic->new->IntrinsicScope->new->InliningScope->parser->graphBuilderInstance->createBytecodeParser->startFrameState->graphBuilderConfig->retainLocalVariables->new->FrameStateBuilder->if->targetMethod->isStatic->nullCheckedValue->startFrameState->initializeFromArgumentsArray->parser->build->calleeReturnDataList->if->isAfterSideEffect->parsingIntrinsic->foreach->sideEffects->frameState->addSideEffect->processCalleeReturn->parser->getBeforeUnwindNode->if->parser->getUnwindValue->catch->finally->if->calleeBeforeUnwindNode->bci->handleException->setNext
BytecodeParser#processCalleeReturn(ResolvedJavaMethod, InliningScope, List)::: bytecode parser process callee return:::if->else->calleeReturnValue->returnMergeNode->if->if->calleeReturnDataList->size->singleReturnData->calleeReturnDataList->get->else->graph->new->MergeNode->add->ValueMergeUtil->mergeValueProducers->if->frameState->targetMethod->getSignature->getReturnKind->getStackKind->push->if->returnMergeNode->stream->nextBCI->createFrameState->setStateAfter->finishInstruction->return->return
BytecodeParser#createMethodCallTarget(InvokeKind, ResolvedJavaMethod, ValueNode[], StampPair, JavaTypeProfile)::: bytecode parser create method call target:::return->new->MethodCallTargetNode
BytecodeParser#createInvoke(int, CallTargetNode, JavaKind)::: bytecode parser create invoke:::invoke->new->InvokeNode->append->frameState->pushReturn->invoke->stream->nextBCI->createFrameState->setStateAfter->return
BytecodeParser#createInvokeWithException(int, CallTargetNode, JavaKind, ExceptionEdgeAction)::: bytecode parser create invoke with exception:::if->stream->nextBCI->frameState->clearNonLiveLocals->exceptionEdge->bci->handleException->invoke->new->InvokeWithExceptionNode->append->frameState->pushReturn->invoke->stream->nextBCI->createFrameState->setStateAfter->return
BytecodeParser#genReturn(ValueNode, JavaKind)::: bytecode parser gen return:::if->parsingIntrinsic->if->stateSplit->stateAfter->stateSplit->stateAfter->if->stateSplit->hasSideEffect->if->state->if->returnVal->getStackKind->targetMethod->getTargetMethod->new->FrameState->else->new->FrameState->stateAfter->graph->add->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs->else->else->realReturnVal->processReturnValue->frameState->setRethrowException->frameState->clearStack->beforeReturn->if->new->ReturnNode->append->else->if->new->ArrayList<>->returnDataList->new->ReturnToCallerData->add
BytecodeParser#processReturnValue(ValueNode, JavaKind)::: bytecode parser process return value:::returnKind->method->getSignature->getReturnKind->if->stamp->value->stamp->if->stamp->lowerBound->returnKind->getMinValue->returnKind->getMaxValue->stamp->upperBound->return->maskSubWordValue->return
BytecodeParser#beforeReturn(ValueNode, JavaKind)::: bytecode parser before return:::if->graph->method->graph->method->isJavaLangObjectInit->receiver->graph->start->stateAfter->localAt->if->RegisterFinalizerNode->graph->getAssumptions->mayHaveFinalizer->new->RegisterFinalizerNode->append->genInfoPointNode->if->new->FinalFieldBarrierNode->append->synchronizedEpilogue->if->method->isSynchronized->finishPrepare
BytecodeParser#createMonitorEnterNode(ValueNode, MonitorIdNode)::: bytecode parser create monitor enter node:::return->new->MonitorEnterNode
BytecodeParser#genMonitorEnter(ValueNode, int)::: bytecode parser gen monitor enter:::monitorId->graph->frameState->lockDepth->new->MonitorIdNode->add->monitorEnter->createMonitorEnterNode->append->frameState->pushLock->monitorEnter->createFrameState->setStateAfter
BytecodeParser#genMonitorExit(ValueNode, ValueNode, int)::: bytecode parser gen monitor exit:::if->frameState->lockDepth->throw->bailout->monitorId->frameState->peekMonitorId->lockedObject->frameState->popLock->if->GraphUtil->originalValue->GraphUtil->originalValue->throw->String->GraphUtil->originalValue->GraphUtil->originalValue->format->bailout->monitorExit->new->MonitorExitNode->append->monitorExit->createFrameState->setStateAfter
BytecodeParser#genJsr(int)::: bytecode parser gen jsr:::successor->currentBlock->getJsrSuccessor->scope->currentBlock->getJsrScope->nextBci->getStream->nextBCI->if->successor->getJsrScope->pop->equals->throw->new->JsrNotSupportedBailout->if->successor->getJsrScope->nextReturnAddress->throw->new->JsrNotSupportedBailout->nextBciNode->getJsrConstant->frameState->push->appendGoto
BytecodeParser#genRet(int)::: bytecode parser gen ret:::successor->currentBlock->getRetSuccessor->local->frameState->loadLocal->scope->currentBlock->getJsrScope->retAddress->scope->nextReturnAddress->returnBciNode->getJsrConstant->guard->IntegerEqualsNode->getConstantReflection->getMetaAccess->create->graph->addOrUniqueWithInputs->new->FixedGuardNode->append->if->successor->getJsrScope->scope->pop->equals->throw->new->JsrNotSupportedBailout->appendGoto
BytecodeParser#getJsrConstant(long)::: bytecode parser get jsr constant:::nextBciConstant->new->RawConstant->nextBciStamp->StampFactory->forConstant->nextBciNode->new->ConstantNode->return->graph->unique
BytecodeParser#genIntegerSwitch(ValueNode, ArrayList, int[], double[], int[])::: bytecode parser gen integer switch:::if->value->isConstant->constant->value->asConstant->constantValue->constant->asInt->for->i->actualSuccessors->get->appendGoto->else->successorProbabilities->actualSuccessors->size->successorProbabilites->switchNode->actualSuccessors->size->new->IntegerSwitchNode->append->for->i->actualSuccessors->size
BytecodeParser#successorProbabilites(int, int[], double[]):::Helper function that sums up the probabilities of all keys that lead to a specific successor.:::probability->new->doubleArr->for->i->return
BytecodeParser#appendConstant(JavaConstant)::: bytecode parser append constant:::return->ConstantNode->getMetaAccess->forConstant
BytecodeParser#append(T)::: bytecode parser append:::if->v->graph->return->added->graph->addOrUniqueWithInputs->if->updateLastInstruction->return
BytecodeParser#updateLastInstruction(T)::: bytecode parser update last instruction:::if->fixedNode->if->lastInstr->setNext->if->fixedWithNextNode->else
BytecodeParser#checkLoopExit(Target, BciBlock)::: bytecode parser check loop exit:::if->exits->if->firstLoopExit->lastLoopExit->pos->exitLoops->Long->bitCount->new->ArrayList<>->do->lMask->if->exitLoops->blockMap->getLoopHeader->add->while->Collections->new->Comparator<BciBlock>->sort->bci->if->newState->copy->foreach->loopBegin->getFirstInstruction->loopExit->graph->new->LoopExitNode->add->if->lastLoopExit->setNext->if->debug->log->newState->clearNonLiveLocals->newState->getEntryState->insertLoopProxies->loopExit->newState->create->setStateAfter->if->lastLoopExit->setNext->return->new->Target->else->replaceAtPredecessor->lastLoopExit->setNext->return->new->Target->return
BytecodeParser#checkUnwind(FixedNode, BciBlock, FrameStateBuilder)::: bytecode parser check unwind:::if->blockMap->getUnwindBlock->return->new->Target->newState->newState->copy->newState->setRethrowException->if->method->isSynchronized->return->new->Target->originalLast->originalState->holder->new->BeginNode->graph->add->exception->frameState->peekObject->synchronizedEpilogue->lastInstr->setNext->result->holder->next->holder->setNext->holder->safeDelete->return->new->Target
BytecodeParser#getEntryState(BciBlock)::: bytecode parser get entry state:::return
BytecodeParser#setEntryState(BciBlock, FrameStateBuilder)::: bytecode parser set entry state:::
BytecodeParser#setFirstInstruction(BciBlock, FixedWithNextNode)::: bytecode parser set first instruction:::
BytecodeParser#getFirstInstruction(BciBlock)::: bytecode parser get first instruction:::return
BytecodeParser#createTarget(double, BciBlock, FrameStateBuilder)::: bytecode parser create target:::if->isNeverExecutedCode->return->graph->new->DeoptimizeNode->add->else->return->createTarget
BytecodeParser#createTarget(BciBlock, FrameStateBuilder)::: bytecode parser create target:::return->createTarget
BytecodeParser#createTarget(BciBlock, FrameStateBuilder, boolean, boolean)::: bytecode parser create target:::try->context->openNodeContext->if->getFirstInstruction->if->block->getPredecessorCount->block->isLoopHeader->setFirstInstruction->else->graph->new->BeginNode->add->setFirstInstruction->target->getFirstInstruction->checkUnwind->checkLoopExit->result->currentEntryState->state->copy->setEntryState->currentEntryState->clearNonLiveLocals->debug->log->return->if->getFirstInstruction->loopBegin->getFirstInstruction->loopEnd->graph->new->LoopEndNode->add->target->new->Target->checkLoopExit->result->getEntryState->merge->debug->log->return->if->getFirstInstruction->getFirstInstruction->beginNode->getFirstInstruction->end->graph->new->EndNode->add->mergeNode->graph->new->MergeNode->add->next->beginNode->next->if->beginNode->predecessor->beginNode->setNext->else->beginNode->replaceAtPredecessor->beginNode->safeDelete->mergeNode->addForwardEnd->mergeNode->setNext->setFirstInstruction->mergeNode->getFirstInstruction->newEnd->graph->new->EndNode->add->target->checkUnwind->checkLoopExit->result->getEntryState->merge->mergeNode->addForwardEnd->debug->log->return->catch->finally
BytecodeParser#createBlockTarget(double, BciBlock, FrameStateBuilder):::Returns a block begin node with the specified state:::target->createTarget->begin->BeginNode->begin->return
BytecodeParser#synchronizedObject(FrameStateBuilder, ResolvedJavaMethod)::: bytecode parser synchronized object:::if->target->isStatic->return->getConstantReflection->target->getDeclaringClass->asJavaClass->appendConstant->else->return->state->loadLocal
BytecodeParser#processBlock(BciBlock)::: bytecode parser process block:::firstInstruction->getFirstInstruction->if->debug->log->return->try->indent->debug->block->isLoopHeader->logAndIndent->getEntryState->setCurrentFrameState->if->blockMap->getUnwindBlock->frameState->setRethrowException->if->setMergeStateAfter->if->blockMap->getUnwindBlock->handleUnwindBlock->else->if->createExceptionDispatch->else->iterateBytecodesForBlock->catch->finally
BytecodeParser#handleUnwindBlock(ExceptionDispatchBlock)::: bytecode parser handle unwind block:::if->frameState->lockDepth->throw->bailout->finishPrepare->if->createUnwind->else->frameState->pop
BytecodeParser#setMergeStateAfter(BciBlock, FixedWithNextNode)::: bytecode parser set merge state after:::abstractMergeNode->if->abstractMergeNode->stateAfter->bci->if->abstractMergeNode->createFrameState->setStateAfter
BytecodeParser#createUnwind()::: bytecode parser create unwind:::try->context->openNodeContext->exception->frameState->pop->new->UnwindNode->append->catch->finally
BytecodeParser#synchronizedEpilogue(int, ValueNode, JavaKind)::: bytecode parser synchronized epilogue:::try->context->openNodeContext->if->method->isSynchronized->if->frameState->push->genMonitorExit->if->frameState->lockDepth->throw->bailout->catch->finally
BytecodeParser#createExceptionDispatch(ExceptionDispatchBlock)::: bytecode parser create exception dispatch:::try->context->openNodeContext->finishInstruction->if->isCatchAll->block->getSuccessor->appendGoto->return->catchType->getCatchType->if->graphBuilderConfig->eagerResolving->catchTypeCPI->lookupType->if->typeIsResolved->checkedCatchType->TypeReference->graph->getAssumptions->createTrusted->if->graphBuilderConfig->getSkippedExceptionTypes->foreach->graphBuilderConfig->getSkippedExceptionTypes->if->skippedType->checkedCatchType->getType->isAssignableFrom->nextBlock->block->getSuccessorCount->blockMap->getUnwindBlock->block->getSuccessor->exception->trueSuccessor->graph->new->DeoptimizeNode->add->nextDispatch->createTarget->graph->createInstanceOf->addOrUniqueWithInputs->new->IfNode->append->return->nextBlock->block->getSuccessorCount->blockMap->getUnwindBlock->block->getSuccessor->exception->piNodeAnchor->graph->new->BeginNode->add->checkedStamp->StampFactory->objectNonNull->piNode->graph->new->PiNode->addWithoutUnique->frameState->pop->frameState->push->catchSuccessor->block->getSuccessor->createTarget->frameState->pop->frameState->push->nextDispatch->createTarget->piNodeAnchor->setNext->ifNode->graph->createInstanceOf->unique->new->IfNode->append->piNode->ifNode->trueSuccessor->setGuard->else->handleUnresolvedExceptionType->catch->finally
BytecodeParser#appendGoto(BciBlock)::: bytecode parser append goto:::targetInstr->createTarget->if->lastInstr->setNext
BytecodeParser#iterateBytecodesForBlock(BciBlock)::: bytecode parser iterate bytecodes for block:::if->block->isLoopHeader->loopBegin->appendLoopBegin->frameState->forceLoopPhis->stampFromValueForForcedPhis->insertLoopPhis->loopBegin->createFrameState->setStateAfter->setFirstInstruction->frameState->copy->setEntryState->debug->log->else->if->frameState->inferPhiStamps->debug->log->finishInstruction->endBCI->stream->endBCI->stream->setBCI->bci->BytecodesParsed->add->if->graphBuilderConfig->insertFullInfopoints->while->try->context->openNodeContext->if->graphBuilderConfig->insertFullInfopoints->parsingIntrinsic->lnt->getLineNumber->if->genInfoPointNode->opcode->stream->currentBC->if->traceInstruction->if->if->block->getJsrScope->throw->new->JsrNotSupportedBailout->x->new->EntryMarkerNode->append->frameState->graph->new->EntryProxyNode->unique->insertProxies->x->createFrameState->setStateAfter->processBytecode->catch->throw->throw->throwParserError->finally->if->lastInstr->next->break->stream->next->stream->currentBCI->finishInstruction->if->if->block->getSuccessor->appendGoto->break
BytecodeParser#openNodeContext(FrameStateBuilder, int)::: bytecode parser open node context:::if->graph->trackNodeSourcePosition->return->graph->state->createBytecodePosition->withNodeSourcePosition->return
BytecodeParser#openNodeContext(ResolvedJavaMethod)::: bytecode parser open node context:::return->openNodeContext
BytecodeParser#openNodeContext(ResolvedJavaMethod, int)::: bytecode parser open node context:::if->graph->trackNodeSourcePosition->return->graph->createBytecodePosition->new->NodeSourcePosition->withNodeSourcePosition->return
BytecodeParser#openNodeContext()::: bytecode parser open node context:::return->bci->openNodeContext
BytecodeParser#forceLoopPhis()::: bytecode parser force loop phis:::return->graph->isOSR
BytecodeParser#stampFromValueForForcedPhis()::: bytecode parser stamp from value for forced phis:::return
BytecodeParser#checkLastInstruction()::: bytecode parser check last instruction:::if->else->if->stateSplit->if->stateSplit->hasSideEffect->return
BytecodeParser#disableLoopSafepoint()::: bytecode parser disable loop safepoint:::return->parsingIntrinsic
BytecodeParser#appendLoopBegin(FixedWithNextNode, int)::: bytecode parser append loop begin:::try->context->openNodeContext->preLoopEnd->graph->new->EndNode->add->loopBegin->graph->new->LoopBeginNode->add->if->disableLoopSafepoint->loopBegin->disableSafepoint->fixedWithNext->setNext->loopBegin->addForwardEnd->return->catch->finally
BytecodeParser#finishInstruction(FixedWithNextNode, FrameStateBuilder):::Hook for subclasses to modify the last instruction or add other instructions.:::return
BytecodeParser#genInfoPointNode(InfopointReason, ValueNode)::: bytecode parser gen info point node:::if->parsingIntrinsic->graphBuilderConfig->insertFullInfopoints->bci->createFrameState->new->FullInfopointNode->append
BytecodeParser#genIf(ValueNode, Condition, ValueNode)::: bytecode parser gen if:::trueBlock->currentBlock->getSuccessor->falseBlock->currentBlock->getSuccessor->if->appendGoto->return->a->b->trueSuccessor->falseSuccessor->canonicalizedCondition->cond->canonicalize->if->canonicalizedCondition->mustMirror->if->canonicalizedCondition->mustNegate->condition->canonicalizedCondition->getCanonicalCondition->createLogicNode->probability->if->extractInjectedProbability->if->canonicalizedCondition->mustNegate->getProfileProbability->clampProbability->genIf
BytecodeParser#getProfileProbability(boolean)::: bytecode parser get profile probability:::if->return->probability->profilingInfo->bci->getBranchTakenProbability->if->debug->bci->log->return->if->shouldComplementProbability->return
BytecodeParser#extractInjectedProbability(IntegerEqualsNode)::: bytecode parser extract injected probability:::equalsNode->probabilityNode->other->if->equalsNode->getX->equalsNode->getX->equalsNode->getY->else->if->equalsNode->getY->equalsNode->getY->equalsNode->getX->if->probabilityNode->getProbability->isConstant->other->isConstant->probabilityValue->probabilityNode->getProbability->asJavaConstant->asDouble->return->other->asJavaConstant->asInt->return
BytecodeParser#genIf(LogicNode, BciBlock, BciBlock, double)::: bytecode parser gen if:::trueBlock->falseBlock->condition->probability->stateBefore->profilingPlugin->getPlugins->getProfilingPlugin->if->profilingPlugin->shouldProfile->createCurrentFrameState->if->logicNegationNode->tmpBlock->if->shouldComplementProbability->logicNegationNode->getValue->if->genConstantTargetIf->else->if->condition->graph->genUnique->deoptBlock->noDeoptBlock->if->isNeverExecutedCode->else->if->isNeverExecutedCode->if->currentPosition->graph->currentNodeSourcePosition->survivingSuccessorPosition->if->graph->trackNodeSourcePosition->currentPosition->getCaller->currentPosition->getMethod->new->NodeSourcePosition->negated->if->isPotentialCountedLoopExit->if->profilingPlugin->shouldProfile->profilingPlugin->bci->profileGoto->new->FixedGuardNode->append->appendGoto->else->noDeoptSuccessor->createTarget->deopt->graph->new->DeoptimizeNode->add->deoptSuccessor->BeginNode->begin->ifNode->genIfNode->postProcessIfNode->append->return->if->profilingPlugin->shouldProfile->profilingPlugin->bci->profileIf->oldBci->stream->currentBCI->trueBlockInt->checkPositiveIntConstantPushed->if->falseBlockInt->checkPositiveIntConstantPushed->if->if->tryGenConditionalForIf->return->trueSuccessor->createTarget->falseSuccessor->createTarget->ifNode->genIfNode->postProcessIfNode->append
BytecodeParser#isPotentialCountedLoopExit(LogicNode, BciBlock)::: bytecode parser is potential counted loop exit:::if->exits->if->return->return
BytecodeParser#shouldComplementProbability():::Hook for subclasses to decide whether the IfNode probability should be complemented during conversion to Graal IR.:::return
BytecodeParser#postProcessIfNode(ValueNode):::Hook for subclasses to generate custom nodes before an IfNode.:::
BytecodeParser#tryGenConditionalForIf(BciBlock, BciBlock, LogicNode, int, int, int)::: bytecode parser try gen conditional for if:::if->gotoOrFallThroughAfterConstant->gotoOrFallThroughAfterConstant->trueBlock->getSuccessor->falseBlock->getSuccessor->genConditionalForIf->return->else->if->returnAfterConstant->returnAfterConstant->genConditionalForIf->return->return
BytecodeParser#genConditionalForIf(BciBlock, LogicNode, int, int, int, boolean)::: bytecode parser gen conditional for if:::trueValue->graph->ConstantNode->forInt->unique->falseValue->graph->ConstantNode->forInt->unique->conditionalNode->ConditionalNode->create->if->conditionalNode->graph->graph->addOrUniqueWithInputs->if->returnKind->method->getSignature->getReturnKind->getStackKind->this->genReturn->else->frameState->push->trueBlock->getSuccessor->appendGoto->stream->setBCI
BytecodeParser#createLogicNode(CanonicalCondition, ValueNode, ValueNode)::: bytecode parser create logic node:::switch->if->a->getStackKind->return->genObjectEquals->else->return->genIntegerEquals->return->genIntegerLessThan->throw->GraalError->shouldNotReachHere
BytecodeParser#genConstantTargetIf(BciBlock, BciBlock, LogicNode)::: bytecode parser gen constant target if:::constantLogicNode->value->constantLogicNode->getValue->nextBlock->if->startBci->targetAtStart->stream->readUByte->if->nextBlock->getPredecessorCount->successorBlock->get->profilingPlugin->graphBuilderConfig->getPlugins->getProfilingPlugin->if->profilingPlugin->shouldProfile->stateBefore->createCurrentFrameState->profilingPlugin->bci->profileGoto->appendGoto->else->profilingPlugin->graphBuilderConfig->getPlugins->getProfilingPlugin->if->profilingPlugin->shouldProfile->stateBefore->createCurrentFrameState->profilingPlugin->bci->profileGoto->appendGoto
BytecodeParser#checkPositiveIntConstantPushed(BciBlock)::: bytecode parser check positive int constant pushed:::stream->setBCI->currentBC->stream->currentBC->if->constValue->return->return
BytecodeParser#gotoOrFallThroughAfterConstant(BciBlock)::: bytecode parser goto or fall through after constant:::stream->setBCI->currentBCI->stream->nextBCI->stream->setBCI->currentBC->stream->currentBC->return->stream->currentBCI
BytecodeParser#returnAfterConstant(BciBlock)::: bytecode parser return after constant:::stream->setBCI->currentBCI->stream->nextBCI->stream->setBCI->currentBC->stream->currentBC->return
BytecodeParser#getStampProvider()::: bytecode parser get stamp provider:::return->providers->getStampProvider
BytecodeParser#getMetaAccess()::: bytecode parser get meta access:::return->providers->getMetaAccess
BytecodeParser#getReplacements()::: bytecode parser get replacements:::return->providers->getReplacements
BytecodeParser#push(JavaKind, ValueNode)::: bytecode parser push:::frameState->push
BytecodeParser#pop(JavaKind)::: bytecode parser pop:::return->frameState->pop
BytecodeParser#getConstantReflection()::: bytecode parser get constant reflection:::return->providers->getConstantReflection
BytecodeParser#getConstantFieldProvider()::: bytecode parser get constant field provider:::return->providers->getConstantFieldProvider
BytecodeParser#getGraph():::Gets the graph being processed by this builder.:::return
BytecodeParser#getParent()::: bytecode parser get parent:::return
BytecodeParser#getIntrinsic()::: bytecode parser get intrinsic:::return
BytecodeParser#toString()::: bytecode parser to string:::fmt->new->Formatter->bp->indent->while->if->fmt->format->fmt->bp->bci->asStackTraceElement->bp->bci->bp->parsingIntrinsic->format->fmt->new->BytecodeDisassembler->bp->bci->bp->bci->disassemble->format->return->fmt->toString
BytecodeParser#bailout(String)::: bytecode parser bailout:::currentFrameState->bci->createFrameState->elements->GraphUtil->approxSourceStackTraceElement->bailout->new->PermanentBailoutException->throw->GraphUtil->createBailoutException
BytecodeParser#createFrameState(int, StateSplit)::: bytecode parser create frame state:::if->frameState->clearNonLiveLocals->return->frameState->create
BytecodeParser#setStateAfter(StateSplit)::: bytecode parser set state after:::stateAfter->stream->nextBCI->createFrameState->sideEffect->setStateAfter
BytecodeParser#createBytecodePosition()::: bytecode parser create bytecode position:::bytecodePosition->frameState->bci->createBytecodePosition->return
BytecodeParser#setCurrentFrameState(FrameStateBuilder)::: bytecode parser set current frame state:::
BytecodeParser#getStream()::: bytecode parser get stream:::return
BytecodeParser#bci()::: bytecode parser bci:::return->stream->currentBCI
BytecodeParser#loadLocal(int, JavaKind)::: bytecode parser load local:::value->frameState->loadLocal->frameState->push
BytecodeParser#loadLocalObject(int)::: bytecode parser load local object:::value->frameState->loadLocal->nextBCI->stream->nextBCI->nextBC->stream->readUByte->if->stream->next->try->ignored->openNodeContext->stream->readCPI->genGetField->catch->finally->else->frameState->push
BytecodeParser#storeLocal(JavaKind, int)::: bytecode parser store local:::value->frameState->pop->frameState->storeLocal
BytecodeParser#genLoadConstant(int, int)::: bytecode parser gen load constant:::con->lookupConstant->if->type->if->typeIsResolved->frameState->getConstantReflection->asJavaClass->appendConstant->push->else->handleUnresolvedLoadConstant->else->if->constant->frameState->constant->getJavaKind->appendConstant->push->else->throw->new->Error
BytecodeParser#refineComponentType(ValueNode, JavaKind)::: bytecode parser refine component type:::if->type->array->stamp->getMetaAccess->javaType->if->type->isArray->componentType->type->getComponentType->if->refinedKind->componentType->getJavaKind->return->return
BytecodeParser#genLoadIndexed(JavaKind)::: bytecode parser gen load indexed:::index->frameState->pop->array->frameState->pop->maybeEmitExplicitNullCheck->boundsCheck->maybeEmitExplicitBoundsCheck->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleLoadIndexed->return->actualKind->refineComponentType->frameState->genLoadIndexed->append->push
BytecodeParser#genStoreIndexed(JavaKind)::: bytecode parser gen store indexed:::value->frameState->pop->index->frameState->pop->array->frameState->pop->maybeEmitExplicitNullCheck->boundsCheck->maybeEmitExplicitBoundsCheck->storeCheck->maybeEmitExplicitStoreCheck->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleStoreIndexed->return->actualKind->refineComponentType->maskSubWordValue->genStoreIndexed
BytecodeParser#genArithmeticOp(JavaKind, int)::: bytecode parser gen arithmetic op:::y->frameState->pop->x->frameState->pop->v->switch->genIntegerAdd->break->genFloatAdd->break->genIntegerSub->break->genFloatSub->break->genIntegerMul->break->genFloatMul->break->genFloatDiv->break->genFloatRem->break->throw->shouldNotReachHere->frameState->append->push
BytecodeParser#genIntegerDivOp(JavaKind, int)::: bytecode parser gen integer div op:::y->frameState->pop->x->frameState->pop->zeroCheck->maybeEmitExplicitDivisionByZeroCheck->v->switch->genIntegerDiv->break->genIntegerRem->break->throw->shouldNotReachHere->frameState->append->push
BytecodeParser#genNegateOp(JavaKind)::: bytecode parser gen negate op:::x->frameState->pop->frameState->genNegateOp->append->push
BytecodeParser#genShiftOp(JavaKind, int)::: bytecode parser gen shift op:::s->frameState->pop->x->frameState->pop->v->switch->genLeftShift->break->genRightShift->break->genUnsignedRightShift->break->throw->shouldNotReachHere->frameState->append->push
BytecodeParser#genLogicOp(JavaKind, int)::: bytecode parser gen logic op:::y->frameState->pop->x->frameState->pop->v->switch->genAnd->break->genOr->break->genXor->break->throw->shouldNotReachHere->frameState->append->push
BytecodeParser#genCompareOp(JavaKind, boolean)::: bytecode parser gen compare op:::y->frameState->pop->x->frameState->pop->frameState->genNormalizeCompare->append->push
BytecodeParser#genFloatConvert(FloatConvert, JavaKind, JavaKind)::: bytecode parser gen float convert:::input->frameState->pop->frameState->genFloatConvert->append->push
BytecodeParser#genSignExtend(JavaKind, JavaKind)::: bytecode parser gen sign extend:::input->frameState->pop->if->from->getStackKind->from->getBitCount->genNarrow->append->frameState->to->getBitCount->genSignExtend->append->push
BytecodeParser#genZeroExtend(JavaKind, JavaKind)::: bytecode parser gen zero extend:::input->frameState->pop->if->from->getStackKind->from->getBitCount->genNarrow->append->frameState->to->getBitCount->genZeroExtend->append->push
BytecodeParser#genNarrow(JavaKind, JavaKind)::: bytecode parser gen narrow:::input->frameState->pop->frameState->to->getBitCount->genNarrow->append->push
BytecodeParser#genIncrement()::: bytecode parser gen increment:::index->getStream->readLocalIndex->delta->getStream->readIncrement->x->frameState->loadLocal->y->JavaConstant->forInt->appendConstant->frameState->genIntegerAdd->append->storeLocal
BytecodeParser#genIfZero(Condition)::: bytecode parser gen if zero:::y->appendConstant->x->frameState->pop->genIf
BytecodeParser#genIfNull(Condition)::: bytecode parser gen if null:::y->appendConstant->x->frameState->pop->genIf
BytecodeParser#genIfSame(JavaKind, Condition)::: bytecode parser gen if same:::y->frameState->pop->x->frameState->pop->genIf
BytecodeParser#initialize(ResolvedJavaType)::: bytecode parser initialize:::synchronized->resolvedType->initialize
BytecodeParser#lookupType(int, int)::: bytecode parser lookup type:::maybeEagerlyResolve->result->constantPool->lookupType->return
BytecodeParser#unresolvedMethodAssertionMessage(JavaMethod)::: bytecode parser unresolved method assertion message:::message->result->format->if->declaringClass->result->getDeclaringClass->className->declaringClass->getName->switch->switch->result->getName->returnType->result->getSignature->getReturnType->toJavaName->if->returnType->declaringClass->toJavaName->equals->String->method->getDeclaringClass->toClassName->format->break->return
BytecodeParser#lookupMethod(int, int)::: bytecode parser lookup method:::maybeEagerlyResolve->result->constantPool->lookupMethod->return
BytecodeParser#lookupField(int, int)::: bytecode parser lookup field:::maybeEagerlyResolve->result->constantPool->lookupField->return->lookupField
BytecodeParser#lookupField(JavaField)::: bytecode parser lookup field:::if->parsingIntrinsic->if->declaringClass->getDeclaringClass->if->declaringClass->isInitialized->initialize->return
BytecodeParser#lookupConstant(int, int)::: bytecode parser lookup constant:::maybeEagerlyResolve->result->constantPool->lookupConstant->return
BytecodeParser#maybeEagerlyResolve(int, int)::: bytecode parser maybe eagerly resolve:::if->constantPool->loadReferencedType->else->if->graphBuilderConfig->eagerResolving->synchronized->classInitializationPlugin->graphBuilderConfig->getPlugins->getClassInitializationPlugin->if->classInitializationPlugin->loadReferencedType->else->constantPool->loadReferencedType
BytecodeParser#maybeEagerlyResolve(JavaType, ResolvedJavaType)::: bytecode parser maybe eagerly resolve:::if->graphBuilderConfig->eagerResolving->parsingIntrinsic->return->type->resolve->return
BytecodeParser#maybeEagerlyInitialize(ResolvedJavaType)::: bytecode parser maybe eagerly initialize:::if->resolvedType->isInitialized->initialize
BytecodeParser#getProfileForTypeCheck(TypeReference)::: bytecode parser get profile for type check:::if->parsingIntrinsic->optimisticOpts->getOptions->useTypeCheckHints->type->isExact->return->else->return->profilingInfo->bci->getTypeProfile
BytecodeParser#genCheckCast(int)::: bytecode parser gen check cast:::type->lookupType->object->frameState->pop->genCheckCast
BytecodeParser#genCheckCast(JavaType, ValueNode)::: bytecode parser gen check cast:::if->typeIsResolved->genCheckCast->else->handleUnresolvedCheckCast
BytecodeParser#genCheckCast(ResolvedJavaType, ValueNode)::: bytecode parser gen check cast:::object->checkedType->TypeReference->graph->getAssumptions->createTrusted->profile->getProfileForTypeCheck->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->checkedType->getType->handleCheckCast->return->castNode->if->if->profile->getNullSeen->isFalse->nullCheckedValue->singleType->profile->asSingleType->if->checkedType->getType->isAssignableFrom->typeCheck->TypeReference->createExactTrusted->createInstanceOf->append->if->typeCheck->isTautology->else->fixedGuard->new->FixedGuardNode->append->PiNode->StampFactory->TypeReference->createExactTrusted->objectNonNull->create->append->nonNull->object->stamp->nonNull->if->condition->createInstanceOfAllowNull->genUnique->if->condition->isTautology->else->guard->if->needsExplicitClassCastException->hub->getConstantReflection->asObjectHub->hubStamp->getStampProvider->StampFactory->TypeReference->createExactTrusted->object->createHubStamp->hubConstant->ConstantNode->getMetaAccess->forConstant->emitBytecodeExceptionCheck->else->new->FixedGuardNode->append->PiNode->StampFactory->object->guard->asNode->create->append->frameState->push
BytecodeParser#genInstanceOf(int)::: bytecode parser gen instance of:::type->lookupType->object->frameState->pop->genInstanceOf
BytecodeParser#genInstanceOf(JavaType, ValueNode)::: bytecode parser gen instance of:::if->typeIsResolved->genInstanceOf->else->handleUnresolvedInstanceOf
BytecodeParser#genInstanceOf(ResolvedJavaType, ValueNode)::: bytecode parser gen instance of:::object->checkedType->TypeReference->graph->getAssumptions->createTrusted->profile->getProfileForTypeCheck->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->checkedType->getType->handleInstanceOf->return->instanceOfNode->if->if->profile->getNullSeen->isFalse->nullCheckedValue->singleType->profile->asSingleType->if->typeCheck->TypeReference->createExactTrusted->createInstanceOf->append->if->typeCheck->isTautology->new->FixedGuardNode->append->LogicConstantNode->checkedType->getType->isAssignableFrom->forBoolean->if->createInstanceOf->logicNode->genUnique->next->getStream->nextBCI->value->getStream->readUByte->if->getStream->next->firstSucc->currentBlock->getSuccessor->secondSucc->currentBlock->getSuccessor->if->negate->if->tmp->getProfileProbability->genIf->else->appendGoto->else->frameState->genConditional->append->push
BytecodeParser#genNewInstance(int)::: bytecode parser gen new instance:::type->lookupType->genNewInstance
BytecodeParser#genNewInstance(JavaType)::: bytecode parser gen new instance:::if->typeIsResolved->genNewInstance->else->handleUnresolvedNewInstance
BytecodeParser#genNewInstance(ResolvedJavaType)::: bytecode parser gen new instance:::if->resolvedType->isAbstract->resolvedType->isInterface->handleIllegalNewInstance->return->maybeEagerlyInitialize->classInitializationPlugin->graphBuilderConfig->getPlugins->getClassInitializationPlugin->if->resolvedType->isInitialized->handleIllegalNewInstance->return->foreach->getSkippedExceptionTypes->if->exceptionType->isAssignableFrom->new->DeoptimizeNode->append->return->if->classInitializationPlugin->this->createCurrentFrameState->apply->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleNewInstance->return->frameState->createNewInstance->append->push
BytecodeParser#arrayTypeCodeToClass(int):::Gets the kind of array elements for the array type code that appears in a Bytecodes#NEWARRAY bytecode.:::switch->return->return->return->return->return->return->return->return->throw->new->IllegalArgumentException
BytecodeParser#genNewPrimitiveArray(int)::: bytecode parser gen new primitive array:::elementType->getMetaAccess->arrayTypeCodeToClass->lookupJavaType->length->frameState->pop->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleNewArray->return->frameState->createNewArray->append->push
BytecodeParser#genNewObjectArray(int)::: bytecode parser gen new object array:::type->lookupType->genNewObjectArray
BytecodeParser#genNewObjectArray(JavaType)::: bytecode parser gen new object array:::if->typeIsResolved->genNewObjectArray->else->length->frameState->pop->handleUnresolvedNewObjectArray
BytecodeParser#genNewObjectArray(ResolvedJavaType)::: bytecode parser gen new object array:::classInitializationPlugin->getPlugins->getClassInitializationPlugin->if->classInitializationPlugin->resolvedType->getArrayClass->this->createCurrentFrameState->apply->length->frameState->pop->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleNewArray->return->frameState->createNewArray->append->push
BytecodeParser#genNewMultiArray(int)::: bytecode parser gen new multi array:::type->lookupType->rank->getStream->bci->readUByte->dims->new->ValueNodeArr->genNewMultiArray
BytecodeParser#genNewMultiArray(JavaType, int, ValueNode[])::: bytecode parser gen new multi array:::if->typeIsResolved->genNewMultiArray->else->for->i->handleUnresolvedNewMultiArray
BytecodeParser#genNewMultiArray(ResolvedJavaType, int, ValueNode[])::: bytecode parser gen new multi array:::classInitializationPlugin->getPlugins->getClassInitializationPlugin->if->classInitializationPlugin->this->createCurrentFrameState->apply->for->i->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleNewMultiArray->return->frameState->createNewMultiArray->append->push
BytecodeParser#genGetField(int, int)::: bytecode parser gen get field:::frameState->pop->genGetField
BytecodeParser#genGetField(int, int, ValueNode)::: bytecode parser gen get field:::field->lookupField->genGetField
BytecodeParser#genGetField(JavaField, ValueNode)::: bytecode parser gen get field:::if->receiver->maybeEmitExplicitNullCheck->resolvedField->genGetField->else->handleUnresolvedLoadField
BytecodeParser#genGetField(ResolvedJavaField, ValueNode)::: bytecode parser gen get field:::if->parsingIntrinsic->GeneratePIC->getOptions->getValue->graph->recordField->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleLoadField->return->fieldRead->genLoadField->append->if->resolvedField->getDeclaringClass->getName->equals->resolvedField->getName->equals->referentIdentity->new->FieldLocationIdentity->new->MembarNode->append->fieldKind->resolvedField->getJavaKind->pushLoadField
BytecodeParser#needsExplicitNullCheckException(ValueNode):::Returns true if an explicit null check should be emitted for the given object.:::return->needsExplicitException
BytecodeParser#needsExplicitBoundsCheckException(ValueNode, ValueNode):::Returns true if an explicit null check should be emitted for the given object.:::return->needsExplicitException
BytecodeParser#needsExplicitClassCastException(ValueNode):::Returns true if an explicit check for a ClassCastException should be emitted for the given object.:::return->needsExplicitException
BytecodeParser#needsExplicitStoreCheckException(ValueNode, ValueNode):::Returns true if an explicit null check should be emitted for the given object.:::return->needsExplicitException
BytecodeParser#needsExplicitDivisionByZeroException(ValueNode):::Returns true if an explicit null check should be emitted for the given object.:::return->needsExplicitException
BytecodeParser#needsExplicitException()::: bytecode parser needs explicit exception:::exceptionMode->graphBuilderConfig->getBytecodeExceptionMode->if->StressExplicitExceptionCode->getValue->return->else->if->return->profilingInfo->bci->getExceptionSeen->return
BytecodeParser#genExplicitExceptionEdge(BytecodeExceptionKind)::: bytecode parser gen explicit exception edge:::exceptionNode->graph->getMetaAccess->new->BytecodeExceptionNode->add->exceptionNode->bci->createFrameState->setStateAfter->exceptionDispatch->bci->handleException->exceptionNode->setNext->return->BeginNode->begin
BytecodeParser#genPutField(int, int)::: bytecode parser gen put field:::field->lookupField->genPutField
BytecodeParser#genPutField(JavaField)::: bytecode parser gen put field:::frameState->field->getJavaKind->pop->genPutField
BytecodeParser#genPutField(JavaField, ValueNode)::: bytecode parser gen put field:::receiverInput->frameState->pop->if->receiver->maybeEmitExplicitNullCheck->resolvedField->if->parsingIntrinsic->GeneratePIC->getOptions->getValue->graph->recordField->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleStoreField->return->if->resolvedField->isFinal->method->isConstructor->genStoreField->else->handleUnresolvedStoreField
BytecodeParser#genGetStatic(int, int)::: bytecode parser gen get static:::field->lookupField->genGetStatic
BytecodeParser#genGetStatic(JavaField)::: bytecode parser gen get static:::resolvedField->resolveStaticFieldAccess->if->return->if->parsingIntrinsic->GeneratePIC->getOptions->getValue->graph->recordField->if->resolvedField->isSynthetic->resolvedField->getName->startsWith->if->parsingIntrinsic->throw->new->GraalError->else->if->graphBuilderConfig->omitAssertions->frameState->field->getJavaKind->ConstantNode->forBoolean->push->return->holder->resolvedField->getDeclaringClass->classInitializationPlugin->getPlugins->getClassInitializationPlugin->if->classInitializationPlugin->this->createCurrentFrameState->apply->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleLoadStaticField->return->fieldRead->genLoadField->append->fieldKind->resolvedField->getJavaKind->pushLoadField
BytecodeParser#pushLoadField(ResolvedJavaField, ValueNode, JavaKind):::Pushes a loaded field onto the stack:::if->resolvedField->isVolatile->readProxy->genVolatileFieldReadProxy->append->frameState->push->readProxy->frameState->stream->nextBCI->create->setStateAfter->else->frameState->push
BytecodeParser#resolveStaticFieldAccess(JavaField, ValueNode)::: bytecode parser resolve static field access:::if->resolvedField->resolvedType->resolvedField->getDeclaringClass->maybeEagerlyInitialize->if->resolvedType->isInitialized->graphBuilderConfig->getPlugins->getClassInitializationPlugin->return->if->resolvedType->isInterface->resolvedType->method->getDeclaringClass->isAssignableFrom->if->method->isClassInitializer->method->isConstructor->return->if->handleUnresolvedLoadField->else->handleUnresolvedStoreField->return
BytecodeParser#genPutStatic(int, int)::: bytecode parser gen put static:::field->lookupField->genPutStatic
BytecodeParser#genPutStatic(JavaField)::: bytecode parser gen put static:::stackSizeBefore->frameState->stackSize->value->frameState->field->getJavaKind->pop->resolvedField->resolveStaticFieldAccess->if->return->if->parsingIntrinsic->GeneratePIC->getOptions->getValue->graph->recordField->classInitializationPlugin->getPlugins->getClassInitializationPlugin->holder->resolvedField->getDeclaringClass->if->stateBefore->pushedSlotKinds->field->getJavaKind->pushedValues->fs->frameState->bci->getNonIntrinsicAncestor->create->return->classInitializationPlugin->apply->foreach->graphBuilderConfig->getPlugins->getNodePlugins->if->plugin->handleStoreStaticField->return->genStoreField
BytecodeParser#switchProbability(int, int)::: bytecode parser switch probability:::prob->profilingInfo->getSwitchProbabilities->if->else->debug->log->new->doubleArr->for->i->return
BytecodeParser#allPositive(double[])::: bytecode parser all positive:::foreach->if->return->return
BytecodeParser#genSwitch(BytecodeSwitch)::: bytecode parser gen switch:::bci->bci->value->frameState->pop->nofCases->bs->numberOfCases->nofCasesPlusDefault->keyProbabilities->switchProbability->bciToBlockSuccessorIndex->EconomicMap->create->for->i->currentBlock->getSuccessorCount->actualSuccessors->new->ArrayList<>->keys->new->intArr->keySuccessors->new->intArr->deoptSuccessorIndex->nextSuccessorIndex->constantValue->value->isConstant->for->i->if->connectedCases->new->intArr->for->i->for->i->genIntegerSwitch
BytecodeParser#isNeverExecutedCode(double)::: bytecode parser is never executed code:::return->optimisticOpts->getOptions->removeNeverExecutedCode
BytecodeParser#clampProbability(double)::: bytecode parser clamp probability:::if->optimisticOpts->getOptions->removeNeverExecutedCode->if->return->else->if->return->return
BytecodeParser#assertAtIfBytecode()::: bytecode parser assert at if bytecode:::bytecode->stream->currentBC->switch->return->return
BytecodeParser#processBytecode(int, int)::: bytecode parser process bytecode:::cpi->switch->break->frameState->appendConstant->push->break->frameState->JavaConstant->forInt->appendConstant->push->break->frameState->JavaConstant->forLong->appendConstant->push->break->frameState->JavaConstant->forFloat->appendConstant->push->break->frameState->JavaConstant->forDouble->appendConstant->push->break->frameState->JavaConstant->stream->readByte->forInt->appendConstant->push->break->frameState->JavaConstant->stream->readShort->forInt->appendConstant->push->break->stream->readCPI->genLoadConstant->break->stream->readLocalIndex->loadLocal->break->stream->readLocalIndex->loadLocal->break->stream->readLocalIndex->loadLocal->break->stream->readLocalIndex->loadLocal->break->stream->readLocalIndex->loadLocalObject->break->loadLocal->break->loadLocal->break->loadLocal->break->loadLocal->break->loadLocalObject->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->genLoadIndexed->break->stream->readLocalIndex->storeLocal->break->stream->readLocalIndex->storeLocal->break->stream->readLocalIndex->storeLocal->break->stream->readLocalIndex->storeLocal->break->stream->readLocalIndex->storeLocal->break->storeLocal->break->storeLocal->break->storeLocal->break->storeLocal->break->storeLocal->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->genStoreIndexed->break->frameState->stackOp->break->genArithmeticOp->break->genIntegerDivOp->break->genArithmeticOp->break->genIntegerDivOp->break->genArithmeticOp->break->genArithmeticOp->break->genNegateOp->break->genNegateOp->break->genNegateOp->break->genNegateOp->break->genShiftOp->break->genLogicOp->break->genShiftOp->break->genLogicOp->break->genIncrement->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genFloatConvert->break->genNarrow->break->genSignExtend->break->genSignExtend->break->genSignExtend->break->genZeroExtend->break->genCompareOp->break->genCompareOp->break->genCompareOp->break->genCompareOp->break->genCompareOp->break->genIfZero->break->genIfZero->break->genIfZero->break->genIfZero->break->genIfZero->break->genIfZero->break->genIfSame->break->genIfSame->break->genIfSame->break->genIfSame->break->genIfSame->break->genIfSame->break->genIfSame->break->genIfSame->break->genGoto->break->stream->readBranchDest->genJsr->break->stream->readLocalIndex->genRet->break->getStream->bci->new->BytecodeTableSwitch->genSwitch->break->getStream->bci->new->BytecodeLookupSwitch->genSwitch->break->frameState->pop->genReturn->break->frameState->pop->genReturn->break->frameState->pop->genReturn->break->frameState->pop->genReturn->break->frameState->pop->genReturn->break->genReturn->break->stream->readCPI->genGetStatic->break->stream->readCPI->genPutStatic->break->stream->readCPI->genGetField->break->stream->readCPI->genPutField->break->stream->readCPI->genInvokeVirtual->break->stream->readCPI->genInvokeSpecial->break->stream->readCPI->genInvokeStatic->break->stream->readCPI->genInvokeInterface->break->stream->readCPI4->genInvokeDynamic->break->stream->readCPI->genNewInstance->break->stream->readLocalIndex->genNewPrimitiveArray->break->stream->readCPI->genNewObjectArray->break->genArrayLength->break->genThrow->break->stream->readCPI->genCheckCast->break->stream->readCPI->genInstanceOf->break->frameState->pop->stream->nextBCI->genMonitorEnter->break->frameState->pop->stream->nextBCI->genMonitorExit->break->stream->readCPI->genNewMultiArray->break->genIfNull->break->genIfNull->break->genGoto->break->stream->readBranchDest->genJsr->break->throw->new->PermanentBailoutException->throw->nameOf->new->PermanentBailoutException
BytecodeParser#genArrayLength()::: bytecode parser gen array length:::array->frameState->pop->maybeEmitExplicitNullCheck->frameState->genArrayLength->append->push
BytecodeParser#getMethod()::: bytecode parser get method:::return
BytecodeParser#getCode()::: bytecode parser get code:::return
BytecodeParser#getFrameStateBuilder()::: bytecode parser get frame state builder:::return
BytecodeParser#traceInstruction(int, int, boolean)::: bytecode parser trace instruction:::indent->getDepth->new->charArr->new->String->replace->sb->new->StringBuilder->nl->System->lineSeparator->if->sb->append->method->format->append->append->if->sb->append->append->append->bm->blockMap->toString->replace->sb->append->append->append->append->if->sb->append->append->append->sb->append->sb->append->if->sb->append->else->if->sb->append->sb->append->append->Bytecodes->nameOf->append->for->i->stream->nextBCI->if->currentBlock->getJsrScope->isEmpty->sb->append->currentBlock->getJsrScope->append->TTY->println
BytecodeParser#parsingIntrinsic()::: bytecode parser parsing intrinsic:::return
BytecodeParser#getNonIntrinsicAncestor()::: bytecode parser get non intrinsic ancestor:::ancestor->while->ancestor->parsingIntrinsic->return
BytecodeParser#nSpaces(int)::: bytecode parser n spaces:::return->format
ComputeLoopFrequenciesClosure#processNode(FixedNode, Double)::: compute loop frequencies closure process node:::return
ComputeLoopFrequenciesClosure#merge(AbstractMergeNode, List)::: compute loop frequencies closure merge:::result->foreach->return
ComputeLoopFrequenciesClosure#afterSplit(AbstractBeginNode, Double)::: compute loop frequencies closure after split:::split->node->predecessor->return->split->probability
ComputeLoopFrequenciesClosure#processLoop(LoopBeginNode, Double)::: compute loop frequencies closure process loop:::exitStates->ReentrantNodeIterator->processLoop->exitRelativeFrequency->foreach->exitStates->getValues->Math->min->Math->max->loopFrequency->loop->setLoopFrequency->adjustmentFactor->exitStates->multiplyRelativeFrequencies->replaceAll->return
ComputeLoopFrequenciesClosure#compute(StructuredGraph):::Computes the frequencies of all loops in the given graph:::if->graph->hasLoops->ReentrantNodeIterator->graph->start->apply
ComputeLoopFrequenciesClosure.ComputeLoopFrequencyPhase#run(StructuredGraph)::: compute loop frequency phase run:::compute
DefaultSuitesCreator#createSuites(OptionValues)::: default suites creator create suites:::return->Suites->createSuites
DefaultSuitesCreator#createGraphBuilderSuite(Plugins)::: default suites creator create graph builder suite:::suite->new->PhaseSuite<>->suite->GraphBuilderConfiguration->getDefault->new->GraphBuilderPhase->appendPhase->return
DefaultSuitesCreator#createLIRSuites(OptionValues)::: default suites creator create suites:::return->Suites->createLIRSuites
FrameStateBuilder#disableKindVerification()::: frame state builder disable kind verification:::
FrameStateBuilder#initializeFromArgumentsArray(ValueNode[])::: frame state builder initialize from arguments array:::javaIndex->index->if->getMethod->isStatic->sig->getMethod->getSignature->max->sig->getParameterCount->for->i
FrameStateBuilder#initializeForMethodStart(Assumptions, boolean, Plugins)::: frame state builder initialize for method start:::javaIndex->index->method->getMethod->originalType->method->getDeclaringClass->if->method->isStatic->receiver->receiverStamp->if->plugins->getOverridingStamp->if->StampFactory->forDeclaredType->if->foreach->plugins->getParameterPlugins->plugin->interceptParameter->if->break->if->new->ParameterNode->graph->addOrUniqueWithInputs->sig->method->getSignature->max->sig->getParameterCount->accessingClass->for->i
FrameStateBuilder#allocateArray(int)::: frame state builder allocate array:::return->new->ValueNodeArr
FrameStateBuilder#getMethod()::: frame state builder get method:::return->code->getMethod
FrameStateBuilder#toString()::: frame state builder to string:::sb->new->StringBuilder->sb->append->for->i->sb->append->for->i->sb->append->for->i->sb->append->if->sb->append->sb->append->return->sb->toString
FrameStateBuilder#create(int, StateSplit)::: frame state builder create:::if->parser->parsingIntrinsic->sourcePosition->parser->getGraph->trackNodeSourcePosition->createBytecodePosition->return->parser->getGraph->createFrameState->return->parser->getNonIntrinsicAncestor->create
FrameStateBuilder#create(int, BytecodeParser, boolean, JavaKind[], ValueNode[])::: frame state builder create:::if->parent->getFrameStateBuilder->parent->bci->parent->getNonIntrinsicAncestor->create->if->newFrameState->outerFrameState->new->JavaKindArr->new->ValueNodeArr->duplicateModified->return->if->throw->shouldNotReachHere->if->stackSizeToRestore->for->i->res->graph->Arrays->asList->new->FrameState->add->return->else->if->clearLocals->return->graph->Arrays->asList->new->FrameState->add
FrameStateBuilder#createBytecodePosition(int)::: frame state builder create bytecode position:::parent->parser->getParent->position->create->return
FrameStateBuilder#create(int, BytecodeParser)::: frame state builder create:::if->parent->getFrameStateBuilder->parent->bci->createBytecodePosition->if->return->FrameState->toSourcePosition->if->throw->shouldNotReachHere->if->original->getOriginalMethod->new->NodeSourcePosition->return->NodeSourcePosition->code->getMethod->substitution->else->return->code->getMethod->new->NodeSourcePosition
FrameStateBuilder#copy()::: frame state builder copy:::return->new->FrameStateBuilder
FrameStateBuilder#isCompatibleWith(FrameStateBuilder)::: frame state builder is compatible with:::if->return->if->stackSize->other->stackSize->return->for->i->stackSize->if->return->for->i->return
FrameStateBuilder#merge(AbstractMergeNode, FrameStateBuilder)::: frame state builder merge:::GraalError->isCompatibleWith->guarantee->for->i->localsSize->for->i->stackSize->for->i->if->else->if->sideEffects->addAll
FrameStateBuilder#merge(ValueNode, ValueNode, AbstractMergeNode)::: frame state builder merge:::if->currentValue->isDeleted->return->else->if->block->isPhiAtMerge->if->otherValue->isDeleted->currentValue->getStackKind->otherValue->getStackKind->ConstantNode->currentValue->getStackKind->defaultForKind->addInput->else->addInput->return->else->if->if->return->else->if->otherValue->isDeleted->currentValue->getStackKind->otherValue->getStackKind->return->return->createValuePhi->else->return
FrameStateBuilder#createValuePhi(ValueNode, ValueNode, AbstractMergeNode)::: frame state builder create value phi:::phi->graph->currentValue->stamp->unrestricted->new->ValuePhiNode->addWithoutUnique->for->i->block->phiPredecessorCount->phi->addInput->return
FrameStateBuilder#inferPhiStamps(AbstractMergeNode)::: frame state builder infer phi stamps:::for->i->localsSize->for->i->stackSize->for->i
FrameStateBuilder#inferPhiStamp(AbstractMergeNode, ValueNode)::: frame state builder infer phi stamp:::if->block->isPhiAtMerge->node->inferStamp
FrameStateBuilder#insertLoopPhis(LocalLiveness, int, LoopBeginNode, boolean, boolean)::: frame state builder insert loop phis:::for->i->localsSize->for->i->stackSize->for->i
FrameStateBuilder#insertLoopProxies(LoopExitNode, FrameStateBuilder)::: frame state builder insert loop proxies:::debug->graph->getDebug->for->i->localsSize->for->i->stackSize->for->i
FrameStateBuilder#insertProxies(Function)::: frame state builder insert proxies:::debug->graph->getDebug->for->i->localsSize->for->i->stackSize->for->i
FrameStateBuilder#createLoopPhi(AbstractMergeNode, ValueNode, boolean)::: frame state builder create loop phi:::if->return->phi->graph->value->stamp->value->stamp->unrestricted->new->ValuePhiNode->addWithoutUnique->phi->addInput->return
FrameStateBuilder#pushLock(ValueNode, MonitorIdNode):::Adds a locked monitor to this frame state.:::Arrays->copyOf->Arrays->copyOf
FrameStateBuilder#popLock():::Removes a locked monitor from this frame state.:::try->return->catch->finally->Arrays->copyOf->Arrays->copyOf
FrameStateBuilder#peekMonitorId()::: frame state builder peek monitor id:::return
FrameStateBuilder#lockDepth(boolean)::: frame state builder lock depth:::depth->if->parser->getParent->parser->getParent->lockDepth->return
FrameStateBuilder#contains(ValueNode)::: frame state builder contains:::for->i->localsSize->for->i->stackSize->for->i->return
FrameStateBuilder#clearNonLiveLocals(BciBlock, LocalLiveness, boolean)::: frame state builder clear non live locals:::isOSREntryBlock->graph->isOSR->getMethod->graph->method->equals->graph->getEntryBCI->if->return->if->for->i->else->for->i
FrameStateBuilder#clearLocals():::Clears all local variables.:::for->i
FrameStateBuilder#rethrowException()::: frame state builder rethrow exception:::return
FrameStateBuilder#setRethrowException(boolean)::: frame state builder set rethrow exception:::
FrameStateBuilder#localsSize():::Returns the size of the local variables.:::return
FrameStateBuilder#stackSize():::Gets the current size (height) of the stack.:::return
FrameStateBuilder#verifyKind(JavaKind, ValueNode)::: frame state builder verify kind:::if->return
FrameStateBuilder#loadLocal(int, JavaKind):::Loads the local variable at the specified index, checking that the returned value is non-null and that two-stack values are properly handled.:::x->return
FrameStateBuilder#storeLocal(int, JavaKind, ValueNode):::Stores a given local variable at the specified index:::if->if->slotKind->needsTwoSlots->if->else->if
FrameStateBuilder#push(JavaKind, ValueNode):::Pushes an instruction onto the stack with the expected type.:::xpush->if->slotKind->needsTwoSlots->xpush
FrameStateBuilder#pushReturn(JavaKind, ValueNode)::: frame state builder push return:::if->push
FrameStateBuilder#pop(JavaKind):::Pops an instruction off the stack with the expected type.:::if->slotKind->needsTwoSlots->s->xpop->x->xpop->return
FrameStateBuilder#xpush(ValueNode)::: frame state builder xpush:::
FrameStateBuilder#xpop()::: frame state builder xpop:::result->return
FrameStateBuilder#xpeek()::: frame state builder xpeek:::result->return
FrameStateBuilder#peekObject()::: frame state builder peek object:::x->xpeek->return
FrameStateBuilder#popArguments(int):::Pop the specified number of slots off of this stack and return them as an array of instructions.:::result->allocateArray->for->i->return
FrameStateBuilder#clearStack():::Clears all values on this stack.:::
FrameStateBuilder#stackOp(int):::Performs a raw stack operation as defined in the Java bytecode specification.:::switch->w1->xpop->break->xpop->w2->xpop->break->w1->xpeek->xpush->break->w1->xpop->w2->xpop->xpush->xpush->xpush->break->w1->xpop->w2->xpop->w3->xpop->xpush->xpush->xpush->xpush->break->w1->xpop->w2->xpop->xpush->xpush->xpush->xpush->break->w1->xpop->w2->xpop->w3->xpop->xpush->xpush->xpush->xpush->xpush->break->w1->xpop->w2->xpop->w3->xpop->w4->xpop->xpush->xpush->xpush->xpush->xpush->xpush->break->w1->xpop->w2->xpop->xpush->xpush->break->throw->shouldNotReachHere
FrameStateBuilder#hashCode()::: frame state builder hash code:::result->hashCode->hashCode->return
FrameStateBuilder#hashCode(Object[], int)::: frame state builder hash code:::result->for->i->return
FrameStateBuilder#equals(ValueNode[], ValueNode[], int)::: frame state builder equals:::for->i->return
FrameStateBuilder#equals(Object)::: frame state builder equals:::if->other->if->equals->return->if->return->if->return->if->return->if->return->if->return->if->return->return->equals->equals->equals->equals->return
FrameStateBuilder#isAfterSideEffect()::: frame state builder is after side effect:::return
FrameStateBuilder#sideEffects()::: frame state builder side effects:::return
FrameStateBuilder#addSideEffect(StateSplit)::: frame state builder add side effect:::if->new->ArrayList<>->sideEffects->add
GraphBuilderPhase#checkContract()::: graph builder phase check contract:::return
GraphBuilderPhase#run(StructuredGraph, HighTierContext)::: graph builder phase run:::context->getOptimisticOptimizations->new->Instance->run
GraphBuilderPhase#getGraphBuilderConfig()::: graph builder phase get graph builder config:::return
GraphBuilderPhase.Instance#checkContract()::: instance check contract:::return
GraphBuilderPhase.Instance#run(StructuredGraph)::: instance run:::graph->method->graph->getEntryBCI->createBytecodeParser->buildRootMethod
GraphBuilderPhase.Instance#createBytecodeParser(StructuredGraph, BytecodeParser, ResolvedJavaMethod, int, IntrinsicContext)::: instance create bytecode parser:::return->new->BytecodeParser
JsrScope#nextReturnAddress()::: jsr scope next return address:::return
JsrScope#push(int)::: jsr scope push:::if->throw->new->JsrNotSupportedBailout->return->new->JsrScope
JsrScope#isEmpty()::: jsr scope is empty:::return
JsrScope#isPrefixOf(JsrScope)::: jsr scope is prefix of:::return
JsrScope#pop()::: jsr scope pop:::return->new->JsrScope
JsrScope#hashCode()::: jsr scope hash code:::return
JsrScope#equals(Object)::: jsr scope equals:::if->return->return->getClass->obj->getClass
JsrScope#toString()::: jsr scope to string:::sb->new->StringBuilder->tmp->sb->append->while->sb->append->append->sb->append->return->sb->toString
LargeLocalLiveness#debugLiveIn(int)::: large local liveness debug live in:::return->toString
LargeLocalLiveness#debugLiveOut(int)::: large local liveness debug live out:::return->toString
LargeLocalLiveness#debugLiveGen(int)::: large local liveness debug live gen:::return->toString
LargeLocalLiveness#debugLiveKill(int)::: large local liveness debug live kill:::return->toString
LargeLocalLiveness#liveOutCardinality(int)::: large local liveness live out cardinality:::return->cardinality
LargeLocalLiveness#propagateLiveness(int, int)::: large local liveness propagate liveness:::or
LargeLocalLiveness#updateLiveness(int)::: large local liveness update liveness:::liveIn->liveIn->clear->liveIn->or->liveIn->andNot->liveIn->or
LargeLocalLiveness#loadOne(int, int)::: large local liveness load one:::if->get->set
LargeLocalLiveness#storeOne(int, int)::: large local liveness store one:::if->get->set->block->tmp->pos->while->if->set
LargeLocalLiveness#localIsLiveIn(BciBlock, int)::: large local liveness local is live in:::return->block->getId->block->getId->get
LargeLocalLiveness#localIsLiveOut(BciBlock, int)::: large local liveness local is live out:::return->block->getId->block->getId->get
LargeLocalLiveness#localIsChangedInLoop(int, int)::: large local liveness local is changed in loop:::return->get
LocalLiveness#compute(DebugContext, BytecodeStream, BciBlock[], int, int)::: local liveness compute:::liveness->new->SmallLocalLiveness->new->LargeLocalLiveness->liveness->computeLiveness->return
LocalLiveness#computeLiveness(DebugContext, BytecodeStream)::: local liveness compute liveness:::foreach->computeLocalLiveness->changed->iteration->do->for->i->while
LocalLiveness#traceIteration(DebugContext, int)::: local liveness trace iteration:::debug->log->return
LocalLiveness#traceEnd(DebugContext, BciBlock, int)::: local liveness trace end:::if->debug->isLogEnabled->debug->block->getId->debugLiveIn->debugLiveOut->debugLiveGen->debugLiveKill->logv->return
LocalLiveness#traceSuccessor(DebugContext, BciBlock)::: local liveness trace successor:::if->debug->isLogEnabled->debug->sux->getId->sux->getId->debugLiveIn->log->return
LocalLiveness#traceStart(DebugContext, BciBlock, int)::: local liveness trace start:::if->debug->isLogEnabled->debug->block->getId->debugLiveIn->debugLiveOut->debugLiveGen->debugLiveKill->logv->return
LocalLiveness#localIsLiveIn(BciBlock, int):::Returns whether the local is live at the beginning of the given block.:::
LocalLiveness#localIsChangedInLoop(int, int):::Returns whether the local is set in the given loop.:::
LocalLiveness#localIsLiveOut(BciBlock, int):::Returns whether the local is live at the end of the given block.:::
LocalLiveness#debugLiveIn(int):::Returns a string representation of the liveIn values of the given block.:::
LocalLiveness#debugLiveOut(int):::Returns a string representation of the liveOut values of the given block.:::
LocalLiveness#debugLiveGen(int):::Returns a string representation of the liveGen values of the given block.:::
LocalLiveness#debugLiveKill(int):::Returns a string representation of the liveKill values of the given block.:::
LocalLiveness#liveOutCardinality(int):::Returns the number of live locals at the end of the given block.:::
LocalLiveness#propagateLiveness(int, int):::Adds all locals the are in the liveIn of the successor to the liveOut of the block.:::
LocalLiveness#updateLiveness(int):::Calculates a new liveIn for the given block from liveOut, liveKill and liveGen.:::
LocalLiveness#loadOne(int, int):::Adds the local to liveGen if it wasn't already killed in this block.:::
LocalLiveness#storeOne(int, int):::Add this local to liveKill if it wasn't already generated in this block.:::
LocalLiveness#computeLocalLiveness(BytecodeStream, BciBlock)::: local liveness compute local liveness:::if->block->isExceptionDispatch->return->blockID->block->getId->localIndex->stream->setBCI->while->stream->currentBCI->switch->stream->currentBC->stream->readLocalIndex->loadTwo->break->loadTwo->break->loadTwo->break->loadTwo->break->loadTwo->break->stream->readLocalIndex->loadOne->storeOne->break->stream->readLocalIndex->loadOne->break->loadOne->break->loadOne->break->loadOne->break->loadOne->break->stream->readLocalIndex->storeTwo->break->storeTwo->break->storeTwo->break->storeTwo->break->storeTwo->break->stream->readLocalIndex->storeOne->break->storeOne->break->storeOne->break->storeOne->break->storeOne->break->stream->next
LocalLiveness#loadTwo(int, int)::: local liveness load two:::loadOne->loadOne
LocalLiveness#storeTwo(int, int)::: local liveness store two:::storeOne->storeOne
SmallLocalLiveness#debugString(long)::: small local liveness debug string:::str->new->StringBuilder->current->for->i->return->str->append->toString
SmallLocalLiveness#debugLiveIn(int)::: small local liveness debug live in:::return->debugString
SmallLocalLiveness#debugLiveOut(int)::: small local liveness debug live out:::return->debugString
SmallLocalLiveness#debugLiveGen(int)::: small local liveness debug live gen:::return->debugString
SmallLocalLiveness#debugLiveKill(int)::: small local liveness debug live kill:::return->debugString
SmallLocalLiveness#liveOutCardinality(int)::: small local liveness live out cardinality:::return->Long->bitCount
SmallLocalLiveness#propagateLiveness(int, int)::: small local liveness propagate liveness:::
SmallLocalLiveness#updateLiveness(int)::: small local liveness update liveness:::
SmallLocalLiveness#loadOne(int, int)::: small local liveness load one:::bit->if
SmallLocalLiveness#storeOne(int, int)::: small local liveness store one:::bit->if->block->tmp->pos->while->if
SmallLocalLiveness#localIsLiveIn(BciBlock, int)::: small local liveness local is live in:::blockID->block->getId->return
SmallLocalLiveness#localIsLiveOut(BciBlock, int)::: small local liveness local is live out:::blockID->block->getId->return
SmallLocalLiveness#localIsChangedInLoop(int, int)::: small local liveness local is changed in loop:::return
SuitesProviderBase#getDefaultSuites(OptionValues)::: suites provider base get default suites:::return->createSuites
SuitesProviderBase#getDefaultGraphBuilderSuite()::: suites provider base get default graph builder suite:::return
SuitesProviderBase#getDefaultLIRSuites(OptionValues)::: suites provider base get default suites:::return->createLIRSuites
SuitesProviderBase#createLIRSuites(OptionValues)::: suites provider base create suites:::
SuitesProviderBase#createSuites(OptionValues)::: suites provider base create suites:::
