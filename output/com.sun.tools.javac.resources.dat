CompilerProperties.Notes#DeferredMethodInst(Symbol, Type, Type):::compiler.note.deferred.method.inst=\    Deferred instantiation of method {0}\n\    instantiated signature: {1}\n\    target-type: {2}:::return->new->Note
CompilerProperties.Notes#DeprecatedFilename(File):::compiler.note.deprecated.filename=\    {0} uses or overrides a deprecated API.:::return->new->Note
CompilerProperties.Notes#DeprecatedFilename(JavaFileObject):::compiler.note.deprecated.filename=\    {0} uses or overrides a deprecated API.:::return->new->Note
CompilerProperties.Notes#DeprecatedFilename(Path):::compiler.note.deprecated.filename=\    {0} uses or overrides a deprecated API.:::return->new->Note
CompilerProperties.Notes#DeprecatedFilenameAdditional(File):::compiler.note.deprecated.filename.additional=\    {0} has additional uses or overrides of a deprecated API.:::return->new->Note
CompilerProperties.Notes#DeprecatedFilenameAdditional(JavaFileObject):::compiler.note.deprecated.filename.additional=\    {0} has additional uses or overrides of a deprecated API.:::return->new->Note
CompilerProperties.Notes#DeprecatedFilenameAdditional(Path):::compiler.note.deprecated.filename.additional=\    {0} has additional uses or overrides of a deprecated API.:::return->new->Note
CompilerProperties.Notes#LambdaStat(boolean, Symbol):::compiler.note.lambda.stat=\    Translating lambda expression\n\    alternate metafactory = {0}\n\    synthetic method = {1}:::return->new->Note
CompilerProperties.Notes#MrefStat(boolean, Void):::compiler.note.mref.stat=\    Translating method reference\n\    alternate metafactory = {0}\n\:::return->new->Note
CompilerProperties.Notes#MrefStat1(boolean, Symbol):::compiler.note.mref.stat.1=\    Translating method reference\n\    alternate metafactory = {0}\n\    bridge method = {1}:::return->new->Note
CompilerProperties.Notes#MultipleElements(String, String, String):::compiler.note.multiple.elements=\    Multiple elements named ''{1}'' in modules ''{2}'' were found by javax.lang.model.util.Elements.{0}.:::return->new->Note
CompilerProperties.Notes#PreviewFilename(File):::compiler.note.preview.filename=\    {0} uses preview language features.:::return->new->Note
CompilerProperties.Notes#PreviewFilename(JavaFileObject):::compiler.note.preview.filename=\    {0} uses preview language features.:::return->new->Note
CompilerProperties.Notes#PreviewFilename(Path):::compiler.note.preview.filename=\    {0} uses preview language features.:::return->new->Note
CompilerProperties.Notes#PreviewFilenameAdditional(File):::compiler.note.preview.filename.additional=\    {0} has additional uses of preview language features.:::return->new->Note
CompilerProperties.Notes#PreviewFilenameAdditional(JavaFileObject):::compiler.note.preview.filename.additional=\    {0} has additional uses of preview language features.:::return->new->Note
CompilerProperties.Notes#PreviewFilenameAdditional(Path):::compiler.note.preview.filename.additional=\    {0} has additional uses of preview language features.:::return->new->Note
CompilerProperties.Notes#ProcMessager(String):::compiler.note.proc.messager=\    {0}:::return->new->Note
CompilerProperties.Notes#RemovalFilename(File):::compiler.note.removal.filename=\    {0} uses or overrides a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#RemovalFilename(JavaFileObject):::compiler.note.removal.filename=\    {0} uses or overrides a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#RemovalFilename(Path):::compiler.note.removal.filename=\    {0} uses or overrides a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#RemovalFilenameAdditional(File):::compiler.note.removal.filename.additional=\    {0} has additional uses or overrides of a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#RemovalFilenameAdditional(JavaFileObject):::compiler.note.removal.filename.additional=\    {0} has additional uses or overrides of a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#RemovalFilenameAdditional(Path):::compiler.note.removal.filename.additional=\    {0} has additional uses or overrides of a deprecated API that is marked for removal.:::return->new->Note
CompilerProperties.Notes#UncheckedFilename(File):::compiler.note.unchecked.filename=\    {0} uses unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#UncheckedFilename(JavaFileObject):::compiler.note.unchecked.filename=\    {0} uses unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#UncheckedFilename(Path):::compiler.note.unchecked.filename=\    {0} uses unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#UncheckedFilenameAdditional(File):::compiler.note.unchecked.filename.additional=\    {0} has additional unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#UncheckedFilenameAdditional(JavaFileObject):::compiler.note.unchecked.filename.additional=\    {0} has additional unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#UncheckedFilenameAdditional(Path):::compiler.note.unchecked.filename.additional=\    {0} has additional unchecked or unsafe operations.:::return->new->Note
CompilerProperties.Notes#VerboseL2mDeduplicate(Symbol):::compiler.note.verbose.l2m.deduplicate=\    deduplicating lambda implementation method {0}:::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, List, List):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, List, JCDiagnostic):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, List, Fragment):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, JCDiagnostic, List):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, JCDiagnostic, JCDiagnostic):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, JCDiagnostic, Fragment):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, Fragment, List):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, Fragment, JCDiagnostic):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti(Name, Symbol, int, String, Fragment, Fragment):::compiler.note.verbose.resolve.multi=\    resolving method {0} in type {1} to candidate {2}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, List, List):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, List, JCDiagnostic):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, List, Fragment):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, JCDiagnostic, List):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, JCDiagnostic, JCDiagnostic):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, JCDiagnostic, Fragment):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, Fragment, List):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, Fragment, JCDiagnostic):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Notes#VerboseResolveMulti1(Name, Symbol, Void, String, Fragment, Fragment):::compiler.note.verbose.resolve.multi.1=\    erroneous resolution for method {0} in type {1}\n\    phase: {3}\n\    with actuals: {4}\n\    with type-args: {5}\n\    candidates::::return->new->Note
CompilerProperties.Warnings#AccessToMemberFromSerializableElement(Symbol):::compiler.warn.access.to.member.from.serializable.element=\    access to member {0} from serializable element can be publicly accessible to untrusted code:::return->new->Warning
CompilerProperties.Warnings#AccessToMemberFromSerializableLambda(Symbol):::compiler.warn.access.to.member.from.serializable.lambda=\    access to member {0} from serializable lambda can be publicly accessible to untrusted code:::return->new->Warning
CompilerProperties.Warnings#AnnotationMethodNotFound(Type, Name):::compiler.warn.annotation.method.not.found=\    Cannot find annotation method ''{1}()'' in type ''{0}'':::return->new->Warning
CompilerProperties.Warnings#AnnotationMethodNotFoundReason(Type, Name, JCDiagnostic):::compiler.warn.annotation.method.not.found.reason=\    Cannot find annotation method ''{1}()'' in type ''{0}'': {2}:::return->new->Warning
CompilerProperties.Warnings#AnnotationMethodNotFoundReason(Type, Name, Fragment):::compiler.warn.annotation.method.not.found.reason=\    Cannot find annotation method ''{1}()'' in type ''{0}'': {2}:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Symbol, File):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Symbol, JavaFileObject):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Symbol, Path):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Type, File):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Type, JavaFileObject):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#AuxiliaryClassAccessedFromOutsideOfItsSourceFile(Type, Path):::compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\    auxiliary class {0} in {1} should not be accessed from outside its own source file:::return->new->Warning
CompilerProperties.Warnings#BadNameForOption(Option, String):::compiler.warn.bad.name.for.option=\    bad name in value for {0} option: ''{1}'':::return->new->Warning
CompilerProperties.Warnings#BigMajorVersion(File, int, int):::compiler.warn.big.major.version=\    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\    It is recommended that the compiler be upgraded.:::return->new->Warning
CompilerProperties.Warnings#BigMajorVersion(JavaFileObject, int, int):::compiler.warn.big.major.version=\    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\    It is recommended that the compiler be upgraded.:::return->new->Warning
CompilerProperties.Warnings#BigMajorVersion(Path, int, int):::compiler.warn.big.major.version=\    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\    It is recommended that the compiler be upgraded.:::return->new->Warning
CompilerProperties.Warnings#ConstantSVUID(Symbol):::compiler.warn.constant.SVUID=\    serialVersionUID must be constant in class {0}:::return->new->Warning
CompilerProperties.Warnings#DeprecatedAnnotationHasNoEffect(KindName):::compiler.warn.deprecated.annotation.has.no.effect=\:::return->new->Warning
CompilerProperties.Warnings#DirPathElementNotDirectory(File):::compiler.warn.dir.path.element.not.directory=\    bad path element "{0}": not a directory:::return->new->Warning
CompilerProperties.Warnings#DirPathElementNotDirectory(JavaFileObject):::compiler.warn.dir.path.element.not.directory=\    bad path element "{0}": not a directory:::return->new->Warning
CompilerProperties.Warnings#DirPathElementNotDirectory(Path):::compiler.warn.dir.path.element.not.directory=\    bad path element "{0}": not a directory:::return->new->Warning
CompilerProperties.Warnings#DirPathElementNotFound(Path):::compiler.warn.dir.path.element.not.found=\    bad path element "{0}": no such directory:::return->new->Warning
CompilerProperties.Warnings#FileFromFuture(File):::compiler.warn.file.from.future=\    Modification date is in the future for file {0}:::return->new->Warning
CompilerProperties.Warnings#FileFromFuture(JavaFileObject):::compiler.warn.file.from.future=\    Modification date is in the future for file {0}:::return->new->Warning
CompilerProperties.Warnings#FileFromFuture(Path):::compiler.warn.file.from.future=\    Modification date is in the future for file {0}:::return->new->Warning
CompilerProperties.Warnings#ForwardRef(Symbol):::compiler.warn.forward.ref=\    reference to variable ''{0}'' before it has been initialized:::return->new->Warning
CompilerProperties.Warnings#FutureAttr(Name, int, int, int, int):::compiler.warn.future.attr=\    {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files:::return->new->Warning
CompilerProperties.Warnings#HasBeenDeprecated(Symbol, Symbol):::compiler.warn.has.been.deprecated=\    {0} in {1} has been deprecated:::return->new->Warning
CompilerProperties.Warnings#HasBeenDeprecatedForRemoval(Symbol, Symbol):::compiler.warn.has.been.deprecated.for.removal=\    {0} in {1} has been deprecated and marked for removal:::return->new->Warning
CompilerProperties.Warnings#HasBeenDeprecatedForRemovalModule(Symbol):::compiler.warn.has.been.deprecated.for.removal.module=\    module {0} has been deprecated and marked for removal:::return->new->Warning
CompilerProperties.Warnings#HasBeenDeprecatedModule(Symbol):::compiler.warn.has.been.deprecated.module=\    module {0} has been deprecated:::return->new->Warning
CompilerProperties.Warnings#ImproperSVUID(Symbol):::compiler.warn.improper.SVUID=\    serialVersionUID must be declared static final in class {0}:::return->new->Warning
CompilerProperties.Warnings#IncubatingModules(String):::compiler.warn.incubating.modules=\    using incubating module(s): {0}:::return->new->Warning
CompilerProperties.Warnings#InexactNonVarargsCall(Type, Type):::compiler.warn.inexact.non-varargs.call=\    non-varargs call of varargs method with inexact argument type for last parameter;\n\    cast to {0} for a varargs call\n\    cast to {1} for a non-varargs call and to suppress this warning:::return->new->Warning
CompilerProperties.Warnings#InvalidArchiveFile(Path):::compiler.warn.invalid.archive.file=\    Unexpected file on path: {0}:::return->new->Warning
CompilerProperties.Warnings#InvalidPath(String):::compiler.warn.invalid.path=\    Invalid filename: {0}:::return->new->Warning
CompilerProperties.Warnings#LeaksNotAccessible(KindName, Symbol, Symbol):::compiler.warn.leaks.not.accessible=\    {0} {1} in module {2} is not accessible to clients that require this module:::return->new->Warning
CompilerProperties.Warnings#LeaksNotAccessibleNotRequiredTransitive(KindName, Symbol, Symbol):::compiler.warn.leaks.not.accessible.not.required.transitive=\    {0} {1} in module {2} is not indirectly exported using 'requires transitive':::return->new->Warning
CompilerProperties.Warnings#LeaksNotAccessibleUnexported(KindName, Symbol, Symbol):::compiler.warn.leaks.not.accessible.unexported=\    {0} {1} in module {2} is not exported:::return->new->Warning
CompilerProperties.Warnings#LeaksNotAccessibleUnexportedQualified(KindName, Symbol, Symbol):::compiler.warn.leaks.not.accessible.unexported.qualified=\    {0} {1} in module {2} may not be visible to all clients that require this module:::return->new->Warning
CompilerProperties.Warnings#LintOption(Option):::compiler.warn.lintOption=\    [{0}]\u0020:::return->new->Warning
CompilerProperties.Warnings#LocnUnknownFileOnModulePath(Path):::compiler.warn.locn.unknown.file.on.module.path=\    unknown file on module path: {0}:::return->new->Warning
CompilerProperties.Warnings#LongSVUID(Symbol):::compiler.warn.long.SVUID=\    serialVersionUID must be of type long in class {0}:::return->new->Warning
CompilerProperties.Warnings#MissingSVUID(Symbol):::compiler.warn.missing.SVUID=\    serializable class {0} has no definition of serialVersionUID:::return->new->Warning
CompilerProperties.Warnings#ModuleForOptionNotFound(Option, Symbol):::compiler.warn.module.for.option.not.found=\    module name in {0} option not found: {1}:::return->new->Warning
CompilerProperties.Warnings#ModuleNotFound(Symbol):::compiler.warn.module.not.found=\    module not found: {0}:::return->new->Warning
CompilerProperties.Warnings#OptionObsoleteSource(String):::compiler.warn.option.obsolete.source=\    source value {0} is obsolete and will be removed in a future release:::return->new->Warning
CompilerProperties.Warnings#OptionObsoleteTarget(Target):::compiler.warn.option.obsolete.target=\    target value {0} is obsolete and will be removed in a future release:::return->new->Warning
CompilerProperties.Warnings#OptionParametersUnsupported(Target, Target):::compiler.warn.option.parameters.unsupported=\    -parameters is not supported for target value {0}:::return->new->Warning
CompilerProperties.Warnings#OutdirIsInExplodedModule(Path):::compiler.warn.outdir.is.in.exploded.module=\    the output directory is within an exploded module: {0}:::return->new->Warning
CompilerProperties.Warnings#OverrideBridge(JCDiagnostic):::compiler.warn.override.bridge=\    {0}; overridden method is a bridge method:::return->new->Warning
CompilerProperties.Warnings#OverrideBridge(Fragment):::compiler.warn.override.bridge=\    {0}; overridden method is a bridge method:::return->new->Warning
CompilerProperties.Warnings#OverrideEqualsButNotHashcode(Symbol):::compiler.warn.override.equals.but.not.hashcode=\    Class {0} overrides equals, but neither it nor any superclass overrides hashCode method:::return->new->Warning
CompilerProperties.Warnings#OverrideUncheckedRet(JCDiagnostic, Type, Type):::compiler.warn.override.unchecked.ret=\    {0}\n\    return type requires unchecked conversion from {1} to {2}:::return->new->Warning
CompilerProperties.Warnings#OverrideUncheckedRet(Fragment, Type, Type):::compiler.warn.override.unchecked.ret=\    {0}\n\    return type requires unchecked conversion from {1} to {2}:::return->new->Warning
CompilerProperties.Warnings#OverrideUncheckedThrown(JCDiagnostic, Type):::compiler.warn.override.unchecked.thrown=\    {0}\n\    overridden method does not throw {1}:::return->new->Warning
CompilerProperties.Warnings#OverrideUncheckedThrown(Fragment, Type):::compiler.warn.override.unchecked.thrown=\    {0}\n\    overridden method does not throw {1}:::return->new->Warning
CompilerProperties.Warnings#OverrideVarargsExtra(JCDiagnostic):::compiler.warn.override.varargs.extra=\    {0}; overriding method is missing ''...'':::return->new->Warning
CompilerProperties.Warnings#OverrideVarargsExtra(Fragment):::compiler.warn.override.varargs.extra=\    {0}; overriding method is missing ''...'':::return->new->Warning
CompilerProperties.Warnings#OverrideVarargsMissing(JCDiagnostic):::compiler.warn.override.varargs.missing=\    {0}; overridden method has no ''...'':::return->new->Warning
CompilerProperties.Warnings#OverrideVarargsMissing(Fragment):::compiler.warn.override.varargs.missing=\    {0}; overridden method has no ''...'':::return->new->Warning
CompilerProperties.Warnings#PackageEmptyOrNotFound(Symbol):::compiler.warn.package.empty.or.not.found=\    package is empty or does not exist: {0}:::return->new->Warning
CompilerProperties.Warnings#PathElementNotFound(Path):::compiler.warn.path.element.not.found=\    bad path element "{0}": no such file or directory:::return->new->Warning
CompilerProperties.Warnings#PkgInfoAlreadySeen(Symbol):::compiler.warn.pkg-info.already.seen=\    a package-info.java file has already been seen for package {0}:::return->new->Warning
CompilerProperties.Warnings#PoorChoiceForModuleName(Name):::compiler.warn.poor.choice.for.module.name=\    module name component {0} should avoid terminal digits:::return->new->Warning
CompilerProperties.Warnings#PositionOverflow(int):::compiler.warn.position.overflow=\    Position encoding overflows at line {0}:::return->new->Warning
CompilerProperties.Warnings#PotentiallyAmbiguousOverload(Symbol, Symbol, Symbol, Symbol):::compiler.warn.potentially.ambiguous.overload=\    {0} in {1} is potentially ambiguous with {2} in {3}:::return->new->Warning
CompilerProperties.Warnings#PreviewFeatureUse(JCDiagnostic):::compiler.warn.preview.feature.use=\   {0} is a preview feature and may be removed in a future release.:::return->new->Warning
CompilerProperties.Warnings#PreviewFeatureUse(Fragment):::compiler.warn.preview.feature.use=\   {0} is a preview feature and may be removed in a future release.:::return->new->Warning
CompilerProperties.Warnings#PreviewFeatureUseClassfile(JavaFileObject, String):::compiler.warn.preview.feature.use.classfile=\   classfile for {0} uses preview features of Java SE {1}.:::return->new->Warning
CompilerProperties.Warnings#PreviewFeatureUsePlural(JCDiagnostic):::compiler.warn.preview.feature.use.plural=\   {0} are a preview feature and may be removed in a future release.:::return->new->Warning
CompilerProperties.Warnings#PreviewFeatureUsePlural(Fragment):::compiler.warn.preview.feature.use.plural=\   {0} are a preview feature and may be removed in a future release.:::return->new->Warning
CompilerProperties.Warnings#ProbFoundReq(JCDiagnostic, Type, Type):::compiler.warn.prob.found.req=\    {0}\n\    required: {2}\n\    found:    {1}:::return->new->Warning
CompilerProperties.Warnings#ProbFoundReq(Fragment, Type, Type):::compiler.warn.prob.found.req=\    {0}\n\    required: {2}\n\    found:    {1}:::return->new->Warning
CompilerProperties.Warnings#ProcAnnotationsWithoutProcessors(Set):::compiler.warn.proc.annotations.without.processors=\    No processor claimed any of these annotations: {0}:::return->new->Warning
CompilerProperties.Warnings#ProcFileCreateLastRound(String):::compiler.warn.proc.file.create.last.round=\    File for type ''{0}'' created in the last round will not be subject to annotation processing.:::return->new->Warning
CompilerProperties.Warnings#ProcFileReopening(String):::compiler.warn.proc.file.reopening=\    Attempt to create a file for ''{0}'' multiple times:::return->new->Warning
CompilerProperties.Warnings#ProcIllegalFileName(String):::compiler.warn.proc.illegal.file.name=\    Cannot create file for illegal name ''{0}''.:::return->new->Warning
CompilerProperties.Warnings#ProcMalformedSupportedString(String, String):::compiler.warn.proc.malformed.supported.string=\    Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}'':::return->new->Warning
CompilerProperties.Warnings#ProcMessager(String):::compiler.warn.proc.messager=\    {0}:::return->new->Warning
CompilerProperties.Warnings#ProcPackageDoesNotExist(String):::compiler.warn.proc.package.does.not.exist=\    package {0} does not exist:::return->new->Warning
CompilerProperties.Warnings#ProcProcessorIncompatibleSourceVersion(SourceVersion, String, String):::compiler.warn.proc.processor.incompatible.source.version=\    Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}'':::return->new->Warning
CompilerProperties.Warnings#ProcSuspiciousClassName(String, String):::compiler.warn.proc.suspicious.class.name=\    Creating file for a type whose name ends in {1}: ''{0}'':::return->new->Warning
CompilerProperties.Warnings#ProcTypeAlreadyExists(String):::compiler.warn.proc.type.already.exists=\    A file for type ''{0}'' already exists on the sourcepath or classpath:::return->new->Warning
CompilerProperties.Warnings#ProcTypeRecreate(String):::compiler.warn.proc.type.recreate=\    Attempt to create a file for type ''{0}'' multiple times:::return->new->Warning
CompilerProperties.Warnings#ProcUnclosedTypeFiles(Set):::compiler.warn.proc.unclosed.type.files=\    Unclosed files for the types ''{0}''; these types will not undergo annotation processing:::return->new->Warning
CompilerProperties.Warnings#ProcUnmatchedProcessorOptions(String):::compiler.warn.proc.unmatched.processor.options=\    The following options were not recognized by any processor: ''{0}'':::return->new->Warning
CompilerProperties.Warnings#ProfileTargetConflict(Profile, Target):::compiler.warn.profile.target.conflict=\    profile {0} is not valid for target release {1}:::return->new->Warning
CompilerProperties.Warnings#RawClassUse(Type, Type):::compiler.warn.raw.class.use=\    found raw type: {0}\n\    missing type arguments for generic class {1}:::return->new->Warning
CompilerProperties.Warnings#RedundantCast(Type):::compiler.warn.redundant.cast=\    redundant cast to {0}:::return->new->Warning
CompilerProperties.Warnings#SelfRef(Symbol):::compiler.warn.self.ref=\    self-reference in initializer of variable ''{0}'':::return->new->Warning
CompilerProperties.Warnings#ServiceProvidedButNotExportedOrUsed(Symbol):::compiler.warn.service.provided.but.not.exported.or.used=\    service interface provided but not exported or used:::return->new->Warning
CompilerProperties.Warnings#SourceNoBootclasspath(String):::compiler.warn.source.no.bootclasspath=\    bootstrap class path not set in conjunction with -source {0}:::return->new->Warning
CompilerProperties.Warnings#SourceTargetConflict(String, Target):::compiler.warn.source.target.conflict=\    source release {0} requires target release {1}:::return->new->Warning
CompilerProperties.Warnings#StaticNotQualifiedByType(KindName, Symbol):::compiler.warn.static.not.qualified.by.type=\    static {0} should be qualified by type name, {1}, instead of by an expression:::return->new->Warning
CompilerProperties.Warnings#SunProprietary(Symbol):::compiler.warn.sun.proprietary=\    {0} is internal proprietary API and may be removed in a future release:::return->new->Warning
CompilerProperties.Warnings#TargetDefaultSourceConflict(String, Target):::compiler.warn.target.default.source.conflict=\    target release {0} conflicts with default source release {1}:::return->new->Warning
CompilerProperties.Warnings#TryResourceNotReferenced(Symbol):::compiler.warn.try.resource.not.referenced=\    auto-closeable resource {0} is never referenced in body of corresponding try statement:::return->new->Warning
CompilerProperties.Warnings#TryResourceThrowsInterruptedExc(Type):::compiler.warn.try.resource.throws.interrupted.exc=\    auto-closeable resource {0} has a member method close() that could throw InterruptedException:::return->new->Warning
CompilerProperties.Warnings#UncheckedAssignToVar(Symbol, Type):::compiler.warn.unchecked.assign.to.var=\    unchecked assignment to variable {0} as member of raw type {1}:::return->new->Warning
CompilerProperties.Warnings#UncheckedCallMbrOfRawType(Symbol, Type):::compiler.warn.unchecked.call.mbr.of.raw.type=\    unchecked call to {0} as a member of the raw type {1}:::return->new->Warning
CompilerProperties.Warnings#UncheckedGenericArrayCreation(Type):::compiler.warn.unchecked.generic.array.creation=\    unchecked generic array creation for varargs parameter of type {0}:::return->new->Warning
CompilerProperties.Warnings#UncheckedMethInvocationApplied(KindName, Name, Object, Object, KindName, Symbol):::compiler.warn.unchecked.meth.invocation.applied=\    unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\    required: {2}\n\    found: {3}:::return->new->Warning
CompilerProperties.Warnings#UncheckedVarargsNonReifiableType(Type):::compiler.warn.unchecked.varargs.non.reifiable.type=\    Possible heap pollution from parameterized vararg type {0}:::return->new->Warning
CompilerProperties.Warnings#UnexpectedArchiveFile(Path):::compiler.warn.unexpected.archive.file=\    Unexpected extension for archive file: {0}:::return->new->Warning
CompilerProperties.Warnings#UnknownEnumConstant(JavaFileObject, Symbol, Name):::compiler.warn.unknown.enum.constant=\    unknown enum constant {1}.{2}:::return->new->Warning
CompilerProperties.Warnings#UnknownEnumConstantReason(JavaFileObject, Symbol, Name, JCDiagnostic):::compiler.warn.unknown.enum.constant.reason=\    unknown enum constant {1}.{2}\n\    reason: {3}:::return->new->Warning
CompilerProperties.Warnings#UnknownEnumConstantReason(JavaFileObject, Symbol, Name, Fragment):::compiler.warn.unknown.enum.constant.reason=\    unknown enum constant {1}.{2}\n\    reason: {3}:::return->new->Warning
CompilerProperties.Warnings#UnreachableCatch(List):::compiler.warn.unreachable.catch=\    unreachable catch clause\n\    thrown type {0} has already been caught:::return->new->Warning
CompilerProperties.Warnings#UnreachableCatch1(List):::compiler.warn.unreachable.catch.1=\    unreachable catch clause\n\    thrown types {0} have already been caught:::return->new->Warning
CompilerProperties.Warnings#VarargsRedundantTrustmeAnno(Symbol, JCDiagnostic):::compiler.warn.varargs.redundant.trustme.anno=\    Redundant {0} annotation:::return->new->Warning
CompilerProperties.Warnings#VarargsRedundantTrustmeAnno(Symbol, Fragment):::compiler.warn.varargs.redundant.trustme.anno=\    Redundant {0} annotation:::return->new->Warning
CompilerProperties.Warnings#VarargsUnsafeUseVarargsParam(Symbol):::compiler.warn.varargs.unsafe.use.varargs.param=\    Varargs method could cause heap pollution from non-reifiable varargs parameter {0}:::return->new->Warning
CompilerProperties.Fragments#AnachronisticModuleInfo(String, String):::compiler.misc.anachronistic.module.info=\    module declaration found in version {0}.{1} classfile:::return->new->Fragment
CompilerProperties.Fragments#AnonymousClass(Name):::compiler.misc.anonymous.class=\    :::return->new->Fragment
CompilerProperties.Fragments#ApplicableMethodFound(int, Symbol, Void):::compiler.misc.applicable.method.found=\:::return->new->Fragment
CompilerProperties.Fragments#ApplicableMethodFound1(int, Symbol, JCDiagnostic):::compiler.misc.applicable.method.found.1=\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#ApplicableMethodFound1(int, Symbol, Fragment):::compiler.misc.applicable.method.found.1=\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#BadClassFile(Name):::compiler.misc.bad.class.file=\    class file is invalid for class {0}:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(File, JCDiagnostic):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(File, Fragment):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(JavaFileObject, JCDiagnostic):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(JavaFileObject, Fragment):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(Path, JCDiagnostic):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadClassFileHeader(Path, Fragment):::compiler.misc.bad.class.file.header=\    bad class file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the classpath.:::return->new->Fragment
CompilerProperties.Fragments#BadConstPoolEntry(File, String, int):::compiler.misc.bad.const.pool.entry=\    bad constant pool entry in {0}\n\    expected {1} at index {2}:::return->new->Fragment
CompilerProperties.Fragments#BadConstPoolEntry(JavaFileObject, String, int):::compiler.misc.bad.const.pool.entry=\    bad constant pool entry in {0}\n\    expected {1} at index {2}:::return->new->Fragment
CompilerProperties.Fragments#BadConstPoolEntry(Path, String, int):::compiler.misc.bad.const.pool.entry=\    bad constant pool entry in {0}\n\    expected {1} at index {2}:::return->new->Fragment
CompilerProperties.Fragments#BadConstantRange(String, Symbol, Type):::compiler.misc.bad.constant.range=\    constant value ''{0}'' for {1} is outside the expected range for {2}:::return->new->Fragment
CompilerProperties.Fragments#BadConstantValue(String, Symbol, String):::compiler.misc.bad.constant.value=\    bad constant value ''{0}'' for {1}, expected {2}:::return->new->Fragment
CompilerProperties.Fragments#BadEnclosingMethod(Symbol):::compiler.misc.bad.enclosing.method=\    bad enclosing method attribute for class {0}:::return->new->Fragment
CompilerProperties.Fragments#BadInstanceMethodInUnboundLookup(Kind, Symbol):::compiler.misc.bad.instance.method.in.unbound.lookup=\    unexpected instance {0} {1} found in unbound lookup:::return->new->Fragment
CompilerProperties.Fragments#BadIntersectionTargetForFunctionalExpr(JCDiagnostic):::compiler.misc.bad.intersection.target.for.functional.expr=\    bad intersection type target for lambda or method reference\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#BadIntersectionTargetForFunctionalExpr(Fragment):::compiler.misc.bad.intersection.target.for.functional.expr=\    bad intersection type target for lambda or method reference\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(File, JCDiagnostic):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(File, Fragment):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(JavaFileObject, JCDiagnostic):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(JavaFileObject, Fragment):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(Path, JCDiagnostic):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadSourceFileHeader(Path, Fragment):::compiler.misc.bad.source.file.header=\    bad source file: {0}\n\    {1}\n\    Please remove or make sure it appears in the correct subdirectory of the sourcepath.:::return->new->Fragment
CompilerProperties.Fragments#BadStaticMethodInBoundLookup(Kind, Symbol):::compiler.misc.bad.static.method.in.bound.lookup=\    unexpected static {0} {1} found in bound lookup:::return->new->Fragment
CompilerProperties.Fragments#BadStaticMethodInUnboundLookup(Kind, Symbol):::compiler.misc.bad.static.method.in.unbound.lookup=\    unexpected static {0} {1} found in unbound lookup:::return->new->Fragment
CompilerProperties.Fragments#CantAccessInnerClsConstr(Symbol, List, Type):::compiler.misc.cant.access.inner.cls.constr=\    cannot access constructor {0}({1})\n\    an enclosing instance of type {2} is not in scope:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(JCDiagnostic, JCDiagnostic):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(JCDiagnostic, Fragment):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(Fragment, JCDiagnostic):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(Fragment, Fragment):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(Type, JCDiagnostic):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplyDiamond1(Type, Fragment):::compiler.misc.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, List, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, List, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, JCDiagnostic, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, Fragment, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, List, Fragment, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, List, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, List, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, JCDiagnostic, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, Fragment, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, JCDiagnostic, Fragment, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, List, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, List, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, JCDiagnostic, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, Fragment, Kind, Type, JCDiagnostic):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbol(Kind, Name, Fragment, Fragment, Kind, Type, Fragment):::compiler.misc.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Fragment
CompilerProperties.Fragments#CantApplySymbols(Kind, Name, List):::compiler.misc.cant.apply.symbols=\    no suitable {0} found for {1}({2}):::return->new->Fragment
CompilerProperties.Fragments#CantHide(Symbol, Symbol, Symbol, Symbol):::compiler.misc.cant.hide=\    {0} in {1} cannot hide {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#CantImplement(Symbol, Symbol, Symbol, Symbol):::compiler.misc.cant.implement=\    {0} in {1} cannot implement {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#CantOverride(Symbol, Symbol, Symbol, Symbol):::compiler.misc.cant.override=\    {0} in {1} cannot override {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#CantResolveArgs(KindName, Name, Void, List):::compiler.misc.cant.resolve.args=\    cannot find symbol\n\    symbol: {0} {1}({3}):::return->new->Fragment
CompilerProperties.Fragments#CantResolveLocationArgs(KindName, Name, Void, List, JCDiagnostic):::compiler.misc.cant.resolve.location.args=\    cannot find symbol\n\    symbol:   {0} {1}({3})\n\    location: {4}:::return->new->Fragment
CompilerProperties.Fragments#CantResolveLocationArgs(KindName, Name, Void, List, Fragment):::compiler.misc.cant.resolve.location.args=\    cannot find symbol\n\    symbol:   {0} {1}({3})\n\    location: {4}:::return->new->Fragment
CompilerProperties.Fragments#CantResolveLocationArgsParams(KindName, Name, List, List, JCDiagnostic):::compiler.misc.cant.resolve.location.args.params=\    cannot find symbol\n\    symbol:   {0} <{2}>{1}({3})\n\    location: {4}:::return->new->Fragment
CompilerProperties.Fragments#CantResolveLocationArgsParams(KindName, Name, List, List, Fragment):::compiler.misc.cant.resolve.location.args.params=\    cannot find symbol\n\    symbol:   {0} <{2}>{1}({3})\n\    location: {4}:::return->new->Fragment
CompilerProperties.Fragments#CapturedType(int):::compiler.misc.captured.type=\    CAP#{0}:::return->new->Fragment
CompilerProperties.Fragments#ClashesWith(Symbol, Symbol, Symbol, Symbol):::compiler.misc.clashes.with=\    {0} in {1} clashes with {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#ClassFileNotFound(Name):::compiler.misc.class.file.not.found=\    class file for {0} not found:::return->new->Fragment
CompilerProperties.Fragments#CountError(int):::compiler.misc.count.error=\    {0} error:::return->new->Fragment
CompilerProperties.Fragments#CountErrorPlural(int):::compiler.misc.count.error.plural=\    {0} errors:::return->new->Fragment
CompilerProperties.Fragments#CountWarn(int):::compiler.misc.count.warn=\    {0} warning:::return->new->Fragment
CompilerProperties.Fragments#CountWarnPlural(int):::compiler.misc.count.warn.plural=\    {0} warnings:::return->new->Fragment
CompilerProperties.Fragments#Descriptor(Name, List, Type, List):::compiler.misc.descriptor=\    descriptor: {2} {0}({1}):::return->new->Fragment
CompilerProperties.Fragments#DescriptorThrows(Name, List, Type, List):::compiler.misc.descriptor.throws=\    descriptor: {2} {0}({1}) throws {3}:::return->new->Fragment
CompilerProperties.Fragments#Diamond(Symbol):::compiler.misc.diamond=\    {0}<>:::return->new->Fragment
CompilerProperties.Fragments#DiamondAndExplicitParams(Type):::compiler.misc.diamond.and.explicit.params=\    cannot use ''<>'' with explicit type parameters for constructor:::return->new->Fragment
CompilerProperties.Fragments#DiamondInvalidArg(List, JCDiagnostic):::compiler.misc.diamond.invalid.arg=\    type argument {0} inferred for {1} is not allowed in this context\n\    inferred argument is not expressible in the Signature attribute:::return->new->Fragment
CompilerProperties.Fragments#DiamondInvalidArg(List, Fragment):::compiler.misc.diamond.invalid.arg=\    type argument {0} inferred for {1} is not allowed in this context\n\    inferred argument is not expressible in the Signature attribute:::return->new->Fragment
CompilerProperties.Fragments#DiamondInvalidArgs(List, JCDiagnostic):::compiler.misc.diamond.invalid.args=\    type arguments {0} inferred for {1} are not allowed in this context\n\    inferred arguments are not expressible in the Signature attribute:::return->new->Fragment
CompilerProperties.Fragments#DiamondInvalidArgs(List, Fragment):::compiler.misc.diamond.invalid.args=\    type arguments {0} inferred for {1} are not allowed in this context\n\    inferred arguments are not expressible in the Signature attribute:::return->new->Fragment
CompilerProperties.Fragments#DiamondNonGeneric(Type):::compiler.misc.diamond.non.generic=\    cannot use ''<>'' with non-generic class {0}:::return->new->Fragment
CompilerProperties.Fragments#EqBounds(List):::compiler.misc.eq.bounds=\        equality constraints: {0}:::return->new->Fragment
CompilerProperties.Fragments#ExceptionMessage(String):::compiler.misc.exception.message=\    {0}:::return->new->Fragment
CompilerProperties.Fragments#ExplicitParamDoNotConformToBounds(Type, List):::compiler.misc.explicit.param.do.not.conform.to.bounds=\    explicit type argument {0} does not conform to declared bound(s) {1}:::return->new->Fragment
CompilerProperties.Fragments#FatalErrCantLocateCtor(Type):::compiler.misc.fatal.err.cant.locate.ctor=\    Fatal Error: Unable to find constructor for {0}:::return->new->Fragment
CompilerProperties.Fragments#FatalErrCantLocateField(Name):::compiler.misc.fatal.err.cant.locate.field=\    Fatal Error: Unable to find field {0}:::return->new->Fragment
CompilerProperties.Fragments#FatalErrCantLocateMeth(Name):::compiler.misc.fatal.err.cant.locate.meth=\    Fatal Error: Unable to find method {0}:::return->new->Fragment
CompilerProperties.Fragments#FeatureNotSupportedInSource(JCDiagnostic, String, String):::compiler.misc.feature.not.supported.in.source=\   {0} is not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Fragment
CompilerProperties.Fragments#FeatureNotSupportedInSource(Fragment, String, String):::compiler.misc.feature.not.supported.in.source=\   {0} is not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Fragment
CompilerProperties.Fragments#FeatureNotSupportedInSourcePlural(JCDiagnostic, String, String):::compiler.misc.feature.not.supported.in.source.plural=\   {0} are not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Fragment
CompilerProperties.Fragments#FeatureNotSupportedInSourcePlural(Fragment, String, String):::compiler.misc.feature.not.supported.in.source.plural=\   {0} are not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Fragment
CompilerProperties.Fragments#FileDoesNotContainPackage(Symbol):::compiler.misc.file.does.not.contain.package=\    file does not contain package {0}:::return->new->Fragment
CompilerProperties.Fragments#FileDoesntContainClass(Name):::compiler.misc.file.doesnt.contain.class=\    file does not contain class {0}:::return->new->Fragment
CompilerProperties.Fragments#IllegalSignature(Symbol, Type):::compiler.misc.illegal.signature=\    illegal signature attribute for type {1}:::return->new->Fragment
CompilerProperties.Fragments#InaccessibleVarargsType(Type, Kind, Symbol):::compiler.misc.inaccessible.varargs.type=\    formal varargs element type {0} is not accessible from {1} {2}:::return->new->Fragment
CompilerProperties.Fragments#InapplicableMethod(KindName, Symbol, Symbol, JCDiagnostic):::compiler.misc.inapplicable.method=\    {0} {1}.{2} is not applicable\n\    ({3}):::return->new->Fragment
CompilerProperties.Fragments#InapplicableMethod(KindName, Symbol, Symbol, Fragment):::compiler.misc.inapplicable.method=\    {0} {1}.{2} is not applicable\n\    ({3}):::return->new->Fragment
CompilerProperties.Fragments#IncompatibleAbstractDefault(KindName, Type, Name, List, Symbol, Symbol):::compiler.misc.incompatible.abstract.default=\    {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleAbstracts(KindName, Symbol):::compiler.misc.incompatible.abstracts=\    multiple non-overriding abstract methods found in {0} {1}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleBounds(Type, Fragment, Fragment):::compiler.misc.incompatible.bounds=\    inference variable {0} has incompatible bounds\n\    {1}\n\    {2}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleDescsInFunctionalIntf(KindName, Symbol):::compiler.misc.incompatible.descs.in.functional.intf=\    incompatible function descriptors found in {0} {1}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleDiffRet(Name, List):::compiler.misc.incompatible.diff.ret=\    both define {0}({1}), but with unrelated return types:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleEqBounds(Type, List):::compiler.misc.incompatible.eq.bounds=\    inference variable {0} has incompatible equality constraints {1}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleRetTypeInLambda(JCDiagnostic):::compiler.misc.incompatible.ret.type.in.lambda=\    bad return type in lambda expression\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleRetTypeInLambda(Fragment):::compiler.misc.incompatible.ret.type.in.lambda=\    bad return type in lambda expression\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleRetTypeInMref(JCDiagnostic):::compiler.misc.incompatible.ret.type.in.mref=\    bad return type in method reference\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleRetTypeInMref(Fragment):::compiler.misc.incompatible.ret.type.in.mref=\    bad return type in method reference\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleTypeInConditional(JCDiagnostic):::compiler.misc.incompatible.type.in.conditional=\    bad type in conditional expression\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleTypeInConditional(Fragment):::compiler.misc.incompatible.type.in.conditional=\    bad type in conditional expression\n\    {0}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleUnrelatedDefaults(KindName, Type, Name, List, Symbol, Symbol):::compiler.misc.incompatible.unrelated.defaults=\    {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}:::return->new->Fragment
CompilerProperties.Fragments#IncompatibleUpperBounds(Type, List):::compiler.misc.incompatible.upper.bounds=\    inference variable {0} has incompatible upper bounds {1}:::return->new->Fragment
CompilerProperties.Fragments#InconvertibleTypes(Type, Type):::compiler.misc.inconvertible.types=\    {0} cannot be converted to {1}:::return->new->Fragment
CompilerProperties.Fragments#InferArgLengthMismatch(List):::compiler.misc.infer.arg.length.mismatch=\    cannot infer type-variable(s) {0}\n\    (actual and formal argument lists differ in length):::return->new->Fragment
CompilerProperties.Fragments#InferNoConformingAssignmentExists(List, JCDiagnostic):::compiler.misc.infer.no.conforming.assignment.exists=\    cannot infer type-variable(s) {0}\n\    (argument mismatch; {1}):::return->new->Fragment
CompilerProperties.Fragments#InferNoConformingAssignmentExists(List, Fragment):::compiler.misc.infer.no.conforming.assignment.exists=\    cannot infer type-variable(s) {0}\n\    (argument mismatch; {1}):::return->new->Fragment
CompilerProperties.Fragments#InferNoConformingInstanceExists(List, Type, Type):::compiler.misc.infer.no.conforming.instance.exists=\    no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}:::return->new->Fragment
CompilerProperties.Fragments#InferVarargsArgumentMismatch(List, JCDiagnostic):::compiler.misc.infer.varargs.argument.mismatch=\    cannot infer type-variable(s) {0}\n\    (varargs mismatch; {1}):::return->new->Fragment
CompilerProperties.Fragments#InferVarargsArgumentMismatch(List, Fragment):::compiler.misc.infer.varargs.argument.mismatch=\    cannot infer type-variable(s) {0}\n\    (varargs mismatch; {1}):::return->new->Fragment
CompilerProperties.Fragments#InferredDoNotConformToEqBounds(Type, List):::compiler.misc.inferred.do.not.conform.to.eq.bounds=\    inferred type does not conform to equality constraint(s)\n\    inferred: {0}\n\    equality constraints(s): {1}:::return->new->Fragment
CompilerProperties.Fragments#InferredDoNotConformToLowerBounds(Type, List):::compiler.misc.inferred.do.not.conform.to.lower.bounds=\    inferred type does not conform to lower bound(s)\n\    inferred: {0}\n\    lower bound(s): {1}:::return->new->Fragment
CompilerProperties.Fragments#InferredDoNotConformToUpperBounds(Type, List):::compiler.misc.inferred.do.not.conform.to.upper.bounds=\    inferred type does not conform to upper bound(s)\n\    inferred: {0}\n\    upper bound(s): {1}:::return->new->Fragment
CompilerProperties.Fragments#IntersectionType(int):::compiler.misc.intersection.type=\    INT#{0}:::return->new->Fragment
CompilerProperties.Fragments#InvalidDefaultInterface(String, String):::compiler.misc.invalid.default.interface=\    default method found in version {0}.{1} classfile:::return->new->Fragment
CompilerProperties.Fragments#InvalidGenericLambdaTarget(Type, KindName, Symbol):::compiler.misc.invalid.generic.lambda.target=\    invalid functional descriptor for lambda expression\n\    method {0} in {1} {2} is generic:::return->new->Fragment
CompilerProperties.Fragments#InvalidMref(KindName, JCDiagnostic):::compiler.misc.invalid.mref=\    invalid {0} reference\n\    {1}:::return->new->Fragment
CompilerProperties.Fragments#InvalidMref(KindName, Fragment):::compiler.misc.invalid.mref=\    invalid {0} reference\n\    {1}:::return->new->Fragment
CompilerProperties.Fragments#InvalidStaticInterface(String, String):::compiler.misc.invalid.static.interface=\    static method found in version {0}.{1} classfile:::return->new->Fragment
CompilerProperties.Fragments#Location(KindName, Type, Void):::compiler.misc.location=\    {0} {1}:::return->new->Fragment
CompilerProperties.Fragments#Location(KindName, Symbol, Void):::compiler.misc.location=\    {0} {1}:::return->new->Fragment
CompilerProperties.Fragments#Location1(KindName, Symbol, Type):::compiler.misc.location.1=\    {0} {1} of type {2}:::return->new->Fragment
CompilerProperties.Fragments#LowerBounds(List):::compiler.misc.lower.bounds=\        lower bounds: {0}:::return->new->Fragment
CompilerProperties.Fragments#MissingRetVal(Type):::compiler.misc.missing.ret.val=\    missing return value:::return->new->Fragment
CompilerProperties.Fragments#ModuleNameMismatch(Name, Name):::compiler.misc.module.name.mismatch=\    module name {0} does not match expected name {1}:::return->new->Fragment
CompilerProperties.Fragments#ModuleNonZeroOpens(Name):::compiler.misc.module.non.zero.opens=\    open module {0} has non-zero opens_count:::return->new->Fragment
CompilerProperties.Fragments#NoAbstracts(KindName, Symbol):::compiler.misc.no.abstracts=\    no abstract method found in {0} {1}:::return->new->Fragment
CompilerProperties.Fragments#NoConformingAssignmentExists(JCDiagnostic):::compiler.misc.no.conforming.assignment.exists=\    argument mismatch; {0}:::return->new->Fragment
CompilerProperties.Fragments#NoConformingAssignmentExists(Fragment):::compiler.misc.no.conforming.assignment.exists=\    argument mismatch; {0}:::return->new->Fragment
CompilerProperties.Fragments#NoSuitableFunctionalIntfInst(Type):::compiler.misc.no.suitable.functional.intf.inst=\    cannot infer functional interface descriptor for {0}:::return->new->Fragment
CompilerProperties.Fragments#NoUniqueMaximalInstanceExists(Type, List):::compiler.misc.no.unique.maximal.instance.exists=\    no unique maximal instance exists for type variable {0} with upper bounds {1}:::return->new->Fragment
CompilerProperties.Fragments#NoUniqueMinimalInstanceExists(Type, List):::compiler.misc.no.unique.minimal.instance.exists=\    no unique minimal instance exists for type variable {0} with lower bounds {1}:::return->new->Fragment
CompilerProperties.Fragments#NotAFunctionalIntf(Symbol):::compiler.misc.not.a.functional.intf=\    {0} is not a functional interface:::return->new->Fragment
CompilerProperties.Fragments#NotAFunctionalIntf1(Symbol, JCDiagnostic):::compiler.misc.not.a.functional.intf.1=\    {0} is not a functional interface\n\    {1}:::return->new->Fragment
CompilerProperties.Fragments#NotAFunctionalIntf1(Symbol, Fragment):::compiler.misc.not.a.functional.intf.1=\    {0} is not a functional interface\n\    {1}:::return->new->Fragment
CompilerProperties.Fragments#NotAnIntfComponent(Symbol):::compiler.misc.not.an.intf.component=\    component type {0} is not an interface:::return->new->Fragment
CompilerProperties.Fragments#NotAnIntfComponent(Type):::compiler.misc.not.an.intf.component=\    component type {0} is not an interface:::return->new->Fragment
CompilerProperties.Fragments#NotApplicableMethodFound(int, Symbol, JCDiagnostic):::compiler.misc.not.applicable.method.found=\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#NotApplicableMethodFound(int, Symbol, Fragment):::compiler.misc.not.applicable.method.found=\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessClassIntfCantAccess(Symbol, Symbol):::compiler.misc.not.def.access.class.intf.cant.access=\    {1}.{0} is defined in an inaccessible class or interface:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessClassIntfCantAccessReason(Symbol, Symbol, Symbol, JCDiagnostic):::compiler.misc.not.def.access.class.intf.cant.access.reason=\    {1}.{0} in package {2} is not accessible\n\    ({3}):::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessClassIntfCantAccessReason(Symbol, Symbol, Symbol, Fragment):::compiler.misc.not.def.access.class.intf.cant.access.reason=\    {1}.{0} in package {2} is not accessible\n\    ({3}):::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessDoesNotRead(Symbol, Symbol, Symbol):::compiler.misc.not.def.access.does.not.read=\    package {1} is declared in module {2}, but module {0} does not read it:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessDoesNotReadFromUnnamed(Symbol, Symbol):::compiler.misc.not.def.access.does.not.read.from.unnamed=\    package {0} is declared in module {1}, which is not in the module graph:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessDoesNotReadUnnamed(Symbol, Symbol):::compiler.misc.not.def.access.does.not.read.unnamed=\    package {0} is declared in the unnamed module, but module {0} does not read it:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessNotExported(Symbol, Symbol):::compiler.misc.not.def.access.not.exported=\    package {0} is declared in module {1}, which does not export it:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessNotExportedFromUnnamed(Symbol, Symbol):::compiler.misc.not.def.access.not.exported.from.unnamed=\    package {0} is declared in module {1}, which does not export it:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessNotExportedToModule(Symbol, Symbol, Symbol):::compiler.misc.not.def.access.not.exported.to.module=\    package {0} is declared in module {1}, which does not export it to module {2}:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessNotExportedToModuleFromUnnamed(Symbol, Symbol):::compiler.misc.not.def.access.not.exported.to.module.from.unnamed=\    package {0} is declared in module {1}, which does not export it to the unnamed module:::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessPackageCantAccess(Symbol, Symbol, JCDiagnostic):::compiler.misc.not.def.access.package.cant.access=\    {0} is not visible\n\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#NotDefAccessPackageCantAccess(Symbol, Symbol, Fragment):::compiler.misc.not.def.access.package.cant.access=\    {0} is not visible\n\    ({2}):::return->new->Fragment
CompilerProperties.Fragments#NotDefPublicCantAccess(Symbol, Symbol):::compiler.misc.not.def.public.cant.access=\    {0} is not public in {1}; cannot be accessed from outside package:::return->new->Fragment
CompilerProperties.Fragments#OverriddenDefault(Symbol, Type):::compiler.misc.overridden.default=\    method {0} is overridden in {1}:::return->new->Fragment
CompilerProperties.Fragments#PackageNotVisible(Symbol, JCDiagnostic):::compiler.misc.package.not.visible=\    package {0} is not visible\n\    ({1}):::return->new->Fragment
CompilerProperties.Fragments#PackageNotVisible(Symbol, Fragment):::compiler.misc.package.not.visible=\    package {0} is not visible\n\    ({1}):::return->new->Fragment
CompilerProperties.Fragments#PartialInstSig(Type):::compiler.misc.partial.inst.sig=\    partially instantiated to: {0}:::return->new->Fragment
CompilerProperties.Fragments#PossibleLossOfPrecision(Type, Type):::compiler.misc.possible.loss.of.precision=\    possible lossy conversion from {0} to {1}:::return->new->Fragment
CompilerProperties.Fragments#ProbFoundReq(JCDiagnostic):::compiler.misc.prob.found.req=\    incompatible types: {0}:::return->new->Fragment
CompilerProperties.Fragments#ProbFoundReq(Fragment):::compiler.misc.prob.found.req=\    incompatible types: {0}:::return->new->Fragment
CompilerProperties.Fragments#RedundantSupertype(Symbol, Type):::compiler.misc.redundant.supertype=\    redundant interface {0} is extended by {1}:::return->new->Fragment
CompilerProperties.Fragments#RedundantSupertype(Symbol, Symbol):::compiler.misc.redundant.supertype=\    redundant interface {0} is extended by {1}:::return->new->Fragment
CompilerProperties.Fragments#RefAmbiguous(Name, Kind, Symbol, Symbol, Kind, Symbol, Symbol):::compiler.misc.ref.ambiguous=\    reference to {0} is ambiguous\n\    both {1} {2} in {3} and {4} {5} in {6} match:::return->new->Fragment
CompilerProperties.Fragments#ReportAccess(Symbol, Set, Symbol):::compiler.misc.report.access=\    {0} has {1} access in {2}:::return->new->Fragment
CompilerProperties.Fragments#SyntheticNameConflict(Symbol, Symbol):::compiler.misc.synthetic.name.conflict=\    the symbol {0} conflicts with a compiler-synthesized symbol in {1}:::return->new->Fragment
CompilerProperties.Fragments#TryNotApplicableToType(JCDiagnostic):::compiler.misc.try.not.applicable.to.type=\    try-with-resources not applicable to variable type\n\    ({0}):::return->new->Fragment
CompilerProperties.Fragments#TryNotApplicableToType(Fragment):::compiler.misc.try.not.applicable.to.type=\    try-with-resources not applicable to variable type\n\    ({0}):::return->new->Fragment
CompilerProperties.Fragments#TypeCaptureof(Name, Type):::compiler.misc.type.captureof=\    capture#{0} of {1}:::return->new->Fragment
CompilerProperties.Fragments#TypeParameter(Type):::compiler.misc.type.parameter=\    type parameter {0}:::return->new->Fragment
CompilerProperties.Fragments#TypeVar(Name, int):::compiler.misc.type.var=\    {0}#{1}:::return->new->Fragment
CompilerProperties.Fragments#UncheckedClashWith(Symbol, Symbol, Symbol, Symbol):::compiler.misc.unchecked.clash.with=\    {0} in {1} overrides {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#UncheckedImplement(Symbol, Symbol, Symbol, Symbol):::compiler.misc.unchecked.implement=\    {0} in {1} implements {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#UncheckedOverride(Symbol, Symbol, Symbol, Symbol):::compiler.misc.unchecked.override=\    {0} in {1} overrides {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#UpperBounds(List):::compiler.misc.upper.bounds=\        lower bounds: {0}:::return->new->Fragment
CompilerProperties.Fragments#VarargsArgumentMismatch(JCDiagnostic):::compiler.misc.varargs.argument.mismatch=\    varargs mismatch; {0}:::return->new->Fragment
CompilerProperties.Fragments#VarargsArgumentMismatch(Fragment):::compiler.misc.varargs.argument.mismatch=\    varargs mismatch; {0}:::return->new->Fragment
CompilerProperties.Fragments#VarargsClashWith(Symbol, Symbol, Symbol, Symbol):::compiler.misc.varargs.clash.with=\    {0} in {1} overrides {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#VarargsImplement(Symbol, Symbol, Symbol, Symbol):::compiler.misc.varargs.implement=\    {0} in {1} implements {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#VarargsOverride(Symbol, Symbol, Symbol, Symbol):::compiler.misc.varargs.override=\    {0} in {1} overrides {2} in {3}:::return->new->Fragment
CompilerProperties.Fragments#VarargsTrustmeOnNonVarargsMeth(Symbol):::compiler.misc.varargs.trustme.on.non.varargs.meth=\    Method {0} is not a varargs method.:::return->new->Fragment
CompilerProperties.Fragments#VarargsTrustmeOnReifiableVarargs(Type):::compiler.misc.varargs.trustme.on.reifiable.varargs=\    Varargs element type {0} is reifiable.:::return->new->Fragment
CompilerProperties.Fragments#VarargsTrustmeOnVirtualVarargs(Symbol):::compiler.misc.varargs.trustme.on.virtual.varargs=\    Instance method {0} is neither final nor private.:::return->new->Fragment
CompilerProperties.Fragments#VarargsTrustmeOnVirtualVarargsFinalOnly(Symbol):::compiler.misc.varargs.trustme.on.virtual.varargs.final.only=\    Instance method {0} is not final.:::return->new->Fragment
CompilerProperties.Fragments#VerboseCheckingAttribution(Symbol):::compiler.misc.verbose.checking.attribution=\    [checking {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseClasspath(String):::compiler.misc.verbose.classpath=\    [search path for class files: {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseLoading(String):::compiler.misc.verbose.loading=\    [loading {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseParsingDone(String):::compiler.misc.verbose.parsing.done=\    [parsing completed {0}ms]:::return->new->Fragment
CompilerProperties.Fragments#VerboseParsingStarted(File):::compiler.misc.verbose.parsing.started=\    [parsing started {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseParsingStarted(JavaFileObject):::compiler.misc.verbose.parsing.started=\    [parsing started {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseParsingStarted(Path):::compiler.misc.verbose.parsing.started=\    [parsing started {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseSourcepath(String):::compiler.misc.verbose.sourcepath=\    [search path for source files: {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseTotal(String):::compiler.misc.verbose.total=\    [total {0}ms]:::return->new->Fragment
CompilerProperties.Fragments#VerboseWroteFile(File):::compiler.misc.verbose.wrote.file=\    [wrote {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseWroteFile(JavaFileObject):::compiler.misc.verbose.wrote.file=\    [wrote {0}]:::return->new->Fragment
CompilerProperties.Fragments#VerboseWroteFile(Path):::compiler.misc.verbose.wrote.file=\    [wrote {0}]:::return->new->Fragment
CompilerProperties.Fragments#WhereCaptured(Type, Type, Type, Type):::compiler.misc.where.captured=\    {0} extends {1} super: {2} from capture of {3}:::return->new->Fragment
CompilerProperties.Fragments#WhereCaptured1(Type, Type, Void, Type):::compiler.misc.where.captured.1=\    {0} extends {1} from capture of {3}:::return->new->Fragment
CompilerProperties.Fragments#WhereDescriptionCaptured1(Set):::compiler.misc.where.description.captured.1=\    where {0} are fresh type-variables::::return->new->Fragment
CompilerProperties.Fragments#WhereDescriptionIntersection(Set):::compiler.misc.where.description.intersection=\    where {0} is an intersection type::::return->new->Fragment
CompilerProperties.Fragments#WhereDescriptionIntersection1(Set):::compiler.misc.where.description.intersection.1=\    where {0} are intersection types::::return->new->Fragment
CompilerProperties.Fragments#WhereDescriptionTypevar(Set):::compiler.misc.where.description.typevar=\    where {0} is a type-variable::::return->new->Fragment
CompilerProperties.Fragments#WhereDescriptionTypevar1(Set):::compiler.misc.where.description.typevar.1=\    where {0} are type-variables::::return->new->Fragment
CompilerProperties.Fragments#WhereFreshTypevar(Type, List):::compiler.misc.where.fresh.typevar=\    {0} extends {1}:::return->new->Fragment
CompilerProperties.Fragments#WhereIntersection(Type, List):::compiler.misc.where.intersection=\    {0} extends {1}:::return->new->Fragment
CompilerProperties.Fragments#WhereTypevar(Type, List, Kind, Symbol):::compiler.misc.where.typevar=\    {0} extends {1} declared in {2} {3}:::return->new->Fragment
CompilerProperties.Fragments#WhereTypevar1(Type, List, Kind, Symbol):::compiler.misc.where.typevar.1=\    {0} declared in {2} {3}:::return->new->Fragment
CompilerProperties.Fragments#WrongNumberTypeArgs(String):::compiler.misc.wrong.number.type.args=\    wrong number of type arguments; required {0}:::return->new->Fragment
CompilerProperties.Fragments#XPrintProcessorInfo(String, String, boolean):::compiler.misc.x.print.processor.info=\    Processor {0} matches {1} and returns {2}.:::return->new->Fragment
CompilerProperties.Fragments#XPrintRounds(int, String, Set, boolean):::compiler.misc.x.print.rounds=\    Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}:::return->new->Fragment
CompilerProperties.Errors#AbstractCantBeAccessedDirectly(KindName, Symbol, Symbol):::compiler.err.abstract.cant.be.accessed.directly=\    abstract {0} {1} in {2} cannot be accessed directly:::return->new->Error
CompilerProperties.Errors#AbstractCantBeInstantiated(Symbol):::compiler.err.abstract.cant.be.instantiated=\    {0} is abstract; cannot be instantiated:::return->new->Error
CompilerProperties.Errors#AddExportsWithRelease(Symbol):::compiler.err.add.exports.with.release=\    exporting a package from system module {0} is not allowed with --release:::return->new->Error
CompilerProperties.Errors#AddReadsWithRelease(Symbol):::compiler.err.add.reads.with.release=\    adding read edges for system module {0} is not allowed with --release:::return->new->Error
CompilerProperties.Errors#AlreadyAnnotated(KindName, Symbol):::compiler.err.already.annotated=\    {0} {1} has already been annotated:::return->new->Error
CompilerProperties.Errors#AlreadyDefined(KindName, Symbol, KindName, Symbol):::compiler.err.already.defined=\    {0} {1} is already defined in {2} {3}:::return->new->Error
CompilerProperties.Errors#AlreadyDefinedInClinit(KindName, Symbol, KindName, KindName, Symbol):::compiler.err.already.defined.in.clinit=\    {0} {1} is already defined in {2} of {3} {4}:::return->new->Error
CompilerProperties.Errors#AlreadyDefinedSingleImport(Symbol):::compiler.err.already.defined.single.import=\    a type with the same simple name is already defined by the single-type-import of {0}:::return->new->Error
CompilerProperties.Errors#AlreadyDefinedStaticSingleImport(Symbol):::compiler.err.already.defined.static.single.import=\    a type with the same simple name is already defined by the static single-type-import of {0}:::return->new->Error
CompilerProperties.Errors#AlreadyDefinedThisUnit(Symbol):::compiler.err.already.defined.this.unit=\    {0} is already defined in this compilation unit:::return->new->Error
CompilerProperties.Errors#AnnotationMissingDefaultValue(Type, List):::compiler.err.annotation.missing.default.value=\    annotation @{0} is missing a default value for the element ''{1}'':::return->new->Error
CompilerProperties.Errors#AnnotationMissingDefaultValue1(Type, List):::compiler.err.annotation.missing.default.value.1=\    annotation @{0} is missing default values for elements {1}:::return->new->Error
CompilerProperties.Errors#AnnotationNotValidForType(Type):::compiler.err.annotation.not.valid.for.type=\    annotation not valid for an element of type {0}:::return->new->Error
CompilerProperties.Errors#AnnotationTypeNotApplicableToType(Type):::compiler.err.annotation.type.not.applicable.to.type=\    annotation @{0} not applicable in this type context:::return->new->Error
CompilerProperties.Errors#AnonymousDiamondMethodDoesNotOverrideSuperclass(JCDiagnostic):::compiler.err.anonymous.diamond.method.does.not.override.superclass=\    method does not override or implement a method from a supertype\n\    {0}:::return->new->Error
CompilerProperties.Errors#AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragment):::compiler.err.anonymous.diamond.method.does.not.override.superclass=\    method does not override or implement a method from a supertype\n\    {0}:::return->new->Error
CompilerProperties.Errors#ArrayAndVarargs(Symbol, Symbol, Symbol):::compiler.err.array.and.varargs=\    cannot declare both {0} and {1} in {2}:::return->new->Error
CompilerProperties.Errors#ArrayReqButFound(Type):::compiler.err.array.req.but.found=\    array required, but {0} found:::return->new->Error
CompilerProperties.Errors#BadFunctionalIntfAnno1(JCDiagnostic):::compiler.err.bad.functional.intf.anno.1=\    Unexpected @FunctionalInterface annotation\n\    {0}:::return->new->Error
CompilerProperties.Errors#BadFunctionalIntfAnno1(Fragment):::compiler.err.bad.functional.intf.anno.1=\    Unexpected @FunctionalInterface annotation\n\    {0}:::return->new->Error
CompilerProperties.Errors#BadInitializer(String):::compiler.err.bad.initializer=\    bad initializer for {0}:::return->new->Error
CompilerProperties.Errors#BadNameForOption(Option, String):::compiler.err.bad.name.for.option=\    bad name in value for {0} option: ''{1}'':::return->new->Error
CompilerProperties.Errors#BadTargetSigpolyCall(Target, Target):::compiler.err.bad.target.sigpoly.call=\    polymorphic signature calls are not supported in -target {0}\n\    (use -target {1} or higher to enable polymorphic signature calls):::return->new->Error
CompilerProperties.Errors#BadValueForOption(String, String):::compiler.err.bad.value.for.option=\    bad value for {0} option: ''{1}'':::return->new->Error
CompilerProperties.Errors#CallMustBeFirstStmtInCtor(Name):::compiler.err.call.must.be.first.stmt.in.ctor=\    call to {0} must be first statement in constructor:::return->new->Error
CompilerProperties.Errors#CallToSuperNotAllowedInEnumCtor(Symbol):::compiler.err.call.to.super.not.allowed.in.enum.ctor=\    call to super not allowed in enum constructor:::return->new->Error
CompilerProperties.Errors#CannotGenerateClass(Symbol, Fragment):::compiler.err.cannot.generate.class=\    error while generating class {0}\n\    ({1}):::return->new->Error
CompilerProperties.Errors#CantAccess(Symbol, JCDiagnostic):::compiler.err.cant.access=\    cannot access {0}\n\    {1}:::return->new->Error
CompilerProperties.Errors#CantAccess(Symbol, Fragment):::compiler.err.cant.access=\    cannot access {0}\n\    {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond(JCDiagnostic, Void):::compiler.err.cant.apply.diamond=\    cannot infer type arguments for {0}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond(Fragment, Void):::compiler.err.cant.apply.diamond=\    cannot infer type arguments for {0}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(JCDiagnostic, JCDiagnostic):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(JCDiagnostic, Fragment):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(Fragment, JCDiagnostic):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(Fragment, Fragment):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(Type, JCDiagnostic):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplyDiamond1(Type, Fragment):::compiler.err.cant.apply.diamond.1=\    cannot infer type arguments for {0}\n\    reason: {1}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, List, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, List, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, JCDiagnostic, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, Fragment, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, List, Fragment, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, List, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, List, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, JCDiagnostic, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, Fragment, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, JCDiagnostic, Fragment, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, List, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, List, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, JCDiagnostic, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, JCDiagnostic, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, Fragment, Kind, Type, JCDiagnostic):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbol(Kind, Name, Fragment, Fragment, Kind, Type, Fragment):::compiler.err.cant.apply.symbol=\    {0} {1} in {4} {5} cannot be applied to given types;\n\    required: {2}\n\    found: {3}\n\    reason: {6}:::return->new->Error
CompilerProperties.Errors#CantApplySymbols(Kind, Name, List):::compiler.err.cant.apply.symbols=\    no suitable {0} found for {1}({2}):::return->new->Error
CompilerProperties.Errors#CantAssignValToFinalVar(Symbol):::compiler.err.cant.assign.val.to.final.var=\    cannot assign a value to final variable {0}:::return->new->Error
CompilerProperties.Errors#CantDeref(Type):::compiler.err.cant.deref=\    {0} cannot be dereferenced:::return->new->Error
CompilerProperties.Errors#CantInferLocalVarType(Name, JCDiagnostic):::compiler.err.cant.infer.local.var.type=\    cannot infer type for local variable {0}\n\    ({1}):::return->new->Error
CompilerProperties.Errors#CantInferLocalVarType(Name, Fragment):::compiler.err.cant.infer.local.var.type=\    cannot infer type for local variable {0}\n\    ({1}):::return->new->Error
CompilerProperties.Errors#CantInheritDiffArg(Symbol, String, String):::compiler.err.cant.inherit.diff.arg=\    {0} cannot be inherited with different arguments: <{1}> and <{2}>:::return->new->Error
CompilerProperties.Errors#CantInheritFromFinal(Symbol):::compiler.err.cant.inherit.from.final=\    cannot inherit from final {0}:::return->new->Error
CompilerProperties.Errors#CantRefBeforeCtorCalled(Symbol):::compiler.err.cant.ref.before.ctor.called=\    cannot reference {0} before supertype constructor has been called:::return->new->Error
CompilerProperties.Errors#CantRefBeforeCtorCalled(String):::compiler.err.cant.ref.before.ctor.called=\    cannot reference {0} before supertype constructor has been called:::return->new->Error
CompilerProperties.Errors#CantRefNonEffectivelyFinalVar(Symbol, JCDiagnostic):::compiler.err.cant.ref.non.effectively.final.var=\    local variables referenced from {1} must be final or effectively final:::return->new->Error
CompilerProperties.Errors#CantRefNonEffectivelyFinalVar(Symbol, Fragment):::compiler.err.cant.ref.non.effectively.final.var=\    local variables referenced from {1} must be final or effectively final:::return->new->Error
CompilerProperties.Errors#CantResolve(KindName, Name, Void, Void):::compiler.err.cant.resolve=\    cannot find symbol\n\    symbol: {0} {1}:::return->new->Error
CompilerProperties.Errors#CantResolveArgs(KindName, Name, Void, List):::compiler.err.cant.resolve.args=\    cannot find symbol\n\    symbol: {0} {1}({3}):::return->new->Error
CompilerProperties.Errors#CantResolveArgsParams(KindName, Name, List, List):::compiler.err.cant.resolve.args.params=\    cannot find symbol\n\    symbol: {0} <{2}>{1}({3}):::return->new->Error
CompilerProperties.Errors#CantResolveLocation(KindName, Name, Void, Void, JCDiagnostic):::compiler.err.cant.resolve.location=\    cannot find symbol\n\    symbol:   {0} {1}\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantResolveLocation(KindName, Name, Void, Void, Fragment):::compiler.err.cant.resolve.location=\    cannot find symbol\n\    symbol:   {0} {1}\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantResolveLocationArgs(KindName, Name, Void, List, JCDiagnostic):::compiler.err.cant.resolve.location.args=\    cannot find symbol\n\    symbol:   {0} {1}({3})\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantResolveLocationArgs(KindName, Name, Void, List, Fragment):::compiler.err.cant.resolve.location.args=\    cannot find symbol\n\    symbol:   {0} {1}({3})\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantResolveLocationArgsParams(KindName, Name, List, List, JCDiagnostic):::compiler.err.cant.resolve.location.args.params=\    cannot find symbol\n\    symbol:   {0} <{2}>{1}({3})\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantResolveLocationArgsParams(KindName, Name, List, List, Fragment):::compiler.err.cant.resolve.location.args.params=\    cannot find symbol\n\    symbol:   {0} <{2}>{1}({3})\n\    location: {4}:::return->new->Error
CompilerProperties.Errors#CantTypeAnnotateScoping(List):::compiler.err.cant.type.annotate.scoping=\    scoping construct cannot be annotated with type-use annotations: {0}:::return->new->Error
CompilerProperties.Errors#CantTypeAnnotateScoping1(Compound):::compiler.err.cant.type.annotate.scoping.1=\    scoping construct cannot be annotated with type-use annotation: {0}:::return->new->Error
CompilerProperties.Errors#ClashWithPkgOfSameName(KindName, Symbol):::compiler.err.clash.with.pkg.of.same.name=\    {0} {1} clashes with package of same name:::return->new->Error
CompilerProperties.Errors#ClassCantWrite(Symbol, String):::compiler.err.class.cant.write=\    error while writing {0}: {1}:::return->new->Error
CompilerProperties.Errors#ClassPublicShouldBeInFile(KindName, Name):::compiler.err.class.public.should.be.in.file=\    {0} {1} is public, should be declared in a file named {1}.java:::return->new->Error
CompilerProperties.Errors#ConcreteInheritanceConflict(Symbol, Type, Symbol, Type, Type):::compiler.err.concrete.inheritance.conflict=\    methods {0} from {1} and {2} from {3} are inherited with the same signature:::return->new->Error
CompilerProperties.Errors#ConflictingExports(Symbol):::compiler.err.conflicting.exports=\    duplicate or conflicting exports: {0}:::return->new->Error
CompilerProperties.Errors#ConflictingExportsToModule(Symbol):::compiler.err.conflicting.exports.to.module=\    duplicate or conflicting exports to module: {0}:::return->new->Error
CompilerProperties.Errors#ConflictingOpens(Symbol):::compiler.err.conflicting.opens=\    duplicate or conflicting opens: {0}:::return->new->Error
CompilerProperties.Errors#ConflictingOpensToModule(Symbol):::compiler.err.conflicting.opens.to.module=\    duplicate or conflicting opens to module: {0}:::return->new->Error
CompilerProperties.Errors#CyclicAnnotationElement(Symbol):::compiler.err.cyclic.annotation.element=\    type of element {0} is cyclic:::return->new->Error
CompilerProperties.Errors#CyclicInheritance(Symbol):::compiler.err.cyclic.inheritance=\    cyclic inheritance involving {0}:::return->new->Error
CompilerProperties.Errors#CyclicInheritance(Type):::compiler.err.cyclic.inheritance=\    cyclic inheritance involving {0}:::return->new->Error
CompilerProperties.Errors#CyclicRequires(Symbol):::compiler.err.cyclic.requires=\    cyclic dependence involving {0}:::return->new->Error
CompilerProperties.Errors#DefaultOverridesObjectMember(Name, KindName, Symbol):::compiler.err.default.overrides.object.member=\    default method {0} in {1} {2} overrides a member of java.lang.Object:::return->new->Error
CompilerProperties.Errors#DoesNotOverrideAbstract(Symbol, Symbol, Symbol):::compiler.err.does.not.override.abstract=\    {0} is not abstract and does not override abstract method {1} in {2}:::return->new->Error
CompilerProperties.Errors#DoesntExist(Symbol):::compiler.err.doesnt.exist=\    package {0} does not exist:::return->new->Error
CompilerProperties.Errors#DuplicateAnnotationInvalidRepeated(Type):::compiler.err.duplicate.annotation.invalid.repeated=\    annotation {0} is not a valid repeatable annotation:::return->new->Error
CompilerProperties.Errors#DuplicateAnnotationMemberValue(Name, Type):::compiler.err.duplicate.annotation.member.value=\    duplicate element ''{0}'' in annotation @{1}.:::return->new->Error
CompilerProperties.Errors#DuplicateAnnotationMissingContainer(Type):::compiler.err.duplicate.annotation.missing.container=\    {0} is not a repeatable annotation type:::return->new->Error
CompilerProperties.Errors#DuplicateClass(Name):::compiler.err.duplicate.class=\    duplicate class: {0}:::return->new->Error
CompilerProperties.Errors#DuplicateModule(Symbol):::compiler.err.duplicate.module=\    duplicate module: {0}:::return->new->Error
CompilerProperties.Errors#DuplicateModuleOnPath(Fragment, Name):::compiler.err.duplicate.module.on.path=\    duplicate module on {0}\nmodule in {1}:::return->new->Error
CompilerProperties.Errors#DuplicateProvides(Symbol, Symbol):::compiler.err.duplicate.provides=\    duplicate provides: service {0}, implementation {1}:::return->new->Error
CompilerProperties.Errors#DuplicateRequires(Symbol):::compiler.err.duplicate.requires=\    duplicate requires: {0}:::return->new->Error
CompilerProperties.Errors#DuplicateUses(Symbol):::compiler.err.duplicate.uses=\    duplicate uses: {0}:::return->new->Error
CompilerProperties.Errors#EnclClassRequired(Symbol):::compiler.err.encl.class.required=\    an enclosing instance that contains {0} is required:::return->new->Error
CompilerProperties.Errors#ErrorReadingFile(File, String):::compiler.err.error.reading.file=\    error reading {0}; {1}:::return->new->Error
CompilerProperties.Errors#ErrorReadingFile(JavaFileObject, String):::compiler.err.error.reading.file=\    error reading {0}; {1}:::return->new->Error
CompilerProperties.Errors#ErrorReadingFile(Path, String):::compiler.err.error.reading.file=\    error reading {0}; {1}:::return->new->Error
CompilerProperties.Errors#ErrorWritingFile(String, String):::compiler.err.error.writing.file=\    error writing {0}; {1}:::return->new->Error
CompilerProperties.Errors#ExceptAlreadyCaught(Type):::compiler.err.except.already.caught=\    exception {0} has already been caught:::return->new->Error
CompilerProperties.Errors#ExceptNeverThrownInTry(Type):::compiler.err.except.never.thrown.in.try=\    exception {0} is never thrown in body of corresponding try statement:::return->new->Error
CompilerProperties.Errors#Expected(TokenKind):::compiler.err.expected=\    {0} expected:::return->new->Error
CompilerProperties.Errors#ExpectedStr(String):::compiler.err.expected.str=\    {0} expected:::return->new->Error
CompilerProperties.Errors#Expected2(TokenKind, TokenKind):::compiler.err.expected2=\    {0} or {1} expected:::return->new->Error
CompilerProperties.Errors#Expected3(TokenKind, TokenKind, TokenKind):::compiler.err.expected3=\    {0}, {1}, or {2} expected:::return->new->Error
CompilerProperties.Errors#FeatureNotSupportedInSource(JCDiagnostic, String, String):::compiler.err.feature.not.supported.in.source=\   {0} is not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Error
CompilerProperties.Errors#FeatureNotSupportedInSource(Fragment, String, String):::compiler.err.feature.not.supported.in.source=\   {0} is not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Error
CompilerProperties.Errors#FeatureNotSupportedInSourcePlural(JCDiagnostic, String, String):::compiler.err.feature.not.supported.in.source.plural=\   {0} are not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Error
CompilerProperties.Errors#FeatureNotSupportedInSourcePlural(Fragment, String, String):::compiler.err.feature.not.supported.in.source.plural=\   {0} are not supported in -source {1}\n\    (use -source {2} or higher to enable {0}):::return->new->Error
CompilerProperties.Errors#FileNotDirectory(String):::compiler.err.file.not.directory=\    not a directory: {0}:::return->new->Error
CompilerProperties.Errors#FileNotFile(Object):::compiler.err.file.not.file=\    not a file: {0}:::return->new->Error
CompilerProperties.Errors#FileNotFound(String):::compiler.err.file.not.found=\    file not found: {0}:::return->new->Error
CompilerProperties.Errors#FilePatchedAndMsp(Name, Name):::compiler.err.file.patched.and.msp=\    file accessible from both --patch-module and --module-source-path, \    but belongs to a different module on each path: {0}, {1}:::return->new->Error
CompilerProperties.Errors#FinalParameterMayNotBeAssigned(Symbol):::compiler.err.final.parameter.may.not.be.assigned=\    final parameter {0} may not be assigned:::return->new->Error
CompilerProperties.Errors#ForeachNotApplicableToType(Type, JCDiagnostic):::compiler.err.foreach.not.applicable.to.type=\    for-each not applicable to expression type\n\    required: {1}\n\    found:    {0}:::return->new->Error
CompilerProperties.Errors#ForeachNotApplicableToType(Type, Fragment):::compiler.err.foreach.not.applicable.to.type=\    for-each not applicable to expression type\n\    required: {1}\n\    found:    {0}:::return->new->Error
CompilerProperties.Errors#IclsCantHaveStaticDecl(Symbol):::compiler.err.icls.cant.have.static.decl=\    Illegal static declaration in inner class {0}\n\    modifier \''static\'' is only allowed in constant variable declarations:::return->new->Error
CompilerProperties.Errors#IllegalArgumentForOption(String, String):::compiler.err.illegal.argument.for.option=\    illegal argument for {0}: {1}:::return->new->Error
CompilerProperties.Errors#IllegalChar(String):::compiler.err.illegal.char=\    illegal character: ''{0}'':::return->new->Error
CompilerProperties.Errors#IllegalCharForEncoding(String, String):::compiler.err.illegal.char.for.encoding=\    unmappable character (0x{0}) for encoding {1}:::return->new->Error
CompilerProperties.Errors#IllegalCombinationOfModifiers(Set, Set):::compiler.err.illegal.combination.of.modifiers=\    illegal combination of modifiers: {0} and {1}:::return->new->Error
CompilerProperties.Errors#IllegalDefaultSuperCall(Symbol, JCDiagnostic):::compiler.err.illegal.default.super.call=\    bad type qualifier {0} in default super call\n\    {1}:::return->new->Error
CompilerProperties.Errors#IllegalDefaultSuperCall(Symbol, Fragment):::compiler.err.illegal.default.super.call=\    bad type qualifier {0} in default super call\n\    {1}:::return->new->Error
CompilerProperties.Errors#IllegalDefaultSuperCall(Type, JCDiagnostic):::compiler.err.illegal.default.super.call=\    bad type qualifier {0} in default super call\n\    {1}:::return->new->Error
CompilerProperties.Errors#IllegalDefaultSuperCall(Type, Fragment):::compiler.err.illegal.default.super.call=\    bad type qualifier {0} in default super call\n\    {1}:::return->new->Error
CompilerProperties.Errors#IllegalInitializerForType(Type):::compiler.err.illegal.initializer.for.type=\    illegal initializer for {0}:::return->new->Error
CompilerProperties.Errors#IllegalQualNotIcls(Symbol):::compiler.err.illegal.qual.not.icls=\    illegal qualifier; {0} is not an inner class:::return->new->Error
CompilerProperties.Errors#IllegalStaticIntfMethCall(Type):::compiler.err.illegal.static.intf.meth.call=\    illegal static interface method call\n\    the receiver expression should be replaced with the type qualifier ''{0}'':::return->new->Error
CompilerProperties.Errors#ImportRequiresCanonical(Symbol):::compiler.err.import.requires.canonical=\    import requires canonical name for {0}:::return->new->Error
CompilerProperties.Errors#IncomparableTypes(Type, Type):::compiler.err.incomparable.types=\    incomparable types: {0} and {1}:::return->new->Error
CompilerProperties.Errors#IncompatibleThrownTypesInMref(List):::compiler.err.incompatible.thrown.types.in.mref=\    incompatible thrown types {0} in functional expression:::return->new->Error
CompilerProperties.Errors#IncorrectConstructorReceiverName(Type, Type):::compiler.err.incorrect.constructor.receiver.name=\    the receiver name does not match the enclosing outer class type\n\    required: {0}\n\    found: {1}:::return->new->Error
CompilerProperties.Errors#IncorrectConstructorReceiverType(Type, Type):::compiler.err.incorrect.constructor.receiver.type=\    the receiver type does not match the enclosing outer class type\n\    required: {0}\n\    found: {1}:::return->new->Error
CompilerProperties.Errors#IncorrectReceiverName(Type, Type):::compiler.err.incorrect.receiver.name=\    the receiver name does not match the enclosing class type\n\    required: {0}\n\    found: {1}:::return->new->Error
CompilerProperties.Errors#IncorrectReceiverType(Type, Type):::compiler.err.incorrect.receiver.type=\    the receiver type does not match the enclosing class type\n\    required: {0}\n\    found: {1}:::return->new->Error
CompilerProperties.Errors#IntNumberTooLarge(String):::compiler.err.int.number.too.large=\    integer number too large:::return->new->Error
CompilerProperties.Errors#IntfAnnotationCantHaveTypeParams(Symbol):::compiler.err.intf.annotation.cant.have.type.params=\    annotation type {0} cannot be generic:::return->new->Error
CompilerProperties.Errors#IntfAnnotationMemberClash(Symbol, Type):::compiler.err.intf.annotation.member.clash=\    annotation type {1} declares an element with the same name as method {0}:::return->new->Error
CompilerProperties.Errors#InvalidAKey(String):::compiler.err.invalid.A.key=\    key in annotation processor option ''{0}'' is not a dot-separated sequence of identifiers:::return->new->Error
CompilerProperties.Errors#InvalidFlag(String):::compiler.err.invalid.flag=\    invalid flag: {0}:::return->new->Error
CompilerProperties.Errors#InvalidLambdaParameterDeclaration(Fragment):::compiler.err.invalid.lambda.parameter.declaration=\    invalid lambda parameter declaration\n\    ({0}):::return->new->Error
CompilerProperties.Errors#InvalidModuleSpecifier(String):::compiler.err.invalid.module.specifier=\    module specifier not allowed: {0}:::return->new->Error
CompilerProperties.Errors#InvalidMref(KindName, JCDiagnostic):::compiler.err.invalid.mref=\    invalid {0} reference\n\    {1}:::return->new->Error
CompilerProperties.Errors#InvalidMref(KindName, Fragment):::compiler.err.invalid.mref=\    invalid {0} reference\n\    {1}:::return->new->Error
CompilerProperties.Errors#InvalidProfile(String):::compiler.err.invalid.profile=\    invalid profile: {0}:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotation(Symbol):::compiler.err.invalid.repeatable.annotation=\    duplicate annotation: {0} is annotated with an invalid @Repeatable annotation:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationElemNondefault(Symbol, Symbol):::compiler.err.invalid.repeatable.annotation.elem.nondefault=\    containing annotation type ({0}) does not have a default value for element {1}:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationElemNondefault(Type, Symbol):::compiler.err.invalid.repeatable.annotation.elem.nondefault=\    containing annotation type ({0}) does not have a default value for element {1}:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationIncompatibleTarget(Symbol, Symbol):::compiler.err.invalid.repeatable.annotation.incompatible.target=\    containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1}):::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationInvalidValue(Type):::compiler.err.invalid.repeatable.annotation.invalid.value=\    {0} is not a valid @Repeatable: invalid value element:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationMultipleValues(Type, int):::compiler.err.invalid.repeatable.annotation.multiple.values=\    {0} is not a valid @Repeatable, {1} element methods named ''value'' declared:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNoValue(Symbol):::compiler.err.invalid.repeatable.annotation.no.value=\    {0} is not a valid @Repeatable, no value element method declared:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNoValue(Type):::compiler.err.invalid.repeatable.annotation.no.value=\    {0} is not a valid @Repeatable, no value element method declared:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNotApplicable(Type, Symbol):::compiler.err.invalid.repeatable.annotation.not.applicable=\    container {0} is not applicable to element {1}:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNotApplicableInContext(Type):::compiler.err.invalid.repeatable.annotation.not.applicable.in.context=\    container {0} is not applicable in this type context:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNotDocumented(Symbol, Symbol):::compiler.err.invalid.repeatable.annotation.not.documented=\    repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationNotInherited(Symbol, Symbol):::compiler.err.invalid.repeatable.annotation.not.inherited=\    repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationRepeatedAndContainerPresent(Symbol):::compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\    container {0} must not be present at the same time as the element it contains:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationRetention(Symbol, String, Symbol, String):::compiler.err.invalid.repeatable.annotation.retention=\    retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2}):::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationValueReturn(Symbol, Type, Type):::compiler.err.invalid.repeatable.annotation.value.return=\    containing annotation type ({0}) must declare an element named ''value'' of type {2}:::return->new->Error
CompilerProperties.Errors#InvalidRepeatableAnnotationValueReturn(Type, Type, Type):::compiler.err.invalid.repeatable.annotation.value.return=\    containing annotation type ({0}) must declare an element named ''value'' of type {2}:::return->new->Error
CompilerProperties.Errors#InvalidSource(String):::compiler.err.invalid.source=\    invalid source release: {0}:::return->new->Error
CompilerProperties.Errors#InvalidTarget(String):::compiler.err.invalid.target=\    invalid target release: {0}:::return->new->Error
CompilerProperties.Errors#LabelAlreadyInUse(Name):::compiler.err.label.already.in.use=\    label {0} already in use:::return->new->Error
CompilerProperties.Errors#LimitStringOverflow(String):::compiler.err.limit.string.overflow=\    UTF8 representation for string \"{0}...\" is too long for the constant pool:::return->new->Error
CompilerProperties.Errors#LocalVarAccessedFromIclsNeedsFinal(Symbol):::compiler.err.local.var.accessed.from.icls.needs.final=\    local variable {0} is accessed from within inner class; needs to be declared final:::return->new->Error
CompilerProperties.Errors#LocnBadModuleInfo(Path):::compiler.err.locn.bad.module-info=\    problem reading module-info.class in {0}:::return->new->Error
CompilerProperties.Errors#LocnCantGetModuleNameForJar(Path):::compiler.err.locn.cant.get.module.name.for.jar=\    cannot determine module name for {0}:::return->new->Error
CompilerProperties.Errors#LocnCantReadDirectory(Path):::compiler.err.locn.cant.read.directory=\    cannot read directory {0}:::return->new->Error
CompilerProperties.Errors#LocnCantReadFile(Path):::compiler.err.locn.cant.read.file=\    cannot read file {0}:::return->new->Error
CompilerProperties.Errors#LocnInvalidArgForXpatch(String):::compiler.err.locn.invalid.arg.for.xpatch=\    invalid argument for --patch-module option: {0}:::return->new->Error
CompilerProperties.Errors#LocnModuleInfoNotAllowedOnPatchPath(JavaFileObject):::compiler.err.locn.module-info.not.allowed.on.patch.path=\    module-info.class not allowed on patch path: {0}:::return->new->Error
CompilerProperties.Errors#ModNotAllowedHere(Set):::compiler.err.mod.not.allowed.here=\    modifier {0} not allowed here:::return->new->Error
CompilerProperties.Errors#ModifierNotAllowedHere(Name):::compiler.err.modifier.not.allowed.here=\    modifier {0} not allowed here:::return->new->Error
CompilerProperties.Errors#ModuleNameMismatch(Name, Name):::compiler.err.module.name.mismatch=\    module name {0} does not match expected name {1}:::return->new->Error
CompilerProperties.Errors#ModuleNonZeroOpens(Name):::compiler.err.module.non.zero.opens=\    open module {0} has non-zero opens_count:::return->new->Error
CompilerProperties.Errors#ModuleNotFound(Symbol):::compiler.err.module.not.found=\    module not found: {0}:::return->new->Error
CompilerProperties.Errors#ModuleNotFoundInModuleSourcePath(String):::compiler.err.module.not.found.in.module.source.path=\    module {0} not found in module source path:::return->new->Error
CompilerProperties.Errors#MultiModuleOutdirCannotBeExplodedModule(Path):::compiler.err.multi-module.outdir.cannot.be.exploded.module=\    in multi-module mode, the output directory cannot be an exploded module: {0}:::return->new->Error
CompilerProperties.Errors#MulticatchParameterMayNotBeAssigned(Symbol):::compiler.err.multicatch.parameter.may.not.be.assigned=\    multi-catch parameter {0} may not be assigned:::return->new->Error
CompilerProperties.Errors#MulticatchTypesMustBeDisjoint(Type, Type):::compiler.err.multicatch.types.must.be.disjoint=\    Alternatives in a multi-catch statement cannot be related by subclassing\n\    Alternative {0} is a subclass of alternative {1}:::return->new->Error
CompilerProperties.Errors#NameClashSameErasure(Symbol, Symbol):::compiler.err.name.clash.same.erasure=\    name clash: {0} and {1} have the same erasure:::return->new->Error
CompilerProperties.Errors#NameClashSameErasureNoHide(Symbol, Symbol, Symbol, Symbol):::compiler.err.name.clash.same.erasure.no.hide=\    name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other:::return->new->Error
CompilerProperties.Errors#NameClashSameErasureNoOverride(Name, List, Symbol, Name, List, Symbol):::compiler.err.name.clash.same.erasure.no.override=\    name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other:::return->new->Error
CompilerProperties.Errors#NameClashSameErasureNoOverride1(String, Name, Name, List, Symbol, Name, List, Symbol):::compiler.err.name.clash.same.erasure.no.override.1=\    name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\n\    first method:  {2}({3}) in {4}\n\    second method: {5}({6}) in {7}:::return->new->Error
CompilerProperties.Errors#NeitherConditionalSubtype(Type, Type):::compiler.err.neither.conditional.subtype=\    incompatible types for ?: neither is a subtype of the other\n\    second operand: {0}\n\    third operand : {1}:::return->new->Error
CompilerProperties.Errors#NoAnnotationMember(Name, Type):::compiler.err.no.annotation.member=\    no annotation member {0} in {1}:::return->new->Error
CompilerProperties.Errors#NoEnclInstanceOfTypeInScope(Symbol):::compiler.err.no.encl.instance.of.type.in.scope=\    no enclosing instance of type {0} is in scope:::return->new->Error
CompilerProperties.Errors#NoSuperclass(Type):::compiler.err.no.superclass=\    {0} has no superclass.:::return->new->Error
CompilerProperties.Errors#NoValueForOption(String):::compiler.err.no.value.for.option=\    no value for {0} option:::return->new->Error
CompilerProperties.Errors#NoZipfsForArchive(Path):::compiler.err.no.zipfs.for.archive=\    No file system provider is available to handle this file: {0}:::return->new->Error
CompilerProperties.Errors#NonStaticCantBeRef(Kind, Symbol):::compiler.err.non-static.cant.be.ref=\    non-static {0} {1} cannot be referenced from a static context:::return->new->Error
CompilerProperties.Errors#NotAnnotationType(Type):::compiler.err.not.annotation.type=\    {0} is not an annotation type:::return->new->Error
CompilerProperties.Errors#NotDefAccessClassIntfCantAccess(Symbol, Symbol):::compiler.err.not.def.access.class.intf.cant.access=\    {1}.{0} is defined in an inaccessible class or interface:::return->new->Error
CompilerProperties.Errors#NotDefAccessClassIntfCantAccessReason(Symbol, Symbol, Symbol, JCDiagnostic):::compiler.err.not.def.access.class.intf.cant.access.reason=\    {1}.{0} in package {2} is not accessible\n\    ({3}):::return->new->Error
CompilerProperties.Errors#NotDefAccessClassIntfCantAccessReason(Symbol, Symbol, Symbol, Fragment):::compiler.err.not.def.access.class.intf.cant.access.reason=\    {1}.{0} in package {2} is not accessible\n\    ({3}):::return->new->Error
CompilerProperties.Errors#NotDefAccessPackageCantAccess(Symbol, Symbol, JCDiagnostic):::compiler.err.not.def.access.package.cant.access=\    {0} is not visible\n\    ({2}):::return->new->Error
CompilerProperties.Errors#NotDefAccessPackageCantAccess(Symbol, Symbol, Fragment):::compiler.err.not.def.access.package.cant.access=\    {0} is not visible\n\    ({2}):::return->new->Error
CompilerProperties.Errors#NotDefPublic(Symbol, Symbol):::compiler.err.not.def.public=\    {0} is not public in {1}:::return->new->Error
CompilerProperties.Errors#NotDefPublicCantAccess(Symbol, Symbol):::compiler.err.not.def.public.cant.access=\    {0} is not public in {1}; cannot be accessed from outside package:::return->new->Error
CompilerProperties.Errors#NotEnclClass(Symbol):::compiler.err.not.encl.class=\    not an enclosing class: {0}:::return->new->Error
CompilerProperties.Errors#NotInProfile(Symbol, Object):::compiler.err.not.in.profile=\    {0} is not available in profile ''{1}'':::return->new->Error
CompilerProperties.Errors#NotLoopLabel(Name):::compiler.err.not.loop.label=\    not a loop label: {0}:::return->new->Error
CompilerProperties.Errors#NotWithinBounds(Type, Type):::compiler.err.not.within.bounds=\    type argument {0} is not within bounds of type-variable {1}:::return->new->Error
CompilerProperties.Errors#NotWithinBounds(Type, Symbol):::compiler.err.not.within.bounds=\    type argument {0} is not within bounds of type-variable {1}:::return->new->Error
CompilerProperties.Errors#OperatorCantBeApplied(Name, Type):::compiler.err.operator.cant.be.applied=\    bad operand type {1} for unary operator ''{0}'':::return->new->Error
CompilerProperties.Errors#OperatorCantBeApplied1(Name, Type, Type):::compiler.err.operator.cant.be.applied.1=\    bad operand types for binary operator ''{0}''\n\    first type:  {1}\n\    second type: {2}:::return->new->Error
CompilerProperties.Errors#OptionNotAllowedWithTarget(Option, Target):::compiler.err.option.not.allowed.with.target=\    option {0} not allowed with target {1}:::return->new->Error
CompilerProperties.Errors#OptionRemovedSource(String, String):::compiler.err.option.removed.source=\    Source option {0} is no longer supported:::return->new->Error
CompilerProperties.Errors#OptionRemovedTarget(Target, Target):::compiler.err.option.removed.target=\    Target option {0} is no longer supported:::return->new->Error
CompilerProperties.Errors#OptionTooMany(String):::compiler.err.option.too.many=\    option {0} can only be specified once:::return->new->Error
CompilerProperties.Errors#Orphaned(TokenKind):::compiler.err.orphaned=\    orphaned {0}:::return->new->Error
CompilerProperties.Errors#OverrideIncompatibleRet(JCDiagnostic, Type, Type):::compiler.err.override.incompatible.ret=\    {0}\n\    return type {1} is not compatible with {2}:::return->new->Error
CompilerProperties.Errors#OverrideIncompatibleRet(Fragment, Type, Type):::compiler.err.override.incompatible.ret=\    {0}\n\    return type {1} is not compatible with {2}:::return->new->Error
CompilerProperties.Errors#OverrideMeth(JCDiagnostic, Set):::compiler.err.override.meth=\    {0}\n\    overridden method is {1}:::return->new->Error
CompilerProperties.Errors#OverrideMeth(Fragment, Set):::compiler.err.override.meth=\    {0}\n\    overridden method is {1}:::return->new->Error
CompilerProperties.Errors#OverrideMethDoesntThrow(JCDiagnostic, Type):::compiler.err.override.meth.doesnt.throw=\    {0}\n\    overridden method does not throw {1}:::return->new->Error
CompilerProperties.Errors#OverrideMethDoesntThrow(Fragment, Type):::compiler.err.override.meth.doesnt.throw=\    {0}\n\    overridden method does not throw {1}:::return->new->Error
CompilerProperties.Errors#OverrideStatic(JCDiagnostic):::compiler.err.override.static=\    {0}\n\    overriding method is static:::return->new->Error
CompilerProperties.Errors#OverrideStatic(Fragment):::compiler.err.override.static=\    {0}\n\    overriding method is static:::return->new->Error
CompilerProperties.Errors#OverrideWeakerAccess(JCDiagnostic, Set):::compiler.err.override.weaker.access=\    {0}\n\    attempting to assign weaker access privileges; was {1}:::return->new->Error
CompilerProperties.Errors#OverrideWeakerAccess(JCDiagnostic, String):::compiler.err.override.weaker.access=\    {0}\n\    attempting to assign weaker access privileges; was {1}:::return->new->Error
CompilerProperties.Errors#OverrideWeakerAccess(Fragment, Set):::compiler.err.override.weaker.access=\    {0}\n\    attempting to assign weaker access privileges; was {1}:::return->new->Error
CompilerProperties.Errors#OverrideWeakerAccess(Fragment, String):::compiler.err.override.weaker.access=\    {0}\n\    attempting to assign weaker access privileges; was {1}:::return->new->Error
CompilerProperties.Errors#PackageClashFromRequires(Symbol, Name, Symbol, Symbol):::compiler.err.package.clash.from.requires=\    module {0} reads package {1} from both {2} and {3}:::return->new->Error
CompilerProperties.Errors#PackageClashFromRequiresInUnnamed(Name, Symbol, Symbol):::compiler.err.package.clash.from.requires.in.unnamed=\    the unnamed module reads package {0} from both {1} and {2}:::return->new->Error
CompilerProperties.Errors#PackageEmptyOrNotFound(Symbol):::compiler.err.package.empty.or.not.found=\    package is empty or does not exist: {0}:::return->new->Error
CompilerProperties.Errors#PackageInOtherModule(Symbol):::compiler.err.package.in.other.module=\    package exists in another module: {0}:::return->new->Error
CompilerProperties.Errors#PackageNotVisible(Symbol, JCDiagnostic):::compiler.err.package.not.visible=\    package {0} is not visible\n\    ({1}):::return->new->Error
CompilerProperties.Errors#PackageNotVisible(Symbol, Fragment):::compiler.err.package.not.visible=\    package {0} is not visible\n\    ({1}):::return->new->Error
CompilerProperties.Errors#PkgClashesWithClassOfSameName(Symbol):::compiler.err.pkg.clashes.with.class.of.same.name=\    package {0} clashes with class of same name:::return->new->Error
CompilerProperties.Errors#PluginNotFound(String):::compiler.err.plugin.not.found=\    plug-in not found: {0}:::return->new->Error
CompilerProperties.Errors#PreviewFeatureDisabled(JCDiagnostic):::compiler.err.preview.feature.disabled=\   {0} is a preview feature and is disabled by default.\n\   (use --enable-preview to enable {0}):::return->new->Error
CompilerProperties.Errors#PreviewFeatureDisabled(Fragment):::compiler.err.preview.feature.disabled=\   {0} is a preview feature and is disabled by default.\n\   (use --enable-preview to enable {0}):::return->new->Error
CompilerProperties.Errors#PreviewFeatureDisabledClassfile(JavaFileObject, String):::compiler.err.preview.feature.disabled.classfile=\   classfile for {0} uses preview features of Java SE {1}.\n\   (use --enable-preview to allow loading of classfiles which contain preview features):::return->new->Error
CompilerProperties.Errors#PreviewFeatureDisabledPlural(JCDiagnostic):::compiler.err.preview.feature.disabled.plural=\   {0} are a preview feature and are disabled by default.\n\   (use --enable-preview to enable {0}):::return->new->Error
CompilerProperties.Errors#PreviewFeatureDisabledPlural(Fragment):::compiler.err.preview.feature.disabled.plural=\   {0} are a preview feature and are disabled by default.\n\   (use --enable-preview to enable {0}):::return->new->Error
CompilerProperties.Errors#PreviewNotLatest(String, Source):::compiler.err.preview.not.latest=\    invalid source release {0} with --enable-preview\n\    (preview language features are only supported for release {1}):::return->new->Error
CompilerProperties.Errors#ProbFoundReq(JCDiagnostic):::compiler.err.prob.found.req=\    incompatible types: {0}:::return->new->Error
CompilerProperties.Errors#ProbFoundReq(Fragment):::compiler.err.prob.found.req=\    incompatible types: {0}:::return->new->Error
CompilerProperties.Errors#ProcBadConfigFile(String):::compiler.err.proc.bad.config.file=\    Bad service configuration file, or exception thrown while constructing Processor object: {0}:::return->new->Error
CompilerProperties.Errors#ProcCantAccess(Symbol, JCDiagnostic, String):::compiler.err.proc.cant.access=\    cannot access {0}\n\    {1}\n\    Consult the following stack trace for details.\n\    {2}:::return->new->Error
CompilerProperties.Errors#ProcCantAccess(Symbol, Fragment, String):::compiler.err.proc.cant.access=\    cannot access {0}\n\    {1}\n\    Consult the following stack trace for details.\n\    {2}:::return->new->Error
CompilerProperties.Errors#ProcCantAccess1(Symbol, JCDiagnostic):::compiler.err.proc.cant.access.1=\    cannot access {0}\n\    {1}:::return->new->Error
CompilerProperties.Errors#ProcCantAccess1(Symbol, Fragment):::compiler.err.proc.cant.access.1=\    cannot access {0}\n\    {1}:::return->new->Error
CompilerProperties.Errors#ProcCantFindClass(String):::compiler.err.proc.cant.find.class=\    Could not find class file for ''{0}''.:::return->new->Error
CompilerProperties.Errors#ProcCantLoadClass(String):::compiler.err.proc.cant.load.class=\    Could not load processor class file due to ''{0}''.:::return->new->Error
CompilerProperties.Errors#ProcMessager(String):::compiler.err.proc.messager=\    {0}:::return->new->Error
CompilerProperties.Errors#ProcNoExplicitAnnotationProcessingRequested(Collection):::compiler.err.proc.no.explicit.annotation.processing.requested=\    Class names, ''{0}'', are only accepted if annotation processing is explicitly requested:::return->new->Error
CompilerProperties.Errors#ProcProcessorBadOptionName(String, String):::compiler.err.proc.processor.bad.option.name=\    Bad option name ''{0}'' provided by processor ''{1}'':::return->new->Error
CompilerProperties.Errors#ProcProcessorCantInstantiate(String):::compiler.err.proc.processor.cant.instantiate=\    Could not instantiate an instance of processor ''{0}'':::return->new->Error
CompilerProperties.Errors#ProcProcessorNotFound(String):::compiler.err.proc.processor.not.found=\    Annotation processor ''{0}'' not found:::return->new->Error
CompilerProperties.Errors#ProcProcessorWrongType(String):::compiler.err.proc.processor.wrong.type=\    Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor:::return->new->Error
CompilerProperties.Errors#QualifiedNewOfStaticClass(Symbol):::compiler.err.qualified.new.of.static.class=\    qualified new of static class:::return->new->Error
CompilerProperties.Errors#RefAmbiguous(Name, Kind, Symbol, Symbol, Kind, Symbol, Symbol):::compiler.err.ref.ambiguous=\    reference to {0} is ambiguous\n\    both {1} {2} in {3} and {4} {5} in {6} match:::return->new->Error
CompilerProperties.Errors#ReleaseBootclasspathConflict(Option):::compiler.err.release.bootclasspath.conflict=\    option {0} cannot be used together with --release:::return->new->Error
CompilerProperties.Errors#RepeatedProvidesForService(Symbol):::compiler.err.repeated.provides.for.service=\    multiple ''provides'' for service {0}:::return->new->Error
CompilerProperties.Errors#RepeatedValueForPatchModule(String):::compiler.err.repeated.value.for.patch.module=\    --patch-module specified more than once for {0}:::return->new->Error
CompilerProperties.Errors#ReportAccess(Symbol, Set, Symbol):::compiler.err.report.access=\    {0} has {1} access in {2}:::return->new->Error
CompilerProperties.Errors#ReqArg(String):::compiler.err.req.arg=\    {0} requires an argument:::return->new->Error
CompilerProperties.Errors#SameBinaryName(Name, Name):::compiler.err.same.binary.name=\    classes: {0} and {1} have the same binary name:::return->new->Error
CompilerProperties.Errors#ServiceDefinitionIsEnum(Symbol):::compiler.err.service.definition.is.enum=\    the service definition is an enum: {0}:::return->new->Error
CompilerProperties.Errors#ServiceImplementationDoesntHaveANoArgsConstructor(Symbol):::compiler.err.service.implementation.doesnt.have.a.no.args.constructor=\    the service implementation does not have a default constructor: {0}:::return->new->Error
CompilerProperties.Errors#ServiceImplementationIsAbstract(Symbol):::compiler.err.service.implementation.is.abstract=\    the service implementation is an abstract class: {0}:::return->new->Error
CompilerProperties.Errors#ServiceImplementationIsInner(Symbol):::compiler.err.service.implementation.is.inner=\    the service implementation is an inner class: {0}:::return->new->Error
CompilerProperties.Errors#ServiceImplementationNoArgsConstructorNotPublic(Symbol):::compiler.err.service.implementation.no.args.constructor.not.public=\    the no arguments constructor of the service implementation is not public: {0}:::return->new->Error
CompilerProperties.Errors#ServiceImplementationNotInRightModule(Symbol):::compiler.err.service.implementation.not.in.right.module=\    service implementation must be defined in the same module as the provides directive:::return->new->Error
CompilerProperties.Errors#SourceCantOverwriteInputFile(JavaFileObject):::compiler.err.source.cant.overwrite.input.file=\    error writing source; cannot overwrite input file {0}:::return->new->Error
CompilerProperties.Errors#StackSimError(Symbol):::compiler.err.stack.sim.error=\    Internal error: stack sim error on {0}:::return->new->Error
CompilerProperties.Errors#TooManyPatchedModules(Set):::compiler.err.too.many.patched.modules=\    too many patched modules ({0}), use --module-source-path:::return->new->Error
CompilerProperties.Errors#TryResourceMayNotBeAssigned(Symbol):::compiler.err.try.resource.may.not.be.assigned=\    auto-closeable resource {0} may not be assigned:::return->new->Error
CompilerProperties.Errors#TryWithResourcesExprEffectivelyFinalVar(Symbol):::compiler.err.try.with.resources.expr.effectively.final.var=\    variable {0} used as a try-with-resources resource neither final nor effectively final:::return->new->Error
CompilerProperties.Errors#TwoClassLoaders2(URL, URL):::compiler.err.two.class.loaders.2=\    javac is split between multiple class loaders:\n\    one class comes from file: {0}\n\    while javac comes from {1}:::return->new->Error
CompilerProperties.Errors#TypeDoesntTakeParams(Symbol):::compiler.err.type.doesnt.take.params=\    type {0} does not take parameters:::return->new->Error
CompilerProperties.Errors#TypeFoundReq(Object, JCDiagnostic):::compiler.err.type.found.req=\    unexpected type\n\    required: {1}\n\    found:    {0}:::return->new->Error
CompilerProperties.Errors#TypeFoundReq(Object, Fragment):::compiler.err.type.found.req=\    unexpected type\n\    required: {1}\n\    found:    {0}:::return->new->Error
CompilerProperties.Errors#TypesIncompatible(Type, Type, Fragment):::compiler.err.types.incompatible=\    types {0} and {1} are incompatible;\n\    {2}:::return->new->Error
CompilerProperties.Errors#UndefLabel(Name):::compiler.err.undef.label=\    undefined label: {0}:::return->new->Error
CompilerProperties.Errors#UnexpectedType(Set, Set):::compiler.err.unexpected.type=\    unexpected type\n\    required: {0}\n\    found:    {1}:::return->new->Error
CompilerProperties.Errors#UnmatchedQuote(String):::compiler.err.unmatched.quote=\    unmatched quote in environment variable {0}:::return->new->Error
CompilerProperties.Errors#UnreportedExceptionDefaultConstructor(Type):::compiler.err.unreported.exception.default.constructor=\    unreported exception {0} in default constructor:::return->new->Error
CompilerProperties.Errors#UnreportedExceptionImplicitClose(Type, Name):::compiler.err.unreported.exception.implicit.close=\    unreported exception {0}; must be caught or declared to be thrown\n\    exception thrown from implicit call to close() on resource variable ''{1}'':::return->new->Error
CompilerProperties.Errors#UnreportedExceptionNeedToCatchOrThrow(Type):::compiler.err.unreported.exception.need.to.catch.or.throw=\    unreported exception {0}; must be caught or declared to be thrown:::return->new->Error
CompilerProperties.Errors#UnsupportedEncoding(String):::compiler.err.unsupported.encoding=\    unsupported encoding: {0}:::return->new->Error
CompilerProperties.Errors#UnsupportedReleaseVersion(String):::compiler.err.unsupported.release.version=\    release version {0} not supported:::return->new->Error
CompilerProperties.Errors#VarMightAlreadyBeAssigned(Symbol):::compiler.err.var.might.already.be.assigned=\    variable {0} might already have been assigned:::return->new->Error
CompilerProperties.Errors#VarMightBeAssignedInLoop(Symbol):::compiler.err.var.might.be.assigned.in.loop=\    variable {0} might be assigned in loop:::return->new->Error
CompilerProperties.Errors#VarMightNotHaveBeenInitialized(Symbol):::compiler.err.var.might.not.have.been.initialized=\    variable {0} might not have been initialized:::return->new->Error
CompilerProperties.Errors#VarNotInitializedInDefaultConstructor(Symbol):::compiler.err.var.not.initialized.in.default.constructor=\    variable {0} not initialized in the default constructor:::return->new->Error
CompilerProperties.Errors#VarargsInvalidTrustmeAnno(Symbol, JCDiagnostic):::compiler.err.varargs.invalid.trustme.anno=\    Invalid {0} annotation:::return->new->Error
CompilerProperties.Errors#VarargsInvalidTrustmeAnno(Symbol, Fragment):::compiler.err.varargs.invalid.trustme.anno=\    Invalid {0} annotation:::return->new->Error
CompilerProperties.Errors#WrongNumberTypeArgs(String):::compiler.err.wrong.number.type.args=\    wrong number of type arguments; required {0}:::return->new->Error
LauncherProperties.Errors#CantAccessMainMethod(String):::launcher.err.cant.access.main.method=\    can''t access main method in class: {0}:::return->new->Error
LauncherProperties.Errors#CantFindClass(String):::launcher.err.cant.find.class=\    can''t find class: {0}:::return->new->Error
LauncherProperties.Errors#CantFindMainMethod(String):::launcher.err.cant.find.main.method=\    can''t find main(String[]) method in class: {0}:::return->new->Error
LauncherProperties.Errors#CantReadFile(Path, Object):::launcher.err.cant.read.file=\    error reading file {0}: {1}:::return->new->Error
LauncherProperties.Errors#FileNotFound(Path):::launcher.err.file.not.found=\    file not found: {0}:::return->new->Error
LauncherProperties.Errors#InvalidFilename(String):::launcher.err.invalid.filename=\    invalid filename: {0}:::return->new->Error
LauncherProperties.Errors#InvalidValueForSource(String):::launcher.err.invalid.value.for.source=\    invalid value for --source option: {0}:::return->new->Error
LauncherProperties.Errors#NoValueForOption(String):::launcher.err.no.value.for.option=\    no value given for option: {0}:::return->new->Error
LauncherProperties.Errors#UnexpectedClass(String):::launcher.err.unexpected.class=\    class found on application class path: {0}:::return->new->Error
