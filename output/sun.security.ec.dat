ECDSAOperations#signDigest(byte[], byte[], Seed):::Sign a digest using the provided private key and seed:::nonceArr->ecOps->seed->getSeedValue->seedToScalar->nonce->new->Nonce->return->signDigest
ECDSAOperations#signDigest(byte[], byte[], Nonce):::Sign a digest using the provided private key and nonce:::orderField->ecOps->getOrderField->orderBits->orderField->getSize->bitLength->if->throw->new->ProviderException->k->nonce->getNonceValue->length->orderField->getSize->bitLength->if->throw->new->ProviderException->R->ecOps->multiply->r->R->asAffine->getX->temp->new->byteArr->r->asByteArray->orderField->getElement->r->asByteArray->result->new->byteArr->ArrayUtil->reverse->System->arraycopy->if->ECOperations->allZero->throw->new->IntermediateValueException->dU->orderField->getElement->lengthE->Math->min->E->new->byteArr->System->arraycopy->ArrayUtil->reverse->e->orderField->getElement->kElem->orderField->getElement->kInv->kElem->multiplicativeInverse->s->r->mutable->s->setProduct->setSum->setProduct->s->asByteArray->ArrayUtil->reverse->System->arraycopy->if->ECOperations->allZero->throw->new->IntermediateValueException->return
ECDSASignature#resetDigest():::Resets the message digest if needed.:::if->if->messageDigest->reset
ECDSASignature#getDigestValue():::Returns the message digest value.:::return->messageDigest->digest
ECKeyFactory#toECKey(Key):::Static method to convert Key into a useable instance of ECPublicKey or ECPrivateKey:::if->ecKey->checkKey->return->else->return->getInstance->translateKey
ECKeyFactory#engineTranslateKey(Key):::Translate an EC key into a Sun EC key:::if->throw->new->InvalidKeyException->keyAlg->key->getAlgorithm->if->keyAlg->equals->throw->new->InvalidKeyException->if->return->implTranslatePublicKey->else->if->return->implTranslatePrivateKey->else->throw->new->InvalidKeyException
ECOperations#multiply(AffinePoint, byte[]):::Multiply an affine point by a scalar and return the result as a mutable point.:::field->affineP->getX->getField->zero->field->get0->t0->zero->mutable->t1->zero->mutable->t2->zero->mutable->t3->zero->mutable->t4->zero->mutable->result->new->ProjectivePoint.Mutable->result->getY->field->get1->mutable->setValue->pointMultiples->new->ProjectivePoint.ImmutableArr->result->fixed->ps->new->ProjectivePoint.Mutable->ps->setValue->ps->fixed->for->i->lookupResult->ps->mutable->for->i->return
ECPrivateKeyImpl#parseKeyBits():::Parse the key:::try->in->new->DerInputStream->derValue->in->getDerValue->if->throw->new->IOException->data->version->data->getInteger->if->throw->new->IOException->privData->data->getOctetString->ArrayUtil->reverse->while->data->available->value->data->getDerValue->if->value->isContextSpecific->else->if->value->isContextSpecific->else->throw->new->InvalidKeyException->algParams->getParameters->if->throw->new->InvalidKeyException->algParams->getParameterSpec->catch->throw->new->InvalidKeyException->throw->new->InvalidKeyException->finally
ECPublicKeyImpl#parseKeyBits():::Parse the key:::algParams->getParameters->if->throw->new->InvalidKeyException->try->algParams->getParameterSpec->ECUtil->params->getCurve->decodePoint->catch->throw->new->InvalidKeyException->throw->new->InvalidKeyException->finally
XECOperations#computePublic(byte[]):::Compute a public key from an encoded private key:::pruneK->return->pointMultiply->asBigInteger
XECOperations#encodedPointMultiply(byte[], BigInteger):::Multiply an encoded scalar with a point as a BigInteger and return an encoded point:::pruneK->elemU->field->getElement->return->pointMultiply->params->getBytes->asByteArray
XECOperations#encodedPointMultiply(byte[], byte[]):::Multiply an encoded scalar with an encoded point and return an encoded point:::pruneK->elemU->decodeU->return->pointMultiply->params->getBytes->asByteArray
XECParameters#getBySize(Function, int):::Get parameters by key size, or throw an exception if no parameters are defined for the specified key size:::xecParams->getBySize->return->xecParams->apply->orElseThrow
XECParameters#get(Function, AlgorithmId):::Get parameters by algorithm ID, or throw an exception if no parameters are defined for the specified ID:::xecParams->algId->getOID->getByOid->return->xecParams->algId->getOID->apply->orElseThrow
XECParameters#get(Function, AlgorithmParameterSpec):::Get parameters by algorithm parameter spec, or throw an exception if no parameters are defined for the spec:::if->namedParams->xecParams->namedParams->getName->getByName->return->xecParams->namedParams->getName->apply->orElseThrow->else->throw->exception->apply
