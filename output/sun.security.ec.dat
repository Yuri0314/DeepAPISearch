ECDHKeyAgreement#engineInit(Key, SecureRandom)::: key agreement engine init:::if->throw->new->InvalidKeyException->ECKeyFactory->toECKey
ECDHKeyAgreement#engineInit(Key, AlgorithmParameterSpec, SecureRandom)::: key agreement engine init:::if->throw->new->InvalidAlgorithmParameterException->engineInit
ECDHKeyAgreement#engineDoPhase(Key, boolean)::: key agreement engine do phase:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->if->throw->new->InvalidKeyException->params->publicKey->getParams->keyLenBits->params->getCurve->getField->getFieldSize->return
ECDHKeyAgreement#validateCoordinate(BigInteger, BigInteger)::: key agreement validate coordinate:::if->c->compareTo->throw->new->ProviderException->if->c->compareTo->throw->new->ProviderException
ECDHKeyAgreement#validate(ECOperations, ECPublicKey)::: key agreement validate:::x->key->getW->getAffineX->y->key->getW->getAffineY->p->ops->getField->getSize->validateCoordinate->validateCoordinate->curve->key->getParams->getCurve->rhs->x->BigInteger->valueOf->modPow->curve->getA->multiply->add->curve->getB->add->mod->lhs->y->BigInteger->valueOf->modPow->mod->if->rhs->equals->throw->new->ProviderException->xElem->ops->getField->getElement->yElem->ops->getField->getElement->affP->new->AffinePoint->order->key->getParams->getOrder->toByteArray->ArrayUtil->reverse->product->ops->multiply->if->ops->isNeutral->throw->new->ProviderException
ECDHKeyAgreement#engineGenerateSecret()::: key agreement engine generate secret:::if->throw->new->IllegalStateException->resultOpt->deriveKeyImpl->result->resultOpt->deriveKeyNative->orElseGet->return
ECDHKeyAgreement#engineGenerateSecret(byte[], int)::: key agreement engine generate secret:::if->throw->new->ShortBufferException->secret->engineGenerateSecret->System->arraycopy->return
ECDHKeyAgreement#engineGenerateSecret(String)::: key agreement engine generate secret:::if->throw->new->NoSuchAlgorithmException->if->algorithm->equals->throw->new->NoSuchAlgorithmException->return->engineGenerateSecret->new->SecretKeySpec
ECDHKeyAgreement#deriveKeyImpl(ECPrivateKey, ECPublicKey)::: key agreement derive key impl:::ecSpec->priv->getParams->curve->ecSpec->getCurve->opsOpt->ECOperations->forParameters->if->opsOpt->isEmpty->return->Optional->empty->ops->opsOpt->get->if->return->Optional->empty->privImpl->sArr->privImpl->getArrayS->validate->field->ops->getField->scalar->field->getElement->mutable->cofactor->field->priv->getParams->getCofactor->getSmallValue->scalar->setProduct->keySize->curve->getField->getFieldSize->privArr->scalar->asByteArray->x->field->pubKey->getW->getAffineX->getElement->y->field->pubKey->getW->getAffineY->getElement->affPub->new->AffinePoint->product->ops->multiply->if->ops->isNeutral->throw->new->ProviderException->affProduct->product->asAffine->result->affProduct->getX->asByteArray->ArrayUtil->reverse->return->Optional->of
ECDHKeyAgreement#deriveKeyNative(ECPrivateKey, ECPublicKey)::: key agreement derive key native:::params->privateKey->getParams->s->privateKey->getS->toByteArray->encodedParams->ECUtil->encodeECParameterSpec->publicValue->if->ecPub->ecPub->getEncodedPublicValue->else->ECUtil->publicKey->getW->params->getCurve->encodePoint->try->return->deriveKey->catch->throw->new->ProviderException->finally
ECDHKeyAgreement#deriveKey(byte[], byte[], byte[]):::Generates a secret key using the public and private keys.:::
ECDSAOperations.Seed#getSeedValue()::: seed get seed value:::return
ECDSAOperations.Nonce#getNonceValue()::: nonce get nonce value:::return
ECDSAOperations#getEcOperations()::: operations get ec operations:::return
ECDSAOperations#basePointMultiply(byte[])::: operations base point multiply:::return->ecOps->multiply->asAffine
ECDSAOperations#toAffinePoint(ECPoint, IntegerFieldModuloP)::: operations to affine point:::affineX->field->point->getAffineX->getElement->affineY->field->point->getAffineY->getElement->return->new->AffinePoint
ECDSAOperations#forParameters(ECParameterSpec)::: operations for parameters:::curveOps->ECOperations->forParameters->return->curveOps->ecParams->getGenerator->new->ECDSAOperations->map
ECDSAOperations#signDigest(byte[], byte[], Seed):::Sign a digest using the provided private key and seed:::nonceArr->ecOps->seed->getSeedValue->seedToScalar->nonce->new->Nonce->return->signDigest
ECDSAOperations#signDigest(byte[], byte[], Nonce):::Sign a digest using the provided private key and nonce:::orderField->ecOps->getOrderField->orderBits->orderField->getSize->bitLength->if->throw->new->ProviderException->k->nonce->getNonceValue->length->orderField->getSize->bitLength->if->throw->new->ProviderException->R->ecOps->multiply->r->R->asAffine->getX->temp->new->byteArr->r->asByteArray->orderField->getElement->r->asByteArray->result->new->byteArr->ArrayUtil->reverse->System->arraycopy->if->ECOperations->allZero->throw->new->IntermediateValueException->dU->orderField->getElement->lengthE->Math->min->E->new->byteArr->System->arraycopy->ArrayUtil->reverse->e->orderField->getElement->kElem->orderField->getElement->kInv->kElem->multiplicativeInverse->s->r->mutable->s->setProduct->setSum->setProduct->s->asByteArray->ArrayUtil->reverse->System->arraycopy->if->ECOperations->allZero->throw->new->IntermediateValueException->return
ECDSASignature.RawECDSA#engineUpdate(byte)::: raw a engine update:::if->return
ECDSASignature.RawECDSA#engineUpdate(byte[], int, int)::: raw a engine update:::if->return->System->arraycopy
ECDSASignature.RawECDSA#engineUpdate(ByteBuffer)::: raw a engine update:::len->byteBuffer->remaining->if->return->if->return->byteBuffer->get
ECDSASignature.RawECDSA#resetDigest()::: raw a reset digest:::
ECDSASignature.RawECDSA#getDigestValue()::: raw a get digest value:::if->throw->new->SignatureException->result->new->byteArr->System->arraycopy->return
ECDSASignature#engineInitVerify(PublicKey)::: signature engine init verify:::ECKeyFactory->toECKey->resetDigest
ECDSASignature#engineInitSign(PrivateKey)::: signature engine init sign:::engineInitSign
ECDSASignature#engineInitSign(PrivateKey, SecureRandom)::: signature engine init sign:::ECKeyFactory->toECKey->resetDigest
ECDSASignature#resetDigest():::Resets the message digest if needed.:::if->if->messageDigest->reset
ECDSASignature#getDigestValue():::Returns the message digest value.:::return->messageDigest->digest
ECDSASignature#engineUpdate(byte)::: signature engine update:::messageDigest->update
ECDSASignature#engineUpdate(byte[], int, int)::: signature engine update:::messageDigest->update
ECDSASignature#engineUpdate(ByteBuffer)::: signature engine update:::len->byteBuffer->remaining->if->return->messageDigest->update
ECDSASignature#signDigestImpl(ECDSAOperations, int, byte[], ECPrivateKeyImpl, SecureRandom)::: signature sign digest impl:::seedBytes->new->byteArr->s->privImpl->getArrayS->numAttempts->for->i->throw->new->SignatureException
ECDSASignature#signDigestImpl(ECPrivateKey, byte[], SecureRandom)::: signature sign digest impl:::if->return->Optional->empty->privImpl->params->privateKey->getParams->seedBits->params->getOrder->bitLength->opsOpt->ECDSAOperations->forParameters->if->opsOpt->isEmpty->return->Optional->empty->else->sig->opsOpt->get->signDigestImpl->return->Optional->of
ECDSASignature#signDigestNative(ECPrivateKey, byte[], SecureRandom)::: signature sign digest native:::s->privateKey->getS->toByteArray->params->privateKey->getParams->encodedParams->ECUtil->encodeECParameterSpec->orderLength->params->getOrder->bitLength->seed->new->byteArr->random->nextBytes->timingArgument->random->nextInt->try->return->signDigest->catch->throw->new->SignatureException->finally
ECDSASignature#engineSign()::: signature engine sign:::if->JCAUtil->getSecureRandom->digest->getDigestValue->sigOpt->signDigestImpl->sig->if->sigOpt->isPresent->sigOpt->get->else->signDigestNative->if->return->else->return->ECUtil->encodeSignature
ECDSASignature#engineVerify(byte[])::: signature engine verify:::w->params->publicKey->getParams->encodedParams->ECUtil->encodeECParameterSpec->if->getEncodedPublicValue->else->ECUtil->publicKey->getW->params->getCurve->encodePoint->sig->if->else->ECUtil->decodeSignature->try->return->getDigestValue->verifySignedDigest->catch->throw->new->SignatureException->finally
ECDSASignature#engineSetParameter(String, Object)::: signature engine set parameter:::throw->new->UnsupportedOperationException
ECDSASignature#engineSetParameter(AlgorithmParameterSpec)::: signature engine set parameter:::if->throw->new->InvalidAlgorithmParameterException
ECDSASignature#engineGetParameter(String)::: signature engine get parameter:::throw->new->UnsupportedOperationException
ECDSASignature#engineGetParameters()::: signature engine get parameters:::return
ECDSASignature#signDigest(byte[], byte[], byte[], byte[], int):::Signs the digest using the private key.:::
ECDSASignature#verifySignedDigest(byte[], byte[], byte[], byte[]):::Verifies the signed digest using the public key.:::
ECKeyFactory#getInstance()::: key factory get instance:::if->try->KeyFactory->getInstance->catch->throw->new->RuntimeException->throw->new->RuntimeException->finally->return
ECKeyFactory#toECKey(Key):::Static method to convert Key into a useable instance of ECPublicKey or ECPrivateKey:::if->ecKey->checkKey->return->else->return->getInstance->translateKey
ECKeyFactory#checkKey(ECKey):::Check that the given EC key is valid.:::if->if->return->else->if->if->return->else->throw->new->InvalidKeyException->keyAlg->getAlgorithm->if->keyAlg->equals->throw->new->InvalidKeyException
ECKeyFactory#engineTranslateKey(Key):::Translate an EC key into a Sun EC key:::if->throw->new->InvalidKeyException->keyAlg->key->getAlgorithm->if->keyAlg->equals->throw->new->InvalidKeyException->if->return->implTranslatePublicKey->else->if->return->implTranslatePrivateKey->else->throw->new->InvalidKeyException
ECKeyFactory#engineGeneratePublic(KeySpec)::: key factory engine generate public:::try->return->implGeneratePublic->catch->throw->throw->new->InvalidKeySpecException->finally
ECKeyFactory#engineGeneratePrivate(KeySpec)::: key factory engine generate private:::try->return->implGeneratePrivate->catch->throw->throw->new->InvalidKeySpecException->finally
ECKeyFactory#implTranslatePublicKey(PublicKey)::: key factory impl translate public key:::if->if->return->ecKey->return->ecKey->getW->ecKey->getParams->new->ECPublicKeyImpl->else->if->key->getFormat->equals->encoded->key->getEncoded->return->new->ECPublicKeyImpl->else->throw->new->InvalidKeyException
ECKeyFactory#implTranslatePrivateKey(PrivateKey)::: key factory impl translate private key:::if->if->return->ecKey->return->ecKey->getS->ecKey->getParams->new->ECPrivateKeyImpl->else->if->key->getFormat->equals->return->key->getEncoded->new->ECPrivateKeyImpl->else->throw->new->InvalidKeyException
ECKeyFactory#implGeneratePublic(KeySpec)::: key factory impl generate public:::if->x509Spec->return->x509Spec->getEncoded->new->ECPublicKeyImpl->else->if->ecSpec->return->ecSpec->getW->ecSpec->getParams->new->ECPublicKeyImpl->else->throw->new->InvalidKeySpecException
ECKeyFactory#implGeneratePrivate(KeySpec)::: key factory impl generate private:::if->pkcsSpec->return->pkcsSpec->getEncoded->new->ECPrivateKeyImpl->else->if->ecSpec->return->ecSpec->getS->ecSpec->getParams->new->ECPrivateKeyImpl->else->throw->new->InvalidKeySpecException
ECKeyFactory#engineGetKeySpec(Key, Class)::: key factory engine get key spec:::try->engineTranslateKey->catch->throw->new->InvalidKeySpecException->finally->if->ecKey->if->isAssignableFrom->return->keySpec->ecKey->getW->ecKey->getParams->new->ECPublicKeySpec->cast->else->if->isAssignableFrom->return->keySpec->key->getEncoded->new->X509EncodedKeySpec->cast->else->throw->new->InvalidKeySpecException->else->if->if->isAssignableFrom->return->keySpec->key->getEncoded->new->PKCS8EncodedKeySpec->cast->else->if->isAssignableFrom->ecKey->return->keySpec->ecKey->getS->ecKey->getParams->new->ECPrivateKeySpec->cast->else->throw->new->InvalidKeySpecException->else->throw->new->InvalidKeySpecException
ECKeyPairGenerator#initialize(int, SecureRandom)::: key pair generator initialize:::checkKeySize->ECUtil->getECParameterSpec->if->throw->new->InvalidParameterException
ECKeyPairGenerator#initialize(AlgorithmParameterSpec, SecureRandom)::: key pair generator initialize:::ecSpec->if->ecParams->ECUtil->getECParameterSpec->if->throw->new->InvalidAlgorithmParameterException->else->if->name->getName->ECUtil->getECParameterSpec->if->throw->new->InvalidAlgorithmParameterException->else->throw->new->InvalidAlgorithmParameterException->ensureCurveIsSupported->ecSpec->getCurve->getField->getFieldSize
ECKeyPairGenerator#ensureCurveIsSupported(ECParameterSpec)::: key pair generator ensure curve is supported:::ecParams->ECUtil->getECParameters->encodedParams->try->ecParams->init->ecParams->getEncoded->catch->throw->ecSpec->toString->new->InvalidAlgorithmParameterException->throw->new->RuntimeException->finally->if->isCurveSupported->throw->ecParams->toString->new->InvalidAlgorithmParameterException
ECKeyPairGenerator#generateKeyPair()::: key pair generator generate key pair:::if->JCAUtil->getSecureRandom->try->kp->generateKeyPairImpl->if->kp->isPresent->return->kp->get->return->generateKeyPairNative->catch->throw->new->ProviderException->finally
ECKeyPairGenerator#generatePrivateScalar(SecureRandom, ECOperations, int)::: key pair generator generate private scalar:::numAttempts->seedArr->new->byteArr->for->i->throw->new->ProviderException
ECKeyPairGenerator#generateKeyPairImpl(SecureRandom)::: key pair generator generate key pair impl:::ecParams->opsOpt->ECOperations->forParameters->if->opsOpt->isEmpty->return->Optional->empty->ops->opsOpt->get->field->ops->getField->numBits->ecParams->getOrder->bitLength->seedBits->seedSize->privArr->generatePrivateScalar->genPoint->ecParams->getGenerator->x->field->genPoint->getAffineX->getElement->y->field->genPoint->getAffineY->getElement->affGen->new->AffinePoint->pub->ops->multiply->affPub->pub->asAffine->privateKey->new->ECPrivateKeyImpl->w->affPub->getX->asBigInteger->affPub->getY->asBigInteger->new->ECPoint->publicKey->new->ECPublicKeyImpl->return->Optional->new->KeyPair->of
ECKeyPairGenerator#generateKeyPairNative(SecureRandom)::: key pair generator generate key pair native:::ecParams->encodedParams->ECUtil->encodeECParameterSpec->seed->new->byteArr->random->nextBytes->keyBytes->generateECKeyPair->s->new->BigInteger->privateKey->new->ECPrivateKeyImpl->pubKey->w->ECUtil->ecParams->getCurve->decodePoint->publicKey->new->ECPublicKeyImpl->return->new->KeyPair
ECKeyPairGenerator#checkKeySize(int)::: key pair generator check key size:::if->throw->new->InvalidParameterException->if->throw->new->InvalidParameterException
ECKeyPairGenerator#isCurveSupported(byte[]):::Checks whether the curve in the encoded parameters is supported by the native implementation:::
ECKeyPairGenerator#generateECKeyPair(int, byte[], byte[])::: key pair generator generate key pair:::
ECOperations#forParameters(ECParameterSpec)::: operations for parameters:::if->return->Optional->empty->curve->params->getCurve->if->curve->getField->return->Optional->empty->primeField->curve->getField->three->BigInteger->valueOf->if->primeField->getP->curve->getA->subtract->equals->return->Optional->empty->field->fields->primeField->getP->get->if->return->Optional->empty->orderField->orderFields->params->getOrder->get->if->return->Optional->empty->b->field->curve->getB->getElement->ecOps->new->ECOperations->return->Optional->of
ECOperations#getField()::: operations get field:::return->b->getField
ECOperations#getOrderField()::: operations get order field:::return
ECOperations#getNeutral()::: operations get neutral:::return
ECOperations#isNeutral(Point)::: operations is neutral:::pp->z->pp->getZ->field->z->getField->byteLength->field->getSize->bitLength->zBytes->z->asByteArray->return->allZero
ECOperations#seedToScalar(byte[])::: operations seed to scalar:::seedBits->orderField->getSize->bitLength->if->throw->new->ProviderException->lastByteBits->if->lastByteIndex->mask->seedLength->scalarElem->orderField->getElement->scalarLength->orderField->getSize->bitLength->scalarArr->new->byteArr->scalarElem->asByteArray->if->ECOperations->allZero->throw->new->IntermediateValueException->return
ECOperations#allZero(byte[])::: operations all zero:::acc->for->i->return
ECOperations#lookup4(ProjectivePoint.Immutable[], int, ProjectivePoint.Mutable, IntegerModuloP)::: operations lookup4:::for->i
ECOperations#double4(ProjectivePoint.Mutable, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP)::: operations double4:::for->i
ECOperations#multiply(AffinePoint, byte[]):::Multiply an affine point by a scalar and return the result as a mutable point.:::field->affineP->getX->getField->zero->field->get0->t0->zero->mutable->t1->zero->mutable->t2->zero->mutable->t3->zero->mutable->t4->zero->mutable->result->new->ProjectivePoint.Mutable->result->getY->field->get1->mutable->setValue->pointMultiples->new->ProjectivePoint.ImmutableArr->result->fixed->ps->new->ProjectivePoint.Mutable->ps->setValue->ps->fixed->for->i->lookupResult->ps->mutable->for->i->return
ECOperations#setDouble(ProjectivePoint.Mutable, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP)::: operations set double:::t0->p->getX->setValue->setSquare->t1->p->getY->setValue->setSquare->t2->p->getZ->setValue->setSquare->t3->p->getX->setValue->p->getY->setProduct->t4->p->getY->setValue->p->getZ->setProduct->t3->setSum->p->getZ->p->getX->setProduct->p->getZ->setProduct->p->getY->setValue->setProduct->p->getY->p->getZ->setDifference->p->getX->p->getY->setValue->setProduct->p->getY->p->getX->setSum->p->getY->setReduced->p->getX->setValue->p->getY->setDifference->p->getY->setSum->p->getY->p->getX->setProduct->p->getX->setProduct->t3->setValue->setProduct->t2->setSum->p->getZ->setProduct->t2->setReduced->p->getZ->setDifference->p->getZ->setDifference->t3->p->getZ->setValue->setProduct->p->getZ->setReduced->p->getZ->setSum->t0->setProduct->t0->setDifference->t0->p->getZ->setProduct->p->getY->setSum->t4->setSum->p->getZ->setProduct->p->getX->p->getZ->setDifference->p->getZ->setValue->setProduct->p->getZ->setProduct
ECOperations#setSum(MutablePoint, AffinePoint)::: operations set sum:::zero->p->getField->get0->t0->zero->mutable->t1->zero->mutable->t2->zero->mutable->t3->zero->mutable->t4->zero->mutable->setSum
ECOperations#setSum(ProjectivePoint.Mutable, AffinePoint, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP)::: operations set sum:::t0->p->getX->setValue->p2->getX->setProduct->t1->p->getY->setValue->p2->getY->setProduct->t3->p2->getX->setValue->p2->getY->setSum->t4->p->getX->setValue->p->getY->setSum->p->getX->setReduced->t3->setProduct->t4->setValue->setSum->t3->setDifference->t4->p2->getY->setValue->p->getZ->setProduct->t4->p->getY->setSum->p->getY->p2->getX->setValue->p->getZ->setProduct->p->getY->p->getX->setSum->t2->p->getZ->setValue->p->getZ->setProduct->p->getX->p->getY->setValue->p->getZ->setDifference->p->getX->setReduced->p->getZ->p->getX->setValue->setProduct->p->getX->p->getZ->setSum->p->getZ->setValue->p->getX->setDifference->p->getX->setSum->p->getY->setProduct->t1->setValue->setProduct->t2->setSum->t2->setReduced->p->getY->setDifference->p->getY->setDifference->p->getY->setReduced->t1->p->getY->setValue->setProduct->p->getY->setSum->t1->setValue->setProduct->t0->setSum->t0->setDifference->t1->setValue->p->getY->setProduct->t2->setValue->p->getY->setProduct->p->getY->p->getX->setValue->p->getZ->setProduct->p->getY->setSum->p->getX->setProduct->p->getX->setDifference->p->getZ->setProduct->t1->setValue->setProduct->p->getZ->setSum
ECOperations#setSum(ProjectivePoint.Mutable, ProjectivePoint.Mutable, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP, MutableIntegerModuloP)::: operations set sum:::t0->p->getX->setValue->p2->getX->setProduct->t1->p->getY->setValue->p2->getY->setProduct->t2->p->getZ->setValue->p2->getZ->setProduct->t3->p->getX->setValue->p->getY->setSum->t4->p2->getX->setValue->p2->getY->setSum->t3->setProduct->t4->setValue->setSum->t3->setDifference->t4->p->getY->setValue->p->getZ->setSum->p->getY->p2->getY->setValue->p2->getZ->setSum->t4->p->getY->setProduct->p->getY->setValue->setSum->t4->p->getY->setDifference->p->getX->p->getZ->setSum->p->getY->p2->getX->setValue->p2->getZ->setSum->p->getX->p->getY->setProduct->p->getY->setValue->setSum->p->getY->setAdditiveInverse->p->getX->setSum->p->getY->setReduced->p->getZ->setValue->setProduct->p->getX->p->getY->setValue->p->getZ->setDifference->p->getZ->p->getX->setValue->setProduct->p->getX->p->getZ->setSum->p->getX->setReduced->p->getZ->setValue->p->getX->setDifference->p->getX->setSum->p->getY->setProduct->t1->setValue->setSum->t2->setSum->t2->setReduced->p->getY->setDifference->p->getY->setDifference->p->getY->setReduced->t1->p->getY->setValue->p->getY->setSum->p->getY->setSum->t1->setValue->setProduct->t0->setSum->t0->setDifference->t1->setValue->p->getY->setProduct->t2->setValue->p->getY->setProduct->p->getY->p->getX->setValue->p->getZ->setProduct->p->getY->setSum->p->getX->setProduct->p->getX->setDifference->p->getZ->setProduct->t1->setValue->setProduct->p->getZ->setSum
ECPrivateKeyImpl#makeEncoding(byte[])::: private key impl make encoding:::ECParameters->getAlgorithmParameters->new->AlgorithmId->try->out->new->DerOutputStream->out->putInteger->privBytes->s->clone->ArrayUtil->reverse->out->putOctetString->val->out->toByteArray->new->DerValue->val->toByteArray->catch->throw->new->InvalidKeyException->finally
ECPrivateKeyImpl#makeEncoding(BigInteger)::: private key impl make encoding:::ECParameters->getAlgorithmParameters->new->AlgorithmId->try->sArr->s->toByteArray->numOctets->params->getOrder->bitLength->sOctets->new->byteArr->inPos->Math->max->outPos->Math->max->length->Math->min->System->arraycopy->out->new->DerOutputStream->out->putInteger->out->putOctetString->val->out->toByteArray->new->DerValue->val->toByteArray->catch->throw->new->InvalidKeyException->finally
ECPrivateKeyImpl#getAlgorithm()::: private key impl get algorithm:::return
ECPrivateKeyImpl#getS()::: private key impl get s:::if->arrCopy->arrayS->clone->ArrayUtil->reverse->new->BigInteger->return
ECPrivateKeyImpl#getArrayS()::: private key impl get array s:::if->arr->getS->toByteArray->ArrayUtil->reverse->byteLength->params->getOrder->bitLength->new->byteArr->length->Math->min->System->arraycopy->return->arrayS->clone
ECPrivateKeyImpl#getParams()::: private key impl get params:::return
ECPrivateKeyImpl#parseKeyBits():::Parse the key:::try->in->new->DerInputStream->derValue->in->getDerValue->if->throw->new->IOException->data->version->data->getInteger->if->throw->new->IOException->privData->data->getOctetString->ArrayUtil->reverse->while->data->available->value->data->getDerValue->if->value->isContextSpecific->else->if->value->isContextSpecific->else->throw->new->InvalidKeyException->algParams->getParameters->if->throw->new->InvalidKeyException->algParams->getParameterSpec->catch->throw->new->InvalidKeyException->throw->new->InvalidKeyException->finally
ECPublicKeyImpl#getAlgorithm()::: public key impl get algorithm:::return
ECPublicKeyImpl#getW()::: public key impl get w:::return
ECPublicKeyImpl#getParams()::: public key impl get params:::return
ECPublicKeyImpl#getEncodedPublicValue()::: public key impl get encoded public value:::return->key->clone
ECPublicKeyImpl#parseKeyBits():::Parse the key:::algParams->getParameters->if->throw->new->InvalidKeyException->try->algParams->getParameterSpec->ECUtil->params->getCurve->decodePoint->catch->throw->new->InvalidKeyException->throw->new->InvalidKeyException->finally
ECPublicKeyImpl#toString()::: public key impl to string:::return->params->getCurve->getField->getFieldSize->w->getAffineX->w->getAffineY
ECPublicKeyImpl#writeReplace()::: public key impl write replace:::return->getAlgorithm->getFormat->getEncoded->new->KeyRep
SunEC.ProviderService#newInstance(Object)::: provider service new instance:::type->getType->if->throw->new->InvalidParameterException->algo->getAlgorithm->try->if->type->equals->inP1363->algo->endsWith->if->algo->algo->length->substring->if->algo->equals->return->new->ECDSASignature.SHA1inP1363Format->new->ECDSASignature.SHA1->else->if->algo->equals->return->new->ECDSASignature.SHA224inP1363Format->new->ECDSASignature.SHA224->else->if->algo->equals->return->new->ECDSASignature.SHA256inP1363Format->new->ECDSASignature.SHA256->else->if->algo->equals->return->new->ECDSASignature.SHA384inP1363Format->new->ECDSASignature.SHA384->else->if->algo->equals->return->new->ECDSASignature.SHA512inP1363Format->new->ECDSASignature.SHA512->else->if->algo->equals->return->new->ECDSASignature.RawinP1363Format->new->ECDSASignature.Raw->else->if->type->equals->if->algo->equals->return->new->ECKeyFactory->else->if->algo->equals->return->new->XDHKeyFactory->else->if->algo->equals->return->new->XDHKeyFactory.X25519->else->if->algo->equals->return->new->XDHKeyFactory.X448->else->if->type->equals->if->algo->equals->return->new->sun.security.util.ECParameters->else->if->type->equals->if->algo->equals->return->new->ECKeyPairGenerator->else->if->algo->equals->return->new->XDHKeyPairGenerator->else->if->algo->equals->return->new->XDHKeyPairGenerator.X25519->else->if->algo->equals->return->new->XDHKeyPairGenerator.X448->else->if->type->equals->if->algo->equals->return->new->ECDHKeyAgreement->else->if->algo->equals->return->new->XDHKeyAgreement->else->if->algo->equals->return->new->XDHKeyAgreement.X25519->else->if->algo->equals->return->new->XDHKeyAgreement.X448->catch->throw->new->NoSuchAlgorithmException->finally->throw->new->ProviderException
SunEC#putEntries(boolean)::: sun c put entries:::ATTRS->new->HashMap<>->ATTRS->put->ecKeyClasses->ATTRS->put->ATTRS->put->new->StringArr->new->ProviderService->putService->firstCurve->names->new->StringBuilder->nameSplitPattern->Pattern->compile->supportedCurves->CurveDB->getSupportedCurves->foreach->if->names->append->else->names->append->commonNames->nameSplitPattern->namedCurve->getName->split->foreach->names->commonName->trim->append->names->append->names->namedCurve->getObjectId->append->names->append->apAttrs->new->HashMap<>->apAttrs->names->toString->put->new->StringArr->new->ProviderService->putService->putXDHEntries->if->return->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->ProviderService->putService->new->ProviderService->putService->new->ProviderService->putService->new->ProviderService->putService->new->ProviderService->putService->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->ProviderService->putService
SunEC#putXDHEntries()::: sun c put entries:::ATTRS->new->HashMap<>->ATTRS->put->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->ProviderService->putService->new->StringArr->new->ProviderService->putService->new->StringArr->new->ProviderService->putService
XDHKeyAgreement#engineInit(Key, SecureRandom)::: key agreement engine init:::initImpl
XDHKeyAgreement#engineInit(Key, AlgorithmParameterSpec, SecureRandom)::: key agreement engine init:::initImpl->if->xecParams->XECParameters->InvalidAlgorithmParameterException->new->get->if->xecParams->getParameters->oidEquals->throw->new->InvalidKeyException
XDHKeyAgreement#checkLockedParams(Function, XECParameters)::: key agreement check locked params:::if->throw->exception->lockedParams->getName->apply
XDHKeyAgreement#initImpl(Key)::: key agreement init impl:::if->throw->new->InvalidKeyException->privateKey->xecParams->XECParameters->InvalidKeyException->new->privateKey->getParams->get->InvalidKeyException->new->checkLockedParams->new->XECOperations->privateKey->getScalar->new->InvalidKeyException->orElseThrow
XDHKeyAgreement#engineDoPhase(Key, boolean)::: key agreement engine do phase:::if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->if->throw->new->IllegalStateException->if->throw->new->InvalidKeyException->publicKey->xecParams->XECParameters->InvalidKeyException->new->publicKey->getParams->get->if->ops->getParameters->oidEquals->throw->new->InvalidKeyException->computedSecret->ops->publicKey->getU->encodedPointMultiply->if->allZero->throw->new->InvalidKeyException->return
XDHKeyAgreement#allZero(byte[])::: key agreement all zero:::orValue->for->i->return
XDHKeyAgreement#engineGenerateSecret()::: key agreement engine generate secret:::if->throw->new->IllegalStateException->result->return
XDHKeyAgreement#engineGenerateSecret(byte[], int)::: key agreement engine generate secret:::if->throw->new->IllegalStateException->secretLen->if->throw->new->ShortBufferException->System->arraycopy->return
XDHKeyAgreement#engineGenerateSecret(String)::: key agreement engine generate secret:::throw->new->NoSuchAlgorithmException
XDHKeyFactory#engineTranslateKey(Key)::: key factory engine translate key:::if->throw->new->InvalidKeyException->if->xecKey->params->XECParameters->InvalidKeyException->new->xecKey->getParams->get->InvalidKeyException->new->checkLockedParams->if->publicKey->return->publicKey->getU->new->XDHPublicKeyImpl->else->if->privateKey->scalar->privateKey->getScalar->new->InvalidKeyException->orElseThrow->return->new->XDHPrivateKeyImpl->else->throw->new->InvalidKeyException->else->if->key->getFormat->equals->result->key->getEncoded->new->XDHPublicKeyImpl->InvalidKeyException->new->result->getParams->checkLockedParams->return->else->if->key->getFormat->equals->result->key->getEncoded->new->XDHPrivateKeyImpl->InvalidKeyException->new->result->getParams->checkLockedParams->return->else->throw->new->InvalidKeyException
XDHKeyFactory#checkLockedParams(Function, AlgorithmParameterSpec)::: key factory check locked params:::params->XECParameters->get->checkLockedParams
XDHKeyFactory#checkLockedParams(Function, XECParameters)::: key factory check locked params:::if->throw->exception->lockedParams->getName->apply
XDHKeyFactory#engineGeneratePublic(KeySpec)::: key factory engine generate public:::try->return->generatePublicImpl->catch->throw->new->InvalidKeySpecException->finally
XDHKeyFactory#engineGeneratePrivate(KeySpec)::: key factory engine generate private:::try->return->generatePrivateImpl->catch->throw->new->InvalidKeySpecException->finally
XDHKeyFactory#generatePublicImpl(KeySpec)::: key factory generate public impl:::if->x509Spec->result->x509Spec->getEncoded->new->XDHPublicKeyImpl->InvalidKeySpecException->new->result->getParams->checkLockedParams->return->else->if->publicKeySpec->params->XECParameters->InvalidKeySpecException->new->publicKeySpec->getParams->get->InvalidKeySpecException->new->checkLockedParams->return->publicKeySpec->getU->new->XDHPublicKeyImpl->else->throw->new->InvalidKeySpecException
XDHKeyFactory#generatePrivateImpl(KeySpec)::: key factory generate private impl:::if->pkcsSpec->result->pkcsSpec->getEncoded->new->XDHPrivateKeyImpl->InvalidKeySpecException->new->result->getParams->checkLockedParams->return->else->if->privateKeySpec->params->XECParameters->InvalidKeySpecException->new->privateKeySpec->getParams->get->InvalidKeySpecException->new->checkLockedParams->return->privateKeySpec->getScalar->new->XDHPrivateKeyImpl->else->throw->new->InvalidKeySpecException
XDHKeyFactory#engineGetKeySpec(Key, Class)::: key factory engine get key spec:::if->InvalidKeySpecException->new->getParams->checkLockedParams->if->isAssignableFrom->if->key->getFormat->equals->throw->new->InvalidKeySpecException->return->keySpec->key->getEncoded->new->X509EncodedKeySpec->cast->else->if->isAssignableFrom->xecKey->return->keySpec->xecKey->getParams->xecKey->getU->new->XECPublicKeySpec->cast->else->throw->new->InvalidKeySpecException->else->if->InvalidKeySpecException->new->getParams->checkLockedParams->if->isAssignableFrom->if->key->getFormat->equals->throw->new->InvalidKeySpecException->return->keySpec->key->getEncoded->new->PKCS8EncodedKeySpec->cast->else->if->isAssignableFrom->xecKey->scalar->xecKey->getScalar->new->InvalidKeySpecException->orElseThrow->return->keySpec->xecKey->getParams->new->XECPrivateKeySpec->cast->else->throw->new->InvalidKeySpecException->else->throw->new->InvalidKeySpecException
XDHKeyPairGenerator#tryInitialize(NamedParameterSpec)::: key pair generator try initialize:::try->initialize->catch->name->paramSpec->getName->throw->new->ProviderException->finally
XDHKeyPairGenerator#initialize(int, SecureRandom)::: key pair generator initialize:::params->XECParameters->InvalidParameterException->new->getBySize->initializeImpl
XDHKeyPairGenerator#initialize(AlgorithmParameterSpec, SecureRandom)::: key pair generator initialize:::xecParams->XECParameters->InvalidAlgorithmParameterException->new->get->initializeImpl
XDHKeyPairGenerator#initializeImpl(XECParameters, SecureRandom)::: key pair generator initialize impl:::if->throw->lockedParams->getName->new->InvalidParameterException->new->XECOperations->JCAUtil->getSecureRandom
XDHKeyPairGenerator#generateKeyPair()::: key pair generator generate key pair:::privateKey->ops->generatePrivate->publicKey->ops->privateKey->clone->computePublic->try->return->ops->getParameters->new->XDHPublicKeyImpl->ops->getParameters->new->XDHPrivateKeyImpl->new->KeyPair->catch->throw->new->ProviderException->finally
XDHPrivateKeyImpl#checkLength(XECParameters)::: private key impl check length:::if->params->getBytes->throw->params->getBytes->new->InvalidKeyException
XDHPrivateKeyImpl#getK()::: private key impl get k:::return->key->clone
XDHPrivateKeyImpl#getAlgorithm()::: private key impl get algorithm:::return
XDHPrivateKeyImpl#getParams()::: private key impl get params:::return
XDHPrivateKeyImpl#getScalar()::: private key impl get scalar:::return->Optional->getK->of
XDHPublicKeyImpl#checkLength(XECParameters)::: public key impl check length:::if->params->getBytes->getKey->length->throw->params->getBytes->new->InvalidKeyException
XDHPublicKeyImpl#getU()::: public key impl get u:::return
XDHPublicKeyImpl#getParams()::: public key impl get params:::return
XDHPublicKeyImpl#getAlgorithm()::: public key impl get algorithm:::return
XDHPublicKeyImpl#writeReplace()::: public key impl write replace:::return->getAlgorithm->getFormat->getEncoded->new->KeyRep
XDHPublicKeyImpl#swap(byte[], int, int)::: public key impl swap:::tmp
XDHPublicKeyImpl#reverse(byte[])::: public key impl reverse:::i->j->while->swap
XECOperations#getParameters()::: operations get parameters:::return
XECOperations#generatePrivate(SecureRandom)::: operations generate private:::result->getBytes->new->byteArr->random->nextBytes->return
XECOperations#computePublic(byte[]):::Compute a public key from an encoded private key:::pruneK->return->pointMultiply->asBigInteger
XECOperations#encodedPointMultiply(byte[], BigInteger):::Multiply an encoded scalar with a point as a BigInteger and return an encoded point:::pruneK->elemU->field->getElement->return->pointMultiply->params->getBytes->asByteArray
XECOperations#encodedPointMultiply(byte[], byte[]):::Multiply an encoded scalar with an encoded point and return an encoded point:::pruneK->elemU->decodeU->return->pointMultiply->params->getBytes->asByteArray
XECOperations#decodeU(byte[], int):::Return the field element corresponding to an encoded u-coordinate:::maskHighOrder->return->field->getElement
XECOperations#maskHighOrder(byte[], int):::Mask off the high order bits of an encoded integer in an array:::lastByteIndex->bitsMod8->highBits->msbMaskOff->return
XECOperations#pruneK(byte[], int, int):::Prune an encoded scalar value by modifying it in place:::lastByteIndex->highBits->maskHighOrder->msbMaskOn->lsbMaskOff
XECOperations#pruneK(byte[])::: operations prune k:::params->getBits->params->getLogCofactor->pruneK
XECOperations#decodeU(byte[])::: operations decode u:::return->params->getBits->decodeU
XECOperations#cswap(int, MutableIntegerModuloP, MutableIntegerModuloP)::: operations cswap:::x1->conditionalSwapWith
XECOperations#getIntegerFieldModulo(BigInteger)::: operations get integer field modulo:::if->p->equals->return->new->IntegerPolynomial25519->else->if->p->equals->return->new->IntegerPolynomial448->throw->p->toString->new->ProviderException
XECOperations#bitAt(byte[], int)::: operations bit at:::byteIndex->bitIndex->return
XECOperations#pointMultiply(byte[], ImmutableIntegerModuloP)::: operations point multiply:::x_1->x_2->mutable->z_2->mutable->x_3->u->mutable->z_3->mutable->swap->m1->mutable->DA->mutable->E->mutable->a24_times_E->mutable->for->t->params->getBits->cswap->cswap->return->x_2->z_2->multiplicativeInverse->setProduct
XECParameters#getBits()::: parameters get bits:::return
XECParameters#getBytes()::: parameters get bytes:::return
XECParameters#getLogCofactor()::: parameters get log cofactor:::return
XECParameters#getP()::: parameters get p:::return
XECParameters#getA24()::: parameters get a24:::return
XECParameters#getBasePoint()::: parameters get base point:::return
XECParameters#getOid()::: parameters get oid:::return
XECParameters#getName()::: parameters get name:::return
XECParameters#addParameters(int, BigInteger, int, byte, int, int[], String, Map, Map, Map)::: parameters add parameters:::oid->new->ObjectIdentifier->params->new->XECParameters->bySize->put->byOid->put->byName->put
XECParameters#getByOid(ObjectIdentifier)::: parameters get by oid:::return->Optional->OID_MAP->get->ofNullable
XECParameters#getBySize(int)::: parameters get by size:::return->Optional->SIZE_MAP->get->ofNullable
XECParameters#getByName(String)::: parameters get by name:::return->Optional->NAME_MAP->get->ofNullable
XECParameters#oidEquals(XECParameters)::: parameters oid equals:::return->oid->other->getOid->equals
XECParameters#apply(Function, A)::: parameters apply:::return->new->Supplier<B>
XECParameters#getBySize(Function, int):::Get parameters by key size, or throw an exception if no parameters are defined for the specified key size:::xecParams->getBySize->return->xecParams->apply->orElseThrow
XECParameters#get(Function, AlgorithmId):::Get parameters by algorithm ID, or throw an exception if no parameters are defined for the specified ID:::xecParams->algId->getOID->getByOid->return->xecParams->algId->getOID->apply->orElseThrow
XECParameters#get(Function, AlgorithmParameterSpec):::Get parameters by algorithm parameter spec, or throw an exception if no parameters are defined for the spec:::if->namedParams->xecParams->namedParams->getName->getByName->return->xecParams->namedParams->getName->apply->orElseThrow->else->throw->exception->apply
