OGLBlitLoops#register()::: blit loops register:::blitIntArgbPreToSurface->new->OGLSwToSurfaceBlit->blitIntArgbPreToTexture->new->OGLSwToTextureBlit->transformBlitIntArgbPreToSurface->new->OGLSwToSurfaceTransform->blitSurfaceToIntArgbPre->new->OGLSurfaceToSwBlit->primitives->new->OGLSurfaceToSurfaceBlit->new->OGLSurfaceToSurfaceScale->new->OGLSurfaceToSurfaceTransform->new->OGLRTTSurfaceToSurfaceBlit->new->OGLRTTSurfaceToSurfaceScale->new->OGLRTTSurfaceToSurfaceTransform->new->OGLSurfaceToSwBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLSwToSurfaceBlit->new->OGLGeneralBlit->new->OGLAnyCompositeBlit->new->OGLAnyCompositeBlit->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceScale->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLSwToSurfaceTransform->new->OGLGeneralTransformedBlit->new->OGLTextureToSurfaceBlit->new->OGLTextureToSurfaceScale->new->OGLTextureToSurfaceTransform->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLSwToTextureBlit->new->OGLGeneralBlit->GraphicsPrimitiveMgr->register
OGLBlitLoops#createPackedParams(boolean, boolean, boolean, boolean, int, int):::Packs the given parameters into a single int value in order to save space on the rendering queue.:::return
OGLBlitLoops#enqueueBlit(RenderQueue, SurfaceData, SurfaceData, int, int, int, int, int, double, double, double, double):::Enqueues a BLIT operation with the given parameters:::buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putDouble->putDouble->buf->putDouble->putDouble->buf->src->getNativeOps->putLong->buf->dst->getNativeOps->putLong
OGLBlitLoops#Blit(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, int, boolean)::: blit loops  blit:::ctxflags->if->srcData->getTransparency->rq->OGLRenderQueue->getInstance->rq->lock->try->rq->addReference->oglDst->if->gc->oglDst->getOGLGraphicsConfig->OGLContext->setScratchSurface->else->OGLContext->validateContext->packedParams->createPackedParams->enqueueBlit->rq->flushNow->catch->finally->rq->unlock
OGLBlitLoops#IsoBlit(SurfaceData, SurfaceData, BufferedImage, BufferedImageOp, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, boolean):::Note: The srcImg and biop parameters are only used when invoked from the OGLBufImgOps.renderImageWithOp() method; in all other cases, this method can be called with null values for those two parameters, and they will be effectively ignored.:::ctxflags->if->srcData->getTransparency->rq->OGLRenderQueue->getInstance->rq->lock->try->oglSrc->oglDst->srctype->oglSrc->getType->rtt->srcCtxData->if->else->if->else->OGLContext->validateContext->if->OGLBufImgOps->enableBufImgOp->packedParams->createPackedParams->enqueueBlit->if->OGLBufImgOps->disableBufImgOp->if->oglDst->isOnScreen->rq->flushNow->catch->finally->rq->unlock
OGLSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: surface to surface blit  blit:::OGLBlitLoops->IsoBlit
OGLSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: surface to surface scale  scale:::OGLBlitLoops->IsoBlit
OGLSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: surface to surface transform  transform:::OGLBlitLoops->IsoBlit
OGLRTTSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: surface to surface blit  blit:::OGLBlitLoops->IsoBlit
OGLRTTSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: surface to surface scale  scale:::OGLBlitLoops->IsoBlit
OGLRTTSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: surface to surface transform  transform:::OGLBlitLoops->IsoBlit
OGLSurfaceToSwBlit#complexClipBlit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: surface to sw blit complex clip blit:::cachedSrc->if->srcTmp->get->type->convertFrom->performop->Blit->src->getSurfaceType->dst->getSurfaceType->getFromCache->performop->Blit->if->new->WeakReference<>
OGLSurfaceToSwBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: surface to sw blit  blit:::if->clip->getIntersectionXYWH->if->clip->isEmpty->return->clip->getLoX->clip->getLoY->clip->getLoX->clip->getLoY->clip->getWidth->clip->getHeight->if->clip->isRectangular->complexClipBlit->return->rq->OGLRenderQueue->getInstance->rq->lock->try->rq->addReference->buf->rq->getBuffer->OGLContext->validateContext->rq->ensureCapacityAndAlignment->buf->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putInt->buf->src->getNativeOps->putLong->buf->dst->getNativeOps->putLong->rq->flushNow->catch->finally->rq->unlock
OGLSwToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: sw to surface blit  blit:::OGLBlitLoops->Blit
OGLSwToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: sw to surface scale  scale:::OGLBlitLoops->Blit
OGLSwToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: sw to surface transform  transform:::OGLBlitLoops->Blit
OGLSwToTextureBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: sw to texture blit  blit:::OGLBlitLoops->Blit
OGLTextureToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: texture to surface blit  blit:::OGLBlitLoops->IsoBlit
OGLTextureToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: texture to surface scale  scale:::OGLBlitLoops->IsoBlit
OGLTextureToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: texture to surface transform  transform:::OGLBlitLoops->IsoBlit
OGLGeneralBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: general blit  blit:::convertsrc->Blit->src->getSurfaceType->getFromCache->cachedSrc->if->srcTmp->get->convertFrom->performop->Blit->if->new->WeakReference<>
OGLGeneralTransformedBlit#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: general transformed blit  transform:::convertsrc->Blit->src->getSurfaceType->getFromCache->cachedSrc->srcTmp->get->convertFrom->performop->Transform->if->new->WeakReference<>
OGLAnyCompositeBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: any composite blit  blit:::if->cachedSrc->if->srcTmp->get->convertFrom->if->new->WeakReference<>->cachedDst->if->dstTmp->get->dstBuffer->convertFrom->bufferClip->clip->getTranslatedRegion->performop->Blit->src->getSurfaceType->dstBuffer->getSurfaceType->getFromCache->performop->Blit->if->new->WeakReference<>->convertresult->Blit
OGLBufImgOps#renderImageWithOp(SunGraphics2D, BufferedImage, BufferedImageOp, int, int):::This method is called from OGLDrawImage.transformImage() only:::if->if->isConvolveOpValid->return->else->if->if->isRescaleOpValid->return->else->if->if->isLookupOpValid->return->else->return->dstData->if->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->oglSrc->gc->oglSrc->getOGLGraphicsConfig->if->oglSrc->getType->gc->isCapPresent->return->sw->img->getWidth->sh->img->getHeight->OGLBlitLoops->sg->getCompClip->IsoBlit->return
OGLContext#setScratchSurface(OGLGraphicsConfig):::Convenience method that delegates to setScratchSurface() below.:::gc->getNativeConfigInfo->setScratchSurface
OGLContext#setScratchSurface(long):::Makes the given GraphicsConfig's context current to its associated "scratch surface":::rq->OGLRenderQueue->getInstance->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong
OGLContext#invalidateCurrentContext():::Invalidates the currentContext field to ensure that we properly revalidate the OGLContext (make it current, etc.) next time through the validate() method:::if->currentContext->invalidateContext->rq->OGLRenderQueue->getInstance->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow
OGLContext#getRenderQueue()::: context get render queue:::return->OGLRenderQueue->getInstance
OGLContext#getOGLIdString():::Returns a string representing adapter id (vendor, renderer, version):::
OGLContext#saveState()::: context save state:::invalidateContext->invalidateCurrentContext->setScratchSurface->rq->ensureCapacity->buf->putInt->rq->flushNow
OGLContext#restoreState()::: context restore state:::invalidateContext->invalidateCurrentContext->setScratchSurface->rq->ensureCapacity->buf->putInt->rq->flushNow
OGLContext.OGLContextCaps#toString()::: context caps to string:::sb->super->toString->new->StringBuilder->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->return->sb->toString
OGLDrawImage#renderImageXform(SunGraphics2D, Image, AffineTransform, int, int, int, int, int, Color)::: draw image render image xform:::if->dstData->srcData->dstData->getSourceSurfaceData->if->isBgOperation->srcData->getSurfaceType->srcData->getSurfaceType->srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blit->TransformBlit->getFromCache->if->blit->sg->getCompClip->Transform->return->super->renderImageXform
OGLDrawImage#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: draw image transform image:::if->if->atop->atop->getTransform->atop->getInterpolationType->transformImage->return->else->if->OGLBufImgOps->renderImageWithOp->return->op->filter->copyImage
OGLGraphicsConfig#getContext()::: graphics config get context:::
OGLGraphicsConfig#getNativeConfigInfo()::: graphics config get native config info:::
OGLGraphicsConfig#isCapPresent(int)::: graphics config is cap present:::
OGLGraphicsConfig#createManagedSurface(int, int, int)::: graphics config create managed surface:::
OGLMaskBlit#register()::: mask blit register:::primitives->new->OGLMaskBlit->new->OGLMaskBlit->new->OGLMaskBlit->new->OGLMaskBlit->new->OGLMaskBlit->new->OGLMaskBlit->GraphicsPrimitiveMgr->register
OGLMaskBlit#validateContext(SurfaceData, Composite, Region)::: mask blit validate context:::oglDst->OGLContext->validateContext
OGLMaskFill#register()::: mask fill register:::primitives->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->new->OGLMaskFill->GraphicsPrimitiveMgr->register
OGLMaskFill#maskFill(int, int, int, int, int, int, int, byte[])::: mask fill mask fill:::
OGLMaskFill#validateContext(SunGraphics2D, Composite, int)::: mask fill validate context:::dstData->try->catch->throw->new->InvalidPipeException->finally->OGLContext->sg2d->getCompClip->validateContext
OGLPaints#isValid(SunGraphics2D):::Attempts to locate an implementation corresponding to the paint state of the provided SunGraphics2D object:::impl->impls->get->return->impl->isPaintValid
OGLPaints#isPaintValid(SunGraphics2D):::Returns true if this implementation is able to accelerate the Paint object associated with, and under the conditions of, the provided SunGraphics2D instance; otherwise returns false.:::
OGLPaints.Gradient#isPaintValid(SunGraphics2D):::There are no restrictions for accelerating GradientPaint, so this method always returns true.:::return
OGLPaints.Texture#isPaintValid(SunGraphics2D):::Returns true if the given TexturePaint instance can be used by the accelerated OGLPaints.Texture implementation:::paint->dstData->bi->paint->getImage->if->dstData->isTexNonPow2Available->imgw->bi->getWidth->imgh->bi->getHeight->if->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->oglData->if->oglData->getType->return->return
OGLPaints.MultiGradient#isPaintValid(SunGraphics2D):::Returns true if the given MultipleGradientPaint instance can be used by the accelerated OGLPaints.MultiGradient implementation:::paint->if->paint->getFractions->return->dstData->gc->dstData->getOGLGraphicsConfig->if->gc->isCapPresent->return->return
OGLPaints.LinearGradient#isPaintValid(SunGraphics2D)::: linear gradient is paint valid:::paint->if->paint->getFractions->paint->getCycleMethod->paint->getColorSpace->return->return->super->isPaintValid
OGLRenderer#validateContext(SunGraphics2D)::: renderer validate context:::ctxflags->getTransparency->dstData->try->catch->throw->new->InvalidPipeException->finally->OGLContext->sg2d->getCompClip->validateContext
OGLRenderer#validateContextAA(SunGraphics2D)::: renderer validate context a:::ctxflags->dstData->try->catch->throw->new->InvalidPipeException->finally->OGLContext->sg2d->getCompClip->validateContext
OGLRenderer#copyArea(SunGraphics2D, int, int, int, int, int, int)::: renderer copy area:::rq->lock->try->ctxflags->getTransparency->dstData->try->catch->throw->new->InvalidPipeException->finally->OGLContext->sg2d->getCompClip->validateContext->rq->ensureCapacity->buf->putInt->buf->putInt->putInt->putInt->putInt->buf->putInt->putInt->catch->finally->rq->unlock
OGLRenderer#drawPoly(int[], int[], int, boolean, int, int)::: renderer draw poly:::
OGLRenderer#traceWrap()::: renderer trace wrap:::return->new->Tracer
OGLRenderer.Tracer#getAAParallelogramPipe()::: tracer get parallelogram pipe:::realpipe->oglr->getAAParallelogramPipe->return->new->ParallelogramPipe
OGLRenderer.Tracer#validateContext(SunGraphics2D)::: tracer validate context:::oglr->validateContext
OGLRenderer.Tracer#drawLine(SunGraphics2D, int, int, int, int)::: tracer draw line:::GraphicsPrimitive->tracePrimitive->oglr->drawLine
OGLRenderer.Tracer#drawRect(SunGraphics2D, int, int, int, int)::: tracer draw rect:::GraphicsPrimitive->tracePrimitive->oglr->drawRect
OGLRenderer.Tracer#drawPoly(SunGraphics2D, int[], int[], int, boolean)::: tracer draw poly:::GraphicsPrimitive->tracePrimitive->oglr->drawPoly
OGLRenderer.Tracer#fillRect(SunGraphics2D, int, int, int, int)::: tracer fill rect:::GraphicsPrimitive->tracePrimitive->oglr->fillRect
OGLRenderer.Tracer#drawPath(SunGraphics2D, Path2D.Float, int, int)::: tracer draw path:::GraphicsPrimitive->tracePrimitive->oglr->drawPath
OGLRenderer.Tracer#fillPath(SunGraphics2D, Path2D.Float, int, int)::: tracer fill path:::GraphicsPrimitive->tracePrimitive->oglr->fillPath
OGLRenderer.Tracer#fillSpans(SunGraphics2D, SpanIterator, int, int)::: tracer fill spans:::GraphicsPrimitive->tracePrimitive->oglr->fillSpans
OGLRenderer.Tracer#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: tracer fill parallelogram:::GraphicsPrimitive->tracePrimitive->oglr->fillParallelogram
OGLRenderer.Tracer#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: tracer draw parallelogram:::GraphicsPrimitive->tracePrimitive->oglr->drawParallelogram
OGLRenderer.Tracer#copyArea(SunGraphics2D, int, int, int, int, int, int)::: tracer copy area:::GraphicsPrimitive->tracePrimitive->oglr->copyArea
OGLRenderQueue#getInstance():::Returns the single OGLRenderQueue instance:::if->new->OGLRenderQueue->return
OGLRenderQueue#sync():::Flushes the single OGLRenderQueue instance synchronously:::if->theInstance->lock->try->theInstance->ensureCapacity->theInstance->getBuffer->putInt->theInstance->flushNow->catch->finally->theInstance->unlock
OGLRenderQueue#disposeGraphicsConfig(long):::Disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread.:::rq->getInstance->rq->lock->try->OGLContext->setScratchSurface->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
OGLRenderQueue#isQueueFlusherThread():::Returns true if the current thread is the OGL QueueFlusher thread.:::return->Thread->currentThread->getInstance
OGLRenderQueue#flushNow()::: render queue flush now:::try->flusher->flushNow->catch->println->e->printStackTrace->finally
OGLRenderQueue#flushAndInvokeNow(Runnable)::: render queue flush and invoke now:::try->flusher->flushAndInvokeNow->catch->println->e->printStackTrace->finally
OGLRenderQueue#flushBuffer(long, int)::: render queue flush buffer:::
OGLRenderQueue#flushBuffer()::: render queue flush buffer:::limit->buf->position->if->buf->getAddress->flushBuffer->buf->clear->refSet->clear
OGLRenderQueue.QueueFlusher#flushNow()::: queue flusher flush now:::notify->while->try->wait->catch->finally->if->throw
OGLRenderQueue.QueueFlusher#flushAndInvokeNow(Runnable)::: queue flusher flush and invoke now:::flushNow
OGLRenderQueue.QueueFlusher#run()::: queue flusher run:::timedOut->while->while->try->wait->if->tryLock->if->buf->position->else->unlock->catch->finally->try->flushBuffer->if->task->run->catch->println->x->printStackTrace->finally->if->unlock->notify
OGLSurfaceData#initTexture(long, boolean, boolean, boolean, int, int)::: surface data init texture:::
OGLSurfaceData#initFBObject(long, boolean, boolean, boolean, int, int)::: surface data init object:::
OGLSurfaceData#initFlipBackbuffer(long)::: surface data init flip backbuffer:::
OGLSurfaceData#getTextureTarget(long)::: surface data get texture target:::
OGLSurfaceData#getTextureID(long)::: surface data get texture d:::
OGLSurfaceData#makeProxyFor(SurfaceData)::: surface data make proxy for:::return->OGLSurfaceDataProxy->createProxy
OGLSurfaceData#getCustomSurfaceType(int):::Returns the appropriate SurfaceType corresponding to the given OpenGL surface type constant (e.g:::switch->return->return->return
OGLSurfaceData#initSurfaceNow(int, int):::Note: This should only be called from the QFT under the AWT lock:::isOpaque->getTransparency->success->switch->getNativeOps->isTexNonPow2Available->isTexRectAvailable->initTexture->break->getNativeOps->isTexNonPow2Available->isTexRectAvailable->initFBObject->break->getNativeOps->initFlipBackbuffer->break->break->if->throw->new->OutOfMemoryError
OGLSurfaceData#initSurface(int, int):::Initializes the appropriate OpenGL offscreen surface based on the value of the type parameter:::rq->OGLRenderQueue->getInstance->rq->lock->try->switch->OGLContext->setScratchSurface->break->break->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock
OGLSurfaceData#getContext():::Returns the OGLContext for the GraphicsConfig associated with this surface.:::return->graphicsConfig->getContext
OGLSurfaceData#getOGLGraphicsConfig():::Returns the OGLGraphicsConfig associated with this surface.:::return
OGLSurfaceData#getType():::Returns one of the surface type constants defined above.:::return
OGLSurfaceData#getTextureTarget():::If this surface is backed by a texture object, returns the target for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB):::return->getNativeOps->getTextureTarget
OGLSurfaceData#getTextureID():::If this surface is backed by a texture object, returns the texture ID for that texture:::return->getNativeOps->getTextureID
OGLSurfaceData#getNativeResource(int):::Returns native resource of specified resType associated with this surface:::if->return->getTextureID->return
OGLSurfaceData#getRaster(int, int, int, int)::: surface data get raster:::throw->new->InternalError
OGLSurfaceData#canRenderLCDText(SunGraphics2D):::For now, we can only render LCD text if:   - the fragment shader extension is available, and   - the source color is opaque, and   - blending is SrcOverNoEa or disabled   - and the destination is opaque  Eventually, we could enhance the native OGL text rendering code and remove the above restrictions, but that would require significantly more code just to support a few uncommon cases.:::return->graphicsConfig->isCapPresent->getTransparency->canHandleComposite
OGLSurfaceData#canHandleComposite(Composite)::: surface data can handle composite:::if->ac->return->ac->getRule->ac->getAlpha->return
OGLSurfaceData#validatePipe(SunGraphics2D)::: surface data validate pipe:::textpipe->validated->if->getRule->else->super->validatePipe->txPipe->nonTxPipe->if->if->if->else->if->if->OGLPaints->isValid->else->if->if->graphicsConfig->isCapPresent->if->super->validatePipe->aaConverter->new->PixelToParallelogramConverter->else->if->if->if->else->if->else->else->if->super->validatePipe
OGLSurfaceData#getMaskFill(SunGraphics2D)::: surface data get mask fill:::if->if->OGLPaints->isValid->graphicsConfig->isCapPresent->return->return->super->getMaskFill
OGLSurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int)::: surface data copy area:::if->return->oglRenderPipe->copyArea->return
OGLSurfaceData#flush()::: surface data flush:::invalidate->rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->setScratchSurface->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->getNativeOps->putLong->rq->flushNow->catch->finally->rq->unlock
OGLSurfaceData#dispose(long, OGLGraphicsConfig):::Disposes the native resources associated with the given OGLSurfaceData (referenced by the pData parameter):::rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->setScratchSurface->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
OGLSurfaceData#swapBuffers(long)::: surface data swap buffers:::rq->OGLRenderQueue->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
OGLSurfaceData#isTexNonPow2Available():::Returns true if OpenGL textures can have non-power-of-two dimensions when using the basic GL_TEXTURE_2D target.:::return->graphicsConfig->isCapPresent
OGLSurfaceData#isTexRectAvailable():::Returns true if OpenGL textures can have non-power-of-two dimensions when using the GL_TEXTURE_RECTANGLE_ARB target (only available when the GL_ARB_texture_rectangle extension is present).:::return->graphicsConfig->isCapPresent
OGLSurfaceData#getNativeBounds()::: surface data get native bounds:::rq->OGLRenderQueue->getInstance->rq->lock->try->return->new->Rectangle->catch->finally->rq->unlock
OGLSurfaceData#isOnScreen():::Returns true if the surface is an on-screen window surface or a FBO texture attached to an on-screen CALayer:::return->getType
OGLSurfaceDataProxy#createProxy(SurfaceData, OGLGraphicsConfig)::: surface data proxy create proxy:::if->return->return->srcData->getTransparency->new->OGLSurfaceDataProxy
OGLSurfaceDataProxy#validateSurfaceData(SurfaceData, SurfaceData, int, int)::: surface data proxy validate surface data:::if->try->oglgc->createManagedSurface->catch->return->finally->return
OGLSurfaceDataProxy#isSupportedOperation(SurfaceData, int, CompositeType, Color)::: surface data proxy is supported operation:::return->comp->isDerivedFrom
OGLTextRenderer#drawGlyphList(int, boolean, boolean, boolean, int, float, float, long[], float[])::: text renderer draw glyph list:::
OGLTextRenderer#validateContext(SunGraphics2D, Composite)::: text renderer validate context:::oglDst->OGLContext->sg2d->getCompClip->validateContext
OGLTextRenderer#traceWrap()::: text renderer trace wrap:::return->new->Tracer
OGLTextRenderer.Tracer#drawGlyphList(SunGraphics2D, GlyphList)::: tracer draw glyph list:::GraphicsPrimitive->tracePrimitive->super->drawGlyphList
OGLUtilities#isQueueFlusherThread():::Returns true if the current thread is the OGL QueueFlusher thread.:::return->OGLRenderQueue->isQueueFlusherThread
OGLUtilities#invokeWithOGLContextCurrent(Graphics, Runnable):::Invokes the given Runnable on the OGL QueueFlusher thread with the OpenGL context corresponding to the given Graphics object made current:::rq->OGLRenderQueue->getInstance->rq->lock->try->if->if->return->sData->if->return->OGLContext->validateContext->rq->flushAndInvokeNow->OGLContext->invalidateCurrentContext->catch->finally->rq->unlock->return
OGLUtilities#invokeWithOGLSharedContextCurrent(GraphicsConfiguration, Runnable):::Invokes the given Runnable on the OGL QueueFlusher thread with the "shared" OpenGL context (corresponding to the given GraphicsConfiguration object) made current:::if->return->rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->setScratchSurface->rq->flushAndInvokeNow->OGLContext->invalidateCurrentContext->catch->finally->rq->unlock->return
OGLUtilities#getOGLViewport(Graphics, int, int):::Returns the Rectangle describing the OpenGL viewport on the Java 2D surface associated with the given Graphics object and component width and height:::if->return->sg2d->sData->x0->y0->surfaceBounds->sData->getBounds->x1->y1->return->new->Rectangle
OGLUtilities#getOGLScissorBox(Graphics):::Returns the Rectangle describing the OpenGL scissor box on the Java 2D surface associated with the given Graphics object:::if->return->sg2d->sData->r->sg2d->getCompClip->if->r->isRectangular->return->x0->r->getLoX->y0->r->getLoY->w->r->getWidth->h->r->getHeight->surfaceBounds->sData->getBounds->x1->y1->return->new->Rectangle
OGLUtilities#getOGLSurfaceIdentifier(Graphics):::Returns an Object identifier for the Java 2D surface associated with the given Graphics object:::if->return->return
OGLUtilities#getOGLSurfaceType(Graphics):::Returns one of the OGL-specific surface type constants (defined in this class), which describes the surface associated with the given Graphics object.:::if->return->sData->if->return->return->getType
OGLUtilities#getOGLTextureType(Graphics):::Returns the OpenGL texture target constant (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB) for the surface associated with the given Graphics object:::if->return->sData->if->return->return->getTextureTarget
WGLGraphicsConfig#getDefaultPixFmt(int)::: graphics config get default pix fmt:::
WGLGraphicsConfig#initWGL()::: graphics config init l:::
WGLGraphicsConfig#getWGLConfigInfo(int, int)::: graphics config get config info:::
WGLGraphicsConfig#getOGLCapabilities(long)::: graphics config get capabilities:::
WGLGraphicsConfig#getProxyKey()::: graphics config get proxy key:::return
WGLGraphicsConfig#createManagedSurface(int, int, int)::: graphics config create managed surface:::return->WGLSurfaceData->getColorModel->createData
WGLGraphicsConfig#getConfig(Win32GraphicsDevice, int)::: graphics config get config:::if->return->cfginfo->ids->new->StringArr->rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->invalidateCurrentContext->action->device->getScreen->new->WGLGetConfigInfo->rq->flushAndInvokeNow->action->getConfigInfo->if->OGLContext->setScratchSurface->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock->if->return->oglCaps->getOGLCapabilities->caps->new->OGLContextCaps->return->new->WGLGraphicsConfig
WGLGraphicsConfig.WGLGetConfigInfo#run()::: get config info run:::getWGLConfigInfo
WGLGraphicsConfig.WGLGetConfigInfo#getConfigInfo()::: get config info get config info:::return
WGLGraphicsConfig#isWGLAvailable()::: graphics config is available:::return
WGLGraphicsConfig#isCapPresent(int):::Returns true if the provided capability bit is present for this config:::return->oglCaps->getCaps
WGLGraphicsConfig#getNativeConfigInfo()::: graphics config get native config info:::return
WGLGraphicsConfig#getContext()::: graphics config get context:::return
WGLGraphicsConfig.WGLGCDisposerRecord#dispose()::: disposer record dispose:::if->OGLRenderQueue->disposeGraphicsConfig
WGLGraphicsConfig#displayChanged()::: graphics config display changed:::super->displayChanged->rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->invalidateCurrentContext->catch->finally->rq->unlock
WGLGraphicsConfig#getColorModel(int)::: graphics config get color model:::switch->return->new->DirectColorModel->return->new->DirectColorModel->cs->ColorSpace->getInstance->return->new->DirectColorModel->return
WGLGraphicsConfig#toString()::: graphics config to string:::return
WGLGraphicsConfig#createSurfaceData(WComponentPeer, int):::Creates a new SurfaceData that will be associated with the given WComponentPeer.:::sd->WGLSurfaceData->createData->if->GDIWindowSurfaceData->createData->return
WGLGraphicsConfig#assertOperationSupported(Component, int, BufferCapabilities):::Checks that the requested configuration is natively supported; if not, an AWTException is thrown.:::if->throw->new->AWTException->configCaps->getBufferCapabilities->if->configCaps->isPageFlipping->throw->new->AWTException->if->caps->getFlipContents->throw->new->AWTException
WGLGraphicsConfig#createBackBuffer(WComponentPeer):::Creates a WGL-based backbuffer for the given peer and returns the image wrapper.:::target->peer->getTarget->w->Math->target->getWidth->max->h->Math->target->getHeight->max->return->new->SunVolatileImage
WGLGraphicsConfig#flip(WComponentPeer, Component, VolatileImage, int, int, int, int, BufferCapabilities.FlipContents):::Performs the native WGL flip operation for the given target Component.:::if->vsm->SurfaceManager->getManager->sd->vsm->getPrimarySurfaceData->if->vsd->bbsd->vsd->getFlipSurface->bbg->new->SunGraphics2D->try->bbg->drawImage->catch->finally->bbg->dispose->else->g->peer->getGraphics->try->g->drawImage->catch->finally->g->dispose->return->else->if->return->OGLSurfaceData->peer->getData->swapBuffers->if->g->backBuffer->getGraphics->try->g->target->getBackground->setColor->g->backBuffer->getWidth->backBuffer->getHeight->fillRect->catch->finally->g->dispose
WGLGraphicsConfig#getBufferCapabilities()::: graphics config get buffer capabilities:::if->dblBuf->isCapPresent->new->WGLBufferCaps->return
WGLGraphicsConfig.WGLImageCaps#isTrueVolatile()::: image caps is true volatile:::return
WGLGraphicsConfig#getImageCapabilities()::: graphics config get image capabilities:::return
WGLGraphicsConfig#createCompatibleVolatileImage(int, int, int, int)::: graphics config create compatible volatile image:::if->isCapPresent->return->vi->new->AccelTypedVolatileImage->sd->vi->getDestSurface->if->getType->vi->flush->return
WGLGraphicsConfig#getContextCapabilities()::: graphics config get context capabilities:::return
WGLSurfaceData#initOps(OGLGraphicsConfig, long, WComponentPeer, long)::: surface data init ops:::
WGLSurfaceData#getDefaultScaleX()::: surface data get default scale x:::return
WGLSurfaceData#getDefaultScaleY()::: surface data get default scale y:::return
WGLSurfaceData#getDeviceConfiguration()::: surface data get device configuration:::return
WGLSurfaceData#createData(WComponentPeer):::Creates a SurfaceData object representing the primary (front) buffer of an on-screen Window.:::if->peer->isAccelCapable->SunToolkit->peer->getTarget->isContainingTopLevelOpaque->return->gc->getGC->return->new->WGLWindowSurfaceData
WGLSurfaceData#createData(WComponentPeer, Image, int):::Creates a SurfaceData object representing the back buffer of a double-buffered on-screen Window.:::if->peer->isAccelCapable->SunToolkit->peer->getTarget->isContainingTopLevelOpaque->return->gc->getGC->r->peer->getBounds->if->return->peer->getColorModel->new->WGLOffScreenSurfaceData->else->return->peer->getColorModel->new->WGLVSyncOffScreenSurfaceData
WGLSurfaceData#createData(WGLGraphicsConfig, int, int, ColorModel, Image, int):::Creates a SurfaceData object representing an off-screen buffer (either a Pbuffer or Texture).:::return->new->WGLOffScreenSurfaceData
WGLSurfaceData#getGC(WComponentPeer)::: surface data get c:::if->return->peer->getGraphicsConfiguration->else->env->GraphicsEnvironment->getLocalGraphicsEnvironment->gd->env->getDefaultScreenDevice->return->gd->getDefaultConfiguration
WGLSurfaceData.WGLWindowSurfaceData#getReplacement()::: window surface data get replacement:::return->peer->getSurfaceData
WGLSurfaceData.WGLWindowSurfaceData#getBounds()::: window surface data get bounds:::r->peer->getBounds->Region->clipRound->Region->clipRound->return
WGLSurfaceData.WGLWindowSurfaceData#getDestination():::Returns destination Component associated with this SurfaceData.:::return->peer->getTarget
WGLSurfaceData.WGLVSyncOffScreenSurfaceData#getFlipSurface()::: sync off screen surface data get flip surface:::return
WGLSurfaceData.WGLVSyncOffScreenSurfaceData#flush()::: sync off screen surface data flush:::flipSurface->flush->super->flush
WGLSurfaceData.WGLOffScreenSurfaceData#getReplacement()::: off screen surface data get replacement:::return->restoreContents
WGLSurfaceData.WGLOffScreenSurfaceData#getBounds()::: off screen surface data get bounds:::if->r->peer->getBounds->Region->clipRound->Region->clipRound->return->else->return->new->Rectangle
WGLSurfaceData.WGLOffScreenSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
WGLSurfaceData#updateWindowAccelImpl(long, WComponentPeer, int, int):::Updates the layered window with the contents of the surface.:::
WGLVolatileSurfaceManager#isAccelerationEnabled()::: volatile surface manager is acceleration enabled:::return
WGLVolatileSurfaceManager#initAcceleratedSurface():::Create a FBO-based SurfaceData object (or init the backbuffer of an existing window if this is a double buffered GraphicsConfig).:::sData->comp->vImg->getComponent->acc->AWTAccessor->getComponentAccessor->peer->acc->getPeer->try->createVSynced->forceback->if->booleanValue->if->caps->peer->getBackBufferCaps->if->ebc->if->ebc->getVSync->ebc->getFlipContents->if->WGLSurfaceData->createData->else->gc->vImg->getGraphicsConfig->cm->gc->vImg->getTransparency->getColorModel->type->vImg->getForcedAccelSurfaceType->if->if->WGLSurfaceData->createData->else->WGLSurfaceData->vImg->getWidth->vImg->getHeight->createData->catch->finally->return
WGLVolatileSurfaceManager#isConfigValid(GraphicsConfiguration)::: volatile surface manager is config valid:::return->vImg->getGraphicsConfig
WGLVolatileSurfaceManager#initContents()::: volatile surface manager init contents:::if->vImg->getForcedAccelSurfaceType->super->initContents
