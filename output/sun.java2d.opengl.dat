OGLBlitLoops#IsoBlit(SurfaceData, SurfaceData, BufferedImage, BufferedImageOp, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, boolean):::Note: The srcImg and biop parameters are only used when invoked from the OGLBufImgOps.renderImageWithOp() method; in all other cases, this method can be called with null values for those two parameters, and they will be effectively ignored.:::ctxflags->if->srcData->getTransparency->rq->OGLRenderQueue->getInstance->rq->lock->try->oglSrc->oglDst->srctype->oglSrc->getType->rtt->srcCtxData->if->else->if->else->OGLContext->validateContext->if->OGLBufImgOps->enableBufImgOp->packedParams->createPackedParams->enqueueBlit->if->OGLBufImgOps->disableBufImgOp->if->oglDst->isOnScreen->rq->flushNow->catch->finally->rq->unlock
OGLBufImgOps#renderImageWithOp(SunGraphics2D, BufferedImage, BufferedImageOp, int, int):::This method is called from OGLDrawImage.transformImage() only:::if->if->isConvolveOpValid->return->else->if->if->isRescaleOpValid->return->else->if->if->isLookupOpValid->return->else->return->dstData->if->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->oglSrc->gc->oglSrc->getOGLGraphicsConfig->if->oglSrc->getType->gc->isCapPresent->return->sw->img->getWidth->sh->img->getHeight->OGLBlitLoops->sg->getCompClip->IsoBlit->return
OGLContext#setScratchSurface(OGLGraphicsConfig):::Convenience method that delegates to setScratchSurface() below.:::gc->getNativeConfigInfo->setScratchSurface
OGLContext#setScratchSurface(long):::Makes the given GraphicsConfig's context current to its associated "scratch surface":::rq->OGLRenderQueue->getInstance->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong
OGLContext#invalidateCurrentContext():::Invalidates the currentContext field to ensure that we properly revalidate the OGLContext (make it current, etc.) next time through the validate() method:::if->currentContext->invalidateContext->rq->OGLRenderQueue->getInstance->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow
OGLContext#getOGLIdString():::Returns a string representing adapter id (vendor, renderer, version):::
OGLPaints#isValid(SunGraphics2D):::Attempts to locate an implementation corresponding to the paint state of the provided SunGraphics2D object:::impl->impls->get->return->impl->isPaintValid
OGLPaints#isPaintValid(SunGraphics2D):::Returns true if this implementation is able to accelerate the Paint object associated with, and under the conditions of, the provided SunGraphics2D instance; otherwise returns false.:::
OGLRenderQueue#getInstance():::Returns the single OGLRenderQueue instance:::if->new->OGLRenderQueue->return
OGLRenderQueue#sync():::Flushes the single OGLRenderQueue instance synchronously:::if->theInstance->lock->try->theInstance->ensureCapacity->theInstance->getBuffer->putInt->theInstance->flushNow->catch->finally->theInstance->unlock
OGLRenderQueue#disposeGraphicsConfig(long):::Disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread.:::rq->getInstance->rq->lock->try->OGLContext->setScratchSurface->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
OGLRenderQueue#isQueueFlusherThread():::Returns true if the current thread is the OGL QueueFlusher thread.:::return->Thread->currentThread->getInstance
OGLSurfaceData#initSurface(int, int):::Initializes the appropriate OpenGL offscreen surface based on the value of the type parameter:::rq->OGLRenderQueue->getInstance->rq->lock->try->switch->OGLContext->setScratchSurface->break->break->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock
OGLSurfaceData#getContext():::Returns the OGLContext for the GraphicsConfig associated with this surface.:::return->graphicsConfig->getContext
OGLSurfaceData#getOGLGraphicsConfig():::Returns the OGLGraphicsConfig associated with this surface.:::return
OGLSurfaceData#getType():::Returns one of the surface type constants defined above.:::return
OGLSurfaceData#getTextureTarget():::If this surface is backed by a texture object, returns the target for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB):::return->getNativeOps->getTextureTarget
OGLSurfaceData#getTextureID():::If this surface is backed by a texture object, returns the texture ID for that texture:::return->getNativeOps->getTextureID
OGLSurfaceData#getNativeResource(int):::Returns native resource of specified resType associated with this surface:::if->return->getTextureID->return
OGLSurfaceData#canRenderLCDText(SunGraphics2D):::For now, we can only render LCD text if:   - the fragment shader extension is available, and   - the source color is opaque, and   - blending is SrcOverNoEa or disabled   - and the destination is opaque  Eventually, we could enhance the native OGL text rendering code and remove the above restrictions, but that would require significantly more code just to support a few uncommon cases.:::return->graphicsConfig->isCapPresent->getTransparency->canHandleComposite
OGLSurfaceData#dispose(long, OGLGraphicsConfig):::Disposes the native resources associated with the given OGLSurfaceData (referenced by the pData parameter):::rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->setScratchSurface->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
OGLSurfaceData#isTexNonPow2Available():::Returns true if OpenGL textures can have non-power-of-two dimensions when using the basic GL_TEXTURE_2D target.:::return->graphicsConfig->isCapPresent
OGLSurfaceData#isTexRectAvailable():::Returns true if OpenGL textures can have non-power-of-two dimensions when using the GL_TEXTURE_RECTANGLE_ARB target (only available when the GL_ARB_texture_rectangle extension is present).:::return->graphicsConfig->isCapPresent
OGLSurfaceData#isOnScreen():::Returns true if the surface is an on-screen window surface or a FBO texture attached to an on-screen CALayer:::return->getType
OGLUtilities#isQueueFlusherThread():::Returns true if the current thread is the OGL QueueFlusher thread.:::return->OGLRenderQueue->isQueueFlusherThread
OGLUtilities#invokeWithOGLContextCurrent(Graphics, Runnable):::Invokes the given Runnable on the OGL QueueFlusher thread with the OpenGL context corresponding to the given Graphics object made current:::rq->OGLRenderQueue->getInstance->rq->lock->try->if->if->return->sData->if->return->OGLContext->validateContext->rq->flushAndInvokeNow->OGLContext->invalidateCurrentContext->catch->finally->rq->unlock->return
OGLUtilities#invokeWithOGLSharedContextCurrent(GraphicsConfiguration, Runnable):::Invokes the given Runnable on the OGL QueueFlusher thread with the "shared" OpenGL context (corresponding to the given GraphicsConfiguration object) made current:::if->return->rq->OGLRenderQueue->getInstance->rq->lock->try->OGLContext->setScratchSurface->rq->flushAndInvokeNow->OGLContext->invalidateCurrentContext->catch->finally->rq->unlock->return
OGLUtilities#getOGLViewport(Graphics, int, int):::Returns the Rectangle describing the OpenGL viewport on the Java 2D surface associated with the given Graphics object and component width and height:::if->return->sg2d->sData->x0->y0->surfaceBounds->sData->getBounds->x1->y1->return->new->Rectangle
OGLUtilities#getOGLScissorBox(Graphics):::Returns the Rectangle describing the OpenGL scissor box on the Java 2D surface associated with the given Graphics object:::if->return->sg2d->sData->r->sg2d->getCompClip->if->r->isRectangular->return->x0->r->getLoX->y0->r->getLoY->w->r->getWidth->h->r->getHeight->surfaceBounds->sData->getBounds->x1->y1->return->new->Rectangle
OGLUtilities#getOGLSurfaceIdentifier(Graphics):::Returns an Object identifier for the Java 2D surface associated with the given Graphics object:::if->return->return
OGLUtilities#getOGLSurfaceType(Graphics):::Returns one of the OGL-specific surface type constants (defined in this class), which describes the surface associated with the given Graphics object.:::if->return->sData->if->return->return->getType
OGLUtilities#getOGLTextureType(Graphics):::Returns the OpenGL texture target constant (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB) for the surface associated with the given Graphics object:::if->return->sData->if->return->return->getTextureTarget
WGLGraphicsConfig#isCapPresent(int):::Returns true if the provided capability bit is present for this config:::return->oglCaps->getCaps
WGLGraphicsConfig#createSurfaceData(WComponentPeer, int):::Creates a new SurfaceData that will be associated with the given WComponentPeer.:::sd->WGLSurfaceData->createData->if->GDIWindowSurfaceData->createData->return
WGLGraphicsConfig#assertOperationSupported(Component, int, BufferCapabilities):::Checks that the requested configuration is natively supported; if not, an AWTException is thrown.:::if->throw->new->AWTException->configCaps->getBufferCapabilities->if->configCaps->isPageFlipping->throw->new->AWTException->if->caps->getFlipContents->throw->new->AWTException
WGLGraphicsConfig#createBackBuffer(WComponentPeer):::Creates a WGL-based backbuffer for the given peer and returns the image wrapper.:::target->peer->getTarget->w->Math->target->getWidth->max->h->Math->target->getHeight->max->return->new->SunVolatileImage
WGLGraphicsConfig#flip(WComponentPeer, Component, VolatileImage, int, int, int, int, BufferCapabilities.FlipContents):::Performs the native WGL flip operation for the given target Component.:::if->vsm->SurfaceManager->getManager->sd->vsm->getPrimarySurfaceData->if->vsd->bbsd->vsd->getFlipSurface->bbg->new->SunGraphics2D->try->bbg->drawImage->catch->finally->bbg->dispose->else->g->peer->getGraphics->try->g->drawImage->catch->finally->g->dispose->return->else->if->return->OGLSurfaceData->peer->getData->swapBuffers->if->g->backBuffer->getGraphics->try->g->target->getBackground->setColor->g->backBuffer->getWidth->backBuffer->getHeight->fillRect->catch->finally->g->dispose
WGLSurfaceData#createData(WComponentPeer):::Creates a SurfaceData object representing the primary (front) buffer of an on-screen Window.:::if->peer->isAccelCapable->SunToolkit->peer->getTarget->isContainingTopLevelOpaque->return->gc->getGC->return->new->WGLWindowSurfaceData
WGLSurfaceData#createData(WComponentPeer, Image, int):::Creates a SurfaceData object representing the back buffer of a double-buffered on-screen Window.:::if->peer->isAccelCapable->SunToolkit->peer->getTarget->isContainingTopLevelOpaque->return->gc->getGC->r->peer->getBounds->if->return->peer->getColorModel->new->WGLOffScreenSurfaceData->else->return->peer->getColorModel->new->WGLVSyncOffScreenSurfaceData
WGLSurfaceData#createData(WGLGraphicsConfig, int, int, ColorModel, Image, int):::Creates a SurfaceData object representing an off-screen buffer (either a Pbuffer or Texture).:::return->new->WGLOffScreenSurfaceData
WGLSurfaceData.WGLWindowSurfaceData#getDestination():::Returns destination Component associated with this SurfaceData.:::return->peer->getTarget
WGLSurfaceData.WGLOffScreenSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
WGLSurfaceData#updateWindowAccelImpl(long, WComponentPeer, int, int):::Updates the layered window with the contents of the surface.:::
WGLVolatileSurfaceManager#initAcceleratedSurface():::Create a FBO-based SurfaceData object (or init the backbuffer of an existing window if this is a double buffered GraphicsConfig).:::sData->comp->vImg->getComponent->acc->AWTAccessor->getComponentAccessor->peer->acc->getPeer->try->createVSynced->forceback->if->booleanValue->if->caps->peer->getBackBufferCaps->if->ebc->if->ebc->getVSync->ebc->getFlipContents->if->WGLSurfaceData->createData->else->gc->vImg->getGraphicsConfig->cm->gc->vImg->getTransparency->getColorModel->type->vImg->getForcedAccelSurfaceType->if->if->WGLSurfaceData->createData->else->WGLSurfaceData->vImg->getWidth->vImg->getHeight->createData->catch->finally->return
