sun.java2d.opengl.OGLBlitLoops#register()->void::: blit loops register
sun.java2d.opengl.OGLBlitLoops#Blit(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, int, boolean)->void::: blit loops  blit
sun.java2d.opengl.OGLBlitLoops#IsoBlit(SurfaceData, SurfaceData, BufferedImage, BufferedImageOp, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, boolean)->void:::Note: The srcImg and biop parameters are only used when invoked from the OGLBufImgOps.renderImageWithOp() method; in all other cases, this method can be called with null values for those two parameters, and they will be effectively ignored.
sun.java2d.opengl.OGLSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: surface to surface blit  blit
sun.java2d.opengl.OGLSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)->void::: surface to surface scale  scale
sun.java2d.opengl.OGLSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)->void::: surface to surface transform  transform
sun.java2d.opengl.OGLRTTSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: surface to surface blit  blit
sun.java2d.opengl.OGLRTTSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)->void::: surface to surface scale  scale
sun.java2d.opengl.OGLRTTSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)->void::: surface to surface transform  transform
sun.java2d.opengl.OGLSurfaceToSwBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: surface to sw blit  blit
sun.java2d.opengl.OGLSwToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: sw to surface blit  blit
sun.java2d.opengl.OGLSwToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)->void::: sw to surface scale  scale
sun.java2d.opengl.OGLSwToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)->void::: sw to surface transform  transform
sun.java2d.opengl.OGLSwToTextureBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: sw to texture blit  blit
sun.java2d.opengl.OGLTextureToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: texture to surface blit  blit
sun.java2d.opengl.OGLTextureToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)->void::: texture to surface scale  scale
sun.java2d.opengl.OGLTextureToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)->void::: texture to surface transform  transform
sun.java2d.opengl.OGLGeneralBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: general blit  blit
sun.java2d.opengl.OGLGeneralTransformedBlit#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)->void::: general transformed blit  transform
sun.java2d.opengl.OGLAnyCompositeBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)->void::: any composite blit  blit
sun.java2d.opengl.OGLBufImgOps#renderImageWithOp(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)->boolean:::This method is called from OGLDrawImage.transformImage() only
sun.java2d.opengl.OGLContext#setScratchSurface(OGLGraphicsConfig)->void:::Convenience method that delegates to setScratchSurface() below.
sun.java2d.opengl.OGLContext#setScratchSurface(long)->void:::Makes the given GraphicsConfig's context current to its associated "scratch surface"
sun.java2d.opengl.OGLContext#invalidateCurrentContext()->void:::Invalidates the currentContext field to ensure that we properly revalidate the OGLContext (make it current, etc.) next time through the validate() method
sun.java2d.opengl.OGLContext#getRenderQueue()->RenderQueue::: context get render queue
sun.java2d.opengl.OGLContext#getOGLIdString()->String:::Returns a string representing adapter id (vendor, renderer, version)
sun.java2d.opengl.OGLContext#saveState()->void::: context save state
sun.java2d.opengl.OGLContext#restoreState()->void::: context restore state
sun.java2d.opengl.OGLContext.OGLContextCaps#toString()->String::: context caps to string
sun.java2d.opengl.OGLDrawImage#renderImageXform(SunGraphics2D, Image, AffineTransform, int, int, int, int, int, Color)->void::: draw image render image xform
sun.java2d.opengl.OGLDrawImage#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)->void::: draw image transform image
sun.java2d.opengl.OGLGraphicsConfig#getContext()->OGLContext::: graphics config get context
sun.java2d.opengl.OGLGraphicsConfig#getNativeConfigInfo()->long::: graphics config get native config info
sun.java2d.opengl.OGLGraphicsConfig#isCapPresent(int)->boolean::: graphics config is cap present
sun.java2d.opengl.OGLGraphicsConfig#createManagedSurface(int, int, int)->SurfaceData::: graphics config create managed surface
sun.java2d.opengl.OGLMaskBlit#register()->void::: mask blit register
sun.java2d.opengl.OGLMaskBlit#validateContext(SurfaceData, Composite, Region)->void::: mask blit validate context
sun.java2d.opengl.OGLMaskFill#register()->void::: mask fill register
sun.java2d.opengl.OGLMaskFill#maskFill(int, int, int, int, int, int, int, byte[])->void::: mask fill mask fill
sun.java2d.opengl.OGLMaskFill#validateContext(SunGraphics2D, Composite, int)->void::: mask fill validate context
sun.java2d.opengl.OGLPaints#isValid(SunGraphics2D)->boolean:::Attempts to locate an implementation corresponding to the paint state of the provided SunGraphics2D object
sun.java2d.opengl.OGLPaints#isPaintValid(SunGraphics2D)->boolean:::Returns true if this implementation is able to accelerate the Paint object associated with, and under the conditions of, the provided SunGraphics2D instance; otherwise returns false.
sun.java2d.opengl.OGLRenderer#validateContext(SunGraphics2D)->void::: renderer validate context
sun.java2d.opengl.OGLRenderer#validateContextAA(SunGraphics2D)->void::: renderer validate context a
sun.java2d.opengl.OGLRenderer#copyArea(SunGraphics2D, int, int, int, int, int, int)->void::: renderer copy area
sun.java2d.opengl.OGLRenderer#drawPoly(int[], int[], int, boolean, int, int)->void::: renderer draw poly
sun.java2d.opengl.OGLRenderer#traceWrap()->OGLRenderer::: renderer trace wrap
sun.java2d.opengl.OGLRenderQueue#getInstance()->OGLRenderQueue:::Returns the single OGLRenderQueue instance
sun.java2d.opengl.OGLRenderQueue#sync()->void:::Flushes the single OGLRenderQueue instance synchronously
sun.java2d.opengl.OGLRenderQueue#disposeGraphicsConfig(long)->void:::Disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread.
sun.java2d.opengl.OGLRenderQueue#isQueueFlusherThread()->boolean:::Returns true if the current thread is the OGL QueueFlusher thread.
sun.java2d.opengl.OGLRenderQueue#flushNow()->void::: render queue flush now
sun.java2d.opengl.OGLRenderQueue#flushAndInvokeNow(Runnable)->void::: render queue flush and invoke now
sun.java2d.opengl.OGLSurfaceData#initTexture(long, boolean, boolean, boolean, int, int)->boolean::: surface data init texture
sun.java2d.opengl.OGLSurfaceData#initFBObject(long, boolean, boolean, boolean, int, int)->boolean::: surface data init object
sun.java2d.opengl.OGLSurfaceData#initFlipBackbuffer(long)->boolean::: surface data init flip backbuffer
sun.java2d.opengl.OGLSurfaceData#makeProxyFor(SurfaceData)->SurfaceDataProxy::: surface data make proxy for
sun.java2d.opengl.OGLSurfaceData#initSurface(int, int)->void:::Initializes the appropriate OpenGL offscreen surface based on the value of the type parameter
sun.java2d.opengl.OGLSurfaceData#getContext()->OGLContext:::Returns the OGLContext for the GraphicsConfig associated with this surface.
sun.java2d.opengl.OGLSurfaceData#getOGLGraphicsConfig()->OGLGraphicsConfig:::Returns the OGLGraphicsConfig associated with this surface.
sun.java2d.opengl.OGLSurfaceData#getType()->int:::Returns one of the surface type constants defined above.
sun.java2d.opengl.OGLSurfaceData#getTextureTarget()->int:::If this surface is backed by a texture object, returns the target for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB)
sun.java2d.opengl.OGLSurfaceData#getTextureID()->int:::If this surface is backed by a texture object, returns the texture ID for that texture
sun.java2d.opengl.OGLSurfaceData#getNativeResource(int)->long:::Returns native resource of specified resType associated with this surface
sun.java2d.opengl.OGLSurfaceData#getRaster(int, int, int, int)->Raster::: surface data get raster
sun.java2d.opengl.OGLSurfaceData#canRenderLCDText(SunGraphics2D)->boolean:::For now, we can only render LCD text if:   - the fragment shader extension is available, and   - the source color is opaque, and   - blending is SrcOverNoEa or disabled   - and the destination is opaque  Eventually, we could enhance the native OGL text rendering code and remove the above restrictions, but that would require significantly more code just to support a few uncommon cases.
sun.java2d.opengl.OGLSurfaceData#validatePipe(SunGraphics2D)->void::: surface data validate pipe
sun.java2d.opengl.OGLSurfaceData#getMaskFill(SunGraphics2D)->MaskFill::: surface data get mask fill
sun.java2d.opengl.OGLSurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int)->boolean::: surface data copy area
sun.java2d.opengl.OGLSurfaceData#flush()->void::: surface data flush
sun.java2d.opengl.OGLSurfaceData#dispose(long, OGLGraphicsConfig)->void:::Disposes the native resources associated with the given OGLSurfaceData (referenced by the pData parameter)
sun.java2d.opengl.OGLSurfaceData#swapBuffers(long)->void::: surface data swap buffers
sun.java2d.opengl.OGLSurfaceData#isTexNonPow2Available()->boolean:::Returns true if OpenGL textures can have non-power-of-two dimensions when using the basic GL_TEXTURE_2D target.
sun.java2d.opengl.OGLSurfaceData#isTexRectAvailable()->boolean:::Returns true if OpenGL textures can have non-power-of-two dimensions when using the GL_TEXTURE_RECTANGLE_ARB target (only available when the GL_ARB_texture_rectangle extension is present).
sun.java2d.opengl.OGLSurfaceData#getNativeBounds()->Rectangle::: surface data get native bounds
sun.java2d.opengl.OGLSurfaceData#isOnScreen()->boolean:::Returns true if the surface is an on-screen window surface or a FBO texture attached to an on-screen CALayer
sun.java2d.opengl.OGLSurfaceDataProxy#createProxy(SurfaceData, OGLGraphicsConfig)->SurfaceDataProxy::: surface data proxy create proxy
sun.java2d.opengl.OGLSurfaceDataProxy#validateSurfaceData(SurfaceData, SurfaceData, int, int)->SurfaceData::: surface data proxy validate surface data
sun.java2d.opengl.OGLSurfaceDataProxy#isSupportedOperation(SurfaceData, int, CompositeType, Color)->boolean::: surface data proxy is supported operation
sun.java2d.opengl.OGLTextRenderer#drawGlyphList(int, boolean, boolean, boolean, int, float, float, long[], float[])->void::: text renderer draw glyph list
sun.java2d.opengl.OGLTextRenderer#validateContext(SunGraphics2D, Composite)->void::: text renderer validate context
sun.java2d.opengl.OGLTextRenderer#traceWrap()->OGLTextRenderer::: text renderer trace wrap
sun.java2d.opengl.OGLUtilities#isQueueFlusherThread()->boolean:::Returns true if the current thread is the OGL QueueFlusher thread.
sun.java2d.opengl.OGLUtilities#invokeWithOGLContextCurrent(Graphics, Runnable)->boolean:::Invokes the given Runnable on the OGL QueueFlusher thread with the OpenGL context corresponding to the given Graphics object made current
sun.java2d.opengl.OGLUtilities#invokeWithOGLSharedContextCurrent(GraphicsConfiguration, Runnable)->boolean:::Invokes the given Runnable on the OGL QueueFlusher thread with the "shared" OpenGL context (corresponding to the given GraphicsConfiguration object) made current
sun.java2d.opengl.OGLUtilities#getOGLViewport(Graphics, int, int)->Rectangle:::Returns the Rectangle describing the OpenGL viewport on the Java 2D surface associated with the given Graphics object and component width and height
sun.java2d.opengl.OGLUtilities#getOGLScissorBox(Graphics)->Rectangle:::Returns the Rectangle describing the OpenGL scissor box on the Java 2D surface associated with the given Graphics object
sun.java2d.opengl.OGLUtilities#getOGLSurfaceIdentifier(Graphics)->Object:::Returns an Object identifier for the Java 2D surface associated with the given Graphics object
sun.java2d.opengl.OGLUtilities#getOGLSurfaceType(Graphics)->int:::Returns one of the OGL-specific surface type constants (defined in this class), which describes the surface associated with the given Graphics object.
sun.java2d.opengl.OGLUtilities#getOGLTextureType(Graphics)->int:::Returns the OpenGL texture target constant (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB) for the surface associated with the given Graphics object
sun.java2d.opengl.WGLGraphicsConfig#getDefaultPixFmt(int)->int::: graphics config get default pix fmt
sun.java2d.opengl.WGLGraphicsConfig#getProxyKey()->Object::: graphics config get proxy key
sun.java2d.opengl.WGLGraphicsConfig#createManagedSurface(int, int, int)->SurfaceData::: graphics config create managed surface
sun.java2d.opengl.WGLGraphicsConfig#getConfig(Win32GraphicsDevice, int)->WGLGraphicsConfig::: graphics config get config
sun.java2d.opengl.WGLGraphicsConfig#isWGLAvailable()->boolean::: graphics config is available
sun.java2d.opengl.WGLGraphicsConfig#isCapPresent(int)->boolean:::Returns true if the provided capability bit is present for this config
sun.java2d.opengl.WGLGraphicsConfig#getNativeConfigInfo()->long::: graphics config get native config info
sun.java2d.opengl.WGLGraphicsConfig#getContext()->OGLContext::: graphics config get context
sun.java2d.opengl.WGLGraphicsConfig#displayChanged()->void::: graphics config display changed
sun.java2d.opengl.WGLGraphicsConfig#getColorModel(int)->ColorModel::: graphics config get color model
sun.java2d.opengl.WGLGraphicsConfig#toString()->String::: graphics config to string
sun.java2d.opengl.WGLGraphicsConfig#createSurfaceData(WComponentPeer, int)->SurfaceData:::Creates a new SurfaceData that will be associated with the given WComponentPeer.
sun.java2d.opengl.WGLGraphicsConfig#assertOperationSupported(Component, int, BufferCapabilities)->void:::Checks that the requested configuration is natively supported; if not, an AWTException is thrown.
sun.java2d.opengl.WGLGraphicsConfig#createBackBuffer(WComponentPeer)->VolatileImage:::Creates a WGL-based backbuffer for the given peer and returns the image wrapper.
sun.java2d.opengl.WGLGraphicsConfig#flip(WComponentPeer, Component, VolatileImage, int, int, int, int, BufferCapabilities.FlipContents)->void:::Performs the native WGL flip operation for the given target Component.
sun.java2d.opengl.WGLGraphicsConfig#getBufferCapabilities()->BufferCapabilities::: graphics config get buffer capabilities
sun.java2d.opengl.WGLGraphicsConfig#getImageCapabilities()->ImageCapabilities::: graphics config get image capabilities
sun.java2d.opengl.WGLGraphicsConfig#createCompatibleVolatileImage(int, int, int, int)->VolatileImage::: graphics config create compatible volatile image
sun.java2d.opengl.WGLGraphicsConfig#getContextCapabilities()->ContextCapabilities::: graphics config get context capabilities
sun.java2d.opengl.WGLSurfaceData#getDefaultScaleX()->double::: surface data get default scale x
sun.java2d.opengl.WGLSurfaceData#getDefaultScaleY()->double::: surface data get default scale y
sun.java2d.opengl.WGLSurfaceData#getDeviceConfiguration()->GraphicsConfiguration::: surface data get device configuration
sun.java2d.opengl.WGLSurfaceData#createData(WComponentPeer)->WGLWindowSurfaceData:::Creates a SurfaceData object representing the primary (front) buffer of an on-screen Window.
sun.java2d.opengl.WGLSurfaceData#createData(WComponentPeer, Image, int)->WGLOffScreenSurfaceData:::Creates a SurfaceData object representing the back buffer of a double-buffered on-screen Window.
sun.java2d.opengl.WGLSurfaceData#createData(WGLGraphicsConfig, int, int, ColorModel, Image, int)->WGLOffScreenSurfaceData:::Creates a SurfaceData object representing an off-screen buffer (either a Pbuffer or Texture).
sun.java2d.opengl.WGLSurfaceData#getGC(WComponentPeer)->WGLGraphicsConfig::: surface data get c
sun.java2d.opengl.WGLSurfaceData.WGLWindowSurfaceData#getReplacement()->SurfaceData::: window surface data get replacement
sun.java2d.opengl.WGLSurfaceData.WGLWindowSurfaceData#getBounds()->Rectangle::: window surface data get bounds
sun.java2d.opengl.WGLSurfaceData.WGLWindowSurfaceData#getDestination()->Object:::Returns destination Component associated with this SurfaceData.
sun.java2d.opengl.WGLSurfaceData.WGLVSyncOffScreenSurfaceData#getFlipSurface()->SurfaceData::: sync off screen surface data get flip surface
sun.java2d.opengl.WGLSurfaceData.WGLVSyncOffScreenSurfaceData#flush()->void::: sync off screen surface data flush
sun.java2d.opengl.WGLSurfaceData.WGLOffScreenSurfaceData#getReplacement()->SurfaceData::: off screen surface data get replacement
sun.java2d.opengl.WGLSurfaceData.WGLOffScreenSurfaceData#getBounds()->Rectangle::: off screen surface data get bounds
sun.java2d.opengl.WGLSurfaceData.WGLOffScreenSurfaceData#getDestination()->Object:::Returns destination Image associated with this SurfaceData.
sun.java2d.opengl.WGLSurfaceData#updateWindowAccelImpl(long, WComponentPeer, int, int)->boolean:::Updates the layered window with the contents of the surface.
sun.java2d.opengl.WGLVolatileSurfaceManager#isAccelerationEnabled()->boolean::: volatile surface manager is acceleration enabled
sun.java2d.opengl.WGLVolatileSurfaceManager#initAcceleratedSurface()->SurfaceData:::Create a FBO-based SurfaceData object (or init the backbuffer of an existing window if this is a double buffered GraphicsConfig).
sun.java2d.opengl.WGLVolatileSurfaceManager#isConfigValid(GraphicsConfiguration)->boolean::: volatile surface manager is config valid
sun.java2d.opengl.WGLVolatileSurfaceManager#initContents()->void::: volatile surface manager init contents
