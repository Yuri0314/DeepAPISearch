BitOpNodesTest#isBitCountIntrinsicSupported(Architecture):::Determines if the current VM context supports intrinsics for the bitCount methods in Integer and Long.:::if->amd64->return->amd64->getFeatures->contains->else->return
BitOpNodesTest#isNumberLeadingZerosIntrinsicSupported(Architecture):::Determines if the current VM context supports intrinsics for the numberOfLeadingZeros methods in Integer and Long.:::if->amd64->return->amd64->getFeatures->contains->amd64->getFlags->contains->else->return
BitOpNodesTest#isNumberTrailingZerosIntrinsicSupported(Architecture):::Determines if the current VM context supports intrinsics for the numberOfTrailingZeros methods in Integer and Long.:::if->amd64->return->amd64->getFeatures->contains->amd64->getFlags->contains->else->return
EdgesTest#test0():::Checks that there are no checkcasts in the compiled version of Edges#getNode(Node, long[], int).:::getMethod->inputs->getOffsets->testMethod
EdgesTest#test1():::Checks that there are no checkcasts in the compiled version of Edges#getNodeList(Node, long[], int).:::getMethod->inputs->getOffsets->testMethod
EdgesTest#test2():::Checks that there are no checkcasts in the compiled version of Edges#setNode(Node, int, Node).:::getMethod->testMethod
InstanceOfTest#testRemoveIntermediateMaterialization():::This test exists to show the kind of pattern that is be optimizable by removeIntermediateMaterialization() in IfNode:::list->Arrays->asList->profile->test->profile->test->profile->test
MonitorTest#test3():::Tests monitor operations on PartialEscapePhase virtual objects.:::new->StringArr->test
MonitorTest#test4():::Tests recursive locking of objects which should be biasable.:::src->toCharArray->new->Chars->dst->new->Chars->test
MonitorTest#test5():::Tests recursive locking of objects which do not appear to be biasable.:::src->toCharArray->dst->new->charArr->test
MonitorTest#test6():::Extends #test4() with contention.:::src->toCharArray->new->Chars->dst->new->Chars->n->Runtime->getRuntime->availableProcessors->testN
MonitorTest#test7():::Extends #test5() with contention.:::src->toCharArray->dst->new->charArr->n->Math->Runtime->getRuntime->availableProcessors->min->testN
MonitorTest#test8():::Reproduces issue reported in https://github.com/graalvm/graal-core/issues/201:::test->test->test
NewInstanceTest#newRegression(boolean):::Tests that an earlier bug does not occur:::result->if->arr->new->B->for->i->else->new->B->return
ReplacementsParseTest.TestObjectSubstitutions#stringize(Object):::Tests conditional intrinsification of a static method.:::if->obj->getClass->return->asNonNullString->else->return->stringize
ReplacementsParseTest.TestObjectSubstitutions#stringizeId(TestObject):::Tests conditional intrinsification of a non-static method.:::if->getClass->return->asNonNullString->else->return->outOfLinePartialIntrinsification
ReplacementsParseTest.TestObjectSubstitutions#copyFirst(byte[], byte[], boolean):::An valid intrinsic as the frame state associated with the merge should prevent the frame states associated with the array stores from being associated with subsequent deoptimizing nodes.:::return->copyFirstBody
ReplacementsParseTest.TestObjectSubstitutions#copyFirstL2R(byte[], byte[]):::An invalid intrinsic as the frame state associated with the array assignment can leak out to subsequent deoptimizing nodes.:::return->copyFirstL2RBody
ReplacementsParseTest.TestObjectSubstitutions#identity(String):::Tests that non-capturing lambdas are folded away.:::return->apply
ReplacementsParseTest#test1():::Ensure that calling the original method from the substitution binds correctly.:::test
ReplacementsParseTest#test2():::Ensure that calling the substitution method binds to the original method properly.:::test
ReplacementsParseTest#testNonVoidIntrinsicWithCall():::This tests the case where an intrinsic ends with a runtime call but returns some kind of value:::testGraph
ReplacementsParseTest#testNonVoidIntrinsicWithOptimizedSplit():::This is similar to #testNonVoidIntrinsicWithCall() but has a merge after the call which would normally capture the FrameState but in this case we force the merge to be optimized away.:::testGraph
ReplacementsTest#getSystemClassLoaderBytecodeProvider():::Gets a ClassfileBytecodeProvider that enables snippets and intrinsics to be loaded from the system class path (instead of from the JVMCI class path or Graal module).:::d->getReplacements->metaAccess->d->getProviders->getMetaAccess->bytecodeProvider->ClassLoader->getSystemClassLoader->new->ClassfileBytecodeProvider->return
