org.graalvm.compiler.lir.amd64.AMD64AddressValue#getBase()->AllocatableValue::: d64 address value get base
org.graalvm.compiler.lir.amd64.AMD64AddressValue#getIndex()->AllocatableValue::: d64 address value get index
org.graalvm.compiler.lir.amd64.AMD64AddressValue#forEachComponent(LIRInstruction, OperandMode, InstructionValueProcedure)->CompositeValue::: d64 address value for each component
org.graalvm.compiler.lir.amd64.AMD64AddressValue#visitEachComponent(LIRInstruction, OperandMode, InstructionValueConsumer)->void::: d64 address value visit each component
org.graalvm.compiler.lir.amd64.AMD64AddressValue#withKind(ValueKind)->AMD64AddressValue::: d64 address value with kind
org.graalvm.compiler.lir.amd64.AMD64AddressValue#toAddress()->AMD64Address::: d64 address value to address
org.graalvm.compiler.lir.amd64.AMD64AddressValue#toString()->String::: d64 address value to string
org.graalvm.compiler.lir.amd64.AMD64AddressValue#isValidImplicitNullCheckFor(Value, int)->boolean::: d64 address value is valid implicit null check for
org.graalvm.compiler.lir.amd64.AMD64AddressValue#equals(Object)->boolean::: d64 address value equals
org.graalvm.compiler.lir.amd64.AMD64AddressValue#hashCode()->int::: d64 address value hash code
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitCountLeadingZeros(Value)->Value::: d64 arithmetic generator tool emit count leading zeros
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitCountTrailingZeros(Value)->Value::: d64 arithmetic generator tool emit count trailing zeros
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitLogicalAndNot(Value, Value)->Value::: d64 arithmetic generator tool emit logical and not
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitLowestSetIsolatedBit(Value)->Value::: d64 arithmetic generator tool emit lowest set isolated bit
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitGetMaskUpToLowestSetBit(Value)->Value::: d64 arithmetic generator tool emit get mask up to lowest set bit
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitResetLowestSetBit(Value)->Value::: d64 arithmetic generator tool emit reset lowest set bit
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitRound(Value, RoundingMode)->Value::: d64 arithmetic generator tool emit round
org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool#emitCompareOp(AMD64Kind, Variable, Value)->void::: d64 arithmetic generator tool emit compare op
org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 array compare to op emit code
org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 array equals op emit code
org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 array index of op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.TwoOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: two op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.CommutativeTwoOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: commutative two op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.CommutativeTwoOp#getOpcode()->AMD64RMOp::: commutative two op get opcode
org.graalvm.compiler.lir.amd64.AMD64Binary.ConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: const op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.DataTwoOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: data two op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.MemoryTwoOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory two op emit code
org.graalvm.compiler.lir.amd64.AMD64Binary.MemoryTwoOp#verify()->void::: memory two op verify
org.graalvm.compiler.lir.amd64.AMD64Binary.MemoryTwoOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory two op make null check for
org.graalvm.compiler.lir.amd64.AMD64Binary.MemoryTwoOp#getOpcode()->AMD64RMOp::: memory two op get opcode
org.graalvm.compiler.lir.amd64.AMD64Binary.RMIOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.Op#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.ConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: const op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.ConstOp#shouldAnnotate()->boolean::: const op should annotate
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.ConstOp#getOpcode()->AMD64MIOp::: const op get opcode
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.VMConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: const op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.VMConstOp#shouldAnnotate()->boolean::: const op should annotate
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.DataOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: data op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryRMOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryRMOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory op make null check for
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryMROp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryMROp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory op make null check for
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory const op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryConstOp#shouldAnnotate()->boolean::: memory const op should annotate
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryConstOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory const op make null check for
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryConstOp#getOpcode()->AMD64MIOp::: memory const op get opcode
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryVMConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory const op emit code
org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryVMConstOp#shouldAnnotate()->boolean::: memory const op should annotate
org.graalvm.compiler.lir.amd64.AMD64BlockEndOp#emitCode(CompilationResultBuilder)->void::: d64 block end op emit code
org.graalvm.compiler.lir.amd64.AMD64BlockEndOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 block end op emit code
org.graalvm.compiler.lir.amd64.AMD64BreakpointOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 breakpoint op emit code
org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 byte swap op emit code
org.graalvm.compiler.lir.amd64.AMD64Call.CallOp#destroysCallerSavedRegisters()->boolean::: call op destroys caller saved registers
org.graalvm.compiler.lir.amd64.AMD64Call.DirectCallOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: direct call op emit code
org.graalvm.compiler.lir.amd64.AMD64Call.DirectCallOp#emitCall(CompilationResultBuilder, AMD64MacroAssembler)->int::: direct call op emit call
org.graalvm.compiler.lir.amd64.AMD64Call.IndirectCallOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: indirect call op emit code
org.graalvm.compiler.lir.amd64.AMD64Call.IndirectCallOp#verify()->void::: indirect call op verify
org.graalvm.compiler.lir.amd64.AMD64Call.ForeignCallOp#destroysCallerSavedRegisters()->boolean::: foreign call op destroys caller saved registers
org.graalvm.compiler.lir.amd64.AMD64Call.DirectNearForeignCallOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: direct near foreign call op emit code
org.graalvm.compiler.lir.amd64.AMD64Call.DirectFarForeignCallOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: direct far foreign call op emit code
org.graalvm.compiler.lir.amd64.AMD64Call#directCall(CompilationResultBuilder, AMD64MacroAssembler, InvokeTarget, Register, boolean, LIRFrameState)->int::: d64 call direct call
org.graalvm.compiler.lir.amd64.AMD64Call#emitAlignmentForDirectCall(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 call emit alignment for direct call
org.graalvm.compiler.lir.amd64.AMD64Call#directJmp(CompilationResultBuilder, AMD64MacroAssembler, InvokeTarget)->int::: d64 call direct jmp
org.graalvm.compiler.lir.amd64.AMD64Call#directJmp(CompilationResultBuilder, AMD64MacroAssembler, InvokeTarget, Register)->int::: d64 call direct jmp
org.graalvm.compiler.lir.amd64.AMD64Call#directConditionalJmp(CompilationResultBuilder, AMD64MacroAssembler, InvokeTarget, ConditionFlag)->void::: d64 call direct conditional jmp
org.graalvm.compiler.lir.amd64.AMD64Call#indirectCall(CompilationResultBuilder, AMD64MacroAssembler, Register, InvokeTarget, LIRFrameState)->int::: d64 call indirect call
org.graalvm.compiler.lir.amd64.AMD64CCall#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 call emit code
org.graalvm.compiler.lir.amd64.AMD64CCall#destroysCallerSavedRegisters()->boolean::: d64 call destroys caller saved registers
org.graalvm.compiler.lir.amd64.AMD64ClearRegisterOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 clear register op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: return op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: branch op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp#jcc(AMD64MacroAssembler, boolean, LabelRef)->void::: branch op jcc
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp#jcc(AMD64MacroAssembler, boolean, LabelRef)->void::: float branch op jcc
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: strategy switch op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp.SwitchClosure#emitComparison(Constant)->void::: switch closure emit comparison
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp.SwitchClosure#conditionalJump(int, Condition, Label)->void::: switch closure conditional jump
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: table switch op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: hash table switch op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: cond set op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: float cond set op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: cond move op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: float cond move op emit code
org.graalvm.compiler.lir.amd64.AMD64ControlFlow#trueOnUnordered(Condition)->boolean::: d64 control flow true on unordered
org.graalvm.compiler.lir.amd64.AMD64FrameMap#totalFrameSize()->int::: d64 frame map total frame size
org.graalvm.compiler.lir.amd64.AMD64FrameMap#currentFrameSize()->int::: d64 frame map current frame size
org.graalvm.compiler.lir.amd64.AMD64FrameMap#alignFrameSize(int)->int::: d64 frame map align frame size
org.graalvm.compiler.lir.amd64.AMD64FrameMap#offsetForStackSlot(StackSlot)->int::: d64 frame map offset for stack slot
org.graalvm.compiler.lir.amd64.AMD64FrameMap#allocateRBPSpillSlot()->StackSlot:::For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot runtime for walking/inspecting frames of such methods.
org.graalvm.compiler.lir.amd64.AMD64FrameMap#freeRBPSpillSlot()->void::: d64 frame map free spill slot
org.graalvm.compiler.lir.amd64.AMD64FrameMap#allocateDeoptimizationRescueSlot()->StackSlot::: d64 frame map allocate deoptimization rescue slot
org.graalvm.compiler.lir.amd64.AMD64FrameMapBuilder#allocateRBPSpillSlot()->StackSlot:::For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot runtime for walking/inspecting frames of such methods.
org.graalvm.compiler.lir.amd64.AMD64FrameMapBuilder#freeRBPSpillSlot()->void::: d64 frame map builder free spill slot
org.graalvm.compiler.lir.amd64.AMD64FrameMapBuilder#allocateDeoptimizationRescueSlot()->StackSlot::: d64 frame map builder allocate deoptimization rescue slot
org.graalvm.compiler.lir.amd64.AMD64HotSpotHelper#registersToValues(Register[])->Value[]::: d64 hot spot helper registers to values
org.graalvm.compiler.lir.amd64.AMD64HotSpotHelper#recordExternalAddress(CompilationResultBuilder, ArrayDataPointerConstant)->AMD64Address::: d64 hot spot helper record external address
org.graalvm.compiler.lir.amd64.AMD64HotSpotHelper#pointerConstant(int, int[])->ArrayDataPointerConstant::: d64 hot spot helper pointer constant
org.graalvm.compiler.lir.amd64.AMD64LFenceOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 fence op emit code
org.graalvm.compiler.lir.amd64.AMD64LIRInstruction#emitCode(CompilationResultBuilder)->void::: d64 instruction emit code
org.graalvm.compiler.lir.amd64.AMD64LIRInstruction#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 instruction emit code
org.graalvm.compiler.lir.amd64.AMD64MathCosOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math cos op emit code
org.graalvm.compiler.lir.amd64.AMD64MathExpOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math exp op emit code
org.graalvm.compiler.lir.amd64.AMD64MathIntrinsicBinaryOp#emitLIRWrapper(LIRGenerator, Value, Value)->Variable::: d64 math intrinsic binary op emit wrapper
org.graalvm.compiler.lir.amd64.AMD64MathIntrinsicUnaryOp#emitLIRWrapper(LIRGeneratorTool, Value)->Variable::: d64 math intrinsic unary op emit wrapper
org.graalvm.compiler.lir.amd64.AMD64MathLog10Op#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math log10 op emit code
org.graalvm.compiler.lir.amd64.AMD64MathLogOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math log op emit code
org.graalvm.compiler.lir.amd64.AMD64MathPowOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math pow op emit code
org.graalvm.compiler.lir.amd64.AMD64MathSinOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math sin op emit code
org.graalvm.compiler.lir.amd64.AMD64MathTanOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 math tan op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.MoveToRegOp#getInput()->AllocatableValue::: move to reg op get input
org.graalvm.compiler.lir.amd64.AMD64Move.MoveToRegOp#getResult()->AllocatableValue::: move to reg op get result
org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromRegOp#getInput()->AllocatableValue::: move from reg op get input
org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromRegOp#getResult()->AllocatableValue::: move from reg op get result
org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromConstOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: move from const op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromConstOp#getConstant()->Constant::: move from const op get constant
org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromConstOp#getResult()->AllocatableValue::: move from const op get result
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64StackMove#getInput()->AllocatableValue::: d64 stack move get input
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64StackMove#getResult()->AllocatableValue::: d64 stack move get result
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64StackMove#getScratchRegister()->Register::: d64 stack move get scratch register
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64StackMove#getBackupSlot()->AllocatableValue::: d64 stack move get backup slot
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64StackMove#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 stack move emit code
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64MultiStackMove#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 multi stack move emit code
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64PushPopStackMove#getInput()->AllocatableValue::: d64 push pop stack move get input
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64PushPopStackMove#getResult()->AllocatableValue::: d64 push pop stack move get result
org.graalvm.compiler.lir.amd64.AMD64Move.AMD64PushPopStackMove#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 push pop stack move emit code
org.graalvm.compiler.lir.amd64.AMD64Move.LeaOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: lea op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.LeaDataOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: lea data op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: stack lea op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: membar op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.NullCheckOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: null check op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.NullCheckOp#getCheckedValue()->Value::: null check op get checked value
org.graalvm.compiler.lir.amd64.AMD64Move.NullCheckOp#getState()->LIRFrameState::: null check op get state
org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: compare and swap op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.AtomicReadAndAddOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: atomic read and add op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.AtomicReadAndWriteOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: atomic read and write op emit code
org.graalvm.compiler.lir.amd64.AMD64Move#move(CompilationResultBuilder, AMD64MacroAssembler, Value, Value)->void::: d64 move move
org.graalvm.compiler.lir.amd64.AMD64Move#move(AMD64Kind, CompilationResultBuilder, AMD64MacroAssembler, Value, Value)->void::: d64 move move
org.graalvm.compiler.lir.amd64.AMD64Move#reg2stack(AMD64Kind, CompilationResultBuilder, AMD64MacroAssembler, Value, Register)->void::: d64 move reg2stack
org.graalvm.compiler.lir.amd64.AMD64Move#stack2reg(AMD64Kind, CompilationResultBuilder, AMD64MacroAssembler, Register, Value)->void::: d64 move stack2reg
org.graalvm.compiler.lir.amd64.AMD64Move#const2reg(CompilationResultBuilder, AMD64MacroAssembler, Register, JavaConstant, AMD64Kind)->void::: d64 move const2reg
org.graalvm.compiler.lir.amd64.AMD64Move#canMoveConst2Stack(JavaConstant)->boolean::: d64 move can move const2 stack
org.graalvm.compiler.lir.amd64.AMD64Move#const2stack(CompilationResultBuilder, AMD64MacroAssembler, Value, JavaConstant)->void::: d64 move const2stack
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#hasBase(OptionValues, CompressEncoding)->boolean::: pointer compression op has base
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#getInput()->Value::: pointer compression op get input
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#getResult()->AllocatableValue::: pointer compression op get result
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#getResultRegister()->Register::: pointer compression op get result register
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#getBaseRegister(CompilationResultBuilder)->Register::: pointer compression op get base register
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#getShift()->int::: pointer compression op get shift
org.graalvm.compiler.lir.amd64.AMD64Move.PointerCompressionOp#move(LIRKind, CompilationResultBuilder, AMD64MacroAssembler)->void::: pointer compression op move
org.graalvm.compiler.lir.amd64.AMD64Move.CompressPointerOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: compress pointer op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.UncompressPointerOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: uncompress pointer op emit code
org.graalvm.compiler.lir.amd64.AMD64Move.UncompressPointerOp#emitUncompressCode(AMD64MacroAssembler, Register, int, Register, boolean)->void::: uncompress pointer op emit uncompress code
org.graalvm.compiler.lir.amd64.AMD64Move.ConvertNullToZeroOp#emitConversion(Register, Register, Register, AMD64MacroAssembler)->void::: convert null to zero op emit conversion
org.graalvm.compiler.lir.amd64.AMD64Move.ConvertZeroToNullOp#emitConversion(Register, Register, Register, AMD64MacroAssembler)->void::: convert zero to null op emit conversion
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#getHighResult()->AllocatableValue::: d64 mul div op get high result
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#getLowResult()->AllocatableValue::: d64 mul div op get low result
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#getQuotient()->AllocatableValue::: d64 mul div op get quotient
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#getRemainder()->AllocatableValue::: d64 mul div op get remainder
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 mul div op emit code
org.graalvm.compiler.lir.amd64.AMD64MulDivOp#verify()->void::: d64 mul div op verify
org.graalvm.compiler.lir.amd64.AMD64PauseOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 pause op emit code
org.graalvm.compiler.lir.amd64.AMD64PrefetchOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 prefetch op emit code
org.graalvm.compiler.lir.amd64.AMD64ReadTimestampCounter#getHighResult()->AllocatableValue::: d64 read timestamp counter get high result
org.graalvm.compiler.lir.amd64.AMD64ReadTimestampCounter#getLowResult()->AllocatableValue::: d64 read timestamp counter get low result
org.graalvm.compiler.lir.amd64.AMD64ReadTimestampCounter#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 read timestamp counter emit code
org.graalvm.compiler.lir.amd64.AMD64RestoreRegistersOp#getSavedRegisters()->Register[]::: d64 restore registers op get saved registers
org.graalvm.compiler.lir.amd64.AMD64RestoreRegistersOp#restoreRegister(CompilationResultBuilder, AMD64MacroAssembler, Register, StackSlot)->void::: d64 restore registers op restore register
org.graalvm.compiler.lir.amd64.AMD64RestoreRegistersOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 restore registers op emit code
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#saveRegister(CompilationResultBuilder, AMD64MacroAssembler, StackSlot, Register)->void::: d64 save registers op save register
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 save registers op emit code
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#getSlots()->AllocatableValue[]::: d64 save registers op get slots
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#supportsRemove()->boolean::: d64 save registers op supports remove
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#remove(EconomicSet)->int::: d64 save registers op remove
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#prune(EconomicSet, Register[])->int::: d64 save registers op prune
org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp#getMap(FrameMap)->RegisterSaveLayout::: d64 save registers op get map
org.graalvm.compiler.lir.amd64.AMD64ShiftOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 shift op emit code
org.graalvm.compiler.lir.amd64.AMD64ShiftOp#verify()->void::: d64 shift op verify
org.graalvm.compiler.lir.amd64.AMD64SignExtendOp#getHighResult()->AllocatableValue::: d64 sign extend op get high result
org.graalvm.compiler.lir.amd64.AMD64SignExtendOp#getLowResult()->AllocatableValue::: d64 sign extend op get low result
org.graalvm.compiler.lir.amd64.AMD64SignExtendOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 sign extend op emit code
org.graalvm.compiler.lir.amd64.AMD64SignExtendOp#verify()->void::: d64 sign extend op verify
org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 string latin1 inflate op emit code
org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 string f16 compress op emit code
org.graalvm.compiler.lir.amd64.AMD64Ternary.ThreeOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: three op emit code
org.graalvm.compiler.lir.amd64.AMD64Unary.MOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.amd64.AMD64Unary.RMOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.amd64.AMD64Unary.MROp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: op emit code
org.graalvm.compiler.lir.amd64.AMD64Unary.MemoryOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: memory op emit code
org.graalvm.compiler.lir.amd64.AMD64Unary.MemoryOp#makeNullCheckFor(Value, LIRFrameState, int)->boolean::: memory op make null check for
org.graalvm.compiler.lir.amd64.AMD64VZeroUpper#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 zero upper emit code
org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 zap registers op emit code
org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp#supportsRemove()->boolean::: d64 zap registers op supports remove
org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp#remove(EconomicSet)->int::: d64 zap registers op remove
org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp#getMap(FrameMap)->RegisterSaveLayout::: d64 zap registers op get map
org.graalvm.compiler.lir.amd64.AMD64ZapStackOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 zap stack op emit code
org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp#emitCode(CompilationResultBuilder, AMD64MacroAssembler)->void::: d64 zero memory op emit code
