SSALinearScan#createMoveResolver()::: linear scan create move resolver:::moveResolver->new->SSAMoveResolver->return
SSALinearScan#createLifetimeAnalysisPhase()::: linear scan create lifetime analysis phase:::return->new->SSALinearScanLifetimeAnalysisPhase
SSALinearScan#createResolveDataFlowPhase()::: linear scan create resolve data flow phase:::return->new->SSALinearScanResolveDataFlowPhase
SSALinearScan#createSpillMoveEliminationPhase()::: linear scan create spill move elimination phase:::return->new->SSALinearScanEliminateSpillMovePhase
SSALinearScan#beforeSpillMoveElimination()::: linear scan before spill move elimination:::try->s1->debug->scope->foreach->sortedBlocks->if->toBlock->getPredecessorCount->SSAUtil->getLIR->removePhiIn->catch->finally
SSALinearScanEliminateSpillMovePhase#firstInstructionOfInterest()::: linear scan eliminate spill move phase first instruction of interest:::return
SSALinearScanEliminateSpillMovePhase#canEliminateSpillMove(AbstractBlockBase, MoveOp)::: linear scan eliminate spill move phase can eliminate spill move:::if->super->canEliminateSpillMove->curInterval->allocator->move->getResult->intervalFor->if->isPhiResolutionMove->return->return
SSALinearScanEliminateSpillMovePhase#isPhiResolutionMove(AbstractBlockBase, MoveOp, Interval)::: linear scan eliminate spill move phase is phi resolution move:::if->toInterval->isSplitParent->return->if->toInterval->from->return->if->block->getSuccessorCount->return->op->allocator->toInterval->from->instructionForId->if->return->intStartBlock->allocator->toInterval->from->blockForId->if->block->getSuccessors->equals->return->debug->allocator->getDebug->try->indent->debug->indent->debug->log->catch->finally->return
SSALinearScanLifetimeAnalysisPhase#addRegisterHint(LIRInstruction, Value, OperandMode, EnumSet, boolean)::: linear scan lifetime analysis phase add register hint:::super->addRegisterHint->if->label->if->label->isPhiIn->return->to->allocator->getOrCreateInterval->lir->allocator->getLIR->block->allocator->label->id->blockForId->idx->SSAUtil->indexOfValue->blockLiveIn->allocator->getBlockData->selectedPredecessor->selectedSource->foreach->block->getPredecessors->if->pred->getRelativeFrequency->selectedPredecessor->getRelativeFrequency->jump->SSAUtil->phiOut->sourceValue->jump->getOutgoingValue->if->LinearScan->isVariableOrRegister->blockLiveIn->getOperandNumber->get->if->from->allocator->getOrCreateInterval->setHint->setHint
SSALinearScanLifetimeAnalysisPhase#setHint(DebugContext, LIRInstruction, Interval, Interval)::: linear scan lifetime analysis phase set hint:::currentHint->target->locationHint->if->currentHint->from->target->from->target->setLocationHint->if->debug->isLogEnabled->debug->op->id->log
SSALinearScanLifetimeAnalysisPhase#registerPriorityOfOutputOperand(LIRInstruction)::: linear scan lifetime analysis phase register priority of output operand:::if->label->if->label->isPhiIn->return->return->super->registerPriorityOfOutputOperand
SSALinearScanResolveDataFlowPhase#resolveCollectMappings(AbstractBlockBase, AbstractBlockBase, AbstractBlockBase, MoveResolver)::: linear scan resolve data flow phase resolve collect mappings:::super->resolveCollectMappings->if->toBlock->getPredecessorCount->toBlockFirstInstructionId->allocator->getFirstLirInstructionId->fromBlockLastInstructionId->allocator->getLastLirInstructionId->phiOutBlock->instructions->allocator->getLIR->getLIRforBlock->phiOutIdx->SSAUtil->allocator->getLIR->phiOutIndex->phiOutId->instructions->get->id->visitor->new->PhiValueVisitor->SSAUtil->allocator->getLIR->forEachPhiValuePair->SSAUtil->allocator->getLIR->removePhiOut
SSAMoveResolver#checkEmpty()::: move resolver check empty:::for->i->return->super->checkEmpty
SSAMoveResolver#checkMultipleReads()::: move resolver check multiple reads:::
SSAMoveResolver#verifyStackSlotMapping()::: move resolver verify stack slot mapping:::
SSAMoveResolver#areMultipleReadsAllowed()::: move resolver are multiple reads allowed:::return
SSAMoveResolver#mightBeBlocked(Value)::: move resolver might be blocked:::if->super->mightBeBlocked->return->if->isStackSlotValue->return->return
SSAMoveResolver#getStackArrayIndex(Value)::: move resolver get stack array index:::if->isStackSlot->return->asStackSlot->getStackArrayIndex->if->isVirtualStackSlot->return->asVirtualStackSlot->getStackArrayIndex->throw->GraalError->shouldNotReachHere
SSAMoveResolver#getStackArrayIndex(StackSlot)::: move resolver get stack array index:::stackIdx->if->stackSlot->isInCallerFrame->else->offset->stackSlot->getRawOffset->return
SSAMoveResolver#getStackArrayIndex(VirtualStackSlot)::: move resolver get stack array index:::return->virtualStackSlot->getId
SSAMoveResolver#setValueBlocked(Value, int)::: move resolver set value blocked:::if->isStackSlotValue->stackIdx->getStackArrayIndex->if->return->if->Arrays->copyOf->else->super->setValueBlocked
SSAMoveResolver#valueBlocked(Value)::: move resolver value blocked:::if->isStackSlotValue->stackIdx->getStackArrayIndex->if->return->if->return->return->return->super->valueBlocked
SSAMoveResolver#createMove(AllocatableValue, AllocatableValue, AllocatableValue, AllocatableValue)::: move resolver create move:::if->isStackSlotValue->isStackSlotValue->return->getAllocator->getSpillMoveFactory->createStackMove->return->super->createMove
SSAMoveResolver#breakCycle(int)::: move resolver break cycle:::if->super->breakCycle->return->stackSpillCandidate->fromInterval->getMappingFrom->spillSlot->getAllocator->getFrameMapBuilder->fromInterval->kind->allocateSpillSlot->spillInterval
