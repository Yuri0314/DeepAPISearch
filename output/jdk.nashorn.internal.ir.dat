jdk.nashorn.internal.ir.AccessNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.AccessNode#toString(StringBuilder, boolean)->void::: access node to string
jdk.nashorn.internal.ir.AccessNode#getProperty()->String:::Get the property name
jdk.nashorn.internal.ir.AccessNode#setType(Type)->AccessNode::: access node set type
jdk.nashorn.internal.ir.AccessNode#setProgramPoint(int)->AccessNode::: access node set program point
jdk.nashorn.internal.ir.AccessNode#setIsFunction()->AccessNode::: access node set is function
jdk.nashorn.internal.ir.AccessNode#setIsSuper()->AccessNode::: access node set is super
jdk.nashorn.internal.ir.Assignment#getAssignmentDest()->D:::Get assignment destination
jdk.nashorn.internal.ir.Assignment#getAssignmentSource()->Expression:::Get the assignment source
jdk.nashorn.internal.ir.Assignment#setAssignmentDest(D)->Node:::Set assignment destination node.
jdk.nashorn.internal.ir.BaseNode#getBase()->Expression:::Get the base node for this access
jdk.nashorn.internal.ir.BaseNode#isFunction()->boolean::: base node is function
jdk.nashorn.internal.ir.BaseNode#getType()->Type::: base node get type
jdk.nashorn.internal.ir.BaseNode#getProgramPoint()->int::: base node get program point
jdk.nashorn.internal.ir.BaseNode#getMostOptimisticType()->Type::: base node get most optimistic type
jdk.nashorn.internal.ir.BaseNode#getMostPessimisticType()->Type::: base node get most pessimistic type
jdk.nashorn.internal.ir.BaseNode#canBeOptimistic()->boolean::: base node can be optimistic
jdk.nashorn.internal.ir.BaseNode#isIndex()->boolean:::Return true if this node represents an index operation normally represented as IndexNode.
jdk.nashorn.internal.ir.BaseNode#setIsFunction()->BaseNode:::Mark this node as being the callee operand of a CallNode.
jdk.nashorn.internal.ir.BaseNode#isSuper()->boolean::: base node is super
jdk.nashorn.internal.ir.BaseNode#setIsSuper()->BaseNode:::Mark this node as being a SuperProperty access.
jdk.nashorn.internal.ir.BinaryNode#isComparison()->boolean:::Returns true if the node is a comparison operation (either equality, inequality, or relational).
jdk.nashorn.internal.ir.BinaryNode#isRelational()->boolean:::Returns true if the node is a relational operation (less than (or equals), greater than (or equals)).
jdk.nashorn.internal.ir.BinaryNode#isLogical()->boolean:::Returns true if the node is a logical operation.
jdk.nashorn.internal.ir.BinaryNode#isLogical(TokenType)->boolean:::Returns true if the token type represents a logical operation.
jdk.nashorn.internal.ir.BinaryNode#getWidestOperandType()->Type:::Return the widest possible operand type for this operation.
jdk.nashorn.internal.ir.BinaryNode#getWidestOperationType()->Type::: binary node get widest operation type
jdk.nashorn.internal.ir.BinaryNode#isAssignment()->boolean:::Check if this node is an assignment
jdk.nashorn.internal.ir.BinaryNode#isSelfModifying()->boolean::: binary node is self modifying
jdk.nashorn.internal.ir.BinaryNode#getAssignmentDest()->Expression::: binary node get assignment dest
jdk.nashorn.internal.ir.BinaryNode#setAssignmentDest(Expression)->BinaryNode::: binary node set assignment dest
jdk.nashorn.internal.ir.BinaryNode#getAssignmentSource()->Expression::: binary node get assignment source
jdk.nashorn.internal.ir.BinaryNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.BinaryNode#isLocal()->boolean::: binary node is local
jdk.nashorn.internal.ir.BinaryNode#isAlwaysFalse()->boolean::: binary node is always false
jdk.nashorn.internal.ir.BinaryNode#isAlwaysTrue()->boolean::: binary node is always true
jdk.nashorn.internal.ir.BinaryNode#toString(StringBuilder, boolean)->void::: binary node to string
jdk.nashorn.internal.ir.BinaryNode#lhs()->Expression:::Get the left hand side expression for this node
jdk.nashorn.internal.ir.BinaryNode#rhs()->Expression:::Get the right hand side expression for this node
jdk.nashorn.internal.ir.BinaryNode#setLHS(Expression)->BinaryNode:::Set the left hand side expression for this node
jdk.nashorn.internal.ir.BinaryNode#setRHS(Expression)->BinaryNode:::Set the right hand side expression for this node
jdk.nashorn.internal.ir.BinaryNode#setOperands(Expression, Expression)->BinaryNode:::Set both the left and the right hand side expression for this node
jdk.nashorn.internal.ir.BinaryNode#getProgramPoint()->int::: binary node get program point
jdk.nashorn.internal.ir.BinaryNode#canBeOptimistic()->boolean::: binary node can be optimistic
jdk.nashorn.internal.ir.BinaryNode#setProgramPoint(int)->BinaryNode::: binary node set program point
jdk.nashorn.internal.ir.BinaryNode#getMostOptimisticType()->Type::: binary node get most optimistic type
jdk.nashorn.internal.ir.BinaryNode#getMostPessimisticType()->Type::: binary node get most pessimistic type
jdk.nashorn.internal.ir.BinaryNode#isOptimisticUndecidedType()->boolean:::Returns true if the node has the optimistic type of the node is not yet decided
jdk.nashorn.internal.ir.BinaryNode#getType()->Type::: binary node get type
jdk.nashorn.internal.ir.BinaryNode#decideType()->BinaryNode:::If the node is a node representing an add operation and has #isOptimisticUndecidedType() optimistic undecided type, decides its type
jdk.nashorn.internal.ir.BinaryNode#setType(Type)->BinaryNode::: binary node set type
jdk.nashorn.internal.ir.Block#isGlobalScope()->boolean:::Is this block the outermost eager global scope - i.e
jdk.nashorn.internal.ir.Block#hasSymbols()->boolean:::Returns true if this block defines any symbols.
jdk.nashorn.internal.ir.Block#replaceSymbols(LexicalContext, Map)->Block:::Replaces symbols defined in this block with different symbols
jdk.nashorn.internal.ir.Block#copyWithNewSymbols()->Block:::Returns a copy of this block with a shallow copy of the symbol table.
jdk.nashorn.internal.ir.Block#ensureUniqueLabels(LexicalContext)->Node::: block ensure unique labels
jdk.nashorn.internal.ir.Block#accept(LexicalContext, NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.Block#getSymbols()->List:::Get a copy of the list for all the symbols defined in this block
jdk.nashorn.internal.ir.Block#getExistingSymbol(String)->Symbol:::Retrieves an existing symbol defined in the current block.
jdk.nashorn.internal.ir.Block#isCatchBlock()->boolean:::Test if this block represents a catch block in a try statement
jdk.nashorn.internal.ir.Block#toString(StringBuilder, boolean)->void::: block to string
jdk.nashorn.internal.ir.Block#printSymbols(PrintWriter)->boolean:::Print symbols in block in alphabetical order, sorted on name Used for debugging, see the --print-symbols flag
jdk.nashorn.internal.ir.Block#setIsTerminal(LexicalContext, boolean)->Block:::Tag block as terminal or non terminal
jdk.nashorn.internal.ir.Block#getFlags()->int::: block get flags
jdk.nashorn.internal.ir.Block#isTerminal()->boolean:::Is this a terminal block, i.e
jdk.nashorn.internal.ir.Block#getEntryLabel()->Label:::Get the entry label for this block
jdk.nashorn.internal.ir.Block#getBreakLabel()->Label::: block get break label
jdk.nashorn.internal.ir.Block#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->Block::: block set local variable conversion
jdk.nashorn.internal.ir.Block#getLocalVariableConversion()->LocalVariableConversion::: block get local variable conversion
jdk.nashorn.internal.ir.Block#getStatements()->List:::Get the list of statements in this block
jdk.nashorn.internal.ir.Block#getStatementCount()->int:::Returns the number of statements in the block.
jdk.nashorn.internal.ir.Block#getFirstStatementLineNumber()->int:::Returns the line number of the first statement in the block.
jdk.nashorn.internal.ir.Block#getLastStatement()->Statement:::Returns the last statement in the block.
jdk.nashorn.internal.ir.Block#setStatements(LexicalContext, List)->Block:::Reset the statement list for this block
jdk.nashorn.internal.ir.Block#putSymbol(Symbol)->void:::Add or overwrite an existing symbol in the block
jdk.nashorn.internal.ir.Block#needsScope()->boolean:::Check whether scope is necessary for this Block
jdk.nashorn.internal.ir.Block#isSynthetic()->boolean:::Check whether this block is synthetic or not.
jdk.nashorn.internal.ir.Block#setFlags(LexicalContext, int)->Block::: block set flags
jdk.nashorn.internal.ir.Block#clearFlag(LexicalContext, int)->Block::: block clear flag
jdk.nashorn.internal.ir.Block#setFlag(LexicalContext, int)->Block::: block set flag
jdk.nashorn.internal.ir.Block#getFlag(int)->boolean::: block get flag
jdk.nashorn.internal.ir.Block#setNeedsScope(LexicalContext)->Block:::Set the needs scope flag.
jdk.nashorn.internal.ir.Block#nextSlot()->int:::Computationally determine the next slot for this block, indexed from 0
jdk.nashorn.internal.ir.Block#providesScopeCreator()->boolean:::Determine whether this block needs to provide its scope object creator for use by its child nodes
jdk.nashorn.internal.ir.Block#isBreakableWithoutLabel()->boolean::: block is breakable without label
jdk.nashorn.internal.ir.Block#getLabels()->List::: block get labels
jdk.nashorn.internal.ir.Block#accept(NodeVisitor)->Node::: block accept
jdk.nashorn.internal.ir.Block#isFunctionBody()->boolean:::Checks if this is a function body.
jdk.nashorn.internal.ir.Block#isParameterBlock()->boolean:::Checks if this is a parameter block.
jdk.nashorn.internal.ir.Block#isSwitchBlock()->boolean:::Checks whether this is a switch block.
jdk.nashorn.internal.ir.BlockLexicalContext#push(T)->T::: block lexical context push
jdk.nashorn.internal.ir.BlockLexicalContext#popStatements()->List:::Get the statement list from the stack, possibly filtered
jdk.nashorn.internal.ir.BlockLexicalContext#afterSetStatements(Block)->Block:::Override this method to perform some additional processing on the block after its statements have been set
jdk.nashorn.internal.ir.BlockLexicalContext#pop(T)->T::: block lexical context pop
jdk.nashorn.internal.ir.BlockLexicalContext#appendStatement(Statement)->void:::Append a statement to the block being generated
jdk.nashorn.internal.ir.BlockLexicalContext#prependStatement(Statement)->Node:::Prepend a statement to the block being generated
jdk.nashorn.internal.ir.BlockLexicalContext#prependStatements(List)->void:::Prepend a list of statement to the block being generated
jdk.nashorn.internal.ir.BlockLexicalContext#getLastStatement()->Statement:::Get the last statement that was emitted into a block
jdk.nashorn.internal.ir.BlockStatement#createReplacement(Statement, List)->BlockStatement:::Use this method to create a block statement meant to replace a single statement.
jdk.nashorn.internal.ir.BlockStatement#createReplacement(Statement, int, List)->BlockStatement:::Use this method to create a block statement meant to replace a single statement.
jdk.nashorn.internal.ir.BlockStatement#isTerminal()->boolean::: block statement is terminal
jdk.nashorn.internal.ir.BlockStatement#isSynthetic()->boolean:::Tells if this is a synthetic block statement or not.
jdk.nashorn.internal.ir.BlockStatement#accept(NodeVisitor)->Node::: block statement accept
jdk.nashorn.internal.ir.BlockStatement#toString(StringBuilder, boolean)->void::: block statement to string
jdk.nashorn.internal.ir.BlockStatement#getBlock()->Block:::Return the block to be executed
jdk.nashorn.internal.ir.BlockStatement#setBlock(Block)->BlockStatement:::Reset the block to be executed
jdk.nashorn.internal.ir.BreakableNode#ensureUniqueLabels(LexicalContext)->Node:::Ensure that any labels in this breakable node are unique so that new jumps won't go to old parts of the tree
jdk.nashorn.internal.ir.BreakableNode#isBreakableWithoutLabel()->boolean:::Check whether this can be broken out from without using a label, e.g
jdk.nashorn.internal.ir.BreakableNode#getBreakLabel()->Label:::Return the break label, i.e
jdk.nashorn.internal.ir.BreakableStatement#isBreakableWithoutLabel()->boolean:::Check whether this can be broken out from without using a label, e.g
jdk.nashorn.internal.ir.BreakableStatement#getBreakLabel()->Label:::Return the break label, i.e
jdk.nashorn.internal.ir.BreakableStatement#getLabels()->List:::Return the labels associated with this node
jdk.nashorn.internal.ir.BreakableStatement#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: breakable statement set local variable conversion
jdk.nashorn.internal.ir.BreakableStatement#getLocalVariableConversion()->LocalVariableConversion::: breakable statement get local variable conversion
jdk.nashorn.internal.ir.BreakableStatement#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)->JoinPredecessor::: breakable statement set local variable conversion changed
jdk.nashorn.internal.ir.BreakNode#accept(NodeVisitor)->Node::: break node accept
jdk.nashorn.internal.ir.BreakNode#createNewJumpStatement(LocalVariableConversion)->JumpStatement::: break node create new jump statement
jdk.nashorn.internal.ir.BreakNode#getStatementName()->String::: break node get statement name
jdk.nashorn.internal.ir.BreakNode#getTarget(LexicalContext)->BreakableNode::: break node get target
jdk.nashorn.internal.ir.BreakNode#getTargetLabel(BreakableNode)->Label::: break node get target label
jdk.nashorn.internal.ir.CallNode.EvalArgs#getArgs()->List:::Return the code that is to be eval:ed by this eval function
jdk.nashorn.internal.ir.CallNode.EvalArgs#getLocation()->String:::Get the human readable location for this eval call
jdk.nashorn.internal.ir.CallNode#getLineNumber()->int:::Returns the line number.
jdk.nashorn.internal.ir.CallNode#getType()->Type::: call node get type
jdk.nashorn.internal.ir.CallNode#setType(Type)->Optimistic::: call node set type
jdk.nashorn.internal.ir.CallNode#accept(LexicalContext, NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.CallNode#toString(StringBuilder, boolean)->void::: call node to string
jdk.nashorn.internal.ir.CallNode#getArgs()->List:::Get the arguments for the call
jdk.nashorn.internal.ir.CallNode#setArgs(List)->CallNode:::Reset the arguments for the call
jdk.nashorn.internal.ir.CallNode#getEvalArgs()->EvalArgs:::If this call is an eval call, get its EvalArgs structure
jdk.nashorn.internal.ir.CallNode#setEvalArgs(EvalArgs)->CallNode:::Set the EvalArgs structure for this call, if it has been determined it is an eval
jdk.nashorn.internal.ir.CallNode#isEval()->boolean:::Check if this call is a call to eval
jdk.nashorn.internal.ir.CallNode#isApplyToCall()->boolean:::Is this an apply call that we optimistically should try to turn into a call instead
jdk.nashorn.internal.ir.CallNode#setIsApplyToCall()->CallNode:::Flag this call node as one that tries to call call instead of apply
jdk.nashorn.internal.ir.CallNode#getFunction()->Expression:::Return the function expression that this call invokes
jdk.nashorn.internal.ir.CallNode#setFunction(Expression)->CallNode:::Reset the function expression that this call invokes
jdk.nashorn.internal.ir.CallNode#isNew()->boolean:::Check if this call is a new operation
jdk.nashorn.internal.ir.CallNode#getProgramPoint()->int::: call node get program point
jdk.nashorn.internal.ir.CallNode#setProgramPoint(int)->CallNode::: call node set program point
jdk.nashorn.internal.ir.CallNode#getMostOptimisticType()->Type::: call node get most optimistic type
jdk.nashorn.internal.ir.CallNode#getMostPessimisticType()->Type::: call node get most pessimistic type
jdk.nashorn.internal.ir.CallNode#canBeOptimistic()->boolean::: call node can be optimistic
jdk.nashorn.internal.ir.CaseNode#isTerminal()->boolean:::Is this a terminal case node, i.e
jdk.nashorn.internal.ir.CaseNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.CaseNode#toString(StringBuilder, boolean)->void::: case node to string
jdk.nashorn.internal.ir.CaseNode#getBody()->Block:::Get the body for this case node
jdk.nashorn.internal.ir.CaseNode#getEntry()->Label:::Get the entry label for this case node
jdk.nashorn.internal.ir.CaseNode#getTest()->Expression:::Get the test expression for this case node
jdk.nashorn.internal.ir.CaseNode#setTest(Expression)->CaseNode:::Reset the test expression for this case node
jdk.nashorn.internal.ir.CaseNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: case node set local variable conversion
jdk.nashorn.internal.ir.CaseNode#getLocalVariableConversion()->LocalVariableConversion::: case node get local variable conversion
jdk.nashorn.internal.ir.CaseNode#getLabels()->List::: case node get labels
jdk.nashorn.internal.ir.CatchNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.CatchNode#isTerminal()->boolean::: catch node is terminal
jdk.nashorn.internal.ir.CatchNode#toString(StringBuilder, boolean)->void::: catch node to string
jdk.nashorn.internal.ir.CatchNode#getException()->Expression:::Get the binding pattern representing the exception thrown
jdk.nashorn.internal.ir.CatchNode#getExceptionIdentifier()->IdentNode:::Get the identifier representing the exception thrown
jdk.nashorn.internal.ir.CatchNode#getExceptionCondition()->Expression:::Get the exception condition for this catch block
jdk.nashorn.internal.ir.CatchNode#setExceptionCondition(Expression)->CatchNode:::Reset the exception condition for this catch block
jdk.nashorn.internal.ir.CatchNode#getBody()->Block:::Get the body for this catch block
jdk.nashorn.internal.ir.CatchNode#setException(Expression)->CatchNode:::Resets the exception of a catch block
jdk.nashorn.internal.ir.CatchNode#isSyntheticRethrow()->boolean:::Is this catch block a non-JavaScript constructor, for example created as part of the rethrow mechanism of a finally block in Lower? Then we just pass the exception on and need not unwrap whatever is in the ECMAException object catch symbol
jdk.nashorn.internal.ir.ClassNode#getIdent()->IdentNode:::Class identifier
jdk.nashorn.internal.ir.ClassNode#getClassHeritage()->Expression:::The expression of the extends clause
jdk.nashorn.internal.ir.ClassNode#getConstructor()->PropertyNode:::Get the constructor method definition.
jdk.nashorn.internal.ir.ClassNode#getClassElements()->List:::Get method definitions except the constructor.
jdk.nashorn.internal.ir.ClassNode#isStatement()->boolean:::Returns if this class was a statement or an expression
jdk.nashorn.internal.ir.ClassNode#getLineNumber()->int:::Returns the line number.
jdk.nashorn.internal.ir.ClassNode#getType()->Type::: class node get type
jdk.nashorn.internal.ir.ClassNode#accept(NodeVisitor)->Node::: class node accept
jdk.nashorn.internal.ir.ClassNode#toString(StringBuilder, boolean)->void::: class node to string
jdk.nashorn.internal.ir.CompileUnitHolder#getCompileUnit()->CompileUnit:::Return the compile unit held by this instance
jdk.nashorn.internal.ir.ContinueNode#accept(NodeVisitor)->Node::: continue node accept
jdk.nashorn.internal.ir.ContinueNode#createNewJumpStatement(LocalVariableConversion)->JumpStatement::: continue node create new jump statement
jdk.nashorn.internal.ir.ContinueNode#getStatementName()->String::: continue node get statement name
jdk.nashorn.internal.ir.ContinueNode#getTarget(LexicalContext)->BreakableNode::: continue node get target
jdk.nashorn.internal.ir.ContinueNode#getTargetLabel(BreakableNode)->Label::: continue node get target label
jdk.nashorn.internal.ir.DebuggerNode#accept(NodeVisitor)->Node::: debugger node accept
jdk.nashorn.internal.ir.DebuggerNode#toString(StringBuilder, boolean)->void::: debugger node to string
jdk.nashorn.internal.ir.EmptyNode#accept(NodeVisitor)->Node::: empty node accept
jdk.nashorn.internal.ir.EmptyNode#toString(StringBuilder, boolean)->void::: empty node to string
jdk.nashorn.internal.ir.ErrorNode#getType()->Type::: error node get type
jdk.nashorn.internal.ir.ErrorNode#accept(NodeVisitor)->Node::: error node accept
jdk.nashorn.internal.ir.ErrorNode#toString(StringBuilder, boolean)->void::: error node to string
jdk.nashorn.internal.ir.Expression#getType()->Type:::Returns the type of the expression.
jdk.nashorn.internal.ir.Expression#isLocal()->boolean:::Returns true if this expression depends exclusively on state that is constant or local to the currently running function and thus inaccessible to other functions
jdk.nashorn.internal.ir.Expression#isSelfModifying()->boolean:::Is this a self modifying assignment?
jdk.nashorn.internal.ir.Expression#getWidestOperationType()->Type:::Returns widest operation type of this operation.
jdk.nashorn.internal.ir.Expression#isOptimistic()->boolean:::Returns true if the type of this expression is narrower than its widest operation type (thus, it is optimistically typed).
jdk.nashorn.internal.ir.Expression#optimisticTypeToString(StringBuilder)->void::: expression optimistic type to string
jdk.nashorn.internal.ir.Expression#optimisticTypeToString(StringBuilder, boolean)->void::: expression optimistic type to string
jdk.nashorn.internal.ir.Expression#isAlwaysFalse()->boolean:::Returns true if the runtime value of this expression is always false when converted to boolean as per ECMAScript ToBoolean conversion
jdk.nashorn.internal.ir.Expression#isAlwaysTrue()->boolean:::Returns true if the runtime value of this expression is always true when converted to boolean as per ECMAScript ToBoolean conversion
jdk.nashorn.internal.ir.Expression#isAlwaysFalse(Expression)->boolean:::Returns true if the expression is not null and #isAlwaysFalse().
jdk.nashorn.internal.ir.Expression#isAlwaysTrue(Expression)->boolean:::Returns true if the expression is null or #isAlwaysTrue()
jdk.nashorn.internal.ir.ExpressionList#getExpressions()->List:::Get the list of expressions.
jdk.nashorn.internal.ir.ExpressionList#accept(NodeVisitor)->Node::: expression list accept
jdk.nashorn.internal.ir.ExpressionList#getType()->Type::: expression list get type
jdk.nashorn.internal.ir.ExpressionList#toString(StringBuilder, boolean)->void::: expression list to string
jdk.nashorn.internal.ir.ExpressionStatement#accept(NodeVisitor)->Node::: expression statement accept
jdk.nashorn.internal.ir.ExpressionStatement#toString(StringBuilder, boolean)->void::: expression statement to string
jdk.nashorn.internal.ir.ExpressionStatement#getExpression()->Expression:::Return the expression to be executed
jdk.nashorn.internal.ir.ExpressionStatement#destructuringDeclarationType()->TokenType:::Return declaration type if this expression statement is a destructuring declaration
jdk.nashorn.internal.ir.ExpressionStatement#setExpression(Expression)->ExpressionStatement:::Reset the expression to be executed
jdk.nashorn.internal.ir.Flags#getFlags()->int:::Get all flags of a LexicalContextNode
jdk.nashorn.internal.ir.Flags#getFlag(int)->boolean:::Check if a flag is set in a lexical context node
jdk.nashorn.internal.ir.Flags#clearFlag(LexicalContext, int)->T:::Clear a flag of a LexicalContextNode
jdk.nashorn.internal.ir.Flags#setFlag(LexicalContext, int)->T:::Set a flag of a LexicalContextNode
jdk.nashorn.internal.ir.Flags#setFlags(LexicalContext, int)->T:::Set all flags of a LexicalContextNode, overwriting previous flags
jdk.nashorn.internal.ir.ForNode#ensureUniqueLabels(LexicalContext)->Node::: for node ensure unique labels
jdk.nashorn.internal.ir.ForNode#accept(LexicalContext, NodeVisitor)->Node::: for node accept
jdk.nashorn.internal.ir.ForNode#toString(StringBuilder, boolean)->void::: for node to string
jdk.nashorn.internal.ir.ForNode#hasGoto()->boolean::: for node has goto
jdk.nashorn.internal.ir.ForNode#mustEnter()->boolean::: for node must enter
jdk.nashorn.internal.ir.ForNode#getInit()->Expression:::Get the initialization expression for this for loop
jdk.nashorn.internal.ir.ForNode#setInit(LexicalContext, Expression)->ForNode:::Reset the initialization expression for this for loop
jdk.nashorn.internal.ir.ForNode#isForIn()->boolean:::Is this a for in construct rather than a standard init;condition;modification one
jdk.nashorn.internal.ir.ForNode#isForOf()->boolean:::Is this a for-of loop?
jdk.nashorn.internal.ir.ForNode#isForInOrOf()->boolean:::Is this a for-in or for-of statement?
jdk.nashorn.internal.ir.ForNode#isForEach()->boolean:::Is this a for each construct, known from e.g
jdk.nashorn.internal.ir.ForNode#getIterator()->Symbol:::If this is a for in or for each construct, there is an iterator symbol
jdk.nashorn.internal.ir.ForNode#setIterator(LexicalContext, Symbol)->ForNode:::Assign an iterator symbol to this ForNode
jdk.nashorn.internal.ir.ForNode#getModify()->JoinPredecessorExpression:::Get the modification expression for this ForNode
jdk.nashorn.internal.ir.ForNode#setModify(LexicalContext, JoinPredecessorExpression)->ForNode:::Reset the modification expression for this ForNode
jdk.nashorn.internal.ir.ForNode#setTest(LexicalContext, JoinPredecessorExpression)->ForNode::: for node set test
jdk.nashorn.internal.ir.ForNode#getBody()->Block::: for node get body
jdk.nashorn.internal.ir.ForNode#setBody(LexicalContext, Block)->ForNode::: for node set body
jdk.nashorn.internal.ir.ForNode#setControlFlowEscapes(LexicalContext, boolean)->ForNode::: for node set control flow escapes
jdk.nashorn.internal.ir.ForNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)->JoinPredecessor::: for node set local variable conversion changed
jdk.nashorn.internal.ir.ForNode#hasPerIterationScope()->boolean::: for node has per iteration scope
jdk.nashorn.internal.ir.ForNode#needsScopeCreator()->boolean:::Returns true if this for-node needs the scope creator of its containing block to create per-iteration scope
jdk.nashorn.internal.ir.FunctionCall#isFunction()->boolean:::Returns true if the value of this expression will be treated as a function and immediately invoked.
jdk.nashorn.internal.ir.FunctionNode#accept(LexicalContext, NodeVisitor)->Node::: function node accept
jdk.nashorn.internal.ir.FunctionNode#visitParameters(NodeVisitor)->List:::Visits the parameter nodes of this function
jdk.nashorn.internal.ir.FunctionNode#getCallSiteFlags()->int:::Get additional callsite flags to be used specific to this function.
jdk.nashorn.internal.ir.FunctionNode#getSource()->Source:::Get the source for this function
jdk.nashorn.internal.ir.FunctionNode#initializeDeserialized(Source, Namespace)->FunctionNode:::Sets the source and namespace for this function
jdk.nashorn.internal.ir.FunctionNode#getId()->int:::Get the unique ID for this function within the script file.
jdk.nashorn.internal.ir.FunctionNode#getSourceName()->String:::get source name - sourceURL or name derived from Source.
jdk.nashorn.internal.ir.FunctionNode#getSourceName(Source)->String:::Static source name getter
jdk.nashorn.internal.ir.FunctionNode#getDirectiveFlag(String)->int:::Function to parse nashorn per-function extension directive comments.
jdk.nashorn.internal.ir.FunctionNode#getLineNumber()->int:::Returns the line number.
jdk.nashorn.internal.ir.FunctionNode#uniqueName(String)->String:::Create a unique name in the namespace of this FunctionNode
jdk.nashorn.internal.ir.FunctionNode#toString(StringBuilder, boolean)->void::: function node to string
jdk.nashorn.internal.ir.FunctionNode#getFlags()->int::: function node get flags
jdk.nashorn.internal.ir.FunctionNode#getFlag(int)->boolean::: function node get flag
jdk.nashorn.internal.ir.FunctionNode#setFlags(LexicalContext, int)->FunctionNode::: function node set flags
jdk.nashorn.internal.ir.FunctionNode#clearFlag(LexicalContext, int)->FunctionNode::: function node clear flag
jdk.nashorn.internal.ir.FunctionNode#setFlag(LexicalContext, int)->FunctionNode::: function node set flag
jdk.nashorn.internal.ir.FunctionNode#getDebugFlags()->int:::Returns the debug flags for this function.
jdk.nashorn.internal.ir.FunctionNode#getDebugFlag(int)->boolean:::Checks whether a debug flag is set for this function.
jdk.nashorn.internal.ir.FunctionNode#isProgram()->boolean:::Returns true if the function is the top-level program.
jdk.nashorn.internal.ir.FunctionNode#canBeDeoptimized()->boolean:::Returns true if the function contains at least one optimistic operation (and thus can be deoptimized).
jdk.nashorn.internal.ir.FunctionNode#hasEval()->boolean:::Check if this function has a call expression for the identifier "eval" (that is, eval(...)).
jdk.nashorn.internal.ir.FunctionNode#hasNestedEval()->boolean:::Returns true if a function nested (directly or transitively) within this function #hasEval().
jdk.nashorn.internal.ir.FunctionNode#getFirstToken()->long:::Get the first token for this function
jdk.nashorn.internal.ir.FunctionNode#hasDeclaredFunctions()->boolean:::Check whether this function has nested function declarations
jdk.nashorn.internal.ir.FunctionNode#needsCallee()->boolean:::Check if this function's generated Java method needs a callee parameter
jdk.nashorn.internal.ir.FunctionNode#usesThis()->boolean:::Return true if this function makes use of the this object.
jdk.nashorn.internal.ir.FunctionNode#hasApplyToCallSpecialization()->boolean:::Return true if function contains an apply to call transform
jdk.nashorn.internal.ir.FunctionNode#getIdent()->IdentNode:::Get the identifier for this function, this is its symbol.
jdk.nashorn.internal.ir.FunctionNode#getBody()->Block:::Get the function body
jdk.nashorn.internal.ir.FunctionNode#setBody(LexicalContext, Block)->FunctionNode:::Reset the function body
jdk.nashorn.internal.ir.FunctionNode#isVarArg()->boolean:::Does this function's method needs to be variable arity (gather all script-declared parameters in a final Object[] parameter
jdk.nashorn.internal.ir.FunctionNode#inDynamicContext()->boolean:::Was this function declared in a dynamic context, i.e
jdk.nashorn.internal.ir.FunctionNode#needsDynamicScope()->boolean:::Check whether a function would need dynamic scope, which is does if it has evals and isn't strict.
jdk.nashorn.internal.ir.FunctionNode#setInDynamicContext(LexicalContext)->FunctionNode:::Flag this function as declared in a dynamic context
jdk.nashorn.internal.ir.FunctionNode#needsArguments()->boolean:::Returns true if this function needs to have an Arguments object defined as a local variable named "arguments"
jdk.nashorn.internal.ir.FunctionNode#needsParentScope()->boolean:::Returns true if this function needs access to its parent scope
jdk.nashorn.internal.ir.FunctionNode#setThisProperties(LexicalContext, int)->FunctionNode:::Set the number of properties assigned to the this object in this function.
jdk.nashorn.internal.ir.FunctionNode#getThisProperties()->int:::Get the number of properties assigned to the this object in this function.
jdk.nashorn.internal.ir.FunctionNode#hasScopeBlock()->boolean:::Returns true if any of the blocks in this function create their own scope.
jdk.nashorn.internal.ir.FunctionNode#getKind()->Kind:::Return the kind of this function
jdk.nashorn.internal.ir.FunctionNode#getLastToken()->long:::Return the last token for this function's code
jdk.nashorn.internal.ir.FunctionNode#getEndParserState()->Object:::Returns the end parser state for this function.
jdk.nashorn.internal.ir.FunctionNode#getName()->String:::Get the name of this function
jdk.nashorn.internal.ir.FunctionNode#setName(LexicalContext, String)->FunctionNode:::Set the internal name for this function
jdk.nashorn.internal.ir.FunctionNode#allVarsInScope()->boolean:::Check if this function should have all its variables in its own scope
jdk.nashorn.internal.ir.FunctionNode#isSplit()->boolean:::Checks if this function is split into several smaller fragments.
jdk.nashorn.internal.ir.FunctionNode#getParameters()->List:::Get the parameters to this function
jdk.nashorn.internal.ir.FunctionNode#getParameterExpressions()->Map:::Get the ES6 style parameter expressions of this function
jdk.nashorn.internal.ir.FunctionNode#getNumOfParams()->int:::Return the number of parameters to this function
jdk.nashorn.internal.ir.FunctionNode#getParameter(int)->IdentNode:::Returns the identifier for a named parameter at the specified position in this function's parameter list.
jdk.nashorn.internal.ir.FunctionNode#setParameters(LexicalContext, List)->FunctionNode:::Reset the compile unit used to compile this function
jdk.nashorn.internal.ir.FunctionNode#isDeclared()->boolean:::Check if this function is created as a function declaration (as opposed to function expression)
jdk.nashorn.internal.ir.FunctionNode#isAnonymous()->boolean:::Check if this function is anonymous
jdk.nashorn.internal.ir.FunctionNode#usesSelfSymbol()->boolean:::Does this function use its self symbol - this is needed only for self-referencing named function expressions
jdk.nashorn.internal.ir.FunctionNode#isNamedFunctionExpression()->boolean:::Returns true if this is a named function expression (that is, it isn't a declared function, it isn't an anonymous function expression, and it isn't a program).
jdk.nashorn.internal.ir.FunctionNode#getType()->Type::: function node get type
jdk.nashorn.internal.ir.FunctionNode#getWidestOperationType()->Type::: function node get widest operation type
jdk.nashorn.internal.ir.FunctionNode#getReturnType()->Type:::Get the return type for this function
jdk.nashorn.internal.ir.FunctionNode#setReturnType(LexicalContext, Type)->FunctionNode:::Set the function return type
jdk.nashorn.internal.ir.FunctionNode#isStrict()->boolean:::Check if the function is generated in strict mode
jdk.nashorn.internal.ir.FunctionNode#isCached()->boolean:::Returns true if this function node has been cached.
jdk.nashorn.internal.ir.FunctionNode#setCached(LexicalContext)->FunctionNode:::Mark this function node as having been cached.
jdk.nashorn.internal.ir.FunctionNode#isStrong()->boolean:::Checks if the function is generated in strong mode.
jdk.nashorn.internal.ir.FunctionNode#isMethod()->boolean:::Checks if this is an ES6 method.
jdk.nashorn.internal.ir.FunctionNode#usesSuper()->boolean:::Checks if this function uses the ES6 super binding.
jdk.nashorn.internal.ir.FunctionNode#hasDirectSuper()->boolean:::Checks if this function directly uses the super binding.
jdk.nashorn.internal.ir.FunctionNode#isClassConstructor()->boolean:::Checks if this is an ES6 class constructor.
jdk.nashorn.internal.ir.FunctionNode#isSubclassConstructor()->boolean:::Checks if this is an ES6 subclass constructor.
jdk.nashorn.internal.ir.FunctionNode#usesNewTarget()->boolean:::Checks if this function uses the ES6 new-targert.
jdk.nashorn.internal.ir.FunctionNode#isModule()->boolean:::Checks if this is an ES6 module.
jdk.nashorn.internal.ir.FunctionNode#getModule()->Module:::Returns the functions's ES6 module.
jdk.nashorn.internal.ir.FunctionNode#getCompileUnit()->CompileUnit:::Get the compile unit used to compile this function
jdk.nashorn.internal.ir.FunctionNode#setCompileUnit(LexicalContext, CompileUnit)->FunctionNode:::Reset the compile unit used to compile this function
jdk.nashorn.internal.ir.FunctionNode#compilerConstant(CompilerConstants)->Symbol:::Get the symbol for a compiler constant, or null if not available (yet)
jdk.nashorn.internal.ir.FunctionNode#getRootClass()->Class:::Get the root class that this function node compiles to
jdk.nashorn.internal.ir.FunctionNode#setRootClass(LexicalContext, Class)->FunctionNode:::Reset the root class that this function is compiled to
jdk.nashorn.internal.ir.GetSplitState#getType()->Type::: get split state get type
jdk.nashorn.internal.ir.GetSplitState#accept(NodeVisitor)->Node::: get split state accept
jdk.nashorn.internal.ir.GetSplitState#toString(StringBuilder, boolean)->void::: get split state to string
jdk.nashorn.internal.ir.IdentNode#createInternalIdentifier(Symbol)->IdentNode:::Creates an identifier for the symbol
jdk.nashorn.internal.ir.IdentNode#getType()->Type::: ident node get type
jdk.nashorn.internal.ir.IdentNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.IdentNode#toString(StringBuilder, boolean)->void::: ident node to string
jdk.nashorn.internal.ir.IdentNode#getName()->String:::Get the name of the identifier
jdk.nashorn.internal.ir.IdentNode#getPropertyName()->String::: ident node get property name
jdk.nashorn.internal.ir.IdentNode#isLocal()->boolean::: ident node is local
jdk.nashorn.internal.ir.IdentNode#getSymbol()->Symbol:::Return the Symbol the compiler has assigned to this identifier
jdk.nashorn.internal.ir.IdentNode#setSymbol(Symbol)->IdentNode:::Assign a symbol to this identifier
jdk.nashorn.internal.ir.IdentNode#isPropertyName()->boolean:::Check if this IdentNode is a property name
jdk.nashorn.internal.ir.IdentNode#setIsPropertyName()->IdentNode:::Flag this IdentNode as a property name
jdk.nashorn.internal.ir.IdentNode#isFutureStrictName()->boolean:::Check if this IdentNode is a future strict name
jdk.nashorn.internal.ir.IdentNode#setIsFutureStrictName()->IdentNode:::Flag this IdentNode as a future strict name
jdk.nashorn.internal.ir.IdentNode#isInitializedHere()->boolean:::Helper function for local def analysis.
jdk.nashorn.internal.ir.IdentNode#setIsInitializedHere()->IdentNode:::Flag IdentNode to be initialized on creation
jdk.nashorn.internal.ir.IdentNode#isDead()->boolean:::Is this a LET or CONST identifier used before its declaration?
jdk.nashorn.internal.ir.IdentNode#markDead()->IdentNode:::Flag this IdentNode as a LET or CONST identifier used before its declaration.
jdk.nashorn.internal.ir.IdentNode#isDeclaredHere()->boolean:::Is this IdentNode declared here?
jdk.nashorn.internal.ir.IdentNode#setIsDeclaredHere()->IdentNode:::Flag this IdentNode as being declared here.
jdk.nashorn.internal.ir.IdentNode#isCompileTimePropertyName()->boolean:::Check if the name of this IdentNode is same as that of a compile-time property (currently __DIR__, __FILE__, and __LINE__).
jdk.nashorn.internal.ir.IdentNode#isFunction()->boolean::: ident node is function
jdk.nashorn.internal.ir.IdentNode#setType(Type)->IdentNode::: ident node set type
jdk.nashorn.internal.ir.IdentNode#setIsFunction()->IdentNode:::Mark this node as being the callee operand of a CallNode.
jdk.nashorn.internal.ir.IdentNode#setIsNotFunction()->IdentNode:::Mark this node as not being the callee operand of a CallNode.
jdk.nashorn.internal.ir.IdentNode#getProgramPoint()->int::: ident node get program point
jdk.nashorn.internal.ir.IdentNode#setProgramPoint(int)->Optimistic::: ident node set program point
jdk.nashorn.internal.ir.IdentNode#getMostOptimisticType()->Type::: ident node get most optimistic type
jdk.nashorn.internal.ir.IdentNode#getMostPessimisticType()->Type::: ident node get most pessimistic type
jdk.nashorn.internal.ir.IdentNode#canBeOptimistic()->boolean::: ident node can be optimistic
jdk.nashorn.internal.ir.IdentNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: ident node set local variable conversion
jdk.nashorn.internal.ir.IdentNode#isInternal()->boolean:::Is this an internal symbol, i.e
jdk.nashorn.internal.ir.IdentNode#getLocalVariableConversion()->LocalVariableConversion::: ident node get local variable conversion
jdk.nashorn.internal.ir.IdentNode#isDirectSuper()->boolean:::Checks if this is a direct super identifier
jdk.nashorn.internal.ir.IdentNode#setIsDirectSuper()->IdentNode:::Return a new identifier with the direct super flag set.
jdk.nashorn.internal.ir.IdentNode#isRestParameter()->boolean:::Checks if this is a rest parameter
jdk.nashorn.internal.ir.IdentNode#setIsRestParameter()->IdentNode:::Return a new identifier with the rest parameter flag set.
jdk.nashorn.internal.ir.IdentNode#isProtoPropertyName()->boolean:::Checks if this is a proto property name.
jdk.nashorn.internal.ir.IdentNode#setIsProtoPropertyName()->IdentNode:::Return a new identifier with the proto property name flag set.
jdk.nashorn.internal.ir.IdentNode#isDefaultParameter()->boolean:::Checks whether this is a default parameter.
jdk.nashorn.internal.ir.IdentNode#setIsDefaultParameter()->IdentNode:::Return a new identifier with the default parameter flag set.
jdk.nashorn.internal.ir.IdentNode#isDestructuredParameter()->boolean:::Checks whether this is a destructured parameter.
jdk.nashorn.internal.ir.IdentNode#setIsDestructuredParameter()->IdentNode:::Return a new identifier with the destructured parameter flag set.
jdk.nashorn.internal.ir.IdentNode#containsEscapes()->boolean:::Checks whether the source code for this ident contains a unicode escape sequence by comparing the length of its name with its length in source code.
jdk.nashorn.internal.ir.IfNode#isTerminal()->boolean::: if node is terminal
jdk.nashorn.internal.ir.IfNode#accept(NodeVisitor)->Node::: if node accept
jdk.nashorn.internal.ir.IfNode#toString(StringBuilder, boolean)->void::: if node to string
jdk.nashorn.internal.ir.IfNode#getFail()->Block:::Get the else block of this IfNode
jdk.nashorn.internal.ir.IfNode#getPass()->Block:::Get the then block for this IfNode
jdk.nashorn.internal.ir.IfNode#getTest()->Expression:::Get the test expression for this IfNode
jdk.nashorn.internal.ir.IfNode#setTest(Expression)->IfNode:::Reset the test expression for this IfNode
jdk.nashorn.internal.ir.IfNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->IfNode::: if node set local variable conversion
jdk.nashorn.internal.ir.IfNode#getLocalVariableConversion()->LocalVariableConversion::: if node get local variable conversion
jdk.nashorn.internal.ir.IndexNode#accept(NodeVisitor)->Node::: index node accept
jdk.nashorn.internal.ir.IndexNode#toString(StringBuilder, boolean)->void::: index node to string
jdk.nashorn.internal.ir.IndexNode#getIndex()->Expression:::Get the index expression for this IndexNode
jdk.nashorn.internal.ir.IndexNode#setIndex(Expression)->IndexNode:::Set the index expression for this node
jdk.nashorn.internal.ir.IndexNode#setType(Type)->IndexNode::: index node set type
jdk.nashorn.internal.ir.IndexNode#setIsFunction()->IndexNode::: index node set is function
jdk.nashorn.internal.ir.IndexNode#setProgramPoint(int)->IndexNode::: index node set program point
jdk.nashorn.internal.ir.IndexNode#setIsSuper()->IndexNode::: index node set is super
jdk.nashorn.internal.ir.JoinPredecessor#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor:::Set the local variable conversions needed to unify their types at a control flow join point.
jdk.nashorn.internal.ir.JoinPredecessor#getLocalVariableConversion()->LocalVariableConversion:::Returns the local variable conversions needed to unify their types at a control flow join point.
jdk.nashorn.internal.ir.JoinPredecessorExpression#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: join predecessor expression set local variable conversion
jdk.nashorn.internal.ir.JoinPredecessorExpression#getType()->Type::: join predecessor expression get type
jdk.nashorn.internal.ir.JoinPredecessorExpression#isAlwaysFalse()->boolean::: join predecessor expression is always false
jdk.nashorn.internal.ir.JoinPredecessorExpression#isAlwaysTrue()->boolean::: join predecessor expression is always true
jdk.nashorn.internal.ir.JoinPredecessorExpression#getExpression()->Expression:::Returns the underlying expression.
jdk.nashorn.internal.ir.JoinPredecessorExpression#setExpression(Expression)->JoinPredecessorExpression:::Sets the underlying expression.
jdk.nashorn.internal.ir.JoinPredecessorExpression#getLocalVariableConversion()->LocalVariableConversion::: join predecessor expression get local variable conversion
jdk.nashorn.internal.ir.JoinPredecessorExpression#accept(NodeVisitor)->Node::: join predecessor expression accept
jdk.nashorn.internal.ir.JoinPredecessorExpression#toString(StringBuilder, boolean)->void::: join predecessor expression to string
jdk.nashorn.internal.ir.JumpStatement#hasGoto()->boolean::: jump statement has goto
jdk.nashorn.internal.ir.JumpStatement#getLabelName()->String:::Get the label name for this break node
jdk.nashorn.internal.ir.JumpStatement#toString(StringBuilder, boolean)->void::: jump statement to string
jdk.nashorn.internal.ir.JumpStatement#getStatementName()->String::: jump statement get statement name
jdk.nashorn.internal.ir.JumpStatement#getTarget(LexicalContext)->BreakableNode:::Finds the target for this jump statement in a lexical context.
jdk.nashorn.internal.ir.JumpStatement#getTargetLabel(BreakableNode)->Label:::Returns the label corresponding to this kind of jump statement (either a break or continue label) in the target.
jdk.nashorn.internal.ir.JumpStatement#getTargetLabel(LexicalContext)->Label:::Returns the label this jump statement targets.
jdk.nashorn.internal.ir.JumpStatement#getPopScopeLimit(LexicalContext)->LexicalContextNode:::Returns the limit node for popping scopes when this jump statement is effected.
jdk.nashorn.internal.ir.JumpStatement#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JumpStatement::: jump statement set local variable conversion
jdk.nashorn.internal.ir.JumpStatement#createNewJumpStatement(LocalVariableConversion)->JumpStatement::: jump statement create new jump statement
jdk.nashorn.internal.ir.JumpStatement#getLocalVariableConversion()->LocalVariableConversion::: jump statement get local variable conversion
jdk.nashorn.internal.ir.JumpToInlinedFinally#accept(NodeVisitor)->Node::: jump to inlined finally accept
jdk.nashorn.internal.ir.JumpToInlinedFinally#createNewJumpStatement(LocalVariableConversion)->JumpStatement::: jump to inlined finally create new jump statement
jdk.nashorn.internal.ir.JumpToInlinedFinally#getStatementName()->String::: jump to inlined finally get statement name
jdk.nashorn.internal.ir.JumpToInlinedFinally#getTarget(LexicalContext)->Block::: jump to inlined finally get target
jdk.nashorn.internal.ir.JumpToInlinedFinally#getPopScopeLimit(LexicalContext)->TryNode::: jump to inlined finally get pop scope limit
jdk.nashorn.internal.ir.JumpToInlinedFinally#getTargetLabel(BreakableNode)->Label::: jump to inlined finally get target label
jdk.nashorn.internal.ir.LabelNode#isTerminal()->boolean::: label node is terminal
jdk.nashorn.internal.ir.LabelNode#accept(LexicalContext, NodeVisitor)->Node::: label node accept
jdk.nashorn.internal.ir.LabelNode#toString(StringBuilder, boolean)->void::: label node to string
jdk.nashorn.internal.ir.LabelNode#getBody()->Block:::Get the body of the node
jdk.nashorn.internal.ir.LabelNode#setBody(LexicalContext, Block)->LabelNode:::Reset the body of the node
jdk.nashorn.internal.ir.LabelNode#getLabelName()->String:::Get the label name
jdk.nashorn.internal.ir.LabelNode#getLocalVariableConversion()->LocalVariableConversion::: label node get local variable conversion
jdk.nashorn.internal.ir.LabelNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->LabelNode::: label node set local variable conversion
jdk.nashorn.internal.ir.Labels#getLabels()->List:::Return the labels associated with this node
jdk.nashorn.internal.ir.LexicalContext#setFlag(LexicalContextNode, int)->void:::Set the flags for a lexical context node on the stack
jdk.nashorn.internal.ir.LexicalContext#setBlockNeedsScope(Block)->void:::Marks the block as one that creates a scope
jdk.nashorn.internal.ir.LexicalContext#getFlags(LexicalContextNode)->int:::Get the flags for a lexical context node on the stack.
jdk.nashorn.internal.ir.LexicalContext#getFunctionBody(FunctionNode)->Block:::Get the function body of a function node on the lexical context stack
jdk.nashorn.internal.ir.LexicalContext#getAllNodes()->Iterator::: lexical context get all nodes
jdk.nashorn.internal.ir.LexicalContext#getOutermostFunction()->FunctionNode:::Returns the outermost function in this context
jdk.nashorn.internal.ir.LexicalContext#push(T)->T:::Pushes a new block on top of the context, making it the innermost open block.
jdk.nashorn.internal.ir.LexicalContext#isEmpty()->boolean:::Is the context empty?
jdk.nashorn.internal.ir.LexicalContext#size()->int::: lexical context size
jdk.nashorn.internal.ir.LexicalContext#pop(T)->T:::Pops the innermost block off the context and all nodes that has been contributed since it was put there.
jdk.nashorn.internal.ir.LexicalContext#applyTopFlags(T)->T:::Explicitly apply flags to the topmost element on the stack
jdk.nashorn.internal.ir.LexicalContext#peek()->LexicalContextNode:::Return the top element in the context.
jdk.nashorn.internal.ir.LexicalContext#contains(LexicalContextNode)->boolean:::Check if a node is in the lexical context.
jdk.nashorn.internal.ir.LexicalContext#replace(LexicalContextNode, LexicalContextNode)->LexicalContextNode:::Replace a node on the lexical context with a new one
jdk.nashorn.internal.ir.LexicalContext#getBlocks()->Iterator:::Returns an iterator over all blocks in the context, with the top block (innermost lexical context) first.
jdk.nashorn.internal.ir.LexicalContext#getFunctions()->Iterator:::Returns an iterator over all functions in the context, with the top (innermost open) function first.
jdk.nashorn.internal.ir.LexicalContext#getParentBlock()->Block:::Get the parent block for the current lexical context block
jdk.nashorn.internal.ir.LexicalContext#getCurrentBlockLabelNode()->LabelNode:::Gets the label node of the current block.
jdk.nashorn.internal.ir.LexicalContext#getAncestorBlocks(Block)->Iterator:::Returns an iterator over all ancestors block of the given block, with its parent block first.
jdk.nashorn.internal.ir.LexicalContext#getBlocks(Block)->Iterator:::Returns an iterator over a block and all its ancestors blocks, with the block first.
jdk.nashorn.internal.ir.LexicalContext#getFunction(Block)->FunctionNode:::Get the function for this block.
jdk.nashorn.internal.ir.LexicalContext#getCurrentBlock()->Block::: lexical context get current block
jdk.nashorn.internal.ir.LexicalContext#getCurrentFunction()->FunctionNode::: lexical context get current function
jdk.nashorn.internal.ir.LexicalContext#getDefiningBlock(Symbol)->Block:::Get the block in which a symbol is defined.
jdk.nashorn.internal.ir.LexicalContext#getDefiningFunction(Symbol)->FunctionNode:::Get the function in which a symbol is defined.
jdk.nashorn.internal.ir.LexicalContext#isFunctionBody()->boolean:::Is the topmost lexical context element a function body?
jdk.nashorn.internal.ir.LexicalContext#isSplitBody()->boolean:::Is the topmost lexical context element body of a SplitNode?
jdk.nashorn.internal.ir.LexicalContext#getParentFunction(FunctionNode)->FunctionNode:::Get the parent function for a function in the lexical context.
jdk.nashorn.internal.ir.LexicalContext#getScopeNestingLevelTo(LexicalContextNode)->int:::Count the number of scopes until a given node
jdk.nashorn.internal.ir.LexicalContext#inLoop()->boolean:::Check whether the lexical context is currently inside a loop.
jdk.nashorn.internal.ir.LexicalContext#getCurrentLoop()->LoopNode::: lexical context get current loop
jdk.nashorn.internal.ir.LexicalContext#getBreakable(String)->BreakableNode:::Find the breakable node corresponding to this label.
jdk.nashorn.internal.ir.LexicalContext#getContinueTo(String)->LoopNode:::Find the continue target node corresponding to this label.
jdk.nashorn.internal.ir.LexicalContext#getInlinedFinally(String)->Block:::Find the inlined finally block node corresponding to this label.
jdk.nashorn.internal.ir.LexicalContext#getTryNodeForInlinedFinally(String)->TryNode:::Find the try node for an inlined finally block corresponding to this label.
jdk.nashorn.internal.ir.LexicalContext#isExternalTarget(SplitNode, BreakableNode)->boolean:::Checks whether a given target is a jump destination that lies outside a given split node.
jdk.nashorn.internal.ir.LexicalContext#inUnprotectedSwitchContext()->boolean:::Checks whether the current context is inside a switch statement without explicit blocks (curly braces).
jdk.nashorn.internal.ir.LexicalContext#toString()->String::: lexical context to string
jdk.nashorn.internal.ir.LexicalContextExpression#accept(NodeVisitor)->Node::: lexical context expression accept
jdk.nashorn.internal.ir.LexicalContextNode#accept(LexicalContext, NodeVisitor)->Node:::Accept function for the node given a lexical context
jdk.nashorn.internal.ir.LexicalContextNode.Acceptor#accept(LexicalContextNode, NodeVisitor)->Node::: acceptor accept
jdk.nashorn.internal.ir.LexicalContextStatement#accept(NodeVisitor)->Node::: lexical context statement accept
jdk.nashorn.internal.ir.LiteralNode#initialize(LexicalContext)->LiteralNode:::Initialization setter, if required for immutable state
jdk.nashorn.internal.ir.LiteralNode#isNull()->boolean:::Check if the literal value is null
jdk.nashorn.internal.ir.LiteralNode#getType()->Type::: literal node get type
jdk.nashorn.internal.ir.LiteralNode#getPropertyName()->String::: literal node get property name
jdk.nashorn.internal.ir.LiteralNode#getBoolean()->boolean:::Fetch boolean value of node.
jdk.nashorn.internal.ir.LiteralNode#getInt32()->int:::Fetch int32 value of node.
jdk.nashorn.internal.ir.LiteralNode#getUint32()->long:::Fetch uint32 value of node.
jdk.nashorn.internal.ir.LiteralNode#getLong()->long:::Fetch long value of node
jdk.nashorn.internal.ir.LiteralNode#getNumber()->double:::Fetch double value of node.
jdk.nashorn.internal.ir.LiteralNode#getString()->String:::Fetch String value of node.
jdk.nashorn.internal.ir.LiteralNode#getObject()->Object:::Fetch Object value of node.
jdk.nashorn.internal.ir.LiteralNode#isArray()->boolean:::Test if the value is an array
jdk.nashorn.internal.ir.LiteralNode#getElementExpressions()->List::: literal node get element expressions
jdk.nashorn.internal.ir.LiteralNode#isBoolean()->boolean:::Test if the value is a boolean.
jdk.nashorn.internal.ir.LiteralNode#isString()->boolean:::Test if the value is a string.
jdk.nashorn.internal.ir.LiteralNode#isNumeric()->boolean:::Test if tha value is a number
jdk.nashorn.internal.ir.LiteralNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.LiteralNode#toString(StringBuilder, boolean)->void::: literal node to string
jdk.nashorn.internal.ir.LiteralNode#getValue()->T:::Get the literal node value
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int)->LiteralNode:::Create a new null literal
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node)->LiteralNode:::Create a new null literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode.PrimitiveLiteralNode#isTrue()->boolean:::Check if the literal value is boolean true
jdk.nashorn.internal.ir.LiteralNode.PrimitiveLiteralNode#isLocal()->boolean::: primitive literal node is local
jdk.nashorn.internal.ir.LiteralNode.PrimitiveLiteralNode#isAlwaysFalse()->boolean::: primitive literal node is always false
jdk.nashorn.internal.ir.LiteralNode.PrimitiveLiteralNode#isAlwaysTrue()->boolean::: primitive literal node is always true
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, boolean)->LiteralNode:::Create a new boolean literal
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, boolean)->LiteralNode:::Create a new boolean literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, Number)->LiteralNode:::Create a new number literal
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, Number)->LiteralNode:::Create a new number literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, Undefined)->LiteralNode:::Create a new undefined literal
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, Undefined)->LiteralNode:::Create a new null literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, String)->LiteralNode:::Create a new string literal
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, String)->LiteralNode:::Create a new String literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, LexerToken)->LiteralNode:::Create a new literal node for a lexer token
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, LexerToken)->LiteralNode:::Create a new lexer token literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#objectAsConstant(Object)->Object:::Get the constant value for an object, or #POSTSET_MARKER if the value can't be statically computed.
jdk.nashorn.internal.ir.LiteralNode#isConstant(Object)->boolean:::Test whether object represents a constant value.
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#isArray()->boolean::: array literal node is array
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#hasSpread()->boolean:::Returns true if this array literal has a spread element.
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#hasTrailingComma()->boolean:::Returns true if this array literal has a trailing comma.
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getElementExpressions()->List:::Returns a list of array element expressions
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#initialize(LexicalContext)->ArrayLiteralNode:::Setter that initializes all code generation meta data for an ArrayLiteralNode
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getArrayType()->ArrayType:::Get the array element type as Java format, e.g
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getType()->Type::: array literal node get type
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getElementType()->Type:::Get the element type of this array literal
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getPostsets()->int[]:::Get indices of arrays containing computed post sets
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getPresets()->Object:::Get presets constant array
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#getSplitRanges()->List:::Get the split ranges for this ArrayLiteral, or null if this array does not have to be split.
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#setSplitRanges(LexicalContext, List)->ArrayLiteralNode:::Set the SplitRanges that make up this ArrayLiteral
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#accept(NodeVisitor)->Node::: array literal node accept
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#accept(LexicalContext, NodeVisitor)->Node::: array literal node accept
jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode#toString(StringBuilder, boolean)->void::: array literal node to string
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, List)->LiteralNode:::Create a new array literal of Nodes from a list of Node values
jdk.nashorn.internal.ir.LiteralNode#newInstance(Node, List)->LiteralNode:::Create a new array literal based on a parent node (source, token, finish)
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, List, boolean, boolean)->LiteralNode::: literal node new instance
jdk.nashorn.internal.ir.LiteralNode#newInstance(long, int, Expression[])->LiteralNode:::Create a new array literal of Nodes
jdk.nashorn.internal.ir.LocalVariableConversion#getFrom()->Type:::Returns the type being converted from.
jdk.nashorn.internal.ir.LocalVariableConversion#getTo()->Type:::Returns the type being converted to.
jdk.nashorn.internal.ir.LocalVariableConversion#getNext()->LocalVariableConversion:::Returns the next conversion at the same join point, or null if this is the last one.
jdk.nashorn.internal.ir.LocalVariableConversion#getSymbol()->Symbol:::Returns the symbol representing the local variable whose value is being converted.
jdk.nashorn.internal.ir.LocalVariableConversion#isLive()->boolean:::Returns true if this conversion is live
jdk.nashorn.internal.ir.LocalVariableConversion#isAnyLive()->boolean:::Returns true if this conversion #isLive(), or if any of its #getNext() conversions are live.
jdk.nashorn.internal.ir.LocalVariableConversion#hasLiveConversion(JoinPredecessor)->boolean:::Returns true if the passed join predecessor has #isAnyLive() conversion.
jdk.nashorn.internal.ir.LocalVariableConversion#toString()->String::: local variable conversion to string
jdk.nashorn.internal.ir.LocalVariableConversion#toString(StringBuilder)->StringBuilder:::Generates a string representation of this conversion in the passed string builder.
jdk.nashorn.internal.ir.LocalVariableConversion#toString(LocalVariableConversion, StringBuilder)->StringBuilder:::Generates a string representation of the passed conversion in the passed string builder.
jdk.nashorn.internal.ir.LoopNode#ensureUniqueLabels(LexicalContext)->Node::: loop node ensure unique labels
jdk.nashorn.internal.ir.LoopNode#controlFlowEscapes()->boolean:::Does the control flow escape from this loop, i.e
jdk.nashorn.internal.ir.LoopNode#isTerminal()->boolean::: loop node is terminal
jdk.nashorn.internal.ir.LoopNode#mustEnter()->boolean:::Conservative check: does this loop have to be entered?
jdk.nashorn.internal.ir.LoopNode#getContinueLabel()->Label:::Get the continue label for this while node, i.e
jdk.nashorn.internal.ir.LoopNode#getLabels()->List::: loop node get labels
jdk.nashorn.internal.ir.LoopNode#isLoop()->boolean::: loop node is loop
jdk.nashorn.internal.ir.LoopNode#getBody()->Block:::Get the body for this for node
jdk.nashorn.internal.ir.LoopNode#setBody(LexicalContext, Block)->LoopNode::: loop node set body
jdk.nashorn.internal.ir.LoopNode#getTest()->JoinPredecessorExpression:::Get the test for this for node
jdk.nashorn.internal.ir.LoopNode#setTest(LexicalContext, JoinPredecessorExpression)->LoopNode:::Set the test for this for node
jdk.nashorn.internal.ir.LoopNode#setControlFlowEscapes(LexicalContext, boolean)->LoopNode:::Set the control flow escapes flag for this node
jdk.nashorn.internal.ir.LoopNode#hasPerIterationScope()->boolean:::Does this loop have a LET declaration and hence require a per-iteration scope?
jdk.nashorn.internal.ir.Module.ExportEntry#exportStarFrom(IdentNode, IdentNode, int, int)->ExportEntry:::Creates a export * export entry.
jdk.nashorn.internal.ir.Module.ExportEntry#exportDefault(IdentNode, IdentNode, int, int)->ExportEntry:::Creates a export default export entry with a local name.
jdk.nashorn.internal.ir.Module.ExportEntry#exportSpecifier(IdentNode, IdentNode, int, int)->ExportEntry:::Creates a export entry with a local name and export name.
jdk.nashorn.internal.ir.Module.ExportEntry#exportSpecifier(IdentNode, int, int)->ExportEntry:::Creates a export entry with an export name.
jdk.nashorn.internal.ir.Module.ExportEntry#withFrom(IdentNode, int)->ExportEntry:::Create a copy of this entry with the specified module request string.
jdk.nashorn.internal.ir.Module.ExportEntry#getExportName()->IdentNode:::Returns the entry's export name.
jdk.nashorn.internal.ir.Module.ExportEntry#getModuleRequest()->IdentNode:::Returns the entry's module request.
jdk.nashorn.internal.ir.Module.ExportEntry#getImportName()->IdentNode:::Returns the entry's import name.
jdk.nashorn.internal.ir.Module.ExportEntry#getLocalName()->IdentNode:::Returns the entry's local name.
jdk.nashorn.internal.ir.Module.ExportEntry#getStartPosition()->int:::Returns the entry's start position.
jdk.nashorn.internal.ir.Module.ExportEntry#getEndPosition()->int:::Returns the entry's end position.
jdk.nashorn.internal.ir.Module.ExportEntry#toString()->String::: export entry to string
jdk.nashorn.internal.ir.Module.ImportEntry#importSpecifier(IdentNode, IdentNode, int, int)->ImportEntry:::Creates an import entry with the given import and local names.
jdk.nashorn.internal.ir.Module.ImportEntry#importSpecifier(IdentNode, int, int)->ImportEntry:::Creates a new import entry with the given import name.
jdk.nashorn.internal.ir.Module.ImportEntry#withFrom(IdentNode, int)->ImportEntry:::Returns a copy of this import entry with the given module request and end position.
jdk.nashorn.internal.ir.Module.ImportEntry#getModuleRequest()->IdentNode:::Returns the entry's module request.
jdk.nashorn.internal.ir.Module.ImportEntry#getImportName()->IdentNode:::Returns the entry's import name.
jdk.nashorn.internal.ir.Module.ImportEntry#getLocalName()->IdentNode:::Returns the entry's local name.
jdk.nashorn.internal.ir.Module.ImportEntry#getStartPosition()->int:::Returns the entry's start position.
jdk.nashorn.internal.ir.Module.ImportEntry#getEndPosition()->int:::Returns the entry's end position.
jdk.nashorn.internal.ir.Module.ImportEntry#toString()->String::: import entry to string
jdk.nashorn.internal.ir.Module#getRequestedModules()->List:::Returns the list of requested modules.
jdk.nashorn.internal.ir.Module#getImportEntries()->List:::Returns the list of import entries.
jdk.nashorn.internal.ir.Module#getLocalExportEntries()->List:::Returns the list of local export entries.
jdk.nashorn.internal.ir.Module#getIndirectExportEntries()->List:::Returns the list of indirect export entries.
jdk.nashorn.internal.ir.Module#getStarExportEntries()->List:::Returns the list of star export entries.
jdk.nashorn.internal.ir.Module#toString()->String::: module to string
jdk.nashorn.internal.ir.Node#isLoop()->boolean:::Is this a loop node?
jdk.nashorn.internal.ir.Node#isAssignment()->boolean:::Is this an assignment node - for example a var node with an init or a binary node that writes to a destination
jdk.nashorn.internal.ir.Node#ensureUniqueLabels(LexicalContext)->Node:::For reference copies - ensure that labels in the copy node are unique using an appropriate copy constructor
jdk.nashorn.internal.ir.Node#accept(NodeVisitor)->Node:::Provides a means to navigate the IR.
jdk.nashorn.internal.ir.Node#toString()->String::: node to string
jdk.nashorn.internal.ir.Node#toString(boolean)->String::: node to string
jdk.nashorn.internal.ir.Node#toString(StringBuilder)->void:::String conversion helper
jdk.nashorn.internal.ir.Node#toString(StringBuilder, boolean)->void:::Print logic that decides whether to show the optimistic type or not - for example it should not be printed after just parse, when it hasn't been computed, or has been set to a trivially provable value
jdk.nashorn.internal.ir.Node#getFinish()->int:::Get the finish position for this node in the source string
jdk.nashorn.internal.ir.Node#getStart()->int:::Get start position for node
jdk.nashorn.internal.ir.Node#getSourceOrder()->int:::Integer to sort nodes in source order
jdk.nashorn.internal.ir.Node#clone()->Object::: node clone
jdk.nashorn.internal.ir.Node#equals(Object)->boolean::: node equals
jdk.nashorn.internal.ir.Node#hashCode()->int::: node hash code
jdk.nashorn.internal.ir.Node#position()->int:::Return token position from a token descriptor.
jdk.nashorn.internal.ir.Node#length()->int:::Return token length from a token descriptor.
jdk.nashorn.internal.ir.Node#tokenType()->TokenType:::Returns this node's token's type
jdk.nashorn.internal.ir.Node#isTokenType(TokenType)->boolean:::Tests if this node has the specific token type.
jdk.nashorn.internal.ir.Node#getToken()->long:::Get the token for this node
jdk.nashorn.internal.ir.Node#accept(NodeVisitor, List)->List::: node accept
jdk.nashorn.internal.ir.Node#replaceInLexicalContext(LexicalContext, T, T)->T::: node replace in lexical context
jdk.nashorn.internal.ir.ObjectNode#accept(NodeVisitor)->Node::: object node accept
jdk.nashorn.internal.ir.ObjectNode#accept(LexicalContext, NodeVisitor)->Node::: object node accept
jdk.nashorn.internal.ir.ObjectNode#getType()->Type::: object node get type
jdk.nashorn.internal.ir.ObjectNode#toString(StringBuilder, boolean)->void::: object node to string
jdk.nashorn.internal.ir.ObjectNode#getElements()->List:::Get the elements of this literal node
jdk.nashorn.internal.ir.ObjectNode#setSplitRanges(LexicalContext, List)->ObjectNode:::Set the split ranges for this ObjectNode
jdk.nashorn.internal.ir.ObjectNode#getSplitRanges()->List:::Get the split ranges for this ObjectNode, or null if the object is not split.
jdk.nashorn.internal.ir.Optimistic#getProgramPoint()->int:::Unique node ID that is associated with an invokedynamic call that mail fail and its callsite
jdk.nashorn.internal.ir.Optimistic#setProgramPoint(int)->Optimistic:::Set the node number for this node, associating with a unique per-function program point
jdk.nashorn.internal.ir.Optimistic#canBeOptimistic()->boolean:::Is it possible for this particular implementor to actually have any optimism? SHIFT operators for instance are binary nodes, but never optimistic
jdk.nashorn.internal.ir.Optimistic#getMostOptimisticType()->Type:::Get the most optimistic type for this node
jdk.nashorn.internal.ir.Optimistic#getMostPessimisticType()->Type:::Most pessimistic type that is guaranteed to be safe
jdk.nashorn.internal.ir.Optimistic#setType(Type)->Optimistic:::Set the override type
jdk.nashorn.internal.ir.OptimisticLexicalContext.Assumption#toString()->String::: assumption to string
jdk.nashorn.internal.ir.OptimisticLexicalContext#isEnabled()->boolean:::Are optimistic types enabled
jdk.nashorn.internal.ir.OptimisticLexicalContext#logOptimisticAssumption(Symbol, Type)->void:::Log an optimistic assumption during codegen TODO : different parameters and more info about the assumption for future profiling needs
jdk.nashorn.internal.ir.OptimisticLexicalContext#getOptimisticAssumptions()->List:::Get the list of optimistic assumptions made
jdk.nashorn.internal.ir.OptimisticLexicalContext#hasOptimisticAssumptions()->boolean:::Does this method have optimistic assumptions made during codegen?
jdk.nashorn.internal.ir.OptimisticLexicalContext#push(T)->T::: optimistic lexical context push
jdk.nashorn.internal.ir.OptimisticLexicalContext#pop(T)->T::: optimistic lexical context pop
jdk.nashorn.internal.ir.PropertyKey#getPropertyName()->String:::Get the property name
jdk.nashorn.internal.ir.PropertyNode#getKeyName()->String:::Get the name of the property key, or null if key is a computed name.
jdk.nashorn.internal.ir.PropertyNode#accept(NodeVisitor)->Node::: property node accept
jdk.nashorn.internal.ir.PropertyNode#toString(StringBuilder, boolean)->void::: property node to string
jdk.nashorn.internal.ir.PropertyNode#getGetter()->FunctionNode:::Get the getter for this property
jdk.nashorn.internal.ir.PropertyNode#setGetter(FunctionNode)->PropertyNode:::Set the getter of this property, null if none
jdk.nashorn.internal.ir.PropertyNode#getKey()->Expression:::Return the key for this property node
jdk.nashorn.internal.ir.PropertyNode#getSetter()->FunctionNode:::Get the setter for this property
jdk.nashorn.internal.ir.PropertyNode#setSetter(FunctionNode)->PropertyNode:::Set the setter for this property, null if none
jdk.nashorn.internal.ir.PropertyNode#getValue()->Expression:::Get the value of this property
jdk.nashorn.internal.ir.PropertyNode#setValue(Expression)->PropertyNode:::Set the value of this property
jdk.nashorn.internal.ir.PropertyNode#isStatic()->boolean:::Returns true if this is a static property.
jdk.nashorn.internal.ir.PropertyNode#isComputed()->boolean:::Returns true if this is a computed property.
jdk.nashorn.internal.ir.ReturnNode#isTerminal()->boolean::: return node is terminal
jdk.nashorn.internal.ir.ReturnNode#isReturn()->boolean:::Return true if is a RETURN node.
jdk.nashorn.internal.ir.ReturnNode#hasExpression()->boolean:::Check if this return node has an expression
jdk.nashorn.internal.ir.ReturnNode#isYield()->boolean:::Return true if is a YIELD node.
jdk.nashorn.internal.ir.ReturnNode#accept(NodeVisitor)->Node::: return node accept
jdk.nashorn.internal.ir.ReturnNode#toString(StringBuilder, boolean)->void::: return node to string
jdk.nashorn.internal.ir.ReturnNode#getExpression()->Expression:::Get the expression this node returns
jdk.nashorn.internal.ir.ReturnNode#setExpression(Expression)->ReturnNode:::Reset the expression this node returns
jdk.nashorn.internal.ir.RuntimeNode#setRequest(Request)->RuntimeNode:::Reset the request for this runtime node
jdk.nashorn.internal.ir.RuntimeNode#getType()->Type:::Return type for the ReferenceNode
jdk.nashorn.internal.ir.RuntimeNode#accept(NodeVisitor)->Node::: runtime node accept
jdk.nashorn.internal.ir.RuntimeNode#toString(StringBuilder, boolean)->void::: runtime node to string
jdk.nashorn.internal.ir.RuntimeNode#getArgs()->List:::Get the arguments for this runtime node
jdk.nashorn.internal.ir.RuntimeNode#setArgs(List)->RuntimeNode:::Set the arguments of this runtime node
jdk.nashorn.internal.ir.RuntimeNode#getRequest()->Request:::Get the request that this runtime node implements
jdk.nashorn.internal.ir.RuntimeNode#isPrimitive()->boolean:::Is this runtime node, engineered to handle the "at least one object" case of the defined requests and specialize on demand, really primitive
jdk.nashorn.internal.ir.SetSplitState#getState()->int:::Returns the state this setter sets.
jdk.nashorn.internal.ir.SetSplitState#accept(NodeVisitor)->Node::: set split state accept
jdk.nashorn.internal.ir.SetSplitState#toString(StringBuilder, boolean)->void::: set split state to string
jdk.nashorn.internal.ir.SplitNode#getBody()->Block:::Get the body for this split node - i.e
jdk.nashorn.internal.ir.SplitNode#accept(LexicalContext, NodeVisitor)->Node::: split node accept
jdk.nashorn.internal.ir.SplitNode#toString(StringBuilder, boolean)->void::: split node to string
jdk.nashorn.internal.ir.SplitNode#getName()->String:::Get the name for this split node
jdk.nashorn.internal.ir.SplitNode#getCompileUnit()->CompileUnit:::Get the compile unit for this split node
jdk.nashorn.internal.ir.SplitNode#setCompileUnit(LexicalContext, CompileUnit)->SplitNode:::Set the compile unit for this split node
jdk.nashorn.internal.ir.SplitReturn#isTerminal()->boolean::: split return is terminal
jdk.nashorn.internal.ir.SplitReturn#accept(NodeVisitor)->Node::: split return accept
jdk.nashorn.internal.ir.SplitReturn#toString(StringBuilder, boolean)->void::: split return to string
jdk.nashorn.internal.ir.Splittable#getSplitRanges()->List:::Get a list of split ranges for this splittable expression, or null if the expression should not be split.
jdk.nashorn.internal.ir.Splittable.SplitRange#getHigh()->int:::Get the high index position of the ArrayUnit (exclusive)
jdk.nashorn.internal.ir.Splittable.SplitRange#getLow()->int:::Get the low index position of the ArrayUnit (inclusive)
jdk.nashorn.internal.ir.Splittable.SplitRange#getCompileUnit()->CompileUnit:::The array compile unit
jdk.nashorn.internal.ir.Statement#getLineNumber()->int:::Return the line number
jdk.nashorn.internal.ir.Statement#isTerminal()->boolean:::Is this a terminal statement, i.e
jdk.nashorn.internal.ir.Statement#hasGoto()->boolean:::Check if this statement repositions control flow with goto like semantics, for example BreakNode or a ForNode with no test
jdk.nashorn.internal.ir.Statement#hasTerminalFlags()->boolean:::Check if this statement has terminal flags, i.e
jdk.nashorn.internal.ir.SwitchNode#ensureUniqueLabels(LexicalContext)->Node::: switch node ensure unique labels
jdk.nashorn.internal.ir.SwitchNode#isTerminal()->boolean::: switch node is terminal
jdk.nashorn.internal.ir.SwitchNode#accept(LexicalContext, NodeVisitor)->Node::: switch node accept
jdk.nashorn.internal.ir.SwitchNode#toString(StringBuilder, boolean)->void::: switch node to string
jdk.nashorn.internal.ir.SwitchNode#getDefaultCase()->CaseNode:::Return the case node that is default case
jdk.nashorn.internal.ir.SwitchNode#getCases()->List:::Get the cases in this switch
jdk.nashorn.internal.ir.SwitchNode#setCases(LexicalContext, List)->SwitchNode:::Replace case nodes with new list
jdk.nashorn.internal.ir.SwitchNode#setCases(LexicalContext, List, CaseNode)->SwitchNode:::Set or reset the list of cases in this switch
jdk.nashorn.internal.ir.SwitchNode#getExpression()->Expression:::Return the expression to switch on
jdk.nashorn.internal.ir.SwitchNode#setExpression(LexicalContext, Expression)->SwitchNode:::Set or reset the expression to switch on
jdk.nashorn.internal.ir.SwitchNode#getTag()->Symbol:::Get the tag symbol for this switch
jdk.nashorn.internal.ir.SwitchNode#setTag(LexicalContext, Symbol)->SwitchNode:::Set the tag symbol for this switch
jdk.nashorn.internal.ir.SwitchNode#isUniqueInteger()->boolean:::Returns true if all cases of this switch statement are 32-bit signed integer constants, without repetitions.
jdk.nashorn.internal.ir.SwitchNode#setUniqueInteger(LexicalContext, boolean)->SwitchNode:::Sets whether all cases of this switch statement are 32-bit signed integer constants, without repetitions.
jdk.nashorn.internal.ir.SwitchNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)->JoinPredecessor::: switch node set local variable conversion changed
jdk.nashorn.internal.ir.Symbol#clone()->Symbol::: symbol clone
jdk.nashorn.internal.ir.Symbol#print(PrintWriter)->void::: symbol print
jdk.nashorn.internal.ir.Symbol#less(int)->boolean:::Compare the the symbol kind with another.
jdk.nashorn.internal.ir.Symbol#setNeedsSlot(boolean)->Symbol:::Allocate a slot for this symbol.
jdk.nashorn.internal.ir.Symbol#slotCount()->int:::Return the number of slots required for the symbol.
jdk.nashorn.internal.ir.Symbol#toString()->String::: symbol to string
jdk.nashorn.internal.ir.Symbol#compareTo(Symbol)->int::: symbol compare to
jdk.nashorn.internal.ir.Symbol#hasSlot()->boolean:::Does this symbol have an allocated bytecode slot? Note that having an allocated bytecode slot doesn't necessarily mean the symbol's value will be stored in it
jdk.nashorn.internal.ir.Symbol#isBytecodeLocal()->boolean:::Is this symbol a local variable stored in bytecode local variable slots? This is true for a slotted variable that is not in scope
jdk.nashorn.internal.ir.Symbol#isDead()->boolean:::Returns true if this symbol is dead (it is a local variable that is statically proven to never be read in any type).
jdk.nashorn.internal.ir.Symbol#isScope()->boolean:::Check if this is a symbol in scope
jdk.nashorn.internal.ir.Symbol#isFunctionDeclaration()->boolean:::Check if this symbol is a function declaration
jdk.nashorn.internal.ir.Symbol#setIsScope()->Symbol:::Flag this symbol as scope as described in Symbol#isScope()
jdk.nashorn.internal.ir.Symbol#setIsFunctionDeclaration()->void:::Mark this symbol as a function declaration.
jdk.nashorn.internal.ir.Symbol#isVar()->boolean:::Check if this symbol is a variable
jdk.nashorn.internal.ir.Symbol#isGlobal()->boolean:::Check if this symbol is a global (undeclared) variable
jdk.nashorn.internal.ir.Symbol#isParam()->boolean:::Check if this symbol is a function parameter
jdk.nashorn.internal.ir.Symbol#isProgramLevel()->boolean:::Check if this is a program (script) level definition
jdk.nashorn.internal.ir.Symbol#isConst()->boolean:::Check if this symbol is a constant
jdk.nashorn.internal.ir.Symbol#isInternal()->boolean:::Check if this is an internal symbol, without an explicit JavaScript source code equivalent
jdk.nashorn.internal.ir.Symbol#isThis()->boolean:::Check if this symbol represents this
jdk.nashorn.internal.ir.Symbol#isLet()->boolean:::Check if this symbol is a let
jdk.nashorn.internal.ir.Symbol#isFunctionSelf()->boolean:::Flag this symbol as a function's self-referencing symbol.
jdk.nashorn.internal.ir.Symbol#isBlockScoped()->boolean:::Is this a block scoped symbol
jdk.nashorn.internal.ir.Symbol#hasBeenDeclared()->boolean:::Has this symbol been declared
jdk.nashorn.internal.ir.Symbol#setHasBeenDeclared()->void:::Mark this symbol as declared
jdk.nashorn.internal.ir.Symbol#getFieldIndex()->int:::Get the index of the field used to store this symbol, should it be an AccessorProperty and get allocated in a JO-prefixed ScriptObject subclass.
jdk.nashorn.internal.ir.Symbol#setFieldIndex(int)->Symbol:::Set the index of the field used to store this symbol, should it be an AccessorProperty and get allocated in a JO-prefixed ScriptObject subclass.
jdk.nashorn.internal.ir.Symbol#getFlags()->int:::Get the symbol flags
jdk.nashorn.internal.ir.Symbol#setFlags(int)->Symbol:::Set the symbol flags
jdk.nashorn.internal.ir.Symbol#setFlag(int)->Symbol:::Set a single symbol flag
jdk.nashorn.internal.ir.Symbol#clearFlag(int)->Symbol:::Clears a single symbol flag
jdk.nashorn.internal.ir.Symbol#getName()->String:::Get the name of this symbol
jdk.nashorn.internal.ir.Symbol#getFirstSlot()->int:::Get the index of the first bytecode slot for this symbol
jdk.nashorn.internal.ir.Symbol#getSlot(Type)->int:::Get the index of the bytecode slot for this symbol for storing a value of the specified type.
jdk.nashorn.internal.ir.Symbol#hasSlotFor(Type)->boolean:::Returns true if this symbol has a local variable slot for storing a value of specific type.
jdk.nashorn.internal.ir.Symbol#setHasSlotFor(Type)->void:::Marks this symbol as having a local variable slot for storing a value of specific type.
jdk.nashorn.internal.ir.Symbol#increaseUseCount()->void:::Increase the symbol's use count by one.
jdk.nashorn.internal.ir.Symbol#getUseCount()->int:::Get the symbol's use count
jdk.nashorn.internal.ir.Symbol#setFirstSlot(int)->Symbol:::Set the bytecode slot for this symbol
jdk.nashorn.internal.ir.Symbol#setSymbolIsScope(LexicalContext, Symbol)->Symbol:::From a lexical context, set this symbol as needing scope, which will set flags for the defining block that will be written when block is popped from the lexical context stack, used by codegen when flags need to be tagged, but block is in the middle of evaluation and cannot be modified.
jdk.nashorn.internal.ir.TemplateLiteral#getType()->Type::: template literal get type
jdk.nashorn.internal.ir.TemplateLiteral#accept(NodeVisitor)->Node::: template literal accept
jdk.nashorn.internal.ir.TemplateLiteral#toString(StringBuilder, boolean)->void::: template literal to string
jdk.nashorn.internal.ir.TemplateLiteral#getExpressions()->List:::The list of expressions that are part of this template literal.
jdk.nashorn.internal.ir.Terminal#isTerminal()->boolean:::Returns true if this AST node is (or contains) a statement that terminates function control flow.
jdk.nashorn.internal.ir.TernaryNode#accept(NodeVisitor)->Node::: ternary node accept
jdk.nashorn.internal.ir.TernaryNode#toString(StringBuilder, boolean)->void::: ternary node to string
jdk.nashorn.internal.ir.TernaryNode#isLocal()->boolean::: ternary node is local
jdk.nashorn.internal.ir.TernaryNode#getType()->Type::: ternary node get type
jdk.nashorn.internal.ir.TernaryNode#getTest()->Expression:::Get the test expression for this ternary expression, i.e
jdk.nashorn.internal.ir.TernaryNode#getTrueExpression()->JoinPredecessorExpression:::Get the true expression for this ternary expression, i.e
jdk.nashorn.internal.ir.TernaryNode#getFalseExpression()->JoinPredecessorExpression:::Get the false expression for this ternary expression, i.e
jdk.nashorn.internal.ir.TernaryNode#setTest(Expression)->TernaryNode:::Set the test expression for this node
jdk.nashorn.internal.ir.TernaryNode#setTrueExpression(JoinPredecessorExpression)->TernaryNode:::Set the true expression for this node
jdk.nashorn.internal.ir.TernaryNode#setFalseExpression(JoinPredecessorExpression)->TernaryNode:::Set the false expression for this node
jdk.nashorn.internal.ir.ThrowNode#isTerminal()->boolean::: throw node is terminal
jdk.nashorn.internal.ir.ThrowNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.ThrowNode#toString(StringBuilder, boolean)->void::: throw node to string
jdk.nashorn.internal.ir.ThrowNode#getExpression()->Expression:::Get the expression that is being thrown by this node
jdk.nashorn.internal.ir.ThrowNode#setExpression(Expression)->ThrowNode:::Reset the expression being thrown by this node
jdk.nashorn.internal.ir.ThrowNode#isSyntheticRethrow()->boolean:::Is this a throw a synthetic rethrow in a synthetic catch-all block created when inlining finally statements? In that case we never wrap whatever is thrown into an ECMAException, just rethrow it.
jdk.nashorn.internal.ir.ThrowNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: throw node set local variable conversion
jdk.nashorn.internal.ir.ThrowNode#getLocalVariableConversion()->LocalVariableConversion::: throw node get local variable conversion
jdk.nashorn.internal.ir.TryNode#ensureUniqueLabels(LexicalContext)->Node::: try node ensure unique labels
jdk.nashorn.internal.ir.TryNode#isTerminal()->boolean::: try node is terminal
jdk.nashorn.internal.ir.TryNode#accept(LexicalContext, NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.TryNode#toString(StringBuilder, boolean)->void::: try node to string
jdk.nashorn.internal.ir.TryNode#getBody()->Block:::Get the body for this try block
jdk.nashorn.internal.ir.TryNode#setBody(LexicalContext, Block)->TryNode:::Reset the body of this try block
jdk.nashorn.internal.ir.TryNode#getCatches()->List:::Get the catches for this try block
jdk.nashorn.internal.ir.TryNode#getCatchBlocks()->List:::Get the catch blocks for this try block
jdk.nashorn.internal.ir.TryNode#setCatchBlocks(LexicalContext, List)->TryNode:::Set the catch blocks of this try
jdk.nashorn.internal.ir.TryNode#getException()->Symbol:::Get the exception symbol for this try block
jdk.nashorn.internal.ir.TryNode#setException(LexicalContext, Symbol)->TryNode:::Set the exception symbol for this try block
jdk.nashorn.internal.ir.TryNode#getFinallyBody()->Block:::Get the body of the finally clause for this try
jdk.nashorn.internal.ir.TryNode#getInlinedFinally(String)->Block:::Get the inlined finally block with the given label name
jdk.nashorn.internal.ir.TryNode#getLabelledInlinedFinallyBlock(Block)->Block:::Given an outer wrapper block for the LabelNode as returned by #getInlinedFinallies(), returns its actual inlined finally block.
jdk.nashorn.internal.ir.TryNode#getInlinedFinallies()->List:::Returns a list of inlined finally blocks
jdk.nashorn.internal.ir.TryNode#setFinallyBody(LexicalContext, Block)->TryNode:::Set the finally body of this try
jdk.nashorn.internal.ir.TryNode#setInlinedFinallies(LexicalContext, List)->TryNode:::Set the inlined finally blocks of this try
jdk.nashorn.internal.ir.TryNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)->JoinPredecessor::: try node set local variable conversion
jdk.nashorn.internal.ir.TryNode#getLocalVariableConversion()->LocalVariableConversion::: try node get local variable conversion
jdk.nashorn.internal.ir.UnaryNode#isAssignment()->boolean:::Is this an assignment - i.e
jdk.nashorn.internal.ir.UnaryNode#isSelfModifying()->boolean::: unary node is self modifying
jdk.nashorn.internal.ir.UnaryNode#getWidestOperationType()->Type::: unary node get widest operation type
jdk.nashorn.internal.ir.UnaryNode#getAssignmentDest()->Expression::: unary node get assignment dest
jdk.nashorn.internal.ir.UnaryNode#setAssignmentDest(Expression)->UnaryNode::: unary node set assignment dest
jdk.nashorn.internal.ir.UnaryNode#getAssignmentSource()->Expression::: unary node get assignment source
jdk.nashorn.internal.ir.UnaryNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.UnaryNode#isLocal()->boolean::: unary node is local
jdk.nashorn.internal.ir.UnaryNode#toString(StringBuilder, boolean)->void::: unary node to string
jdk.nashorn.internal.ir.UnaryNode#toString(StringBuilder, Runnable, boolean)->void:::Creates the string representation of this unary node, delegating the creation of the string representation of its operand to a specified runnable.
jdk.nashorn.internal.ir.UnaryNode#getExpression()->Expression:::Get the right hand side of this if it is inherited by a binary expression, or just the expression itself if still Unary
jdk.nashorn.internal.ir.UnaryNode#setExpression(Expression)->UnaryNode:::Reset the right hand side of this if it is inherited by a binary expression, or just the expression itself if still Unary
jdk.nashorn.internal.ir.UnaryNode#getProgramPoint()->int::: unary node get program point
jdk.nashorn.internal.ir.UnaryNode#setProgramPoint(int)->UnaryNode::: unary node set program point
jdk.nashorn.internal.ir.UnaryNode#canBeOptimistic()->boolean::: unary node can be optimistic
jdk.nashorn.internal.ir.UnaryNode#getMostOptimisticType()->Type::: unary node get most optimistic type
jdk.nashorn.internal.ir.UnaryNode#getMostPessimisticType()->Type::: unary node get most pessimistic type
jdk.nashorn.internal.ir.UnaryNode#getType()->Type::: unary node get type
jdk.nashorn.internal.ir.UnaryNode#setType(Type)->UnaryNode::: unary node set type
jdk.nashorn.internal.ir.VarNode#getSourceOrder()->int::: var node get source order
jdk.nashorn.internal.ir.VarNode#isAssignment()->boolean::: var node is assignment
jdk.nashorn.internal.ir.VarNode#getAssignmentDest()->IdentNode::: var node get assignment dest
jdk.nashorn.internal.ir.VarNode#setAssignmentDest(IdentNode)->VarNode::: var node set assignment dest
jdk.nashorn.internal.ir.VarNode#getAssignmentSource()->Expression::: var node get assignment source
jdk.nashorn.internal.ir.VarNode#isBlockScoped()->boolean:::Is this a VAR node block scoped? This returns true for ECMAScript 6 LET and CONST nodes.
jdk.nashorn.internal.ir.VarNode#isLet()->boolean:::Is this an ECMAScript 6 LET node?
jdk.nashorn.internal.ir.VarNode#isConst()->boolean:::Is this an ECMAScript 6 CONST node?
jdk.nashorn.internal.ir.VarNode#getSymbolFlags()->int:::Return the flags to use for symbols for this declaration.
jdk.nashorn.internal.ir.VarNode#hasInit()->boolean:::Does this variable declaration have an init value
jdk.nashorn.internal.ir.VarNode#accept(NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.VarNode#toString(StringBuilder, boolean)->void::: var node to string
jdk.nashorn.internal.ir.VarNode#getInit()->Expression:::If this is an assignment of the form var x = init;, get the init part.
jdk.nashorn.internal.ir.VarNode#setInit(Expression)->VarNode:::Reset the initialization expression
jdk.nashorn.internal.ir.VarNode#getName()->IdentNode:::Get the identifier for the variable
jdk.nashorn.internal.ir.VarNode#setName(IdentNode)->VarNode:::Reset the identifier for this VarNode
jdk.nashorn.internal.ir.VarNode#getFlag(int)->boolean:::Check if a flag is set for this var node
jdk.nashorn.internal.ir.VarNode#setFlag(int)->VarNode:::Set a flag for this var node
jdk.nashorn.internal.ir.VarNode#isFunctionDeclaration()->boolean:::Returns true if this is a function declaration.
jdk.nashorn.internal.ir.WhileNode#ensureUniqueLabels(LexicalContext)->Node::: while node ensure unique labels
jdk.nashorn.internal.ir.WhileNode#hasGoto()->boolean::: while node has goto
jdk.nashorn.internal.ir.WhileNode#accept(LexicalContext, NodeVisitor)->Node::: while node accept
jdk.nashorn.internal.ir.WhileNode#setTest(LexicalContext, JoinPredecessorExpression)->WhileNode::: while node set test
jdk.nashorn.internal.ir.WhileNode#getBody()->Block::: while node get body
jdk.nashorn.internal.ir.WhileNode#setBody(LexicalContext, Block)->WhileNode::: while node set body
jdk.nashorn.internal.ir.WhileNode#setControlFlowEscapes(LexicalContext, boolean)->WhileNode::: while node set control flow escapes
jdk.nashorn.internal.ir.WhileNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)->JoinPredecessor::: while node set local variable conversion changed
jdk.nashorn.internal.ir.WhileNode#isDoWhile()->boolean:::Check if this is a do while loop or a normal while loop
jdk.nashorn.internal.ir.WhileNode#toString(StringBuilder, boolean)->void::: while node to string
jdk.nashorn.internal.ir.WhileNode#mustEnter()->boolean::: while node must enter
jdk.nashorn.internal.ir.WhileNode#hasPerIterationScope()->boolean::: while node has per iteration scope
jdk.nashorn.internal.ir.WithNode#accept(LexicalContext, NodeVisitor)->Node:::Assist in IR navigation.
jdk.nashorn.internal.ir.WithNode#isTerminal()->boolean::: with node is terminal
jdk.nashorn.internal.ir.WithNode#toString(StringBuilder, boolean)->void::: with node to string
jdk.nashorn.internal.ir.WithNode#getBody()->Block:::Get the body of this WithNode
jdk.nashorn.internal.ir.WithNode#setBody(LexicalContext, Block)->WithNode:::Reset the body of this with node
jdk.nashorn.internal.ir.WithNode#getExpression()->Expression:::Get the expression of this WithNode
jdk.nashorn.internal.ir.WithNode#setExpression(LexicalContext, Expression)->WithNode:::Reset the expression of this with node
