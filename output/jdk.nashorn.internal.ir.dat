AccessNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterAccessNode->return->visitor->base->accept->setBase->leaveAccessNode->return
AccessNode#toString(StringBuilder, boolean)::: access node to string:::needsParen->tokenType->getBase->tokenType->needsParens->if->optimisticTypeToString->if->sb->append->base->toString->if->sb->append->sb->append->sb->append
AccessNode#getProperty():::Get the property name:::return
AccessNode#setBase(Expression)::: access node set base:::if->return->return->isFunction->isSuper->new->AccessNode
AccessNode#setType(Type)::: access node set type:::if->return->return->isFunction->isSuper->new->AccessNode
AccessNode#setProgramPoint(int)::: access node set program point:::if->return->return->isFunction->isSuper->new->AccessNode
AccessNode#setIsFunction()::: access node set is function:::if->isFunction->return->return->isSuper->new->AccessNode
AccessNode#setIsSuper()::: access node set is super:::if->isSuper->return->return->isFunction->new->AccessNode
Assignment#getAssignmentDest():::Get assignment destination:::
Assignment#getAssignmentSource():::Get the assignment source:::
Assignment#setAssignmentDest(D):::Set assignment destination node.:::
BaseNode#getBase():::Get the base node for this access:::return
BaseNode#isFunction()::: base node is function:::return
BaseNode#getType()::: base node get type:::return->getMostPessimisticType
BaseNode#getProgramPoint()::: base node get program point:::return
BaseNode#getMostOptimisticType()::: base node get most optimistic type:::return
BaseNode#getMostPessimisticType()::: base node get most pessimistic type:::return
BaseNode#canBeOptimistic()::: base node can be optimistic:::return
BaseNode#isIndex():::Return true if this node represents an index operation normally represented as IndexNode.:::return->isTokenType
BaseNode#setIsFunction():::Mark this node as being the callee operand of a CallNode.:::
BaseNode#isSuper()::: base node is super:::return
BaseNode#setIsSuper():::Mark this node as being a SuperProperty access.:::
BinaryNode#isComparison():::Returns true if the node is a comparison operation (either equality, inequality, or relational).:::switch->tokenType->return->return
BinaryNode#isRelational():::Returns true if the node is a relational operation (less than (or equals), greater than (or equals)).:::switch->tokenType->return->return
BinaryNode#isLogical():::Returns true if the node is a logical operation.:::return->tokenType->isLogical
BinaryNode#isLogical(TokenType):::Returns true if the token type represents a logical operation.:::switch->return->return
BinaryNode#getWidestOperandType():::Return the widest possible operand type for this operation.:::switch->tokenType->return->return->if->isComparison->return->return->getWidestOperationType
BinaryNode#getWidestOperationType()::: binary node get widest operation type:::switch->tokenType->lhsType->lhs->getType->rhsType->rhs->getType->if->return->else->if->isString->isString->return->widestOperandType->Type->booleanToInt->undefinedToNumber->booleanToInt->undefinedToNumber->widest->if->widestOperandType->isNumeric->return->return->return->return->return->lhsType->lhs->getType->rhsType->rhs->getType->if->return->return->return->return->rhs->getType->return->return->rhs->getType->return->Type->lhs->getType->rhs->getType->widestReturnType->if->isComparison->return->return
BinaryNode#isString(Type)::: binary node is string:::return
BinaryNode#booleanToInt(Type)::: binary node boolean to int:::return
BinaryNode#undefinedToNumber(Type)::: binary node undefined to number:::return
BinaryNode#isAssignment():::Check if this node is an assignment:::switch->tokenType->return->return
BinaryNode#isSelfModifying()::: binary node is self modifying:::return->isAssignment->isTokenType
BinaryNode#getAssignmentDest()::: binary node get assignment dest:::return->isAssignment->lhs
BinaryNode#setAssignmentDest(Expression)::: binary node set assignment dest:::return->setLHS
BinaryNode#getAssignmentSource()::: binary node get assignment source:::return->rhs
BinaryNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterBinaryNode->return->visitor->lhs->accept->setLHS->rhs->accept->setRHS->leaveBinaryNode->return
BinaryNode#isLocal()::: binary node is local:::switch->tokenType->return->lhs->isLocal->lhs->getType->isJSPrimitive->rhs->isLocal->rhs->getType->isJSPrimitive->return->lhs->isLocal->lhs->getType->isJSPrimitive->rhs->isLocal->rhs->getType->isJSPrimitive->return->lhs->isLocal->rhs->isLocal->return
BinaryNode#isAlwaysFalse()::: binary node is always false:::switch->tokenType->return->rhs->isAlwaysFalse->return
BinaryNode#isAlwaysTrue()::: binary node is always true:::switch->tokenType->return->rhs->isAlwaysTrue->return
BinaryNode#toString(StringBuilder, boolean)::: binary node to string:::tokenType->tokenType->lhsParen->tokenType->lhs->tokenType->needsParens->rhsParen->tokenType->rhs->tokenType->needsParens->if->sb->append->lhs->toString->if->sb->append->sb->append->switch->sb->append->break->sb->append->break->sb->tokenType->getName->append->break->if->isOptimistic->sb->append->sb->append->if->sb->append->rhs->toString->if->sb->append
BinaryNode#lhs():::Get the left hand side expression for this node:::return
BinaryNode#rhs():::Get the right hand side expression for this node:::return
BinaryNode#setLHS(Expression):::Set the left hand side expression for this node:::if->return->return->new->BinaryNode
BinaryNode#setRHS(Expression):::Set the right hand side expression for this node:::if->return->return->new->BinaryNode
BinaryNode#setOperands(Expression, Expression):::Set both the left and the right hand side expression for this node:::if->return->return->new->BinaryNode
BinaryNode#getProgramPoint()::: binary node get program point:::return
BinaryNode#canBeOptimistic()::: binary node can be optimistic:::return->isTokenType->getMostOptimisticType->getMostPessimisticType
BinaryNode#setProgramPoint(int)::: binary node set program point:::if->return->return->new->BinaryNode
BinaryNode#getMostOptimisticType()::: binary node get most optimistic type:::tokenType->tokenType->if->return->else->if->CAN_OVERFLOW->contains->return->return->getMostPessimisticType
BinaryNode#getMostPessimisticType()::: binary node get most pessimistic type:::return->getWidestOperationType
BinaryNode#isOptimisticUndecidedType():::Returns true if the node has the optimistic type of the node is not yet decided:::return
BinaryNode#getType()::: binary node get type:::if->getTypeUncached->return
BinaryNode#getTypeUncached()::: binary node get type uncached:::if->return->lhs->getType->rhs->getType->decideType->widest->getWidestOperationType->if->return->if->tokenType->tokenType->return->return->Type->Type->Type->lhs->getType->rhs->getType->widest->widest->narrowest
BinaryNode#decideType(Type, Type)::: binary node decide type:::if->isString->isString->return->widest->Type->booleanToInt->undefinedToNumber->booleanToInt->undefinedToNumber->widest->return->widest->isObject
BinaryNode#decideType():::If the node is a node representing an add operation and has #isOptimisticUndecidedType() optimistic undecided type, decides its type:::return->lhs->getType->rhs->getType->decideType->setType
BinaryNode#setType(Type)::: binary node set type:::if->return->return->new->BinaryNode
Block#isGlobalScope():::Is this block the outermost eager global scope - i.e:::return->getFlag
Block#hasSymbols():::Returns true if this block defines any symbols.:::return->symbols->isEmpty
Block#replaceSymbols(LexicalContext, Map):::Replaces symbols defined in this block with different symbols:::if->symbols->isEmpty->return->newSymbols->new->LinkedHashMap<>->foreach->newSymbols->entrySet->newSymbol->replacements->entry->getValue->get->entry->setValue->return->Node->new->Block->replaceInLexicalContext
Block#copyWithNewSymbols():::Returns a copy of this block with a shallow copy of the symbol table.:::return->new->LinkedHashMap<>->new->Block
Block#ensureUniqueLabels(LexicalContext)::: block ensure unique labels:::return->Node->new->Block->replaceInLexicalContext
Block#accept(LexicalContext, NodeVisitor):::Assist in IR navigation.:::if->visitor->enterBlock->return->visitor->Node->accept->setStatements->leaveBlock->return
Block#getSymbols():::Get a copy of the list for all the symbols defined in this block:::return->symbols->isEmpty->Collections->emptyList->Collections->symbols->values->new->ArrayList<>->unmodifiableList
Block#getExistingSymbol(String):::Retrieves an existing symbol defined in the current block.:::return->symbols->get
Block#isCatchBlock():::Test if this block represents a catch block in a try statement:::return->statements->size->statements->get
Block#toString(StringBuilder, boolean)::: block to string:::foreach->statement->toString->sb->append
Block#printSymbols(PrintWriter):::Print symbols in block in alphabetical order, sorted on name Used for debugging, see the --print-symbols flag:::values->symbols->values->new->ArrayList<>->Collections->new->Comparator<Symbol>->sort->foreach->symbol->print->return->values->isEmpty
Block#setIsTerminal(LexicalContext, boolean):::Tag block as terminal or non terminal:::return->setFlag->clearFlag
Block#getFlags()::: block get flags:::return
Block#isTerminal():::Is this a terminal block, i.e:::return->getFlag->getFlag
Block#getEntryLabel():::Get the entry label for this block:::return
Block#getBreakLabel()::: block get break label:::return
Block#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: block set local variable conversion:::if->return->return->Node->new->Block->replaceInLexicalContext
Block#getLocalVariableConversion()::: block get local variable conversion:::return
Block#getStatements():::Get the list of statements in this block:::return->Collections->unmodifiableList
Block#getStatementCount():::Returns the number of statements in the block.:::return->statements->size
Block#getFirstStatementLineNumber():::Returns the line number of the first statement in the block.:::if->statements->isEmpty->return->return->statements->get->getLineNumber
Block#getLastStatement():::Returns the last statement in the block.:::return->statements->isEmpty->statements->statements->size->get
Block#setStatements(LexicalContext, List):::Reset the statement list for this block:::if->return->lastFinish->if->statements->isEmpty->statements->statements->size->get->getFinish->return->Node->Math->max->new->Block->replaceInLexicalContext
Block#putSymbol(Symbol):::Add or overwrite an existing symbol in the block:::symbols->symbol->getName->put
Block#needsScope():::Check whether scope is necessary for this Block:::return
Block#isSynthetic():::Check whether this block is synthetic or not.:::return
Block#setFlags(LexicalContext, int)::: block set flags:::if->return->return->Node->new->Block->replaceInLexicalContext
Block#clearFlag(LexicalContext, int)::: block clear flag:::return->setFlags
Block#setFlag(LexicalContext, int)::: block set flag:::return->setFlags
Block#getFlag(int)::: block get flag:::return
Block#setNeedsScope(LexicalContext):::Set the needs scope flag.:::if->needsScope->return->return->Node->new->Block->replaceInLexicalContext
Block#nextSlot():::Computationally determine the next slot for this block, indexed from 0:::next->foreach->getSymbols->if->symbol->hasSlot->symbol->slotCount->return
Block#providesScopeCreator():::Determine whether this block needs to provide its scope object creator for use by its child nodes:::return->needsScope->isSynthetic->getLastStatement->getLastStatement->needsScopeCreator
Block#isBreakableWithoutLabel()::: block is breakable without label:::return
Block#getLabels()::: block get labels:::return->Collections->Arrays->asList->unmodifiableList
Block#accept(NodeVisitor)::: block accept:::return->Acceptor->accept
Block#isFunctionBody():::Checks if this is a function body.:::return->getFlag
Block#isParameterBlock():::Checks if this is a parameter block.:::return->getFlag
Block#isSwitchBlock():::Checks whether this is a switch block.:::return->getFlag
BlockLexicalContext#push(T)::: block lexical context push:::pushed->super->push->if->sstack->new->ArrayList<Statement>->push->return
BlockLexicalContext#popStatements():::Get the statement list from the stack, possibly filtered:::return->sstack->pop
BlockLexicalContext#afterSetStatements(Block):::Override this method to perform some additional processing on the block after its statements have been set:::return
BlockLexicalContext#pop(T)::: block lexical context pop:::expected->if->newStatements->popStatements->setStatements->afterSetStatements->if->sstack->isEmpty->sstack->peek->lastStatement->return->super->pop
BlockLexicalContext#appendStatement(Statement):::Append a statement to the block being generated:::sstack->peek->add
BlockLexicalContext#prependStatement(Statement):::Prepend a statement to the block being generated:::sstack->peek->add->return
BlockLexicalContext#prependStatements(List):::Prepend a list of statement to the block being generated:::sstack->peek->addAll
BlockLexicalContext#getLastStatement():::Get the last statement that was emitted into a block:::return
BlockLexicalContext#lastStatement(List)::: block lexical context last statement:::s->statements->size->return->statements->get
BlockStatement#createReplacement(Statement, List):::Use this method to create a block statement meant to replace a single statement.:::return->stmt->getFinish->createReplacement
BlockStatement#createReplacement(Statement, int, List):::Use this method to create a block statement meant to replace a single statement.:::return->stmt->getLineNumber->stmt->getToken->new->Block->new->BlockStatement
BlockStatement#isTerminal()::: block statement is terminal:::return->block->isTerminal
BlockStatement#isSynthetic():::Tells if this is a synthetic block statement or not.:::return->block->isSynthetic
BlockStatement#accept(NodeVisitor)::: block statement accept:::if->visitor->enterBlockStatement->return->visitor->block->accept->setBlock->leaveBlockStatement->return
BlockStatement#toString(StringBuilder, boolean)::: block statement to string:::block->toString
BlockStatement#getBlock():::Return the block to be executed:::return
BlockStatement#setBlock(Block):::Reset the block to be executed:::if->return->return->new->BlockStatement
BreakableNode#ensureUniqueLabels(LexicalContext):::Ensure that any labels in this breakable node are unique so that new jumps won't go to old parts of the tree:::
BreakableNode#isBreakableWithoutLabel():::Check whether this can be broken out from without using a label, e.g:::
BreakableNode#getBreakLabel():::Return the break label, i.e:::
BreakableStatement#isBreakableWithoutLabel():::Check whether this can be broken out from without using a label, e.g:::return
BreakableStatement#getBreakLabel():::Return the break label, i.e:::return
BreakableStatement#getLabels():::Return the labels associated with this node:::return->Collections->Collections->singletonList->unmodifiableList
BreakableStatement#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: breakable statement set local variable conversion:::if->return->return->setLocalVariableConversionChanged
BreakableStatement#getLocalVariableConversion()::: breakable statement get local variable conversion:::return
BreakableStatement#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)::: breakable statement set local variable conversion changed:::
BreakNode#accept(NodeVisitor)::: break node accept:::if->visitor->enterBreakNode->return->visitor->leaveBreakNode->return
BreakNode#createNewJumpStatement(LocalVariableConversion)::: break node create new jump statement:::return->new->BreakNode
BreakNode#getStatementName()::: break node get statement name:::return
BreakNode#getTarget(LexicalContext)::: break node get target:::return->lc->getLabelName->getBreakable
BreakNode#getTargetLabel(BreakableNode)::: break node get target label:::return->target->getBreakLabel
CallNode.EvalArgs#getArgs():::Return the code that is to be eval:ed by this eval function:::return->Collections->unmodifiableList
CallNode.EvalArgs#setArgs(List)::: eval args set args:::if->return->return->new->EvalArgs
CallNode.EvalArgs#getLocation():::Get the human readable location for this eval call:::return
CallNode#getLineNumber():::Returns the line number.:::return
CallNode#getType()::: call node get type:::return
CallNode#setType(Type)::: call node set type:::if->return->return->new->CallNode
CallNode#accept(LexicalContext, NodeVisitor):::Assist in IR navigation.:::if->visitor->enterCallNode->newCallNode->visitor->function->accept->setFunction->Node->accept->setArgs->evalArgs->Node->evalArgs->getArgs->accept->setArgs->setEvalArgs->leaveCallNode->if->return->Node->replaceInLexicalContext->return
CallNode#toString(StringBuilder, boolean)::: call node to string:::if->optimisticTypeToString->fsb->new->StringBuilder->function->toString->if->isApplyToCall->sb->fsb->toString->replace->append->else->sb->append->sb->append->first->foreach->if->sb->append->else->arg->toString->sb->append
CallNode#getArgs():::Get the arguments for the call:::return->Collections->unmodifiableList
CallNode#setArgs(List):::Reset the arguments for the call:::if->return->return->new->CallNode
CallNode#getEvalArgs():::If this call is an eval call, get its EvalArgs structure:::return
CallNode#setEvalArgs(EvalArgs):::Set the EvalArgs structure for this call, if it has been determined it is an eval:::if->return->return->new->CallNode
CallNode#isEval():::Check if this call is a call to eval:::return
CallNode#isApplyToCall():::Is this an apply call that we optimistically should try to turn into a call instead:::return
CallNode#setIsApplyToCall():::Flag this call node as one that tries to call call instead of apply:::return->setFlags
CallNode#getFunction():::Return the function expression that this call invokes:::return
CallNode#setFunction(Expression):::Reset the function expression that this call invokes:::if->return->return->new->CallNode
CallNode#isNew():::Check if this call is a new operation:::return
CallNode#setFlags(int)::: call node set flags:::if->return->return->new->CallNode
CallNode#getProgramPoint()::: call node get program point:::return
CallNode#setProgramPoint(int)::: call node set program point:::if->return->return->new->CallNode
CallNode#getMostOptimisticType()::: call node get most optimistic type:::return
CallNode#getMostPessimisticType()::: call node get most pessimistic type:::return
CallNode#canBeOptimistic()::: call node can be optimistic:::return
CaseNode#isTerminal():::Is this a terminal case node, i.e:::return->body->isTerminal
CaseNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterCaseNode->newTest->test->accept->newBody->body->accept->return->visitor->setTest->setBody->leaveCaseNode->return
CaseNode#toString(StringBuilder, boolean)::: case node to string:::if->sb->append->test->toString->sb->append->else->sb->append
CaseNode#getBody():::Get the body for this case node:::return
CaseNode#getEntry():::Get the entry label for this case node:::return
CaseNode#getTest():::Get the test expression for this case node:::return
CaseNode#setTest(Expression):::Reset the test expression for this case node:::if->return->return->new->CaseNode
CaseNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: case node set local variable conversion:::if->return->return->new->CaseNode
CaseNode#getLocalVariableConversion()::: case node get local variable conversion:::return
CaseNode#setBody(Block)::: case node set body:::if->return->return->new->CaseNode
CaseNode#getLabels()::: case node get labels:::return->Collections->Collections->singletonList->unmodifiableList
CatchNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterCatchNode->return->visitor->exception->accept->setException->exceptionCondition->accept->setExceptionCondition->body->accept->setBody->leaveCatchNode->return
CatchNode#isTerminal()::: catch node is terminal:::return->body->isTerminal
CatchNode#toString(StringBuilder, boolean)::: catch node to string:::sb->append->exception->toString->if->sb->append->exceptionCondition->toString->sb->append
CatchNode#getException():::Get the binding pattern representing the exception thrown:::return
CatchNode#getExceptionIdentifier():::Get the identifier representing the exception thrown:::return
CatchNode#getExceptionCondition():::Get the exception condition for this catch block:::return
CatchNode#setExceptionCondition(Expression):::Reset the exception condition for this catch block:::if->return->return->new->CatchNode
CatchNode#getBody():::Get the body for this catch block:::return
CatchNode#setException(Expression):::Resets the exception of a catch block:::if->return->if->throw->new->IllegalArgumentException->return->new->CatchNode
CatchNode#setBody(Block)::: catch node set body:::if->return->return->new->CatchNode
CatchNode#isSyntheticRethrow():::Is this catch block a non-JavaScript constructor, for example created as part of the rethrow mechanism of a finally block in Lower? Then we just pass the exception on and need not unwrap whatever is in the ECMAException object catch symbol:::return
ClassNode#getIdent():::Class identifier:::return
ClassNode#getClassHeritage():::The expression of the extends clause:::return
ClassNode#getConstructor():::Get the constructor method definition.:::return
ClassNode#getClassElements():::Get method definitions except the constructor.:::return->Collections->unmodifiableList
ClassNode#isStatement():::Returns if this class was a statement or an expression:::return
ClassNode#getLineNumber():::Returns the line number.:::return
ClassNode#getType()::: class node get type:::return
ClassNode#accept(NodeVisitor)::: class node accept:::if->visitor->enterClassNode->return->visitor->leaveClassNode->return
ClassNode#toString(StringBuilder, boolean)::: class node to string:::sb->append->if->sb->append->ident->toString->if->sb->append->classHeritage->toString->sb->append->if->constructor->toString->foreach->sb->append->classElement->toString->sb->append
CompileUnitHolder#getCompileUnit():::Return the compile unit held by this instance:::
ContinueNode#accept(NodeVisitor)::: continue node accept:::if->visitor->enterContinueNode->return->visitor->leaveContinueNode->return
ContinueNode#createNewJumpStatement(LocalVariableConversion)::: continue node create new jump statement:::return->new->ContinueNode
ContinueNode#getStatementName()::: continue node get statement name:::return
ContinueNode#getTarget(LexicalContext)::: continue node get target:::return->lc->getLabelName->getContinueTo
ContinueNode#getTargetLabel(BreakableNode)::: continue node get target label:::return->getContinueLabel
DebuggerNode#accept(NodeVisitor)::: debugger node accept:::if->visitor->enterDebuggerNode->return->visitor->leaveDebuggerNode->return
DebuggerNode#toString(StringBuilder, boolean)::: debugger node to string:::sb->append
EmptyNode#accept(NodeVisitor)::: empty node accept:::if->visitor->enterEmptyNode->return->visitor->leaveEmptyNode->return
EmptyNode#toString(StringBuilder, boolean)::: empty node to string:::sb->append
ErrorNode#getType()::: error node get type:::return
ErrorNode#accept(NodeVisitor)::: error node accept:::if->visitor->enterErrorNode->return->visitor->leaveErrorNode->return
ErrorNode#toString(StringBuilder, boolean)::: error node to string:::sb->append
Expression#getType():::Returns the type of the expression.:::
Expression#isLocal():::Returns true if this expression depends exclusively on state that is constant or local to the currently running function and thus inaccessible to other functions:::return
Expression#isSelfModifying():::Is this a self modifying assignment?:::return
Expression#getWidestOperationType():::Returns widest operation type of this operation.:::return
Expression#isOptimistic():::Returns true if the type of this expression is narrower than its widest operation type (thus, it is optimistically typed).:::return->getType->getWidestOperationType->narrowerThan
Expression#optimisticTypeToString(StringBuilder)::: expression optimistic type to string:::isOptimistic->optimisticTypeToString
Expression#optimisticTypeToString(StringBuilder, boolean)::: expression optimistic type to string:::sb->append->type->getType->desc->type->getDescriptor->sb->desc->desc->length->charAt->append->if->isOptimistic->sb->append->pp->getProgramPoint->if->UnwarrantedOptimismException->isValid->sb->append->append->sb->append
Expression#isAlwaysFalse():::Returns true if the runtime value of this expression is always false when converted to boolean as per ECMAScript ToBoolean conversion:::return
Expression#isAlwaysTrue():::Returns true if the runtime value of this expression is always true when converted to boolean as per ECMAScript ToBoolean conversion:::return
Expression#isAlwaysFalse(Expression):::Returns true if the expression is not null and #isAlwaysFalse().:::return->test->isAlwaysFalse
Expression#isAlwaysTrue(Expression):::Returns true if the expression is null or #isAlwaysTrue():::return->test->isAlwaysTrue
ExpressionList#getExpressions():::Get the list of expressions.:::return->Collections->unmodifiableList
ExpressionList#accept(NodeVisitor)::: expression list accept:::throw->new->UnsupportedOperationException
ExpressionList#getType()::: expression list get type:::return
ExpressionList#toString(StringBuilder, boolean)::: expression list to string:::sb->append->first->foreach->if->else->sb->append->expression->toString->sb->append
ExpressionStatement#accept(NodeVisitor)::: expression statement accept:::if->visitor->enterExpressionStatement->return->visitor->expression->accept->setExpression->leaveExpressionStatement->return
ExpressionStatement#toString(StringBuilder, boolean)::: expression statement to string:::expression->toString
ExpressionStatement#getExpression():::Return the expression to be executed:::return
ExpressionStatement#destructuringDeclarationType():::Return declaration type if this expression statement is a destructuring declaration:::return
ExpressionStatement#setExpression(Expression):::Reset the expression to be executed:::if->return->return->new->ExpressionStatement
Flags#getFlags():::Get all flags of a LexicalContextNode:::
Flags#getFlag(int):::Check if a flag is set in a lexical context node:::
Flags#clearFlag(LexicalContext, int):::Clear a flag of a LexicalContextNode:::
Flags#setFlag(LexicalContext, int):::Set a flag of a LexicalContextNode:::
Flags#setFlags(LexicalContext, int):::Set all flags of a LexicalContextNode, overwriting previous flags:::
ForNode#ensureUniqueLabels(LexicalContext)::: for node ensure unique labels:::return->Node->new->ForNode->replaceInLexicalContext
ForNode#accept(LexicalContext, NodeVisitor)::: for node accept:::if->visitor->enterForNode->return->visitor->init->accept->setInit->test->accept->setTest->modify->accept->setModify->body->accept->setBody->leaveForNode->return
ForNode#toString(StringBuilder, boolean)::: for node to string:::sb->append->LocalVariableConversion->toString->append->if->isForIn->init->toString->sb->append->modify->toString->else->if->isForOf->init->toString->sb->append->modify->toString->else->if->init->toString->sb->append->if->test->toString->sb->append->if->modify->toString->sb->append
ForNode#hasGoto()::: for node has goto:::return->isForInOrOf
ForNode#mustEnter()::: for node must enter:::if->isForInOrOf->return->return
ForNode#getInit():::Get the initialization expression for this for loop:::return
ForNode#setInit(LexicalContext, Expression):::Reset the initialization expression for this for loop:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#isForIn():::Is this a for in construct rather than a standard init;condition;modification one:::return
ForNode#isForOf():::Is this a for-of loop?:::return
ForNode#isForInOrOf():::Is this a for-in or for-of statement?:::return->isForIn->isForOf
ForNode#isForEach():::Is this a for each construct, known from e.g:::return
ForNode#getIterator():::If this is a for in or for each construct, there is an iterator symbol:::return
ForNode#setIterator(LexicalContext, Symbol):::Assign an iterator symbol to this ForNode:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#getModify():::Get the modification expression for this ForNode:::return
ForNode#setModify(LexicalContext, JoinPredecessorExpression):::Reset the modification expression for this ForNode:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#setTest(LexicalContext, JoinPredecessorExpression)::: for node set test:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#getBody()::: for node get body:::return
ForNode#setBody(LexicalContext, Block)::: for node set body:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#setControlFlowEscapes(LexicalContext, boolean)::: for node set control flow escapes:::if->return->return->Node->new->ForNode->replaceInLexicalContext
ForNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)::: for node set local variable conversion changed:::return->Node->new->ForNode->replaceInLexicalContext
ForNode#hasPerIterationScope()::: for node has per iteration scope:::return
ForNode#needsScopeCreator():::Returns true if this for-node needs the scope creator of its containing block to create per-iteration scope:::return->isForInOrOf->hasPerIterationScope
FunctionCall#isFunction():::Returns true if the value of this expression will be treated as a function and immediately invoked.:::
FunctionNode#accept(LexicalContext, NodeVisitor)::: function node accept:::if->visitor->enterFunctionNode->return->visitor->body->accept->setBody->leaveFunctionNode->return
FunctionNode#visitParameters(NodeVisitor):::Visits the parameter nodes of this function:::return->Node->accept
FunctionNode#getCallSiteFlags():::Get additional callsite flags to be used specific to this function.:::callsiteFlags->if->getFlag->if->return->if->getDebugFlag->if->getDebugFlag->if->getDebugFlag->if->getDebugFlag->return
FunctionNode#getSource():::Get the source for this function:::return
FunctionNode#initializeDeserialized(Source, Namespace):::Sets the source and namespace for this function:::if->throw->new->IllegalArgumentException->else->if->return->else->if->throw->new->IllegalStateException->return->new->FunctionNode
FunctionNode#getId():::Get the unique ID for this function within the script file.:::return->isProgram->Token->descPosition
FunctionNode#getSourceName():::get source name - sourceURL or name derived from Source.:::return->getSourceName
FunctionNode#getSourceName(Source):::Static source name getter:::explicitURL->source->getExplicitURL->return->source->getName
FunctionNode#getDirectiveFlag(String):::Function to parse nashorn per-function extension directive comments.:::switch->return->return->return->return->return->return->return->return->return->return
FunctionNode#getLineNumber():::Returns the line number.:::return
FunctionNode#uniqueName(String):::Create a unique name in the namespace of this FunctionNode:::return->namespace->uniqueName
FunctionNode#toString(StringBuilder, boolean)::: function node to string:::sb->append->append->append->append->sb->append->if->sb->append->ident->toString->sb->append->for->iter->parameters->iterator->iter->hasNext->sb->append
FunctionNode#getFlags()::: function node get flags:::return
FunctionNode#getFlag(int)::: function node get flag:::return
FunctionNode#setFlags(LexicalContext, int)::: function node set flags:::if->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#clearFlag(LexicalContext, int)::: function node clear flag:::return->setFlags
FunctionNode#setFlag(LexicalContext, int)::: function node set flag:::return->setFlags
FunctionNode#getDebugFlags():::Returns the debug flags for this function.:::return
FunctionNode#getDebugFlag(int):::Checks whether a debug flag is set for this function.:::return
FunctionNode#isProgram():::Returns true if the function is the top-level program.:::return->getFlag
FunctionNode#canBeDeoptimized():::Returns true if the function contains at least one optimistic operation (and thus can be deoptimized).:::return->getFlag
FunctionNode#hasEval():::Check if this function has a call expression for the identifier "eval" (that is, eval(...)).:::return->getFlag
FunctionNode#hasNestedEval():::Returns true if a function nested (directly or transitively) within this function #hasEval().:::return->getFlag
FunctionNode#getFirstToken():::Get the first token for this function:::return
FunctionNode#hasDeclaredFunctions():::Check whether this function has nested function declarations:::return->getFlag
FunctionNode#needsCallee():::Check if this function's generated Java method needs a callee parameter:::return->needsParentScope->usesSelfSymbol->isSplit->needsArguments->hasApplyToCallSpecialization->isStrict
FunctionNode#usesThis():::Return true if this function makes use of the this object.:::return->getFlag
FunctionNode#hasApplyToCallSpecialization():::Return true if function contains an apply to call transform:::return->getFlag
FunctionNode#getIdent():::Get the identifier for this function, this is its symbol.:::return
FunctionNode#getBody():::Get the function body:::return
FunctionNode#setBody(LexicalContext, Block):::Reset the function body:::if->return->return->Node->body->needsScope->new->FunctionNode->replaceInLexicalContext
FunctionNode#isVarArg():::Does this function's method needs to be variable arity (gather all script-declared parameters in a final Object[] parameter:::return->needsArguments->parameters->size
FunctionNode#inDynamicContext():::Was this function declared in a dynamic context, i.e:::return->getFlag
FunctionNode#needsDynamicScope():::Check whether a function would need dynamic scope, which is does if it has evals and isn't strict.:::return->hasEval->isStrict
FunctionNode#setInDynamicContext(LexicalContext):::Flag this function as declared in a dynamic context:::return->setFlag
FunctionNode#needsArguments():::Returns true if this function needs to have an Arguments object defined as a local variable named "arguments":::return->getFlag->getFlag->isProgram
FunctionNode#needsParentScope():::Returns true if this function needs access to its parent scope:::return->getFlag
FunctionNode#setThisProperties(LexicalContext, int):::Set the number of properties assigned to the this object in this function.:::if->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#getThisProperties():::Get the number of properties assigned to the this object in this function.:::return
FunctionNode#hasScopeBlock():::Returns true if any of the blocks in this function create their own scope.:::return->getFlag
FunctionNode#getKind():::Return the kind of this function:::return
FunctionNode#getLastToken():::Return the last token for this function's code:::return
FunctionNode#getEndParserState():::Returns the end parser state for this function.:::return
FunctionNode#getName():::Get the name of this function:::return
FunctionNode#setName(LexicalContext, String):::Set the internal name for this function:::if->equals->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#allVarsInScope():::Check if this function should have all its variables in its own scope:::return->getFlag
FunctionNode#isSplit():::Checks if this function is split into several smaller fragments.:::return->getFlag
FunctionNode#getParameters():::Get the parameters to this function:::return->Collections->unmodifiableList
FunctionNode#getParameterExpressions():::Get the ES6 style parameter expressions of this function:::return
FunctionNode#getNumOfParams():::Return the number of parameters to this function:::return->parameters->size
FunctionNode#getParameter(int):::Returns the identifier for a named parameter at the specified position in this function's parameter list.:::return->parameters->get
FunctionNode#setParameters(LexicalContext, List):::Reset the compile unit used to compile this function:::if->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#isDeclared():::Check if this function is created as a function declaration (as opposed to function expression):::return->getFlag
FunctionNode#isAnonymous():::Check if this function is anonymous:::return->getFlag
FunctionNode#usesSelfSymbol():::Does this function use its self symbol - this is needed only for self-referencing named function expressions:::return->getFlag
FunctionNode#isNamedFunctionExpression():::Returns true if this is a named function expression (that is, it isn't a declared function, it isn't an anonymous function expression, and it isn't a program).:::return->getFlag
FunctionNode#getType()::: function node get type:::return
FunctionNode#getWidestOperationType()::: function node get widest operation type:::return
FunctionNode#getReturnType():::Get the return type for this function:::return
FunctionNode#setReturnType(LexicalContext, Type):::Set the function return type:::type->returnType->isObject->if->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#isStrict():::Check if the function is generated in strict mode:::return->getFlag
FunctionNode#isCached():::Returns true if this function node has been cached.:::return->getFlag
FunctionNode#setCached(LexicalContext):::Mark this function node as having been cached.:::return->setFlag
FunctionNode#isStrong():::Checks if the function is generated in strong mode.:::return->getFlag
FunctionNode#isMethod():::Checks if this is an ES6 method.:::return->getFlag
FunctionNode#usesSuper():::Checks if this function uses the ES6 super binding.:::return->getFlag
FunctionNode#hasDirectSuper():::Checks if this function directly uses the super binding.:::return->getFlag
FunctionNode#isClassConstructor():::Checks if this is an ES6 class constructor.:::return->getFlag
FunctionNode#isSubclassConstructor():::Checks if this is an ES6 subclass constructor.:::return->getFlag
FunctionNode#usesNewTarget():::Checks if this function uses the ES6 new-targert.:::return->getFlag
FunctionNode#isModule():::Checks if this is an ES6 module.:::return
FunctionNode#getModule():::Returns the functions's ES6 module.:::return
FunctionNode#getCompileUnit():::Get the compile unit used to compile this function:::return
FunctionNode#setCompileUnit(LexicalContext, CompileUnit):::Reset the compile unit used to compile this function:::if->return->return->Node->new->FunctionNode->replaceInLexicalContext
FunctionNode#compilerConstant(CompilerConstants):::Get the symbol for a compiler constant, or null if not available (yet):::return->body->cc->symbolName->getExistingSymbol
FunctionNode#getRootClass():::Get the root class that this function node compiles to:::return
FunctionNode#setRootClass(LexicalContext, Class):::Reset the root class that this function is compiled to:::if->return->return->Node->new->FunctionNode->replaceInLexicalContext
GetSplitState#getType()::: get split state get type:::return
GetSplitState#accept(NodeVisitor)::: get split state accept:::return->visitor->enterGetSplitState->visitor->leaveGetSplitState
GetSplitState#toString(StringBuilder, boolean)::: get split state to string:::if->sb->append->sb->symbolName->append->append->name->append->append
GetSplitState#readResolve()::: get split state read resolve:::return
IdentNode#createInternalIdentifier(Symbol):::Creates an identifier for the symbol:::return->Token->toDesc->symbol->getName->new->IdentNode->setSymbol
IdentNode#getType()::: ident node get type:::if->return->else->if->symbol->isScope->return->return
IdentNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterIdentNode->return->visitor->leaveIdentNode->return
IdentNode#toString(StringBuilder, boolean)::: ident node to string:::if->symbol->hasSlot->optimisticTypeToString->sb->append
IdentNode#getName():::Get the name of the identifier:::return
IdentNode#getPropertyName()::: ident node get property name:::return->getName
IdentNode#isLocal()::: ident node is local:::return->getSymbol->isScope
IdentNode#getSymbol():::Return the Symbol the compiler has assigned to this identifier:::return
IdentNode#setSymbol(Symbol):::Assign a symbol to this identifier:::if->return->newIdent->clone->return
IdentNode#isPropertyName():::Check if this IdentNode is a property name:::return
IdentNode#setIsPropertyName():::Flag this IdentNode as a property name:::if->isPropertyName->return->return->new->IdentNode
IdentNode#isFutureStrictName():::Check if this IdentNode is a future strict name:::return
IdentNode#setIsFutureStrictName():::Flag this IdentNode as a future strict name:::if->isFutureStrictName->return->return->new->IdentNode
IdentNode#isInitializedHere():::Helper function for local def analysis.:::return
IdentNode#setIsInitializedHere():::Flag IdentNode to be initialized on creation:::if->isInitializedHere->return->return->new->IdentNode
IdentNode#isDead():::Is this a LET or CONST identifier used before its declaration?:::return
IdentNode#markDead():::Flag this IdentNode as a LET or CONST identifier used before its declaration.:::return->new->IdentNode
IdentNode#isDeclaredHere():::Is this IdentNode declared here?:::return
IdentNode#setIsDeclaredHere():::Flag this IdentNode as being declared here.:::if->isDeclaredHere->return->return->new->IdentNode
IdentNode#isCompileTimePropertyName():::Check if the name of this IdentNode is same as that of a compile-time property (currently __DIR__, __FILE__, and __LINE__).:::return->name->__DIR__->symbolName->equals->name->__FILE__->symbolName->equals->name->__LINE__->symbolName->equals
IdentNode#isFunction()::: ident node is function:::return
IdentNode#setType(Type)::: ident node set type:::if->return->return->new->IdentNode
IdentNode#setIsFunction():::Mark this node as being the callee operand of a CallNode.:::if->isFunction->return->return->new->IdentNode
IdentNode#setIsNotFunction():::Mark this node as not being the callee operand of a CallNode.:::if->isFunction->return->return->new->IdentNode
IdentNode#getProgramPoint()::: ident node get program point:::return
IdentNode#setProgramPoint(int)::: ident node set program point:::if->return->return->new->IdentNode
IdentNode#getMostOptimisticType()::: ident node get most optimistic type:::return
IdentNode#getMostPessimisticType()::: ident node get most pessimistic type:::return
IdentNode#canBeOptimistic()::: ident node can be optimistic:::return
IdentNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: ident node set local variable conversion:::if->return->return->new->IdentNode
IdentNode#isInternal():::Is this an internal symbol, i.e:::return->name->charAt
IdentNode#getLocalVariableConversion()::: ident node get local variable conversion:::return
IdentNode#isDirectSuper():::Checks if this is a direct super identifier:::return
IdentNode#setIsDirectSuper():::Return a new identifier with the direct super flag set.:::return->new->IdentNode
IdentNode#isRestParameter():::Checks if this is a rest parameter:::return
IdentNode#setIsRestParameter():::Return a new identifier with the rest parameter flag set.:::return->new->IdentNode
IdentNode#isProtoPropertyName():::Checks if this is a proto property name.:::return
IdentNode#setIsProtoPropertyName():::Return a new identifier with the proto property name flag set.:::return->new->IdentNode
IdentNode#isDefaultParameter():::Checks whether this is a default parameter.:::return
IdentNode#setIsDefaultParameter():::Return a new identifier with the default parameter flag set.:::return->new->IdentNode
IdentNode#isDestructuredParameter():::Checks whether this is a destructured parameter.:::return
IdentNode#setIsDestructuredParameter():::Return a new identifier with the destructured parameter flag set.:::return->new->IdentNode
IdentNode#containsEscapes():::Checks whether the source code for this ident contains a unicode escape sequence by comparing the length of its name with its length in source code.:::return->Token->getToken->descLength->name->length
IfNode#isTerminal()::: if node is terminal:::return->pass->isTerminal->fail->isTerminal
IfNode#accept(NodeVisitor)::: if node accept:::if->visitor->enterIfNode->return->visitor->test->accept->setTest->pass->accept->setPass->fail->accept->setFail->leaveIfNode->return
IfNode#toString(StringBuilder, boolean)::: if node to string:::sb->append->test->toString->sb->append
IfNode#getFail():::Get the else block of this IfNode:::return
IfNode#setFail(Block)::: if node set fail:::if->return->return->new->IfNode
IfNode#getPass():::Get the then block for this IfNode:::return
IfNode#setPass(Block)::: if node set pass:::if->return->return->new->IfNode
IfNode#getTest():::Get the test expression for this IfNode:::return
IfNode#setTest(Expression):::Reset the test expression for this IfNode:::if->return->return->new->IfNode
IfNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: if node set local variable conversion:::if->return->return->new->IfNode
IfNode#getLocalVariableConversion()::: if node get local variable conversion:::return
IndexNode#accept(NodeVisitor)::: index node accept:::if->visitor->enterIndexNode->return->visitor->base->accept->setBase->index->accept->setIndex->leaveIndexNode->return
IndexNode#toString(StringBuilder, boolean)::: index node to string:::needsParen->tokenType->base->tokenType->needsParens->if->sb->append->if->optimisticTypeToString->base->toString->if->sb->append->sb->append->index->toString->sb->append
IndexNode#getIndex():::Get the index expression for this IndexNode:::return
IndexNode#setBase(Expression)::: index node set base:::if->return->return->isFunction->isSuper->new->IndexNode
IndexNode#setIndex(Expression):::Set the index expression for this node:::if->return->return->isFunction->isSuper->new->IndexNode
IndexNode#setType(Type)::: index node set type:::if->return->return->isFunction->isSuper->new->IndexNode
IndexNode#setIsFunction()::: index node set is function:::if->isFunction->return->return->isSuper->new->IndexNode
IndexNode#setProgramPoint(int)::: index node set program point:::if->return->return->isFunction->isSuper->new->IndexNode
IndexNode#setIsSuper()::: index node set is super:::if->isSuper->return->return->isFunction->new->IndexNode
JoinPredecessor#setLocalVariableConversion(LexicalContext, LocalVariableConversion):::Set the local variable conversions needed to unify their types at a control flow join point.:::
JoinPredecessor#getLocalVariableConversion():::Returns the local variable conversions needed to unify their types at a control flow join point.:::
JoinPredecessorExpression#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: join predecessor expression set local variable conversion:::if->return->return->new->JoinPredecessorExpression
JoinPredecessorExpression#getType()::: join predecessor expression get type:::return->expression->getType
JoinPredecessorExpression#isAlwaysFalse()::: join predecessor expression is always false:::return->expression->isAlwaysFalse
JoinPredecessorExpression#isAlwaysTrue()::: join predecessor expression is always true:::return->expression->isAlwaysTrue
JoinPredecessorExpression#getExpression():::Returns the underlying expression.:::return
JoinPredecessorExpression#setExpression(Expression):::Sets the underlying expression.:::if->return->return->new->JoinPredecessorExpression
JoinPredecessorExpression#getLocalVariableConversion()::: join predecessor expression get local variable conversion:::return
JoinPredecessorExpression#accept(NodeVisitor)::: join predecessor expression accept:::if->visitor->enterJoinPredecessorExpression->expr->getExpression->return->visitor->expr->accept->setExpression->leaveJoinPredecessorExpression->return
JoinPredecessorExpression#toString(StringBuilder, boolean)::: join predecessor expression to string:::if->expression->toString->if->conversion->toString
JumpStatement#hasGoto()::: jump statement has goto:::return
JumpStatement#getLabelName():::Get the label name for this break node:::return
JumpStatement#toString(StringBuilder, boolean)::: jump statement to string:::sb->getStatementName->append->if->sb->append->append
JumpStatement#getStatementName()::: jump statement get statement name:::
JumpStatement#getTarget(LexicalContext):::Finds the target for this jump statement in a lexical context.:::
JumpStatement#getTargetLabel(BreakableNode):::Returns the label corresponding to this kind of jump statement (either a break or continue label) in the target.:::
JumpStatement#getTargetLabel(LexicalContext):::Returns the label this jump statement targets.:::return->getTarget->getTargetLabel
JumpStatement#getPopScopeLimit(LexicalContext):::Returns the limit node for popping scopes when this jump statement is effected.:::return->getTarget
JumpStatement#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: jump statement set local variable conversion:::if->return->return->createNewJumpStatement
JumpStatement#createNewJumpStatement(LocalVariableConversion)::: jump statement create new jump statement:::
JumpStatement#getLocalVariableConversion()::: jump statement get local variable conversion:::return
JumpToInlinedFinally#accept(NodeVisitor)::: jump to inlined finally accept:::if->visitor->enterJumpToInlinedFinally->return->visitor->leaveJumpToInlinedFinally->return
JumpToInlinedFinally#createNewJumpStatement(LocalVariableConversion)::: jump to inlined finally create new jump statement:::return->new->JumpToInlinedFinally
JumpToInlinedFinally#getStatementName()::: jump to inlined finally get statement name:::return
JumpToInlinedFinally#getTarget(LexicalContext)::: jump to inlined finally get target:::return->lc->getLabelName->getInlinedFinally
JumpToInlinedFinally#getPopScopeLimit(LexicalContext)::: jump to inlined finally get pop scope limit:::return->lc->getLabelName->getTryNodeForInlinedFinally
JumpToInlinedFinally#getTargetLabel(BreakableNode)::: jump to inlined finally get target label:::return->getEntryLabel
LabelNode#isTerminal()::: label node is terminal:::return->body->isTerminal
LabelNode#accept(LexicalContext, NodeVisitor)::: label node accept:::if->visitor->enterLabelNode->return->visitor->body->accept->setBody->leaveLabelNode->return
LabelNode#toString(StringBuilder, boolean)::: label node to string:::sb->append->append
LabelNode#getBody():::Get the body of the node:::return
LabelNode#setBody(LexicalContext, Block):::Reset the body of the node:::if->return->return->Node->new->LabelNode->replaceInLexicalContext
LabelNode#getLabelName():::Get the label name:::return
LabelNode#getLocalVariableConversion()::: label node get local variable conversion:::return
LabelNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: label node set local variable conversion:::if->return->return->Node->new->LabelNode->replaceInLexicalContext
Labels#getLabels():::Return the labels associated with this node:::
LexicalContext#setFlag(LexicalContextNode, int):::Set the flags for a lexical context node on the stack:::if->for->i
LexicalContext#setBlockNeedsScope(Block):::Marks the block as one that creates a scope:::for->i
LexicalContext#getFlags(LexicalContextNode):::Get the flags for a lexical context node on the stack.:::for->i->throw->new->AssertionError
LexicalContext#getFunctionBody(FunctionNode):::Get the function body of a function node on the lexical context stack:::for->i->throw->functionNode->getName->new->AssertionError
LexicalContext#getAllNodes()::: lexical context get all nodes:::return->new->NodeIterator<>
LexicalContext#getOutermostFunction():::Returns the outermost function in this context:::return
LexicalContext#push(T):::Pushes a new block on top of the context, making it the innermost open block.:::if->newStack->new->LexicalContextNodeArr->System->arraycopy->newFlags->new->intArr->System->arraycopy->return
LexicalContext#isEmpty():::Is the context empty?:::return
LexicalContext#size()::: lexical context size:::return
LexicalContext#pop(T):::Pops the innermost block off the context and all nodes that has been contributed since it was put there.:::popped->if->return->setFlag->return
LexicalContext#applyTopFlags(T):::Explicitly apply flags to the topmost element on the stack:::return->node->setFlag
LexicalContext#peek():::Return the top element in the context.:::return
LexicalContext#contains(LexicalContextNode):::Check if a node is in the lexical context.:::for->i->return
LexicalContext#replace(LexicalContextNode, LexicalContextNode):::Replace a node on the lexical context with a new one:::for->i->return
LexicalContext#getBlocks():::Returns an iterator over all blocks in the context, with the top block (innermost lexical context) first.:::return->new->NodeIterator<>
LexicalContext#getFunctions():::Returns an iterator over all functions in the context, with the top (innermost open) function first.:::return->new->NodeIterator<>
LexicalContext#getParentBlock():::Get the parent block for the current lexical context block:::iter->getCurrentFunction->new->NodeIterator<>->iter->next->return->iter->hasNext->iter->next
LexicalContext#getCurrentBlockLabelNode():::Gets the label node of the current block.:::if->return->parent->return
LexicalContext#getAncestorBlocks(Block):::Returns an iterator over all ancestors block of the given block, with its parent block first.:::iter->getBlocks->while->iter->hasNext->b->iter->next->if->return->throw->new->AssertionError
LexicalContext#getBlocks(Block):::Returns an iterator over a block and all its ancestors blocks, with the block first.:::iter->getAncestorBlocks->return->new->Iterator<Block>
LexicalContext#getFunction(Block):::Get the function for this block.:::iter->new->NodeIterator<>->while->iter->hasNext->next->iter->next->if->while->iter->hasNext->next2->iter->next->if->return->return
LexicalContext#getCurrentBlock()::: lexical context get current block:::return->getBlocks->next
LexicalContext#getCurrentFunction()::: lexical context get current function:::for->i->return
LexicalContext#getDefiningBlock(Symbol):::Get the block in which a symbol is defined.:::name->symbol->getName->for->it->getBlocks->it->hasNext->throw->new->AssertionError
LexicalContext#getDefiningFunction(Symbol):::Get the function in which a symbol is defined.:::name->symbol->getName->for->iter->new->NodeIterator<>->iter->hasNext->throw->new->AssertionError
LexicalContext#isFunctionBody():::Is the topmost lexical context element a function body?:::return->getParentBlock
LexicalContext#isSplitBody():::Is the topmost lexical context element body of a SplitNode?:::return
LexicalContext#getParentFunction(FunctionNode):::Get the parent function for a function in the lexical context.:::iter->new->NodeIterator<>->while->iter->hasNext->next->iter->next->if->return->iter->hasNext->iter->next->return
LexicalContext#getScopeNestingLevelTo(LexicalContextNode):::Count the number of scopes until a given node:::n->for->iter->getAllNodes->iter->hasNext->return
LexicalContext#getBreakable()::: lexical context get breakable:::for->iter->getCurrentFunction->new->NodeIterator<>->iter->hasNext->return
LexicalContext#inLoop():::Check whether the lexical context is currently inside a loop.:::return->getCurrentLoop
LexicalContext#getCurrentLoop()::: lexical context get current loop:::iter->getCurrentFunction->new->NodeIterator<>->return->iter->hasNext->iter->next
LexicalContext#getBreakable(String):::Find the breakable node corresponding to this label.:::if->foundLabel->findLabel->if->breakable->for->iter->new->NodeIterator<>->iter->hasNext->return->return->return->getBreakable
LexicalContext#getContinueTo()::: lexical context get continue to:::return->getCurrentLoop
LexicalContext#getContinueTo(String):::Find the continue target node corresponding to this label.:::if->foundLabel->findLabel->if->loop->for->iter->new->NodeIterator<>->iter->hasNext->return->return->return->getContinueTo
LexicalContext#getInlinedFinally(String):::Find the inlined finally block node corresponding to this label.:::for->iter->new->NodeIterator<>->iter->hasNext->return
LexicalContext#getTryNodeForInlinedFinally(String):::Find the try node for an inlined finally block corresponding to this label.:::for->iter->new->NodeIterator<>->iter->hasNext->return
LexicalContext#findLabel(String):::Check the lexical context for a given label node by name.:::for->iter->getCurrentFunction->new->NodeIterator<>->iter->hasNext->return
LexicalContext#isExternalTarget(SplitNode, BreakableNode):::Checks whether a given target is a jump destination that lies outside a given split node.:::for->i->throw->new->AssertionError
LexicalContext#inUnprotectedSwitchContext():::Checks whether the current context is inside a switch statement without explicit blocks (curly braces).:::for->i->return
LexicalContext#toString()::: lexical context to string:::sb->new->StringBuffer->sb->append->for->i->sb->append->return->sb->toString
LexicalContext.NodeIterator#hasNext()::: node iterator has next:::return
LexicalContext.NodeIterator#next()::: node iterator next:::if->throw->new->NoSuchElementException->lnext->findNext->return
LexicalContext.NodeIterator#findNext()::: node iterator find next:::for->i->return
LexicalContext.NodeIterator#remove()::: node iterator remove:::throw->new->UnsupportedOperationException
LexicalContextExpression#accept(NodeVisitor)::: lexical context expression accept:::return->Acceptor->accept
LexicalContextNode#accept(LexicalContext, NodeVisitor):::Accept function for the node given a lexical context:::
LexicalContextNode.Acceptor#accept(LexicalContextNode, NodeVisitor)::: acceptor accept:::lc->visitor->getLexicalContext->lc->push->newNode->node->accept->return->lc->pop
LexicalContextStatement#accept(NodeVisitor)::: lexical context statement accept:::return->Acceptor->accept
LiteralNode#initialize(LexicalContext):::Initialization setter, if required for immutable state:::return
LiteralNode#isNull():::Check if the literal value is null:::return
LiteralNode#getType()::: literal node get type:::return->Type->value->getClass->typeFor
LiteralNode#getPropertyName()::: literal node get property name:::return->JSType->getObject->toString
LiteralNode#getBoolean():::Fetch boolean value of node.:::return->JSType->toBoolean
LiteralNode#getInt32():::Fetch int32 value of node.:::return->JSType->toInt32
LiteralNode#getUint32():::Fetch uint32 value of node.:::return->JSType->toUint32
LiteralNode#getLong():::Fetch long value of node:::return->JSType->toLong
LiteralNode#getNumber():::Fetch double value of node.:::return->JSType->toNumber
LiteralNode#getString():::Fetch String value of node.:::return->JSType->toString
LiteralNode#getObject():::Fetch Object value of node.:::return
LiteralNode#isArray():::Test if the value is an array:::return
LiteralNode#getElementExpressions()::: literal node get element expressions:::return
LiteralNode#isBoolean():::Test if the value is a boolean.:::return
LiteralNode#isString():::Test if the value is a string.:::return
LiteralNode#isNumeric():::Test if tha value is a number:::return
LiteralNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterLiteralNode->return->visitor->leaveLiteralNode->return
LiteralNode#toString(StringBuilder, boolean)::: literal node to string:::if->sb->append->else->sb->value->toString->append
LiteralNode#getValue():::Get the literal node value:::return
LiteralNode#valueToArray(List)::: literal node value to array:::return->value->new->ExpressionArr->toArray
LiteralNode#newInstance(long, int):::Create a new null literal:::return->new->NullLiteralNode
LiteralNode#newInstance(Node):::Create a new null literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->NullLiteralNode
LiteralNode.PrimitiveLiteralNode#isTrue():::Check if the literal value is boolean true:::return->JSType->toBoolean
LiteralNode.PrimitiveLiteralNode#isLocal()::: primitive literal node is local:::return
LiteralNode.PrimitiveLiteralNode#isAlwaysFalse()::: primitive literal node is always false:::return->isTrue
LiteralNode.PrimitiveLiteralNode#isAlwaysTrue()::: primitive literal node is always true:::return->isTrue
LiteralNode.BooleanLiteralNode#isTrue()::: boolean literal node is true:::return
LiteralNode.BooleanLiteralNode#getType()::: boolean literal node get type:::return
LiteralNode.BooleanLiteralNode#getWidestOperationType()::: boolean literal node get widest operation type:::return
LiteralNode#newInstance(long, int, boolean):::Create a new boolean literal:::return->new->BooleanLiteralNode
LiteralNode#newInstance(Node, boolean):::Create a new boolean literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->BooleanLiteralNode
LiteralNode.NumberLiteralNode#numberGetType(Number)::: number literal node number get type:::if->return->else->if->return->else->return
LiteralNode.NumberLiteralNode#getType()::: number literal node get type:::return
LiteralNode.NumberLiteralNode#getWidestOperationType()::: number literal node get widest operation type:::return->getType
LiteralNode#newInstance(long, int, Number):::Create a new number literal:::return->new->NumberLiteralNode
LiteralNode#newInstance(Node, Number):::Create a new number literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->NumberLiteralNode
LiteralNode#newInstance(long, int, Undefined):::Create a new undefined literal:::return->new->UndefinedLiteralNode
LiteralNode#newInstance(Node, Undefined):::Create a new null literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->UndefinedLiteralNode
LiteralNode.StringLiteralNode#toString(StringBuilder, boolean)::: string literal node to string:::sb->append->sb->append->sb->append
LiteralNode#newInstance(long, int, String):::Create a new string literal:::return->new->StringLiteralNode
LiteralNode#newInstance(Node, String):::Create a new String literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->StringLiteralNode
LiteralNode.LexerTokenLiteralNode#getType()::: lexer token literal node get type:::return
LiteralNode.LexerTokenLiteralNode#toString(StringBuilder, boolean)::: lexer token literal node to string:::sb->value->toString->append
LiteralNode#newInstance(long, int, LexerToken):::Create a new literal node for a lexer token:::return->new->LexerTokenLiteralNode
LiteralNode#newInstance(Node, LexerToken):::Create a new lexer token literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->new->LexerTokenLiteralNode
LiteralNode#objectAsConstant(Object):::Get the constant value for an object, or #POSTSET_MARKER if the value can't be statically computed.:::if->return->else->if->return->else->if->return->getValue->objectAsConstant->return
LiteralNode#isConstant(Object):::Test whether object represents a constant value.:::return->objectAsConstant
LiteralNode.NullLiteralNode#accept(NodeVisitor)::: null literal node accept:::if->visitor->enterLiteralNode->return->visitor->leaveLiteralNode->return
LiteralNode.NullLiteralNode#getType()::: null literal node get type:::return
LiteralNode.NullLiteralNode#getWidestOperationType()::: null literal node get widest operation type:::return
LiteralNode.ArrayLiteralNode#isArray()::: array literal node is array:::return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#initialize(ArrayLiteralNode)::: array literal initializer initialize:::elementType->computeElementType->postsets->computePostsets->presets->computePresets->return->new->ArrayLiteralNode
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#computeElementType(Expression[])::: array literal initializer compute element type:::widestElementType->foreach->if->widestElementType->widest->break->type->elem->getType->isUnknown->elem->getType->if->type->isBoolean->widestElementType->widest->break->widestElementType->widest->if->widestElementType->isObject->break->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#computePostsets(Expression[])::: array literal initializer compute postsets:::computed->new->intArr->nComputed->for->i->return->Arrays->copyOf
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#setArrayElement(int[], int, Object)::: array literal initializer set array element:::if->intValue->return->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#setArrayElement(long[], int, Object)::: array literal initializer set array element:::if->longValue->return->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#setArrayElement(double[], int, Object)::: array literal initializer set array element:::if->doubleValue->return->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#presetIntArray(Expression[], int[])::: array literal initializer preset int array:::array->new->intArr->nComputed->for->i->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#presetLongArray(Expression[], int[])::: array literal initializer preset long array:::array->new->longArr->nComputed->for->i->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#presetDoubleArray(Expression[], int[])::: array literal initializer preset double array:::array->new->doubleArr->nComputed->for->i->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#presetObjectArray(Expression[], int[])::: array literal initializer preset object array:::array->new->ObjectArr->nComputed->for->i->return
LiteralNode.ArrayLiteralNode.ArrayLiteralInitializer#computePresets(Expression[], Type, int[])::: array literal initializer compute presets:::if->elementType->isInteger->return->presetIntArray->else->if->elementType->isNumeric->return->presetDoubleArray->else->return->presetObjectArray
LiteralNode.ArrayLiteralNode#hasSpread():::Returns true if this array literal has a spread element.:::return
LiteralNode.ArrayLiteralNode#hasTrailingComma():::Returns true if this array literal has a trailing comma.:::return
LiteralNode.ArrayLiteralNode#getElementExpressions():::Returns a list of array element expressions:::return->Collections->Arrays->asList->unmodifiableList
LiteralNode.ArrayLiteralNode#initialize(LexicalContext):::Setter that initializes all code generation meta data for an ArrayLiteralNode:::return->Node->ArrayLiteralInitializer->initialize->replaceInLexicalContext
LiteralNode.ArrayLiteralNode#getArrayType():::Get the array element type as Java format, e.g:::return->getElementType->getArrayType
LiteralNode.ArrayLiteralNode#getArrayType(Type)::: array literal node get array type:::if->elementType->isInteger->return->else->if->elementType->isNumeric->return->else->return
LiteralNode.ArrayLiteralNode#getType()::: array literal node get type:::return->Type->typeFor
LiteralNode.ArrayLiteralNode#getElementType():::Get the element type of this array literal:::return
LiteralNode.ArrayLiteralNode#getPostsets():::Get indices of arrays containing computed post sets:::return
LiteralNode.ArrayLiteralNode#presetsMatchElementType()::: array literal node presets match element type:::if->return->else->if->return->else->return
LiteralNode.ArrayLiteralNode#getPresets():::Get presets constant array:::return
LiteralNode.ArrayLiteralNode#getSplitRanges():::Get the split ranges for this ArrayLiteral, or null if this array does not have to be split.:::return->Collections->unmodifiableList
LiteralNode.ArrayLiteralNode#setSplitRanges(LexicalContext, List):::Set the SplitRanges that make up this ArrayLiteral:::if->return->return->Node->new->ArrayLiteralNode->replaceInLexicalContext
LiteralNode.ArrayLiteralNode#accept(NodeVisitor)::: array literal node accept:::return->Acceptor->accept
LiteralNode.ArrayLiteralNode#accept(LexicalContext, NodeVisitor)::: array literal node accept:::if->visitor->enterLiteralNode->oldValue->Arrays->asList->newValue->Node->accept->return->visitor->setValue->leaveLiteralNode->return
LiteralNode.ArrayLiteralNode#setValue(LexicalContext, Expression[])::: array literal node set value:::if->return->return->Node->new->ArrayLiteralNode->replaceInLexicalContext
LiteralNode.ArrayLiteralNode#setValue(LexicalContext, List)::: array literal node set value:::return->value->new->ExpressionArr->toArray->setValue
LiteralNode.ArrayLiteralNode#toString(StringBuilder, boolean)::: array literal node to string:::sb->append->first->foreach->if->sb->append->sb->append->if->sb->append->else->node->toString->sb->append
LiteralNode#newInstance(long, int, List):::Create a new array literal of Nodes from a list of Node values:::return->valueToArray->new->ArrayLiteralNode
LiteralNode#newInstance(Node, List):::Create a new array literal based on a parent node (source, token, finish):::return->parent->getToken->parent->getFinish->valueToArray->new->ArrayLiteralNode
LiteralNode#newInstance(long, int, List, boolean, boolean)::: literal node new instance:::return->valueToArray->new->ArrayLiteralNode
LiteralNode#newInstance(long, int, Expression[]):::Create a new array literal of Nodes:::return->new->ArrayLiteralNode
LocalVariableConversion#getFrom():::Returns the type being converted from.:::return
LocalVariableConversion#getTo():::Returns the type being converted to.:::return
LocalVariableConversion#getNext():::Returns the next conversion at the same join point, or null if this is the last one.:::return
LocalVariableConversion#getSymbol():::Returns the symbol representing the local variable whose value is being converted.:::return
LocalVariableConversion#isLive():::Returns true if this conversion is live:::return->symbol->hasSlotFor
LocalVariableConversion#isAnyLive():::Returns true if this conversion #isLive(), or if any of its #getNext() conversions are live.:::return->isLive->isAnyLive
LocalVariableConversion#hasLiveConversion(JoinPredecessor):::Returns true if the passed join predecessor has #isAnyLive() conversion.:::return->jp->getLocalVariableConversion->isAnyLive
LocalVariableConversion#isAnyLive(LocalVariableConversion):::Returns true if the passed conversion is not null, and it #isAnyLive().:::return->conv->isAnyLive
LocalVariableConversion#toString()::: local variable conversion to string:::return->new->StringBuilder->toString->toString
LocalVariableConversion#toString(StringBuilder):::Generates a string representation of this conversion in the passed string builder.:::if->isLive->return->sb->append->toStringNext->append->return->next->toString
LocalVariableConversion#toString(LocalVariableConversion, StringBuilder):::Generates a string representation of the passed conversion in the passed string builder.:::return->conv->toString
LocalVariableConversion#toStringNext(StringBuilder, boolean)::: local variable conversion to string next:::if->isLive->if->sb->append->sb->symbol->getName->append->append->getTypeChar->append->append->getTypeChar->append->return->next->toStringNext->return->next->toStringNext
LocalVariableConversion#getTypeChar(Type)::: local variable conversion get type char:::if->return->else->if->type->isObject->return->else->if->return->return->type->getBytecodeStackType
LoopNode#ensureUniqueLabels(LexicalContext)::: loop node ensure unique labels:::
LoopNode#controlFlowEscapes():::Does the control flow escape from this loop, i.e:::return
LoopNode#isTerminal()::: loop node is terminal:::if->mustEnter->return->if->return->if->body->isTerminal->return->return
LoopNode#mustEnter():::Conservative check: does this loop have to be entered?:::
LoopNode#getContinueLabel():::Get the continue label for this while node, i.e:::return
LoopNode#getLabels()::: loop node get labels:::return->Collections->Arrays->asList->unmodifiableList
LoopNode#isLoop()::: loop node is loop:::return
LoopNode#getBody():::Get the body for this for node:::
LoopNode#setBody(LexicalContext, Block)::: loop node set body:::
LoopNode#getTest():::Get the test for this for node:::return
LoopNode#setTest(LexicalContext, JoinPredecessorExpression):::Set the test for this for node:::
LoopNode#setControlFlowEscapes(LexicalContext, boolean):::Set the control flow escapes flag for this node:::
LoopNode#hasPerIterationScope():::Does this loop have a LET declaration and hence require a per-iteration scope?:::
Module.ExportEntry#exportStarFrom(IdentNode, IdentNode, int, int):::Creates a export * export entry.:::return->new->ExportEntry
Module.ExportEntry#exportDefault(IdentNode, IdentNode, int, int):::Creates a export default export entry with a local name.:::return->new->ExportEntry
Module.ExportEntry#exportSpecifier(IdentNode, IdentNode, int, int):::Creates a export entry with a local name and export name.:::return->new->ExportEntry
Module.ExportEntry#exportSpecifier(IdentNode, int, int):::Creates a export entry with an export name.:::return->exportSpecifier
Module.ExportEntry#withFrom(IdentNode, int):::Create a copy of this entry with the specified module request string.:::return->new->ExportEntry
Module.ExportEntry#getExportName():::Returns the entry's export name.:::return
Module.ExportEntry#getModuleRequest():::Returns the entry's module request.:::return
Module.ExportEntry#getImportName():::Returns the entry's import name.:::return
Module.ExportEntry#getLocalName():::Returns the entry's local name.:::return
Module.ExportEntry#getStartPosition():::Returns the entry's start position.:::return
Module.ExportEntry#getEndPosition():::Returns the entry's end position.:::return
Module.ExportEntry#toString()::: export entry to string:::return
Module.ImportEntry#importSpecifier(IdentNode, IdentNode, int, int):::Creates an import entry with the given import and local names.:::return->new->ImportEntry
Module.ImportEntry#importSpecifier(IdentNode, int, int):::Creates a new import entry with the given import name.:::return->importSpecifier
Module.ImportEntry#withFrom(IdentNode, int):::Returns a copy of this import entry with the given module request and end position.:::return->new->ImportEntry
Module.ImportEntry#getModuleRequest():::Returns the entry's module request.:::return
Module.ImportEntry#getImportName():::Returns the entry's import name.:::return
Module.ImportEntry#getLocalName():::Returns the entry's local name.:::return
Module.ImportEntry#getStartPosition():::Returns the entry's start position.:::return
Module.ImportEntry#getEndPosition():::Returns the entry's end position.:::return
Module.ImportEntry#toString()::: import entry to string:::return
Module#getRequestedModules():::Returns the list of requested modules.:::return
Module#getImportEntries():::Returns the list of import entries.:::return
Module#getLocalExportEntries():::Returns the list of local export entries.:::return
Module#getIndirectExportEntries():::Returns the list of indirect export entries.:::return
Module#getStarExportEntries():::Returns the list of star export entries.:::return
Module#toString()::: module to string:::return
Node#isLoop():::Is this a loop node?:::return
Node#isAssignment():::Is this an assignment node - for example a var node with an init or a binary node that writes to a destination:::return
Node#ensureUniqueLabels(LexicalContext):::For reference copies - ensure that labels in the copy node are unique using an appropriate copy constructor:::return
Node#accept(NodeVisitor):::Provides a means to navigate the IR.:::
Node#toString()::: node to string:::return->toString
Node#toString(boolean)::: node to string:::sb->new->StringBuilder->toString->return->sb->toString
Node#toString(StringBuilder):::String conversion helper:::toString
Node#toString(StringBuilder, boolean):::Print logic that decides whether to show the optimistic type or not - for example it should not be printed after just parse, when it hasn't been computed, or has been set to a trivially provable value:::
Node#getFinish():::Get the finish position for this node in the source string:::return
Node#getStart():::Get start position for node:::return
Node#getSourceOrder():::Integer to sort nodes in source order:::return->getStart
Node#clone()::: node clone:::try->return->super->clone->catch->throw->new->AssertionError->finally
Node#equals(Object)::: node equals:::return
Node#hashCode()::: node hash code:::return->Long->hashCode
Node#position():::Return token position from a token descriptor.:::return->Token->descPosition
Node#length():::Return token length from a token descriptor.:::return->Token->descLength
Node#tokenType():::Returns this node's token's type:::return->Token->descType
Node#isTokenType(TokenType):::Tests if this node has the specific token type.:::return->tokenType
Node#getToken():::Get the token for this node:::return
Node#accept(NodeVisitor, List)::: node accept:::size->list->size->if->return->newList->for->i->return
Node#replaceInLexicalContext(LexicalContext, T, T)::: node replace in lexical context:::if->lc->replace->return
ObjectNode#accept(NodeVisitor)::: object node accept:::return->Acceptor->accept
ObjectNode#accept(LexicalContext, NodeVisitor)::: object node accept:::if->visitor->enterObjectNode->return->visitor->Node->accept->setElements->leaveObjectNode->return
ObjectNode#getType()::: object node get type:::return
ObjectNode#toString(StringBuilder, boolean)::: object node to string:::sb->append->if->elements->isEmpty->sb->append->first->foreach->if->sb->append->element->toString->sb->append->sb->append
ObjectNode#getElements():::Get the elements of this literal node:::return->Collections->unmodifiableList
ObjectNode#setElements(LexicalContext, List)::: object node set elements:::if->return->return->Node->new->ObjectNode->replaceInLexicalContext
ObjectNode#setSplitRanges(LexicalContext, List):::Set the split ranges for this ObjectNode:::if->return->return->Node->new->ObjectNode->replaceInLexicalContext
ObjectNode#getSplitRanges():::Get the split ranges for this ObjectNode, or null if the object is not split.:::return->Collections->unmodifiableList
Optimistic#getProgramPoint():::Unique node ID that is associated with an invokedynamic call that mail fail and its callsite:::
Optimistic#setProgramPoint(int):::Set the node number for this node, associating with a unique per-function program point:::
Optimistic#canBeOptimistic():::Is it possible for this particular implementor to actually have any optimism? SHIFT operators for instance are binary nodes, but never optimistic:::
Optimistic#getMostOptimisticType():::Get the most optimistic type for this node:::
Optimistic#getMostPessimisticType():::Most pessimistic type that is guaranteed to be safe:::
Optimistic#setType(Type):::Set the override type:::
OptimisticLexicalContext.Assumption#toString()::: assumption to string:::return->symbol->getName
OptimisticLexicalContext#isEnabled():::Are optimistic types enabled:::return
OptimisticLexicalContext#logOptimisticAssumption(Symbol, Type):::Log an optimistic assumption during codegen TODO : different parameters and more info about the assumption for future profiling needs:::if->peek->optimisticAssumptions->peek->peek->new->Assumption->add
OptimisticLexicalContext#getOptimisticAssumptions():::Get the list of optimistic assumptions made:::return->Collections->optimisticAssumptions->peek->unmodifiableList
OptimisticLexicalContext#hasOptimisticAssumptions():::Does this method have optimistic assumptions made during codegen?:::return->optimisticAssumptions->isEmpty->getOptimisticAssumptions->isEmpty
OptimisticLexicalContext#push(T)::: optimistic lexical context push:::if->if->optimisticAssumptions->new->ArrayList<Assumption>->push->return->super->push
OptimisticLexicalContext#pop(T)::: optimistic lexical context pop:::popped->super->pop->if->if->optimisticAssumptions->pop->return
PropertyKey#getPropertyName():::Get the property name:::
PropertyNode#getKeyName():::Get the name of the property key, or null if key is a computed name.:::return->getPropertyName
PropertyNode#accept(NodeVisitor)::: property node accept:::if->visitor->enterPropertyNode->return->visitor->key->accept->setKey->value->accept->setValue->getter->accept->setGetter->setter->accept->setSetter->leavePropertyNode->return
PropertyNode#toString(StringBuilder, boolean)::: property node to string:::if->getIdent->value->toString->if->toString->sb->append->value->toString->if->sb->append->getter->toString->if->sb->append->setter->toString
PropertyNode#getGetter():::Get the getter for this property:::return
PropertyNode#setGetter(FunctionNode):::Set the getter of this property, null if none:::if->return->return->new->PropertyNode
PropertyNode#getKey():::Return the key for this property node:::return
PropertyNode#setKey(Expression)::: property node set key:::if->return->return->new->PropertyNode
PropertyNode#getSetter():::Get the setter for this property:::return
PropertyNode#setSetter(FunctionNode):::Set the setter for this property, null if none:::if->return->return->new->PropertyNode
PropertyNode#getValue():::Get the value of this property:::return
PropertyNode#setValue(Expression):::Set the value of this property:::if->return->return->new->PropertyNode
PropertyNode#isStatic():::Returns true if this is a static property.:::return
PropertyNode#isComputed():::Returns true if this is a computed property.:::return
ReturnNode#isTerminal()::: return node is terminal:::return
ReturnNode#isReturn():::Return true if is a RETURN node.:::return->isTokenType
ReturnNode#hasExpression():::Check if this return node has an expression:::return
ReturnNode#isYield():::Return true if is a YIELD node.:::return->isTokenType
ReturnNode#accept(NodeVisitor)::: return node accept:::if->visitor->enterReturnNode->if->return->visitor->expression->accept->setExpression->leaveReturnNode->return->visitor->leaveReturnNode->return
ReturnNode#toString(StringBuilder, boolean)::: return node to string:::sb->isYield->append->if->sb->append->expression->toString
ReturnNode#getExpression():::Get the expression this node returns:::return
ReturnNode#setExpression(Expression):::Reset the expression this node returns:::if->return->return->new->ReturnNode
RuntimeNode#setRequest(Request):::Reset the request for this runtime node:::if->return->return->new->RuntimeNode
RuntimeNode#getType():::Return type for the ReferenceNode:::return->request->getReturnType
RuntimeNode#accept(NodeVisitor)::: runtime node accept:::if->visitor->enterRuntimeNode->return->visitor->Node->accept->setArgs->leaveRuntimeNode->return
RuntimeNode#toString(StringBuilder, boolean)::: runtime node to string:::sb->append->sb->append->sb->append->first->foreach->if->sb->append->else->arg->toString->sb->append
RuntimeNode#getArgs():::Get the arguments for this runtime node:::return->Collections->unmodifiableList
RuntimeNode#setArgs(List):::Set the arguments of this runtime node:::if->return->return->new->RuntimeNode
RuntimeNode#getRequest():::Get the request that this runtime node implements:::return
RuntimeNode#isPrimitive():::Is this runtime node, engineered to handle the "at least one object" case of the defined requests and specialize on demand, really primitive:::foreach->if->arg->getType->isObject->return->return
SetSplitState#getState():::Returns the state this setter sets.:::return
SetSplitState#accept(NodeVisitor)::: set split state accept:::return->visitor->enterSetSplitState->visitor->leaveSetSplitState
SetSplitState#toString(StringBuilder, boolean)::: set split state to string:::sb->symbolName->append->append->name->append->append->append->append
SplitNode#getBody():::Get the body for this split node - i.e:::return
SplitNode#setBody(LexicalContext, Block)::: split node set body:::if->return->return->Node->new->SplitNode->replaceInLexicalContext
SplitNode#accept(LexicalContext, NodeVisitor)::: split node accept:::if->visitor->enterSplitNode->return->visitor->body->accept->setBody->leaveSplitNode->return
SplitNode#toString(StringBuilder, boolean)::: split node to string:::sb->append->sb->compileUnit->getClass->getSimpleName->append->sb->append->body->toString
SplitNode#getName():::Get the name for this split node:::return
SplitNode#getCompileUnit():::Get the compile unit for this split node:::return
SplitNode#setCompileUnit(LexicalContext, CompileUnit):::Set the compile unit for this split node:::if->return->return->Node->new->SplitNode->replaceInLexicalContext
SplitNode#writeObject(ObjectOutputStream)::: split node write object:::throw->getClass->getName->new->NotSerializableException
SplitReturn#isTerminal()::: split return is terminal:::return
SplitReturn#accept(NodeVisitor)::: split return accept:::return->visitor->enterSplitReturn->visitor->leaveSplitReturn
SplitReturn#toString(StringBuilder, boolean)::: split return to string:::sb->append
SplitReturn#readResolve()::: split return read resolve:::return
Splittable#getSplitRanges():::Get a list of split ranges for this splittable expression, or null if the expression should not be split.:::
Splittable.SplitRange#getHigh():::Get the high index position of the ArrayUnit (exclusive):::return
Splittable.SplitRange#getLow():::Get the low index position of the ArrayUnit (inclusive):::return
Splittable.SplitRange#getCompileUnit():::The array compile unit:::return
Statement#getLineNumber():::Return the line number:::return
Statement#isTerminal():::Is this a terminal statement, i.e:::return
Statement#hasGoto():::Check if this statement repositions control flow with goto like semantics, for example BreakNode or a ForNode with no test:::return
Statement#hasTerminalFlags():::Check if this statement has terminal flags, i.e:::return->isTerminal->hasGoto
SwitchNode#ensureUniqueLabels(LexicalContext)::: switch node ensure unique labels:::newCases->new->ArrayList<>->foreach->newCases->caseNode->getTest->caseNode->getBody->caseNode->getLocalVariableConversion->new->CaseNode->add->return->Node->new->SwitchNode->replaceInLexicalContext
SwitchNode#isTerminal()::: switch node is terminal:::if->cases->isEmpty->foreach->if->caseNode->isTerminal->return->return->return
SwitchNode#accept(LexicalContext, NodeVisitor)::: switch node accept:::if->visitor->enterSwitchNode->return->visitor->expression->accept->setExpression->Node->accept->setCases->leaveSwitchNode->return
SwitchNode#toString(StringBuilder, boolean)::: switch node to string:::sb->append->expression->toString->sb->append
SwitchNode#getDefaultCase():::Return the case node that is default case:::return->cases->get
SwitchNode#getCases():::Get the cases in this switch:::return->Collections->unmodifiableList
SwitchNode#setCases(LexicalContext, List):::Replace case nodes with new list:::return->setCases
SwitchNode#setCases(LexicalContext, List, int)::: switch node set cases:::if->return->return->Node->new->SwitchNode->replaceInLexicalContext
SwitchNode#setCases(LexicalContext, List, CaseNode):::Set or reset the list of cases in this switch:::return->cases->indexOf->setCases
SwitchNode#getExpression():::Return the expression to switch on:::return
SwitchNode#setExpression(LexicalContext, Expression):::Set or reset the expression to switch on:::if->return->return->Node->new->SwitchNode->replaceInLexicalContext
SwitchNode#getTag():::Get the tag symbol for this switch:::return
SwitchNode#setTag(LexicalContext, Symbol):::Set the tag symbol for this switch:::if->return->return->Node->new->SwitchNode->replaceInLexicalContext
SwitchNode#isUniqueInteger():::Returns true if all cases of this switch statement are 32-bit signed integer constants, without repetitions.:::return
SwitchNode#setUniqueInteger(LexicalContext, boolean):::Sets whether all cases of this switch statement are 32-bit signed integer constants, without repetitions.:::if->return->return->Node->new->SwitchNode->replaceInLexicalContext
SwitchNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)::: switch node set local variable conversion changed:::return->Node->new->SwitchNode->replaceInLexicalContext
Symbol#clone()::: symbol clone:::try->return->super->clone->catch->throw->new->AssertionError->finally
Symbol#align(String, int)::: symbol align:::sb->new->StringBuilder->sb->string->Math->string->length->min->substring->append->while->sb->length->sb->append->return->sb->toString
Symbol#print(PrintWriter)::: symbol print:::sb->new->StringBuilder->sb->align->append->append->append->align->append->switch->sb->append->break->if->isConst->sb->append->else->if->isLet->sb->append->else->sb->append->break->sb->append->break->break->if->isScope->sb->append->if->isInternal->sb->append->if->isThis->sb->append->if->isProgramLevel->sb->append->sb->append->stream->sb->toString->print
Symbol#less(int):::Compare the the symbol kind with another.:::return
Symbol#setNeedsSlot(boolean):::Allocate a slot for this symbol.:::if->else->return
Symbol#slotCount():::Return the number of slots required for the symbol.:::return
Symbol#isSlotted()::: symbol is slotted:::return
Symbol#toString()::: symbol to string:::sb->new->StringBuilder->sb->append->append->if->hasSlot->sb->append->append->append->append->append->if->sb->append->if->sb->append->if->sb->append->sb->append->if->isScope->if->isGlobal->sb->append->else->sb->append->return->sb->toString
Symbol#compareTo(Symbol)::: symbol compare to:::return->name->compareTo
Symbol#hasSlot():::Does this symbol have an allocated bytecode slot? Note that having an allocated bytecode slot doesn't necessarily mean the symbol's value will be stored in it:::return
Symbol#isBytecodeLocal():::Is this symbol a local variable stored in bytecode local variable slots? This is true for a slotted variable that is not in scope:::return->hasSlot->isScope
Symbol#isDead():::Returns true if this symbol is dead (it is a local variable that is statically proven to never be read in any type).:::return
Symbol#isScope():::Check if this is a symbol in scope:::return
Symbol#isFunctionDeclaration():::Check if this symbol is a function declaration:::return
Symbol#setIsScope():::Flag this symbol as scope as described in Symbol#isScope():::if->isScope->if->shouldTrace->trace->if->isParam->return
Symbol#setIsFunctionDeclaration():::Mark this symbol as a function declaration.:::if->isFunctionDeclaration->if->shouldTrace->trace
Symbol#isVar():::Check if this symbol is a variable:::return
Symbol#isGlobal():::Check if this symbol is a global (undeclared) variable:::return
Symbol#isParam():::Check if this symbol is a function parameter:::return
Symbol#isProgramLevel():::Check if this is a program (script) level definition:::return
Symbol#isConst():::Check if this symbol is a constant:::return
Symbol#isInternal():::Check if this is an internal symbol, without an explicit JavaScript source code equivalent:::return
Symbol#isThis():::Check if this symbol represents this:::return
Symbol#isLet():::Check if this symbol is a let:::return
Symbol#isFunctionSelf():::Flag this symbol as a function's self-referencing symbol.:::return
Symbol#isBlockScoped():::Is this a block scoped symbol:::return->isLet->isConst
Symbol#hasBeenDeclared():::Has this symbol been declared:::return
Symbol#setHasBeenDeclared():::Mark this symbol as declared:::if->hasBeenDeclared
Symbol#getFieldIndex():::Get the index of the field used to store this symbol, should it be an AccessorProperty and get allocated in a JO-prefixed ScriptObject subclass.:::return
Symbol#setFieldIndex(int):::Set the index of the field used to store this symbol, should it be an AccessorProperty and get allocated in a JO-prefixed ScriptObject subclass.:::if->return
Symbol#getFlags():::Get the symbol flags:::return
Symbol#setFlags(int):::Set the symbol flags:::if->return
Symbol#setFlag(int):::Set a single symbol flag:::if->return
Symbol#clearFlag(int):::Clears a single symbol flag:::if->return
Symbol#getName():::Get the name of this symbol:::return
Symbol#getFirstSlot():::Get the index of the first bytecode slot for this symbol:::return
Symbol#getSlot(Type):::Get the index of the bytecode slot for this symbol for storing a value of the specified type.:::typeSlot->if->type->isBoolean->type->isInteger->return->if->type->isNumber->return->return
Symbol#hasSlotFor(Type):::Returns true if this symbol has a local variable slot for storing a value of specific type.:::if->type->isBoolean->type->isInteger->return->else->if->type->isNumber->return->return
Symbol#setHasSlotFor(Type):::Marks this symbol as having a local variable slot for storing a value of specific type.:::if->type->isBoolean->type->isInteger->setFlag->else->if->type->isNumber->setFlag->else->setFlag
Symbol#increaseUseCount():::Increase the symbol's use count by one.:::if->isScope
Symbol#getUseCount():::Get the symbol's use count:::return
Symbol#setFirstSlot(int):::Set the bytecode slot for this symbol:::if->if->shouldTrace->trace->return
Symbol#setSymbolIsScope(LexicalContext, Symbol):::From a lexical context, set this symbol as needing scope, which will set flags for the defining block that will be written when block is popped from the lexical context stack, used by codegen when flags need to be tagged, but block is in the middle of evaluation and cannot be modified.:::symbol->setIsScope->if->symbol->isGlobal->lc->lc->getDefiningBlock->setBlockNeedsScope->return
Symbol#shouldTrace()::: symbol should trace:::return->TRACE_SYMBOLS->isEmpty->TRACE_SYMBOLS->contains
Symbol#trace(String)::: symbol trace:::Context->Debug->id->err->if->TRACE_SYMBOLS_STACKTRACE->isEmpty->TRACE_SYMBOLS_STACKTRACE->contains->new->Throwable->Context->getCurrentErr->printStackTrace
Symbol#readObject(ObjectInputStream)::: symbol read object:::in->defaultReadObject
TemplateLiteral#getType()::: template literal get type:::return
TemplateLiteral#accept(NodeVisitor)::: template literal accept:::if->visitor->enterTemplateLiteral->return->visitor->leaveTemplateLiteral->return
TemplateLiteral#toString(StringBuilder, boolean)::: template literal to string:::foreach->sb->append
TemplateLiteral#getExpressions():::The list of expressions that are part of this template literal.:::return->Collections->unmodifiableList
Terminal#isTerminal():::Returns true if this AST node is (or contains) a statement that terminates function control flow.:::
TernaryNode#accept(NodeVisitor)::: ternary node accept:::if->visitor->enterTernaryNode->newTest->getTest->accept->newTrueExpr->trueExpr->accept->newFalseExpr->falseExpr->accept->return->visitor->setTest->setTrueExpression->setFalseExpression->leaveTernaryNode->return
TernaryNode#toString(StringBuilder, boolean)::: ternary node to string:::tokenType->tokenType->testParen->tokenType->getTest->tokenType->needsParens->trueParen->tokenType->getTrueExpression->tokenType->needsParens->falseParen->tokenType->getFalseExpression->tokenType->needsParens->if->sb->append->getTest->toString->if->sb->append->sb->append->if->sb->append->getTrueExpression->toString->if->sb->append->sb->append->if->sb->append->getFalseExpression->toString->if->sb->append
TernaryNode#isLocal()::: ternary node is local:::return->getTest->isLocal->getTrueExpression->isLocal->getFalseExpression->isLocal
TernaryNode#getType()::: ternary node get type:::return->Type->getTrueExpression->getType->getFalseExpression->getType->widestReturnType
TernaryNode#getTest():::Get the test expression for this ternary expression, i.e:::return
TernaryNode#getTrueExpression():::Get the true expression for this ternary expression, i.e:::return
TernaryNode#getFalseExpression():::Get the false expression for this ternary expression, i.e:::return
TernaryNode#setTest(Expression):::Set the test expression for this node:::if->return->return->new->TernaryNode
TernaryNode#setTrueExpression(JoinPredecessorExpression):::Set the true expression for this node:::if->return->return->new->TernaryNode
TernaryNode#setFalseExpression(JoinPredecessorExpression):::Set the false expression for this node:::if->return->return->new->TernaryNode
ThrowNode#isTerminal()::: throw node is terminal:::return
ThrowNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterThrowNode->return->visitor->expression->accept->setExpression->leaveThrowNode->return
ThrowNode#toString(StringBuilder, boolean)::: throw node to string:::sb->append->if->expression->toString->if->conversion->toString
ThrowNode#getExpression():::Get the expression that is being thrown by this node:::return
ThrowNode#setExpression(Expression):::Reset the expression being thrown by this node:::if->return->return->new->ThrowNode
ThrowNode#isSyntheticRethrow():::Is this a throw a synthetic rethrow in a synthetic catch-all block created when inlining finally statements? In that case we never wrap whatever is thrown into an ECMAException, just rethrow it.:::return
ThrowNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: throw node set local variable conversion:::if->return->return->new->ThrowNode
ThrowNode#getLocalVariableConversion()::: throw node get local variable conversion:::return
TryNode#ensureUniqueLabels(LexicalContext)::: try node ensure unique labels:::return->new->TryNode
TryNode#isTerminal()::: try node is terminal:::if->body->isTerminal->foreach->getCatchBlocks->if->catchBlock->isTerminal->return->return->return
TryNode#accept(LexicalContext, NodeVisitor):::Assist in IR navigation.:::if->visitor->enterTryNode->newFinallyBody->finallyBody->accept->newBody->body->accept->return->visitor->setBody->setFinallyBody->Node->accept->setCatchBlocks->Node->accept->setInlinedFinallies->leaveTryNode->return
TryNode#toString(StringBuilder, boolean)::: try node to string:::sb->append
TryNode#getBody():::Get the body for this try block:::return
TryNode#setBody(LexicalContext, Block):::Reset the body of this try block:::if->return->return->Node->new->TryNode->replaceInLexicalContext
TryNode#getCatches():::Get the catches for this try block:::catches->catchBlocks->size->new->ArrayList<>->foreach->catches->getCatchNodeFromBlock->add->return->Collections->unmodifiableList
TryNode#getCatchNodeFromBlock(Block)::: try node get catch node from block:::return->catchBlock->getStatements->get
TryNode#getCatchBlocks():::Get the catch blocks for this try block:::return->Collections->unmodifiableList
TryNode#setCatchBlocks(LexicalContext, List):::Set the catch blocks of this try:::if->return->return->Node->new->TryNode->replaceInLexicalContext
TryNode#getException():::Get the exception symbol for this try block:::return
TryNode#setException(LexicalContext, Symbol):::Set the exception symbol for this try block:::if->return->return->Node->new->TryNode->replaceInLexicalContext
TryNode#getFinallyBody():::Get the body of the finally clause for this try:::return
TryNode#getInlinedFinally(String):::Get the inlined finally block with the given label name:::foreach->labelNode->getInlinedFinallyLabelNode->if->labelNode->getLabelName->equals->return->labelNode->getBody->return
TryNode#getInlinedFinallyLabelNode(Block)::: try node get inlined finally label node:::return->inlinedFinally->getStatements->get
TryNode#getLabelledInlinedFinallyBlock(Block):::Given an outer wrapper block for the LabelNode as returned by #getInlinedFinallies(), returns its actual inlined finally block.:::return->getInlinedFinallyLabelNode->getBody
TryNode#getInlinedFinallies():::Returns a list of inlined finally blocks:::return->Collections->unmodifiableList
TryNode#setFinallyBody(LexicalContext, Block):::Set the finally body of this try:::if->return->return->Node->new->TryNode->replaceInLexicalContext
TryNode#setInlinedFinallies(LexicalContext, List):::Set the inlined finally blocks of this try:::if->return->return->Node->new->TryNode->replaceInLexicalContext
TryNode#checkInlinedFinallies(List)::: try node check inlined finallies:::if->inlinedFinallies->isEmpty->labels->new->HashSet<>->foreach->stmts->inlinedFinally->getStatements->ln->getInlinedFinallyLabelNode->return
TryNode#setLocalVariableConversion(LexicalContext, LocalVariableConversion)::: try node set local variable conversion:::if->return->return->new->TryNode
TryNode#getLocalVariableConversion()::: try node get local variable conversion:::return
UnaryNode#isAssignment():::Is this an assignment - i.e:::switch->tokenType->return->return
UnaryNode#isSelfModifying()::: unary node is self modifying:::return->isAssignment
UnaryNode#getWidestOperationType()::: unary node get widest operation type:::switch->tokenType->operandType->getExpression->getType->if->return->else->if->operandType->isObject->return->return->return->return->return->return->return->isAssignment
UnaryNode#getAssignmentDest()::: unary node get assignment dest:::return->isAssignment->getExpression
UnaryNode#setAssignmentDest(Expression)::: unary node set assignment dest:::return->setExpression
UnaryNode#getAssignmentSource()::: unary node get assignment source:::return->getAssignmentDest
UnaryNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterUnaryNode->return->visitor->expression->accept->setExpression->leaveUnaryNode->return
UnaryNode#isLocal()::: unary node is local:::switch->tokenType->return->return->expression->isLocal->expression->getType->isJSPrimitive->return->expression->isLocal->expression->getType->isJSPrimitive->return->expression->isLocal
UnaryNode#toString(StringBuilder, boolean)::: unary node to string:::new->Runnable->toString
UnaryNode#toString(StringBuilder, Runnable, boolean):::Creates the string representation of this unary node, delegating the creation of the string representation of its operand to a specified runnable.:::tokenType->tokenType->name->tokenType->getName->isPostfix->if->isOptimistic->sb->append->rhsParen->tokenType->getExpression->tokenType->needsParens->if->if->sb->tokenType->name->append->else->sb->append->if->tokenType->ordinal->BIT_NOT->ordinal->sb->append->if->sb->append->rhsStringBuilder->run->if->sb->append->if->sb->append
UnaryNode#getExpression():::Get the right hand side of this if it is inherited by a binary expression, or just the expression itself if still Unary:::return
UnaryNode#setExpression(Expression):::Reset the right hand side of this if it is inherited by a binary expression, or just the expression itself if still Unary:::if->return->return->new->UnaryNode
UnaryNode#getProgramPoint()::: unary node get program point:::return
UnaryNode#setProgramPoint(int)::: unary node set program point:::if->return->return->new->UnaryNode
UnaryNode#canBeOptimistic()::: unary node can be optimistic:::return->getMostOptimisticType->getMostPessimisticType
UnaryNode#getMostOptimisticType()::: unary node get most optimistic type:::if->CAN_OVERFLOW->tokenType->contains->return->return->getMostPessimisticType
UnaryNode#getMostPessimisticType()::: unary node get most pessimistic type:::return->getWidestOperationType
UnaryNode#getType()::: unary node get type:::widest->getWidestOperationType->if->return->return->Type->Type->expression->getType->widest->narrowest
UnaryNode#setType(Type)::: unary node set type:::if->return->return->new->UnaryNode
VarNode#getSourceOrder()::: var node get source order:::return->super->getSourceOrder
VarNode#isAssignment()::: var node is assignment:::return->hasInit
VarNode#getAssignmentDest()::: var node get assignment dest:::return->isAssignment
VarNode#setAssignmentDest(IdentNode)::: var node set assignment dest:::return->setName
VarNode#getAssignmentSource()::: var node get assignment source:::return->isAssignment->getInit
VarNode#isBlockScoped():::Is this a VAR node block scoped? This returns true for ECMAScript 6 LET and CONST nodes.:::return->getFlag->getFlag
VarNode#isLet():::Is this an ECMAScript 6 LET node?:::return->getFlag
VarNode#isConst():::Is this an ECMAScript 6 CONST node?:::return->getFlag
VarNode#getSymbolFlags():::Return the flags to use for symbols for this declaration.:::if->isLet->return->else->if->isConst->return->return
VarNode#hasInit():::Does this variable declaration have an init value:::return
VarNode#accept(NodeVisitor):::Assist in IR navigation.:::if->visitor->enterVarNode->newInit->init->accept->newName->name->accept->newThis->if->new->VarNode->else->return->visitor->leaveVarNode->return
VarNode#toString(StringBuilder, boolean)::: var node to string:::sb->tokenType->getName->append->append->name->toString->if->sb->append->init->toString
VarNode#getInit():::If this is an assignment of the form var x = init;, get the init part.:::return
VarNode#setInit(Expression):::Reset the initialization expression:::if->return->return->new->VarNode
VarNode#getName():::Get the identifier for the variable:::return
VarNode#setName(IdentNode):::Reset the identifier for this VarNode:::if->return->return->new->VarNode
VarNode#setFlags(int)::: var node set flags:::if->return->return->new->VarNode
VarNode#getFlag(int):::Check if a flag is set for this var node:::return
VarNode#setFlag(int):::Set a flag for this var node:::return->setFlags
VarNode#isFunctionDeclaration():::Returns true if this is a function declaration.:::return->isDeclared
WhileNode#ensureUniqueLabels(LexicalContext)::: while node ensure unique labels:::return->Node->new->WhileNode->replaceInLexicalContext
WhileNode#hasGoto()::: while node has goto:::return
WhileNode#accept(LexicalContext, NodeVisitor)::: while node accept:::if->visitor->enterWhileNode->if->isDoWhile->return->visitor->body->accept->setBody->test->accept->setTest->leaveWhileNode->return->visitor->test->accept->setTest->body->accept->setBody->leaveWhileNode->return
WhileNode#setTest(LexicalContext, JoinPredecessorExpression)::: while node set test:::if->return->return->Node->new->WhileNode->replaceInLexicalContext
WhileNode#getBody()::: while node get body:::return
WhileNode#setBody(LexicalContext, Block)::: while node set body:::if->return->return->Node->new->WhileNode->replaceInLexicalContext
WhileNode#setControlFlowEscapes(LexicalContext, boolean)::: while node set control flow escapes:::if->return->return->Node->new->WhileNode->replaceInLexicalContext
WhileNode#setLocalVariableConversionChanged(LexicalContext, LocalVariableConversion)::: while node set local variable conversion changed:::return->Node->new->WhileNode->replaceInLexicalContext
WhileNode#isDoWhile():::Check if this is a do while loop or a normal while loop:::return
WhileNode#toString(StringBuilder, boolean)::: while node to string:::sb->append->test->toString->sb->append
WhileNode#mustEnter()::: while node must enter:::if->isDoWhile->return->return
WhileNode#hasPerIterationScope()::: while node has per iteration scope:::return
WithNode#accept(LexicalContext, NodeVisitor):::Assist in IR navigation.:::if->visitor->enterWithNode->return->visitor->expression->accept->setExpression->body->accept->setBody->leaveWithNode->return
WithNode#isTerminal()::: with node is terminal:::return->body->isTerminal
WithNode#toString(StringBuilder, boolean)::: with node to string:::sb->append->expression->toString->sb->append
WithNode#getBody():::Get the body of this WithNode:::return
WithNode#setBody(LexicalContext, Block):::Reset the body of this with node:::if->return->return->Node->new->WithNode->replaceInLexicalContext
WithNode#getExpression():::Get the expression of this WithNode:::return
WithNode#setExpression(LexicalContext, Expression):::Reset the expression of this with node:::if->return->return->Node->new->WithNode->replaceInLexicalContext
