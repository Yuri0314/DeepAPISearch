AFLBinaryTreeDictionary#initialize(TypeDataBase)::: binary tree dictionary initialize:::type->db->lookupType->type->getCIntegerField
AFLBinaryTreeDictionary#size()::: binary tree dictionary size:::return->totalSizeField->getValue
AltHashing#murmur3_32(long, byte[])::: alt hashing murmur3_32:::h1->len->count->offset->while->k1->Integer->rotateLeft->Integer->rotateLeft->if->k1->switch->Integer->rotateLeft->return
CodeHeap#initialize(TypeDataBase)::: code heap initialize:::type->db->lookupType->type->getField->type->getField->type->getCIntegerField
CodeHeap#begin()::: code heap begin:::return->getMemory->low
CodeHeap#end()::: code heap end:::return->getMemory->high
CodeHeap#contains(Address)::: code heap contains:::return->begin->lessThanOrEqual->end->greaterThan
CodeHeap#findStart(Address):::Returns the start of the block containing p or null:::if->contains->return->h->blockStart->if->h->isFree->return->return->h->getAllocatedSpace
CodeHeap#nextBlock(Address)::: code heap next block:::base->blockBase->if->return->block->getBlockAt->return->base->block->getLength->getLog2SegmentSize->addOffsetTo
CodeHeap#iterate(CodeCacheVisitor, CodeCache)::: code heap iterate:::lastBlob->ptr->begin->while->ptr->end->lessThan->try->blob->cache->findStart->createCodeBlobWrapper->if->visitor->visit->if->throw->new->InternalError->catch->e->printStackTrace->finally->next->nextBlock->if->next->lessThan->throw->new->InternalError
CodeHeap#getMemory()::: code heap get memory:::return
CodeHeap#getSegmentMap()::: code heap get segment map:::return
CodeHeap#segmentFor(Address)::: code heap segment for:::return->p->getMemory->low->minus->getLog2SegmentSize
CodeHeap#getLog2SegmentSize()::: code heap get log2 segment size:::return
CodeHeap#getBlockAt(Address)::: code heap get block at:::return->VMObjectFactory->newObject
CodeHeap#blockStart(Address)::: code heap block start:::base->blockBase->if->return->return->getBlockAt
CodeHeap#blockBase(Address)::: code heap block base:::i->segmentFor->b->getSegmentMap->low->if->b->getCIntegerAt->return->while->b->getCIntegerAt->b->getCIntegerAt->return->getMemory->low->getLog2SegmentSize->addOffsetTo
Dictionary#initialize(TypeDataBase)::: dictionary initialize:::type->db->lookupType
Dictionary#getHashtableEntryClass()::: dictionary get hashtable entry class:::return
Dictionary#allEntriesDo(ClassLoaderDataGraph.ClassAndLoaderVisitor, Oop):::All classes, and their initiating class loader, passed in.:::tblSize->tableSize->for->index
Dictionary#getEntry(int, long, Symbol)::: dictionary get entry:::for->entry->bucket->entry->next->return
Dictionary#contains(Klass)::: dictionary contains:::hash->c->getName->computeHash->index->hashToIndex->for->entry->bucket->entry->next->return
DictionaryEntry#initialize(TypeDataBase)::: dictionary entry initialize:::type->db->lookupType
DictionaryEntry#klass()::: dictionary entry klass:::return->Metadata->literalValue->instantiateWrapperFor
DictionaryEntry#equals(Symbol)::: dictionary entry equals:::ik->klass->return->ik->getName->equals
FileMapInfo#initialize(TypeDataBase)::: file map info initialize:::type->db->lookupType->currentInfoField->type->getAddressField->headerFieldOffset->type->getField->getOffset->headerAddress->currentInfoField->getValue->addOffsetTo->headerAddress->getAddressAt->db->lookupType->spaceField->type->getAddressField->spaceValue->headerValue->type->getField->getOffset->addOffsetTo->spaceValue->spaceField->getSize->addOffsetTo->db->lookupType->mdRegionBaseAddressOffset->type->getField->getOffset->mdSpaceValue->addOffsetTo->getAddressAt->mdRegionSizeOffset->type->getField->getOffset->mdRegionSize->mdSpaceValue->addOffsetTo->getAddressAt->asLongValue->mdRegionBaseAddress->addOffsetTo->populateMetadataTypeArray
FileMapInfo#populateMetadataTypeArray(TypeDataBase)::: file map info populate metadata type array:::new->TypeArr->db->lookupType->db->lookupType->db->lookupType->db->lookupType->db->lookupType->db->lookupType->db->lookupType->db->lookupType
FileMapInfo#getHeader()::: file map info get header:::if->VMObjectFactory->newObject->return
FileMapInfo#inCopiedVtableSpace(Address)::: file map info in copied vtable space:::fmHeader->getHeader->return->fmHeader->inCopiedVtableSpace
FileMapInfo#getTypeForVptrAddress(Address)::: file map info get type for vptr address:::if->getHeader->createVtableTypeMapping->return->vTableTypeMap->get
FileMapInfo.FileMapHeader#inCopiedVtableSpace(Address)::: file map header in copied vtable space:::if->vptrAddress->greaterThan->vptrAddress->lessThanOrEqual->return->return
FileMapInfo.FileMapHeader#createVtableTypeMapping()::: file map header create vtable type mapping:::new->HashMap<Address,Type>->metadataVTableSize->addressSize->VM->getVM->getAddressSize->copiedVtableAddress->for->i
FreeChunk#initialize(TypeDataBase)::: free chunk initialize:::type->db->lookupType->type->getAddressField->type->getAddressField->type->getAddressField
FreeChunk#next()::: free chunk next:::return->VMObjectFactory->nextField->getValue->newObject
FreeChunk#prev()::: free chunk prev:::prev->prevField->getValue->andWithMask->return->VMObjectFactory->newObject
FreeChunk#size()::: free chunk size:::if->VM->getVM->isCompressedOopsEnabled->mark->addr->sizeField->getOffset->addOffsetTo->new->Mark->return->mark->getSize->else->size->sizeField->getValue->dbg->VM->getVM->getDebugger->return->dbg->getAddressValue
FreeChunk#indicatesFreeChunk(Address)::: free chunk indicates free chunk:::f->new->FreeChunk->return->f->isFree
FreeChunk#isFree()::: free chunk is free:::if->VM->getVM->isCompressedOopsEnabled->mark->addr->sizeField->getOffset->addOffsetTo->new->Mark->return->mark->isCmsFreeChunk->else->prev->prevField->getValue->dbg->VM->getVM->getDebugger->word->dbg->getAddressValue->return
HeapBlock#initialize(TypeDataBase)::: heap block initialize:::type->db->lookupType->type->getSize->type->getField->db->lookupType->type->getCIntegerField->type->getCIntegerField
HeapBlock#getLength()::: heap block get length:::return->getHeader->getLength
HeapBlock#isFree()::: heap block is free:::return->getHeader->isFree
HeapBlock#getAllocatedSpace()::: heap block get allocated space:::return->addr->addOffsetTo
HeapBlock.Header#getLength()::: header get length:::return->headerLengthField->getValue
HeapBlock.Header#isFree()::: header is free:::return->headerUsedField->getValue
HeapBlock#getHeader()::: heap block get header:::return->VMObjectFactory->addr->headerField->getOffset->addOffsetTo->newObject
MemRegion#initialize(TypeDataBase)::: mem region initialize:::type->db->lookupType->type->getAddressField->type->getCIntegerField
MemRegion#clone()::: mem region clone:::return->new->MemRegion
MemRegion#copy()::: mem region copy:::return->clone
MemRegion#intersection(MemRegion)::: mem region intersection:::res->new->MemRegion->if->AddressOps->mr2->start->start->gt->res->mr2->start->setStart->else->res->start->setStart->resEnd->end->end->mr2End->mr2->end->if->AddressOps->lt->else->if->AddressOps->res->start->lt->res->setStart->res->setWordSize->else->res->setEnd->return
MemRegion#union(MemRegion)::: mem region union:::res->new->MemRegion->if->AddressOps->mr2->start->start->lt->res->mr2->start->setStart->else->res->start->setStart->resEnd->end->end->mr2End->mr2->end->if->AddressOps->gt->else->res->setEnd->return
MemRegion#start()::: mem region start:::return
MemRegion#startAsOopHandle()::: mem region start as oop handle:::return->start->addOffsetToAsOopHandle
MemRegion#end()::: mem region end:::return->start->addOffsetTo
MemRegion#endAsOopHandle()::: mem region end as oop handle:::return->end->addOffsetToAsOopHandle
MemRegion#setStart(Address)::: mem region set start:::
MemRegion#setEnd(Address)::: mem region set end:::end->minus
MemRegion#setWordSize(long)::: mem region set word size:::VM->getVM->getAddressSize
MemRegion#contains(MemRegion)::: mem region contains:::return->AddressOps->lte->AddressOps->end->mr2->end->gte
MemRegion#contains(Address)::: mem region contains:::return->AddressOps->start->gte->AddressOps->end->lt
MemRegion#byteSize()::: mem region byte size:::return
MemRegion#wordSize()::: mem region word size:::return->VM->getVM->getAddressSize
SymbolTable#initialize(TypeDataBase)::: symbol table initialize:::type->db->lookupType->type->getAddressField->type->getAddressField->db->lookupType->type->getCIntegerField
SymbolTable#getTheTable()::: symbol table get the table:::tmp->theTableField->getValue->table->VMObjectFactory->newObject->shared->sharedTableField->getStaticFieldAddress->VMObjectFactory->newObject->return
SymbolTable#getSharedTable()::: symbol table get shared table:::return
SymbolTable#getSeed()::: symbol table get seed:::return->seedField->getValue
SymbolTable#useAlternateHashcode()::: symbol table use alternate hashcode:::if->getSeed->return->return
SymbolTable#probe(String):::Clone of VM's "temporary" probe routine, as the SA currently       does not support mutation so lookup() would have no effect       anyway:::try->return->toModifiedUTF8Bytes->probe->catch->return->finally
SymbolTable#probe(byte[]):::Clone of VM's "temporary" probe routine, as the SA currently       does not support mutation so lookup() would have no effect       anyway:::hashValue->hashSymbol->s->sharedTable->probe->if->return->if->useAlternateHashcode->AltHashing->getSeed->murmur3_32->for->e->hashToIndex->bucket->e->next->return
SymbolTable.SymbolVisitor#visit(Symbol)::: symbol visitor visit:::
SymbolTable#symbolsDo(SymbolVisitor)::: symbol table symbols do:::numBuckets->tableSize->for->i
SymbolTable#toModifiedUTF8Bytes(String)::: symbol table to modified f8 bytes:::baos->new->ByteArrayOutputStream->dos->new->DataOutputStream->dos->writeUTF->dos->flush->buf->baos->toByteArray->res->new->byteArr->System->arraycopy->return
SystemDictionary#initialize(TypeDataBase)::: system dictionary initialize:::type->db->lookupType->type->getAddressField->type->getOopField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField->type->WK_KLASS->getAddressField
SystemDictionary#WK_KLASS(String)::: system dictionary  k_ s:::return->WK_KLASS_ENUM_NAME
SystemDictionary#WK_KLASS_ENUM_NAME(String)::: system dictionary  k_ s_ m_ e:::return
SystemDictionary#sharedDictionary()::: system dictionary shared dictionary:::tmp->sharedDictionaryField->getValue->return->VMObjectFactory->newObject
SystemDictionary#getThreadKlass()::: system dictionary get thread klass:::return->Metadata->threadKlassField->getValue->instantiateWrapperFor
SystemDictionary#getThreadGroupKlass()::: system dictionary get thread group klass:::return->Metadata->threadGroupKlassField->getValue->instantiateWrapperFor
SystemDictionary#getObjectKlass()::: system dictionary get object klass:::return->Metadata->objectKlassField->getValue->instantiateWrapperFor
SystemDictionary#getStringKlass()::: system dictionary get string klass:::return->Metadata->stringKlassField->getValue->instantiateWrapperFor
SystemDictionary#getClassLoaderKlass()::: system dictionary get class loader klass:::return->Metadata->classLoaderKlassField->getValue->instantiateWrapperFor
SystemDictionary#getSystemKlass()::: system dictionary get system klass:::return->Metadata->systemKlassField->getValue->instantiateWrapperFor
SystemDictionary#getMethodHandleKlass()::: system dictionary get method handle klass:::return->Metadata->methodHandleKlassField->getValue->instantiateWrapperFor
SystemDictionary#getAbstractOwnableSynchronizerKlass()::: system dictionary get abstract ownable synchronizer klass:::cldg->VM->getVM->getClassLoaderDataGraph->return->cldg->find
SystemDictionary#javaSystemLoader()::: system dictionary java system loader:::return->javaSystemLoaderField->getValue->newOop
SystemDictionary#newOop(OopHandle)::: system dictionary new oop:::return->VM->getVM->getObjectHeap->newOop
Universe#typeExists(TypeDataBase, String)::: universe type exists:::try->db->lookupType->catch->return->finally->return
Universe#addHeapTypeIfInDB(TypeDataBase, Class)::: universe add heap type if in b:::heapName->heapClass->getSimpleName->if->typeExists->heapConstructor->addMapping
Universe#initialize(TypeDataBase)::: universe initialize:::type->db->lookupType->type->getAddressField->new->VirtualConstructor->addHeapTypeIfInDB->addHeapTypeIfInDB->addHeapTypeIfInDB->addHeapTypeIfInDB->addHeapTypeIfInDB->addHeapTypeIfInDB->type->getOopField->type->getOopField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField->type->getCIntegerField->type->getAddressField->type->getCIntegerField->UniverseExt->initialize
Universe#narrowOopModeToString(NARROW_OOP_MODE)::: universe narrow oop mode to string:::switch->return->return->return->return
Universe#heap()::: universe heap:::return->heapConstructor->collectedHeapField->getValue->instantiateWrapperFor
Universe#getNarrowOopBase()::: universe get narrow oop base:::if->narrowOopBaseField->getValue->return->else->return->narrowOopBaseField->getValue->minus
Universe#getNarrowOopShift()::: universe get narrow oop shift:::return->narrowOopShiftField->getValue
Universe#getNarrowKlassBase()::: universe get narrow klass base:::if->narrowKlassBaseField->getValue->return->else->return->narrowKlassBaseField->getValue->minus
Universe#getNarrowKlassShift()::: universe get narrow klass shift:::return->narrowKlassShiftField->getValue
Universe#isIn(Address):::Returns "TRUE" iff "p" points into the allocated area of the heap.:::return->heap->isIn
Universe#isInReserved(Address):::Returns "TRUE" iff "p" points into the reserved area of the heap.:::return->heap->isInReserved
Universe#newOop(OopHandle)::: universe new oop:::return->VM->getVM->getObjectHeap->newOop
Universe#mainThreadGroup()::: universe main thread group:::return->mainThreadGroupField->getValue->newOop
Universe#systemThreadGroup()::: universe system thread group:::return->systemThreadGroupField->getValue->newOop
Universe#print()::: universe print:::printOn
Universe#printOn(PrintStream)::: universe print on:::heap->printOn
Universe#elementTypeShouldBeAligned(BasicType)::: universe element type should be aligned:::return
Universe#fieldTypeShouldBeAligned(BasicType)::: universe field type should be aligned:::return
UniverseExt#initialize(VirtualConstructor)::: universe ext initialize:::
VirtualSpace#initialize(TypeDataBase)::: virtual space initialize:::type->db->lookupType->type->getAddressField->type->getAddressField->type->getAddressField->type->getAddressField
VirtualSpace#low()::: virtual space low:::return->lowField->getValue
VirtualSpace#high()::: virtual space high:::return->highField->getValue
VirtualSpace#lowBoundary()::: virtual space low boundary:::return->lowBoundaryField->getValue
VirtualSpace#highBoundary()::: virtual space high boundary:::return->highBoundaryField->getValue
VirtualSpace#committedSize():::Testers (all sizes are byte sizes):::return->high->low->minus
VirtualSpace#reservedSize()::: virtual space reserved size:::return->highBoundary->lowBoundary->minus
VirtualSpace#uncommittedSize()::: virtual space uncommitted size:::return->reservedSize->committedSize
VirtualSpace#contains(Address)::: virtual space contains:::return->low->lessThanOrEqual->addr->high->lessThan
