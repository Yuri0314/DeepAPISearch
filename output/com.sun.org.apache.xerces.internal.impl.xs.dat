AttributePSVImpl#constant()::: attribute impl constant:::if->isConstant->return->return->new->AttributePSVImpl
AttributePSVImpl#isConstant()::: attribute impl is constant:::return
AttributePSVImpl#getSchemaDefault():::[schema default]:::return->fDeclaration->getConstraintValue
AttributePSVImpl#getSchemaNormalizedValue():::[schema normalized value]:::return->fValue->getNormalizedValue
AttributePSVImpl#getIsSchemaSpecified():::[schema specified]:::return
AttributePSVImpl#getValidationAttempted():::Determines the extent to which the document has been validated:::return
AttributePSVImpl#getValidity():::Determine the validity of the node with respect to the validation being attempted:::return
AttributePSVImpl#getErrorCodes():::A list of error codes generated from validation attempts:::if->return->return->new->PSVIErrorList
AttributePSVImpl#getErrorMessages():::A list of error messages generated from the validation attempt or an empty StringList if no errors occurred during the validation attempt:::if->return->return->new->PSVIErrorList
AttributePSVImpl#getValidationContext()::: attribute impl get validation context:::return
AttributePSVImpl#getTypeDefinition():::An item isomorphic to the type definition used to validate this element.:::return
AttributePSVImpl#getMemberTypeDefinition():::If and only if that type definition is a simple type definition with {variety} union, or a complex type definition whose {content type} is a simple thype definition with {variety} union, then an item isomorphic to that member of the union's {member type definitions} which actually validated the element item's normalized value.:::return->fValue->getMemberTypeDefinition
AttributePSVImpl#getAttributeDeclaration():::An item isomorphic to the attribute declaration used to validate this attribute.:::return
AttributePSVImpl#getActualNormalizedValue()::: attribute impl get actual normalized value:::return->fValue->getActualValue
AttributePSVImpl#getActualNormalizedValueType()::: attribute impl get actual normalized value type:::return->fValue->getActualValueType
AttributePSVImpl#getItemValueTypes()::: attribute impl get item value types:::return->fValue->getListValueTypes
AttributePSVImpl#getSchemaValue()::: attribute impl get schema value:::return
AttributePSVImpl#reset():::Reset():::fValue->reset
ElementPSVImpl#constant()::: element impl constant:::if->isConstant->return->return->new->ElementPSVImpl
ElementPSVImpl#isConstant()::: element impl is constant:::return
ElementPSVImpl#getSchemaDefault():::[schema default]:::return->fDeclaration->getConstraintValue
ElementPSVImpl#getSchemaNormalizedValue():::[schema normalized value]:::return->fValue->getNormalizedValue
ElementPSVImpl#getIsSchemaSpecified():::[schema specified]:::return
ElementPSVImpl#getValidationAttempted():::Determines the extent to which the document has been validated:::return
ElementPSVImpl#getValidity():::Determine the validity of the node with respect to the validation being attempted:::return
ElementPSVImpl#getErrorCodes():::A list of error codes generated from validation attempts:::if->return->return->new->PSVIErrorList
ElementPSVImpl#getErrorMessages():::A list of error messages generated from the validation attempt or an empty StringList if no errors occurred during the validation attempt:::if->return->return->new->PSVIErrorList
ElementPSVImpl#getValidationContext()::: element impl get validation context:::return
ElementPSVImpl#getNil():::[nil]:::return
ElementPSVImpl#getNotation():::[notation]:::return
ElementPSVImpl#getTypeDefinition():::An item isomorphic to the type definition used to validate this element.:::return
ElementPSVImpl#getMemberTypeDefinition():::If and only if that type definition is a simple type definition with {variety} union, or a complex type definition whose {content type} is a simple thype definition with {variety} union, then an item isomorphic to that member of the union's {member type definitions} which actually validated the element item's normalized value.:::return->fValue->getMemberTypeDefinition
ElementPSVImpl#getElementDeclaration():::An item isomorphic to the element declaration used to validate this element.:::return
ElementPSVImpl#getSchemaInformation():::[schema information]:::if->new->XSModelImpl->return
ElementPSVImpl#getActualNormalizedValue()::: element impl get actual normalized value:::return->fValue->getActualValue
ElementPSVImpl#getActualNormalizedValueType()::: element impl get actual normalized value type:::return->fValue->getActualValueType
ElementPSVImpl#getItemValueTypes()::: element impl get item value types:::return->fValue->getListValueTypes
ElementPSVImpl#getSchemaValue()::: element impl get schema value:::return
ElementPSVImpl#reset():::Reset() should be called in validator startElement(..) method.:::fValue->reset
ElementPSVImpl#copySchemaInformationTo(ElementPSVImpl)::: element impl copy schema information to:::
PSVIErrorList#contains(String)::: error list contains:::if->for->i->else->for->i->return
PSVIErrorList#getLength()::: error list get length:::return
PSVIErrorList#item(int)::: error list item:::if->return->return
PSVIErrorList#get(int)::: error list get:::if->return->throw->new->IndexOutOfBoundsException
PSVIErrorList#size()::: error list size:::return->getLength
SchemaGrammar.BuiltinSchemaGrammar#getGrammarDescription()::: builtin schema grammar get grammar description:::return->fGrammarDescription->makeClone
SchemaGrammar.BuiltinSchemaGrammar#setImportedGrammars(List)::: builtin schema grammar set imported grammars:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalAttributeDecl(XSAttributeDecl)::: builtin schema grammar add global attribute decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalAttributeDecl(XSAttributeDecl, String)::: builtin schema grammar add global attribute decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalAttributeGroupDecl(XSAttributeGroupDecl)::: builtin schema grammar add global attribute group decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalAttributeGroupDecl(XSAttributeGroupDecl, String)::: builtin schema grammar add global attribute group decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalElementDecl(XSElementDecl)::: builtin schema grammar add global element decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalElementDecl(XSElementDecl, String)::: builtin schema grammar add global element decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalElementDeclAll(XSElementDecl)::: builtin schema grammar add global element decl all:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalGroupDecl(XSGroupDecl)::: builtin schema grammar add global group decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalGroupDecl(XSGroupDecl, String)::: builtin schema grammar add global group decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalNotationDecl(XSNotationDecl)::: builtin schema grammar add global notation decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalNotationDecl(XSNotationDecl, String)::: builtin schema grammar add global notation decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalTypeDecl(XSTypeDefinition)::: builtin schema grammar add global type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalTypeDecl(XSTypeDefinition, String)::: builtin schema grammar add global type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalComplexTypeDecl(XSComplexTypeDecl)::: builtin schema grammar add global complex type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalComplexTypeDecl(XSComplexTypeDecl, String)::: builtin schema grammar add global complex type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalSimpleTypeDecl(XSSimpleType)::: builtin schema grammar add global simple type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addGlobalSimpleTypeDecl(XSSimpleType, String)::: builtin schema grammar add global simple type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addComplexTypeDecl(XSComplexTypeDecl, SimpleLocator)::: builtin schema grammar add complex type decl:::
SchemaGrammar.BuiltinSchemaGrammar#addRedefinedGroupDecl(XSGroupDecl, XSGroupDecl, SimpleLocator)::: builtin schema grammar add redefined group decl:::
SchemaGrammar.BuiltinSchemaGrammar#addDocument(Object, String)::: builtin schema grammar add document:::
SchemaGrammar.BuiltinSchemaGrammar#getDOMParser()::: builtin schema grammar get parser:::return
SchemaGrammar.BuiltinSchemaGrammar#getSAXParser()::: builtin schema grammar get parser:::return
SchemaGrammar.Schema4Annotations#getGrammarDescription()::: schema4 annotations get grammar description:::return->fGrammarDescription->makeClone
SchemaGrammar.Schema4Annotations#setImportedGrammars(List)::: schema4 annotations set imported grammars:::
SchemaGrammar.Schema4Annotations#addGlobalAttributeDecl(XSAttributeDecl)::: schema4 annotations add global attribute decl:::
SchemaGrammar.Schema4Annotations#addGlobalAttributeDecl(XSAttributeGroupDecl, String)::: schema4 annotations add global attribute decl:::
SchemaGrammar.Schema4Annotations#addGlobalAttributeGroupDecl(XSAttributeGroupDecl)::: schema4 annotations add global attribute group decl:::
SchemaGrammar.Schema4Annotations#addGlobalAttributeGroupDecl(XSAttributeGroupDecl, String)::: schema4 annotations add global attribute group decl:::
SchemaGrammar.Schema4Annotations#addGlobalElementDecl(XSElementDecl)::: schema4 annotations add global element decl:::
SchemaGrammar.Schema4Annotations#addGlobalElementDecl(XSElementDecl, String)::: schema4 annotations add global element decl:::
SchemaGrammar.Schema4Annotations#addGlobalElementDeclAll(XSElementDecl)::: schema4 annotations add global element decl all:::
SchemaGrammar.Schema4Annotations#addGlobalGroupDecl(XSGroupDecl)::: schema4 annotations add global group decl:::
SchemaGrammar.Schema4Annotations#addGlobalGroupDecl(XSGroupDecl, String)::: schema4 annotations add global group decl:::
SchemaGrammar.Schema4Annotations#addGlobalNotationDecl(XSNotationDecl)::: schema4 annotations add global notation decl:::
SchemaGrammar.Schema4Annotations#addGlobalNotationDecl(XSNotationDecl, String)::: schema4 annotations add global notation decl:::
SchemaGrammar.Schema4Annotations#addGlobalTypeDecl(XSTypeDefinition)::: schema4 annotations add global type decl:::
SchemaGrammar.Schema4Annotations#addGlobalTypeDecl(XSTypeDefinition, String)::: schema4 annotations add global type decl:::
SchemaGrammar.Schema4Annotations#addGlobalComplexTypeDecl(XSComplexTypeDecl)::: schema4 annotations add global complex type decl:::
SchemaGrammar.Schema4Annotations#addGlobalComplexTypeDecl(XSComplexTypeDecl, String)::: schema4 annotations add global complex type decl:::
SchemaGrammar.Schema4Annotations#addGlobalSimpleTypeDecl(XSSimpleType)::: schema4 annotations add global simple type decl:::
SchemaGrammar.Schema4Annotations#addGlobalSimpleTypeDecl(XSSimpleType, String)::: schema4 annotations add global simple type decl:::
SchemaGrammar.Schema4Annotations#addComplexTypeDecl(XSComplexTypeDecl, SimpleLocator)::: schema4 annotations add complex type decl:::
SchemaGrammar.Schema4Annotations#addRedefinedGroupDecl(XSGroupDecl, XSGroupDecl, SimpleLocator)::: schema4 annotations add redefined group decl:::
SchemaGrammar.Schema4Annotations#addDocument(Object, String)::: schema4 annotations add document:::
SchemaGrammar.Schema4Annotations#getDOMParser()::: schema4 annotations get parser:::return
SchemaGrammar.Schema4Annotations#getSAXParser()::: schema4 annotations get parser:::return
SchemaGrammar.Schema4Annotations#createAnnotationElementDecl(String)::: schema4 annotations create annotation element decl:::eDecl->new->XSElementDecl->eDecl->setIsGlobal->eDecl->setConstraintType->return
SchemaGrammar.Schema4Annotations#createUnboundedModelGroupParticle()::: schema4 annotations create unbounded model group particle:::particle->new->XSParticleDecl->return
SchemaGrammar.Schema4Annotations#createChoiceElementParticle(XSElementDecl)::: schema4 annotations create choice element particle:::particle->new->XSParticleDecl->return
SchemaGrammar.Schema4Annotations#createUnboundedAnyWildcardSequenceParticle()::: schema4 annotations create unbounded any wildcard sequence particle:::particle->createUnboundedModelGroupParticle->sequence->new->XSModelGroupImpl->new->XSParticleDeclArr->createAnyLaxWildcardParticle->return
SchemaGrammar.Schema4Annotations#createAnyLaxWildcardParticle()::: schema4 annotations create any lax wildcard particle:::particle->new->XSParticleDecl->anyWC->new->XSWildcardDecl->return
SchemaGrammar#getGrammarDescription()::: schema grammar get grammar description:::return
SchemaGrammar#isNamespaceAware()::: schema grammar is namespace aware:::return
SchemaGrammar#setImportedGrammars(List)::: schema grammar set imported grammars:::
SchemaGrammar#getImportedGrammars()::: schema grammar get imported grammars:::return
SchemaGrammar#getTargetNamespace():::Returns this grammar's target namespace.:::return
SchemaGrammar#addGlobalAttributeDecl(XSAttributeDecl):::register one global attribute:::fGlobalAttrDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalAttributeDecl(XSAttributeDecl, String)::: schema grammar add global attribute decl:::fGlobalAttrDeclsExt->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalAttributeGroupDecl(XSAttributeGroupDecl):::register one global attribute group:::fGlobalAttrGrpDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalAttributeGroupDecl(XSAttributeGroupDecl, String)::: schema grammar add global attribute group decl:::fGlobalAttrGrpDeclsExt->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalElementDeclAll(XSElementDecl):::register one global element:::if->fAllGlobalElemDecls->get->fAllGlobalElemDecls->put->if->if->resize
SchemaGrammar#addGlobalElementDecl(XSElementDecl)::: schema grammar add global element decl:::fGlobalElemDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalElementDecl(XSElementDecl, String)::: schema grammar add global element decl:::fGlobalElemDeclsExt->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalGroupDecl(XSGroupDecl):::register one global group:::fGlobalGroupDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalGroupDecl(XSGroupDecl, String)::: schema grammar add global group decl:::fGlobalGroupDeclsExt->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalNotationDecl(XSNotationDecl):::register one global notation:::fGlobalNotationDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalNotationDecl(XSNotationDecl, String)::: schema grammar add global notation decl:::fGlobalNotationDeclsExt->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalTypeDecl(XSTypeDefinition):::register one global type:::fGlobalTypeDecls->decl->getName->put->if->setNamespaceItem->else->if->setNamespaceItem
SchemaGrammar#addGlobalTypeDecl(XSTypeDefinition, String)::: schema grammar add global type decl:::fGlobalTypeDeclsExt->decl->getName->put->if->decl->getNamespaceItem->if->setNamespaceItem->else->if->setNamespaceItem
SchemaGrammar#addGlobalComplexTypeDecl(XSComplexTypeDecl):::register one global complex type:::fGlobalTypeDecls->decl->getName->put->decl->setNamespaceItem
SchemaGrammar#addGlobalComplexTypeDecl(XSComplexTypeDecl, String)::: schema grammar add global complex type decl:::fGlobalTypeDeclsExt->decl->getName->put->if->decl->getNamespaceItem->decl->setNamespaceItem
SchemaGrammar#addGlobalSimpleTypeDecl(XSSimpleType):::register one global simple type:::fGlobalTypeDecls->decl->getName->put->if->setNamespaceItem
SchemaGrammar#addGlobalSimpleTypeDecl(XSSimpleType, String)::: schema grammar add global simple type decl:::fGlobalTypeDeclsExt->decl->getName->put->if->decl->getNamespaceItem->setNamespaceItem
SchemaGrammar#addIDConstraintDecl(XSElementDecl, IdentityConstraint):::register one identity constraint:::elmDecl->addIDConstraint->fGlobalIDConstraintDecls->decl->getIdentityConstraintName->put
SchemaGrammar#addIDConstraintDecl(XSElementDecl, IdentityConstraint, String)::: schema grammar add constraint decl:::fGlobalIDConstraintDeclsExt->decl->getIdentityConstraintName->put
SchemaGrammar#getGlobalAttributeDecl(String):::get one global attribute:::return->fGlobalAttrDecls->get
SchemaGrammar#getGlobalAttributeDecl(String, String)::: schema grammar get global attribute decl:::return->fGlobalAttrDeclsExt->get
SchemaGrammar#getGlobalAttributeGroupDecl(String):::get one global attribute group:::return->fGlobalAttrGrpDecls->get
SchemaGrammar#getGlobalAttributeGroupDecl(String, String)::: schema grammar get global attribute group decl:::return->fGlobalAttrGrpDeclsExt->get
SchemaGrammar#getGlobalElementDecl(String):::get one global element:::return->fGlobalElemDecls->get
SchemaGrammar#getGlobalElementDecl(String, String)::: schema grammar get global element decl:::return->fGlobalElemDeclsExt->get
SchemaGrammar#getGlobalGroupDecl(String):::get one global group:::return->fGlobalGroupDecls->get
SchemaGrammar#getGlobalGroupDecl(String, String)::: schema grammar get global group decl:::return->fGlobalGroupDeclsExt->get
SchemaGrammar#getGlobalNotationDecl(String):::get one global notation:::return->fGlobalNotationDecls->get
SchemaGrammar#getGlobalNotationDecl(String, String)::: schema grammar get global notation decl:::return->fGlobalNotationDeclsExt->get
SchemaGrammar#getGlobalTypeDecl(String):::get one global type:::return->fGlobalTypeDecls->get
SchemaGrammar#getGlobalTypeDecl(String, String)::: schema grammar get global type decl:::return->fGlobalTypeDeclsExt->get
SchemaGrammar#getIDConstraintDecl(String):::get one identity constraint:::return->fGlobalIDConstraintDecls->get
SchemaGrammar#getIDConstraintDecl(String, String)::: schema grammar get constraint decl:::return->fGlobalIDConstraintDeclsExt->get
SchemaGrammar#hasIDConstraints():::get one identity constraint:::return->fGlobalIDConstraintDecls->getLength
SchemaGrammar#addComplexTypeDecl(XSComplexTypeDecl, SimpleLocator):::add one complex type decl: for later constraint checking:::if->resize->resize
SchemaGrammar#addRedefinedGroupDecl(XSGroupDecl, XSGroupDecl, SimpleLocator):::add a group redefined by restriction: for later constraint checking:::if->resize->resize
SchemaGrammar#getUncheckedComplexTypeDecls():::get all complex type decls: for later constraint checking:::if->resize->resize->return
SchemaGrammar#getUncheckedCTLocators():::get the error locator of all complex type decls:::if->resize->resize->return
SchemaGrammar#getRedefinedGroupDecls():::get all redefined groups: for later constraint checking:::if->resize->resize->return
SchemaGrammar#getRGLocators():::get the error locator of all redefined groups:::if->resize->resize->return
SchemaGrammar#setUncheckedTypeNum(int):::after the first-round checking, some types don't need to be checked against UPA again:::resize->resize
SchemaGrammar#getSubstitutionGroups():::get all substitution group information: for the 3 constraint checking:::if->resize->return
SchemaGrammar.XSAnyType#setValues(String, String, XSTypeDefinition, short, short, short, short, boolean, XSAttributeGroupDecl, XSSimpleType, XSParticleDecl)::: any type set values:::
SchemaGrammar.XSAnyType#setName(String)::: any type set name:::
SchemaGrammar.XSAnyType#setIsAbstractType()::: any type set is abstract type:::
SchemaGrammar.XSAnyType#setContainsTypeID()::: any type set contains type d:::
SchemaGrammar.XSAnyType#setIsAnonymous()::: any type set is anonymous:::
SchemaGrammar.XSAnyType#reset()::: any type reset:::
SchemaGrammar.XSAnyType#getAnnotations()::: any type get annotations:::return
SchemaGrammar.XSAnyType#getNamespaceItem()::: any type get namespace item:::return
SchemaGrammar.XSAnyType#createAttrGrp()::: any type create attr grp:::wildcard->new->XSWildcardDecl->attrGrp->new->XSAttributeGroupDecl->return
SchemaGrammar.XSAnyType#createParticle()::: any type create particle:::wildcard->new->XSWildcardDecl->particleW->new->XSParticleDecl->group->new->XSModelGroupImpl->new->XSParticleDeclArr->particleG->new->XSParticleDecl->return
SchemaGrammar.BuiltinAttrDecl#setValues(String, String, XSSimpleType, short, short, ValidatedInfo, XSComplexTypeDecl)::: builtin attr decl set values:::
SchemaGrammar.BuiltinAttrDecl#reset()::: builtin attr decl reset:::
SchemaGrammar.BuiltinAttrDecl#getAnnotation()::: builtin attr decl get annotation:::return
SchemaGrammar.BuiltinAttrDecl#getNamespaceItem()::: builtin attr decl get namespace item:::return
SchemaGrammar#getS4SGrammar(short)::: schema grammar get s4 grammar:::if->return->else->return
SchemaGrammar#resize(XSComplexTypeDecl[], int)::: schema grammar resize:::newArray->new->XSComplexTypeDeclArr->System->Math->min->arraycopy->return
SchemaGrammar#resize(XSGroupDecl[], int)::: schema grammar resize:::newArray->new->XSGroupDeclArr->System->Math->min->arraycopy->return
SchemaGrammar#resize(XSElementDecl[], int)::: schema grammar resize:::newArray->new->XSElementDeclArr->System->Math->min->arraycopy->return
SchemaGrammar#resize(SimpleLocator[], int)::: schema grammar resize:::newArray->new->SimpleLocatorArr->System->Math->min->arraycopy->return
SchemaGrammar#addDocument(Object, String)::: schema grammar add document:::if->new->CopyOnWriteArrayList<>->new->CopyOnWriteArrayList<>->fDocuments->add->fLocations->add
SchemaGrammar#removeDocument(int)::: schema grammar remove document:::if->fDocuments->size->fDocuments->remove->fLocations->remove
SchemaGrammar#getSchemaNamespace():::[schema namespace]:::return
SchemaGrammar#getDOMParser()::: schema grammar get parser:::if->parser->fDOMParser->get->if->return->config->new->XML11Configuration->config->setFeature->config->setFeature->parser->new->DOMParser->try->parser->setFeature->catch->finally->new->SoftReference<DOMParser>->return
SchemaGrammar#getSAXParser()::: schema grammar get parser:::if->parser->fSAXParser->get->if->return->config->new->XML11Configuration->config->setFeature->config->setFeature->parser->new->SAXParser->new->SoftReference<SAXParser>->return
SchemaGrammar#getComponents(short):::[schema components]: a list of top-level components, i.e:::if->return->if->new->XSNamedMapArr->if->table->switch->break->break->break->break->break->break->break->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
SchemaGrammar#getComponentsExt(short)::: schema grammar get components ext:::if->return->if->new->ObjectListArr->if->table->switch->break->break->break->break->break->break->break->entries->table->getEntries->new->ObjectListImpl->return
SchemaGrammar#resetComponents()::: schema grammar reset components:::
SchemaGrammar#getTypeDefinition(String):::Convenience method:::return->getGlobalTypeDecl
SchemaGrammar#getAttributeDeclaration(String):::Convenience method:::return->getGlobalAttributeDecl
SchemaGrammar#getElementDeclaration(String):::Convenience method:::return->getGlobalElementDecl
SchemaGrammar#getAttributeGroup(String):::Convenience method:::return->getGlobalAttributeGroupDecl
SchemaGrammar#getModelGroupDefinition(String):::Convenience method:::return->getGlobalGroupDecl
SchemaGrammar#getNotationDeclaration(String):::Convenience method:::return->getGlobalNotationDecl
SchemaGrammar#getIDCDefinition(String)::: schema grammar get definition:::return->getIDConstraintDecl
SchemaGrammar#getDocumentLocations():::[document location]:::return->new->StringListImpl
SchemaGrammar#toXSModel():::Return an XSModel that represents components in this schema grammar.:::return->new->SchemaGrammarArr->new->XSModelImpl
SchemaGrammar#toXSModel(XSGrammar[])::: schema grammar to model:::if->return->toXSModel->len->hasSelf->for->i->gs->new->SchemaGrammarArr->for->i->if->return->new->XSModelImpl
SchemaGrammar#getAnnotations()::: schema grammar get annotations:::if->return->return->new->XSObjectListImpl
SchemaGrammar#addAnnotation(XSAnnotationImpl)::: schema grammar add annotation:::if->return->if->new->XSAnnotationImplArr->else->if->newArray->new->XSAnnotationImplArr->System->arraycopy
SchemaGrammar#setImmutable(boolean)::: schema grammar set immutable:::
SchemaGrammar#isImmutable()::: schema grammar is immutable:::return
SchemaNamespaceSupport#setEffectiveContext(String[]):::This method takes a set of Strings, as stored in a NamespaceSupport object, and "fools" the object into thinking that this is one unified context:::if->return->pushContext->newSize->if->tempNSArray->new->StringArr->System->arraycopy->System->arraycopy
SchemaNamespaceSupport#getEffectiveLocalContext():::This method returns an array of Strings, as would be stored in a NamespaceSupport object:::returnVal->if->bottomLocalContext->copyCount->if->new->StringArr->System->arraycopy->return
SchemaNamespaceSupport#makeGlobal()::: schema namespace support make global:::if
SubstitutionGroupHandler#getMatchingElemDecl(QName, XSElementDecl)::: substitution group handler get matching elem decl:::if->return->if->return->if->return->eDecl->fXSElementDeclHelper->getGlobalElementDecl->if->return->if->substitutionGroupOK->return->return
SubstitutionGroupHandler#substitutionGroupOK(XSElementDecl, XSElementDecl, short)::: substitution group handler substitution group k:::if->return->if->return->subGroup->while->if->return->return->typeDerivationOK
SubstitutionGroupHandler#typeDerivationOK(XSTypeDefinition, XSTypeDefinition, short)::: substitution group handler type derivation k:::devMethod->blockConstraint->type->while->if->type->getTypeCategory->else->type->getBaseType->if->if->type->getTypeCategory->if->if->base->getTypeCategory->st->if->st->getVariety->memberTypes->st->getMemberTypes->length->memberTypes->getLength->for->i->return->if->return->return
SubstitutionGroupHandler#inSubstitutionGroup(XSElementDecl, XSElementDecl)::: substitution group handler in substitution group:::return->substitutionGroupOK
SubstitutionGroupHandler#reset():::clear the internal registry of substitutionGroup information:::fSubGroupsB->clear->fSubGroups->clear
SubstitutionGroupHandler#addSubstitutionGroup(XSElementDecl[]):::add a list of substitution group information.:::subHead->element->subGroup->for->i
SubstitutionGroupHandler#getSubstitutionGroup(XSElementDecl):::get all elements that can substitute the given element, according to the spec, we shouldn't consider the {block} constraints:::subGroup->fSubGroups->get->if->return->if->fSubGroups->put->return->groupB->new->OneSubGroup->getSubGroupB->len->rlen->ret->new->XSElementDeclArr->for->i->if->ret1->new->XSElementDeclArr->System->arraycopy->fSubGroups->put->return
SubstitutionGroupHandler#getSubGroupB(XSElementDecl, OneSubGroup)::: substitution group handler get sub group b:::subGroup->fSubGroupsB->get->if->fSubGroupsB->put->return->if->return->group->newGroup->new->ArrayList<>->group1->dMethod->bMethod->dSubMethod->bSubMethod->for->i->group->size->j->ret->newGroup->size->new->OneSubGroupArr->for->i->newGroup->size->fSubGroupsB->put->return
SubstitutionGroupHandler#getDBMethods(XSTypeDefinition, XSTypeDefinition, OneSubGroup)::: substitution group handler get methods:::dMethod->bMethod->while->if->typed->getTypeCategory->else->typed->getBaseType->if->if->typed->getTypeCategory->if->return->return
XMLSchemaException#getKey()::: schema exception get key:::return
XMLSchemaException#getArgs()::: schema exception get args:::return
XMLSchemaLoader#getRecognizedFeatures():::Returns a list of feature identifiers that are recognized by this XMLGrammarLoader:::return->RECOGNIZED_FEATURES->clone
XMLSchemaLoader#getFeature(String):::Returns the state of a feature.:::return->fLoaderConfig->getFeature
XMLSchemaLoader#setFeature(String, boolean):::Sets the state of a feature.:::if->featureId->equals->fErrorReporter->setFeature->else->if->featureId->equals->fSchemaHandler->setGenerateSyntheticAnnotations->fLoaderConfig->setFeature
XMLSchemaLoader#getRecognizedProperties():::Returns a list of property identifiers that are recognized by this XMLGrammarLoader:::return->RECOGNIZED_PROPERTIES->clone
XMLSchemaLoader#getProperty(String):::Returns the state of a property.:::return->fLoaderConfig->getProperty
XMLSchemaLoader#setProperty(String, Object):::Sets the state of a property.:::fLoaderConfig->setProperty->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->setLocale->else->if->propertyId->equals->fEntityManager->setProperty->else->if->propertyId->equals->if->fErrorReporter->getMessageFormatter->fErrorReporter->new->XSMessageFormatter->putMessageFormatter->else->if->propertyId->equals->spm->spm->getValue
XMLSchemaLoader#setLocale(Locale):::Set the locale to use for messages.:::fErrorReporter->setLocale
XMLSchemaLoader#getLocale():::Return the Locale the XMLGrammarLoader is using.:::return
XMLSchemaLoader#setErrorHandler(XMLErrorHandler):::Sets the error handler.:::fErrorReporter->setProperty
XMLSchemaLoader#getErrorHandler():::Returns the registered error handler.:::return->fErrorReporter->getErrorHandler
XMLSchemaLoader#setEntityResolver(XMLEntityResolver):::Sets the entity resolver.:::fLoaderConfig->setProperty->fEntityManager->setProperty
XMLSchemaLoader#getEntityResolver():::Returns the registered entity resolver.:::return
XMLSchemaLoader#loadGrammar(XMLInputSource[]):::Returns a Grammar object by parsing the contents of the entities pointed to by sources.:::numSource->for->i
XMLSchemaLoader#loadGrammar(XMLInputSource):::Returns a Grammar object by parsing the contents of the entity pointed to by source.:::reset->desc->new->XSDDescription->desc->source->getBaseSystemId->setBaseSystemId->desc->source->getSystemId->setLiteralSystemId->locationPairs->new->HashMap<>->processExternalHints->grammar->loadSchema->if->fGrammarPool->fGrammarBucket->getGrammars->cacheGrammars->if->fJAXPCache->get->XSConstraints->fullSchemaChecking->return
XMLSchemaLoader#loadSchema(XSDDescription, XMLInputSource, Map):::This method is called either from XMLGrammarLoader.loadGrammar or from XMLSchemaValidator:::if->processJAXPSchemaSource->if->desc->isExternal->source->isCreatedByResolver->accessError->SecuritySupport->desc->getExpandedSystemId->checkAccess->if->throw->fErrorReporter->new->ObjectArr->SecuritySupport->desc->getExpandedSystemId->sanitizePath->reportError->new->XNIException->grammar->fSchemaHandler->parseSchema->return
XMLSchemaLoader#resolveDocument(XSDDescription, Map, XMLEntityResolver):::This method tries to resolve location of the given schema:::loc->if->desc->getContextType->desc->fromInstance->namespace->desc->getTargetNamespace->ns->tempLA->locationPairs->get->if->tempLA->getFirstLocation->if->hints->desc->getLocationHints->if->expandedLoc->XMLEntityManager->desc->getBaseSystemId->expandSystemId->desc->setLiteralSystemId->desc->setExpandedSystemId->return->entityResolver->resolveEntity
XMLSchemaLoader#processExternalHints(String, String, Map, XMLErrorReporter)::: schema loader process external hints:::if->try->attrDecl->getGlobalAttributeDecl->validate->if->tokenizeSchemaLocationStr->er->new->ObjectArr->reportError->catch->er->ex->getKey->ex->getArgs->reportError->finally->if->try->attrDecl->getGlobalAttributeDecl->validate->la->locations->get->if->new->LocationArray->locations->put->la->addLocation->catch->er->ex->getKey->ex->getArgs->reportError->finally
XMLSchemaLoader#tokenizeSchemaLocationStr(String, Map, String)::: schema loader tokenize schema location str:::if->t->new->StringTokenizer->namespace->location->while->t->hasMoreTokens->t->nextToken->if->t->hasMoreTokens->return->t->nextToken->la->locations->get->if->new->LocationArray->locations->put->if->try->XMLEntityManager->expandSystemId->catch->finally->la->addLocation->return
XMLSchemaLoader#processJAXPSchemaSource(Map):::Translate the various JAXP SchemaSource property types to XNI XMLInputSource:::if->return->componentType->fJAXPSource->getClass->getComponentType->xis->sid->if->if->g->fJAXPCache->get->if->fGrammarBucket->putGrammar->return->fXSDDescription->reset->xsdToXMLInputSource->xis->getSystemId->if->fXSDDescription->xis->getBaseSystemId->setBaseSystemId->fXSDDescription->setLiteralSystemId->fXSDDescription->setExpandedSystemId->new->StringArr->g->loadSchema->if->if->fJAXPCache->put->if->XSConstraints->fullSchemaChecking->fGrammarBucket->putGrammar->return->else->if->isAssignableFrom->isAssignableFrom->isAssignableFrom->componentType->isInterface->mf->fErrorReporter->getMessageFormatter->throw->mf->fErrorReporter->getLocale->new->ObjectArr->componentType->getName->formatMessage->new->XMLConfigurationException->objArr->jaxpSchemaSourceNamespaces->new->ArrayList<>->for->i
XMLSchemaLoader#xsdToXMLInputSource(Object)::: schema loader xsd to input source:::if->loc->fXSDDescription->reset->fXSDDescription->setValues->xis->try->fEntityManager->resolveEntity->catch->fErrorReporter->new->ObjectArr->reportError->finally->if->return->new->XMLInputSource->return->else->if->return->saxToXMLInputSource->else->if->return->new->XMLInputSource->else->if->file->is->try->new->FileInputStream->new->BufferedInputStream->catch->fErrorReporter->new->ObjectArr->file->toString->reportError->finally->return->file->toURI->toString->new->XMLInputSource->mf->fErrorReporter->getMessageFormatter->throw->mf->fErrorReporter->getLocale->new->ObjectArr->val->getClass->getName->formatMessage->new->XMLConfigurationException
XMLSchemaLoader#saxToXMLInputSource(InputSource)::: schema loader sax to input source:::publicId->sis->getPublicId->systemId->sis->getSystemId->charStream->sis->getCharacterStream->if->return->new->XMLInputSource->byteStream->sis->getByteStream->if->return->sis->getEncoding->new->XMLInputSource->return->new->XMLInputSource
XMLSchemaLoader.LocationArray#resize(int, int)::: location array resize:::temp->new->StringArr->System->Math->min->arraycopy->Math->min
XMLSchemaLoader.LocationArray#addLocation(String)::: location array add location:::if->Math->max->resize
XMLSchemaLoader.LocationArray#getLocationArray()::: location array get location array:::if->resize->return
XMLSchemaLoader.LocationArray#getFirstLocation()::: location array get first location:::return
XMLSchemaLoader.LocationArray#getLength()::: location array get length:::return
XMLSchemaLoader#getFeatureDefault(String)::: schema loader get feature default:::if->featureId->equals->return->return
XMLSchemaLoader#getPropertyDefault(String)::: schema loader get property default:::return
XMLSchemaLoader#reset(XMLComponentManager)::: schema loader reset:::spm->componentManager->getProperty->if->new->XMLSecurityPropertyManager->setProperty->sm->componentManager->getProperty->if->new->XMLSecurityManager->setProperty->spm->getValue->fGrammarBucket->reset->fSubGroupHandler->reset->parser_settings->if->componentManager->getFeature->if->initGrammarBucket->if->fDeclPool->reset->return->fNodeFactory->reset->componentManager->getProperty->componentManager->getProperty->dvFactory->fSchemaHandler->getDVFactory->if->SchemaDVFactory->getInstance->fSchemaHandler->setDVFactory->try->componentManager->getProperty->componentManager->getProperty->catch->finally->componentManager->getProperty->componentManager->getProperty->initGrammarBucket->psvi->componentManager->getFeature->if->if->fDeclPool->reset->else->new->XSDeclarationPool->fCMBuilder->setDeclPool->fSchemaHandler->setDeclPool->if->fDeclPool->setDVFactory->setDeclPool->else->fCMBuilder->setDeclPool->fSchemaHandler->setDeclPool->if->setDeclPool->try->fatalError->componentManager->getFeature->if->fErrorReporter->setFeature->catch->finally->componentManager->getFeature->fSchemaHandler->componentManager->getFeature->setGenerateSyntheticAnnotations->fSchemaHandler->reset
XMLSchemaLoader#initGrammarBucket()::: schema loader init grammar bucket:::if->initialGrammars->fGrammarPool->retrieveInitialGrammarSet->length->for->i
XMLSchemaLoader#getConfig()::: schema loader get config:::return
XMLSchemaLoader#load(LSInput)::: schema loader load:::try->g->dom2xmlInputSource->loadGrammar->return->toXSModel->catch->reportDOMFatalError->return->finally
XMLSchemaLoader#loadInputList(LSInputList)::: schema loader load input list:::length->is->getLength->gs->new->SchemaGrammarArr->for->i->return->new->XSModelImpl
XMLSchemaLoader#loadURI(String)::: schema loader load i:::try->g->new->XMLInputSource->loadGrammar->return->toXSModel->catch->reportDOMFatalError->return->finally
XMLSchemaLoader#loadURIList(StringList)::: schema loader load list:::length->uriList->getLength->gs->new->SchemaGrammarArr->for->i->return->new->XSModelImpl
XMLSchemaLoader#reportDOMFatalError(Exception)::: schema loader report fatal error:::if->error->new->DOMErrorImpl->e->getMessage->fErrorHandler->getErrorHandler->handleError
XMLSchemaLoader#canSetParameter(String, Object)::: schema loader can set parameter:::if->if->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->return->return->if->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->return->return
XMLSchemaLoader#getParameter(String)::: schema loader get parameter:::if->name->equals->return->fErrorHandler->getErrorHandler->else->if->name->equals->return->fResourceResolver->getEntityResolver->try->feature->getFeature->return->catch->property->try->getProperty->return->catch->msg->DOMMessageFormatter->new->ObjectArr->formatMessage->throw->new->DOMException->finally->finally
XMLSchemaLoader#getParameterNames()::: schema loader get parameter names:::if->v->new->ArrayList<>->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->v->add->new->DOMStringListImpl->return
XMLSchemaLoader#setParameter(String, Object)::: schema loader set parameter:::if->state->booleanValue->if->name->equals->return->try->setFeature->catch->msg->DOMMessageFormatter->new->ObjectArr->formatMessage->throw->new->DOMException->finally->return->if->name->equals->if->try->new->DOMErrorHandlerWrapper->setErrorHandler->catch->finally->else->msg->DOMMessageFormatter->new->ObjectArr->formatMessage->throw->new->DOMException->return->if->name->equals->if->try->new->DOMEntityResolverWrapper->setEntityResolver->catch->finally->else->msg->DOMMessageFormatter->new->ObjectArr->formatMessage->throw->new->DOMException->return->try->setProperty->catch->msg->DOMMessageFormatter->new->ObjectArr->formatMessage->throw->new->DOMException->finally
XMLSchemaLoader#dom2xmlInputSource(LSInput)::: schema loader dom2xml input source:::xis->if->is->getCharacterStream->is->getPublicId->is->getSystemId->is->getBaseURI->is->getCharacterStream->new->XMLInputSource->else->if->is->getByteStream->is->getPublicId->is->getSystemId->is->getBaseURI->is->getByteStream->is->getEncoding->new->XMLInputSource->else->if->is->getStringData->is->getStringData->length->is->getPublicId->is->getSystemId->is->getBaseURI->is->getStringData->new->StringReader->new->XMLInputSource->else->is->getPublicId->is->getSystemId->is->getBaseURI->new->XMLInputSource->return
XMLSchemaLoader#getGlobalElementDecl(QName)::: schema loader get global element decl:::sGrammar->fGrammarBucket->getGrammar->if->return->sGrammar->getGlobalElementDecl->return
XMLSchemaValidator.XSIErrorReporter#reset(XMLErrorReporter)::: error reporter reset:::fErrors->removeAllElements
XMLSchemaValidator.XSIErrorReporter#pushContext()::: error reporter push context:::if->return->if->newSize->newArray->new->intArr->System->arraycopy->fErrors->size
XMLSchemaValidator.XSIErrorReporter#popContext()::: error reporter pop context:::if->return->contextPos->size->fErrors->size->if->return->errors->new->StringArr->for->i->fErrors->setSize->return
XMLSchemaValidator.XSIErrorReporter#mergeContext()::: error reporter merge context:::if->return->contextPos->size->fErrors->size->if->return->errors->new->StringArr->for->i->return
XMLSchemaValidator.XSIErrorReporter#reportError(String, String, Object[], short)::: error reporter report error:::message->fErrorReporter->reportError->if->fErrors->add->fErrors->add
XMLSchemaValidator.XSIErrorReporter#reportError(XMLLocator, String, String, Object[], short)::: error reporter report error:::message->fErrorReporter->reportError->if->fErrors->add->fErrors->add
XMLSchemaValidator#getRecognizedFeatures():::Returns a list of feature identifiers that are recognized by this component:::return->RECOGNIZED_FEATURES->clone
XMLSchemaValidator#setFeature(String, boolean):::Sets the state of a feature:::
XMLSchemaValidator#getRecognizedProperties():::Returns a list of property identifiers that are recognized by this component:::return->RECOGNIZED_PROPERTIES->clone
XMLSchemaValidator#setProperty(String, Object):::Sets the value of a property:::if->propertyId->equals->if->else->if->else->else->if->propertyId->equals->if->else->if->else
XMLSchemaValidator#getFeatureDefault(String):::Returns the default state for a feature, or null if this component does not want to report a default value for this feature.:::for->i->return
XMLSchemaValidator#getPropertyDefault(String):::Returns the default state for a property, or null if this component does not want to report a default value for this property.:::for->i->return
XMLSchemaValidator#setDocumentHandler(XMLDocumentHandler):::Sets the document handler to receive information about the document.:::if->try->getFeature->catch->finally
XMLSchemaValidator#getDocumentHandler():::Returns the document handler:::return
XMLSchemaValidator#setDocumentSource(XMLDocumentSource):::Sets the document source:::
XMLSchemaValidator#getDocumentSource():::Returns the document source:::return
XMLSchemaValidator#startDocument(XMLLocator, String, NamespaceContext, Augmentations):::The start of the document.:::fValidationState->setNamespaceSupport->fState4XsiType->setNamespaceSupport->fState4ApplyDefault->setNamespaceSupport->handleStartDocument->if->fDocumentHandler->startDocument
XMLSchemaValidator#xmlDecl(String, String, String, Augmentations):::Notifies of the presence of an XMLDecl line in the document:::if->fDocumentHandler->xmlDecl
XMLSchemaValidator#doctypeDecl(String, String, String, Augmentations):::Notifies of the presence of the DOCTYPE line in the document.:::if->fDocumentHandler->doctypeDecl
XMLSchemaValidator#startElement(QName, XMLAttributes, Augmentations):::The start of an element.:::modifiedAugs->handleStartElement->if->fDocumentHandler->startElement
XMLSchemaValidator#emptyElement(QName, XMLAttributes, Augmentations):::An empty element.:::modifiedAugs->handleStartElement->if->handleEndElement->if->if->fDocumentHandler->emptyElement->else->fDocumentHandler->startElement->fDocumentHandler->characters->fDocumentHandler->endElement
XMLSchemaValidator#characters(XMLString, Augmentations):::Character content.:::handleCharacters->if->if->ignorableWhitespace->return->if->if->if->fDocumentHandler->characters->else->fDocumentHandler->characters
XMLSchemaValidator#ignorableWhitespace(XMLString, Augmentations):::Ignorable whitespace:::handleIgnorableWhitespace->if->fDocumentHandler->ignorableWhitespace
XMLSchemaValidator#endElement(QName, Augmentations):::The end of an element.:::modifiedAugs->handleEndElement->if->if->fDocumentHandler->endElement->else->fDocumentHandler->characters->fDocumentHandler->endElement
XMLSchemaValidator#startCDATA(Augmentations):::The start of a CDATA section.:::if->fDocumentHandler->startCDATA
XMLSchemaValidator#endCDATA(Augmentations):::The end of a CDATA section.:::if->fDocumentHandler->endCDATA
XMLSchemaValidator#endDocument(Augmentations):::The end of the document.:::handleEndDocument->if->fDocumentHandler->endDocument
XMLSchemaValidator#characterData(String, Augmentations)::: schema validator character data:::data->length->if->normalizeWhitespace->fBuffer->append->else->if->fBuffer->append->allWhiteSpace->if->fCurrentType->getTypeCategory->ctype->if->for->i->data->length->return
XMLSchemaValidator#elementDefault(String)::: schema validator element default:::
XMLSchemaValidator#startGeneralEntity(String, XMLResourceIdentifier, String, Augmentations):::This method notifies the start of a general entity:::if->fDocumentHandler->startGeneralEntity
XMLSchemaValidator#textDecl(String, String, Augmentations):::Notifies of the presence of a TextDecl line in an entity:::if->fDocumentHandler->textDecl
XMLSchemaValidator#comment(XMLString, Augmentations):::A comment.:::if->fDocumentHandler->comment
XMLSchemaValidator#processingInstruction(String, XMLString, Augmentations):::A processing instruction:::if->fDocumentHandler->processingInstruction
XMLSchemaValidator#endGeneralEntity(String, Augmentations):::This method notifies the end of a general entity:::if->fDocumentHandler->endGeneralEntity
XMLSchemaValidator#reset(XMLComponentManager)::: schema validator reset:::fLocationPairs->clear->fValidationState->resetIDTables->fSchemaLoader->reset->fMatcherStack->clear->fXSIErrorReporter->componentManager->getProperty->reset->parser_settings->componentManager->getFeature->if->fValidationManager->addValidationState->nodeFactory->reset->XMLSchemaLoader->processExternalHints->return->nodeFactory->reset->symbolTable->componentManager->getProperty->if->componentManager->getFeature->componentManager->getFeature->if->else->componentManager->getFeature->if->componentManager->getFeature->componentManager->getFeature->componentManager->getFeature->componentManager->getFeature->componentManager->getFeature->componentManager->getProperty->componentManager->getFeature->componentManager->getProperty->componentManager->getProperty->fValidationManager->addValidationState->fValidationState->setSymbolTable->try->rootType->componentManager->getProperty->if->else->if->else->catch->finally->try->rootDecl->componentManager->getProperty->if->else->if->else->catch->finally->ignoreXSIType->componentManager->getFeature->try->componentManager->getFeature->catch->finally->try->fValidationState->componentManager->getFeature->setIdIdrefChecking->catch->fValidationState->setIdIdrefChecking->finally->try->fValidationState->componentManager->getFeature->setUnparsedEntityChecking->catch->fValidationState->setUnparsedEntityChecking->finally->try->componentManager->getProperty->componentManager->getProperty->catch->finally->XMLSchemaLoader->processExternalHints->componentManager->getProperty->componentManager->getProperty->fState4XsiType->setSymbolTable->fState4ApplyDefault->setSymbolTable
XMLSchemaValidator#startValueScopeFor(IdentityConstraint, int):::Start the value scope for the specified identity constraint:::valueStore->fValueStoreCache->getValueStoreFor->valueStore->startValueScope
XMLSchemaValidator#activateField(Field, int):::Request to activate the specified field:::valueStore->fValueStoreCache->field->getIdentityConstraint->getValueStoreFor->matcher->field->createMatcher->fMatcherStack->addMatcher->matcher->startDocumentFragment->return
XMLSchemaValidator#endValueScopeFor(IdentityConstraint, int):::Ends the value scope for the specified identity constraint.:::valueStore->fValueStoreCache->getValueStoreFor->valueStore->endValueScope
XMLSchemaValidator#activateSelectorFor(IdentityConstraint)::: schema validator activate selector for:::selector->ic->getSelector->activator->if->return->matcher->selector->createMatcher->fMatcherStack->addMatcher->matcher->startDocumentFragment
XMLSchemaValidator#getGlobalElementDecl(QName)::: schema validator get global element decl:::sGrammar->findSchemaGrammar->if->return->sGrammar->getGlobalElementDecl->return
XMLSchemaValidator#ensureStackCapacity():::ensure element stack capacity:::if->newSize->newArrayB->new->booleanArr->System->arraycopy->newArrayE->new->XSElementDeclArr->System->arraycopy->new->booleanArr->System->arraycopy->newArrayN->new->XSNotationDeclArr->System->arraycopy->newArrayT->new->XSTypeDefinitionArr->System->arraycopy->newArrayC->new->XSCMValidatorArr->System->arraycopy->new->booleanArr->System->arraycopy->new->booleanArr->System->arraycopy->new->booleanArr->System->arraycopy->newArrayIA->new->intArrs->System->arraycopy
XMLSchemaValidator#handleStartDocument(XMLLocator, String)::: schema validator handle start document:::if->fValueStoreCache->startDocument->if
XMLSchemaValidator#handleEndDocument()::: schema validator handle end document:::if->fValueStoreCache->endDocument
XMLSchemaValidator#handleCharacters(XMLString)::: schema validator handle characters:::if->return->if->normalizeWhitespace->if->fBuffer->append->if->fCurrentType->getTypeCategory->ctype->if->for->i->return
XMLSchemaValidator#normalizeWhitespace(XMLString, boolean):::Normalize whitespace in an XMLString according to the rules defined in XML Schema specifications.:::skipSpace->sawNonWS->leading->trailing->c->size->if->new->charArr->for->i->if->if->else->if->if->if->if->else->if->if
XMLSchemaValidator#normalizeWhitespace(String, boolean)::: schema validator normalize whitespace:::skipSpace->c->size->value->length->if->new->charArr->for->i->if->if
XMLSchemaValidator#handleIgnorableWhitespace(XMLString)::: schema validator handle ignorable whitespace:::if->return
XMLSchemaValidator#handleStartElement(QName, XMLAttributes, Augmentations):::Handle element.:::if->println->if->fValidationManager->isGrammarFound->if->else->if->sLocation->attributes->getValue->nsLocation->attributes->getValue->storeLocations->if->if->getEmptyAugs->return->decl->if->fCurrentCM->oneTransition->if->ctype->next->if->fCurrentCM->whatCanGoHere->size->expected->expectedStr->occurenceInfo->fCurrentCM->occurenceInfo->elemExpandedQname->if->minOccurs->maxOccurs->count->if->required->if->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->Integer->toString->reportSchemaError->else->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->reportSchemaError->else->if->new->ObjectArr->Integer->toString->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->occurenceInfo->fCurrentCM->occurenceInfo->if->maxOccurs->count->if->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->new->ObjectArr->reportSchemaError->if->ensureStackCapacity->wildcard->fBuffer->setLength->if->if->else->if->if->getEmptyAugs->return->if->if->checkElementMatchesRootElementDecl->else->if->processRootElementDeclQName->else->if->else->if->processRootTypeQName->if->if->sGrammar->findSchemaGrammar->if->sGrammar->getGlobalElementDecl->if->if->xsiType->if->attributes->getValue->if->if->if->if->fDocumentSource->setDocumentHandler->if->fDocumentHandler->setDocumentSource->return->if->getEmptyAugs->return->new->ObjectArr->reportError->else->if->new->ObjectArr->reportSchemaError->fXSIErrorReporter->pushContext->else->fXSIErrorReporter->pushContext->if->oldType->getAndCheckXsiType->if->if->else->if->fCurrentElemDecl->getConstraintType->else->if->fCurrentType->getTypeCategory->else->ctype->if->fCurrentElemDecl->getAbstract->new->ObjectArr->reportSchemaError->if->if->if->fCurrentType->getTypeCategory->ctype->if->ctype->getAbstract->new->ObjectArr->reportSchemaError->if->if->if->getVariety->else->try->getWhitespace->catch->finally->else->if->dv->if->dv->getVariety->else->try->dv->getWhitespace->catch->finally->if->fCurrentType->getTypeCategory->getContentModel->if->fCurrentCM->startContentModel->xsiNil->attributes->getValue->if->getXsiNil->attrGrp->if->fCurrentType->getTypeCategory->ctype->ctype->getAttrGrp->if->fValueStoreCache->startElement->fMatcherStack->pushContext->if->fValueStoreCache->initValueStoresFor->processAttributes->if->addDefaultAttributes->count->fMatcherStack->getMatcherCount->for->i->if->getEmptyAugs->return
XMLSchemaValidator#handleEndElement(QName, Augmentations)::: Handle end element:::if->println->if->if->else->if->XSConstraints->fullSchemaChecking->if->getEmptyAugs->return->processElementContent->if->oldCount->fMatcherStack->getMatcherCount->for->i->if->fMatcherStack->size->fMatcherStack->popContext->newCount->fMatcherStack->getMatcherCount->for->i->for->i->fValueStoreCache->endElement->if->grammars->if->invIdRefs->fValidationState->checkIDRefID->fValidationState->resetIDTables->if->while->invIdRefs->hasNext->new->ObjectArr->invIdRefs->next->reportSchemaError->if->XSConstraints->fullSchemaChecking->fGrammarBucket->getGrammars->if->for->k->fGrammarPool->cacheGrammars->endElementPSVI->else->endElementPSVI->return
XMLSchemaValidator#endElementPSVI(boolean, SchemaGrammar[], Augmentations)::: schema validator end element i:::if->getEmptyAugs->if->else->if->else->if->if->if->copyFrom->if->errors->fXSIErrorReporter->mergeContext->else->fXSIErrorReporter->popContext->if->return
XMLSchemaValidator#getEmptyAugs(Augmentations)::: schema validator get empty augs:::if->augs->removeAllItems->augs->putItem->fCurrentPSVI->reset->return
XMLSchemaValidator#storeLocations(String, String)::: schema validator store locations:::if->if->XMLSchemaLoader->fLocator->getExpandedSystemId->tokenizeSchemaLocationStr->fXSIErrorReporter->new->ObjectArr->reportError->if->la->fLocationPairs->get->if->new->XMLSchemaLoader.LocationArray->fLocationPairs->put->if->try->XMLEntityManager->fLocator->getExpandedSystemId->expandSystemId->catch->finally->la->addLocation
XMLSchemaValidator#findSchemaGrammar(short, String, QName, QName, XMLAttributes)::: schema validator find schema grammar:::grammar->fGrammarBucket->getGrammar->if->fXSDDescription->setNamespace->if->fGrammarPool->retrieveGrammar->if->if->fGrammarBucket->putGrammar->reportError->if->hasSchemaComponent->fXSDDescription->reset->fXSDDescription->setNamespace->if->fXSDDescription->fLocator->getExpandedSystemId->setBaseSystemId->locationPairs->locationArray->locationPairs->get->if->temp->locationArray->getLocationArray->if->setLocationHints->if->toParseSchema->if->Collections->emptyMap->try->xis->XMLSchemaLoader->resolveDocument->if->try->if->grammar->getDocumentLocations->XMLEntityManager->xis->getSystemId->xis->getBaseSystemId->expandSystemId->contains->catch->finally->if->fSchemaLoader->loadSchema->catch->locationHints->fXSDDescription->getLocationHints->new->ObjectArr->reportError->finally->return
XMLSchemaValidator#hasSchemaComponent(SchemaGrammar, short, QName)::: schema validator has schema component:::if->localName->if->localName->length->switch->return->grammar->getElementDeclaration->return->grammar->getAttributeDeclaration->return->grammar->getTypeDefinition->return
XMLSchemaValidator#setLocationHints(XSDDescription, String[], SchemaGrammar)::: schema validator set location hints:::length->if->new->StringArr->System->arraycopy->else->grammar->getDocumentLocations->setLocationHints
XMLSchemaValidator#setLocationHints(XSDDescription, String[], StringList)::: schema validator set location hints:::length->hints->new->StringArr->counter->for->i->if->if->else->new->StringArr->System->arraycopy
XMLSchemaValidator#getAndCheckXsiType(QName, String, XMLAttributes)::: schema validator get and check xsi type:::typeName->try->fQNameDV->validate->catch->e->getKey->e->getArgs->reportSchemaError->new->ObjectArr->reportSchemaError->return->finally->type->if->getGlobalTypeDecl->if->grammar->findSchemaGrammar->if->grammar->getGlobalTypeDecl->if->new->ObjectArr->reportSchemaError->return->if->block->if->if->fCurrentType->getTypeCategory->if->XSConstraints->checkTypeDerivationOk->new->ObjectArr->XS10TypeHelper->getSchemaTypeName->reportSchemaError->return
XMLSchemaValidator#getXsiNil(QName, String)::: schema validator get xsi nil:::if->fCurrentElemDecl->getNillable->new->ObjectArr->reportSchemaError->else->value->XMLChar->trim->if->value->equals->value->equals->if->fCurrentElemDecl->getConstraintType->new->ObjectArr->reportSchemaError->return->return
XMLSchemaValidator#processAttributes(QName, XMLAttributes, XSAttributeGroupDecl)::: schema validator process attributes:::if->attributes->getLength->println->wildcardIDName->attCount->attributes->getLength->augs->attrPSVI->isSimple->fCurrentType->getTypeCategory->attrUses->useCount->attrWildcard->if->attrGrp->getAttributeUses->attrUses->getLength->for->index->if->new->ObjectArr->reportSchemaError
XMLSchemaValidator#processOneAttribute(QName, XMLAttributes, int, XSAttributeDecl, XSAttributeUseImpl, AttributePSVImpl)::: schema validator process one attribute:::attrValue->attributes->getValue->fXSIErrorReporter->pushContext->attDV->actualValue->try->attDV->validate->if->attributes->setValue->if->attDV->getVariety->attDV->getPrimitiveKind->qName->grammar->fGrammarBucket->getGrammar->if->grammar->getGlobalNotationDecl->catch->idve->getKey->idve->getArgs->reportSchemaError->new->ObjectArr->getTypeName->attDV->getName->reportSchemaError->finally->if->currDecl->getConstraintType->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->if->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->if->copyFrom->if->copyFrom->if->errors->fXSIErrorReporter->mergeContext
XMLSchemaValidator#addDefaultAttributes(QName, XMLAttributes, XSAttributeGroupDecl)::: schema validator add default attributes:::if->println->attrUses->attrGrp->getAttributeUses->useCount->attrUses->getLength->currUse->currDecl->constType->defaultValue->isSpecified->attName->for->i
XMLSchemaValidator#processElementContent(QName)::: If there is not text content, and there is a  {value constraint} on the corresponding element decl, then return  an XMLString representing the default value.:::if->strv->stringValue->bufLen->strv->length->if->new->charArr->strv->getChars->if->if->new->ObjectArr->reportSchemaError->reset->if->fCurrentElemDecl->getConstraintType->if->if->XSConstraints->stringValue->ElementDefaultValidImmediate->new->ObjectArr->fCurrentType->getName->stringValue->reportSchemaError->stringValue->elementLocallyValidType->else->actualValue->elementLocallyValidType->if->fCurrentElemDecl->getConstraintType->content->fBuffer->toString->if->new->ObjectArr->reportSchemaError->if->fCurrentType->getTypeCategory->ctype->if->if->equals->new->ObjectArr->reportSchemaError->else->if->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->else->if->fCurrentType->getTypeCategory->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->if->content->if->fBuffer->toString->bufLen->content->length->if->new->charArr->content->getChars->fDocumentHandler->characters
XMLSchemaValidator#elementLocallyValidType(QName, Object)::: schema validator element locally valid type:::if->return->retValue->if->fCurrentType->getTypeCategory->if->new->ObjectArr->reportSchemaError->if->dv->try->if->fValidationState->setNormalizationRequired->dv->validate->catch->e->getKey->e->getArgs->reportSchemaError->new->ObjectArr->reportSchemaError->finally->else->elementLocallyValidComplexType->return
XMLSchemaValidator#elementLocallyValidComplexType(QName, Object)::: schema validator element locally valid complex type:::actualValue->ctype->if->if->new->ObjectArr->reportSchemaError->else->if->if->new->ObjectArr->reportSchemaError->dv->try->if->fValidationState->setNormalizationRequired->dv->validate->catch->e->getKey->e->getArgs->reportSchemaError->new->ObjectArr->reportSchemaError->finally->else->if->if->new->ObjectArr->reportSchemaError->if->if->println->if->fCurrentCM->endContentModel->expected->fCurrentCM->whatCanGoHere->expectedStr->occurenceInfo->fCurrentCM->occurenceInfo->if->minOccurs->count->if->required->if->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->Integer->toString->reportSchemaError->else->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->errors->fCurrentCM->checkMinMaxBounds->if->for->i->errors->size->return
XMLSchemaValidator#processRootTypeQName(javax.xml.namespace.QName)::: schema validator process root type name:::rootTypeNamespace->rootTypeQName->getNamespaceURI->fSymbolTable->addSymbol->if->rootTypeNamespace->equals->if->equals->rootTypeQName->getLocalPart->getGlobalTypeDecl->else->grammarForRootType->findSchemaGrammar->if->grammarForRootType->rootTypeQName->getLocalPart->getGlobalTypeDecl->if->typeName->rootTypeQName->getPrefix->equals->rootTypeQName->getLocalPart->rootTypeQName->getPrefix->rootTypeQName->getLocalPart->new->ObjectArr->reportSchemaError
XMLSchemaValidator#processRootElementDeclQName(javax.xml.namespace.QName, QName)::: schema validator process root element decl name:::rootElementDeclNamespace->rootElementDeclQName->getNamespaceURI->fSymbolTable->addSymbol->if->rootElementDeclNamespace->equals->grammarForRootElement->findSchemaGrammar->if->grammarForRootElement->rootElementDeclQName->getLocalPart->getGlobalElementDecl->if->declName->rootElementDeclQName->getPrefix->equals->rootElementDeclQName->getLocalPart->rootElementDeclQName->getPrefix->rootElementDeclQName->getLocalPart->new->ObjectArr->reportSchemaError->else->checkElementMatchesRootElementDecl
XMLSchemaValidator#checkElementMatchesRootElementDecl(XSElementDecl, QName)::: schema validator check element matches root element decl:::if->new->ObjectArr->reportSchemaError
XMLSchemaValidator#reportSchemaError(String, Object[])::: schema validator report schema error:::if->fXSIErrorReporter->reportError
XMLSchemaValidator#expectedStr(List)::: schema validator expected str:::ret->new->StringBuilder->size->expected->size->for->i->ret->append->return->ret->toString
XMLSchemaValidator.XPathMatcherStack#clear():::Resets the XPath matcher stack.:::for->i->fContextStack->clear
XMLSchemaValidator.XPathMatcherStack#size():::Returns the size of the stack.:::return->fContextStack->size
XMLSchemaValidator.XPathMatcherStack#getMatcherCount():::Returns the count of XPath matchers.:::return
XMLSchemaValidator.XPathMatcherStack#addMatcher(XPathMatcher):::Adds a matcher.:::ensureMatcherCapacity
XMLSchemaValidator.XPathMatcherStack#getMatcherAt(int):::Returns the XPath matcher at the specified index.:::return
XMLSchemaValidator.XPathMatcherStack#pushContext():::Pushes a new context onto the stack.:::fContextStack->push
XMLSchemaValidator.XPathMatcherStack#popContext():::Pops a context off of the stack.:::fContextStack->pop
XMLSchemaValidator.XPathMatcherStack#ensureMatcherCapacity():::Ensures the size of the matchers array.:::if->array->new->XPathMatcherArr->System->arraycopy
XMLSchemaValidator.ValueStoreBase#clear()::: value store base clear:::fValues->setSize->if->fValueTypes->clear->if->fItemValueTypes->setSize
XMLSchemaValidator.ValueStoreBase#append(ValueStoreBase)::: value store base append:::for->i->size
XMLSchemaValidator.ValueStoreBase#startValueScope():::Start scope for value store.:::for->i
XMLSchemaValidator.ValueStoreBase#endValueScope():::Ends scope for value store.:::if->if->fIdentityConstraint->getCategory->code->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError->return->if->if->fIdentityConstraint->getCategory->code->key->eName->fIdentityConstraint->getElementName->cName->key->getIdentityConstraintName->new->ObjectArr->reportSchemaError->return
XMLSchemaValidator.ValueStoreBase#endDocumentFragment()::: value store base end document fragment:::
XMLSchemaValidator.ValueStoreBase#endDocument():::Signals the end of the document:::
XMLSchemaValidator.ValueStoreBase#reportError(String, Object[])::: value store base report error:::reportSchemaError
XMLSchemaValidator.ValueStoreBase#addValue(Field, boolean, Object, short, ShortList):::Adds the specified value to the value store.:::i->for->if->code->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->field->toString->reportSchemaError->return->if->code->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->field->toString->reportSchemaError->else->if->checkDuplicateValues->for
XMLSchemaValidator.ValueStoreBase#contains():::Returns true if this value store contains the locally scoped value stores:::next->size->fValues->size->for->i->return
XMLSchemaValidator.ValueStoreBase#contains(ValueStoreBase):::Returns -1 if this value store contains the specified values, otherwise the index of the first field in the key sequence.:::values->size1->values->size->if->for->i->else->size2->fValues->size->for->i->return
XMLSchemaValidator.ValueStoreBase#checkDuplicateValues()::: value store base check duplicate values:::
XMLSchemaValidator.ValueStoreBase#toString(Object[]):::Returns a string of the specified values.:::size->if->return->fTempBuffer->setLength->for->i->return->fTempBuffer->toString
XMLSchemaValidator.ValueStoreBase#toString(Vector, int, int):::Returns a string of the specified values.:::if->return->if->return->String->values->get->valueOf->str->new->StringBuilder->for->i->return->str->toString
XMLSchemaValidator.ValueStoreBase#toString():::Returns a string representation of this object.:::s->super->toString->index1->s->lastIndexOf->if->s->substring->index2->s->lastIndexOf->if->s->substring->return
XMLSchemaValidator.ValueStoreBase#addValueType(short)::: value store base add value type:::if->fValueTypes->add->else->if->else->if->if->new->ShortVector->for->i->fValueTypes->add
XMLSchemaValidator.ValueStoreBase#getValueTypeAt(int)::: value store base get value type at:::if->return->fValueTypes->valueAt->return
XMLSchemaValidator.ValueStoreBase#valueTypeContains(short)::: value store base value type contains:::if->return->fValueTypes->contains->return
XMLSchemaValidator.ValueStoreBase#addItemValueType(ShortList)::: value store base add item value type:::if->fItemValueTypes->add->else->if->else->if->fItemValueType->equals->if->new->Vector<>->for->i->fItemValueTypes->add
XMLSchemaValidator.ValueStoreBase#getItemValueTypeAt(int)::: value store base get item value type at:::if->return->fItemValueTypes->get->return
XMLSchemaValidator.ValueStoreBase#itemValueTypeContains(ShortList)::: value store base item value type contains:::if->return->fItemValueTypes->contains->return->fItemValueType->equals
XMLSchemaValidator.UniqueValueStore#checkDuplicateValues():::Called when a duplicate value is added.:::if->contains->code->value->toString->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError
XMLSchemaValidator.KeyValueStore#checkDuplicateValues():::Called when a duplicate value is added.:::if->contains->code->value->toString->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError
XMLSchemaValidator.KeyRefValueStore#endDocumentFragment()::: key ref value store end document fragment:::super->endDocumentFragment->getKey->get->if->code->value->fIdentityConstraint->toString->new->ObjectArr->reportSchemaError->return->errorIndex->fKeyValueStore->contains->if->code->values->toString->element->fIdentityConstraint->getElementName->name->fIdentityConstraint->getName->new->ObjectArr->reportSchemaError
XMLSchemaValidator.KeyRefValueStore#endDocument():::End document.:::super->endDocument
XMLSchemaValidator.ValueStoreCache#startDocument():::Resets the identity constraint cache.:::fValueStores->clear->fIdentityConstraint2ValueStoreMap->clear->fGlobalIDConstraintMap->clear->fGlobalMapStack->removeAllElements
XMLSchemaValidator.ValueStoreCache#startElement()::: value store cache start element:::if->fGlobalIDConstraintMap->size->fGlobalMapStack->clone->push->else->fGlobalMapStack->push->fGlobalIDConstraintMap->clear
XMLSchemaValidator.ValueStoreCache#endElement():::endElement():  merges contents of fGlobalIDConstraintMap with the top of fGlobalMapStack into fGlobalIDConstraintMap.:::if->fGlobalMapStack->isEmpty->return->oldMap->fGlobalMapStack->pop->if->return->foreach->oldMap->entrySet->id->entry->getKey->oldVal->entry->getValue->if->currVal->fGlobalIDConstraintMap->get->if->fGlobalIDConstraintMap->put->else->if->currVal->append
XMLSchemaValidator.ValueStoreCache#initValueStoresFor(XSElementDecl, FieldActivator):::Initializes the value stores for the specified element declaration.:::icArray->icCount->for->i
XMLSchemaValidator.ValueStoreCache#getValueStoreFor(IdentityConstraint, int):::Returns the value store associated to the specified IdentityConstraint.:::return->fIdentityConstraint2ValueStoreMap->get
XMLSchemaValidator.ValueStoreCache#getGlobalValueStoreFor(IdentityConstraint):::Returns the global value store associated to the specified IdentityConstraint.:::return->fGlobalIDConstraintMap->get
XMLSchemaValidator.ValueStoreCache#transplant(IdentityConstraint, int)::: value store cache transplant:::newVals->fIdentityConstraint2ValueStoreMap->get->if->id->getCategory->return->currVals->fGlobalIDConstraintMap->get->if->currVals->append->fGlobalIDConstraintMap->put->else->fGlobalIDConstraintMap->put
XMLSchemaValidator.ValueStoreCache#endDocument():::Check identity constraints.:::foreach->valueStore->endDocument
XMLSchemaValidator.ValueStoreCache#toString():::Returns a string representation of this object.:::s->super->toString->index1->s->lastIndexOf->if->return->s->substring->index2->s->lastIndexOf->if->return->s->substring->return
XMLSchemaValidator.LocalIDKey#hashCode()::: local key hash code:::return->fId->hashCode
XMLSchemaValidator.LocalIDKey#equals(Object)::: local key equals:::if->lIDKey->return->return
XMLSchemaValidator.ShortVector#length():::Returns the length of the vector.:::return
XMLSchemaValidator.ShortVector#add(short):::Adds the value to the vector.:::ensureCapacity
XMLSchemaValidator.ShortVector#valueAt(int):::Returns the short value at the specified position in the vector.:::return
XMLSchemaValidator.ShortVector#clear():::Clears the vector.:::
XMLSchemaValidator.ShortVector#contains(short):::Returns whether the short is contained in the vector.:::for->i->return
XMLSchemaValidator.ShortVector#ensureCapacity(int):::Ensures capacity.:::if->new->shortArr->else->if->newdata->new->shortArr->System->arraycopy
XSAnnotationImpl#writeAnnotation(Object, short)::: Write contents of the annotation to the specified DOM object:::if->writeToDOM->return->else->if->writeToSAX->return->return
XSAnnotationImpl#getAnnotationString():::A text representation of annotation.:::return
XSAnnotationImpl#getType()::: The type of this object, i.e:::return
XSAnnotationImpl#getName():::The name of type NCName of this declaration as defined in XML Namespaces.:::return
XSAnnotationImpl#getNamespace()::: The [target namespace] of this object, or null if it is unspecified.:::return
XSAnnotationImpl#getNamespaceItem():::A namespace schema information item corresponding to the target namespace of the component, if it's globally declared; or null otherwise.:::return
XSAnnotationImpl#writeToSAX(ContentHandler)::: annotation impl write to x:::parser->fGrammar->getSAXParser->aReader->new->StringReader->aSource->new->InputSource->parser->setContentHandler->try->parser->parse->catch->finally->parser->setContentHandler
XSAnnotationImpl#writeToDOM(Node, short)::: annotation impl write to m:::futureOwner->target->getOwnerDocument->parser->fGrammar->getDOMParser->aReader->new->StringReader->aSource->new->InputSource->try->parser->parse->catch->finally->aDocument->parser->getDocument->parser->dropDocumentReferences->annotation->aDocument->getDocumentElement->newElem->if->futureOwner->adoptNode->if->futureOwner->importNode->else->futureOwner->importNode->target->target->getFirstChild->insertBefore
XSAttributeDecl#setValues(String, String, XSSimpleType, short, short, ValidatedInfo, XSComplexTypeDecl, XSObjectList)::: attribute decl set values:::
XSAttributeDecl#reset()::: attribute decl reset:::
XSAttributeDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeDecl#getTypeDefinition():::A simple type definition:::return
XSAttributeDecl#getScope():::Optional:::return
XSAttributeDecl#getEnclosingCTDefinition():::Locally scoped declarations are available for use only within the complex type definition identified by the scope property.:::return
XSAttributeDecl#getConstraintType():::Value constraint: one of default, fixed.:::return
XSAttributeDecl#getConstraintValue():::Value constraint: The actual value (with respect to the {type definition}) Should we return Object instead of DOMString?:::return->getConstraintType->fDefault->stringValue
XSAttributeDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSAttributeDecl#getAnnotations():::Optional:::return
XSAttributeDecl#getValInfo()::: attribute decl get val info:::return
XSAttributeDecl#getNamespaceItem()::: attribute decl get namespace item:::return
XSAttributeDecl#setNamespaceItem(XSNamespaceItem)::: attribute decl set namespace item:::
XSAttributeDecl#getActualVC()::: attribute decl get actual c:::return->getConstraintType
XSAttributeDecl#getActualVCType()::: attribute decl get actual type:::return->getConstraintType
XSAttributeDecl#getItemValueTypes()::: attribute decl get item value types:::return->getConstraintType
XSAttributeDecl#getValueConstraintValue()::: attribute decl get value constraint value:::return
XSAttributeGroupDecl#addAttributeUse(XSAttributeUseImpl)::: attribute group decl add attribute use:::if->if->isIDType->if->else->return->if->resize->return
XSAttributeGroupDecl#replaceAttributeUse(XSAttributeUse, XSAttributeUseImpl)::: attribute group decl replace attribute use:::for->i
XSAttributeGroupDecl#getAttributeUse(String, String)::: attribute group decl get attribute use:::for->i->return
XSAttributeGroupDecl#getAttributeUseNoProhibited(String, String)::: attribute group decl get attribute use no prohibited:::for->i->return
XSAttributeGroupDecl#removeProhibitedAttrs()::: attribute group decl remove prohibited attrs:::if->return->count->uses->new->XSAttributeUseImplArr->for->i
XSAttributeGroupDecl#validRestrictionOf(String, XSAttributeGroupDecl):::Check that the attributes in this group validly restrict those from a base group:::errorArgs->attrUse->attrDecl->baseAttrUse->baseAttrDecl->for->i->for->i->if->if->new->ObjectArr->return->if->fAttributeWC->isSubsetOf->new->ObjectArr->return->if->fAttributeWC->weakerProcessContents->new->ObjectArr->fAttributeWC->getProcessContentsAsString->getProcessContentsAsString->return->return
XSAttributeGroupDecl#resize(XSAttributeUseImpl[], int)::: attribute group decl resize:::newArray->new->XSAttributeUseImplArr->System->Math->min->arraycopy->return
XSAttributeGroupDecl#reset()::: attribute group decl reset:::for->i
XSAttributeGroupDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeGroupDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeGroupDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeGroupDecl#getAttributeUses():::{attribute uses} A set of attribute uses.:::if->new->XSObjectListImpl->return
XSAttributeGroupDecl#getAttributeWildcard():::{attribute wildcard} Optional:::return
XSAttributeGroupDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSAttributeGroupDecl#getAnnotations():::Optional:::return
XSAttributeGroupDecl#getNamespaceItem()::: attribute group decl get namespace item:::return
XSAttributeGroupDecl#setNamespaceItem(XSNamespaceItem)::: attribute group decl set namespace item:::
XSAttributeUseImpl#reset()::: attribute use impl reset:::
XSAttributeUseImpl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeUseImpl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeUseImpl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeUseImpl#getRequired():::{required} determines whether this use of an attribute declaration requires an appropriate attribute information item to be present, or merely allows it.:::return
XSAttributeUseImpl#getAttrDeclaration():::{attribute declaration} provides the attribute declaration itself, which will in turn determine the simple type definition used.:::return
XSAttributeUseImpl#getConstraintType():::Value Constraint: one of default, fixed.:::return
XSAttributeUseImpl#getConstraintValue():::Value Constraint: The actual value (with respect to the {type definition}).:::return->getConstraintType->fDefault->stringValue
XSAttributeUseImpl#getNamespaceItem()::: attribute use impl get namespace item:::return
XSAttributeUseImpl#getActualVC()::: attribute use impl get actual c:::return->getConstraintType
XSAttributeUseImpl#getActualVCType()::: attribute use impl get actual type:::return->getConstraintType
XSAttributeUseImpl#getItemValueTypes()::: attribute use impl get item value types:::return->getConstraintType
XSAttributeUseImpl#getValueConstraintValue()::: attribute use impl get value constraint value:::return
XSAttributeUseImpl#getAnnotations():::Optional:::return
XSComplexTypeDecl#setValues(String, String, XSTypeDefinition, short, short, short, short, boolean, XSAttributeGroupDecl, XSSimpleType, XSParticleDecl, XSObjectListImpl)::: complex type decl set values:::if
XSComplexTypeDecl#setName(String)::: complex type decl set name:::
XSComplexTypeDecl#getTypeCategory()::: complex type decl get type category:::return
XSComplexTypeDecl#getTypeName()::: complex type decl get type name:::return
XSComplexTypeDecl#getFinalSet()::: complex type decl get final set:::return
XSComplexTypeDecl#getTargetNamespace()::: complex type decl get target namespace:::return
XSComplexTypeDecl#containsTypeID()::: complex type decl contains type d:::return
XSComplexTypeDecl#setIsAbstractType()::: complex type decl set is abstract type:::
XSComplexTypeDecl#setContainsTypeID()::: complex type decl set contains type d:::
XSComplexTypeDecl#setIsAnonymous()::: complex type decl set is anonymous:::
XSComplexTypeDecl#getContentModel(CMBuilder)::: complex type decl get content model:::if->return->if->getContentModel->return
XSComplexTypeDecl#getContentModel(CMBuilder, boolean)::: complex type decl get content model:::if->if->if->cmBuilder->getContentModel->if->fUPACMValidator->isCompactedForUPA->return->else->cmBuilder->getContentModel->return
XSComplexTypeDecl#getAttrGrp()::: complex type decl get attr grp:::return
XSComplexTypeDecl#toString()::: complex type decl to string:::str->new->StringBuilder->appendTypeInfo->return->str->toString
XSComplexTypeDecl#appendTypeInfo(StringBuilder)::: complex type decl append type info:::contentType->derivedBy->str->append->append->append->getTypeName->append->append->if->str->append->fBaseType->getName->append->append->str->append->append->append->str->append->getAbstract->append->append->str->append->containsTypeID->append->append->str->append->append->append->str->append->append->append->if->str->append->fParticle->toString->append->append->str->append->append->append
XSComplexTypeDecl#derivedFromType(XSTypeDefinition, short)::: complex type decl derived from type:::if->return->if->return->type->while->type->getBaseType->return
XSComplexTypeDecl#derivedFrom(String, String, short)::: complex type decl derived from:::if->return->if->ancestorNS->equals->ancestorName->equals->return->type->while->ancestorName->type->getName->equals->type->getNamespace->ancestorNS->type->getNamespace->equals->type->getBaseType->return
XSComplexTypeDecl#isDOMDerivedFrom(String, String, int):::Checks if a type is derived from another given the the name, namespace and derivation method:::if->return->if->ancestorNS->equals->ancestorName->equals->return->if->if->isDerivedByRestriction->return->if->if->isDerivedByExtension->return->if->if->ancestorNS->equals->ancestorName->equals->if->fName->equals->fTargetNamespace->equals->if->return->isDOMDerivedFrom->else->if->return->isDOMDerivedFrom->if->return->isDerivedByAny->return
XSComplexTypeDecl#isDerivedByAny(String, String, int, XSTypeDefinition):::Checks if a type is derived from another by any combination of restriction, list ir union:::oldType->derivedFrom->while->if->ancestorName->type->getName->equals->type->getNamespace->ancestorNS->type->getNamespace->equals->break->if->isDerivedByRestriction->return->else->if->isDerivedByExtension->return->type->getBaseType->return
XSComplexTypeDecl#isDerivedByRestriction(String, String, int, XSTypeDefinition):::Checks if a type is derived from another by restriction:::oldType->while->if->ancestorNS->equals->ancestorName->equals->return->if->ancestorName->type->getName->equals->ancestorNS->type->getNamespace->equals->type->getNamespace->return->if->if->ancestorNS->equals->ancestorName->equals->return->isDOMDerivedFrom->else->if->getDerivationMethod->return->type->getBaseType->return
XSComplexTypeDecl#isDerivedByExtension(String, String, int, XSTypeDefinition):::Checks if a type is derived from another by extension:::extension->oldType->while->if->ancestorNS->equals->ancestorName->equals->type->getNamespace->equals->type->getName->equals->break->if->ancestorName->type->getName->equals->type->getNamespace->ancestorNS->type->getNamespace->equals->return->if->if->ancestorNS->equals->ancestorName->equals->if->return->isDOMDerivedFrom->else->return->isDOMDerivedFrom->else->if->getDerivationMethod->type->getBaseType->return
XSComplexTypeDecl#reset()::: complex type decl reset:::fAttrGrp->reset->if->fAnnotations->clearXSObjectList
XSComplexTypeDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSComplexTypeDecl#getName():::The name of this XSObject depending on the XSObject type.:::return->getAnonymous
XSComplexTypeDecl#getAnonymous():::A boolean that specifies if the type definition is anonymous:::return
XSComplexTypeDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSComplexTypeDecl#getBaseType():::{base type definition} Either a simple type definition or a complex type definition.:::return
XSComplexTypeDecl#getDerivationMethod():::{derivation method} Either extension or restriction:::return
XSComplexTypeDecl#isFinal(short):::{final} For complex type definition it is a subset of {extension, restriction}:::return
XSComplexTypeDecl#getFinal():::{final} For complex type definition it is a subset of {extension, restriction}.:::return
XSComplexTypeDecl#getAbstract():::{abstract} A boolean:::return
XSComplexTypeDecl#getAttributeUses()::: {attribute uses} A set of attribute uses.:::return->fAttrGrp->getAttributeUses
XSComplexTypeDecl#getAttributeWildcard():::{attribute wildcard} Optional:::return->fAttrGrp->getAttributeWildcard
XSComplexTypeDecl#getContentType():::{content type} One of empty, a simple type definition (see simpleType, or mixed, element-only (see cmParticle).:::return
XSComplexTypeDecl#getSimpleType():::A simple type definition corresponding to simple content model, otherwise null:::return
XSComplexTypeDecl#getParticle():::A particle for mixed or element-only content model, otherwise null:::return
XSComplexTypeDecl#isProhibitedSubstitution(short):::{prohibited substitutions} A subset of {extension, restriction}.:::return
XSComplexTypeDecl#getProhibitedSubstitutions():::{prohibited substitutions}:::return
XSComplexTypeDecl#getAnnotations():::Optional:::return
XSComplexTypeDecl#getNamespaceItem()::: complex type decl get namespace item:::return
XSComplexTypeDecl#setNamespaceItem(XSNamespaceItem)::: complex type decl set namespace item:::
XSComplexTypeDecl#getAttributeUse(String, String)::: complex type decl get attribute use:::return->fAttrGrp->getAttributeUse
XSComplexTypeDecl#getTypeNamespace()::: complex type decl get type namespace:::return->getNamespace
XSComplexTypeDecl#isDerivedFrom(String, String, int)::: complex type decl is derived from:::return->isDOMDerivedFrom
XSConstraints#getEmptySequence()::: constraints get empty sequence:::if->group->new->XSModelGroupImpl->particle->new->XSParticleDecl->return
XSConstraints#checkTypeDerivationOk(XSTypeDefinition, XSTypeDefinition, short):::check whether derived is valid derived from base, given a subset of {restriction, extension}.B:::if->return->if->return->if->derived->getTypeCategory->if->base->getTypeCategory->if->else->return->return->checkSimpleDerivation->else->return->checkComplexDerivation
XSConstraints#checkSimpleDerivationOk(XSSimpleType, XSTypeDefinition, short):::check whether simple type derived is valid derived from base, given a subset of {restriction, extension}.:::if->return->if->base->getTypeCategory->if->else->return->return->checkSimpleDerivation
XSConstraints#checkComplexDerivationOk(XSComplexTypeDecl, XSTypeDefinition, short):::check whether complex type derived is valid derived from base, given a subset of {restriction, extension}.:::if->return->return->checkComplexDerivation
XSConstraints#checkSimpleDerivation(XSSimpleType, XSSimpleType, short):::Note: this will be a private method, and it assumes that derived is not       anySimpleType, and base is not anyType:::if->return->if->derived->getBaseType->getFinal->return->directBase->derived->getBaseType->if->return->if->checkSimpleDerivation->return->if->derived->getVariety->derived->getVariety->return->if->base->getVariety->subUnionMemberDV->base->getMemberTypes->subUnionSize->subUnionMemberDV->getLength->for->i->return
XSConstraints#checkComplexDerivation(XSComplexTypeDecl, XSTypeDefinition, short):::Note: this will be a private method, and it assumes that derived is not       anyType:::if->return->if->return->directBase->if->return->if->return->if->directBase->getTypeCategory->return->checkComplexDerivation->if->directBase->getTypeCategory->if->base->getTypeCategory->if->else->return->return->checkSimpleDerivation->return
XSConstraints#ElementDefaultValidImmediate(XSTypeDefinition, String, ValidationContext, ValidatedInfo):::check whether a value is a valid default for some type returns the compiled form of the value The parameter value could be either a String or a ValidatedInfo object:::dv->if->type->getTypeCategory->else->ctype->if->else->if->if->ctype->getParticle->emptiable->return->else->return->actualValue->if->try->dv->validate->if->dv->vinfo->stringValue->validate->catch->return->finally->return
XSConstraints#reportSchemaError(XMLErrorReporter, SimpleLocator, String, Object[])::: constraints report schema error:::if->errorReporter->reportError->else->errorReporter->reportError
XSConstraints#fullSchemaChecking(XSGrammarBucket, SubstitutionGroupHandler, CMBuilder, XMLErrorReporter):::used to check the 3 constraints against each complex type (should be each model group): Unique Particle Attribution, Particle Derivation (Restriction), Element Declrations Consistent.:::grammars->grammarBucket->getGrammars->for->i->fakeDerived->new->XSParticleDecl->fakeBase->new->XSParticleDecl->for->g->types->ctLocators->further->fullChecked->keepType->elemTable->new->SymbolHash->for->i->j
XSConstraints#checkElementDeclsConsistent(XSComplexTypeDecl, XSParticleDecl, SymbolHash, SubstitutionGroupHandler)::: constraints check element decls consistent:::pType->if->return->if->elem->findElemInTable->if->subGroup->sgHandler->getSubstitutionGroup->for->i->return->group->for->i
XSConstraints#findElemInTable(XSComplexTypeDecl, XSElementDecl, SymbolHash)::: constraints find elem in table:::name->existingElem->if->elemDeclHash->get->elemDeclHash->put->else->if->return->if->throw->new->ObjectArr->new->XMLSchemaException
XSConstraints#particleValidRestriction(XSParticleDecl, SubstitutionGroupHandler, XSParticleDecl, SubstitutionGroupHandler)::: constraints particle valid restriction:::return->particleValidRestriction
XSConstraints#particleValidRestriction(XSParticleDecl, SubstitutionGroupHandler, XSParticleDecl, SubstitutionGroupHandler, boolean)::: constraints particle valid restriction:::dChildren->bChildren->dMinEffectiveTotalRange->dMaxEffectiveTotalRange->bExpansionHappened->if->dParticle->isEmpty->bParticle->emptiable->throw->new->XMLSchemaException->else->if->dParticle->isEmpty->bParticle->isEmpty->throw->new->XMLSchemaException->dType->if->dtmp->getNonUnaryGroup->if->if->removePointlessChildren->dMinOccurs->dMaxOccurs->if->dElement->if->subGroup->dSGHandler->getSubstitutionGroup->if->new->ArrayList<>->for->i->addElementToParticleVector->Collections->sort->bType->if->btmp->getNonUnaryGroup->if->if->removePointlessChildren->bMinOccurs->bMaxOccurs->if->bElement->if->bsubGroup->bSGHandler->getSubstitutionGroup->if->new->ArrayList<>->for->i->addElementToParticleVector->Collections->sort->switch->switch->checkNameAndTypeOK->return->checkNSCompat->return->new->ArrayList<>->dChildren->add->checkRecurseLax->return->new->ArrayList<>->dChildren->add->checkRecurse->return->throw->new->ObjectArr->new->XMLSchemaException->switch->checkNSSubset->return->throw->new->ObjectArr->new->XMLSchemaException->throw->new->ObjectArr->new->XMLSchemaException->switch->if->dParticle->minEffectiveTotalRange->if->dParticle->maxEffectiveTotalRange->checkNSRecurseCheckCardinality->return->checkRecurse->return->throw->new->ObjectArr->new->XMLSchemaException->throw->new->ObjectArr->new->XMLSchemaException->switch->if->dParticle->minEffectiveTotalRange->if->dParticle->maxEffectiveTotalRange->checkNSRecurseCheckCardinality->return->checkRecurseLax->return->throw->new->ObjectArr->new->XMLSchemaException->throw->new->ObjectArr->new->XMLSchemaException->switch->if->dParticle->minEffectiveTotalRange->if->dParticle->maxEffectiveTotalRange->checkNSRecurseCheckCardinality->return->checkRecurseUnordered->return->checkRecurse->return->min1->dChildren->size->max1->dChildren->size->checkMapAndSum->return->throw->new->ObjectArr->new->XMLSchemaException->throw->new->ObjectArr->new->XMLSchemaException->return
XSConstraints#addElementToParticleVector(List, XSElementDecl)::: constraints add element to particle vector:::p->new->XSParticleDecl->v->add
XSConstraints#getNonUnaryGroup(XSParticleDecl)::: constraints get non unary group:::if->return->if->return->getNonUnaryGroup->else->return
XSConstraints#removePointlessChildren(XSParticleDecl)::: constraints remove pointless children:::if->return->children->new->ArrayList<>->group->for->i->return
XSConstraints#gatherChildren(int, XSParticleDecl, List)::: constraints gather children:::min->max->type->if->if->children->add->return->if->children->add->else->if->group->for->i->else->if->p->isEmpty->children->add
XSConstraints#checkNameAndTypeOK(XSElementDecl, int, int, XSElementDecl, int, int)::: constraints check name and type k:::if->throw->new->ObjectArr->new->XMLSchemaException->if->bElement->getNillable->dElement->getNillable->throw->new->ObjectArr->new->XMLSchemaException->if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->if->bElement->getConstraintType->if->dElement->getConstraintType->throw->new->ObjectArr->stringValue->new->XMLSchemaException->isSimple->if->getTypeCategory->if->equals->equals->throw->new->ObjectArr->stringValue->stringValue->new->XMLSchemaException->checkIDConstraintRestriction->blockSet1->blockSet2->if->throw->new->ObjectArr->new->XMLSchemaException->if->checkTypeDerivationOk->throw->new->ObjectArr->getName->getName->new->XMLSchemaException
XSConstraints#checkIDConstraintRestriction(XSElementDecl, XSElementDecl)::: constraints check constraint restriction:::
XSConstraints#checkOccurrenceRange(int, int, int, int)::: constraints check occurrence range:::if->return->else->return
XSConstraints#checkNSCompat(XSElementDecl, int, int, XSWildcardDecl, int, int, boolean)::: constraints check compat:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->if->wildcard->allowNamespace->throw->new->ObjectArr->new->XMLSchemaException
XSConstraints#checkNSSubset(XSWildcardDecl, int, int, XSWildcardDecl, int, int)::: constraints check subset:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->if->dWildcard->isSubsetOf->throw->new->XMLSchemaException->if->dWildcard->weakerProcessContents->throw->new->ObjectArr->dWildcard->getProcessContentsAsString->bWildcard->getProcessContentsAsString->new->XMLSchemaException
XSConstraints#checkNSRecurseCheckCardinality(List, int, int, SubstitutionGroupHandler, XSParticleDecl, int, int, boolean)::: constraints check recurse check cardinality:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->count->children->size->try->for->i->catch->throw->new->XMLSchemaException->finally
XSConstraints#checkRecurse(List, int, int, SubstitutionGroupHandler, List, int, int, SubstitutionGroupHandler)::: constraints check recurse:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->count1->dChildren->size->count2->bChildren->size->current->for->i->for->j
XSConstraints#checkRecurseUnordered(List, int, int, SubstitutionGroupHandler, List, int, int, SubstitutionGroupHandler)::: constraints check recurse unordered:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->count1->dChildren->size->count2->bChildren->size->foundIt->new->booleanArr->for->i->for->j
XSConstraints#checkRecurseLax(List, int, int, SubstitutionGroupHandler, List, int, int, SubstitutionGroupHandler)::: constraints check recurse lax:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->count1->dChildren->size->count2->bChildren->size->current->for->i
XSConstraints#checkMapAndSum(List, int, int, SubstitutionGroupHandler, List, int, int, SubstitutionGroupHandler)::: constraints check map and sum:::if->checkOccurrenceRange->throw->new->ObjectArr->Integer->toString->Integer->toString->Integer->toString->Integer->toString->new->XMLSchemaException->count1->dChildren->size->count2->bChildren->size->for->i
XSConstraints#overlapUPA(XSElementDecl, XSElementDecl, SubstitutionGroupHandler)::: constraints overlap a:::if->return->subGroup->sgHandler->getSubstitutionGroup->for->i->sgHandler->getSubstitutionGroup->for->i->return
XSConstraints#overlapUPA(XSElementDecl, XSWildcardDecl, SubstitutionGroupHandler)::: constraints overlap a:::if->wildcard->allowNamespace->return->subGroup->sgHandler->getSubstitutionGroup->for->i->return
XSConstraints#overlapUPA(XSWildcardDecl, XSWildcardDecl)::: constraints overlap a:::intersect->wildcard1->performIntersectionWith->if->return->return
XSConstraints#overlapUPA(Object, Object, SubstitutionGroupHandler)::: constraints overlap a:::if->if->return->overlapUPA->else->return->overlapUPA->else->if->return->overlapUPA->else->return->overlapUPA
XSDDescription#getGrammarType():::the type of the grammar (e.g., DTD or XSD);:::return
XSDDescription#getContextType():::Get the context:::return
XSDDescription#getTargetNamespace():::If the context is "include" or "redefine", then return the target namespace of the enclosing schema document; otherwise, the expected target namespace of this document.:::return
XSDDescription#getLocationHints():::For import and references from the instance document, it's possible to have multiple hints for one namespace:::return
XSDDescription#getTriggeringComponent():::If a call is triggered by an element/attribute/xsi:type in the instance, this call returns the name of such triggering component: the name of the element/attribute, or the value of the xsi:type.:::return
XSDDescription#getEnclosingElementName():::If a call is triggered by an attribute or xsi:type, then this mehtod returns the enclosing element of such element.:::return
XSDDescription#getAttributes():::If a call is triggered by an element/attribute/xsi:type in the instance, this call returns all attribute of such element (or enclosing element).:::return
XSDDescription#fromInstance()::: description from instance:::return
XSDDescription#isExternal()::: description is external:::return
XSDDescription#equals(Object):::Compares this grammar with the given grammar:::if->return->desc->if->return->fNamespace->desc->getTargetNamespace->equals->else->return->desc->getTargetNamespace
XSDDescription#hashCode():::Returns the hash code of this grammar:::return->fNamespace->hashCode
XSDDescription#setContextType(short)::: description set context type:::
XSDDescription#setTargetNamespace(String)::: description set target namespace:::
XSDDescription#setLocationHints(String[])::: description set location hints:::length->new->StringArr->System->arraycopy
XSDDescription#setTriggeringComponent(QName)::: description set triggering component:::
XSDDescription#setEnclosingElementName(QName)::: description set enclosing element name:::
XSDDescription#setAttributes(XMLAttributes)::: description set attributes:::
XSDDescription#reset()::: resets all the fields:::super->clear
XSDDescription#makeClone()::: description make clone:::desc->new->XSDDescription->return
XSDeclarationPool#setDVFactory(SchemaDVFactoryImpl)::: declaration pool set factory:::
XSDeclarationPool#getElementDecl()::: declaration pool get element decl:::chunk->index->ensureElementDeclCapacity->if->new->XSElementDecl->else->reset->return
XSDeclarationPool#getAttributeDecl()::: declaration pool get attribute decl:::chunk->index->ensureAttrDeclCapacity->if->new->XSAttributeDecl->else->reset->return
XSDeclarationPool#getAttributeUse()::: declaration pool get attribute use:::chunk->index->ensureAttributeUseCapacity->if->new->XSAttributeUseImpl->else->reset->return
XSDeclarationPool#getComplexTypeDecl()::: declaration pool get complex type decl:::chunk->index->ensureCTDeclCapacity->if->new->XSComplexTypeDecl->else->reset->return
XSDeclarationPool#getSimpleTypeDecl()::: declaration pool get simple type decl:::chunk->index->ensureSTDeclCapacity->if->dvFactory->newXSSimpleTypeDecl->else->reset->return
XSDeclarationPool#getParticleDecl()::: declaration pool get particle decl:::chunk->index->ensureParticleDeclCapacity->if->new->XSParticleDecl->else->reset->return
XSDeclarationPool#getModelGroup()::: declaration pool get model group:::chunk->index->ensureModelGroupCapacity->if->new->XSModelGroupImpl->else->reset->return
XSDeclarationPool#ensureElementDeclCapacity(int)::: declaration pool ensure element decl capacity:::if->resize->else->if->return->new->XSElementDeclArr->return
XSDeclarationPool#resize(XSElementDecl[][], int)::: declaration pool resize:::newarray->new->XSElementDeclArrs->System->arraycopy->return
XSDeclarationPool#ensureParticleDeclCapacity(int)::: declaration pool ensure particle decl capacity:::if->resize->else->if->return->new->XSParticleDeclArr->return
XSDeclarationPool#ensureModelGroupCapacity(int)::: declaration pool ensure model group capacity:::if->resize->else->if->return->new->XSModelGroupImplArr->return
XSDeclarationPool#resize(XSParticleDecl[][], int)::: declaration pool resize:::newarray->new->XSParticleDeclArrs->System->arraycopy->return
XSDeclarationPool#resize(XSModelGroupImpl[][], int)::: declaration pool resize:::newarray->new->XSModelGroupImplArrs->System->arraycopy->return
XSDeclarationPool#ensureAttrDeclCapacity(int)::: declaration pool ensure attr decl capacity:::if->resize->else->if->return->new->XSAttributeDeclArr->return
XSDeclarationPool#resize(XSAttributeDecl[][], int)::: declaration pool resize:::newarray->new->XSAttributeDeclArrs->System->arraycopy->return
XSDeclarationPool#ensureAttributeUseCapacity(int)::: declaration pool ensure attribute use capacity:::if->resize->else->if->return->new->XSAttributeUseImplArr->return
XSDeclarationPool#resize(XSAttributeUseImpl[][], int)::: declaration pool resize:::newarray->new->XSAttributeUseImplArrs->System->arraycopy->return
XSDeclarationPool#ensureSTDeclCapacity(int)::: declaration pool ensure decl capacity:::if->resize->else->if->return->new->XSSimpleTypeDeclArr->return
XSDeclarationPool#resize(XSSimpleTypeDecl[][], int)::: declaration pool resize:::newarray->new->XSSimpleTypeDeclArrs->System->arraycopy->return
XSDeclarationPool#ensureCTDeclCapacity(int)::: declaration pool ensure decl capacity:::if->resize->else->if->return->new->XSComplexTypeDeclArr->return
XSDeclarationPool#resize(XSComplexTypeDecl[][], int)::: declaration pool resize:::newarray->new->XSComplexTypeDeclArrs->System->arraycopy->return
XSDeclarationPool#reset()::: declaration pool reset:::
XSElementDecl#setConstraintType(short)::: element decl set constraint type:::
XSElementDecl#setIsNillable()::: element decl set is nillable:::
XSElementDecl#setIsAbstract()::: element decl set is abstract:::
XSElementDecl#setIsGlobal()::: element decl set is global:::
XSElementDecl#setIsLocal(XSComplexTypeDecl)::: element decl set is local:::
XSElementDecl#addIDConstraint(IdentityConstraint)::: element decl add constraint:::if->resize
XSElementDecl#getIDConstraints()::: element decl get constraints:::if->return->if->resize->return
XSElementDecl#resize(IdentityConstraint[], int)::: element decl resize:::newArray->new->IdentityConstraintArr->System->Math->min->arraycopy->return
XSElementDecl#toString()::: element decl to string:::if->if->buffer->fTargetNamespace->length->fName->length->new->StringBuffer->buffer->append->buffer->append->buffer->append->buffer->append->buffer->append->buffer->toString->else->return
XSElementDecl#hashCode():::get the hash code:::code->fName->hashCode->if->fTargetNamespace->hashCode->return
XSElementDecl#equals(Object):::whether two decls are the same:::return
XSElementDecl#reset():::Reset current element declaration:::for->i
XSElementDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSElementDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSElementDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSElementDecl#getTypeDefinition():::Either a simple type definition or a complex type definition.:::return
XSElementDecl#getScope():::Optional:::return
XSElementDecl#getEnclosingCTDefinition():::Locally scoped declarations are available for use only within the complex type definition identified by the scope property.:::return
XSElementDecl#getConstraintType():::A value constraint: one of default, fixed.:::return
XSElementDecl#getConstraintValue():::A value constraint: The actual value (with respect to the {type definition}):::return->getConstraintType->fDefault->stringValue
XSElementDecl#getNillable():::If {nillable} is true, then an element may also be valid if it carries the namespace qualified attribute with [local name] nil from namespace http://www.w3.org/2001/XMLSchema-instance and value true (see xsi:nil (2.6.2)) even if it has no text or element content despite a {content type} which would otherwise require content.:::return
XSElementDecl#getIdentityConstraints():::{identity-constraint definitions} A set of constraint definitions.:::return->new->XSNamedMapImpl
XSElementDecl#getSubstitutionGroupAffiliation():::{substitution group affiliation} Optional:::return
XSElementDecl#isSubstitutionGroupExclusion(short):::Convenience method:::return
XSElementDecl#getSubstitutionGroupExclusions():::Specifies if this declaration can be nominated as the {substitution group affiliation} of other element declarations having the same {type definition} or types derived therefrom.:::return
XSElementDecl#isDisallowedSubstitution(short):::Convenience method:::return
XSElementDecl#getDisallowedSubstitutions():::The supplied values for {disallowed substitutions}:::return
XSElementDecl#getAbstract():::{abstract} A boolean.:::return
XSElementDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSElementDecl#getAnnotations():::Optional:::return
XSElementDecl#getNamespaceItem()::: element decl get namespace item:::return
XSElementDecl#setNamespaceItem(XSNamespaceItem)::: element decl set namespace item:::
XSElementDecl#getActualVC()::: element decl get actual c:::return->getConstraintType
XSElementDecl#getActualVCType()::: element decl get actual type:::return->getConstraintType
XSElementDecl#getItemValueTypes()::: element decl get item value types:::return->getConstraintType
XSElementDecl#getValueConstraintValue()::: element decl get value constraint value:::return
XSElementDeclHelper#getGlobalElementDecl(QName)::: element decl helper get global element decl:::
XSGrammarBucket#getGrammar(String):::Get the schema grammar for the specified namespace:::if->return->return->fGrammarRegistry->get
XSGrammarBucket#putGrammar(SchemaGrammar):::Put a schema grammar into the registry This method is for internal use only: it assumes that a grammar with the same target namespace is not already in the bucket.:::if->grammar->getTargetNamespace->else->fGrammarRegistry->grammar->getTargetNamespace->put
XSGrammarBucket#putGrammar(SchemaGrammar, boolean):::put a schema grammar and any grammars imported by it (directly or inderectly) into the registry:::sg->getGrammar->if->return->if->putGrammar->return->currGrammars->grammar->getImportedGrammars->if->putGrammar->return->grammars->currGrammars->clone->sg1->sg2->gs->for->i->grammars->size->putGrammar->for->i->grammars->size->return
XSGrammarBucket#putGrammar(SchemaGrammar, boolean, boolean):::put a schema grammar and any grammars imported by it (directly or inderectly) into the registry:::if->return->putGrammar->sg->getGrammar->if->putGrammar->if->return->currGrammars->grammar->getImportedGrammars->if->return->grammars->currGrammars->clone->sg1->sg2->gs->for->i->grammars->size->for->i->grammars->size->return
XSGrammarBucket#getGrammars():::get all grammars in the registry:::count->fGrammarRegistry->size->grammars->new->SchemaGrammarArr->i->foreach->fGrammarRegistry->entrySet->entry->getValue->if->return
XSGrammarBucket#reset():::Clear the registry:::fGrammarRegistry->clear
XSGroupDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSGroupDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSGroupDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSGroupDecl#getModelGroup():::{model group} A model group.:::return
XSGroupDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSGroupDecl#getAnnotations():::Optional:::return
XSGroupDecl#getNamespaceItem()::: group decl get namespace item:::return
XSGroupDecl#setNamespaceItem(XSNamespaceItem)::: group decl set namespace item:::
XSImplementationImpl#getDOMImplementation():::NON-DOM: Obtain and return the single shared object:::return
XSImplementationImpl#hasFeature(String, String):::Test if the DOM implementation supports a specific "feature" -- currently meaning language and level thereof.:::return->feature->equalsIgnoreCase->version->equals->super->hasFeature
XSImplementationImpl#createXSLoader(StringList)::: implementation impl create loader:::loader->new->XSLoaderImpl->if->return->for->i->versions->getLength->return
XSImplementationImpl#getRecognizedVersions()::: implementation impl get recognized versions:::list->new->StringArr->new->StringListImpl->return
XSLoaderImpl#getConfig()::: The configuration of a document:::return
XSLoaderImpl#loadURIList(StringList):::Parses the content of XML Schema documents specified as the list of URI references:::length->uriList->getLength->try->fGrammarPool->clear->for->i->return->fGrammarPool->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#loadInputList(LSInputList)::: Parses the content of XML Schema documents specified as a list of LSInputs.:::length->is->getLength->try->fGrammarPool->clear->for->i->return->fGrammarPool->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#loadURI(String):::Parse an XML Schema document from a location identified by a URI reference:::try->fGrammarPool->clear->return->fSchemaLoader->new->XMLInputSource->loadGrammar->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#load(LSInput)::: Parse an XML Schema document from a resource identified by a LSInput .:::try->fGrammarPool->clear->return->fSchemaLoader->fSchemaLoader->dom2xmlInputSource->loadGrammar->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#setParameter(String, Object)::: loader impl set parameter:::fSchemaLoader->setParameter
XSLoaderImpl#getParameter(String)::: loader impl get parameter:::return->fSchemaLoader->getParameter
XSLoaderImpl#canSetParameter(String, Object)::: loader impl can set parameter:::return->fSchemaLoader->canSetParameter
XSLoaderImpl#getParameterNames()::: loader impl get parameter names:::return->fSchemaLoader->getParameterNames
XSLoaderImpl.XSGrammarMerger#putGrammar(Grammar)::: grammar merger put grammar:::cachedGrammar->super->grammar->getGrammarDescription->getGrammar->toSchemaGrammar->if->newGrammar->toSchemaGrammar->if->mergeSchemaGrammars->else->super->putGrammar
XSLoaderImpl.XSGrammarMerger#toSchemaGrammar(Grammar)::: grammar merger to schema grammar:::return
XSLoaderImpl.XSGrammarMerger#mergeSchemaGrammars(SchemaGrammar, SchemaGrammar)::: grammar merger merge schema grammars:::map->newGrammar->getComponents->length->map->getLength->for->i->newGrammar->getComponents->map->getLength->for->i->newGrammar->getComponents->map->getLength->for->i->newGrammar->getComponents->map->getLength->for->i->newGrammar->getComponents->map->getLength->for->i->newGrammar->getComponents->map->getLength->for->i->annotations->newGrammar->getAnnotations->annotations->getLength->for->i
XSLoaderImpl.XSGrammarMerger#containsGrammar(XMLGrammarDescription)::: grammar merger contains grammar:::return
XSLoaderImpl.XSGrammarMerger#getGrammar(XMLGrammarDescription)::: grammar merger get grammar:::return
XSLoaderImpl.XSGrammarMerger#retrieveGrammar(XMLGrammarDescription)::: grammar merger retrieve grammar:::return
XSLoaderImpl.XSGrammarMerger#retrieveInitialGrammarSet(String)::: grammar merger retrieve initial grammar set:::return->new->GrammarArr
XSMessageFormatter#formatMessage(Locale, String, Object[]):::Formats a message with the specified arguments using the given locale information.:::if->if->SecuritySupport->getResourceBundle->if->SecuritySupport->getResourceBundle->msg->fResourceBundle->getString->if->try->format->catch->fResourceBundle->getString->fResourceBundle->getString->finally->if->fResourceBundle->getString->throw->new->MissingResourceException->return
XSModelGroupImpl#isEmpty()::: model group impl is empty:::for->i->return
XSModelGroupImpl#minEffectiveTotalRange():::3.8.6 Effective Total Range (all and sequence) and       Effective Total Range (choice) The following methods are used to return min/max range for a particle:::if->return->minEffectiveTotalRangeChoice->else->return->minEffectiveTotalRangeAllSeq
XSModelGroupImpl#minEffectiveTotalRangeAllSeq()::: model group impl min effective total range all seq:::total->for->i->return
XSModelGroupImpl#minEffectiveTotalRangeChoice()::: model group impl min effective total range choice:::min->one->if->minEffectiveTotalRange->for->i->return
XSModelGroupImpl#maxEffectiveTotalRange()::: model group impl max effective total range:::if->return->maxEffectiveTotalRangeChoice->else->return->maxEffectiveTotalRangeAllSeq
XSModelGroupImpl#maxEffectiveTotalRangeAllSeq()::: model group impl max effective total range all seq:::total->one->for->i->return
XSModelGroupImpl#maxEffectiveTotalRangeChoice()::: model group impl max effective total range choice:::max->one->if->maxEffectiveTotalRange->if->return->for->i->return
XSModelGroupImpl#toString()::: model group impl to string:::if->buffer->new->StringBuffer->if->buffer->append->else->buffer->append->if->buffer->toString->append->for->i->buffer->append->buffer->toString->return
XSModelGroupImpl#reset()::: model group impl reset:::
XSModelGroupImpl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSModelGroupImpl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSModelGroupImpl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSModelGroupImpl#getCompositor():::{compositor} One of all, choice or sequence:::if->return->else->if->return->else->return
XSModelGroupImpl#getParticles():::{particles} A list of particles:::return->new->XSObjectListImpl
XSModelGroupImpl#getAnnotation():::Optional:::return->fAnnotations->item
XSModelGroupImpl#getAnnotations():::Optional:::return
XSModelGroupImpl#getNamespaceItem()::: model group impl get namespace item:::return
XSModelImpl#buildSubGroups_Org()::: model impl build sub groups_ org:::sgHandler->new->SubstitutionGroupHandler->for->i->elements->getComponents->len->elements->getLength->subGroupMap->new->SymbolHash->head->subGroup->for->i->return
XSModelImpl#buildSubGroups()::: model impl build sub groups:::sgHandler->new->SubstitutionGroupHandler->for->i->elements->getGlobalElements->len->elements->getLength->subGroupMap->new->SymbolHash->head->subGroup->for->i->return
XSModelImpl#getGlobalElements()::: model impl get global elements:::tables->new->SymbolHashArr->length->for->i->if->return->components->new->XSObjectArr->start->for->i->return->new->XSObjectListImpl
XSModelImpl#getNamespaces():::Convenience method:::return
XSModelImpl#getNamespaceItems():::A set of namespace schema information information items (of type XSNamespaceItem), one for each namespace name which appears as the target namespace of any schema component in the schema used for that assessment, and one for absent if any schema component in the schema had no target namespace:::return
XSModelImpl#getComponents(short):::Returns a list of top-level components, i.e:::if->return->tables->new->SymbolHashArr->if->for->i->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
XSModelImpl#getComponentsByNamespace(short, String):::Convenience method:::if->return->i->if->for->else->for->if->return->if->table->switch->break->break->break->break->break->break->break->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
XSModelImpl#getTypeDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getTypeDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalTypeDecl
XSModelImpl#getAttributeDeclaration(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getAttributeDeclaration(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalAttributeDecl
XSModelImpl#getElementDeclaration(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getElementDeclaration(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalElementDecl
XSModelImpl#getAttributeGroup(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getAttributeGroup(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalAttributeGroupDecl
XSModelImpl#getModelGroupDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getModelGroupDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalGroupDecl
XSModelImpl#getIDCDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getIDCDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getIDConstraintDecl
XSModelImpl#getNotationDeclaration(String, String)::: model impl get notation declaration:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getNotationDeclaration(String, String, String)::: model impl get notation declaration:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalNotationDecl
XSModelImpl#getAnnotations()::: [annotations]: a set of annotations if it exists, otherwise an empty XSObjectList.:::if->return->totalAnnotations->for->i->if->return->annotations->new->XSAnnotationImplArr->currPos->for->i->new->XSObjectListImpl->return
XSModelImpl#null2EmptyString(String)::: model impl null2 empty string:::return
XSModelImpl#hasIDConstraints():::REVISIT: to expose identity constraints from XSModel:::return
XSModelImpl#getSubstitutionGroup(XSElementDeclaration):::Convenience method:::return->fSubGroupMap->get
XSModelImpl#getLength():::The number of XSNamespaceItems in the list:::return
XSModelImpl#item(int):::Returns the indexth item in the collection or null if index is greater than or equal to the number of objects in the list:::if->return->return
XSModelImpl#get(int)::: model impl get:::if->return->throw->new->IndexOutOfBoundsException
XSModelImpl#size()::: model impl size:::return->getLength
XSModelImpl#iterator()::: model impl iterator:::return->listIterator0
XSModelImpl#listIterator()::: model impl list iterator:::return->listIterator0
XSModelImpl#listIterator(int)::: model impl list iterator:::if->return->listIterator0->throw->new->IndexOutOfBoundsException
XSModelImpl#listIterator0(int)::: model impl list iterator0:::return->new->XSNamespaceItemListIterator
XSModelImpl#toArray()::: model impl to array:::a->new->ObjectArr->toArray0->return
XSModelImpl#toArray(Object[])::: model impl to array:::if->arrayClass->a->getClass->componentType->arrayClass->getComponentType->Array->newInstance->toArray0->if->return
XSModelImpl#toArray0(Object[])::: model impl to array0:::if->System->arraycopy
XSModelImpl.XSNamespaceItemListIterator#hasNext()::: namespace item list iterator has next:::return
XSModelImpl.XSNamespaceItemListIterator#next()::: namespace item list iterator next:::if->return->throw->new->NoSuchElementException
XSModelImpl.XSNamespaceItemListIterator#hasPrevious()::: namespace item list iterator has previous:::return
XSModelImpl.XSNamespaceItemListIterator#previous()::: namespace item list iterator previous:::if->return->throw->new->NoSuchElementException
XSModelImpl.XSNamespaceItemListIterator#nextIndex()::: namespace item list iterator next index:::return
XSModelImpl.XSNamespaceItemListIterator#previousIndex()::: namespace item list iterator previous index:::return
XSModelImpl.XSNamespaceItemListIterator#remove()::: namespace item list iterator remove:::throw->new->UnsupportedOperationException
XSModelImpl.XSNamespaceItemListIterator#set(XSNamespaceItem)::: namespace item list iterator set:::throw->new->UnsupportedOperationException
XSModelImpl.XSNamespaceItemListIterator#add(XSNamespaceItem)::: namespace item list iterator add:::throw->new->UnsupportedOperationException
XSNotationDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSNotationDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSNotationDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSNotationDecl#getSystemId():::Optional if {public identifier} is present:::return
XSNotationDecl#getPublicId():::Optional if {system identifier} is present:::return
XSNotationDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSNotationDecl#getAnnotations():::Optional:::return
XSNotationDecl#getNamespaceItem()::: notation decl get namespace item:::return
XSNotationDecl#setNamespaceItem(XSNamespaceItem)::: notation decl set namespace item:::
XSParticleDecl#makeClone()::: particle decl make clone:::particle->new->XSParticleDecl->return
XSParticleDecl#emptiable():::3.9.6 Schema Component Constraint: Particle Emptiable whether this particle is emptible:::return->minEffectiveTotalRange
XSParticleDecl#isEmpty()::: particle decl is empty:::if->return->if->return->return->isEmpty
XSParticleDecl#minEffectiveTotalRange():::3.8.6 Effective Total Range (all and sequence) and       Effective Total Range (choice) The following methods are used to return min/max range for a particle:::if->return->if->return->minEffectiveTotalRange->return
XSParticleDecl#maxEffectiveTotalRange()::: particle decl max effective total range:::if->return->if->max->maxEffectiveTotalRange->if->return->if->return->return->return
XSParticleDecl#toString()::: particle decl to string:::if->buffer->new->StringBuffer->appendParticle->if->buffer->append->append->if->buffer->append->else->if->buffer->append->append->buffer->append->buffer->toString->return
XSParticleDecl#appendParticle(StringBuffer):::append the string description of this particle to the string buffer this is for error message.:::switch->buffer->append->break->buffer->fValue->toString->append->break->buffer->append->buffer->fValue->toString->append->buffer->append->break->buffer->fValue->toString->append->break
XSParticleDecl#reset()::: particle decl reset:::
XSParticleDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSParticleDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSParticleDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSParticleDecl#getMinOccurs():::{min occurs} determines the minimum number of terms that can occur.:::return
XSParticleDecl#getMaxOccursUnbounded():::{max occurs} whether the maxOccurs value is unbounded.:::return
XSParticleDecl#getMaxOccurs():::{max occurs} determines the maximum number of terms that can occur.:::return
XSParticleDecl#getTerm():::{term} One of a model group, a wildcard, or an element declaration.:::return
XSParticleDecl#getNamespaceItem()::: particle decl get namespace item:::return
XSParticleDecl#getAnnotations():::Optional:::return
XSWildcardDecl#allowNamespace(String):::Validation Rule: Wildcard allows Namespace Name:::if->return->if->found->listNum->for->i->if->return->if->listNum->for->i->return
XSWildcardDecl#isSubsetOf(XSWildcardDecl)::: Schema Component Constraint: Wildcard Subset:::if->return->if->return->if->if->return->if->if->subset2sets->return->if->elementInSet->elementInSet->return->return
XSWildcardDecl#weakerProcessContents(XSWildcardDecl):::Check whether this wildcard has a weaker process contents than the super.:::return
XSWildcardDecl#performUnionWith(XSWildcardDecl, short):::Schema Component Constraint: Attribute Wildcard Union:::if->return->unionWildcard->new->XSWildcardDecl->if->areSame->else->if->else->if->union2sets->else->if->new->StringArr->else->if->other->list->if->else->foundAbsent->elementInSet->if->foundNS->elementInSet->if->else->if->new->StringArr->else->if->return->else->else->if->else->return
XSWildcardDecl#performIntersectionWith(XSWildcardDecl, short):::Schema Component Constraint: Attribute Wildcard Intersection:::if->return->intersectWildcard->new->XSWildcardDecl->if->areSame->else->if->other->if->else->if->list->other->if->else->listSize->intersect->new->StringArr->newSize->for->i->new->StringArr->System->arraycopy->else->if->intersect2sets->else->if->if->return->other->if->return
XSWildcardDecl#areSame(XSWildcardDecl)::: wildcard decl are same:::if->if->return->if->return->if->for->i->return->return
XSWildcardDecl#intersect2sets(String[], String[])::: wildcard decl intersect2sets:::result->Math->min->new->StringArr->count->for->i->result2->new->StringArr->System->arraycopy->return
XSWildcardDecl#union2sets(String[], String[])::: wildcard decl union2sets:::result1->new->StringArr->count->for->i->result2->new->StringArr->System->arraycopy->System->arraycopy->return
XSWildcardDecl#subset2sets(String[], String[])::: wildcard decl subset2sets:::for->i->return
XSWildcardDecl#elementInSet(String, String[])::: wildcard decl element in set:::found->for->i->return
XSWildcardDecl#toString()::: wildcard decl to string:::if->buffer->new->StringBuffer->buffer->append->switch->buffer->append->break->buffer->append->buffer->append->if->buffer->append->buffer->append->break->if->break->buffer->append->if->buffer->append->buffer->append->for->i->break->buffer->append->buffer->toString->return
XSWildcardDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSWildcardDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSWildcardDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSWildcardDecl#getConstraintType():::Namespace constraint: A constraint type: any, not, list.:::return
XSWildcardDecl#getNsConstraintList():::Namespace constraint:::return->new->StringListImpl
XSWildcardDecl#getProcessContents():::{process contents} One of skip, lax or strict:::return
XSWildcardDecl#getProcessContentsAsString():::String valid of {process contents}:::switch->return->return->return->return
XSWildcardDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSWildcardDecl#getAnnotations():::Optional:::return
XSWildcardDecl#getNamespaceItem()::: wildcard decl get namespace item:::return
