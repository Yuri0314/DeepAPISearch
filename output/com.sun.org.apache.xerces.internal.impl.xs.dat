AttributePSVImpl#getSchemaDefault():::[schema default]:::return->fDeclaration->getConstraintValue
AttributePSVImpl#getSchemaNormalizedValue():::[schema normalized value]:::return->fValue->getNormalizedValue
AttributePSVImpl#getIsSchemaSpecified():::[schema specified]:::return
AttributePSVImpl#getValidationAttempted():::Determines the extent to which the document has been validated:::return
AttributePSVImpl#getValidity():::Determine the validity of the node with respect to the validation being attempted:::return
AttributePSVImpl#getErrorCodes():::A list of error codes generated from validation attempts:::if->return->return->new->PSVIErrorList
AttributePSVImpl#getErrorMessages():::A list of error messages generated from the validation attempt or an empty StringList if no errors occurred during the validation attempt:::if->return->return->new->PSVIErrorList
AttributePSVImpl#getTypeDefinition():::An item isomorphic to the type definition used to validate this element.:::return
AttributePSVImpl#getMemberTypeDefinition():::If and only if that type definition is a simple type definition with {variety} union, or a complex type definition whose {content type} is a simple thype definition with {variety} union, then an item isomorphic to that member of the union's {member type definitions} which actually validated the element item's normalized value.:::return->fValue->getMemberTypeDefinition
AttributePSVImpl#getAttributeDeclaration():::An item isomorphic to the attribute declaration used to validate this attribute.:::return
AttributePSVImpl#reset():::Reset():::fValue->reset
ElementPSVImpl#getSchemaDefault():::[schema default]:::return->fDeclaration->getConstraintValue
ElementPSVImpl#getSchemaNormalizedValue():::[schema normalized value]:::return->fValue->getNormalizedValue
ElementPSVImpl#getIsSchemaSpecified():::[schema specified]:::return
ElementPSVImpl#getValidationAttempted():::Determines the extent to which the document has been validated:::return
ElementPSVImpl#getValidity():::Determine the validity of the node with respect to the validation being attempted:::return
ElementPSVImpl#getErrorCodes():::A list of error codes generated from validation attempts:::if->return->return->new->PSVIErrorList
ElementPSVImpl#getErrorMessages():::A list of error messages generated from the validation attempt or an empty StringList if no errors occurred during the validation attempt:::if->return->return->new->PSVIErrorList
ElementPSVImpl#getNil():::[nil]:::return
ElementPSVImpl#getNotation():::[notation]:::return
ElementPSVImpl#getTypeDefinition():::An item isomorphic to the type definition used to validate this element.:::return
ElementPSVImpl#getMemberTypeDefinition():::If and only if that type definition is a simple type definition with {variety} union, or a complex type definition whose {content type} is a simple thype definition with {variety} union, then an item isomorphic to that member of the union's {member type definitions} which actually validated the element item's normalized value.:::return->fValue->getMemberTypeDefinition
ElementPSVImpl#getElementDeclaration():::An item isomorphic to the element declaration used to validate this element.:::return
ElementPSVImpl#getSchemaInformation():::[schema information]:::if->new->XSModelImpl->return
ElementPSVImpl#reset():::Reset() should be called in validator startElement(..) method.:::fValue->reset
SchemaGrammar#getTargetNamespace():::Returns this grammar's target namespace.:::return
SchemaGrammar#addGlobalAttributeDecl(XSAttributeDecl):::register one global attribute:::fGlobalAttrDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalAttributeGroupDecl(XSAttributeGroupDecl):::register one global attribute group:::fGlobalAttrGrpDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalElementDeclAll(XSElementDecl):::register one global element:::if->fAllGlobalElemDecls->get->fAllGlobalElemDecls->put->if->if->resize
SchemaGrammar#addGlobalGroupDecl(XSGroupDecl):::register one global group:::fGlobalGroupDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalNotationDecl(XSNotationDecl):::register one global notation:::fGlobalNotationDecls->put->decl->setNamespaceItem
SchemaGrammar#addGlobalTypeDecl(XSTypeDefinition):::register one global type:::fGlobalTypeDecls->decl->getName->put->if->setNamespaceItem->else->if->setNamespaceItem
SchemaGrammar#addGlobalComplexTypeDecl(XSComplexTypeDecl):::register one global complex type:::fGlobalTypeDecls->decl->getName->put->decl->setNamespaceItem
SchemaGrammar#addGlobalSimpleTypeDecl(XSSimpleType):::register one global simple type:::fGlobalTypeDecls->decl->getName->put->if->setNamespaceItem
SchemaGrammar#addIDConstraintDecl(XSElementDecl, IdentityConstraint):::register one identity constraint:::elmDecl->addIDConstraint->fGlobalIDConstraintDecls->decl->getIdentityConstraintName->put
SchemaGrammar#getGlobalAttributeDecl(String):::get one global attribute:::return->fGlobalAttrDecls->get
SchemaGrammar#getGlobalAttributeGroupDecl(String):::get one global attribute group:::return->fGlobalAttrGrpDecls->get
SchemaGrammar#getGlobalElementDecl(String):::get one global element:::return->fGlobalElemDecls->get
SchemaGrammar#getGlobalGroupDecl(String):::get one global group:::return->fGlobalGroupDecls->get
SchemaGrammar#getGlobalNotationDecl(String):::get one global notation:::return->fGlobalNotationDecls->get
SchemaGrammar#getGlobalTypeDecl(String):::get one global type:::return->fGlobalTypeDecls->get
SchemaGrammar#getIDConstraintDecl(String):::get one identity constraint:::return->fGlobalIDConstraintDecls->get
SchemaGrammar#hasIDConstraints():::get one identity constraint:::return->fGlobalIDConstraintDecls->getLength
SchemaGrammar#addComplexTypeDecl(XSComplexTypeDecl, SimpleLocator):::add one complex type decl: for later constraint checking:::if->resize->resize
SchemaGrammar#addRedefinedGroupDecl(XSGroupDecl, XSGroupDecl, SimpleLocator):::add a group redefined by restriction: for later constraint checking:::if->resize->resize
SchemaGrammar#getUncheckedComplexTypeDecls():::get all complex type decls: for later constraint checking:::if->resize->resize->return
SchemaGrammar#getUncheckedCTLocators():::get the error locator of all complex type decls:::if->resize->resize->return
SchemaGrammar#getRedefinedGroupDecls():::get all redefined groups: for later constraint checking:::if->resize->resize->return
SchemaGrammar#getRGLocators():::get the error locator of all redefined groups:::if->resize->resize->return
SchemaGrammar#setUncheckedTypeNum(int):::after the first-round checking, some types don't need to be checked against UPA again:::resize->resize
SchemaGrammar#getSubstitutionGroups():::get all substitution group information: for the 3 constraint checking:::if->resize->return
SchemaGrammar#getSchemaNamespace():::[schema namespace]:::return
SchemaGrammar#getComponents(short):::[schema components]: a list of top-level components, i.e:::if->return->if->new->XSNamedMapArr->if->table->switch->break->break->break->break->break->break->break->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
SchemaGrammar#getTypeDefinition(String):::Convenience method:::return->getGlobalTypeDecl
SchemaGrammar#getAttributeDeclaration(String):::Convenience method:::return->getGlobalAttributeDecl
SchemaGrammar#getElementDeclaration(String):::Convenience method:::return->getGlobalElementDecl
SchemaGrammar#getAttributeGroup(String):::Convenience method:::return->getGlobalAttributeGroupDecl
SchemaGrammar#getModelGroupDefinition(String):::Convenience method:::return->getGlobalGroupDecl
SchemaGrammar#getNotationDeclaration(String):::Convenience method:::return->getGlobalNotationDecl
SchemaGrammar#getDocumentLocations():::[document location]:::return->new->StringListImpl
SchemaGrammar#toXSModel():::Return an XSModel that represents components in this schema grammar.:::return->new->SchemaGrammarArr->new->XSModelImpl
SchemaNamespaceSupport#setEffectiveContext(String[]):::This method takes a set of Strings, as stored in a NamespaceSupport object, and "fools" the object into thinking that this is one unified context:::if->return->pushContext->newSize->if->tempNSArray->new->StringArr->System->arraycopy->System->arraycopy
SchemaNamespaceSupport#getEffectiveLocalContext():::This method returns an array of Strings, as would be stored in a NamespaceSupport object:::returnVal->if->bottomLocalContext->copyCount->if->new->StringArr->System->arraycopy->return
SubstitutionGroupHandler#reset():::clear the internal registry of substitutionGroup information:::fSubGroupsB->clear->fSubGroups->clear
SubstitutionGroupHandler#addSubstitutionGroup(XSElementDecl[]):::add a list of substitution group information.:::subHead->element->subGroup->for->i
SubstitutionGroupHandler#getSubstitutionGroup(XSElementDecl):::get all elements that can substitute the given element, according to the spec, we shouldn't consider the {block} constraints:::subGroup->fSubGroups->get->if->return->if->fSubGroups->put->return->groupB->new->OneSubGroup->getSubGroupB->len->rlen->ret->new->XSElementDeclArr->for->i->if->ret1->new->XSElementDeclArr->System->arraycopy->fSubGroups->put->return
XMLSchemaLoader#getRecognizedFeatures():::Returns a list of feature identifiers that are recognized by this XMLGrammarLoader:::return->RECOGNIZED_FEATURES->clone
XMLSchemaLoader#getFeature(String):::Returns the state of a feature.:::return->fLoaderConfig->getFeature
XMLSchemaLoader#setFeature(String, boolean):::Sets the state of a feature.:::if->featureId->equals->fErrorReporter->setFeature->else->if->featureId->equals->fSchemaHandler->setGenerateSyntheticAnnotations->fLoaderConfig->setFeature
XMLSchemaLoader#getRecognizedProperties():::Returns a list of property identifiers that are recognized by this XMLGrammarLoader:::return->RECOGNIZED_PROPERTIES->clone
XMLSchemaLoader#getProperty(String):::Returns the state of a property.:::return->fLoaderConfig->getProperty
XMLSchemaLoader#setProperty(String, Object):::Sets the state of a property.:::fLoaderConfig->setProperty->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->else->if->propertyId->equals->setLocale->else->if->propertyId->equals->fEntityManager->setProperty->else->if->propertyId->equals->if->fErrorReporter->getMessageFormatter->fErrorReporter->new->XSMessageFormatter->putMessageFormatter->else->if->propertyId->equals->spm->spm->getValue
XMLSchemaLoader#setLocale(Locale):::Set the locale to use for messages.:::fErrorReporter->setLocale
XMLSchemaLoader#getLocale():::Return the Locale the XMLGrammarLoader is using.:::return
XMLSchemaLoader#setErrorHandler(XMLErrorHandler):::Sets the error handler.:::fErrorReporter->setProperty
XMLSchemaLoader#getErrorHandler():::Returns the registered error handler.:::return->fErrorReporter->getErrorHandler
XMLSchemaLoader#setEntityResolver(XMLEntityResolver):::Sets the entity resolver.:::fLoaderConfig->setProperty->fEntityManager->setProperty
XMLSchemaLoader#getEntityResolver():::Returns the registered entity resolver.:::return
XMLSchemaLoader#loadGrammar(XMLInputSource[]):::Returns a Grammar object by parsing the contents of the entities pointed to by sources.:::numSource->for->i
XMLSchemaLoader#loadGrammar(XMLInputSource):::Returns a Grammar object by parsing the contents of the entity pointed to by source.:::reset->desc->new->XSDDescription->desc->source->getBaseSystemId->setBaseSystemId->desc->source->getSystemId->setLiteralSystemId->locationPairs->new->HashMap<>->processExternalHints->grammar->loadSchema->if->fGrammarPool->fGrammarBucket->getGrammars->cacheGrammars->if->fJAXPCache->get->XSConstraints->fullSchemaChecking->return
XMLSchemaLoader#loadSchema(XSDDescription, XMLInputSource, Map):::This method is called either from XMLGrammarLoader.loadGrammar or from XMLSchemaValidator:::if->processJAXPSchemaSource->if->desc->isExternal->source->isCreatedByResolver->accessError->SecuritySupport->desc->getExpandedSystemId->checkAccess->if->throw->fErrorReporter->new->ObjectArr->SecuritySupport->desc->getExpandedSystemId->sanitizePath->reportError->new->XNIException->grammar->fSchemaHandler->parseSchema->return
XMLSchemaLoader#resolveDocument(XSDDescription, Map, XMLEntityResolver):::This method tries to resolve location of the given schema:::loc->if->desc->getContextType->desc->fromInstance->namespace->desc->getTargetNamespace->ns->tempLA->locationPairs->get->if->tempLA->getFirstLocation->if->hints->desc->getLocationHints->if->expandedLoc->XMLEntityManager->desc->getBaseSystemId->expandSystemId->desc->setLiteralSystemId->desc->setExpandedSystemId->return->entityResolver->resolveEntity
XMLSchemaValidator#getRecognizedFeatures():::Returns a list of feature identifiers that are recognized by this component:::return->RECOGNIZED_FEATURES->clone
XMLSchemaValidator#setFeature(String, boolean):::Sets the state of a feature:::
XMLSchemaValidator#getRecognizedProperties():::Returns a list of property identifiers that are recognized by this component:::return->RECOGNIZED_PROPERTIES->clone
XMLSchemaValidator#setProperty(String, Object):::Sets the value of a property:::if->propertyId->equals->if->else->if->else->else->if->propertyId->equals->if->else->if->else
XMLSchemaValidator#getFeatureDefault(String):::Returns the default state for a feature, or null if this component does not want to report a default value for this feature.:::for->i->return
XMLSchemaValidator#getPropertyDefault(String):::Returns the default state for a property, or null if this component does not want to report a default value for this property.:::for->i->return
XMLSchemaValidator#setDocumentHandler(XMLDocumentHandler):::Sets the document handler to receive information about the document.:::if->try->getFeature->catch->finally
XMLSchemaValidator#getDocumentHandler():::Returns the document handler:::return
XMLSchemaValidator#setDocumentSource(XMLDocumentSource):::Sets the document source:::
XMLSchemaValidator#getDocumentSource():::Returns the document source:::return
XMLSchemaValidator#startDocument(XMLLocator, String, NamespaceContext, Augmentations):::The start of the document.:::fValidationState->setNamespaceSupport->fState4XsiType->setNamespaceSupport->fState4ApplyDefault->setNamespaceSupport->handleStartDocument->if->fDocumentHandler->startDocument
XMLSchemaValidator#xmlDecl(String, String, String, Augmentations):::Notifies of the presence of an XMLDecl line in the document:::if->fDocumentHandler->xmlDecl
XMLSchemaValidator#doctypeDecl(String, String, String, Augmentations):::Notifies of the presence of the DOCTYPE line in the document.:::if->fDocumentHandler->doctypeDecl
XMLSchemaValidator#startElement(QName, XMLAttributes, Augmentations):::The start of an element.:::modifiedAugs->handleStartElement->if->fDocumentHandler->startElement
XMLSchemaValidator#emptyElement(QName, XMLAttributes, Augmentations):::An empty element.:::modifiedAugs->handleStartElement->if->handleEndElement->if->if->fDocumentHandler->emptyElement->else->fDocumentHandler->startElement->fDocumentHandler->characters->fDocumentHandler->endElement
XMLSchemaValidator#characters(XMLString, Augmentations):::Character content.:::handleCharacters->if->if->ignorableWhitespace->return->if->if->if->fDocumentHandler->characters->else->fDocumentHandler->characters
XMLSchemaValidator#ignorableWhitespace(XMLString, Augmentations):::Ignorable whitespace:::handleIgnorableWhitespace->if->fDocumentHandler->ignorableWhitespace
XMLSchemaValidator#endElement(QName, Augmentations):::The end of an element.:::modifiedAugs->handleEndElement->if->if->fDocumentHandler->endElement->else->fDocumentHandler->characters->fDocumentHandler->endElement
XMLSchemaValidator#startCDATA(Augmentations):::The start of a CDATA section.:::if->fDocumentHandler->startCDATA
XMLSchemaValidator#endCDATA(Augmentations):::The end of a CDATA section.:::if->fDocumentHandler->endCDATA
XMLSchemaValidator#endDocument(Augmentations):::The end of the document.:::handleEndDocument->if->fDocumentHandler->endDocument
XMLSchemaValidator#startGeneralEntity(String, XMLResourceIdentifier, String, Augmentations):::This method notifies the start of a general entity:::if->fDocumentHandler->startGeneralEntity
XMLSchemaValidator#textDecl(String, String, Augmentations):::Notifies of the presence of a TextDecl line in an entity:::if->fDocumentHandler->textDecl
XMLSchemaValidator#comment(XMLString, Augmentations):::A comment.:::if->fDocumentHandler->comment
XMLSchemaValidator#processingInstruction(String, XMLString, Augmentations):::A processing instruction:::if->fDocumentHandler->processingInstruction
XMLSchemaValidator#endGeneralEntity(String, Augmentations):::This method notifies the end of a general entity:::if->fDocumentHandler->endGeneralEntity
XMLSchemaValidator#startValueScopeFor(IdentityConstraint, int):::Start the value scope for the specified identity constraint:::valueStore->fValueStoreCache->getValueStoreFor->valueStore->startValueScope
XMLSchemaValidator#activateField(Field, int):::Request to activate the specified field:::valueStore->fValueStoreCache->field->getIdentityConstraint->getValueStoreFor->matcher->field->createMatcher->fMatcherStack->addMatcher->matcher->startDocumentFragment->return
XMLSchemaValidator#endValueScopeFor(IdentityConstraint, int):::Ends the value scope for the specified identity constraint.:::valueStore->fValueStoreCache->getValueStoreFor->valueStore->endValueScope
XMLSchemaValidator#ensureStackCapacity():::ensure element stack capacity:::if->newSize->newArrayB->new->booleanArr->System->arraycopy->newArrayE->new->XSElementDeclArr->System->arraycopy->new->booleanArr->System->arraycopy->newArrayN->new->XSNotationDeclArr->System->arraycopy->newArrayT->new->XSTypeDefinitionArr->System->arraycopy->newArrayC->new->XSCMValidatorArr->System->arraycopy->new->booleanArr->System->arraycopy->new->booleanArr->System->arraycopy->new->booleanArr->System->arraycopy->newArrayIA->new->intArrs->System->arraycopy
XMLSchemaValidator#handleStartElement(QName, XMLAttributes, Augmentations):::Handle element.:::if->println->if->fValidationManager->isGrammarFound->if->else->if->sLocation->attributes->getValue->nsLocation->attributes->getValue->storeLocations->if->if->getEmptyAugs->return->decl->if->fCurrentCM->oneTransition->if->ctype->next->if->fCurrentCM->whatCanGoHere->size->expected->expectedStr->occurenceInfo->fCurrentCM->occurenceInfo->elemExpandedQname->if->minOccurs->maxOccurs->count->if->required->if->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->Integer->toString->reportSchemaError->else->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->reportSchemaError->else->if->new->ObjectArr->Integer->toString->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->occurenceInfo->fCurrentCM->occurenceInfo->if->maxOccurs->count->if->new->ObjectArr->fCurrentCM->getTermName->Integer->toString->reportSchemaError->else->new->ObjectArr->reportSchemaError->else->new->ObjectArr->reportSchemaError->if->ensureStackCapacity->wildcard->fBuffer->setLength->if->if->else->if->if->getEmptyAugs->return->if->if->checkElementMatchesRootElementDecl->else->if->processRootElementDeclQName->else->if->else->if->processRootTypeQName->if->if->sGrammar->findSchemaGrammar->if->sGrammar->getGlobalElementDecl->if->if->xsiType->if->attributes->getValue->if->if->if->if->fDocumentSource->setDocumentHandler->if->fDocumentHandler->setDocumentSource->return->if->getEmptyAugs->return->new->ObjectArr->reportError->else->if->new->ObjectArr->reportSchemaError->fXSIErrorReporter->pushContext->else->fXSIErrorReporter->pushContext->if->oldType->getAndCheckXsiType->if->if->else->if->fCurrentElemDecl->getConstraintType->else->if->fCurrentType->getTypeCategory->else->ctype->if->fCurrentElemDecl->getAbstract->new->ObjectArr->reportSchemaError->if->if->if->fCurrentType->getTypeCategory->ctype->if->ctype->getAbstract->new->ObjectArr->reportSchemaError->if->if->if->getVariety->else->try->getWhitespace->catch->finally->else->if->dv->if->dv->getVariety->else->try->dv->getWhitespace->catch->finally->if->fCurrentType->getTypeCategory->getContentModel->if->fCurrentCM->startContentModel->xsiNil->attributes->getValue->if->getXsiNil->attrGrp->if->fCurrentType->getTypeCategory->ctype->ctype->getAttrGrp->if->fValueStoreCache->startElement->fMatcherStack->pushContext->if->fValueStoreCache->initValueStoresFor->processAttributes->if->addDefaultAttributes->count->fMatcherStack->getMatcherCount->for->i->if->getEmptyAugs->return
XMLSchemaValidator#handleEndElement(QName, Augmentations)::: Handle end element:::if->println->if->if->else->if->XSConstraints->fullSchemaChecking->if->getEmptyAugs->return->processElementContent->if->oldCount->fMatcherStack->getMatcherCount->for->i->if->fMatcherStack->size->fMatcherStack->popContext->newCount->fMatcherStack->getMatcherCount->for->i->for->i->fValueStoreCache->endElement->if->grammars->if->invIdRefs->fValidationState->checkIDRefID->fValidationState->resetIDTables->if->while->invIdRefs->hasNext->new->ObjectArr->invIdRefs->next->reportSchemaError->if->XSConstraints->fullSchemaChecking->fGrammarBucket->getGrammars->if->for->k->fGrammarPool->cacheGrammars->endElementPSVI->else->endElementPSVI->return
XMLSchemaValidator#processElementContent(QName)::: If there is not text content, and there is a  {value constraint} on the corresponding element decl, then return  an XMLString representing the default value.:::if->strv->stringValue->bufLen->strv->length->if->new->charArr->strv->getChars->if->if->new->ObjectArr->reportSchemaError->reset->if->fCurrentElemDecl->getConstraintType->if->if->XSConstraints->stringValue->ElementDefaultValidImmediate->new->ObjectArr->fCurrentType->getName->stringValue->reportSchemaError->stringValue->elementLocallyValidType->else->actualValue->elementLocallyValidType->if->fCurrentElemDecl->getConstraintType->content->fBuffer->toString->if->new->ObjectArr->reportSchemaError->if->fCurrentType->getTypeCategory->ctype->if->if->equals->new->ObjectArr->reportSchemaError->else->if->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->else->if->fCurrentType->getTypeCategory->if->ValidatedInfo->isComparable->actualValue->equals->new->ObjectArr->stringValue->reportSchemaError->if->content->if->fBuffer->toString->bufLen->content->length->if->new->charArr->content->getChars->fDocumentHandler->characters
XMLSchemaValidator.XPathMatcherStack#clear():::Resets the XPath matcher stack.:::for->i->fContextStack->clear
XMLSchemaValidator.XPathMatcherStack#size():::Returns the size of the stack.:::return->fContextStack->size
XMLSchemaValidator.XPathMatcherStack#getMatcherCount():::Returns the count of XPath matchers.:::return
XMLSchemaValidator.XPathMatcherStack#addMatcher(XPathMatcher):::Adds a matcher.:::ensureMatcherCapacity
XMLSchemaValidator.XPathMatcherStack#getMatcherAt(int):::Returns the XPath matcher at the specified index.:::return
XMLSchemaValidator.XPathMatcherStack#pushContext():::Pushes a new context onto the stack.:::fContextStack->push
XMLSchemaValidator.XPathMatcherStack#popContext():::Pops a context off of the stack.:::fContextStack->pop
XMLSchemaValidator.ValueStoreBase#startValueScope():::Start scope for value store.:::for->i
XMLSchemaValidator.ValueStoreBase#endValueScope():::Ends scope for value store.:::if->if->fIdentityConstraint->getCategory->code->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError->return->if->if->fIdentityConstraint->getCategory->code->key->eName->fIdentityConstraint->getElementName->cName->key->getIdentityConstraintName->new->ObjectArr->reportSchemaError->return
XMLSchemaValidator.ValueStoreBase#endDocument():::Signals the end of the document:::
XMLSchemaValidator.ValueStoreBase#addValue(Field, boolean, Object, short, ShortList):::Adds the specified value to the value store.:::i->for->if->code->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->field->toString->reportSchemaError->return->if->code->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->field->toString->reportSchemaError->else->if->checkDuplicateValues->for
XMLSchemaValidator.ValueStoreBase#contains():::Returns true if this value store contains the locally scoped value stores:::next->size->fValues->size->for->i->return
XMLSchemaValidator.ValueStoreBase#contains(ValueStoreBase):::Returns -1 if this value store contains the specified values, otherwise the index of the first field in the key sequence.:::values->size1->values->size->if->for->i->else->size2->fValues->size->for->i->return
XMLSchemaValidator.ValueStoreBase#toString(Object[]):::Returns a string of the specified values.:::size->if->return->fTempBuffer->setLength->for->i->return->fTempBuffer->toString
XMLSchemaValidator.ValueStoreBase#toString(Vector, int, int):::Returns a string of the specified values.:::if->return->if->return->String->values->get->valueOf->str->new->StringBuilder->for->i->return->str->toString
XMLSchemaValidator.ValueStoreBase#toString():::Returns a string representation of this object.:::s->super->toString->index1->s->lastIndexOf->if->s->substring->index2->s->lastIndexOf->if->s->substring->return
XMLSchemaValidator.UniqueValueStore#checkDuplicateValues():::Called when a duplicate value is added.:::if->contains->code->value->toString->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError
XMLSchemaValidator.KeyValueStore#checkDuplicateValues():::Called when a duplicate value is added.:::if->contains->code->value->toString->eName->fIdentityConstraint->getElementName->cName->fIdentityConstraint->getIdentityConstraintName->new->ObjectArr->reportSchemaError
XMLSchemaValidator.KeyRefValueStore#endDocument():::End document.:::super->endDocument
XMLSchemaValidator.ValueStoreCache#startDocument():::Resets the identity constraint cache.:::fValueStores->clear->fIdentityConstraint2ValueStoreMap->clear->fGlobalIDConstraintMap->clear->fGlobalMapStack->removeAllElements
XMLSchemaValidator.ValueStoreCache#endElement():::endElement():  merges contents of fGlobalIDConstraintMap with the top of fGlobalMapStack into fGlobalIDConstraintMap.:::if->fGlobalMapStack->isEmpty->return->oldMap->fGlobalMapStack->pop->if->return->foreach->oldMap->entrySet->id->entry->getKey->oldVal->entry->getValue->if->currVal->fGlobalIDConstraintMap->get->if->fGlobalIDConstraintMap->put->else->if->currVal->append
XMLSchemaValidator.ValueStoreCache#initValueStoresFor(XSElementDecl, FieldActivator):::Initializes the value stores for the specified element declaration.:::icArray->icCount->for->i
XMLSchemaValidator.ValueStoreCache#getValueStoreFor(IdentityConstraint, int):::Returns the value store associated to the specified IdentityConstraint.:::return->fIdentityConstraint2ValueStoreMap->get
XMLSchemaValidator.ValueStoreCache#getGlobalValueStoreFor(IdentityConstraint):::Returns the global value store associated to the specified IdentityConstraint.:::return->fGlobalIDConstraintMap->get
XMLSchemaValidator.ValueStoreCache#endDocument():::Check identity constraints.:::foreach->valueStore->endDocument
XMLSchemaValidator.ValueStoreCache#toString():::Returns a string representation of this object.:::s->super->toString->index1->s->lastIndexOf->if->return->s->substring->index2->s->lastIndexOf->if->return->s->substring->return
XMLSchemaValidator.ShortVector#length():::Returns the length of the vector.:::return
XMLSchemaValidator.ShortVector#add(short):::Adds the value to the vector.:::ensureCapacity
XMLSchemaValidator.ShortVector#valueAt(int):::Returns the short value at the specified position in the vector.:::return
XMLSchemaValidator.ShortVector#clear():::Clears the vector.:::
XMLSchemaValidator.ShortVector#contains(short):::Returns whether the short is contained in the vector.:::for->i->return
XSAnnotationImpl#writeAnnotation(Object, short)::: Write contents of the annotation to the specified DOM object:::if->writeToDOM->return->else->if->writeToSAX->return->return
XSAnnotationImpl#getAnnotationString():::A text representation of annotation.:::return
XSAnnotationImpl#getType()::: The type of this object, i.e:::return
XSAnnotationImpl#getName():::The name of type NCName of this declaration as defined in XML Namespaces.:::return
XSAnnotationImpl#getNamespace()::: The [target namespace] of this object, or null if it is unspecified.:::return
XSAnnotationImpl#getNamespaceItem():::A namespace schema information item corresponding to the target namespace of the component, if it's globally declared; or null otherwise.:::return
XSAttributeDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeDecl#getTypeDefinition():::A simple type definition:::return
XSAttributeDecl#getScope():::Optional:::return
XSAttributeDecl#getEnclosingCTDefinition():::Locally scoped declarations are available for use only within the complex type definition identified by the scope property.:::return
XSAttributeDecl#getConstraintType():::Value constraint: one of default, fixed.:::return
XSAttributeDecl#getConstraintValue():::Value constraint: The actual value (with respect to the {type definition}) Should we return Object instead of DOMString?:::return->getConstraintType->fDefault->stringValue
XSAttributeDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSAttributeDecl#getAnnotations():::Optional:::return
XSAttributeGroupDecl#validRestrictionOf(String, XSAttributeGroupDecl):::Check that the attributes in this group validly restrict those from a base group:::errorArgs->attrUse->attrDecl->baseAttrUse->baseAttrDecl->for->i->for->i->if->if->new->ObjectArr->return->if->fAttributeWC->isSubsetOf->new->ObjectArr->return->if->fAttributeWC->weakerProcessContents->new->ObjectArr->fAttributeWC->getProcessContentsAsString->getProcessContentsAsString->return->return
XSAttributeGroupDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeGroupDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeGroupDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeGroupDecl#getAttributeUses():::{attribute uses} A set of attribute uses.:::if->new->XSObjectListImpl->return
XSAttributeGroupDecl#getAttributeWildcard():::{attribute wildcard} Optional:::return
XSAttributeGroupDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSAttributeGroupDecl#getAnnotations():::Optional:::return
XSAttributeUseImpl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSAttributeUseImpl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSAttributeUseImpl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSAttributeUseImpl#getRequired():::{required} determines whether this use of an attribute declaration requires an appropriate attribute information item to be present, or merely allows it.:::return
XSAttributeUseImpl#getAttrDeclaration():::{attribute declaration} provides the attribute declaration itself, which will in turn determine the simple type definition used.:::return
XSAttributeUseImpl#getConstraintType():::Value Constraint: one of default, fixed.:::return
XSAttributeUseImpl#getConstraintValue():::Value Constraint: The actual value (with respect to the {type definition}).:::return->getConstraintType->fDefault->stringValue
XSAttributeUseImpl#getAnnotations():::Optional:::return
XSComplexTypeDecl#isDOMDerivedFrom(String, String, int):::Checks if a type is derived from another given the the name, namespace and derivation method:::if->return->if->ancestorNS->equals->ancestorName->equals->return->if->if->isDerivedByRestriction->return->if->if->isDerivedByExtension->return->if->if->ancestorNS->equals->ancestorName->equals->if->fName->equals->fTargetNamespace->equals->if->return->isDOMDerivedFrom->else->if->return->isDOMDerivedFrom->if->return->isDerivedByAny->return
XSComplexTypeDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSComplexTypeDecl#getName():::The name of this XSObject depending on the XSObject type.:::return->getAnonymous
XSComplexTypeDecl#getAnonymous():::A boolean that specifies if the type definition is anonymous:::return
XSComplexTypeDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSComplexTypeDecl#getBaseType():::{base type definition} Either a simple type definition or a complex type definition.:::return
XSComplexTypeDecl#getDerivationMethod():::{derivation method} Either extension or restriction:::return
XSComplexTypeDecl#isFinal(short):::{final} For complex type definition it is a subset of {extension, restriction}:::return
XSComplexTypeDecl#getFinal():::{final} For complex type definition it is a subset of {extension, restriction}.:::return
XSComplexTypeDecl#getAbstract():::{abstract} A boolean:::return
XSComplexTypeDecl#getAttributeUses()::: {attribute uses} A set of attribute uses.:::return->fAttrGrp->getAttributeUses
XSComplexTypeDecl#getAttributeWildcard():::{attribute wildcard} Optional:::return->fAttrGrp->getAttributeWildcard
XSComplexTypeDecl#getContentType():::{content type} One of empty, a simple type definition (see simpleType, or mixed, element-only (see cmParticle).:::return
XSComplexTypeDecl#getSimpleType():::A simple type definition corresponding to simple content model, otherwise null:::return
XSComplexTypeDecl#getParticle():::A particle for mixed or element-only content model, otherwise null:::return
XSComplexTypeDecl#isProhibitedSubstitution(short):::{prohibited substitutions} A subset of {extension, restriction}.:::return
XSComplexTypeDecl#getProhibitedSubstitutions():::{prohibited substitutions}:::return
XSComplexTypeDecl#getAnnotations():::Optional:::return
XSConstraints#checkTypeDerivationOk(XSTypeDefinition, XSTypeDefinition, short):::check whether derived is valid derived from base, given a subset of {restriction, extension}.B:::if->return->if->return->if->derived->getTypeCategory->if->base->getTypeCategory->if->else->return->return->checkSimpleDerivation->else->return->checkComplexDerivation
XSConstraints#checkSimpleDerivationOk(XSSimpleType, XSTypeDefinition, short):::check whether simple type derived is valid derived from base, given a subset of {restriction, extension}.:::if->return->if->base->getTypeCategory->if->else->return->return->checkSimpleDerivation
XSConstraints#checkComplexDerivationOk(XSComplexTypeDecl, XSTypeDefinition, short):::check whether complex type derived is valid derived from base, given a subset of {restriction, extension}.:::if->return->return->checkComplexDerivation
XSConstraints#ElementDefaultValidImmediate(XSTypeDefinition, String, ValidationContext, ValidatedInfo):::check whether a value is a valid default for some type returns the compiled form of the value The parameter value could be either a String or a ValidatedInfo object:::dv->if->type->getTypeCategory->else->ctype->if->else->if->if->ctype->getParticle->emptiable->return->else->return->actualValue->if->try->dv->validate->if->dv->vinfo->stringValue->validate->catch->return->finally->return
XSConstraints#fullSchemaChecking(XSGrammarBucket, SubstitutionGroupHandler, CMBuilder, XMLErrorReporter):::used to check the 3 constraints against each complex type (should be each model group): Unique Particle Attribution, Particle Derivation (Restriction), Element Declrations Consistent.:::grammars->grammarBucket->getGrammars->for->i->fakeDerived->new->XSParticleDecl->fakeBase->new->XSParticleDecl->for->g->types->ctLocators->further->fullChecked->keepType->elemTable->new->SymbolHash->for->i->j
XSDDescription#getGrammarType():::the type of the grammar (e.g., DTD or XSD);:::return
XSDDescription#getContextType():::Get the context:::return
XSDDescription#getTargetNamespace():::If the context is "include" or "redefine", then return the target namespace of the enclosing schema document; otherwise, the expected target namespace of this document.:::return
XSDDescription#getLocationHints():::For import and references from the instance document, it's possible to have multiple hints for one namespace:::return
XSDDescription#getTriggeringComponent():::If a call is triggered by an element/attribute/xsi:type in the instance, this call returns the name of such triggering component: the name of the element/attribute, or the value of the xsi:type.:::return
XSDDescription#getEnclosingElementName():::If a call is triggered by an attribute or xsi:type, then this mehtod returns the enclosing element of such element.:::return
XSDDescription#getAttributes():::If a call is triggered by an element/attribute/xsi:type in the instance, this call returns all attribute of such element (or enclosing element).:::return
XSDDescription#equals(Object):::Compares this grammar with the given grammar:::if->return->desc->if->return->fNamespace->desc->getTargetNamespace->equals->else->return->desc->getTargetNamespace
XSDDescription#hashCode():::Returns the hash code of this grammar:::return->fNamespace->hashCode
XSDDescription#reset()::: resets all the fields:::super->clear
XSElementDecl#hashCode():::get the hash code:::code->fName->hashCode->if->fTargetNamespace->hashCode->return
XSElementDecl#equals(Object):::whether two decls are the same:::return
XSElementDecl#reset():::Reset current element declaration:::for->i
XSElementDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSElementDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSElementDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSElementDecl#getTypeDefinition():::Either a simple type definition or a complex type definition.:::return
XSElementDecl#getScope():::Optional:::return
XSElementDecl#getEnclosingCTDefinition():::Locally scoped declarations are available for use only within the complex type definition identified by the scope property.:::return
XSElementDecl#getConstraintType():::A value constraint: one of default, fixed.:::return
XSElementDecl#getConstraintValue():::A value constraint: The actual value (with respect to the {type definition}):::return->getConstraintType->fDefault->stringValue
XSElementDecl#getNillable():::If {nillable} is true, then an element may also be valid if it carries the namespace qualified attribute with [local name] nil from namespace http://www.w3.org/2001/XMLSchema-instance and value true (see xsi:nil (2.6.2)) even if it has no text or element content despite a {content type} which would otherwise require content.:::return
XSElementDecl#getIdentityConstraints():::{identity-constraint definitions} A set of constraint definitions.:::return->new->XSNamedMapImpl
XSElementDecl#getSubstitutionGroupAffiliation():::{substitution group affiliation} Optional:::return
XSElementDecl#isSubstitutionGroupExclusion(short):::Convenience method:::return
XSElementDecl#getSubstitutionGroupExclusions():::Specifies if this declaration can be nominated as the {substitution group affiliation} of other element declarations having the same {type definition} or types derived therefrom.:::return
XSElementDecl#isDisallowedSubstitution(short):::Convenience method:::return
XSElementDecl#getDisallowedSubstitutions():::The supplied values for {disallowed substitutions}:::return
XSElementDecl#getAbstract():::{abstract} A boolean.:::return
XSElementDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSElementDecl#getAnnotations():::Optional:::return
XSGrammarBucket#getGrammar(String):::Get the schema grammar for the specified namespace:::if->return->return->fGrammarRegistry->get
XSGrammarBucket#putGrammar(SchemaGrammar):::Put a schema grammar into the registry This method is for internal use only: it assumes that a grammar with the same target namespace is not already in the bucket.:::if->grammar->getTargetNamespace->else->fGrammarRegistry->grammar->getTargetNamespace->put
XSGrammarBucket#putGrammar(SchemaGrammar, boolean):::put a schema grammar and any grammars imported by it (directly or inderectly) into the registry:::sg->getGrammar->if->return->if->putGrammar->return->currGrammars->grammar->getImportedGrammars->if->putGrammar->return->grammars->currGrammars->clone->sg1->sg2->gs->for->i->grammars->size->putGrammar->for->i->grammars->size->return
XSGrammarBucket#putGrammar(SchemaGrammar, boolean, boolean):::put a schema grammar and any grammars imported by it (directly or inderectly) into the registry:::if->return->putGrammar->sg->getGrammar->if->putGrammar->if->return->currGrammars->grammar->getImportedGrammars->if->return->grammars->currGrammars->clone->sg1->sg2->gs->for->i->grammars->size->for->i->grammars->size->return
XSGrammarBucket#getGrammars():::get all grammars in the registry:::count->fGrammarRegistry->size->grammars->new->SchemaGrammarArr->i->foreach->fGrammarRegistry->entrySet->entry->getValue->if->return
XSGrammarBucket#reset():::Clear the registry:::fGrammarRegistry->clear
XSGroupDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSGroupDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSGroupDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSGroupDecl#getModelGroup():::{model group} A model group.:::return
XSGroupDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSGroupDecl#getAnnotations():::Optional:::return
XSImplementationImpl#getDOMImplementation():::NON-DOM: Obtain and return the single shared object:::return
XSImplementationImpl#hasFeature(String, String):::Test if the DOM implementation supports a specific "feature" -- currently meaning language and level thereof.:::return->feature->equalsIgnoreCase->version->equals->super->hasFeature
XSLoaderImpl#getConfig()::: The configuration of a document:::return
XSLoaderImpl#loadURIList(StringList):::Parses the content of XML Schema documents specified as the list of URI references:::length->uriList->getLength->try->fGrammarPool->clear->for->i->return->fGrammarPool->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#loadInputList(LSInputList)::: Parses the content of XML Schema documents specified as a list of LSInputs.:::length->is->getLength->try->fGrammarPool->clear->for->i->return->fGrammarPool->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#loadURI(String):::Parse an XML Schema document from a location identified by a URI reference:::try->fGrammarPool->clear->return->fSchemaLoader->new->XMLInputSource->loadGrammar->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSLoaderImpl#load(LSInput)::: Parse an XML Schema document from a resource identified by a LSInput .:::try->fGrammarPool->clear->return->fSchemaLoader->fSchemaLoader->dom2xmlInputSource->loadGrammar->toXSModel->catch->fSchemaLoader->reportDOMFatalError->return->finally
XSMessageFormatter#formatMessage(Locale, String, Object[]):::Formats a message with the specified arguments using the given locale information.:::if->if->SecuritySupport->getResourceBundle->if->SecuritySupport->getResourceBundle->msg->fResourceBundle->getString->if->try->format->catch->fResourceBundle->getString->fResourceBundle->getString->finally->if->fResourceBundle->getString->throw->new->MissingResourceException->return
XSModelGroupImpl#minEffectiveTotalRange():::3.8.6 Effective Total Range (all and sequence) and       Effective Total Range (choice) The following methods are used to return min/max range for a particle:::if->return->minEffectiveTotalRangeChoice->else->return->minEffectiveTotalRangeAllSeq
XSModelGroupImpl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSModelGroupImpl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSModelGroupImpl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSModelGroupImpl#getCompositor():::{compositor} One of all, choice or sequence:::if->return->else->if->return->else->return
XSModelGroupImpl#getParticles():::{particles} A list of particles:::return->new->XSObjectListImpl
XSModelGroupImpl#getAnnotation():::Optional:::return->fAnnotations->item
XSModelGroupImpl#getAnnotations():::Optional:::return
XSModelImpl#getNamespaces():::Convenience method:::return
XSModelImpl#getNamespaceItems():::A set of namespace schema information information items (of type XSNamespaceItem), one for each namespace name which appears as the target namespace of any schema component in the schema used for that assessment, and one for absent if any schema component in the schema had no target namespace:::return
XSModelImpl#getComponents(short):::Returns a list of top-level components, i.e:::if->return->tables->new->SymbolHashArr->if->for->i->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
XSModelImpl#getComponentsByNamespace(short, String):::Convenience method:::if->return->i->if->for->else->for->if->return->if->table->switch->break->break->break->break->break->break->break->if->new->XSNamedMap4Types->else->new->XSNamedMapImpl->return
XSModelImpl#getTypeDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getTypeDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalTypeDecl
XSModelImpl#getAttributeDeclaration(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getAttributeDeclaration(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalAttributeDecl
XSModelImpl#getElementDeclaration(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getElementDeclaration(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalElementDecl
XSModelImpl#getAttributeGroup(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getAttributeGroup(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalAttributeGroupDecl
XSModelImpl#getModelGroupDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getModelGroupDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getGlobalGroupDecl
XSModelImpl#getIDCDefinition(String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->get
XSModelImpl#getIDCDefinition(String, String, String):::Convenience method:::sg->fGrammarMap->null2EmptyString->get->if->return->return->sg->getIDConstraintDecl
XSModelImpl#getAnnotations()::: [annotations]: a set of annotations if it exists, otherwise an empty XSObjectList.:::if->return->totalAnnotations->for->i->if->return->annotations->new->XSAnnotationImplArr->currPos->for->i->new->XSObjectListImpl->return
XSModelImpl#hasIDConstraints():::REVISIT: to expose identity constraints from XSModel:::return
XSModelImpl#getSubstitutionGroup(XSElementDeclaration):::Convenience method:::return->fSubGroupMap->get
XSModelImpl#getLength():::The number of XSNamespaceItems in the list:::return
XSModelImpl#item(int):::Returns the indexth item in the collection or null if index is greater than or equal to the number of objects in the list:::if->return->return
XSNotationDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSNotationDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSNotationDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSNotationDecl#getSystemId():::Optional if {public identifier} is present:::return
XSNotationDecl#getPublicId():::Optional if {system identifier} is present:::return
XSNotationDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSNotationDecl#getAnnotations():::Optional:::return
XSParticleDecl#emptiable():::3.9.6 Schema Component Constraint: Particle Emptiable whether this particle is emptible:::return->minEffectiveTotalRange
XSParticleDecl#minEffectiveTotalRange():::3.8.6 Effective Total Range (all and sequence) and       Effective Total Range (choice) The following methods are used to return min/max range for a particle:::if->return->if->return->minEffectiveTotalRange->return
XSParticleDecl#appendParticle(StringBuffer):::append the string description of this particle to the string buffer this is for error message.:::switch->buffer->append->break->buffer->fValue->toString->append->break->buffer->append->buffer->fValue->toString->append->buffer->append->break->buffer->fValue->toString->append->break
XSParticleDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSParticleDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSParticleDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSParticleDecl#getMinOccurs():::{min occurs} determines the minimum number of terms that can occur.:::return
XSParticleDecl#getMaxOccursUnbounded():::{max occurs} whether the maxOccurs value is unbounded.:::return
XSParticleDecl#getMaxOccurs():::{max occurs} determines the maximum number of terms that can occur.:::return
XSParticleDecl#getTerm():::{term} One of a model group, a wildcard, or an element declaration.:::return
XSParticleDecl#getAnnotations():::Optional:::return
XSWildcardDecl#allowNamespace(String):::Validation Rule: Wildcard allows Namespace Name:::if->return->if->found->listNum->for->i->if->return->if->listNum->for->i->return
XSWildcardDecl#isSubsetOf(XSWildcardDecl)::: Schema Component Constraint: Wildcard Subset:::if->return->if->return->if->if->return->if->if->subset2sets->return->if->elementInSet->elementInSet->return->return
XSWildcardDecl#weakerProcessContents(XSWildcardDecl):::Check whether this wildcard has a weaker process contents than the super.:::return
XSWildcardDecl#performUnionWith(XSWildcardDecl, short):::Schema Component Constraint: Attribute Wildcard Union:::if->return->unionWildcard->new->XSWildcardDecl->if->areSame->else->if->else->if->union2sets->else->if->new->StringArr->else->if->other->list->if->else->foundAbsent->elementInSet->if->foundNS->elementInSet->if->else->if->new->StringArr->else->if->return->else->else->if->else->return
XSWildcardDecl#performIntersectionWith(XSWildcardDecl, short):::Schema Component Constraint: Attribute Wildcard Intersection:::if->return->intersectWildcard->new->XSWildcardDecl->if->areSame->else->if->other->if->else->if->list->other->if->else->listSize->intersect->new->StringArr->newSize->for->i->new->StringArr->System->arraycopy->else->if->intersect2sets->else->if->if->return->other->if->return
XSWildcardDecl#getType():::Get the type of the object, i.e ELEMENT_DECLARATION.:::return
XSWildcardDecl#getName():::The name of this XSObject depending on the XSObject type.:::return
XSWildcardDecl#getNamespace():::The namespace URI of this node, or null if it is unspecified:::return
XSWildcardDecl#getConstraintType():::Namespace constraint: A constraint type: any, not, list.:::return
XSWildcardDecl#getNsConstraintList():::Namespace constraint:::return->new->StringListImpl
XSWildcardDecl#getProcessContents():::{process contents} One of skip, lax or strict:::return
XSWildcardDecl#getProcessContentsAsString():::String valid of {process contents}:::switch->return->return->return->return
XSWildcardDecl#getAnnotation():::Optional:::return->fAnnotations->item
XSWildcardDecl#getAnnotations():::Optional:::return
