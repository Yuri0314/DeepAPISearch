AdobeMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::writeTag->id->ios->write->write2bytes->write2bytes->write2bytes->ios->write
COMMarkerSegment#getComment():::Returns the array encoded as a String, using ISO-Latin-1 encoding:::try->return->new->String->catch->finally->return
COMMarkerSegment#getNativeNode():::Returns an IIOMetadataNode containing the data array as a user object and a string encoded using ISO-8895-1, as an attribute.:::node->new->IIOMetadataNode->node->getComment->setAttribute->if->node->data->clone->setUserObject->return
COMMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format, directly from the data array.:::writeTag->ios->write
DHTMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
DQTMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
DQTMarkerSegment#getChromaForLuma(Qtable):::Assuming the given table was generated by scaling the "standard" visually lossless luminance table, extract the scale factor that was used.:::newGuy->allSame->for->i->if->luma->clone->else->largestPos->for->i->scaleFactor->getTable->jpegTable->getScaledInstance->new->Qtable->return
DRIMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
JFIFMarkerSegment#clone():::Returns a deep-copy clone of this object.:::newGuy->super->clone->if->extSegments->isEmpty->new->ArrayList<>->for->iter->extSegments->iterator->iter->hasNext->if->iccSegment->clone->return
JFIFMarkerSegment#addJFXX(JPEGBuffer, JPEGImageReader):::Add an JFXX extension marker segment from the stream wrapped in the JPEGBuffer to the list of extension segments.:::extSegments->new->JFIFExtensionMarkerSegment->add
JFIFMarkerSegment#addICC(JPEGBuffer):::Adds an ICC Profile APP2 segment from the stream wrapped in the JPEGBuffer.:::if->if->throw->new->IIOException->new->ICCMarkerSegment->if->else->if->tempICCSegment->addData
JFIFMarkerSegment#addICC(ICC_ColorSpace):::Add an ICC Profile APP2 segment by constructing it from the given ICC_ColorSpace object.:::if->throw->new->IIOException->new->ICCMarkerSegment
JFIFMarkerSegment#getNativeNode():::Returns a tree of DOM nodes representing this object and any subordinate JFXX extension or ICC Profile segments.:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->if->extSegments->isEmpty->JFXXnode->new->IIOMetadataNode->node->appendChild->for->iter->extSegments->iterator->iter->hasNext->if->node->iccSegment->getNativeNode->appendChild->return
JFIFMarkerSegment#updateFromNativeNode(Node, boolean):::Updates the data in this object from the given DOM Node tree:::attrs->node->getAttributes->if->attrs->getLength->value->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->if->node->hasChildNodes->children->node->getChildNodes->count->children->getLength->if->throw->new->IIOInvalidTreeException->for->i
JFIFMarkerSegment#write(ImageOutputStream, JPEGImageWriter):::Writes the data for this segment to the stream in valid JPEG format:::write
JFIFMarkerSegment#write(ImageOutputStream, BufferedImage, JPEGImageWriter):::Writes the data for this segment to the stream in valid JPEG format:::thumbWidth->thumbHeight->thumbLength->thumbData->if->thumb->getWidth->thumb->getHeight->if->writer->warningOccurred->Math->min->Math->min->thumb->getRaster->getPixels->writeTag->id->ios->write->ios->write->ios->write->ios->write->write2bytes->write2bytes->ios->write->ios->write->if->writer->thumbnailStarted->writeThumbnailData->writer->thumbnailComplete
JFIFMarkerSegment#writeWithThumbs(ImageOutputStream, List, JPEGImageWriter):::Write out this JFIF Marker Segment, including a thumbnail or appending a series of JFXX Marker Segments, as appropriate:::if->jfxx->if->thumbnails->size->if->extSegments->isEmpty->extSegments->get->thumbnails->get->writeThumb->else->write->for->i->thumbnails->size->else->write
JFIFMarkerSegment#writeDefaultJFIF(ImageOutputStream, List, ICC_Profile, JPEGImageWriter):::Writes out a default JFIF marker segment to the given output stream:::jfif->new->JFIFMarkerSegment->jfif->writeWithThumbs->if->writeICC
JFIFMarkerSegment#print():::Prints out the contents of this object to System.out for debugging.:::printTag->print->print->Integer->toString->println->print->println->print->println->print->println->print->println->print->println->if->extSegments->isEmpty->for->iter->extSegments->iterator->iter->hasNext->if->iccSegment->print
JFIFMarkerSegment#writeICC(ICC_Profile, ImageOutputStream):::Write out the given profile to the stream, embedded in the necessary number of APP2 segments, per the ICC spec:::LENGTH_LENGTH->ID->ID_LENGTH->ID->length->COUNTS_LENGTH->MAX_ICC_CHUNK_SIZE->data->profile->getData->numChunks->if->chunkNum->offset->for->i
JFIFMarkerSegment.ICCMarkerSegment#write(ImageOutputStream):::No-op:::
JPEG#isNonStandardICC(ColorSpace):::Returns true if the given ColorSpace object is an instance of ICC_ColorSpace but is not one of the standard ColorSpaces returned by ColorSpace.getInstance().:::retval->if->cs->isCS_sRGB->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->return
JPEG#isJFIFcompliant(ImageTypeSpecifier, boolean):::Returns true if the given imageType can be used in a JFIF file:::cm->imageType->getColorModel->if->cm->hasAlpha->return->numComponents->imageType->getNumComponents->if->return->if->return->if->if->cm->getColorSpace->getType->return->else->if->cm->getColorSpace->getType->return->return
JPEG#transformForType(ImageTypeSpecifier, boolean):::Given an image type, return the Adobe transform corresponding to that type, or ADOBE_IMPOSSIBLE if the image type is incompatible with an Adobe marker segment:::retval->cm->imageType->getColorModel->switch->cm->getColorSpace->getType->break->break->break->return
JPEG#convertToLinearQuality(float):::Converts an ImageWriteParam (i.e:::if->if->if->else->return
JPEG#getDefaultQTables():::Return an array of default, visually lossless quantization tables.:::qTables->new->JPEGQTableArr->return
JPEG#getDefaultHuffmanTables(boolean):::Return an array of default Huffman tables.:::tables->new->JPEGHuffmanTableArr->if->else->return
JPEGBuffer#loadBuf(int):::Ensures that there are at least count bytes available in the buffer, loading more data and moving any remaining bytes to the front:::if->print->print->println->if->if->return->else->if->return->if->System->arraycopy->ret->iis->read->if->println->if->minimum->Math->min->if->throw->new->IIOException
JPEGBuffer#readData(byte[]):::Fills the data array from the stream, starting with the buffer and then reading directly from the stream if necessary:::count->if->System->arraycopy->return->offset->if->System->arraycopy->if->iis->read->throw->new->IIOException
JPEGBuffer#skipData(int):::Skips count bytes, leaving the buffer in an appropriate state:::if->return->if->if->iis->skipBytes->throw->new->IIOException
JPEGBuffer#pushBack():::Push back the remaining contents of the buffer by repositioning the input stream.:::iis->iis->getStreamPosition->seek
JPEGBuffer#getStreamPosition():::Return the stream position corresponding to the next available byte in the buffer.:::return->iis->getStreamPosition
JPEGBuffer#scanForFF(JPEGImageReader):::Scan the buffer until the next 0xff byte, reloading the buffer as necessary:::retval->foundFF->while->while->if->break->loadBuf->if->while->if->return
JPEGBuffer#print(int):::Prints the contents of the buffer, in hex.:::print->print->println->if->for->ptr->println
JPEGImageReader#warningOccurred(int):::Called by the native code or other classes to signal a warning:::cbLock->lock->try->if->throw->new->InternalError->Integer->toString->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageReader#warningWithMessage(String):::The library has it's own error facility that emits warning messages:::cbLock->lock->try->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageWriter#warningOccurred(int):::Called by the native code or other classes to signal a warning:::cbLock->lock->try->if->throw->new->InternalError->Integer->toString->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageWriter#warningWithMessage(String):::The library has it's own error facility that emits warning messages:::cbLock->lock->try->processWarningOccurred->catch->finally->cbLock->unlock
JPEGMetadata#findMarkerSegment(int):::Returns the first MarkerSegment object in the list with the given tag, or null if none is found.:::iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->return->return
JPEGMetadata#findMarkerSegment(Class, boolean):::Returns the first or last MarkerSegment object in the list of the given class, or null if none is found.:::if->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->cls->isInstance->return->else->iter->markerSequence->markerSequence->size->listIterator->while->iter->hasPrevious->seg->iter->previous->if->cls->isInstance->return->return
JPEGMetadataFormat#isInSubtree(String, String):::Returns true if the named element occurs in the subtree of the format starting with the node named by subtreeName, including the node itself:::if->elementName->equals->return->children->getChildNames->for->i->return
MarkerSegment#clone():::Deep copy of data array.:::newGuy->try->super->clone->catch->finally->if->data->clone->return
MarkerSegment#loadData(JPEGBuffer):::We have determined that we don't know the type, so load the data using the length parameter.:::new->byteArr->buffer->readData
MarkerSegment#writeTag(ImageOutputStream):::Writes the marker, tag, and length:::ios->write->ios->write->write2bytes
MarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::writeTag->if->ios->write
SOFMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
SOSMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
