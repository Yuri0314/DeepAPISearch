AdobeMarkerSegment#getNativeNode()::: adobe marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->return
AdobeMarkerSegment#updateFromNativeNode(Node, boolean)::: adobe marker segment update from native node:::attrs->node->getAttributes->getAttributeValue->count->attrs->getLength->if->throw->new->IIOInvalidTreeException->if->value->getAttributeValue->getAttributeValue->getAttributeValue
AdobeMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::writeTag->id->ios->write->write2bytes->write2bytes->write2bytes->ios->write
AdobeMarkerSegment#writeAdobeSegment(ImageOutputStream, int)::: adobe marker segment write adobe segment:::new->AdobeMarkerSegment->write
AdobeMarkerSegment#print()::: adobe marker segment print:::printTag->print->println->print->Integer->toHexString->println->print->Integer->toHexString->println->print->println
COMMarkerSegment#getComment():::Returns the array encoded as a String, using ISO-Latin-1 encoding:::try->return->new->String->catch->finally->return
COMMarkerSegment#getNativeNode():::Returns an IIOMetadataNode containing the data array as a user object and a string encoded using ISO-8895-1, as an attribute.:::node->new->IIOMetadataNode->node->getComment->setAttribute->if->node->data->clone->setUserObject->return
COMMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format, directly from the data array.:::writeTag->ios->write
COMMarkerSegment#print()::: marker segment print:::printTag->getComment->println
DHTMarkerSegment#clone()::: marker segment clone:::newGuy->super->clone->tables->size->new->ArrayList<>->iter->tables->iterator->while->iter->hasNext->table->iter->next->table->clone->add->return
DHTMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->for->i->tables->size->return
DHTMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
DHTMarkerSegment#print()::: marker segment print:::printTag->Integer->tables->size->toString->println->for->i->tables->size->println
DHTMarkerSegment#getHtableFromNode(Node)::: marker segment get htable from node:::return->new->Htable
DHTMarkerSegment#addHtable(JPEGHuffmanTable, boolean, int)::: marker segment add htable:::tables->new->Htable->add
DHTMarkerSegment.Htable#clone()::: htable clone:::newGuy->try->super->clone->catch->finally->if->numCodes->clone->if->values->clone->return
DHTMarkerSegment.Htable#getNativeNode()::: htable get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->new->JPEGHuffmanTable->setUserObject->return
DHTMarkerSegment.Htable#print()::: htable print:::println->println->Integer->toString->println->new->JPEGHuffmanTable->toString
DQTMarkerSegment#clone()::: marker segment clone:::newGuy->super->clone->tables->size->new->ArrayList<>->iter->tables->iterator->while->iter->hasNext->table->iter->next->table->clone->add->return
DQTMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->for->i->tables->size->return
DQTMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
DQTMarkerSegment#print()::: marker segment print:::printTag->Integer->tables->size->toString->println->for->i->tables->size->println
DQTMarkerSegment#getChromaForLuma(Qtable):::Assuming the given table was generated by scaling the "standard" visually lossless luminance table, extract the scale factor that was used.:::newGuy->allSame->for->i->if->luma->clone->else->largestPos->for->i->scaleFactor->getTable->jpegTable->getScaledInstance->new->Qtable->return
DQTMarkerSegment#getQtableFromNode(Node)::: marker segment get qtable from node:::return->new->Qtable
DQTMarkerSegment.Qtable#clone()::: qtable clone:::newGuy->try->super->clone->catch->finally->if->data->clone->return
DQTMarkerSegment.Qtable#getNativeNode()::: qtable get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->new->JPEGQTable->setUserObject->return
DQTMarkerSegment.Qtable#print()::: qtable print:::Integer->toString->println->Integer->toString->println->new->JPEGQTable->toString
DRIMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->return
DRIMarkerSegment#updateFromNativeNode(Node, boolean)::: marker segment update from native node:::getAttributeValue
DRIMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
DRIMarkerSegment#print()::: marker segment print:::printTag->Integer->toString->println
JFIFMarkerSegment#clone():::Returns a deep-copy clone of this object.:::newGuy->super->clone->if->extSegments->isEmpty->new->ArrayList<>->for->iter->extSegments->iterator->iter->hasNext->if->iccSegment->clone->return
JFIFMarkerSegment#addJFXX(JPEGBuffer, JPEGImageReader):::Add an JFXX extension marker segment from the stream wrapped in the JPEGBuffer to the list of extension segments.:::extSegments->new->JFIFExtensionMarkerSegment->add
JFIFMarkerSegment#addICC(JPEGBuffer):::Adds an ICC Profile APP2 segment from the stream wrapped in the JPEGBuffer.:::if->if->throw->new->IIOException->new->ICCMarkerSegment->if->else->if->tempICCSegment->addData
JFIFMarkerSegment#addICC(ICC_ColorSpace):::Add an ICC Profile APP2 segment by constructing it from the given ICC_ColorSpace object.:::if->throw->new->IIOException->new->ICCMarkerSegment
JFIFMarkerSegment#getNativeNode():::Returns a tree of DOM nodes representing this object and any subordinate JFXX extension or ICC Profile segments.:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->if->extSegments->isEmpty->JFXXnode->new->IIOMetadataNode->node->appendChild->for->iter->extSegments->iterator->iter->hasNext->if->node->iccSegment->getNativeNode->appendChild->return
JFIFMarkerSegment#updateFromNativeNode(Node, boolean):::Updates the data in this object from the given DOM Node tree:::attrs->node->getAttributes->if->attrs->getLength->value->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->if->node->hasChildNodes->children->node->getChildNodes->count->children->getLength->if->throw->new->IIOInvalidTreeException->for->i
JFIFMarkerSegment#getThumbnailWidth(int)::: marker segment get thumbnail width:::if->if->return->thumb->getWidth->jfxx->extSegments->get->return->getWidth
JFIFMarkerSegment#getThumbnailHeight(int)::: marker segment get thumbnail height:::if->if->return->thumb->getHeight->jfxx->extSegments->get->return->getHeight
JFIFMarkerSegment#getThumbnail(ImageInputStream, int, JPEGImageReader)::: marker segment get thumbnail:::reader->thumbnailStarted->ret->if->thumb->getThumbnail->else->if->jfxx->extSegments->get->getThumbnail->reader->thumbnailComplete->return
JFIFMarkerSegment#write(ImageOutputStream, JPEGImageWriter):::Writes the data for this segment to the stream in valid JPEG format:::write
JFIFMarkerSegment#write(ImageOutputStream, BufferedImage, JPEGImageWriter):::Writes the data for this segment to the stream in valid JPEG format:::thumbWidth->thumbHeight->thumbLength->thumbData->if->thumb->getWidth->thumb->getHeight->if->writer->warningOccurred->Math->min->Math->min->thumb->getRaster->getPixels->writeTag->id->ios->write->ios->write->ios->write->ios->write->write2bytes->write2bytes->ios->write->ios->write->if->writer->thumbnailStarted->writeThumbnailData->writer->thumbnailComplete
JFIFMarkerSegment#writeThumbnailData(ImageOutputStream, int[], JPEGImageWriter)::: marker segment write thumbnail data:::progInterval->if->for->i
JFIFMarkerSegment#writeWithThumbs(ImageOutputStream, List, JPEGImageWriter):::Write out this JFIF Marker Segment, including a thumbnail or appending a series of JFXX Marker Segments, as appropriate:::if->jfxx->if->thumbnails->size->if->extSegments->isEmpty->extSegments->get->thumbnails->get->writeThumb->else->write->for->i->thumbnails->size->else->write
JFIFMarkerSegment#writeThumb(ImageOutputStream, BufferedImage, JFIFExtensionMarkerSegment, int, boolean, JPEGImageWriter)::: marker segment write thumb:::cm->thumb->getColorModel->cs->cm->getColorSpace->if->if->write->if->writeJFXXSegment->else->thumbRGB->thumb->getRaster->convertToIntDiscrete->jfxx->setThumbnail->writer->thumbnailStarted->jfxx->write->writer->thumbnailComplete->else->if->cs->getType->if->if->write->else->writeJFXXSegment->else->if->write->if->writeJFXXSegment->writer->warningOccurred->else->jfxx->setThumbnail->writer->thumbnailStarted->jfxx->write->writer->thumbnailComplete->else->if->cs->getType->if->if->thumbRGB->expandGrayThumb->write->else->writeJFXXSegment->else->if->write->if->thumbRGB->expandGrayThumb->writeJFXXSegment->else->if->jfxx->setThumbnail->writer->thumbnailStarted->jfxx->write->writer->thumbnailComplete->else->if->writeJFXXSegment->writer->warningOccurred->else->writer->warningOccurred
JFIFMarkerSegment#writeJFXXSegment(int, BufferedImage, ImageOutputStream, JPEGImageWriter):::Writes out a new JFXX extension segment, without saving it.:::jfxx->try->new->JFIFExtensionMarkerSegment->catch->writer->warningOccurred->return->finally->writer->thumbnailStarted->jfxx->write->writer->thumbnailComplete
JFIFMarkerSegment#expandGrayThumb(BufferedImage):::Return an RGB image that is the expansion of the given grayscale image.:::ret->thumb->getWidth->thumb->getHeight->new->BufferedImage->g->ret->getGraphics->g->drawImage->return
JFIFMarkerSegment#writeDefaultJFIF(ImageOutputStream, List, ICC_Profile, JPEGImageWriter):::Writes out a default JFIF marker segment to the given output stream:::jfif->new->JFIFMarkerSegment->jfif->writeWithThumbs->if->writeICC
JFIFMarkerSegment#print():::Prints out the contents of this object to System.out for debugging.:::printTag->print->print->Integer->toString->println->print->println->print->println->print->println->print->println->print->println->if->extSegments->isEmpty->for->iter->extSegments->iterator->iter->hasNext->if->iccSegment->print
JFIFMarkerSegment.JFIFExtensionMarkerSegment#setThumbnail(BufferedImage)::: extension marker segment set thumbnail:::try->switch->new->JFIFThumbPalette->break->new->JFIFThumbRGB->break->new->JFIFThumbJPEG->break->catch->throw->new->InternalError->finally
JFIFMarkerSegment.JFIFExtensionMarkerSegment#clone()::: extension marker segment clone:::newGuy->super->clone->if->thumb->clone->return
JFIFMarkerSegment.JFIFExtensionMarkerSegment#getNativeNode()::: extension marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->thumb->getNativeNode->appendChild->return
JFIFMarkerSegment.JFIFExtensionMarkerSegment#write(ImageOutputStream, JPEGImageWriter)::: extension marker segment write:::thumb->getLength->writeTag->id->ios->write->ios->write->thumb->write
JFIFMarkerSegment.JFIFExtensionMarkerSegment#print()::: extension marker segment print:::printTag->thumb->print
JFIFMarkerSegment.JFIFThumb#getLength()::: thumb get length:::
JFIFMarkerSegment.JFIFThumb#getWidth()::: thumb get width:::
JFIFMarkerSegment.JFIFThumb#getHeight()::: thumb get height:::
JFIFMarkerSegment.JFIFThumb#getThumbnail(ImageInputStream, JPEGImageReader)::: thumb get thumbnail:::
JFIFMarkerSegment.JFIFThumb#print()::: thumb print:::
JFIFMarkerSegment.JFIFThumb#getNativeNode()::: thumb get native node:::
JFIFMarkerSegment.JFIFThumb#write(ImageOutputStream, JPEGImageWriter)::: thumb write:::
JFIFMarkerSegment.JFIFThumb#clone()::: thumb clone:::try->return->super->clone->catch->finally->return
JFIFMarkerSegment.JFIFThumbUncompressed#readByteBuffer(ImageInputStream, byte[], JPEGImageReader, float, float)::: thumb uncompressed read byte buffer:::progInterval->Math->max->for->offset
JFIFMarkerSegment.JFIFThumbUncompressed#getWidth()::: thumb uncompressed get width:::return
JFIFMarkerSegment.JFIFThumbUncompressed#getHeight()::: thumb uncompressed get height:::return
JFIFMarkerSegment.JFIFThumbUncompressed#getNativeNode()::: thumb uncompressed get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->return
JFIFMarkerSegment.JFIFThumbUncompressed#write(ImageOutputStream, JPEGImageWriter)::: thumb uncompressed write:::if->writer->warningOccurred->Math->min->Math->min->ios->write->ios->write
JFIFMarkerSegment.JFIFThumbUncompressed#writePixels(ImageOutputStream, JPEGImageWriter)::: thumb uncompressed write pixels:::if->writer->warningOccurred->Math->min->Math->min->data->thumbnail->getRaster->getPixels->writeThumbnailData
JFIFMarkerSegment.JFIFThumbUncompressed#print()::: thumb uncompressed print:::print->println->print->println
JFIFMarkerSegment.JFIFThumbRGB#getLength()::: thumb b get length:::return
JFIFMarkerSegment.JFIFThumbRGB#getThumbnail(ImageInputStream, JPEGImageReader)::: thumb b get thumbnail:::iis->mark->iis->seek->buffer->getLength->new->DataBufferByte->buffer->getData->readByteBuffer->iis->reset->raster->Raster->new->intArr->createInterleavedRaster->cm->new->ComponentColorModel->return->new->BufferedImage
JFIFMarkerSegment.JFIFThumbRGB#write(ImageOutputStream, JPEGImageWriter)::: thumb b write:::super->write->writePixels
JFIFMarkerSegment.JFIFThumbPalette#getLength()::: thumb palette get length:::return
JFIFMarkerSegment.JFIFThumbPalette#getThumbnail(ImageInputStream, JPEGImageReader)::: thumb palette get thumbnail:::iis->mark->iis->seek->palette->new->byteArr->palettePart->getLength->readByteBuffer->buffer->new->DataBufferByte->buffer->getData->readByteBuffer->iis->read->iis->reset->cm->new->IndexColorModel->sm->cm->createCompatibleSampleModel->raster->Raster->createWritableRaster->return->new->BufferedImage
JFIFMarkerSegment.JFIFThumbPalette#write(ImageOutputStream, JPEGImageWriter)::: thumb palette write:::super->write->palette->new->byteArr->icm->thumbnail->getColorModel->reds->new->byteArr->greens->new->byteArr->blues->new->byteArr->icm->getReds->icm->getGreens->icm->getBlues->for->i->ios->write->writePixels
JFIFMarkerSegment.JFIFThumbJPEG#getWidth()::: thumb g get width:::retval->sof->thumbMetadata->findMarkerSegment->if->return
JFIFMarkerSegment.JFIFThumbJPEG#getHeight()::: thumb g get height:::retval->sof->thumbMetadata->findMarkerSegment->if->return
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#sequenceStarted(ImageReader, int)::: thumbnail read listener sequence started:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#sequenceComplete(ImageReader)::: thumbnail read listener sequence complete:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#imageStarted(ImageReader, int)::: thumbnail read listener image started:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#imageProgress(ImageReader, float)::: thumbnail read listener image progress:::reader->thumbnailProgress
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#imageComplete(ImageReader)::: thumbnail read listener image complete:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#thumbnailStarted(ImageReader, int, int)::: thumbnail read listener thumbnail started:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#thumbnailProgress(ImageReader, float)::: thumbnail read listener thumbnail progress:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#thumbnailComplete(ImageReader)::: thumbnail read listener thumbnail complete:::
JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener#readAborted(ImageReader)::: thumbnail read listener read aborted:::
JFIFMarkerSegment.JFIFThumbJPEG#getThumbnail(ImageInputStream, JPEGImageReader)::: thumb g get thumbnail:::iis->mark->iis->seek->thumbReader->new->JPEGImageReader->thumbReader->setInput->thumbReader->new->ThumbnailReadListener->addIIOReadProgressListener->ret->thumbReader->read->thumbReader->dispose->iis->reset->return
JFIFMarkerSegment.JFIFThumbJPEG#clone()::: thumb g clone:::newGuy->super->clone->if->thumbMetadata->clone->return
JFIFMarkerSegment.JFIFThumbJPEG#getNativeNode()::: thumb g get native node:::node->new->IIOMetadataNode->if->node->thumbMetadata->getNativeTree->appendChild->return
JFIFMarkerSegment.JFIFThumbJPEG#getLength()::: thumb g get length:::if->return->else->return
JFIFMarkerSegment.JFIFThumbJPEG#write(ImageOutputStream, JPEGImageWriter)::: thumb g write:::progInterval->if->for->offset
JFIFMarkerSegment.JFIFThumbJPEG#print()::: thumb g print:::println
JFIFMarkerSegment#writeICC(ICC_Profile, ImageOutputStream):::Write out the given profile to the stream, embedded in the necessary number of APP2 segments, per the ICC spec:::LENGTH_LENGTH->ID->ID_LENGTH->ID->length->COUNTS_LENGTH->MAX_ICC_CHUNK_SIZE->data->profile->getData->numChunks->if->chunkNum->offset->for->i
JFIFMarkerSegment.ICCMarkerSegment#clone()::: marker segment clone:::newGuy->super->clone->if->profile->clone->return
JFIFMarkerSegment.ICCMarkerSegment#addData(JPEGBuffer)::: marker segment add data:::if->println->dataLen->chunkNum->if->throw->new->IIOException->newNumChunks->if->throw->new->IIOException->if->println->retval->profileData->new->byteArr->buffer->readData->chunks->add->if->else->if->println->new->byteArr->index->for->i->return
JFIFMarkerSegment.ICCMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->if->node->ICC_Profile->getInstance->setUserObject->return
JFIFMarkerSegment.ICCMarkerSegment#write(ImageOutputStream):::No-op:::
JFIFMarkerSegment.ICCMarkerSegment#print()::: marker segment print:::printTag
JPEG#isNonStandardICC(ColorSpace):::Returns true if the given ColorSpace object is an instance of ICC_ColorSpace but is not one of the standard ColorSpaces returned by ColorSpace.getInstance().:::retval->if->cs->isCS_sRGB->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->cs->ColorSpace->getInstance->equals->return
JPEG#isJFIFcompliant(ImageTypeSpecifier, boolean):::Returns true if the given imageType can be used in a JFIF file:::cm->imageType->getColorModel->if->cm->hasAlpha->return->numComponents->imageType->getNumComponents->if->return->if->return->if->if->cm->getColorSpace->getType->return->else->if->cm->getColorSpace->getType->return->return
JPEG#transformForType(ImageTypeSpecifier, boolean):::Given an image type, return the Adobe transform corresponding to that type, or ADOBE_IMPOSSIBLE if the image type is incompatible with an Adobe marker segment:::retval->cm->imageType->getColorModel->switch->cm->getColorSpace->getType->break->break->break->return
JPEG#convertToLinearQuality(float):::Converts an ImageWriteParam (i.e:::if->if->if->else->return
JPEG#getDefaultQTables():::Return an array of default, visually lossless quantization tables.:::qTables->new->JPEGQTableArr->return
JPEG#getDefaultHuffmanTables(boolean):::Return an array of default Huffman tables.:::tables->new->JPEGHuffmanTableArr->if->else->return
JPEGBuffer#loadBuf(int):::Ensures that there are at least count bytes available in the buffer, loading more data and moving any remaining bytes to the front:::if->print->print->println->if->if->return->else->if->return->if->System->arraycopy->ret->iis->read->if->println->if->minimum->Math->min->if->throw->new->IIOException
JPEGBuffer#readData(byte[]):::Fills the data array from the stream, starting with the buffer and then reading directly from the stream if necessary:::count->if->System->arraycopy->return->offset->if->System->arraycopy->if->iis->read->throw->new->IIOException
JPEGBuffer#skipData(int):::Skips count bytes, leaving the buffer in an appropriate state:::if->return->if->if->iis->skipBytes->throw->new->IIOException
JPEGBuffer#pushBack():::Push back the remaining contents of the buffer by repositioning the input stream.:::iis->iis->getStreamPosition->seek
JPEGBuffer#getStreamPosition():::Return the stream position corresponding to the next available byte in the buffer.:::return->iis->getStreamPosition
JPEGBuffer#scanForFF(JPEGImageReader):::Scan the buffer until the next 0xff byte, reloading the buffer as necessary:::retval->foundFF->while->while->if->break->loadBuf->if->while->if->return
JPEGBuffer#print(int):::Prints the contents of the buffer, in hex.:::print->print->println->if->for->ptr->println
JPEGImageMetadataFormat#canNodeAppear(String, ImageTypeSpecifier)::: image metadata format can node appear:::if->elementName->getRootName->equals->elementName->equals->isInSubtree->return->if->isInSubtree->JPEG->isJFIFcompliant->return->return
JPEGImageMetadataFormat#getInstance()::: image metadata format get instance:::if->new->JPEGImageMetadataFormat->return
JPEGImageMetadataFormatResources#getContents()::: image metadata format resources get contents:::combinedContents->new->ObjectArrs->combined->for->i->for->i->return
JPEGImageReader#initReaderIDs(Class, Class, Class):::Sets up static C structures.:::
JPEGImageReader#initJPEGImageReader():::Sets up per-reader C structure and returns a pointer to it.:::
JPEGImageReader#warningOccurred(int):::Called by the native code or other classes to signal a warning:::cbLock->lock->try->if->throw->new->InternalError->Integer->toString->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageReader#warningWithMessage(String):::The library has it's own error facility that emits warning messages:::cbLock->lock->try->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageReader#setInput(Object, boolean, boolean)::: image reader set input:::setThreadLock->try->cbLock->check->super->setInput->resetInternalState->setSource->catch->finally->clearThreadLock
JPEGImageReader#readInputData(byte[], int, int):::This method is called from native code in order to fill native input buffer:::cbLock->lock->try->return->iis->read->catch->finally->cbLock->unlock
JPEGImageReader#skipInputBytes(long):::This method is called from the native code in order to skip requested number of bytes in the input stream.:::cbLock->lock->try->return->iis->skipBytes->catch->finally->cbLock->unlock
JPEGImageReader#setSource(long)::: image reader set source:::
JPEGImageReader#checkTablesOnly()::: image reader check tables only:::if->println->savePos->iis->getStreamPosition->if->println->iis->length->println->tablesOnly->readNativeHeader->if->if->println->pos->iis->getStreamPosition->println->if->iis->seek->new->JPEGMetadata->pos->iis->getStreamPosition->if->println->if->hasNextImage->imagePositions->iis->getStreamPosition->add->else->imagePositions->add->if->imagePositions->isEmpty->pos->imagePositions->imagePositions->size->get->iis->pos->longValue->flushBefore
JPEGImageReader#getNumImages(boolean)::: image reader get num images:::setThreadLock->try->cbLock->check->return->getNumImagesOnThread->catch->finally->clearThreadLock
JPEGImageReader#skipPastImage(int)::: image reader skip past image:::cbLock->lock->try->gotoImage->skipImage->catch->finally->cbLock->unlock
JPEGImageReader#getNumImagesOnThread(boolean)::: image reader get num images on thread:::if->return->if->throw->new->IllegalStateException->if->if->throw->new->IllegalStateException->if->checkTablesOnly->iis->mark->gotoImage->buffer->new->JPEGBuffer->buffer->loadBuf->done->while->buffer->scanForFF->switch->break->buffer->loadBuf->length->buffer->skipData->iis->reset->return->return
JPEGImageReader#gotoImage(int):::Sets the input stream to the start of the requested image:::if->throw->new->IllegalStateException->if->throw->new->IndexOutOfBoundsException->if->checkTablesOnly->if->imagePositions->isEmpty->throw->new->IIOException->if->imagePositions->size->iis->imagePositions->get->longValue->seek->else->pos->imagePositions->imagePositions->size->get->iis->pos->longValue->seek->skipImage->for->index->imagePositions->size->if
JPEGImageReader#skipImage():::Skip over a complete image in the stream, leaving the stream positioned such that the next byte to be read is the first byte of the next image:::if->println->initialFF->iis->read->if->soiMarker->iis->read->if->throw->new->IOException->else->throw->new->IOException->foundFF->IOOBE->markerLength->for->byteval->iis->read->iis->read->throw->new->IndexOutOfBoundsException
JPEGImageReader#hasNextImage():::Returns true if there is an image beyond the current stream position:::if->print->iis->mark->foundFF->for->byteval->iis->read->iis->read->iis->reset->if->println->return
JPEGImageReader#pushBack(int):::Push back the given number of bytes to the input stream:::if->println->cbLock->lock->try->iis->iis->getStreamPosition->seek->catch->finally->cbLock->unlock
JPEGImageReader#readHeader(int, boolean):::Reads header information for the given image, if possible.:::gotoImage->readNativeHeader
JPEGImageReader#readNativeHeader(boolean)::: image reader read native header:::retval->readImageHeader->return
JPEGImageReader#readImageHeader(long, boolean, boolean):::Read in the header information starting from the current stream position, returning true if the header was a tables-only image:::
JPEGImageReader#setImageData(int, int, int, int, int, byte[])::: image reader set image data:::if->return->newProfile->try->ICC_Profile->getInstance->catch->warningOccurred->return->finally->newData->newProfile->getData->oldProfile->if->getProfile->oldData->if->oldProfile->getData->if->equals->new->ICC_ColorSpace->try->colors->iccCS->new->floatArr->fromRGB->catch->cbLock->lock->try->warningOccurred->catch->finally->cbLock->unlock->finally
JPEGImageReader#getWidth(int)::: image reader get width:::setThreadLock->try->if->cbLock->check->readHeader->return->catch->finally->clearThreadLock
JPEGImageReader#getHeight(int)::: image reader get height:::setThreadLock->try->if->cbLock->check->readHeader->return->catch->finally->clearThreadLock
JPEGImageReader#getImageType(int):::Return an ImageTypeSpecifier corresponding to the given color space code, or null if the color space is unsupported.:::ret->if->ImageTypeProducer->getTypeProducer->return
JPEGImageReader#getRawImageType(int)::: image reader get raw image type:::setThreadLock->try->if->cbLock->check->readHeader->return->getImageType->getType->catch->finally->clearThreadLock
JPEGImageReader#getImageTypes(int)::: image reader get image types:::setThreadLock->try->return->getImageTypesOnThread->catch->finally->clearThreadLock
JPEGImageReader#getImageTypesOnThread(int)::: image reader get image types on thread:::if->cbLock->check->readHeader->raw->getImageType->list->new->ArrayList<ImageTypeProducer>->switch->list->add->list->getImageType->add->break->list->add->list->getImageType->add->break->list->getImageType->add->if->list->new->ImageTypeProducer->add->list->getImageType->add->break->return->list->iterator->new->ImageTypeIterator
JPEGImageReader#checkColorConversion(BufferedImage, ImageReadParam):::Checks the implied color conversion between the stream and the target image, altering the IJG output color space if necessary:::if->if->param->getSourceBands->param->getDestinationBands->return->cm->image->getColorModel->if->throw->new->IIOException->cs->cm->getColorSpace->csType->cs->getType->switch->if->setOutColorSpace->else->if->throw->new->IIOException->break->if->if->setOutColorSpace->else->if->cm->getNumComponents->new->ColorConvertOp->else->if->cs->isCS_sRGB->cm->getNumComponents->new->ColorConvertOp->else->if->throw->new->IIOException->break->throw->new->IIOException
JPEGImageReader#setOutColorSpace(long, int):::Set the IJG output space to the given value:::
JPEGImageReader#getDefaultReadParam()::: image reader get default read param:::return->new->JPEGImageReadParam
JPEGImageReader#getStreamMetadata()::: image reader get stream metadata:::setThreadLock->try->if->cbLock->check->checkTablesOnly->return->catch->finally->clearThreadLock
JPEGImageReader#getImageMetadata(int)::: image reader get image metadata:::setThreadLock->try->if->return->cbLock->check->gotoImage->new->JPEGMetadata->return->catch->finally->clearThreadLock
JPEGImageReader#read(int, ImageReadParam)::: image reader read:::setThreadLock->try->cbLock->check->try->readInternal->catch->resetLibraryState->throw->resetLibraryState->throw->finally->ret->return->catch->finally->clearThreadLock
JPEGImageReader#readInternal(int, ImageReadParam, boolean)::: image reader read internal:::readHeader->imRas->numImageBands->if->imageTypes->getImageTypes->if->imageTypes->hasNext->throw->new->IIOException->getDestination->image->getRaster->image->getSampleModel->getNumBands->checkColorConversion->checkReadParamBandSettings->else->setOutColorSpace->srcBands->numRasterBands->srcROI->new->Rectangle->new->Rectangle->computeRegions->periodX->periodY->if->param->getSourceXSubsampling->param->getSourceYSubsampling->sBands->param->getSourceBands->if->if->param->getDestinationBands->param->getSourceMinProgressivePass->param->getSourceMaxProgressivePass->if->jparam->if->jparam->areTablesSet->jparam->getQTables->jparam->getDCHuffmanTables->jparam->getACHuffmanTables->lineSize->new->DataBufferByte->bandOffs->Raster->createInterleavedRaster->if->Raster->createInterleavedRaster->else->bandSizes->target->getSampleModel->getSampleSize->for->i->callbackUpdates->initProgressData->if->for->iter->iterator->iter->hasNext->Math->target->getHeight->max->if->else->if->if->println->println->print->for->i->println->println->if->for->i->println->println->println->println->println->println->println->println->clearNativeReadAbortFlag->processImageStarted->aborted->buffer->getData->readImage->if->processReadAborted->else->processImageComplete->return
JPEGImageReader#acceptPixels(int, boolean):::This method is called back from C when the intermediate Raster is full:::if->convert->filter->target->setRect->cbLock->lock->try->raster->getWidth->processImageUpdate->if->height->target->getHeight->percentOfPass->if->if->processImageProgress->else->if->processImageProgress->else->remainingPasses->Math->max->totalPasses->Math->max->if->if->print->print->print->print->print->print->print->print->processImageProgress->else->processImageProgress->catch->finally->cbLock->unlock
JPEGImageReader#initProgressData()::: image reader init progress data:::
JPEGImageReader#passStarted(int)::: image reader pass started:::cbLock->lock->try->processPassStarted->catch->finally->cbLock->unlock
JPEGImageReader#passComplete()::: image reader pass complete:::cbLock->lock->try->processPassComplete->catch->finally->cbLock->unlock
JPEGImageReader#thumbnailStarted(int)::: image reader thumbnail started:::cbLock->lock->try->processThumbnailStarted->catch->finally->cbLock->unlock
JPEGImageReader#thumbnailProgress(float)::: image reader thumbnail progress:::cbLock->lock->try->processThumbnailProgress->catch->finally->cbLock->unlock
JPEGImageReader#thumbnailComplete()::: image reader thumbnail complete:::cbLock->lock->try->processThumbnailComplete->catch->finally->cbLock->unlock
JPEGImageReader#readImage(int, long, byte[], int, int[], int[], int, int, int, int, int, int, JPEGQTable[], JPEGHuffmanTable[], JPEGHuffmanTable[], int, int, boolean):::Returns true if the read was aborted.:::
JPEGImageReader#clearNativeReadAbortFlag(long)::: image reader clear native read abort flag:::
JPEGImageReader#abort()::: image reader abort:::setThreadLock->try->super->abort->abortRead->catch->finally->clearThreadLock
JPEGImageReader#abortRead(long):::Set the C level abort flag:::
JPEGImageReader#resetLibraryState(long):::Resets library state when an exception occurred during a read.:::
JPEGImageReader#canReadRaster()::: image reader can read raster:::return
JPEGImageReader#readRaster(int, ImageReadParam)::: image reader read raster:::setThreadLock->retval->try->cbLock->check->saveDestOffset->if->param->getDestinationOffset->param->new->Point->setDestinationOffset->readInternal->if->target->createWritableTranslatedChild->catch->resetLibraryState->throw->resetLibraryState->throw->finally->clearThreadLock->return
JPEGImageReader#readerSupportsThumbnails()::: image reader reader supports thumbnails:::return
JPEGImageReader#getNumThumbnails(int)::: image reader get num thumbnails:::setThreadLock->try->cbLock->check->getImageMetadata->jfif->imageMetadata->findMarkerSegment->retval->if->size->return->catch->finally->clearThreadLock
JPEGImageReader#getThumbnailWidth(int, int)::: image reader get thumbnail width:::setThreadLock->try->cbLock->check->if->getNumThumbnails->throw->new->IndexOutOfBoundsException->jfif->imageMetadata->findMarkerSegment->return->jfif->getThumbnailWidth->catch->finally->clearThreadLock
JPEGImageReader#getThumbnailHeight(int, int)::: image reader get thumbnail height:::setThreadLock->try->cbLock->check->if->getNumThumbnails->throw->new->IndexOutOfBoundsException->jfif->imageMetadata->findMarkerSegment->return->jfif->getThumbnailHeight->catch->finally->clearThreadLock
JPEGImageReader#readThumbnail(int, int)::: image reader read thumbnail:::setThreadLock->try->cbLock->check->if->getNumThumbnails->throw->new->IndexOutOfBoundsException->jfif->imageMetadata->findMarkerSegment->return->jfif->getThumbnail->catch->finally->clearThreadLock
JPEGImageReader#resetInternalState()::: image reader reset internal state:::resetReader->new->ArrayList<>->initProgressData
JPEGImageReader#reset()::: image reader reset:::setThreadLock->try->cbLock->check->super->reset->catch->finally->clearThreadLock
JPEGImageReader#resetReader(long)::: image reader reset reader:::
JPEGImageReader#dispose()::: image reader dispose:::setThreadLock->try->cbLock->check->if->disposerRecord->dispose->catch->finally->clearThreadLock
JPEGImageReader#disposeReader(long)::: image reader dispose reader:::
JPEGImageReader.JPEGReaderDisposerRecord#dispose()::: reader disposer record dispose:::if->disposeReader
JPEGImageReader#setThreadLock()::: image reader set thread lock:::currThread->Thread->currentThread->if->if->throw->new->IllegalStateException->else->else
JPEGImageReader#clearThreadLock()::: image reader clear thread lock:::currThread->Thread->currentThread->if->throw->new->IllegalStateException->if
JPEGImageReader.CallBackLock#check()::: call back lock check:::if->throw->new->IllegalStateException
JPEGImageReader.CallBackLock#lock()::: call back lock lock:::
JPEGImageReader.CallBackLock#unlock()::: call back lock unlock:::
ImageTypeIterator#hasNext()::: image type iterator has next:::if->return->if->producers->hasNext->return->do->producers->next->getType->while->producers->hasNext->return
ImageTypeIterator#next()::: image type iterator next:::if->hasNext->t->return->else->throw->new->NoSuchElementException
ImageTypeIterator#remove()::: image type iterator remove:::producers->remove
ImageTypeProducer#getType()::: image type producer get type:::if->try->produce->catch->finally->return
ImageTypeProducer#getTypeProducer(int)::: image type producer get type producer:::if->return->if->new->ImageTypeProducer->return
ImageTypeProducer#produce()::: image type producer produce:::switch->return->ImageTypeSpecifier->createFromBufferedImageType->return->ImageTypeSpecifier->createInterleaved->return
JPEGImageReaderResources#getContents()::: image reader resources get contents:::return->new->ObjectArrs->Integer->toString->Integer->toString->Integer->toString
JPEGImageReaderSpi#getDescription(Locale)::: image reader spi get description:::return
JPEGImageReaderSpi#canDecodeInput(Object)::: image reader spi can decode input:::if->return->iis->iis->mark->byte1->iis->read->byte2->iis->read->iis->reset->if->return->return
JPEGImageReaderSpi#createReaderInstance(Object)::: image reader spi create reader instance:::return->new->JPEGImageReader
JPEGImageWriter#setOutput(Object)::: image writer set output:::setThreadLock->try->cbLock->check->super->setOutput->resetInternalState->setDest->catch->finally->clearThreadLock
JPEGImageWriter#getDefaultWriteParam()::: image writer get default write param:::return->new->JPEGImageWriteParam
JPEGImageWriter#getDefaultStreamMetadata(ImageWriteParam)::: image writer get default stream metadata:::setThreadLock->try->return->new->JPEGMetadata->catch->finally->clearThreadLock
JPEGImageWriter#getDefaultImageMetadata(ImageTypeSpecifier, ImageWriteParam)::: image writer get default image metadata:::setThreadLock->try->return->new->JPEGMetadata->catch->finally->clearThreadLock
JPEGImageWriter#convertStreamMetadata(IIOMetadata, ImageWriteParam)::: image writer convert stream metadata:::if->jpegData->if->return->return
JPEGImageWriter#convertImageMetadata(IIOMetadata, ImageTypeSpecifier, ImageWriteParam)::: image writer convert image metadata:::setThreadLock->try->return->convertImageMetadataOnThread->catch->finally->clearThreadLock
JPEGImageWriter#convertImageMetadataOnThread(IIOMetadata, ImageTypeSpecifier, ImageWriteParam)::: image writer convert image metadata on thread:::if->jpegData->if->return->else->return->if->inData->isStandardMetadataFormatSupported->formatName->tree->inData->getAsTree->if->jpegData->new->JPEGMetadata->try->jpegData->setFromTree->catch->return->finally->return->return
JPEGImageWriter#getNumThumbnailsSupported(ImageTypeSpecifier, ImageWriteParam, IIOMetadata, IIOMetadata)::: image writer get num thumbnails supported:::if->return->if->jfifOK->return->return
JPEGImageWriter#getPreferredThumbnailSizes(ImageTypeSpecifier, ImageWriteParam, IIOMetadata, IIOMetadata)::: image writer get preferred thumbnail sizes:::if->jfifOK->return->preferredThumbSizes->clone->return
JPEGImageWriter#jfifOK(ImageTypeSpecifier, ImageWriteParam, IIOMetadata, IIOMetadata)::: image writer jfif k:::if->JPEG->isJFIFcompliant->return->if->metadata->if->else->convertImageMetadata->if->metadata->findMarkerSegment->return->return
JPEGImageWriter#canWriteRasters()::: image writer can write rasters:::return
JPEGImageWriter#write(IIOMetadata, IIOImage, ImageWriteParam)::: image writer write:::setThreadLock->try->cbLock->check->writeOnThread->catch->finally->clearThreadLock
JPEGImageWriter#writeOnThread(IIOMetadata, IIOImage, ImageWriteParam)::: image writer write on thread:::if->throw->new->IllegalStateException->if->throw->new->IllegalArgumentException->if->warningOccurred->rasterOnly->image->hasRaster->rimage->if->image->getRaster->else->image->getRenderedImage->if->getRaster->else->if->rimage->getNumXTiles->rimage->getNumYTiles->rimage->rimage->getMinTileX->rimage->getMinTileY->getTile->if->srcRas->getWidth->rimage->getWidth->srcRas->getHeight->rimage->getHeight->srcRas->srcRas->getMinX->srcRas->getMinY->rimage->getWidth->rimage->getHeight->srcRas->getMinX->srcRas->getMinY->createChild->else->rimage->getData->numSrcBands->srcRas->getNumBands->cm->cs->if->rimage->getColorModel->if->cm->getColorSpace->if->cm->getNumComponents->if->cm->isAlphaPremultiplied->numBandsUsed->if->sBands->param->getSourceBands->if->if->warningOccurred->else->if->throw->new->IIOException->usingBandSubset->fullImage->bandSizes->if->srcRas->getSampleModel->getSampleSize->if->temp->new->intArr->for->i->else->tempSize->srcRas->getSampleModel->getSampleSize->new->intArr->for->i->for->i->if->println->println->println->println->print->for->i->println->destType->if->param->getDestinationType->if->warningOccurred->srcRas->getMinX->srcRas->getMinY->imageWidth->srcRas->getWidth->imageHeight->srcRas->getHeight->periodX->periodY->gridX->gridY->qTables->DCHuffmanTables->ACHuffmanTables->optimizeHuffman->jparam->progressiveMode->if->sourceRegion->param->getSourceRegion->if->imageBounds->new->Rectangle->sourceRegion->intersection->if->if->param->getSourceXSubsampling->param->getSourceYSubsampling->param->getSubsamplingXOffset->param->getSubsamplingYOffset->switch->param->getCompressionMode->throw->new->IIOException->quality->param->getCompressionQuality->JPEG->convertToLinearQuality->new->JPEGQTableArr->getScaledInstance->getScaledInstance->break->new->JPEGQTableArr->break->param->getProgressiveMode->if->jparam->getOptimizeHuffmanTables->mdata->image->getMetadata->if->if->if->println->else->if->type->if->new->ImageTypeSpecifier->convertImageMetadata->else->warningOccurred->inCsType->outCsType->jfif->adobe->sof->if->metadata->findMarkerSegment->metadata->findMarkerSegment->metadata->findMarkerSegment->if->if->destType->getNumBands->throw->new->IIOException->destType->getColorModel->getColorSpace->if->checkSOFBands->checkJFIF->if->if->JPEG->isNonStandardICC->getProfile->checkAdobe->else->if->JPEG->isJFIFcompliant->if->JPEG->isNonStandardICC->getProfile->else->transform->JPEG->transformForType->if->new->JPEGMetadata->getSrcCSType->getDefaultDestCSType->else->if->if->new->ImageTypeSpecifier->new->JPEGMetadata->if->metadata->findMarkerSegment->rimage->getColorModel->getColorSpace->if->JPEG->isNonStandardICC->getProfile->getSrcCSType->getDefaultDestCSType->else->checkSOFBands->if->inputType->new->ImageTypeSpecifier->getSrcCSType->if->alpha->cm->hasAlpha->switch->cs->getType->if->else->if->warningOccurred->if->warningOccurred->break->if->if->JPEG->isNonStandardICC->getProfile->else->if->switch->break->break->warningOccurred->break->else->outCS->sof->getIDencodedCSType->if->else->subsampled->isSubsampled->if->else->break->metadataProgressive->scans->if->if->metadata->findMarkerSegment->if->if->collectScans->else->if->metadata->findMarkerSegment->image->getThumbnails->numThumbs->image->getNumThumbnails->if->if->if->warningOccurred->else->if->if->if->warningOccurred->else->if->if->if->warningOccurred->else->if->warningOccurred->haveMetadata->writeDQT->writeDHT->dqt->dht->restartInterval->if->metadata->findMarkerSegment->metadata->findMarkerSegment->dri->metadata->findMarkerSegment->if->if->if->if->if->collectQTablesFromMetadata->else->if->else->if->jparam->areTablesSet->jparam->getQTables->else->JPEG->getDefaultQTables->if->if->collectHTablesFromMetadata->collectHTablesFromMetadata->else->if->else->if->jparam->areTablesSet->jparam->getDCHuffmanTables->jparam->getACHuffmanTables->else->JPEG->getDefaultHuffmanTables->JPEG->getDefaultHuffmanTables->componentIds->new->intArr->HsamplingFactors->new->intArr->VsamplingFactors->new->intArr->QtableSelectors->new->intArr->for->i->if->for->i->destWidth->destHeight->lineSize->buffer->new->DataBufferByte->bandOffs->Raster->createInterleavedRaster->clearAbortRequest->cbLock->lock->try->processImageStarted->catch->finally->cbLock->unlock->aborted->if->println->println->buffer->getData->writeImage->cbLock->lock->try->if->processWriteAborted->else->processImageComplete->ios->flush->catch->finally->cbLock->unlock
JPEGImageWriter#canWriteSequence()::: image writer can write sequence:::return
JPEGImageWriter#prepareWriteSequence(IIOMetadata)::: image writer prepare write sequence:::setThreadLock->try->cbLock->check->prepareWriteSequenceOnThread->catch->finally->clearThreadLock
JPEGImageWriter#prepareWriteSequenceOnThread(IIOMetadata)::: image writer prepare write sequence on thread:::if->throw->new->IllegalStateException->if->if->jmeta->if->throw->new->IllegalArgumentException->if->throw->new->IIOException->if->throw->new->IIOException->collectQTablesFromMetadata->if->println->if->JPEG->getDefaultQTables->collectHTablesFromMetadata->if->JPEG->getDefaultHuffmanTables->collectHTablesFromMetadata->if->JPEG->getDefaultHuffmanTables->writeTables->else->throw->new->IIOException
JPEGImageWriter#writeToSequence(IIOImage, ImageWriteParam)::: image writer write to sequence:::setThreadLock->try->cbLock->check->if->throw->new->IllegalStateException->write->catch->finally->clearThreadLock
JPEGImageWriter#endWriteSequence()::: image writer end write sequence:::setThreadLock->try->cbLock->check->if->throw->new->IllegalStateException->catch->finally->clearThreadLock
JPEGImageWriter#abort()::: image writer abort:::setThreadLock->try->super->abort->abortWrite->catch->finally->clearThreadLock
JPEGImageWriter#clearAbortRequest()::: image writer clear abort request:::setThreadLock->try->cbLock->check->if->abortRequested->super->clearAbortRequest->resetWriter->setDest->catch->finally->clearThreadLock
JPEGImageWriter#resetInternalState()::: image writer reset internal state:::resetWriter
JPEGImageWriter#reset()::: image writer reset:::setThreadLock->try->cbLock->check->super->reset->catch->finally->clearThreadLock
JPEGImageWriter#dispose()::: image writer dispose:::setThreadLock->try->cbLock->check->if->disposerRecord->dispose->catch->finally->clearThreadLock
JPEGImageWriter#warningOccurred(int):::Called by the native code or other classes to signal a warning:::cbLock->lock->try->if->throw->new->InternalError->Integer->toString->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageWriter#warningWithMessage(String):::The library has it's own error facility that emits warning messages:::cbLock->lock->try->processWarningOccurred->catch->finally->cbLock->unlock
JPEGImageWriter#thumbnailStarted(int)::: image writer thumbnail started:::cbLock->lock->try->processThumbnailStarted->catch->finally->cbLock->unlock
JPEGImageWriter#thumbnailProgress(float)::: image writer thumbnail progress:::cbLock->lock->try->processThumbnailProgress->catch->finally->cbLock->unlock
JPEGImageWriter#thumbnailComplete()::: image writer thumbnail complete:::cbLock->lock->try->processThumbnailComplete->catch->finally->cbLock->unlock
JPEGImageWriter#checkSOFBands(SOFMarkerSegment, int)::: image writer check bands:::if->if->throw->new->IIOException
JPEGImageWriter#checkJFIF(JFIFMarkerSegment, ImageTypeSpecifier, boolean)::: image writer check f:::if->if->JPEG->isJFIFcompliant->warningOccurred
JPEGImageWriter#checkAdobe(AdobeMarkerSegment, ImageTypeSpecifier, boolean)::: image writer check adobe:::if->rightTransform->JPEG->transformForType->if->warningOccurred->if->else
JPEGImageWriter#collectScans(JPEGMetadata, SOFMarkerSegment):::Collect all the scan info from the given metadata, and organize it into the scan info array required by the IJG libray:::segments->new->ArrayList<>->SCAN_SIZE->MAX_COMPS_PER_SCAN->for->iter->iterator->iter->hasNext->retval->if->segments->isEmpty->segments->size->new->intArr->index->for->i->return
JPEGImageWriter#collectQTablesFromMetadata(JPEGMetadata):::Finds all DQT marker segments and returns all the q tables as a single array of JPEGQTables.:::tables->new->ArrayList<>->iter->iterator->while->iter->hasNext->seg->iter->next->if->dqt->tables->addAll->retval->if->tables->size->tables->size->new->JPEGQTableArr->for->i->return
JPEGImageWriter#collectHTablesFromMetadata(JPEGMetadata, boolean):::Finds all DHT marker segments and returns all the q tables as a single array of JPEGQTables:::tables->new->ArrayList<>->iter->iterator->while->iter->hasNext->seg->iter->next->if->dht->for->i->size->retval->if->tables->size->htables->tables->size->new->DHTMarkerSegment.HtableArr->tables->toArray->tables->size->new->JPEGHuffmanTableArr->for->i->return
JPEGImageWriter#getSrcCSType(ImageTypeSpecifier)::: image writer get src type:::return->type->getColorModel->getSrcCSType
JPEGImageWriter#getSrcCSType(RenderedImage)::: image writer get src type:::return->rimage->getColorModel->getSrcCSType
JPEGImageWriter#getSrcCSType(ColorModel)::: image writer get src type:::retval->if->alpha->cm->hasAlpha->cs->cm->getColorSpace->switch->cs->getType->break->break->break->break->return
JPEGImageWriter#getDestCSType(ImageTypeSpecifier)::: image writer get dest type:::cm->destType->getColorModel->alpha->cm->hasAlpha->cs->cm->getColorSpace->retval->switch->cs->getType->break->break->break->break->return
JPEGImageWriter#getDefaultDestCSType(ImageTypeSpecifier)::: image writer get default dest type:::return->type->getColorModel->getDefaultDestCSType
JPEGImageWriter#getDefaultDestCSType(RenderedImage)::: image writer get default dest type:::return->rimage->getColorModel->getDefaultDestCSType
JPEGImageWriter#getDefaultDestCSType(ColorModel)::: image writer get default dest type:::retval->if->alpha->cm->hasAlpha->cs->cm->getColorSpace->switch->cs->getType->break->break->break->break->return
JPEGImageWriter#isSubsampled(SOFMarkerSegment.ComponentSpec[])::: image writer is subsampled:::hsamp0->vsamp0->for->i->return
JPEGImageWriter#initWriterIDs(Class, Class):::Sets up static native structures.:::
JPEGImageWriter#initJPEGImageWriter():::Sets up per-writer native structure and returns a pointer to it.:::
JPEGImageWriter#setDest(long):::Sets up native structures for output stream:::
JPEGImageWriter#writeImage(long, byte[], int, int, int, int[], int, int, int, int, int, JPEGQTable[], boolean, JPEGHuffmanTable[], JPEGHuffmanTable[], boolean, boolean, boolean, int, int[], int[], int[], int[], int[], boolean, int):::Returns true if the write was aborted.:::
JPEGImageWriter#writeMetadata():::Writes the metadata out when called by the native code, which will have already written the header to the stream and established the library state:::if->if->JFIFMarkerSegment->writeDefaultJFIF->if->AdobeMarkerSegment->writeAdobeSegment->else->metadata->writeToStream
JPEGImageWriter#writeTables(long, JPEGQTable[], JPEGHuffmanTable[], JPEGHuffmanTable[]):::Write out a tables-only image to the stream.:::
JPEGImageWriter#grabPixels(int):::Put the scanline y of the source ROI view Raster into the 1-line Raster for writing:::sourceLine->if->srcRas->new->intArr->createChild->forceARGB->indexCM->getTransparency->temp->indexCM->convertToIntDiscrete->temp->getRaster->else->srcRas->createChild->if->if->println->convertOp->filter->if->wr->sourceLine->createCompatibleWritableRaster->data->sourceLine->sourceLine->getMinX->sourceLine->getMinY->sourceLine->getWidth->sourceLine->getHeight->getPixels->wr->sourceLine->getMinX->sourceLine->getMinY->sourceLine->getWidth->sourceLine->getHeight->setPixels->srcCM->coerceData->wr->wr->getMinX->wr->getMinY->wr->getWidth->wr->getHeight->createChild->raster->setRect->if->cbLock->lock->try->processImageProgress->catch->finally->cbLock->unlock
JPEGImageWriter#abortWrite(long):::Aborts the current write in the native code:::
JPEGImageWriter#resetWriter(long):::Resets native structures:::
JPEGImageWriter#disposeWriter(long):::Releases native structures:::
JPEGImageWriter.JPEGWriterDisposerRecord#dispose()::: writer disposer record dispose:::if->disposeWriter
JPEGImageWriter#writeOutputData(byte[], int, int):::This method is called from native code in order to write encoder output to the destination:::cbLock->lock->try->ios->write->catch->finally->cbLock->unlock
JPEGImageWriter#setThreadLock()::: image writer set thread lock:::currThread->Thread->currentThread->if->if->throw->new->IllegalStateException->else->else
JPEGImageWriter#clearThreadLock()::: image writer clear thread lock:::currThread->Thread->currentThread->if->throw->new->IllegalStateException->if
JPEGImageWriter.CallBackLock#check()::: call back lock check:::if->throw->new->IllegalStateException
JPEGImageWriter.CallBackLock#lock()::: call back lock lock:::
JPEGImageWriter.CallBackLock#unlock()::: call back lock unlock:::
JPEGImageWriterResources#getContents()::: image writer resources get contents:::return->new->ObjectArrs->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString->Integer->toString
JPEGImageWriterSpi#getDescription(Locale)::: image writer spi get description:::return
JPEGImageWriterSpi#isFormatLossless()::: image writer spi is format lossless:::return
JPEGImageWriterSpi#canEncodeImage(ImageTypeSpecifier)::: image writer spi can encode image:::sampleModel->type->getSampleModel->cm->type->getColorModel->if->cm->hasAlpha->return->sampleSize->sampleModel->getSampleSize->bitDepth->for->i->if->return->return
JPEGImageWriterSpi#createWriterInstance(Object)::: image writer spi create writer instance:::return->new->JPEGImageWriter
JPEGMetadata#findMarkerSegment(int):::Returns the first MarkerSegment object in the list with the given tag, or null if none is found.:::iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->return->return
JPEGMetadata#findMarkerSegment(Class, boolean):::Returns the first or last MarkerSegment object in the list of the given class, or null if none is found.:::if->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->cls->isInstance->return->else->iter->markerSequence->markerSequence->size->listIterator->while->iter->hasPrevious->seg->iter->previous->if->cls->isInstance->return->return
JPEGMetadata#findMarkerSegmentPosition(Class, boolean):::Returns the index of the first or last MarkerSegment in the list of the given class, or -1 if none is found.:::if->iter->markerSequence->listIterator->for->i->iter->hasNext->else->iter->markerSequence->markerSequence->size->listIterator->for->i->markerSequence->size->iter->hasPrevious->return
JPEGMetadata#findLastUnknownMarkerSegmentPosition()::: metadata find last unknown marker segment position:::iter->markerSequence->markerSequence->size->listIterator->for->i->markerSequence->size->iter->hasPrevious->return
JPEGMetadata#clone()::: metadata clone:::newGuy->try->super->clone->catch->finally->if->cloneSequence->return
JPEGMetadata#cloneSequence():::Returns a deep copy of the current marker sequence.:::if->return->retval->markerSequence->size->new->ArrayList<>->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->retval->seg->clone->add->return
JPEGMetadata#getAsTree(String)::: metadata get as tree:::if->throw->new->IllegalArgumentException->if->if->formatName->equals->return->getNativeTree->else->if->formatName->equals->return->getNativeTree->if->formatName->equals->return->getStandardTree->throw->new->IllegalArgumentException
JPEGMetadata#getNativeTree()::: metadata get native tree:::root->top->iter->markerSequence->iterator->if->new->IIOMetadataNode->else->sequence->new->IIOMetadataNode->if->new->IIOMetadataNode->header->new->IIOMetadataNode->root->appendChild->jfif->findMarkerSegment->if->iter->next->header->jfif->getNativeNode->appendChild->root->appendChild->else->while->iter->hasNext->seg->iter->next->top->seg->getNativeNode->appendChild->return
JPEGMetadata#getStandardChromaNode()::: metadata get standard chroma node:::sof->findMarkerSegment->if->return->chroma->new->IIOMetadataNode->csType->new->IIOMetadataNode->chroma->appendChild->numChannels->numChanNode->new->IIOMetadataNode->chroma->appendChild->numChanNode->Integer->toString->setAttribute->if->findMarkerSegment->if->csType->setAttribute->else->csType->setAttribute->return->adobe->findMarkerSegment->if->switch->csType->setAttribute->break->csType->setAttribute->break->if->csType->setAttribute->else->if->csType->setAttribute->break->return->if->csType->setAttribute->if->return->idsAreJFIF->cid0->cid1->cid2->if->if->csType->setAttribute->if->return->if->csType->setAttribute->if->return->if->csType->setAttribute->if->return->subsampled->hfactor->vfactor->for->i->if->csType->setAttribute->if->return->if->csType->setAttribute->else->csType->setAttribute->return
JPEGMetadata#getStandardCompressionNode()::: metadata get standard compression node:::compression->new->IIOMetadataNode->name->new->IIOMetadataNode->name->setAttribute->compression->appendChild->lossless->new->IIOMetadataNode->lossless->setAttribute->compression->appendChild->sosCount->iter->markerSequence->iterator->while->iter->hasNext->ms->iter->next->if->if->prog->new->IIOMetadataNode->prog->Integer->toString->setAttribute->compression->appendChild->return
JPEGMetadata#getStandardDimensionNode()::: metadata get standard dimension node:::dim->new->IIOMetadataNode->orient->new->IIOMetadataNode->orient->setAttribute->dim->appendChild->jfif->findMarkerSegment->if->aspectRatio->if->else->aspect->new->IIOMetadataNode->aspect->Float->toString->setAttribute->dim->insertBefore->if->scale->horiz->new->IIOMetadataNode->horiz->Float->toString->setAttribute->dim->appendChild->vert->new->IIOMetadataNode->vert->Float->toString->setAttribute->dim->appendChild->return
JPEGMetadata#getStandardTextNode()::: metadata get standard text node:::text->if->findMarkerSegment->new->IIOMetadataNode->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->com->entry->new->IIOMetadataNode->entry->setAttribute->entry->com->getComment->setAttribute->text->appendChild->return
JPEGMetadata#getStandardTransparencyNode()::: metadata get standard transparency node:::trans->if->new->IIOMetadataNode->alpha->new->IIOMetadataNode->alpha->setAttribute->trans->appendChild->return
JPEGMetadata#isReadOnly()::: metadata is read only:::return
JPEGMetadata#mergeTree(String, Node)::: metadata merge tree:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->copy->if->cloneSequence->else->cloneSequence->if->formatName->equals->mergeNativeTree->else->if->formatName->equals->mergeNativeTree->else->if->formatName->equals->mergeStandardTree->else->throw->new->IllegalArgumentException->if->isConsistent->throw->new->IIOInvalidTreeException
JPEGMetadata#mergeNativeTree(Node)::: metadata merge native tree:::name->root->getNodeName->if->throw->new->IIOInvalidTreeException->if->root->getChildNodes->getLength->throw->new->IIOInvalidTreeException->root->getFirstChild->mergeJFIFsubtree->root->getLastChild->mergeSequenceSubtree
JPEGMetadata#mergeJFIFsubtree(Node):::Merge a JFIF subtree into the marker sequence, if the subtree is non-empty:::if->JPEGvariety->getChildNodes->getLength->jfifNode->JPEGvariety->getFirstChild->jfifSeg->findMarkerSegment->if->jfifSeg->updateFromNativeNode->else->markerSequence->new->JFIFMarkerSegment->add
JPEGMetadata#mergeSequenceSubtree(Node)::: metadata merge sequence subtree:::children->sequenceTree->getChildNodes->for->i->children->getLength
JPEGMetadata#mergeDQTNode(Node):::Merge the given DQT node into the marker sequence:::oldDQTs->new->ArrayList<>->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->oldDQTs->add->if->oldDQTs->isEmpty->children->node->getChildNodes->for->i->children->getLength->else->newGuy->new->DQTMarkerSegment->firstDHT->findMarkerSegmentPosition->firstSOF->findMarkerSegmentPosition->firstSOS->findMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->else->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeDHTNode(Node):::Merge the given DHT node into the marker sequence:::oldDHTs->new->ArrayList<>->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->oldDHTs->add->if->oldDHTs->isEmpty->children->node->getChildNodes->for->i->children->getLength->else->newGuy->new->DHTMarkerSegment->lastDQT->findMarkerSegmentPosition->firstSOF->findMarkerSegmentPosition->firstSOS->findMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->else->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeDRINode(Node):::Merge the given DRI node into the marker sequence:::dri->findMarkerSegment->if->dri->updateFromNativeNode->else->newGuy->new->DRIMarkerSegment->firstSOF->findMarkerSegmentPosition->firstSOS->findMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeCOMNode(Node):::Merge the given COM node into the marker sequence:::newGuy->new->COMMarkerSegment->insertCOMMarkerSegment
JPEGMetadata#insertCOMMarkerSegment(COMMarkerSegment):::Insert a new COM marker segment into an appropriate place in the marker sequence, as follows: If there already exist COM marker segments, the new one is inserted after the last one:::lastCOM->findMarkerSegmentPosition->hasJFIF->findMarkerSegment->firstAdobe->findMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->else->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeAdobeNode(Node):::Merge the given Adobe APP14 node into the marker sequence:::adobe->findMarkerSegment->if->adobe->updateFromNativeNode->else->newGuy->new->AdobeMarkerSegment->insertAdobeMarkerSegment
JPEGMetadata#insertAdobeMarkerSegment(AdobeMarkerSegment):::Insert the given AdobeMarkerSegment into the marker sequence, as follows (we assume there is no Adobe segment yet): If there is a JFIF segment, then the new Adobe segment is inserted after it:::hasJFIF->findMarkerSegment->lastUnknown->findLastUnknownMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeUnknownNode(Node):::Merge the given Unknown node into the marker sequence:::newGuy->new->MarkerSegment->lastUnknown->findLastUnknownMarkerSegmentPosition->hasJFIF->findMarkerSegment->firstAdobe->findMarkerSegmentPosition->if->markerSequence->add->else->if->markerSequence->add->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeSOFNode(Node):::Merge the given SOF node into the marker sequence:::sof->findMarkerSegment->if->sof->updateFromNativeNode->else->newGuy->new->SOFMarkerSegment->firstSOS->findMarkerSegmentPosition->if->markerSequence->add->else->markerSequence->add
JPEGMetadata#mergeSOSNode(Node):::Merge the given SOS node into the marker sequence:::firstSOS->findMarkerSegment->lastSOS->findMarkerSegment->if->if->throw->new->IIOInvalidTreeException->firstSOS->updateFromNativeNode->else->markerSequence->new->SOSMarkerSegment->add
JPEGMetadata#mergeStandardTree(Node)::: metadata merge standard tree:::children->root->getChildNodes->for->i->children->getLength
JPEGMetadata#mergeStandardChromaNode(Node, NodeList)::: metadata merge standard chroma node:::if->throw->new->IIOInvalidTreeException->csType->node->getFirstChild->if->csType->getNodeName->equals->return->csName->csType->getAttributes->getNamedItem->getNodeValue->numChannels->wantJFIF->wantAdobe->transform->willSubsample->ids->if->csName->equals->else->if->csName->equals->else->if->csName->equals->else->if->csName->equals->else->if->csName->equals->csName->equals->csName->equals->csName->equals->csName->equals->csName->equals->csName->equals->csName->equals->else->if->csName->equals->else->if->csName->equals->else->if->csName->equals->else->return->wantAlpha->for->i->siblings->getLength->if->if->jfif->findMarkerSegment->adobe->findMarkerSegment->sof->findMarkerSegment->sos->findMarkerSegment->if->if->return->if->markerSequence->remove->if->markerSequence->new->JFIFMarkerSegment->add->if->if->new->AdobeMarkerSegment->insertAdobeMarkerSegment->else->else->if->markerSequence->remove->updateQtables->updateHtables->progressive->subsampledSelectors->nonSubsampledSelectors->newTableSelectors->oldCompSpecs->if->markerSequence->markerSequence->indexOf->new->SOFMarkerSegment->set->for->i->if->idsDiffer->for->i->if->for->iter->markerSequence->iterator->iter->hasNext->else->if->for->i->markerSequence->markerSequence->indexOf->new->SOSMarkerSegment->set->else->if->if->tableSegments->new->ArrayList<>->for->iter->markerSequence->iterator->iter->hasNext->if->tableSegments->isEmpty->found->for->iter->tableSegments->iterator->iter->hasNext->if->table0->for->iter->tableSegments->iterator->iter->hasNext->dqt->tableSegments->tableSegments->size->get->dqt->getChromaForLuma->add->if->tableSegments->new->ArrayList<>->for->iter->markerSequence->iterator->iter->hasNext->if->tableSegments->isEmpty->found->for->iter->tableSegments->iterator->iter->hasNext->if->lastDHT->tableSegments->tableSegments->size->get->lastDHT->addHtable->lastDHT->addHtable
JPEGMetadata#wantAlpha(Node)::: metadata want alpha:::returnValue->alpha->transparency->getFirstChild->if->alpha->getNodeName->equals->if->alpha->hasAttributes->value->alpha->getAttributes->getNamedItem->getNodeValue->if->value->equals->return
JPEGMetadata#mergeStandardCompressionNode(Node)::: metadata merge standard compression node:::
JPEGMetadata#mergeStandardDataNode(Node)::: metadata merge standard data node:::
JPEGMetadata#mergeStandardDimensionNode(Node)::: metadata merge standard dimension node:::jfif->findMarkerSegment->if->canHaveJFIF->sof->findMarkerSegment->if->numChannels->if->for->i->adobe->findMarkerSegment->if->if->if->new->JFIFMarkerSegment->markerSequence->add->if->children->node->getChildNodes->for->i->children->getLength
JPEGMetadata#findIntegerRatio(float)::: metadata find integer ratio:::epsilon->Math->abs->if->return->new->Point->if->return->new->Point->inverted->if->y->x->Math->round->ratio->delta->Math->abs->while->Math->round->Math->abs->return->new->Point->new->Point
JPEGMetadata#mergeStandardDocumentNode(Node)::: metadata merge standard document node:::
JPEGMetadata#mergeStandardTextNode(Node)::: metadata merge standard text node:::children->node->getChildNodes->for->i->children->getLength
JPEGMetadata#mergeStandardTransparencyNode(Node)::: metadata merge standard transparency node:::if->wantAlpha->wantAlpha->jfif->findMarkerSegment->adobe->findMarkerSegment->sof->findMarkerSegment->sos->findMarkerSegment->if->return->if->numChannels->hadAlpha->if->if->if->markerSequence->remove->if->newSpecs->new->SOFMarkerSegment.ComponentSpecArr->for->i->oldFirstID->newID->sof->getComponentSpec->newScanSpecs->new->SOSMarkerSegment.ScanComponentSpecArr->for->i->sos->getScanComponentSpec->else->newSpecs->new->SOFMarkerSegment.ComponentSpecArr->for->i->newScanSpecs->new->SOSMarkerSegment.ScanComponentSpecArr->for->i
JPEGMetadata#setFromTree(String, Node)::: metadata set from tree:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->if->formatName->equals->setFromNativeTree->else->if->formatName->equals->setFromNativeTree->else->if->formatName->equals->super->setFromTree->else->throw->new->IllegalArgumentException
JPEGMetadata#setFromNativeTree(Node)::: metadata set from native tree:::if->new->ArrayList<>->name->root->getNodeName->if->throw->new->IIOInvalidTreeException->if->if->root->getChildNodes->getLength->throw->new->IIOInvalidTreeException->JPEGvariety->root->getFirstChild->if->JPEGvariety->getChildNodes->getLength->markerSequence->JPEGvariety->getFirstChild->new->JFIFMarkerSegment->add->markerSequenceNode->root->getLastChild->setFromMarkerSequenceNode
JPEGMetadata#setFromMarkerSequenceNode(Node)::: metadata set from marker sequence node:::children->markerSequenceNode->getChildNodes->for->i->children->getLength
JPEGMetadata#isConsistent():::Check that this metadata object is in a consistent state and return true if it is or false otherwise:::sof->findMarkerSegment->jfif->findMarkerSegment->adobe->findMarkerSegment->retval->if->if->numSOFBands->numScanBands->countScanBands->if->if->if->if->for->i->if->else->sos->findMarkerSegment->if->return
JPEGMetadata#countScanBands():::Returns the total number of bands referenced in all SOS marker segments, including 0 if there are no SOS marker segments.:::ids->new->ArrayList<>->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->sos->specs->for->i->return->ids->size
JPEGMetadata#writeToStream(ImageOutputStream, boolean, boolean, List, ICC_Profile, boolean, int, JPEGImageWriter)::: metadata write to stream:::if->JFIFMarkerSegment->writeDefaultJFIF->if->if->writer->warningOccurred->iter->markerSequence->iterator->while->iter->hasNext->seg->iter->next->if->if->jfif->jfif->writeWithThumbs->if->JFIFMarkerSegment->writeICC->else->if->if->if->newAdobe->seg->clone->newAdobe->write->else->if->adobe->if->adobe->write->else->writer->warningOccurred->else->seg->write->else->seg->write
JPEGMetadata#reset()::: metadata reset:::if
JPEGMetadata#print()::: metadata print:::for->i->markerSequence->size
JPEGMetadataFormat#addStreamElements(String)::: metadata format add stream elements:::addElement->addElement->addAttribute->tabids->new->ArrayList<>->tabids->add->tabids->add->tabids->add->tabids->add->addAttribute->addObjectValue->addElement->addElement->classes->new->ArrayList<>->classes->add->classes->add->addAttribute->addAttribute->addObjectValue->addElement->addAttribute->addElement->addAttribute->addObjectValue->addElement->addAttribute->addObjectValue
JPEGMetadataFormat#canNodeAppear(String, ImageTypeSpecifier)::: metadata format can node appear:::if->getRootName->isInSubtree->return->return
JPEGMetadataFormat#isInSubtree(String, String):::Returns true if the named element occurs in the subtree of the format starting with the node named by subtreeName, including the node itself:::if->elementName->equals->return->children->getChildNames->for->i->return
JPEGStreamMetadataFormat#getInstance()::: stream metadata format get instance:::if->new->JPEGStreamMetadataFormat->return
JPEGStreamMetadataFormatResources#getContents()::: stream metadata format resources get contents:::commonCopy->new->ObjectArrs->for->i->return
MarkerSegment#clone():::Deep copy of data array.:::newGuy->try->super->clone->catch->finally->if->data->clone->return
MarkerSegment#loadData(JPEGBuffer):::We have determined that we don't know the type, so load the data using the length parameter.:::new->byteArr->buffer->readData
MarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->setUserObject->return
MarkerSegment#getAttributeValue(Node, NamedNodeMap, String, int, int, boolean)::: marker segment get attribute value:::if->node->getAttributes->valueString->attrs->getNamedItem->getNodeValue->value->if->if->throw->new->IIOInvalidTreeException->else->Integer->parseInt->if->throw->new->IIOInvalidTreeException->return
MarkerSegment#writeTag(ImageOutputStream):::Writes the marker, tag, and length:::ios->write->ios->write->write2bytes
MarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::writeTag->if->ios->write
MarkerSegment#write2bytes(ImageOutputStream, int)::: marker segment write2bytes:::ios->write->ios->write
MarkerSegment#printTag(String)::: marker segment print tag:::Integer->toHexString->println->println
MarkerSegment#print()::: marker segment print:::printTag->if->print->for->i->print->for->i->else->print->for->i->println
SOFMarkerSegment#clone()::: marker segment clone:::newGuy->super->clone->if->componentSpecs->clone->for->i->return
SOFMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->for->i->return
SOFMarkerSegment#updateFromNativeNode(Node, boolean)::: marker segment update from native node:::attrs->node->getAttributes->value->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->numComponents->getAttributeValue->children->node->getChildNodes->if->children->getLength->throw->new->IIOInvalidTreeException->new->ComponentSpecArr->for->i
SOFMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
SOFMarkerSegment#print()::: marker segment print:::printTag->print->println->print->println->print->println->print->println->for->i
SOFMarkerSegment#getIDencodedCSType()::: marker segment get dencoded type:::for->i->switch->if->return->break->return
SOFMarkerSegment#getComponentSpec(byte, int, int)::: marker segment get component spec:::return->new->ComponentSpec
SOFMarkerSegment.ComponentSpec#clone()::: component spec clone:::try->return->super->clone->catch->finally->return
SOFMarkerSegment.ComponentSpec#getNativeNode()::: component spec get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->return
SOFMarkerSegment.ComponentSpec#print()::: component spec print:::print->println->print->println->print->println->print->println
SOSMarkerSegment#clone()::: marker segment clone:::newGuy->super->clone->if->componentSpecs->clone->for->i->return
SOSMarkerSegment#getNativeNode()::: marker segment get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->for->i->return
SOSMarkerSegment#updateFromNativeNode(Node, boolean)::: marker segment update from native node:::attrs->node->getAttributes->numComponents->getAttributeValue->value->getAttributeValue->getAttributeValue->getAttributeValue->getAttributeValue->children->node->getChildNodes->if->children->getLength->throw->new->IIOInvalidTreeException->new->ScanComponentSpecArr->for->i
SOSMarkerSegment#write(ImageOutputStream):::Writes the data for this segment to the stream in valid JPEG format.:::
SOSMarkerSegment#print()::: marker segment print:::printTag->print->println->print->println->print->println->print->println->print->println->for->i
SOSMarkerSegment#getScanComponentSpec(byte, int)::: marker segment get scan component spec:::return->new->ScanComponentSpec
SOSMarkerSegment.ScanComponentSpec#clone()::: scan component spec clone:::try->return->super->clone->catch->finally->return
SOSMarkerSegment.ScanComponentSpec#getNativeNode()::: scan component spec get native node:::node->new->IIOMetadataNode->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->node->Integer->toString->setAttribute->return
SOSMarkerSegment.ScanComponentSpec#print()::: scan component spec print:::print->println->print->println->print->println
