EndEntityChecker#getInstance(String, String)::: end entity checker get instance:::return->new->EndEntityChecker
EndEntityChecker#check(X509Certificate[], Object, boolean)::: end entity checker check:::if->variant->equals->return->exts->getCriticalExtensions->if->variant->equals->checkTLSServer->else->if->variant->equals->checkTLSClient->else->if->variant->equals->checkCodeSigning->else->if->variant->equals->checkCodeSigning->else->if->variant->equals->checkCodeSigning->else->if->variant->equals->checkTSAServer->else->throw->new->CertificateException->if->checkRemainingExtensions->foreach->policy->checkDistrust
EndEntityChecker#getCriticalExtensions(X509Certificate):::Utility method returning the Set of critical extensions for certificate cert (never null).:::exts->cert->getCriticalExtensionOIDs->if->Collections->emptySet->return
EndEntityChecker#checkRemainingExtensions(Set):::Utility method checking if there are any unresolved critical extensions.:::exts->remove->exts->remove->if->exts->isEmpty->throw->new->CertificateException
EndEntityChecker#checkEKU(X509Certificate, Set, String):::Utility method checking if the extended key usage extension in certificate cert allows use for expectedEKU.:::eku->cert->getExtendedKeyUsage->if->return->return->eku->contains->eku->contains
EndEntityChecker#checkKeyUsage(X509Certificate, int):::Utility method checking if bit 'bit' is set in this certificates key usage extension.:::keyUsage->cert->getKeyUsage->if->return->return
EndEntityChecker#checkTLSClient(X509Certificate, Set):::Check whether this certificate can be used for TLS client authentication.:::if->checkKeyUsage->throw->new->ValidatorException->if->checkEKU->throw->new->ValidatorException->if->SimpleValidator->getNetscapeCertTypeBit->throw->new->ValidatorException->exts->remove->exts->remove->exts->remove
EndEntityChecker#checkTLSServer(X509Certificate, String, Set):::Check whether this certificate can be used for TLS server authentication using the specified authentication type parameter:::if->KU_SERVER_ENCRYPTION->contains->if->checkKeyUsage->throw->new->ValidatorException->else->if->KU_SERVER_SIGNATURE->contains->if->checkKeyUsage->throw->new->ValidatorException->else->if->KU_SERVER_KEY_AGREEMENT->contains->if->checkKeyUsage->throw->new->ValidatorException->else->throw->new->CertificateException->if->checkEKU->if->checkEKU->checkEKU->throw->new->ValidatorException->if->SimpleValidator->getNetscapeCertTypeBit->throw->new->ValidatorException->exts->remove->exts->remove->exts->remove
EndEntityChecker#checkCodeSigning(X509Certificate, Set):::Check whether this certificate can be used for code signing.:::if->checkKeyUsage->throw->new->ValidatorException->if->checkEKU->throw->new->ValidatorException->if->variant->equals->if->SimpleValidator->getNetscapeCertTypeBit->throw->new->ValidatorException->exts->remove->exts->remove->exts->remove
EndEntityChecker#checkTSAServer(X509Certificate, Set):::Check whether this certificate can be used by a time stamping authority server (see RFC 3161, section 2.3).:::if->checkKeyUsage->throw->new->ValidatorException->if->cert->getExtendedKeyUsage->throw->new->ValidatorException->if->checkEKU->throw->new->ValidatorException->exts->remove->exts->remove
PKIXValidator#allowNonCaAnchor()::: validator allow non ca anchor:::prop->GetPropertyAction->privilegedGetProperty->return->prop->isEmpty->prop->equalsIgnoreCase
PKIXValidator#setTrustedSubjects():::Populate the trustedSubjects Map using the DN and public keys from the list of trusted certificates:::subjectMap->new->HashMap<>->foreach->dn->cert->getSubjectX500Principal->keys->if->subjectMap->containsKey->subjectMap->get->else->new->ArrayList<PublicKey>->subjectMap->put->keys->cert->getPublicKey->add->return
PKIXValidator#getTrustedCertificates()::: validator get trusted certificates:::return
PKIXValidator#getCertPathLength():::Returns the length of the last certification path that is validated by CertPathValidator:::return
PKIXValidator#setDefaultParameters(String):::Set J2SE global default PKIX parameters:::if->parameterTemplate->setRevocationEnabled->else->parameterTemplate->setRevocationEnabled
PKIXValidator#getParameters():::Return the PKIX parameters used by this instance:::return
PKIXValidator#engineValidate(X509Certificate[], Collection, List, AlgorithmConstraints, Object)::: validator engine validate:::if->throw->new->CertificateException->pkixParameters->try->parameterTemplate->clone->new->PKIXExtendedParameters->catch->finally->if->pkixParameters->new->AlgorithmChecker->addCertPathChecker->if->responseList->isEmpty->addResponses->prevIssuer->for->i->last->issuer->last->getIssuerX500Principal->subject->last->getSubjectX500Principal->if->trustedSubjects->containsKey->trustedSubjects->get->isSignatureValid->return->doValidate->if->if->newChain->new->X509CertificateArr->System->arraycopy->try->pkixParameters->Collections->new->TrustAnchor->singleton->setTrustAnchors->catch->throw->new->CertificateException->finally->doValidate->throw->new->ValidatorException->return->doBuild
PKIXValidator#isSignatureValid(List, X509Certificate)::: validator is signature valid:::if->foreach->try->sub->verify->return->catch->continue->finally->return->return
PKIXValidator#toArray(CertPath, TrustAnchor)::: validator to array:::trustedCert->anchor->getTrustedCert->if->throw->new->ValidatorException->verifyTrustAnchor->list->path->getCertificates->chain->list->size->new->X509CertificateArr->list->toArray->return
PKIXValidator#setDate(PKIXBuilderParameters):::Set the check date (for debugging).:::date->if->params->setDate
PKIXValidator#doValidate(X509Certificate[], PKIXBuilderParameters)::: validator do validate:::try->setDate->validator->CertPathValidator->getInstance->path->factory->Arrays->asList->generateCertPath->result->validator->validate->return->result->getTrustAnchor->toArray->catch->throw->e->toString->new->ValidatorException->finally
PKIXValidator#verifyTrustAnchor(X509Certificate):::Verify that a trust anchor certificate is a CA certificate.:::if->return->if->trustedCert->getVersion->return->if->trustedCert->getBasicConstraints->throw->trustedCert->getSubjectX500Principal->new->ValidatorException->keyUsageBits->trustedCert->getKeyUsage->if->throw->trustedCert->getSubjectX500Principal->new->ValidatorException
PKIXValidator#doBuild(X509Certificate[], Collection, PKIXBuilderParameters)::: validator do build:::try->setDate->selector->new->X509CertSelector->selector->setCertificate->params->setTargetCertConstraints->certs->new->ArrayList<X509Certificate>->certs->Arrays->asList->addAll->if->certs->addAll->store->CertStore->new->CollectionCertStoreParameters->getInstance->params->addCertStore->builder->CertPathBuilder->getInstance->result->builder->build->return->result->getCertPath->result->getTrustAnchor->toArray->catch->throw->e->toString->new->ValidatorException->finally
PKIXValidator#addResponses(PKIXBuilderParameters, X509Certificate[], List):::For OCSP Stapling, add responses that came in during the handshake into a PKIXRevocationChecker so we can evaluate them.:::if->pkixParams->isRevocationEnabled->try->revChecker->checkerList->pkixParams->getCertPathCheckers->new->ArrayList<>->foreach->if->break->if->CertPathValidator->getInstance->getRevocationChecker->checkerList->add->responseMap->revChecker->getOcspResponses->limit->Integer->responseList->size->min->for->idx->revChecker->setOcspResponses->pkixParams->setCertPathCheckers->catch->finally
SimpleValidator#getTrustedCertificates()::: simple validator get trusted certificates:::return
SimpleValidator#engineValidate(X509Certificate[], Collection, List, AlgorithmConstraints, Object):::Perform simple validation of chain:::if->throw->new->CertificateException->buildTrustedChain->date->if->new->Date->untrustedChecker->new->UntrustedChecker->anchorCert->try->untrustedChecker->check->catch->throw->anchorCert->getSubjectX500Principal->new->ValidatorException->finally->anchor->new->TrustAnchor->defaultAlgChecker->new->AlgorithmChecker->appAlgChecker->if->new->AlgorithmChecker->maxPathLength->for->i->return
SimpleValidator#checkExtensions(X509Certificate, int)::: simple validator check extensions:::critSet->cert->getCriticalExtensionOIDs->if->Collections->emptySet->pathLenConstraint->checkBasicConstraints->checkKeyUsage->checkNetscapeCertType->if->critSet->isEmpty->throw->new->ValidatorException->return
SimpleValidator#checkNetscapeCertType(X509Certificate, Set)::: simple validator check netscape cert type:::if->variant->equals->else->if->variant->equals->variant->equals->if->getNetscapeCertTypeBit->throw->new->ValidatorException->critSet->remove->else->if->variant->equals->variant->equals->if->getNetscapeCertTypeBit->throw->new->ValidatorException->critSet->remove->else->throw->new->CertificateException
SimpleValidator#getNetscapeCertTypeBit(X509Certificate, String):::Get the value of the specified bit in the Netscape certificate type extension:::try->ext->if->certImpl->oid->certImpl->getExtension->if->return->else->extVal->cert->getExtensionValue->if->return->in->new->DerInputStream->encoded->in->getOctetString->new->DerValue->getUnalignedBitString->toByteArray->new->NetscapeCertTypeExtension->val->ext->get->return->val->booleanValue->catch->return->finally
SimpleValidator#checkBasicConstraints(X509Certificate, Set, int)::: simple validator check basic constraints:::critSet->remove->constraints->cert->getBasicConstraints->if->throw->new->ValidatorException->if->X509CertImpl->isSelfIssued->if->throw->new->ValidatorException->if->return
SimpleValidator#checkKeyUsage(X509Certificate, Set)::: simple validator check key usage:::critSet->remove->critSet->remove->keyUsageInfo->cert->getKeyUsage->if->if->throw->new->ValidatorException
SimpleValidator#buildTrustedChain(X509Certificate[]):::Build a trusted certificate chain:::c->new->ArrayList<X509Certificate>->for->i->cert->subject->cert->getSubjectX500Principal->issuer->cert->getIssuerX500Principal->list->trustedX500Principals->get->if->matchedCert->list->get->certImpl->X509CertImpl->toImpl->akid->certImpl->getAuthKeyId->if->foreach->supCert->X509CertImpl->toImpl->if->akid->supCert->getSubjectKeyId->equals->break->c->add->return->c->toArray->throw->new->ValidatorException
SimpleValidator#getTrustedCertificate(X509Certificate):::Return a trusted certificate that matches the input certificate, or null if no such certificate can be found:::certSubjectName->cert->getSubjectX500Principal->list->trustedX500Principals->get->if->return->certIssuerName->cert->getIssuerX500Principal->certPublicKey->cert->getPublicKey->foreach->if->mycert->equals->return->if->mycert->getIssuerX500Principal->equals->continue->if->mycert->getPublicKey->equals->continue->return->return
SymantecTLSPolicy#checkDistrust(X509Certificate[]):::This method assumes the eeCert is a TLS Server Cert and chains back to the anchor.:::anchor->if->FINGERPRINTS->fingerprint->contains->notBefore->getNotBefore->ldNotBefore->LocalDate->notBefore->toInstant->ofInstant->if->subCA->distrustDate->EXEMPT_SUBCAS->fingerprint->get->if->checkNotBefore->return->checkNotBefore
SymantecTLSPolicy#fingerprint(X509Certificate)::: symantec policy fingerprint:::return->getFingerprint->X509CertImpl->getFingerprint
SymantecTLSPolicy#checkNotBefore(LocalDate, LocalDate, X509Certificate)::: symantec policy check not before:::if->notBeforeDate->isAfter->throw->anchor->getSubjectX500Principal->new->ValidatorException
TrustStoreUtil#getTrustedCerts(KeyStore):::Return an unmodifiable Set with all trusted X509Certificates contained in the specified KeyStore.:::set->new->HashSet<>->try->for->e->ks->aliases->e->hasMoreElements->catch->finally->return->Collections->unmodifiableSet
Validator#getInstance(String, String, KeyStore):::Get a new Validator instance using the trusted certificates from the specified KeyStore as trust anchors.:::return->TrustStoreUtil->getTrustedCerts->getInstance
Validator#getInstance(String, String, Collection):::Get a new Validator instance using the Set of X509Certificates as trust anchors.:::if->type->equals->return->new->SimpleValidator->else->if->type->equals->return->new->PKIXValidator->else->throw->new->IllegalArgumentException
Validator#getInstance(String, String, PKIXBuilderParameters):::Get a new Validator instance using the provided PKIXBuilderParameters:::if->type->equals->throw->new->IllegalArgumentException->return->new->PKIXValidator
Validator#validate(X509Certificate[]):::Validate the given certificate chain.:::return->validate
Validator#validate(X509Certificate[], Collection):::Validate the given certificate chain:::return->validate
Validator#validate(X509Certificate[], Collection, Object):::Validate the given certificate chain:::return->Collections->emptyList->validate
Validator#validate(X509Certificate[], Collection, List, AlgorithmConstraints, Object):::Validate the given certificate chain.:::engineValidate->if->checkUnresolvedCritExts->endEntityChecker->check->return
Validator#engineValidate(X509Certificate[], Collection, List, AlgorithmConstraints, Object)::: validator engine validate:::
Validator#getTrustedCertificates():::Returns an immutable Collection of the X509Certificates this instance uses as trust anchors.:::
Validator#setValidationDate(Date):::Set the date to be used for subsequent validations:::
ValidatorException#getErrorType():::Get the type of the failure (one of the T_XXX constants), if available:::return
ValidatorException#getErrorCertificate():::Get the certificate causing the exception, if available.:::return
