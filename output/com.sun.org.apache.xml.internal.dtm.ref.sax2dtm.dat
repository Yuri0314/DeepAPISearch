SAX2DTM#setUseSourceLocation(boolean):::Set whether information about document source location should be maintained or not.:::
SAX2DTM#_dataOrQName(int):::Get the data or qualified name for the given node identity.:::if->return->m_dataOrQName->elementAt->while->isMore->nextNode->if->return->else->if->return->m_dataOrQName->elementAt
SAX2DTM#clearCoRoutine():::Ask the CoRoutine parser to doTerminate and clear the reference.:::clearCoRoutine
SAX2DTM#clearCoRoutine(boolean):::Ask the CoRoutine parser to doTerminate and clear the reference:::if->if->m_incrementalSAXSource->deliverMoreNodes
SAX2DTM#setIncrementalSAXSource(IncrementalSAXSource):::Bind a IncrementalSAXSource to this DTM:::incrementalSAXSource->setContentHandler->incrementalSAXSource->setLexicalHandler->incrementalSAXSource->setDTDHandler
SAX2DTM#getContentHandler():::getContentHandler returns "our SAX builder" -- the thing that someone else should send SAX events to in order to extend this DTM model:::if->m_incrementalSAXSource->getClass->getName->equals->return->else->return
SAX2DTM#getLexicalHandler():::Return this DTM's lexical handler:::if->m_incrementalSAXSource->getClass->getName->equals->return->else->return
SAX2DTM#getEntityResolver():::Return this DTM's EntityResolver.:::return
SAX2DTM#getDTDHandler():::Return this DTM's DTDHandler.:::return
SAX2DTM#getErrorHandler():::Return this DTM's ErrorHandler.:::return
SAX2DTM#getDeclHandler():::Return this DTM's DeclHandler.:::return
SAX2DTM#needsTwoThreads()::: x2 m needs two threads:::return
SAX2DTM#dispatchCharactersEvents(int, ContentHandler, boolean):::Directly call the characters method on the passed ContentHandler for the string-value of the given node (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value):::identity->makeNodeIdentity->if->return->type->_type->if->isTextType->dataIndex->m_dataOrQName->elementAt->offset->m_data->elementAt->length->m_data->elementAt->if->m_chars->sendNormalizedSAXcharacters->else->m_chars->sendSAXcharacters->else->firstChild->_firstch->if->offset->length->startNode->do->_type->if->isTextType->dataIndex->_dataOrQName->if->m_data->elementAt->m_data->elementAt->getNextNodeIdentity->while->_parent->if->if->m_chars->sendNormalizedSAXcharacters->else->m_chars->sendSAXcharacters->else->if->dataIndex->_dataOrQName->if->m_data->elementAt->str->m_valuesOrPrefixes->indexToString->if->FastStringBuffer->str->toCharArray->str->length->sendNormalizedSAXcharacters->else->ch->str->toCharArray->str->length->characters
SAX2DTM#getNodeName(int):::Given a node handle, return its DOM-style node name:::expandedTypeID->getExpandedTypeID->namespaceID->m_expandedNameTable->getNamespaceID->if->type->getNodeType->if->if->m_expandedNameTable->getLocalName->return->else->return->m_expandedNameTable->getLocalName->else->if->m_expandedNameTable->getLocalNameID->return->else->return->m_expandedNameTable->getLocalName->else->qnameIndex->m_dataOrQName->makeNodeIdentity->elementAt->if->m_data->elementAt->return->m_valuesOrPrefixes->indexToString
SAX2DTM#getNodeNameX(int):::Given a node handle, return the XPath node name:::expandedTypeID->getExpandedTypeID->namespaceID->m_expandedNameTable->getNamespaceID->if->name->m_expandedNameTable->getLocalName->if->return->else->return->else->qnameIndex->m_dataOrQName->makeNodeIdentity->elementAt->if->m_data->elementAt->return->m_valuesOrPrefixes->indexToString
SAX2DTM#isAttributeSpecified(int):::    5:::return
SAX2DTM#getDocumentTypeDeclarationSystemIdentifier():::  A document type declaration information item has the following properties:      1:::XMLMessages->createXMLMessage->error->return
SAX2DTM#getNextNodeIdentity(int):::Get the next node identity value in the list, and call the iterator if it hasn't been added yet.:::while->if->return->nextNode->return
SAX2DTM#dispatchToEvents(int, ContentHandler):::Directly create SAX parser events from a subtree.:::treeWalker->prevCH->treeWalker->getcontentHandler->if->new->DTMTreeWalker->treeWalker->setcontentHandler->treeWalker->setDTM->try->treeWalker->traverse->catch->finally->treeWalker->setcontentHandler
SAX2DTM#getNumberOfNodes():::Get the number of nodes that have been added.:::return
SAX2DTM#nextNode():::This method should try and build one or more nodes in the table.:::if->return->if->clearCoRoutine->return->gotMore->m_incrementalSAXSource->deliverMoreNodes->if->if->throw->else->if->throw->new->WrappedRuntimeException->clearCoRoutine->return->if->clearCoRoutine->return
SAX2DTM#isTextType(int):::Bottleneck determination of text type.:::return
SAX2DTM#addNode(int, int, int, int, int, boolean):::Construct the node map from the node.:::nodeIndex->if->m_dtmIdent->size->addNewDTMID->m_firstch->addElement->m_nextsib->addElement->m_parent->addElement->m_exptype->addElement->m_dataOrQName->addElement->if->m_prevsib->addElement->if->m_nextsib->setElementAt->if->setSourceLocation->switch->declareNamespaceInContext->break->break->if->m_firstch->setElementAt->break->return
SAX2DTM#addNewDTMID(int):::Get a new DTM ID beginning at the specified node index.:::try->if->throw->new->ClassCastException->mgrD->id->mgrD->getFirstFreeDTMID->mgrD->addDTM->m_dtmIdent->addElement->catch->XMLMessages->createXMLMessage->error->finally
SAX2DTM#migrateTo(DTMManager):::Migrate a DTM built with an old DTMManager to a new DTMManager:::super->migrateTo->numDTMs->m_dtmIdent->size->dtmId->m_mgrDefault->getFirstFreeDTMID->nodeIndex->for->i
SAX2DTM#setSourceLocation():::Store the source location of the current node:::m_sourceSystemId->m_locator->getSystemId->addElement->m_sourceLine->m_locator->getLineNumber->addElement->m_sourceColumn->m_locator->getColumnNumber->addElement->if->m_sourceSystemId->size->msg->m_sourceSystemId->size->println->throw->new->RuntimeException
SAX2DTM#getNodeValue(int):::Given a node handle, return its node value:::identity->makeNodeIdentity->type->_type->if->isTextType->dataIndex->_dataOrQName->offset->m_data->elementAt->length->m_data->elementAt->return->m_chars->getString->else->if->return->else->dataIndex->_dataOrQName->if->m_data->elementAt->return->m_valuesOrPrefixes->indexToString
SAX2DTM#getLocalName(int):::Given a node handle, return its XPath-style localname:::return->m_expandedNameTable->makeNodeIdentity->_exptype->getLocalName
SAX2DTM#getUnparsedEntityURI(String):::The getUnparsedEntityURI function returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]):::url->if->return->n->m_entities->size->for->i->return
SAX2DTM#getPrefix(int):::Given a namespace handle, return the prefix that the namespace decl is mapping:::identity->makeNodeIdentity->type->_type->if->prefixIndex->_dataOrQName->if->return->else->qname->m_valuesOrPrefixes->indexToString->return->getPrefix->else->if->prefixIndex->_dataOrQName->if->m_data->elementAt->qname->m_valuesOrPrefixes->indexToString->return->getPrefix->return
SAX2DTM#getAttributeNode(int, String, String):::Retrieves an attribute node by by qualified name and namespace URI.:::for->attrH->getFirstAttribute->getNextAttribute->return
SAX2DTM#getDocumentTypeDeclarationPublicIdentifier():::Return the public identifier of the external subset, normalized as described in 4.2.2 External Entities [XML]:::XMLMessages->createXMLMessage->error->return
SAX2DTM#getNamespaceURI(int):::Given a node handle, return its DOM-style namespace URI (As defined in Namespaces, this is the declared URI which this node's prefix -- or default in lieu thereof -- was mapped to.)  %REVIEW% Null or ""? -sb:::return->m_expandedNameTable->makeNodeIdentity->_exptype->getNamespace
SAX2DTM#getStringValue(int):::Get the string-value of a node as a String object (see http://www.w3.org/TR/xpath#data-model for the definition of a node's string-value).:::identity->makeNodeIdentity->type->if->else->_type->if->isTextType->dataIndex->_dataOrQName->offset->m_data->elementAt->length->m_data->elementAt->return->m_xstrf->newstr->else->firstChild->_firstch->if->offset->length->startNode->do->_type->if->isTextType->dataIndex->_dataOrQName->if->m_data->elementAt->m_data->elementAt->getNextNodeIdentity->while->_parent->if->return->m_xstrf->newstr->else->if->dataIndex->_dataOrQName->if->m_data->elementAt->return->m_xstrf->m_valuesOrPrefixes->indexToString->newstr->return->m_xstrf->emptystr
SAX2DTM#isWhitespace(int):::Determine if the string-value of a node is whitespace:::identity->makeNodeIdentity->type->if->else->_type->if->isTextType->dataIndex->_dataOrQName->offset->m_data->elementAt->length->m_data->elementAt->return->m_chars->isWhitespace->return
SAX2DTM#getElementById(String):::Returns the Element whose ID is given by elementId:::intObj->isMore->do->m_idAttributes->get->if->return->intObj->intValue->makeNodeHandle->if->break->nextNode->while->return
SAX2DTM#getPrefix(String, String):::Get a prefix either from the qname or from the uri mapping, or just make one up!:::prefix->uriIndex->if->uri->length->do->m_prefixMappings->indexOf->while->if->m_prefixMappings->get->else->if->indexOfNSSep->qname->indexOf->if->qname->equals->else->if->qname->startsWith->qname->substring->else->qname->substring->else->else->if->indexOfNSSep->qname->indexOf->if->if->qname->startsWith->qname->substring->else->qname->substring->else->if->qname->equals->else->else->return
SAX2DTM#getIdForNamespace(String):::Get a prefix either from the uri mapping, or just make one up!:::return->m_valuesOrPrefixes->stringToIndex
SAX2DTM#getNamespaceURI(String):::Get a prefix either from the qname or from the uri mapping, or just make one up!:::uri->prefixIndex->m_contextIndexes->peek->if->do->m_prefixMappings->indexOf->while->if->m_prefixMappings->get->return
SAX2DTM#setIDAttribute(String, int):::Set an ID string to node association in the ID table.:::m_idAttributes->put
SAX2DTM#charactersFlush():::Check whether accumulated text should be stripped; if not, append the appropriate flavor of text/cdata node.:::if->length->m_chars->size->doStrip->if->getShouldStripWhitespace->m_chars->isWhitespace->if->m_chars->setLength->else->if->exName->m_expandedNameTable->getExpandedTypeID->dataIndex->m_data->size->m_parents->peek->addNode->m_data->addElement->m_data->addElement
SAX2DTM#resolveEntity(String, String):::Resolve an external entity:::return
SAX2DTM#notationDecl(String, String, String):::Receive notification of a notation declaration:::
SAX2DTM#unparsedEntityDecl(String, String, String, String):::Receive notification of an unparsed entity declaration:::if->new->ArrayList<>->try->SystemIDResolver->getDocumentBaseURI->getAbsoluteURI->catch->throw->new->SAXException->finally->m_entities->add->m_entities->add->m_entities->add->m_entities->add
SAX2DTM#setDocumentLocator(Locator):::Receive a Locator object for document events:::locator->getSystemId
SAX2DTM#startDocument():::Receive notification of the beginning of the document.:::if->println->doc->m_expandedNameTable->getExpandedTypeID->addNode->m_parents->push->m_contextIndexes->m_prefixMappings->size->push
SAX2DTM#endDocument():::Receive notification of the end of the document.:::if->println->charactersFlush->m_nextsib->setElementAt->if->m_firstch->elementAt->m_firstch->setElementAt->if->m_nextsib->setElementAt
SAX2DTM#startPrefixMapping(String, String):::Receive notification of the start of a Namespace mapping:::if->println->if->m_prefixMappings->add->m_prefixMappings->add
SAX2DTM#endPrefixMapping(String):::Receive notification of the end of a Namespace mapping:::if->println->if->index->m_contextIndexes->peek->do->m_prefixMappings->indexOf->while->if->m_prefixMappings->setElementAt->m_prefixMappings->setElementAt
SAX2DTM#declAlreadyDeclared(String):::Check if a declaration has already been made for a given prefix.:::startDecls->m_contextIndexes->peek->prefixMappings->nDecls->prefixMappings->size->for->i->return
SAX2DTM#startElement(String, String, String, Attributes):::Receive notification of the start of an element:::if->println->DEBUG_ATTRS->if->n->attributes->getLength->if->println->else->for->i->charactersFlush->if->localName->isEmpty->uri->isEmpty->exName->m_expandedNameTable->getExpandedTypeID->prefix->getPrefix->prefixIndex->m_valuesOrPrefixes->stringToIndex->elemNode->m_parents->peek->addNode->if->indexNode->m_parents->push->startDecls->m_contextIndexes->peek->nDecls->m_prefixMappings->size->prev->if->declURL->m_expandedNameTable->getExpandedTypeID->val->m_valuesOrPrefixes->stringToIndex->addNode->for->i->n->attributes->getLength->for->i->if->m_nextsib->setElementAt->if->wsv->m_wsfilter->makeNodeHandle->getShouldStripSpace->shouldStrip->getShouldStripWhitespace->pushShouldStripWhitespace->m_contextIndexes->m_prefixMappings->size->push
SAX2DTM#endElement(String, String, String):::Receive notification of the end of an element:::if->println->charactersFlush->m_contextIndexes->quickPop->topContextIndex->m_contextIndexes->peek->if->m_prefixMappings->size->m_prefixMappings->setSize->lastNode->m_parents->pop->if->m_firstch->setElementAt->else->m_nextsib->setElementAt->popShouldStripWhitespace
SAX2DTM#characters(char[], int, int):::Receive notification of character data inside an element:::if->m_chars->size->else->if->m_chars->append
SAX2DTM#ignorableWhitespace(char[], int, int):::Receive notification of ignorable whitespace in element content:::characters
SAX2DTM#processingInstruction(String, String):::Receive notification of a processing instruction:::if->println->charactersFlush->exName->m_expandedNameTable->getExpandedTypeID->dataIndex->m_valuesOrPrefixes->stringToIndex->m_parents->peek->addNode
SAX2DTM#skippedEntity(String):::Receive notification of a skipped entity:::
SAX2DTM#warning(SAXParseException):::Receive notification of a parser warning:::e->getMessage->println
SAX2DTM#error(SAXParseException):::Receive notification of a recoverable parser error:::throw
SAX2DTM#fatalError(SAXParseException):::Report a fatal XML parsing error:::throw
SAX2DTM#elementDecl(String, String):::Report an element type declaration:::
SAX2DTM#attributeDecl(String, String, String, String, String):::Report an attribute type declaration:::
SAX2DTM#internalEntityDecl(String, String):::Report an internal entity declaration:::
SAX2DTM#externalEntityDecl(String, String, String):::Report a parsed external entity declaration:::
SAX2DTM#startDTD(String, String, String):::Report the start of DTD declarations, if any:::
SAX2DTM#endDTD():::Report the end of DTD declarations.:::
SAX2DTM#startEntity(String):::Report the beginning of an entity in content:::
SAX2DTM#endEntity(String):::Report the end of an entity.:::
SAX2DTM#startCDATA():::Report the start of a CDATA section:::
SAX2DTM#endCDATA():::Report the end of a CDATA section.:::
SAX2DTM#comment(char[], int, int):::Report an XML comment anywhere in the document:::if->return->charactersFlush->exName->m_expandedNameTable->getExpandedTypeID->dataIndex->m_valuesOrPrefixes->new->String->stringToIndex->m_parents->peek->addNode
SAX2DTM#setProperty(String, Object):::Set a run time property for this DTM instance:::
SAX2DTM#getSourceLocatorFor(int):::Retrieve the SourceLocator associated with a specific node:::if->makeNodeIdentity->return->m_sourceSystemId->elementAt->m_sourceLine->elementAt->m_sourceColumn->elementAt->new->NodeLocator->else->if->return->m_locator->getSystemId->new->NodeLocator->else->if->return->new->NodeLocator->return
SAX2DTM#getFixedNames(int)::: x2 m get fixed names:::return
SAX2DTM2.ChildrenIterator#setStartNode(int):::Setting start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch2->return->resetPosition->return
SAX2DTM2.ChildrenIterator#next():::Get the next node in the iteration.:::if->node->_nextsib2->return->makeNodeHandle->returnNode->return
SAX2DTM2.ParentIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->if->makeNodeIdentity->_parent2->else->return->resetPosition->return
SAX2DTM2.ParentIterator#setNodeType(int):::Set the node type of the parent that we're looking for:::return
SAX2DTM2.ParentIterator#next():::Get the next node in the iteration:::result->if->return->if->return->makeNodeHandle->returnNode->else->if->if->_exptype2->return->makeNodeHandle->returnNode->else->if->_type2->return->makeNodeHandle->returnNode->return
SAX2DTM2.TypedChildrenIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->_firstch2->return->resetPosition->return
SAX2DTM2.TypedChildrenIterator#next():::Get the next node in the iteration.:::node->if->return->nodeType->if->while->_exptype2->_nextsib2->else->eType->while->_exptype2->if->break->else->_nextsib2->if->return->else->_nextsib2->return->makeNodeHandle->returnNode
SAX2DTM2.TypedChildrenIterator#getNodeByPosition(int):::Return the node at the given position.:::if->return->node->pos->nodeType->if->while->if->_exptype2->if->return->makeNodeHandle->_nextsib2->return->else->while->if->_exptype2->if->return->makeNodeHandle->_nextsib2->return
SAX2DTM2.TypedRootIterator#next():::Get the next node in the iteration.:::if->return->node->expType->makeNodeIdentity->_exptype2->if->if->return->returnNode->else->if->if->return->returnNode->else->if->getNodeType->return->returnNode->return
SAX2DTM2.FollowingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->return->resetPosition->return
SAX2DTM2.FollowingSiblingIterator#next():::Get the next node in the iteration.:::_nextsib2->return->makeNodeHandle->returnNode
SAX2DTM2.TypedFollowingSiblingIterator#next():::Get the next node in the iteration.:::if->return->node->nodeType->if->while->_nextsib2->_exptype2->else->while->_nextsib2->_exptype2->return->makeNodeHandle->returnNode
SAX2DTM2.AttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->getFirstAttributeIdentity->return->resetPosition->return
SAX2DTM2.AttributeIterator#next():::Get the next node in the iteration.:::node->if->getNextAttributeIdentity->return->makeNodeHandle->returnNode->return
SAX2DTM2.TypedAttributeIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getTypedAttribute->return->resetPosition->return
SAX2DTM2.TypedAttributeIterator#next():::Get the next node in the iteration.:::node->return->returnNode
SAX2DTM2.PrecedingSiblingIterator#isReverse():::True if this iterator has a reversed axis.:::return
SAX2DTM2.PrecedingSiblingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->type->_type2->if->else->_parent2->if->_firstch2->else->return->resetPosition->return
SAX2DTM2.PrecedingSiblingIterator#next():::Get the next node in the iteration.:::if->return->else->node->_nextsib2->return->makeNodeHandle->returnNode
SAX2DTM2.TypedPrecedingSiblingIterator#next():::Get the next node in the iteration.:::node->nodeType->startNodeID->if->while->_exptype2->_nextsib2->else->while->_exptype2->_nextsib2->if->return->else->_nextsib2->return->makeNodeHandle->returnNode
SAX2DTM2.TypedPrecedingSiblingIterator#getLast():::Return the index of the last node in this iterator.:::if->return->setMark->node->nodeType->startNodeID->last->if->while->if->_exptype2->_nextsib2->else->while->if->_exptype2->_nextsib2->gotoMark->return
SAX2DTM2.PrecedingIterator#isReverse():::True if this iterator has a reversed axis.:::return
SAX2DTM2.PrecedingIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->stackCopy->new->intArr->System->arraycopy->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
SAX2DTM2.PrecedingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->parent->index->if->_type2->_parent2->while->_parent2->if->stack->new->intArr->System->arraycopy->if->return->resetPosition->return
SAX2DTM2.PrecedingIterator#next():::Get the next node in the iteration.:::for->return
SAX2DTM2.PrecedingIterator#reset():::Resets the iterator to the last start node.:::return->resetPosition
SAX2DTM2.PrecedingIterator#setMark()::: preceding iterator set mark:::
SAX2DTM2.PrecedingIterator#gotoMark()::: preceding iterator goto mark:::
SAX2DTM2.TypedPrecedingIterator#next():::Get the next node in the iteration.:::node->nodeType->if->while->if->break->else->if->if->break->else->if->_exptype2->break->else->expType->while->if->break->else->if->if->break->else->_exptype2->if->if->break->else->if->getNodeType->break->return->makeNodeHandle->returnNode
SAX2DTM2.FollowingIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->first->type->_type2->if->_parent2->_firstch2->if->makeNodeHandle->return->resetPosition->do->_nextsib2->if->_parent2->while->makeNodeHandle->return->resetPosition->return
SAX2DTM2.FollowingIterator#next():::Get the next node in the iteration.:::node->current->makeNodeIdentity->while->type->_type2->if->return->returnNode->if->continue->makeNodeHandle->return->returnNode
SAX2DTM2.TypedFollowingIterator#next():::Get the next node in the iteration.:::current->node->type->nodeType->currentNodeID->makeNodeIdentity->if->do->do->_type2->while->while->_exptype2->else->do->do->_type2->while->while->_exptype2->_type2->makeNodeHandle->return->makeNodeHandle->returnNode
SAX2DTM2.AncestorIterator#getStartNode():::Get start to END should 'close' the iterator, i.e:::return
SAX2DTM2.AncestorIterator#isReverse():::True if this iterator has a reversed axis.:::return
SAX2DTM2.AncestorIterator#cloneIterator():::Returns a deep copy of this iterator:::try->clone->super->clone->return->catch->throw->XMLMessages->createXMLMessage->new->DTMException->finally
SAX2DTM2.AncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->if->return->if->_parent2->makeNodeHandle->while->if->newAncestors->new->intArr->System->arraycopy->_parent2->makeNodeHandle->return->resetPosition->return
SAX2DTM2.AncestorIterator#reset():::Resets the iterator to the last start node.:::return->resetPosition
SAX2DTM2.AncestorIterator#next():::Get the next node in the iteration.:::next->pos->return->returnNode
SAX2DTM2.AncestorIterator#setMark()::: ancestor iterator set mark:::
SAX2DTM2.AncestorIterator#gotoMark()::: ancestor iterator goto mark:::
SAX2DTM2.TypedAncestorIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->nodeID->makeNodeIdentity->if->return->nodeType->if->_parent2->makeNodeHandle->if->while->eType->_exptype2->if->if->newAncestors->new->intArr->System->arraycopy->makeNodeHandle->_parent2->else->while->eType->_exptype2->if->getNodeType->if->newAncestors->new->intArr->System->arraycopy->makeNodeHandle->_parent2->return->resetPosition->return
SAX2DTM2.TypedAncestorIterator#getNodeByPosition(int):::Return the node at the given position.:::if->return->else->return
SAX2DTM2.TypedAncestorIterator#getLast():::Returns the position of the last node within the iteration, as defined by XPath.:::return
SAX2DTM2.DescendantIterator#setStartNode(int):::Set start to END should 'close' the iterator, i.e:::if->getDocument->if->makeNodeIdentity->if->return->resetPosition->return
SAX2DTM2.DescendantIterator#isDescendant(int):::Tell if this node identity is a descendant:::return->_parent2
SAX2DTM2.DescendantIterator#next():::Get the next node in the iteration.:::startNode->if->return->if->return->makeNodeHandle->returnNode->node->type->if->eType->do->_exptype2->if->return->while->getNodeType->else->do->_type2->if->isDescendant->return->while->return->makeNodeHandle->returnNode
SAX2DTM2.DescendantIterator#reset():::Reset.:::temp->makeNodeHandle->setStartNode->return
SAX2DTM2.TypedDescendantIterator#next():::Get the next node in the iteration.:::startNode->if->return->node->expType->nodeType->if->do->_exptype2->if->_parent2->return->while->else->if->do->_exptype2->if->return->while->getNodeType->else->do->_exptype2->if->_parent2->return->while->getNodeType->return->makeNodeHandle->returnNode
SAX2DTM2.TypedSingletonIterator#next():::Get the next node in the iteration.:::result->if->return->if->if->makeNodeIdentity->_exptype2->return->returnNode->else->if->makeNodeIdentity->_type2->return->returnNode->return
SAX2DTM2#_exptype(int):::Override DTMDefaultBase._exptype() by dropping the incremental code:::return->m_exptype->elementAt
SAX2DTM2#_exptype2(int):::The optimized version of DTMDefaultBase._exptype().:::if->return->else->return
SAX2DTM2#_nextsib2(int):::The optimized version of DTMDefaultBase._nextsib().:::if->return->else->return
SAX2DTM2#_firstch2(int):::The optimized version of DTMDefaultBase._firstch().:::if->return->else->return
SAX2DTM2#_parent2(int):::The optimized version of DTMDefaultBase._parent().:::if->return->else->return
SAX2DTM2#_type2(int):::The optimized version of DTMDefaultBase._type().:::eType->if->else->if->return->getNodeType->else->return
SAX2DTM2#getExpandedTypeID2(int):::The optimized version of DTMDefaultBase.getExpandedTypeID(int):::nodeID->makeNodeIdentity->if->if->return->else->return->else->return
SAX2DTM2#_exptype2Type(int):::Return the node type from the expanded type:::if->return->getNodeType->else->return
SAX2DTM2#getIdForNamespace(String):::Get a prefix either from the uri mapping, or just make one up!:::index->m_values->indexOf->if->m_values->add->return->else->return
SAX2DTM2#startElement(String, String, String, Attributes):::Override SAX2DTM.startElement()  Receive notification of the start of an element:::charactersFlush->if->uri->isEmpty->localName->isEmpty->colon->qName->lastIndexOf->qName->substring->exName->m_expandedNameTable->getExpandedTypeID->prefixIndex->qName->length->localName->length->m_valuesOrPrefixes->stringToIndex->elemNode->m_parents->peek->addNode->if->indexNode->m_parents->push->startDecls->m_contextIndexes->peek->nDecls->m_prefixMappings->size->prefix->if->declURL->m_expandedNameTable->getExpandedTypeID->m_values->add->val->addNode->for->i->n->attributes->getLength->for->i->if->wsv->m_wsfilter->makeNodeHandle->getShouldStripSpace->shouldStrip->getShouldStripWhitespace->pushShouldStripWhitespace->m_contextIndexes->m_prefixMappings->size->push
SAX2DTM2#endElement(String, String, String):::Receive notification of the end of an element:::charactersFlush->m_contextIndexes->quickPop->topContextIndex->m_contextIndexes->peek->if->m_prefixMappings->size->m_prefixMappings->setSize->m_parents->pop->popShouldStripWhitespace
SAX2DTM2#comment(char[], int, int):::Report an XML comment anywhere in the document:::if->return->charactersFlush->m_values->new->String->add->dataIndex->m_parents->peek->addNode
SAX2DTM2#startDocument():::Receive notification of the beginning of the document.:::doc->addNode->m_parents->push->m_contextIndexes->m_prefixMappings->size->push
SAX2DTM2#endDocument():::Receive notification of the end of the document.:::super->endDocument->m_exptype->addElement->m_parent->addElement->m_nextsib->addElement->m_firstch->addElement->m_expandedNameTable->getExtendedTypes->m_exptype->getMap->m_nextsib->getMap->m_firstch->getMap->m_parent->getMap
SAX2DTM2#addNode(int, int, int, int, int, boolean):::Construct the node map from the node.:::nodeIndex->if->addNewDTMID->m_firstch->addElement->m_nextsib->addElement->m_parent->addElement->m_exptype->addElement->m_dataOrQName->addElement->if->m_prevsib->addElement->if->setSourceLocation->switch->declareNamespaceInContext->break->break->if->m_nextsib->setElementAt->else->if->m_firstch->setElementAt->break->return
SAX2DTM2#charactersFlush():::Check whether accumulated text should be stripped; if not, append the appropriate flavor of text/cdata node.:::if->length->m_chars->size->doStrip->if->getShouldStripWhitespace->m_chars->isWhitespace->if->m_chars->setLength->else->if->if->m_parents->peek->addNode->else->dataIndex->m_data->size->m_parents->peek->addNode->m_data->addElement->m_data->addElement
SAX2DTM2#processingInstruction(String, String):::Override the processingInstruction() interface in SAX2DTM2:::charactersFlush->dataIndex->m_data->size->m_parents->peek->addNode->m_data->m_valuesOrPrefixes->stringToIndex->addElement->m_values->add->m_data->addElement
SAX2DTM2#getFirstAttribute(int):::The optimized version of DTMDefaultBase.getFirstAttribute():::nodeID->makeNodeIdentity->if->return->type->_type2->if->while->_type2->if->return->makeNodeHandle->else->if->break->return
SAX2DTM2#getFirstAttributeIdentity(int):::The optimized version of DTMDefaultBase.getFirstAttributeIdentity(int):::if->return->type->_type2->if->while->_type2->if->return->else->if->break->return
SAX2DTM2#getNextAttributeIdentity(int):::The optimized version of DTMDefaultBase.getNextAttributeIdentity(int):::while->type->_type2->if->return->else->if->break->return
SAX2DTM2#getTypedAttribute(int, int):::The optimized version of DTMDefaultBase.getTypedAttribute(int, int):::nodeID->makeNodeIdentity->if->return->type->_type2->if->expType->while->_exptype2->if->getNodeType->else->return->if->if->return->makeNodeHandle->else->if->break->return
SAX2DTM2#getLocalName(int):::Override SAX2DTM.getLocalName() in SAX2DTM2:::expType->makeNodeIdentity->_exptype->if->dataIndex->makeNodeIdentity->_dataOrQName->m_data->elementAt->return->m_valuesOrPrefixes->indexToString->else->return->m_expandedNameTable->getLocalName
SAX2DTM2#getNodeNameX(int):::The optimized version of SAX2DTM.getNodeNameX():::nodeID->makeNodeIdentity->eType->_exptype2->if->dataIndex->_dataOrQName->m_data->elementAt->return->m_valuesOrPrefixes->indexToString->extType->if->extType->getNamespace->length->return->extType->getLocalName->else->qnameIndex->m_dataOrQName->elementAt->if->return->extType->getLocalName->if->m_data->elementAt->return->m_valuesOrPrefixes->indexToString
SAX2DTM2#getNodeName(int):::The optimized version of SAX2DTM.getNodeName():::nodeID->makeNodeIdentity->eType->_exptype2->extType->if->extType->getNamespace->length->type->extType->getNodeType->localName->extType->getLocalName->if->if->localName->length->return->else->return->else->if->dataIndex->_dataOrQName->m_data->elementAt->return->m_valuesOrPrefixes->indexToString->else->if->localName->length->return->getFixedNames->else->return->else->qnameIndex->m_dataOrQName->elementAt->if->return->extType->getLocalName->if->m_data->elementAt->return->m_valuesOrPrefixes->indexToString
SAX2DTM2#getStringValue(int):::Override SAX2DTM.getStringValue(int)  This method is only used by Xalan-J Interpretive:::identity->makeNodeIdentity->if->return->type->_type2->if->startNode->_firstch2->if->offset->length->do->_exptype2->if->dataIndex->m_dataOrQName->elementAt->if->if->else->if->m_data->elementAt->m_data->elementAt->while->_parent2->if->if->return->m_xstrf->newstr->else->return->m_chars->getString->new->XMLStringDefault->else->return->else->return->else->if->dataIndex->m_dataOrQName->elementAt->if->if->return->m_xstrf->newstr->else->return->m_chars->getString->new->XMLStringDefault->else->if->return->m_xstrf->m_data->elementAt->m_data->elementAt->newstr->else->return->m_chars->m_data->elementAt->m_data->elementAt->getString->new->XMLStringDefault->else->dataIndex->m_dataOrQName->elementAt->if->m_data->elementAt->if->return->m_xstrf->m_values->get->newstr->else->return->m_values->get->new->XMLStringDefault
SAX2DTM2#getStringValueX(int):::The optimized version of SAX2DTM.getStringValue(int):::identity->makeNodeIdentity->if->return->type->_type2->if->startNode->_firstch2->if->offset->length->do->_exptype2->if->dataIndex->m_dataOrQName->elementAt->if->if->else->if->m_data->elementAt->m_data->elementAt->while->_parent2->if->return->m_chars->getString->else->return->else->return->else->if->dataIndex->m_dataOrQName->elementAt->if->return->m_chars->getString->else->return->m_chars->m_data->elementAt->m_data->elementAt->getString->else->dataIndex->m_dataOrQName->elementAt->if->m_data->elementAt->return->m_values->get
SAX2DTM2#getStringValue():::Returns the string value of the entire tree:::child->_firstch2->if->return->if->_exptype2->_nextsib2->dataIndex->m_dataOrQName->elementAt->if->return->m_chars->getString->else->return->m_chars->m_data->elementAt->m_data->elementAt->getString->else->return->getDocument->getStringValueX
SAX2DTM2#dispatchCharactersEvents(int, ContentHandler, boolean):::The optimized version of SAX2DTM.dispatchCharactersEvents(int, ContentHandler, boolean):::identity->makeNodeIdentity->if->return->type->_type2->if->startNode->_firstch2->if->offset->length->do->_exptype2->if->dataIndex->m_dataOrQName->elementAt->if->if->else->if->m_data->elementAt->m_data->elementAt->while->_parent2->if->if->m_chars->sendNormalizedSAXcharacters->else->m_chars->sendSAXcharacters->else->if->dataIndex->m_dataOrQName->elementAt->if->if->m_chars->sendNormalizedSAXcharacters->else->m_chars->sendSAXcharacters->else->if->m_chars->m_data->elementAt->m_data->elementAt->sendNormalizedSAXcharacters->else->m_chars->m_data->elementAt->m_data->elementAt->sendSAXcharacters->else->dataIndex->m_dataOrQName->elementAt->if->m_data->elementAt->str->m_values->get->if->FastStringBuffer->str->toCharArray->str->length->sendNormalizedSAXcharacters->else->ch->str->toCharArray->str->length->characters
SAX2DTM2#getNodeValue(int):::Given a node handle, return its node value:::identity->makeNodeIdentity->type->_type2->if->dataIndex->_dataOrQName->if->return->m_chars->getString->else->return->m_chars->m_data->elementAt->m_data->elementAt->getString->else->if->return->else->dataIndex->m_dataOrQName->elementAt->if->m_data->elementAt->return->m_values->get
SAX2DTM2#copyTextNode(int, SerializationHandler):::Copy the String value of a Text node to a SerializationHandler:::if->dataIndex->m_dataOrQName->elementAt->if->m_chars->sendSAXcharacters->else->m_chars->m_data->elementAt->m_data->elementAt->sendSAXcharacters
SAX2DTM2#copyElement(int, int, SerializationHandler):::Copy an Element node to a SerializationHandler.:::extType->uri->extType->getNamespace->name->extType->getLocalName->if->uri->length->handler->startElement->return->else->qnameIndex->m_dataOrQName->elementAt->if->handler->startElement->handler->namespaceAfterStartElement->return->if->m_data->elementAt->qName->m_valuesOrPrefixes->indexToString->handler->startElement->prefixIndex->qName->indexOf->prefix->if->qName->substring->else->handler->namespaceAfterStartElement->return
SAX2DTM2#copyNS(int, SerializationHandler, boolean):::Copy  namespace nodes.:::if->m_namespaceDeclSetElements->size->m_namespaceDeclSets->get->size->return->nsContext->nextNSNode->if->findNamespaceContext->if->nsContext->size->return->else->nsContext->elementAt->makeNodeIdentity->else->getNextNamespaceNode2->nsIndex->while->eType->_exptype2->nodeName->getLocalName->dataIndex->m_dataOrQName->elementAt->if->m_data->elementAt->nodeValue->m_values->get->handler->namespaceAfterStartElement->if->if->nsContext->size->nsContext->elementAt->makeNodeIdentity->else->return->else->getNextNamespaceNode2
SAX2DTM2#getNextNamespaceNode2(int):::Return the next namespace node following the given base node.:::type->while->_type2->if->return->else->return
SAX2DTM2#copyAttributes(int, SerializationHandler):::Copy  attribute nodes from an element .:::for->current->getFirstAttributeIdentity->getNextAttributeIdentity
SAX2DTM2#copyAttribute(int, int, SerializationHandler):::Copy an Attribute node to a SerializationHandler:::extType->uri->extType->getNamespace->localName->extType->getLocalName->prefix->qname->dataIndex->_dataOrQName->valueIndex->if->prefixIndex->m_data->elementAt->m_data->elementAt->m_valuesOrPrefixes->indexToString->colonIndex->qname->indexOf->if->qname->substring->if->uri->length->handler->namespaceAfterStartElement->nodeName->nodeValue->m_values->get->handler->addAttribute
SAX2RTFDTM#getDocument():::Given a DTM, find the owning document node:::return->makeNodeHandle
SAX2RTFDTM#getDocumentRoot(int):::Given a node handle, find the owning document node, using DTM semantics (Document owns itself) rather than DOM semantics (Document has no owner):::for->id->makeNodeIdentity->_parent->return
SAX2RTFDTM#_documentRoot(int):::Given a node identifier, find the owning document node:::if->return->for->parent->_parent->_parent->return
SAX2RTFDTM#startDocument():::Receive notification of the beginning of a new RTF document:::new->Vector<>->new->IntStack->new->IntStack->super->startDocument
SAX2RTFDTM#endDocument():::Receive notification of the end of the document:::charactersFlush->m_nextsib->setElementAt->if->m_firstch->elementAt->m_firstch->setElementAt->if->m_nextsib->setElementAt
SAX2RTFDTM#pushRewindMark():::"Tail-pruning" support for RTFs:::if->throw->new->java.lang.NullPointerException->mark_size->push->mark_nsdeclset_size->m_namespaceDeclSets->size->push->mark_nsdeclelem_size->m_namespaceDeclSetElements->size->push->mark_data_size->m_data->size->push->mark_char_size->m_chars->size->push->mark_doq_size->m_dataOrQName->size->push
SAX2RTFDTM#popRewindMark():::"Tail-pruning" support for RTFs:::top->mark_size->empty->mark_size->pop->m_exptype->setSize->m_firstch->setSize->m_nextsib->setSize->m_prevsib->setSize->m_parent->setSize->ds->mark_nsdeclset_size->pop->if->m_namespaceDeclSets->setSize->ds1->mark_nsdeclelem_size->pop->if->m_namespaceDeclSetElements->setSize->m_data->mark_data_size->pop->setSize->m_chars->mark_char_size->pop->setLength->m_dataOrQName->mark_doq_size->pop->setSize->return
SAX2RTFDTM#isTreeIncomplete()::: x2 m is tree incomplete:::return
