ClassFile#internalize(byte[], int, int):::Return internal representation of buf[offset..offset+len-1], converting '/' to '.':::translated->new->byteArr->for->j->return
ClassFile#internalize(Name):::Return internal representation of given name, converting '/' to '.':::return->name->getByteArray->name->getByteOffset->name->getByteLength->internalize
ClassFile#externalize(byte[], int, int):::Return external representation of buf[offset..offset+len-1], converting '.' to '/':::translated->new->byteArr->for->j->return
ClassFile#externalize(Name):::Return external representation of given name, converting '/' to '.':::return->name->getByteArray->name->getByteOffset->name->getByteLength->externalize
ClassReader#instance(Context):::Get the ClassReader instance for this invocation.:::instance->context->get->if->new->ClassReader->return
ClassReader#nextChar():::Read a character.:::return
ClassReader#nextByte():::Read a byte.:::return
ClassReader#nextInt():::Read an integer.:::return
ClassReader#getChar(int):::Extract a character at position bp from buf.:::return
ClassReader#getInt(int):::Extract an integer at position bp from buf.:::return
ClassReader#getLong(int):::Extract a long integer at position bp from buf.:::bufin->new->ByteArrayInputStream->new->DataInputStream->try->return->bufin->readLong->catch->throw->new->AssertionError->finally
ClassReader#getFloat(int):::Extract a float at position bp from buf.:::bufin->new->ByteArrayInputStream->new->DataInputStream->try->return->bufin->readFloat->catch->throw->new->AssertionError->finally
ClassReader#getDouble(int):::Extract a double at position bp from buf.:::bufin->new->ByteArrayInputStream->new->DataInputStream->try->return->bufin->readDouble->catch->throw->new->AssertionError->finally
ClassReader#indexPool():::Index all constant pool entries, writing their start addresses into  poolIdx.:::nextChar->new->intArr->new->ObjectArr->i->while->tag->switch->len->nextChar->break->break->break->break->break->throw->Byte->toString->Integer->toString->badClassFile
ClassReader#readPool(int):::Read constant pool entry at start address i, use pool as a cache.:::result->if->return->index->if->return->tag->switch->names->getChar->fromUtf->break->throw->badClassFile->getChar->readClassOrType->break->getChar->readName->toString->break->owner->getChar->readClassSymbol->nt->getChar->readNameAndType->new->VarSymbol->break->owner->getChar->readClassSymbol->nt->getChar->readNameAndType->new->MethodSymbol->break->getChar->readName->getChar->readType->new->NameAndType->break->getInt->break->Float->getFloat->valueOf->break->Long->getLong->valueOf->break->Double->getDouble->valueOf->break->skipBytes->break->skipBytes->break->skipBytes->break->getChar->readName->break->throw->Byte->toString->badClassFile->return
ClassReader#readType(int):::Read signature and convert to type.:::index->return->getChar->sigToType
ClassReader#readClassOrType(int):::If name is an array type or class signature, return the  corresponding type; otherwise return a ClassSymbol with given name.:::index->len->getChar->start->Assert->check->return->sigToType->names->internalize->fromUtf->enterClass
ClassReader#readTypeParams(int):::Read signature and convert to type parameters.:::index->return->getChar->sigToTypeParams
ClassReader#readClassSymbol(int):::Read class entry.:::obj->readPool->if->throw->currentClassFile->toString->badClassFile->return
ClassReader#readName(int):::Read name.:::obj->readPool->if->throw->currentClassFile->toString->badClassFile->return
ClassReader#readNameAndType(int):::Read name and type.:::obj->readPool->if->throw->currentClassFile->toString->badClassFile->return
ClassReader#readModuleName(int):::Read the name of a module:::return->readName
ClassReader#readModuleFlags(int):::Read module_flags.:::set->EnumSet->noneOf->foreach->ModuleFlags->values->if->set->add->return
ClassReader#readModuleResolutionFlags(int):::Read resolution_flags.:::set->EnumSet->noneOf->foreach->ModuleResolutionFlags->values->if->set->add->return
ClassReader#readExportsFlags(int):::Read exports_flags.:::set->EnumSet->noneOf->foreach->ExportsFlag->values->if->set->add->return
ClassReader#readOpensFlags(int):::Read opens_flags.:::set->EnumSet->noneOf->foreach->OpensFlag->values->if->set->add->return
ClassReader#readRequiresFlags(int):::Read requires_flags.:::set->EnumSet->noneOf->foreach->RequiresFlag->values->if->set->add->return
ClassReader#sigToType(byte[], int, int):::Convert signature to type, where signature is a byte array segment.:::return->sigToType
ClassReader#sigToType():::Convert signature to type, where signature is implicit.:::switch->start->while->return->names->fromUtf->findTypeVar->t->sigToType->return->new->WildcardType->return->new->WildcardType->t->sigToType->return->new->WildcardType->return->return->return->return->return->return->t->classSigToType->if->throw->badClassFile->return->return->return->return->return->sigToType->new->ArrayType->argtypes->sigToTypes->restype->sigToType->thrown->List->nil->while->thrown->sigToType->prepend->for->l->l->nonEmpty->return->thrown->reverse->new->MethodType->typevars->dup->poly->sigToTypeParams->sigToType->new->ForAll->typevars->leave->return->throw->Convert->utf2string->badClassFile
ClassReader#classSigToType():::Convert class signature to type, where signature is implicit.:::if->throw->Convert->utf2string->badClassFile->outer->startSbp->while->c->switch->t->names->fromUtf->enterClass->try->return->t->erasure->List->nil->new->ClassType->catch->finally->t->names->fromUtf->enterClass->sigToTypes->new->ClassType->switch->if->break->else->return->break->throw->new->AssertionError->continue->if->names->fromUtf->enterClass->List->nil->new->ClassType->continue->continue->continue
ClassReader#sigToTypes(char):::Convert (implicit) signature to list of types  until `terminator' is encountered.:::head->List->of->tail->while->tail->List->sigToType->of->setTail->return
ClassReader#sigToTypeParams(byte[], int, int):::Convert signature to type parameters, where signature is a byte  array segment.:::return->sigToTypeParams
ClassReader#sigToTypeParams():::Convert signature to type parameters, where signature is implicit.:::tvars->List->nil->if->start->while->tvars->sigToTypeParam->prepend->while->sigToTypeParam->return->tvars->reverse
ClassReader#sigToTypeParam():::Convert (implicit) signature to type parameter.:::start->while->name->names->fromUtf->tvar->if->new->TypeVar->typevars->enter->else->findTypeVar->bounds->List->nil->allInterfaces->if->while->bounds->sigToType->prepend->if->types->bounds->reverse->setBounds->return
ClassReader#findTypeVar(Name):::Find type variable with given name in `typevars' scope.:::s->typevars->findFirst->if->return->else->if->t->new->TypeVar->missingTypeVariables->prepend->return->throw->badClassFile
ClassReader#readMemberAttrs(Symbol):::Read member attributes.:::readAttrs
ClassReader#readClassAttrs(ClassSymbol):::Read class attributes.:::readAttrs
ClassReader#readCode(Symbol):::Read code block.:::nextChar->nextChar->code_length->nextInt->exception_table_length->nextChar->readMemberAttrs->return
ClassReader#readAnnotations():::Save annotations.:::numAttributes->nextChar->annotations->new->ListBuffer<>->for->i->return->annotations->toList
ClassReader#attachAnnotations(Symbol):::Attach annotations.:::readAnnotations->attachAnnotations
ClassReader#attachAnnotations(Symbol, List):::Attach annotations.:::if->annotations->isEmpty->return->proxies->new->ListBuffer<>->foreach->if->else->if->if->foreach->if->c->if->else->if->else->if->else->if->foreach->if->c->if->proxies->append->annotate->proxies->toList->new->AnnotationCompleter->normal
ClassReader#readParameterAnnotations(Symbol):::Read parameter annotations.:::numParameters->if->new->ParameterAnnotationsArr->else->if->throw->badClassFile->for->pnum
ClassReader#attachAnnotationDefault(Symbol):::Attach the default value for an annotation element.:::meth->value->readAttributeValue->annotate->new->AnnotationDefaultCompleter->normal
ClassReader#readField():::Read a field.:::flags->nextChar->adjustFieldFlags->name->nextChar->readName->type->nextChar->readType->v->new->VarSymbol->readMemberAttrs->return
ClassReader#readMethod():::Read a method.:::flags->nextChar->adjustMethodFlags->name->nextChar->readName->type->nextChar->readType->if->currentOwner->isInterface->name->equals->if->if->else->throw->Integer->toString->Integer->toString->badClassFile->if->currentOwner->hasOuterInstance->local->members->includes->if->isEmpty->type->getParameterTypes->adjustMethodParams->type->getReturnType->type->getThrownTypes->new->MethodType->m->new->MethodSymbol->if->types->isSignaturePolymorphic->if->initParameterNames->prevOwner->try->readMemberAttrs->catch->finally->setParameters->if->last->type->getParameterTypes->last->if->last->hasTag->throw->badClassFile->return
ClassReader#initParameterNames(MethodSymbol):::Init the parameter names array:::excessSlots->expectedParameterSlots->Code->getParameterTypes->width->if->new->intArr->else->Arrays->fill
ClassReader#setParameters(MethodSymbol, Type):::Set the parameters for a method symbol, including any names and annotations that were read:::firstParam->if->sym->flags->if->currentOwner->hasOuterInstance->if->isEmpty->if->skip->Code->jvmType->getParameterTypes->width->Code->getParameterTypes->width->paramNames->List->nil->params->new->ListBuffer<>->nameIndex->annotationIndex->foreach->getParameterTypes->name->parameterName->paramNames->prepend->param->new->VarSymbol->params->append->if->annotations->if->isEmpty->annotate->new->AnnotationCompleter->normal->Code->width->if->throw->badClassFile->Assert->checkNull->params->toList
ClassReader#skipBytes(int):::skip n bytes:::
ClassReader#skipMember():::Skip a field or method:::ac->nextChar->for->i
ClassReader#enterTypevars(Symbol, Type):::Enter type variables of this classtype and all enclosing ones in  `typevars'.:::if->t->getEnclosingType->if->t->getEnclosingType->hasTag->t->getEnclosingType->enterTypevars->else->if->sym->isStatic->enterTypevars->for->xs->t->getTypeArguments->xs->nonEmpty
ClassReader#readClass(ClassSymbol):::Read contents of a given class symbol `c':::ct->WriteableScope->create->typevars->dup->if->ct->getEnclosingType->hasTag->ct->getEnclosingType->enterTypevars->f->nextChar->flags->adjustClassFlags->if->if->c->packge->self->nextChar->readClassSymbol->if->throw->badClassFile->else->if->throw->Integer->toString->Integer->toString->badClassFile->this_class->nextChar->startbp->nextChar->interfaceCount->nextChar->fieldCount->nextChar->for->i->methodCount->nextChar->for->i->readClassAttrs->if->for->i->new->Pool->n->nextChar->if->throw->badClassFile->if->readClassSymbol->erasure->nextChar->is->List->nil->for->i->if->is->reverse->Assert->nextChar->check->for->i->Assert->nextChar->check->for->i->typevars->leave
ClassReader#readInnerClasses(ClassSymbol):::Read inner class info:::n->nextChar->for->i
ClassWriter#instance(Context):::Get the ClassWriter instance for this context.:::instance->context->get->if->new->ClassWriter->return
ClassWriter#flagNames(long):::Return flags as a string, separated by " ".:::sbuf->new->StringBuilder->i->f->while->if->sbuf->append->sbuf->append->return->sbuf->toString
ClassWriter#putChar(ByteBuffer, int, int):::Write a character into given byte buffer;  byte buffer will not be grown.:::
ClassWriter#putInt(ByteBuffer, int, int):::Write an integer into given byte buffer;  byte buffer will not be grown.:::
ClassWriter#typeSig(Type):::Return signature of given type:::Assert->signatureGen->isEmpty->check->signatureGen->assembleSig->n->signatureGen->toName->signatureGen->reset->return
ClassWriter#xClassName(Type):::Given a type t, return the extended class name of its erasure in  external representation.:::if->t->hasTag->return->names->flatName->externalize->fromUtf->else->if->t->hasTag->return->types->erasure->typeSig->else->throw->new->AssertionError
ClassWriter#writePool(Pool):::Write constant pool to pool buffer:::poolCountIdx->poolbuf->appendChar->i->while->value->Assert->checkNonNull->if->getUnderlyingSymbol->if->m->if->m->isDynamic->poolbuf->flags->appendByte->poolbuf->pool->put->appendChar->poolbuf->pool->nameType->put->appendChar->else->dynSym->handle->new->MethodHandle->key->new->DynamicMethod.BootstrapMethodsKey->val->bootstrapMethods->get->if->index->bootstrapMethods->size->new->DynamicMethod.BootstrapMethodsValue->bootstrapMethods->put->pool->put->pool->put->foreach->pool->put->poolbuf->appendByte->poolbuf->appendChar->poolbuf->pool->nameType->put->appendChar->else->if->v->poolbuf->appendByte->poolbuf->pool->put->appendChar->poolbuf->pool->nameType->put->appendChar->else->if->poolbuf->appendByte->bs->toUtf->poolbuf->appendChar->poolbuf->appendBytes->if->throw->value->toString->new->StringOverflow->else->if->c->if->pool->put->poolbuf->appendByte->if->hasTag->poolbuf->pool->typeSig->put->appendChar->else->poolbuf->pool->names->externalize->fromUtf->put->appendChar->enterInner->else->if->nt->poolbuf->appendByte->poolbuf->pool->put->appendChar->poolbuf->pool->typeSig->put->appendChar->else->if->poolbuf->appendByte->poolbuf->intValue->appendInt->else->if->poolbuf->appendByte->poolbuf->longValue->appendLong->else->if->poolbuf->appendByte->poolbuf->floatValue->appendFloat->else->if->poolbuf->appendByte->poolbuf->doubleValue->appendDouble->else->if->poolbuf->appendByte->poolbuf->pool->names->fromString->put->appendChar->else->if->type->if->type->hasTag->poolbuf->appendByte->poolbuf->pool->typeSig->put->appendChar->else->Assert->type->hasTag->check->poolbuf->appendByte->poolbuf->pool->xClassName->put->appendChar->else->if->ref->poolbuf->appendByte->poolbuf->appendByte->poolbuf->pool->put->appendChar->else->if->m->poolbuf->appendByte->poolbuf->pool->put->appendChar->else->if->m->poolbuf->appendByte->poolbuf->pool->names->externalize->fromUtf->put->appendChar->else->Assert->error->if->throw->new->PoolOverflow->putChar
ClassWriter#nameType(Symbol):::Given a symbol, return its name-and-type.:::return->sym->externalType->new->NameAndType
ClassWriter#writeAttr(Name):::Write header for an attribute to data buffer and return  position past attribute length index.:::databuf->pool->put->appendChar->databuf->appendInt->return
ClassWriter#endAttr(int):::Fill in attribute length.:::putInt
ClassWriter#beginAttrs():::Leave space for attribute count and return index for  number of attributes field.:::databuf->appendChar->return
ClassWriter#endAttrs(int, int):::Fill in number of attributes.:::putChar
ClassWriter#writeEnclosingMethodAttribute(ClassSymbol):::Write the EnclosingMethod attribute if needed:::return->writeEnclosingMethodAttribute
ClassWriter#writeEnclosingMethodAttribute(Name, ClassSymbol):::Write the EnclosingMethod attribute with a specified name:::if->return->alenIdx->writeAttr->enclClass->enclClass->enclMethod->databuf->pool->put->appendChar->databuf->pool->nameType->put->appendChar->endAttr->return
ClassWriter#writeFlagAttrs(long):::Write flag attributes; return number of attributes written.:::acount->if->alenIdx->writeAttr->endAttr->return
ClassWriter#writeMemberAttrs(Symbol):::Write member (field or method) attributes;  return number of attributes written.:::acount->sym->flags->writeFlagAttrs->flags->sym->flags->if->types->sym->erasure->isSameType->signatureGen->getThrownTypes->hasTypeVar->alenIdx->writeAttr->databuf->pool->typeSig->put->appendChar->endAttr->sym->getRawAttributes->writeJavaAnnotations->sym->getRawTypeAttributes->writeTypeAnnotations->return
ClassWriter#writeMethodParametersAttr(MethodSymbol):::Write method parameter names attribute.:::ty->m->externalType->asMethodType->allparams->size->if->attrIndex->writeAttr->databuf->appendByte->foreach->flags->s->flags->m->flags->databuf->pool->put->appendChar->databuf->appendChar->foreach->flags->s->flags->m->flags->databuf->pool->put->appendChar->databuf->appendChar->foreach->flags->s->flags->m->flags->databuf->pool->put->appendChar->databuf->appendChar->endAttr->return->else->return
ClassWriter#writeParameterAttrs(MethodSymbol):::Write method parameter annotations;  return number of attributes written.:::hasVisible->hasInvisible->if->foreach->foreach->s->getRawAttributes->switch->types->getRetention->break->break->break->attrCount->if->attrIndex->writeAttr->writeParamAnnotations->endAttr->if->attrIndex->writeAttr->writeParamAnnotations->endAttr->return
ClassWriter#writeJavaAnnotations(List):::Write Java-language annotations; return number of JVM  attributes written (zero or one).:::if->attrs->isEmpty->return->visibles->new->ListBuffer<>->invisibles->new->ListBuffer<>->foreach->switch->types->getRetention->break->invisibles->append->break->visibles->append->break->attrCount->if->visibles->length->attrIndex->writeAttr->databuf->visibles->length->appendChar->foreach->writeCompoundAttribute->endAttr->if->invisibles->length->attrIndex->writeAttr->databuf->invisibles->length->appendChar->foreach->writeCompoundAttribute->endAttr->return
ClassWriter#writeCompoundAttribute(Attribute.Compound):::Write a compound attribute excluding the '@' marker.:::databuf->pool->typeSig->put->appendChar->databuf->length->appendChar->foreach->databuf->pool->put->appendChar->accept
ClassWriter#writeModuleAttribute(ClassSymbol):::Write the Module attribute if needed:::m->alenIdx->writeAttr->databuf->pool->put->appendChar->databuf->ModuleFlags->value->appendChar->databuf->pool->put->appendChar->requires->new->ListBuffer<>->foreach->if->contains->requires->add->databuf->requires->size->appendChar->foreach->databuf->pool->put->appendChar->databuf->RequiresFlag->value->appendChar->databuf->pool->put->appendChar->exports->databuf->exports->size->appendChar->foreach->databuf->pool->put->appendChar->databuf->ExportsFlag->value->appendChar->if->databuf->appendChar->else->databuf->size->appendChar->foreach->databuf->pool->put->appendChar->opens->databuf->opens->size->appendChar->foreach->databuf->pool->put->appendChar->databuf->OpensFlag->value->appendChar->if->databuf->appendChar->else->databuf->size->appendChar->foreach->databuf->pool->put->appendChar->uses->databuf->uses->size->appendChar->foreach->databuf->pool->put->appendChar->mergedProvides->new->LinkedHashMap<>->foreach->mergedProvides->new->LinkedHashSet<>->computeIfAbsent->addAll->databuf->mergedProvides->size->appendChar->mergedProvides->databuf->pool->put->appendChar->databuf->impls->size->appendChar->impls->databuf->pool->put->appendChar->forEach->forEach->endAttr->return
ClassWriter#enterInner(ClassSymbol):::Enter an inner class into the `innerClasses' set/queue.:::if->isCompound->throw->new->AssertionError->try->c->complete->catch->ex->getMessage->println->throw->finally->if->hasTag->return->if->enclClass->innerClasses->contains->enclClass->enterInner->pool->put->if->pool->put->if->new->HashSet<>->new->ListBuffer<>->pool->put->innerClasses->add->innerClassesQueue->append
ClassWriter#writeInnerClasses():::Write "inner classes" attribute.:::alenIdx->writeAttr->databuf->innerClassesQueue->length->appendChar->for->l->innerClassesQueue->toList->l->nonEmpty->endAttr
ClassWriter#writeNestMembersIfNeeded(ClassSymbol):::Write NestMembers attribute (if needed):::nested->new->ListBuffer<>->listNested->nestedUnique->new->LinkedHashSet<>->if->nestedUnique->isEmpty->alenIdx->writeAttr->databuf->nestedUnique->size->appendChar->foreach->databuf->pool->put->appendChar->endAttr->return->return
ClassWriter#writeNestHostIfNeeded(ClassSymbol):::Write NestHost attribute (if needed):::if->alenIdx->writeAttr->databuf->pool->csym->outermostClass->put->appendChar->endAttr->return->return
ClassWriter#writeBootstrapMethods():::Write "bootstrapMethods" attribute.:::alenIdx->writeAttr->databuf->bootstrapMethods->size->appendChar->foreach->bootstrapMethods->entrySet->bsmKey->entry->getKey->databuf->pool->entry->getValue->get->appendChar->uniqueArgs->bsmKey->getUniqueArgs->databuf->appendChar->foreach->databuf->pool->get->appendChar->endAttr
ClassWriter#writeField(VarSymbol):::Write field symbol, entering all references into constant pool.:::flags->v->flags->adjustFlags->databuf->appendChar->if->pw->log->getWriter->pw->println->pw->v->flags->flagNames->println->databuf->pool->put->appendChar->databuf->pool->v->erasure->typeSig->put->appendChar->acountIdx->beginAttrs->acount->if->v->getConstValue->alenIdx->writeAttr->databuf->pool->v->getConstValue->put->appendChar->endAttr->writeMemberAttrs->endAttrs
ClassWriter#writeMethod(MethodSymbol):::Write method symbol, entering all references into constant pool.:::flags->m->flags->adjustFlags->databuf->appendChar->if->pw->log->getWriter->pw->println->pw->m->flags->flagNames->println->databuf->pool->put->appendChar->databuf->pool->m->externalType->typeSig->put->appendChar->acountIdx->beginAttrs->acount->if->alenIdx->writeAttr->writeCode->endAttr->thrown->m->erasure->getThrownTypes->if->thrown->nonEmpty->alenIdx->writeAttr->databuf->thrown->length->appendChar->for->l->l->nonEmpty->endAttr->if->alenIdx->writeAttr->accept->endAttr->if->options->isSet->target->hasMethodParameters->if->m->isLambdaMethod->writeMethodParametersAttr->writeMemberAttrs->if->m->isLambdaMethod->writeParameterAttrs->endAttrs
ClassWriter#writeCode(Code):::Write code attribute of method.:::databuf->appendChar->databuf->appendChar->databuf->appendInt->databuf->appendBytes->databuf->length->appendChar->for->l->toList->l->nonEmpty->acountIdx->beginAttrs->acount->if->nonEmpty->alenIdx->writeAttr->databuf->length->appendChar->for->l->reverse->l->nonEmpty->endAttr->if->crt->alenIdx->writeAttr->crtIdx->beginAttrs->crtEntries->crt->writeCRT->endAttrs->endAttr->if->nGenericVars->alenIdx->writeAttr->databuf->code->getLVTSize->appendChar->for->i->endAttr->if->writeAttr->databuf->appendChar->count->for->i->Assert->check->endAttr->if->if->println->alenIdx->getAttributeName->writeAttr->writeStackMap->endAttr->getRawTypeAttributes->writeTypeAnnotations->endAttrs
ClassWriter.StackMapTableFrame#getInstance(Code.StackMapFrame, int, Type[], Types):::Compare this frame with the previous frame and produce  an entry of compressed stack map frame.:::locals->stack->offset_delta->if->if->compare->return->new->SameLocals1StackItemFrame->else->if->diff_length->compare->if->return->new->SameFrame->else->if->local_diff->new->TypeArr->for->i->j->return->new->AppendFrame->else->if->return->new->ChopFrame->return->new->FullFrame
ClassWriter#writeClass(ClassSymbol):::Emit a class file for a given class.:::name->toString->outLocn->if->msym->c->packge->fileManager->toString->getLocationForModule->else->outFile->fileManager->getJavaFileForOutput->out->outFile->openOutputStream->try->writeClassFile->if->log->outFile->getName->printVerbose->out->close->catch->log->Errors->Fragments->ex->type->IllegalSignature->CannotGenerateClass->error->finally->if->out->close->outFile->delete->return
ClassWriter#writeClassFile(OutputStream, ClassSymbol):::Write class `c' to outstream `out'.:::Assert->c->flags->check->databuf->reset->poolbuf->reset->signatureGen->reset->new->LinkedHashMap<>->supertype->types->supertype->interfaces->types->interfaces->typarams->getTypeArguments->flags->if->else->c->flags->adjustFlags->if->if->if->pw->log->getWriter->pw->println->pw->c->getQualifiedName->println->pw->flagNames->println->databuf->appendChar->if->unnamed->databuf->pool->new->ClassSymbol->put->appendChar->else->databuf->pool->put->appendChar->databuf->supertype->hasTag->pool->put->appendChar->databuf->interfaces->length->appendChar->for->l->l->nonEmpty->fieldsCount->methodsCount->foreach->c->members->getSymbols->switch->break->if->sym->flags->break->enterInner->break->Assert->error->if->foreach->enterInner->databuf->appendChar->c->members->writeFields->databuf->appendChar->c->members->writeMethods->acountIdx->beginAttrs->acount->sigReq->typarams->length->supertype->allparams->length->for->l->l->nonEmpty->if->alenIdx->writeAttr->if->typarams->length->signatureGen->assembleParamsSig->signatureGen->assembleSig->for->l->l->nonEmpty->databuf->pool->signatureGen->toName->put->appendChar->signatureGen->reset->endAttr->if->alenIdx->writeAttr->simpleName->PathFileObject->getSimpleName->databuf->names->fromString->put->appendChar->endAttr->if->alenIdx->writeAttr->databuf->names->Long->getLastModified->toString->fromString->put->appendChar->endAttr->writeAttr->databuf->names->Long->System->currentTimeMillis->toString->fromString->put->appendChar->endAttr->c->flags->writeFlagAttrs->c->getRawAttributes->writeJavaAnnotations->c->getRawTypeAttributes->writeTypeAnnotations->writeEnclosingMethodAttribute->if->writeModuleAttribute->flags->writeFlagAttrs->writeExtraClassAttributes->poolbuf->appendInt->if->preview->isEnabled->poolbuf->appendChar->else->poolbuf->appendChar->poolbuf->appendChar->if->if->target->hasNestmateAccess->writeNestMembersIfNeeded->writeNestHostIfNeeded->writePool->if->writeInnerClasses->if->bootstrapMethods->isEmpty->writeBootstrapMethods->endAttrs->poolbuf->appendBytes->out->write
ClassWriter#writeExtraClassAttributes(ClassSymbol):::Allows subclasses to write additional class attributes:::return
Code#checkLimits(DiagnosticPosition, Log):::Check the code against VM spec limits; if  problems report them and return true.:::if->log->error->return->if->log->error->return->if->log->error->return->return
Code#typecode(Type):::Given a type, return its type code (used implicitly in the  JVM architecture).:::switch->type->getTag->return->return->return->return->return->return->return->return->return->return->throw->type->getTag->new->AssertionError
Code#truncate(int):::Collapse type code for subtypes of int to INTcode.:::switch->return->return
Code#width(int):::The width in bytes of objects of the type.:::switch->return->return->return
Code#width(List):::The total width taken up by a vector of objects.:::w->for->l->l->nonEmpty->return
Code#arraycode(Type):::Given a type, return its code for allocating arrays of that type.:::switch->type->getTag->return->return->return->return->return->return->return->return->return->return->throw->new->AssertionError
Code#curCP():::The current output code pointer.:::if->resolvePending->if->markStatBegin->return
Code#emit4(int):::Emit four bytes of code.:::if->return->if->emit1->emit1->emit1->emit1->else
Code#emitLdc(int):::Emit a ldc (or ldc_w) instruction, taking into account operand size:::if->emitop1->else->emitop2
Code#emitMultianewarray(int, int, Type):::Emit a multinewarray instruction.:::emitop->if->return->emit2->emit1->state->pop->state->push
Code#emitNewarray(int, Type):::Emit newarray.:::emitop->if->return->emit1->state->pop->state->push
Code#emitAnewarray(int, Type):::Emit anewarray.:::emitop->if->return->emit2->state->pop->state->push
Code#emitInvokeinterface(int, Type):::Emit an invokeinterface instruction.:::argsize->mtype->getParameterTypes->width->emitop->if->return->emit2->emit1->emit1->state->pop->state->mtype->getReturnType->push
Code#emitInvokespecial(int, Type):::Emit an invokespecial instruction.:::argsize->mtype->getParameterTypes->width->emitop->if->return->emit2->sym->state->pop->if->sym->isConstructor->state->state->peek->markInitialized->state->pop->state->mtype->getReturnType->push
Code#emitInvokestatic(int, Type):::Emit an invokestatic instruction.:::argsize->mtype->getParameterTypes->width->emitop->if->return->emit2->state->pop->state->mtype->getReturnType->push
Code#emitInvokevirtual(int, Type):::Emit an invokevirtual instruction.:::argsize->mtype->getParameterTypes->width->emitop->if->return->emit2->state->pop->state->mtype->getReturnType->push
Code#emitInvokedynamic(int, Type):::Emit an invokedynamic instruction.:::argsize->mtype->getParameterTypes->width->emitop->if->return->emit2->emit2->state->pop->state->mtype->getReturnType->push
Code#emitop0(int):::Emit an opcode with no operand field.:::emitop->if->return->switch->state->pop->a->Assert->a->hasTag->check->state->pop->state->types->types->elemtype->erasure->push->break->markDead->break->break->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->break->Assert->check->state->pop->markDead->break->state->pop->markDead->break->state->pop->break->Assert->check->state->pop->markDead->break->state->push->break->Assert->check->markDead->break->state->pop->state->push->break->state->pop->break->state->pop->break->state->pop->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->state->push->break->state->pop->break->val1->state->pop1->val2->state->pop1->state->push->state->push->state->push->break->state->pop->break->break->state->pop->break->state->pop->break->state->pop->break->if->value1->state->pop1->value2->state->pop1->state->push->state->push->state->push->state->push->else->value->state->pop2->state->push->state->push->break->if->value1->state->pop1->value2->state->pop1->value3->state->pop1->state->push->state->push->state->push->state->push->state->push->else->value1->state->pop2->value2->state->pop1->state->push->state->push->state->push->break->if->value1->state->pop1->value2->state->pop1->if->value3->state->pop1->value4->state->pop1->state->push->state->push->state->push->state->push->state->push->state->push->else->value3->state->pop2->state->push->state->push->state->push->state->push->state->push->else->value1->state->pop2->if->value2->state->pop1->value3->state->pop1->state->push->state->push->state->push->state->push->else->value2->state->pop2->state->push->state->push->state->push->break->value1->state->pop1->if->value2->state->pop1->value3->state->pop1->state->push->state->push->state->push->state->push->else->value2->state->pop2->state->push->state->push->state->push->break->state->pop->state->push->break->state->pop->state->push->break->value1->state->pop1->value2->state->pop1->state->push->state->push->break->state->pop->break->markDead->break->return->state->pop->break->throw->mnem->new->AssertionError->postop
Code#emitop1(int, int):::Emit an opcode with a one-byte operand field.:::emitop->if->return->emit1->switch->state->push->break->state->typeForPool->push->break->throw->mnem->new->AssertionError->postop
Code#emitop1w(int, int):::Emit an opcode with a one-byte operand field;  widen if field does not fit in a byte.:::if->emitop->emitop->emit2->else->emitop->emit1->if->return->switch->state->push->break->state->push->break->state->push->break->state->push->break->state->push->break->state->pop->break->state->pop->break->markDead->break->throw->mnem->new->AssertionError->postop
Code#emitop1w(int, int, int):::Emit an opcode with two one-byte operand fields;  widen if either field does not fit in a byte.:::if->emitop->emitop->emit2->emit2->else->emitop->emit1->emit1->if->return->switch->break->throw->mnem->new->AssertionError
Code#emitop2(int, int):::Emit an opcode with a two-byte operand field.:::emitop->if->return->emit2->switch->state->erasure->push->break->state->erasure->pop->break->sym->if->else->state->sym->erasure->uninitializedObject->push->break->state->push->break->state->pop->break->state->pop->break->markDead->break->state->erasure->pop->state->pop->break->state->pop->state->erasure->push->break->state->pop->o->t->erasure->types->erasure->state->push->break->state->typeForPool->push->break->state->pop->state->push->break->state->typeForPool->push->break->break->throw->mnem->new->AssertionError
Code#emitop4(int, int):::Emit an opcode with a four-byte operand field.:::emitop->if->return->emit4->switch->markDead->break->break->throw->mnem->new->AssertionError
Code#align(int):::Align code pointer to next `incr' boundary.:::if->while->emitop0
Code#put4(int, int):::Place four  bytes into code at address pc:::put1->put1->put1->put1
Code#get4(int):::Return four code bytes at position pc as an int.:::return->get1->get1->get1->get1
Code#isAlive():::Is code generation currently enabled?:::return
Code#markDead():::Switch code generation on/off.:::
Code#entryPoint():::Declare an entry point; return current code pointer:::pc->curCP->return
Code#entryPoint(State):::Declare an entry point with initial state;  return current code pointer:::pc->curCP->newState->state->dup->setDefined->Assert->check->if->println->return
Code#entryPoint(State, Type):::Declare an entry point with initial state plus a pushed value;  return current code pointer:::pc->curCP->newState->state->dup->setDefined->Assert->check->push->if->println->return
Code#emitStackMap():::Emit a stack map entry.:::pc->curCP->if->return->switch->getLocalsSize->emitCLDCStackMap->break->getLocalsSize->emitStackMapFrame->break->throw->new->AssertionError->if->state->dump
Code#emitCLDCStackMap(int, int):::Emit a CLDC stack map frame.:::if->if->new->StackMapFrameArr->else->ArrayUtils->ensureCapacity->frame->new->StackMapFrame->new->TypeArr->for->i->new->TypeArr->for->i
Code#negate(int):::Negate a branch opcode.:::if->return->else->if->return->else->return
Code#emitJump(int):::Emit a jump instruction:::if->if->emitop4->else->negate->emitop2->emitop4->return->else->emitop2->return
Code#branch(int):::Emit a branch with given opcode; return its chain:::result->if->if->isAlive->emitJump->state->dup->new->Chain->if->return
Code#resolve(Chain, int):::Resolve chain to point to given target.:::changed->newState->for->Assert->check->if->setDefined
Code#resolve(Chain):::Resolve chain to point to current code pointer.:::Assert->check->mergeChains
Code#resolvePending():::Resolve any pending jumps.:::x->resolve
Code#mergeChains(Chain, Chain):::Merge the jumps in of two chains into one.:::if->return->if->return->Assert->check->if->return->mergeChains->new->Chain->return->mergeChains->new->Chain
Code#addCatch(char, char, char, char):::Add a catch clause to code.:::catchInfo->new->charArr->append
Code#addLineNumber(char, char):::Add a line number entry.:::if->if->lineInfo->nonEmpty->if->lineInfo->isEmpty->lineInfo->new->charArr->prepend
Code#statBegin(int):::Mark beginning of statement.:::if
Code#markStatBegin():::Force stat begin eagerly:::if->line->lineMap->getLineNumber->cp1->line1->if->addLineNumber
Code.State#forceStackTop(Type):::Force the top of the stack to be treated as this supertype  of its current type.:::if->return->switch->t->getTag->width->width->old->Assert->types->types->erasure->types->erasure->isSubtype->check->break
Code#getLVTSize():::Calculates the size of the LocalVariableTable.:::result->for->i->return
Code#setDefined(Bits):::Set the current variable defined state.:::if->diff->new->Bits->xorSet->for->adr->diff->nextBit->diff->nextBit
Code#setDefined(int):::Mark a register as being (possibly) defined.:::v->if->excl->else->incl->if->v->openRange
Code#setUndefined(int):::Mark a register as being undefined.:::excl->if->isLastRangeInitialized->v->length->curCP->v->lastRange->if->v->dup->v->closeRange->putVar->else->v->removeLastRange
Code#putVar(LocalVar):::Put a live variable range into the buffer to be output to the  class file.:::keepLocalVariables->isExceptionParameter->hasTypeAnnotations->if->return->ignoredSyntheticVar->flags->flags->flags->if->return->if->new->LocalVarArr->else->ArrayUtils->ensureCapacity
Code#newRegSegment():::Start a set of fresh registers.:::
Code#endScopes(int):::End scopes of all variables with registers &ge; first.:::prevNextReg->for->i
CRTable#put(Object, int, int, int):::Create a new CRTEntry and add it to the entries.:::entries->new->CRTEntry->append
CRTable#writeCRT(ByteBuffer, Position.LineMap, Log):::Compute source positions and write CRT to the databuf.:::crtEntries->new->SourceComputer->csp->for->l->entries->toList->l->nonEmpty->return
CRTable#length():::Return the number of the entries.:::return->entries->length
CRTable.SourceComputer#csp(JCTree):::Visitor method: compute source positions for a single node.:::if->return->tree->accept->if->positions->put->return
CRTable.SourceComputer#csp(List):::Visitor method: compute source positions for a list of nodes.:::if->trees->nonEmpty->return->list_sr->new->SourceRange->for->l->l->nonEmpty->positions->put->return
CRTable.SourceComputer#cspCases(List)::: Visitor method: compute source positions for    a list of case blocks of switch statements.:::if->trees->nonEmpty->return->list_sr->new->SourceRange->for->l->l->nonEmpty->positions->put->return
CRTable.SourceComputer#cspCatchers(List)::: Visitor method: compute source positions for   a list of catch clauses in try statements.:::if->trees->nonEmpty->return->list_sr->new->SourceRange->for->l->l->nonEmpty->positions->put->return
CRTable.SourceComputer#startPos(JCTree):::The start position of given tree.:::if->return->return->TreeInfo->getStartPos
CRTable.SourceComputer#endPos(JCTree):::The end position of given tree, if it has  defined endpos, NOPOS otherwise.:::if->return->return->TreeInfo->getEndPos
CRTable.SourceRange#mergeWith(SourceRange):::Compare the starting and the ending positions  of the source range and combines them assigning  the widest range to this.:::if->return->if->else->if->if->else->if->return
Gen#loadIntConst(int):::Generate code to load an integer constant.:::items->makeImmediateItem->load
Gen#zero(int):::The opcode that loads a zero constant of a given type code.:::switch->return->return->return->return->throw->new->AssertionError
Gen#one(int):::The opcode that loads a one constant of a given type code.:::return->zero
Gen#emitMinusOne(int):::Generate code to load -1 of the given type code (either int or long).:::if->items->Long->valueOf->makeImmediateItem->load->else->code->emitop0
Gen#binaryQualifier(Symbol, Type):::Construct a symbol to reflect the qualifying type that should  appear in the byte code as per JLS 13.1:::if->site->hasTag->if->return->qualifier->new->ClassSymbol->return->sym->clone->if->sym->flags->return->if->return->return->sym->clone
Gen#makeRef(DiagnosticPosition, Type):::Insert a reference to given type in the constant pool,  checking for an array with too many dimensions;  return the reference's index.:::checkDimension->if->type->isAnnotated->return->pool->put->else->return->pool->type->hasTag->put
Gen#makeTemp(Type):::Create a tempory variable.:::v->new->VarSymbol->code->newLocal->return->items->makeLocalItem
Gen#callMethod(DiagnosticPosition, Type, Name, List, boolean):::Generate code to call a non-private method or constructor.:::msym->rs->resolveInternalMethod->if->items->makeStaticItem->invoke->else->items->makeMemberItem->invoke
Gen#genFinalizer(Env):::Generate code to invoke the finalizer associated with given  environment:::if->code->isAlive->gen
Gen#unwind(JCTree, Env):::Generate code to call all finalizers of structures aborted by  a non-local  exit:::env1->while->genFinalizer->if->break->return
Gen#endFinalizerGap(Env):::Mark end of gap in catch-all range for finalizer.:::if->length->code->curCP->append
Gen#endFinalizerGaps(Env, Env):::Mark end of all gaps in catch-all ranges for finalizers of environments  lying between, and including to two environments.:::last->while->endFinalizerGap
Gen#hasFinally(JCTree, Env):::Do any of the structures aborted by a non-local exit have  finalizers that require an empty stack?:::while->if->hasTag->hasFinalizer->return->return
Gen#normalizeDefs(List, ClassSymbol):::Distribute member initializer code into constructors and <clinit>  method.:::initCode->new->ListBuffer<>->initTAs->new->ListBuffer<>->clinitCode->new->ListBuffer<>->clinitTAs->new->ListBuffer<>->methodDefs->new->ListBuffer<>->for->l->l->nonEmpty->if->initCode->length->inits->initCode->toList->initTAs->c->getInitTypeAttributes->addAll->initTAlist->initTAs->toList->foreach->normalizeMethod->if->clinitCode->length->clinit->c->flags->List->nil->List->nil->new->MethodType->new->MethodSymbol->c->members->enter->clinitStats->clinitCode->toList->block->make->pos->at->Block->TreeInfo->clinitStats->last->endPos->methodDefs->make->MethodDef->append->if->clinitTAs->isEmpty->clinit->clinitTAs->toList->appendUniqueTypeAttributes->if->c->getClassInitTypeAttributes->isEmpty->clinit->c->getClassInitTypeAttributes->appendUniqueTypeAttributes->return->methodDefs->toList
Gen#normalizeMethod(JCMethodDecl, List, List):::Insert instance initializer code into initial constructor.:::if->TreeInfo->isInitialConstructor->stats->newstats->new->ListBuffer<>->if->stats->nonEmpty->while->TreeInfo->isSyntheticInit->newstats->append->newstats->append->while->stats->nonEmpty->TreeInfo->isSyntheticInit->newstats->append->newstats->appendList->while->stats->nonEmpty->newstats->append->newstats->toList->if->TreeInfo->last->endPos->appendUniqueTypeAttributes
Gen#genDef(JCTree, Env):::Visitor method: generate code for a definition, catching and reporting  any completion failures.:::prevEnv->try->tree->accept->catch->chk->tree->pos->completionError->finally
Gen#genStat(JCTree, Env, int):::Derived visitor method: check whether CharacterRangeTable  should be emitted, if so, put a new entry into CRTable  and call method to generate bytecode:::if->genStat->return->startpc->code->curCP->genStat->if->tree->hasTag->code->curCP->put
Gen#genStat(JCTree, Env):::Derived visitor method: generate code for a statement.:::if->code->isAlive->code->statBegin->genDef->else->if->tree->hasTag->code->newLocal
Gen#genStats(List, Env, int):::Derived visitor method: check whether CharacterRangeTable  should be emitted, if so, put a new entry into CRTable  and call method to generate bytecode:::if->genStats->return->if->trees->length->genStat->else->startpc->code->curCP->genStats->code->curCP->put
Gen#genStats(List, Env):::Derived visitor method: generate code for a list of statements.:::for->l->l->nonEmpty
Gen#genCond(JCTree, int):::Derived visitor method: check whether CharacterRangeTable  should be emitted, if so, put a new entry into CRTable  and call method to generate bytecode:::if->return->genCond->startpc->code->curCP->item->genCond->code->curCP->put->return
Gen#genCond(JCTree, boolean):::Derived visitor method: generate code for a boolean  expression in a control-flow context.:::inner_tree->TreeInfo->skipParens->if->inner_tree->hasTag->tree->cond->genCond->if->cond->isTrue->code->resolve->result->genCond->if->return->if->cond->isFalse->code->resolve->result->genCond->if->return->secondJumps->cond->jumpFalse->code->resolve->first->genCond->if->falseJumps->first->jumpFalse->code->resolve->trueJumps->code->branch->code->resolve->second->genCond->result->items->Code->mergeChains->Code->mergeChains->makeCondItem->if->return->else->result->genExpr->mkCond->if->return
Gen#genExpr(JCTree, Type):::Visitor method: generate code for an expression, catching and reporting  any completion failures.:::prevPt->try->if->constValue->tree->accept->tree->pos->constValue->checkStringConstant->items->constValue->makeImmediateItem->else->tree->accept->return->result->coerce->catch->chk->tree->pos->completionError->return->items->makeStackItem->finally
Gen#genArgs(List, List):::Derived visitor method: generate code for a list of method arguments.:::for->l->l->nonEmpty->Assert->pts->isEmpty->check
Gen#genMethod(JCMethodDecl, Env, boolean):::Generate code for a method.:::meth->extras->if->meth->isConstructor->if->meth->enclClass->isInner->meth->enclClass->isStatic->else->if->if->Code->types->erasure->getParameterTypes->width->log->tree->pos->error->else->if->startpcCrt->initCode->try->genStat->catch->initCode->genStat->finally->if->log->pos->Errors->StackSimError->error->throw->new->AssertionError->if->code->isAlive->code->TreeInfo->endPos->statBegin->if->getReturnType->hasTag->code->emitop0->else->startpc->code->entryPoint->c->items->makeCondItem->code->c->jumpTrue->resolve->if->code->curCP->put->code->endScopes->if->code->tree->pos->checkLimits->return->if->genMethod->if->code->compressCatchTable->code->fillExceptionParameterPositions
Gen#qsort2(int[], int[], int, int):::Sort (int) arrays of keys and values:::i->j->pivot->do->while->while->if->temp1->temp2->while->if->qsort2->if->qsort2
Gen#genTry(JCTree, List, Env):::Generate code for a try or synchronized statement:::limit->startpc->code->curCP->stateTry->dup->genStat->endpc->code->curCP->gaps->toList->code->TreeInfo->endPos->statBegin->genFinalizer->code->TreeInfo->endPos->statBegin->exitChain->code->branch->endFinalizerGap->afterBody->hasFinalizer->hasFinalizer->if->for->l->l->nonEmpty->if->code->newRegSegment->catchallpc->code->entryPoint->startseg->while->nonEmpty->endseg->next->intValue->body->pos->registerCatch->next->intValue->code->TreeInfo->finalizerPos->statBegin->code->markStatBegin->excVar->makeTemp->excVar->store->genFinalizer->code->resolvePending->code->TreeInfo->finalizerPos->statBegin->code->markStatBegin->excVar->load->body->pos->next->intValue->registerCatch->code->emitop0->code->markDead->if->code->resolve->code->TreeInfo->finalizerPos->statBegin->code->markStatBegin->retVar->makeTemp->retVar->store->genLast->code->emitop1w->code->markDead->code->resolve->code->endScopes
Gen#genCatch(JCCatch, Env, int, int, List):::Generate code for a catch clause.:::if->catchTypeExprs->catchTypesWithAnnotations->while->gaps->nonEmpty->foreach->subCatch->catchType->tree->pos->makeRef->end->intValue->tree->pos->code->curCP->registerCatch->foreach->setCatchInfo->intValue->if->foreach->subCatch->catchType->tree->pos->makeRef->tree->pos->code->curCP->registerCatch->foreach->setCatchInfo->exparam->code->statBegin->code->markStatBegin->limit->code->newLocal->items->makeLocalItem->store->code->TreeInfo->firstStatPos->statBegin->genStat->code->endScopes->code->TreeInfo->endPos->statBegin
Gen#registerCatch(DiagnosticPosition, int, int, int, int):::Register a catch clause in the "Exceptions" code-attribute.:::startpc1->endpc1->handler_pc1->if->code->addCatch->else->log->error
Gen#makeNewArray(DiagnosticPosition, Type, int):::Generate code to create an array with given element type and number  of dimensions.:::elemtype->types->elemtype->if->types->dimensions->log->error->elemcode->Code->arraycode->if->code->makeRef->emitAnewarray->else->if->code->makeRef->emitMultianewarray->else->code->emitNewarray->return->items->makeStackItem
Gen#completeBinop(JCTree, JCTree, OperatorSymbol):::Complete generating code for operation, with left operand  already on stack.:::optype->opcode->if->constValue->constValue->intValue->else->if->TreeInfo->isNull->else->rtype->operator->erasure->getParameterTypes->if->genExpr->load->if->code->emitop0->if->return->items->makeCondItem->else->code->emitop0->return->items->makeStackItem
Gen#genClass(Env, JCClassDecl):::Generate code for a class definition.:::try->c->pool->reset->normalizeDefs->generateReferencesToPrunedTree->localEnv->new->GenContext->new->Env<>->for->l->l->nonEmpty->if->pool->numEntries->log->cdef->pos->error->if->for->l->l->nonEmpty->List->nil->return->catch->finally
Gen.GenFinalizer#gen():::Generate code to clean up when unwinding.:::
Gen.GenFinalizer#genLast():::Generate code to clean up at last.:::
Gen.GenFinalizer#hasFinalizer():::Does this finalizer have some nontrivial cleanup to perform?:::return
Gen.GenFinalizer#afterBody():::Should be invoked after the try's body has been visited.:::
Gen.GenContext#addExit(Chain):::Add given chain to exit chain.:::Code->mergeChains
Gen.GenContext#addCont(Chain):::Add given chain to cont chain.:::Code->mergeChains
Items#makeVoidItem():::Make a void item:::return
Items#makeThisItem():::Make an item representing `this'.:::return
Items#makeSuperItem():::Make an item representing `super'.:::return
Items#makeStackItem(Type):::Make an item representing a value on stack.:::return->Code->typecode
Items#makeDynamicItem(Symbol):::Make an item representing a dynamically invoked method.:::return->new->DynamicItem
Items#makeIndexedItem(Type):::Make an item representing an indexed expression.:::return->new->IndexedItem
Items#makeLocalItem(VarSymbol):::Make an item representing a local variable.:::return->v->erasure->new->LocalItem
Items#makeStaticItem(Symbol):::Make an item representing a static variable or method.:::return->new->StaticItem
Items#makeMemberItem(Symbol, boolean):::Make an item representing an instance variable or method.:::return->new->MemberItem
Items#makeImmediateItem(Type, Object):::Make an item representing a literal.:::return->new->ImmediateItem
Items#makeAssignItem(Item):::Make an item representing an assignment expression.:::return->new->AssignItem
Items#makeCondItem(int, Chain, Chain):::Make an item representing a conditional or unconditional jump.:::return->new->CondItem
Items#makeCondItem(int):::Make an item representing a conditional or unconditional jump.:::return->makeCondItem
Items.Item#load():::Generate code to load this item onto stack.:::throw->new->AssertionError
Items.Item#store():::Generate code to store top of stack into this item.:::throw->new->AssertionError
Items.Item#invoke():::Generate code to invoke method represented by this item.:::throw->new->AssertionError
Items.Item#duplicate():::Generate code to use this item twice.:::
Items.Item#drop():::Generate code to avoid having to use this item.:::
Items.Item#stash(int):::Generate code to stash a copy of top of stack - of typecode toscode -  under this item.:::duplicate
Items.Item#mkCond():::Generate code to turn item into a testable condition.:::load->return->makeCondItem
Items.Item#coerce(int):::Generate code to coerce item to given type code.:::if->return->else->load->typecode1->Code->truncate->targetcode1->Code->truncate->if->offset->code->emitop0->if->code->emitop0->return
Items.Item#coerce(Type):::Generate code to coerce item to given type.:::return->Code->typecode->coerce
Items.Item#width():::Return the width of this item on stack as a number of words.:::return
JNIWriter#instance(Context):::Get the ClassWriter instance for this context.:::instance->context->get->if->new->JNIWriter->return
JNIWriter#write(ClassSymbol):::Emit a class file for a given class.:::className->c->flatName->toString->outLocn->if->msym->c->packge->fileManager->toString->getLocationForModule->else->outFile->fileManager->className->replaceAll->getFileForOutput->out->outFile->openWriter->new->PrintWriter->try->write->if->log->outFile->getName->printVerbose->out->close->catch->finally->if->out->close->outFile->delete->return
ModuleNameReader#getChar(int):::Extract a character at position bp from buf.:::return
ModuleNameReader#nextChar():::Read a character.:::return
ModuleNameReader#nextInt():::Read an integer.:::return
ModuleNameReader#indexPool():::Index all constant pool entries, writing their start addresses into  poolIdx.:::nextChar->new->intArr->i->while->tag->switch->len->nextChar->break->break->break->break->break->throw->new->BadClassFile
Pool#numEntries():::Return the number of entries in the constant pool.:::return
Pool#reset():::Remove everything from this pool.:::indices->clear
Pool#put(Object):::Place an object in the pool, unless it is already there:::makePoolValue->Assert->check->Assert->check->index->indices->get->if->indices->put->ArrayUtils->ensureCapacity->if->ArrayUtils->ensureCapacity->return->index->intValue
Pool#get(Object):::Return the given object's index in the pool,  or -1 if object is not in there.:::n->indices->get->return->n->intValue
StringConcat#sharpestAccessible(Type):::If the type is not accessible from current context, try to figure out the sharpest accessible supertype.:::if->originalType->hasTag->return->types->types->elemtype->sharpestAccessible->makeArrayType->type->while->rs->gen->getAttrEnv->type->asElement->isAccessible->types->supertype->return
