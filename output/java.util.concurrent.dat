AbstractExecutorService#newTaskFor(Runnable, T):::Returns a RunnableFuture for the given runnable and default value.:::return->new->FutureTask<T>
AbstractExecutorService#newTaskFor(Callable):::Returns a RunnableFuture for the given callable task.:::return->new->FutureTask<T>
AbstractExecutorService#submit(Runnable)::: abstract executor service submit:::if->throw->new->NullPointerException->ftask->newTaskFor->execute->return
AbstractExecutorService#submit(Runnable, T)::: abstract executor service submit:::if->throw->new->NullPointerException->ftask->newTaskFor->execute->return
AbstractExecutorService#submit(Callable)::: abstract executor service submit:::if->throw->new->NullPointerException->ftask->newTaskFor->execute->return
AbstractExecutorService#doInvokeAny(Collection>, boolean, long):::the main mechanics of invokeAny.:::if->throw->new->NullPointerException->ntasks->tasks->size->if->throw->new->IllegalArgumentException->futures->new->ArrayList<>->ecs->new->ExecutorCompletionService<T>->try->ee->deadline->System->nanoTime->it->tasks->iterator->futures->ecs->it->next->submit->add->active->for->if->new->ExecutionException->throw->catch->finally->cancelAll
AbstractExecutorService#invokeAny(Collection>)::: abstract executor service invoke any:::try->return->doInvokeAny->catch->return->finally
AbstractExecutorService#invokeAny(Collection>, long, TimeUnit)::: abstract executor service invoke any:::return->unit->toNanos->doInvokeAny
AbstractExecutorService#invokeAll(Collection>)::: abstract executor service invoke all:::if->throw->new->NullPointerException->futures->tasks->size->new->ArrayList<>->try->foreach->f->newTaskFor->futures->add->execute->for->i->size->futures->size->return->catch->cancelAll->throw->finally
AbstractExecutorService#invokeAll(Collection>, long, TimeUnit)::: abstract executor service invoke all:::if->throw->new->NullPointerException->nanos->unit->toNanos->deadline->System->nanoTime->futures->tasks->size->new->ArrayList<>->j->try->foreach->futures->newTaskFor->add->size->futures->size->for->i->for->return->catch->cancelAll->throw->finally->cancelAll->return
AbstractExecutorService#cancelAll(ArrayList>)::: abstract executor service cancel all:::cancelAll
AbstractExecutorService#cancelAll(ArrayList>, int):::Cancels all futures with index at least j.:::for->size->futures->size
ArrayBlockingQueue#inc(int, int):::Increments i, mod modulus:::if->return
ArrayBlockingQueue#dec(int, int):::Decrements i, mod modulus:::if->return
ArrayBlockingQueue#itemAt(int):::Returns item at index i.:::return
ArrayBlockingQueue#itemAt(Object[], int):::Returns element at array index i:::return
ArrayBlockingQueue#enqueue(E):::Inserts element at current put position, advances, and signals:::items->if->notEmpty->signal
ArrayBlockingQueue#dequeue():::Extracts element at current take position, advances, and signals:::items->e->if->if->itrs->elementDequeued->notFull->signal->return
ArrayBlockingQueue#removeAt(int):::Deletes item at array index removeIndex:::items->if->if->if->itrs->elementDequeued->else->for->i->putIndex->if->itrs->removedAt->notFull->signal
ArrayBlockingQueue#add(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.:::return->super->add
ArrayBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::Objects->requireNonNull->lock->lock->lock->try->if->return->else->enqueue->return->catch->finally->lock->unlock
ArrayBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.:::Objects->requireNonNull->lock->lock->lockInterruptibly->try->while->notFull->await->enqueue->catch->finally->lock->unlock
ArrayBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.:::Objects->requireNonNull->nanos->unit->toNanos->lock->lock->lockInterruptibly->try->while->if->return->notFull->awaitNanos->enqueue->return->catch->finally->lock->unlock
ArrayBlockingQueue#poll()::: array blocking queue poll:::lock->lock->lock->try->return->dequeue->catch->finally->lock->unlock
ArrayBlockingQueue#take()::: array blocking queue take:::lock->lock->lockInterruptibly->try->while->notEmpty->await->return->dequeue->catch->finally->lock->unlock
ArrayBlockingQueue#poll(long, TimeUnit)::: array blocking queue poll:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->while->if->return->notEmpty->awaitNanos->return->dequeue->catch->finally->lock->unlock
ArrayBlockingQueue#peek()::: array blocking queue peek:::lock->lock->lock->try->return->itemAt->catch->finally->lock->unlock
ArrayBlockingQueue#size():::Returns the number of elements in this queue.:::lock->lock->lock->try->return->catch->finally->lock->unlock
ArrayBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::lock->lock->lock->try->return->catch->finally->lock->unlock
ArrayBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->lock->lock->lock->try->if->items->for->i->end->to->return->catch->finally->lock->unlock
ArrayBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->lock->lock->lock->try->if->items->for->i->end->to->return->catch->finally->lock->unlock
ArrayBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::lock->lock->lock->try->items->end->a->Arrays->copyOfRange->if->System->arraycopy->return->catch->finally->lock->unlock
ArrayBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->items->count->firstLeg->Math->min->if->Arrays->a->getClass->copyOfRange->else->System->arraycopy->if->if->System->arraycopy->return->catch->finally->lock->unlock
ArrayBlockingQueue#toString()::: array blocking queue to string:::return->Helpers->collectionToString
ArrayBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock->lock->lock->try->k->if->circularClear->if->itrs->queueIsEmpty->for->lock->hasWaiters->catch->finally->lock->unlock
ArrayBlockingQueue#circularClear(Object[], int, int):::Nulls out slots starting at array index i, upto index end:::for->to
ArrayBlockingQueue#drainTo(Collection)::: array blocking queue drain to:::return->drainTo
ArrayBlockingQueue#drainTo(Collection, int)::: array blocking queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->items->lock->lock->lock->try->n->Math->min->take->i->try->while->e->c->add->if->return->catch->finally->if->if->if->itrs->queueIsEmpty->else->if->itrs->takeIndexWrapped->for->lock->hasWaiters->catch->finally->lock->unlock
ArrayBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
ArrayBlockingQueue.Itrs#doSomeSweeping(boolean):::Sweeps itrs, looking for and expunging stale iterators:::probes->o->p->sweeper->passedGo->if->else->for
ArrayBlockingQueue.Itrs#register(Itr):::Adds a new iterator to the linked list of tracked iterators.:::new->Node
ArrayBlockingQueue.Itrs#takeIndexWrapped():::Called whenever takeIndex wraps around to 0:::for->o->p->if
ArrayBlockingQueue.Itrs#removedAt(int):::Called whenever an interior remove (not at takeIndex) occurred:::for->o->p->if
ArrayBlockingQueue.Itrs#queueIsEmpty():::Called whenever the queue becomes empty:::for->p
ArrayBlockingQueue.Itrs#elementDequeued():::Called whenever an element has been dequeued (at takeIndex).:::if->queueIsEmpty->else->if->takeIndexWrapped
ArrayBlockingQueue.Itr#isDetached()::: itr is detached:::return
ArrayBlockingQueue.Itr#incCursor(int)::: itr inc cursor:::if->if->return
ArrayBlockingQueue.Itr#invalidated(int, int, long, int):::Returns true if index is invalidated by the given number of dequeues, starting from prevTakeIndex.:::if->return->distance->if->return
ArrayBlockingQueue.Itr#incorporateDequeues():::Adjusts indices to incorporate all dequeues since the last operation on this iterator:::cycles->takeIndex->prevCycles->prevTakeIndex->if->len->dequeues->if->invalidated->if->invalidated->if->invalidated->if->detach->else
ArrayBlockingQueue.Itr#detach():::Called when itrs should stop tracking this iterator, either because there are no more indices to update (cursor < 0 && nextIndex < 0 && lastRet < 0) or as a special exception, when lastRet >= 0, because hasNext() is about to return false for the first time:::if->itrs->doSomeSweeping
ArrayBlockingQueue.Itr#hasNext():::For performance reasons, we would like not to acquire a lock in hasNext in the common case:::if->return->noNext->return
ArrayBlockingQueue.Itr#noNext()::: itr no next:::lock->lock->lock->try->if->isDetached->incorporateDequeues->if->itemAt->detach->catch->finally->lock->unlock
ArrayBlockingQueue.Itr#next()::: itr next:::e->if->throw->new->NoSuchElementException->lock->lock->lock->try->if->isDetached->incorporateDequeues->cursor->if->itemAt->incCursor->else->if->detach->catch->finally->lock->unlock->return
ArrayBlockingQueue.Itr#forEachRemaining(Consumer)::: itr for each remaining:::Objects->requireNonNull->lock->lock->lock->try->e->if->return->if->isDetached->incorporateDequeues->action->accept->if->isDetached->return->items->for->i->end->to->catch->finally->detach->lock->unlock
ArrayBlockingQueue.Itr#remove()::: itr remove:::lock->lock->lock->try->if->isDetached->incorporateDequeues->lastRet->if->if->isDetached->removeAt->else->lastItem->if->itemAt->removeAt->else->if->throw->new->IllegalStateException->if->detach->catch->finally->lock->unlock
ArrayBlockingQueue.Itr#shutdown():::Called to notify the iterator that the queue is empty, or that it has fallen hopelessly behind, so that it should abandon any further iteration, except possibly to return one more element from next(), as promised by returning true from hasNext().:::if->if
ArrayBlockingQueue.Itr#distance(int, int, int)::: itr distance:::distance->if->return
ArrayBlockingQueue.Itr#removedAt(int):::Called whenever an interior remove (not at takeIndex) occurred.:::if->isDetached->return->takeIndex->prevTakeIndex->len->removedDistance->cursor->if->x->distance->if->if->else->if->dec->lastRet->if->x->distance->if->else->if->dec->nextIndex->if->x->distance->if->else->if->dec->if->return->return
ArrayBlockingQueue.Itr#takeIndexWrapped():::Called whenever takeIndex wraps around to zero.:::if->isDetached->return->if->shutdown->return->return
ArrayBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->Spliterators->spliterator
ArrayBlockingQueue#forEach(Consumer)::: array blocking queue for each:::Objects->requireNonNull->lock->lock->lock->try->if->items->for->i->end->to->catch->finally->lock->unlock
ArrayBlockingQueue#removeIf(Predicate)::: array blocking queue remove if:::Objects->requireNonNull->return->bulkRemove
ArrayBlockingQueue#removeAll(Collection)::: array blocking queue remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
ArrayBlockingQueue#retainAll(Collection)::: array blocking queue retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
ArrayBlockingQueue#bulkRemove(Predicate):::Implementation of bulk remove methods.:::lock->lock->lock->try->if->if->items->for->i->end->to->return->catch->finally->lock->unlock->return->super->removeIf
ArrayBlockingQueue#nBits(int)::: array blocking queue n bits:::return->new->longArr
ArrayBlockingQueue#setBit(long[], int)::: array blocking queue set bit:::
ArrayBlockingQueue#isClear(long[], int)::: array blocking queue is clear:::return
ArrayBlockingQueue#distanceNonEmpty(int, int):::Returns circular distance from i to j, disambiguating i == j to items.length; never returns 0.:::if->return
ArrayBlockingQueue#bulkRemoveModified(Predicate, int):::Helper for bulkRemove, in case of at least one deletion:::es->capacity->end->deathRow->distanceNonEmpty->nBits->for->i->to->k->w->for->i->to->k->distanceNonEmpty->circularClear->return
ArrayBlockingQueue#checkInvariants():::debugging:::if->invariantsSatisfied->detail->String->Arrays->toString->format->println->throw->new->AssertionError
ArrayBlockingQueue#invariantsSatisfied()::: array blocking queue invariants satisfied:::capacity->return->items->getClass->dec
ArrayBlockingQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::s->defaultReadObject->if->invariantsSatisfied->throw->new->java.io.InvalidObjectException
BlockingDeque#addFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#addLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offerFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#offerLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#putFirst(E):::Inserts the specified element at the front of this deque, waiting if necessary for space to become available.:::
BlockingDeque#putLast(E):::Inserts the specified element at the end of this deque, waiting if necessary for space to become available.:::
BlockingDeque#offerFirst(E, long, TimeUnit):::Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#offerLast(E, long, TimeUnit):::Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#takeFirst():::Retrieves and removes the first element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#takeLast():::Retrieves and removes the last element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#pollFirst(long, TimeUnit):::Retrieves and removes the first element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#pollLast(long, TimeUnit):::Retrieves and removes the last element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::
BlockingDeque#add(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offer(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#put(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available:::
BlockingDeque#offer(E, long, TimeUnit):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available:::
BlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#poll():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#take():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting if necessary until an element becomes available:::
BlockingDeque#poll(long, TimeUnit):::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting up to the specified wait time if necessary for an element to become available:::
BlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#peek():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::
BlockingDeque#size():::Returns the number of elements in this deque.:::
BlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::
BlockingDeque#push(E):::Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingQueue#add(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingQueue#offer(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingQueue#put(E):::Inserts the specified element into this queue, waiting if necessary for space to become available.:::
BlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.:::
BlockingQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.:::
BlockingQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit:::
BlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::
BlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::
BlockingQueue#drainTo(Collection):::Removes all available elements from this queue and adds them to the given collection:::
BlockingQueue#drainTo(Collection, int):::Removes at most the given number of available elements from this queue and adds them to the given collection:::
Callable#call():::Computes a result, or throws an exception if unable to do so.:::
CompletableFuture#internalComplete(Object)::: completable future internal complete:::return->RESULT->compareAndSet
CompletableFuture#tryPushStack(Completion):::Returns true if successfully pushed c onto stack.:::h->NEXT->set->return->STACK->compareAndSet
CompletableFuture#pushStack(Completion):::Unconditionally pushes c onto stack, retrying if necessary.:::do->while->tryPushStack
CompletableFuture#completeNull():::Completes with the null value, unless already completed.:::return->RESULT->compareAndSet
CompletableFuture#encodeValue(T):::Returns the encoding of the given non-exceptional value.:::return
CompletableFuture#completeValue(T):::Completes with a non-exceptional result, unless already completed.:::return->RESULT->compareAndSet
CompletableFuture#encodeThrowable(Throwable):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already.:::return->new->CompletionException->new->AltResult
CompletableFuture#completeThrowable(Throwable):::Completes with an exceptional result, unless already completed.:::return->RESULT->encodeThrowable->compareAndSet
CompletableFuture#encodeThrowable(Throwable, Object):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already:::if->new->CompletionException->else->if->return->return->new->AltResult
CompletableFuture#completeThrowable(Throwable, Object):::Completes with the given (non-null) exceptional result as a wrapped CompletionException unless it is one already, unless already completed:::return->RESULT->encodeThrowable->compareAndSet
CompletableFuture#encodeOutcome(T, Throwable):::Returns the encoding of the given arguments: if the exception is non-null, encodes as AltResult:::return->encodeThrowable
CompletableFuture#encodeRelay(Object):::Returns the encoding of a copied outcome; if exceptional, rewraps as a CompletionException, else returns argument.:::x->if->new->CompletionException->new->AltResult->return
CompletableFuture#completeRelay(Object):::Completes with r or a copy of r, unless already completed:::return->RESULT->encodeRelay->compareAndSet
CompletableFuture#reportGet(Object):::Reports result using Future.get conventions.:::if->throw->new->InterruptedException->if->x->cause->if->return->if->throw->if->x->getCause->throw->new->ExecutionException->return
CompletableFuture#reportJoin(Object):::Decodes outcome to return result or throw unchecked exception.:::if->x->if->return->if->throw->if->throw->throw->new->CompletionException->return
CompletableFuture.ThreadPerTaskExecutor#execute(Runnable)::: thread per task executor execute:::new->Thread->start
CompletableFuture#screenExecutor(Executor):::Null-checks user executor argument, and translates uses of commonPool to ASYNC_POOL in case parallelism disabled.:::if->ForkJoinPool->commonPool->return->if->throw->new->NullPointerException->return
CompletableFuture.Completion#tryFire(int):::Performs completion action if triggered, returning a dependent that may need propagation, if one exists.:::
CompletableFuture.Completion#isLive():::Returns true if possibly still triggerable:::
CompletableFuture.Completion#run()::: completion run:::tryFire
CompletableFuture.Completion#exec()::: completion exec:::tryFire->return
CompletableFuture.Completion#getRawResult()::: completion get raw result:::return
CompletableFuture.Completion#setRawResult(Void)::: completion set raw result:::
CompletableFuture#postComplete():::Pops and tries to trigger all reachable dependents:::f->h->while->d->t->if->STACK->compareAndSet->if->if->pushStack->continue->NEXT->compareAndSet->h->tryFire
CompletableFuture#cleanStack():::Traverses stack and unlinks one or more dead Completions, if found.:::p->for->unlinked->for->q
CompletableFuture.UniCompletion#claim():::Returns true if action can be run:::e->if->compareAndSetForkJoinTaskTag->if->return->e->execute->return
CompletableFuture.UniCompletion#isLive()::: uni completion is live:::return
CompletableFuture#unipush(Completion):::Pushes the given completion unless it completes while trying:::if->while->tryPushStack->if->NEXT->set->break->if->c->tryFire
CompletableFuture#postFire(CompletableFuture, int):::Post-processing by dependent after successful UniCompletion tryFire:::if->r->if->a->cleanStack->if->a->postComplete->if->if->return->else->postComplete->return
CompletableFuture.UniApply#tryFire(int)::: uni apply try fire:::d->a->r->x->f->if->return->if->if->if->d->completeThrowable->break->try->if->claim->return->else->t->d->f->apply->completeValue->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#uniApplyStage(Executor, Function)::: completable future uni apply stage:::if->throw->new->NullPointerException->r->if->return->uniApplyNow->d->newIncompleteFuture->new->UniApply<T,V>->unipush->return
CompletableFuture#uniApplyNow(Object, Executor, Function)::: completable future uni apply now:::x->d->newIncompleteFuture->if->if->encodeThrowable->return->try->if->e->new->UniApply<T,V>->execute->else->t->d->f->apply->encodeValue->catch->encodeThrowable->finally->return
CompletableFuture.UniAccept#tryFire(int)::: uni accept try fire:::d->a->r->x->f->if->return->if->if->if->d->completeThrowable->break->try->if->claim->return->else->t->f->accept->d->completeNull->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#uniAcceptStage(Executor, Consumer)::: completable future uni accept stage:::if->throw->new->NullPointerException->r->if->return->uniAcceptNow->d->newIncompleteFuture->new->UniAccept<T>->unipush->return
CompletableFuture#uniAcceptNow(Object, Executor, Consumer)::: completable future uni accept now:::x->d->newIncompleteFuture->if->if->encodeThrowable->return->try->if->e->new->UniAccept<T>->execute->else->t->f->accept->catch->encodeThrowable->finally->return
CompletableFuture.UniRun#tryFire(int)::: uni run try fire:::d->a->r->x->f->if->return->if->if->d->completeThrowable->else->try->if->claim->return->else->f->run->d->completeNull->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#uniRunStage(Executor, Runnable)::: completable future uni run stage:::if->throw->new->NullPointerException->r->if->return->uniRunNow->d->newIncompleteFuture->new->UniRun<T>->unipush->return
CompletableFuture#uniRunNow(Object, Executor, Runnable)::: completable future uni run now:::x->d->newIncompleteFuture->if->encodeThrowable->else->try->if->e->new->UniRun<T>->execute->else->f->run->catch->encodeThrowable->finally->return
CompletableFuture.UniWhenComplete#tryFire(int)::: uni when complete try fire:::d->a->r->f->if->d->uniWhenComplete->return->return->d->postFire
CompletableFuture#uniWhenComplete(Object, BiConsumer, UniWhenComplete)::: completable future uni when complete:::t->x->if->try->if->c->claim->return->if->else->tr->f->accept->if->internalComplete->return->catch->if->else->if->x->addSuppressed->finally->completeThrowable->return
CompletableFuture#uniWhenCompleteStage(Executor, BiConsumer)::: completable future uni when complete stage:::if->throw->new->NullPointerException->d->newIncompleteFuture->r->if->new->UniWhenComplete<T>->unipush->else->if->d->uniWhenComplete->else->try->e->new->UniWhenComplete<T>->execute->catch->encodeThrowable->finally->return
CompletableFuture.UniHandle#tryFire(int)::: uni handle try fire:::d->a->r->f->if->d->uniHandle->return->return->d->postFire
CompletableFuture#uniHandle(Object, BiFunction, UniHandle)::: completable future uni handle:::s->x->if->try->if->c->claim->return->if->else->ss->f->apply->completeValue->catch->completeThrowable->finally->return
CompletableFuture#uniHandleStage(Executor, BiFunction)::: completable future uni handle stage:::if->throw->new->NullPointerException->d->newIncompleteFuture->r->if->new->UniHandle<T,V>->unipush->else->if->d->uniHandle->else->try->e->new->UniHandle<T,V>->execute->catch->encodeThrowable->finally->return
CompletableFuture.UniExceptionally#tryFire(int)::: uni exceptionally try fire:::d->a->r->f->if->d->uniExceptionally->return->return->d->postFire
CompletableFuture#uniExceptionally(Object, Function, UniExceptionally)::: completable future uni exceptionally:::x->if->try->if->if->c->claim->return->f->apply->completeValue->else->internalComplete->catch->completeThrowable->finally->return
CompletableFuture#uniExceptionallyStage(Function)::: completable future uni exceptionally stage:::if->throw->new->NullPointerException->d->newIncompleteFuture->r->if->new->UniExceptionally<T>->unipush->else->d->uniExceptionally->return
CompletableFuture.UniRelay#tryFire(int)::: uni relay try fire:::d->a->r->if->return->if->d->completeRelay->return->d->postFire
CompletableFuture#uniCopyStage(CompletableFuture)::: completable future uni copy stage:::r->d->src->newIncompleteFuture->if->encodeRelay->else->src->new->UniRelay<U,T>->unipush->return
CompletableFuture#uniAsMinimalStage()::: completable future uni as minimal stage:::r->if->return->encodeRelay->new->MinimalStage<T>->d->new->MinimalStage<T>->new->UniRelay<T,T>->unipush->return
CompletableFuture.UniCompose#tryFire(int)::: uni compose try fire:::d->a->f->r->x->if->return->if->if->if->d->completeThrowable->break->try->if->claim->return->t->g->f->apply->toCompletableFuture->if->d->completeRelay->else->g->new->UniRelay<V,V>->unipush->if->return->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#uniComposeStage(Executor, Function>)::: completable future uni compose stage:::if->throw->new->NullPointerException->d->newIncompleteFuture->r->s->x->if->new->UniCompose<T,V>->unipush->else->if->if->if->encodeThrowable->return->try->t->g->f->apply->toCompletableFuture->if->encodeRelay->else->g->new->UniRelay<V,V>->unipush->catch->encodeThrowable->finally->else->try->e->new->UniCompose<T,V>->execute->catch->encodeThrowable->finally->return
CompletableFuture.CoCompletion#tryFire(int)::: co completion try fire:::c->d->if->c->tryFire->return->return
CompletableFuture.CoCompletion#isLive()::: co completion is live:::c->return
CompletableFuture#bipush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless both done:::if->while->if->tryPushStack->if->b->new->CoCompletion->unipush->else->if->c->tryFire->return->b->unipush
CompletableFuture#postFire(CompletableFuture, CompletableFuture, int):::Post-processing after successful BiCompletion tryFire.:::if->r->if->b->cleanStack->if->b->postComplete->return->postFire
CompletableFuture.BiApply#tryFire(int)::: bi apply try fire:::d->a->b->r->s->f->if->d->biApply->return->return->d->postFire
CompletableFuture#biApply(Object, Object, BiFunction, BiApply)::: completable future bi apply:::x->if->if->if->completeThrowable->break->if->if->completeThrowable->break->try->if->c->claim->return->rr->ss->f->apply->completeValue->catch->completeThrowable->finally->return
CompletableFuture#biApplyStage(Executor, CompletionStage, BiFunction)::: completable future bi apply stage:::b->r->s->if->o->toCompletableFuture->throw->new->NullPointerException->d->newIncompleteFuture->if->new->BiApply<T,U,V>->bipush->else->if->d->biApply->else->try->e->new->BiApply<T,U,V>->execute->catch->encodeThrowable->finally->return
CompletableFuture.BiAccept#tryFire(int)::: bi accept try fire:::d->a->b->r->s->f->if->d->biAccept->return->return->d->postFire
CompletableFuture#biAccept(Object, Object, BiConsumer, BiAccept)::: completable future bi accept:::x->if->if->if->completeThrowable->break->if->if->completeThrowable->break->try->if->c->claim->return->rr->ss->f->accept->completeNull->catch->completeThrowable->finally->return
CompletableFuture#biAcceptStage(Executor, CompletionStage, BiConsumer)::: completable future bi accept stage:::b->r->s->if->o->toCompletableFuture->throw->new->NullPointerException->d->newIncompleteFuture->if->new->BiAccept<T,U>->bipush->else->if->d->biAccept->else->try->e->new->BiAccept<T,U>->execute->catch->encodeThrowable->finally->return
CompletableFuture.BiRun#tryFire(int)::: bi run try fire:::d->a->b->r->s->f->if->d->biRun->return->return->d->postFire
CompletableFuture#biRun(Object, Object, Runnable, BiRun)::: completable future bi run:::x->z->if->if->completeThrowable->else->try->if->c->claim->return->f->run->completeNull->catch->completeThrowable->finally->return
CompletableFuture#biRunStage(Executor, CompletionStage, Runnable)::: completable future bi run stage:::b->r->s->if->o->toCompletableFuture->throw->new->NullPointerException->d->newIncompleteFuture->if->new->BiRun<>->bipush->else->if->d->biRun->else->try->e->new->BiRun<>->execute->catch->encodeThrowable->finally->return
CompletableFuture.BiRelay#tryFire(int)::: bi relay try fire:::d->a->b->r->s->z->x->if->return->if->if->d->completeThrowable->else->d->completeNull->return->d->postFire
CompletableFuture#andTree(CompletableFuture[], int, int):::Recursively constructs a tree of completions.:::d->new->CompletableFuture<Void>->if->else->a->b->r->s->z->x->mid->if->andTree->andTree->throw->new->NullPointerException->if->a->new->BiRelay<>->bipush->else->if->encodeThrowable->else->return
CompletableFuture#orpush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless either done:::if->while->tryPushStack->if->NEXT->set->break->if->c->tryFire->else->b->new->CoCompletion->unipush
CompletableFuture.OrApply#tryFire(int)::: or apply try fire:::d->a->b->r->x->f->if->return->if->try->if->claim->return->if->if->d->completeThrowable->break->t->d->f->apply->completeValue->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#orApplyStage(Executor, CompletionStage, Function)::: completable future or apply stage:::b->if->o->toCompletableFuture->throw->new->NullPointerException->r->z->if->return->z->uniApplyNow->d->newIncompleteFuture->new->OrApply<T,U,V>->orpush->return
CompletableFuture.OrAccept#tryFire(int)::: or accept try fire:::d->a->b->r->x->f->if->return->if->try->if->claim->return->if->if->d->completeThrowable->break->t->f->accept->d->completeNull->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#orAcceptStage(Executor, CompletionStage, Consumer)::: completable future or accept stage:::b->if->o->toCompletableFuture->throw->new->NullPointerException->r->z->if->return->z->uniAcceptNow->d->newIncompleteFuture->new->OrAccept<T,U>->orpush->return
CompletableFuture.OrRun#tryFire(int)::: or run try fire:::d->a->b->r->x->f->if->return->if->try->if->claim->return->else->if->d->completeThrowable->else->f->run->d->completeNull->catch->d->completeThrowable->finally->return->d->postFire
CompletableFuture#orRunStage(Executor, CompletionStage, Runnable)::: completable future or run stage:::b->if->o->toCompletableFuture->throw->new->NullPointerException->r->z->if->return->z->uniRunNow->d->newIncompleteFuture->new->OrRun<>->orpush->return
CompletableFuture.AnyOf#tryFire(int)::: any of try fire:::d->a->as->r->if->return->if->d->completeRelay->foreach->if->b->cleanStack->if->return->else->d->postComplete->return
CompletableFuture.AnyOf#isLive()::: any of is live:::d->return
CompletableFuture.AsyncSupply#getRawResult()::: async supply get raw result:::return
CompletableFuture.AsyncSupply#setRawResult(Void)::: async supply set raw result:::
CompletableFuture.AsyncSupply#exec()::: async supply exec:::run->return
CompletableFuture.AsyncSupply#run()::: async supply run:::d->f->if->if->try->d->f->get->completeValue->catch->d->completeThrowable->finally->d->postComplete
CompletableFuture#asyncSupplyStage(Executor, Supplier)::: completable future async supply stage:::if->throw->new->NullPointerException->d->new->CompletableFuture<U>->e->new->AsyncSupply<U>->execute->return
CompletableFuture.AsyncRun#getRawResult()::: async run get raw result:::return
CompletableFuture.AsyncRun#setRawResult(Void)::: async run set raw result:::
CompletableFuture.AsyncRun#exec()::: async run exec:::run->return
CompletableFuture.AsyncRun#run()::: async run run:::d->f->if->if->try->f->run->d->completeNull->catch->d->completeThrowable->finally->d->postComplete
CompletableFuture#asyncRunStage(Executor, Runnable)::: completable future async run stage:::if->throw->new->NullPointerException->d->new->CompletableFuture<Void>->e->new->AsyncRun->execute->return
CompletableFuture.Signaller#tryFire(int)::: signaller try fire:::w->if->LockSupport->unpark->return
CompletableFuture.Signaller#isReleasable()::: signaller is releasable:::if->Thread->interrupted->return->System->nanoTime
CompletableFuture.Signaller#block()::: signaller block:::while->isReleasable->if->LockSupport->park->else->LockSupport->parkNanos->return
CompletableFuture.Signaller#isLive()::: signaller is live:::return
CompletableFuture#waitingGet(boolean):::Returns raw result after waiting, or null if interruptible and interrupted.:::q->queued->r->while->if->new->Signaller->if->Thread->currentThread->ForkJoinPool->defaultExecutor->helpAsyncBlocker->else->if->tryPushStack->else->try->ForkJoinPool->managedBlock->catch->finally->if->break->if->if->Thread->currentThread->interrupt->if->cleanStack->if->postComplete->return
CompletableFuture#timedGet(long):::Returns raw result after waiting, or null if interrupted, or throws TimeoutException on timeout.:::if->Thread->interrupted->return->if->d->System->nanoTime->deadline->q->queued->r->while->if->new->Signaller->if->Thread->currentThread->ForkJoinPool->defaultExecutor->helpAsyncBlocker->else->if->tryPushStack->else->if->break->else->try->ForkJoinPool->managedBlock->catch->finally->if->break->if->if->cleanStack->if->postComplete->if->return->throw->new->TimeoutException
CompletableFuture#supplyAsync(Supplier):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() with the value obtained by calling the given Supplier.:::return->asyncSupplyStage
CompletableFuture#supplyAsync(Supplier, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.:::return->screenExecutor->asyncSupplyStage
CompletableFuture#runAsync(Runnable):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() after it runs the given action.:::return->asyncRunStage
CompletableFuture#runAsync(Runnable, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor after it runs the given action.:::return->screenExecutor->asyncRunStage
CompletableFuture#completedFuture(U):::Returns a new CompletableFuture that is already completed with the given value.:::return->new->CompletableFuture<U>
CompletableFuture#isDone():::Returns true if completed in any fashion: normally, exceptionally, or via cancellation.:::return
CompletableFuture#get():::Waits if necessary for this future to complete, and then returns its result.:::r->if->waitingGet->return->reportGet
CompletableFuture#get(long, TimeUnit):::Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.:::nanos->unit->toNanos->r->if->timedGet->return->reportGet
CompletableFuture#join():::Returns the result value when complete, or throws an (unchecked) exception if completed exceptionally:::r->if->waitingGet->return->reportJoin
CompletableFuture#getNow(T):::Returns the result value (or throws any encountered exception) if completed, else returns the given valueIfAbsent.:::r->return->reportJoin
CompletableFuture#complete(T):::If not already completed, sets the value returned by #get() and related methods to the given value.:::triggered->completeValue->postComplete->return
CompletableFuture#completeExceptionally(Throwable):::If not already completed, causes invocations of #get() and related methods to throw the given exception.:::if->throw->new->NullPointerException->triggered->new->AltResult->internalComplete->postComplete->return
CompletableFuture#thenApply(Function)::: completable future then apply:::return->uniApplyStage
CompletableFuture#thenApplyAsync(Function)::: completable future then apply async:::return->defaultExecutor->uniApplyStage
CompletableFuture#thenApplyAsync(Function, Executor)::: completable future then apply async:::return->screenExecutor->uniApplyStage
CompletableFuture#thenAccept(Consumer)::: completable future then accept:::return->uniAcceptStage
CompletableFuture#thenAcceptAsync(Consumer)::: completable future then accept async:::return->defaultExecutor->uniAcceptStage
CompletableFuture#thenAcceptAsync(Consumer, Executor)::: completable future then accept async:::return->screenExecutor->uniAcceptStage
CompletableFuture#thenRun(Runnable)::: completable future then run:::return->uniRunStage
CompletableFuture#thenRunAsync(Runnable)::: completable future then run async:::return->defaultExecutor->uniRunStage
CompletableFuture#thenRunAsync(Runnable, Executor)::: completable future then run async:::return->screenExecutor->uniRunStage
CompletableFuture#thenCombine(CompletionStage, BiFunction)::: completable future then combine:::return->biApplyStage
CompletableFuture#thenCombineAsync(CompletionStage, BiFunction)::: completable future then combine async:::return->defaultExecutor->biApplyStage
CompletableFuture#thenCombineAsync(CompletionStage, BiFunction, Executor)::: completable future then combine async:::return->screenExecutor->biApplyStage
CompletableFuture#thenAcceptBoth(CompletionStage, BiConsumer)::: completable future then accept both:::return->biAcceptStage
CompletableFuture#thenAcceptBothAsync(CompletionStage, BiConsumer)::: completable future then accept both async:::return->defaultExecutor->biAcceptStage
CompletableFuture#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor)::: completable future then accept both async:::return->screenExecutor->biAcceptStage
CompletableFuture#runAfterBoth(CompletionStage, Runnable)::: completable future run after both:::return->biRunStage
CompletableFuture#runAfterBothAsync(CompletionStage, Runnable)::: completable future run after both async:::return->defaultExecutor->biRunStage
CompletableFuture#runAfterBothAsync(CompletionStage, Runnable, Executor)::: completable future run after both async:::return->screenExecutor->biRunStage
CompletableFuture#applyToEither(CompletionStage, Function)::: completable future apply to either:::return->orApplyStage
CompletableFuture#applyToEitherAsync(CompletionStage, Function)::: completable future apply to either async:::return->defaultExecutor->orApplyStage
CompletableFuture#applyToEitherAsync(CompletionStage, Function, Executor)::: completable future apply to either async:::return->screenExecutor->orApplyStage
CompletableFuture#acceptEither(CompletionStage, Consumer)::: completable future accept either:::return->orAcceptStage
CompletableFuture#acceptEitherAsync(CompletionStage, Consumer)::: completable future accept either async:::return->defaultExecutor->orAcceptStage
CompletableFuture#acceptEitherAsync(CompletionStage, Consumer, Executor)::: completable future accept either async:::return->screenExecutor->orAcceptStage
CompletableFuture#runAfterEither(CompletionStage, Runnable)::: completable future run after either:::return->orRunStage
CompletableFuture#runAfterEitherAsync(CompletionStage, Runnable)::: completable future run after either async:::return->defaultExecutor->orRunStage
CompletableFuture#runAfterEitherAsync(CompletionStage, Runnable, Executor)::: completable future run after either async:::return->screenExecutor->orRunStage
CompletableFuture#thenCompose(Function>)::: completable future then compose:::return->uniComposeStage
CompletableFuture#thenComposeAsync(Function>)::: completable future then compose async:::return->defaultExecutor->uniComposeStage
CompletableFuture#thenComposeAsync(Function>, Executor)::: completable future then compose async:::return->screenExecutor->uniComposeStage
CompletableFuture#whenComplete(BiConsumer)::: completable future when complete:::return->uniWhenCompleteStage
CompletableFuture#whenCompleteAsync(BiConsumer)::: completable future when complete async:::return->defaultExecutor->uniWhenCompleteStage
CompletableFuture#whenCompleteAsync(BiConsumer, Executor)::: completable future when complete async:::return->screenExecutor->uniWhenCompleteStage
CompletableFuture#handle(BiFunction)::: completable future handle:::return->uniHandleStage
CompletableFuture#handleAsync(BiFunction)::: completable future handle async:::return->defaultExecutor->uniHandleStage
CompletableFuture#handleAsync(BiFunction, Executor)::: completable future handle async:::return->screenExecutor->uniHandleStage
CompletableFuture#toCompletableFuture():::Returns this CompletableFuture.:::return
CompletableFuture#exceptionally(Function):::Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value:::return->uniExceptionallyStage
CompletableFuture#allOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete:::return->andTree
CompletableFuture#anyOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result:::n->r->if->return->new->CompletableFuture<Object>->uniCopyStage->foreach->if->return->encodeRelay->new->CompletableFuture<Object>->cfs->clone->d->new->CompletableFuture<>->foreach->cf->new->AnyOf->unipush->if->for->i->len->return
CompletableFuture#cancel(boolean):::If not already completed, completes this CompletableFuture with a CancellationException:::cancelled->new->CancellationException->new->AltResult->internalComplete->postComplete->return->isCancelled
CompletableFuture#isCancelled():::Returns true if this CompletableFuture was cancelled before it completed normally.:::r->return
CompletableFuture#isCompletedExceptionally():::Returns true if this CompletableFuture completed exceptionally, in any way:::r->return
CompletableFuture#obtrudeValue(T):::Forcibly sets or resets the value subsequently returned by method #get() and related methods, whether or not already completed:::postComplete
CompletableFuture#obtrudeException(Throwable):::Forcibly causes subsequent invocations of method #get() and related methods to throw the given exception, whether or not already completed:::if->throw->new->NullPointerException->new->AltResult->postComplete
CompletableFuture#getNumberOfDependents():::Returns the estimated number of CompletableFutures whose completions are awaiting completion of this CompletableFuture:::count->for->p->return
CompletableFuture#toString():::Returns a string identifying this CompletableFuture, as well as its completion state:::r->count->for->p->return->super->toString
CompletableFuture#newIncompleteFuture():::Returns a new incomplete CompletableFuture of the type to be returned by a CompletionStage method:::return->new->CompletableFuture<U>
CompletableFuture#defaultExecutor():::Returns the default Executor used for async methods that do not specify an Executor:::return
CompletableFuture#copy():::Returns a new CompletableFuture that is completed normally with the same value as this CompletableFuture when it completes normally:::return->uniCopyStage
CompletableFuture#minimalCompletionStage():::Returns a new CompletionStage that is completed normally with the same value as this CompletableFuture when it completes normally, and cannot be independently completed or otherwise used in ways not defined by the methods of interface CompletionStage:::return->uniAsMinimalStage
CompletableFuture#completeAsync(Supplier, Executor):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the given executor.:::if->throw->new->NullPointerException->executor->new->AsyncSupply<T>->execute->return
CompletableFuture#completeAsync(Supplier):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the default executor.:::return->defaultExecutor->completeAsync
CompletableFuture#orTimeout(long, TimeUnit):::Exceptionally completes this CompletableFuture with a TimeoutException if not otherwise completed before the given timeout.:::if->throw->new->NullPointerException->if->Delayer->new->Timeout->delay->new->Canceller->whenComplete->return
CompletableFuture#completeOnTimeout(T, long, TimeUnit):::Completes this CompletableFuture with the given value if not otherwise completed before the given timeout.:::if->throw->new->NullPointerException->if->Delayer->new->DelayedCompleter<T>->delay->new->Canceller->whenComplete->return
CompletableFuture#delayedExecutor(long, TimeUnit, Executor):::Returns a new Executor that submits a task to the given base executor after the given delay (or no delay if non-positive):::if->throw->new->NullPointerException->return->new->DelayedExecutor
CompletableFuture#delayedExecutor(long, TimeUnit):::Returns a new Executor that submits a task to the default executor after the given delay (or no delay if non-positive):::if->throw->new->NullPointerException->return->new->DelayedExecutor
CompletableFuture#completedStage(U):::Returns a new CompletionStage that is already completed with the given value and supports only those methods in interface CompletionStage.:::return->new->MinimalStage<U>
CompletableFuture#failedFuture(Throwable):::Returns a new CompletableFuture that is already completed exceptionally with the given exception.:::if->throw->new->NullPointerException->return->new->AltResult->new->CompletableFuture<U>
CompletableFuture#failedStage(Throwable):::Returns a new CompletionStage that is already completed exceptionally with the given exception and supports only those methods in interface CompletionStage.:::if->throw->new->NullPointerException->return->new->AltResult->new->MinimalStage<U>
CompletableFuture.Delayer#delay(Runnable, long, TimeUnit)::: delayer delay:::return->delayer->schedule
CompletableFuture.Delayer.DaemonThreadFactory#newThread(Runnable)::: daemon thread factory new thread:::t->new->Thread->t->setDaemon->t->setName->return
CompletableFuture.DelayedExecutor#execute(Runnable)::: delayed executor execute:::Delayer->new->TaskSubmitter->delay
CompletableFuture.TaskSubmitter#run()::: task submitter run:::executor->execute
CompletableFuture.Timeout#run()::: timeout run:::if->f->isDone->f->new->TimeoutException->completeExceptionally
CompletableFuture.DelayedCompleter#run()::: delayed completer run:::if->f->complete
CompletableFuture.Canceller#accept(Object, Throwable)::: canceller accept:::if->f->isDone->f->cancel
CompletableFuture.MinimalStage#newIncompleteFuture()::: minimal stage new incomplete future:::return->new->MinimalStage<U>
CompletableFuture.MinimalStage#get()::: minimal stage get:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#get(long, TimeUnit)::: minimal stage get:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#getNow(T)::: minimal stage get now:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#join()::: minimal stage join:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#complete(T)::: minimal stage complete:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#completeExceptionally(Throwable)::: minimal stage complete exceptionally:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#cancel(boolean)::: minimal stage cancel:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#obtrudeValue(T)::: minimal stage obtrude value:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#obtrudeException(Throwable)::: minimal stage obtrude exception:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#isDone()::: minimal stage is done:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#isCancelled()::: minimal stage is cancelled:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#isCompletedExceptionally()::: minimal stage is completed exceptionally:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#getNumberOfDependents()::: minimal stage get number of dependents:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#completeAsync(Supplier, Executor)::: minimal stage complete async:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#completeAsync(Supplier)::: minimal stage complete async:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#orTimeout(long, TimeUnit)::: minimal stage or timeout:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#completeOnTimeout(T, long, TimeUnit)::: minimal stage complete on timeout:::throw->new->UnsupportedOperationException
CompletableFuture.MinimalStage#toCompletableFuture()::: minimal stage to completable future:::r->if->return->encodeRelay->new->CompletableFuture<T>->else->d->new->CompletableFuture<>->new->UniRelay<T,T>->unipush->return
CompletionService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
CompletionService#submit(Runnable, V):::Submits a Runnable task for execution and returns a Future representing that task:::
CompletionService#take():::Retrieves and removes the Future representing the next completed task, waiting if none are yet present.:::
CompletionService#poll():::Retrieves and removes the Future representing the next completed task, or null if none are present.:::
CompletionService#poll(long, TimeUnit):::Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.:::
CompletionStage#thenApply(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function:::
CompletionStage#thenAccept(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied action:::
CompletionStage#thenRun(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action:::
CompletionStage#thenRunAsync(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#thenRunAsync(Runnable, Executor):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using the supplied Executor:::
CompletionStage#thenCombine(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function:::
CompletionStage#thenAcceptBoth(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied action:::
CompletionStage#runAfterBoth(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using the supplied executor:::
CompletionStage#applyToEither(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function:::
CompletionStage#acceptEither(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied action:::
CompletionStage#runAfterEither(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using the supplied executor:::
CompletionStage#thenCompose(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function:::
CompletionStage#thenComposeAsync(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using this stage's default asynchronous execution facility:::
CompletionStage#thenComposeAsync(Function>, Executor):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using the supplied Executor:::
CompletionStage#handle(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using this stage's default asynchronous execution facility, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction, Executor):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using the supplied executor, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#whenComplete(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using this stage's default asynchronous execution facility when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer, Executor):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using the supplied Executor when this stage completes:::
CompletionStage#exceptionally(Function):::Returns a new CompletionStage that, when this stage completes exceptionally, is executed with this stage's exception as the argument to the supplied function:::
CompletionStage#toCompletableFuture():::Returns a CompletableFuture maintaining the same completion properties as this stage:::
ConcurrentHashMap.Node#getKey()::: node get key:::return
ConcurrentHashMap.Node#getValue()::: node get value:::return
ConcurrentHashMap.Node#hashCode()::: node hash code:::return->key->hashCode->val->hashCode
ConcurrentHashMap.Node#toString()::: node to string:::return->Helpers->mapEntryToString
ConcurrentHashMap.Node#setValue(V)::: node set value:::throw->new->UnsupportedOperationException
ConcurrentHashMap.Node#equals(Object)::: node equals:::k->v->u->e->return->getKey->e->getValue->k->equals->v->equals
ConcurrentHashMap.Node#find(int, Object):::Virtualized support for map.get(); overridden in subclasses.:::e->if->do->ek->if->k->equals->return->while->return
ConcurrentHashMap#spread(int):::Spreads (XORs) higher bits of hash to lower and also forces top bit to 0:::return
ConcurrentHashMap#tableSizeFor(int):::Returns a power of two table size for the given desired capacity:::n->Integer->numberOfLeadingZeros->return
ConcurrentHashMap#comparableClassFor(Object):::Returns x's Class if it is of the form "class C implements Comparable<C>", else null.:::if->c->ts->as->p->if->x->getClass->return->if->c->getGenericInterfaces->foreach->if->getRawType->p->getActualTypeArguments->return->return
ConcurrentHashMap#compareComparables(Class, Object, Object):::Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.:::return->x->getClass->compareTo
ConcurrentHashMap#tabAt(Node[], int)::: concurrent hash map tab at:::return->U->getObjectAcquire
ConcurrentHashMap#casTabAt(Node[], int, Node, Node)::: concurrent hash map cas tab at:::return->U->compareAndSetObject
ConcurrentHashMap#setTabAt(Node[], int, Node)::: concurrent hash map set tab at:::U->putObjectRelease
ConcurrentHashMap#size()::: concurrent hash map size:::n->sumCount->return
ConcurrentHashMap#isEmpty()::: concurrent hash map is empty:::return->sumCount
ConcurrentHashMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::tab->e->p->n->eh->ek->h->key->hashCode->spread->if->tabAt->if->if->key->equals->return->else->if->return->e->find->while->if->key->equals->return->return
ConcurrentHashMap#containsKey(Object):::Tests if the specified object is a key in this table.:::return->get
ConcurrentHashMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#put(K, V):::Maps the specified key to the specified value in this table:::return->putVal
ConcurrentHashMap#putVal(K, V, boolean):::Implementation for put and putIfAbsent:::if->throw->new->NullPointerException->hash->key->hashCode->spread->binCount->for->tab->addCount->return
ConcurrentHashMap#putAll(Map):::Copies all of the mappings from the specified map to this one:::m->size->tryPresize->foreach->m->entrySet->e->getKey->e->getValue->putVal
ConcurrentHashMap#remove(Object):::Removes the key (and its corresponding value) from this map:::return->replaceNode
ConcurrentHashMap#replaceNode(Object, V, Object):::Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null:::hash->key->hashCode->spread->for->tab->return
ConcurrentHashMap#clear():::Removes all of the mappings from this map.:::delta->i->tab->while->fh->f->tabAt->if->else->if->helpTransfer->else->synchronized->if->tabAt->p->while->setTabAt->if->addCount
ConcurrentHashMap#keySet():::Returns a Set view of the keys contained in this map:::ks->if->return->return->new->KeySetView<K,V>
ConcurrentHashMap#values():::Returns a Collection view of the values contained in this map:::vs->if->return->return->new->ValuesView<K,V>
ConcurrentHashMap#entrySet():::Returns a Set view of the mappings contained in this map:::es->if->return->return->new->EntrySetView<K,V>
ConcurrentHashMap#hashCode():::Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().:::h->t->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#toString():::Returns a string representation of this map:::t->f->it->new->Traverser<K,V>->sb->new->StringBuilder->sb->append->p->if->it->advance->for->return->sb->append->toString
ConcurrentHashMap#equals(Object):::Compares the specified object with this map for equality:::if->if->return->m->t->f->it->new->Traverser<K,V>->for->p->it->advance->foreach->m->entrySet->mk->mv->v->if->e->getKey->e->getValue->get->mv->equals->return->return
ConcurrentHashMap#writeObject(java.io.ObjectOutputStream):::Saves this map to a stream (that is, serializes it).:::sshift->ssize->while->segmentShift->segmentMask->segments->new->Segment<?,?>Arr->for->i->streamFields->s->putFields->streamFields->put->streamFields->put->streamFields->put->s->writeFields->t->if->it->new->Traverser<K,V>->for->p->it->advance->s->writeObject->s->writeObject
ConcurrentHashMap#readObject(java.io.ObjectInputStream):::Reconstitutes this map from a stream (that is, deserializes it).:::s->defaultReadObject->size->p->for->if->else->ts->n->tableSizeFor->tab->new->Node<?,?>Arr->mask->added->while->insertAtFront->next->first->h->j->if->tabAt->else->k->if->t->if->t->putTreeVal->else->binCount->q->qk->for->if->hd->tl->for->new->TreeBin<K,V>->setTabAt->if->setTabAt
ConcurrentHashMap#putIfAbsent(K, V)::: concurrent hash map put if absent:::return->putVal
ConcurrentHashMap#remove(Object, Object)::: concurrent hash map remove:::if->throw->new->NullPointerException->return->replaceNode
ConcurrentHashMap#replace(K, V, V)::: concurrent hash map replace:::if->throw->new->NullPointerException->return->replaceNode
ConcurrentHashMap#replace(K, V)::: concurrent hash map replace:::if->throw->new->NullPointerException->return->replaceNode
ConcurrentHashMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.:::v->return->get
ConcurrentHashMap#forEach(BiConsumer)::: concurrent hash map for each:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance
ConcurrentHashMap#replaceAll(BiFunction)::: concurrent hash map replace all:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance
ConcurrentHashMap#removeEntryIf(Predicate>):::Helper method for EntrySetView.removeIf.:::if->throw->new->NullPointerException->t->removed->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#removeValueIf(Predicate):::Helper method for ValuesView.removeIf.:::if->throw->new->NullPointerException->t->removed->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->binCount->for->tab->if->addCount->return
ConcurrentHashMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#merge(K, V, BiFunction):::If the specified key is not already associated with a (non-null) value, associates it with the given value:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#contains(Object):::Tests if some key maps into the specified value in this table:::return->containsValue
ConcurrentHashMap#keys():::Returns an enumeration of the keys in this table.:::t->f->return->new->KeyIterator<K,V>
ConcurrentHashMap#elements():::Returns an enumeration of the values in this table.:::t->f->return->new->ValueIterator<K,V>
ConcurrentHashMap#mappingCount():::Returns the number of mappings:::n->sumCount->return
ConcurrentHashMap#newKeySet():::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::return->new->ConcurrentHashMap<K,Boolean>->new->KeySetView<K,Boolean>
ConcurrentHashMap#newKeySet(int):::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::return->new->ConcurrentHashMap<K,Boolean>->new->KeySetView<K,Boolean>
ConcurrentHashMap#keySet(V):::Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., Collection#add and Collection#addAll(Collection)):::if->throw->new->NullPointerException->return->new->KeySetView<K,V>
ConcurrentHashMap.ForwardingNode#find(int, Object)::: forwarding node find:::for->tab
ConcurrentHashMap.ReservationNode#find(int, Object)::: reservation node find:::return
ConcurrentHashMap#resizeStamp(int):::Returns the stamp bits for resizing a table of size n:::return->Integer->numberOfLeadingZeros
ConcurrentHashMap#initTable():::Initializes table, using the size recorded in sizeCtl.:::tab->sc->while->if->Thread->yield->else->if->U->compareAndSetInt->try->if->n->nt->new->Node<?,?>Arr->catch->finally->break->return
ConcurrentHashMap#addCount(long, int):::Adds to count, and if table is too small and not already resizing, initiates transfer:::cs->b->s->if->U->compareAndSetLong->c->v->m->uncontended->if->ThreadLocalRandom->getProbe->U->compareAndSetLong->fullAddCount->return->if->return->sumCount->if->tab->nt->n->sc->while->rs->resizeStamp->if->if->break->if->U->compareAndSetInt->transfer->else->if->U->compareAndSetInt->transfer->sumCount
ConcurrentHashMap#helpTransfer(Node[], Node):::Helps transfer if a resize is in progress.:::nextTab->sc->if->rs->resizeStamp->while->if->break->if->U->compareAndSetInt->transfer->break->return->return
ConcurrentHashMap#tryPresize(int):::Tries to presize table to accommodate the given number of elements.:::c->tableSizeFor->sc->while->tab->n->if->if->U->compareAndSetInt->try->if->nt->new->Node<?,?>Arr->catch->finally->else->if->break->else->if->rs->resizeStamp->if->U->compareAndSetInt->transfer
ConcurrentHashMap#transfer(Node[], Node[]):::Moves and/or copies the nodes in each bin to new table:::n->stride->if->if->try->nt->new->Node<?,?>Arr->catch->return->finally->nextn->fwd->new->ForwardingNode<K,V>->advance->finishing->for->i->bound
ConcurrentHashMap#sumCount()::: concurrent hash map sum count:::cs->sum->if->foreach->if->return
ConcurrentHashMap#fullAddCount(long, boolean)::: concurrent hash map full add count:::h->if->ThreadLocalRandom->getProbe->ThreadLocalRandom->localInit->ThreadLocalRandom->getProbe->collide->for
ConcurrentHashMap#treeifyBin(Node[], int):::Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.:::b->n->if->if->tryPresize->else->if->tabAt->synchronized->if->tabAt->hd->tl->for->e->new->TreeBin<K,V>->setTabAt
ConcurrentHashMap#untreeify(Node):::Returns a list of non-TreeNodes replacing those in given list.:::hd->tl->for->q->return
ConcurrentHashMap.TreeNode#find(int, Object)::: tree node find:::return->findTreeNode
ConcurrentHashMap.TreeNode#findTreeNode(int, Object, Class):::Returns the TreeNode (or null if not found) for the given key starting at given root.:::if->p->do->ph->dir->pk->q->pl->pr->if->else->if->else->if->k->equals->return->else->if->else->if->else->if->comparableClassFor->compareComparables->else->if->pr->findTreeNode->return->else->while->return
ConcurrentHashMap.TreeBin#tieBreakOrder(Object, Object):::Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable:::d->if->a->getClass->getName->b->getClass->getName->compareTo->System->identityHashCode->System->identityHashCode->return
ConcurrentHashMap.TreeBin#lockRoot():::Acquires write lock for tree restructuring.:::if->U->compareAndSetInt->contendedLock
ConcurrentHashMap.TreeBin#unlockRoot():::Releases write lock for tree restructuring.:::
ConcurrentHashMap.TreeBin#contendedLock():::Possibly blocks awaiting root lock.:::waiting->for->s
ConcurrentHashMap.TreeBin#find(int, Object):::Returns matching node or null if none:::if->for->e->return
ConcurrentHashMap.TreeBin#putTreeVal(int, K, V):::Finds or adds a node.:::kc->searched->for->p->return
ConcurrentHashMap.TreeBin#removeTreeNode(TreeNode):::Removes the given node, that must be present before this call:::next->pred->r->rl->if->else->if->if->return->if->return->lockRoot->try->replacement->pl->pr->if->s->sl->while->c->sr->pp->if->else->sp->if->if->else->if->if->if->if->else->if->else->if->else->else->if->else->if->else->if->pp->if->else->if->else->balanceDeletion->if->pp->if->if->else->if->catch->finally->unlockRoot->return
ConcurrentHashMap.TreeBin#rotateLeft(TreeNode, TreeNode)::: tree bin rotate left:::r->pp->rl->if->if->if->else->if->else->return
ConcurrentHashMap.TreeBin#rotateRight(TreeNode, TreeNode)::: tree bin rotate right:::l->pp->lr->if->if->if->else->if->else->return
ConcurrentHashMap.TreeBin#balanceInsertion(TreeNode, TreeNode)::: tree bin balance insertion:::for->xp->xpp->xppl->xppr
ConcurrentHashMap.TreeBin#balanceDeletion(TreeNode, TreeNode)::: tree bin balance deletion:::for->xp->xpl->xpr
ConcurrentHashMap.TreeBin#checkInvariants(TreeNode):::Checks invariants recursively for the tree of Nodes rooted at t.:::tp->tl->tr->tb->tn->if->return->if->return->if->return->if->return->if->return->if->return->if->checkInvariants->return->if->checkInvariants->return->return
ConcurrentHashMap.Traverser#advance():::Advances if possible, returning next valid node, or null if none.:::e->if->for
ConcurrentHashMap.Traverser#pushState(Node[], int, int):::Saves traversal state upon encountering a forwarding node.:::s->if->else->new->TableStack<K,V>
ConcurrentHashMap.Traverser#recoverState(int):::Possibly pops traversal state.:::s->len->while->next->if
ConcurrentHashMap.BaseIterator#hasNext()::: base iterator has next:::return
ConcurrentHashMap.BaseIterator#hasMoreElements()::: base iterator has more elements:::return
ConcurrentHashMap.BaseIterator#remove()::: base iterator remove:::p->if->throw->new->IllegalStateException->map->replaceNode
ConcurrentHashMap.KeyIterator#next()::: key iterator next:::p->if->throw->new->NoSuchElementException->k->advance->return
ConcurrentHashMap.KeyIterator#nextElement()::: key iterator next element:::return->next
ConcurrentHashMap.ValueIterator#next()::: value iterator next:::p->if->throw->new->NoSuchElementException->v->advance->return
ConcurrentHashMap.ValueIterator#nextElement()::: value iterator next element:::return->next
ConcurrentHashMap.EntryIterator#next()::: entry iterator next:::p->if->throw->new->NoSuchElementException->k->v->advance->return->new->MapEntry<K,V>
ConcurrentHashMap.MapEntry#getKey()::: map entry get key:::return
ConcurrentHashMap.MapEntry#getValue()::: map entry get value:::return
ConcurrentHashMap.MapEntry#hashCode()::: map entry hash code:::return->key->hashCode->val->hashCode
ConcurrentHashMap.MapEntry#toString()::: map entry to string:::return->Helpers->mapEntryToString
ConcurrentHashMap.MapEntry#equals(Object)::: map entry equals:::k->v->e->return->getKey->e->getValue->k->equals->v->equals
ConcurrentHashMap.MapEntry#setValue(V):::Sets our entry's value and writes through to the map:::if->throw->new->NullPointerException->v->map->put->return
ConcurrentHashMap.KeySpliterator#trySplit()::: key spliterator try split:::i->f->h->return->new->KeySpliterator<K,V>
ConcurrentHashMap.KeySpliterator#forEachRemaining(Consumer)::: key spliterator for each remaining:::if->throw->new->NullPointerException->for->p->advance
ConcurrentHashMap.KeySpliterator#tryAdvance(Consumer)::: key spliterator try advance:::if->throw->new->NullPointerException->p->if->advance->return->action->accept->return
ConcurrentHashMap.KeySpliterator#estimateSize()::: key spliterator estimate size:::return
ConcurrentHashMap.KeySpliterator#characteristics()::: key spliterator characteristics:::return
ConcurrentHashMap.ValueSpliterator#trySplit()::: value spliterator try split:::i->f->h->return->new->ValueSpliterator<K,V>
ConcurrentHashMap.ValueSpliterator#forEachRemaining(Consumer)::: value spliterator for each remaining:::if->throw->new->NullPointerException->for->p->advance
ConcurrentHashMap.ValueSpliterator#tryAdvance(Consumer)::: value spliterator try advance:::if->throw->new->NullPointerException->p->if->advance->return->action->accept->return
ConcurrentHashMap.ValueSpliterator#estimateSize()::: value spliterator estimate size:::return
ConcurrentHashMap.ValueSpliterator#characteristics()::: value spliterator characteristics:::return
ConcurrentHashMap.EntrySpliterator#trySpliterator trySplit()::: entry spliterator try split:::i->f->h->return->new->EntrySpliterator<K,V>
ConcurrentHashMap.EntrySpliterator#forEachRemaining(Consumer>)::: entry spliterator for each remaining:::if->throw->new->NullPointerException->for->p->advance
ConcurrentHashMap.EntrySpliterator#tryAdvance(Consumer>)::: entry spliterator try advance:::if->throw->new->NullPointerException->p->if->advance->return->action->new->MapEntry<K,V>->accept->return
ConcurrentHashMap.EntrySpliterator#estimateSize()::: entry spliterator estimate size:::return
ConcurrentHashMap.EntrySpliterator#characteristics()::: entry spliterator characteristics:::return
ConcurrentHashMap#batchFor(long):::Computes initial batch value for bulk tasks:::n->if->sumCount->return->sp->ForkJoinPool->getCommonPoolParallelism->return
ConcurrentHashMap#forEach(long, BiConsumer):::Performs the given action for each (key, value).:::if->throw->new->NullPointerException->batchFor->new->ForEachMappingTask<K,V>->invoke
ConcurrentHashMap#forEach(long, BiFunction, Consumer):::Performs the given action for each non-null transformation of each (key, value).:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedMappingTask<K,V,U>->invoke
ConcurrentHashMap#search(long, BiFunction):::Returns a non-null result from applying the given search function on each (key, value), or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchMappingsTask<K,V,U>->invoke
ConcurrentHashMap#reduce(long, BiFunction, BiFunction):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsTask<K,V,U>->invoke
ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceToLong(long, ToLongBiFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToLongTask<K,V>->invoke
ConcurrentHashMap#reduceToInt(long, ToIntBiFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToIntTask<K,V>->invoke
ConcurrentHashMap#forEachKey(long, Consumer):::Performs the given action for each key.:::if->throw->new->NullPointerException->batchFor->new->ForEachKeyTask<K,V>->invoke
ConcurrentHashMap#forEachKey(long, Function, Consumer):::Performs the given action for each non-null transformation of each key.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedKeyTask<K,V,U>->invoke
ConcurrentHashMap#searchKeys(long, Function):::Returns a non-null result from applying the given search function on each key, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchKeysTask<K,V,U>->invoke
ConcurrentHashMap#reduceKeys(long, BiFunction):::Returns the result of accumulating all keys using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceKeysTask<K,V>->invoke
ConcurrentHashMap#reduceKeys(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysTask<K,V,U>->invoke
ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToLongTask<K,V>->invoke
ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToIntTask<K,V>->invoke
ConcurrentHashMap#forEachValue(long, Consumer):::Performs the given action for each value.:::if->throw->new->NullPointerException->batchFor->new->ForEachValueTask<K,V>->invoke
ConcurrentHashMap#forEachValue(long, Function, Consumer):::Performs the given action for each non-null transformation of each value.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedValueTask<K,V,U>->invoke
ConcurrentHashMap#searchValues(long, Function):::Returns a non-null result from applying the given search function on each value, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchValuesTask<K,V,U>->invoke
ConcurrentHashMap#reduceValues(long, BiFunction):::Returns the result of accumulating all values using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceValuesTask<K,V>->invoke
ConcurrentHashMap#reduceValues(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesTask<K,V,U>->invoke
ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToLongTask<K,V>->invoke
ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToIntTask<K,V>->invoke
ConcurrentHashMap#forEachEntry(long, Consumer>):::Performs the given action for each entry.:::if->throw->new->NullPointerException->batchFor->new->ForEachEntryTask<K,V>->invoke
ConcurrentHashMap#forEachEntry(long, Function, ? extends U>, Consumer):::Performs the given action for each non-null transformation of each entry.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedEntryTask<K,V,U>->invoke
ConcurrentHashMap#searchEntries(long, Function, ? extends U>):::Returns a non-null result from applying the given search function on each entry, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchEntriesTask<K,V,U>->invoke
ConcurrentHashMap#reduceEntries(long, BiFunction, Map.Entry, ? extends Map.Entry>):::Returns the result of accumulating all entries using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceEntriesTask<K,V>->invoke
ConcurrentHashMap#reduceEntries(long, Function, ? extends U>, BiFunction):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesTask<K,V,U>->invoke
ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction>, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction>, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToLongTask<K,V>->invoke
ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction>, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToIntTask<K,V>->invoke
ConcurrentHashMap.CollectionView#getMap():::Returns the map backing this view.:::return
ConcurrentHashMap.CollectionView#clear():::Removes all of the elements from this view, by removing all the mappings from the map backing this view.:::map->clear
ConcurrentHashMap.CollectionView#size()::: collection view size:::return->map->size
ConcurrentHashMap.CollectionView#isEmpty()::: collection view is empty:::return->map->isEmpty
ConcurrentHashMap.CollectionView#iterator():::Returns an iterator over the elements in this collection:::
ConcurrentHashMap.CollectionView#contains(Object)::: collection view contains:::
ConcurrentHashMap.CollectionView#remove(Object)::: collection view remove:::
ConcurrentHashMap.CollectionView#toArray()::: collection view to array:::sz->map->mappingCount->if->throw->new->OutOfMemoryError->n->r->new->ObjectArr->i->foreach->if->if->throw->new->OutOfMemoryError->if->else->Arrays->copyOf->return->Arrays->copyOf
ConcurrentHashMap.CollectionView#toArray(T[])::: collection view to array:::sz->map->mappingCount->if->throw->new->OutOfMemoryError->m->r->a->getClass->getComponentType->newInstance->n->i->foreach->if->if->throw->new->OutOfMemoryError->if->else->Arrays->copyOf->if->return->return->Arrays->copyOf
ConcurrentHashMap.CollectionView#toString():::Returns a string representation of this collection:::sb->new->StringBuilder->sb->append->it->iterator->if->it->hasNext->for->return->sb->append->toString
ConcurrentHashMap.CollectionView#containsAll(Collection)::: collection view contains all:::if->foreach->if->contains->return->return
ConcurrentHashMap.CollectionView#removeAll(Collection)::: collection view remove all:::if->throw->new->NullPointerException->modified->t->if->return->else->if->c->size->for->it->iterator->it->hasNext->else->foreach->remove->return
ConcurrentHashMap.CollectionView#retainAll(Collection)::: collection view retain all:::if->throw->new->NullPointerException->modified->for->it->iterator->it->hasNext->return
ConcurrentHashMap.KeySetView#getMappedValue():::Returns the default mapped value for additions, or null if additions are not supported.:::return
ConcurrentHashMap.KeySetView#contains(Object)::: key set view contains:::return->map->containsKey
ConcurrentHashMap.KeySetView#remove(Object):::Removes the key from this map view, by removing the key (and its corresponding value) from the backing map:::return->map->remove
ConcurrentHashMap.KeySetView#iterator()::: key set view iterator:::t->m->f->return->new->KeyIterator<K,V>
ConcurrentHashMap.KeySetView#add(K):::Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.:::v->if->throw->new->UnsupportedOperationException->return->map->putVal
ConcurrentHashMap.KeySetView#addAll(Collection):::Adds all of the elements in the specified collection to this set, as if by calling #add on each one.:::added->v->if->throw->new->UnsupportedOperationException->foreach->if->map->putVal->return
ConcurrentHashMap.KeySetView#hashCode()::: key set view hash code:::h->foreach->e->hashCode->return
ConcurrentHashMap.KeySetView#equals(Object)::: key set view equals:::c->return->containsAll->c->containsAll
ConcurrentHashMap.KeySetView#spliterator()::: key set view spliterator:::t->m->n->m->sumCount->f->return->new->KeySpliterator<K,V>
ConcurrentHashMap.KeySetView#forEach(Consumer)::: key set view for each:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance
ConcurrentHashMap.ValuesView#contains(Object)::: values view contains:::return->map->containsValue
ConcurrentHashMap.ValuesView#remove(Object)::: values view remove:::if->for->it->iterator->it->hasNext->return
ConcurrentHashMap.ValuesView#iterator()::: values view iterator:::m->t->f->return->new->ValueIterator<K,V>
ConcurrentHashMap.ValuesView#add(V)::: values view add:::throw->new->UnsupportedOperationException
ConcurrentHashMap.ValuesView#addAll(Collection)::: values view add all:::throw->new->UnsupportedOperationException
ConcurrentHashMap.ValuesView#removeAll(Collection)::: values view remove all:::if->throw->new->NullPointerException->modified->for->it->iterator->it->hasNext->return
ConcurrentHashMap.ValuesView#removeIf(Predicate)::: values view remove if:::return->map->removeValueIf
ConcurrentHashMap.ValuesView#spliterator()::: values view spliterator:::t->m->n->m->sumCount->f->return->new->ValueSpliterator<K,V>
ConcurrentHashMap.ValuesView#forEach(Consumer)::: values view for each:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance
ConcurrentHashMap.EntrySetView#contains(Object)::: entry set view contains:::k->v->r->e->return->getKey->map->get->e->getValue->v->equals
ConcurrentHashMap.EntrySetView#remove(Object)::: entry set view remove:::k->v->e->return->getKey->e->getValue->map->remove
ConcurrentHashMap.EntrySetView#iterator()::: entry set view iterator:::m->t->f->return->new->EntryIterator<K,V>
ConcurrentHashMap.EntrySetView#add(Entry)::: entry set view add:::return->map->e->getKey->e->getValue->putVal
ConcurrentHashMap.EntrySetView#addAll(Collection>)::: entry set view add all:::added->foreach->if->add->return
ConcurrentHashMap.EntrySetView#removeIf(Predicate>)::: entry set view remove if:::return->map->removeEntryIf
ConcurrentHashMap.EntrySetView#hashCode()::: entry set view hash code:::h->t->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap.EntrySetView#equals(Object)::: entry set view equals:::c->return->containsAll->c->containsAll
ConcurrentHashMap.EntrySetView#spliterator()::: entry set view spliterator:::t->m->n->m->sumCount->f->return->new->EntrySpliterator<K,V>
ConcurrentHashMap.EntrySetView#forEach(Consumer>)::: entry set view for each:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance
ConcurrentHashMap.BulkTask#advance():::Same as Traverser version.:::e->if->for
ConcurrentHashMap.BulkTask#pushState(Node[], int, int)::: bulk task push state:::s->if->else->new->TableStack<K,V>
ConcurrentHashMap.BulkTask#recoverState(int)::: bulk task recover state:::s->len->while->next->if
ConcurrentHashMap.ForEachKeyTask#compute()::: for each key task compute:::action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachValueTask#compute()::: for each value task compute:::action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachEntryTask#compute()::: for each entry task compute:::action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachMappingTask#compute()::: for each mapping task compute:::action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachTransformedKeyTask#compute()::: for each transformed key task compute:::transformer->action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachTransformedValueTask#compute()::: for each transformed value task compute:::transformer->action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachTransformedEntryTask#compute()::: for each transformed entry task compute:::transformer->action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.ForEachTransformedMappingTask#compute()::: for each transformed mapping task compute:::transformer->action->if->for->i->f->h->for->p->advance->propagateCompletion
ConcurrentHashMap.SearchKeysTask#getRawResult()::: search keys task get raw result:::return->result->get
ConcurrentHashMap.SearchKeysTask#compute()::: search keys task compute:::searchFunction->result->if->for->i->f->h->while->result->get->u->p->if->advance->propagateCompletion->break->if->searchFunction->apply->if->result->compareAndSet->quietlyCompleteRoot->break
ConcurrentHashMap.SearchValuesTask#getRawResult()::: search values task get raw result:::return->result->get
ConcurrentHashMap.SearchValuesTask#compute()::: search values task compute:::searchFunction->result->if->for->i->f->h->while->result->get->u->p->if->advance->propagateCompletion->break->if->searchFunction->apply->if->result->compareAndSet->quietlyCompleteRoot->break
ConcurrentHashMap.SearchEntriesTask#getRawResult()::: search entries task get raw result:::return->result->get
ConcurrentHashMap.SearchEntriesTask#compute()::: search entries task compute:::searchFunction->result->if->for->i->f->h->while->result->get->u->p->if->advance->propagateCompletion->break->if->searchFunction->apply->if->result->compareAndSet->quietlyCompleteRoot->return
ConcurrentHashMap.SearchMappingsTask#getRawResult()::: search mappings task get raw result:::return->result->get
ConcurrentHashMap.SearchMappingsTask#compute()::: search mappings task compute:::searchFunction->result->if->for->i->f->h->while->result->get->u->p->if->advance->propagateCompletion->break->if->searchFunction->apply->if->result->compareAndSet->quietlyCompleteRoot->break
ConcurrentHashMap.ReduceKeysTask#getRawResult()::: reduce keys task get raw result:::return
ConcurrentHashMap.ReduceKeysTask#compute()::: reduce keys task compute:::reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.ReduceValuesTask#getRawResult()::: reduce values task get raw result:::return
ConcurrentHashMap.ReduceValuesTask#compute()::: reduce values task compute:::reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.ReduceEntriesTask#getRawResult()::: reduce entries task get raw result:::return
ConcurrentHashMap.ReduceEntriesTask#compute()::: reduce entries task compute:::reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceKeysTask#getRawResult()::: map reduce keys task get raw result:::return
ConcurrentHashMap.MapReduceKeysTask#compute()::: map reduce keys task compute:::transformer->reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceValuesTask#getRawResult()::: map reduce values task get raw result:::return
ConcurrentHashMap.MapReduceValuesTask#compute()::: map reduce values task compute:::transformer->reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceEntriesTask#getRawResult()::: map reduce entries task get raw result:::return
ConcurrentHashMap.MapReduceEntriesTask#compute()::: map reduce entries task compute:::transformer->reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceMappingsTask#getRawResult()::: map reduce mappings task get raw result:::return
ConcurrentHashMap.MapReduceMappingsTask#compute()::: map reduce mappings task compute:::transformer->reducer->if->for->i->f->h->r->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceKeysToDoubleTask#getRawResult()::: map reduce keys to double task get raw result:::return
ConcurrentHashMap.MapReduceKeysToDoubleTask#compute()::: map reduce keys to double task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceValuesToDoubleTask#getRawResult()::: map reduce values to double task get raw result:::return
ConcurrentHashMap.MapReduceValuesToDoubleTask#compute()::: map reduce values to double task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceEntriesToDoubleTask#getRawResult()::: map reduce entries to double task get raw result:::return
ConcurrentHashMap.MapReduceEntriesToDoubleTask#compute()::: map reduce entries to double task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceMappingsToDoubleTask#getRawResult()::: map reduce mappings to double task get raw result:::return
ConcurrentHashMap.MapReduceMappingsToDoubleTask#compute()::: map reduce mappings to double task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceKeysToLongTask#getRawResult()::: map reduce keys to long task get raw result:::return
ConcurrentHashMap.MapReduceKeysToLongTask#compute()::: map reduce keys to long task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceValuesToLongTask#getRawResult()::: map reduce values to long task get raw result:::return
ConcurrentHashMap.MapReduceValuesToLongTask#compute()::: map reduce values to long task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceEntriesToLongTask#getRawResult()::: map reduce entries to long task get raw result:::return
ConcurrentHashMap.MapReduceEntriesToLongTask#compute()::: map reduce entries to long task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceMappingsToLongTask#getRawResult()::: map reduce mappings to long task get raw result:::return
ConcurrentHashMap.MapReduceMappingsToLongTask#compute()::: map reduce mappings to long task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceKeysToIntTask#getRawResult()::: map reduce keys to int task get raw result:::return
ConcurrentHashMap.MapReduceKeysToIntTask#compute()::: map reduce keys to int task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceValuesToIntTask#getRawResult()::: map reduce values to int task get raw result:::return
ConcurrentHashMap.MapReduceValuesToIntTask#compute()::: map reduce values to int task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceEntriesToIntTask#getRawResult()::: map reduce entries to int task get raw result:::return
ConcurrentHashMap.MapReduceEntriesToIntTask#compute()::: map reduce entries to int task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentHashMap.MapReduceMappingsToIntTask#getRawResult()::: map reduce mappings to int task get raw result:::return
ConcurrentHashMap.MapReduceMappingsToIntTask#compute()::: map reduce mappings to int task compute:::transformer->reducer->if->r->for->i->f->h->for->p->advance->c->for->firstComplete->c->nextComplete
ConcurrentLinkedDeque#prevTerminator()::: concurrent linked deque prev terminator:::return
ConcurrentLinkedDeque#nextTerminator()::: concurrent linked deque next terminator:::return
ConcurrentLinkedDeque#newNode(E):::Returns a new node holding item:::node->new->Node<E>->ITEM->set->return
ConcurrentLinkedDeque#linkFirst(E):::Links e as first element.:::newNode->Objects->requireNonNull->newNode->for
ConcurrentLinkedDeque#linkLast(E):::Links e as last element.:::newNode->Objects->requireNonNull->newNode->for
ConcurrentLinkedDeque#unlink(Node):::Unlinks non-null node x.:::prev->next->if->unlinkFirst->else->if->unlinkLast->else->activePred->activeSucc->isFirst->isLast->hops->for->p->for->p->if->return->skipDeletedSuccessors->skipDeletedPredecessors->if->updateHead->updateTail->PREV->prevTerminator->setRelease->NEXT->nextTerminator->setRelease
ConcurrentLinkedDeque#unlinkFirst(Node, Node):::Unlinks non-null first node.:::for->o->p->q
ConcurrentLinkedDeque#unlinkLast(Node, Node):::Unlinks non-null last node.:::for->o->p->q
ConcurrentLinkedDeque#updateHead():::Guarantees that any node which was unlinked before a call to this method will be unreachable from head after it returns:::h->p->q->while->for
ConcurrentLinkedDeque#updateTail():::Guarantees that any node which was unlinked before a call to this method will be unreachable from tail after it returns:::t->p->q->while->for
ConcurrentLinkedDeque#skipDeletedPredecessors(Node)::: concurrent linked deque skip deleted predecessors:::do->prev->p->for->if->PREV->compareAndSet->return->while
ConcurrentLinkedDeque#skipDeletedSuccessors(Node)::: concurrent linked deque skip deleted successors:::do->next->p->for->if->NEXT->compareAndSet->return->while
ConcurrentLinkedDeque#succ(Node):::Returns the successor of p, or the first node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->first->return
ConcurrentLinkedDeque#pred(Node):::Returns the predecessor of p, or the last node if p.prev has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->last->return
ConcurrentLinkedDeque#first():::Returns the first node, the unique node p for which:     p.prev == null && p.next != p The returned node may or may not be logically deleted:::for
ConcurrentLinkedDeque#last():::Returns the last node, the unique node p for which:     p.next == null && p.prev != p The returned node may or may not be logically deleted:::for
ConcurrentLinkedDeque#screenNullResult(E):::Returns element unless it is null, in which case throws NoSuchElementException.:::if->throw->new->NoSuchElementException->return
ConcurrentLinkedDeque#initHeadTail(Node, Node):::Initializes head and tail, ensuring invariants hold.:::if->if->new->Node<E>->else->newNode->new->Node<E>->NEXT->set->PREV->set
ConcurrentLinkedDeque#addFirst(E):::Inserts the specified element at the front of this deque:::linkFirst
ConcurrentLinkedDeque#addLast(E):::Inserts the specified element at the end of this deque:::linkLast
ConcurrentLinkedDeque#offerFirst(E):::Inserts the specified element at the front of this deque:::linkFirst->return
ConcurrentLinkedDeque#offerLast(E):::Inserts the specified element at the end of this deque:::linkLast->return
ConcurrentLinkedDeque#peekFirst()::: concurrent linked deque peek first:::for
ConcurrentLinkedDeque#peekLast()::: concurrent linked deque peek last:::for
ConcurrentLinkedDeque#getFirst()::: concurrent linked deque get first:::return->peekFirst->screenNullResult
ConcurrentLinkedDeque#getLast()::: concurrent linked deque get last:::return->peekLast->screenNullResult
ConcurrentLinkedDeque#pollFirst()::: concurrent linked deque poll first:::for
ConcurrentLinkedDeque#pollLast()::: concurrent linked deque poll last:::for
ConcurrentLinkedDeque#removeFirst()::: concurrent linked deque remove first:::return->pollFirst->screenNullResult
ConcurrentLinkedDeque#removeLast()::: concurrent linked deque remove last:::return->pollLast->screenNullResult
ConcurrentLinkedDeque#offer(E):::Inserts the specified element at the tail of this deque:::return->offerLast
ConcurrentLinkedDeque#add(E):::Inserts the specified element at the tail of this deque:::return->offerLast
ConcurrentLinkedDeque#poll()::: concurrent linked deque poll:::return->pollFirst
ConcurrentLinkedDeque#peek()::: concurrent linked deque peek:::return->peekFirst
ConcurrentLinkedDeque#remove()::: concurrent linked deque remove:::return->removeFirst
ConcurrentLinkedDeque#pop()::: concurrent linked deque pop:::return->removeFirst
ConcurrentLinkedDeque#element()::: concurrent linked deque element:::return->getFirst
ConcurrentLinkedDeque#push(E)::: concurrent linked deque push:::addFirst
ConcurrentLinkedDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::Objects->requireNonNull->for->p->first->succ->return
ConcurrentLinkedDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::Objects->requireNonNull->for->p->last->pred->return
ConcurrentLinkedDeque#contains(Object):::Returns true if this deque contains the specified element:::if->for->p->first->succ->return
ConcurrentLinkedDeque#isEmpty():::Returns true if this collection contains no elements.:::return->peekFirst
ConcurrentLinkedDeque#size():::Returns the number of elements in this deque:::for
ConcurrentLinkedDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::return->removeFirstOccurrence
ConcurrentLinkedDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beginningOfTheEnd->last->foreach->newNode->Objects->requireNonNull->newNode->if->else->NEXT->set->PREV->set->if->return->for
ConcurrentLinkedDeque#clear():::Removes all of the elements from this deque.:::while->pollFirst
ConcurrentLinkedDeque#toString()::: concurrent linked deque to string:::a->for
ConcurrentLinkedDeque#toArrayInternal(Object[])::: concurrent linked deque to array internal:::x->for
ConcurrentLinkedDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::return->toArrayInternal
ConcurrentLinkedDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::if->throw->new->NullPointerException->return->toArrayInternal
ConcurrentLinkedDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::return->new->Itr
ConcurrentLinkedDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::return->new->DescendingItr
ConcurrentLinkedDeque.AbstractItr#startNode()::: abstract itr start node:::
ConcurrentLinkedDeque.AbstractItr#nextNode(Node)::: abstract itr next node:::
ConcurrentLinkedDeque.AbstractItr#advance():::Sets nextNode and nextItem to next valid node, or to null if no such.:::p->startNode->nextNode->for->nextNode
ConcurrentLinkedDeque.AbstractItr#hasNext()::: abstract itr has next:::return
ConcurrentLinkedDeque.AbstractItr#next()::: abstract itr next:::item->if->throw->new->NoSuchElementException->advance->return
ConcurrentLinkedDeque.AbstractItr#remove()::: abstract itr remove:::l->if->throw->new->IllegalStateException->unlink
ConcurrentLinkedDeque.Itr#startNode()::: itr start node:::return->first
ConcurrentLinkedDeque.Itr#nextNode(Node)::: itr next node:::return->succ
ConcurrentLinkedDeque.DescendingItr#startNode()::: descending itr start node:::return->last
ConcurrentLinkedDeque.DescendingItr#nextNode(Node)::: descending itr next node:::return->pred
ConcurrentLinkedDeque.CLDSpliterator#trySplit()::: spliterator try split:::p->q->if->current->return->i->n->Math->min->a->do->e->if->if->new->ObjectArr->if->first->while->setCurrent->return->Spliterators->spliterator
ConcurrentLinkedDeque.CLDSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->p->if->current->do->e->if->action->accept->if->first->while
ConcurrentLinkedDeque.CLDSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->p->if->current->e->do->if->first->while->setCurrent->if->action->accept->return->return
ConcurrentLinkedDeque.CLDSpliterator#setCurrent(Node)::: spliterator set current:::if
ConcurrentLinkedDeque.CLDSpliterator#current()::: spliterator current:::p->if->first->setCurrent->return
ConcurrentLinkedDeque.CLDSpliterator#estimateSize()::: spliterator estimate size:::return
ConcurrentLinkedDeque.CLDSpliterator#characteristics()::: spliterator characteristics:::return
ConcurrentLinkedDeque#spliterator():::Returns a Spliterator over the elements in this deque:::return->new->CLDSpliterator
ConcurrentLinkedDeque#writeObject(java.io.ObjectOutputStream):::Saves this deque to a stream (that is, serializes it).:::s->defaultWriteObject->for->p->first->succ->s->writeObject
ConcurrentLinkedDeque#readObject(java.io.ObjectInputStream):::Reconstitutes this deque from a stream (that is, deserializes it).:::s->defaultReadObject->h->t->for->item->s->readObject->initHeadTail
ConcurrentLinkedDeque#removeIf(Predicate)::: concurrent linked deque remove if:::Objects->requireNonNull->return->bulkRemove
ConcurrentLinkedDeque#removeAll(Collection)::: concurrent linked deque remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
ConcurrentLinkedDeque#retainAll(Collection)::: concurrent linked deque retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
ConcurrentLinkedDeque#bulkRemove(Predicate):::Implementation of bulk remove methods.:::removed->for->p->first->succ->return
ConcurrentLinkedDeque#forEach(Consumer)::: concurrent linked deque for each:::Objects->requireNonNull->item->for->p->first->succ
ConcurrentLinkedQueue.Node#appendRelaxed(Node)::: node append relaxed:::NEXT->set
ConcurrentLinkedQueue.Node#casItem(E, E)::: node cas item:::return->ITEM->compareAndSet
ConcurrentLinkedQueue#add(E):::Inserts the specified element at the tail of this queue:::return->offer
ConcurrentLinkedQueue#updateHead(Node, Node):::Tries to CAS head to p:::if->HEAD->compareAndSet->NEXT->setRelease
ConcurrentLinkedQueue#succ(Node):::Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->return
ConcurrentLinkedQueue#tryCasSuccessor(Node, Node, Node):::Tries to CAS pred.next (or head, if pred is null) from c to p:::if->return->NEXT->compareAndSet->if->HEAD->compareAndSet->NEXT->setRelease->return->return
ConcurrentLinkedQueue#skipDeadNodes(Node, Node, Node, Node):::Collapse dead nodes between pred and q.:::if->if->return->return->tryCasSuccessor->ITEM->get
ConcurrentLinkedQueue#offer(E):::Inserts the specified element at the tail of this queue:::newNode->Objects->requireNonNull->new->Node<E>->for->t->p
ConcurrentLinkedQueue#poll()::: concurrent linked queue poll:::for
ConcurrentLinkedQueue#peek()::: concurrent linked queue peek:::for
ConcurrentLinkedQueue#first():::Returns the first live (non-deleted) node on list, or null if none:::for
ConcurrentLinkedQueue#isEmpty():::Returns true if this queue contains no elements.:::return->first
ConcurrentLinkedQueue#size():::Returns the number of elements in this queue:::for
ConcurrentLinkedQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->for
ConcurrentLinkedQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->for
ConcurrentLinkedQueue#addAll(Collection):::Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beginningOfTheEnd->last->foreach->newNode->Objects->requireNonNull->new->Node<E>->if->else->last->appendRelaxed->if->return->for->t->p
ConcurrentLinkedQueue#toString()::: concurrent linked queue to string:::a->for
ConcurrentLinkedQueue#toArrayInternal(Object[])::: concurrent linked queue to array internal:::x->for
ConcurrentLinkedQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::return->toArrayInternal
ConcurrentLinkedQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects->requireNonNull->return->toArrayInternal
ConcurrentLinkedQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
ConcurrentLinkedQueue.Itr#hasNext()::: itr has next:::return
ConcurrentLinkedQueue.Itr#next()::: itr next:::pred->if->throw->new->NoSuchElementException->item->for->p->succ->q
ConcurrentLinkedQueue.Itr#remove()::: itr remove:::l->if->throw->new->IllegalStateException
ConcurrentLinkedQueue#writeObject(java.io.ObjectOutputStream):::Saves this queue to a stream (that is, serializes it).:::s->defaultWriteObject->for->p->first->succ->s->writeObject
ConcurrentLinkedQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::s->defaultReadObject->h->t->for->item->s->readObject->if->new->Node<E>
ConcurrentLinkedQueue.CLQSpliterator#trySplit()::: spliterator try split:::p->q->if->current->return->i->n->Math->min->a->do->e->if->if->new->ObjectArr->if->first->while->setCurrent->return->Spliterators->spliterator
ConcurrentLinkedQueue.CLQSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->p->if->current->forEachFrom
ConcurrentLinkedQueue.CLQSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->p->if->current->e->do->if->first->while->setCurrent->if->action->accept->return->return
ConcurrentLinkedQueue.CLQSpliterator#setCurrent(Node)::: spliterator set current:::if
ConcurrentLinkedQueue.CLQSpliterator#current()::: spliterator current:::p->if->first->setCurrent->return
ConcurrentLinkedQueue.CLQSpliterator#estimateSize()::: spliterator estimate size:::return
ConcurrentLinkedQueue.CLQSpliterator#characteristics()::: spliterator characteristics:::return
ConcurrentLinkedQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->CLQSpliterator
ConcurrentLinkedQueue#removeIf(Predicate)::: concurrent linked queue remove if:::Objects->requireNonNull->return->bulkRemove
ConcurrentLinkedQueue#removeAll(Collection)::: concurrent linked queue remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
ConcurrentLinkedQueue#retainAll(Collection)::: concurrent linked queue retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
ConcurrentLinkedQueue#clear()::: concurrent linked queue clear:::bulkRemove
ConcurrentLinkedQueue#bulkRemove(Predicate):::Implementation of bulk remove methods.:::removed->for
ConcurrentLinkedQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::for->pred
ConcurrentLinkedQueue#forEach(Consumer)::: concurrent linked queue for each:::Objects->requireNonNull->forEachFrom
ConcurrentMap#getOrDefault(Object, V)::: concurrent map get or default:::v->return->get
ConcurrentMap#forEach(BiConsumer)::: concurrent map for each:::Objects->requireNonNull->foreach->entrySet->k->v->try->entry->getKey->entry->getValue->catch->continue->finally->action->accept
ConcurrentMap#putIfAbsent(K, V):::If the specified key is not already associated with a value, associates it with the given value:::
ConcurrentMap#remove(Object, Object):::Removes the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V, V):::Replaces the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V):::Replaces the entry for a key only if currently mapped to some value:::
ConcurrentMap#replaceAll(BiFunction)::: concurrent map replace all:::Objects->requireNonNull->while->function->apply->replace->if->get->break->forEach
ConcurrentMap#computeIfAbsent(K, Function)::: concurrent map compute if absent:::Objects->requireNonNull->oldValue->newValue->return->get->mappingFunction->apply->putIfAbsent
ConcurrentMap#computeIfPresent(K, BiFunction)::: concurrent map compute if present:::Objects->requireNonNull->for->oldValue->get->return
ConcurrentMap#compute(K, BiFunction)::: concurrent map compute:::for
ConcurrentMap#merge(K, V, BiFunction)::: concurrent map merge:::Objects->requireNonNull->Objects->requireNonNull->for
ConcurrentNavigableMap#subMap(K, boolean, K, boolean)::: concurrent navigable map sub map:::
ConcurrentNavigableMap#headMap(K, boolean)::: concurrent navigable map head map:::
ConcurrentNavigableMap#tailMap(K, boolean)::: concurrent navigable map tail map:::
ConcurrentNavigableMap#subMap(K, K)::: concurrent navigable map sub map:::
ConcurrentNavigableMap#headMap(K)::: concurrent navigable map head map:::
ConcurrentNavigableMap#tailMap(K)::: concurrent navigable map tail map:::
ConcurrentNavigableMap#descendingMap():::Returns a reverse order view of the mappings contained in this map:::
ConcurrentNavigableMap#navigableKeySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#descendingKeySet():::Returns a reverse order NavigableSet view of the keys contained in this map:::
ConcurrentSkipListMap#cpr(Comparator, Object, Object):::Compares using comparator or natural ordering if null:::return->c->compare->compareTo
ConcurrentSkipListMap#baseHead():::Returns the header for base node list, or null if uninitialized:::h->VarHandle->acquireFence->return
ConcurrentSkipListMap#unlinkNode(Node, Node):::Tries to unlink deleted node n from predecessor b (if both exist), by first splicing in a marker if not already present:::if->f->p->for->NEXT->compareAndSet
ConcurrentSkipListMap#addCount(long):::Adds to element count, initializing adder if necessary:::a->do->while->ADDER->new->LongAdder->compareAndSet->a->add
ConcurrentSkipListMap#getAdderCount():::Returns element count, initializing adder if necessary.:::a->c->do->while->ADDER->new->LongAdder->compareAndSet->return->a->sum
ConcurrentSkipListMap#findPredecessor(Object, Comparator):::Returns an index node with key strictly less than given key:::q->VarHandle->acquireFence->if->return->else->for->r->d
ConcurrentSkipListMap#findNode(Object):::Returns node holding key or null if no such, clearing out any deleted nodes seen along the way:::if->throw->new->NullPointerException->cmp->b->while->findPredecessor->for->return
ConcurrentSkipListMap#doGet(Object):::Gets value for key:::q->VarHandle->acquireFence->if->throw->new->NullPointerException->cmp->result->if->for->r->d->return
ConcurrentSkipListMap#doPut(K, V, boolean):::Main insertion method:::if->throw->new->NullPointerException->cmp->for
ConcurrentSkipListMap#addIndices(Index, int, Index, Comparator):::Add indices after an insertion:::z->key->if->retrying->for->return
ConcurrentSkipListMap#doRemove(Object, Object):::Main deletion method:::if->throw->new->NullPointerException->cmp->result->b->while->findPredecessor->for->if->tryReduceLevel->addCount->return
ConcurrentSkipListMap#tryReduceLevel():::Possibly reduce head level if it has no nodes:::h->d->e->if->HEAD->compareAndSet->HEAD->compareAndSet
ConcurrentSkipListMap#findFirst():::Gets first valid node, unlinking deleted nodes if encountered.:::b->n->if->baseHead->while->if->unlinkNode->else->return->return
ConcurrentSkipListMap#findFirstEntry():::Entry snapshot version of findFirst:::b->n->v->if->baseHead->while->if->unlinkNode->else->return->new->AbstractMap.SimpleImmutableEntry<K,V>->return
ConcurrentSkipListMap#doRemoveFirstEntry():::Removes first entry; returns its snapshot.:::b->n->v->if->baseHead->while->if->VAL->compareAndSet->k->unlinkNode->if->tryReduceLevel->findPredecessor->addCount->return->new->AbstractMap.SimpleImmutableEntry<K,V>->return
ConcurrentSkipListMap#findLast():::Specialized version of find to get last valid node.:::for->return
ConcurrentSkipListMap#findLastEntry():::Entry version of findLast:::for
ConcurrentSkipListMap#doRemoveLastEntry():::Removes last entry; returns its snapshot:::for->return
ConcurrentSkipListMap#findNear(K, int, Comparator):::Utility for ceiling, floor, lower, higher methods.:::if->throw->new->NullPointerException->result->for->b->return
ConcurrentSkipListMap#findNearEntry(K, int, Comparator):::Variant of findNear returning SimpleImmutableEntry:::for
ConcurrentSkipListMap#clone():::Returns a shallow copy of this ConcurrentSkipListMap instance:::try->clone->super->clone->clone->buildFromSorted->return->catch->throw->new->InternalError->finally
ConcurrentSkipListMap#buildFromSorted(SortedMap):::Streamlined bulk insertion to initialize from elements of given sorted map:::if->throw->new->NullPointerException->it->map->entrySet->iterator->preds->new->Index<?,?>Arr->bp->new->Node<K,V>->h->new->Index<K,V>->count->while->it->hasNext->e->it->next->k->e->getKey->v->e->getValue->if->throw->new->NullPointerException->z->new->Node<K,V>->if->m->i->idx->q->do->new->Index<K,V>->if->new->Index<K,V>->else->while->if->VarHandle->releaseFence->addCount->VarHandle->fullFence
ConcurrentSkipListMap#writeObject(java.io.ObjectOutputStream):::Saves this map to a stream (that is, serializes it).:::s->defaultWriteObject->b->n->v->if->baseHead->while->if->s->writeObject->s->writeObject->s->writeObject
ConcurrentSkipListMap#readObject(java.io.ObjectInputStream):::Reconstitutes this map from a stream (that is, deserializes it).:::s->defaultReadObject->preds->new->Index<?,?>Arr->bp->new->Node<K,V>->h->new->Index<K,V>->cmp->prevKey->count->for->if->VarHandle->releaseFence->addCount->VarHandle->fullFence
ConcurrentSkipListMap#containsKey(Object):::Returns true if this map contains a mapping for the specified key.:::return->doGet
ConcurrentSkipListMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::return->doGet
ConcurrentSkipListMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.:::v->return->doGet
ConcurrentSkipListMap#put(K, V):::Associates the specified value with the specified key in this map:::if->throw->new->NullPointerException->return->doPut
ConcurrentSkipListMap#remove(Object):::Removes the mapping for the specified key from this map if present.:::return->doRemove
ConcurrentSkipListMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::if->throw->new->NullPointerException->b->n->v->if->baseHead->while->if->value->equals->return->else->return
ConcurrentSkipListMap#size()::: concurrent skip list map size:::c->return->baseHead->getAdderCount
ConcurrentSkipListMap#isEmpty()::: concurrent skip list map is empty:::return->findFirst
ConcurrentSkipListMap#clear():::Removes all of the mappings from this map.:::h->r->d->b->VarHandle->acquireFence->while->if->RIGHT->compareAndSet->else->if->HEAD->compareAndSet->else->count->if->n->v->while->if->VAL->compareAndSet->if->unlinkNode->if->addCount->else->break
ConcurrentSkipListMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::if->throw->new->NullPointerException->v->p->r->if->doGet->mappingFunction->apply->doPut->return
ConcurrentSkipListMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::if->throw->new->NullPointerException->n->v->while->findNode->if->r->remappingFunction->apply->if->if->VAL->compareAndSet->return->else->if->doRemove->break->return
ConcurrentSkipListMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::if->throw->new->NullPointerException->for->return
ConcurrentSkipListMap#merge(K, V, BiFunction):::If the specified key is not already associated with a value, associates it with the given value:::if->throw->new->NullPointerException->for
ConcurrentSkipListMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::ks->if->return->return->new->KeySet<>
ConcurrentSkipListMap#navigableKeySet()::: concurrent skip list map navigable key set:::ks->if->return->return->new->KeySet<>
ConcurrentSkipListMap#values():::Returns a Collection view of the values contained in this map:::vs->if->return->return->new->Values<>
ConcurrentSkipListMap#entrySet():::Returns a Set view of the mappings contained in this map:::es->if->return->return->new->EntrySet<K,V>
ConcurrentSkipListMap#descendingMap()::: concurrent skip list map descending map:::dm->if->return->return->new->SubMap<K,V>
ConcurrentSkipListMap#descendingKeySet()::: concurrent skip list map descending key set:::return->descendingMap->navigableKeySet
ConcurrentSkipListMap#equals(Object):::Compares the specified object with this map for equality:::if->return->if->return->m->try->cmp->it->m->entrySet->iterator->if->comparator->b->n->if->baseHead->while->k->v->if->if->it->hasNext->return->e->it->next->mk->e->getKey->mv->e->getValue->if->return->try->if->cpr->return->catch->return->finally->if->mv->equals->return->return->it->hasNext->else->while->it->hasNext->v->e->it->next->mk->e->getKey->mv->e->getValue->if->get->v->equals->return->b->n->if->baseHead->k->v->mv->while->if->m->get->mv->equals->return->return->catch->return->finally
ConcurrentSkipListMap#putIfAbsent(K, V)::: concurrent skip list map put if absent:::if->throw->new->NullPointerException->return->doPut
ConcurrentSkipListMap#remove(Object, Object)::: concurrent skip list map remove:::if->throw->new->NullPointerException->return->doRemove
ConcurrentSkipListMap#replace(K, V, V)::: concurrent skip list map replace:::if->throw->new->NullPointerException->for
ConcurrentSkipListMap#replace(K, V)::: concurrent skip list map replace:::if->throw->new->NullPointerException->for
ConcurrentSkipListMap#comparator()::: concurrent skip list map comparator:::return
ConcurrentSkipListMap#firstKey()::: concurrent skip list map first key:::n->findFirst->if->throw->new->NoSuchElementException->return
ConcurrentSkipListMap#lastKey()::: concurrent skip list map last key:::n->findLast->if->throw->new->NoSuchElementException->return
ConcurrentSkipListMap#subMap(K, boolean, K, boolean)::: concurrent skip list map sub map:::if->throw->new->NullPointerException->return->new->SubMap<K,V>
ConcurrentSkipListMap#headMap(K, boolean)::: concurrent skip list map head map:::if->throw->new->NullPointerException->return->new->SubMap<K,V>
ConcurrentSkipListMap#tailMap(K, boolean)::: concurrent skip list map tail map:::if->throw->new->NullPointerException->return->new->SubMap<K,V>
ConcurrentSkipListMap#subMap(K, K)::: concurrent skip list map sub map:::return->subMap
ConcurrentSkipListMap#headMap(K)::: concurrent skip list map head map:::return->headMap
ConcurrentSkipListMap#tailMap(K)::: concurrent skip list map tail map:::return->tailMap
ConcurrentSkipListMap#lowerEntry(K):::Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#lowerKey(K)::: concurrent skip list map lower key:::n->findNear->return
ConcurrentSkipListMap#floorEntry(K):::Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#floorKey(K)::: concurrent skip list map floor key:::n->findNear->return
ConcurrentSkipListMap#ceilingEntry(K):::Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such entry:::return->findNearEntry
ConcurrentSkipListMap#ceilingKey(K)::: concurrent skip list map ceiling key:::n->findNear->return
ConcurrentSkipListMap#higherEntry(K):::Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#higherKey(K)::: concurrent skip list map higher key:::n->findNear->return
ConcurrentSkipListMap#firstEntry():::Returns a key-value mapping associated with the least key in this map, or null if the map is empty:::return->findFirstEntry
ConcurrentSkipListMap#lastEntry():::Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::return->findLastEntry
ConcurrentSkipListMap#pollFirstEntry():::Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty:::return->doRemoveFirstEntry
ConcurrentSkipListMap#pollLastEntry():::Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::return->doRemoveLastEntry
ConcurrentSkipListMap.Iter#hasNext()::: iter has next:::return
ConcurrentSkipListMap.Iter#advance(Node):::Advances next to higher entry.:::n->v->if->while
ConcurrentSkipListMap.Iter#remove()::: iter remove:::n->k->if->throw->new->IllegalStateException->ConcurrentSkipListMap.this->remove
ConcurrentSkipListMap.ValueIterator#next()::: value iterator next:::v->if->throw->new->NoSuchElementException->advance->return
ConcurrentSkipListMap.KeyIterator#next()::: key iterator next:::n->if->throw->new->NoSuchElementException->k->advance->return
ConcurrentSkipListMap.EntryIterator#next()::: entry iterator next:::n->if->throw->new->NoSuchElementException->k->v->advance->return->new->AbstractMap.SimpleImmutableEntry<K,V>
ConcurrentSkipListMap#toList(Collection)::: concurrent skip list map to list:::list->new->ArrayList<E>->foreach->list->add->return
ConcurrentSkipListMap.KeySet#size()::: key set size:::return->m->size
ConcurrentSkipListMap.KeySet#isEmpty()::: key set is empty:::return->m->isEmpty
ConcurrentSkipListMap.KeySet#contains(Object)::: key set contains:::return->m->containsKey
ConcurrentSkipListMap.KeySet#remove(Object)::: key set remove:::return->m->remove
ConcurrentSkipListMap.KeySet#clear()::: key set clear:::m->clear
ConcurrentSkipListMap.KeySet#lower(K)::: key set lower:::return->m->lowerKey
ConcurrentSkipListMap.KeySet#floor(K)::: key set floor:::return->m->floorKey
ConcurrentSkipListMap.KeySet#ceiling(K)::: key set ceiling:::return->m->ceilingKey
ConcurrentSkipListMap.KeySet#higher(K)::: key set higher:::return->m->higherKey
ConcurrentSkipListMap.KeySet#comparator()::: key set comparator:::return->m->comparator
ConcurrentSkipListMap.KeySet#first()::: key set first:::return->m->firstKey
ConcurrentSkipListMap.KeySet#last()::: key set last:::return->m->lastKey
ConcurrentSkipListMap.KeySet#pollFirst()::: key set poll first:::e->m->pollFirstEntry->return->e->getKey
ConcurrentSkipListMap.KeySet#pollLast()::: key set poll last:::e->m->pollLastEntry->return->e->getKey
ConcurrentSkipListMap.KeySet#iterator()::: key set iterator:::return->new->KeyIterator->new->SubMapKeyIterator
ConcurrentSkipListMap.KeySet#equals(Object)::: key set equals:::if->return->if->return->c->try->return->containsAll->c->containsAll->catch->return->finally
ConcurrentSkipListMap.KeySet#toArray()::: key set to array:::return->toList->toArray
ConcurrentSkipListMap.KeySet#toArray(T[])::: key set to array:::return->toList->toArray
ConcurrentSkipListMap.KeySet#descendingIterator()::: key set descending iterator:::return->descendingSet->iterator
ConcurrentSkipListMap.KeySet#subSet(K, boolean, K, boolean)::: key set sub set:::return->m->subMap->new->KeySet<>
ConcurrentSkipListMap.KeySet#headSet(K, boolean)::: key set head set:::return->m->headMap->new->KeySet<>
ConcurrentSkipListMap.KeySet#tailSet(K, boolean)::: key set tail set:::return->m->tailMap->new->KeySet<>
ConcurrentSkipListMap.KeySet#subSet(K, K)::: key set sub set:::return->subSet
ConcurrentSkipListMap.KeySet#headSet(K)::: key set head set:::return->headSet
ConcurrentSkipListMap.KeySet#tailSet(K)::: key set tail set:::return->tailSet
ConcurrentSkipListMap.KeySet#descendingSet()::: key set descending set:::return->m->descendingMap->new->KeySet<>
ConcurrentSkipListMap.KeySet#spliterator()::: key set spliterator:::return->keySpliterator->new->SubMapKeyIterator
ConcurrentSkipListMap.Values#iterator()::: values iterator:::return->new->ValueIterator->new->SubMapValueIterator
ConcurrentSkipListMap.Values#size()::: values size:::return->m->size
ConcurrentSkipListMap.Values#isEmpty()::: values is empty:::return->m->isEmpty
ConcurrentSkipListMap.Values#contains(Object)::: values contains:::return->m->containsValue
ConcurrentSkipListMap.Values#clear()::: values clear:::m->clear
ConcurrentSkipListMap.Values#toArray()::: values to array:::return->toList->toArray
ConcurrentSkipListMap.Values#toArray(T[])::: values to array:::return->toList->toArray
ConcurrentSkipListMap.Values#spliterator()::: values spliterator:::return->valueSpliterator->new->SubMapValueIterator
ConcurrentSkipListMap.Values#removeIf(Predicate)::: values remove if:::if->throw->new->NullPointerException->if->return->removeValueIf->it->new->SubMapEntryIterator->removed->while->it->hasNext->e->it->next->v->e->getValue->if->filter->test->m->e->getKey->remove->return
ConcurrentSkipListMap.EntrySet#iterator()::: entry set iterator:::return->new->EntryIterator->new->SubMapEntryIterator
ConcurrentSkipListMap.EntrySet#contains(Object)::: entry set contains:::if->return->e->v->m->e->getKey->get->return->v->e->getValue->equals
ConcurrentSkipListMap.EntrySet#remove(Object)::: entry set remove:::if->return->e->return->m->e->getKey->e->getValue->remove
ConcurrentSkipListMap.EntrySet#isEmpty()::: entry set is empty:::return->m->isEmpty
ConcurrentSkipListMap.EntrySet#size()::: entry set size:::return->m->size
ConcurrentSkipListMap.EntrySet#clear()::: entry set clear:::m->clear
ConcurrentSkipListMap.EntrySet#equals(Object)::: entry set equals:::if->return->if->return->c->try->return->containsAll->c->containsAll->catch->return->finally
ConcurrentSkipListMap.EntrySet#toArray()::: entry set to array:::return->toList->toArray
ConcurrentSkipListMap.EntrySet#toArray(T[])::: entry set to array:::return->toList->toArray
ConcurrentSkipListMap.EntrySet#spliterator()::: entry set spliterator:::return->entrySpliterator->new->SubMapEntryIterator
ConcurrentSkipListMap.EntrySet#removeIf(Predicate>)::: entry set remove if:::if->throw->new->NullPointerException->if->return->removeEntryIf->it->new->SubMapEntryIterator->removed->while->it->hasNext->e->it->next->if->filter->test->m->e->getKey->e->getValue->remove->return
ConcurrentSkipListMap.SubMap#tooLow(Object, Comparator)::: sub map too low:::c->return->cpr
ConcurrentSkipListMap.SubMap#tooHigh(Object, Comparator)::: sub map too high:::c->return->cpr
ConcurrentSkipListMap.SubMap#inBounds(Object, Comparator)::: sub map in bounds:::return->tooLow->tooHigh
ConcurrentSkipListMap.SubMap#checkKeyBounds(K, Comparator)::: sub map check key bounds:::if->throw->new->NullPointerException->if->inBounds->throw->new->IllegalArgumentException
ConcurrentSkipListMap.SubMap#isBeforeEnd(ConcurrentSkipListMap.Node, Comparator):::Returns true if node key is less than upper bound of range.:::if->return->if->return->k->if->return->c->cpr->return
ConcurrentSkipListMap.SubMap#loNode(Comparator):::Returns lowest node:::if->return->m->findFirst->else->if->return->m->findNear->else->return->m->findNear
ConcurrentSkipListMap.SubMap#hiNode(Comparator):::Returns highest node:::if->return->m->findLast->else->if->return->m->findNear->else->return->m->findNear
ConcurrentSkipListMap.SubMap#lowestKey():::Returns lowest absolute key (ignoring directionality).:::cmp->n->loNode->if->isBeforeEnd->return->else->throw->new->NoSuchElementException
ConcurrentSkipListMap.SubMap#highestKey():::Returns highest absolute key (ignoring directionality).:::cmp->n->hiNode->if->last->if->inBounds->return->throw->new->NoSuchElementException
ConcurrentSkipListMap.SubMap#lowestEntry()::: sub map lowest entry:::cmp->for
ConcurrentSkipListMap.SubMap#highestEntry()::: sub map highest entry:::cmp->for
ConcurrentSkipListMap.SubMap#removeLowest()::: sub map remove lowest:::cmp->for
ConcurrentSkipListMap.SubMap#removeHighest()::: sub map remove highest:::cmp->for
ConcurrentSkipListMap.SubMap#getNearEntry(K, int):::Submap version of ConcurrentSkipListMap.findNearEntry.:::cmp->if->if->else->if->tooLow->return->lowestEntry->if->tooHigh->return->highestEntry->e->m->findNearEntry->if->e->getKey->inBounds->return->else->return
ConcurrentSkipListMap.SubMap#getNearKey(K, int)::: sub map get near key:::cmp->if->if->else->if->tooLow->if->n->loNode->if->isBeforeEnd->return->return->if->tooHigh->if->n->hiNode->if->last->if->inBounds->return->return->for
ConcurrentSkipListMap.SubMap#containsKey(Object)::: sub map contains key:::if->throw->new->NullPointerException->return->inBounds->m->containsKey
ConcurrentSkipListMap.SubMap#get(Object)::: sub map get:::if->throw->new->NullPointerException->return->inBounds->m->get
ConcurrentSkipListMap.SubMap#put(K, V)::: sub map put:::checkKeyBounds->return->m->put
ConcurrentSkipListMap.SubMap#remove(Object)::: sub map remove:::return->inBounds->m->remove
ConcurrentSkipListMap.SubMap#size()::: sub map size:::cmp->count->for->n->loNode->isBeforeEnd->return
ConcurrentSkipListMap.SubMap#isEmpty()::: sub map is empty:::cmp->return->loNode->isBeforeEnd
ConcurrentSkipListMap.SubMap#containsValue(Object)::: sub map contains value:::if->throw->new->NullPointerException->cmp->for->n->loNode->isBeforeEnd->return
ConcurrentSkipListMap.SubMap#clear()::: sub map clear:::cmp->for->n->loNode->isBeforeEnd
ConcurrentSkipListMap.SubMap#putIfAbsent(K, V)::: sub map put if absent:::checkKeyBounds->return->m->putIfAbsent
ConcurrentSkipListMap.SubMap#remove(Object, Object)::: sub map remove:::return->inBounds->m->remove
ConcurrentSkipListMap.SubMap#replace(K, V, V)::: sub map replace:::checkKeyBounds->return->m->replace
ConcurrentSkipListMap.SubMap#replace(K, V)::: sub map replace:::checkKeyBounds->return->m->replace
ConcurrentSkipListMap.SubMap#comparator()::: sub map comparator:::cmp->m->comparator->if->return->Collections->reverseOrder->else->return
ConcurrentSkipListMap.SubMap#newSubMap(K, boolean, K, boolean):::Utility to create submaps, where given bounds override unbounded(null) ones and/or are checked against bounded ones.:::cmp->if->tk->ti->if->if->else->c->cpr->if->throw->new->IllegalArgumentException->if->if->else->c->cpr->if->throw->new->IllegalArgumentException->return->new->SubMap<K,V>
ConcurrentSkipListMap.SubMap#subMap(K, boolean, K, boolean)::: sub map sub map:::if->throw->new->NullPointerException->return->newSubMap
ConcurrentSkipListMap.SubMap#headMap(K, boolean)::: sub map head map:::if->throw->new->NullPointerException->return->newSubMap
ConcurrentSkipListMap.SubMap#tailMap(K, boolean)::: sub map tail map:::if->throw->new->NullPointerException->return->newSubMap
ConcurrentSkipListMap.SubMap#subMap(K, K)::: sub map sub map:::return->subMap
ConcurrentSkipListMap.SubMap#headMap(K)::: sub map head map:::return->headMap
ConcurrentSkipListMap.SubMap#tailMap(K)::: sub map tail map:::return->tailMap
ConcurrentSkipListMap.SubMap#descendingMap()::: sub map descending map:::return->new->SubMap<K,V>
ConcurrentSkipListMap.SubMap#ceilingEntry(K)::: sub map ceiling entry:::return->getNearEntry
ConcurrentSkipListMap.SubMap#ceilingKey(K)::: sub map ceiling key:::return->getNearKey
ConcurrentSkipListMap.SubMap#lowerEntry(K)::: sub map lower entry:::return->getNearEntry
ConcurrentSkipListMap.SubMap#lowerKey(K)::: sub map lower key:::return->getNearKey
ConcurrentSkipListMap.SubMap#floorEntry(K)::: sub map floor entry:::return->getNearEntry
ConcurrentSkipListMap.SubMap#floorKey(K)::: sub map floor key:::return->getNearKey
ConcurrentSkipListMap.SubMap#higherEntry(K)::: sub map higher entry:::return->getNearEntry
ConcurrentSkipListMap.SubMap#higherKey(K)::: sub map higher key:::return->getNearKey
ConcurrentSkipListMap.SubMap#firstKey()::: sub map first key:::return->highestKey->lowestKey
ConcurrentSkipListMap.SubMap#lastKey()::: sub map last key:::return->lowestKey->highestKey
ConcurrentSkipListMap.SubMap#firstEntry()::: sub map first entry:::return->highestEntry->lowestEntry
ConcurrentSkipListMap.SubMap#lastEntry()::: sub map last entry:::return->lowestEntry->highestEntry
ConcurrentSkipListMap.SubMap#pollFirstEntry()::: sub map poll first entry:::return->removeHighest->removeLowest
ConcurrentSkipListMap.SubMap#pollLastEntry()::: sub map poll last entry:::return->removeLowest->removeHighest
ConcurrentSkipListMap.SubMap#keySet()::: sub map key set:::ks->if->return->return->new->KeySet<>
ConcurrentSkipListMap.SubMap#navigableKeySet()::: sub map navigable key set:::ks->if->return->return->new->KeySet<>
ConcurrentSkipListMap.SubMap#values()::: sub map values:::vs->if->return->return->new->Values<>
ConcurrentSkipListMap.SubMap#entrySet()::: sub map entry set:::es->if->return->return->new->EntrySet<K,V>
ConcurrentSkipListMap.SubMap#descendingKeySet()::: sub map descending key set:::return->descendingMap->navigableKeySet
ConcurrentSkipListMap.SubMap.SubMapIter#hasNext()::: sub map iter has next:::return
ConcurrentSkipListMap.SubMap.SubMapIter#advance()::: sub map iter advance:::if->throw->new->NoSuchElementException->if->descend->else->ascend
ConcurrentSkipListMap.SubMap.SubMapIter#ascend()::: sub map iter ascend:::cmp->for
ConcurrentSkipListMap.SubMap.SubMapIter#descend()::: sub map iter descend:::cmp->for
ConcurrentSkipListMap.SubMap.SubMapIter#remove()::: sub map iter remove:::l->if->throw->new->IllegalStateException->m->remove
ConcurrentSkipListMap.SubMap.SubMapIter#trySplit()::: sub map iter try split:::return
ConcurrentSkipListMap.SubMap.SubMapIter#tryAdvance(Consumer)::: sub map iter try advance:::if->hasNext->action->next->accept->return->return
ConcurrentSkipListMap.SubMap.SubMapIter#forEachRemaining(Consumer)::: sub map iter for each remaining:::while->hasNext->action->next->accept
ConcurrentSkipListMap.SubMap.SubMapIter#estimateSize()::: sub map iter estimate size:::return
ConcurrentSkipListMap.SubMap.SubMapValueIterator#next()::: sub map value iterator next:::v->advance->return
ConcurrentSkipListMap.SubMap.SubMapValueIterator#characteristics()::: sub map value iterator characteristics:::return
ConcurrentSkipListMap.SubMap.SubMapKeyIterator#next()::: sub map key iterator next:::n->advance->return
ConcurrentSkipListMap.SubMap.SubMapKeyIterator#characteristics()::: sub map key iterator characteristics:::return
ConcurrentSkipListMap.SubMap.SubMapKeyIterator#getComparator()::: sub map key iterator get comparator:::return->SubMap.this->comparator
ConcurrentSkipListMap.SubMap.SubMapEntryIterator#next()::: sub map entry iterator next:::n->v->advance->return->new->AbstractMap.SimpleImmutableEntry<K,V>
ConcurrentSkipListMap.SubMap.SubMapEntryIterator#characteristics()::: sub map entry iterator characteristics:::return
ConcurrentSkipListMap#forEach(BiConsumer)::: concurrent skip list map for each:::if->throw->new->NullPointerException->b->n->v->if->baseHead->while->if->action->accept
ConcurrentSkipListMap#replaceAll(BiFunction)::: concurrent skip list map replace all:::if->throw->new->NullPointerException->b->n->v->if->baseHead->while->while->r->function->apply->if->throw->new->NullPointerException->if->VAL->compareAndSet->break
ConcurrentSkipListMap#removeEntryIf(Predicate>):::Helper method for EntrySet.removeIf.:::if->throw->new->NullPointerException->removed->b->n->v->if->baseHead->while->if->k->e->new->AbstractMap.SimpleImmutableEntry<>->if->function->test->remove->return
ConcurrentSkipListMap#removeValueIf(Predicate):::Helper method for Values.removeIf.:::if->throw->new->NullPointerException->removed->b->n->v->if->baseHead->while->if->function->test->remove->return
ConcurrentSkipListMap.CSLMSpliterator#estimateSize()::: spliterator estimate size:::return
ConcurrentSkipListMap.KeySpliterator#trySplit()::: key spliterator try split:::e->ek->cmp->f->if->for->q->return
ConcurrentSkipListMap.KeySpliterator#forEachRemaining(Consumer)::: key spliterator for each remaining:::if->throw->new->NullPointerException->cmp->f->e->for
ConcurrentSkipListMap.KeySpliterator#tryAdvance(Consumer)::: key spliterator try advance:::if->throw->new->NullPointerException->cmp->f->e->for->return
ConcurrentSkipListMap.KeySpliterator#characteristics()::: key spliterator characteristics:::return
ConcurrentSkipListMap.KeySpliterator#getComparator()::: key spliterator get comparator:::return
ConcurrentSkipListMap#keySpliterator()::: concurrent skip list map key spliterator:::h->n->est->VarHandle->acquireFence->if->else->getAdderCount->return->new->KeySpliterator<K,V>
ConcurrentSkipListMap.ValueSpliterator#trySplit()::: value spliterator try split:::e->ek->cmp->f->if->for->q->return
ConcurrentSkipListMap.ValueSpliterator#forEachRemaining(Consumer)::: value spliterator for each remaining:::if->throw->new->NullPointerException->cmp->f->e->for
ConcurrentSkipListMap.ValueSpliterator#tryAdvance(Consumer)::: value spliterator try advance:::if->throw->new->NullPointerException->cmp->f->e->for->return
ConcurrentSkipListMap.ValueSpliterator#characteristics()::: value spliterator characteristics:::return
ConcurrentSkipListMap#valueSpliterator()::: concurrent skip list map value spliterator:::h->n->est->VarHandle->acquireFence->if->else->getAdderCount->return->new->ValueSpliterator<K,V>
ConcurrentSkipListMap.EntrySpliterator#trySpliterator trySplit()::: entry spliterator try split:::e->ek->cmp->f->if->for->q->return
ConcurrentSkipListMap.EntrySpliterator#forEachRemaining(Consumer>)::: entry spliterator for each remaining:::if->throw->new->NullPointerException->cmp->f->e->for
ConcurrentSkipListMap.EntrySpliterator#tryAdvance(Consumer>)::: entry spliterator try advance:::if->throw->new->NullPointerException->cmp->f->e->for->return
ConcurrentSkipListMap.EntrySpliterator#characteristics()::: entry spliterator characteristics:::return
ConcurrentSkipListMap.EntrySpliterator#getComparator()::: entry spliterator get comparator:::if->return->comparingByKey->else->return->k1->e1->getKey->return->k1->e2->getKey->compareTo
ConcurrentSkipListMap#entrySpliterator()::: concurrent skip list map entry spliterator:::h->n->est->VarHandle->acquireFence->if->else->getAdderCount->return->new->EntrySpliterator<K,V>
ConcurrentSkipListSet#clone():::Returns a shallow copy of this ConcurrentSkipListSet instance:::try->clone->super->clone->clone->new->ConcurrentSkipListMap<E,Object>->setMap->return->catch->throw->new->InternalError->finally
ConcurrentSkipListSet#size():::Returns the number of elements in this set:::return->m->size
ConcurrentSkipListSet#isEmpty():::Returns true if this set contains no elements.:::return->m->isEmpty
ConcurrentSkipListSet#contains(Object):::Returns true if this set contains the specified element:::return->m->containsKey
ConcurrentSkipListSet#add(E):::Adds the specified element to this set if it is not already present:::return->m->putIfAbsent
ConcurrentSkipListSet#remove(Object):::Removes the specified element from this set if it is present:::return->m->remove
ConcurrentSkipListSet#clear():::Removes all of the elements from this set.:::m->clear
ConcurrentSkipListSet#iterator():::Returns an iterator over the elements in this set in ascending order.:::return->m->navigableKeySet->iterator
ConcurrentSkipListSet#descendingIterator():::Returns an iterator over the elements in this set in descending order.:::return->m->descendingKeySet->iterator
ConcurrentSkipListSet#equals(Object):::Compares the specified object with this set for equality:::if->return->if->return->c->try->return->containsAll->c->containsAll->catch->return->finally
ConcurrentSkipListSet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::modified->foreach->if->remove->return
ConcurrentSkipListSet#lower(E)::: concurrent skip list set lower:::return->m->lowerKey
ConcurrentSkipListSet#floor(E)::: concurrent skip list set floor:::return->m->floorKey
ConcurrentSkipListSet#ceiling(E)::: concurrent skip list set ceiling:::return->m->ceilingKey
ConcurrentSkipListSet#higher(E)::: concurrent skip list set higher:::return->m->higherKey
ConcurrentSkipListSet#pollFirst()::: concurrent skip list set poll first:::e->m->pollFirstEntry->return->e->getKey
ConcurrentSkipListSet#pollLast()::: concurrent skip list set poll last:::e->m->pollLastEntry->return->e->getKey
ConcurrentSkipListSet#comparator()::: concurrent skip list set comparator:::return->m->comparator
ConcurrentSkipListSet#first()::: concurrent skip list set first:::return->m->firstKey
ConcurrentSkipListSet#last()::: concurrent skip list set last:::return->m->lastKey
ConcurrentSkipListSet#subSet(E, boolean, E, boolean)::: concurrent skip list set sub set:::return->m->subMap->new->ConcurrentSkipListSet<E>
ConcurrentSkipListSet#headSet(E, boolean)::: concurrent skip list set head set:::return->m->headMap->new->ConcurrentSkipListSet<E>
ConcurrentSkipListSet#tailSet(E, boolean)::: concurrent skip list set tail set:::return->m->tailMap->new->ConcurrentSkipListSet<E>
ConcurrentSkipListSet#subSet(E, E)::: concurrent skip list set sub set:::return->subSet
ConcurrentSkipListSet#headSet(E)::: concurrent skip list set head set:::return->headSet
ConcurrentSkipListSet#tailSet(E)::: concurrent skip list set tail set:::return->tailSet
ConcurrentSkipListSet#descendingSet():::Returns a reverse order view of the elements contained in this set:::return->m->descendingMap->new->ConcurrentSkipListSet<E>
ConcurrentSkipListSet#spliterator():::Returns a Spliterator over the elements in this set:::return->keySpliterator->new->SubMapKeyIterator
ConcurrentSkipListSet#setMap(ConcurrentNavigableMap):::Initializes map field; for use in clone.:::mapField->try->f->getDeclaredField->f->setAccessible->return->catch->throw->new->Error->finally->doPrivileged->try->mapField->set->catch->throw->new->Error->finally
CopyOnWriteArrayList#getArray():::Gets the array:::return
CopyOnWriteArrayList#setArray(Object[]):::Sets the array.:::
CopyOnWriteArrayList#size():::Returns the number of elements in this list.:::return->getArray
CopyOnWriteArrayList#isEmpty():::Returns true if this list contains no elements.:::return->size
CopyOnWriteArrayList#indexOfRange(Object, Object[], int, int):::static version of indexOf, to allow repeated calls without needing to re-acquire array each time.:::if->for->i->else->for->i->return
CopyOnWriteArrayList#lastIndexOfRange(Object, Object[], int, int):::static version of lastIndexOf.:::if->for->i->else->for->i->return
CopyOnWriteArrayList#contains(Object):::Returns true if this list contains the specified element:::return->indexOf
CopyOnWriteArrayList#indexOf(Object)::: copy on write array list index of:::es->getArray->return->indexOfRange
CopyOnWriteArrayList#indexOf(E, int):::Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found:::es->getArray->return->indexOfRange
CopyOnWriteArrayList#lastIndexOf(Object)::: copy on write array list last index of:::es->getArray->return->lastIndexOfRange
CopyOnWriteArrayList#lastIndexOf(E, int):::Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found:::es->getArray->return->lastIndexOfRange
CopyOnWriteArrayList#clone():::Returns a shallow copy of this list:::try->clone->super->clone->clone->resetLock->VarHandle->releaseFence->return->catch->throw->new->InternalError->finally
CopyOnWriteArrayList#toArray():::Returns an array containing all of the elements in this list in proper sequence (from first to last element):::return->getArray->clone
CopyOnWriteArrayList#toArray(T[]):::Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::es->getArray->len->if->return->Arrays->a->getClass->copyOf->else->System->arraycopy->if->return
CopyOnWriteArrayList#elementAt(Object[], int)::: copy on write array list element at:::return
CopyOnWriteArrayList#outOfBounds(int, int)::: copy on write array list out of bounds:::return
CopyOnWriteArrayList#get(int)::: copy on write array list get:::return->getArray->elementAt
CopyOnWriteArrayList#set(int, E):::Replaces the element at the specified position in this list with the specified element.:::synchronized->es->getArray->oldValue->elementAt->if->es->clone->setArray->return
CopyOnWriteArrayList#add(E):::Appends the specified element to the end of this list.:::synchronized->es->getArray->len->Arrays->copyOf->setArray->return
CopyOnWriteArrayList#add(int, E):::Inserts the specified element at the specified position in this list:::synchronized->es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->newElements->numMoved->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->setArray
CopyOnWriteArrayList#remove(int):::Removes the element at the specified position in this list:::synchronized->es->getArray->len->oldValue->elementAt->numMoved->newElements->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->setArray->return
CopyOnWriteArrayList#remove(Object):::Removes the first occurrence of the specified element from this list, if it is present:::snapshot->getArray->index->indexOfRange->return->remove
CopyOnWriteArrayList#remove(Object, Object[], int):::A version of remove(Object) using the strong hint that given recent snapshot contains o at the given index.:::synchronized->current->getArray->len->if->prefix->Math->min->for->i->if->return->if->break->indexOfRange->if->return->newElements->new->ObjectArr->System->arraycopy->System->arraycopy->setArray->return
CopyOnWriteArrayList#removeRange(int, int):::Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive:::synchronized->es->getArray->len->if->throw->new->IndexOutOfBoundsException->newlen->numMoved->if->Arrays->copyOf->setArray->else->newElements->new->ObjectArr->System->arraycopy->System->arraycopy->setArray
CopyOnWriteArrayList#addIfAbsent(E):::Appends the element, if not present.:::snapshot->getArray->return->indexOfRange->addIfAbsent
CopyOnWriteArrayList#addIfAbsent(E, Object[]):::A version of addIfAbsent using the strong hint that given recent snapshot does not contain e.:::synchronized->current->getArray->len->if->common->Math->min->for->i->if->indexOfRange->return->newElements->Arrays->copyOf->setArray->return
CopyOnWriteArrayList#containsAll(Collection):::Returns true if this list contains all of the elements of the specified collection.:::es->getArray->len->foreach->if->indexOfRange->return->return
CopyOnWriteArrayList#removeAll(Collection):::Removes from this list all of its elements that are contained in the specified collection:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList#retainAll(Collection):::Retains only the elements in this list that are contained in the specified collection:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList#addAllAbsent(Collection):::Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.:::cs->c->toArray->if->return->synchronized->es->getArray->len->added->for->i->if->newElements->Arrays->copyOf->System->arraycopy->setArray->return
CopyOnWriteArrayList#clear():::Removes all of the elements from this list:::synchronized->new->ObjectArr->setArray
CopyOnWriteArrayList#addAll(Collection):::Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.:::cs->c->getClass->getArray->c->toArray->if->return->synchronized->es->getArray->len->newElements->if->cs->getClass->else->Arrays->copyOf->System->arraycopy->setArray->return
CopyOnWriteArrayList#addAll(int, Collection):::Inserts all of the elements in the specified collection into this list, starting at the specified position:::cs->c->toArray->synchronized->es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->if->return->numMoved->newElements->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->System->arraycopy->setArray->return
CopyOnWriteArrayList#forEach(Consumer)::: copy on write array list for each:::Objects->requireNonNull->foreach->getArray->e->action->accept
CopyOnWriteArrayList#removeIf(Predicate)::: copy on write array list remove if:::Objects->requireNonNull->return->bulkRemove
CopyOnWriteArrayList#nBits(int)::: copy on write array list n bits:::return->new->longArr
CopyOnWriteArrayList#setBit(long[], int)::: copy on write array list set bit:::
CopyOnWriteArrayList#isClear(long[], int)::: copy on write array list is clear:::return
CopyOnWriteArrayList#bulkRemove(Predicate)::: copy on write array list bulk remove:::synchronized->return->getArray->bulkRemove
CopyOnWriteArrayList#bulkRemove(Predicate, int, int)::: copy on write array list bulk remove:::es->getArray->for->filter->elementAt->test->if->beg->deathRow->nBits->deleted->for->if->getArray->throw->new->ConcurrentModificationException->newElts->Arrays->copyOf->w->for->System->arraycopy->setArray->return->else->if->getArray->throw->new->ConcurrentModificationException->return
CopyOnWriteArrayList#replaceAll(UnaryOperator)::: copy on write array list replace all:::synchronized->getArray->replaceAllRange
CopyOnWriteArrayList#replaceAllRange(UnaryOperator, int, int)::: copy on write array list replace all range:::Objects->requireNonNull->es->getArray->clone->for->setArray
CopyOnWriteArrayList#sort(Comparator)::: copy on write array list sort:::synchronized->getArray->sortRange
CopyOnWriteArrayList#sortRange(Comparator, int, int)::: copy on write array list sort range:::es->getArray->clone->Arrays->sort->setArray
CopyOnWriteArrayList#writeObject(java.io.ObjectOutputStream):::Saves this list to a stream (that is, serializes it).:::s->defaultWriteObject->es->getArray->s->writeInt->foreach->s->writeObject
CopyOnWriteArrayList#readObject(java.io.ObjectInputStream):::Reconstitutes this list from a stream (that is, deserializes it).:::s->defaultReadObject->resetLock->len->s->readInt->SharedSecrets->getJavaObjectInputStreamAccess->checkArray->es->new->ObjectArr->for->i->setArray
CopyOnWriteArrayList#toString():::Returns a string representation of this list:::return->Arrays->getArray->toString
CopyOnWriteArrayList#equals(Object):::Compares the specified object with this list for equality:::if->return->if->return->list->it->list->iterator->foreach->getArray->if->it->hasNext->Objects->it->next->equals->return->return->it->hasNext
CopyOnWriteArrayList#hashCodeOfRange(Object[], int, int)::: copy on write array list hash code of range:::hashCode->for->i->return
CopyOnWriteArrayList#hashCode():::Returns the hash code value for this list:::es->getArray->return->hashCodeOfRange
CopyOnWriteArrayList#iterator():::Returns an iterator over the elements in this list in proper sequence:::return->getArray->new->COWIterator<E>
CopyOnWriteArrayList#listIterator():::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::return->getArray->new->COWIterator<E>
CopyOnWriteArrayList#listIterator(int):::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->return->new->COWIterator<E>
CopyOnWriteArrayList#spliterator():::Returns a Spliterator over the elements in this list:::return->Spliterators->getArray->spliterator
CopyOnWriteArrayList.COWIterator#hasNext()::: iterator has next:::return
CopyOnWriteArrayList.COWIterator#hasPrevious()::: iterator has previous:::return
CopyOnWriteArrayList.COWIterator#next()::: iterator next:::if->hasNext->throw->new->NoSuchElementException->return
CopyOnWriteArrayList.COWIterator#previous()::: iterator previous:::if->hasPrevious->throw->new->NoSuchElementException->return
CopyOnWriteArrayList.COWIterator#nextIndex()::: iterator next index:::return
CopyOnWriteArrayList.COWIterator#previousIndex()::: iterator previous index:::return
CopyOnWriteArrayList.COWIterator#remove():::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWIterator#set(E):::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWIterator#add(E):::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWIterator#forEachRemaining(Consumer)::: iterator for each remaining:::Objects->requireNonNull->size->i->for
CopyOnWriteArrayList#subList(int, int):::Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive:::synchronized->es->getArray->len->size->if->throw->new->IndexOutOfBoundsException->return->new->COWSubList
CopyOnWriteArrayList.COWSubList#checkForComodification()::: sub list check for comodification:::if->getArray->throw->new->ConcurrentModificationException
CopyOnWriteArrayList.COWSubList#getArrayChecked()::: sub list get array checked:::a->getArray->if->throw->new->ConcurrentModificationException->return
CopyOnWriteArrayList.COWSubList#rangeCheck(int)::: sub list range check:::if->throw->outOfBounds->new->IndexOutOfBoundsException
CopyOnWriteArrayList.COWSubList#rangeCheckForAdd(int)::: sub list range check for add:::if->throw->outOfBounds->new->IndexOutOfBoundsException
CopyOnWriteArrayList.COWSubList#toArray()::: sub list to array:::es->offset->size->synchronized->getArrayChecked->return->Arrays->copyOfRange
CopyOnWriteArrayList.COWSubList#toArray(T[])::: sub list to array:::es->offset->size->synchronized->getArrayChecked->if->return->Arrays->a->getClass->copyOfRange->else->System->arraycopy->if->return
CopyOnWriteArrayList.COWSubList#indexOf(Object)::: sub list index of:::es->offset->size->synchronized->getArrayChecked->i->indexOfRange->return
CopyOnWriteArrayList.COWSubList#lastIndexOf(Object)::: sub list last index of:::es->offset->size->synchronized->getArrayChecked->i->lastIndexOfRange->return
CopyOnWriteArrayList.COWSubList#contains(Object)::: sub list contains:::return->indexOf
CopyOnWriteArrayList.COWSubList#containsAll(Collection)::: sub list contains all:::es->offset->size->synchronized->getArrayChecked->foreach->if->indexOfRange->return->return
CopyOnWriteArrayList.COWSubList#isEmpty()::: sub list is empty:::return->size
CopyOnWriteArrayList.COWSubList#toString()::: sub list to string:::return->Arrays->toArray->toString
CopyOnWriteArrayList.COWSubList#hashCode()::: sub list hash code:::es->offset->size->synchronized->getArrayChecked->return->hashCodeOfRange
CopyOnWriteArrayList.COWSubList#equals(Object)::: sub list equals:::if->return->if->return->it->iterator->es->offset->size->synchronized->getArrayChecked->for->i->end->return->it->hasNext
CopyOnWriteArrayList.COWSubList#set(int, E)::: sub list set:::synchronized->rangeCheck->checkForComodification->x->CopyOnWriteArrayList.this->set->getArray->return
CopyOnWriteArrayList.COWSubList#get(int)::: sub list get:::synchronized->rangeCheck->checkForComodification->return->CopyOnWriteArrayList.this->get
CopyOnWriteArrayList.COWSubList#size()::: sub list size:::synchronized->checkForComodification->return
CopyOnWriteArrayList.COWSubList#add(E)::: sub list add:::synchronized->checkForComodification->CopyOnWriteArrayList.this->add->getArray->return
CopyOnWriteArrayList.COWSubList#add(int, E)::: sub list add:::synchronized->checkForComodification->rangeCheckForAdd->CopyOnWriteArrayList.this->add->getArray
CopyOnWriteArrayList.COWSubList#addAll(Collection)::: sub list add all:::synchronized->oldArray->getArrayChecked->modified->CopyOnWriteArrayList.this->addAll->getArray->return
CopyOnWriteArrayList.COWSubList#addAll(int, Collection)::: sub list add all:::synchronized->rangeCheckForAdd->oldArray->getArrayChecked->modified->CopyOnWriteArrayList.this->addAll->getArray->return
CopyOnWriteArrayList.COWSubList#clear()::: sub list clear:::synchronized->checkForComodification->removeRange->getArray
CopyOnWriteArrayList.COWSubList#remove(int)::: sub list remove:::synchronized->rangeCheck->checkForComodification->result->CopyOnWriteArrayList.this->remove->getArray->return
CopyOnWriteArrayList.COWSubList#remove(Object)::: sub list remove:::synchronized->checkForComodification->index->indexOf->if->return->remove->return
CopyOnWriteArrayList.COWSubList#iterator()::: sub list iterator:::return->listIterator
CopyOnWriteArrayList.COWSubList#listIterator()::: sub list list iterator:::return->listIterator
CopyOnWriteArrayList.COWSubList#listIterator(int)::: sub list list iterator:::synchronized->checkForComodification->rangeCheckForAdd->return->new->COWSubListIterator<E>
CopyOnWriteArrayList.COWSubList#subList(int, int)::: sub list sub list:::synchronized->checkForComodification->if->throw->new->IndexOutOfBoundsException->return->new->COWSubList
CopyOnWriteArrayList.COWSubList#forEach(Consumer)::: sub list for each:::Objects->requireNonNull->i->end->es->synchronized->getArrayChecked->for
CopyOnWriteArrayList.COWSubList#replaceAll(UnaryOperator)::: sub list replace all:::synchronized->checkForComodification->replaceAllRange->getArray
CopyOnWriteArrayList.COWSubList#sort(Comparator)::: sub list sort:::synchronized->checkForComodification->sortRange->getArray
CopyOnWriteArrayList.COWSubList#removeAll(Collection)::: sub list remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList.COWSubList#retainAll(Collection)::: sub list retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList.COWSubList#removeIf(Predicate)::: sub list remove if:::Objects->requireNonNull->return->bulkRemove
CopyOnWriteArrayList.COWSubList#bulkRemove(Predicate)::: sub list bulk remove:::synchronized->oldArray->getArrayChecked->modified->CopyOnWriteArrayList.this->bulkRemove->getArray->return
CopyOnWriteArrayList.COWSubList#spliterator()::: sub list spliterator:::synchronized->return->Spliterators->getArrayChecked->spliterator
CopyOnWriteArrayList.COWSubListIterator#hasNext()::: sub list iterator has next:::return->nextIndex
CopyOnWriteArrayList.COWSubListIterator#next()::: sub list iterator next:::if->hasNext->return->it->next->else->throw->new->NoSuchElementException
CopyOnWriteArrayList.COWSubListIterator#hasPrevious()::: sub list iterator has previous:::return->previousIndex
CopyOnWriteArrayList.COWSubListIterator#previous()::: sub list iterator previous:::if->hasPrevious->return->it->previous->else->throw->new->NoSuchElementException
CopyOnWriteArrayList.COWSubListIterator#nextIndex()::: sub list iterator next index:::return->it->nextIndex
CopyOnWriteArrayList.COWSubListIterator#previousIndex()::: sub list iterator previous index:::return->it->previousIndex
CopyOnWriteArrayList.COWSubListIterator#remove()::: sub list iterator remove:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWSubListIterator#set(E)::: sub list iterator set:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWSubListIterator#add(E)::: sub list iterator add:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWSubListIterator#forEachRemaining(Consumer)::: sub list iterator for each remaining:::Objects->requireNonNull->while->hasNext->action->it->next->accept
CopyOnWriteArrayList#resetLock():::Initializes the lock; for use when deserializing or cloning.:::lockField->try->f->getDeclaredField->f->setAccessible->return->catch->throw->new->Error->finally->doPrivileged->try->lockField->new->Object->set->catch->throw->new->Error->finally
CopyOnWriteArraySet#size():::Returns the number of elements in this set.:::return->al->size
CopyOnWriteArraySet#isEmpty():::Returns true if this set contains no elements.:::return->al->isEmpty
CopyOnWriteArraySet#contains(Object):::Returns true if this set contains the specified element:::return->al->contains
CopyOnWriteArraySet#toArray():::Returns an array containing all of the elements in this set:::return->al->toArray
CopyOnWriteArraySet#toArray(T[]):::Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array:::return->al->toArray
CopyOnWriteArraySet#clear():::Removes all of the elements from this set:::al->clear
CopyOnWriteArraySet#remove(Object):::Removes the specified element from this set if it is present:::return->al->remove
CopyOnWriteArraySet#add(E):::Adds the specified element to this set if it is not already present:::return->al->addIfAbsent
CopyOnWriteArraySet#containsAll(Collection):::Returns true if this set contains all of the elements of the specified collection:::return->al->getArray->compareSets->al->containsAll
CopyOnWriteArraySet#compareSets(Object[], Set):::Tells whether the objects in snapshot (regarded as a set) are a superset of the given set.:::len->matched->new->booleanArr->j->foreach->for->i->return->return
CopyOnWriteArraySet#addAll(Collection):::Adds all of the elements in the specified collection to this set if they're not already present:::return->al->addAllAbsent
CopyOnWriteArraySet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::return->al->removeAll
CopyOnWriteArraySet#retainAll(Collection):::Retains only the elements in this set that are contained in the specified collection:::return->al->retainAll
CopyOnWriteArraySet#iterator():::Returns an iterator over the elements contained in this set in the order in which these elements were added:::return->al->iterator
CopyOnWriteArraySet#equals(Object):::Compares the specified object with this set for equality:::return->al->getArray->compareSets
CopyOnWriteArraySet#removeIf(Predicate)::: copy on write array set remove if:::return->al->removeIf
CopyOnWriteArraySet#forEach(Consumer)::: copy on write array set for each:::al->forEach
CopyOnWriteArraySet#spliterator():::Returns a Spliterator over the elements in this set in the order in which these elements were added:::return->Spliterators->al->getArray->spliterator
CountDownLatch.Sync#getCount()::: sync get count:::return->getState
CountDownLatch.Sync#tryAcquireShared(int)::: sync try acquire shared:::return->getState
CountDownLatch.Sync#tryReleaseShared(int)::: sync try release shared:::for
CountDownLatch#await():::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted:::sync->acquireSharedInterruptibly
CountDownLatch#await(long, TimeUnit):::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted, or the specified waiting time elapses:::return->sync->unit->toNanos->tryAcquireSharedNanos
CountDownLatch#countDown():::Decrements the count of the latch, releasing all waiting threads if the count reaches zero:::sync->releaseShared
CountDownLatch#getCount():::Returns the current count:::return->sync->getCount
CountDownLatch#toString():::Returns a string identifying this latch, as well as its state:::return->super->toString->sync->getCount
CountedCompleter#compute():::The main computation performed by this task.:::
CountedCompleter#onCompletion(CountedCompleter):::Performs an action when method #tryComplete is invoked and the pending count is zero, or when the unconditional method #complete is invoked:::
CountedCompleter#onExceptionalCompletion(Throwable, CountedCompleter):::Performs an action when method #completeExceptionally(Throwable) is invoked or method #compute throws an exception, and this task has not already otherwise completed normally:::return
CountedCompleter#getCompleter():::Returns the completer established in this task's constructor, or null if none.:::return
CountedCompleter#getPendingCount():::Returns the current pending count.:::return
CountedCompleter#setPendingCount(int):::Sets the pending count to the given value.:::
CountedCompleter#addToPendingCount(int):::Adds (atomically) the given value to the pending count.:::PENDING->getAndAdd
CountedCompleter#compareAndSetPendingCount(int, int):::Sets (atomically) the pending count to the given count only if it currently holds the given expected value.:::return->PENDING->compareAndSet
CountedCompleter#decrementPendingCountUnlessZero():::If the pending count is nonzero, (atomically) decrements it.:::c->do->while->PENDING->weakCompareAndSet->return
CountedCompleter#getRoot():::Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.:::a->p->while->return
CountedCompleter#tryComplete():::If the pending count is nonzero, decrements the count; otherwise invokes #onCompletion(CountedCompleter) and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.:::a->s->for->c
CountedCompleter#propagateCompletion():::Equivalent to #tryComplete but does not invoke #onCompletion(CountedCompleter) along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete:::a->s->for->c
CountedCompleter#complete(T):::Regardless of pending count, invokes #onCompletion(CountedCompleter), marks this task as complete and further triggers #tryComplete on this task's completer, if one exists:::p->setRawResult->onCompletion->quietlyComplete->if->p->tryComplete
CountedCompleter#firstComplete():::If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null:::for->c
CountedCompleter#nextComplete():::If this task does not have a completer, invokes ForkJoinTask#quietlyComplete and returns null:::p->if->return->p->firstComplete->else->quietlyComplete->return
CountedCompleter#quietlyCompleteRoot():::Equivalent to getRoot().quietlyComplete().:::for->a->p
CountedCompleter#helpComplete(int):::If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.:::t->wt->if->if->Thread->currentThread->helpComplete->else->externalHelpComplete
CountedCompleter#internalPropagateException(Throwable):::Supports ForkJoinTask exception propagation.:::a->s->while->a->onExceptionalCompletion->a->recordExceptionalCompletion->isExceptionalStatus
CountedCompleter#exec():::Implements execution conventions for CountedCompleters.:::compute->return
CountedCompleter#getRawResult():::Returns the result of the computation:::return
CountedCompleter#setRawResult(T):::A method that result-bearing CountedCompleters may optionally use to help maintain result data:::
CyclicBarrier#nextGeneration():::Updates state on barrier trip and wakes up everyone:::trip->signalAll->new->Generation
CyclicBarrier#breakBarrier():::Sets current barrier generation as broken and wakes up everyone:::trip->signalAll
CyclicBarrier#dowait(boolean, long):::Main barrier code, covering the various policies.:::lock->lock->lock->try->g->if->throw->new->BrokenBarrierException->if->Thread->interrupted->breakBarrier->throw->new->InterruptedException->index->if->ranAction->try->command->if->command->run->nextGeneration->return->catch->finally->if->breakBarrier->for->catch->finally->lock->unlock
CyclicBarrier#getParties():::Returns the number of parties required to trip this barrier.:::return
CyclicBarrier#await():::Waits until all #getParties parties have invoked await on this barrier:::try->return->dowait->catch->throw->new->Error->finally
CyclicBarrier#await(long, TimeUnit):::Waits until all #getParties parties have invoked await on this barrier, or the specified waiting time elapses:::return->unit->toNanos->dowait
CyclicBarrier#isBroken():::Queries if this barrier is in a broken state.:::lock->lock->lock->try->return->catch->finally->lock->unlock
CyclicBarrier#reset():::Resets the barrier to its initial state:::lock->lock->lock->try->breakBarrier->nextGeneration->catch->finally->lock->unlock
CyclicBarrier#getNumberWaiting():::Returns the number of parties currently waiting at the barrier:::lock->lock->lock->try->return->catch->finally->lock->unlock
Delayed#getDelay(TimeUnit):::Returns the remaining delay associated with this object, in the given time unit.:::
DelayQueue#add(E):::Inserts the specified element into this delay queue.:::return->offer
DelayQueue#offer(E):::Inserts the specified element into this delay queue.:::lock->lock->lock->try->q->offer->if->q->peek->available->signal->return->catch->finally->lock->unlock
DelayQueue#put(E):::Inserts the specified element into this delay queue:::offer
DelayQueue#offer(E, long, TimeUnit):::Inserts the specified element into this delay queue:::return->offer
DelayQueue#poll():::Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.:::lock->lock->lock->try->first->q->peek->return->first->getDelay->q->poll->catch->finally->lock->unlock
DelayQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.:::lock->lock->lockInterruptibly->try->for->catch->finally->if->q->peek->available->signal->lock->unlock
DelayQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->for->catch->finally->if->q->peek->available->signal->lock->unlock
DelayQueue#peek():::Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty:::lock->lock->lock->try->return->q->peek->catch->finally->lock->unlock
DelayQueue#size()::: delay queue size:::lock->lock->lock->try->return->q->size->catch->finally->lock->unlock
DelayQueue#drainTo(Collection)::: delay queue drain to:::return->drainTo
DelayQueue#drainTo(Collection, int)::: delay queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->lock->lock->lock->try->n->for->first->q->peek->first->getDelay->return->catch->finally->lock->unlock
DelayQueue#clear():::Atomically removes all of the elements from this delay queue:::lock->lock->lock->try->q->clear->catch->finally->lock->unlock
DelayQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.:::return
DelayQueue#toArray():::Returns an array containing all of the elements in this queue:::lock->lock->lock->try->return->q->toArray->catch->finally->lock->unlock
DelayQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->return->q->toArray->catch->finally->lock->unlock
DelayQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.:::lock->lock->lock->try->return->q->remove->catch->finally->lock->unlock
DelayQueue#removeEQ(Object):::Identity-based version for use in Itr.remove.:::lock->lock->lock->try->for->it->q->iterator->it->hasNext->catch->finally->lock->unlock
DelayQueue#iterator():::Returns an iterator over all the elements (both expired and unexpired) in this queue:::return->toArray->new->Itr
DelayQueue.Itr#hasNext()::: itr has next:::return
DelayQueue.Itr#next()::: itr next:::if->throw->new->NoSuchElementException->return
DelayQueue.Itr#remove()::: itr remove:::if->throw->new->IllegalStateException->removeEQ
Exchanger.Participant#initialValue()::: participant initial value:::return->new->Node
Exchanger#arenaExchange(Object, boolean, long):::Exchange function when arenas enabled:::a->alen->p->participant->get->for->i
Exchanger#slotExchange(Object, boolean, long):::Exchange function used until arenas enabled:::p->participant->get->t->Thread->currentThread->if->t->isInterrupted->return->for->q->h->end->System->nanoTime->spins->v->while->if->if->t->getId->else->if->Thread->yield->else->if->else->if->t->isInterrupted->System->nanoTime->if->if->LockSupport->park->else->LockSupport->parkNanos->else->if->SLOT->compareAndSet->t->isInterrupted->break->MATCH->setRelease->return
Exchanger#exchange(V):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted), and then transfers the given object to it, receiving its object in return:::v->a->item->if->slotExchange->Thread->interrupted->arenaExchange->throw->new->InterruptedException->return
Exchanger#exchange(V, long, TimeUnit):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return:::v->item->ns->unit->toNanos->if->slotExchange->Thread->interrupted->arenaExchange->throw->new->InterruptedException->if->throw->new->TimeoutException->return
Executor#execute(Runnable):::Executes the given command at some time in the future:::
ExecutorCompletionService.QueueingFuture#done()::: queueing future done:::completionQueue->add
ExecutorCompletionService#newTaskFor(Callable)::: executor completion service new task for:::if->return->new->FutureTask<V>->else->return->aes->newTaskFor
ExecutorCompletionService#newTaskFor(Runnable, V)::: executor completion service new task for:::if->return->new->FutureTask<V>->else->return->aes->newTaskFor
ExecutorCompletionService#submit(Callable)::: executor completion service submit:::if->throw->new->NullPointerException->f->newTaskFor->executor->new->QueueingFuture<V>->execute->return
ExecutorCompletionService#submit(Runnable, V)::: executor completion service submit:::if->throw->new->NullPointerException->f->newTaskFor->executor->new->QueueingFuture<V>->execute->return
ExecutorCompletionService#take()::: executor completion service take:::return->completionQueue->take
ExecutorCompletionService#poll()::: executor completion service poll:::return->completionQueue->poll
ExecutorCompletionService#poll(long, TimeUnit)::: executor completion service poll:::return->completionQueue->poll
Executors#newFixedThreadPool(int):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor
Executors#newWorkStealingPool(int):::Creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention:::return->new->ForkJoinPool
Executors#newWorkStealingPool():::Creates a work-stealing thread pool using the number of Runtime#availableProcessors available processors as its target parallelism level.:::return->Runtime->getRuntime->availableProcessors->new->ForkJoinPool
Executors#newFixedThreadPool(int, ThreadFactory):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue, using the provided ThreadFactory to create new threads when needed:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor
Executors#newSingleThreadExecutor():::Creates an Executor that uses a single worker thread operating off an unbounded queue:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor->new->FinalizableDelegatedExecutorService
Executors#newSingleThreadExecutor(ThreadFactory):::Creates an Executor that uses a single worker thread operating off an unbounded queue, and uses the provided ThreadFactory to create a new thread when needed:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor->new->FinalizableDelegatedExecutorService
Executors#newCachedThreadPool():::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available:::return->new->SynchronousQueue<Runnable>->new->ThreadPoolExecutor
Executors#newCachedThreadPool(ThreadFactory):::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available, and uses the provided ThreadFactory to create new threads when needed.:::return->new->SynchronousQueue<Runnable>->new->ThreadPoolExecutor
Executors#newSingleThreadScheduledExecutor():::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::return->new->ScheduledThreadPoolExecutor->new->DelegatedScheduledExecutorService
Executors#newSingleThreadScheduledExecutor(ThreadFactory):::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::return->new->ScheduledThreadPoolExecutor->new->DelegatedScheduledExecutorService
Executors#newScheduledThreadPool(int):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::return->new->ScheduledThreadPoolExecutor
Executors#newScheduledThreadPool(int, ThreadFactory):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::return->new->ScheduledThreadPoolExecutor
Executors#unconfigurableExecutorService(ExecutorService):::Returns an object that delegates all defined ExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::if->throw->new->NullPointerException->return->new->DelegatedExecutorService
Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService):::Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::if->throw->new->NullPointerException->return->new->DelegatedScheduledExecutorService
Executors#defaultThreadFactory():::Returns a default thread factory used to create new threads:::return->new->DefaultThreadFactory
Executors#privilegedThreadFactory():::Returns a thread factory used to create new threads that have the same permissions as the current thread:::return->new->PrivilegedThreadFactory
Executors#callable(Runnable, T):::Returns a Callable object that, when called, runs the given task and returns the given result:::if->throw->new->NullPointerException->return->new->RunnableAdapter<T>
Executors#callable(Runnable):::Returns a Callable object that, when called, runs the given task and returns null.:::if->throw->new->NullPointerException->return->new->RunnableAdapter<Object>
Executors#callable(PrivilegedAction):::Returns a Callable object that, when called, runs the given privileged action and returns its result.:::if->throw->new->NullPointerException->return->new->Callable<Object>
Executors#callable(PrivilegedExceptionAction):::Returns a Callable object that, when called, runs the given privileged exception action and returns its result.:::if->throw->new->NullPointerException->return->new->Callable<Object>
Executors#privilegedCallable(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context:::if->throw->new->NullPointerException->return->new->PrivilegedCallable<T>
Executors#privilegedCallableUsingCurrentClassLoader(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context, with the current context class loader as the context class loader:::if->throw->new->NullPointerException->return->new->PrivilegedCallableUsingCurrentClassLoader<T>
Executors.RunnableAdapter#call()::: runnable adapter call:::task->run->return
Executors.RunnableAdapter#toString()::: runnable adapter to string:::return->super->toString
Executors.PrivilegedCallable#call()::: privileged callable call:::try->return->AccessController->new->PrivilegedExceptionAction<T>->doPrivileged->catch->throw->e->getException->finally
Executors.PrivilegedCallable#toString()::: privileged callable to string:::return->super->toString
Executors.PrivilegedCallableUsingCurrentClassLoader#call()::: privileged callable using current class loader call:::try->return->AccessController->new->PrivilegedExceptionAction<T>->doPrivileged->catch->throw->e->getException->finally
Executors.PrivilegedCallableUsingCurrentClassLoader#toString()::: privileged callable using current class loader to string:::return->super->toString
Executors.DefaultThreadFactory#newThread(Runnable)::: default thread factory new thread:::t->threadNumber->getAndIncrement->new->Thread->if->t->isDaemon->t->setDaemon->if->t->getPriority->t->setPriority->return
Executors.PrivilegedThreadFactory#newThread(Runnable)::: privileged thread factory new thread:::return->super->new->Runnable->newThread
Executors.DelegatedExecutorService#execute(Runnable)::: delegated executor service execute:::try->e->execute->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#shutdown()::: delegated executor service shutdown:::e->shutdown
Executors.DelegatedExecutorService#shutdownNow()::: delegated executor service shutdown now:::try->return->e->shutdownNow->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#isShutdown()::: delegated executor service is shutdown:::try->return->e->isShutdown->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#isTerminated()::: delegated executor service is terminated:::try->return->e->isTerminated->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#awaitTermination(long, TimeUnit)::: delegated executor service await termination:::try->return->e->awaitTermination->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#submit(Runnable)::: delegated executor service submit:::try->return->e->submit->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#submit(Callable)::: delegated executor service submit:::try->return->e->submit->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#submit(Runnable, T)::: delegated executor service submit:::try->return->e->submit->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#invokeAll(Collection>)::: delegated executor service invoke all:::try->return->e->invokeAll->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#invokeAll(Collection>, long, TimeUnit)::: delegated executor service invoke all:::try->return->e->invokeAll->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#invokeAny(Collection>)::: delegated executor service invoke any:::try->return->e->invokeAny->catch->finally->reachabilityFence
Executors.DelegatedExecutorService#invokeAny(Collection>, long, TimeUnit)::: delegated executor service invoke any:::try->return->e->invokeAny->catch->finally->reachabilityFence
Executors.FinalizableDelegatedExecutorService#finalize()::: finalizable delegated executor service finalize:::super->shutdown
Executors.DelegatedScheduledExecutorService#schedule(Runnable, long, TimeUnit)::: delegated scheduled executor service schedule:::return->e->schedule
Executors.DelegatedScheduledExecutorService#schedule(Callable, long, TimeUnit)::: delegated scheduled executor service schedule:::return->e->schedule
Executors.DelegatedScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)::: delegated scheduled executor service schedule at fixed rate:::return->e->scheduleAtFixedRate
Executors.DelegatedScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)::: delegated scheduled executor service schedule with fixed delay:::return->e->scheduleWithFixedDelay
ExecutorService#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::
ExecutorService#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::
ExecutorService#isShutdown():::Returns true if this executor has been shut down.:::
ExecutorService#isTerminated():::Returns true if all tasks have completed following shut down:::
ExecutorService#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.:::
ExecutorService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
ExecutorService#submit(Runnable, T):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#submit(Runnable):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#invokeAll(Collection>):::Executes the given tasks, returning a list of Futures holding their status and results when all complete:::
ExecutorService#invokeAll(Collection>, long, TimeUnit):::Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first:::
ExecutorService#invokeAny(Collection>):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do:::
ExecutorService#invokeAny(Collection>, long, TimeUnit):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses:::
Flow.Publisher#subscribe(Subscriber):::Adds the given Subscriber if possible:::
Flow.Subscriber#onSubscribe(Subscription):::Method invoked prior to invoking any other Subscriber methods for the given Subscription:::
Flow.Subscriber#onNext(T):::Method invoked with a Subscription's next item:::
Flow.Subscriber#onError(Throwable):::Method invoked upon an unrecoverable error encountered by a Publisher or Subscription, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscriber#onComplete():::Method invoked when it is known that no additional Subscriber method invocations will occur for a Subscription that is not already terminated by error, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscription#request(long):::Adds the given number n of items to the current unfulfilled demand for this subscription:::
Flow.Subscription#cancel():::Causes the Subscriber to (eventually) stop receiving messages:::
Flow#defaultBufferSize():::Returns a default value for Publisher or Subscriber buffering, that may be used in the absence of other constraints.:::return
ForkJoinPool#checkPermission():::If there is a security manager, makes sure caller has permission to modify threads.:::security->System->getSecurityManager->if->security->checkPermission
ForkJoinPool.ForkJoinWorkerThreadFactory#newThread(ForkJoinPool):::Returns a new worker thread operating in the given pool:::
ForkJoinPool#contextWithPermissions(Permission...)::: fork join pool context with permissions:::permissions->new->Permissions->foreach->permissions->add->return->new->ProtectionDomainArr->new->ProtectionDomain->new->AccessControlContext
ForkJoinPool.DefaultForkJoinWorkerThreadFactory#newThread(ForkJoinPool)::: default fork join worker thread factory new thread:::return->AccessController->new->PrivilegedAction<>->doPrivileged
ForkJoinPool.WorkQueue#tryLockPhase():::Tries to lock shared queue by CASing phase field.:::return->PHASE->compareAndSet
ForkJoinPool.WorkQueue#releasePhaseLock()::: work queue release phase lock:::PHASE->setRelease
ForkJoinPool.WorkQueue#getPoolIndex():::Returns an exportable index (used by ForkJoinWorkerThread).:::return
ForkJoinPool.WorkQueue#queueSize():::Returns the approximate number of tasks in the queue.:::n->BASE->getAcquire->return
ForkJoinPool.WorkQueue#isEmpty():::Provides a more accurate estimate of whether this queue has any tasks than does queueSize, by checking whether a near-empty queue has at least one unclaimed task.:::a->n->cap->b->VarHandle->acquireFence->return
ForkJoinPool.WorkQueue#push(ForkJoinTask):::Pushes a task:::a->s->d->cap->m->p->if->QA->setRelease->if->BASE->getAcquire->VarHandle->fullFence->p->signalWork->else->if->growArray
ForkJoinPool.WorkQueue#lockedPush(ForkJoinTask):::Version of push for shared queues:::a->signal->s->b->cap->d->if->if->growArray->else->if->return
ForkJoinPool.WorkQueue#growArray(boolean):::Doubles the capacity of array:::newA->try->oldA->oldSize->newSize->if->try->new->ForkJoinTask<?>Arr->catch->finally->if->oldMask->newMask->for->s->k->VarHandle->releaseFence->catch->finally->if->if->throw->new->RejectedExecutionException
ForkJoinPool.WorkQueue#poll():::Takes next task, if one exists, in FIFO order.:::b->k->cap->a->while->t->QA->getAcquire->if->if->Thread->yield->else->if->QA->compareAndSet->BASE->setOpaque->return->return
ForkJoinPool.WorkQueue#nextLocalTask():::Takes next task, if one exists, in order specified by mode.:::t->md->b->s->d->cap->a->if->if->if->QA->getAndSet->TOP->setOpaque->else->if->QA->getAndSet->BASE->setOpaque->else->poll->return
ForkJoinPool.WorkQueue#peek():::Returns next task, if one exists, in order specified by mode.:::cap->a->return
ForkJoinPool.WorkQueue#tryUnpush(ForkJoinTask):::Pops the given task only if it is at the current top.:::popped->s->cap->a->if->QA->compareAndSet->TOP->setOpaque->return
ForkJoinPool.WorkQueue#tryLockedUnpush(ForkJoinTask):::Shared version of tryUnpush.:::popped->s->k->cap->a->if->tryLockPhase->if->QA->compareAndSet->releasePhaseLock->return
ForkJoinPool.WorkQueue#cancelAll():::Removes and cancels all known tasks, ignoring any exceptions.:::for->t->poll
ForkJoinPool.WorkQueue#topLevelExec(ForkJoinTask, WorkQueue, int):::Runs the given (stolen) task if nonnull, as well as remaining local tasks and others available from the given queue, up to bound n (to avoid infinite unfairness).:::if->nstolen->for->thread->if->thread->afterTopLevelExec
ForkJoinPool.WorkQueue#tryRemoveAndExec(ForkJoinTask):::If present, removes task from queue and executes it.:::a->s->cap->if->for->m->ns->i
ForkJoinPool.WorkQueue#helpCC(CountedCompleter, int, boolean):::Tries to pop and run tasks within the target's computation until done, not found, or limit exceeded.:::status->if->s->k->cap->a->while->v->o->if->t->for->f->if->v->doExec->if->break->return
ForkJoinPool.WorkQueue#helpAsyncBlocker(ManagedBlocker):::Tries to poll and run AsynchronousCompletionTasks until none found or blocker is released:::if->b->k->cap->a->t->while->QA->getAcquire->if->blocker->isReleasable->break->else->if->if->break->else->if->QA->compareAndSet->BASE->setOpaque->t->doExec
ForkJoinPool.WorkQueue#isApparentlyUnblocked():::Returns true if owned and not known to be blocked.:::wt->s->return->wt->getState
ForkJoinPool#nextPoolId():::Returns the next sequence number:::return
ForkJoinPool#createWorker():::Tries to construct and start one worker:::fac->ex->wt->try->if->fac->newThread->wt->start->return->catch->finally->deregisterWorker->return
ForkJoinPool#tryAddWorker(long):::Tries to add one worker, incrementing ctl counts before doing so, relying on createWorker to back out on failure.:::do->nc->if->CTL->compareAndSet->createWorker->break->while
ForkJoinPool#registerWorker(ForkJoinWorkerThread):::Callback from ForkJoinWorkerThread constructor to establish and record its WorkQueue.:::handler->wt->setDaemon->if->wt->setUncaughtExceptionHandler->tid->idbits->prefix->w->new->WorkQueue->if->synchronized->ws->n->s->if->m->for->probes->if->else->an->as->new->WorkQueueArr->am->for->j->wt->prefix->Integer->toString->concat->setName->return
ForkJoinPool#deregisterWorker(ForkJoinWorkerThread, Throwable):::Final callback from terminating worker, as well as upon failure to construct or start a worker:::w->phase->if->lock->wid->ns->if->synchronized->ws->n->i->if->if->c->do->while->CTL->weakCompareAndSet->if->w->cancelAll->if->tryTerminate->signalWork->if->ForkJoinTask->helpExpungeStaleExceptions->else->ForkJoinTask->rethrow
ForkJoinPool#signalWork():::Tries to create or release a worker if too few are running.:::for
ForkJoinPool#tryCompensate(WorkQueue):::Tries to decrement counts (sometimes implicitly) and possibly arrange for a compensating worker in preparation for blocking: If not all core workers yet exist, creates one, else if any are unreleased (possibly including caller) releases one, else if fewer than the minimum allowed number of workers running, checks to see that they are all active, and if so creates an extra worker unless over maximum limit and policy is to saturate:::t->n->sp->c->ws->if->if->return->else->if->v->wp->uc->np->if->vp->vt->nc->if->CTL->compareAndSet->if->LockSupport->unpark->return->return->else->if->nc->return->CTL->compareAndSet->else->md->pc->tc->bc->unstable->for->i->if->return->else->if->sat->if->sat->test->return->else->if->Thread->yield->return->else->throw->new->RejectedExecutionException->nc->return->CTL->compareAndSet->createWorker
ForkJoinPool#runWorker(WorkQueue):::Top-level runloop for workers, called by ForkJoinWorkerThread.run:::r->ThreadLocalRandom->nextSecondarySeed->new->ForkJoinTask<?>Arr->for
ForkJoinPool#scan(WorkQueue, int):::Scans for and if found executes one or more top-level tasks from a queue.:::ws->n->if->for->m->j->return
ForkJoinPool#awaitJoin(WorkQueue, ForkJoinTask, long):::Helps and/or blocks until the given task is done or timeout:::s->seed->ThreadLocalRandom->nextSecondarySeed->if->w->helpCC->w->tryRemoveAndExec->src->id->r->step->while->ws->n->m->while->q->b->if->a->cap->k->qid->if->t->QA->getAcquire->if->QA->compareAndSet->t->doExec->break->else->if->break->else->if->ms->ns->block->if->else->if->System->nanoTime->break->else->if->toMillis->if->tryCompensate->task->internalWait->CTL->getAndAdd->return
ForkJoinPool#helpQuiescePool(WorkQueue):::Runs tasks until isQuiescent():::prevSrc->seed->ThreadLocalRandom->nextSecondarySeed->r->step->for->source->released
ForkJoinPool#pollScan(boolean):::Scans for and returns a polled task, if available:::ws->n->while->m->r->ThreadLocalRandom->nextSecondarySeed->h->origin->step->if->else->nonempty->for->i->oldSum->checkSum->return
ForkJoinPool#nextTaskFor(WorkQueue):::Gets and removes a local or stolen task for the given worker.:::t->if->w->nextLocalTask->pollScan->return
ForkJoinPool#externalPush(ForkJoinTask):::Adds the given task to a submission queue at submitter's current queue, creating one if null or contended.:::r->if->ThreadLocalRandom->getProbe->ThreadLocalRandom->localInit->ThreadLocalRandom->getProbe->for
ForkJoinPool#externalSubmit(ForkJoinTask):::Pushes a possibly-external submission.:::t->w->q->if->throw->new->NullPointerException->if->Thread->currentThread->q->push->else->externalPush->return
ForkJoinPool#commonSubmitterQueue():::Returns common pool queue for an external thread.:::p->r->ThreadLocalRandom->getProbe->ws->n->return
ForkJoinPool#tryExternalUnpush(ForkJoinTask):::Performs tryUnpush for an external submitter.:::r->ThreadLocalRandom->getProbe->ws->w->n->return->w->tryLockedUnpush
ForkJoinPool#externalHelpComplete(CountedCompleter, int):::Performs helpComplete for an external submitter.:::r->ThreadLocalRandom->getProbe->ws->w->n->return->w->helpCC
ForkJoinPool#helpComplete(WorkQueue, CountedCompleter, int):::Tries to steal and run tasks within the target's computation:::return->w->helpCC
ForkJoinPool#getSurplusQueuedTaskCount():::Returns a cheap heuristic guide for task partitioning when programmers, frameworks, tools, or languages have little or no idea about task granularity:::t->wt->pool->q->if->Thread->currentThread->p->a->n->return->return
ForkJoinPool#tryTerminate(boolean, boolean):::Possibly initiates and/or completes termination.:::md->while->if->return->else->MODE->compareAndSet->while->if->for->oldSum->if->MODE->compareAndSet->while->for->oldSum->if->break->else->if->break->else->if->MODE->compareAndSet->synchronized->notifyAll->break->return
ForkJoinPool#newInstanceFromSystemProperty(String)::: fork join pool new instance from system property:::className->System->getProperty->return->ClassLoader->getSystemClassLoader->loadClass->getConstructor->newInstance
ForkJoinPool#commonPool():::Returns the common pool instance:::return
ForkJoinPool#invoke(ForkJoinTask):::Performs the given task, returning its result upon completion:::if->throw->new->NullPointerException->externalSubmit->return->task->join
ForkJoinPool#execute(ForkJoinTask):::Arranges for (asynchronous) execution of the given task.:::externalSubmit
ForkJoinPool#execute(Runnable)::: fork join pool execute:::if->throw->new->NullPointerException->job->if->else->new->ForkJoinTask.RunnableExecuteAction->externalSubmit
ForkJoinPool#submit(ForkJoinTask):::Submits a ForkJoinTask for execution.:::return->externalSubmit
ForkJoinPool#submit(Callable)::: fork join pool submit:::return->new->ForkJoinTask.AdaptedCallable<T>->externalSubmit
ForkJoinPool#submit(Runnable, T)::: fork join pool submit:::return->new->ForkJoinTask.AdaptedRunnable<T>->externalSubmit
ForkJoinPool#submit(Runnable)::: fork join pool submit:::if->throw->new->NullPointerException->return->new->ForkJoinTask.AdaptedRunnableAction->externalSubmit
ForkJoinPool#invokeAll(Collection>)::: fork join pool invoke all:::futures->tasks->size->new->ArrayList<>->try->foreach->f->new->ForkJoinTask.AdaptedCallable<T>->futures->add->externalSubmit->for->i->size->futures->size->return->catch->for->i->size->futures->size->throw->finally
ForkJoinPool#getFactory():::Returns the factory used for constructing new workers.:::return
ForkJoinPool#getUncaughtExceptionHandler():::Returns the handler for internal worker threads that terminate due to unrecoverable errors encountered while executing tasks.:::return
ForkJoinPool#getParallelism():::Returns the targeted parallelism level of this pool.:::par->return
ForkJoinPool#getCommonPoolParallelism():::Returns the targeted parallelism level of the common pool.:::return
ForkJoinPool#getPoolSize():::Returns the number of worker threads that have started but not yet terminated:::return
ForkJoinPool#getAsyncMode():::Returns true if this pool uses local first-in-first-out scheduling mode for forked tasks that are never joined.:::return
ForkJoinPool#getRunningThreadCount():::Returns an estimate of the number of worker threads that are not blocked waiting to join tasks or for other managed synchronization:::ws->w->VarHandle->acquireFence->rc->if->for->i->return
ForkJoinPool#getActiveThreadCount():::Returns an estimate of the number of threads that are currently stealing or executing tasks:::r->return
ForkJoinPool#isQuiescent():::Returns true if all worker threads are currently idle:::for
ForkJoinPool#getStealCount():::Returns an estimate of the total number of tasks stolen from one thread's work queue by another:::count->ws->w->if->for->i->return
ForkJoinPool#getQueuedTaskCount():::Returns an estimate of the total number of tasks currently held in queues by worker threads (but not including tasks submitted to the pool that have not begun executing):::ws->w->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#getQueuedSubmissionCount():::Returns an estimate of the number of tasks submitted to this pool that have not yet begun executing:::ws->w->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#hasQueuedSubmissions():::Returns true if there are any tasks submitted to this pool that have not yet begun executing.:::ws->w->VarHandle->acquireFence->if->for->i->return
ForkJoinPool#pollSubmission():::Removes and returns the next unexecuted submission if one is available:::return->pollScan
ForkJoinPool#drainTasksTo(Collection>):::Removes all available unexecuted submitted and forked tasks from scheduling queues and adds them to the given collection, without altering their execution status:::ws->w->t->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#toString():::Returns a string identifying this pool, as well as its state, including indications of run state, parallelism level, and worker and task counts.:::md->c->st->qt->qs->rc->ws->w->if->for->i->pc->tc->ac->if->level->return->super->toString
ForkJoinPool#shutdown():::Possibly initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::checkPermission->tryTerminate
ForkJoinPool#shutdownNow():::Possibly attempts to cancel and/or stop all tasks, and reject all subsequently submitted tasks:::checkPermission->tryTerminate->return->Collections->emptyList
ForkJoinPool#isTerminated():::Returns true if all tasks have completed following shut down.:::return
ForkJoinPool#isTerminating():::Returns true if the process of termination has commenced but not yet completed:::md->return
ForkJoinPool#isShutdown():::Returns true if this pool has been shut down.:::return
ForkJoinPool#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first:::if->Thread->interrupted->throw->new->InterruptedException->if->awaitQuiescence->return->nanos->unit->toNanos->if->isTerminated->return->if->return->deadline->System->nanoTime->synchronized->for
ForkJoinPool#awaitQuiescence(long, TimeUnit):::If called by a ForkJoinTask operating in this pool, equivalent in effect to ForkJoinTask#helpQuiesce:::nanos->unit->toNanos->wt->thread->Thread->currentThread->if->helpQuiescePool->return->else->for->startTime->System->nanoTime
ForkJoinPool#quiesceCommonPool():::Waits and/or attempts to assist performing tasks indefinitely until the #commonPool() #isQuiescent.:::common->awaitQuiescence
ForkJoinPool.ManagedBlocker#block():::Possibly blocks the current thread, for example waiting for a lock or condition.:::
ForkJoinPool.ManagedBlocker#isReleasable():::Returns true if blocking is unnecessary.:::
ForkJoinPool#managedBlock(ManagedBlocker):::Runs the given possibly blocking task:::if->throw->new->NullPointerException->p->wt->w->t->Thread->currentThread->if->block->while->blocker->isReleasable->if->p->tryCompensate->try->do->while->blocker->isReleasable->blocker->block->catch->finally->CTL->getAndAdd->break->else->do->while->blocker->isReleasable->blocker->block
ForkJoinPool#helpAsyncBlocker(Executor, ManagedBlocker):::If the given executor is a ForkJoinPool, poll and execute AsynchronousCompletionTasks from worker's queue until none are available or blocker is released.:::if->w->wt->ws->r->n->p->thread->Thread->currentThread->if->else->if->ThreadLocalRandom->getProbe->else->if->w->helpAsyncBlocker
ForkJoinPool#newTaskFor(Runnable, T)::: fork join pool new task for:::return->new->ForkJoinTask.AdaptedRunnable<T>
ForkJoinPool#newTaskFor(Callable)::: fork join pool new task for:::return->new->ForkJoinTask.AdaptedCallable<T>
ForkJoinPool.InnocuousForkJoinWorkerThreadFactory#newThread(ForkJoinPool)::: innocuous fork join worker thread factory new thread:::return->AccessController->new->PrivilegedAction<>->doPrivileged
ForkJoinTask#isExceptionalStatus(int)::: fork join task is exceptional status:::return
ForkJoinTask#setDone():::Sets DONE status and wakes up threads waiting to join this task.:::s->if->STATUS->getAndBitwiseOr->synchronized->notifyAll->return
ForkJoinTask#abnormalCompletion(int):::Marks cancelled or exceptional completion unless already done.:::for->s->ns
ForkJoinTask#doExec():::Primary execution method for stolen tasks:::s->completed->if->try->exec->catch->setExceptionalCompletion->finally->if->setDone->return
ForkJoinTask#internalWait(long):::If not done, sets SIGNAL status and performs Object.wait(timeout):::if->STATUS->getAndBitwiseOr->synchronized->if->try->wait->catch->finally->else->notifyAll
ForkJoinTask#externalAwaitDone():::Blocks a non-worker-thread until completion.:::s->tryExternalHelp->if->STATUS->getAndBitwiseOr->interrupted->synchronized->for->if->Thread->currentThread->interrupt->return
ForkJoinTask#externalInterruptibleAwaitDone():::Blocks a non-worker-thread until completion or interruption.:::s->tryExternalHelp->if->STATUS->getAndBitwiseOr->synchronized->for->else->if->Thread->interrupted->throw->new->InterruptedException->return
ForkJoinTask#tryExternalHelp():::Tries to help with tasks allowed for external callers.:::s->return->externalHelpComplete->tryExternalUnpush->doExec
ForkJoinTask#doJoin():::Implementation for join, get, quietlyJoin:::s->t->wt->w->return->Thread->currentThread->tryUnpush->doExec->awaitJoin->externalAwaitDone
ForkJoinTask#doInvoke():::Implementation for invoke, quietlyInvoke.:::s->t->wt->return->doExec->Thread->currentThread->awaitJoin->externalAwaitDone
ForkJoinTask#recordExceptionalCompletion(Throwable):::Records exception and sets status.:::s->if->h->System->identityHashCode->lock->lock->lock->try->expungeStaleExceptions->t->i->for->e->catch->finally->lock->unlock->abnormalCompletion->return
ForkJoinTask#setExceptionalCompletion(Throwable):::Records exception and possibly propagates.:::s->recordExceptionalCompletion->if->internalPropagateException->return
ForkJoinTask#internalPropagateException(Throwable):::Hook for exception propagation support for tasks with completers.:::
ForkJoinTask#cancelIgnoringExceptions(ForkJoinTask):::Cancels, ignoring any exceptions thrown by cancel:::if->try->t->cancel->catch->finally
ForkJoinTask#clearExceptionalCompletion():::Removes exception node and clears status.:::h->System->identityHashCode->lock->lock->lock->try->t->i->e->pred->while->next->if->e->get->if->else->break->expungeStaleExceptions->catch->finally->lock->unlock
ForkJoinTask#getThrowableException():::Returns a rethrowable exception for this task, if available:::h->System->identityHashCode->e->lock->lock->lock->try->expungeStaleExceptions->t->while->e->get->catch->finally->lock->unlock->ex->if->return->if->Thread->currentThread->getId->try->noArgCtor->foreach->ex->getClass->getConstructors->ps->c->getParameterTypes->if->else->if->return->c->newInstance->if->wx->noArgCtor->newInstance->wx->initCause->return->catch->finally->return
ForkJoinTask#expungeStaleExceptions():::Polls stale refs and removes them:::for->x->exceptionTableRefQueue->poll
ForkJoinTask#helpExpungeStaleExceptions():::If lock is available, polls stale refs and removes them:::lock->if->lock->tryLock->try->expungeStaleExceptions->catch->finally->lock->unlock
ForkJoinTask#rethrow(Throwable):::A version of "sneaky throw" to relay exceptions.:::ForkJoinTask->uncheckedThrow
ForkJoinTask#uncheckedThrow(Throwable):::The sneaky part of sneaky throw, relying on generics limitations to evade compiler complaints about rethrowing unchecked exceptions.:::if->throw->else->throw->new->Error
ForkJoinTask#reportException(int):::Throws exception, if any, associated with the given status.:::getThrowableException->new->CancellationException->rethrow
ForkJoinTask#fork():::Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool#commonPool() if not #inForkJoinPool:::t->if->Thread->currentThread->push->else->externalPush->return
ForkJoinTask#join():::Returns the result of the computation when it #isDone is done:::s->if->doJoin->reportException->return->getRawResult
ForkJoinTask#invoke():::Commences performing this task, awaits its completion if necessary, and returns its result, or throws an (unchecked) RuntimeException or Error if the underlying computation did so.:::s->if->doInvoke->reportException->return->getRawResult
ForkJoinTask#invokeAll(ForkJoinTask, ForkJoinTask):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::s1->s2->t2->fork->if->t1->doInvoke->t1->reportException->if->t2->doJoin->t2->reportException
ForkJoinTask#invokeAll(ForkJoinTask...):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::ex->last->for->i->for->i->if->rethrow
ForkJoinTask#invokeAll(Collection):::Forks all tasks in the specified collection, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::if->tasks->new->ForkJoinTask<?>Arr->toArray->invokeAll->return->ts->ex->last->ts->size->for->i->for->i->if->rethrow->return
ForkJoinTask#cancel(boolean):::Attempts to cancel execution of this task:::s->abnormalCompletion->return
ForkJoinTask#isDone()::: fork join task is done:::return
ForkJoinTask#isCancelled()::: fork join task is cancelled:::return
ForkJoinTask#isCompletedAbnormally():::Returns true if this task threw an exception or was cancelled.:::return
ForkJoinTask#isCompletedNormally():::Returns true if this task completed without throwing an exception and was not cancelled.:::return
ForkJoinTask#getException():::Returns the exception thrown by the base computation, or a CancellationException if cancelled, or null if none or if the method has not yet completed.:::s->return->new->CancellationException->getThrowableException
ForkJoinTask#completeExceptionally(Throwable):::Completes this task abnormally, and if not already aborted or cancelled, causes it to throw the given exception upon join and related operations:::new->RuntimeException->setExceptionalCompletion
ForkJoinTask#complete(V):::Completes this task, and if not already aborted or cancelled, returning the given value as the result of subsequent invocations of join and related operations:::try->setRawResult->catch->setExceptionalCompletion->return->finally->setDone
ForkJoinTask#quietlyComplete():::Completes this task normally without setting a value:::setDone
ForkJoinTask#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::s->Thread->currentThread->doJoin->externalInterruptibleAwaitDone->if->throw->getThrowableException->new->ExecutionException->else->if->throw->new->CancellationException->else->return->getRawResult
ForkJoinTask#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::s->nanos->unit->toNanos->if->Thread->interrupted->throw->new->InterruptedException->if->d->System->nanoTime->deadline->t->Thread->currentThread->if->wt->awaitJoin->else->if->externalHelpComplete->tryExternalUnpush->doExec->ns->ms->while->System->nanoTime->if->toMillis->STATUS->getAndBitwiseOr->synchronized->if->wait->else->notifyAll->if->throw->new->TimeoutException->else->if->throw->getThrowableException->new->ExecutionException->else->if->throw->new->CancellationException->else->return->getRawResult
ForkJoinTask#quietlyJoin():::Joins this task, without returning its result or throwing its exception:::doJoin
ForkJoinTask#quietlyInvoke():::Commences performing this task and awaits its completion if necessary, without returning its result or throwing its exception.:::doInvoke
ForkJoinTask#helpQuiesce():::Possibly executes tasks until the pool hosting the current task ForkJoinPool#isQuiescent is quiescent:::t->if->Thread->currentThread->wt->helpQuiescePool->else->ForkJoinPool->quiesceCommonPool
ForkJoinTask#reinitialize():::Resets the internal bookkeeping state of this task, allowing a subsequent fork:::if->clearExceptionalCompletion->else
ForkJoinTask#getPool():::Returns the pool hosting the current thread, or null if the current thread is executing outside of any ForkJoinPool:::t->Thread->currentThread->return
ForkJoinTask#inForkJoinPool():::Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.:::return->Thread->currentThread
ForkJoinTask#tryUnfork():::Tries to unschedule this task for execution:::t->return->Thread->currentThread->tryUnpush->tryExternalUnpush
ForkJoinTask#getQueuedTaskCount():::Returns an estimate of the number of tasks that have been forked by the current worker thread but not yet executed:::t->q->if->Thread->currentThread->else->ForkJoinPool->commonSubmitterQueue->return->q->queueSize
ForkJoinTask#getSurplusQueuedTaskCount():::Returns an estimate of how many more locally queued tasks are held by the current worker thread than there are other worker threads that might steal them, or zero if this thread is not operating in a ForkJoinPool:::return->ForkJoinPool->getSurplusQueuedTaskCount
ForkJoinTask#getRawResult():::Returns the result that would be returned by #join, even if this task completed abnormally, or null if this task is not known to have been completed:::
ForkJoinTask#setRawResult(V):::Forces the given value to be returned as a result:::
ForkJoinTask#exec():::Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally:::
ForkJoinTask#peekNextLocalTask():::Returns, but does not unschedule or execute, a task queued by the current thread but not yet executed, if one is immediately available:::t->q->if->Thread->currentThread->else->ForkJoinPool->commonSubmitterQueue->return->q->peek
ForkJoinTask#pollNextLocalTask():::Unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if the current thread is operating in a ForkJoinPool:::t->return->Thread->currentThread->nextLocalTask
ForkJoinTask#pollTask():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available:::t->wt->return->Thread->currentThread->nextTaskFor
ForkJoinTask#pollSubmission():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available:::t->return->Thread->currentThread->pollSubmission
ForkJoinTask#getForkJoinTaskTag():::Returns the tag for this task.:::return
ForkJoinTask#setForkJoinTaskTag(short):::Atomically sets the tag value for this task and returns the old value.:::for->s
ForkJoinTask#compareAndSetForkJoinTaskTag(short, short):::Atomically conditionally sets the tag value for this task:::for->s
ForkJoinTask.AdaptedRunnable#getRawResult()::: adapted runnable get raw result:::return
ForkJoinTask.AdaptedRunnable#setRawResult(T)::: adapted runnable set raw result:::
ForkJoinTask.AdaptedRunnable#exec()::: adapted runnable exec:::runnable->run->return
ForkJoinTask.AdaptedRunnable#run()::: adapted runnable run:::invoke
ForkJoinTask.AdaptedRunnable#toString()::: adapted runnable to string:::return->super->toString
ForkJoinTask.AdaptedRunnableAction#getRawResult()::: adapted runnable action get raw result:::return
ForkJoinTask.AdaptedRunnableAction#setRawResult(Void)::: adapted runnable action set raw result:::
ForkJoinTask.AdaptedRunnableAction#exec()::: adapted runnable action exec:::runnable->run->return
ForkJoinTask.AdaptedRunnableAction#run()::: adapted runnable action run:::invoke
ForkJoinTask.AdaptedRunnableAction#toString()::: adapted runnable action to string:::return->super->toString
ForkJoinTask.RunnableExecuteAction#getRawResult()::: runnable execute action get raw result:::return
ForkJoinTask.RunnableExecuteAction#setRawResult(Void)::: runnable execute action set raw result:::
ForkJoinTask.RunnableExecuteAction#exec()::: runnable execute action exec:::runnable->run->return
ForkJoinTask.RunnableExecuteAction#internalPropagateException(Throwable)::: runnable execute action internal propagate exception:::rethrow
ForkJoinTask.AdaptedCallable#getRawResult()::: adapted callable get raw result:::return
ForkJoinTask.AdaptedCallable#setRawResult(T)::: adapted callable set raw result:::
ForkJoinTask.AdaptedCallable#exec()::: adapted callable exec:::try->callable->call->return->catch->throw->throw->new->RuntimeException->finally
ForkJoinTask.AdaptedCallable#run()::: adapted callable run:::invoke
ForkJoinTask.AdaptedCallable#toString()::: adapted callable to string:::return->super->toString
ForkJoinTask#adapt(Runnable):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns a null result upon #join.:::return->new->AdaptedRunnableAction
ForkJoinTask#adapt(Runnable, T):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns the given result upon #join.:::return->new->AdaptedRunnable<T>
ForkJoinTask#adapt(Callable):::Returns a new ForkJoinTask that performs the call method of the given Callable as its action, and returns its result upon #join, translating any checked exceptions encountered into RuntimeException.:::return->new->AdaptedCallable<T>
ForkJoinTask#writeObject(java.io.ObjectOutputStream):::Saves this task to a stream (that is, serializes it).:::s->defaultWriteObject->s->getException->writeObject
ForkJoinTask#readObject(java.io.ObjectInputStream):::Reconstitutes this task from a stream (that is, deserializes it).:::s->defaultReadObject->ex->s->readObject->if->setExceptionalCompletion
ForkJoinWorkerThread#getPool():::Returns the pool hosting this thread.:::return
ForkJoinWorkerThread#getPoolIndex():::Returns the unique index number of this thread in its pool:::return->workQueue->getPoolIndex
ForkJoinWorkerThread#onStart():::Initializes internal state after construction but before processing any tasks:::
ForkJoinWorkerThread#onTermination(Throwable):::Performs cleanup associated with termination of this worker thread:::
ForkJoinWorkerThread#run():::This method is required to be public, but should never be called explicitly:::if->exception->try->onStart->pool->runWorker->catch->finally->try->onTermination->catch->if->finally->pool->deregisterWorker
ForkJoinWorkerThread#afterTopLevelExec():::Non-public hook method for InnocuousForkJoinWorkerThread.:::
ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#afterTopLevelExec()::: innocuous fork join worker thread after top level exec:::ThreadLocalRandom->eraseThreadLocals
ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setUncaughtExceptionHandler(UncaughtExceptionHandler)::: innocuous fork join worker thread set uncaught exception handler:::
ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setContextClassLoader(ClassLoader)::: innocuous fork join worker thread set context class loader:::throw->new->SecurityException
Future#cancel(boolean):::Attempts to cancel execution of this task:::
Future#isCancelled():::Returns true if this task was cancelled before it completed normally.:::
Future#isDone():::Returns true if this task completed:::
Future#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::
Future#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::
FutureTask#report(int):::Returns result or throws exception for completed task.:::x->if->return->if->throw->new->CancellationException->throw->new->ExecutionException
FutureTask#isCancelled()::: future task is cancelled:::return
FutureTask#isDone()::: future task is done:::return
FutureTask#cancel(boolean)::: future task cancel:::if->STATE->compareAndSet->return->try->if->try->t->if->t->interrupt->catch->finally->STATE->setRelease->catch->finally->finishCompletion->return
FutureTask#get()::: future task get:::s->if->awaitDone->return->report
FutureTask#get(long, TimeUnit)::: future task get:::if->throw->new->NullPointerException->s->if->unit->toNanos->awaitDone->throw->new->TimeoutException->return->report
FutureTask#done():::Protected method invoked when this task transitions to state isDone (whether normally or via cancellation):::
FutureTask#set(V):::Sets the result of this future to the given value unless this future has already been set or has been cancelled:::if->STATE->compareAndSet->STATE->setRelease->finishCompletion
FutureTask#setException(Throwable):::Causes this future to report an ExecutionException with the given throwable as its cause, unless this future has already been set or has been cancelled:::if->STATE->compareAndSet->STATE->setRelease->finishCompletion
FutureTask#run()::: future task run:::if->RUNNER->Thread->currentThread->compareAndSet->return->try->c->if->result->ran->try->c->call->catch->setException->finally->if->set->catch->finally->s->if->handlePossibleCancellationInterrupt
FutureTask#runAndReset():::Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled:::if->RUNNER->Thread->currentThread->compareAndSet->return->ran->s->try->c->if->try->c->call->catch->setException->finally->catch->finally->if->handlePossibleCancellationInterrupt->return
FutureTask#handlePossibleCancellationInterrupt(int):::Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset.:::if->while->Thread->yield
FutureTask#finishCompletion():::Removes and signals all waiting threads, invokes done(), and nulls out callable.:::for->q->done
FutureTask#awaitDone(boolean, long):::Awaits completion or aborts on interrupt or timeout.:::startTime->q->queued->for
FutureTask#removeWaiter(WaitNode):::Tries to unlink a timed-out or interrupted wait node to avoid accumulating garbage:::if->for
FutureTask#toString():::Returns a string representation of this FutureTask.:::status->switch->break->break->break->callable->return->super->toString
Helpers#collectionToString(Collection):::An implementation of Collection.toString() suitable for classes with locks:::a->c->toArray->size->if->return->charLength->for->i->return->toString
Helpers#toString(Object[], int, int):::Like Arrays.toString(), but caller guarantees that size > 0, each element with index 0 <= i < size is a non-null String, and charLength is the sum of the lengths of the input Strings.:::chars->new->charArr->j->for->i->return->new->String
Helpers#mapEntryToString(Object, Object):::Optimized form of: key + "=" + val:::k->v->klen->vlen->chars->objectToString->length->objectToString->length->new->charArr->k->getChars->v->getChars->return->new->String
Helpers#objectToString(Object)::: helpers object to string:::s->return->x->toString
LinkedBlockingDeque#linkFirst(Node):::Links node as first element, or returns false if full.:::if->return->f->if->else->notEmpty->signal->return
LinkedBlockingDeque#linkLast(Node):::Links node as last element, or returns false if full.:::if->return->l->if->else->notEmpty->signal->return
LinkedBlockingDeque#unlinkFirst():::Removes and returns first element, or null if empty.:::f->if->return->n->item->if->else->notFull->signal->return
LinkedBlockingDeque#unlinkLast():::Removes and returns last element, or null if empty.:::l->if->return->p->item->if->else->notFull->signal->return
LinkedBlockingDeque#unlink(Node):::Unlinks x.:::p->n->if->unlinkFirst->else->if->unlinkLast->else->notFull->signal
LinkedBlockingDeque#addFirst(E)::: linked blocking deque add first:::if->offerFirst->throw->new->IllegalStateException
LinkedBlockingDeque#addLast(E)::: linked blocking deque add last:::if->offerLast->throw->new->IllegalStateException
LinkedBlockingDeque#offerFirst(E)::: linked blocking deque offer first:::if->throw->new->NullPointerException->node->new->Node<E>->lock->lock->lock->try->return->linkFirst->catch->finally->lock->unlock
LinkedBlockingDeque#offerLast(E)::: linked blocking deque offer last:::if->throw->new->NullPointerException->node->new->Node<E>->lock->lock->lock->try->return->linkLast->catch->finally->lock->unlock
LinkedBlockingDeque#putFirst(E)::: linked blocking deque put first:::if->throw->new->NullPointerException->node->new->Node<E>->lock->lock->lock->try->while->linkFirst->notFull->await->catch->finally->lock->unlock
LinkedBlockingDeque#putLast(E)::: linked blocking deque put last:::if->throw->new->NullPointerException->node->new->Node<E>->lock->lock->lock->try->while->linkLast->notFull->await->catch->finally->lock->unlock
LinkedBlockingDeque#offerFirst(E, long, TimeUnit)::: linked blocking deque offer first:::if->throw->new->NullPointerException->node->new->Node<E>->nanos->unit->toNanos->lock->lock->lockInterruptibly->try->while->linkFirst->if->return->notFull->awaitNanos->return->catch->finally->lock->unlock
LinkedBlockingDeque#offerLast(E, long, TimeUnit)::: linked blocking deque offer last:::if->throw->new->NullPointerException->node->new->Node<E>->nanos->unit->toNanos->lock->lock->lockInterruptibly->try->while->linkLast->if->return->notFull->awaitNanos->return->catch->finally->lock->unlock
LinkedBlockingDeque#removeFirst()::: linked blocking deque remove first:::x->pollFirst->if->throw->new->NoSuchElementException->return
LinkedBlockingDeque#removeLast()::: linked blocking deque remove last:::x->pollLast->if->throw->new->NoSuchElementException->return
LinkedBlockingDeque#pollFirst()::: linked blocking deque poll first:::lock->lock->lock->try->return->unlinkFirst->catch->finally->lock->unlock
LinkedBlockingDeque#pollLast()::: linked blocking deque poll last:::lock->lock->lock->try->return->unlinkLast->catch->finally->lock->unlock
LinkedBlockingDeque#takeFirst()::: linked blocking deque take first:::lock->lock->lock->try->x->while->unlinkFirst->notEmpty->await->return->catch->finally->lock->unlock
LinkedBlockingDeque#takeLast()::: linked blocking deque take last:::lock->lock->lock->try->x->while->unlinkLast->notEmpty->await->return->catch->finally->lock->unlock
LinkedBlockingDeque#pollFirst(long, TimeUnit)::: linked blocking deque poll first:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->x->while->unlinkFirst->if->return->notEmpty->awaitNanos->return->catch->finally->lock->unlock
LinkedBlockingDeque#pollLast(long, TimeUnit)::: linked blocking deque poll last:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->x->while->unlinkLast->if->return->notEmpty->awaitNanos->return->catch->finally->lock->unlock
LinkedBlockingDeque#getFirst()::: linked blocking deque get first:::x->peekFirst->if->throw->new->NoSuchElementException->return
LinkedBlockingDeque#getLast()::: linked blocking deque get last:::x->peekLast->if->throw->new->NoSuchElementException->return
LinkedBlockingDeque#peekFirst()::: linked blocking deque peek first:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#peekLast()::: linked blocking deque peek last:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#removeFirstOccurrence(Object)::: linked blocking deque remove first occurrence:::if->return->lock->lock->lock->try->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#removeLastOccurrence(Object)::: linked blocking deque remove last occurrence:::if->return->lock->lock->lock->try->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#add(E):::Inserts the specified element at the end of this deque unless it would violate capacity restrictions:::addLast->return
LinkedBlockingDeque#offer(E)::: linked blocking deque offer:::return->offerLast
LinkedBlockingDeque#put(E)::: linked blocking deque put:::putLast
LinkedBlockingDeque#offer(E, long, TimeUnit)::: linked blocking deque offer:::return->offerLast
LinkedBlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque:::return->removeFirst
LinkedBlockingDeque#poll()::: linked blocking deque poll:::return->pollFirst
LinkedBlockingDeque#take()::: linked blocking deque take:::return->takeFirst
LinkedBlockingDeque#poll(long, TimeUnit)::: linked blocking deque poll:::return->pollFirst
LinkedBlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque:::return->getFirst
LinkedBlockingDeque#peek()::: linked blocking deque peek:::return->peekFirst
LinkedBlockingDeque#remainingCapacity():::Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#drainTo(Collection)::: linked blocking deque drain to:::return->drainTo
LinkedBlockingDeque#drainTo(Collection, int)::: linked blocking deque drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->lock->lock->lock->try->n->Math->min->for->i->return->catch->finally->lock->unlock
LinkedBlockingDeque#push(E)::: linked blocking deque push:::addFirst
LinkedBlockingDeque#pop()::: linked blocking deque pop:::return->removeFirst
LinkedBlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::return->removeFirstOccurrence
LinkedBlockingDeque#size():::Returns the number of elements in this deque.:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::if->return->lock->lock->lock->try->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beg->end->n->foreach->Objects->requireNonNull->newNode->new->Node<E>->if->else->if->return->lock->lock->lock->try->if->if->else->notEmpty->signalAll->return->catch->finally->lock->unlock->return->super->addAll
LinkedBlockingDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::lock->lock->lock->try->a->new->ObjectArr->k->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->if->a->getClass->getComponentType->newInstance->k->for->p->if->return->catch->finally->lock->unlock
LinkedBlockingDeque#toString()::: linked blocking deque to string:::return->Helpers->collectionToString
LinkedBlockingDeque#clear():::Atomically removes all of the elements from this deque:::lock->lock->lock->try->for->f->notFull->signalAll->catch->finally->lock->unlock
LinkedBlockingDeque#succ(Node):::Used for any element traversal that is not entirely under lock:::if->return
LinkedBlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::return->new->Itr
LinkedBlockingDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::return->new->DescendingItr
LinkedBlockingDeque.AbstractItr#firstNode()::: abstract itr first node:::
LinkedBlockingDeque.AbstractItr#nextNode(Node)::: abstract itr next node:::
LinkedBlockingDeque.AbstractItr#succ(Node)::: abstract itr succ:::if->nextNode->firstNode->return
LinkedBlockingDeque.AbstractItr#hasNext()::: abstract itr has next:::return
LinkedBlockingDeque.AbstractItr#next()::: abstract itr next:::p->if->throw->new->NoSuchElementException->x->lock->lock->lock->try->e->for->nextNode->catch->finally->lock->unlock->return
LinkedBlockingDeque.AbstractItr#forEachRemaining(Consumer)::: abstract itr for each remaining:::Objects->requireNonNull->p->if->return->lock->batchSize->es->n->len->do->lock->lock->try->if->nextNode->for->q->succ->new->ObjectArr->else->for->succ->catch->finally->lock->unlock->for->i->while
LinkedBlockingDeque.AbstractItr#remove()::: abstract itr remove:::n->if->throw->new->IllegalStateException->lock->lock->lock->try->if->unlink->catch->finally->lock->unlock
LinkedBlockingDeque.Itr#firstNode()::: itr first node:::return
LinkedBlockingDeque.Itr#nextNode(Node)::: itr next node:::return
LinkedBlockingDeque.DescendingItr#firstNode()::: descending itr first node:::return
LinkedBlockingDeque.DescendingItr#nextNode(Node)::: descending itr next node:::return
LinkedBlockingDeque.LBDSpliterator#estimateSize()::: spliterator estimate size:::return
LinkedBlockingDeque.LBDSpliterator#trySplit()::: spliterator try split:::h->if->n->Math->min->a->new->ObjectArr->lock->i->p->lock->lock->try->if->for->succ->catch->finally->lock->unlock->if->else->if->if->return->Spliterators->spliterator->return
LinkedBlockingDeque.LBDSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->if->e->lock->lock->lock->try->p->if->do->succ->while->if->catch->finally->lock->unlock->if->action->accept->return->return
LinkedBlockingDeque.LBDSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->if->p->forEachFrom
LinkedBlockingDeque.LBDSpliterator#characteristics()::: spliterator characteristics:::return
LinkedBlockingDeque#spliterator():::Returns a Spliterator over the elements in this deque:::return->new->LBDSpliterator
LinkedBlockingDeque#forEach(Consumer)::: linked blocking deque for each:::Objects->requireNonNull->forEachFrom
LinkedBlockingDeque#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::lock->batchSize->es->n->len->do->lock->lock->try->if->if->for->q->succ->new->ObjectArr->for->succ->catch->finally->lock->unlock->for->i->while
LinkedBlockingDeque#removeIf(Predicate)::: linked blocking deque remove if:::Objects->requireNonNull->return->bulkRemove
LinkedBlockingDeque#removeAll(Collection)::: linked blocking deque remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedBlockingDeque#retainAll(Collection)::: linked blocking deque retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedBlockingDeque#bulkRemove(Predicate):::Implementation of bulk remove methods.:::removed->lock->p->nodes->n->len->do->lock->lock->try->if->for->q->succ->new->Node<?>Arr->for->succ->catch->finally->lock->unlock->deathRow->for->i->if->lock->lock->try->for->i->catch->finally->lock->unlock->while->return
LinkedBlockingDeque#writeObject(java.io.ObjectOutputStream):::Saves this deque to a stream (that is, serializes it).:::lock->lock->lock->try->s->defaultWriteObject->for->p->s->writeObject->catch->finally->lock->unlock
LinkedBlockingDeque#readObject(java.io.ObjectInputStream):::Reconstitutes this deque from a stream (that is, deserializes it).:::s->defaultReadObject->for
LinkedBlockingDeque#checkInvariants()::: linked blocking deque check invariants:::for->p
LinkedBlockingQueue#signalNotEmpty():::Signals a waiting take:::takeLock->takeLock->lock->try->notEmpty->signal->catch->finally->takeLock->unlock
LinkedBlockingQueue#signalNotFull():::Signals a waiting put:::putLock->putLock->lock->try->notFull->signal->catch->finally->putLock->unlock
LinkedBlockingQueue#enqueue(Node):::Links node at end of queue.:::
LinkedBlockingQueue#dequeue():::Removes a node from head of queue.:::h->first->x->return
LinkedBlockingQueue#fullyLock():::Locks to prevent both puts and takes.:::putLock->lock->takeLock->lock
LinkedBlockingQueue#fullyUnlock():::Unlocks to allow both puts and takes.:::takeLock->unlock->putLock->unlock
LinkedBlockingQueue#size():::Returns the number of elements in this queue.:::return->count->get
LinkedBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::return->count->get
LinkedBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.:::if->throw->new->NullPointerException->c->node->new->Node<E>->putLock->count->putLock->lockInterruptibly->try->while->count->get->notFull->await->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty
LinkedBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.:::if->throw->new->NullPointerException->nanos->unit->toNanos->c->putLock->count->putLock->lockInterruptibly->try->while->count->get->if->return->notFull->awaitNanos->new->Node<E>->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty->return
LinkedBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::if->throw->new->NullPointerException->count->if->count->get->return->c->node->new->Node<E>->putLock->putLock->lock->try->if->count->get->return->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty->return
LinkedBlockingQueue#take()::: linked blocking queue take:::x->c->count->takeLock->takeLock->lockInterruptibly->try->while->count->get->notEmpty->await->dequeue->count->getAndDecrement->if->notEmpty->signal->catch->finally->takeLock->unlock->if->signalNotFull->return
LinkedBlockingQueue#poll(long, TimeUnit)::: linked blocking queue poll:::x->c->nanos->unit->toNanos->count->takeLock->takeLock->lockInterruptibly->try->while->count->get->if->return->notEmpty->awaitNanos->dequeue->count->getAndDecrement->if->notEmpty->signal->catch->finally->takeLock->unlock->if->signalNotFull->return
LinkedBlockingQueue#poll()::: linked blocking queue poll:::count->if->count->get->return->x->c->takeLock->takeLock->lock->try->if->count->get->return->dequeue->count->getAndDecrement->if->notEmpty->signal->catch->finally->takeLock->unlock->if->signalNotFull->return
LinkedBlockingQueue#peek()::: linked blocking queue peek:::count->if->count->get->return->takeLock->takeLock->lock->try->return->count->get->catch->finally->takeLock->unlock
LinkedBlockingQueue#unlink(Node, Node):::Unlinks interior Node p with predecessor pred.:::if->if->count->getAndDecrement->notFull->signal
LinkedBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->fullyLock->try->for->pred->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->fullyLock->try->for->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::fullyLock->try->size->count->get->a->new->ObjectArr->k->for->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::fullyLock->try->size->count->get->if->a->getClass->getComponentType->newInstance->k->for->p->if->return->catch->finally->fullyUnlock
LinkedBlockingQueue#toString()::: linked blocking queue to string:::return->Helpers->collectionToString
LinkedBlockingQueue#clear():::Atomically removes all of the elements from this queue:::fullyLock->try->for->p->h->if->count->getAndSet->notFull->signal->catch->finally->fullyUnlock
LinkedBlockingQueue#drainTo(Collection)::: linked blocking queue drain to:::return->drainTo
LinkedBlockingQueue#drainTo(Collection, int)::: linked blocking queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->signalNotFull->takeLock->takeLock->lock->try->n->Math->count->get->min->h->i->try->while->p->c->add->return->catch->finally->if->count->getAndAdd->catch->finally->takeLock->unlock->if->signalNotFull
LinkedBlockingQueue#succ(Node):::Used for any element traversal that is not entirely under lock:::if->return
LinkedBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
LinkedBlockingQueue.Itr#hasNext()::: itr has next:::return
LinkedBlockingQueue.Itr#next()::: itr next:::p->if->throw->new->NoSuchElementException->x->fullyLock->try->e->for->catch->finally->fullyUnlock->return
LinkedBlockingQueue.Itr#forEachRemaining(Consumer)::: itr for each remaining:::Objects->requireNonNull->p->if->return->batchSize->es->n->len->do->fullyLock->try->if->for->q->succ->new->ObjectArr->else->for->succ->catch->finally->fullyUnlock->for->i->while
LinkedBlockingQueue.Itr#remove()::: itr remove:::p->if->throw->new->IllegalStateException->fullyLock->try->if->if->findPred->unlink->catch->finally->fullyUnlock
LinkedBlockingQueue.LBQSpliterator#estimateSize()::: spliterator estimate size:::return
LinkedBlockingQueue.LBQSpliterator#trySplit()::: spliterator try split:::h->if->n->Math->min->a->new->ObjectArr->i->p->fullyLock->try->if->for->succ->catch->finally->fullyUnlock->if->else->if->if->return->Spliterators->spliterator->return
LinkedBlockingQueue.LBQSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->if->e->fullyLock->try->p->if->do->succ->while->if->catch->finally->fullyUnlock->if->action->accept->return->return
LinkedBlockingQueue.LBQSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->if->p->forEachFrom
LinkedBlockingQueue.LBQSpliterator#characteristics()::: spliterator characteristics:::return
LinkedBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->LBQSpliterator
LinkedBlockingQueue#forEach(Consumer)::: linked blocking queue for each:::Objects->requireNonNull->forEachFrom
LinkedBlockingQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::batchSize->es->n->len->do->fullyLock->try->if->if->for->q->succ->new->ObjectArr->for->succ->catch->finally->fullyUnlock->for->i->while
LinkedBlockingQueue#removeIf(Predicate)::: linked blocking queue remove if:::Objects->requireNonNull->return->bulkRemove
LinkedBlockingQueue#removeAll(Collection)::: linked blocking queue remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedBlockingQueue#retainAll(Collection)::: linked blocking queue retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedBlockingQueue#findPred(Node, Node):::Returns the predecessor of live node p, given a node that was once a live ancestor of p (or head); allows unlinking of p.:::if->for->q->return
LinkedBlockingQueue#bulkRemove(Predicate):::Implementation of bulk remove methods.:::removed->p->ancestor->nodes->n->len->do->fullyLock->try->if->for->q->succ->new->Node<?>Arr->for->succ->catch->finally->fullyUnlock->deathRow->for->i->if->fullyLock->try->for->i->catch->finally->fullyUnlock->while->return
LinkedBlockingQueue#writeObject(java.io.ObjectOutputStream):::Saves this queue to a stream (that is, serializes it).:::fullyLock->try->s->defaultWriteObject->for->p->s->writeObject->catch->finally->fullyUnlock
LinkedBlockingQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::s->defaultReadObject->count->set->new->Node<E>->for
LinkedTransferQueue.Node#casNext(Node, Node)::: node cas next:::return->NEXT->compareAndSet
LinkedTransferQueue.Node#casItem(Object, Object)::: node cas item:::return->ITEM->compareAndSet
LinkedTransferQueue.Node#selfLink():::Links node to itself to avoid garbage retention:::NEXT->setRelease
LinkedTransferQueue.Node#appendRelaxed(Node)::: node append relaxed:::NEXT->set
LinkedTransferQueue.Node#forgetContents():::Sets item (of a request node) to self and waiter to null, to avoid garbage retention after matching or cancelling:::if->ITEM->set->WAITER->set
LinkedTransferQueue.Node#isMatched():::Returns true if this node has been matched, including the case of artificial matches due to cancellation.:::return
LinkedTransferQueue.Node#tryMatch(Object, Object):::Tries to CAS-match this node; if successful, wakes waiter.:::if->casItem->LockSupport->unpark->return->return
LinkedTransferQueue.Node#cannotPrecede(boolean):::Returns true if a node with the given mode cannot be appended to this node because this node is unmatched and has opposite data mode.:::d->return
LinkedTransferQueue#casTail(Node, Node)::: linked transfer queue cas tail:::return->TAIL->compareAndSet
LinkedTransferQueue#casHead(Node, Node)::: linked transfer queue cas head:::return->HEAD->compareAndSet
LinkedTransferQueue#incSweepVotes():::Atomic version of ++sweepVotes.:::return->SWEEPVOTES->getAndAdd
LinkedTransferQueue#tryCasSuccessor(Node, Node, Node):::Tries to CAS pred.next (or head, if pred is null) from c to p:::if->return->pred->casNext->if->casHead->c->selfLink->return->return
LinkedTransferQueue#skipDeadNodes(Node, Node, Node, Node):::Collapses dead (matched) nodes between pred and q.:::if->if->return->return->tryCasSuccessor->pred->isMatched
LinkedTransferQueue#skipDeadNodesNearHead(Node, Node):::Collapses dead (matched) nodes from h (which was once head) to p:::for->if->casHead->h->selfLink
LinkedTransferQueue#xfer(E, boolean, int, long):::Implements all queuing methods:::if->throw->new->NullPointerException->for->s->t->h
LinkedTransferQueue#awaitMatch(Node, Node, E, boolean, long):::Spins/yields/blocks until node s is matched or caller gives up.:::deadline->System->nanoTime->w->Thread->currentThread->spins->randomYields->for
LinkedTransferQueue#spinsFor(Node, boolean):::Returns spin/yield value for a node with given predecessor and data mode:::if->if->return->if->pred->isMatched->return->if->return->return
LinkedTransferQueue#firstDataNode():::Returns the first unmatched data node, or null if none:::first->for
LinkedTransferQueue#countOfMode(boolean):::Traverses and counts unmatched nodes of the given mode:::for
LinkedTransferQueue#toString()::: linked transfer queue to string:::a->for
LinkedTransferQueue#toArrayInternal(Object[])::: linked transfer queue to array internal:::x->for
LinkedTransferQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::return->toArrayInternal
LinkedTransferQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects->requireNonNull->return->toArrayInternal
LinkedTransferQueue.Itr#advance(Node):::Moves to next node after pred, or first node if pred null.:::for->p->c
LinkedTransferQueue.Itr#hasNext()::: itr has next:::return
LinkedTransferQueue.Itr#next()::: itr next:::p->if->throw->new->NoSuchElementException->e->advance->return
LinkedTransferQueue.Itr#forEachRemaining(Consumer)::: itr for each remaining:::Objects->requireNonNull->q->for->p->advance->if
LinkedTransferQueue.Itr#remove()::: itr remove:::lastRet->if->throw->new->IllegalStateException->if->return->pred->for->p->c->q
LinkedTransferQueue.LTQSpliterator#trySplit()::: spliterator try split:::p->q->if->current->return->i->n->Math->min->a->do->item->if->if->if->new->ObjectArr->else->if->break->if->firstDataNode->while->setCurrent->return->Spliterators->spliterator
LinkedTransferQueue.LTQSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->p->if->current->forEachFrom
LinkedTransferQueue.LTQSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->p->if->current->e->do->item->isData->if->if->if->break->else->if->while->setCurrent->if->action->accept->return->return
LinkedTransferQueue.LTQSpliterator#setCurrent(Node)::: spliterator set current:::if
LinkedTransferQueue.LTQSpliterator#current()::: spliterator current:::p->if->firstDataNode->setCurrent->return
LinkedTransferQueue.LTQSpliterator#estimateSize()::: spliterator estimate size:::return
LinkedTransferQueue.LTQSpliterator#characteristics()::: spliterator characteristics:::return
LinkedTransferQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->LTQSpliterator
LinkedTransferQueue#unsplice(Node, Node):::Unsplices (now or later) the given deleted/cancelled node with the given predecessor.:::if->n->if->pred->casNext->pred->isMatched->for->if->incSweepVotes->sweep
LinkedTransferQueue#sweep():::Unlinks matched (typically cancelled) nodes encountered in a traversal from head.:::for->p->s->n
LinkedTransferQueue#put(E):::Inserts the specified element at the tail of this queue:::xfer
LinkedTransferQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#offer(E):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#add(E):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::return->xfer
LinkedTransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::if->xfer->Thread->interrupted->throw->new->InterruptedException
LinkedTransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::if->unit->toNanos->xfer->return->if->Thread->interrupted->return->throw->new->InterruptedException
LinkedTransferQueue#take()::: linked transfer queue take:::e->xfer->if->return->Thread->interrupted->throw->new->InterruptedException
LinkedTransferQueue#poll(long, TimeUnit)::: linked transfer queue poll:::e->unit->toNanos->xfer->if->Thread->interrupted->return->throw->new->InterruptedException
LinkedTransferQueue#poll()::: linked transfer queue poll:::return->xfer
LinkedTransferQueue#drainTo(Collection)::: linked transfer queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->n->for->e->poll->return
LinkedTransferQueue#drainTo(Collection, int)::: linked transfer queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->n->for->e->poll->return
LinkedTransferQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
LinkedTransferQueue#peek()::: linked transfer queue peek:::for
LinkedTransferQueue#isEmpty():::Returns true if this queue contains no elements.:::return->firstDataNode
LinkedTransferQueue#hasWaitingConsumer()::: linked transfer queue has waiting consumer:::for
LinkedTransferQueue#size():::Returns the number of elements in this queue:::return->countOfMode
LinkedTransferQueue#getWaitingConsumerCount()::: linked transfer queue get waiting consumer count:::return->countOfMode
LinkedTransferQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->for
LinkedTransferQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->for
LinkedTransferQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a LinkedTransferQueue is not capacity constrained.:::return
LinkedTransferQueue#writeObject(java.io.ObjectOutputStream):::Saves this queue to a stream (that is, serializes it).:::s->defaultWriteObject->foreach->s->writeObject->s->writeObject
LinkedTransferQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::h->t->for->item->s->readObject->if->new->Node
LinkedTransferQueue#removeIf(Predicate)::: linked transfer queue remove if:::Objects->requireNonNull->return->bulkRemove
LinkedTransferQueue#removeAll(Collection)::: linked transfer queue remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedTransferQueue#retainAll(Collection)::: linked transfer queue retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
LinkedTransferQueue#clear()::: linked transfer queue clear:::bulkRemove
LinkedTransferQueue#bulkRemove(Predicate):::Implementation of bulk remove methods.:::removed->for
LinkedTransferQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::for->pred
LinkedTransferQueue#forEach(Consumer)::: linked transfer queue for each:::Objects->requireNonNull->forEachFrom
Phaser#unarrivedOf(long)::: phaser unarrived of:::counts->return
Phaser#partiesOf(long)::: phaser parties of:::return
Phaser#phaseOf(long)::: phaser phase of:::return
Phaser#arrivedOf(long)::: phaser arrived of:::counts->return
Phaser#badArrive(long):::Returns message string for bounds exceptions on arrival.:::return->stateToString
Phaser#badRegister(long):::Returns message string for bounds exceptions on registration.:::return->stateToString
Phaser#doArrive(int):::Main implementation for methods arrive and arriveAndDeregister:::root->for
Phaser#doRegister(int):::Implementation of register, bulkRegister.:::adjust->parent->phase->for->return
Phaser#reconcileState():::Resolves lagged phase propagation from root if necessary:::root->s->if->phase->p->while->STATE->weakCompareAndSet->return
Phaser#register():::Adds a new unarrived party to this phaser:::return->doRegister
Phaser#bulkRegister(int):::Adds the given number of new unarrived parties to this phaser:::if->throw->new->IllegalArgumentException->if->return->getPhase->return->doRegister
Phaser#arrive():::Arrives at this phaser, without waiting for others to arrive:::return->doArrive
Phaser#arriveAndDeregister():::Arrives at this phaser and deregisters from it without waiting for others to arrive:::return->doArrive
Phaser#arriveAndAwaitAdvance():::Arrives at this phaser and awaits others:::root->for
Phaser#awaitAdvance(int):::Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::root->s->reconcileState->p->if->return->if->return->root->internalAwaitAdvance->return
Phaser#awaitAdvanceInterruptibly(int):::Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::root->s->reconcileState->p->if->return->if->node->new->QNode->root->internalAwaitAdvance->if->throw->new->InterruptedException->return
Phaser#awaitAdvanceInterruptibly(int, long, TimeUnit):::Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::nanos->unit->toNanos->root->s->reconcileState->p->if->return->if->node->new->QNode->root->internalAwaitAdvance->if->throw->new->InterruptedException->else->if->throw->new->TimeoutException->return
Phaser#forceTermination():::Forces this phaser to enter termination state:::root->s->while->if->STATE->compareAndSet->releaseWaiters->releaseWaiters->return
Phaser#getPhase():::Returns the current phase number:::return
Phaser#getRegisteredParties():::Returns the number of parties registered at this phaser.:::return->partiesOf
Phaser#getArrivedParties():::Returns the number of registered parties that have arrived at the current phase of this phaser:::return->reconcileState->arrivedOf
Phaser#getUnarrivedParties():::Returns the number of registered parties that have not yet arrived at the current phase of this phaser:::return->reconcileState->unarrivedOf
Phaser#getParent():::Returns the parent of this phaser, or null if none.:::return
Phaser#getRoot():::Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.:::return
Phaser#isTerminated():::Returns true if this phaser has been terminated.:::return
Phaser#onAdvance(int, int):::Overridable method to perform an action upon impending phase advance, and to control termination:::return
Phaser#toString():::Returns a string identifying this phaser, as well as its state:::return->reconcileState->stateToString
Phaser#stateToString(long):::Implementation of toString and string-based error messages.:::return->super->toString->phaseOf->partiesOf->arrivedOf
Phaser#releaseWaiters(int):::Removes and signals threads from queue for phase.:::q->t->head->while->head->get->if->head->compareAndSet->LockSupport->unpark
Phaser#abortWait(int):::Variant of releaseWaiters that additionally tries to remove any nodes no longer waiting for advance due to timeout or interrupt:::head->for
Phaser#internalAwaitAdvance(int, QNode):::Possibly blocks and waits for phase to advance unless aborted:::releaseWaiters->queued->lastUnarrived->spins->s->p->while->if->unarrived->if->interrupted->Thread->interrupted->if->new->QNode->else->Thread->onSpinWait->else->if->node->isReleasable->break->else->if->head->q->head->get->if->head->compareAndSet->else->try->ForkJoinPool->managedBlock->catch->finally->if->if->if->Thread->currentThread->interrupt->if->return->abortWait->releaseWaiters->return
Phaser.QNode#isReleasable()::: node is releasable:::if->return->if->phaser->getPhase->return->if->Thread->interrupted->if->return->if->System->nanoTime->return->return
Phaser.QNode#block()::: node block:::while->isReleasable->if->LockSupport->parkNanos->else->LockSupport->park->return
PriorityBlockingQueue#ensureNonEmpty(Object[]):::Ensures that queue[0] exists, helping peek() and poll().:::return->new->ObjectArr
PriorityBlockingQueue#tryGrow(Object[], int):::Tries to grow array to accommodate at least one more element (but normally expand by about 50%), giving up (allowing retry) on contention (which we expect to be rare):::lock->unlock->newArray->if->ALLOCATIONSPINLOCK->compareAndSet->try->newCap->if->minCap->if->throw->new->OutOfMemoryError->if->new->ObjectArr->catch->finally->if->Thread->yield->lock->lock->if->System->arraycopy
PriorityBlockingQueue#dequeue():::Mechanics for poll():::es->result->if->n->x->if->cmp->if->siftDownComparable->else->siftDownUsingComparator->return
PriorityBlockingQueue#siftUpComparable(int, T, Object[]):::Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root:::key->while->parent->e->if->key->compareTo->break
PriorityBlockingQueue#siftUpUsingComparator(int, T, Object[], Comparator)::: priority blocking queue sift up using comparator:::while->parent->e->if->cmp->compare->break
PriorityBlockingQueue#siftDownComparable(int, T, Object[], int):::Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.:::key->half->while->child->c->right->if->compareTo->if->key->compareTo->break
PriorityBlockingQueue#siftDownUsingComparator(int, T, Object[], int, Comparator)::: priority blocking queue sift down using comparator:::half->while->child->c->right->if->cmp->compare->if->cmp->compare->break
PriorityBlockingQueue#heapify():::Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call:::es->n->i->cmp->if->for->else->for
PriorityBlockingQueue#add(E):::Inserts the specified element into this priority queue.:::return->offer
PriorityBlockingQueue#offer(E):::Inserts the specified element into this priority queue:::if->throw->new->NullPointerException->lock->lock->lock->n->cap->es->while->tryGrow->try->cmp->if->siftUpComparable->else->siftUpUsingComparator->notEmpty->signal->catch->finally->lock->unlock->return
PriorityBlockingQueue#put(E):::Inserts the specified element into this priority queue:::offer
PriorityBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this priority queue:::return->offer
PriorityBlockingQueue#poll()::: priority blocking queue poll:::lock->lock->lock->try->return->dequeue->catch->finally->lock->unlock
PriorityBlockingQueue#take()::: priority blocking queue take:::lock->lock->lockInterruptibly->result->try->while->dequeue->notEmpty->await->catch->finally->lock->unlock->return
PriorityBlockingQueue#poll(long, TimeUnit)::: priority blocking queue poll:::nanos->unit->toNanos->lock->lock->lockInterruptibly->result->try->while->dequeue->notEmpty->awaitNanos->catch->finally->lock->unlock->return
PriorityBlockingQueue#peek()::: priority blocking queue peek:::lock->lock->lock->try->return->catch->finally->lock->unlock
PriorityBlockingQueue#comparator():::Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.:::return
PriorityBlockingQueue#size()::: priority blocking queue size:::lock->lock->lock->try->return->catch->finally->lock->unlock
PriorityBlockingQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.:::return
PriorityBlockingQueue#indexOf(Object)::: priority blocking queue index of:::if->es->for->i->n->return
PriorityBlockingQueue#removeAt(int):::Removes the ith element from queue.:::es->n->if->else->moved->cmp->if->siftDownComparable->else->siftDownUsingComparator->if->if->siftUpComparable->else->siftUpUsingComparator
PriorityBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::lock->lock->lock->try->i->indexOf->if->return->removeAt->return->catch->finally->lock->unlock
PriorityBlockingQueue#removeEq(Object):::Identity-based version for use in Itr.remove.:::lock->lock->lock->try->es->for->i->n->catch->finally->lock->unlock
PriorityBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::lock->lock->lock->try->return->indexOf->catch->finally->lock->unlock
PriorityBlockingQueue#toString()::: priority blocking queue to string:::return->Helpers->collectionToString
PriorityBlockingQueue#drainTo(Collection)::: priority blocking queue drain to:::return->drainTo
PriorityBlockingQueue#drainTo(Collection, int)::: priority blocking queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->lock->lock->lock->try->n->Math->min->for->i->return->catch->finally->lock->unlock
PriorityBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock->lock->lock->try->es->for->i->n->catch->finally->lock->unlock
PriorityBlockingQueue#toArray():::Returns an array containing all of the elements in this queue:::lock->lock->lock->try->return->Arrays->copyOf->catch->finally->lock->unlock
PriorityBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->n->if->return->Arrays->a->getClass->copyOf->System->arraycopy->if->return->catch->finally->lock->unlock
PriorityBlockingQueue#iterator():::Returns an iterator over the elements in this queue:::return->toArray->new->Itr
PriorityBlockingQueue.Itr#hasNext()::: itr has next:::return
PriorityBlockingQueue.Itr#next()::: itr next:::if->throw->new->NoSuchElementException->return
PriorityBlockingQueue.Itr#remove()::: itr remove:::if->throw->new->IllegalStateException->removeEq
PriorityBlockingQueue.Itr#forEachRemaining(Consumer)::: itr for each remaining:::Objects->requireNonNull->es->i->if->for
PriorityBlockingQueue#writeObject(java.io.ObjectOutputStream):::Saves this queue to a stream (that is, serializes it):::lock->lock->try->Math->max->new->PriorityQueue<E>->q->addAll->s->defaultWriteObject->catch->finally->lock->unlock
PriorityBlockingQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::try->s->defaultReadObject->sz->q->size->SharedSecrets->getJavaObjectInputStreamAccess->checkArray->Math->max->new->ObjectArr->q->comparator->addAll->catch->finally
PriorityBlockingQueue.PBQSpliterator#getFence()::: spliterator get fence:::if->toArray->return
PriorityBlockingQueue.PBQSpliterator#trySplit()::: spliterator try split:::hi->getFence->lo->mid->return->new->PBQSpliterator
PriorityBlockingQueue.PBQSpliterator#forEachRemaining(Consumer)::: spliterator for each remaining:::Objects->requireNonNull->hi->getFence->lo->es->for->i
PriorityBlockingQueue.PBQSpliterator#tryAdvance(Consumer)::: spliterator try advance:::Objects->requireNonNull->if->getFence->action->accept->return->return
PriorityBlockingQueue.PBQSpliterator#estimateSize()::: spliterator estimate size:::return->getFence
PriorityBlockingQueue.PBQSpliterator#characteristics()::: spliterator characteristics:::return
PriorityBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->PBQSpliterator
PriorityBlockingQueue#removeIf(Predicate)::: priority blocking queue remove if:::Objects->requireNonNull->return->bulkRemove
PriorityBlockingQueue#removeAll(Collection)::: priority blocking queue remove all:::Objects->requireNonNull->return->c->contains->bulkRemove
PriorityBlockingQueue#retainAll(Collection)::: priority blocking queue retain all:::Objects->requireNonNull->return->c->contains->bulkRemove
PriorityBlockingQueue#nBits(int)::: priority blocking queue n bits:::return->new->longArr
PriorityBlockingQueue#setBit(long[], int)::: priority blocking queue set bit:::
PriorityBlockingQueue#isClear(long[], int)::: priority blocking queue is clear:::return
PriorityBlockingQueue#bulkRemove(Predicate):::Implementation of bulk remove methods.:::lock->lock->lock->try->es->end->i->for->filter->test->if->return->beg->deathRow->nBits->for->w->for->for->heapify->return->catch->finally->lock->unlock
PriorityBlockingQueue#forEach(Consumer)::: priority blocking queue for each:::Objects->requireNonNull->lock->lock->lock->try->es->for->i->n->catch->finally->lock->unlock
RecursiveAction#compute():::The main computation performed by this task.:::
RecursiveAction#getRawResult():::Always returns null.:::return
RecursiveAction#setRawResult(Void):::Requires null completion value.:::
RecursiveAction#exec():::Implements execution conventions for RecursiveActions.:::compute->return
RecursiveTask#compute():::The main computation performed by this task.:::
RecursiveTask#getRawResult()::: recursive task get raw result:::return
RecursiveTask#setRawResult(V)::: recursive task set raw result:::
RecursiveTask#exec():::Implements execution conventions for RecursiveTask.:::compute->return
RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor):::Method that may be invoked by a ThreadPoolExecutor when ThreadPoolExecutor#execute execute cannot accept a task:::
RunnableFuture#run():::Sets this Future to the result of its computation unless it has been cancelled.:::
RunnableScheduledFuture#isPeriodic():::Returns true if this task is periodic:::
ScheduledExecutorService#schedule(Runnable, long, TimeUnit):::Submits a one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#schedule(Callable, long, TimeUnit):::Submits a value-returning one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::
ScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::
ScheduledThreadPoolExecutor.ScheduledFutureTask#getDelay(TimeUnit)::: scheduled future task get delay:::return->unit->System->nanoTime->convert
ScheduledThreadPoolExecutor.ScheduledFutureTask#compareTo(Delayed)::: scheduled future task compare to:::if->return->if->x->diff->if->return->else->if->return->else->if->return->else->return->diff->getDelay->other->getDelay->return
ScheduledThreadPoolExecutor.ScheduledFutureTask#isPeriodic():::Returns true if this is a periodic (not a one-shot) action.:::return
ScheduledThreadPoolExecutor.ScheduledFutureTask#setNextRunTime():::Sets the next time to run for a periodic task.:::p->if->else->triggerTime
ScheduledThreadPoolExecutor.ScheduledFutureTask#cancel(boolean)::: scheduled future task cancel:::cancelled->super->cancel->if->remove->return
ScheduledThreadPoolExecutor.ScheduledFutureTask#run():::Overrides FutureTask version so as to reset/requeue if periodic.:::if->canRunInCurrentRunState->cancel->else->if->isPeriodic->super->run->else->if->super->runAndReset->setNextRunTime->reExecutePeriodic
ScheduledThreadPoolExecutor#canRunInCurrentRunState(RunnableScheduledFuture):::Returns true if can run a task given current run state and run-after-shutdown parameters.:::if->isShutdown->return->if->isStopped->return->return->task->isPeriodic->task->getDelay
ScheduledThreadPoolExecutor#delayedExecute(RunnableScheduledFuture):::Main execution method for delayed or periodic tasks:::if->isShutdown->reject->else->super->getQueue->add->if->canRunInCurrentRunState->remove->task->cancel->else->ensurePrestart
ScheduledThreadPoolExecutor#reExecutePeriodic(RunnableScheduledFuture):::Requeues a periodic task unless current run state precludes it:::if->canRunInCurrentRunState->super->getQueue->add->if->canRunInCurrentRunState->remove->ensurePrestart->return->task->cancel
ScheduledThreadPoolExecutor#onShutdown():::Cancels and clears the queue of all tasks that should not be run due to shutdown policy:::q->super->getQueue->keepDelayed->getExecuteExistingDelayedTasksAfterShutdownPolicy->keepPeriodic->getContinueExistingPeriodicTasksAfterShutdownPolicy->foreach->q->toArray->if->t->if->t->isPeriodic->t->getDelay->t->isCancelled->if->q->remove->t->cancel->tryTerminate
ScheduledThreadPoolExecutor#decorateTask(Runnable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a runnable:::return
ScheduledThreadPoolExecutor#decorateTask(Callable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a callable:::return
ScheduledThreadPoolExecutor#triggerTime(long, TimeUnit):::Returns the nanoTime-based trigger time of a delayed action.:::return->unit->toNanos->triggerTime
ScheduledThreadPoolExecutor#triggerTime(long):::Returns the nanoTime-based trigger time of a delayed action.:::return->System->nanoTime->overflowFree
ScheduledThreadPoolExecutor#overflowFree(long):::Constrains the values of all delays in the queue to be within Long.MAX_VALUE of each other, to avoid overflow in compareTo:::head->super->getQueue->peek->if->headDelay->head->getDelay->if->return
ScheduledThreadPoolExecutor#schedule(Runnable, long, TimeUnit)::: scheduled thread pool executor schedule:::if->throw->new->NullPointerException->t->triggerTime->sequencer->getAndIncrement->new->ScheduledFutureTask<Void>->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#schedule(Callable, long, TimeUnit)::: scheduled thread pool executor schedule:::if->throw->new->NullPointerException->t->triggerTime->sequencer->getAndIncrement->new->ScheduledFutureTask<V>->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->sft->triggerTime->unit->toNanos->sequencer->getAndIncrement->new->ScheduledFutureTask<Void>->t->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->sft->triggerTime->unit->toNanos->sequencer->getAndIncrement->new->ScheduledFutureTask<Void>->t->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#execute(Runnable):::Executes command with zero required delay:::schedule
ScheduledThreadPoolExecutor#submit(Runnable)::: scheduled thread pool executor submit:::return->schedule
ScheduledThreadPoolExecutor#submit(Runnable, T)::: scheduled thread pool executor submit:::return->Executors->callable->schedule
ScheduledThreadPoolExecutor#submit(Callable)::: scheduled thread pool executor submit:::return->schedule
ScheduledThreadPoolExecutor#setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::if->isShutdown->onShutdown
ScheduledThreadPoolExecutor#getContinueExistingPeriodicTasksAfterShutdownPolicy():::Gets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::return
ScheduledThreadPoolExecutor#setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::if->isShutdown->onShutdown
ScheduledThreadPoolExecutor#getExecuteExistingDelayedTasksAfterShutdownPolicy():::Gets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::return
ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean):::Sets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::
ScheduledThreadPoolExecutor#getRemoveOnCancelPolicy():::Gets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::return
ScheduledThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::super->shutdown
ScheduledThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::return->super->shutdownNow
ScheduledThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::return->super->getQueue
ScheduledThreadPoolExecutor.DelayedWorkQueue#setIndex(RunnableScheduledFuture, int):::Sets f's heapIndex if it is a ScheduledFutureTask.:::if
ScheduledThreadPoolExecutor.DelayedWorkQueue#siftUp(int, RunnableScheduledFuture):::Sifts element added at bottom up to its heap-ordered spot:::while->parent->e->if->key->compareTo->break->setIndex->setIndex
ScheduledThreadPoolExecutor.DelayedWorkQueue#siftDown(int, RunnableScheduledFuture):::Sifts element added at top down to its heap-ordered spot:::half->while->child->c->right->if->c->compareTo->if->key->compareTo->break->setIndex->setIndex
ScheduledThreadPoolExecutor.DelayedWorkQueue#grow():::Resizes the heap array:::oldCapacity->newCapacity->if->Arrays->copyOf
ScheduledThreadPoolExecutor.DelayedWorkQueue#indexOf(Object):::Finds index of given object, or -1 if absent.:::if->if->i->if->return->else->for->i->return
ScheduledThreadPoolExecutor.DelayedWorkQueue#contains(Object)::: delayed work queue contains:::lock->lock->lock->try->return->indexOf->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#remove(Object)::: delayed work queue remove:::lock->lock->lock->try->i->indexOf->if->return->setIndex->s->replacement->if->siftDown->if->siftUp->return->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#size()::: delayed work queue size:::lock->lock->lock->try->return->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#isEmpty()::: delayed work queue is empty:::return->size
ScheduledThreadPoolExecutor.DelayedWorkQueue#remainingCapacity()::: delayed work queue remaining capacity:::return
ScheduledThreadPoolExecutor.DelayedWorkQueue#peek()::: delayed work queue peek:::lock->lock->lock->try->return->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable)::: delayed work queue offer:::if->throw->new->NullPointerException->e->lock->lock->lock->try->i->if->grow->if->setIndex->else->siftUp->if->available->signal->catch->finally->lock->unlock->return
ScheduledThreadPoolExecutor.DelayedWorkQueue#put(Runnable)::: delayed work queue put:::offer
ScheduledThreadPoolExecutor.DelayedWorkQueue#add(Runnable)::: delayed work queue add:::return->offer
ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable, long, TimeUnit)::: delayed work queue offer:::return->offer
ScheduledThreadPoolExecutor.DelayedWorkQueue#finishPoll(RunnableScheduledFuture):::Performs common bookkeeping for poll and take: Replaces first element with last and sifts it down:::s->x->if->siftDown->setIndex->return
ScheduledThreadPoolExecutor.DelayedWorkQueue#poll()::: delayed work queue poll:::lock->lock->lock->try->first->return->first->getDelay->finishPoll->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#take()::: delayed work queue take:::lock->lock->lockInterruptibly->try->for->catch->finally->if->available->signal->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#poll(long, TimeUnit)::: delayed work queue poll:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->for->catch->finally->if->available->signal->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#clear()::: delayed work queue clear:::lock->lock->lock->try->for->i->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection)::: delayed work queue drain to:::return->drainTo
ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection, int)::: delayed work queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->if->return->lock->lock->lock->try->n->for->first->first->getDelay->return->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray()::: delayed work queue to array:::lock->lock->lock->try->return->Arrays->copyOf->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray(T[])::: delayed work queue to array:::lock->lock->lock->try->if->return->Arrays->a->getClass->copyOf->System->arraycopy->if->return->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue#iterator()::: delayed work queue iterator:::lock->lock->lock->try->return->Arrays->copyOf->new->Itr->catch->finally->lock->unlock
ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#hasNext()::: itr has next:::return
ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#next()::: itr next:::if->throw->new->NoSuchElementException->return
ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#remove()::: itr remove:::if->throw->new->IllegalStateException->DelayedWorkQueue.this->remove
Semaphore.Sync#getPermits()::: sync get permits:::return->getState
Semaphore.Sync#nonfairTryAcquireShared(int)::: sync nonfair try acquire shared:::for
Semaphore.Sync#tryReleaseShared(int)::: sync try release shared:::for
Semaphore.Sync#reducePermits(int)::: sync reduce permits:::for
Semaphore.Sync#drainPermits()::: sync drain permits:::for
Semaphore.NonfairSync#tryAcquireShared(int)::: nonfair sync try acquire shared:::return->nonfairTryAcquireShared
Semaphore.FairSync#tryAcquireShared(int)::: fair sync try acquire shared:::for
Semaphore#acquire():::Acquires a permit from this semaphore, blocking until one is available, or the thread is Thread#interrupt interrupted:::sync->acquireSharedInterruptibly
Semaphore#acquireUninterruptibly():::Acquires a permit from this semaphore, blocking until one is available:::sync->acquireShared
Semaphore#tryAcquire():::Acquires a permit from this semaphore, only if one is available at the time of invocation:::return->sync->nonfairTryAcquireShared
Semaphore#tryAcquire(long, TimeUnit):::Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::return->sync->unit->toNanos->tryAcquireSharedNanos
Semaphore#release():::Releases a permit, returning it to the semaphore:::sync->releaseShared
Semaphore#acquire(int):::Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is Thread#interrupt interrupted:::if->throw->new->IllegalArgumentException->sync->acquireSharedInterruptibly
Semaphore#acquireUninterruptibly(int):::Acquires the given number of permits from this semaphore, blocking until all are available:::if->throw->new->IllegalArgumentException->sync->acquireShared
Semaphore#tryAcquire(int):::Acquires the given number of permits from this semaphore, only if all are available at the time of invocation:::if->throw->new->IllegalArgumentException->return->sync->nonfairTryAcquireShared
Semaphore#tryAcquire(int, long, TimeUnit):::Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::if->throw->new->IllegalArgumentException->return->sync->unit->toNanos->tryAcquireSharedNanos
Semaphore#release(int):::Releases the given number of permits, returning them to the semaphore:::if->throw->new->IllegalArgumentException->sync->releaseShared
Semaphore#availablePermits():::Returns the current number of permits available in this semaphore:::return->sync->getPermits
Semaphore#drainPermits():::Acquires and returns all permits that are immediately available, or if negative permits are available, releases them:::return->sync->drainPermits
Semaphore#reducePermits(int):::Shrinks the number of available permits by the indicated reduction:::if->throw->new->IllegalArgumentException->sync->reducePermits
Semaphore#isFair():::Returns true if this semaphore has fairness set true.:::return
Semaphore#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::return->sync->hasQueuedThreads
Semaphore#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::return->sync->getQueueLength
Semaphore#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::return->sync->getQueuedThreads
Semaphore#toString():::Returns a string identifying this semaphore, as well as its state:::return->super->toString->sync->getPermits
SubmissionPublisher#roundCapacity(int):::Round capacity to power of 2, at most limit.:::n->return
SubmissionPublisher.ThreadPerTaskExecutor#execute(Runnable)::: thread per task executor execute:::new->Thread->start
SubmissionPublisher#subscribe(Subscriber):::Adds the given Subscriber unless already subscribed:::if->throw->new->NullPointerException->max->array->new->ObjectArr->subscription->new->BufferedSubscription<T>->synchronized->if->Thread->currentThread->for->b->pred
SubmissionPublisher#doOffer(T, long, BiPredicate, ? super T>):::Common implementation for all three forms of submit and offer:::if->throw->new->NullPointerException->lag->complete->unowned->synchronized->t->Thread->currentThread->o->b->if->if->else->cleanMe->retries->rtail->next->do->stat->b->offer->if->if->else->else->if->else->if->while->if->retryOffer->if->throw->new->IllegalStateException->else->return
SubmissionPublisher#retryOffer(T, long, BiPredicate, ? super T>, BufferedSubscription, int, boolean):::Helps, (timed) waits for, and/or drops buffers on list; returns lag or negative drops (for use in offer).:::for->r->if->cleanAndCount->return
SubmissionPublisher#cleanAndCount():::Returns current list count after removing closed subscribers:::count->pred->next->for->b->return
SubmissionPublisher#submit(T):::Publishes the given item to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking uninterruptibly while resources for any subscriber are unavailable:::return->doOffer
SubmissionPublisher#offer(T, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method:::return->doOffer
SubmissionPublisher#offer(T, long, TimeUnit, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking while resources for any subscription are unavailable, up to the specified timeout or until the caller thread is interrupted, at which point the given handler (if non-null) is invoked, and if it returns true, retried once:::nanos->unit->toNanos->if->return->doOffer
SubmissionPublisher#close():::Unless already closed, issues Flow.Subscriber#onComplete() onComplete signals to current subscribers, and disallows subsequent attempts to publish:::if->b->synchronized->while->next->b->onComplete
SubmissionPublisher#closeExceptionally(Throwable):::Unless already closed, issues Flow.Subscriber#onError(Throwable) onError signals to current subscribers with the given error, and disallows subsequent attempts to publish:::if->throw->new->NullPointerException->if->b->synchronized->if->while->next->b->onError
SubmissionPublisher#isClosed():::Returns true if this publisher is not accepting submissions.:::return
SubmissionPublisher#getClosedException():::Returns the exception associated with #closeExceptionally(Throwable) closeExceptionally, or null if not closed or if closed normally.:::return
SubmissionPublisher#hasSubscribers():::Returns true if this publisher has any subscribers.:::nonEmpty->synchronized->for->b->return
SubmissionPublisher#getNumberOfSubscribers():::Returns the number of current subscribers.:::synchronized->return->cleanAndCount
SubmissionPublisher#getExecutor():::Returns the Executor used for asynchronous delivery.:::return
SubmissionPublisher#getMaxBufferCapacity():::Returns the maximum per-subscriber buffer capacity.:::return
SubmissionPublisher#getSubscribers():::Returns a list of current subscribers for monitoring and tracking purposes, not for invoking Flow.Subscriber methods on the subscribers.:::subs->new->ArrayList<>->synchronized->pred->next->for->b->return
SubmissionPublisher#isSubscribed(Subscriber):::Returns true if the given Subscriber is currently subscribed.:::if->throw->new->NullPointerException->if->synchronized->pred->next->for->b->return
SubmissionPublisher#estimateMinimumDemand():::Returns an estimate of the minimum number of items requested (via Flow.Subscription#request(long) request) but not yet produced, among all current subscribers.:::min->nonEmpty->synchronized->pred->next->for->b->return
SubmissionPublisher#estimateMaximumLag():::Returns an estimate of the maximum number of items produced but not yet consumed among all current subscribers.:::max->synchronized->pred->next->for->b->return
SubmissionPublisher#consume(Consumer):::Processes all published items using the given Consumer function:::if->throw->new->NullPointerException->status->new->CompletableFuture<>->new->ConsumerSubscriber<T>->subscribe->return
SubmissionPublisher.ConsumerSubscriber#onSubscribe(Subscription)::: consumer subscriber on subscribe:::status->subscription->cancel->whenComplete->if->status->isDone->subscription->request
SubmissionPublisher.ConsumerSubscriber#onError(Throwable)::: consumer subscriber on error:::status->completeExceptionally
SubmissionPublisher.ConsumerSubscriber#onComplete()::: consumer subscriber on complete:::status->complete
SubmissionPublisher.ConsumerSubscriber#onNext(T)::: consumer subscriber on next:::try->consumer->accept->catch->subscription->cancel->status->completeExceptionally->finally
SubmissionPublisher.ConsumerTask#getRawResult()::: consumer task get raw result:::return
SubmissionPublisher.ConsumerTask#setRawResult(Void)::: consumer task set raw result:::
SubmissionPublisher.ConsumerTask#exec()::: consumer task exec:::consumer->consume->return
SubmissionPublisher.ConsumerTask#run()::: consumer task run:::consumer->consume
SubmissionPublisher.BufferedSubscription#weakCasCtl(int, int)::: buffered subscription weak cas ctl:::return->CTL->weakCompareAndSet
SubmissionPublisher.BufferedSubscription#getAndBitwiseOrCtl(int)::: buffered subscription get and bitwise or ctl:::return->CTL->getAndBitwiseOr
SubmissionPublisher.BufferedSubscription#subtractDemand(int)::: buffered subscription subtract demand:::n->return->DEMAND->getAndAdd
SubmissionPublisher.BufferedSubscription#casDemand(long, long)::: buffered subscription cas demand:::return->DEMAND->compareAndSet
SubmissionPublisher.BufferedSubscription#isClosed():::Returns true if closed (consumer task may still be running).:::return
SubmissionPublisher.BufferedSubscription#estimateLag():::Returns estimated number of buffered items, or negative if closed.:::c->n->return
SubmissionPublisher.BufferedSubscription#offer(T, boolean):::Tries to add item and start consumer task if necessary.:::a->stat->cap->t->i->n->if->added->if->growAndOffer->else->if->QA->compareAndSet->else->QA->setRelease->if->return->startOnOffer
SubmissionPublisher.BufferedSubscription#growAndOffer(T, Object[], int):::Tries to expand buffer and add item, returning true on success:::cap->newCap->newArray->if->try->new->ObjectArr->catch->finally->if->return->else->newMask->for->mask->k->VarHandle->releaseFence->return
SubmissionPublisher.BufferedSubscription#retryOffer(T):::Version of offer for retries (no resize or bias):::a->stat->t->h->cap->if->QA->compareAndSet->return->startOnOffer
SubmissionPublisher.BufferedSubscription#startOnOffer(int):::Tries to start consumer task after offer.:::c->if->getAndBitwiseOrCtl->tryStart->else->if->return
SubmissionPublisher.BufferedSubscription#tryStart():::Tries to start consumer task:::try->e->task->new->ConsumerTask<T>->if->e->execute->catch->getAndBitwiseOrCtl->throw->finally
SubmissionPublisher.BufferedSubscription#startOnSignal(int):::Sets the given control bits, starting task if not running or closed.:::if->getAndBitwiseOrCtl->tryStart
SubmissionPublisher.BufferedSubscription#onSubscribe()::: buffered subscription on subscribe:::startOnSignal
SubmissionPublisher.BufferedSubscription#onComplete()::: buffered subscription on complete:::startOnSignal
SubmissionPublisher.BufferedSubscription#onError(Throwable)::: buffered subscription on error:::c->a->if->if->getAndBitwiseOrCtl->if->tryStart->else->if->Arrays->fill
SubmissionPublisher.BufferedSubscription#cancel()::: buffered subscription cancel:::onError
SubmissionPublisher.BufferedSubscription#request(long)::: buffered subscription request:::if->for->startOnSignal->else->new->IllegalArgumentException->onError
SubmissionPublisher.BufferedSubscription#consume():::Consumer loop, called from ConsumerTask, or indirectly when helping during submit.:::s->if->subscribeOnOpen->d->for->h->t
SubmissionPublisher.BufferedSubscription#takeItems(Subscriber, long, int):::Consumes some items until unavailable or bound or error.:::a->k->cap->if->m->b->n->for->return
SubmissionPublisher.BufferedSubscription#consumeNext(Subscriber, Object)::: buffered subscription consume next:::try->y->if->s->onNext->return->catch->handleOnNext->return->finally
SubmissionPublisher.BufferedSubscription#handleOnNext(Subscriber, Throwable):::Processes exception in Subscriber.onNext.:::h->try->if->h->accept->catch->finally->closeOnError
SubmissionPublisher.BufferedSubscription#subscribeOnOpen(Subscriber):::Issues subscriber.onSubscribe if this is first signal.:::if->getAndBitwiseOrCtl->consumeSubscribe
SubmissionPublisher.BufferedSubscription#consumeSubscribe(Subscriber)::: buffered subscription consume subscribe:::try->if->s->onSubscribe->catch->closeOnError->finally
SubmissionPublisher.BufferedSubscription#closeOnComplete(Subscriber):::Issues subscriber.onComplete unless already closed.:::if->getAndBitwiseOrCtl->consumeComplete
SubmissionPublisher.BufferedSubscription#consumeComplete(Subscriber)::: buffered subscription consume complete:::try->if->s->onComplete->catch->finally
SubmissionPublisher.BufferedSubscription#closeOnError(Subscriber, Throwable):::Issues subscriber.onError, and unblocks producer if needed.:::if->getAndBitwiseOrCtl->if->signalWaiter->consumeError
SubmissionPublisher.BufferedSubscription#consumeError(Subscriber, Throwable)::: buffered subscription consume error:::try->if->s->onError->catch->finally
SubmissionPublisher.BufferedSubscription#signalWaiter():::Unblocks waiting producer.:::w->if->LockSupport->unpark
SubmissionPublisher.BufferedSubscription#isReleasable():::Returns true if closed or space available:::a->cap->return->QA->getAcquire
SubmissionPublisher.BufferedSubscription#awaitSpace(long):::Helps or blocks until timeout, closed, or space available.:::if->isReleasable->ForkJoinPool->helpAsyncBlocker->if->isReleasable->try->ForkJoinPool->managedBlock->catch->finally->if->Thread->currentThread->interrupt
SubmissionPublisher.BufferedSubscription#block():::Blocks until closed, space available or timeout:::nanos->timed->deadline->System->nanoTime->while->isReleasable->if->Thread->interrupted->if->break->else->if->System->nanoTime->break->else->if->Thread->currentThread->else->if->else->if->LockSupport->parkNanos->else->LockSupport->park->return
SynchronousQueue.Transferer#transfer(E, boolean, long):::Performs a put or take.:::
SynchronousQueue.TransferStack#isFulfilling(int):::Returns true if m has fulfilling bit set.:::return
SynchronousQueue.TransferStack.SNode#casNext(SNode, SNode)::: node cas next:::return->SNEXT->compareAndSet
SynchronousQueue.TransferStack.SNode#tryMatch(SNode):::Tries to match node s to this node, if so, waking up thread:::if->SMATCH->compareAndSet->w->if->LockSupport->unpark->return->return
SynchronousQueue.TransferStack.SNode#tryCancel():::Tries to cancel a wait by matching node to itself.:::SMATCH->compareAndSet
SynchronousQueue.TransferStack.SNode#isCancelled()::: node is cancelled:::return
SynchronousQueue.TransferStack#casHead(SNode, SNode)::: transfer stack cas head:::return->SHEAD->compareAndSet
SynchronousQueue.TransferStack#snode(SNode, Object, SNode, int):::Creates or resets fields of a node:::if->new->SNode->return
SynchronousQueue.TransferStack#transfer(E, boolean, long):::Puts or takes an item.:::s->mode->for
SynchronousQueue.TransferStack#awaitFulfill(SNode, boolean, long):::Spins/blocks until node s is matched by a fulfill operation.:::deadline->System->nanoTime->w->Thread->currentThread->spins->shouldSpin->for
SynchronousQueue.TransferStack#shouldSpin(SNode):::Returns true if node s is at head or there is an active fulfiller.:::h->return->isFulfilling
SynchronousQueue.TransferStack#clean(SNode):::Unlinks s from the stack.:::past->if->past->isCancelled->p->while->p->isCancelled->casHead->while->n->if->n->isCancelled->p->casNext->else
SynchronousQueue.TransferQueue.QNode#casNext(QNode, QNode)::: node cas next:::return->QNEXT->compareAndSet
SynchronousQueue.TransferQueue.QNode#casItem(Object, Object)::: node cas item:::return->QITEM->compareAndSet
SynchronousQueue.TransferQueue.QNode#tryCancel(Object):::Tries to cancel by CAS'ing ref to this as item.:::QITEM->compareAndSet
SynchronousQueue.TransferQueue.QNode#isCancelled()::: node is cancelled:::return
SynchronousQueue.TransferQueue.QNode#isOffList():::Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.:::return
SynchronousQueue.TransferQueue#advanceHead(QNode, QNode):::Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.:::if->QHEAD->compareAndSet
SynchronousQueue.TransferQueue#advanceTail(QNode, QNode):::Tries to cas nt as new tail.:::if->QTAIL->compareAndSet
SynchronousQueue.TransferQueue#casCleanMe(QNode, QNode):::Tries to CAS cleanMe slot.:::return->QCLEANME->compareAndSet
SynchronousQueue.TransferQueue#transfer(E, boolean, long):::Puts or takes an item.:::s->isData->for
SynchronousQueue.TransferQueue#awaitFulfill(QNode, E, boolean, long):::Spins/blocks until node s is fulfilled.:::deadline->System->nanoTime->w->Thread->currentThread->spins->for
SynchronousQueue.TransferQueue#clean(QNode, QNode):::Gets rid of cancelled node s with original predecessor pred.:::while->h->hn->if->hn->isCancelled->advanceHead->continue->t->if->return->tn->if->continue->if->advanceTail->continue->if->sn->if->pred->casNext->return->dp->if->d->dn->if->d->isCancelled->dp->casNext->casCleanMe->if->return->else->if->casCleanMe->return
SynchronousQueue#put(E):::Adds the specified element to this queue, waiting if necessary for another thread to receive it.:::if->throw->new->NullPointerException->if->transferer->transfer->Thread->interrupted->throw->new->InterruptedException
SynchronousQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.:::if->throw->new->NullPointerException->if->transferer->unit->toNanos->transfer->return->if->Thread->interrupted->return->throw->new->InterruptedException
SynchronousQueue#offer(E):::Inserts the specified element into this queue, if another thread is waiting to receive it.:::if->throw->new->NullPointerException->return->transferer->transfer
SynchronousQueue#take():::Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.:::e->transferer->transfer->if->return->Thread->interrupted->throw->new->InterruptedException
SynchronousQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.:::e->transferer->unit->toNanos->transfer->if->Thread->interrupted->return->throw->new->InterruptedException
SynchronousQueue#poll():::Retrieves and removes the head of this queue, if another thread is currently making an element available.:::return->transferer->transfer
SynchronousQueue#isEmpty():::Always returns true:::return
SynchronousQueue#size():::Always returns zero:::return
SynchronousQueue#remainingCapacity():::Always returns zero:::return
SynchronousQueue#clear():::Does nothing:::
SynchronousQueue#contains(Object):::Always returns false:::return
SynchronousQueue#remove(Object):::Always returns false:::return
SynchronousQueue#containsAll(Collection):::Returns false unless the given collection is empty:::return->c->isEmpty
SynchronousQueue#removeAll(Collection):::Always returns false:::return
SynchronousQueue#retainAll(Collection):::Always returns false:::return
SynchronousQueue#peek():::Always returns null:::return
SynchronousQueue#iterator():::Returns an empty iterator in which hasNext always returns false.:::return->Collections->emptyIterator
SynchronousQueue#spliterator():::Returns an empty spliterator in which calls to Spliterator#trySplit() trySplit always return null.:::return->Spliterators->emptySpliterator
SynchronousQueue#toArray():::Returns a zero-length array.:::return->new->ObjectArr
SynchronousQueue#toArray(T[]):::Sets the zeroth element of the specified array to null (if the array has non-zero length) and returns it.:::if->return
SynchronousQueue#toString():::Always returns "[]".:::return
SynchronousQueue#drainTo(Collection)::: synchronous queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->n->for->e->poll->return
SynchronousQueue#drainTo(Collection, int)::: synchronous queue drain to:::Objects->requireNonNull->if->throw->new->IllegalArgumentException->n->for->e->poll->return
SynchronousQueue#writeObject(java.io.ObjectOutputStream):::Saves this queue to a stream (that is, serializes it).:::fair->if->new->ReentrantLock->new->FifoWaitQueue->new->FifoWaitQueue->else->new->ReentrantLock->new->LifoWaitQueue->new->LifoWaitQueue->s->defaultWriteObject
SynchronousQueue#readObject(java.io.ObjectInputStream):::Reconstitutes this queue from a stream (that is, deserializes it).:::s->defaultReadObject->if->new->TransferQueue<E>->else->new->TransferStack<E>
ThreadFactory#newThread(Runnable):::Constructs a new Thread:::
ThreadLocalRandom#mix64(long)::: thread local random mix64:::return
ThreadLocalRandom#mix32(long)::: thread local random mix32:::return
ThreadLocalRandom#localInit():::Initialize Thread fields for the current thread:::p->probeGenerator->addAndGet->probe->seed->seeder->getAndAdd->mix64->t->Thread->currentThread->U->putLong->U->putInt
ThreadLocalRandom#current():::Returns the current thread's ThreadLocalRandom.:::if->U->Thread->currentThread->getInt->localInit->return
ThreadLocalRandom#setSeed(long):::Throws UnsupportedOperationException:::if->throw->new->UnsupportedOperationException
ThreadLocalRandom#nextSeed()::: thread local random next seed:::t->r->U->Thread->currentThread->U->getLong->putLong->return
ThreadLocalRandom#next(int):::Generates a pseudorandom number with the indicated number of low-order bits:::return->nextInt
ThreadLocalRandom#internalNextLong(long, long):::The form of nextLong used by LongStream Spliterators:::r->nextSeed->mix64->if->n->m->if->else->if->for->u->nextSeed->mix64->else->while->nextSeed->mix64->return
ThreadLocalRandom#internalNextInt(int, int):::The form of nextInt used by IntStream Spliterators:::r->nextSeed->mix32->if->n->m->if->else->if->for->u->nextSeed->mix32->else->while->nextSeed->mix32->return
ThreadLocalRandom#internalNextDouble(double, double):::The form of nextDouble used by DoubleStream Spliterators.:::r->nextLong->if->if->Double->Double->doubleToLongBits->longBitsToDouble->return
ThreadLocalRandom#nextInt():::Returns a pseudorandom int value.:::return->nextSeed->mix32
ThreadLocalRandom#nextInt(int):::Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->r->nextSeed->mix32->m->if->else->for->u->nextSeed->mix32->return
ThreadLocalRandom#nextInt(int, int):::Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextInt
ThreadLocalRandom#nextLong():::Returns a pseudorandom long value.:::return->nextSeed->mix64
ThreadLocalRandom#nextLong(long):::Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->r->nextSeed->mix64->m->if->else->for->u->nextSeed->mix64->return
ThreadLocalRandom#nextLong(long, long):::Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextLong
ThreadLocalRandom#nextDouble():::Returns a pseudorandom double value between zero (inclusive) and one (exclusive).:::return->nextSeed->mix64
ThreadLocalRandom#nextDouble(double):::Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->result->nextSeed->mix64->return->Double->Double->doubleToLongBits->longBitsToDouble
ThreadLocalRandom#nextDouble(double, double):::Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextDouble
ThreadLocalRandom#nextBoolean():::Returns a pseudorandom boolean value.:::return->nextSeed->mix32
ThreadLocalRandom#nextFloat():::Returns a pseudorandom float value between zero (inclusive) and one (exclusive).:::return->nextSeed->mix32
ThreadLocalRandom#nextGaussian()::: thread local random next gaussian:::d->nextLocalGaussian->get->if->nextLocalGaussian->set->return->d->doubleValue->v1->v2->s->do->nextDouble->nextDouble->while->multiplier->StrictMath->StrictMath->log->sqrt->nextLocalGaussian->Double->valueOf->set->return
ThreadLocalRandom#ints(long):::Returns a stream producing the given streamSize number of pseudorandom int values.:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints():::Returns an effectively unlimited stream of pseudorandom int values.:::return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints(long, int, int):::Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints(int, int):::Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#longs(long):::Returns a stream producing the given streamSize number of pseudorandom long values.:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs():::Returns an effectively unlimited stream of pseudorandom long values.:::return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs(long, long, long):::Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs(long, long):::Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#doubles(long):::Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles():::Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles(long, double, double):::Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles(double, double):::Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom.RandomIntsSpliterator#trySplit()::: random ints spliterator try split:::i->m->return->new->RandomIntsSpliterator
ThreadLocalRandom.RandomIntsSpliterator#estimateSize()::: random ints spliterator estimate size:::return
ThreadLocalRandom.RandomIntsSpliterator#characteristics()::: random ints spliterator characteristics:::return
ThreadLocalRandom.RandomIntsSpliterator#tryAdvance(IntConsumer)::: random ints spliterator try advance:::if->throw->new->NullPointerException->i->f->if->consumer->ThreadLocalRandom->current->internalNextInt->accept->return->return
ThreadLocalRandom.RandomIntsSpliterator#forEachRemaining(IntConsumer)::: random ints spliterator for each remaining:::if->throw->new->NullPointerException->i->f->if->o->b->rng->ThreadLocalRandom->current->do->consumer->rng->internalNextInt->accept->while
ThreadLocalRandom.RandomLongsSpliterator#trySplit()::: random longs spliterator try split:::i->m->return->new->RandomLongsSpliterator
ThreadLocalRandom.RandomLongsSpliterator#estimateSize()::: random longs spliterator estimate size:::return
ThreadLocalRandom.RandomLongsSpliterator#characteristics()::: random longs spliterator characteristics:::return
ThreadLocalRandom.RandomLongsSpliterator#tryAdvance(LongConsumer)::: random longs spliterator try advance:::if->throw->new->NullPointerException->i->f->if->consumer->ThreadLocalRandom->current->internalNextLong->accept->return->return
ThreadLocalRandom.RandomLongsSpliterator#forEachRemaining(LongConsumer)::: random longs spliterator for each remaining:::if->throw->new->NullPointerException->i->f->if->o->b->rng->ThreadLocalRandom->current->do->consumer->rng->internalNextLong->accept->while
ThreadLocalRandom.RandomDoublesSpliterator#trySplit()::: random doubles spliterator try split:::i->m->return->new->RandomDoublesSpliterator
ThreadLocalRandom.RandomDoublesSpliterator#estimateSize()::: random doubles spliterator estimate size:::return
ThreadLocalRandom.RandomDoublesSpliterator#characteristics()::: random doubles spliterator characteristics:::return
ThreadLocalRandom.RandomDoublesSpliterator#tryAdvance(DoubleConsumer)::: random doubles spliterator try advance:::if->throw->new->NullPointerException->i->f->if->consumer->ThreadLocalRandom->current->internalNextDouble->accept->return->return
ThreadLocalRandom.RandomDoublesSpliterator#forEachRemaining(DoubleConsumer)::: random doubles spliterator for each remaining:::if->throw->new->NullPointerException->i->f->if->o->b->rng->ThreadLocalRandom->current->do->consumer->rng->internalNextDouble->accept->while
ThreadLocalRandom#getProbe():::Returns the probe value for the current thread without forcing initialization:::return->U->Thread->currentThread->getInt
ThreadLocalRandom#advanceProbe(int):::Pseudo-randomly advances and records the given probe value for the given thread.:::U->Thread->currentThread->putInt->return
ThreadLocalRandom#nextSecondarySeed():::Returns the pseudo-randomly initialized or updated secondary seed.:::r->t->Thread->currentThread->if->U->getInt->else->if->seeder->getAndAdd->mix32->U->putInt->return
ThreadLocalRandom#eraseThreadLocals(Thread):::Erases ThreadLocals by nulling out Thread maps.:::U->putObject->U->putObject
ThreadLocalRandom#setInheritedAccessControlContext(Thread, AccessControlContext)::: thread local random set inherited access control context:::U->putObjectRelease
ThreadLocalRandom#writeObject(java.io.ObjectOutputStream):::Saves the ThreadLocalRandom to a stream (that is, serializes it).:::fields->s->putFields->fields->U->Thread->currentThread->getLong->put->fields->put->s->writeFields
ThreadLocalRandom#readResolve():::Returns the #current() current thread's ThreadLocalRandom.:::return->current
ThreadPoolExecutor#runStateOf(int)::: thread pool executor run state of:::return
ThreadPoolExecutor#workerCountOf(int)::: thread pool executor worker count of:::return
ThreadPoolExecutor#ctlOf(int, int)::: thread pool executor ctl of:::return
ThreadPoolExecutor#runStateLessThan(int, int)::: thread pool executor run state less than:::return
ThreadPoolExecutor#runStateAtLeast(int, int)::: thread pool executor run state at least:::return
ThreadPoolExecutor#isRunning(int)::: thread pool executor is running:::return
ThreadPoolExecutor#compareAndIncrementWorkerCount(int):::Attempts to CAS-increment the workerCount field of ctl.:::return->ctl->compareAndSet
ThreadPoolExecutor#compareAndDecrementWorkerCount(int):::Attempts to CAS-decrement the workerCount field of ctl.:::return->ctl->compareAndSet
ThreadPoolExecutor#decrementWorkerCount():::Decrements the workerCount field of ctl:::ctl->addAndGet
ThreadPoolExecutor.Worker#run():::Delegates main run loop to outer runWorker.:::runWorker
ThreadPoolExecutor.Worker#isHeldExclusively()::: worker is held exclusively:::return->getState
ThreadPoolExecutor.Worker#tryAcquire(int)::: worker try acquire:::if->compareAndSetState->Thread->currentThread->setExclusiveOwnerThread->return->return
ThreadPoolExecutor.Worker#tryRelease(int)::: worker try release:::setExclusiveOwnerThread->setState->return
ThreadPoolExecutor.Worker#lock()::: worker lock:::acquire
ThreadPoolExecutor.Worker#tryLock()::: worker try lock:::return->tryAcquire
ThreadPoolExecutor.Worker#unlock()::: worker unlock:::release
ThreadPoolExecutor.Worker#isLocked()::: worker is locked:::return->isHeldExclusively
ThreadPoolExecutor.Worker#interruptIfStarted()::: worker interrupt if started:::t->if->getState->t->isInterrupted->try->t->interrupt->catch->finally
ThreadPoolExecutor#advanceRunState(int):::Transitions runState to given target, or leaves it alone if already at least the given target.:::for
ThreadPoolExecutor#tryTerminate():::Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty):::for
ThreadPoolExecutor#checkShutdownAccess():::If there is a security manager, makes sure caller has permission to shut down threads in general (see shutdownPerm):::security->System->getSecurityManager->if->security->checkPermission->foreach->security->checkAccess
ThreadPoolExecutor#interruptWorkers():::Interrupts all threads, even if active:::foreach->w->interruptIfStarted
ThreadPoolExecutor#interruptIdleWorkers(boolean):::Interrupts threads that might be waiting for tasks (as indicated by not being locked) so they can check for termination or configuration changes:::mainLock->mainLock->lock->try->foreach->t->if->t->isInterrupted->w->tryLock->try->t->interrupt->catch->finally->w->unlock->if->break->catch->finally->mainLock->unlock
ThreadPoolExecutor#interruptIdleWorkers():::Common form of interruptIdleWorkers, to avoid having to remember what the boolean argument means.:::interruptIdleWorkers
ThreadPoolExecutor#reject(Runnable):::Invokes the rejected execution handler for the given command:::handler->rejectedExecution
ThreadPoolExecutor#onShutdown():::Performs any further cleanup following run state transition on invocation of shutdown:::
ThreadPoolExecutor#drainQueue():::Drains the task queue into a new list, normally using drainTo:::q->taskList->new->ArrayList<>->q->drainTo->if->q->isEmpty->foreach->q->new->RunnableArr->toArray->if->q->remove->taskList->add->return
ThreadPoolExecutor#addWorker(Runnable, boolean):::Checks if a new worker can be added with respect to current pool state and the given bound (either core or maximum):::for->c->ctl->get->workerStarted->workerAdded->w->try->new->Worker->t->if->mainLock->mainLock->lock->try->c->ctl->get->if->isRunning->runStateLessThan->if->t->getState->throw->new->IllegalThreadStateException->workers->add->s->workers->size->if->catch->finally->mainLock->unlock->if->t->start->catch->finally->if->addWorkerFailed->return
ThreadPoolExecutor#addWorkerFailed(Worker):::Rolls back the worker thread creation:::mainLock->mainLock->lock->try->if->workers->remove->decrementWorkerCount->tryTerminate->catch->finally->mainLock->unlock
ThreadPoolExecutor#processWorkerExit(Worker, boolean):::Performs cleanup and bookkeeping for a dying worker:::if->decrementWorkerCount->mainLock->mainLock->lock->try->workers->remove->catch->finally->mainLock->unlock->tryTerminate->c->ctl->get->if->runStateLessThan->if->min->if->workQueue->isEmpty->if->workerCountOf->return->addWorker
ThreadPoolExecutor#getTask():::Performs blocking or timed wait for a task, depending on current configuration settings, or returns null if this worker must exit because of any of: 1:::timedOut->for
ThreadPoolExecutor#runWorker(Worker):::Main worker run loop:::wt->Thread->currentThread->task->w->unlock->completedAbruptly->try->while->getTask->w->lock->if->ctl->get->runStateAtLeast->Thread->interrupted->ctl->get->runStateAtLeast->wt->isInterrupted->wt->interrupt->try->beforeExecute->try->task->run->afterExecute->catch->afterExecute->throw->finally->catch->finally->w->unlock->catch->finally->processWorkerExit
ThreadPoolExecutor#execute(Runnable):::Executes the given task sometime in the future:::if->throw->new->NullPointerException->c->ctl->get->if->workerCountOf->if->addWorker->return->ctl->get->if->isRunning->workQueue->offer->recheck->ctl->get->if->isRunning->remove->reject->else->if->workerCountOf->addWorker->else->if->addWorker->reject
ThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::mainLock->mainLock->lock->try->checkShutdownAccess->advanceRunState->interruptIdleWorkers->onShutdown->catch->finally->mainLock->unlock->tryTerminate
ThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::tasks->mainLock->mainLock->lock->try->checkShutdownAccess->advanceRunState->interruptWorkers->drainQueue->catch->finally->mainLock->unlock->tryTerminate->return
ThreadPoolExecutor#isShutdown()::: thread pool executor is shutdown:::return->ctl->get->runStateAtLeast
ThreadPoolExecutor#isStopped():::Used by ScheduledThreadPoolExecutor.:::return->ctl->get->runStateAtLeast
ThreadPoolExecutor#isTerminating():::Returns true if this executor is in the process of terminating after #shutdown or #shutdownNow but has not completely terminated:::c->ctl->get->return->runStateAtLeast->runStateLessThan
ThreadPoolExecutor#isTerminated()::: thread pool executor is terminated:::return->ctl->get->runStateAtLeast
ThreadPoolExecutor#awaitTermination(long, TimeUnit)::: thread pool executor await termination:::nanos->unit->toNanos->mainLock->mainLock->lock->try->while->ctl->get->runStateLessThan->if->return->termination->awaitNanos->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#finalize()::: thread pool executor finalize:::
ThreadPoolExecutor#setThreadFactory(ThreadFactory):::Sets the thread factory used to create new threads.:::if->throw->new->NullPointerException
ThreadPoolExecutor#getThreadFactory():::Returns the thread factory used to create new threads.:::return
ThreadPoolExecutor#setRejectedExecutionHandler(RejectedExecutionHandler):::Sets a new handler for unexecutable tasks.:::if->throw->new->NullPointerException
ThreadPoolExecutor#getRejectedExecutionHandler():::Returns the current handler for unexecutable tasks.:::return
ThreadPoolExecutor#setCorePoolSize(int):::Sets the core number of threads:::if->throw->new->IllegalArgumentException->delta->if->ctl->get->workerCountOf->interruptIdleWorkers->else->if->k->Math->workQueue->size->min->while->addWorker->if->workQueue->isEmpty->break
ThreadPoolExecutor#getCorePoolSize():::Returns the core number of threads.:::return
ThreadPoolExecutor#prestartCoreThread():::Starts a core thread, causing it to idly wait for work:::return->ctl->get->workerCountOf->addWorker
ThreadPoolExecutor#ensurePrestart():::Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.:::wc->ctl->get->workerCountOf->if->addWorker->else->if->addWorker
ThreadPoolExecutor#prestartAllCoreThreads():::Starts all core threads, causing them to idly wait for work:::n->while->addWorker->return
ThreadPoolExecutor#allowsCoreThreadTimeOut():::Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive:::return
ThreadPoolExecutor#allowCoreThreadTimeOut(boolean):::Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive:::if->throw->new->IllegalArgumentException->if->if->interruptIdleWorkers
ThreadPoolExecutor#setMaximumPoolSize(int):::Sets the maximum allowed number of threads:::if->throw->new->IllegalArgumentException->if->ctl->get->workerCountOf->interruptIdleWorkers
ThreadPoolExecutor#getMaximumPoolSize():::Returns the maximum allowed number of threads.:::return
ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit):::Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::if->throw->new->IllegalArgumentException->if->allowsCoreThreadTimeOut->throw->new->IllegalArgumentException->keepAliveTime->unit->toNanos->delta->if->interruptIdleWorkers
ThreadPoolExecutor#getKeepAliveTime(TimeUnit):::Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::return->unit->convert
ThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::return
ThreadPoolExecutor#remove(Runnable):::Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started:::removed->workQueue->remove->tryTerminate->return
ThreadPoolExecutor#purge():::Tries to remove from the work queue all Future tasks that have been cancelled:::q->try->it->q->iterator->while->it->hasNext->r->it->next->if->isCancelled->it->remove->catch->foreach->q->toArray->if->isCancelled->q->remove->finally->tryTerminate
ThreadPoolExecutor#getPoolSize():::Returns the current number of threads in the pool.:::mainLock->mainLock->lock->try->return->ctl->get->runStateAtLeast->workers->size->catch->finally->mainLock->unlock
ThreadPoolExecutor#getActiveCount():::Returns the approximate number of threads that are actively executing tasks.:::mainLock->mainLock->lock->try->n->foreach->if->w->isLocked->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#getLargestPoolSize():::Returns the largest number of threads that have ever simultaneously been in the pool.:::mainLock->mainLock->lock->try->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#getTaskCount():::Returns the approximate total number of tasks that have ever been scheduled for execution:::mainLock->mainLock->lock->try->n->foreach->if->w->isLocked->return->workQueue->size->catch->finally->mainLock->unlock
ThreadPoolExecutor#getCompletedTaskCount():::Returns the approximate total number of tasks that have completed execution:::mainLock->mainLock->lock->try->n->foreach->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#toString():::Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.:::ncompleted->nworkers->nactive->mainLock->mainLock->lock->try->workers->size->foreach->if->w->isLocked->catch->finally->mainLock->unlock->c->ctl->get->runState->isRunning->runStateAtLeast->return->super->toString->workQueue->size
ThreadPoolExecutor#beforeExecute(Thread, Runnable):::Method invoked prior to executing the given Runnable in the given thread:::
ThreadPoolExecutor#afterExecute(Runnable, Throwable):::Method invoked upon completion of execution of the given Runnable:::
ThreadPoolExecutor#terminated():::Method invoked when the Executor has terminated:::
ThreadPoolExecutor.CallerRunsPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.:::if->e->isShutdown->r->run
ThreadPoolExecutor.AbortPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Always throws RejectedExecutionException.:::throw->r->toString->e->toString->new->RejectedExecutionException
ThreadPoolExecutor.DiscardPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Does nothing, which has the effect of discarding task r.:::
ThreadPoolExecutor.DiscardOldestPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.:::if->e->isShutdown->e->getQueue->poll->e->execute
TransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::
TransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::
TransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::
TransferQueue#hasWaitingConsumer():::Returns true if there is at least one consumer waiting to receive an element via #take or timed #poll(long,TimeUnit) poll:::
TransferQueue#getWaitingConsumerCount():::Returns an estimate of the number of consumers waiting to receive elements via #take or timed #poll(long,TimeUnit) poll:::
