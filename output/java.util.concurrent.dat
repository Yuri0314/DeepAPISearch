java.util.concurrent.AbstractExecutorService#newTaskFor(Runnable, T)->RunnableFuture<T>:::Returns a {@code RunnableFuture} for the given runnable and default  value.
java.util.concurrent.AbstractExecutorService#newTaskFor(Callable<T>)->RunnableFuture<T>:::Returns a {@code RunnableFuture} for the given callable task.
java.util.concurrent.AbstractExecutorService#submit(Runnable)->Future<?>:::
java.util.concurrent.AbstractExecutorService#submit(Runnable, T)->Future<T>:::
java.util.concurrent.AbstractExecutorService#submit(Callable<T>)->Future<T>:::
java.util.concurrent.AbstractExecutorService#invokeAny(Collection<? extends Callable<T>>)->T:::
java.util.concurrent.AbstractExecutorService#invokeAny(Collection<? extends Callable<T>>, long, TimeUnit)->T:::
java.util.concurrent.AbstractExecutorService#invokeAll(Collection<? extends Callable<T>>)->List<Future<T>>:::
java.util.concurrent.AbstractExecutorService#invokeAll(Collection<? extends Callable<T>>, long, TimeUnit)->List<Future<T>>:::
java.util.concurrent.ArrayBlockingQueue#inc(int, int)->int:::Increments i, mod modulus
java.util.concurrent.ArrayBlockingQueue#dec(int, int)->int:::Decrements i, mod modulus
java.util.concurrent.ArrayBlockingQueue#itemAt(int)->E:::Returns item at index i.
java.util.concurrent.ArrayBlockingQueue#itemAt(Object[], int)->E:::Returns element at array index i
java.util.concurrent.ArrayBlockingQueue#removeAt(int)->void:::Deletes item at array index removeIndex
java.util.concurrent.ArrayBlockingQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue if it is  possible to do so immediately without exceeding the queue's capacity,  returning {@code true} upon success and throwing an  {@code IllegalStateException} if this queue is full.
java.util.concurrent.ArrayBlockingQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue if it is  possible to do so immediately without exceeding the queue's capacity,  returning {@code true} upon success and {@code false} if this queue  is full
java.util.concurrent.ArrayBlockingQueue#put(E)->void:::Inserts the specified element at the tail of this queue, waiting  for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue, waiting  up to the specified wait time for space to become available if  the queue is full.
java.util.concurrent.ArrayBlockingQueue#poll()->E:::
java.util.concurrent.ArrayBlockingQueue#take()->E:::
java.util.concurrent.ArrayBlockingQueue#poll(long, TimeUnit)->E:::
java.util.concurrent.ArrayBlockingQueue#peek()->E:::
java.util.concurrent.ArrayBlockingQueue#size()->int:::Returns the number of elements in this queue.
java.util.concurrent.ArrayBlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally  (in the absence of memory or resource constraints) accept without  blocking
java.util.concurrent.ArrayBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.ArrayBlockingQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.ArrayBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in  proper sequence
java.util.concurrent.ArrayBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in  proper sequence; the runtime type of the returned array is that of  the specified array
java.util.concurrent.ArrayBlockingQueue#toString()->String:::
java.util.concurrent.ArrayBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.ArrayBlockingQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.ArrayBlockingQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.ArrayBlockingQueue#iterator()->Iterator<E>:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.ArrayBlockingQueue.Itrs#doSomeSweeping(boolean)->void:::Sweeps itrs, looking for and expunging stale iterators
java.util.concurrent.ArrayBlockingQueue.Itrs#register(Itr)->void:::Adds a new iterator to the linked list of tracked iterators.
java.util.concurrent.ArrayBlockingQueue.Itrs#takeIndexWrapped()->void:::Called whenever takeIndex wraps around to 0
java.util.concurrent.ArrayBlockingQueue.Itrs#removedAt(int)->void:::Called whenever an interior remove (not at takeIndex) occurred
java.util.concurrent.ArrayBlockingQueue.Itrs#queueIsEmpty()->void:::Called whenever the queue becomes empty
java.util.concurrent.ArrayBlockingQueue.Itrs#elementDequeued()->void:::Called whenever an element has been dequeued (at takeIndex).
java.util.concurrent.ArrayBlockingQueue.Itr#isDetached()->boolean:::
java.util.concurrent.ArrayBlockingQueue.Itr#hasNext()->boolean:::For performance reasons, we would like not to acquire a lock in  hasNext in the common case
java.util.concurrent.ArrayBlockingQueue.Itr#next()->E:::
java.util.concurrent.ArrayBlockingQueue.Itr#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.ArrayBlockingQueue.Itr#remove()->void:::
java.util.concurrent.ArrayBlockingQueue.Itr#shutdown()->void:::Called to notify the iterator that the queue is empty, or that it  has fallen hopelessly behind, so that it should abandon any  further iteration, except possibly to return one more element  from next(), as promised by returning true from hasNext().
java.util.concurrent.ArrayBlockingQueue.Itr#removedAt(int)->boolean:::Called whenever an interior remove (not at takeIndex) occurred.
java.util.concurrent.ArrayBlockingQueue.Itr#takeIndexWrapped()->boolean:::Called whenever takeIndex wraps around to zero.
java.util.concurrent.ArrayBlockingQueue#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this queue
java.util.concurrent.ArrayBlockingQueue#forEach(Consumer<? super E>)->void:::
java.util.concurrent.ArrayBlockingQueue#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.ArrayBlockingQueue#removeAll(Collection<?>)->boolean:::
java.util.concurrent.ArrayBlockingQueue#retainAll(Collection<?>)->boolean:::
java.util.concurrent.ArrayBlockingQueue#checkInvariants()->void:::debugging
java.util.concurrent.BlockingDeque#addFirst(E)->void:::Inserts the specified element at the front of this deque if it is  possible to do so immediately without violating capacity restrictions,  throwing an {@code IllegalStateException} if no space is currently  available
java.util.concurrent.BlockingDeque#addLast(E)->void:::Inserts the specified element at the end of this deque if it is  possible to do so immediately without violating capacity restrictions,  throwing an {@code IllegalStateException} if no space is currently  available
java.util.concurrent.BlockingDeque#offerFirst(E)->boolean:::Inserts the specified element at the front of this deque if it is  possible to do so immediately without violating capacity restrictions,  returning {@code true} upon success and {@code false} if no space is  currently available
java.util.concurrent.BlockingDeque#offerLast(E)->boolean:::Inserts the specified element at the end of this deque if it is  possible to do so immediately without violating capacity restrictions,  returning {@code true} upon success and {@code false} if no space is  currently available
java.util.concurrent.BlockingDeque#putFirst(E)->void:::Inserts the specified element at the front of this deque,  waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque#putLast(E)->void:::Inserts the specified element at the end of this deque,  waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque#offerFirst(E, long, TimeUnit)->boolean:::Inserts the specified element at the front of this deque,  waiting up to the specified wait time if necessary for space to  become available.
java.util.concurrent.BlockingDeque#offerLast(E, long, TimeUnit)->boolean:::Inserts the specified element at the end of this deque,  waiting up to the specified wait time if necessary for space to  become available.
java.util.concurrent.BlockingDeque#takeFirst()->E:::Retrieves and removes the first element of this deque, waiting  if necessary until an element becomes available.
java.util.concurrent.BlockingDeque#takeLast()->E:::Retrieves and removes the last element of this deque, waiting  if necessary until an element becomes available.
java.util.concurrent.BlockingDeque#pollFirst(long, TimeUnit)->E:::Retrieves and removes the first element of this deque, waiting  up to the specified wait time if necessary for an element to  become available.
java.util.concurrent.BlockingDeque#pollLast(long, TimeUnit)->E:::Retrieves and removes the last element of this deque, waiting  up to the specified wait time if necessary for an element to  become available.
java.util.concurrent.BlockingDeque#removeFirstOccurrence(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#removeLastOccurrence(Object)->boolean:::Removes the last occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#add(E)->boolean:::Inserts the specified element into the queue represented by this deque  (in other words, at the tail of this deque) if it is possible to do so  immediately without violating capacity restrictions, returning  {@code true} upon success and throwing an  {@code IllegalStateException} if no space is currently available
java.util.concurrent.BlockingDeque#offer(E)->boolean:::Inserts the specified element into the queue represented by this deque  (in other words, at the tail of this deque) if it is possible to do so  immediately without violating capacity restrictions, returning  {@code true} upon success and {@code false} if no space is currently  available
java.util.concurrent.BlockingDeque#put(E)->void:::Inserts the specified element into the queue represented by this deque  (in other words, at the tail of this deque), waiting if necessary for  space to become available
java.util.concurrent.BlockingDeque#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into the queue represented by this deque  (in other words, at the tail of this deque), waiting up to the  specified wait time if necessary for space to become available
java.util.concurrent.BlockingDeque#remove()->E:::Retrieves and removes the head of the queue represented by this deque  (in other words, the first element of this deque)
java.util.concurrent.BlockingDeque#poll()->E:::Retrieves and removes the head of the queue represented by this deque  (in other words, the first element of this deque), or returns  {@code null} if this deque is empty
java.util.concurrent.BlockingDeque#take()->E:::Retrieves and removes the head of the queue represented by this deque  (in other words, the first element of this deque), waiting if  necessary until an element becomes available
java.util.concurrent.BlockingDeque#poll(long, TimeUnit)->E:::Retrieves and removes the head of the queue represented by this deque  (in other words, the first element of this deque), waiting up to the  specified wait time if necessary for an element to become available
java.util.concurrent.BlockingDeque#element()->E:::Retrieves, but does not remove, the head of the queue represented by  this deque (in other words, the first element of this deque)
java.util.concurrent.BlockingDeque#peek()->E:::Retrieves, but does not remove, the head of the queue represented by  this deque (in other words, the first element of this deque), or  returns {@code null} if this deque is empty
java.util.concurrent.BlockingDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#contains(Object)->boolean:::Returns {@code true} if this deque contains the specified element
java.util.concurrent.BlockingDeque#size()->int:::Returns the number of elements in this deque.
java.util.concurrent.BlockingDeque#iterator()->Iterator<E>:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.BlockingDeque#push(E)->void:::Pushes an element onto the stack represented by this deque (in other  words, at the head of this deque) if it is possible to do so  immediately without violating capacity restrictions, throwing an  {@code IllegalStateException} if no space is currently available
java.util.concurrent.BlockingQueue#add(E)->boolean:::Inserts the specified element into this queue if it is possible to do  so immediately without violating capacity restrictions, returning  {@code true} upon success and throwing an  {@code IllegalStateException} if no space is currently available
java.util.concurrent.BlockingQueue#offer(E)->boolean:::Inserts the specified element into this queue if it is possible to do  so immediately without violating capacity restrictions, returning  {@code true} upon success and {@code false} if no space is currently  available
java.util.concurrent.BlockingQueue#put(E)->void:::Inserts the specified element into this queue, waiting if necessary  for space to become available.
java.util.concurrent.BlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this queue, waiting up to the  specified wait time if necessary for space to become available.
java.util.concurrent.BlockingQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary  until an element becomes available.
java.util.concurrent.BlockingQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting up to the  specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally  (in the absence of memory or resource constraints) accept without  blocking, or {@code Integer.MAX_VALUE} if there is no intrinsic  limit
java.util.concurrent.BlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.BlockingQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.BlockingQueue#drainTo(Collection<? super E>)->int:::Removes all available elements from this queue and adds them  to the given collection
java.util.concurrent.BlockingQueue#drainTo(Collection<? super E>, int)->int:::Removes at most the given number of available elements from  this queue and adds them to the given collection
java.util.concurrent.Callable#call()->V:::Computes a result, or throws an exception if unable to do so.
java.util.concurrent.CompletableFuture#internalComplete(Object)->boolean:::
java.util.concurrent.CompletableFuture#tryPushStack(Completion)->boolean:::Returns true if successfully pushed c onto stack.
java.util.concurrent.CompletableFuture#pushStack(Completion)->void:::Unconditionally pushes c onto stack, retrying if necessary.
java.util.concurrent.CompletableFuture#completeNull()->boolean:::Completes with the null value, unless already completed.
java.util.concurrent.CompletableFuture#encodeValue(T)->Object:::Returns the encoding of the given non-exceptional value.
java.util.concurrent.CompletableFuture#completeValue(T)->boolean:::Completes with a non-exceptional result, unless already completed.
java.util.concurrent.CompletableFuture#encodeThrowable(Throwable)->AltResult:::Returns the encoding of the given (non-null) exception as a  wrapped CompletionException unless it is one already.
java.util.concurrent.CompletableFuture#completeThrowable(Throwable)->boolean:::Completes with an exceptional result, unless already completed.
java.util.concurrent.CompletableFuture#encodeThrowable(Throwable, Object)->Object:::Returns the encoding of the given (non-null) exception as a  wrapped CompletionException unless it is one already
java.util.concurrent.CompletableFuture#completeThrowable(Throwable, Object)->boolean:::Completes with the given (non-null) exceptional result as a  wrapped CompletionException unless it is one already, unless  already completed
java.util.concurrent.CompletableFuture#encodeOutcome(T, Throwable)->Object:::Returns the encoding of the given arguments: if the exception  is non-null, encodes as AltResult
java.util.concurrent.CompletableFuture#encodeRelay(Object)->Object:::Returns the encoding of a copied outcome; if exceptional,  rewraps as a CompletionException, else returns argument.
java.util.concurrent.CompletableFuture#completeRelay(Object)->boolean:::Completes with r or a copy of r, unless already completed
java.util.concurrent.CompletableFuture.ThreadPerTaskExecutor#execute(Runnable)->void:::
java.util.concurrent.CompletableFuture#screenExecutor(Executor)->Executor:::Null-checks user executor argument, and translates uses of  commonPool to ASYNC_POOL in case parallelism disabled.
java.util.concurrent.CompletableFuture.Completion#tryFire(int)->CompletableFuture<?>:::Performs completion action if triggered, returning a  dependent that may need propagation, if one exists.
java.util.concurrent.CompletableFuture.Completion#isLive()->boolean:::Returns true if possibly still triggerable
java.util.concurrent.CompletableFuture.Completion#run()->void:::
java.util.concurrent.CompletableFuture.Completion#exec()->boolean:::
java.util.concurrent.CompletableFuture.Completion#getRawResult()->Void:::
java.util.concurrent.CompletableFuture.Completion#setRawResult(Void)->void:::
java.util.concurrent.CompletableFuture#postComplete()->void:::Pops and tries to trigger all reachable dependents
java.util.concurrent.CompletableFuture#cleanStack()->void:::Traverses stack and unlinks one or more dead Completions, if found.
java.util.concurrent.CompletableFuture.UniCompletion#claim()->boolean:::Returns true if action can be run
java.util.concurrent.CompletableFuture.UniCompletion#isLive()->boolean:::
java.util.concurrent.CompletableFuture#unipush(Completion)->void:::Pushes the given completion unless it completes while trying
java.util.concurrent.CompletableFuture#postFire(CompletableFuture<?>, int)->CompletableFuture<T>:::Post-processing by dependent after successful UniCompletion tryFire
java.util.concurrent.CompletableFuture.UniApply#tryFire(int)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture.UniAccept#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture.UniRun#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture.UniWhenComplete#tryFire(int)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture#uniWhenComplete(Object, BiConsumer<? super T, ? super Throwable>, UniWhenComplete<T>)->boolean:::
java.util.concurrent.CompletableFuture.UniHandle#tryFire(int)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture#uniHandle(Object, BiFunction<? super S, Throwable, ? extends T>, UniHandle<S, T>)->boolean:::
java.util.concurrent.CompletableFuture.UniExceptionally#tryFire(int)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture#uniExceptionally(Object, Function<? super Throwable, ? extends T>, UniExceptionally<T>)->boolean:::
java.util.concurrent.CompletableFuture.UniRelay#tryFire(int)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture.UniCompose#tryFire(int)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture.CoCompletion#tryFire(int)->CompletableFuture<?>:::
java.util.concurrent.CompletableFuture.CoCompletion#isLive()->boolean:::
java.util.concurrent.CompletableFuture#bipush(CompletableFuture<?>, BiCompletion<?, ?, ?>)->void:::Pushes completion to this and b unless both done
java.util.concurrent.CompletableFuture#postFire(CompletableFuture<?>, CompletableFuture<?>, int)->CompletableFuture<T>:::Post-processing after successful BiCompletion tryFire.
java.util.concurrent.CompletableFuture.BiApply#tryFire(int)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture#biApply(Object, Object, BiFunction<? super R, ? super S, ? extends T>, BiApply<R, S, T>)->boolean:::
java.util.concurrent.CompletableFuture.BiAccept#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#biAccept(Object, Object, BiConsumer<? super R, ? super S>, BiAccept<R, S>)->boolean:::
java.util.concurrent.CompletableFuture.BiRun#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#biRun(Object, Object, Runnable, BiRun<?, ?>)->boolean:::
java.util.concurrent.CompletableFuture.BiRelay#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#andTree(CompletableFuture<?>[], int, int)->CompletableFuture<Void>:::Recursively constructs a tree of completions.
java.util.concurrent.CompletableFuture#orpush(CompletableFuture<?>, BiCompletion<?, ?, ?>)->void:::Pushes completion to this and b unless either done
java.util.concurrent.CompletableFuture.OrApply#tryFire(int)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture.OrAccept#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture.OrRun#tryFire(int)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture.AnyOf#tryFire(int)->CompletableFuture<Object>:::
java.util.concurrent.CompletableFuture.AnyOf#isLive()->boolean:::
java.util.concurrent.CompletableFuture.AsyncSupply#getRawResult()->Void:::
java.util.concurrent.CompletableFuture.AsyncSupply#setRawResult(Void)->void:::
java.util.concurrent.CompletableFuture.AsyncSupply#exec()->boolean:::
java.util.concurrent.CompletableFuture.AsyncSupply#run()->void:::
java.util.concurrent.CompletableFuture#asyncSupplyStage(Executor, Supplier<U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture.AsyncRun#getRawResult()->Void:::
java.util.concurrent.CompletableFuture.AsyncRun#setRawResult(Void)->void:::
java.util.concurrent.CompletableFuture.AsyncRun#exec()->boolean:::
java.util.concurrent.CompletableFuture.AsyncRun#run()->void:::
java.util.concurrent.CompletableFuture#asyncRunStage(Executor, Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture.Signaller#tryFire(int)->CompletableFuture<?>:::
java.util.concurrent.CompletableFuture.Signaller#isReleasable()->boolean:::
java.util.concurrent.CompletableFuture.Signaller#block()->boolean:::
java.util.concurrent.CompletableFuture.Signaller#isLive()->boolean:::
java.util.concurrent.CompletableFuture#supplyAsync(Supplier<U>)->CompletableFuture<U>:::Returns a new CompletableFuture that is asynchronously completed  by a task running in the {@link ForkJoinPool#commonPool()} with  the value obtained by calling the given Supplier.
java.util.concurrent.CompletableFuture#supplyAsync(Supplier<U>, Executor)->CompletableFuture<U>:::Returns a new CompletableFuture that is asynchronously completed  by a task running in the given executor with the value obtained  by calling the given Supplier.
java.util.concurrent.CompletableFuture#runAsync(Runnable)->CompletableFuture<Void>:::Returns a new CompletableFuture that is asynchronously completed  by a task running in the {@link ForkJoinPool#commonPool()} after  it runs the given action.
java.util.concurrent.CompletableFuture#runAsync(Runnable, Executor)->CompletableFuture<Void>:::Returns a new CompletableFuture that is asynchronously completed  by a task running in the given executor after it runs the given  action.
java.util.concurrent.CompletableFuture#completedFuture(U)->CompletableFuture<U>:::Returns a new CompletableFuture that is already completed with  the given value.
java.util.concurrent.CompletableFuture#isDone()->boolean:::Returns {@code true} if completed in any fashion: normally,  exceptionally, or via cancellation.
java.util.concurrent.CompletableFuture#get()->T:::Waits if necessary for this future to complete, and then  returns its result.
java.util.concurrent.CompletableFuture#get(long, TimeUnit)->T:::Waits if necessary for at most the given time for this future  to complete, and then returns its result, if available.
java.util.concurrent.CompletableFuture#join()->T:::Returns the result value when complete, or throws an  (unchecked) exception if completed exceptionally
java.util.concurrent.CompletableFuture#getNow(T)->T:::Returns the result value (or throws any encountered exception)  if completed, else returns the given valueIfAbsent.
java.util.concurrent.CompletableFuture#complete(T)->boolean:::If not already completed, sets the value returned by {@link  #get()} and related methods to the given value.
java.util.concurrent.CompletableFuture#completeExceptionally(Throwable)->boolean:::If not already completed, causes invocations of {@link #get()}  and related methods to throw the given exception.
java.util.concurrent.CompletableFuture#thenApply(Function<? super T, ? extends U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#thenApplyAsync(Function<? super T, ? extends U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#thenApplyAsync(Function<? super T, ? extends U>, Executor)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#thenAccept(Consumer<? super T>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenAcceptAsync(Consumer<? super T>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenAcceptAsync(Consumer<? super T>, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenRun(Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenRunAsync(Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenRunAsync(Runnable, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenCombine(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture#thenCombineAsync(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture#thenCombineAsync(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>, Executor)->CompletableFuture<V>:::
java.util.concurrent.CompletableFuture#thenAcceptBoth(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenAcceptBothAsync(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenAcceptBothAsync(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterBoth(CompletionStage<?>, Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterBothAsync(CompletionStage<?>, Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterBothAsync(CompletionStage<?>, Runnable, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#applyToEither(CompletionStage<? extends T>, Function<? super T, U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#applyToEitherAsync(CompletionStage<? extends T>, Function<? super T, U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#applyToEitherAsync(CompletionStage<? extends T>, Function<? super T, U>, Executor)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#acceptEither(CompletionStage<? extends T>, Consumer<? super T>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#acceptEitherAsync(CompletionStage<? extends T>, Consumer<? super T>)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#acceptEitherAsync(CompletionStage<? extends T>, Consumer<? super T>, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterEither(CompletionStage<?>, Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterEitherAsync(CompletionStage<?>, Runnable)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#runAfterEitherAsync(CompletionStage<?>, Runnable, Executor)->CompletableFuture<Void>:::
java.util.concurrent.CompletableFuture#thenCompose(Function<? super T, ? extends CompletionStage<U>>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#thenComposeAsync(Function<? super T, ? extends CompletionStage<U>>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#thenComposeAsync(Function<? super T, ? extends CompletionStage<U>>, Executor)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#whenComplete(BiConsumer<? super T, ? super Throwable>)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture#whenCompleteAsync(BiConsumer<? super T, ? super Throwable>)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture#whenCompleteAsync(BiConsumer<? super T, ? super Throwable>, Executor)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture#handle(BiFunction<? super T, Throwable, ? extends U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#handleAsync(BiFunction<? super T, Throwable, ? extends U>)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#handleAsync(BiFunction<? super T, Throwable, ? extends U>, Executor)->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture#toCompletableFuture()->CompletableFuture<T>:::Returns this CompletableFuture.
java.util.concurrent.CompletableFuture#exceptionally(Function<Throwable, ? extends T>)->CompletableFuture<T>:::Returns a new CompletableFuture that is completed when this  CompletableFuture completes, with the result of the given  function of the exception triggering this CompletableFuture's  completion when it completes exceptionally; otherwise, if this  CompletableFuture completes normally, then the returned  CompletableFuture also completes normally with the same value
java.util.concurrent.CompletableFuture#allOf(CompletableFuture<?>...)->CompletableFuture<Void>:::Returns a new CompletableFuture that is completed when all of  the given CompletableFutures complete
java.util.concurrent.CompletableFuture#anyOf(CompletableFuture<?>...)->CompletableFuture<Object>:::Returns a new CompletableFuture that is completed when any of  the given CompletableFutures complete, with the same result
java.util.concurrent.CompletableFuture#cancel(boolean)->boolean:::If not already completed, completes this CompletableFuture with  a {@link CancellationException}
java.util.concurrent.CompletableFuture#isCancelled()->boolean:::Returns {@code true} if this CompletableFuture was cancelled  before it completed normally.
java.util.concurrent.CompletableFuture#isCompletedExceptionally()->boolean:::Returns {@code true} if this CompletableFuture completed  exceptionally, in any way
java.util.concurrent.CompletableFuture#obtrudeValue(T)->void:::Forcibly sets or resets the value subsequently returned by  method {@link #get()} and related methods, whether or not  already completed
java.util.concurrent.CompletableFuture#obtrudeException(Throwable)->void:::Forcibly causes subsequent invocations of method {@link #get()}  and related methods to throw the given exception, whether or  not already completed
java.util.concurrent.CompletableFuture#getNumberOfDependents()->int:::Returns the estimated number of CompletableFutures whose  completions are awaiting completion of this CompletableFuture
java.util.concurrent.CompletableFuture#toString()->String:::Returns a string identifying this CompletableFuture, as well as  its completion state
java.util.concurrent.CompletableFuture#newIncompleteFuture()->CompletableFuture<U>:::Returns a new incomplete CompletableFuture of the type to be  returned by a CompletionStage method
java.util.concurrent.CompletableFuture#defaultExecutor()->Executor:::Returns the default Executor used for async methods that do not  specify an Executor
java.util.concurrent.CompletableFuture#copy()->CompletableFuture<T>:::Returns a new CompletableFuture that is completed normally with  the same value as this CompletableFuture when it completes  normally
java.util.concurrent.CompletableFuture#minimalCompletionStage()->CompletionStage<T>:::Returns a new CompletionStage that is completed normally with  the same value as this CompletableFuture when it completes  normally, and cannot be independently completed or otherwise  used in ways not defined by the methods of interface {@link  CompletionStage}
java.util.concurrent.CompletableFuture#completeAsync(Supplier<? extends T>, Executor)->CompletableFuture<T>:::Completes this CompletableFuture with the result of  the given Supplier function invoked from an asynchronous  task using the given executor.
java.util.concurrent.CompletableFuture#completeAsync(Supplier<? extends T>)->CompletableFuture<T>:::Completes this CompletableFuture with the result of the given  Supplier function invoked from an asynchronous task using the  default executor.
java.util.concurrent.CompletableFuture#orTimeout(long, TimeUnit)->CompletableFuture<T>:::Exceptionally completes this CompletableFuture with  a {@link TimeoutException} if not otherwise completed  before the given timeout.
java.util.concurrent.CompletableFuture#completeOnTimeout(T, long, TimeUnit)->CompletableFuture<T>:::Completes this CompletableFuture with the given value if not  otherwise completed before the given timeout.
java.util.concurrent.CompletableFuture#delayedExecutor(long, TimeUnit, Executor)->Executor:::Returns a new Executor that submits a task to the given base  executor after the given delay (or no delay if non-positive)
java.util.concurrent.CompletableFuture#delayedExecutor(long, TimeUnit)->Executor:::Returns a new Executor that submits a task to the default  executor after the given delay (or no delay if non-positive)
java.util.concurrent.CompletableFuture#completedStage(U)->CompletionStage<U>:::Returns a new CompletionStage that is already completed with  the given value and supports only those methods in  interface {@link CompletionStage}.
java.util.concurrent.CompletableFuture#failedFuture(Throwable)->CompletableFuture<U>:::Returns a new CompletableFuture that is already completed  exceptionally with the given exception.
java.util.concurrent.CompletableFuture#failedStage(Throwable)->CompletionStage<U>:::Returns a new CompletionStage that is already completed  exceptionally with the given exception and supports only those  methods in interface {@link CompletionStage}.
java.util.concurrent.CompletableFuture.Delayer#delay(Runnable, long, TimeUnit)->ScheduledFuture<?>:::
java.util.concurrent.CompletableFuture.Delayer.DaemonThreadFactory#newThread(Runnable)->Thread:::
java.util.concurrent.CompletableFuture.DelayedExecutor#execute(Runnable)->void:::
java.util.concurrent.CompletableFuture.TaskSubmitter#run()->void:::
java.util.concurrent.CompletableFuture.Timeout#run()->void:::
java.util.concurrent.CompletableFuture.DelayedCompleter#run()->void:::
java.util.concurrent.CompletableFuture.Canceller#accept(Object, Throwable)->void:::
java.util.concurrent.CompletableFuture.MinimalStage#newIncompleteFuture()->CompletableFuture<U>:::
java.util.concurrent.CompletableFuture.MinimalStage#get()->T:::
java.util.concurrent.CompletableFuture.MinimalStage#get(long, TimeUnit)->T:::
java.util.concurrent.CompletableFuture.MinimalStage#getNow(T)->T:::
java.util.concurrent.CompletableFuture.MinimalStage#join()->T:::
java.util.concurrent.CompletableFuture.MinimalStage#complete(T)->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#completeExceptionally(Throwable)->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#cancel(boolean)->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#obtrudeValue(T)->void:::
java.util.concurrent.CompletableFuture.MinimalStage#obtrudeException(Throwable)->void:::
java.util.concurrent.CompletableFuture.MinimalStage#isDone()->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#isCancelled()->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#isCompletedExceptionally()->boolean:::
java.util.concurrent.CompletableFuture.MinimalStage#getNumberOfDependents()->int:::
java.util.concurrent.CompletableFuture.MinimalStage#completeAsync(Supplier<? extends T>, Executor)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture.MinimalStage#completeAsync(Supplier<? extends T>)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture.MinimalStage#orTimeout(long, TimeUnit)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture.MinimalStage#completeOnTimeout(T, long, TimeUnit)->CompletableFuture<T>:::
java.util.concurrent.CompletableFuture.MinimalStage#toCompletableFuture()->CompletableFuture<T>:::
java.util.concurrent.CompletionService#submit(Callable<V>)->Future<V>:::Submits a value-returning task for execution and returns a Future  representing the pending results of the task
java.util.concurrent.CompletionService#submit(Runnable, V)->Future<V>:::Submits a Runnable task for execution and returns a Future  representing that task
java.util.concurrent.CompletionService#take()->Future<V>:::Retrieves and removes the Future representing the next  completed task, waiting if none are yet present.
java.util.concurrent.CompletionService#poll()->Future<V>:::Retrieves and removes the Future representing the next  completed task, or {@code null} if none are present.
java.util.concurrent.CompletionService#poll(long, TimeUnit)->Future<V>:::Retrieves and removes the Future representing the next  completed task, waiting if necessary up to the specified wait  time if none are yet present.
java.util.concurrent.CompletionStage#thenApply(Function<? super T, ? extends U>)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  normally, is executed with this stage's result as the argument  to the supplied function
java.util.concurrent.CompletionStage#thenApplyAsync(Function<? super T, ? extends U>)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  normally, is executed using this stage's default asynchronous  execution facility, with this stage's result as the argument to  the supplied function
java.util.concurrent.CompletionStage#thenApplyAsync(Function<? super T, ? extends U>, Executor)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  normally, is executed using the supplied Executor, with this  stage's result as the argument to the supplied function
java.util.concurrent.CompletionStage#thenAccept(Consumer<? super T>)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, is executed with this stage's result as the argument  to the supplied action
java.util.concurrent.CompletionStage#thenAcceptAsync(Consumer<? super T>)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, is executed using this stage's default asynchronous  execution facility, with this stage's result as the argument to  the supplied action
java.util.concurrent.CompletionStage#thenAcceptAsync(Consumer<? super T>, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, is executed using the supplied Executor, with this  stage's result as the argument to the supplied action
java.util.concurrent.CompletionStage#thenRun(Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, executes the given action
java.util.concurrent.CompletionStage#thenRunAsync(Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, executes the given action using this stage's default  asynchronous execution facility
java.util.concurrent.CompletionStage#thenRunAsync(Runnable, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when this stage completes  normally, executes the given action using the supplied Executor
java.util.concurrent.CompletionStage#thenCombine(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>)->CompletionStage<V>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed with the two  results as arguments to the supplied function
java.util.concurrent.CompletionStage#thenCombineAsync(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>)->CompletionStage<V>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed using this  stage's default asynchronous execution facility, with the two  results as arguments to the supplied function
java.util.concurrent.CompletionStage#thenCombineAsync(CompletionStage<? extends U>, BiFunction<? super T, ? super U, ? extends V>, Executor)->CompletionStage<V>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed using the  supplied executor, with the two results as arguments to the  supplied function
java.util.concurrent.CompletionStage#thenAcceptBoth(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed with the two  results as arguments to the supplied action
java.util.concurrent.CompletionStage#thenAcceptBothAsync(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed using this  stage's default asynchronous execution facility, with the two  results as arguments to the supplied action
java.util.concurrent.CompletionStage#thenAcceptBothAsync(CompletionStage<? extends U>, BiConsumer<? super T, ? super U>, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, is executed using the  supplied executor, with the two results as arguments to the  supplied action
java.util.concurrent.CompletionStage#runAfterBoth(CompletionStage<?>, Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, executes the given action
java.util.concurrent.CompletionStage#runAfterBothAsync(CompletionStage<?>, Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, executes the given action  using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#runAfterBothAsync(CompletionStage<?>, Runnable, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when this and the other  given stage both complete normally, executes the given action  using the supplied executor
java.util.concurrent.CompletionStage#applyToEither(CompletionStage<? extends T>, Function<? super T, U>)->CompletionStage<U>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed with the  corresponding result as argument to the supplied function
java.util.concurrent.CompletionStage#applyToEitherAsync(CompletionStage<? extends T>, Function<? super T, U>)->CompletionStage<U>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed using this  stage's default asynchronous execution facility, with the  corresponding result as argument to the supplied function
java.util.concurrent.CompletionStage#applyToEitherAsync(CompletionStage<? extends T>, Function<? super T, U>, Executor)->CompletionStage<U>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed using the  supplied executor, with the corresponding result as argument to  the supplied function
java.util.concurrent.CompletionStage#acceptEither(CompletionStage<? extends T>, Consumer<? super T>)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed with the  corresponding result as argument to the supplied action
java.util.concurrent.CompletionStage#acceptEitherAsync(CompletionStage<? extends T>, Consumer<? super T>)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed using this  stage's default asynchronous execution facility, with the  corresponding result as argument to the supplied action
java.util.concurrent.CompletionStage#acceptEitherAsync(CompletionStage<? extends T>, Consumer<? super T>, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, is executed using the  supplied executor, with the corresponding result as argument to  the supplied action
java.util.concurrent.CompletionStage#runAfterEither(CompletionStage<?>, Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, executes the given action
java.util.concurrent.CompletionStage#runAfterEitherAsync(CompletionStage<?>, Runnable)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, executes the given action  using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#runAfterEitherAsync(CompletionStage<?>, Runnable, Executor)->CompletionStage<Void>:::Returns a new CompletionStage that, when either this or the  other given stage complete normally, executes the given action  using the supplied executor
java.util.concurrent.CompletionStage#thenCompose(Function<? super T, ? extends CompletionStage<U>>)->CompletionStage<U>:::Returns a new CompletionStage that is completed with the same  value as the CompletionStage returned by the given function
java.util.concurrent.CompletionStage#thenComposeAsync(Function<? super T, ? extends CompletionStage<U>>)->CompletionStage<U>:::Returns a new CompletionStage that is completed with the same  value as the CompletionStage returned by the given function,  executed using this stage's default asynchronous execution  facility
java.util.concurrent.CompletionStage#thenComposeAsync(Function<? super T, ? extends CompletionStage<U>>, Executor)->CompletionStage<U>:::Returns a new CompletionStage that is completed with the same  value as the CompletionStage returned by the given function,  executed using the supplied Executor
java.util.concurrent.CompletionStage#handle(BiFunction<? super T, Throwable, ? extends U>)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  either normally or exceptionally, is executed with this stage's  result and exception as arguments to the supplied function
java.util.concurrent.CompletionStage#handleAsync(BiFunction<? super T, Throwable, ? extends U>)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  either normally or exceptionally, is executed using this stage's  default asynchronous execution facility, with this stage's  result and exception as arguments to the supplied function
java.util.concurrent.CompletionStage#handleAsync(BiFunction<? super T, Throwable, ? extends U>, Executor)->CompletionStage<U>:::Returns a new CompletionStage that, when this stage completes  either normally or exceptionally, is executed using the  supplied executor, with this stage's result and exception as  arguments to the supplied function
java.util.concurrent.CompletionStage#whenComplete(BiConsumer<? super T, ? super Throwable>)->CompletionStage<T>:::Returns a new CompletionStage with the same result or exception as  this stage, that executes the given action when this stage completes
java.util.concurrent.CompletionStage#whenCompleteAsync(BiConsumer<? super T, ? super Throwable>)->CompletionStage<T>:::Returns a new CompletionStage with the same result or exception as  this stage, that executes the given action using this stage's  default asynchronous execution facility when this stage completes
java.util.concurrent.CompletionStage#whenCompleteAsync(BiConsumer<? super T, ? super Throwable>, Executor)->CompletionStage<T>:::Returns a new CompletionStage with the same result or exception as  this stage, that executes the given action using the supplied  Executor when this stage completes
java.util.concurrent.CompletionStage#exceptionally(Function<Throwable, ? extends T>)->CompletionStage<T>:::Returns a new CompletionStage that, when this stage completes  exceptionally, is executed with this stage's exception as the  argument to the supplied function
java.util.concurrent.CompletionStage#toCompletableFuture()->CompletableFuture<T>:::Returns a {@link CompletableFuture} maintaining the same  completion properties as this stage
java.util.concurrent.ConcurrentHashMap.Node#getKey()->K:::
java.util.concurrent.ConcurrentHashMap.Node#getValue()->V:::
java.util.concurrent.ConcurrentHashMap.Node#hashCode()->int:::
java.util.concurrent.ConcurrentHashMap.Node#toString()->String:::
java.util.concurrent.ConcurrentHashMap.Node#setValue(V)->V:::
java.util.concurrent.ConcurrentHashMap.Node#equals(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.Node#V> find(int, Object)->Node<K,:::Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap#spread(int)->int:::Spreads (XORs) higher bits of hash to lower and also forces top  bit to 0
java.util.concurrent.ConcurrentHashMap#comparableClassFor(Object)->Class<?>:::Returns x's Class if it is of the form "class C implements  Comparable<C>", else null.
java.util.concurrent.ConcurrentHashMap#compareComparables(Class<?>, Object, Object)->int:::Returns k.compareTo(x) if x matches kc (k's screened comparable  class), else 0.
java.util.concurrent.ConcurrentHashMap#V> tabAt(Node<K, V>[], int)->Node<K,:::
java.util.concurrent.ConcurrentHashMap#casTabAt(Node<K, V>[], int, Node<K, V>, Node<K, V>)->boolean:::
java.util.concurrent.ConcurrentHashMap#setTabAt(Node<K, V>[], int, Node<K, V>)->void:::
java.util.concurrent.ConcurrentHashMap#size()->int:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#isEmpty()->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#get(Object)->V:::Returns the value to which the specified key is mapped,  or {@code null} if this map contains no mapping for the key
java.util.concurrent.ConcurrentHashMap#containsKey(Object)->boolean:::Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap#containsValue(Object)->boolean:::Returns {@code true} if this map maps one or more keys to the  specified value
java.util.concurrent.ConcurrentHashMap#put(K, V)->V:::Maps the specified key to the specified value in this table
java.util.concurrent.ConcurrentHashMap#putVal(K, V, boolean)->V:::Implementation for put and putIfAbsent
java.util.concurrent.ConcurrentHashMap#putAll(Map<? extends K, ? extends V>)->void:::Copies all of the mappings from the specified map to this one
java.util.concurrent.ConcurrentHashMap#remove(Object)->V:::Removes the key (and its corresponding value) from this map
java.util.concurrent.ConcurrentHashMap#replaceNode(Object, V, Object)->V:::Implementation for the four public remove/replace methods:  Replaces node value with v, conditional upon match of cv if  non-null
java.util.concurrent.ConcurrentHashMap#clear()->void:::Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap#V> keySet()->KeySetView<K,:::Returns a {@link Set} view of the keys contained in this map
java.util.concurrent.ConcurrentHashMap#values()->Collection<V>:::Returns a {@link Collection} view of the values contained in this map
java.util.concurrent.ConcurrentHashMap#V>> entrySet()->Set<Map.Entry<K,:::Returns a {@link Set} view of the mappings contained in this map
java.util.concurrent.ConcurrentHashMap#hashCode()->int:::Returns the hash code value for this {@link Map}, i.e.,  the sum of, for each key-value pair in the map,  {@code key.hashCode() ^ value.hashCode()}.
java.util.concurrent.ConcurrentHashMap#toString()->String:::Returns a string representation of this map
java.util.concurrent.ConcurrentHashMap#equals(Object)->boolean:::Compares the specified object with this map for equality
java.util.concurrent.ConcurrentHashMap#putIfAbsent(K, V)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#remove(Object, Object)->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#replace(K, V, V)->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#replace(K, V)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap#getOrDefault(Object, V)->V:::Returns the value to which the specified key is mapped, or the  given default value if this map contains no mapping for the  key.
java.util.concurrent.ConcurrentHashMap#forEach(BiConsumer<? super K, ? super V>)->void:::
java.util.concurrent.ConcurrentHashMap#replaceAll(BiFunction<? super K, ? super V, ? extends V>)->void:::
java.util.concurrent.ConcurrentHashMap#removeEntryIf(Predicate<? super Entry<K, V>>)->boolean:::Helper method for EntrySetView.removeIf.
java.util.concurrent.ConcurrentHashMap#removeValueIf(Predicate<? super V>)->boolean:::Helper method for ValuesView.removeIf.
java.util.concurrent.ConcurrentHashMap#computeIfAbsent(K, Function<? super K, ? extends V>)->V:::If the specified key is not already associated with a value,  attempts to compute its value using the given mapping function  and enters it into this map unless {@code null}
java.util.concurrent.ConcurrentHashMap#computeIfPresent(K, BiFunction<? super K, ? super V, ? extends V>)->V:::If the value for the specified key is present, attempts to  compute a new mapping given the key and its current mapped  value
java.util.concurrent.ConcurrentHashMap#compute(K, BiFunction<? super K, ? super V, ? extends V>)->V:::Attempts to compute a mapping for the specified key and its  current mapped value (or {@code null} if there is no current  mapping)
java.util.concurrent.ConcurrentHashMap#merge(K, V, BiFunction<? super V, ? super V, ? extends V>)->V:::If the specified key is not already associated with a  (non-null) value, associates it with the given value
java.util.concurrent.ConcurrentHashMap#contains(Object)->boolean:::Tests if some key maps into the specified value in this table
java.util.concurrent.ConcurrentHashMap#keys()->Enumeration<K>:::Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap#elements()->Enumeration<V>:::Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap#mappingCount()->long:::Returns the number of mappings
java.util.concurrent.ConcurrentHashMap#Boolean> newKeySet()->KeySetView<K,:::Creates a new {@link Set} backed by a ConcurrentHashMap  from the given type to {@code Boolean.TRUE}.
java.util.concurrent.ConcurrentHashMap#Boolean> newKeySet(int)->KeySetView<K,:::Creates a new {@link Set} backed by a ConcurrentHashMap  from the given type to {@code Boolean.TRUE}.
java.util.concurrent.ConcurrentHashMap#V> keySet(V)->KeySetView<K,:::Returns a {@link Set} view of the keys in this map, using the  given common mapped value for any additions (i.e., {@link  Collection#add} and {@link Collection#addAll(Collection)})
java.util.concurrent.ConcurrentHashMap.ForwardingNode#V> find(int, Object)->Node<K,:::
java.util.concurrent.ConcurrentHashMap.ReservationNode#V> find(int, Object)->Node<K,:::
java.util.concurrent.ConcurrentHashMap#resizeStamp(int)->int:::Returns the stamp bits for resizing a table of size n
java.util.concurrent.ConcurrentHashMap#V>[] helpTransfer(Node<K, V>[], Node<K, V>)->Node<K,:::Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap#sumCount()->long:::
java.util.concurrent.ConcurrentHashMap#V> untreeify(Node<K, V>)->Node<K,:::Returns a list of non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap.TreeNode#V> find(int, Object)->Node<K,:::
java.util.concurrent.ConcurrentHashMap.TreeNode#V> findTreeNode(int, Object, Class<?>)->TreeNode<K,:::Returns the TreeNode (or null if not found) for the given key  starting at given root.
java.util.concurrent.ConcurrentHashMap.TreeBin#tieBreakOrder(Object, Object)->int:::Tie-breaking utility for ordering insertions when equal  hashCodes and non-comparable
java.util.concurrent.ConcurrentHashMap.TreeBin#V> find(int, Object)->Node<K,:::Returns matching node or null if none
java.util.concurrent.ConcurrentHashMap.TreeBin#V> putTreeVal(int, K, V)->TreeNode<K,:::Finds or adds a node.
java.util.concurrent.ConcurrentHashMap.TreeBin#removeTreeNode(TreeNode<K, V>)->boolean:::Removes the given node, that must be present before this  call
java.util.concurrent.ConcurrentHashMap.TreeBin#V> rotateLeft(TreeNode<K, V>, TreeNode<K, V>)->TreeNode<K,:::
java.util.concurrent.ConcurrentHashMap.TreeBin#V> rotateRight(TreeNode<K, V>, TreeNode<K, V>)->TreeNode<K,:::
java.util.concurrent.ConcurrentHashMap.TreeBin#V> balanceInsertion(TreeNode<K, V>, TreeNode<K, V>)->TreeNode<K,:::
java.util.concurrent.ConcurrentHashMap.TreeBin#V> balanceDeletion(TreeNode<K, V>, TreeNode<K, V>)->TreeNode<K,:::
java.util.concurrent.ConcurrentHashMap.TreeBin#checkInvariants(TreeNode<K, V>)->boolean:::Checks invariants recursively for the tree of Nodes rooted at t.
java.util.concurrent.ConcurrentHashMap.Traverser#V> advance()->Node<K,:::Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap.BaseIterator#hasNext()->boolean:::
java.util.concurrent.ConcurrentHashMap.BaseIterator#hasMoreElements()->boolean:::
java.util.concurrent.ConcurrentHashMap.BaseIterator#remove()->void:::
java.util.concurrent.ConcurrentHashMap.KeyIterator#next()->K:::
java.util.concurrent.ConcurrentHashMap.KeyIterator#nextElement()->K:::
java.util.concurrent.ConcurrentHashMap.ValueIterator#next()->V:::
java.util.concurrent.ConcurrentHashMap.ValueIterator#nextElement()->V:::
java.util.concurrent.ConcurrentHashMap.EntryIterator#V> next()->Map.Entry<K,:::
java.util.concurrent.ConcurrentHashMap.MapEntry#getKey()->K:::
java.util.concurrent.ConcurrentHashMap.MapEntry#getValue()->V:::
java.util.concurrent.ConcurrentHashMap.MapEntry#hashCode()->int:::
java.util.concurrent.ConcurrentHashMap.MapEntry#toString()->String:::
java.util.concurrent.ConcurrentHashMap.MapEntry#equals(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.MapEntry#setValue(V)->V:::Sets our entry's value and writes through to the map
java.util.concurrent.ConcurrentHashMap.KeySpliterator#V> trySplit()->KeySpliterator<K,:::
java.util.concurrent.ConcurrentHashMap.KeySpliterator#forEachRemaining(Consumer<? super K>)->void:::
java.util.concurrent.ConcurrentHashMap.KeySpliterator#tryAdvance(Consumer<? super K>)->boolean:::
java.util.concurrent.ConcurrentHashMap.KeySpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentHashMap.KeySpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#V> trySplit()->ValueSpliterator<K,:::
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#forEachRemaining(Consumer<? super V>)->void:::
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#tryAdvance(Consumer<? super V>)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#V> trySplit()->EntrySpliterator<K,:::
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#forEachRemaining(Consumer<? super Map.Entry<K, V>>)->void:::
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#tryAdvance(Consumer<? super Map.Entry<K, V>>)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentHashMap#batchFor(long)->int:::Computes initial batch value for bulk tasks
java.util.concurrent.ConcurrentHashMap#forEach(long, BiConsumer<? super K, ? super V>)->void:::Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap#forEach(long, BiFunction<? super K, ? super V, ? extends U>, Consumer<? super U>)->void:::Performs the given action for each non-null transformation  of each (key, value).
java.util.concurrent.ConcurrentHashMap#search(long, BiFunction<? super K, ? super V, ? extends U>)->U:::Returns a non-null result from applying the given search  function on each (key, value), or null if none
java.util.concurrent.ConcurrentHashMap#reduce(long, BiFunction<? super K, ? super V, ? extends U>, BiFunction<? super U, ? super U, ? extends U>)->U:::Returns the result of accumulating the given transformation  of all (key, value) pairs using the given reducer to  combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction<? super K, ? super V>, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation  of all (key, value) pairs using the given reducer to  combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceToLong(long, ToLongBiFunction<? super K, ? super V>, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation  of all (key, value) pairs using the given reducer to  combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceToInt(long, ToIntBiFunction<? super K, ? super V>, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation  of all (key, value) pairs using the given reducer to  combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Consumer<? super K>)->void:::Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Function<? super K, ? extends U>, Consumer<? super U>)->void:::Performs the given action for each non-null transformation  of each key.
java.util.concurrent.ConcurrentHashMap#searchKeys(long, Function<? super K, ? extends U>)->U:::Returns a non-null result from applying the given search  function on each key, or null if none
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, BiFunction<? super K, ? super K, ? extends K>)->K:::Returns the result of accumulating all keys using the given  reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, Function<? super K, ? extends U>, BiFunction<? super U, ? super U, ? extends U>)->U:::Returns the result of accumulating the given transformation  of all keys using the given reducer to combine values, or  null if none.
java.util.concurrent.ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction<? super K>, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation  of all keys using the given reducer to combine values, and  the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction<? super K>, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation  of all keys using the given reducer to combine values, and  the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction<? super K>, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation  of all keys using the given reducer to combine values, and  the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Consumer<? super V>)->void:::Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Function<? super V, ? extends U>, Consumer<? super U>)->void:::Performs the given action for each non-null transformation  of each value.
java.util.concurrent.ConcurrentHashMap#searchValues(long, Function<? super V, ? extends U>)->U:::Returns a non-null result from applying the given search  function on each value, or null if none
java.util.concurrent.ConcurrentHashMap#reduceValues(long, BiFunction<? super V, ? super V, ? extends V>)->V:::Returns the result of accumulating all values using the  given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceValues(long, Function<? super V, ? extends U>, BiFunction<? super U, ? super U, ? extends U>)->U:::Returns the result of accumulating the given transformation  of all values using the given reducer to combine values, or  null if none.
java.util.concurrent.ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction<? super V>, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation  of all values using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction<? super V>, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation  of all values using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction<? super V>, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation  of all values using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Consumer<? super Map.Entry<K, V>>)->void:::Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Function<Map.Entry<K, V>, ? extends U>, Consumer<? super U>)->void:::Performs the given action for each non-null transformation  of each entry.
java.util.concurrent.ConcurrentHashMap#searchEntries(long, Function<Map.Entry<K, V>, ? extends U>)->U:::Returns a non-null result from applying the given search  function on each entry, or null if none
java.util.concurrent.ConcurrentHashMap#V> reduceEntries(long, BiFunction<Map.Entry<K, V>, Map.Entry<K, V>, ? extends Map.Entry<K, V>>)->Map.Entry<K,:::Returns the result of accumulating all entries using the  given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceEntries(long, Function<Map.Entry<K, V>, ? extends U>, BiFunction<? super U, ? super U, ? extends U>)->U:::Returns the result of accumulating the given transformation  of all entries using the given reducer to combine values,  or null if none.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction<Map.Entry<K, V>>, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation  of all entries using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction<Map.Entry<K, V>>, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation  of all entries using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction<Map.Entry<K, V>>, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation  of all entries using the given reducer to combine values,  and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.CollectionView#V> getMap()->ConcurrentHashMap<K,:::Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView#clear()->void:::Removes all of the elements from this view, by removing all  the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView#size()->int:::
java.util.concurrent.ConcurrentHashMap.CollectionView#isEmpty()->boolean:::
java.util.concurrent.ConcurrentHashMap.CollectionView#iterator()->Iterator<E>:::Returns an iterator over the elements in this collection
java.util.concurrent.ConcurrentHashMap.CollectionView#contains(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.CollectionView#remove(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.CollectionView#toArray()->Object[]:::
java.util.concurrent.ConcurrentHashMap.CollectionView#toArray(T[])->T[]:::
java.util.concurrent.ConcurrentHashMap.CollectionView#toString()->String:::Returns a string representation of this collection
java.util.concurrent.ConcurrentHashMap.CollectionView#containsAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentHashMap.CollectionView#removeAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentHashMap.CollectionView#retainAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentHashMap.KeySetView#getMappedValue()->V:::Returns the default mapped value for additions,  or {@code null} if additions are not supported.
java.util.concurrent.ConcurrentHashMap.KeySetView#contains(Object)->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentHashMap.KeySetView#remove(Object)->boolean:::Removes the key from this map view, by removing the key (and its  corresponding value) from the backing map
java.util.concurrent.ConcurrentHashMap.KeySetView#iterator()->Iterator<K>:::
java.util.concurrent.ConcurrentHashMap.KeySetView#add(K)->boolean:::Adds the specified key to this set view by mapping the key to  the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap.KeySetView#addAll(Collection<? extends K>)->boolean:::Adds all of the elements in the specified collection to this set,  as if by calling {@link #add} on each one.
java.util.concurrent.ConcurrentHashMap.KeySetView#hashCode()->int:::
java.util.concurrent.ConcurrentHashMap.KeySetView#equals(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.KeySetView#spliterator()->Spliterator<K>:::
java.util.concurrent.ConcurrentHashMap.KeySetView#forEach(Consumer<? super K>)->void:::
java.util.concurrent.ConcurrentHashMap.ValuesView#contains(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#remove(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#iterator()->Iterator<V>:::
java.util.concurrent.ConcurrentHashMap.ValuesView#add(V)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#addAll(Collection<? extends V>)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#removeAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#removeIf(Predicate<? super V>)->boolean:::
java.util.concurrent.ConcurrentHashMap.ValuesView#spliterator()->Spliterator<V>:::
java.util.concurrent.ConcurrentHashMap.ValuesView#forEach(Consumer<? super V>)->void:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#contains(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#remove(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#V>> iterator()->Iterator<Map.Entry<K,:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#add(Entry<K, V>)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#addAll(Collection<? extends Entry<K, V>>)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#removeIf(Predicate<? super Entry<K, V>>)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#hashCode()->int:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#equals(Object)->boolean:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#V>> spliterator()->Spliterator<Map.Entry<K,:::
java.util.concurrent.ConcurrentHashMap.EntrySetView#forEach(Consumer<? super Map.Entry<K, V>>)->void:::
java.util.concurrent.ConcurrentHashMap.BulkTask#V> advance()->Node<K,:::Same as Traverser version.
java.util.concurrent.ConcurrentHashMap.ForEachKeyTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachValueTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachEntryTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachMappingTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachTransformedKeyTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachTransformedValueTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachTransformedEntryTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ForEachTransformedMappingTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.SearchKeysTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.SearchKeysTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.SearchValuesTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.SearchValuesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.SearchEntriesTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.SearchEntriesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.SearchMappingsTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.SearchMappingsTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ReduceKeysTask#getRawResult()->K:::
java.util.concurrent.ConcurrentHashMap.ReduceKeysTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ReduceValuesTask#getRawResult()->V:::
java.util.concurrent.ConcurrentHashMap.ReduceValuesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.ReduceEntriesTask#V> getRawResult()->Map.Entry<K,:::
java.util.concurrent.ConcurrentHashMap.ReduceEntriesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsTask#getRawResult()->U:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToDoubleTask#getRawResult()->Double:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToDoubleTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToDoubleTask#getRawResult()->Double:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToDoubleTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToDoubleTask#getRawResult()->Double:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToDoubleTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToDoubleTask#getRawResult()->Double:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToDoubleTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToLongTask#getRawResult()->Long:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToLongTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToLongTask#getRawResult()->Long:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToLongTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToLongTask#getRawResult()->Long:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToLongTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToLongTask#getRawResult()->Long:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToLongTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToIntTask#getRawResult()->Integer:::
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToIntTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToIntTask#getRawResult()->Integer:::
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToIntTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToIntTask#getRawResult()->Integer:::
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToIntTask#compute()->void:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToIntTask#getRawResult()->Integer:::
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToIntTask#compute()->void:::
java.util.concurrent.ConcurrentLinkedDeque#prevTerminator()->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque#nextTerminator()->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque#newNode(E)->Node<E>:::Returns a new node holding item
java.util.concurrent.ConcurrentLinkedDeque#unlink(Node<E>)->void:::Unlinks non-null node x.
java.util.concurrent.ConcurrentLinkedDeque#succ(Node<E>)->Node<E>:::Returns the successor of p, or the first node if p.next has been  linked to self, which will only be true if traversing with a  stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque#pred(Node<E>)->Node<E>:::Returns the predecessor of p, or the last node if p.prev has been  linked to self, which will only be true if traversing with a  stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque#first()->Node<E>:::Returns the first node, the unique node p for which:      p.prev == null && p.next != p  The returned node may or may not be logically deleted
java.util.concurrent.ConcurrentLinkedDeque#last()->Node<E>:::Returns the last node, the unique node p for which:      p.next == null && p.prev != p  The returned node may or may not be logically deleted
java.util.concurrent.ConcurrentLinkedDeque#addFirst(E)->void:::Inserts the specified element at the front of this deque
java.util.concurrent.ConcurrentLinkedDeque#addLast(E)->void:::Inserts the specified element at the end of this deque
java.util.concurrent.ConcurrentLinkedDeque#offerFirst(E)->boolean:::Inserts the specified element at the front of this deque
java.util.concurrent.ConcurrentLinkedDeque#offerLast(E)->boolean:::Inserts the specified element at the end of this deque
java.util.concurrent.ConcurrentLinkedDeque#peekFirst()->E:::
java.util.concurrent.ConcurrentLinkedDeque#peekLast()->E:::
java.util.concurrent.ConcurrentLinkedDeque#getFirst()->E:::
java.util.concurrent.ConcurrentLinkedDeque#getLast()->E:::
java.util.concurrent.ConcurrentLinkedDeque#pollFirst()->E:::
java.util.concurrent.ConcurrentLinkedDeque#pollLast()->E:::
java.util.concurrent.ConcurrentLinkedDeque#removeFirst()->E:::
java.util.concurrent.ConcurrentLinkedDeque#removeLast()->E:::
java.util.concurrent.ConcurrentLinkedDeque#offer(E)->boolean:::Inserts the specified element at the tail of this deque
java.util.concurrent.ConcurrentLinkedDeque#add(E)->boolean:::Inserts the specified element at the tail of this deque
java.util.concurrent.ConcurrentLinkedDeque#poll()->E:::
java.util.concurrent.ConcurrentLinkedDeque#peek()->E:::
java.util.concurrent.ConcurrentLinkedDeque#remove()->E:::
java.util.concurrent.ConcurrentLinkedDeque#pop()->E:::
java.util.concurrent.ConcurrentLinkedDeque#element()->E:::
java.util.concurrent.ConcurrentLinkedDeque#push(E)->void:::
java.util.concurrent.ConcurrentLinkedDeque#removeFirstOccurrence(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#removeLastOccurrence(Object)->boolean:::Removes the last occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#contains(Object)->boolean:::Returns {@code true} if this deque contains the specified element
java.util.concurrent.ConcurrentLinkedDeque#isEmpty()->boolean:::Returns {@code true} if this collection contains no elements.
java.util.concurrent.ConcurrentLinkedDeque#size()->int:::Returns the number of elements in this deque
java.util.concurrent.ConcurrentLinkedDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#addAll(Collection<? extends E>)->boolean:::Appends all of the elements in the specified collection to the end of  this deque, in the order that they are returned by the specified  collection's iterator
java.util.concurrent.ConcurrentLinkedDeque#clear()->void:::Removes all of the elements from this deque.
java.util.concurrent.ConcurrentLinkedDeque#toString()->String:::
java.util.concurrent.ConcurrentLinkedDeque#toArray()->Object[]:::Returns an array containing all of the elements in this deque, in  proper sequence (from first to last element)
java.util.concurrent.ConcurrentLinkedDeque#toArray(T[])->T[]:::Returns an array containing all of the elements in this deque,  in proper sequence (from first to last element); the runtime  type of the returned array is that of the specified array
java.util.concurrent.ConcurrentLinkedDeque#iterator()->Iterator<E>:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.ConcurrentLinkedDeque#descendingIterator()->Iterator<E>:::Returns an iterator over the elements in this deque in reverse  sequential order
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr#startNode()->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr#hasNext()->boolean:::
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr#next()->E:::
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr#remove()->void:::
java.util.concurrent.ConcurrentLinkedDeque.Itr#startNode()->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.Itr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.DescendingItr#startNode()->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.DescendingItr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#trySplit()->Spliterator<E>:::
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentLinkedDeque#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this deque
java.util.concurrent.ConcurrentLinkedDeque#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.ConcurrentLinkedDeque#removeAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentLinkedDeque#retainAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentLinkedDeque#forEach(Consumer<? super E>)->void:::
java.util.concurrent.ConcurrentLinkedQueue.Node#appendRelaxed(Node<E>)->void:::
java.util.concurrent.ConcurrentLinkedQueue.Node#casItem(E, E)->boolean:::
java.util.concurrent.ConcurrentLinkedQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.ConcurrentLinkedQueue#updateHead(Node<E>, Node<E>)->void:::Tries to CAS head to p
java.util.concurrent.ConcurrentLinkedQueue#succ(Node<E>)->Node<E>:::Returns the successor of p, or the head node if p.next has been  linked to self, which will only be true if traversing with a  stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.ConcurrentLinkedQueue#poll()->E:::
java.util.concurrent.ConcurrentLinkedQueue#peek()->E:::
java.util.concurrent.ConcurrentLinkedQueue#first()->Node<E>:::Returns the first live (non-deleted) node on list, or null if none
java.util.concurrent.ConcurrentLinkedQueue#isEmpty()->boolean:::Returns {@code true} if this queue contains no elements.
java.util.concurrent.ConcurrentLinkedQueue#size()->int:::Returns the number of elements in this queue
java.util.concurrent.ConcurrentLinkedQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.ConcurrentLinkedQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.ConcurrentLinkedQueue#addAll(Collection<? extends E>)->boolean:::Appends all of the elements in the specified collection to the end of  this queue, in the order that they are returned by the specified  collection's iterator
java.util.concurrent.ConcurrentLinkedQueue#toString()->String:::
java.util.concurrent.ConcurrentLinkedQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in  proper sequence
java.util.concurrent.ConcurrentLinkedQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in  proper sequence; the runtime type of the returned array is that of  the specified array
java.util.concurrent.ConcurrentLinkedQueue#iterator()->Iterator<E>:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.ConcurrentLinkedQueue.Itr#hasNext()->boolean:::
java.util.concurrent.ConcurrentLinkedQueue.Itr#next()->E:::
java.util.concurrent.ConcurrentLinkedQueue.Itr#remove()->void:::
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#trySplit()->Spliterator<E>:::
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentLinkedQueue#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this queue
java.util.concurrent.ConcurrentLinkedQueue#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.ConcurrentLinkedQueue#removeAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentLinkedQueue#retainAll(Collection<?>)->boolean:::
java.util.concurrent.ConcurrentLinkedQueue#clear()->void:::
java.util.concurrent.ConcurrentLinkedQueue#forEachFrom(Consumer<? super E>, Node<E>)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.ConcurrentLinkedQueue#forEach(Consumer<? super E>)->void:::
java.util.concurrent.ConcurrentMap#getOrDefault(Object, V)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#forEach(BiConsumer<? super K, ? super V>)->void:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#putIfAbsent(K, V)->V:::If the specified key is not already associated  with a value, associates it with the given value
java.util.concurrent.ConcurrentMap#remove(Object, Object)->boolean:::Removes the entry for a key only if currently mapped to a given value
java.util.concurrent.ConcurrentMap#replace(K, V, V)->boolean:::Replaces the entry for a key only if currently mapped to a given value
java.util.concurrent.ConcurrentMap#replace(K, V)->V:::Replaces the entry for a key only if currently mapped to some value
java.util.concurrent.ConcurrentMap#replaceAll(BiFunction<? super K, ? super V, ? extends V>)->void:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#computeIfAbsent(K, Function<? super K, ? extends V>)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#computeIfPresent(K, BiFunction<? super K, ? super V, ? extends V>)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#compute(K, BiFunction<? super K, ? super V, ? extends V>)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentMap#merge(K, V, BiFunction<? super V, ? super V, ? extends V>)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentNavigableMap#V> subMap(K, boolean, K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> headMap(K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> tailMap(K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> subMap(K, K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> headMap(K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> tailMap(K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentNavigableMap#V> descendingMap()->ConcurrentNavigableMap<K,:::Returns a reverse order view of the mappings contained in this map
java.util.concurrent.ConcurrentNavigableMap#navigableKeySet()->NavigableSet<K>:::Returns a {@link NavigableSet} view of the keys contained in this map
java.util.concurrent.ConcurrentNavigableMap#keySet()->NavigableSet<K>:::Returns a {@link NavigableSet} view of the keys contained in this map
java.util.concurrent.ConcurrentNavigableMap#descendingKeySet()->NavigableSet<K>:::Returns a reverse order {@link NavigableSet} view of the keys contained in this map
java.util.concurrent.ConcurrentSkipListMap#cpr(Comparator, Object, Object)->int:::Compares using comparator or natural ordering if null
java.util.concurrent.ConcurrentSkipListMap#V> baseHead()->Node<K,:::Returns the header for base node list, or null if uninitialized
java.util.concurrent.ConcurrentSkipListMap#unlinkNode(Node<K, V>, Node<K, V>)->void:::Tries to unlink deleted node n from predecessor b (if both  exist), by first splicing in a marker if not already present
java.util.concurrent.ConcurrentSkipListMap#getAdderCount()->long:::Returns element count, initializing adder if necessary.
java.util.concurrent.ConcurrentSkipListMap#addIndices(Index<K, V>, int, Index<K, V>, Comparator<? super K>)->boolean:::Add indices after an insertion
java.util.concurrent.ConcurrentSkipListMap#doRemove(Object, Object)->V:::Main deletion method
java.util.concurrent.ConcurrentSkipListMap#V> findFirst()->Node<K,:::Gets first valid node, unlinking deleted nodes if encountered.
java.util.concurrent.ConcurrentSkipListMap#V> findFirstEntry()->AbstractMap.SimpleImmutableEntry<K,:::Entry snapshot version of findFirst
java.util.concurrent.ConcurrentSkipListMap#V> findLast()->Node<K,:::Specialized version of find to get last valid node.
java.util.concurrent.ConcurrentSkipListMap#V> findLastEntry()->AbstractMap.SimpleImmutableEntry<K,:::Entry version of findLast
java.util.concurrent.ConcurrentSkipListMap#V> findNear(K, int, Comparator<? super K>)->Node<K,:::Utility for ceiling, floor, lower, higher methods.
java.util.concurrent.ConcurrentSkipListMap#V> findNearEntry(K, int, Comparator<? super K>)->AbstractMap.SimpleImmutableEntry<K,:::Variant of findNear returning SimpleImmutableEntry
java.util.concurrent.ConcurrentSkipListMap#V> clone()->ConcurrentSkipListMap<K,:::Returns a shallow copy of this {@code ConcurrentSkipListMap}  instance
java.util.concurrent.ConcurrentSkipListMap#containsKey(Object)->boolean:::Returns {@code true} if this map contains a mapping for the specified  key.
java.util.concurrent.ConcurrentSkipListMap#get(Object)->V:::Returns the value to which the specified key is mapped,  or {@code null} if this map contains no mapping for the key
java.util.concurrent.ConcurrentSkipListMap#getOrDefault(Object, V)->V:::Returns the value to which the specified key is mapped,  or the given defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentSkipListMap#put(K, V)->V:::Associates the specified value with the specified key in this map
java.util.concurrent.ConcurrentSkipListMap#remove(Object)->V:::Removes the mapping for the specified key from this map if present.
java.util.concurrent.ConcurrentSkipListMap#containsValue(Object)->boolean:::Returns {@code true} if this map maps one or more keys to the  specified value
java.util.concurrent.ConcurrentSkipListMap#size()->int:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#isEmpty()->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#clear()->void:::Removes all of the mappings from this map.
java.util.concurrent.ConcurrentSkipListMap#computeIfAbsent(K, Function<? super K, ? extends V>)->V:::If the specified key is not already associated with a value,  attempts to compute its value using the given mapping function  and enters it into this map unless {@code null}
java.util.concurrent.ConcurrentSkipListMap#computeIfPresent(K, BiFunction<? super K, ? super V, ? extends V>)->V:::If the value for the specified key is present, attempts to  compute a new mapping given the key and its current mapped  value
java.util.concurrent.ConcurrentSkipListMap#compute(K, BiFunction<? super K, ? super V, ? extends V>)->V:::Attempts to compute a mapping for the specified key and its  current mapped value (or {@code null} if there is no current  mapping)
java.util.concurrent.ConcurrentSkipListMap#merge(K, V, BiFunction<? super V, ? super V, ? extends V>)->V:::If the specified key is not already associated with a value,  associates it with the given value
java.util.concurrent.ConcurrentSkipListMap#keySet()->NavigableSet<K>:::Returns a {@link NavigableSet} view of the keys contained in this map
java.util.concurrent.ConcurrentSkipListMap#navigableKeySet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap#values()->Collection<V>:::Returns a {@link Collection} view of the values contained in this map
java.util.concurrent.ConcurrentSkipListMap#V>> entrySet()->Set<Map.Entry<K,:::Returns a {@link Set} view of the mappings contained in this map
java.util.concurrent.ConcurrentSkipListMap#V> descendingMap()->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#descendingKeySet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap#equals(Object)->boolean:::Compares the specified object with this map for equality
java.util.concurrent.ConcurrentSkipListMap#putIfAbsent(K, V)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#remove(Object, Object)->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#replace(K, V, V)->boolean:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#replace(K, V)->V:::{@inheritDoc}
java.util.concurrent.ConcurrentSkipListMap#super K> comparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListMap#firstKey()->K:::
java.util.concurrent.ConcurrentSkipListMap#lastKey()->K:::
java.util.concurrent.ConcurrentSkipListMap#V> subMap(K, boolean, K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> headMap(K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> tailMap(K, boolean)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> subMap(K, K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> headMap(K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> tailMap(K)->ConcurrentNavigableMap<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> lowerEntry(K)->Map.Entry<K,:::Returns a key-value mapping associated with the greatest key  strictly less than the given key, or {@code null} if there is  no such key
java.util.concurrent.ConcurrentSkipListMap#lowerKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap#V> floorEntry(K)->Map.Entry<K,:::Returns a key-value mapping associated with the greatest key  less than or equal to the given key, or {@code null} if there  is no such key
java.util.concurrent.ConcurrentSkipListMap#floorKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap#V> ceilingEntry(K)->Map.Entry<K,:::Returns a key-value mapping associated with the least key  greater than or equal to the given key, or {@code null} if  there is no such entry
java.util.concurrent.ConcurrentSkipListMap#ceilingKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap#V> higherEntry(K)->Map.Entry<K,:::Returns a key-value mapping associated with the least key  strictly greater than the given key, or {@code null} if there  is no such key
java.util.concurrent.ConcurrentSkipListMap#higherKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap#V> firstEntry()->Map.Entry<K,:::Returns a key-value mapping associated with the least  key in this map, or {@code null} if the map is empty
java.util.concurrent.ConcurrentSkipListMap#V> lastEntry()->Map.Entry<K,:::Returns a key-value mapping associated with the greatest  key in this map, or {@code null} if the map is empty
java.util.concurrent.ConcurrentSkipListMap#V> pollFirstEntry()->Map.Entry<K,:::Removes and returns a key-value mapping associated with  the least key in this map, or {@code null} if the map is empty
java.util.concurrent.ConcurrentSkipListMap#V> pollLastEntry()->Map.Entry<K,:::Removes and returns a key-value mapping associated with  the greatest key in this map, or {@code null} if the map is empty
java.util.concurrent.ConcurrentSkipListMap.Iter#hasNext()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.Iter#advance(Node<K, V>)->void:::Advances next to higher entry.
java.util.concurrent.ConcurrentSkipListMap.Iter#remove()->void:::
java.util.concurrent.ConcurrentSkipListMap.ValueIterator#next()->V:::
java.util.concurrent.ConcurrentSkipListMap.KeyIterator#next()->K:::
java.util.concurrent.ConcurrentSkipListMap.EntryIterator#V> next()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap#toList(Collection<E>)->List<E>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#size()->int:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#isEmpty()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#contains(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#remove(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#clear()->void:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#lower(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#floor(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#ceiling(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#higher(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#super K> comparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#first()->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#last()->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#pollFirst()->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#pollLast()->K:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#iterator()->Iterator<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#equals(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#toArray()->Object[]:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#toArray(T[])->T[]:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#descendingIterator()->Iterator<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#subSet(K, boolean, K, boolean)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#headSet(K, boolean)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#tailSet(K, boolean)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#subSet(K, K)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#headSet(K)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#tailSet(K)->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#descendingSet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.KeySet#spliterator()->Spliterator<K>:::
java.util.concurrent.ConcurrentSkipListMap.Values#iterator()->Iterator<V>:::
java.util.concurrent.ConcurrentSkipListMap.Values#size()->int:::
java.util.concurrent.ConcurrentSkipListMap.Values#isEmpty()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.Values#contains(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.Values#clear()->void:::
java.util.concurrent.ConcurrentSkipListMap.Values#toArray()->Object[]:::
java.util.concurrent.ConcurrentSkipListMap.Values#toArray(T[])->T[]:::
java.util.concurrent.ConcurrentSkipListMap.Values#spliterator()->Spliterator<V>:::
java.util.concurrent.ConcurrentSkipListMap.Values#removeIf(Predicate<? super V>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#V>> iterator()->Iterator<Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#contains(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#remove(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#isEmpty()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#size()->int:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#clear()->void:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#equals(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#toArray()->Object[]:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#toArray(T[])->T[]:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#V>> spliterator()->Spliterator<Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.EntrySet#removeIf(Predicate<? super Entry<K, V>>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#tooLow(Object, Comparator<? super K>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#tooHigh(Object, Comparator<? super K>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#inBounds(Object, Comparator<? super K>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#checkKeyBounds(K, Comparator<? super K>)->void:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#isBeforeEnd(ConcurrentSkipListMap.Node<K, V>, Comparator<? super K>)->boolean:::Returns true if node key is less than upper bound of range.
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> loNode(Comparator<? super K>)->ConcurrentSkipListMap.Node<K,:::Returns lowest node
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> hiNode(Comparator<? super K>)->ConcurrentSkipListMap.Node<K,:::Returns highest node
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowestKey()->K:::Returns lowest absolute key (ignoring directionality).
java.util.concurrent.ConcurrentSkipListMap.SubMap#highestKey()->K:::Returns highest absolute key (ignoring directionality).
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> lowestEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> highestEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> removeLowest()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> removeHighest()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> getNearEntry(K, int)->Map.Entry<K,:::Submap version of ConcurrentSkipListMap.findNearEntry.
java.util.concurrent.ConcurrentSkipListMap.SubMap#getNearKey(K, int)->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#containsKey(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#get(Object)->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#put(K, V)->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#remove(Object)->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#size()->int:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#isEmpty()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#containsValue(Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#clear()->void:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#putIfAbsent(K, V)->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#remove(Object, Object)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#replace(K, V, V)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#replace(K, V)->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#super K> comparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> newSubMap(K, boolean, K, boolean)->SubMap<K,:::Utility to create submaps, where given bounds override  unbounded(null) ones and/or are checked against bounded ones.
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> subMap(K, boolean, K, boolean)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> headMap(K, boolean)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> tailMap(K, boolean)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> subMap(K, K)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> headMap(K)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> tailMap(K)->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> descendingMap()->SubMap<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> ceilingEntry(K)->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#ceilingKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> lowerEntry(K)->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowerKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> floorEntry(K)->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#floorKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> higherEntry(K)->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#higherKey(K)->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#firstKey()->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#lastKey()->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> firstEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> lastEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> pollFirstEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V> pollLastEntry()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#keySet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#navigableKeySet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#values()->Collection<V>:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#V>> entrySet()->Set<Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap#descendingKeySet()->NavigableSet<K>:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#hasNext()->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#advance()->void:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#remove()->void:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#trySplit()->Spliterator<T>:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#tryAdvance(Consumer<? super T>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#forEachRemaining(Consumer<? super T>)->void:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#estimateSize()->long:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapValueIterator#next()->V:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapValueIterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#next()->K:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#super K> getComparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapEntryIterator#V> next()->Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapEntryIterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap#forEach(BiConsumer<? super K, ? super V>)->void:::
java.util.concurrent.ConcurrentSkipListMap#replaceAll(BiFunction<? super K, ? super V, ? extends V>)->void:::
java.util.concurrent.ConcurrentSkipListMap#removeEntryIf(Predicate<? super Entry<K, V>>)->boolean:::Helper method for EntrySet.removeIf.
java.util.concurrent.ConcurrentSkipListMap#removeValueIf(Predicate<? super V>)->boolean:::Helper method for Values.removeIf.
java.util.concurrent.ConcurrentSkipListMap.CSLMSpliterator#estimateSize()->long:::
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#V> trySplit()->KeySpliterator<K,:::
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#forEachRemaining(Consumer<? super K>)->void:::
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#tryAdvance(Consumer<? super K>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#super K> getComparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListMap#V> keySpliterator()->KeySpliterator<K,:::
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#V> trySplit()->ValueSpliterator<K,:::
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#forEachRemaining(Consumer<? super V>)->void:::
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#tryAdvance(Consumer<? super V>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap#V> valueSpliterator()->ValueSpliterator<K,:::
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#V> trySplit()->EntrySpliterator<K,:::
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#forEachRemaining(Consumer<? super Map.Entry<K, V>>)->void:::
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#tryAdvance(Consumer<? super Map.Entry<K, V>>)->boolean:::
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#characteristics()->int:::
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#V>> getComparator()->Comparator<Map.Entry<K,:::
java.util.concurrent.ConcurrentSkipListMap#V> entrySpliterator()->EntrySpliterator<K,:::
java.util.concurrent.ConcurrentSkipListSet#clone()->ConcurrentSkipListSet<E>:::Returns a shallow copy of this {@code ConcurrentSkipListSet}  instance
java.util.concurrent.ConcurrentSkipListSet#size()->int:::Returns the number of elements in this set
java.util.concurrent.ConcurrentSkipListSet#isEmpty()->boolean:::Returns {@code true} if this set contains no elements.
java.util.concurrent.ConcurrentSkipListSet#contains(Object)->boolean:::Returns {@code true} if this set contains the specified element
java.util.concurrent.ConcurrentSkipListSet#add(E)->boolean:::Adds the specified element to this set if it is not already present
java.util.concurrent.ConcurrentSkipListSet#remove(Object)->boolean:::Removes the specified element from this set if it is present
java.util.concurrent.ConcurrentSkipListSet#clear()->void:::Removes all of the elements from this set.
java.util.concurrent.ConcurrentSkipListSet#iterator()->Iterator<E>:::Returns an iterator over the elements in this set in ascending order.
java.util.concurrent.ConcurrentSkipListSet#descendingIterator()->Iterator<E>:::Returns an iterator over the elements in this set in descending order.
java.util.concurrent.ConcurrentSkipListSet#equals(Object)->boolean:::Compares the specified object with this set for equality
java.util.concurrent.ConcurrentSkipListSet#removeAll(Collection<?>)->boolean:::Removes from this set all of its elements that are contained in  the specified collection
java.util.concurrent.ConcurrentSkipListSet#lower(E)->E:::
java.util.concurrent.ConcurrentSkipListSet#floor(E)->E:::
java.util.concurrent.ConcurrentSkipListSet#ceiling(E)->E:::
java.util.concurrent.ConcurrentSkipListSet#higher(E)->E:::
java.util.concurrent.ConcurrentSkipListSet#pollFirst()->E:::
java.util.concurrent.ConcurrentSkipListSet#pollLast()->E:::
java.util.concurrent.ConcurrentSkipListSet#super E> comparator()->Comparator<?:::
java.util.concurrent.ConcurrentSkipListSet#first()->E:::
java.util.concurrent.ConcurrentSkipListSet#last()->E:::
java.util.concurrent.ConcurrentSkipListSet#subSet(E, boolean, E, boolean)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#headSet(E, boolean)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#tailSet(E, boolean)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#subSet(E, E)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#headSet(E)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#tailSet(E)->NavigableSet<E>:::
java.util.concurrent.ConcurrentSkipListSet#descendingSet()->NavigableSet<E>:::Returns a reverse order view of the elements contained in this set
java.util.concurrent.ConcurrentSkipListSet#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this set
java.util.concurrent.CopyOnWriteArrayList#getArray()->Object[]:::Gets the array
java.util.concurrent.CopyOnWriteArrayList#setArray(Object[])->void:::Sets the array.
java.util.concurrent.CopyOnWriteArrayList#size()->int:::Returns the number of elements in this list.
java.util.concurrent.CopyOnWriteArrayList#isEmpty()->boolean:::Returns {@code true} if this list contains no elements.
java.util.concurrent.CopyOnWriteArrayList#contains(Object)->boolean:::Returns {@code true} if this list contains the specified element
java.util.concurrent.CopyOnWriteArrayList#indexOf(Object)->int:::{@inheritDoc}
java.util.concurrent.CopyOnWriteArrayList#indexOf(E, int)->int:::Returns the index of the first occurrence of the specified element in  this list, searching forwards from {@code index}, or returns -1 if  the element is not found
java.util.concurrent.CopyOnWriteArrayList#lastIndexOf(Object)->int:::{@inheritDoc}
java.util.concurrent.CopyOnWriteArrayList#lastIndexOf(E, int)->int:::Returns the index of the last occurrence of the specified element in  this list, searching backwards from {@code index}, or returns -1 if  the element is not found
java.util.concurrent.CopyOnWriteArrayList#clone()->Object:::Returns a shallow copy of this list
java.util.concurrent.CopyOnWriteArrayList#toArray()->Object[]:::Returns an array containing all of the elements in this list  in proper sequence (from first to last element)
java.util.concurrent.CopyOnWriteArrayList#toArray(T[])->T[]:::Returns an array containing all of the elements in this list in  proper sequence (from first to last element); the runtime type of  the returned array is that of the specified array
java.util.concurrent.CopyOnWriteArrayList#elementAt(Object[], int)->E:::
java.util.concurrent.CopyOnWriteArrayList#outOfBounds(int, int)->String:::
java.util.concurrent.CopyOnWriteArrayList#get(int)->E:::{@inheritDoc}
java.util.concurrent.CopyOnWriteArrayList#set(int, E)->E:::Replaces the element at the specified position in this list with the  specified element.
java.util.concurrent.CopyOnWriteArrayList#add(E)->boolean:::Appends the specified element to the end of this list.
java.util.concurrent.CopyOnWriteArrayList#add(int, E)->void:::Inserts the specified element at the specified position in this  list
java.util.concurrent.CopyOnWriteArrayList#remove(int)->E:::Removes the element at the specified position in this list
java.util.concurrent.CopyOnWriteArrayList#remove(Object)->boolean:::Removes the first occurrence of the specified element from this list,  if it is present
java.util.concurrent.CopyOnWriteArrayList#removeRange(int, int)->void:::Removes from this list all of the elements whose index is between  {@code fromIndex}, inclusive, and {@code toIndex}, exclusive
java.util.concurrent.CopyOnWriteArrayList#addIfAbsent(E)->boolean:::Appends the element, if not present.
java.util.concurrent.CopyOnWriteArrayList#containsAll(Collection<?>)->boolean:::Returns {@code true} if this list contains all of the elements of the  specified collection.
java.util.concurrent.CopyOnWriteArrayList#removeAll(Collection<?>)->boolean:::Removes from this list all of its elements that are contained in  the specified collection
java.util.concurrent.CopyOnWriteArrayList#retainAll(Collection<?>)->boolean:::Retains only the elements in this list that are contained in the  specified collection
java.util.concurrent.CopyOnWriteArrayList#addAllAbsent(Collection<? extends E>)->int:::Appends all of the elements in the specified collection that  are not already contained in this list, to the end of  this list, in the order that they are returned by the  specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList#clear()->void:::Removes all of the elements from this list
java.util.concurrent.CopyOnWriteArrayList#addAll(Collection<? extends E>)->boolean:::Appends all of the elements in the specified collection to the end  of this list, in the order that they are returned by the specified  collection's iterator.
java.util.concurrent.CopyOnWriteArrayList#addAll(int, Collection<? extends E>)->boolean:::Inserts all of the elements in the specified collection into this  list, starting at the specified position
java.util.concurrent.CopyOnWriteArrayList#forEach(Consumer<? super E>)->void:::
java.util.concurrent.CopyOnWriteArrayList#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList#bulkRemove(Predicate<? super E>, int, int)->boolean:::
java.util.concurrent.CopyOnWriteArrayList#replaceAll(UnaryOperator<E>)->void:::
java.util.concurrent.CopyOnWriteArrayList#replaceAllRange(UnaryOperator<E>, int, int)->void:::
java.util.concurrent.CopyOnWriteArrayList#sort(Comparator<? super E>)->void:::
java.util.concurrent.CopyOnWriteArrayList#sortRange(Comparator<? super E>, int, int)->void:::
java.util.concurrent.CopyOnWriteArrayList#toString()->String:::Returns a string representation of this list
java.util.concurrent.CopyOnWriteArrayList#equals(Object)->boolean:::Compares the specified object with this list for equality
java.util.concurrent.CopyOnWriteArrayList#hashCode()->int:::Returns the hash code value for this list
java.util.concurrent.CopyOnWriteArrayList#iterator()->Iterator<E>:::Returns an iterator over the elements in this list in proper sequence
java.util.concurrent.CopyOnWriteArrayList#listIterator()->ListIterator<E>:::{@inheritDoc}    <p>The returned iterator provides a snapshot of the state of the list  when the iterator was constructed
java.util.concurrent.CopyOnWriteArrayList#listIterator(int)->ListIterator<E>:::{@inheritDoc}    <p>The returned iterator provides a snapshot of the state of the list  when the iterator was constructed
java.util.concurrent.CopyOnWriteArrayList#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this list
java.util.concurrent.CopyOnWriteArrayList.COWIterator#hasNext()->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#hasPrevious()->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#next()->E:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#previous()->E:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#nextIndex()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#previousIndex()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWIterator#remove()->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#set(E)->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#add(E)->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.CopyOnWriteArrayList#subList(int, int)->List<E>:::Returns a view of the portion of this list between  {@code fromIndex}, inclusive, and {@code toIndex}, exclusive
java.util.concurrent.CopyOnWriteArrayList.COWSubList#toArray()->Object[]:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#toArray(T[])->T[]:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#indexOf(Object)->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#lastIndexOf(Object)->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#contains(Object)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#containsAll(Collection<?>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#isEmpty()->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#toString()->String:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#hashCode()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#equals(Object)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#set(int, E)->E:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#get(int)->E:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#size()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#add(E)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#add(int, E)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#addAll(Collection<? extends E>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#addAll(int, Collection<? extends E>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#clear()->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#remove(int)->E:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#remove(Object)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#iterator()->Iterator<E>:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#listIterator()->ListIterator<E>:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#listIterator(int)->ListIterator<E>:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#subList(int, int)->List<E>:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#forEach(Consumer<? super E>)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#replaceAll(UnaryOperator<E>)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#sort(Comparator<? super E>)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#removeAll(Collection<?>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#retainAll(Collection<?>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubList#spliterator()->Spliterator<E>:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#hasNext()->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#next()->E:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#hasPrevious()->boolean:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#previous()->E:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#nextIndex()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#previousIndex()->int:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#remove()->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#set(E)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#add(E)->void:::
java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.CopyOnWriteArraySet#size()->int:::Returns the number of elements in this set.
java.util.concurrent.CopyOnWriteArraySet#isEmpty()->boolean:::Returns {@code true} if this set contains no elements.
java.util.concurrent.CopyOnWriteArraySet#contains(Object)->boolean:::Returns {@code true} if this set contains the specified element
java.util.concurrent.CopyOnWriteArraySet#toArray()->Object[]:::Returns an array containing all of the elements in this set
java.util.concurrent.CopyOnWriteArraySet#toArray(T[])->T[]:::Returns an array containing all of the elements in this set; the  runtime type of the returned array is that of the specified array
java.util.concurrent.CopyOnWriteArraySet#clear()->void:::Removes all of the elements from this set
java.util.concurrent.CopyOnWriteArraySet#remove(Object)->boolean:::Removes the specified element from this set if it is present
java.util.concurrent.CopyOnWriteArraySet#add(E)->boolean:::Adds the specified element to this set if it is not already present
java.util.concurrent.CopyOnWriteArraySet#containsAll(Collection<?>)->boolean:::Returns {@code true} if this set contains all of the elements of the  specified collection
java.util.concurrent.CopyOnWriteArraySet#addAll(Collection<? extends E>)->boolean:::Adds all of the elements in the specified collection to this set if  they're not already present
java.util.concurrent.CopyOnWriteArraySet#removeAll(Collection<?>)->boolean:::Removes from this set all of its elements that are contained in the  specified collection
java.util.concurrent.CopyOnWriteArraySet#retainAll(Collection<?>)->boolean:::Retains only the elements in this set that are contained in the  specified collection
java.util.concurrent.CopyOnWriteArraySet#iterator()->Iterator<E>:::Returns an iterator over the elements contained in this set  in the order in which these elements were added
java.util.concurrent.CopyOnWriteArraySet#equals(Object)->boolean:::Compares the specified object with this set for equality
java.util.concurrent.CopyOnWriteArraySet#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.CopyOnWriteArraySet#forEach(Consumer<? super E>)->void:::
java.util.concurrent.CopyOnWriteArraySet#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this set in the order  in which these elements were added
java.util.concurrent.CountDownLatch.Sync#getCount()->int:::
java.util.concurrent.CountDownLatch.Sync#tryAcquireShared(int)->int:::
java.util.concurrent.CountDownLatch.Sync#tryReleaseShared(int)->boolean:::
java.util.concurrent.CountDownLatch#await()->void:::Causes the current thread to wait until the latch has counted down to  zero, unless the thread is {@linkplain Thread#interrupt interrupted}
java.util.concurrent.CountDownLatch#await(long, TimeUnit)->boolean:::Causes the current thread to wait until the latch has counted down to  zero, unless the thread is {@linkplain Thread#interrupt interrupted},  or the specified waiting time elapses
java.util.concurrent.CountDownLatch#countDown()->void:::Decrements the count of the latch, releasing all waiting threads if  the count reaches zero
java.util.concurrent.CountDownLatch#getCount()->long:::Returns the current count
java.util.concurrent.CountDownLatch#toString()->String:::Returns a string identifying this latch, as well as its state
java.util.concurrent.CountedCompleter#compute()->void:::The main computation performed by this task.
java.util.concurrent.CountedCompleter#onCompletion(CountedCompleter<?>)->void:::Performs an action when method {@link #tryComplete} is invoked  and the pending count is zero, or when the unconditional  method {@link #complete} is invoked
java.util.concurrent.CountedCompleter#onExceptionalCompletion(Throwable, CountedCompleter<?>)->boolean:::Performs an action when method {@link  #completeExceptionally(Throwable)} is invoked or method {@link  #compute} throws an exception, and this task has not already  otherwise completed normally
java.util.concurrent.CountedCompleter#getCompleter()->CountedCompleter<?>:::Returns the completer established in this task's constructor,  or {@code null} if none.
java.util.concurrent.CountedCompleter#getPendingCount()->int:::Returns the current pending count.
java.util.concurrent.CountedCompleter#setPendingCount(int)->void:::Sets the pending count to the given value.
java.util.concurrent.CountedCompleter#addToPendingCount(int)->void:::Adds (atomically) the given value to the pending count.
java.util.concurrent.CountedCompleter#compareAndSetPendingCount(int, int)->boolean:::Sets (atomically) the pending count to the given count only if  it currently holds the given expected value.
java.util.concurrent.CountedCompleter#decrementPendingCountUnlessZero()->int:::If the pending count is nonzero, (atomically) decrements it.
java.util.concurrent.CountedCompleter#getRoot()->CountedCompleter<?>:::Returns the root of the current computation; i.e., this  task if it has no completer, else its completer's root.
java.util.concurrent.CountedCompleter#tryComplete()->void:::If the pending count is nonzero, decrements the count;  otherwise invokes {@link #onCompletion(CountedCompleter)}  and then similarly tries to complete this task's completer,  if one exists, else marks this task as complete.
java.util.concurrent.CountedCompleter#propagateCompletion()->void:::Equivalent to {@link #tryComplete} but does not invoke {@link  #onCompletion(CountedCompleter)} along the completion path:  If the pending count is nonzero, decrements the count;  otherwise, similarly tries to complete this task's completer, if  one exists, else marks this task as complete
java.util.concurrent.CountedCompleter#complete(T)->void:::Regardless of pending count, invokes  {@link #onCompletion(CountedCompleter)}, marks this task as  complete and further triggers {@link #tryComplete} on this  task's completer, if one exists
java.util.concurrent.CountedCompleter#firstComplete()->CountedCompleter<?>:::If this task's pending count is zero, returns this task;  otherwise decrements its pending count and returns {@code null}
java.util.concurrent.CountedCompleter#nextComplete()->CountedCompleter<?>:::If this task does not have a completer, invokes {@link  ForkJoinTask#quietlyComplete} and returns {@code null}
java.util.concurrent.CountedCompleter#quietlyCompleteRoot()->void:::Equivalent to {@code getRoot().quietlyComplete()}.
java.util.concurrent.CountedCompleter#helpComplete(int)->void:::If this task has not completed, attempts to process at most the  given number of other unprocessed tasks for which this task is  on the completion path, if any are known to exist.
java.util.concurrent.CountedCompleter#internalPropagateException(Throwable)->void:::Supports ForkJoinTask exception propagation.
java.util.concurrent.CountedCompleter#exec()->boolean:::Implements execution conventions for CountedCompleters.
java.util.concurrent.CountedCompleter#getRawResult()->T:::Returns the result of the computation
java.util.concurrent.CountedCompleter#setRawResult(T)->void:::A method that result-bearing CountedCompleters may optionally  use to help maintain result data
java.util.concurrent.CyclicBarrier#getParties()->int:::Returns the number of parties required to trip this barrier.
java.util.concurrent.CyclicBarrier#await()->int:::Waits until all {@linkplain #getParties parties} have invoked  {@code await} on this barrier
java.util.concurrent.CyclicBarrier#await(long, TimeUnit)->int:::Waits until all {@linkplain #getParties parties} have invoked  {@code await} on this barrier, or the specified waiting time elapses
java.util.concurrent.CyclicBarrier#isBroken()->boolean:::Queries if this barrier is in a broken state.
java.util.concurrent.CyclicBarrier#reset()->void:::Resets the barrier to its initial state
java.util.concurrent.CyclicBarrier#getNumberWaiting()->int:::Returns the number of parties currently waiting at the barrier
java.util.concurrent.Delayed#getDelay(TimeUnit)->long:::Returns the remaining delay associated with this object, in the  given time unit.
java.util.concurrent.DelayQueue#add(E)->boolean:::Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue#offer(E)->boolean:::Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue#put(E)->void:::Inserts the specified element into this delay queue
java.util.concurrent.DelayQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this delay queue
java.util.concurrent.DelayQueue#poll()->E:::Retrieves and removes the head of this queue, or returns {@code null}  if this queue has no elements with an expired delay.
java.util.concurrent.DelayQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary  until an element with an expired delay is available on this queue.
java.util.concurrent.DelayQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting if necessary  until an element with an expired delay is available on this queue,  or the specified wait time expires.
java.util.concurrent.DelayQueue#peek()->E:::Retrieves, but does not remove, the head of this queue, or  returns {@code null} if this queue is empty
java.util.concurrent.DelayQueue#size()->int:::
java.util.concurrent.DelayQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.DelayQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.DelayQueue#clear()->void:::Atomically removes all of the elements from this delay queue
java.util.concurrent.DelayQueue#remainingCapacity()->int:::Always returns {@code Integer.MAX_VALUE} because  a {@code DelayQueue} is not capacity constrained.
java.util.concurrent.DelayQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue
java.util.concurrent.DelayQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue; the  runtime type of the returned array is that of the specified array
java.util.concurrent.DelayQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this  queue, if it is present, whether or not it has expired.
java.util.concurrent.DelayQueue#removeEQ(Object)->void:::Identity-based version for use in Itr.remove.
java.util.concurrent.DelayQueue#iterator()->Iterator<E>:::Returns an iterator over all the elements (both expired and  unexpired) in this queue
java.util.concurrent.DelayQueue.Itr#hasNext()->boolean:::
java.util.concurrent.DelayQueue.Itr#next()->E:::
java.util.concurrent.DelayQueue.Itr#remove()->void:::
java.util.concurrent.Exchanger.Participant#initialValue()->Node:::
java.util.concurrent.Exchanger#exchange(V)->V:::Waits for another thread to arrive at this exchange point (unless  the current thread is {@linkplain Thread#interrupt interrupted}),  and then transfers the given object to it, receiving its object  in return
java.util.concurrent.Exchanger#exchange(V, long, TimeUnit)->V:::Waits for another thread to arrive at this exchange point (unless  the current thread is {@linkplain Thread#interrupt interrupted} or  the specified waiting time elapses), and then transfers the given  object to it, receiving its object in return
java.util.concurrent.Executor#execute(Runnable)->void:::Executes the given command at some time in the future
java.util.concurrent.ExecutorCompletionService.QueueingFuture#done()->void:::
java.util.concurrent.ExecutorCompletionService#submit(Callable<V>)->Future<V>:::
java.util.concurrent.ExecutorCompletionService#submit(Runnable, V)->Future<V>:::
java.util.concurrent.ExecutorCompletionService#take()->Future<V>:::
java.util.concurrent.ExecutorCompletionService#poll()->Future<V>:::
java.util.concurrent.ExecutorCompletionService#poll(long, TimeUnit)->Future<V>:::
java.util.concurrent.Executors#newFixedThreadPool(int)->ExecutorService:::Creates a thread pool that reuses a fixed number of threads  operating off a shared unbounded queue
java.util.concurrent.Executors#newWorkStealingPool(int)->ExecutorService:::Creates a thread pool that maintains enough threads to support  the given parallelism level, and may use multiple queues to  reduce contention
java.util.concurrent.Executors#newWorkStealingPool()->ExecutorService:::Creates a work-stealing thread pool using the number of  {@linkplain Runtime#availableProcessors available processors}  as its target parallelism level.
java.util.concurrent.Executors#newFixedThreadPool(int, ThreadFactory)->ExecutorService:::Creates a thread pool that reuses a fixed number of threads  operating off a shared unbounded queue, using the provided  ThreadFactory to create new threads when needed
java.util.concurrent.Executors#newSingleThreadExecutor()->ExecutorService:::Creates an Executor that uses a single worker thread operating  off an unbounded queue
java.util.concurrent.Executors#newSingleThreadExecutor(ThreadFactory)->ExecutorService:::Creates an Executor that uses a single worker thread operating  off an unbounded queue, and uses the provided ThreadFactory to  create a new thread when needed
java.util.concurrent.Executors#newCachedThreadPool()->ExecutorService:::Creates a thread pool that creates new threads as needed, but  will reuse previously constructed threads when they are  available
java.util.concurrent.Executors#newCachedThreadPool(ThreadFactory)->ExecutorService:::Creates a thread pool that creates new threads as needed, but  will reuse previously constructed threads when they are  available, and uses the provided  ThreadFactory to create new threads when needed.
java.util.concurrent.Executors#newSingleThreadScheduledExecutor()->ScheduledExecutorService:::Creates a single-threaded executor that can schedule commands  to run after a given delay, or to execute periodically
java.util.concurrent.Executors#newSingleThreadScheduledExecutor(ThreadFactory)->ScheduledExecutorService:::Creates a single-threaded executor that can schedule commands  to run after a given delay, or to execute periodically
java.util.concurrent.Executors#newScheduledThreadPool(int)->ScheduledExecutorService:::Creates a thread pool that can schedule commands to run after a  given delay, or to execute periodically.
java.util.concurrent.Executors#newScheduledThreadPool(int, ThreadFactory)->ScheduledExecutorService:::Creates a thread pool that can schedule commands to run after a  given delay, or to execute periodically.
java.util.concurrent.Executors#unconfigurableExecutorService(ExecutorService)->ExecutorService:::Returns an object that delegates all defined {@link  ExecutorService} methods to the given executor, but not any  other methods that might otherwise be accessible using  casts
java.util.concurrent.Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService)->ScheduledExecutorService:::Returns an object that delegates all defined {@link  ScheduledExecutorService} methods to the given executor, but  not any other methods that might otherwise be accessible using  casts
java.util.concurrent.Executors#defaultThreadFactory()->ThreadFactory:::Returns a default thread factory used to create new threads
java.util.concurrent.Executors#privilegedThreadFactory()->ThreadFactory:::Returns a thread factory used to create new threads that  have the same permissions as the current thread
java.util.concurrent.Executors#callable(Runnable, T)->Callable<T>:::Returns a {@link Callable} object that, when  called, runs the given task and returns the given result
java.util.concurrent.Executors#callable(Runnable)->Callable<Object>:::Returns a {@link Callable} object that, when  called, runs the given task and returns {@code null}.
java.util.concurrent.Executors#callable(PrivilegedAction<?>)->Callable<Object>:::Returns a {@link Callable} object that, when  called, runs the given privileged action and returns its result.
java.util.concurrent.Executors#callable(PrivilegedExceptionAction<?>)->Callable<Object>:::Returns a {@link Callable} object that, when  called, runs the given privileged exception action and returns  its result.
java.util.concurrent.Executors#privilegedCallable(Callable<T>)->Callable<T>:::Returns a {@link Callable} object that will, when called,  execute the given {@code callable} under the current access  control context
java.util.concurrent.Executors#privilegedCallableUsingCurrentClassLoader(Callable<T>)->Callable<T>:::Returns a {@link Callable} object that will, when called,  execute the given {@code callable} under the current access  control context, with the current context class loader as the  context class loader
java.util.concurrent.Executors.RunnableAdapter#call()->T:::
java.util.concurrent.Executors.RunnableAdapter#toString()->String:::
java.util.concurrent.Executors.PrivilegedCallable#call()->T:::
java.util.concurrent.Executors.PrivilegedCallable#toString()->String:::
java.util.concurrent.Executors.PrivilegedCallableUsingCurrentClassLoader#call()->T:::
java.util.concurrent.Executors.PrivilegedCallableUsingCurrentClassLoader#toString()->String:::
java.util.concurrent.Executors.DefaultThreadFactory#newThread(Runnable)->Thread:::
java.util.concurrent.Executors.PrivilegedThreadFactory#newThread(Runnable)->Thread:::
java.util.concurrent.Executors.DelegatedExecutorService#execute(Runnable)->void:::
java.util.concurrent.Executors.DelegatedExecutorService#shutdown()->void:::
java.util.concurrent.Executors.DelegatedExecutorService#shutdownNow()->List<Runnable>:::
java.util.concurrent.Executors.DelegatedExecutorService#isShutdown()->boolean:::
java.util.concurrent.Executors.DelegatedExecutorService#isTerminated()->boolean:::
java.util.concurrent.Executors.DelegatedExecutorService#awaitTermination(long, TimeUnit)->boolean:::
java.util.concurrent.Executors.DelegatedExecutorService#submit(Runnable)->Future<?>:::
java.util.concurrent.Executors.DelegatedExecutorService#submit(Callable<T>)->Future<T>:::
java.util.concurrent.Executors.DelegatedExecutorService#submit(Runnable, T)->Future<T>:::
java.util.concurrent.Executors.DelegatedExecutorService#invokeAll(Collection<? extends Callable<T>>)->List<Future<T>>:::
java.util.concurrent.Executors.DelegatedExecutorService#invokeAll(Collection<? extends Callable<T>>, long, TimeUnit)->List<Future<T>>:::
java.util.concurrent.Executors.DelegatedExecutorService#invokeAny(Collection<? extends Callable<T>>)->T:::
java.util.concurrent.Executors.DelegatedExecutorService#invokeAny(Collection<? extends Callable<T>>, long, TimeUnit)->T:::
java.util.concurrent.Executors.FinalizableDelegatedExecutorService#finalize()->void:::
java.util.concurrent.Executors.DelegatedScheduledExecutorService#schedule(Runnable, long, TimeUnit)->ScheduledFuture<?>:::
java.util.concurrent.Executors.DelegatedScheduledExecutorService#schedule(Callable<V>, long, TimeUnit)->ScheduledFuture<V>:::
java.util.concurrent.Executors.DelegatedScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::
java.util.concurrent.Executors.DelegatedScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::
java.util.concurrent.ExecutorService#shutdown()->void:::Initiates an orderly shutdown in which previously submitted  tasks are executed, but no new tasks will be accepted
java.util.concurrent.ExecutorService#shutdownNow()->List<Runnable>:::Attempts to stop all actively executing tasks, halts the  processing of waiting tasks, and returns a list of the tasks  that were awaiting execution
java.util.concurrent.ExecutorService#isShutdown()->boolean:::Returns {@code true} if this executor has been shut down.
java.util.concurrent.ExecutorService#isTerminated()->boolean:::Returns {@code true} if all tasks have completed following shut down
java.util.concurrent.ExecutorService#awaitTermination(long, TimeUnit)->boolean:::Blocks until all tasks have completed execution after a shutdown  request, or the timeout occurs, or the current thread is  interrupted, whichever happens first.
java.util.concurrent.ExecutorService#submit(Callable<T>)->Future<T>:::Submits a value-returning task for execution and returns a  Future representing the pending results of the task
java.util.concurrent.ExecutorService#submit(Runnable, T)->Future<T>:::Submits a Runnable task for execution and returns a Future  representing that task
java.util.concurrent.ExecutorService#submit(Runnable)->Future<?>:::Submits a Runnable task for execution and returns a Future  representing that task
java.util.concurrent.ExecutorService#invokeAll(Collection<? extends Callable<T>>)->List<Future<T>>:::Executes the given tasks, returning a list of Futures holding  their status and results when all complete
java.util.concurrent.ExecutorService#invokeAll(Collection<? extends Callable<T>>, long, TimeUnit)->List<Future<T>>:::Executes the given tasks, returning a list of Futures holding  their status and results  when all complete or the timeout expires, whichever happens first
java.util.concurrent.ExecutorService#invokeAny(Collection<? extends Callable<T>>)->T:::Executes the given tasks, returning the result  of one that has completed successfully (i.e., without throwing  an exception), if any do
java.util.concurrent.ExecutorService#invokeAny(Collection<? extends Callable<T>>, long, TimeUnit)->T:::Executes the given tasks, returning the result  of one that has completed successfully (i.e., without throwing  an exception), if any do before the given timeout elapses
java.util.concurrent.Flow.Publisher#subscribe(Subscriber<? super T>)->void:::Adds the given Subscriber if possible
java.util.concurrent.Flow.Subscriber#onSubscribe(Subscription)->void:::Method invoked prior to invoking any other Subscriber  methods for the given Subscription
java.util.concurrent.Flow.Subscriber#onNext(T)->void:::Method invoked with a Subscription's next item
java.util.concurrent.Flow.Subscriber#onError(Throwable)->void:::Method invoked upon an unrecoverable error encountered by a  Publisher or Subscription, after which no other Subscriber  methods are invoked by the Subscription
java.util.concurrent.Flow.Subscriber#onComplete()->void:::Method invoked when it is known that no additional  Subscriber method invocations will occur for a Subscription  that is not already terminated by error, after which no  other Subscriber methods are invoked by the Subscription
java.util.concurrent.Flow.Subscription#request(long)->void:::Adds the given number {@code n} of items to the current  unfulfilled demand for this subscription
java.util.concurrent.Flow.Subscription#cancel()->void:::Causes the Subscriber to (eventually) stop receiving  messages
java.util.concurrent.Flow#defaultBufferSize()->int:::Returns a default value for Publisher or Subscriber buffering,  that may be used in the absence of other constraints.
java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory#newThread(ForkJoinPool)->ForkJoinWorkerThread:::Returns a new worker thread operating in the given pool
java.util.concurrent.ForkJoinPool#contextWithPermissions(Permission...)->AccessControlContext:::
java.util.concurrent.ForkJoinPool.DefaultForkJoinWorkerThreadFactory#newThread(ForkJoinPool)->ForkJoinWorkerThread:::
java.util.concurrent.ForkJoinPool.WorkQueue#tryLockPhase()->boolean:::Tries to lock shared queue by CASing phase field.
java.util.concurrent.ForkJoinPool.WorkQueue#releasePhaseLock()->void:::
java.util.concurrent.ForkJoinPool.WorkQueue#getPoolIndex()->int:::Returns an exportable index (used by ForkJoinWorkerThread).
java.util.concurrent.ForkJoinPool.WorkQueue#queueSize()->int:::Returns the approximate number of tasks in the queue.
java.util.concurrent.ForkJoinPool.WorkQueue#isEmpty()->boolean:::Provides a more accurate estimate of whether this queue has  any tasks than does queueSize, by checking whether a  near-empty queue has at least one unclaimed task.
java.util.concurrent.ForkJoinPool.WorkQueue#push(ForkJoinTask<?>)->void:::Pushes a task
java.util.concurrent.ForkJoinPool.WorkQueue#lockedPush(ForkJoinTask<?>)->boolean:::Version of push for shared queues
java.util.concurrent.ForkJoinPool.WorkQueue#growArray(boolean)->void:::Doubles the capacity of array
java.util.concurrent.ForkJoinPool.WorkQueue#poll()->ForkJoinTask<?>:::Takes next task, if one exists, in FIFO order.
java.util.concurrent.ForkJoinPool.WorkQueue#nextLocalTask()->ForkJoinTask<?>:::Takes next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue#peek()->ForkJoinTask<?>:::Returns next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue#tryUnpush(ForkJoinTask<?>)->boolean:::Pops the given task only if it is at the current top.
java.util.concurrent.ForkJoinPool.WorkQueue#tryLockedUnpush(ForkJoinTask<?>)->boolean:::Shared version of tryUnpush.
java.util.concurrent.ForkJoinPool.WorkQueue#cancelAll()->void:::Removes and cancels all known tasks, ignoring any exceptions.
java.util.concurrent.ForkJoinPool.WorkQueue#topLevelExec(ForkJoinTask<?>, WorkQueue, int)->void:::Runs the given (stolen) task if nonnull, as well as  remaining local tasks and others available from the given  queue, up to bound n (to avoid infinite unfairness).
java.util.concurrent.ForkJoinPool.WorkQueue#tryRemoveAndExec(ForkJoinTask<?>)->void:::If present, removes task from queue and executes it.
java.util.concurrent.ForkJoinPool.WorkQueue#helpCC(CountedCompleter<?>, int, boolean)->int:::Tries to pop and run tasks within the target's computation  until done, not found, or limit exceeded.
java.util.concurrent.ForkJoinPool.WorkQueue#helpAsyncBlocker(ManagedBlocker)->void:::Tries to poll and run AsynchronousCompletionTasks until  none found or blocker is released
java.util.concurrent.ForkJoinPool.WorkQueue#isApparentlyUnblocked()->boolean:::Returns true if owned and not known to be blocked.
java.util.concurrent.ForkJoinPool#registerWorker(ForkJoinWorkerThread)->WorkQueue:::Callback from ForkJoinWorkerThread constructor to establish and  record its WorkQueue.
java.util.concurrent.ForkJoinPool#deregisterWorker(ForkJoinWorkerThread, Throwable)->void:::Final callback from terminating worker, as well as upon failure  to construct or start a worker
java.util.concurrent.ForkJoinPool#signalWork()->void:::Tries to create or release a worker if too few are running.
java.util.concurrent.ForkJoinPool#runWorker(WorkQueue)->void:::Top-level runloop for workers, called by ForkJoinWorkerThread.run
java.util.concurrent.ForkJoinPool#awaitJoin(WorkQueue, ForkJoinTask<?>, long)->int:::Helps and/or blocks until the given task is done or timeout
java.util.concurrent.ForkJoinPool#helpQuiescePool(WorkQueue)->void:::Runs tasks until {@code isQuiescent()}
java.util.concurrent.ForkJoinPool#nextTaskFor(WorkQueue)->ForkJoinTask<?>:::Gets and removes a local or stolen task for the given worker.
java.util.concurrent.ForkJoinPool#externalPush(ForkJoinTask<?>)->void:::Adds the given task to a submission queue at submitter's  current queue, creating one if null or contended.
java.util.concurrent.ForkJoinPool#commonSubmitterQueue()->WorkQueue:::Returns common pool queue for an external thread.
java.util.concurrent.ForkJoinPool#tryExternalUnpush(ForkJoinTask<?>)->boolean:::Performs tryUnpush for an external submitter.
java.util.concurrent.ForkJoinPool#externalHelpComplete(CountedCompleter<?>, int)->int:::Performs helpComplete for an external submitter.
java.util.concurrent.ForkJoinPool#helpComplete(WorkQueue, CountedCompleter<?>, int)->int:::Tries to steal and run tasks within the target's computation
java.util.concurrent.ForkJoinPool#getSurplusQueuedTaskCount()->int:::Returns a cheap heuristic guide for task partitioning when  programmers, frameworks, tools, or languages have little or no  idea about task granularity
java.util.concurrent.ForkJoinPool#commonPool()->ForkJoinPool:::Returns the common pool instance
java.util.concurrent.ForkJoinPool#invoke(ForkJoinTask<T>)->T:::Performs the given task, returning its result upon completion
java.util.concurrent.ForkJoinPool#execute(ForkJoinTask<?>)->void:::Arranges for (asynchronous) execution of the given task.
java.util.concurrent.ForkJoinPool#execute(Runnable)->void:::
java.util.concurrent.ForkJoinPool#submit(ForkJoinTask<T>)->ForkJoinTask<T>:::Submits a ForkJoinTask for execution.
java.util.concurrent.ForkJoinPool#submit(Callable<T>)->ForkJoinTask<T>:::
java.util.concurrent.ForkJoinPool#submit(Runnable, T)->ForkJoinTask<T>:::
java.util.concurrent.ForkJoinPool#submit(Runnable)->ForkJoinTask<?>:::
java.util.concurrent.ForkJoinPool#invokeAll(Collection<? extends Callable<T>>)->List<Future<T>>:::
java.util.concurrent.ForkJoinPool#getFactory()->ForkJoinWorkerThreadFactory:::Returns the factory used for constructing new workers.
java.util.concurrent.ForkJoinPool#getUncaughtExceptionHandler()->UncaughtExceptionHandler:::Returns the handler for internal worker threads that terminate  due to unrecoverable errors encountered while executing tasks.
java.util.concurrent.ForkJoinPool#getParallelism()->int:::Returns the targeted parallelism level of this pool.
java.util.concurrent.ForkJoinPool#getCommonPoolParallelism()->int:::Returns the targeted parallelism level of the common pool.
java.util.concurrent.ForkJoinPool#getPoolSize()->int:::Returns the number of worker threads that have started but not  yet terminated
java.util.concurrent.ForkJoinPool#getAsyncMode()->boolean:::Returns {@code true} if this pool uses local first-in-first-out  scheduling mode for forked tasks that are never joined.
java.util.concurrent.ForkJoinPool#getRunningThreadCount()->int:::Returns an estimate of the number of worker threads that are  not blocked waiting to join tasks or for other managed  synchronization
java.util.concurrent.ForkJoinPool#getActiveThreadCount()->int:::Returns an estimate of the number of threads that are currently  stealing or executing tasks
java.util.concurrent.ForkJoinPool#isQuiescent()->boolean:::Returns {@code true} if all worker threads are currently idle
java.util.concurrent.ForkJoinPool#getStealCount()->long:::Returns an estimate of the total number of tasks stolen from  one thread's work queue by another
java.util.concurrent.ForkJoinPool#getQueuedTaskCount()->long:::Returns an estimate of the total number of tasks currently held  in queues by worker threads (but not including tasks submitted  to the pool that have not begun executing)
java.util.concurrent.ForkJoinPool#getQueuedSubmissionCount()->int:::Returns an estimate of the number of tasks submitted to this  pool that have not yet begun executing
java.util.concurrent.ForkJoinPool#hasQueuedSubmissions()->boolean:::Returns {@code true} if there are any tasks submitted to this  pool that have not yet begun executing.
java.util.concurrent.ForkJoinPool#pollSubmission()->ForkJoinTask<?>:::Removes and returns the next unexecuted submission if one is  available
java.util.concurrent.ForkJoinPool#drainTasksTo(Collection<? super ForkJoinTask<?>>)->int:::Removes all available unexecuted submitted and forked tasks  from scheduling queues and adds them to the given collection,  without altering their execution status
java.util.concurrent.ForkJoinPool#toString()->String:::Returns a string identifying this pool, as well as its state,  including indications of run state, parallelism level, and  worker and task counts.
java.util.concurrent.ForkJoinPool#shutdown()->void:::Possibly initiates an orderly shutdown in which previously  submitted tasks are executed, but no new tasks will be  accepted
java.util.concurrent.ForkJoinPool#shutdownNow()->List<Runnable>:::Possibly attempts to cancel and/or stop all tasks, and reject  all subsequently submitted tasks
java.util.concurrent.ForkJoinPool#isTerminated()->boolean:::Returns {@code true} if all tasks have completed following shut down.
java.util.concurrent.ForkJoinPool#isTerminating()->boolean:::Returns {@code true} if the process of termination has  commenced but not yet completed
java.util.concurrent.ForkJoinPool#isShutdown()->boolean:::Returns {@code true} if this pool has been shut down.
java.util.concurrent.ForkJoinPool#awaitTermination(long, TimeUnit)->boolean:::Blocks until all tasks have completed execution after a  shutdown request, or the timeout occurs, or the current thread  is interrupted, whichever happens first
java.util.concurrent.ForkJoinPool#awaitQuiescence(long, TimeUnit)->boolean:::If called by a ForkJoinTask operating in this pool, equivalent  in effect to {@link ForkJoinTask#helpQuiesce}
java.util.concurrent.ForkJoinPool#quiesceCommonPool()->void:::Waits and/or attempts to assist performing tasks indefinitely  until the {@link #commonPool()} {@link #isQuiescent}.
java.util.concurrent.ForkJoinPool.ManagedBlocker#block()->boolean:::Possibly blocks the current thread, for example waiting for  a lock or condition.
java.util.concurrent.ForkJoinPool.ManagedBlocker#isReleasable()->boolean:::Returns {@code true} if blocking is unnecessary.
java.util.concurrent.ForkJoinPool#managedBlock(ManagedBlocker)->void:::Runs the given possibly blocking task
java.util.concurrent.ForkJoinPool#helpAsyncBlocker(Executor, ManagedBlocker)->void:::If the given executor is a ForkJoinPool, poll and execute  AsynchronousCompletionTasks from worker's queue until none are  available or blocker is released.
java.util.concurrent.ForkJoinPool#newTaskFor(Runnable, T)->RunnableFuture<T>:::
java.util.concurrent.ForkJoinPool#newTaskFor(Callable<T>)->RunnableFuture<T>:::
java.util.concurrent.ForkJoinPool.InnocuousForkJoinWorkerThreadFactory#newThread(ForkJoinPool)->ForkJoinWorkerThread:::
java.util.concurrent.ForkJoinTask#isExceptionalStatus(int)->boolean:::
java.util.concurrent.ForkJoinTask#doExec()->int:::Primary execution method for stolen tasks
java.util.concurrent.ForkJoinTask#internalWait(long)->void:::If not done, sets SIGNAL status and performs Object.wait(timeout)
java.util.concurrent.ForkJoinTask#recordExceptionalCompletion(Throwable)->int:::Records exception and sets status.
java.util.concurrent.ForkJoinTask#internalPropagateException(Throwable)->void:::Hook for exception propagation support for tasks with completers.
java.util.concurrent.ForkJoinTask#cancelIgnoringExceptions(ForkJoinTask<?>)->void:::Cancels, ignoring any exceptions thrown by cancel
java.util.concurrent.ForkJoinTask#helpExpungeStaleExceptions()->void:::If lock is available, polls stale refs and removes them
java.util.concurrent.ForkJoinTask#rethrow(Throwable)->void:::A version of "sneaky throw" to relay exceptions.
java.util.concurrent.ForkJoinTask#uncheckedThrow(Throwable)->void:::The sneaky part of sneaky throw, relying on generics  limitations to evade compiler complaints about rethrowing  unchecked exceptions.
java.util.concurrent.ForkJoinTask#fork()->ForkJoinTask<V>:::Arranges to asynchronously execute this task in the pool the  current task is running in, if applicable, or using the {@link  ForkJoinPool#commonPool()} if not {@link #inForkJoinPool}
java.util.concurrent.ForkJoinTask#join()->V:::Returns the result of the computation when it  {@linkplain #isDone is done}
java.util.concurrent.ForkJoinTask#invoke()->V:::Commences performing this task, awaits its completion if  necessary, and returns its result, or throws an (unchecked)  {@code RuntimeException} or {@code Error} if the underlying  computation did so.
java.util.concurrent.ForkJoinTask#invokeAll(ForkJoinTask<?>, ForkJoinTask<?>)->void:::Forks the given tasks, returning when {@code isDone} holds for  each task or an (unchecked) exception is encountered, in which  case the exception is rethrown
java.util.concurrent.ForkJoinTask#invokeAll(ForkJoinTask<?>...)->void:::Forks the given tasks, returning when {@code isDone} holds for  each task or an (unchecked) exception is encountered, in which  case the exception is rethrown
java.util.concurrent.ForkJoinTask#invokeAll(Collection<T>)->Collection<T>:::Forks all tasks in the specified collection, returning when  {@code isDone} holds for each task or an (unchecked) exception  is encountered, in which case the exception is rethrown
java.util.concurrent.ForkJoinTask#cancel(boolean)->boolean:::Attempts to cancel execution of this task
java.util.concurrent.ForkJoinTask#isDone()->boolean:::
java.util.concurrent.ForkJoinTask#isCancelled()->boolean:::
java.util.concurrent.ForkJoinTask#isCompletedAbnormally()->boolean:::Returns {@code true} if this task threw an exception or was cancelled.
java.util.concurrent.ForkJoinTask#isCompletedNormally()->boolean:::Returns {@code true} if this task completed without throwing an  exception and was not cancelled.
java.util.concurrent.ForkJoinTask#getException()->Throwable:::Returns the exception thrown by the base computation, or a  {@code CancellationException} if cancelled, or {@code null} if  none or if the method has not yet completed.
java.util.concurrent.ForkJoinTask#completeExceptionally(Throwable)->void:::Completes this task abnormally, and if not already aborted or  cancelled, causes it to throw the given exception upon  {@code join} and related operations
java.util.concurrent.ForkJoinTask#complete(V)->void:::Completes this task, and if not already aborted or cancelled,  returning the given value as the result of subsequent  invocations of {@code join} and related operations
java.util.concurrent.ForkJoinTask#quietlyComplete()->void:::Completes this task normally without setting a value
java.util.concurrent.ForkJoinTask#get()->V:::Waits if necessary for the computation to complete, and then  retrieves its result.
java.util.concurrent.ForkJoinTask#get(long, TimeUnit)->V:::Waits if necessary for at most the given time for the computation  to complete, and then retrieves its result, if available.
java.util.concurrent.ForkJoinTask#quietlyJoin()->void:::Joins this task, without returning its result or throwing its  exception
java.util.concurrent.ForkJoinTask#quietlyInvoke()->void:::Commences performing this task and awaits its completion if  necessary, without returning its result or throwing its  exception.
java.util.concurrent.ForkJoinTask#helpQuiesce()->void:::Possibly executes tasks until the pool hosting the current task  {@linkplain ForkJoinPool#isQuiescent is quiescent}
java.util.concurrent.ForkJoinTask#reinitialize()->void:::Resets the internal bookkeeping state of this task, allowing a  subsequent {@code fork}
java.util.concurrent.ForkJoinTask#getPool()->ForkJoinPool:::Returns the pool hosting the current thread, or {@code null}  if the current thread is executing outside of any ForkJoinPool
java.util.concurrent.ForkJoinTask#inForkJoinPool()->boolean:::Returns {@code true} if the current thread is a {@link  ForkJoinWorkerThread} executing as a ForkJoinPool computation.
java.util.concurrent.ForkJoinTask#tryUnfork()->boolean:::Tries to unschedule this task for execution
java.util.concurrent.ForkJoinTask#getQueuedTaskCount()->int:::Returns an estimate of the number of tasks that have been  forked by the current worker thread but not yet executed
java.util.concurrent.ForkJoinTask#getSurplusQueuedTaskCount()->int:::Returns an estimate of how many more locally queued tasks are  held by the current worker thread than there are other worker  threads that might steal them, or zero if this thread is not  operating in a ForkJoinPool
java.util.concurrent.ForkJoinTask#getRawResult()->V:::Returns the result that would be returned by {@link #join}, even  if this task completed abnormally, or {@code null} if this task  is not known to have been completed
java.util.concurrent.ForkJoinTask#setRawResult(V)->void:::Forces the given value to be returned as a result
java.util.concurrent.ForkJoinTask#exec()->boolean:::Immediately performs the base action of this task and returns  true if, upon return from this method, this task is guaranteed  to have completed normally
java.util.concurrent.ForkJoinTask#peekNextLocalTask()->ForkJoinTask<?>:::Returns, but does not unschedule or execute, a task queued by  the current thread but not yet executed, if one is immediately  available
java.util.concurrent.ForkJoinTask#pollNextLocalTask()->ForkJoinTask<?>:::Unschedules and returns, without executing, the next task  queued by the current thread but not yet executed, if the  current thread is operating in a ForkJoinPool
java.util.concurrent.ForkJoinTask#pollTask()->ForkJoinTask<?>:::If the current thread is operating in a ForkJoinPool,  unschedules and returns, without executing, the next task  queued by the current thread but not yet executed, if one is  available, or if not available, a task that was forked by some  other thread, if available
java.util.concurrent.ForkJoinTask#pollSubmission()->ForkJoinTask<?>:::If the current thread is operating in a ForkJoinPool,  unschedules and returns, without executing, a task externally  submitted to the pool, if one is available
java.util.concurrent.ForkJoinTask#getForkJoinTaskTag()->short:::Returns the tag for this task.
java.util.concurrent.ForkJoinTask#setForkJoinTaskTag(short)->short:::Atomically sets the tag value for this task and returns the old value.
java.util.concurrent.ForkJoinTask#compareAndSetForkJoinTaskTag(short, short)->boolean:::Atomically conditionally sets the tag value for this task
java.util.concurrent.ForkJoinTask.AdaptedRunnable#getRawResult()->T:::
java.util.concurrent.ForkJoinTask.AdaptedRunnable#setRawResult(T)->void:::
java.util.concurrent.ForkJoinTask.AdaptedRunnable#exec()->boolean:::
java.util.concurrent.ForkJoinTask.AdaptedRunnable#run()->void:::
java.util.concurrent.ForkJoinTask.AdaptedRunnable#toString()->String:::
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#getRawResult()->Void:::
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#setRawResult(Void)->void:::
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#exec()->boolean:::
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#run()->void:::
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#toString()->String:::
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#getRawResult()->Void:::
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#setRawResult(Void)->void:::
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#exec()->boolean:::
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#internalPropagateException(Throwable)->void:::
java.util.concurrent.ForkJoinTask.AdaptedCallable#getRawResult()->T:::
java.util.concurrent.ForkJoinTask.AdaptedCallable#setRawResult(T)->void:::
java.util.concurrent.ForkJoinTask.AdaptedCallable#exec()->boolean:::
java.util.concurrent.ForkJoinTask.AdaptedCallable#run()->void:::
java.util.concurrent.ForkJoinTask.AdaptedCallable#toString()->String:::
java.util.concurrent.ForkJoinTask#adapt(Runnable)->ForkJoinTask<?>:::Returns a new {@code ForkJoinTask} that performs the {@code run}  method of the given {@code Runnable} as its action, and returns  a null result upon {@link #join}.
java.util.concurrent.ForkJoinTask#adapt(Runnable, T)->ForkJoinTask<T>:::Returns a new {@code ForkJoinTask} that performs the {@code run}  method of the given {@code Runnable} as its action, and returns  the given result upon {@link #join}.
java.util.concurrent.ForkJoinTask#adapt(Callable<? extends T>)->ForkJoinTask<T>:::Returns a new {@code ForkJoinTask} that performs the {@code call}  method of the given {@code Callable} as its action, and returns  its result upon {@link #join}, translating any checked exceptions  encountered into {@code RuntimeException}.
java.util.concurrent.ForkJoinWorkerThread#getPool()->ForkJoinPool:::Returns the pool hosting this thread.
java.util.concurrent.ForkJoinWorkerThread#getPoolIndex()->int:::Returns the unique index number of this thread in its pool
java.util.concurrent.ForkJoinWorkerThread#onStart()->void:::Initializes internal state after construction but before  processing any tasks
java.util.concurrent.ForkJoinWorkerThread#onTermination(Throwable)->void:::Performs cleanup associated with termination of this worker  thread
java.util.concurrent.ForkJoinWorkerThread#run()->void:::This method is required to be public, but should never be  called explicitly
java.util.concurrent.ForkJoinWorkerThread#afterTopLevelExec()->void:::Non-public hook method for InnocuousForkJoinWorkerThread.
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#afterTopLevelExec()->void:::
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setUncaughtExceptionHandler(UncaughtExceptionHandler)->void:::
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setContextClassLoader(ClassLoader)->void:::
java.util.concurrent.Future#cancel(boolean)->boolean:::Attempts to cancel execution of this task
java.util.concurrent.Future#isCancelled()->boolean:::Returns {@code true} if this task was cancelled before it completed  normally.
java.util.concurrent.Future#isDone()->boolean:::Returns {@code true} if this task completed
java.util.concurrent.Future#get()->V:::Waits if necessary for the computation to complete, and then  retrieves its result.
java.util.concurrent.Future#get(long, TimeUnit)->V:::Waits if necessary for at most the given time for the computation  to complete, and then retrieves its result, if available.
java.util.concurrent.FutureTask#isCancelled()->boolean:::
java.util.concurrent.FutureTask#isDone()->boolean:::
java.util.concurrent.FutureTask#cancel(boolean)->boolean:::
java.util.concurrent.FutureTask#get()->V:::
java.util.concurrent.FutureTask#get(long, TimeUnit)->V:::
java.util.concurrent.FutureTask#done()->void:::Protected method invoked when this task transitions to state  {@code isDone} (whether normally or via cancellation)
java.util.concurrent.FutureTask#set(V)->void:::Sets the result of this future to the given value unless  this future has already been set or has been cancelled
java.util.concurrent.FutureTask#setException(Throwable)->void:::Causes this future to report an {@link ExecutionException}  with the given throwable as its cause, unless this future has  already been set or has been cancelled
java.util.concurrent.FutureTask#run()->void:::
java.util.concurrent.FutureTask#runAndReset()->boolean:::Executes the computation without setting its result, and then  resets this future to initial state, failing to do so if the  computation encounters an exception or is cancelled
java.util.concurrent.FutureTask#toString()->String:::Returns a string representation of this FutureTask.
java.util.concurrent.Helpers#collectionToString(Collection<?>)->String:::An implementation of Collection.toString() suitable for classes  with locks
java.util.concurrent.Helpers#toString(Object[], int, int)->String:::Like Arrays.toString(), but caller guarantees that size > 0,  each element with index 0 <= i < size is a non-null String,  and charLength is the sum of the lengths of the input Strings.
java.util.concurrent.Helpers#mapEntryToString(Object, Object)->String:::Optimized form of: key + "=" + val
java.util.concurrent.LinkedBlockingDeque#unlink(Node<E>)->void:::Unlinks x.
java.util.concurrent.LinkedBlockingDeque#addFirst(E)->void:::
java.util.concurrent.LinkedBlockingDeque#addLast(E)->void:::
java.util.concurrent.LinkedBlockingDeque#offerFirst(E)->boolean:::
java.util.concurrent.LinkedBlockingDeque#offerLast(E)->boolean:::
java.util.concurrent.LinkedBlockingDeque#putFirst(E)->void:::
java.util.concurrent.LinkedBlockingDeque#putLast(E)->void:::
java.util.concurrent.LinkedBlockingDeque#offerFirst(E, long, TimeUnit)->boolean:::
java.util.concurrent.LinkedBlockingDeque#offerLast(E, long, TimeUnit)->boolean:::
java.util.concurrent.LinkedBlockingDeque#removeFirst()->E:::
java.util.concurrent.LinkedBlockingDeque#removeLast()->E:::
java.util.concurrent.LinkedBlockingDeque#pollFirst()->E:::
java.util.concurrent.LinkedBlockingDeque#pollLast()->E:::
java.util.concurrent.LinkedBlockingDeque#takeFirst()->E:::
java.util.concurrent.LinkedBlockingDeque#takeLast()->E:::
java.util.concurrent.LinkedBlockingDeque#pollFirst(long, TimeUnit)->E:::
java.util.concurrent.LinkedBlockingDeque#pollLast(long, TimeUnit)->E:::
java.util.concurrent.LinkedBlockingDeque#getFirst()->E:::
java.util.concurrent.LinkedBlockingDeque#getLast()->E:::
java.util.concurrent.LinkedBlockingDeque#peekFirst()->E:::
java.util.concurrent.LinkedBlockingDeque#peekLast()->E:::
java.util.concurrent.LinkedBlockingDeque#removeFirstOccurrence(Object)->boolean:::
java.util.concurrent.LinkedBlockingDeque#removeLastOccurrence(Object)->boolean:::
java.util.concurrent.LinkedBlockingDeque#add(E)->boolean:::Inserts the specified element at the end of this deque unless it would  violate capacity restrictions
java.util.concurrent.LinkedBlockingDeque#offer(E)->boolean:::
java.util.concurrent.LinkedBlockingDeque#put(E)->void:::
java.util.concurrent.LinkedBlockingDeque#offer(E, long, TimeUnit)->boolean:::
java.util.concurrent.LinkedBlockingDeque#remove()->E:::Retrieves and removes the head of the queue represented by this deque
java.util.concurrent.LinkedBlockingDeque#poll()->E:::
java.util.concurrent.LinkedBlockingDeque#take()->E:::
java.util.concurrent.LinkedBlockingDeque#poll(long, TimeUnit)->E:::
java.util.concurrent.LinkedBlockingDeque#element()->E:::Retrieves, but does not remove, the head of the queue represented by  this deque
java.util.concurrent.LinkedBlockingDeque#peek()->E:::
java.util.concurrent.LinkedBlockingDeque#remainingCapacity()->int:::Returns the number of additional elements that this deque can ideally  (in the absence of memory or resource constraints) accept without  blocking
java.util.concurrent.LinkedBlockingDeque#drainTo(Collection<? super E>)->int:::
java.util.concurrent.LinkedBlockingDeque#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.LinkedBlockingDeque#push(E)->void:::
java.util.concurrent.LinkedBlockingDeque#pop()->E:::
java.util.concurrent.LinkedBlockingDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.LinkedBlockingDeque#size()->int:::Returns the number of elements in this deque.
java.util.concurrent.LinkedBlockingDeque#contains(Object)->boolean:::Returns {@code true} if this deque contains the specified element
java.util.concurrent.LinkedBlockingDeque#addAll(Collection<? extends E>)->boolean:::Appends all of the elements in the specified collection to the end of  this deque, in the order that they are returned by the specified  collection's iterator
java.util.concurrent.LinkedBlockingDeque#toArray()->Object[]:::Returns an array containing all of the elements in this deque, in  proper sequence (from first to last element)
java.util.concurrent.LinkedBlockingDeque#toArray(T[])->T[]:::Returns an array containing all of the elements in this deque, in  proper sequence; the runtime type of the returned array is that of  the specified array
java.util.concurrent.LinkedBlockingDeque#toString()->String:::
java.util.concurrent.LinkedBlockingDeque#clear()->void:::Atomically removes all of the elements from this deque
java.util.concurrent.LinkedBlockingDeque#succ(Node<E>)->Node<E>:::Used for any element traversal that is not entirely under lock
java.util.concurrent.LinkedBlockingDeque#iterator()->Iterator<E>:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.LinkedBlockingDeque#descendingIterator()->Iterator<E>:::Returns an iterator over the elements in this deque in reverse  sequential order
java.util.concurrent.LinkedBlockingDeque.AbstractItr#firstNode()->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.AbstractItr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.AbstractItr#hasNext()->boolean:::
java.util.concurrent.LinkedBlockingDeque.AbstractItr#next()->E:::
java.util.concurrent.LinkedBlockingDeque.AbstractItr#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingDeque.AbstractItr#remove()->void:::
java.util.concurrent.LinkedBlockingDeque.Itr#firstNode()->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.Itr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.DescendingItr#firstNode()->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.DescendingItr#nextNode(Node<E>)->Node<E>:::
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator#estimateSize()->long:::
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator#trySplit()->Spliterator<E>:::
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator#characteristics()->int:::
java.util.concurrent.LinkedBlockingDeque#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this deque
java.util.concurrent.LinkedBlockingDeque#forEach(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingDeque#forEachFrom(Consumer<? super E>, Node<E>)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedBlockingDeque#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.LinkedBlockingDeque#removeAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedBlockingDeque#retainAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedBlockingDeque#checkInvariants()->void:::
java.util.concurrent.LinkedBlockingQueue#fullyLock()->void:::Locks to prevent both puts and takes.
java.util.concurrent.LinkedBlockingQueue#fullyUnlock()->void:::Unlocks to allow both puts and takes.
java.util.concurrent.LinkedBlockingQueue#size()->int:::Returns the number of elements in this queue.
java.util.concurrent.LinkedBlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally  (in the absence of memory or resource constraints) accept without  blocking
java.util.concurrent.LinkedBlockingQueue#put(E)->void:::Inserts the specified element at the tail of this queue, waiting if  necessary for space to become available.
java.util.concurrent.LinkedBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue, waiting if  necessary up to the specified wait time for space to become available.
java.util.concurrent.LinkedBlockingQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue if it is  possible to do so immediately without exceeding the queue's capacity,  returning {@code true} upon success and {@code false} if this queue  is full
java.util.concurrent.LinkedBlockingQueue#take()->E:::
java.util.concurrent.LinkedBlockingQueue#poll(long, TimeUnit)->E:::
java.util.concurrent.LinkedBlockingQueue#poll()->E:::
java.util.concurrent.LinkedBlockingQueue#peek()->E:::
java.util.concurrent.LinkedBlockingQueue#unlink(Node<E>, Node<E>)->void:::Unlinks interior Node p with predecessor pred.
java.util.concurrent.LinkedBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.LinkedBlockingQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.LinkedBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in  proper sequence
java.util.concurrent.LinkedBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in  proper sequence; the runtime type of the returned array is that of  the specified array
java.util.concurrent.LinkedBlockingQueue#toString()->String:::
java.util.concurrent.LinkedBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.LinkedBlockingQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.LinkedBlockingQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.LinkedBlockingQueue#succ(Node<E>)->Node<E>:::Used for any element traversal that is not entirely under lock
java.util.concurrent.LinkedBlockingQueue#iterator()->Iterator<E>:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.LinkedBlockingQueue.Itr#hasNext()->boolean:::
java.util.concurrent.LinkedBlockingQueue.Itr#next()->E:::
java.util.concurrent.LinkedBlockingQueue.Itr#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingQueue.Itr#remove()->void:::
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator#estimateSize()->long:::
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator#trySplit()->Spliterator<E>:::
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator#characteristics()->int:::
java.util.concurrent.LinkedBlockingQueue#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this queue
java.util.concurrent.LinkedBlockingQueue#forEach(Consumer<? super E>)->void:::
java.util.concurrent.LinkedBlockingQueue#forEachFrom(Consumer<? super E>, Node<E>)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedBlockingQueue#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.LinkedBlockingQueue#removeAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedBlockingQueue#retainAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedBlockingQueue#findPred(Node<E>, Node<E>)->Node<E>:::Returns the predecessor of live node p, given a node that was  once a live ancestor of p (or head); allows unlinking of p.
java.util.concurrent.LinkedTransferQueue.Node#casNext(Node, Node)->boolean:::
java.util.concurrent.LinkedTransferQueue.Node#casItem(Object, Object)->boolean:::
java.util.concurrent.LinkedTransferQueue.Node#selfLink()->void:::Links node to itself to avoid garbage retention
java.util.concurrent.LinkedTransferQueue.Node#appendRelaxed(Node)->void:::
java.util.concurrent.LinkedTransferQueue.Node#forgetContents()->void:::Sets item (of a request node) to self and waiter to null,  to avoid garbage retention after matching or cancelling
java.util.concurrent.LinkedTransferQueue.Node#isMatched()->boolean:::Returns true if this node has been matched, including the  case of artificial matches due to cancellation.
java.util.concurrent.LinkedTransferQueue.Node#tryMatch(Object, Object)->boolean:::Tries to CAS-match this node; if successful, wakes waiter.
java.util.concurrent.LinkedTransferQueue.Node#cannotPrecede(boolean)->boolean:::Returns true if a node with the given mode cannot be  appended to this node because this node is unmatched and  has opposite data mode.
java.util.concurrent.LinkedTransferQueue#firstDataNode()->Node:::Returns the first unmatched data node, or null if none
java.util.concurrent.LinkedTransferQueue#toString()->String:::
java.util.concurrent.LinkedTransferQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in  proper sequence
java.util.concurrent.LinkedTransferQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in  proper sequence; the runtime type of the returned array is that of  the specified array
java.util.concurrent.LinkedTransferQueue.Itr#hasNext()->boolean:::
java.util.concurrent.LinkedTransferQueue.Itr#next()->E:::
java.util.concurrent.LinkedTransferQueue.Itr#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedTransferQueue.Itr#remove()->void:::
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#trySplit()->Spliterator<E>:::
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#estimateSize()->long:::
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#characteristics()->int:::
java.util.concurrent.LinkedTransferQueue#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this queue
java.util.concurrent.LinkedTransferQueue#unsplice(Node, Node)->void:::Unsplices (now or later) the given deleted/cancelled node with  the given predecessor.
java.util.concurrent.LinkedTransferQueue#put(E)->void:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#tryTransfer(E)->boolean:::Transfers the element to a waiting consumer immediately, if possible
java.util.concurrent.LinkedTransferQueue#transfer(E)->void:::Transfers the element to a consumer, waiting if necessary to do so
java.util.concurrent.LinkedTransferQueue#tryTransfer(E, long, TimeUnit)->boolean:::Transfers the element to a consumer if it is possible to do so  before the timeout elapses
java.util.concurrent.LinkedTransferQueue#take()->E:::
java.util.concurrent.LinkedTransferQueue#poll(long, TimeUnit)->E:::
java.util.concurrent.LinkedTransferQueue#poll()->E:::
java.util.concurrent.LinkedTransferQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.LinkedTransferQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.LinkedTransferQueue#iterator()->Iterator<E>:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.LinkedTransferQueue#peek()->E:::
java.util.concurrent.LinkedTransferQueue#isEmpty()->boolean:::Returns {@code true} if this queue contains no elements.
java.util.concurrent.LinkedTransferQueue#hasWaitingConsumer()->boolean:::
java.util.concurrent.LinkedTransferQueue#size()->int:::Returns the number of elements in this queue
java.util.concurrent.LinkedTransferQueue#getWaitingConsumerCount()->int:::
java.util.concurrent.LinkedTransferQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.LinkedTransferQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.LinkedTransferQueue#remainingCapacity()->int:::Always returns {@code Integer.MAX_VALUE} because a  {@code LinkedTransferQueue} is not capacity constrained.
java.util.concurrent.LinkedTransferQueue#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.LinkedTransferQueue#removeAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedTransferQueue#retainAll(Collection<?>)->boolean:::
java.util.concurrent.LinkedTransferQueue#clear()->void:::
java.util.concurrent.LinkedTransferQueue#forEachFrom(Consumer<? super E>, Node)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedTransferQueue#forEach(Consumer<? super E>)->void:::
java.util.concurrent.Phaser#register()->int:::Adds a new unarrived party to this phaser
java.util.concurrent.Phaser#bulkRegister(int)->int:::Adds the given number of new unarrived parties to this phaser
java.util.concurrent.Phaser#arrive()->int:::Arrives at this phaser, without waiting for others to arrive
java.util.concurrent.Phaser#arriveAndDeregister()->int:::Arrives at this phaser and deregisters from it without waiting  for others to arrive
java.util.concurrent.Phaser#arriveAndAwaitAdvance()->int:::Arrives at this phaser and awaits others
java.util.concurrent.Phaser#awaitAdvance(int)->int:::Awaits the phase of this phaser to advance from the given phase  value, returning immediately if the current phase is not equal  to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser#awaitAdvanceInterruptibly(int)->int:::Awaits the phase of this phaser to advance from the given phase  value, throwing {@code InterruptedException} if interrupted  while waiting, or returning immediately if the current phase is  not equal to the given phase value or this phaser is  terminated.
java.util.concurrent.Phaser#awaitAdvanceInterruptibly(int, long, TimeUnit)->int:::Awaits the phase of this phaser to advance from the given phase  value or the given timeout to elapse, throwing {@code  InterruptedException} if interrupted while waiting, or  returning immediately if the current phase is not equal to the  given phase value or this phaser is terminated.
java.util.concurrent.Phaser#forceTermination()->void:::Forces this phaser to enter termination state
java.util.concurrent.Phaser#getPhase()->int:::Returns the current phase number
java.util.concurrent.Phaser#getRegisteredParties()->int:::Returns the number of parties registered at this phaser.
java.util.concurrent.Phaser#getArrivedParties()->int:::Returns the number of registered parties that have arrived at  the current phase of this phaser
java.util.concurrent.Phaser#getUnarrivedParties()->int:::Returns the number of registered parties that have not yet  arrived at the current phase of this phaser
java.util.concurrent.Phaser#getParent()->Phaser:::Returns the parent of this phaser, or {@code null} if none.
java.util.concurrent.Phaser#getRoot()->Phaser:::Returns the root ancestor of this phaser, which is the same as  this phaser if it has no parent.
java.util.concurrent.Phaser#isTerminated()->boolean:::Returns {@code true} if this phaser has been terminated.
java.util.concurrent.Phaser#onAdvance(int, int)->boolean:::Overridable method to perform an action upon impending phase  advance, and to control termination
java.util.concurrent.Phaser#toString()->String:::Returns a string identifying this phaser, as well as its  state
java.util.concurrent.Phaser.QNode#isReleasable()->boolean:::
java.util.concurrent.Phaser.QNode#block()->boolean:::
java.util.concurrent.PriorityBlockingQueue#add(E)->boolean:::Inserts the specified element into this priority queue.
java.util.concurrent.PriorityBlockingQueue#offer(E)->boolean:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#put(E)->void:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#poll()->E:::
java.util.concurrent.PriorityBlockingQueue#take()->E:::
java.util.concurrent.PriorityBlockingQueue#poll(long, TimeUnit)->E:::
java.util.concurrent.PriorityBlockingQueue#peek()->E:::
java.util.concurrent.PriorityBlockingQueue#super E> comparator()->Comparator<?:::Returns the comparator used to order the elements in this queue,  or {@code null} if this queue uses the {@linkplain Comparable  natural ordering} of its elements.
java.util.concurrent.PriorityBlockingQueue#size()->int:::
java.util.concurrent.PriorityBlockingQueue#remainingCapacity()->int:::Always returns {@code Integer.MAX_VALUE} because  a {@code PriorityBlockingQueue} is not capacity constrained.
java.util.concurrent.PriorityBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue,  if it is present
java.util.concurrent.PriorityBlockingQueue#removeEq(Object)->void:::Identity-based version for use in Itr.remove.
java.util.concurrent.PriorityBlockingQueue#contains(Object)->boolean:::Returns {@code true} if this queue contains the specified element
java.util.concurrent.PriorityBlockingQueue#toString()->String:::
java.util.concurrent.PriorityBlockingQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.PriorityBlockingQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.PriorityBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.PriorityBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue
java.util.concurrent.PriorityBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue; the  runtime type of the returned array is that of the specified array
java.util.concurrent.PriorityBlockingQueue#iterator()->Iterator<E>:::Returns an iterator over the elements in this queue
java.util.concurrent.PriorityBlockingQueue.Itr#hasNext()->boolean:::
java.util.concurrent.PriorityBlockingQueue.Itr#next()->E:::
java.util.concurrent.PriorityBlockingQueue.Itr#remove()->void:::
java.util.concurrent.PriorityBlockingQueue.Itr#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#trySplit()->PBQSpliterator:::
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#forEachRemaining(Consumer<? super E>)->void:::
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#tryAdvance(Consumer<? super E>)->boolean:::
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#estimateSize()->long:::
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#characteristics()->int:::
java.util.concurrent.PriorityBlockingQueue#spliterator()->Spliterator<E>:::Returns a {@link Spliterator} over the elements in this queue
java.util.concurrent.PriorityBlockingQueue#removeIf(Predicate<? super E>)->boolean:::
java.util.concurrent.PriorityBlockingQueue#removeAll(Collection<?>)->boolean:::
java.util.concurrent.PriorityBlockingQueue#retainAll(Collection<?>)->boolean:::
java.util.concurrent.PriorityBlockingQueue#forEach(Consumer<? super E>)->void:::
java.util.concurrent.RecursiveAction#compute()->void:::The main computation performed by this task.
java.util.concurrent.RecursiveAction#getRawResult()->Void:::Always returns {@code null}.
java.util.concurrent.RecursiveAction#setRawResult(Void)->void:::Requires null completion value.
java.util.concurrent.RecursiveAction#exec()->boolean:::Implements execution conventions for RecursiveActions.
java.util.concurrent.RecursiveTask#compute()->V:::The main computation performed by this task.
java.util.concurrent.RecursiveTask#getRawResult()->V:::
java.util.concurrent.RecursiveTask#setRawResult(V)->void:::
java.util.concurrent.RecursiveTask#exec()->boolean:::Implements execution conventions for RecursiveTask.
java.util.concurrent.RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Method that may be invoked by a {@link ThreadPoolExecutor} when  {@link ThreadPoolExecutor#execute execute} cannot accept a  task
java.util.concurrent.RunnableFuture#run()->void:::Sets this Future to the result of its computation  unless it has been cancelled.
java.util.concurrent.RunnableScheduledFuture#isPeriodic()->boolean:::Returns {@code true} if this task is periodic
java.util.concurrent.ScheduledExecutorService#schedule(Runnable, long, TimeUnit)->ScheduledFuture<?>:::Submits a one-shot task that becomes enabled after the given delay.
java.util.concurrent.ScheduledExecutorService#schedule(Callable<V>, long, TimeUnit)->ScheduledFuture<V>:::Submits a value-returning one-shot task that becomes enabled  after the given delay.
java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::Submits a periodic action that becomes enabled first after the  given initial delay, and subsequently with the given period;  that is, executions will commence after  {@code initialDelay}, then {@code initialDelay + period}, then  {@code initialDelay + 2 * period}, and so on
java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::Submits a periodic action that becomes enabled first after the  given initial delay, and subsequently with the given delay  between the termination of one execution and the commencement of  the next
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask#getDelay(TimeUnit)->long:::
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask#compareTo(Delayed)->int:::
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask#isPeriodic()->boolean:::Returns {@code true} if this is a periodic (not a one-shot) action.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask#cancel(boolean)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask#run()->void:::Overrides FutureTask version so as to reset/requeue if periodic.
java.util.concurrent.ScheduledThreadPoolExecutor#canRunInCurrentRunState(RunnableScheduledFuture<?>)->boolean:::Returns true if can run a task given current run state and  run-after-shutdown parameters.
java.util.concurrent.ScheduledThreadPoolExecutor#reExecutePeriodic(RunnableScheduledFuture<?>)->void:::Requeues a periodic task unless current run state precludes it
java.util.concurrent.ScheduledThreadPoolExecutor#onShutdown()->void:::Cancels and clears the queue of all tasks that should not be run  due to shutdown policy
java.util.concurrent.ScheduledThreadPoolExecutor#decorateTask(Runnable, RunnableScheduledFuture<V>)->RunnableScheduledFuture<V>:::Modifies or replaces the task used to execute a runnable
java.util.concurrent.ScheduledThreadPoolExecutor#decorateTask(Callable<V>, RunnableScheduledFuture<V>)->RunnableScheduledFuture<V>:::Modifies or replaces the task used to execute a callable
java.util.concurrent.ScheduledThreadPoolExecutor#triggerTime(long)->long:::Returns the nanoTime-based trigger time of a delayed action.
java.util.concurrent.ScheduledThreadPoolExecutor#schedule(Runnable, long, TimeUnit)->ScheduledFuture<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor#schedule(Callable<V>, long, TimeUnit)->ScheduledFuture<V>:::
java.util.concurrent.ScheduledThreadPoolExecutor#scheduleAtFixedRate(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::Submits a periodic action that becomes enabled first after the  given initial delay, and subsequently with the given period;  that is, executions will commence after  {@code initialDelay}, then {@code initialDelay + period}, then  {@code initialDelay + 2 * period}, and so on
java.util.concurrent.ScheduledThreadPoolExecutor#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)->ScheduledFuture<?>:::Submits a periodic action that becomes enabled first after the  given initial delay, and subsequently with the given delay  between the termination of one execution and the commencement of  the next
java.util.concurrent.ScheduledThreadPoolExecutor#execute(Runnable)->void:::Executes {@code command} with zero required delay
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Runnable)->Future<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Runnable, T)->Future<T>:::
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Callable<T>)->Future<T>:::
java.util.concurrent.ScheduledThreadPoolExecutor#setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean)->void:::Sets the policy on whether to continue executing existing  periodic tasks even when this executor has been {@code shutdown}
java.util.concurrent.ScheduledThreadPoolExecutor#getContinueExistingPeriodicTasksAfterShutdownPolicy()->boolean:::Gets the policy on whether to continue executing existing  periodic tasks even when this executor has been {@code shutdown}
java.util.concurrent.ScheduledThreadPoolExecutor#setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean)->void:::Sets the policy on whether to execute existing delayed  tasks even when this executor has been {@code shutdown}
java.util.concurrent.ScheduledThreadPoolExecutor#getExecuteExistingDelayedTasksAfterShutdownPolicy()->boolean:::Gets the policy on whether to execute existing delayed  tasks even when this executor has been {@code shutdown}
java.util.concurrent.ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean)->void:::Sets the policy on whether cancelled tasks should be immediately  removed from the work queue at time of cancellation
java.util.concurrent.ScheduledThreadPoolExecutor#getRemoveOnCancelPolicy()->boolean:::Gets the policy on whether cancelled tasks should be immediately  removed from the work queue at time of cancellation
java.util.concurrent.ScheduledThreadPoolExecutor#shutdown()->void:::Initiates an orderly shutdown in which previously submitted  tasks are executed, but no new tasks will be accepted
java.util.concurrent.ScheduledThreadPoolExecutor#shutdownNow()->List<Runnable>:::Attempts to stop all actively executing tasks, halts the  processing of waiting tasks, and returns a list of the tasks  that were awaiting execution
java.util.concurrent.ScheduledThreadPoolExecutor#getQueue()->BlockingQueue<Runnable>:::Returns the task queue used by this executor
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#contains(Object)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#remove(Object)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#size()->int:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#isEmpty()->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#remainingCapacity()->int:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#peek()->RunnableScheduledFuture<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#put(Runnable)->void:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#add(Runnable)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable, long, TimeUnit)->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#poll()->RunnableScheduledFuture<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#take()->RunnableScheduledFuture<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#poll(long, TimeUnit)->RunnableScheduledFuture<?>:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#clear()->void:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection<? super Runnable>)->int:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection<? super Runnable>, int)->int:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray()->Object[]:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray(T[])->T[]:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#iterator()->Iterator<Runnable>:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#hasNext()->boolean:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#next()->Runnable:::
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr#remove()->void:::
java.util.concurrent.Semaphore.Sync#getPermits()->int:::
java.util.concurrent.Semaphore.Sync#nonfairTryAcquireShared(int)->int:::
java.util.concurrent.Semaphore.Sync#tryReleaseShared(int)->boolean:::
java.util.concurrent.Semaphore.Sync#reducePermits(int)->void:::
java.util.concurrent.Semaphore.Sync#drainPermits()->int:::
java.util.concurrent.Semaphore.NonfairSync#tryAcquireShared(int)->int:::
java.util.concurrent.Semaphore.FairSync#tryAcquireShared(int)->int:::
java.util.concurrent.Semaphore#acquire()->void:::Acquires a permit from this semaphore, blocking until one is  available, or the thread is {@linkplain Thread#interrupt interrupted}
java.util.concurrent.Semaphore#acquireUninterruptibly()->void:::Acquires a permit from this semaphore, blocking until one is  available
java.util.concurrent.Semaphore#tryAcquire()->boolean:::Acquires a permit from this semaphore, only if one is available at the  time of invocation
java.util.concurrent.Semaphore#tryAcquire(long, TimeUnit)->boolean:::Acquires a permit from this semaphore, if one becomes available  within the given waiting time and the current thread has not  been {@linkplain Thread#interrupt interrupted}
java.util.concurrent.Semaphore#release()->void:::Releases a permit, returning it to the semaphore
java.util.concurrent.Semaphore#acquire(int)->void:::Acquires the given number of permits from this semaphore,  blocking until all are available,  or the thread is {@linkplain Thread#interrupt interrupted}
java.util.concurrent.Semaphore#acquireUninterruptibly(int)->void:::Acquires the given number of permits from this semaphore,  blocking until all are available
java.util.concurrent.Semaphore#tryAcquire(int)->boolean:::Acquires the given number of permits from this semaphore, only  if all are available at the time of invocation
java.util.concurrent.Semaphore#tryAcquire(int, long, TimeUnit)->boolean:::Acquires the given number of permits from this semaphore, if all  become available within the given waiting time and the current  thread has not been {@linkplain Thread#interrupt interrupted}
java.util.concurrent.Semaphore#release(int)->void:::Releases the given number of permits, returning them to the semaphore
java.util.concurrent.Semaphore#availablePermits()->int:::Returns the current number of permits available in this semaphore
java.util.concurrent.Semaphore#drainPermits()->int:::Acquires and returns all permits that are immediately  available, or if negative permits are available, releases them
java.util.concurrent.Semaphore#reducePermits(int)->void:::Shrinks the number of available permits by the indicated  reduction
java.util.concurrent.Semaphore#isFair()->boolean:::Returns {@code true} if this semaphore has fairness set true.
java.util.concurrent.Semaphore#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire
java.util.concurrent.Semaphore#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire
java.util.concurrent.Semaphore#getQueuedThreads()->Collection<Thread>:::Returns a collection containing threads that may be waiting to acquire
java.util.concurrent.Semaphore#toString()->String:::Returns a string identifying this semaphore, as well as its state
java.util.concurrent.SubmissionPublisher#roundCapacity(int)->int:::Round capacity to power of 2, at most limit.
java.util.concurrent.SubmissionPublisher.ThreadPerTaskExecutor#execute(Runnable)->void:::
java.util.concurrent.SubmissionPublisher#subscribe(Subscriber<? super T>)->void:::Adds the given Subscriber unless already subscribed
java.util.concurrent.SubmissionPublisher#submit(T)->int:::Publishes the given item to each current subscriber by  asynchronously invoking its {@link Flow.Subscriber#onNext(Object)  onNext} method, blocking uninterruptibly while resources for any  subscriber are unavailable
java.util.concurrent.SubmissionPublisher#offer(T, BiPredicate<Subscriber<? super T>, ? super T>)->int:::Publishes the given item, if possible, to each current subscriber  by asynchronously invoking its {@link  Flow.Subscriber#onNext(Object) onNext} method
java.util.concurrent.SubmissionPublisher#offer(T, long, TimeUnit, BiPredicate<Subscriber<? super T>, ? super T>)->int:::Publishes the given item, if possible, to each current subscriber  by asynchronously invoking its {@link  Flow.Subscriber#onNext(Object) onNext} method, blocking while  resources for any subscription are unavailable, up to the  specified timeout or until the caller thread is interrupted, at  which point the given handler (if non-null) is invoked, and if it  returns true, retried once
java.util.concurrent.SubmissionPublisher#close()->void:::Unless already closed, issues {@link  Flow.Subscriber#onComplete() onComplete} signals to current  subscribers, and disallows subsequent attempts to publish
java.util.concurrent.SubmissionPublisher#closeExceptionally(Throwable)->void:::Unless already closed, issues {@link  Flow.Subscriber#onError(Throwable) onError} signals to current  subscribers with the given error, and disallows subsequent  attempts to publish
java.util.concurrent.SubmissionPublisher#isClosed()->boolean:::Returns true if this publisher is not accepting submissions.
java.util.concurrent.SubmissionPublisher#getClosedException()->Throwable:::Returns the exception associated with {@link  #closeExceptionally(Throwable) closeExceptionally}, or null if  not closed or if closed normally.
java.util.concurrent.SubmissionPublisher#hasSubscribers()->boolean:::Returns true if this publisher has any subscribers.
java.util.concurrent.SubmissionPublisher#getNumberOfSubscribers()->int:::Returns the number of current subscribers.
java.util.concurrent.SubmissionPublisher#getExecutor()->Executor:::Returns the Executor used for asynchronous delivery.
java.util.concurrent.SubmissionPublisher#getMaxBufferCapacity()->int:::Returns the maximum per-subscriber buffer capacity.
java.util.concurrent.SubmissionPublisher#super T>> getSubscribers()->List<Subscriber<?:::Returns a list of current subscribers for monitoring and  tracking purposes, not for invoking {@link Flow.Subscriber}  methods on the subscribers.
java.util.concurrent.SubmissionPublisher#isSubscribed(Subscriber<? super T>)->boolean:::Returns true if the given Subscriber is currently subscribed.
java.util.concurrent.SubmissionPublisher#estimateMinimumDemand()->long:::Returns an estimate of the minimum number of items requested  (via {@link Flow.Subscription#request(long) request}) but not  yet produced, among all current subscribers.
java.util.concurrent.SubmissionPublisher#estimateMaximumLag()->int:::Returns an estimate of the maximum number of items produced but  not yet consumed among all current subscribers.
java.util.concurrent.SubmissionPublisher#consume(Consumer<? super T>)->CompletableFuture<Void>:::Processes all published items using the given Consumer function
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onSubscribe(Subscription)->void:::
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onError(Throwable)->void:::
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onComplete()->void:::
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onNext(T)->void:::
java.util.concurrent.SubmissionPublisher.ConsumerTask#getRawResult()->Void:::
java.util.concurrent.SubmissionPublisher.ConsumerTask#setRawResult(Void)->void:::
java.util.concurrent.SubmissionPublisher.ConsumerTask#exec()->boolean:::
java.util.concurrent.SubmissionPublisher.ConsumerTask#run()->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#weakCasCtl(int, int)->boolean:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#getAndBitwiseOrCtl(int)->int:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#subtractDemand(int)->long:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#casDemand(long, long)->boolean:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#isClosed()->boolean:::Returns true if closed (consumer task may still be running).
java.util.concurrent.SubmissionPublisher.BufferedSubscription#estimateLag()->int:::Returns estimated number of buffered items, or negative if  closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#offer(T, boolean)->int:::Tries to add item and start consumer task if necessary.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#growAndOffer(T, Object[], int)->boolean:::Tries to expand buffer and add item, returning true on  success
java.util.concurrent.SubmissionPublisher.BufferedSubscription#retryOffer(T)->int:::Version of offer for retries (no resize or bias)
java.util.concurrent.SubmissionPublisher.BufferedSubscription#startOnOffer(int)->int:::Tries to start consumer task after offer.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#tryStart()->void:::Tries to start consumer task
java.util.concurrent.SubmissionPublisher.BufferedSubscription#startOnSignal(int)->void:::Sets the given control bits, starting task if not running or closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onSubscribe()->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onComplete()->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onError(Throwable)->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#cancel()->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#request(long)->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consume()->void:::Consumer loop, called from ConsumerTask, or indirectly when  helping during submit.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#takeItems(Subscriber<? super T>, long, int)->int:::Consumes some items until unavailable or bound or error.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeNext(Subscriber<? super T>, Object)->boolean:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#handleOnNext(Subscriber<? super T>, Throwable)->void:::Processes exception in Subscriber.onNext.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#subscribeOnOpen(Subscriber<? super T>)->void:::Issues subscriber.onSubscribe if this is first signal.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeSubscribe(Subscriber<? super T>)->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#closeOnComplete(Subscriber<? super T>)->void:::Issues subscriber.onComplete unless already closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeComplete(Subscriber<? super T>)->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#closeOnError(Subscriber<? super T>, Throwable)->void:::Issues subscriber.onError, and unblocks producer if needed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeError(Subscriber<? super T>, Throwable)->void:::
java.util.concurrent.SubmissionPublisher.BufferedSubscription#signalWaiter()->void:::Unblocks waiting producer.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#isReleasable()->boolean:::Returns true if closed or space available
java.util.concurrent.SubmissionPublisher.BufferedSubscription#awaitSpace(long)->void:::Helps or blocks until timeout, closed, or space available.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#block()->boolean:::Blocks until closed, space available or timeout
java.util.concurrent.SynchronousQueue.Transferer#transfer(E, boolean, long)->E:::Performs a put or take.
java.util.concurrent.SynchronousQueue.TransferStack#isFulfilling(int)->boolean:::Returns true if m has fulfilling bit set.
java.util.concurrent.SynchronousQueue.TransferStack.SNode#casNext(SNode, SNode)->boolean:::
java.util.concurrent.SynchronousQueue.TransferStack.SNode#tryMatch(SNode)->boolean:::Tries to match node s to this node, if so, waking up thread
java.util.concurrent.SynchronousQueue.TransferStack.SNode#tryCancel()->void:::Tries to cancel a wait by matching node to itself.
java.util.concurrent.SynchronousQueue.TransferStack.SNode#isCancelled()->boolean:::
java.util.concurrent.SynchronousQueue.TransferStack#casHead(SNode, SNode)->boolean:::
java.util.concurrent.SynchronousQueue.TransferStack#snode(SNode, Object, SNode, int)->SNode:::Creates or resets fields of a node
java.util.concurrent.SynchronousQueue.TransferStack#transfer(E, boolean, long)->E:::Puts or takes an item.
java.util.concurrent.SynchronousQueue.TransferStack#awaitFulfill(SNode, boolean, long)->SNode:::Spins/blocks until node s is matched by a fulfill operation.
java.util.concurrent.SynchronousQueue.TransferStack#shouldSpin(SNode)->boolean:::Returns true if node s is at head or there is an active  fulfiller.
java.util.concurrent.SynchronousQueue.TransferStack#clean(SNode)->void:::Unlinks s from the stack.
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#casNext(QNode, QNode)->boolean:::
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#casItem(Object, Object)->boolean:::
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#tryCancel(Object)->void:::Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#isCancelled()->boolean:::
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#isOffList()->boolean:::Returns true if this node is known to be off the queue  because its next pointer has been forgotten due to  an advanceHead operation.
java.util.concurrent.SynchronousQueue.TransferQueue#advanceHead(QNode, QNode)->void:::Tries to cas nh as new head; if successful, unlink  old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue.TransferQueue#advanceTail(QNode, QNode)->void:::Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue.TransferQueue#casCleanMe(QNode, QNode)->boolean:::Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue.TransferQueue#transfer(E, boolean, long)->E:::Puts or takes an item.
java.util.concurrent.SynchronousQueue.TransferQueue#awaitFulfill(QNode, E, boolean, long)->Object:::Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue.TransferQueue#clean(QNode, QNode)->void:::Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue#put(E)->void:::Adds the specified element to this queue, waiting if necessary for  another thread to receive it.
java.util.concurrent.SynchronousQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this queue, waiting if necessary  up to the specified wait time for another thread to receive it.
java.util.concurrent.SynchronousQueue#offer(E)->boolean:::Inserts the specified element into this queue, if another thread is  waiting to receive it.
java.util.concurrent.SynchronousQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary  for another thread to insert it.
java.util.concurrent.SynchronousQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting  if necessary up to the specified wait time, for another thread  to insert it.
java.util.concurrent.SynchronousQueue#poll()->E:::Retrieves and removes the head of this queue, if another thread  is currently making an element available.
java.util.concurrent.SynchronousQueue#isEmpty()->boolean:::Always returns {@code true}
java.util.concurrent.SynchronousQueue#size()->int:::Always returns zero
java.util.concurrent.SynchronousQueue#remainingCapacity()->int:::Always returns zero
java.util.concurrent.SynchronousQueue#clear()->void:::Does nothing
java.util.concurrent.SynchronousQueue#contains(Object)->boolean:::Always returns {@code false}
java.util.concurrent.SynchronousQueue#remove(Object)->boolean:::Always returns {@code false}
java.util.concurrent.SynchronousQueue#containsAll(Collection<?>)->boolean:::Returns {@code false} unless the given collection is empty
java.util.concurrent.SynchronousQueue#removeAll(Collection<?>)->boolean:::Always returns {@code false}
java.util.concurrent.SynchronousQueue#retainAll(Collection<?>)->boolean:::Always returns {@code false}
java.util.concurrent.SynchronousQueue#peek()->E:::Always returns {@code null}
java.util.concurrent.SynchronousQueue#iterator()->Iterator<E>:::Returns an empty iterator in which {@code hasNext} always returns  {@code false}.
java.util.concurrent.SynchronousQueue#spliterator()->Spliterator<E>:::Returns an empty spliterator in which calls to  {@link Spliterator#trySplit() trySplit} always return {@code null}.
java.util.concurrent.SynchronousQueue#toArray()->Object[]:::Returns a zero-length array.
java.util.concurrent.SynchronousQueue#toArray(T[])->T[]:::Sets the zeroth element of the specified array to {@code null}  (if the array has non-zero length) and returns it.
java.util.concurrent.SynchronousQueue#toString()->String:::Always returns {@code "[]"}.
java.util.concurrent.SynchronousQueue#drainTo(Collection<? super E>)->int:::
java.util.concurrent.SynchronousQueue#drainTo(Collection<? super E>, int)->int:::
java.util.concurrent.ThreadFactory#newThread(Runnable)->Thread:::Constructs a new {@code Thread}
java.util.concurrent.ThreadLocalRandom#localInit()->void:::Initialize Thread fields for the current thread
java.util.concurrent.ThreadLocalRandom#current()->ThreadLocalRandom:::Returns the current thread's {@code ThreadLocalRandom}.
java.util.concurrent.ThreadLocalRandom#setSeed(long)->void:::Throws {@code UnsupportedOperationException}
java.util.concurrent.ThreadLocalRandom#nextSeed()->long:::
java.util.concurrent.ThreadLocalRandom#next(int)->int:::Generates a pseudorandom number with the indicated number of  low-order bits
java.util.concurrent.ThreadLocalRandom#internalNextLong(long, long)->long:::The form of nextLong used by LongStream Spliterators
java.util.concurrent.ThreadLocalRandom#internalNextInt(int, int)->int:::The form of nextInt used by IntStream Spliterators
java.util.concurrent.ThreadLocalRandom#internalNextDouble(double, double)->double:::The form of nextDouble used by DoubleStream Spliterators.
java.util.concurrent.ThreadLocalRandom#nextInt()->int:::Returns a pseudorandom {@code int} value.
java.util.concurrent.ThreadLocalRandom#nextInt(int)->int:::Returns a pseudorandom {@code int} value between zero (inclusive)  and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextInt(int, int)->int:::Returns a pseudorandom {@code int} value between the specified  origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextLong()->long:::Returns a pseudorandom {@code long} value.
java.util.concurrent.ThreadLocalRandom#nextLong(long)->long:::Returns a pseudorandom {@code long} value between zero (inclusive)  and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextLong(long, long)->long:::Returns a pseudorandom {@code long} value between the specified  origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble()->double:::Returns a pseudorandom {@code double} value between zero  (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble(double)->double:::Returns a pseudorandom {@code double} value between 0.0  (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble(double, double)->double:::Returns a pseudorandom {@code double} value between the specified  origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextBoolean()->boolean:::Returns a pseudorandom {@code boolean} value.
java.util.concurrent.ThreadLocalRandom#nextFloat()->float:::Returns a pseudorandom {@code float} value between zero  (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#nextGaussian()->double:::
java.util.concurrent.ThreadLocalRandom#ints(long)->IntStream:::Returns a stream producing the given {@code streamSize} number of  pseudorandom {@code int} values.
java.util.concurrent.ThreadLocalRandom#ints()->IntStream:::Returns an effectively unlimited stream of pseudorandom {@code int}  values.
java.util.concurrent.ThreadLocalRandom#ints(long, int, int)->IntStream:::Returns a stream producing the given {@code streamSize} number  of pseudorandom {@code int} values, each conforming to the given  origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#ints(int, int)->IntStream:::Returns an effectively unlimited stream of pseudorandom {@code  int} values, each conforming to the given origin (inclusive) and bound  (exclusive).
java.util.concurrent.ThreadLocalRandom#longs(long)->LongStream:::Returns a stream producing the given {@code streamSize} number of  pseudorandom {@code long} values.
java.util.concurrent.ThreadLocalRandom#longs()->LongStream:::Returns an effectively unlimited stream of pseudorandom {@code long}  values.
java.util.concurrent.ThreadLocalRandom#longs(long, long, long)->LongStream:::Returns a stream producing the given {@code streamSize} number of  pseudorandom {@code long}, each conforming to the given origin  (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#longs(long, long)->LongStream:::Returns an effectively unlimited stream of pseudorandom {@code  long} values, each conforming to the given origin (inclusive) and bound  (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(long)->DoubleStream:::Returns a stream producing the given {@code streamSize} number of  pseudorandom {@code double} values, each between zero  (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles()->DoubleStream:::Returns an effectively unlimited stream of pseudorandom {@code  double} values, each between zero (inclusive) and one  (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(long, double, double)->DoubleStream:::Returns a stream producing the given {@code streamSize} number of  pseudorandom {@code double} values, each conforming to the given origin  (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(double, double)->DoubleStream:::Returns an effectively unlimited stream of pseudorandom {@code  double} values, each conforming to the given origin (inclusive) and bound  (exclusive).
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator#trySplit()->RandomIntsSpliterator:::
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator#estimateSize()->long:::
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator#characteristics()->int:::
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator#tryAdvance(IntConsumer)->boolean:::
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator#forEachRemaining(IntConsumer)->void:::
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator#trySplit()->RandomLongsSpliterator:::
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator#estimateSize()->long:::
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator#characteristics()->int:::
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator#tryAdvance(LongConsumer)->boolean:::
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator#forEachRemaining(LongConsumer)->void:::
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator#trySplit()->RandomDoublesSpliterator:::
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator#estimateSize()->long:::
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator#characteristics()->int:::
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator#tryAdvance(DoubleConsumer)->boolean:::
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator#forEachRemaining(DoubleConsumer)->void:::
java.util.concurrent.ThreadLocalRandom#getProbe()->int:::Returns the probe value for the current thread without forcing  initialization
java.util.concurrent.ThreadLocalRandom#advanceProbe(int)->int:::Pseudo-randomly advances and records the given probe value for the  given thread.
java.util.concurrent.ThreadLocalRandom#nextSecondarySeed()->int:::Returns the pseudo-randomly initialized or updated secondary seed.
java.util.concurrent.ThreadLocalRandom#eraseThreadLocals(Thread)->void:::Erases ThreadLocals by nulling out Thread maps.
java.util.concurrent.ThreadLocalRandom#setInheritedAccessControlContext(Thread, AccessControlContext)->void:::
java.util.concurrent.ThreadPoolExecutor.Worker#run()->void:::Delegates main run loop to outer runWorker.
java.util.concurrent.ThreadPoolExecutor.Worker#isHeldExclusively()->boolean:::
java.util.concurrent.ThreadPoolExecutor.Worker#tryAcquire(int)->boolean:::
java.util.concurrent.ThreadPoolExecutor.Worker#tryRelease(int)->boolean:::
java.util.concurrent.ThreadPoolExecutor.Worker#lock()->void:::
java.util.concurrent.ThreadPoolExecutor.Worker#tryLock()->boolean:::
java.util.concurrent.ThreadPoolExecutor.Worker#unlock()->void:::
java.util.concurrent.ThreadPoolExecutor.Worker#isLocked()->boolean:::
java.util.concurrent.ThreadPoolExecutor.Worker#interruptIfStarted()->void:::
java.util.concurrent.ThreadPoolExecutor#tryTerminate()->void:::Transitions to TERMINATED state if either (SHUTDOWN and pool  and queue empty) or (STOP and pool empty)
java.util.concurrent.ThreadPoolExecutor#reject(Runnable)->void:::Invokes the rejected execution handler for the given command
java.util.concurrent.ThreadPoolExecutor#onShutdown()->void:::Performs any further cleanup following run state transition on  invocation of shutdown
java.util.concurrent.ThreadPoolExecutor#runWorker(Worker)->void:::Main worker run loop
java.util.concurrent.ThreadPoolExecutor#execute(Runnable)->void:::Executes the given task sometime in the future
java.util.concurrent.ThreadPoolExecutor#shutdown()->void:::Initiates an orderly shutdown in which previously submitted  tasks are executed, but no new tasks will be accepted
java.util.concurrent.ThreadPoolExecutor#shutdownNow()->List<Runnable>:::Attempts to stop all actively executing tasks, halts the  processing of waiting tasks, and returns a list of the tasks  that were awaiting execution
java.util.concurrent.ThreadPoolExecutor#isShutdown()->boolean:::
java.util.concurrent.ThreadPoolExecutor#isStopped()->boolean:::Used by ScheduledThreadPoolExecutor.
java.util.concurrent.ThreadPoolExecutor#isTerminating()->boolean:::Returns true if this executor is in the process of terminating  after {@link #shutdown} or {@link #shutdownNow} but has not  completely terminated
java.util.concurrent.ThreadPoolExecutor#isTerminated()->boolean:::
java.util.concurrent.ThreadPoolExecutor#awaitTermination(long, TimeUnit)->boolean:::
java.util.concurrent.ThreadPoolExecutor#finalize()->void:::
java.util.concurrent.ThreadPoolExecutor#setThreadFactory(ThreadFactory)->void:::Sets the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor#getThreadFactory()->ThreadFactory:::Returns the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor#setRejectedExecutionHandler(RejectedExecutionHandler)->void:::Sets a new handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor#getRejectedExecutionHandler()->RejectedExecutionHandler:::Returns the current handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor#setCorePoolSize(int)->void:::Sets the core number of threads
java.util.concurrent.ThreadPoolExecutor#getCorePoolSize()->int:::Returns the core number of threads.
java.util.concurrent.ThreadPoolExecutor#prestartCoreThread()->boolean:::Starts a core thread, causing it to idly wait for work
java.util.concurrent.ThreadPoolExecutor#ensurePrestart()->void:::Same as prestartCoreThread except arranges that at least one  thread is started even if corePoolSize is 0.
java.util.concurrent.ThreadPoolExecutor#prestartAllCoreThreads()->int:::Starts all core threads, causing them to idly wait for work
java.util.concurrent.ThreadPoolExecutor#allowsCoreThreadTimeOut()->boolean:::Returns true if this pool allows core threads to time out and  terminate if no tasks arrive within the keepAlive time, being  replaced if needed when new tasks arrive
java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)->void:::Sets the policy governing whether core threads may time out and  terminate if no tasks arrive within the keep-alive time, being  replaced if needed when new tasks arrive
java.util.concurrent.ThreadPoolExecutor#setMaximumPoolSize(int)->void:::Sets the maximum allowed number of threads
java.util.concurrent.ThreadPoolExecutor#getMaximumPoolSize()->int:::Returns the maximum allowed number of threads.
java.util.concurrent.ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit)->void:::Sets the thread keep-alive time, which is the amount of time  that threads may remain idle before being terminated
java.util.concurrent.ThreadPoolExecutor#getKeepAliveTime(TimeUnit)->long:::Returns the thread keep-alive time, which is the amount of time  that threads may remain idle before being terminated
java.util.concurrent.ThreadPoolExecutor#getQueue()->BlockingQueue<Runnable>:::Returns the task queue used by this executor
java.util.concurrent.ThreadPoolExecutor#remove(Runnable)->boolean:::Removes this task from the executor's internal queue if it is  present, thus causing it not to be run if it has not already  started
java.util.concurrent.ThreadPoolExecutor#purge()->void:::Tries to remove from the work queue all {@link Future}  tasks that have been cancelled
java.util.concurrent.ThreadPoolExecutor#getPoolSize()->int:::Returns the current number of threads in the pool.
java.util.concurrent.ThreadPoolExecutor#getActiveCount()->int:::Returns the approximate number of threads that are actively  executing tasks.
java.util.concurrent.ThreadPoolExecutor#getLargestPoolSize()->int:::Returns the largest number of threads that have ever  simultaneously been in the pool.
java.util.concurrent.ThreadPoolExecutor#getTaskCount()->long:::Returns the approximate total number of tasks that have ever been  scheduled for execution
java.util.concurrent.ThreadPoolExecutor#getCompletedTaskCount()->long:::Returns the approximate total number of tasks that have  completed execution
java.util.concurrent.ThreadPoolExecutor#toString()->String:::Returns a string identifying this pool, as well as its state,  including indications of run state and estimated worker and  task counts.
java.util.concurrent.ThreadPoolExecutor#beforeExecute(Thread, Runnable)->void:::Method invoked prior to executing the given Runnable in the  given thread
java.util.concurrent.ThreadPoolExecutor#afterExecute(Runnable, Throwable)->void:::Method invoked upon completion of execution of the given Runnable
java.util.concurrent.ThreadPoolExecutor#terminated()->void:::Method invoked when the Executor has terminated
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Executes task r in the caller's thread, unless the executor  has been shut down, in which case the task is discarded.
java.util.concurrent.ThreadPoolExecutor.AbortPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Always throws RejectedExecutionException.
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Does nothing, which has the effect of discarding task r.
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Obtains and ignores the next task that the executor  would otherwise execute, if one is immediately available,  and then retries execution of task r, unless the executor  is shut down, in which case task r is instead discarded.
java.util.concurrent.TransferQueue#tryTransfer(E)->boolean:::Transfers the element to a waiting consumer immediately, if possible
java.util.concurrent.TransferQueue#transfer(E)->void:::Transfers the element to a consumer, waiting if necessary to do so
java.util.concurrent.TransferQueue#tryTransfer(E, long, TimeUnit)->boolean:::Transfers the element to a consumer if it is possible to do so  before the timeout elapses
java.util.concurrent.TransferQueue#hasWaitingConsumer()->boolean:::Returns {@code true} if there is at least one consumer waiting  to receive an element via {@link #take} or  timed {@link #poll(long,TimeUnit) poll}
java.util.concurrent.TransferQueue#getWaitingConsumerCount()->int:::Returns an estimate of the number of consumers waiting to  receive elements via {@link #take} or timed  {@link #poll(long,TimeUnit) poll}
