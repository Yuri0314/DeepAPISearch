AbstractExecutorService#newTaskFor(Runnable, T):::Returns a RunnableFuture for the given runnable and default value.:::return->new->FutureTask<T>
AbstractExecutorService#newTaskFor(Callable):::Returns a RunnableFuture for the given callable task.:::return->new->FutureTask<T>
ArrayBlockingQueue#inc(int, int):::Increments i, mod modulus:::if->return
ArrayBlockingQueue#dec(int, int):::Decrements i, mod modulus:::if->return
ArrayBlockingQueue#itemAt(int):::Returns item at index i.:::return
ArrayBlockingQueue#itemAt(Object[], int):::Returns element at array index i:::return
ArrayBlockingQueue#removeAt(int):::Deletes item at array index removeIndex:::items->if->if->if->itrs->elementDequeued->else->for->i->putIndex->if->itrs->removedAt->notFull->signal
ArrayBlockingQueue#add(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.:::return->super->add
ArrayBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::Objects->requireNonNull->lock->lock->lock->try->if->return->else->enqueue->return->catch->finally->lock->unlock
ArrayBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.:::Objects->requireNonNull->lock->lock->lockInterruptibly->try->while->notFull->await->enqueue->catch->finally->lock->unlock
ArrayBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.:::Objects->requireNonNull->nanos->unit->toNanos->lock->lock->lockInterruptibly->try->while->if->return->notFull->awaitNanos->enqueue->return->catch->finally->lock->unlock
ArrayBlockingQueue#size():::Returns the number of elements in this queue.:::lock->lock->lock->try->return->catch->finally->lock->unlock
ArrayBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::lock->lock->lock->try->return->catch->finally->lock->unlock
ArrayBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->lock->lock->lock->try->if->items->for->i->end->to->return->catch->finally->lock->unlock
ArrayBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->lock->lock->lock->try->if->items->for->i->end->to->return->catch->finally->lock->unlock
ArrayBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::lock->lock->lock->try->items->end->a->Arrays->copyOfRange->if->System->arraycopy->return->catch->finally->lock->unlock
ArrayBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->items->count->firstLeg->Math->min->if->Arrays->a->getClass->copyOfRange->else->System->arraycopy->if->if->System->arraycopy->return->catch->finally->lock->unlock
ArrayBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock->lock->lock->try->k->if->circularClear->if->itrs->queueIsEmpty->for->lock->hasWaiters->catch->finally->lock->unlock
ArrayBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
ArrayBlockingQueue.Itrs#doSomeSweeping(boolean):::Sweeps itrs, looking for and expunging stale iterators:::probes->o->p->sweeper->passedGo->if->else->for
ArrayBlockingQueue.Itrs#register(Itr):::Adds a new iterator to the linked list of tracked iterators.:::new->Node
ArrayBlockingQueue.Itrs#takeIndexWrapped():::Called whenever takeIndex wraps around to 0:::for->o->p->if
ArrayBlockingQueue.Itrs#removedAt(int):::Called whenever an interior remove (not at takeIndex) occurred:::for->o->p->if
ArrayBlockingQueue.Itrs#queueIsEmpty():::Called whenever the queue becomes empty:::for->p
ArrayBlockingQueue.Itrs#elementDequeued():::Called whenever an element has been dequeued (at takeIndex).:::if->queueIsEmpty->else->if->takeIndexWrapped
ArrayBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->Spliterators->spliterator
ArrayBlockingQueue#checkInvariants():::debugging:::if->invariantsSatisfied->detail->String->Arrays->toString->format->println->throw->new->AssertionError
BlockingDeque#addFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#addLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offerFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#offerLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#putFirst(E):::Inserts the specified element at the front of this deque, waiting if necessary for space to become available.:::
BlockingDeque#putLast(E):::Inserts the specified element at the end of this deque, waiting if necessary for space to become available.:::
BlockingDeque#offerFirst(E, long, TimeUnit):::Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#offerLast(E, long, TimeUnit):::Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#takeFirst():::Retrieves and removes the first element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#takeLast():::Retrieves and removes the last element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#pollFirst(long, TimeUnit):::Retrieves and removes the first element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#pollLast(long, TimeUnit):::Retrieves and removes the last element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::
BlockingDeque#add(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offer(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#put(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available:::
BlockingDeque#offer(E, long, TimeUnit):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available:::
BlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#poll():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#take():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting if necessary until an element becomes available:::
BlockingDeque#poll(long, TimeUnit):::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting up to the specified wait time if necessary for an element to become available:::
BlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#peek():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::
BlockingDeque#size():::Returns the number of elements in this deque.:::
BlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::
BlockingDeque#push(E):::Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingQueue#add(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingQueue#offer(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingQueue#put(E):::Inserts the specified element into this queue, waiting if necessary for space to become available.:::
BlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.:::
BlockingQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.:::
BlockingQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit:::
BlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::
BlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::
BlockingQueue#drainTo(Collection):::Removes all available elements from this queue and adds them to the given collection:::
BlockingQueue#drainTo(Collection, int):::Removes at most the given number of available elements from this queue and adds them to the given collection:::
Callable#call():::Computes a result, or throws an exception if unable to do so.:::
CompletableFuture#tryPushStack(Completion):::Returns true if successfully pushed c onto stack.:::h->NEXT->set->return->STACK->compareAndSet
CompletableFuture#pushStack(Completion):::Unconditionally pushes c onto stack, retrying if necessary.:::do->while->tryPushStack
CompletableFuture#completeNull():::Completes with the null value, unless already completed.:::return->RESULT->compareAndSet
CompletableFuture#encodeValue(T):::Returns the encoding of the given non-exceptional value.:::return
CompletableFuture#completeValue(T):::Completes with a non-exceptional result, unless already completed.:::return->RESULT->compareAndSet
CompletableFuture#encodeThrowable(Throwable):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already.:::return->new->CompletionException->new->AltResult
CompletableFuture#completeThrowable(Throwable):::Completes with an exceptional result, unless already completed.:::return->RESULT->encodeThrowable->compareAndSet
CompletableFuture#encodeThrowable(Throwable, Object):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already:::if->new->CompletionException->else->if->return->return->new->AltResult
CompletableFuture#completeThrowable(Throwable, Object):::Completes with the given (non-null) exceptional result as a wrapped CompletionException unless it is one already, unless already completed:::return->RESULT->encodeThrowable->compareAndSet
CompletableFuture#encodeOutcome(T, Throwable):::Returns the encoding of the given arguments: if the exception is non-null, encodes as AltResult:::return->encodeThrowable
CompletableFuture#encodeRelay(Object):::Returns the encoding of a copied outcome; if exceptional, rewraps as a CompletionException, else returns argument.:::x->if->new->CompletionException->new->AltResult->return
CompletableFuture#completeRelay(Object):::Completes with r or a copy of r, unless already completed:::return->RESULT->encodeRelay->compareAndSet
CompletableFuture#screenExecutor(Executor):::Null-checks user executor argument, and translates uses of commonPool to ASYNC_POOL in case parallelism disabled.:::if->ForkJoinPool->commonPool->return->if->throw->new->NullPointerException->return
CompletableFuture.Completion#tryFire(int):::Performs completion action if triggered, returning a dependent that may need propagation, if one exists.:::
CompletableFuture.Completion#isLive():::Returns true if possibly still triggerable:::
CompletableFuture#postComplete():::Pops and tries to trigger all reachable dependents:::f->h->while->d->t->if->STACK->compareAndSet->if->if->pushStack->continue->NEXT->compareAndSet->h->tryFire
CompletableFuture#cleanStack():::Traverses stack and unlinks one or more dead Completions, if found.:::p->for->unlinked->for->q
CompletableFuture.UniCompletion#claim():::Returns true if action can be run:::e->if->compareAndSetForkJoinTaskTag->if->return->e->execute->return
CompletableFuture#unipush(Completion):::Pushes the given completion unless it completes while trying:::if->while->tryPushStack->if->NEXT->set->break->if->c->tryFire
CompletableFuture#postFire(CompletableFuture, int):::Post-processing by dependent after successful UniCompletion tryFire:::if->r->if->a->cleanStack->if->a->postComplete->if->if->return->else->postComplete->return
CompletableFuture#bipush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless both done:::if->while->if->tryPushStack->if->b->new->CoCompletion->unipush->else->if->c->tryFire->return->b->unipush
CompletableFuture#postFire(CompletableFuture, CompletableFuture, int):::Post-processing after successful BiCompletion tryFire.:::if->r->if->b->cleanStack->if->b->postComplete->return->postFire
CompletableFuture#andTree(CompletableFuture[], int, int):::Recursively constructs a tree of completions.:::d->new->CompletableFuture<Void>->if->else->a->b->r->s->z->x->mid->if->andTree->andTree->throw->new->NullPointerException->if->a->new->BiRelay<>->bipush->else->if->encodeThrowable->else->return
CompletableFuture#orpush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless either done:::if->while->tryPushStack->if->NEXT->set->break->if->c->tryFire->else->b->new->CoCompletion->unipush
CompletableFuture#supplyAsync(Supplier):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() with the value obtained by calling the given Supplier.:::return->asyncSupplyStage
CompletableFuture#supplyAsync(Supplier, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.:::return->screenExecutor->asyncSupplyStage
CompletableFuture#runAsync(Runnable):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() after it runs the given action.:::return->asyncRunStage
CompletableFuture#runAsync(Runnable, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor after it runs the given action.:::return->screenExecutor->asyncRunStage
CompletableFuture#completedFuture(U):::Returns a new CompletableFuture that is already completed with the given value.:::return->new->CompletableFuture<U>
CompletableFuture#isDone():::Returns true if completed in any fashion: normally, exceptionally, or via cancellation.:::return
CompletableFuture#get():::Waits if necessary for this future to complete, and then returns its result.:::r->if->waitingGet->return->reportGet
CompletableFuture#get(long, TimeUnit):::Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.:::nanos->unit->toNanos->r->if->timedGet->return->reportGet
CompletableFuture#join():::Returns the result value when complete, or throws an (unchecked) exception if completed exceptionally:::r->if->waitingGet->return->reportJoin
CompletableFuture#getNow(T):::Returns the result value (or throws any encountered exception) if completed, else returns the given valueIfAbsent.:::r->return->reportJoin
CompletableFuture#complete(T):::If not already completed, sets the value returned by #get() and related methods to the given value.:::triggered->completeValue->postComplete->return
CompletableFuture#completeExceptionally(Throwable):::If not already completed, causes invocations of #get() and related methods to throw the given exception.:::if->throw->new->NullPointerException->triggered->new->AltResult->internalComplete->postComplete->return
CompletableFuture#toCompletableFuture():::Returns this CompletableFuture.:::return
CompletableFuture#exceptionally(Function):::Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value:::return->uniExceptionallyStage
CompletableFuture#allOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete:::return->andTree
CompletableFuture#anyOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result:::n->r->if->return->new->CompletableFuture<Object>->uniCopyStage->foreach->if->return->encodeRelay->new->CompletableFuture<Object>->cfs->clone->d->new->CompletableFuture<>->foreach->cf->new->AnyOf->unipush->if->for->i->len->return
CompletableFuture#cancel(boolean):::If not already completed, completes this CompletableFuture with a CancellationException:::cancelled->new->CancellationException->new->AltResult->internalComplete->postComplete->return->isCancelled
CompletableFuture#isCancelled():::Returns true if this CompletableFuture was cancelled before it completed normally.:::r->return
CompletableFuture#isCompletedExceptionally():::Returns true if this CompletableFuture completed exceptionally, in any way:::r->return
CompletableFuture#obtrudeValue(T):::Forcibly sets or resets the value subsequently returned by method #get() and related methods, whether or not already completed:::postComplete
CompletableFuture#obtrudeException(Throwable):::Forcibly causes subsequent invocations of method #get() and related methods to throw the given exception, whether or not already completed:::if->throw->new->NullPointerException->new->AltResult->postComplete
CompletableFuture#getNumberOfDependents():::Returns the estimated number of CompletableFutures whose completions are awaiting completion of this CompletableFuture:::count->for->p->return
CompletableFuture#toString():::Returns a string identifying this CompletableFuture, as well as its completion state:::r->count->for->p->return->super->toString
CompletableFuture#newIncompleteFuture():::Returns a new incomplete CompletableFuture of the type to be returned by a CompletionStage method:::return->new->CompletableFuture<U>
CompletableFuture#defaultExecutor():::Returns the default Executor used for async methods that do not specify an Executor:::return
CompletableFuture#copy():::Returns a new CompletableFuture that is completed normally with the same value as this CompletableFuture when it completes normally:::return->uniCopyStage
CompletableFuture#minimalCompletionStage():::Returns a new CompletionStage that is completed normally with the same value as this CompletableFuture when it completes normally, and cannot be independently completed or otherwise used in ways not defined by the methods of interface CompletionStage:::return->uniAsMinimalStage
CompletableFuture#completeAsync(Supplier, Executor):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the given executor.:::if->throw->new->NullPointerException->executor->new->AsyncSupply<T>->execute->return
CompletableFuture#completeAsync(Supplier):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the default executor.:::return->defaultExecutor->completeAsync
CompletableFuture#orTimeout(long, TimeUnit):::Exceptionally completes this CompletableFuture with a TimeoutException if not otherwise completed before the given timeout.:::if->throw->new->NullPointerException->if->Delayer->new->Timeout->delay->new->Canceller->whenComplete->return
CompletableFuture#completeOnTimeout(T, long, TimeUnit):::Completes this CompletableFuture with the given value if not otherwise completed before the given timeout.:::if->throw->new->NullPointerException->if->Delayer->new->DelayedCompleter<T>->delay->new->Canceller->whenComplete->return
CompletableFuture#delayedExecutor(long, TimeUnit, Executor):::Returns a new Executor that submits a task to the given base executor after the given delay (or no delay if non-positive):::if->throw->new->NullPointerException->return->new->DelayedExecutor
CompletableFuture#delayedExecutor(long, TimeUnit):::Returns a new Executor that submits a task to the default executor after the given delay (or no delay if non-positive):::if->throw->new->NullPointerException->return->new->DelayedExecutor
CompletableFuture#completedStage(U):::Returns a new CompletionStage that is already completed with the given value and supports only those methods in interface CompletionStage.:::return->new->MinimalStage<U>
CompletableFuture#failedFuture(Throwable):::Returns a new CompletableFuture that is already completed exceptionally with the given exception.:::if->throw->new->NullPointerException->return->new->AltResult->new->CompletableFuture<U>
CompletableFuture#failedStage(Throwable):::Returns a new CompletionStage that is already completed exceptionally with the given exception and supports only those methods in interface CompletionStage.:::if->throw->new->NullPointerException->return->new->AltResult->new->MinimalStage<U>
CompletionService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
CompletionService#submit(Runnable, V):::Submits a Runnable task for execution and returns a Future representing that task:::
CompletionService#take():::Retrieves and removes the Future representing the next completed task, waiting if none are yet present.:::
CompletionService#poll():::Retrieves and removes the Future representing the next completed task, or null if none are present.:::
CompletionService#poll(long, TimeUnit):::Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.:::
CompletionStage#thenApply(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function:::
CompletionStage#thenAccept(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied action:::
CompletionStage#thenRun(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action:::
CompletionStage#thenRunAsync(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#thenRunAsync(Runnable, Executor):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using the supplied Executor:::
CompletionStage#thenCombine(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function:::
CompletionStage#thenAcceptBoth(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied action:::
CompletionStage#runAfterBoth(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using the supplied executor:::
CompletionStage#applyToEither(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function:::
CompletionStage#acceptEither(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied action:::
CompletionStage#runAfterEither(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using the supplied executor:::
CompletionStage#thenCompose(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function:::
CompletionStage#thenComposeAsync(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using this stage's default asynchronous execution facility:::
CompletionStage#thenComposeAsync(Function>, Executor):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using the supplied Executor:::
CompletionStage#handle(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using this stage's default asynchronous execution facility, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction, Executor):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using the supplied executor, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#whenComplete(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using this stage's default asynchronous execution facility when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer, Executor):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using the supplied Executor when this stage completes:::
CompletionStage#exceptionally(Function):::Returns a new CompletionStage that, when this stage completes exceptionally, is executed with this stage's exception as the argument to the supplied function:::
CompletionStage#toCompletableFuture():::Returns a CompletableFuture maintaining the same completion properties as this stage:::
ConcurrentHashMap.Node#find(int, Object):::Virtualized support for map.get(); overridden in subclasses.:::e->if->do->ek->if->k->equals->return->while->return
ConcurrentHashMap#spread(int):::Spreads (XORs) higher bits of hash to lower and also forces top bit to 0:::return
ConcurrentHashMap#comparableClassFor(Object):::Returns x's Class if it is of the form "class C implements Comparable<C>", else null.:::if->c->ts->as->p->if->x->getClass->return->if->c->getGenericInterfaces->foreach->if->getRawType->p->getActualTypeArguments->return->return
ConcurrentHashMap#compareComparables(Class, Object, Object):::Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.:::return->x->getClass->compareTo
ConcurrentHashMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::tab->e->p->n->eh->ek->h->key->hashCode->spread->if->tabAt->if->if->key->equals->return->else->if->return->e->find->while->if->key->equals->return->return
ConcurrentHashMap#containsKey(Object):::Tests if the specified object is a key in this table.:::return->get
ConcurrentHashMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::if->throw->new->NullPointerException->t->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#put(K, V):::Maps the specified key to the specified value in this table:::return->putVal
ConcurrentHashMap#putVal(K, V, boolean):::Implementation for put and putIfAbsent:::if->throw->new->NullPointerException->hash->key->hashCode->spread->binCount->for->tab->addCount->return
ConcurrentHashMap#putAll(Map):::Copies all of the mappings from the specified map to this one:::m->size->tryPresize->foreach->m->entrySet->e->getKey->e->getValue->putVal
ConcurrentHashMap#remove(Object):::Removes the key (and its corresponding value) from this map:::return->replaceNode
ConcurrentHashMap#replaceNode(Object, V, Object):::Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null:::hash->key->hashCode->spread->for->tab->return
ConcurrentHashMap#clear():::Removes all of the mappings from this map.:::delta->i->tab->while->fh->f->tabAt->if->else->if->helpTransfer->else->synchronized->if->tabAt->p->while->setTabAt->if->addCount
ConcurrentHashMap#keySet():::Returns a Set view of the keys contained in this map:::ks->if->return->return->new->KeySetView<K,V>
ConcurrentHashMap#values():::Returns a Collection view of the values contained in this map:::vs->if->return->return->new->ValuesView<K,V>
ConcurrentHashMap#entrySet():::Returns a Set view of the mappings contained in this map:::es->if->return->return->new->EntrySetView<K,V>
ConcurrentHashMap#hashCode():::Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().:::h->t->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#toString():::Returns a string representation of this map:::t->f->it->new->Traverser<K,V>->sb->new->StringBuilder->sb->append->p->if->it->advance->for->return->sb->append->toString
ConcurrentHashMap#equals(Object):::Compares the specified object with this map for equality:::if->if->return->m->t->f->it->new->Traverser<K,V>->for->p->it->advance->foreach->m->entrySet->mk->mv->v->if->e->getKey->e->getValue->get->mv->equals->return->return
ConcurrentHashMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.:::v->return->get
ConcurrentHashMap#removeEntryIf(Predicate>):::Helper method for EntrySetView.removeIf.:::if->throw->new->NullPointerException->t->removed->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#removeValueIf(Predicate):::Helper method for ValuesView.removeIf.:::if->throw->new->NullPointerException->t->removed->if->it->new->Traverser<K,V>->for->p->it->advance->return
ConcurrentHashMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->binCount->for->tab->if->addCount->return
ConcurrentHashMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#merge(K, V, BiFunction):::If the specified key is not already associated with a (non-null) value, associates it with the given value:::if->throw->new->NullPointerException->h->key->hashCode->spread->val->delta->binCount->for->tab->if->addCount->return
ConcurrentHashMap#contains(Object):::Tests if some key maps into the specified value in this table:::return->containsValue
ConcurrentHashMap#keys():::Returns an enumeration of the keys in this table.:::t->f->return->new->KeyIterator<K,V>
ConcurrentHashMap#elements():::Returns an enumeration of the values in this table.:::t->f->return->new->ValueIterator<K,V>
ConcurrentHashMap#mappingCount():::Returns the number of mappings:::n->sumCount->return
ConcurrentHashMap#newKeySet():::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::return->new->ConcurrentHashMap<K,Boolean>->new->KeySetView<K,Boolean>
ConcurrentHashMap#newKeySet(int):::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::return->new->ConcurrentHashMap<K,Boolean>->new->KeySetView<K,Boolean>
ConcurrentHashMap#keySet(V):::Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., Collection#add and Collection#addAll(Collection)):::if->throw->new->NullPointerException->return->new->KeySetView<K,V>
ConcurrentHashMap#resizeStamp(int):::Returns the stamp bits for resizing a table of size n:::return->Integer->numberOfLeadingZeros
ConcurrentHashMap#helpTransfer(Node[], Node):::Helps transfer if a resize is in progress.:::nextTab->sc->if->rs->resizeStamp->while->if->break->if->U->compareAndSetInt->transfer->break->return->return
ConcurrentHashMap#untreeify(Node):::Returns a list of non-TreeNodes replacing those in given list.:::hd->tl->for->q->return
ConcurrentHashMap.TreeNode#findTreeNode(int, Object, Class):::Returns the TreeNode (or null if not found) for the given key starting at given root.:::if->p->do->ph->dir->pk->q->pl->pr->if->else->if->else->if->k->equals->return->else->if->else->if->else->if->comparableClassFor->compareComparables->else->if->pr->findTreeNode->return->else->while->return
ConcurrentHashMap.TreeBin#tieBreakOrder(Object, Object):::Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable:::d->if->a->getClass->getName->b->getClass->getName->compareTo->System->identityHashCode->System->identityHashCode->return
ConcurrentHashMap.TreeBin#find(int, Object):::Returns matching node or null if none:::if->for->e->return
ConcurrentHashMap.TreeBin#putTreeVal(int, K, V):::Finds or adds a node.:::kc->searched->for->p->return
ConcurrentHashMap.TreeBin#removeTreeNode(TreeNode):::Removes the given node, that must be present before this call:::next->pred->r->rl->if->else->if->if->return->if->return->lockRoot->try->replacement->pl->pr->if->s->sl->while->c->sr->pp->if->else->sp->if->if->else->if->if->if->if->else->if->else->if->else->else->if->else->if->else->if->pp->if->else->if->else->balanceDeletion->if->pp->if->if->else->if->catch->finally->unlockRoot->return
ConcurrentHashMap.TreeBin#checkInvariants(TreeNode):::Checks invariants recursively for the tree of Nodes rooted at t.:::tp->tl->tr->tb->tn->if->return->if->return->if->return->if->return->if->return->if->return->if->checkInvariants->return->if->checkInvariants->return->return
ConcurrentHashMap.Traverser#advance():::Advances if possible, returning next valid node, or null if none.:::e->if->for
ConcurrentHashMap.MapEntry#setValue(V):::Sets our entry's value and writes through to the map:::if->throw->new->NullPointerException->v->map->put->return
ConcurrentHashMap#batchFor(long):::Computes initial batch value for bulk tasks:::n->if->sumCount->return->sp->ForkJoinPool->getCommonPoolParallelism->return
ConcurrentHashMap#forEach(long, BiConsumer):::Performs the given action for each (key, value).:::if->throw->new->NullPointerException->batchFor->new->ForEachMappingTask<K,V>->invoke
ConcurrentHashMap#forEach(long, BiFunction, Consumer):::Performs the given action for each non-null transformation of each (key, value).:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedMappingTask<K,V,U>->invoke
ConcurrentHashMap#search(long, BiFunction):::Returns a non-null result from applying the given search function on each (key, value), or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchMappingsTask<K,V,U>->invoke
ConcurrentHashMap#reduce(long, BiFunction, BiFunction):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsTask<K,V,U>->invoke
ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceToLong(long, ToLongBiFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToLongTask<K,V>->invoke
ConcurrentHashMap#reduceToInt(long, ToIntBiFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceMappingsToIntTask<K,V>->invoke
ConcurrentHashMap#forEachKey(long, Consumer):::Performs the given action for each key.:::if->throw->new->NullPointerException->batchFor->new->ForEachKeyTask<K,V>->invoke
ConcurrentHashMap#forEachKey(long, Function, Consumer):::Performs the given action for each non-null transformation of each key.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedKeyTask<K,V,U>->invoke
ConcurrentHashMap#searchKeys(long, Function):::Returns a non-null result from applying the given search function on each key, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchKeysTask<K,V,U>->invoke
ConcurrentHashMap#reduceKeys(long, BiFunction):::Returns the result of accumulating all keys using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceKeysTask<K,V>->invoke
ConcurrentHashMap#reduceKeys(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysTask<K,V,U>->invoke
ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToLongTask<K,V>->invoke
ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceKeysToIntTask<K,V>->invoke
ConcurrentHashMap#forEachValue(long, Consumer):::Performs the given action for each value.:::if->throw->new->NullPointerException->batchFor->new->ForEachValueTask<K,V>->invoke
ConcurrentHashMap#forEachValue(long, Function, Consumer):::Performs the given action for each non-null transformation of each value.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedValueTask<K,V,U>->invoke
ConcurrentHashMap#searchValues(long, Function):::Returns a non-null result from applying the given search function on each value, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchValuesTask<K,V,U>->invoke
ConcurrentHashMap#reduceValues(long, BiFunction):::Returns the result of accumulating all values using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceValuesTask<K,V>->invoke
ConcurrentHashMap#reduceValues(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesTask<K,V,U>->invoke
ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToLongTask<K,V>->invoke
ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceValuesToIntTask<K,V>->invoke
ConcurrentHashMap#forEachEntry(long, Consumer>):::Performs the given action for each entry.:::if->throw->new->NullPointerException->batchFor->new->ForEachEntryTask<K,V>->invoke
ConcurrentHashMap#forEachEntry(long, Function, ? extends U>, Consumer):::Performs the given action for each non-null transformation of each entry.:::if->throw->new->NullPointerException->batchFor->new->ForEachTransformedEntryTask<K,V,U>->invoke
ConcurrentHashMap#searchEntries(long, Function, ? extends U>):::Returns a non-null result from applying the given search function on each entry, or null if none:::if->throw->new->NullPointerException->return->batchFor->new->AtomicReference<U>->new->SearchEntriesTask<K,V,U>->invoke
ConcurrentHashMap#reduceEntries(long, BiFunction, Map.Entry, ? extends Map.Entry>):::Returns the result of accumulating all entries using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->ReduceEntriesTask<K,V>->invoke
ConcurrentHashMap#reduceEntries(long, Function, ? extends U>, BiFunction):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesTask<K,V,U>->invoke
ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction>, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToDoubleTask<K,V>->invoke
ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction>, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToLongTask<K,V>->invoke
ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction>, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::if->throw->new->NullPointerException->return->batchFor->new->MapReduceEntriesToIntTask<K,V>->invoke
ConcurrentHashMap.CollectionView#getMap():::Returns the map backing this view.:::return
ConcurrentHashMap.CollectionView#clear():::Removes all of the elements from this view, by removing all the mappings from the map backing this view.:::map->clear
ConcurrentHashMap.CollectionView#iterator():::Returns an iterator over the elements in this collection:::
ConcurrentHashMap.CollectionView#toString():::Returns a string representation of this collection:::sb->new->StringBuilder->sb->append->it->iterator->if->it->hasNext->for->return->sb->append->toString
ConcurrentHashMap.KeySetView#getMappedValue():::Returns the default mapped value for additions, or null if additions are not supported.:::return
ConcurrentHashMap.KeySetView#remove(Object):::Removes the key from this map view, by removing the key (and its corresponding value) from the backing map:::return->map->remove
ConcurrentHashMap.KeySetView#add(K):::Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.:::v->if->throw->new->UnsupportedOperationException->return->map->putVal
ConcurrentHashMap.KeySetView#addAll(Collection):::Adds all of the elements in the specified collection to this set, as if by calling #add on each one.:::added->v->if->throw->new->UnsupportedOperationException->foreach->if->map->putVal->return
ConcurrentHashMap.BulkTask#advance():::Same as Traverser version.:::e->if->for
ConcurrentLinkedDeque#newNode(E):::Returns a new node holding item:::node->new->Node<E>->ITEM->set->return
ConcurrentLinkedDeque#unlink(Node):::Unlinks non-null node x.:::prev->next->if->unlinkFirst->else->if->unlinkLast->else->activePred->activeSucc->isFirst->isLast->hops->for->p->for->p->if->return->skipDeletedSuccessors->skipDeletedPredecessors->if->updateHead->updateTail->PREV->prevTerminator->setRelease->NEXT->nextTerminator->setRelease
ConcurrentLinkedDeque#succ(Node):::Returns the successor of p, or the first node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->first->return
ConcurrentLinkedDeque#pred(Node):::Returns the predecessor of p, or the last node if p.prev has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->last->return
ConcurrentLinkedDeque#first():::Returns the first node, the unique node p for which:     p.prev == null && p.next != p The returned node may or may not be logically deleted:::for
ConcurrentLinkedDeque#last():::Returns the last node, the unique node p for which:     p.next == null && p.prev != p The returned node may or may not be logically deleted:::for
ConcurrentLinkedDeque#addFirst(E):::Inserts the specified element at the front of this deque:::linkFirst
ConcurrentLinkedDeque#addLast(E):::Inserts the specified element at the end of this deque:::linkLast
ConcurrentLinkedDeque#offerFirst(E):::Inserts the specified element at the front of this deque:::linkFirst->return
ConcurrentLinkedDeque#offerLast(E):::Inserts the specified element at the end of this deque:::linkLast->return
ConcurrentLinkedDeque#offer(E):::Inserts the specified element at the tail of this deque:::return->offerLast
ConcurrentLinkedDeque#add(E):::Inserts the specified element at the tail of this deque:::return->offerLast
ConcurrentLinkedDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::Objects->requireNonNull->for->p->first->succ->return
ConcurrentLinkedDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::Objects->requireNonNull->for->p->last->pred->return
ConcurrentLinkedDeque#contains(Object):::Returns true if this deque contains the specified element:::if->for->p->first->succ->return
ConcurrentLinkedDeque#isEmpty():::Returns true if this collection contains no elements.:::return->peekFirst
ConcurrentLinkedDeque#size():::Returns the number of elements in this deque:::for
ConcurrentLinkedDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::return->removeFirstOccurrence
ConcurrentLinkedDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beginningOfTheEnd->last->foreach->newNode->Objects->requireNonNull->newNode->if->else->NEXT->set->PREV->set->if->return->for
ConcurrentLinkedDeque#clear():::Removes all of the elements from this deque.:::while->pollFirst
ConcurrentLinkedDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::return->toArrayInternal
ConcurrentLinkedDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::if->throw->new->NullPointerException->return->toArrayInternal
ConcurrentLinkedDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::return->new->Itr
ConcurrentLinkedDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::return->new->DescendingItr
ConcurrentLinkedDeque#spliterator():::Returns a Spliterator over the elements in this deque:::return->new->CLDSpliterator
ConcurrentLinkedQueue#add(E):::Inserts the specified element at the tail of this queue:::return->offer
ConcurrentLinkedQueue#updateHead(Node, Node):::Tries to CAS head to p:::if->HEAD->compareAndSet->NEXT->setRelease
ConcurrentLinkedQueue#succ(Node):::Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::if->return
ConcurrentLinkedQueue#offer(E):::Inserts the specified element at the tail of this queue:::newNode->Objects->requireNonNull->new->Node<E>->for->t->p
ConcurrentLinkedQueue#first():::Returns the first live (non-deleted) node on list, or null if none:::for
ConcurrentLinkedQueue#isEmpty():::Returns true if this queue contains no elements.:::return->first
ConcurrentLinkedQueue#size():::Returns the number of elements in this queue:::for
ConcurrentLinkedQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->for
ConcurrentLinkedQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->for
ConcurrentLinkedQueue#addAll(Collection):::Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beginningOfTheEnd->last->foreach->newNode->Objects->requireNonNull->new->Node<E>->if->else->last->appendRelaxed->if->return->for->t->p
ConcurrentLinkedQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::return->toArrayInternal
ConcurrentLinkedQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects->requireNonNull->return->toArrayInternal
ConcurrentLinkedQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
ConcurrentLinkedQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->CLQSpliterator
ConcurrentLinkedQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::for->pred
ConcurrentMap#putIfAbsent(K, V):::If the specified key is not already associated with a value, associates it with the given value:::
ConcurrentMap#remove(Object, Object):::Removes the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V, V):::Replaces the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V):::Replaces the entry for a key only if currently mapped to some value:::
ConcurrentNavigableMap#descendingMap():::Returns a reverse order view of the mappings contained in this map:::
ConcurrentNavigableMap#navigableKeySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#descendingKeySet():::Returns a reverse order NavigableSet view of the keys contained in this map:::
ConcurrentSkipListMap#cpr(Comparator, Object, Object):::Compares using comparator or natural ordering if null:::return->c->compare->compareTo
ConcurrentSkipListMap#baseHead():::Returns the header for base node list, or null if uninitialized:::h->VarHandle->acquireFence->return
ConcurrentSkipListMap#unlinkNode(Node, Node):::Tries to unlink deleted node n from predecessor b (if both exist), by first splicing in a marker if not already present:::if->f->p->for->NEXT->compareAndSet
ConcurrentSkipListMap#getAdderCount():::Returns element count, initializing adder if necessary.:::a->c->do->while->ADDER->new->LongAdder->compareAndSet->return->a->sum
ConcurrentSkipListMap#addIndices(Index, int, Index, Comparator):::Add indices after an insertion:::z->key->if->retrying->for->return
ConcurrentSkipListMap#doRemove(Object, Object):::Main deletion method:::if->throw->new->NullPointerException->cmp->result->b->while->findPredecessor->for->if->tryReduceLevel->addCount->return
ConcurrentSkipListMap#findFirst():::Gets first valid node, unlinking deleted nodes if encountered.:::b->n->if->baseHead->while->if->unlinkNode->else->return->return
ConcurrentSkipListMap#findFirstEntry():::Entry snapshot version of findFirst:::b->n->v->if->baseHead->while->if->unlinkNode->else->return->new->AbstractMap.SimpleImmutableEntry<K,V>->return
ConcurrentSkipListMap#findLast():::Specialized version of find to get last valid node.:::for->return
ConcurrentSkipListMap#findLastEntry():::Entry version of findLast:::for
ConcurrentSkipListMap#findNear(K, int, Comparator):::Utility for ceiling, floor, lower, higher methods.:::if->throw->new->NullPointerException->result->for->b->return
ConcurrentSkipListMap#findNearEntry(K, int, Comparator):::Variant of findNear returning SimpleImmutableEntry:::for
ConcurrentSkipListMap#clone():::Returns a shallow copy of this ConcurrentSkipListMap instance:::try->clone->super->clone->clone->buildFromSorted->return->catch->throw->new->InternalError->finally
ConcurrentSkipListMap#containsKey(Object):::Returns true if this map contains a mapping for the specified key.:::return->doGet
ConcurrentSkipListMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::return->doGet
ConcurrentSkipListMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.:::v->return->doGet
ConcurrentSkipListMap#put(K, V):::Associates the specified value with the specified key in this map:::if->throw->new->NullPointerException->return->doPut
ConcurrentSkipListMap#remove(Object):::Removes the mapping for the specified key from this map if present.:::return->doRemove
ConcurrentSkipListMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::if->throw->new->NullPointerException->b->n->v->if->baseHead->while->if->value->equals->return->else->return
ConcurrentSkipListMap#clear():::Removes all of the mappings from this map.:::h->r->d->b->VarHandle->acquireFence->while->if->RIGHT->compareAndSet->else->if->HEAD->compareAndSet->else->count->if->n->v->while->if->VAL->compareAndSet->if->unlinkNode->if->addCount->else->break
ConcurrentSkipListMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::if->throw->new->NullPointerException->v->p->r->if->doGet->mappingFunction->apply->doPut->return
ConcurrentSkipListMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::if->throw->new->NullPointerException->n->v->while->findNode->if->r->remappingFunction->apply->if->if->VAL->compareAndSet->return->else->if->doRemove->break->return
ConcurrentSkipListMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::if->throw->new->NullPointerException->for->return
ConcurrentSkipListMap#merge(K, V, BiFunction):::If the specified key is not already associated with a value, associates it with the given value:::if->throw->new->NullPointerException->for
ConcurrentSkipListMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::ks->if->return->return->new->KeySet<>
ConcurrentSkipListMap#values():::Returns a Collection view of the values contained in this map:::vs->if->return->return->new->Values<>
ConcurrentSkipListMap#entrySet():::Returns a Set view of the mappings contained in this map:::es->if->return->return->new->EntrySet<K,V>
ConcurrentSkipListMap#equals(Object):::Compares the specified object with this map for equality:::if->return->if->return->m->try->cmp->it->m->entrySet->iterator->if->comparator->b->n->if->baseHead->while->k->v->if->if->it->hasNext->return->e->it->next->mk->e->getKey->mv->e->getValue->if->return->try->if->cpr->return->catch->return->finally->if->mv->equals->return->return->it->hasNext->else->while->it->hasNext->v->e->it->next->mk->e->getKey->mv->e->getValue->if->get->v->equals->return->b->n->if->baseHead->k->v->mv->while->if->m->get->mv->equals->return->return->catch->return->finally
ConcurrentSkipListMap#lowerEntry(K):::Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#floorEntry(K):::Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#ceilingEntry(K):::Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such entry:::return->findNearEntry
ConcurrentSkipListMap#higherEntry(K):::Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key:::return->findNearEntry
ConcurrentSkipListMap#firstEntry():::Returns a key-value mapping associated with the least key in this map, or null if the map is empty:::return->findFirstEntry
ConcurrentSkipListMap#lastEntry():::Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::return->findLastEntry
ConcurrentSkipListMap#pollFirstEntry():::Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty:::return->doRemoveFirstEntry
ConcurrentSkipListMap#pollLastEntry():::Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::return->doRemoveLastEntry
ConcurrentSkipListMap.Iter#advance(Node):::Advances next to higher entry.:::n->v->if->while
ConcurrentSkipListMap.SubMap#isBeforeEnd(ConcurrentSkipListMap.Node, Comparator):::Returns true if node key is less than upper bound of range.:::if->return->if->return->k->if->return->c->cpr->return
ConcurrentSkipListMap.SubMap#loNode(Comparator):::Returns lowest node:::if->return->m->findFirst->else->if->return->m->findNear->else->return->m->findNear
ConcurrentSkipListMap.SubMap#hiNode(Comparator):::Returns highest node:::if->return->m->findLast->else->if->return->m->findNear->else->return->m->findNear
ConcurrentSkipListMap.SubMap#lowestKey():::Returns lowest absolute key (ignoring directionality).:::cmp->n->loNode->if->isBeforeEnd->return->else->throw->new->NoSuchElementException
ConcurrentSkipListMap.SubMap#highestKey():::Returns highest absolute key (ignoring directionality).:::cmp->n->hiNode->if->last->if->inBounds->return->throw->new->NoSuchElementException
ConcurrentSkipListMap.SubMap#getNearEntry(K, int):::Submap version of ConcurrentSkipListMap.findNearEntry.:::cmp->if->if->else->if->tooLow->return->lowestEntry->if->tooHigh->return->highestEntry->e->m->findNearEntry->if->e->getKey->inBounds->return->else->return
ConcurrentSkipListMap.SubMap#newSubMap(K, boolean, K, boolean):::Utility to create submaps, where given bounds override unbounded(null) ones and/or are checked against bounded ones.:::cmp->if->tk->ti->if->if->else->c->cpr->if->throw->new->IllegalArgumentException->if->if->else->c->cpr->if->throw->new->IllegalArgumentException->return->new->SubMap<K,V>
ConcurrentSkipListMap#removeEntryIf(Predicate>):::Helper method for EntrySet.removeIf.:::if->throw->new->NullPointerException->removed->b->n->v->if->baseHead->while->if->k->e->new->AbstractMap.SimpleImmutableEntry<>->if->function->test->remove->return
ConcurrentSkipListMap#removeValueIf(Predicate):::Helper method for Values.removeIf.:::if->throw->new->NullPointerException->removed->b->n->v->if->baseHead->while->if->function->test->remove->return
ConcurrentSkipListSet#clone():::Returns a shallow copy of this ConcurrentSkipListSet instance:::try->clone->super->clone->clone->new->ConcurrentSkipListMap<E,Object>->setMap->return->catch->throw->new->InternalError->finally
ConcurrentSkipListSet#size():::Returns the number of elements in this set:::return->m->size
ConcurrentSkipListSet#isEmpty():::Returns true if this set contains no elements.:::return->m->isEmpty
ConcurrentSkipListSet#contains(Object):::Returns true if this set contains the specified element:::return->m->containsKey
ConcurrentSkipListSet#add(E):::Adds the specified element to this set if it is not already present:::return->m->putIfAbsent
ConcurrentSkipListSet#remove(Object):::Removes the specified element from this set if it is present:::return->m->remove
ConcurrentSkipListSet#clear():::Removes all of the elements from this set.:::m->clear
ConcurrentSkipListSet#iterator():::Returns an iterator over the elements in this set in ascending order.:::return->m->navigableKeySet->iterator
ConcurrentSkipListSet#descendingIterator():::Returns an iterator over the elements in this set in descending order.:::return->m->descendingKeySet->iterator
ConcurrentSkipListSet#equals(Object):::Compares the specified object with this set for equality:::if->return->if->return->c->try->return->containsAll->c->containsAll->catch->return->finally
ConcurrentSkipListSet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::modified->foreach->if->remove->return
ConcurrentSkipListSet#descendingSet():::Returns a reverse order view of the elements contained in this set:::return->m->descendingMap->new->ConcurrentSkipListSet<E>
ConcurrentSkipListSet#spliterator():::Returns a Spliterator over the elements in this set:::return->keySpliterator->new->SubMapKeyIterator
CopyOnWriteArrayList#getArray():::Gets the array:::return
CopyOnWriteArrayList#setArray(Object[]):::Sets the array.:::
CopyOnWriteArrayList#size():::Returns the number of elements in this list.:::return->getArray
CopyOnWriteArrayList#isEmpty():::Returns true if this list contains no elements.:::return->size
CopyOnWriteArrayList#contains(Object):::Returns true if this list contains the specified element:::return->indexOf
CopyOnWriteArrayList#indexOf(E, int):::Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found:::es->getArray->return->indexOfRange
CopyOnWriteArrayList#lastIndexOf(E, int):::Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found:::es->getArray->return->lastIndexOfRange
CopyOnWriteArrayList#clone():::Returns a shallow copy of this list:::try->clone->super->clone->clone->resetLock->VarHandle->releaseFence->return->catch->throw->new->InternalError->finally
CopyOnWriteArrayList#toArray():::Returns an array containing all of the elements in this list in proper sequence (from first to last element):::return->getArray->clone
CopyOnWriteArrayList#toArray(T[]):::Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::es->getArray->len->if->return->Arrays->a->getClass->copyOf->else->System->arraycopy->if->return
CopyOnWriteArrayList#set(int, E):::Replaces the element at the specified position in this list with the specified element.:::synchronized->es->getArray->oldValue->elementAt->if->es->clone->setArray->return
CopyOnWriteArrayList#add(E):::Appends the specified element to the end of this list.:::synchronized->es->getArray->len->Arrays->copyOf->setArray->return
CopyOnWriteArrayList#add(int, E):::Inserts the specified element at the specified position in this list:::synchronized->es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->newElements->numMoved->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->setArray
CopyOnWriteArrayList#remove(int):::Removes the element at the specified position in this list:::synchronized->es->getArray->len->oldValue->elementAt->numMoved->newElements->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->setArray->return
CopyOnWriteArrayList#remove(Object):::Removes the first occurrence of the specified element from this list, if it is present:::snapshot->getArray->index->indexOfRange->return->remove
CopyOnWriteArrayList#removeRange(int, int):::Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive:::synchronized->es->getArray->len->if->throw->new->IndexOutOfBoundsException->newlen->numMoved->if->Arrays->copyOf->setArray->else->newElements->new->ObjectArr->System->arraycopy->System->arraycopy->setArray
CopyOnWriteArrayList#addIfAbsent(E):::Appends the element, if not present.:::snapshot->getArray->return->indexOfRange->addIfAbsent
CopyOnWriteArrayList#containsAll(Collection):::Returns true if this list contains all of the elements of the specified collection.:::es->getArray->len->foreach->if->indexOfRange->return->return
CopyOnWriteArrayList#removeAll(Collection):::Removes from this list all of its elements that are contained in the specified collection:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList#retainAll(Collection):::Retains only the elements in this list that are contained in the specified collection:::Objects->requireNonNull->return->c->contains->bulkRemove
CopyOnWriteArrayList#addAllAbsent(Collection):::Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.:::cs->c->toArray->if->return->synchronized->es->getArray->len->added->for->i->if->newElements->Arrays->copyOf->System->arraycopy->setArray->return
CopyOnWriteArrayList#clear():::Removes all of the elements from this list:::synchronized->new->ObjectArr->setArray
CopyOnWriteArrayList#addAll(Collection):::Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.:::cs->c->getClass->getArray->c->toArray->if->return->synchronized->es->getArray->len->newElements->if->cs->getClass->else->Arrays->copyOf->System->arraycopy->setArray->return
CopyOnWriteArrayList#addAll(int, Collection):::Inserts all of the elements in the specified collection into this list, starting at the specified position:::cs->c->toArray->synchronized->es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->if->return->numMoved->newElements->if->Arrays->copyOf->else->new->ObjectArr->System->arraycopy->System->arraycopy->System->arraycopy->setArray->return
CopyOnWriteArrayList#toString():::Returns a string representation of this list:::return->Arrays->getArray->toString
CopyOnWriteArrayList#equals(Object):::Compares the specified object with this list for equality:::if->return->if->return->list->it->list->iterator->foreach->getArray->if->it->hasNext->Objects->it->next->equals->return->return->it->hasNext
CopyOnWriteArrayList#hashCode():::Returns the hash code value for this list:::es->getArray->return->hashCodeOfRange
CopyOnWriteArrayList#iterator():::Returns an iterator over the elements in this list in proper sequence:::return->getArray->new->COWIterator<E>
CopyOnWriteArrayList#listIterator():::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::return->getArray->new->COWIterator<E>
CopyOnWriteArrayList#listIterator(int):::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::es->getArray->len->if->throw->outOfBounds->new->IndexOutOfBoundsException->return->new->COWIterator<E>
CopyOnWriteArrayList#spliterator():::Returns a Spliterator over the elements in this list:::return->Spliterators->getArray->spliterator
CopyOnWriteArrayList.COWIterator#remove():::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWIterator#set(E):::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList.COWIterator#add(E):::Not supported:::throw->new->UnsupportedOperationException
CopyOnWriteArrayList#subList(int, int):::Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive:::synchronized->es->getArray->len->size->if->throw->new->IndexOutOfBoundsException->return->new->COWSubList
CopyOnWriteArraySet#size():::Returns the number of elements in this set.:::return->al->size
CopyOnWriteArraySet#isEmpty():::Returns true if this set contains no elements.:::return->al->isEmpty
CopyOnWriteArraySet#contains(Object):::Returns true if this set contains the specified element:::return->al->contains
CopyOnWriteArraySet#toArray():::Returns an array containing all of the elements in this set:::return->al->toArray
CopyOnWriteArraySet#toArray(T[]):::Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array:::return->al->toArray
CopyOnWriteArraySet#clear():::Removes all of the elements from this set:::al->clear
CopyOnWriteArraySet#remove(Object):::Removes the specified element from this set if it is present:::return->al->remove
CopyOnWriteArraySet#add(E):::Adds the specified element to this set if it is not already present:::return->al->addIfAbsent
CopyOnWriteArraySet#containsAll(Collection):::Returns true if this set contains all of the elements of the specified collection:::return->al->getArray->compareSets->al->containsAll
CopyOnWriteArraySet#addAll(Collection):::Adds all of the elements in the specified collection to this set if they're not already present:::return->al->addAllAbsent
CopyOnWriteArraySet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::return->al->removeAll
CopyOnWriteArraySet#retainAll(Collection):::Retains only the elements in this set that are contained in the specified collection:::return->al->retainAll
CopyOnWriteArraySet#iterator():::Returns an iterator over the elements contained in this set in the order in which these elements were added:::return->al->iterator
CopyOnWriteArraySet#equals(Object):::Compares the specified object with this set for equality:::return->al->getArray->compareSets
CopyOnWriteArraySet#spliterator():::Returns a Spliterator over the elements in this set in the order in which these elements were added:::return->Spliterators->al->getArray->spliterator
CountDownLatch#await():::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted:::sync->acquireSharedInterruptibly
CountDownLatch#await(long, TimeUnit):::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted, or the specified waiting time elapses:::return->sync->unit->toNanos->tryAcquireSharedNanos
CountDownLatch#countDown():::Decrements the count of the latch, releasing all waiting threads if the count reaches zero:::sync->releaseShared
CountDownLatch#getCount():::Returns the current count:::return->sync->getCount
CountDownLatch#toString():::Returns a string identifying this latch, as well as its state:::return->super->toString->sync->getCount
CountedCompleter#compute():::The main computation performed by this task.:::
CountedCompleter#onCompletion(CountedCompleter):::Performs an action when method #tryComplete is invoked and the pending count is zero, or when the unconditional method #complete is invoked:::
CountedCompleter#onExceptionalCompletion(Throwable, CountedCompleter):::Performs an action when method #completeExceptionally(Throwable) is invoked or method #compute throws an exception, and this task has not already otherwise completed normally:::return
CountedCompleter#getCompleter():::Returns the completer established in this task's constructor, or null if none.:::return
CountedCompleter#getPendingCount():::Returns the current pending count.:::return
CountedCompleter#setPendingCount(int):::Sets the pending count to the given value.:::
CountedCompleter#addToPendingCount(int):::Adds (atomically) the given value to the pending count.:::PENDING->getAndAdd
CountedCompleter#compareAndSetPendingCount(int, int):::Sets (atomically) the pending count to the given count only if it currently holds the given expected value.:::return->PENDING->compareAndSet
CountedCompleter#decrementPendingCountUnlessZero():::If the pending count is nonzero, (atomically) decrements it.:::c->do->while->PENDING->weakCompareAndSet->return
CountedCompleter#getRoot():::Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.:::a->p->while->return
CountedCompleter#tryComplete():::If the pending count is nonzero, decrements the count; otherwise invokes #onCompletion(CountedCompleter) and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.:::a->s->for->c
CountedCompleter#propagateCompletion():::Equivalent to #tryComplete but does not invoke #onCompletion(CountedCompleter) along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete:::a->s->for->c
CountedCompleter#complete(T):::Regardless of pending count, invokes #onCompletion(CountedCompleter), marks this task as complete and further triggers #tryComplete on this task's completer, if one exists:::p->setRawResult->onCompletion->quietlyComplete->if->p->tryComplete
CountedCompleter#firstComplete():::If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null:::for->c
CountedCompleter#nextComplete():::If this task does not have a completer, invokes ForkJoinTask#quietlyComplete and returns null:::p->if->return->p->firstComplete->else->quietlyComplete->return
CountedCompleter#quietlyCompleteRoot():::Equivalent to getRoot().quietlyComplete().:::for->a->p
CountedCompleter#helpComplete(int):::If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.:::t->wt->if->if->Thread->currentThread->helpComplete->else->externalHelpComplete
CountedCompleter#internalPropagateException(Throwable):::Supports ForkJoinTask exception propagation.:::a->s->while->a->onExceptionalCompletion->a->recordExceptionalCompletion->isExceptionalStatus
CountedCompleter#exec():::Implements execution conventions for CountedCompleters.:::compute->return
CountedCompleter#getRawResult():::Returns the result of the computation:::return
CountedCompleter#setRawResult(T):::A method that result-bearing CountedCompleters may optionally use to help maintain result data:::
CyclicBarrier#getParties():::Returns the number of parties required to trip this barrier.:::return
CyclicBarrier#await():::Waits until all #getParties parties have invoked await on this barrier:::try->return->dowait->catch->throw->new->Error->finally
CyclicBarrier#await(long, TimeUnit):::Waits until all #getParties parties have invoked await on this barrier, or the specified waiting time elapses:::return->unit->toNanos->dowait
CyclicBarrier#isBroken():::Queries if this barrier is in a broken state.:::lock->lock->lock->try->return->catch->finally->lock->unlock
CyclicBarrier#reset():::Resets the barrier to its initial state:::lock->lock->lock->try->breakBarrier->nextGeneration->catch->finally->lock->unlock
CyclicBarrier#getNumberWaiting():::Returns the number of parties currently waiting at the barrier:::lock->lock->lock->try->return->catch->finally->lock->unlock
Delayed#getDelay(TimeUnit):::Returns the remaining delay associated with this object, in the given time unit.:::
DelayQueue#add(E):::Inserts the specified element into this delay queue.:::return->offer
DelayQueue#offer(E):::Inserts the specified element into this delay queue.:::lock->lock->lock->try->q->offer->if->q->peek->available->signal->return->catch->finally->lock->unlock
DelayQueue#put(E):::Inserts the specified element into this delay queue:::offer
DelayQueue#offer(E, long, TimeUnit):::Inserts the specified element into this delay queue:::return->offer
DelayQueue#poll():::Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.:::lock->lock->lock->try->first->q->peek->return->first->getDelay->q->poll->catch->finally->lock->unlock
DelayQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.:::lock->lock->lockInterruptibly->try->for->catch->finally->if->q->peek->available->signal->lock->unlock
DelayQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.:::nanos->unit->toNanos->lock->lock->lockInterruptibly->try->for->catch->finally->if->q->peek->available->signal->lock->unlock
DelayQueue#peek():::Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty:::lock->lock->lock->try->return->q->peek->catch->finally->lock->unlock
DelayQueue#clear():::Atomically removes all of the elements from this delay queue:::lock->lock->lock->try->q->clear->catch->finally->lock->unlock
DelayQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.:::return
DelayQueue#toArray():::Returns an array containing all of the elements in this queue:::lock->lock->lock->try->return->q->toArray->catch->finally->lock->unlock
DelayQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->return->q->toArray->catch->finally->lock->unlock
DelayQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.:::lock->lock->lock->try->return->q->remove->catch->finally->lock->unlock
DelayQueue#removeEQ(Object):::Identity-based version for use in Itr.remove.:::lock->lock->lock->try->for->it->q->iterator->it->hasNext->catch->finally->lock->unlock
DelayQueue#iterator():::Returns an iterator over all the elements (both expired and unexpired) in this queue:::return->toArray->new->Itr
Exchanger#exchange(V):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted), and then transfers the given object to it, receiving its object in return:::v->a->item->if->slotExchange->Thread->interrupted->arenaExchange->throw->new->InterruptedException->return
Exchanger#exchange(V, long, TimeUnit):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return:::v->item->ns->unit->toNanos->if->slotExchange->Thread->interrupted->arenaExchange->throw->new->InterruptedException->if->throw->new->TimeoutException->return
Executor#execute(Runnable):::Executes the given command at some time in the future:::
Executors#newFixedThreadPool(int):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor
Executors#newWorkStealingPool(int):::Creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention:::return->new->ForkJoinPool
Executors#newWorkStealingPool():::Creates a work-stealing thread pool using the number of Runtime#availableProcessors available processors as its target parallelism level.:::return->Runtime->getRuntime->availableProcessors->new->ForkJoinPool
Executors#newFixedThreadPool(int, ThreadFactory):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue, using the provided ThreadFactory to create new threads when needed:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor
Executors#newSingleThreadExecutor():::Creates an Executor that uses a single worker thread operating off an unbounded queue:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor->new->FinalizableDelegatedExecutorService
Executors#newSingleThreadExecutor(ThreadFactory):::Creates an Executor that uses a single worker thread operating off an unbounded queue, and uses the provided ThreadFactory to create a new thread when needed:::return->new->LinkedBlockingQueue<Runnable>->new->ThreadPoolExecutor->new->FinalizableDelegatedExecutorService
Executors#newCachedThreadPool():::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available:::return->new->SynchronousQueue<Runnable>->new->ThreadPoolExecutor
Executors#newCachedThreadPool(ThreadFactory):::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available, and uses the provided ThreadFactory to create new threads when needed.:::return->new->SynchronousQueue<Runnable>->new->ThreadPoolExecutor
Executors#newSingleThreadScheduledExecutor():::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::return->new->ScheduledThreadPoolExecutor->new->DelegatedScheduledExecutorService
Executors#newSingleThreadScheduledExecutor(ThreadFactory):::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::return->new->ScheduledThreadPoolExecutor->new->DelegatedScheduledExecutorService
Executors#newScheduledThreadPool(int):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::return->new->ScheduledThreadPoolExecutor
Executors#newScheduledThreadPool(int, ThreadFactory):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::return->new->ScheduledThreadPoolExecutor
Executors#unconfigurableExecutorService(ExecutorService):::Returns an object that delegates all defined ExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::if->throw->new->NullPointerException->return->new->DelegatedExecutorService
Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService):::Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::if->throw->new->NullPointerException->return->new->DelegatedScheduledExecutorService
Executors#defaultThreadFactory():::Returns a default thread factory used to create new threads:::return->new->DefaultThreadFactory
Executors#privilegedThreadFactory():::Returns a thread factory used to create new threads that have the same permissions as the current thread:::return->new->PrivilegedThreadFactory
Executors#callable(Runnable, T):::Returns a Callable object that, when called, runs the given task and returns the given result:::if->throw->new->NullPointerException->return->new->RunnableAdapter<T>
Executors#callable(Runnable):::Returns a Callable object that, when called, runs the given task and returns null.:::if->throw->new->NullPointerException->return->new->RunnableAdapter<Object>
Executors#callable(PrivilegedAction):::Returns a Callable object that, when called, runs the given privileged action and returns its result.:::if->throw->new->NullPointerException->return->new->Callable<Object>
Executors#callable(PrivilegedExceptionAction):::Returns a Callable object that, when called, runs the given privileged exception action and returns its result.:::if->throw->new->NullPointerException->return->new->Callable<Object>
Executors#privilegedCallable(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context:::if->throw->new->NullPointerException->return->new->PrivilegedCallable<T>
Executors#privilegedCallableUsingCurrentClassLoader(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context, with the current context class loader as the context class loader:::if->throw->new->NullPointerException->return->new->PrivilegedCallableUsingCurrentClassLoader<T>
ExecutorService#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::
ExecutorService#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::
ExecutorService#isShutdown():::Returns true if this executor has been shut down.:::
ExecutorService#isTerminated():::Returns true if all tasks have completed following shut down:::
ExecutorService#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.:::
ExecutorService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
ExecutorService#submit(Runnable, T):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#submit(Runnable):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#invokeAll(Collection>):::Executes the given tasks, returning a list of Futures holding their status and results when all complete:::
ExecutorService#invokeAll(Collection>, long, TimeUnit):::Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first:::
ExecutorService#invokeAny(Collection>):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do:::
ExecutorService#invokeAny(Collection>, long, TimeUnit):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses:::
Flow.Publisher#subscribe(Subscriber):::Adds the given Subscriber if possible:::
Flow.Subscriber#onSubscribe(Subscription):::Method invoked prior to invoking any other Subscriber methods for the given Subscription:::
Flow.Subscriber#onNext(T):::Method invoked with a Subscription's next item:::
Flow.Subscriber#onError(Throwable):::Method invoked upon an unrecoverable error encountered by a Publisher or Subscription, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscriber#onComplete():::Method invoked when it is known that no additional Subscriber method invocations will occur for a Subscription that is not already terminated by error, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscription#request(long):::Adds the given number n of items to the current unfulfilled demand for this subscription:::
Flow.Subscription#cancel():::Causes the Subscriber to (eventually) stop receiving messages:::
Flow#defaultBufferSize():::Returns a default value for Publisher or Subscriber buffering, that may be used in the absence of other constraints.:::return
ForkJoinPool.ForkJoinWorkerThreadFactory#newThread(ForkJoinPool):::Returns a new worker thread operating in the given pool:::
ForkJoinPool.WorkQueue#tryLockPhase():::Tries to lock shared queue by CASing phase field.:::return->PHASE->compareAndSet
ForkJoinPool.WorkQueue#getPoolIndex():::Returns an exportable index (used by ForkJoinWorkerThread).:::return
ForkJoinPool.WorkQueue#queueSize():::Returns the approximate number of tasks in the queue.:::n->BASE->getAcquire->return
ForkJoinPool.WorkQueue#isEmpty():::Provides a more accurate estimate of whether this queue has any tasks than does queueSize, by checking whether a near-empty queue has at least one unclaimed task.:::a->n->cap->b->VarHandle->acquireFence->return
ForkJoinPool.WorkQueue#push(ForkJoinTask):::Pushes a task:::a->s->d->cap->m->p->if->QA->setRelease->if->BASE->getAcquire->VarHandle->fullFence->p->signalWork->else->if->growArray
ForkJoinPool.WorkQueue#lockedPush(ForkJoinTask):::Version of push for shared queues:::a->signal->s->b->cap->d->if->if->growArray->else->if->return
ForkJoinPool.WorkQueue#growArray(boolean):::Doubles the capacity of array:::newA->try->oldA->oldSize->newSize->if->try->new->ForkJoinTask<?>Arr->catch->finally->if->oldMask->newMask->for->s->k->VarHandle->releaseFence->catch->finally->if->if->throw->new->RejectedExecutionException
ForkJoinPool.WorkQueue#poll():::Takes next task, if one exists, in FIFO order.:::b->k->cap->a->while->t->QA->getAcquire->if->if->Thread->yield->else->if->QA->compareAndSet->BASE->setOpaque->return->return
ForkJoinPool.WorkQueue#nextLocalTask():::Takes next task, if one exists, in order specified by mode.:::t->md->b->s->d->cap->a->if->if->if->QA->getAndSet->TOP->setOpaque->else->if->QA->getAndSet->BASE->setOpaque->else->poll->return
ForkJoinPool.WorkQueue#peek():::Returns next task, if one exists, in order specified by mode.:::cap->a->return
ForkJoinPool.WorkQueue#tryUnpush(ForkJoinTask):::Pops the given task only if it is at the current top.:::popped->s->cap->a->if->QA->compareAndSet->TOP->setOpaque->return
ForkJoinPool.WorkQueue#tryLockedUnpush(ForkJoinTask):::Shared version of tryUnpush.:::popped->s->k->cap->a->if->tryLockPhase->if->QA->compareAndSet->releasePhaseLock->return
ForkJoinPool.WorkQueue#cancelAll():::Removes and cancels all known tasks, ignoring any exceptions.:::for->t->poll
ForkJoinPool.WorkQueue#topLevelExec(ForkJoinTask, WorkQueue, int):::Runs the given (stolen) task if nonnull, as well as remaining local tasks and others available from the given queue, up to bound n (to avoid infinite unfairness).:::if->nstolen->for->thread->if->thread->afterTopLevelExec
ForkJoinPool.WorkQueue#tryRemoveAndExec(ForkJoinTask):::If present, removes task from queue and executes it.:::a->s->cap->if->for->m->ns->i
ForkJoinPool.WorkQueue#helpCC(CountedCompleter, int, boolean):::Tries to pop and run tasks within the target's computation until done, not found, or limit exceeded.:::status->if->s->k->cap->a->while->v->o->if->t->for->f->if->v->doExec->if->break->return
ForkJoinPool.WorkQueue#helpAsyncBlocker(ManagedBlocker):::Tries to poll and run AsynchronousCompletionTasks until none found or blocker is released:::if->b->k->cap->a->t->while->QA->getAcquire->if->blocker->isReleasable->break->else->if->if->break->else->if->QA->compareAndSet->BASE->setOpaque->t->doExec
ForkJoinPool.WorkQueue#isApparentlyUnblocked():::Returns true if owned and not known to be blocked.:::wt->s->return->wt->getState
ForkJoinPool#registerWorker(ForkJoinWorkerThread):::Callback from ForkJoinWorkerThread constructor to establish and record its WorkQueue.:::handler->wt->setDaemon->if->wt->setUncaughtExceptionHandler->tid->idbits->prefix->w->new->WorkQueue->if->synchronized->ws->n->s->if->m->for->probes->if->else->an->as->new->WorkQueueArr->am->for->j->wt->prefix->Integer->toString->concat->setName->return
ForkJoinPool#deregisterWorker(ForkJoinWorkerThread, Throwable):::Final callback from terminating worker, as well as upon failure to construct or start a worker:::w->phase->if->lock->wid->ns->if->synchronized->ws->n->i->if->if->c->do->while->CTL->weakCompareAndSet->if->w->cancelAll->if->tryTerminate->signalWork->if->ForkJoinTask->helpExpungeStaleExceptions->else->ForkJoinTask->rethrow
ForkJoinPool#signalWork():::Tries to create or release a worker if too few are running.:::for
ForkJoinPool#runWorker(WorkQueue):::Top-level runloop for workers, called by ForkJoinWorkerThread.run:::r->ThreadLocalRandom->nextSecondarySeed->new->ForkJoinTask<?>Arr->for
ForkJoinPool#awaitJoin(WorkQueue, ForkJoinTask, long):::Helps and/or blocks until the given task is done or timeout:::s->seed->ThreadLocalRandom->nextSecondarySeed->if->w->helpCC->w->tryRemoveAndExec->src->id->r->step->while->ws->n->m->while->q->b->if->a->cap->k->qid->if->t->QA->getAcquire->if->QA->compareAndSet->t->doExec->break->else->if->break->else->if->ms->ns->block->if->else->if->System->nanoTime->break->else->if->toMillis->if->tryCompensate->task->internalWait->CTL->getAndAdd->return
ForkJoinPool#helpQuiescePool(WorkQueue):::Runs tasks until isQuiescent():::prevSrc->seed->ThreadLocalRandom->nextSecondarySeed->r->step->for->source->released
ForkJoinPool#nextTaskFor(WorkQueue):::Gets and removes a local or stolen task for the given worker.:::t->if->w->nextLocalTask->pollScan->return
ForkJoinPool#externalPush(ForkJoinTask):::Adds the given task to a submission queue at submitter's current queue, creating one if null or contended.:::r->if->ThreadLocalRandom->getProbe->ThreadLocalRandom->localInit->ThreadLocalRandom->getProbe->for
ForkJoinPool#commonSubmitterQueue():::Returns common pool queue for an external thread.:::p->r->ThreadLocalRandom->getProbe->ws->n->return
ForkJoinPool#tryExternalUnpush(ForkJoinTask):::Performs tryUnpush for an external submitter.:::r->ThreadLocalRandom->getProbe->ws->w->n->return->w->tryLockedUnpush
ForkJoinPool#externalHelpComplete(CountedCompleter, int):::Performs helpComplete for an external submitter.:::r->ThreadLocalRandom->getProbe->ws->w->n->return->w->helpCC
ForkJoinPool#helpComplete(WorkQueue, CountedCompleter, int):::Tries to steal and run tasks within the target's computation:::return->w->helpCC
ForkJoinPool#getSurplusQueuedTaskCount():::Returns a cheap heuristic guide for task partitioning when programmers, frameworks, tools, or languages have little or no idea about task granularity:::t->wt->pool->q->if->Thread->currentThread->p->a->n->return->return
ForkJoinPool#commonPool():::Returns the common pool instance:::return
ForkJoinPool#invoke(ForkJoinTask):::Performs the given task, returning its result upon completion:::if->throw->new->NullPointerException->externalSubmit->return->task->join
ForkJoinPool#execute(ForkJoinTask):::Arranges for (asynchronous) execution of the given task.:::externalSubmit
ForkJoinPool#submit(ForkJoinTask):::Submits a ForkJoinTask for execution.:::return->externalSubmit
ForkJoinPool#getFactory():::Returns the factory used for constructing new workers.:::return
ForkJoinPool#getUncaughtExceptionHandler():::Returns the handler for internal worker threads that terminate due to unrecoverable errors encountered while executing tasks.:::return
ForkJoinPool#getParallelism():::Returns the targeted parallelism level of this pool.:::par->return
ForkJoinPool#getCommonPoolParallelism():::Returns the targeted parallelism level of the common pool.:::return
ForkJoinPool#getPoolSize():::Returns the number of worker threads that have started but not yet terminated:::return
ForkJoinPool#getAsyncMode():::Returns true if this pool uses local first-in-first-out scheduling mode for forked tasks that are never joined.:::return
ForkJoinPool#getRunningThreadCount():::Returns an estimate of the number of worker threads that are not blocked waiting to join tasks or for other managed synchronization:::ws->w->VarHandle->acquireFence->rc->if->for->i->return
ForkJoinPool#getActiveThreadCount():::Returns an estimate of the number of threads that are currently stealing or executing tasks:::r->return
ForkJoinPool#isQuiescent():::Returns true if all worker threads are currently idle:::for
ForkJoinPool#getStealCount():::Returns an estimate of the total number of tasks stolen from one thread's work queue by another:::count->ws->w->if->for->i->return
ForkJoinPool#getQueuedTaskCount():::Returns an estimate of the total number of tasks currently held in queues by worker threads (but not including tasks submitted to the pool that have not begun executing):::ws->w->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#getQueuedSubmissionCount():::Returns an estimate of the number of tasks submitted to this pool that have not yet begun executing:::ws->w->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#hasQueuedSubmissions():::Returns true if there are any tasks submitted to this pool that have not yet begun executing.:::ws->w->VarHandle->acquireFence->if->for->i->return
ForkJoinPool#pollSubmission():::Removes and returns the next unexecuted submission if one is available:::return->pollScan
ForkJoinPool#drainTasksTo(Collection>):::Removes all available unexecuted submitted and forked tasks from scheduling queues and adds them to the given collection, without altering their execution status:::ws->w->t->VarHandle->acquireFence->count->if->for->i->return
ForkJoinPool#toString():::Returns a string identifying this pool, as well as its state, including indications of run state, parallelism level, and worker and task counts.:::md->c->st->qt->qs->rc->ws->w->if->for->i->pc->tc->ac->if->level->return->super->toString
ForkJoinPool#shutdown():::Possibly initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::checkPermission->tryTerminate
ForkJoinPool#shutdownNow():::Possibly attempts to cancel and/or stop all tasks, and reject all subsequently submitted tasks:::checkPermission->tryTerminate->return->Collections->emptyList
ForkJoinPool#isTerminated():::Returns true if all tasks have completed following shut down.:::return
ForkJoinPool#isTerminating():::Returns true if the process of termination has commenced but not yet completed:::md->return
ForkJoinPool#isShutdown():::Returns true if this pool has been shut down.:::return
ForkJoinPool#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first:::if->Thread->interrupted->throw->new->InterruptedException->if->awaitQuiescence->return->nanos->unit->toNanos->if->isTerminated->return->if->return->deadline->System->nanoTime->synchronized->for
ForkJoinPool#awaitQuiescence(long, TimeUnit):::If called by a ForkJoinTask operating in this pool, equivalent in effect to ForkJoinTask#helpQuiesce:::nanos->unit->toNanos->wt->thread->Thread->currentThread->if->helpQuiescePool->return->else->for->startTime->System->nanoTime
ForkJoinPool#quiesceCommonPool():::Waits and/or attempts to assist performing tasks indefinitely until the #commonPool() #isQuiescent.:::common->awaitQuiescence
ForkJoinPool.ManagedBlocker#block():::Possibly blocks the current thread, for example waiting for a lock or condition.:::
ForkJoinPool.ManagedBlocker#isReleasable():::Returns true if blocking is unnecessary.:::
ForkJoinPool#managedBlock(ManagedBlocker):::Runs the given possibly blocking task:::if->throw->new->NullPointerException->p->wt->w->t->Thread->currentThread->if->block->while->blocker->isReleasable->if->p->tryCompensate->try->do->while->blocker->isReleasable->blocker->block->catch->finally->CTL->getAndAdd->break->else->do->while->blocker->isReleasable->blocker->block
ForkJoinPool#helpAsyncBlocker(Executor, ManagedBlocker):::If the given executor is a ForkJoinPool, poll and execute AsynchronousCompletionTasks from worker's queue until none are available or blocker is released.:::if->w->wt->ws->r->n->p->thread->Thread->currentThread->if->else->if->ThreadLocalRandom->getProbe->else->if->w->helpAsyncBlocker
ForkJoinTask#doExec():::Primary execution method for stolen tasks:::s->completed->if->try->exec->catch->setExceptionalCompletion->finally->if->setDone->return
ForkJoinTask#internalWait(long):::If not done, sets SIGNAL status and performs Object.wait(timeout):::if->STATUS->getAndBitwiseOr->synchronized->if->try->wait->catch->finally->else->notifyAll
ForkJoinTask#recordExceptionalCompletion(Throwable):::Records exception and sets status.:::s->if->h->System->identityHashCode->lock->lock->lock->try->expungeStaleExceptions->t->i->for->e->catch->finally->lock->unlock->abnormalCompletion->return
ForkJoinTask#internalPropagateException(Throwable):::Hook for exception propagation support for tasks with completers.:::
ForkJoinTask#cancelIgnoringExceptions(ForkJoinTask):::Cancels, ignoring any exceptions thrown by cancel:::if->try->t->cancel->catch->finally
ForkJoinTask#helpExpungeStaleExceptions():::If lock is available, polls stale refs and removes them:::lock->if->lock->tryLock->try->expungeStaleExceptions->catch->finally->lock->unlock
ForkJoinTask#rethrow(Throwable):::A version of "sneaky throw" to relay exceptions.:::ForkJoinTask->uncheckedThrow
ForkJoinTask#uncheckedThrow(Throwable):::The sneaky part of sneaky throw, relying on generics limitations to evade compiler complaints about rethrowing unchecked exceptions.:::if->throw->else->throw->new->Error
ForkJoinTask#fork():::Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool#commonPool() if not #inForkJoinPool:::t->if->Thread->currentThread->push->else->externalPush->return
ForkJoinTask#join():::Returns the result of the computation when it #isDone is done:::s->if->doJoin->reportException->return->getRawResult
ForkJoinTask#invoke():::Commences performing this task, awaits its completion if necessary, and returns its result, or throws an (unchecked) RuntimeException or Error if the underlying computation did so.:::s->if->doInvoke->reportException->return->getRawResult
ForkJoinTask#invokeAll(ForkJoinTask, ForkJoinTask):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::s1->s2->t2->fork->if->t1->doInvoke->t1->reportException->if->t2->doJoin->t2->reportException
ForkJoinTask#invokeAll(ForkJoinTask...):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::ex->last->for->i->for->i->if->rethrow
ForkJoinTask#invokeAll(Collection):::Forks all tasks in the specified collection, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::if->tasks->new->ForkJoinTask<?>Arr->toArray->invokeAll->return->ts->ex->last->ts->size->for->i->for->i->if->rethrow->return
ForkJoinTask#cancel(boolean):::Attempts to cancel execution of this task:::s->abnormalCompletion->return
ForkJoinTask#isCompletedAbnormally():::Returns true if this task threw an exception or was cancelled.:::return
ForkJoinTask#isCompletedNormally():::Returns true if this task completed without throwing an exception and was not cancelled.:::return
ForkJoinTask#getException():::Returns the exception thrown by the base computation, or a CancellationException if cancelled, or null if none or if the method has not yet completed.:::s->return->new->CancellationException->getThrowableException
ForkJoinTask#completeExceptionally(Throwable):::Completes this task abnormally, and if not already aborted or cancelled, causes it to throw the given exception upon join and related operations:::new->RuntimeException->setExceptionalCompletion
ForkJoinTask#complete(V):::Completes this task, and if not already aborted or cancelled, returning the given value as the result of subsequent invocations of join and related operations:::try->setRawResult->catch->setExceptionalCompletion->return->finally->setDone
ForkJoinTask#quietlyComplete():::Completes this task normally without setting a value:::setDone
ForkJoinTask#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::s->Thread->currentThread->doJoin->externalInterruptibleAwaitDone->if->throw->getThrowableException->new->ExecutionException->else->if->throw->new->CancellationException->else->return->getRawResult
ForkJoinTask#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::s->nanos->unit->toNanos->if->Thread->interrupted->throw->new->InterruptedException->if->d->System->nanoTime->deadline->t->Thread->currentThread->if->wt->awaitJoin->else->if->externalHelpComplete->tryExternalUnpush->doExec->ns->ms->while->System->nanoTime->if->toMillis->STATUS->getAndBitwiseOr->synchronized->if->wait->else->notifyAll->if->throw->new->TimeoutException->else->if->throw->getThrowableException->new->ExecutionException->else->if->throw->new->CancellationException->else->return->getRawResult
ForkJoinTask#quietlyJoin():::Joins this task, without returning its result or throwing its exception:::doJoin
ForkJoinTask#quietlyInvoke():::Commences performing this task and awaits its completion if necessary, without returning its result or throwing its exception.:::doInvoke
ForkJoinTask#helpQuiesce():::Possibly executes tasks until the pool hosting the current task ForkJoinPool#isQuiescent is quiescent:::t->if->Thread->currentThread->wt->helpQuiescePool->else->ForkJoinPool->quiesceCommonPool
ForkJoinTask#reinitialize():::Resets the internal bookkeeping state of this task, allowing a subsequent fork:::if->clearExceptionalCompletion->else
ForkJoinTask#getPool():::Returns the pool hosting the current thread, or null if the current thread is executing outside of any ForkJoinPool:::t->Thread->currentThread->return
ForkJoinTask#inForkJoinPool():::Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.:::return->Thread->currentThread
ForkJoinTask#tryUnfork():::Tries to unschedule this task for execution:::t->return->Thread->currentThread->tryUnpush->tryExternalUnpush
ForkJoinTask#getQueuedTaskCount():::Returns an estimate of the number of tasks that have been forked by the current worker thread but not yet executed:::t->q->if->Thread->currentThread->else->ForkJoinPool->commonSubmitterQueue->return->q->queueSize
ForkJoinTask#getSurplusQueuedTaskCount():::Returns an estimate of how many more locally queued tasks are held by the current worker thread than there are other worker threads that might steal them, or zero if this thread is not operating in a ForkJoinPool:::return->ForkJoinPool->getSurplusQueuedTaskCount
ForkJoinTask#getRawResult():::Returns the result that would be returned by #join, even if this task completed abnormally, or null if this task is not known to have been completed:::
ForkJoinTask#setRawResult(V):::Forces the given value to be returned as a result:::
ForkJoinTask#exec():::Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally:::
ForkJoinTask#peekNextLocalTask():::Returns, but does not unschedule or execute, a task queued by the current thread but not yet executed, if one is immediately available:::t->q->if->Thread->currentThread->else->ForkJoinPool->commonSubmitterQueue->return->q->peek
ForkJoinTask#pollNextLocalTask():::Unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if the current thread is operating in a ForkJoinPool:::t->return->Thread->currentThread->nextLocalTask
ForkJoinTask#pollTask():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available:::t->wt->return->Thread->currentThread->nextTaskFor
ForkJoinTask#pollSubmission():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available:::t->return->Thread->currentThread->pollSubmission
ForkJoinTask#getForkJoinTaskTag():::Returns the tag for this task.:::return
ForkJoinTask#setForkJoinTaskTag(short):::Atomically sets the tag value for this task and returns the old value.:::for->s
ForkJoinTask#compareAndSetForkJoinTaskTag(short, short):::Atomically conditionally sets the tag value for this task:::for->s
ForkJoinTask#adapt(Runnable):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns a null result upon #join.:::return->new->AdaptedRunnableAction
ForkJoinTask#adapt(Runnable, T):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns the given result upon #join.:::return->new->AdaptedRunnable<T>
ForkJoinTask#adapt(Callable):::Returns a new ForkJoinTask that performs the call method of the given Callable as its action, and returns its result upon #join, translating any checked exceptions encountered into RuntimeException.:::return->new->AdaptedCallable<T>
ForkJoinWorkerThread#getPool():::Returns the pool hosting this thread.:::return
ForkJoinWorkerThread#getPoolIndex():::Returns the unique index number of this thread in its pool:::return->workQueue->getPoolIndex
ForkJoinWorkerThread#onStart():::Initializes internal state after construction but before processing any tasks:::
ForkJoinWorkerThread#onTermination(Throwable):::Performs cleanup associated with termination of this worker thread:::
ForkJoinWorkerThread#run():::This method is required to be public, but should never be called explicitly:::if->exception->try->onStart->pool->runWorker->catch->finally->try->onTermination->catch->if->finally->pool->deregisterWorker
ForkJoinWorkerThread#afterTopLevelExec():::Non-public hook method for InnocuousForkJoinWorkerThread.:::
Future#cancel(boolean):::Attempts to cancel execution of this task:::
Future#isCancelled():::Returns true if this task was cancelled before it completed normally.:::
Future#isDone():::Returns true if this task completed:::
Future#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::
Future#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::
FutureTask#done():::Protected method invoked when this task transitions to state isDone (whether normally or via cancellation):::
FutureTask#set(V):::Sets the result of this future to the given value unless this future has already been set or has been cancelled:::if->STATE->compareAndSet->STATE->setRelease->finishCompletion
FutureTask#setException(Throwable):::Causes this future to report an ExecutionException with the given throwable as its cause, unless this future has already been set or has been cancelled:::if->STATE->compareAndSet->STATE->setRelease->finishCompletion
FutureTask#runAndReset():::Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled:::if->RUNNER->Thread->currentThread->compareAndSet->return->ran->s->try->c->if->try->c->call->catch->setException->finally->catch->finally->if->handlePossibleCancellationInterrupt->return
FutureTask#toString():::Returns a string representation of this FutureTask.:::status->switch->break->break->break->callable->return->super->toString
Helpers#collectionToString(Collection):::An implementation of Collection.toString() suitable for classes with locks:::a->c->toArray->size->if->return->charLength->for->i->return->toString
Helpers#toString(Object[], int, int):::Like Arrays.toString(), but caller guarantees that size > 0, each element with index 0 <= i < size is a non-null String, and charLength is the sum of the lengths of the input Strings.:::chars->new->charArr->j->for->i->return->new->String
Helpers#mapEntryToString(Object, Object):::Optimized form of: key + "=" + val:::k->v->klen->vlen->chars->objectToString->length->objectToString->length->new->charArr->k->getChars->v->getChars->return->new->String
LinkedBlockingDeque#unlink(Node):::Unlinks x.:::p->n->if->unlinkFirst->else->if->unlinkLast->else->notFull->signal
LinkedBlockingDeque#add(E):::Inserts the specified element at the end of this deque unless it would violate capacity restrictions:::addLast->return
LinkedBlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque:::return->removeFirst
LinkedBlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque:::return->getFirst
LinkedBlockingDeque#remainingCapacity():::Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::return->removeFirstOccurrence
LinkedBlockingDeque#size():::Returns the number of elements in this deque.:::lock->lock->lock->try->return->catch->finally->lock->unlock
LinkedBlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::if->return->lock->lock->lock->try->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::if->throw->new->IllegalArgumentException->beg->end->n->foreach->Objects->requireNonNull->newNode->new->Node<E>->if->else->if->return->lock->lock->lock->try->if->if->else->notEmpty->signalAll->return->catch->finally->lock->unlock->return->super->addAll
LinkedBlockingDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::lock->lock->lock->try->a->new->ObjectArr->k->for->p->return->catch->finally->lock->unlock
LinkedBlockingDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->if->a->getClass->getComponentType->newInstance->k->for->p->if->return->catch->finally->lock->unlock
LinkedBlockingDeque#clear():::Atomically removes all of the elements from this deque:::lock->lock->lock->try->for->f->notFull->signalAll->catch->finally->lock->unlock
LinkedBlockingDeque#succ(Node):::Used for any element traversal that is not entirely under lock:::if->return
LinkedBlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::return->new->Itr
LinkedBlockingDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::return->new->DescendingItr
LinkedBlockingDeque#spliterator():::Returns a Spliterator over the elements in this deque:::return->new->LBDSpliterator
LinkedBlockingDeque#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::lock->batchSize->es->n->len->do->lock->lock->try->if->if->for->q->succ->new->ObjectArr->for->succ->catch->finally->lock->unlock->for->i->while
LinkedBlockingQueue#fullyLock():::Locks to prevent both puts and takes.:::putLock->lock->takeLock->lock
LinkedBlockingQueue#fullyUnlock():::Unlocks to allow both puts and takes.:::takeLock->unlock->putLock->unlock
LinkedBlockingQueue#size():::Returns the number of elements in this queue.:::return->count->get
LinkedBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::return->count->get
LinkedBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.:::if->throw->new->NullPointerException->c->node->new->Node<E>->putLock->count->putLock->lockInterruptibly->try->while->count->get->notFull->await->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty
LinkedBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.:::if->throw->new->NullPointerException->nanos->unit->toNanos->c->putLock->count->putLock->lockInterruptibly->try->while->count->get->if->return->notFull->awaitNanos->new->Node<E>->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty->return
LinkedBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::if->throw->new->NullPointerException->count->if->count->get->return->c->node->new->Node<E>->putLock->putLock->lock->try->if->count->get->return->enqueue->count->getAndIncrement->if->notFull->signal->catch->finally->putLock->unlock->if->signalNotEmpty->return
LinkedBlockingQueue#unlink(Node, Node):::Unlinks interior Node p with predecessor pred.:::if->if->count->getAndDecrement->notFull->signal
LinkedBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->fullyLock->try->for->pred->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->fullyLock->try->for->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::fullyLock->try->size->count->get->a->new->ObjectArr->k->for->p->return->catch->finally->fullyUnlock
LinkedBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::fullyLock->try->size->count->get->if->a->getClass->getComponentType->newInstance->k->for->p->if->return->catch->finally->fullyUnlock
LinkedBlockingQueue#clear():::Atomically removes all of the elements from this queue:::fullyLock->try->for->p->h->if->count->getAndSet->notFull->signal->catch->finally->fullyUnlock
LinkedBlockingQueue#succ(Node):::Used for any element traversal that is not entirely under lock:::if->return
LinkedBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
LinkedBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->LBQSpliterator
LinkedBlockingQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::batchSize->es->n->len->do->fullyLock->try->if->if->for->q->succ->new->ObjectArr->for->succ->catch->finally->fullyUnlock->for->i->while
LinkedBlockingQueue#findPred(Node, Node):::Returns the predecessor of live node p, given a node that was once a live ancestor of p (or head); allows unlinking of p.:::if->for->q->return
LinkedTransferQueue.Node#selfLink():::Links node to itself to avoid garbage retention:::NEXT->setRelease
LinkedTransferQueue.Node#forgetContents():::Sets item (of a request node) to self and waiter to null, to avoid garbage retention after matching or cancelling:::if->ITEM->set->WAITER->set
LinkedTransferQueue.Node#isMatched():::Returns true if this node has been matched, including the case of artificial matches due to cancellation.:::return
LinkedTransferQueue.Node#tryMatch(Object, Object):::Tries to CAS-match this node; if successful, wakes waiter.:::if->casItem->LockSupport->unpark->return->return
LinkedTransferQueue.Node#cannotPrecede(boolean):::Returns true if a node with the given mode cannot be appended to this node because this node is unmatched and has opposite data mode.:::d->return
LinkedTransferQueue#firstDataNode():::Returns the first unmatched data node, or null if none:::first->for
LinkedTransferQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::return->toArrayInternal
LinkedTransferQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects->requireNonNull->return->toArrayInternal
LinkedTransferQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->LTQSpliterator
LinkedTransferQueue#unsplice(Node, Node):::Unsplices (now or later) the given deleted/cancelled node with the given predecessor.:::if->n->if->pred->casNext->pred->isMatched->for->if->incSweepVotes->sweep
LinkedTransferQueue#put(E):::Inserts the specified element at the tail of this queue:::xfer
LinkedTransferQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#offer(E):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#add(E):::Inserts the specified element at the tail of this queue:::xfer->return
LinkedTransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::return->xfer
LinkedTransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::if->xfer->Thread->interrupted->throw->new->InterruptedException
LinkedTransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::if->unit->toNanos->xfer->return->if->Thread->interrupted->return->throw->new->InterruptedException
LinkedTransferQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::return->new->Itr
LinkedTransferQueue#isEmpty():::Returns true if this queue contains no elements.:::return->firstDataNode
LinkedTransferQueue#size():::Returns the number of elements in this queue:::return->countOfMode
LinkedTransferQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::if->return->for
LinkedTransferQueue#contains(Object):::Returns true if this queue contains the specified element:::if->return->for
LinkedTransferQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a LinkedTransferQueue is not capacity constrained.:::return
LinkedTransferQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::for->pred
Phaser#register():::Adds a new unarrived party to this phaser:::return->doRegister
Phaser#bulkRegister(int):::Adds the given number of new unarrived parties to this phaser:::if->throw->new->IllegalArgumentException->if->return->getPhase->return->doRegister
Phaser#arrive():::Arrives at this phaser, without waiting for others to arrive:::return->doArrive
Phaser#arriveAndDeregister():::Arrives at this phaser and deregisters from it without waiting for others to arrive:::return->doArrive
Phaser#arriveAndAwaitAdvance():::Arrives at this phaser and awaits others:::root->for
Phaser#awaitAdvance(int):::Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::root->s->reconcileState->p->if->return->if->return->root->internalAwaitAdvance->return
Phaser#awaitAdvanceInterruptibly(int):::Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::root->s->reconcileState->p->if->return->if->node->new->QNode->root->internalAwaitAdvance->if->throw->new->InterruptedException->return
Phaser#awaitAdvanceInterruptibly(int, long, TimeUnit):::Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::nanos->unit->toNanos->root->s->reconcileState->p->if->return->if->node->new->QNode->root->internalAwaitAdvance->if->throw->new->InterruptedException->else->if->throw->new->TimeoutException->return
Phaser#forceTermination():::Forces this phaser to enter termination state:::root->s->while->if->STATE->compareAndSet->releaseWaiters->releaseWaiters->return
Phaser#getPhase():::Returns the current phase number:::return
Phaser#getRegisteredParties():::Returns the number of parties registered at this phaser.:::return->partiesOf
Phaser#getArrivedParties():::Returns the number of registered parties that have arrived at the current phase of this phaser:::return->reconcileState->arrivedOf
Phaser#getUnarrivedParties():::Returns the number of registered parties that have not yet arrived at the current phase of this phaser:::return->reconcileState->unarrivedOf
Phaser#getParent():::Returns the parent of this phaser, or null if none.:::return
Phaser#getRoot():::Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.:::return
Phaser#isTerminated():::Returns true if this phaser has been terminated.:::return
Phaser#onAdvance(int, int):::Overridable method to perform an action upon impending phase advance, and to control termination:::return
Phaser#toString():::Returns a string identifying this phaser, as well as its state:::return->reconcileState->stateToString
PriorityBlockingQueue#add(E):::Inserts the specified element into this priority queue.:::return->offer
PriorityBlockingQueue#offer(E):::Inserts the specified element into this priority queue:::if->throw->new->NullPointerException->lock->lock->lock->n->cap->es->while->tryGrow->try->cmp->if->siftUpComparable->else->siftUpUsingComparator->notEmpty->signal->catch->finally->lock->unlock->return
PriorityBlockingQueue#put(E):::Inserts the specified element into this priority queue:::offer
PriorityBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this priority queue:::return->offer
PriorityBlockingQueue#comparator():::Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.:::return
PriorityBlockingQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.:::return
PriorityBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::lock->lock->lock->try->i->indexOf->if->return->removeAt->return->catch->finally->lock->unlock
PriorityBlockingQueue#removeEq(Object):::Identity-based version for use in Itr.remove.:::lock->lock->lock->try->es->for->i->n->catch->finally->lock->unlock
PriorityBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::lock->lock->lock->try->return->indexOf->catch->finally->lock->unlock
PriorityBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock->lock->lock->try->es->for->i->n->catch->finally->lock->unlock
PriorityBlockingQueue#toArray():::Returns an array containing all of the elements in this queue:::lock->lock->lock->try->return->Arrays->copyOf->catch->finally->lock->unlock
PriorityBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock->lock->lock->try->n->if->return->Arrays->a->getClass->copyOf->System->arraycopy->if->return->catch->finally->lock->unlock
PriorityBlockingQueue#iterator():::Returns an iterator over the elements in this queue:::return->toArray->new->Itr
PriorityBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::return->new->PBQSpliterator
RecursiveAction#compute():::The main computation performed by this task.:::
RecursiveAction#getRawResult():::Always returns null.:::return
RecursiveAction#setRawResult(Void):::Requires null completion value.:::
RecursiveAction#exec():::Implements execution conventions for RecursiveActions.:::compute->return
RecursiveTask#compute():::The main computation performed by this task.:::
RecursiveTask#exec():::Implements execution conventions for RecursiveTask.:::compute->return
RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor):::Method that may be invoked by a ThreadPoolExecutor when ThreadPoolExecutor#execute execute cannot accept a task:::
RunnableFuture#run():::Sets this Future to the result of its computation unless it has been cancelled.:::
RunnableScheduledFuture#isPeriodic():::Returns true if this task is periodic:::
ScheduledExecutorService#schedule(Runnable, long, TimeUnit):::Submits a one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#schedule(Callable, long, TimeUnit):::Submits a value-returning one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::
ScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::
ScheduledThreadPoolExecutor#canRunInCurrentRunState(RunnableScheduledFuture):::Returns true if can run a task given current run state and run-after-shutdown parameters.:::if->isShutdown->return->if->isStopped->return->return->task->isPeriodic->task->getDelay
ScheduledThreadPoolExecutor#reExecutePeriodic(RunnableScheduledFuture):::Requeues a periodic task unless current run state precludes it:::if->canRunInCurrentRunState->super->getQueue->add->if->canRunInCurrentRunState->remove->ensurePrestart->return->task->cancel
ScheduledThreadPoolExecutor#onShutdown():::Cancels and clears the queue of all tasks that should not be run due to shutdown policy:::q->super->getQueue->keepDelayed->getExecuteExistingDelayedTasksAfterShutdownPolicy->keepPeriodic->getContinueExistingPeriodicTasksAfterShutdownPolicy->foreach->q->toArray->if->t->if->t->isPeriodic->t->getDelay->t->isCancelled->if->q->remove->t->cancel->tryTerminate
ScheduledThreadPoolExecutor#decorateTask(Runnable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a runnable:::return
ScheduledThreadPoolExecutor#decorateTask(Callable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a callable:::return
ScheduledThreadPoolExecutor#triggerTime(long):::Returns the nanoTime-based trigger time of a delayed action.:::return->System->nanoTime->overflowFree
ScheduledThreadPoolExecutor#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->sft->triggerTime->unit->toNanos->sequencer->getAndIncrement->new->ScheduledFutureTask<Void>->t->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->sft->triggerTime->unit->toNanos->sequencer->getAndIncrement->new->ScheduledFutureTask<Void>->t->decorateTask->delayedExecute->return
ScheduledThreadPoolExecutor#execute(Runnable):::Executes command with zero required delay:::schedule
ScheduledThreadPoolExecutor#setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::if->isShutdown->onShutdown
ScheduledThreadPoolExecutor#getContinueExistingPeriodicTasksAfterShutdownPolicy():::Gets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::return
ScheduledThreadPoolExecutor#setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::if->isShutdown->onShutdown
ScheduledThreadPoolExecutor#getExecuteExistingDelayedTasksAfterShutdownPolicy():::Gets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::return
ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean):::Sets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::
ScheduledThreadPoolExecutor#getRemoveOnCancelPolicy():::Gets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::return
ScheduledThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::super->shutdown
ScheduledThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::return->super->shutdownNow
ScheduledThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::return->super->getQueue
Semaphore#acquire():::Acquires a permit from this semaphore, blocking until one is available, or the thread is Thread#interrupt interrupted:::sync->acquireSharedInterruptibly
Semaphore#acquireUninterruptibly():::Acquires a permit from this semaphore, blocking until one is available:::sync->acquireShared
Semaphore#tryAcquire():::Acquires a permit from this semaphore, only if one is available at the time of invocation:::return->sync->nonfairTryAcquireShared
Semaphore#tryAcquire(long, TimeUnit):::Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::return->sync->unit->toNanos->tryAcquireSharedNanos
Semaphore#release():::Releases a permit, returning it to the semaphore:::sync->releaseShared
Semaphore#acquire(int):::Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is Thread#interrupt interrupted:::if->throw->new->IllegalArgumentException->sync->acquireSharedInterruptibly
Semaphore#acquireUninterruptibly(int):::Acquires the given number of permits from this semaphore, blocking until all are available:::if->throw->new->IllegalArgumentException->sync->acquireShared
Semaphore#tryAcquire(int):::Acquires the given number of permits from this semaphore, only if all are available at the time of invocation:::if->throw->new->IllegalArgumentException->return->sync->nonfairTryAcquireShared
Semaphore#tryAcquire(int, long, TimeUnit):::Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::if->throw->new->IllegalArgumentException->return->sync->unit->toNanos->tryAcquireSharedNanos
Semaphore#release(int):::Releases the given number of permits, returning them to the semaphore:::if->throw->new->IllegalArgumentException->sync->releaseShared
Semaphore#availablePermits():::Returns the current number of permits available in this semaphore:::return->sync->getPermits
Semaphore#drainPermits():::Acquires and returns all permits that are immediately available, or if negative permits are available, releases them:::return->sync->drainPermits
Semaphore#reducePermits(int):::Shrinks the number of available permits by the indicated reduction:::if->throw->new->IllegalArgumentException->sync->reducePermits
Semaphore#isFair():::Returns true if this semaphore has fairness set true.:::return
Semaphore#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::return->sync->hasQueuedThreads
Semaphore#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::return->sync->getQueueLength
Semaphore#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::return->sync->getQueuedThreads
Semaphore#toString():::Returns a string identifying this semaphore, as well as its state:::return->super->toString->sync->getPermits
SubmissionPublisher#roundCapacity(int):::Round capacity to power of 2, at most limit.:::n->return
SubmissionPublisher#subscribe(Subscriber):::Adds the given Subscriber unless already subscribed:::if->throw->new->NullPointerException->max->array->new->ObjectArr->subscription->new->BufferedSubscription<T>->synchronized->if->Thread->currentThread->for->b->pred
SubmissionPublisher#submit(T):::Publishes the given item to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking uninterruptibly while resources for any subscriber are unavailable:::return->doOffer
SubmissionPublisher#offer(T, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method:::return->doOffer
SubmissionPublisher#offer(T, long, TimeUnit, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking while resources for any subscription are unavailable, up to the specified timeout or until the caller thread is interrupted, at which point the given handler (if non-null) is invoked, and if it returns true, retried once:::nanos->unit->toNanos->if->return->doOffer
SubmissionPublisher#close():::Unless already closed, issues Flow.Subscriber#onComplete() onComplete signals to current subscribers, and disallows subsequent attempts to publish:::if->b->synchronized->while->next->b->onComplete
SubmissionPublisher#closeExceptionally(Throwable):::Unless already closed, issues Flow.Subscriber#onError(Throwable) onError signals to current subscribers with the given error, and disallows subsequent attempts to publish:::if->throw->new->NullPointerException->if->b->synchronized->if->while->next->b->onError
SubmissionPublisher#isClosed():::Returns true if this publisher is not accepting submissions.:::return
SubmissionPublisher#getClosedException():::Returns the exception associated with #closeExceptionally(Throwable) closeExceptionally, or null if not closed or if closed normally.:::return
SubmissionPublisher#hasSubscribers():::Returns true if this publisher has any subscribers.:::nonEmpty->synchronized->for->b->return
SubmissionPublisher#getNumberOfSubscribers():::Returns the number of current subscribers.:::synchronized->return->cleanAndCount
SubmissionPublisher#getExecutor():::Returns the Executor used for asynchronous delivery.:::return
SubmissionPublisher#getMaxBufferCapacity():::Returns the maximum per-subscriber buffer capacity.:::return
SubmissionPublisher#getSubscribers():::Returns a list of current subscribers for monitoring and tracking purposes, not for invoking Flow.Subscriber methods on the subscribers.:::subs->new->ArrayList<>->synchronized->pred->next->for->b->return
SubmissionPublisher#isSubscribed(Subscriber):::Returns true if the given Subscriber is currently subscribed.:::if->throw->new->NullPointerException->if->synchronized->pred->next->for->b->return
SubmissionPublisher#estimateMinimumDemand():::Returns an estimate of the minimum number of items requested (via Flow.Subscription#request(long) request) but not yet produced, among all current subscribers.:::min->nonEmpty->synchronized->pred->next->for->b->return
SubmissionPublisher#estimateMaximumLag():::Returns an estimate of the maximum number of items produced but not yet consumed among all current subscribers.:::max->synchronized->pred->next->for->b->return
SubmissionPublisher#consume(Consumer):::Processes all published items using the given Consumer function:::if->throw->new->NullPointerException->status->new->CompletableFuture<>->new->ConsumerSubscriber<T>->subscribe->return
SubmissionPublisher.BufferedSubscription#isClosed():::Returns true if closed (consumer task may still be running).:::return
SubmissionPublisher.BufferedSubscription#estimateLag():::Returns estimated number of buffered items, or negative if closed.:::c->n->return
SubmissionPublisher.BufferedSubscription#offer(T, boolean):::Tries to add item and start consumer task if necessary.:::a->stat->cap->t->i->n->if->added->if->growAndOffer->else->if->QA->compareAndSet->else->QA->setRelease->if->return->startOnOffer
SubmissionPublisher.BufferedSubscription#growAndOffer(T, Object[], int):::Tries to expand buffer and add item, returning true on success:::cap->newCap->newArray->if->try->new->ObjectArr->catch->finally->if->return->else->newMask->for->mask->k->VarHandle->releaseFence->return
SubmissionPublisher.BufferedSubscription#retryOffer(T):::Version of offer for retries (no resize or bias):::a->stat->t->h->cap->if->QA->compareAndSet->return->startOnOffer
SubmissionPublisher.BufferedSubscription#startOnOffer(int):::Tries to start consumer task after offer.:::c->if->getAndBitwiseOrCtl->tryStart->else->if->return
SubmissionPublisher.BufferedSubscription#tryStart():::Tries to start consumer task:::try->e->task->new->ConsumerTask<T>->if->e->execute->catch->getAndBitwiseOrCtl->throw->finally
SubmissionPublisher.BufferedSubscription#startOnSignal(int):::Sets the given control bits, starting task if not running or closed.:::if->getAndBitwiseOrCtl->tryStart
SubmissionPublisher.BufferedSubscription#consume():::Consumer loop, called from ConsumerTask, or indirectly when helping during submit.:::s->if->subscribeOnOpen->d->for->h->t
SubmissionPublisher.BufferedSubscription#takeItems(Subscriber, long, int):::Consumes some items until unavailable or bound or error.:::a->k->cap->if->m->b->n->for->return
SubmissionPublisher.BufferedSubscription#handleOnNext(Subscriber, Throwable):::Processes exception in Subscriber.onNext.:::h->try->if->h->accept->catch->finally->closeOnError
SubmissionPublisher.BufferedSubscription#subscribeOnOpen(Subscriber):::Issues subscriber.onSubscribe if this is first signal.:::if->getAndBitwiseOrCtl->consumeSubscribe
SubmissionPublisher.BufferedSubscription#closeOnComplete(Subscriber):::Issues subscriber.onComplete unless already closed.:::if->getAndBitwiseOrCtl->consumeComplete
SubmissionPublisher.BufferedSubscription#closeOnError(Subscriber, Throwable):::Issues subscriber.onError, and unblocks producer if needed.:::if->getAndBitwiseOrCtl->if->signalWaiter->consumeError
SubmissionPublisher.BufferedSubscription#signalWaiter():::Unblocks waiting producer.:::w->if->LockSupport->unpark
SubmissionPublisher.BufferedSubscription#isReleasable():::Returns true if closed or space available:::a->cap->return->QA->getAcquire
SubmissionPublisher.BufferedSubscription#awaitSpace(long):::Helps or blocks until timeout, closed, or space available.:::if->isReleasable->ForkJoinPool->helpAsyncBlocker->if->isReleasable->try->ForkJoinPool->managedBlock->catch->finally->if->Thread->currentThread->interrupt
SubmissionPublisher.BufferedSubscription#block():::Blocks until closed, space available or timeout:::nanos->timed->deadline->System->nanoTime->while->isReleasable->if->Thread->interrupted->if->break->else->if->System->nanoTime->break->else->if->Thread->currentThread->else->if->else->if->LockSupport->parkNanos->else->LockSupport->park->return
SynchronousQueue.Transferer#transfer(E, boolean, long):::Performs a put or take.:::
SynchronousQueue.TransferStack#isFulfilling(int):::Returns true if m has fulfilling bit set.:::return
SynchronousQueue.TransferStack.SNode#tryMatch(SNode):::Tries to match node s to this node, if so, waking up thread:::if->SMATCH->compareAndSet->w->if->LockSupport->unpark->return->return
SynchronousQueue.TransferStack.SNode#tryCancel():::Tries to cancel a wait by matching node to itself.:::SMATCH->compareAndSet
SynchronousQueue.TransferStack#snode(SNode, Object, SNode, int):::Creates or resets fields of a node:::if->new->SNode->return
SynchronousQueue.TransferStack#transfer(E, boolean, long):::Puts or takes an item.:::s->mode->for
SynchronousQueue.TransferStack#awaitFulfill(SNode, boolean, long):::Spins/blocks until node s is matched by a fulfill operation.:::deadline->System->nanoTime->w->Thread->currentThread->spins->shouldSpin->for
SynchronousQueue.TransferStack#shouldSpin(SNode):::Returns true if node s is at head or there is an active fulfiller.:::h->return->isFulfilling
SynchronousQueue.TransferStack#clean(SNode):::Unlinks s from the stack.:::past->if->past->isCancelled->p->while->p->isCancelled->casHead->while->n->if->n->isCancelled->p->casNext->else
SynchronousQueue.TransferQueue.QNode#tryCancel(Object):::Tries to cancel by CAS'ing ref to this as item.:::QITEM->compareAndSet
SynchronousQueue.TransferQueue.QNode#isOffList():::Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.:::return
SynchronousQueue.TransferQueue#advanceHead(QNode, QNode):::Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.:::if->QHEAD->compareAndSet
SynchronousQueue.TransferQueue#advanceTail(QNode, QNode):::Tries to cas nt as new tail.:::if->QTAIL->compareAndSet
SynchronousQueue.TransferQueue#casCleanMe(QNode, QNode):::Tries to CAS cleanMe slot.:::return->QCLEANME->compareAndSet
SynchronousQueue.TransferQueue#transfer(E, boolean, long):::Puts or takes an item.:::s->isData->for
SynchronousQueue.TransferQueue#awaitFulfill(QNode, E, boolean, long):::Spins/blocks until node s is fulfilled.:::deadline->System->nanoTime->w->Thread->currentThread->spins->for
SynchronousQueue.TransferQueue#clean(QNode, QNode):::Gets rid of cancelled node s with original predecessor pred.:::while->h->hn->if->hn->isCancelled->advanceHead->continue->t->if->return->tn->if->continue->if->advanceTail->continue->if->sn->if->pred->casNext->return->dp->if->d->dn->if->d->isCancelled->dp->casNext->casCleanMe->if->return->else->if->casCleanMe->return
SynchronousQueue#put(E):::Adds the specified element to this queue, waiting if necessary for another thread to receive it.:::if->throw->new->NullPointerException->if->transferer->transfer->Thread->interrupted->throw->new->InterruptedException
SynchronousQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.:::if->throw->new->NullPointerException->if->transferer->unit->toNanos->transfer->return->if->Thread->interrupted->return->throw->new->InterruptedException
SynchronousQueue#offer(E):::Inserts the specified element into this queue, if another thread is waiting to receive it.:::if->throw->new->NullPointerException->return->transferer->transfer
SynchronousQueue#take():::Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.:::e->transferer->transfer->if->return->Thread->interrupted->throw->new->InterruptedException
SynchronousQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.:::e->transferer->unit->toNanos->transfer->if->Thread->interrupted->return->throw->new->InterruptedException
SynchronousQueue#poll():::Retrieves and removes the head of this queue, if another thread is currently making an element available.:::return->transferer->transfer
SynchronousQueue#isEmpty():::Always returns true:::return
SynchronousQueue#size():::Always returns zero:::return
SynchronousQueue#remainingCapacity():::Always returns zero:::return
SynchronousQueue#clear():::Does nothing:::
SynchronousQueue#contains(Object):::Always returns false:::return
SynchronousQueue#remove(Object):::Always returns false:::return
SynchronousQueue#containsAll(Collection):::Returns false unless the given collection is empty:::return->c->isEmpty
SynchronousQueue#removeAll(Collection):::Always returns false:::return
SynchronousQueue#retainAll(Collection):::Always returns false:::return
SynchronousQueue#peek():::Always returns null:::return
SynchronousQueue#iterator():::Returns an empty iterator in which hasNext always returns false.:::return->Collections->emptyIterator
SynchronousQueue#spliterator():::Returns an empty spliterator in which calls to Spliterator#trySplit() trySplit always return null.:::return->Spliterators->emptySpliterator
SynchronousQueue#toArray():::Returns a zero-length array.:::return->new->ObjectArr
SynchronousQueue#toArray(T[]):::Sets the zeroth element of the specified array to null (if the array has non-zero length) and returns it.:::if->return
SynchronousQueue#toString():::Always returns "[]".:::return
ThreadFactory#newThread(Runnable):::Constructs a new Thread:::
ThreadLocalRandom#localInit():::Initialize Thread fields for the current thread:::p->probeGenerator->addAndGet->probe->seed->seeder->getAndAdd->mix64->t->Thread->currentThread->U->putLong->U->putInt
ThreadLocalRandom#current():::Returns the current thread's ThreadLocalRandom.:::if->U->Thread->currentThread->getInt->localInit->return
ThreadLocalRandom#setSeed(long):::Throws UnsupportedOperationException:::if->throw->new->UnsupportedOperationException
ThreadLocalRandom#next(int):::Generates a pseudorandom number with the indicated number of low-order bits:::return->nextInt
ThreadLocalRandom#internalNextLong(long, long):::The form of nextLong used by LongStream Spliterators:::r->nextSeed->mix64->if->n->m->if->else->if->for->u->nextSeed->mix64->else->while->nextSeed->mix64->return
ThreadLocalRandom#internalNextInt(int, int):::The form of nextInt used by IntStream Spliterators:::r->nextSeed->mix32->if->n->m->if->else->if->for->u->nextSeed->mix32->else->while->nextSeed->mix32->return
ThreadLocalRandom#internalNextDouble(double, double):::The form of nextDouble used by DoubleStream Spliterators.:::r->nextLong->if->if->Double->Double->doubleToLongBits->longBitsToDouble->return
ThreadLocalRandom#nextInt():::Returns a pseudorandom int value.:::return->nextSeed->mix32
ThreadLocalRandom#nextInt(int):::Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->r->nextSeed->mix32->m->if->else->for->u->nextSeed->mix32->return
ThreadLocalRandom#nextInt(int, int):::Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextInt
ThreadLocalRandom#nextLong():::Returns a pseudorandom long value.:::return->nextSeed->mix64
ThreadLocalRandom#nextLong(long):::Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->r->nextSeed->mix64->m->if->else->for->u->nextSeed->mix64->return
ThreadLocalRandom#nextLong(long, long):::Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextLong
ThreadLocalRandom#nextDouble():::Returns a pseudorandom double value between zero (inclusive) and one (exclusive).:::return->nextSeed->mix64
ThreadLocalRandom#nextDouble(double):::Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).:::if->throw->new->IllegalArgumentException->result->nextSeed->mix64->return->Double->Double->doubleToLongBits->longBitsToDouble
ThreadLocalRandom#nextDouble(double, double):::Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->internalNextDouble
ThreadLocalRandom#nextBoolean():::Returns a pseudorandom boolean value.:::return->nextSeed->mix32
ThreadLocalRandom#nextFloat():::Returns a pseudorandom float value between zero (inclusive) and one (exclusive).:::return->nextSeed->mix32
ThreadLocalRandom#ints(long):::Returns a stream producing the given streamSize number of pseudorandom int values.:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints():::Returns an effectively unlimited stream of pseudorandom int values.:::return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints(long, int, int):::Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#ints(int, int):::Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomIntsSpliterator->intStream
ThreadLocalRandom#longs(long):::Returns a stream producing the given streamSize number of pseudorandom long values.:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs():::Returns an effectively unlimited stream of pseudorandom long values.:::return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs(long, long, long):::Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#longs(long, long):::Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomLongsSpliterator->longStream
ThreadLocalRandom#doubles(long):::Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles():::Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles(long, double, double):::Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#doubles(double, double):::Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::if->throw->new->IllegalArgumentException->return->StreamSupport->new->RandomDoublesSpliterator->doubleStream
ThreadLocalRandom#getProbe():::Returns the probe value for the current thread without forcing initialization:::return->U->Thread->currentThread->getInt
ThreadLocalRandom#advanceProbe(int):::Pseudo-randomly advances and records the given probe value for the given thread.:::U->Thread->currentThread->putInt->return
ThreadLocalRandom#nextSecondarySeed():::Returns the pseudo-randomly initialized or updated secondary seed.:::r->t->Thread->currentThread->if->U->getInt->else->if->seeder->getAndAdd->mix32->U->putInt->return
ThreadLocalRandom#eraseThreadLocals(Thread):::Erases ThreadLocals by nulling out Thread maps.:::U->putObject->U->putObject
ThreadPoolExecutor#tryTerminate():::Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty):::for
ThreadPoolExecutor#reject(Runnable):::Invokes the rejected execution handler for the given command:::handler->rejectedExecution
ThreadPoolExecutor#onShutdown():::Performs any further cleanup following run state transition on invocation of shutdown:::
ThreadPoolExecutor#runWorker(Worker):::Main worker run loop:::wt->Thread->currentThread->task->w->unlock->completedAbruptly->try->while->getTask->w->lock->if->ctl->get->runStateAtLeast->Thread->interrupted->ctl->get->runStateAtLeast->wt->isInterrupted->wt->interrupt->try->beforeExecute->try->task->run->afterExecute->catch->afterExecute->throw->finally->catch->finally->w->unlock->catch->finally->processWorkerExit
ThreadPoolExecutor#execute(Runnable):::Executes the given task sometime in the future:::if->throw->new->NullPointerException->c->ctl->get->if->workerCountOf->if->addWorker->return->ctl->get->if->isRunning->workQueue->offer->recheck->ctl->get->if->isRunning->remove->reject->else->if->workerCountOf->addWorker->else->if->addWorker->reject
ThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::mainLock->mainLock->lock->try->checkShutdownAccess->advanceRunState->interruptIdleWorkers->onShutdown->catch->finally->mainLock->unlock->tryTerminate
ThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::tasks->mainLock->mainLock->lock->try->checkShutdownAccess->advanceRunState->interruptWorkers->drainQueue->catch->finally->mainLock->unlock->tryTerminate->return
ThreadPoolExecutor#isStopped():::Used by ScheduledThreadPoolExecutor.:::return->ctl->get->runStateAtLeast
ThreadPoolExecutor#isTerminating():::Returns true if this executor is in the process of terminating after #shutdown or #shutdownNow but has not completely terminated:::c->ctl->get->return->runStateAtLeast->runStateLessThan
ThreadPoolExecutor#setThreadFactory(ThreadFactory):::Sets the thread factory used to create new threads.:::if->throw->new->NullPointerException
ThreadPoolExecutor#getThreadFactory():::Returns the thread factory used to create new threads.:::return
ThreadPoolExecutor#setRejectedExecutionHandler(RejectedExecutionHandler):::Sets a new handler for unexecutable tasks.:::if->throw->new->NullPointerException
ThreadPoolExecutor#getRejectedExecutionHandler():::Returns the current handler for unexecutable tasks.:::return
ThreadPoolExecutor#setCorePoolSize(int):::Sets the core number of threads:::if->throw->new->IllegalArgumentException->delta->if->ctl->get->workerCountOf->interruptIdleWorkers->else->if->k->Math->workQueue->size->min->while->addWorker->if->workQueue->isEmpty->break
ThreadPoolExecutor#getCorePoolSize():::Returns the core number of threads.:::return
ThreadPoolExecutor#prestartCoreThread():::Starts a core thread, causing it to idly wait for work:::return->ctl->get->workerCountOf->addWorker
ThreadPoolExecutor#ensurePrestart():::Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.:::wc->ctl->get->workerCountOf->if->addWorker->else->if->addWorker
ThreadPoolExecutor#prestartAllCoreThreads():::Starts all core threads, causing them to idly wait for work:::n->while->addWorker->return
ThreadPoolExecutor#allowsCoreThreadTimeOut():::Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive:::return
ThreadPoolExecutor#allowCoreThreadTimeOut(boolean):::Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive:::if->throw->new->IllegalArgumentException->if->if->interruptIdleWorkers
ThreadPoolExecutor#setMaximumPoolSize(int):::Sets the maximum allowed number of threads:::if->throw->new->IllegalArgumentException->if->ctl->get->workerCountOf->interruptIdleWorkers
ThreadPoolExecutor#getMaximumPoolSize():::Returns the maximum allowed number of threads.:::return
ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit):::Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::if->throw->new->IllegalArgumentException->if->allowsCoreThreadTimeOut->throw->new->IllegalArgumentException->keepAliveTime->unit->toNanos->delta->if->interruptIdleWorkers
ThreadPoolExecutor#getKeepAliveTime(TimeUnit):::Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::return->unit->convert
ThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::return
ThreadPoolExecutor#remove(Runnable):::Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started:::removed->workQueue->remove->tryTerminate->return
ThreadPoolExecutor#purge():::Tries to remove from the work queue all Future tasks that have been cancelled:::q->try->it->q->iterator->while->it->hasNext->r->it->next->if->isCancelled->it->remove->catch->foreach->q->toArray->if->isCancelled->q->remove->finally->tryTerminate
ThreadPoolExecutor#getPoolSize():::Returns the current number of threads in the pool.:::mainLock->mainLock->lock->try->return->ctl->get->runStateAtLeast->workers->size->catch->finally->mainLock->unlock
ThreadPoolExecutor#getActiveCount():::Returns the approximate number of threads that are actively executing tasks.:::mainLock->mainLock->lock->try->n->foreach->if->w->isLocked->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#getLargestPoolSize():::Returns the largest number of threads that have ever simultaneously been in the pool.:::mainLock->mainLock->lock->try->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#getTaskCount():::Returns the approximate total number of tasks that have ever been scheduled for execution:::mainLock->mainLock->lock->try->n->foreach->if->w->isLocked->return->workQueue->size->catch->finally->mainLock->unlock
ThreadPoolExecutor#getCompletedTaskCount():::Returns the approximate total number of tasks that have completed execution:::mainLock->mainLock->lock->try->n->foreach->return->catch->finally->mainLock->unlock
ThreadPoolExecutor#toString():::Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.:::ncompleted->nworkers->nactive->mainLock->mainLock->lock->try->workers->size->foreach->if->w->isLocked->catch->finally->mainLock->unlock->c->ctl->get->runState->isRunning->runStateAtLeast->return->super->toString->workQueue->size
ThreadPoolExecutor#beforeExecute(Thread, Runnable):::Method invoked prior to executing the given Runnable in the given thread:::
ThreadPoolExecutor#afterExecute(Runnable, Throwable):::Method invoked upon completion of execution of the given Runnable:::
ThreadPoolExecutor#terminated():::Method invoked when the Executor has terminated:::
ThreadPoolExecutor.CallerRunsPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.:::if->e->isShutdown->r->run
ThreadPoolExecutor.AbortPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Always throws RejectedExecutionException.:::throw->r->toString->e->toString->new->RejectedExecutionException
ThreadPoolExecutor.DiscardPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Does nothing, which has the effect of discarding task r.:::
ThreadPoolExecutor.DiscardOldestPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.:::if->e->isShutdown->e->getQueue->poll->e->execute
TransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::
TransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::
TransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::
TransferQueue#hasWaitingConsumer():::Returns true if there is at least one consumer waiting to receive an element via #take or timed #poll(long,TimeUnit) poll:::
TransferQueue#getWaitingConsumerCount():::Returns an estimate of the number of consumers waiting to receive elements via #take or timed #poll(long,TimeUnit) poll:::
