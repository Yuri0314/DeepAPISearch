AbstractExecutorService#newTaskFor(Runnable, T):::Returns a RunnableFuture for the given runnable and default value.:::
AbstractExecutorService#newTaskFor(Callable):::Returns a RunnableFuture for the given callable task.:::
ArrayBlockingQueue#inc(int, int):::Increments i, mod modulus:::
ArrayBlockingQueue#dec(int, int):::Decrements i, mod modulus:::
ArrayBlockingQueue#itemAt(int):::Returns item at index i.:::
ArrayBlockingQueue#itemAt(Object[], int):::Returns element at array index i:::
ArrayBlockingQueue#removeAt(int):::Deletes item at array index removeIndex:::itrs.removedAt->itrs.elementDequeued->notFull.signal
ArrayBlockingQueue#add(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.:::super.add
ArrayBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::Objects.requireNonNull->lock.lock->lock.unlock->this.enqueue
ArrayBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.:::Objects.requireNonNull->lock.lockInterruptibly->lock.unlock->notFull.await->this.enqueue
ArrayBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.:::Objects.requireNonNull->unit.toNanos->lock.lockInterruptibly->lock.unlock->notFull.awaitNanos->this.enqueue
ArrayBlockingQueue#size():::Returns the number of elements in this queue.:::lock.lock->lock.unlock
ArrayBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::lock.lock->lock.unlock
ArrayBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::lock.lock->lock.unlock->o.equals->this.removeAt
ArrayBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::lock.lock->lock.unlock->o.equals
ArrayBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::lock.lock->lock.unlock->Arrays.copyOfRange->System.arraycopy
ArrayBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::lock.lock->lock.unlock->Math.min->System.arraycopy->a.getClass->Arrays.copyOfRange->System.arraycopy
ArrayBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock.lock->lock.unlock->this.circularClear->itrs.queueIsEmpty->notFull.signal->lock.hasWaiters
ArrayBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::
ArrayBlockingQueue.Itrs#doSomeSweeping(boolean):::Sweeps itrs, looking for and expunging stale iterators:::p.get->it.isDetached->p.clear
ArrayBlockingQueue.Itrs#register(Itr):::Adds a new iterator to the linked list of tracked iterators.:::
ArrayBlockingQueue.Itrs#takeIndexWrapped():::Called whenever takeIndex wraps around to 0:::p.get->it.takeIndexWrapped->p.clear
ArrayBlockingQueue.Itrs#removedAt(int):::Called whenever an interior remove (not at takeIndex) occurred:::p.get->it.removedAt->p.clear
ArrayBlockingQueue.Itrs#queueIsEmpty():::Called whenever the queue becomes empty:::p.get->p.clear->it.shutdown
ArrayBlockingQueue.Itrs#elementDequeued():::Called whenever an element has been dequeued (at takeIndex).:::this.takeIndexWrapped->this.queueIsEmpty
ArrayBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::Spliterators.spliterator
ArrayBlockingQueue#checkInvariants():::debugging:::this.invariantsSatisfied->Arrays.toString->String.format->System.err.println
BlockingDeque#addFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#addLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offerFirst(E):::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#offerLast(E):::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#putFirst(E):::Inserts the specified element at the front of this deque, waiting if necessary for space to become available.:::
BlockingDeque#putLast(E):::Inserts the specified element at the end of this deque, waiting if necessary for space to become available.:::
BlockingDeque#offerFirst(E, long, TimeUnit):::Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#offerLast(E, long, TimeUnit):::Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.:::
BlockingDeque#takeFirst():::Retrieves and removes the first element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#takeLast():::Retrieves and removes the last element of this deque, waiting if necessary until an element becomes available.:::
BlockingDeque#pollFirst(long, TimeUnit):::Retrieves and removes the first element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#pollLast(long, TimeUnit):::Retrieves and removes the last element of this deque, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::
BlockingDeque#add(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingDeque#offer(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingDeque#put(E):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available:::
BlockingDeque#offer(E, long, TimeUnit):::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available:::
BlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#poll():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#take():::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting if necessary until an element becomes available:::
BlockingDeque#poll(long, TimeUnit):::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting up to the specified wait time if necessary for an element to become available:::
BlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque):::
BlockingDeque#peek():::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty:::
BlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::
BlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::
BlockingDeque#size():::Returns the number of elements in this deque.:::
BlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::
BlockingDeque#push(E):::Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available:::
BlockingQueue#add(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available:::
BlockingQueue#offer(E):::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available:::
BlockingQueue#put(E):::Inserts the specified element into this queue, waiting if necessary for space to become available.:::
BlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.:::
BlockingQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.:::
BlockingQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.:::
BlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit:::
BlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::
BlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::
BlockingQueue#drainTo(Collection):::Removes all available elements from this queue and adds them to the given collection:::
BlockingQueue#drainTo(Collection, int):::Removes at most the given number of available elements from this queue and adds them to the given collection:::
Callable#call():::Computes a result, or throws an exception if unable to do so.:::
CompletableFuture#tryPushStack(Completion):::Returns true if successfully pushed c onto stack.:::NEXT.set->STACK.compareAndSet
CompletableFuture#pushStack(Completion):::Unconditionally pushes c onto stack, retrying if necessary.:::this.tryPushStack
CompletableFuture#completeNull():::Completes with the null value, unless already completed.:::RESULT.compareAndSet
CompletableFuture#encodeValue(T):::Returns the encoding of the given non-exceptional value.:::
CompletableFuture#completeValue(T):::Completes with a non-exceptional result, unless already completed.:::RESULT.compareAndSet
CompletableFuture#encodeThrowable(Throwable):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already.:::
CompletableFuture#completeThrowable(Throwable):::Completes with an exceptional result, unless already completed.:::this.encodeThrowable->RESULT.compareAndSet
CompletableFuture#encodeThrowable(Throwable, Object):::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already:::
CompletableFuture#completeThrowable(Throwable, Object):::Completes with the given (non-null) exceptional result as a wrapped CompletionException unless it is one already, unless already completed:::this.encodeThrowable->RESULT.compareAndSet
CompletableFuture#encodeOutcome(T, Throwable):::Returns the encoding of the given arguments: if the exception is non-null, encodes as AltResult:::this.encodeThrowable
CompletableFuture#encodeRelay(Object):::Returns the encoding of a copied outcome; if exceptional, rewraps as a CompletionException, else returns argument.:::
CompletableFuture#completeRelay(Object):::Completes with r or a copy of r, unless already completed:::this.encodeRelay->RESULT.compareAndSet
CompletableFuture#screenExecutor(Executor):::Null-checks user executor argument, and translates uses of commonPool to ASYNC_POOL in case parallelism disabled.:::ForkJoinPool.commonPool
CompletableFuture.Completion#tryFire(int):::Performs completion action if triggered, returning a dependent that may need propagation, if one exists.:::
CompletableFuture.Completion#isLive():::Returns true if possibly still triggerable:::
CompletableFuture#postComplete():::Pops and tries to trigger all reachable dependents:::STACK.compareAndSet->this.pushStack->NEXT.compareAndSet->h.tryFire
CompletableFuture#cleanStack():::Traverses stack and unlinks one or more dead Completions, if found.:::p.isLive->STACK.weakCompareAndSet->q.isLive->NEXT.weakCompareAndSet
CompletableFuture.UniCompletion#claim():::Returns true if action can be run:::this.compareAndSetForkJoinTaskTag->e.execute
CompletableFuture#unipush(Completion):::Pushes the given completion unless it completes while trying:::NEXT.set->this.tryPushStack->c.tryFire
CompletableFuture#postFire(CompletableFuture, int):::Post-processing by dependent after successful UniCompletion tryFire:::a.cleanStack->a.postComplete->this.postComplete
CompletableFuture#bipush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless both done:::this.tryPushStack->c.tryFire->b.unipush->b.unipush
CompletableFuture#postFire(CompletableFuture, CompletableFuture, int):::Post-processing after successful BiCompletion tryFire.:::b.cleanStack->b.postComplete->this.postFire
CompletableFuture#andTree(CompletableFuture[], int, int):::Recursively constructs a tree of completions.:::this.andTree->this.andTree->this.encodeThrowable->a.bipush
CompletableFuture#orpush(CompletableFuture, BiCompletion):::Pushes completion to this and b unless either done:::NEXT.set->this.tryPushStack->b.unipush->c.tryFire
CompletableFuture#supplyAsync(Supplier):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() with the value obtained by calling the given Supplier.:::this.asyncSupplyStage
CompletableFuture#supplyAsync(Supplier, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.:::this.screenExecutor->this.asyncSupplyStage
CompletableFuture#runAsync(Runnable):::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() after it runs the given action.:::this.asyncRunStage
CompletableFuture#runAsync(Runnable, Executor):::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor after it runs the given action.:::this.screenExecutor->this.asyncRunStage
CompletableFuture#completedFuture(U):::Returns a new CompletableFuture that is already completed with the given value.:::
CompletableFuture#isDone():::Returns true if completed in any fashion: normally, exceptionally, or via cancellation.:::
CompletableFuture#get():::Waits if necessary for this future to complete, and then returns its result.:::this.waitingGet->this.reportGet
CompletableFuture#get(long, TimeUnit):::Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.:::unit.toNanos->this.timedGet->this.reportGet
CompletableFuture#join():::Returns the result value when complete, or throws an (unchecked) exception if completed exceptionally:::this.waitingGet->this.reportJoin
CompletableFuture#getNow(T):::Returns the result value (or throws any encountered exception) if completed, else returns the given valueIfAbsent.:::this.reportJoin
CompletableFuture#complete(T):::If not already completed, sets the value returned by #get() and related methods to the given value.:::this.completeValue->this.postComplete
CompletableFuture#completeExceptionally(Throwable):::If not already completed, causes invocations of #get() and related methods to throw the given exception.:::this.internalComplete->this.postComplete
CompletableFuture#toCompletableFuture():::Returns this CompletableFuture.:::
CompletableFuture#exceptionally(Function):::Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value:::this.uniExceptionallyStage
CompletableFuture#allOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete:::this.andTree
CompletableFuture#anyOf(CompletableFuture...):::Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result:::this.uniCopyStage->this.encodeRelay->cfs.clone->cf.unipush->cfs[i].cleanStack
CompletableFuture#cancel(boolean):::If not already completed, completes this CompletableFuture with a CancellationException:::this.internalComplete->this.postComplete->this.isCancelled
CompletableFuture#isCancelled():::Returns true if this CompletableFuture was cancelled before it completed normally.:::
CompletableFuture#isCompletedExceptionally():::Returns true if this CompletableFuture completed exceptionally, in any way:::
CompletableFuture#obtrudeValue(T):::Forcibly sets or resets the value subsequently returned by method #get() and related methods, whether or not already completed:::this.postComplete
CompletableFuture#obtrudeException(Throwable):::Forcibly causes subsequent invocations of method #get() and related methods to throw the given exception, whether or not already completed:::this.postComplete
CompletableFuture#getNumberOfDependents():::Returns the estimated number of CompletableFutures whose completions are awaiting completion of this CompletableFuture:::
CompletableFuture#toString():::Returns a string identifying this CompletableFuture, as well as its completion state:::super.toString
CompletableFuture#newIncompleteFuture():::Returns a new incomplete CompletableFuture of the type to be returned by a CompletionStage method:::
CompletableFuture#defaultExecutor():::Returns the default Executor used for async methods that do not specify an Executor:::
CompletableFuture#copy():::Returns a new CompletableFuture that is completed normally with the same value as this CompletableFuture when it completes normally:::this.uniCopyStage
CompletableFuture#minimalCompletionStage():::Returns a new CompletionStage that is completed normally with the same value as this CompletableFuture when it completes normally, and cannot be independently completed or otherwise used in ways not defined by the methods of interface CompletionStage:::this.uniAsMinimalStage
CompletableFuture#completeAsync(Supplier, Executor):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the given executor.:::executor.execute
CompletableFuture#completeAsync(Supplier):::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the default executor.:::this.defaultExecutor->this.completeAsync
CompletableFuture#orTimeout(long, TimeUnit):::Exceptionally completes this CompletableFuture with a TimeoutException if not otherwise completed before the given timeout.:::this.whenComplete
CompletableFuture#completeOnTimeout(T, long, TimeUnit):::Completes this CompletableFuture with the given value if not otherwise completed before the given timeout.:::this.whenComplete
CompletableFuture#delayedExecutor(long, TimeUnit, Executor):::Returns a new Executor that submits a task to the given base executor after the given delay (or no delay if non-positive):::
CompletableFuture#delayedExecutor(long, TimeUnit):::Returns a new Executor that submits a task to the default executor after the given delay (or no delay if non-positive):::
CompletableFuture#completedStage(U):::Returns a new CompletionStage that is already completed with the given value and supports only those methods in interface CompletionStage.:::
CompletableFuture#failedFuture(Throwable):::Returns a new CompletableFuture that is already completed exceptionally with the given exception.:::
CompletableFuture#failedStage(Throwable):::Returns a new CompletionStage that is already completed exceptionally with the given exception and supports only those methods in interface CompletionStage.:::
CompletionService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
CompletionService#submit(Runnable, V):::Submits a Runnable task for execution and returns a Future representing that task:::
CompletionService#take():::Retrieves and removes the Future representing the next completed task, waiting if none are yet present.:::
CompletionService#poll():::Retrieves and removes the Future representing the next completed task, or null if none are present.:::
CompletionService#poll(long, TimeUnit):::Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.:::
CompletionStage#thenApply(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied function:::
CompletionStage#thenApplyAsync(Function, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function:::
CompletionStage#thenAccept(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer):::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied action:::
CompletionStage#thenAcceptAsync(Consumer, Executor):::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied action:::
CompletionStage#thenRun(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action:::
CompletionStage#thenRunAsync(Runnable):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#thenRunAsync(Runnable, Executor):::Returns a new CompletionStage that, when this stage completes normally, executes the given action using the supplied Executor:::
CompletionStage#thenCombine(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied function:::
CompletionStage#thenCombineAsync(CompletionStage, BiFunction, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function:::
CompletionStage#thenAcceptBoth(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied action:::
CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied action:::
CompletionStage#runAfterBoth(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterBothAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using the supplied executor:::
CompletionStage#applyToEither(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied function:::
CompletionStage#applyToEitherAsync(CompletionStage, Function, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function:::
CompletionStage#acceptEither(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied action:::
CompletionStage#acceptEitherAsync(CompletionStage, Consumer, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied action:::
CompletionStage#runAfterEither(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility:::
CompletionStage#runAfterEitherAsync(CompletionStage, Runnable, Executor):::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using the supplied executor:::
CompletionStage#thenCompose(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function:::
CompletionStage#thenComposeAsync(Function>):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using this stage's default asynchronous execution facility:::
CompletionStage#thenComposeAsync(Function>, Executor):::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using the supplied Executor:::
CompletionStage#handle(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using this stage's default asynchronous execution facility, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#handleAsync(BiFunction, Executor):::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using the supplied executor, with this stage's result and exception as arguments to the supplied function:::
CompletionStage#whenComplete(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using this stage's default asynchronous execution facility when this stage completes:::
CompletionStage#whenCompleteAsync(BiConsumer, Executor):::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using the supplied Executor when this stage completes:::
CompletionStage#exceptionally(Function):::Returns a new CompletionStage that, when this stage completes exceptionally, is executed with this stage's exception as the argument to the supplied function:::
CompletionStage#toCompletableFuture():::Returns a CompletableFuture maintaining the same completion properties as this stage:::
ConcurrentHashMap.Node#find(int, Object):::Virtualized support for map.get(); overridden in subclasses.:::k.equals
ConcurrentHashMap#spread(int):::Spreads (XORs) higher bits of hash to lower and also forces top bit to 0:::
ConcurrentHashMap#comparableClassFor(Object):::Returns x's Class if it is of the form "class C implements Comparable<C>", else null.:::x.getClass->c.getGenericInterfaces->(p = (ParameterizedType) t).getRawType->p.getActualTypeArguments
ConcurrentHashMap#compareComparables(Class, Object, Object):::Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.:::x.getClass->((Comparable) k).compareTo
ConcurrentHashMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::key.hashCode->this.spread->this.tabAt->e.find->key.equals->key.equals
ConcurrentHashMap#containsKey(Object):::Tests if the specified object is a key in this table.:::this.get
ConcurrentHashMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::value.equals->it.advance
ConcurrentHashMap#put(K, V):::Maps the specified key to the specified value in this table:::this.putVal
ConcurrentHashMap#putVal(K, V, boolean):::Implementation for put and putIfAbsent:::key.hashCode->this.spread->this.tabAt->key.equals->this.tabAt->((TreeBin<K, V>) f).putTreeVal->key.equals->this.treeifyBin->this.helpTransfer->this.casTabAt->this.initTable->this.addCount
ConcurrentHashMap#putAll(Map):::Copies all of the mappings from the specified map to this one:::m.size->this.tryPresize->e.getKey->e.getValue->this.putVal->m.entrySet
ConcurrentHashMap#remove(Object):::Removes the key (and its corresponding value) from this map:::this.replaceNode
ConcurrentHashMap#replaceNode(Object, V, Object):::Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null:::key.hashCode->this.spread->this.tabAt->this.tabAt->r.findTreeNode->cv.equals->t.removeTreeNode->this.untreeify->this.setTabAt->key.equals->cv.equals->this.setTabAt->this.addCount->this.helpTransfer
ConcurrentHashMap#clear():::Removes all of the mappings from this map.:::this.tabAt->this.tabAt->this.setTabAt->this.helpTransfer->this.addCount
ConcurrentHashMap#keySet():::Returns a Set view of the keys contained in this map:::
ConcurrentHashMap#values():::Returns a Collection view of the values contained in this map:::
ConcurrentHashMap#entrySet():::Returns a Set view of the mappings contained in this map:::
ConcurrentHashMap#hashCode():::Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().:::p.key.hashCode->p.val.hashCode->it.advance
ConcurrentHashMap#toString():::Returns a string representation of this map:::sb.append->it.advance->sb.append->sb.append->sb.append->it.advance->sb.append(',').append->sb.append('}').toString
ConcurrentHashMap#equals(Object):::Compares the specified object with this map for equality:::m.get->v.equals->it.advance->e.getKey->e.getValue->this.get->mv.equals->m.entrySet
ConcurrentHashMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.:::this.get
ConcurrentHashMap#removeEntryIf(Predicate>):::Helper method for EntrySetView.removeIf.:::function.test->this.replaceNode->it.advance
ConcurrentHashMap#removeValueIf(Predicate):::Helper method for ValuesView.removeIf.:::function.test->this.replaceNode->it.advance
ConcurrentHashMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::key.hashCode->this.spread->this.tabAt->key.equals->this.tabAt->r.findTreeNode->mappingFunction.apply->t.putTreeVal->key.equals->mappingFunction.apply->this.treeifyBin->this.helpTransfer->this.casTabAt->this.setTabAt->mappingFunction.apply->this.initTable->this.addCount
ConcurrentHashMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::key.hashCode->this.spread->this.tabAt->this.tabAt->r.findTreeNode->remappingFunction.apply->t.removeTreeNode->this.untreeify->this.setTabAt->key.equals->remappingFunction.apply->this.setTabAt->this.helpTransfer->this.initTable->this.addCount
ConcurrentHashMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::key.hashCode->this.spread->this.tabAt->this.tabAt->r.findTreeNode->remappingFunction.apply->t.removeTreeNode->this.untreeify->this.setTabAt->t.putTreeVal->key.equals->remappingFunction.apply->this.setTabAt->remappingFunction.apply->this.treeifyBin->this.helpTransfer->this.casTabAt->this.setTabAt->remappingFunction.apply->this.initTable->this.addCount
ConcurrentHashMap#merge(K, V, BiFunction):::If the specified key is not already associated with a (non-null) value, associates it with the given value:::key.hashCode->this.spread->this.tabAt->this.tabAt->r.findTreeNode->remappingFunction.apply->t.removeTreeNode->this.untreeify->this.setTabAt->t.putTreeVal->key.equals->remappingFunction.apply->this.setTabAt->this.treeifyBin->this.helpTransfer->this.casTabAt->this.initTable->this.addCount
ConcurrentHashMap#contains(Object):::Tests if some key maps into the specified value in this table:::this.containsValue
ConcurrentHashMap#keys():::Returns an enumeration of the keys in this table.:::
ConcurrentHashMap#elements():::Returns an enumeration of the values in this table.:::
ConcurrentHashMap#mappingCount():::Returns the number of mappings:::this.sumCount
ConcurrentHashMap#newKeySet():::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::
ConcurrentHashMap#newKeySet(int):::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.:::
ConcurrentHashMap#keySet(V):::Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., Collection#add and Collection#addAll(Collection)):::
ConcurrentHashMap#resizeStamp(int):::Returns the stamp bits for resizing a table of size n:::Integer.numberOfLeadingZeros
ConcurrentHashMap#helpTransfer(Node[], Node):::Helps transfer if a resize is in progress.:::this.resizeStamp->U.compareAndSetInt->this.transfer
ConcurrentHashMap#untreeify(Node):::Returns a list of non-TreeNodes replacing those in given list.:::
ConcurrentHashMap.TreeNode#findTreeNode(int, Object, Class):::Returns the TreeNode (or null if not found) for the given key starting at given root.:::k.equals->this.comparableClassFor->this.compareComparables->pr.findTreeNode
ConcurrentHashMap.TreeBin#tieBreakOrder(Object, Object):::Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable:::b.getClass().getName->a.getClass().getName().compareTo->System.identityHashCode->System.identityHashCode
ConcurrentHashMap.TreeBin#find(int, Object):::Returns matching node or null if none:::U.compareAndSetInt->U.getAndAddInt->LockSupport.unpark->r.findTreeNode->k.equals
ConcurrentHashMap.TreeBin#putTreeVal(int, K, V):::Finds or adds a node.:::k.equals->this.comparableClassFor->this.compareComparables->ch.findTreeNode->ch.findTreeNode->this.tieBreakOrder->this.lockRoot->this.unlockRoot->this.balanceInsertion->this.checkInvariants
ConcurrentHashMap.TreeBin#removeTreeNode(TreeNode):::Removes the given node, that must be present before this call:::this.lockRoot->this.unlockRoot->this.balanceDeletion->this.checkInvariants
ConcurrentHashMap.TreeBin#checkInvariants(TreeNode):::Checks invariants recursively for the tree of Nodes rooted at t.:::this.checkInvariants->this.checkInvariants
ConcurrentHashMap.Traverser#advance():::Advances if possible, returning next valid node, or null if none.:::this.tabAt->this.pushState->this.recoverState
ConcurrentHashMap.MapEntry#setValue(V):::Sets our entry's value and writes through to the map:::map.put
ConcurrentHashMap#batchFor(long):::Computes initial batch value for bulk tasks:::this.sumCount->ForkJoinPool.getCommonPoolParallelism
ConcurrentHashMap#forEach(long, BiConsumer):::Performs the given action for each (key, value).:::new ForEachMappingTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, action).invoke
ConcurrentHashMap#forEach(long, BiFunction, Consumer):::Performs the given action for each non-null transformation of each (key, value).:::new ForEachTransformedMappingTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, transformer, action).invoke
ConcurrentHashMap#search(long, BiFunction):::Returns a non-null result from applying the given search function on each (key, value), or null if none:::new SearchMappingsTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, searchFunction, new AtomicReference<U>()).invoke
ConcurrentHashMap#reduce(long, BiFunction, BiFunction):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.:::new MapReduceMappingsTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke
ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceMappingsToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceToLong(long, ToLongBiFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceMappingsToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceToInt(long, ToIntBiFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceMappingsToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#forEachKey(long, Consumer):::Performs the given action for each key.:::new ForEachKeyTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, action).invoke
ConcurrentHashMap#forEachKey(long, Function, Consumer):::Performs the given action for each non-null transformation of each key.:::new ForEachTransformedKeyTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, transformer, action).invoke
ConcurrentHashMap#searchKeys(long, Function):::Returns a non-null result from applying the given search function on each key, or null if none:::new SearchKeysTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, searchFunction, new AtomicReference<U>()).invoke
ConcurrentHashMap#reduceKeys(long, BiFunction):::Returns the result of accumulating all keys using the given reducer to combine values, or null if none.:::new ReduceKeysTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, reducer).invoke
ConcurrentHashMap#reduceKeys(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.:::new MapReduceKeysTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke
ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceKeysToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceKeysToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceKeysToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#forEachValue(long, Consumer):::Performs the given action for each value.:::new ForEachValueTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, action).invoke
ConcurrentHashMap#forEachValue(long, Function, Consumer):::Performs the given action for each non-null transformation of each value.:::new ForEachTransformedValueTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, transformer, action).invoke
ConcurrentHashMap#searchValues(long, Function):::Returns a non-null result from applying the given search function on each value, or null if none:::new SearchValuesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, searchFunction, new AtomicReference<U>()).invoke
ConcurrentHashMap#reduceValues(long, BiFunction):::Returns the result of accumulating all values using the given reducer to combine values, or null if none.:::new ReduceValuesTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, reducer).invoke
ConcurrentHashMap#reduceValues(long, Function, BiFunction):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.:::new MapReduceValuesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke
ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceValuesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceValuesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceValuesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#forEachEntry(long, Consumer>):::Performs the given action for each entry.:::new ForEachEntryTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, action).invoke
ConcurrentHashMap#forEachEntry(long, Function, ? extends U>, Consumer):::Performs the given action for each non-null transformation of each entry.:::new ForEachTransformedEntryTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, transformer, action).invoke
ConcurrentHashMap#searchEntries(long, Function, ? extends U>):::Returns a non-null result from applying the given search function on each entry, or null if none:::new SearchEntriesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, searchFunction, new AtomicReference<U>()).invoke
ConcurrentHashMap#reduceEntries(long, BiFunction, Map.Entry, ? extends Map.Entry>):::Returns the result of accumulating all entries using the given reducer to combine values, or null if none.:::new ReduceEntriesTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, reducer).invoke
ConcurrentHashMap#reduceEntries(long, Function, ? extends U>, BiFunction):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.:::new MapReduceEntriesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke
ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction>, double, DoubleBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceEntriesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction>, long, LongBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceEntriesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction>, int, IntBinaryOperator):::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.:::new MapReduceEntriesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke
ConcurrentHashMap.CollectionView#getMap():::Returns the map backing this view.:::
ConcurrentHashMap.CollectionView#clear():::Removes all of the elements from this view, by removing all the mappings from the map backing this view.:::map.clear
ConcurrentHashMap.CollectionView#iterator():::Returns an iterator over the elements in this collection:::
ConcurrentHashMap.CollectionView#toString():::Returns a string representation of this collection:::sb.append->this.iterator->it.hasNext->it.next->sb.append->it.hasNext->sb.append(',').append->sb.append(']').toString
ConcurrentHashMap.KeySetView#getMappedValue():::Returns the default mapped value for additions, or null if additions are not supported.:::
ConcurrentHashMap.KeySetView#remove(Object):::Removes the key from this map view, by removing the key (and its corresponding value) from the backing map:::map.remove
ConcurrentHashMap.KeySetView#add(K):::Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.:::map.putVal
ConcurrentHashMap.KeySetView#addAll(Collection):::Adds all of the elements in the specified collection to this set, as if by calling #add on each one.:::map.putVal
ConcurrentHashMap.BulkTask#advance():::Same as Traverser version.:::this.tabAt->this.pushState->this.recoverState
ConcurrentLinkedDeque#newNode(E):::Returns a new node holding item:::ITEM.set
ConcurrentLinkedDeque#unlink(Node):::Unlinks non-null node x.:::this.skipDeletedSuccessors->this.skipDeletedPredecessors->this.updateHead->this.updateTail->PREV.setRelease->NEXT.setRelease->this.unlinkLast->this.unlinkFirst
ConcurrentLinkedDeque#succ(Node):::Returns the successor of p, or the first node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::this.first
ConcurrentLinkedDeque#pred(Node):::Returns the predecessor of p, or the last node if p.prev has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::this.last
ConcurrentLinkedDeque#first():::Returns the first node, the unique node p for which:     p.prev == null && p.next != p The returned node may or may not be logically deleted:::HEAD.compareAndSet
ConcurrentLinkedDeque#last():::Returns the last node, the unique node p for which:     p.next == null && p.prev != p The returned node may or may not be logically deleted:::TAIL.compareAndSet
ConcurrentLinkedDeque#addFirst(E):::Inserts the specified element at the front of this deque:::this.linkFirst
ConcurrentLinkedDeque#addLast(E):::Inserts the specified element at the end of this deque:::this.linkLast
ConcurrentLinkedDeque#offerFirst(E):::Inserts the specified element at the front of this deque:::this.linkFirst
ConcurrentLinkedDeque#offerLast(E):::Inserts the specified element at the end of this deque:::this.linkLast
ConcurrentLinkedDeque#offer(E):::Inserts the specified element at the tail of this deque:::this.offerLast
ConcurrentLinkedDeque#add(E):::Inserts the specified element at the tail of this deque:::this.offerLast
ConcurrentLinkedDeque#removeFirstOccurrence(Object):::Removes the first occurrence of the specified element from this deque:::Objects.requireNonNull->o.equals->ITEM.compareAndSet->this.unlink->this.first->this.succ
ConcurrentLinkedDeque#removeLastOccurrence(Object):::Removes the last occurrence of the specified element from this deque:::Objects.requireNonNull->o.equals->ITEM.compareAndSet->this.unlink->this.last->this.pred
ConcurrentLinkedDeque#contains(Object):::Returns true if this deque contains the specified element:::o.equals->this.first->this.succ
ConcurrentLinkedDeque#isEmpty():::Returns true if this collection contains no elements.:::this.peekFirst
ConcurrentLinkedDeque#size():::Returns the number of elements in this deque:::this.first
ConcurrentLinkedDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::this.removeFirstOccurrence
ConcurrentLinkedDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::Objects.requireNonNull->this.newNode->NEXT.set->PREV.set->PREV.set->NEXT.compareAndSet->TAIL.weakCompareAndSet->TAIL.weakCompareAndSet
ConcurrentLinkedDeque#clear():::Removes all of the elements from this deque.:::this.pollFirst
ConcurrentLinkedDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::this.toArrayInternal
ConcurrentLinkedDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::this.toArrayInternal
ConcurrentLinkedDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::
ConcurrentLinkedDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::
ConcurrentLinkedDeque#spliterator():::Returns a Spliterator over the elements in this deque:::
ConcurrentLinkedQueue#add(E):::Inserts the specified element at the tail of this queue:::this.offer
ConcurrentLinkedQueue#updateHead(Node, Node):::Tries to CAS head to p:::HEAD.compareAndSet->NEXT.setRelease
ConcurrentLinkedQueue#succ(Node):::Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.:::
ConcurrentLinkedQueue#offer(E):::Inserts the specified element at the tail of this queue:::Objects.requireNonNull->NEXT.compareAndSet->TAIL.weakCompareAndSet
ConcurrentLinkedQueue#first():::Returns the first live (non-deleted) node on list, or null if none:::this.updateHead
ConcurrentLinkedQueue#isEmpty():::Returns true if this queue contains no elements.:::this.first
ConcurrentLinkedQueue#size():::Returns the number of elements in this queue:::this.first
ConcurrentLinkedQueue#contains(Object):::Returns true if this queue contains the specified element:::o.equals->this.skipDeadNodes
ConcurrentLinkedQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::o.equals->p.casItem->this.skipDeadNodes->this.skipDeadNodes
ConcurrentLinkedQueue#addAll(Collection):::Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator:::Objects.requireNonNull->last.appendRelaxed->NEXT.compareAndSet->TAIL.weakCompareAndSet->TAIL.weakCompareAndSet
ConcurrentLinkedQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::this.toArrayInternal
ConcurrentLinkedQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects.requireNonNull->this.toArrayInternal
ConcurrentLinkedQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::
ConcurrentLinkedQueue#spliterator():::Returns a Spliterator over the elements in this queue:::
ConcurrentLinkedQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::action.accept->this.skipDeadNodes
ConcurrentMap#putIfAbsent(K, V):::If the specified key is not already associated with a value, associates it with the given value:::
ConcurrentMap#remove(Object, Object):::Removes the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V, V):::Replaces the entry for a key only if currently mapped to a given value:::
ConcurrentMap#replace(K, V):::Replaces the entry for a key only if currently mapped to some value:::
ConcurrentNavigableMap#descendingMap():::Returns a reverse order view of the mappings contained in this map:::
ConcurrentNavigableMap#navigableKeySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentNavigableMap#descendingKeySet():::Returns a reverse order NavigableSet view of the keys contained in this map:::
ConcurrentSkipListMap#cpr(Comparator, Object, Object):::Compares using comparator or natural ordering if null:::((Comparable) x).compareTo->c.compare
ConcurrentSkipListMap#baseHead():::Returns the header for base node list, or null if uninitialized:::VarHandle.acquireFence
ConcurrentSkipListMap#unlinkNode(Node, Node):::Tries to unlink deleted node n from predecessor b (if both exist), by first splicing in a marker if not already present:::NEXT.compareAndSet->NEXT.compareAndSet
ConcurrentSkipListMap#getAdderCount():::Returns element count, initializing adder if necessary.:::ADDER.compareAndSet->a.sum
ConcurrentSkipListMap#addIndices(Index, int, Index, Comparator):::Add indices after an insertion:::this.cpr->RIGHT.compareAndSet->this.addIndices->RIGHT.compareAndSet
ConcurrentSkipListMap#doRemove(Object, Object):::Main deletion method:::this.cpr->value.equals->VAL.compareAndSet->this.unlinkNode->this.unlinkNode->this.findPredecessor->this.tryReduceLevel->this.addCount
ConcurrentSkipListMap#findFirst():::Gets first valid node, unlinking deleted nodes if encountered.:::this.baseHead->this.unlinkNode
ConcurrentSkipListMap#findFirstEntry():::Entry snapshot version of findFirst:::this.baseHead->this.unlinkNode
ConcurrentSkipListMap#findLast():::Specialized version of find to get last valid node.:::VarHandle.acquireFence->RIGHT.compareAndSet->this.unlinkNode
ConcurrentSkipListMap#findLastEntry():::Entry version of findLast:::this.findLast
ConcurrentSkipListMap#findNear(K, int, Comparator):::Utility for ceiling, floor, lower, higher methods.:::this.findPredecessor->this.cpr->this.unlinkNode
ConcurrentSkipListMap#findNearEntry(K, int, Comparator):::Variant of findNear returning SimpleImmutableEntry:::this.findNear
ConcurrentSkipListMap#clone():::Returns a shallow copy of this ConcurrentSkipListMap instance:::super.clone->clone.buildFromSorted
ConcurrentSkipListMap#containsKey(Object):::Returns true if this map contains a mapping for the specified key.:::this.doGet
ConcurrentSkipListMap#get(Object):::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key:::this.doGet
ConcurrentSkipListMap#getOrDefault(Object, V):::Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.:::this.doGet
ConcurrentSkipListMap#put(K, V):::Associates the specified value with the specified key in this map:::this.doPut
ConcurrentSkipListMap#remove(Object):::Removes the mapping for the specified key from this map if present.:::this.doRemove
ConcurrentSkipListMap#containsValue(Object):::Returns true if this map maps one or more keys to the specified value:::this.baseHead->value.equals
ConcurrentSkipListMap#clear():::Removes all of the mappings from this map.:::VarHandle.acquireFence->VAL.compareAndSet->this.unlinkNode->this.addCount->HEAD.compareAndSet->RIGHT.compareAndSet
ConcurrentSkipListMap#computeIfAbsent(K, Function):::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null:::this.doGet->mappingFunction.apply->this.doPut
ConcurrentSkipListMap#computeIfPresent(K, BiFunction):::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value:::remappingFunction.apply->this.doRemove->VAL.compareAndSet->this.findNode
ConcurrentSkipListMap#compute(K, BiFunction):::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping):::this.findNode->remappingFunction.apply->this.doRemove->VAL.compareAndSet->remappingFunction.apply->this.doPut
ConcurrentSkipListMap#merge(K, V, BiFunction):::If the specified key is not already associated with a value, associates it with the given value:::this.findNode->remappingFunction.apply->this.doRemove->VAL.compareAndSet->this.doPut
ConcurrentSkipListMap#keySet():::Returns a NavigableSet view of the keys contained in this map:::
ConcurrentSkipListMap#values():::Returns a Collection view of the values contained in this map:::
ConcurrentSkipListMap#entrySet():::Returns a Set view of the mappings contained in this map:::
ConcurrentSkipListMap#equals(Object):::Compares the specified object with this map for equality:::m.entrySet().iterator->((SortedMap<?, ?>) m).comparator->it.next->e.getKey->e.getValue->this.get->v.equals->it.hasNext->this.baseHead->m.get->mv.equals->this.baseHead->it.hasNext->it.next->e.getKey->e.getValue->this.cpr->mv.equals->it.hasNext
ConcurrentSkipListMap#lowerEntry(K):::Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key:::this.findNearEntry
ConcurrentSkipListMap#floorEntry(K):::Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key:::this.findNearEntry
ConcurrentSkipListMap#ceilingEntry(K):::Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such entry:::this.findNearEntry
ConcurrentSkipListMap#higherEntry(K):::Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key:::this.findNearEntry
ConcurrentSkipListMap#firstEntry():::Returns a key-value mapping associated with the least key in this map, or null if the map is empty:::this.findFirstEntry
ConcurrentSkipListMap#lastEntry():::Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::this.findLastEntry
ConcurrentSkipListMap#pollFirstEntry():::Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty:::this.doRemoveFirstEntry
ConcurrentSkipListMap#pollLastEntry():::Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty:::this.doRemoveLastEntry
ConcurrentSkipListMap.Iter#advance(Node):::Advances next to higher entry.:::
ConcurrentSkipListMap.SubMap#isBeforeEnd(ConcurrentSkipListMap.Node, Comparator):::Returns true if node key is less than upper bound of range.:::this.cpr
ConcurrentSkipListMap.SubMap#loNode(Comparator):::Returns lowest node:::m.findNear->m.findNear->m.findFirst
ConcurrentSkipListMap.SubMap#hiNode(Comparator):::Returns highest node:::m.findNear->m.findNear->m.findLast
ConcurrentSkipListMap.SubMap#lowestKey():::Returns lowest absolute key (ignoring directionality).:::this.loNode->this.isBeforeEnd
ConcurrentSkipListMap.SubMap#highestKey():::Returns highest absolute key (ignoring directionality).:::this.hiNode->this.inBounds
ConcurrentSkipListMap.SubMap#getNearEntry(K, int):::Submap version of ConcurrentSkipListMap.findNearEntry.:::this.tooLow->this.lowestEntry->this.tooHigh->this.highestEntry->m.findNearEntry->e.getKey->this.inBounds
ConcurrentSkipListMap.SubMap#newSubMap(K, boolean, K, boolean):::Utility to create submaps, where given bounds override unbounded(null) ones and/or are checked against bounded ones.:::this.cpr->this.cpr
ConcurrentSkipListMap#removeEntryIf(Predicate>):::Helper method for EntrySet.removeIf.:::this.baseHead->function.test->this.remove
ConcurrentSkipListMap#removeValueIf(Predicate):::Helper method for Values.removeIf.:::this.baseHead->function.test->this.remove
ConcurrentSkipListSet#clone():::Returns a shallow copy of this ConcurrentSkipListSet instance:::super.clone->clone.setMap
ConcurrentSkipListSet#size():::Returns the number of elements in this set:::m.size
ConcurrentSkipListSet#isEmpty():::Returns true if this set contains no elements.:::m.isEmpty
ConcurrentSkipListSet#contains(Object):::Returns true if this set contains the specified element:::m.containsKey
ConcurrentSkipListSet#add(E):::Adds the specified element to this set if it is not already present:::m.putIfAbsent
ConcurrentSkipListSet#remove(Object):::Removes the specified element from this set if it is present:::m.remove
ConcurrentSkipListSet#clear():::Removes all of the elements from this set.:::m.clear
ConcurrentSkipListSet#iterator():::Returns an iterator over the elements in this set in ascending order.:::m.navigableKeySet().iterator
ConcurrentSkipListSet#descendingIterator():::Returns an iterator over the elements in this set in descending order.:::m.descendingKeySet().iterator
ConcurrentSkipListSet#equals(Object):::Compares the specified object with this set for equality:::this.containsAll->c.containsAll
ConcurrentSkipListSet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::this.remove
ConcurrentSkipListSet#descendingSet():::Returns a reverse order view of the elements contained in this set:::m.descendingMap
ConcurrentSkipListSet#spliterator():::Returns a Spliterator over the elements in this set:::((ConcurrentSkipListMap<E, ?>) m).keySpliterator
CopyOnWriteArrayList#getArray():::Gets the array:::
CopyOnWriteArrayList#setArray(Object[]):::Sets the array.:::
CopyOnWriteArrayList#size():::Returns the number of elements in this list.:::this.getArray
CopyOnWriteArrayList#isEmpty():::Returns true if this list contains no elements.:::this.size
CopyOnWriteArrayList#contains(Object):::Returns true if this list contains the specified element:::this.indexOf
CopyOnWriteArrayList#indexOf(E, int):::Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found:::this.getArray->this.indexOfRange
CopyOnWriteArrayList#lastIndexOf(E, int):::Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found:::this.getArray->this.lastIndexOfRange
CopyOnWriteArrayList#clone():::Returns a shallow copy of this list:::super.clone->clone.resetLock->VarHandle.releaseFence
CopyOnWriteArrayList#toArray():::Returns an array containing all of the elements in this list in proper sequence (from first to last element):::getArray().clone
CopyOnWriteArrayList#toArray(T[]):::Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array:::this.getArray->System.arraycopy->a.getClass->Arrays.copyOf
CopyOnWriteArrayList#set(int, E):::Replaces the element at the specified position in this list with the specified element.:::this.getArray->this.elementAt->es.clone->this.setArray
CopyOnWriteArrayList#add(E):::Appends the specified element to the end of this list.:::this.getArray->Arrays.copyOf->this.setArray
CopyOnWriteArrayList#add(int, E):::Inserts the specified element at the specified position in this list:::this.getArray->this.outOfBounds->System.arraycopy->System.arraycopy->Arrays.copyOf->this.setArray
CopyOnWriteArrayList#remove(int):::Removes the element at the specified position in this list:::this.getArray->this.elementAt->System.arraycopy->System.arraycopy->Arrays.copyOf->this.setArray
CopyOnWriteArrayList#remove(Object):::Removes the first occurrence of the specified element from this list, if it is present:::this.getArray->this.indexOfRange->this.remove
CopyOnWriteArrayList#removeRange(int, int):::Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive:::this.getArray->System.arraycopy->System.arraycopy->this.setArray->Arrays.copyOf->this.setArray
CopyOnWriteArrayList#addIfAbsent(E):::Appends the element, if not present.:::this.getArray->this.indexOfRange->this.addIfAbsent
CopyOnWriteArrayList#containsAll(Collection):::Returns true if this list contains all of the elements of the specified collection.:::this.getArray->this.indexOfRange
CopyOnWriteArrayList#removeAll(Collection):::Removes from this list all of its elements that are contained in the specified collection:::Objects.requireNonNull->this.bulkRemove
CopyOnWriteArrayList#retainAll(Collection):::Retains only the elements in this list that are contained in the specified collection:::Objects.requireNonNull->this.bulkRemove
CopyOnWriteArrayList#addAllAbsent(Collection):::Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.:::c.toArray->this.getArray->this.indexOfRange->this.indexOfRange->Arrays.copyOf->System.arraycopy->this.setArray
CopyOnWriteArrayList#clear():::Removes all of the elements from this list:::this.setArray
CopyOnWriteArrayList#addAll(Collection):::Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.:::c.getClass->c.toArray->((CopyOnWriteArrayList<?>) c).getArray->this.getArray->cs.getClass->Arrays.copyOf->System.arraycopy->this.setArray
CopyOnWriteArrayList#addAll(int, Collection):::Inserts all of the elements in the specified collection into this list, starting at the specified position:::c.toArray->this.getArray->this.outOfBounds->System.arraycopy->System.arraycopy->Arrays.copyOf->System.arraycopy->this.setArray
CopyOnWriteArrayList#toString():::Returns a string representation of this list:::this.getArray->Arrays.toString
CopyOnWriteArrayList#equals(Object):::Compares the specified object with this list for equality:::list.iterator->it.hasNext->it.next->Objects.equals->this.getArray->it.hasNext
CopyOnWriteArrayList#hashCode():::Returns the hash code value for this list:::this.getArray->this.hashCodeOfRange
CopyOnWriteArrayList#iterator():::Returns an iterator over the elements in this list in proper sequence:::this.getArray
CopyOnWriteArrayList#listIterator():::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::this.getArray
CopyOnWriteArrayList#listIterator(int):::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed:::this.getArray->this.outOfBounds
CopyOnWriteArrayList#spliterator():::Returns a Spliterator over the elements in this list:::this.getArray->Spliterators.spliterator
CopyOnWriteArrayList.COWIterator#remove():::Not supported:::
CopyOnWriteArrayList.COWIterator#set(E):::Not supported:::
CopyOnWriteArrayList.COWIterator#add(E):::Not supported:::
CopyOnWriteArrayList#subList(int, int):::Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive:::this.getArray
CopyOnWriteArraySet#size():::Returns the number of elements in this set.:::al.size
CopyOnWriteArraySet#isEmpty():::Returns true if this set contains no elements.:::al.isEmpty
CopyOnWriteArraySet#contains(Object):::Returns true if this set contains the specified element:::al.contains
CopyOnWriteArraySet#toArray():::Returns an array containing all of the elements in this set:::al.toArray
CopyOnWriteArraySet#toArray(T[]):::Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array:::al.toArray
CopyOnWriteArraySet#clear():::Removes all of the elements from this set:::al.clear
CopyOnWriteArraySet#remove(Object):::Removes the specified element from this set if it is present:::al.remove
CopyOnWriteArraySet#add(E):::Adds the specified element to this set if it is not already present:::al.addIfAbsent
CopyOnWriteArraySet#containsAll(Collection):::Returns true if this set contains all of the elements of the specified collection:::al.containsAll->al.getArray->this.compareSets
CopyOnWriteArraySet#addAll(Collection):::Adds all of the elements in the specified collection to this set if they're not already present:::al.addAllAbsent
CopyOnWriteArraySet#removeAll(Collection):::Removes from this set all of its elements that are contained in the specified collection:::al.removeAll
CopyOnWriteArraySet#retainAll(Collection):::Retains only the elements in this set that are contained in the specified collection:::al.retainAll
CopyOnWriteArraySet#iterator():::Returns an iterator over the elements contained in this set in the order in which these elements were added:::al.iterator
CopyOnWriteArraySet#equals(Object):::Compares the specified object with this set for equality:::al.getArray->this.compareSets
CopyOnWriteArraySet#spliterator():::Returns a Spliterator over the elements in this set in the order in which these elements were added:::al.getArray->Spliterators.spliterator
CountDownLatch#await():::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted:::sync.acquireSharedInterruptibly
CountDownLatch#await(long, TimeUnit):::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted, or the specified waiting time elapses:::unit.toNanos->sync.tryAcquireSharedNanos
CountDownLatch#countDown():::Decrements the count of the latch, releasing all waiting threads if the count reaches zero:::sync.releaseShared
CountDownLatch#getCount():::Returns the current count:::sync.getCount
CountDownLatch#toString():::Returns a string identifying this latch, as well as its state:::super.toString->sync.getCount
CountedCompleter#compute():::The main computation performed by this task.:::
CountedCompleter#onCompletion(CountedCompleter):::Performs an action when method #tryComplete is invoked and the pending count is zero, or when the unconditional method #complete is invoked:::
CountedCompleter#onExceptionalCompletion(Throwable, CountedCompleter):::Performs an action when method #completeExceptionally(Throwable) is invoked or method #compute throws an exception, and this task has not already otherwise completed normally:::
CountedCompleter#getCompleter():::Returns the completer established in this task's constructor, or null if none.:::
CountedCompleter#getPendingCount():::Returns the current pending count.:::
CountedCompleter#setPendingCount(int):::Sets the pending count to the given value.:::
CountedCompleter#addToPendingCount(int):::Adds (atomically) the given value to the pending count.:::PENDING.getAndAdd
CountedCompleter#compareAndSetPendingCount(int, int):::Sets (atomically) the pending count to the given count only if it currently holds the given expected value.:::PENDING.compareAndSet
CountedCompleter#decrementPendingCountUnlessZero():::If the pending count is nonzero, (atomically) decrements it.:::PENDING.weakCompareAndSet
CountedCompleter#getRoot():::Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.:::
CountedCompleter#tryComplete():::If the pending count is nonzero, decrements the count; otherwise invokes #onCompletion(CountedCompleter) and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.:::PENDING.weakCompareAndSet->a.onCompletion->s.quietlyComplete
CountedCompleter#propagateCompletion():::Equivalent to #tryComplete but does not invoke #onCompletion(CountedCompleter) along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete:::PENDING.weakCompareAndSet->s.quietlyComplete
CountedCompleter#complete(T):::Regardless of pending count, invokes #onCompletion(CountedCompleter), marks this task as complete and further triggers #tryComplete on this task's completer, if one exists:::this.setRawResult->this.onCompletion->this.quietlyComplete->p.tryComplete
CountedCompleter#firstComplete():::If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null:::PENDING.weakCompareAndSet
CountedCompleter#nextComplete():::If this task does not have a completer, invokes ForkJoinTask#quietlyComplete and returns null:::this.quietlyComplete->p.firstComplete
CountedCompleter#quietlyCompleteRoot():::Equivalent to getRoot().quietlyComplete().:::a.quietlyComplete
CountedCompleter#helpComplete(int):::If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.:::Thread.currentThread->ForkJoinPool.common.externalHelpComplete->(wt = (ForkJoinWorkerThread) t).pool.helpComplete
CountedCompleter#internalPropagateException(Throwable):::Supports ForkJoinTask exception propagation.:::a.onExceptionalCompletion->a.recordExceptionalCompletion->this.isExceptionalStatus
CountedCompleter#exec():::Implements execution conventions for CountedCompleters.:::this.compute
CountedCompleter#getRawResult():::Returns the result of the computation:::
CountedCompleter#setRawResult(T):::A method that result-bearing CountedCompleters may optionally use to help maintain result data:::
CyclicBarrier#getParties():::Returns the number of parties required to trip this barrier.:::
CyclicBarrier#await():::Waits until all #getParties parties have invoked await on this barrier:::this.dowait
CyclicBarrier#await(long, TimeUnit):::Waits until all #getParties parties have invoked await on this barrier, or the specified waiting time elapses:::unit.toNanos->this.dowait
CyclicBarrier#isBroken():::Queries if this barrier is in a broken state.:::lock.lock->lock.unlock
CyclicBarrier#reset():::Resets the barrier to its initial state:::lock.lock->lock.unlock->this.breakBarrier->this.nextGeneration
CyclicBarrier#getNumberWaiting():::Returns the number of parties currently waiting at the barrier:::lock.lock->lock.unlock
Delayed#getDelay(TimeUnit):::Returns the remaining delay associated with this object, in the given time unit.:::
DelayQueue#add(E):::Inserts the specified element into this delay queue.:::this.offer
DelayQueue#offer(E):::Inserts the specified element into this delay queue.:::lock.lock->lock.unlock->q.offer->q.peek->available.signal
DelayQueue#put(E):::Inserts the specified element into this delay queue:::this.offer
DelayQueue#offer(E, long, TimeUnit):::Inserts the specified element into this delay queue:::this.offer
DelayQueue#poll():::Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.:::lock.lock->lock.unlock->q.peek->first.getDelay->q.poll
DelayQueue#take():::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.:::lock.lockInterruptibly->q.peek->available.signal->lock.unlock->q.peek->first.getDelay->q.poll->Thread.currentThread->available.awaitNanos->available.await->available.await
DelayQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.:::unit.toNanos->lock.lockInterruptibly->q.peek->available.signal->lock.unlock->q.peek->first.getDelay->q.poll->Thread.currentThread->available.awaitNanos->available.awaitNanos->available.awaitNanos
DelayQueue#peek():::Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty:::lock.lock->lock.unlock->q.peek
DelayQueue#clear():::Atomically removes all of the elements from this delay queue:::lock.lock->lock.unlock->q.clear
DelayQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.:::
DelayQueue#toArray():::Returns an array containing all of the elements in this queue:::lock.lock->lock.unlock->q.toArray
DelayQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock.lock->lock.unlock->q.toArray
DelayQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.:::lock.lock->lock.unlock->q.remove
DelayQueue#removeEQ(Object):::Identity-based version for use in Itr.remove.:::lock.lock->lock.unlock->it.next->it.remove->it.hasNext->q.iterator
DelayQueue#iterator():::Returns an iterator over all the elements (both expired and unexpired) in this queue:::this.toArray
Exchanger#exchange(V):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted), and then transfers the given object to it, receiving its object in return:::this.slotExchange->Thread.interrupted->this.arenaExchange
Exchanger#exchange(V, long, TimeUnit):::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return:::unit.toNanos->this.slotExchange->Thread.interrupted->this.arenaExchange
Executor#execute(Runnable):::Executes the given command at some time in the future:::
Executors#newFixedThreadPool(int):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue:::
Executors#newWorkStealingPool(int):::Creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention:::
Executors#newWorkStealingPool():::Creates a work-stealing thread pool using the number of Runtime#availableProcessors available processors as its target parallelism level.:::Runtime.getRuntime().availableProcessors
Executors#newFixedThreadPool(int, ThreadFactory):::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue, using the provided ThreadFactory to create new threads when needed:::
Executors#newSingleThreadExecutor():::Creates an Executor that uses a single worker thread operating off an unbounded queue:::
Executors#newSingleThreadExecutor(ThreadFactory):::Creates an Executor that uses a single worker thread operating off an unbounded queue, and uses the provided ThreadFactory to create a new thread when needed:::
Executors#newCachedThreadPool():::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available:::
Executors#newCachedThreadPool(ThreadFactory):::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available, and uses the provided ThreadFactory to create new threads when needed.:::
Executors#newSingleThreadScheduledExecutor():::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::
Executors#newSingleThreadScheduledExecutor(ThreadFactory):::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically:::
Executors#newScheduledThreadPool(int):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::
Executors#newScheduledThreadPool(int, ThreadFactory):::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.:::
Executors#unconfigurableExecutorService(ExecutorService):::Returns an object that delegates all defined ExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::
Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService):::Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts:::
Executors#defaultThreadFactory():::Returns a default thread factory used to create new threads:::
Executors#privilegedThreadFactory():::Returns a thread factory used to create new threads that have the same permissions as the current thread:::
Executors#callable(Runnable, T):::Returns a Callable object that, when called, runs the given task and returns the given result:::
Executors#callable(Runnable):::Returns a Callable object that, when called, runs the given task and returns null.:::
Executors#callable(PrivilegedAction):::Returns a Callable object that, when called, runs the given privileged action and returns its result.:::action.run
Executors#callable(PrivilegedExceptionAction):::Returns a Callable object that, when called, runs the given privileged exception action and returns its result.:::action.run
Executors#privilegedCallable(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context:::
Executors#privilegedCallableUsingCurrentClassLoader(Callable):::Returns a Callable object that will, when called, execute the given callable under the current access control context, with the current context class loader as the context class loader:::
ExecutorService#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::
ExecutorService#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::
ExecutorService#isShutdown():::Returns true if this executor has been shut down.:::
ExecutorService#isTerminated():::Returns true if all tasks have completed following shut down:::
ExecutorService#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.:::
ExecutorService#submit(Callable):::Submits a value-returning task for execution and returns a Future representing the pending results of the task:::
ExecutorService#submit(Runnable, T):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#submit(Runnable):::Submits a Runnable task for execution and returns a Future representing that task:::
ExecutorService#invokeAll(Collection>):::Executes the given tasks, returning a list of Futures holding their status and results when all complete:::
ExecutorService#invokeAll(Collection>, long, TimeUnit):::Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first:::
ExecutorService#invokeAny(Collection>):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do:::
ExecutorService#invokeAny(Collection>, long, TimeUnit):::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses:::
Flow.Publisher#subscribe(Subscriber):::Adds the given Subscriber if possible:::
Flow.Subscriber#onSubscribe(Subscription):::Method invoked prior to invoking any other Subscriber methods for the given Subscription:::
Flow.Subscriber#onNext(T):::Method invoked with a Subscription's next item:::
Flow.Subscriber#onError(Throwable):::Method invoked upon an unrecoverable error encountered by a Publisher or Subscription, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscriber#onComplete():::Method invoked when it is known that no additional Subscriber method invocations will occur for a Subscription that is not already terminated by error, after which no other Subscriber methods are invoked by the Subscription:::
Flow.Subscription#request(long):::Adds the given number n of items to the current unfulfilled demand for this subscription:::
Flow.Subscription#cancel():::Causes the Subscriber to (eventually) stop receiving messages:::
Flow#defaultBufferSize():::Returns a default value for Publisher or Subscriber buffering, that may be used in the absence of other constraints.:::
ForkJoinPool.ForkJoinWorkerThreadFactory#newThread(ForkJoinPool):::Returns a new worker thread operating in the given pool:::
ForkJoinPool.WorkQueue#tryLockPhase():::Tries to lock shared queue by CASing phase field.:::PHASE.compareAndSet
ForkJoinPool.WorkQueue#getPoolIndex():::Returns an exportable index (used by ForkJoinWorkerThread).:::
ForkJoinPool.WorkQueue#queueSize():::Returns the approximate number of tasks in the queue.:::BASE.getAcquire
ForkJoinPool.WorkQueue#isEmpty():::Provides a more accurate estimate of whether this queue has any tasks than does queueSize, by checking whether a near-empty queue has at least one unclaimed task.:::VarHandle.acquireFence
ForkJoinPool.WorkQueue#push(ForkJoinTask):::Pushes a task:::QA.setRelease->BASE.getAcquire->this.growArray->VarHandle.fullFence->p.signalWork
ForkJoinPool.WorkQueue#lockedPush(ForkJoinTask):::Version of push for shared queues:::this.growArray
ForkJoinPool.WorkQueue#growArray(boolean):::Doubles the capacity of array:::QA.getAndSet->VarHandle.releaseFence
ForkJoinPool.WorkQueue#poll():::Takes next task, if one exists, in FIFO order.:::QA.getAcquire->QA.compareAndSet->BASE.setOpaque->Thread.yield
ForkJoinPool.WorkQueue#nextLocalTask():::Takes next task, if one exists, in order specified by mode.:::QA.getAndSet->this.poll->BASE.setOpaque->QA.getAndSet->TOP.setOpaque
ForkJoinPool.WorkQueue#peek():::Returns next task, if one exists, in order specified by mode.:::
ForkJoinPool.WorkQueue#tryUnpush(ForkJoinTask):::Pops the given task only if it is at the current top.:::QA.compareAndSet->TOP.setOpaque
ForkJoinPool.WorkQueue#tryLockedUnpush(ForkJoinTask):::Shared version of tryUnpush.:::this.tryLockPhase->QA.compareAndSet->this.releasePhaseLock
ForkJoinPool.WorkQueue#cancelAll():::Removes and cancels all known tasks, ignoring any exceptions.:::ForkJoinTask.cancelIgnoringExceptions->this.poll
ForkJoinPool.WorkQueue#topLevelExec(ForkJoinTask, WorkQueue, int):::Runs the given (stolen) task if nonnull, as well as remaining local tasks and others available from the given queue, up to bound n (to avoid infinite unfairness).:::t.doExec->this.nextLocalTask->q.poll->thread.afterTopLevelExec
ForkJoinPool.WorkQueue#tryRemoveAndExec(ForkJoinTask):::If present, removes task from queue and executes it.:::QA.get->QA.compareAndSet->QA.get->QA.setVolatile->QA.setRelease->VarHandle.releaseFence->t.doExec
ForkJoinPool.WorkQueue#helpCC(CountedCompleter, int, boolean):::Tries to pop and run tasks within the target's computation until done, not found, or limit exceeded.:::QA.compareAndSet->this.tryLockPhase->QA.compareAndSet->this.releasePhaseLock->v.doExec
ForkJoinPool.WorkQueue#helpAsyncBlocker(ManagedBlocker):::Tries to poll and run AsynchronousCompletionTasks until none found or blocker is released:::QA.getAcquire->blocker.isReleasable->QA.compareAndSet->BASE.setOpaque->t.doExec
ForkJoinPool.WorkQueue#isApparentlyUnblocked():::Returns true if owned and not known to be blocked.:::wt.getState
ForkJoinPool#registerWorker(ForkJoinWorkerThread):::Callback from ForkJoinWorkerThread constructor to establish and record its WorkQueue.:::wt.setDaemon->wt.setUncaughtExceptionHandler->Integer.toString->prefix.concat->wt.setName
ForkJoinPool#deregisterWorker(ForkJoinWorkerThread, Throwable):::Final callback from terminating worker, as well as upon failure to construct or start a worker:::CTL.weakCompareAndSet->w.cancelAll->this.tryTerminate->this.signalWork->ForkJoinTask.rethrow->ForkJoinTask.helpExpungeStaleExceptions
ForkJoinPool#signalWork():::Tries to create or release a worker if too few are running.:::CTL.compareAndSet->LockSupport.unpark->this.tryAddWorker
ForkJoinPool#runWorker(WorkQueue):::Top-level runloop for workers, called by ForkJoinWorkerThread.run:::ThreadLocalRandom.nextSecondarySeed->this.scan->Thread.interrupted->this.tryTerminate->LockSupport.park->System.currentTimeMillis->LockSupport.parkUntil->System.currentTimeMillis->CTL.compareAndSet->CTL.weakCompareAndSet
ForkJoinPool#awaitJoin(WorkQueue, ForkJoinTask, long):::Helps and/or blocks until the given task is done or timeout:::ThreadLocalRandom.nextSecondarySeed->w.helpCC->w.tryRemoveAndExec->QA.getAcquire->QA.compareAndSet->t.doExec->System.nanoTime->TimeUnit.NANOSECONDS.toMillis->this.tryCompensate->task.internalWait->CTL.getAndAdd
ForkJoinPool#helpQuiescePool(WorkQueue):::Runs tasks until isQuiescent():::ThreadLocalRandom.nextSecondarySeed->localTask.doExec->w.nextLocalTask->CTL.getAndAdd->QA.getAcquire->QA.compareAndSet->t.doExec->CTL.getAndAdd->CTL.getAndAdd
ForkJoinPool#nextTaskFor(WorkQueue):::Gets and removes a local or stolen task for the given worker.:::w.nextLocalTask->this.pollScan
ForkJoinPool#externalPush(ForkJoinTask):::Adds the given task to a submission queue at submitter's current queue, creating one if null or contended.:::ThreadLocalRandom.getProbe->ThreadLocalRandom.localInit->ThreadLocalRandom.getProbe->q.tryLockPhase->q.lockedPush->this.signalWork->ThreadLocalRandom.advanceProbe
ForkJoinPool#commonSubmitterQueue():::Returns common pool queue for an external thread.:::ThreadLocalRandom.getProbe
ForkJoinPool#tryExternalUnpush(ForkJoinTask):::Performs tryUnpush for an external submitter.:::ThreadLocalRandom.getProbe->w.tryLockedUnpush
ForkJoinPool#externalHelpComplete(CountedCompleter, int):::Performs helpComplete for an external submitter.:::ThreadLocalRandom.getProbe->w.helpCC
ForkJoinPool#helpComplete(WorkQueue, CountedCompleter, int):::Tries to steal and run tasks within the target's computation:::w.helpCC
ForkJoinPool#getSurplusQueuedTaskCount():::Returns a cheap heuristic guide for task partitioning when programmers, frameworks, tools, or languages have little or no idea about task granularity:::Thread.currentThread
ForkJoinPool#commonPool():::Returns the common pool instance:::
ForkJoinPool#invoke(ForkJoinTask):::Performs the given task, returning its result upon completion:::this.externalSubmit->task.join
ForkJoinPool#execute(ForkJoinTask):::Arranges for (asynchronous) execution of the given task.:::this.externalSubmit
ForkJoinPool#submit(ForkJoinTask):::Submits a ForkJoinTask for execution.:::this.externalSubmit
ForkJoinPool#getFactory():::Returns the factory used for constructing new workers.:::
ForkJoinPool#getUncaughtExceptionHandler():::Returns the handler for internal worker threads that terminate due to unrecoverable errors encountered while executing tasks.:::
ForkJoinPool#getParallelism():::Returns the targeted parallelism level of this pool.:::
ForkJoinPool#getCommonPoolParallelism():::Returns the targeted parallelism level of the common pool.:::
ForkJoinPool#getPoolSize():::Returns the number of worker threads that have started but not yet terminated:::
ForkJoinPool#getAsyncMode():::Returns true if this pool uses local first-in-first-out scheduling mode for forked tasks that are never joined.:::
ForkJoinPool#getRunningThreadCount():::Returns an estimate of the number of worker threads that are not blocked waiting to join tasks or for other managed synchronization:::VarHandle.acquireFence->w.isApparentlyUnblocked
ForkJoinPool#getActiveThreadCount():::Returns an estimate of the number of threads that are currently stealing or executing tasks:::
ForkJoinPool#isQuiescent():::Returns true if all worker threads are currently idle:::
ForkJoinPool#getStealCount():::Returns an estimate of the total number of tasks stolen from one thread's work queue by another:::
ForkJoinPool#getQueuedTaskCount():::Returns an estimate of the total number of tasks currently held in queues by worker threads (but not including tasks submitted to the pool that have not begun executing):::VarHandle.acquireFence->w.queueSize
ForkJoinPool#getQueuedSubmissionCount():::Returns an estimate of the number of tasks submitted to this pool that have not yet begun executing:::VarHandle.acquireFence->w.queueSize
ForkJoinPool#hasQueuedSubmissions():::Returns true if there are any tasks submitted to this pool that have not yet begun executing.:::VarHandle.acquireFence->w.isEmpty
ForkJoinPool#pollSubmission():::Removes and returns the next unexecuted submission if one is available:::this.pollScan
ForkJoinPool#drainTasksTo(Collection>):::Removes all available unexecuted submitted and forked tasks from scheduling queues and adds them to the given collection, without altering their execution status:::VarHandle.acquireFence->c.add->w.poll
ForkJoinPool#toString():::Returns a string identifying this pool, as well as its state, including indications of run state, parallelism level, and worker and task counts.:::w.queueSize->w.isApparentlyUnblocked->super.toString
ForkJoinPool#shutdown():::Possibly initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::this.checkPermission->this.tryTerminate
ForkJoinPool#shutdownNow():::Possibly attempts to cancel and/or stop all tasks, and reject all subsequently submitted tasks:::this.checkPermission->this.tryTerminate->Collections.emptyList
ForkJoinPool#isTerminated():::Returns true if all tasks have completed following shut down.:::
ForkJoinPool#isTerminating():::Returns true if the process of termination has commenced but not yet completed:::
ForkJoinPool#isShutdown():::Returns true if this pool has been shut down.:::
ForkJoinPool#awaitTermination(long, TimeUnit):::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first:::Thread.interrupted->this.awaitQuiescence->unit.toNanos->this.isTerminated->System.nanoTime->this.isTerminated->TimeUnit.NANOSECONDS.toMillis->this.wait->System.nanoTime
ForkJoinPool#awaitQuiescence(long, TimeUnit):::If called by a ForkJoinTask operating in this pool, equivalent in effect to ForkJoinTask#helpQuiesce:::unit.toNanos->Thread.currentThread->this.pollScan->this.isQuiescent->System.nanoTime->Thread.yield->t.doExec->System.nanoTime->this.helpQuiescePool
ForkJoinPool#quiesceCommonPool():::Waits and/or attempts to assist performing tasks indefinitely until the #commonPool() #isQuiescent.:::common.awaitQuiescence
ForkJoinPool.ManagedBlocker#block():::Possibly blocks the current thread, for example waiting for a lock or condition.:::
ForkJoinPool.ManagedBlocker#isReleasable():::Returns true if blocking is unnecessary.:::
ForkJoinPool#managedBlock(ManagedBlocker):::Runs the given possibly blocking task:::Thread.currentThread->blocker.isReleasable->blocker.block->p.tryCompensate->CTL.getAndAdd->blocker.isReleasable->blocker.block->blocker.isReleasable
ForkJoinPool#helpAsyncBlocker(Executor, ManagedBlocker):::If the given executor is a ForkJoinPool, poll and execute AsynchronousCompletionTasks from worker's queue until none are available or blocker is released.:::Thread.currentThread->ThreadLocalRandom.getProbe->w.helpAsyncBlocker
ForkJoinTask#doExec():::Primary execution method for stolen tasks:::this.setExceptionalCompletion->this.exec->this.setDone
ForkJoinTask#internalWait(long):::If not done, sets SIGNAL status and performs Object.wait(timeout):::STATUS.getAndBitwiseOr->this.notifyAll->this.wait
ForkJoinTask#recordExceptionalCompletion(Throwable):::Records exception and sets status.:::System.identityHashCode->lock.lock->lock.unlock->this.expungeStaleExceptions->e.get->this.abnormalCompletion
ForkJoinTask#internalPropagateException(Throwable):::Hook for exception propagation support for tasks with completers.:::
ForkJoinTask#cancelIgnoringExceptions(ForkJoinTask):::Cancels, ignoring any exceptions thrown by cancel:::t.cancel
ForkJoinTask#helpExpungeStaleExceptions():::If lock is available, polls stale refs and removes them:::lock.tryLock->lock.unlock->this.expungeStaleExceptions
ForkJoinTask#rethrow(Throwable):::A version of "sneaky throw" to relay exceptions.:::ForkJoinTask.uncheckedThrow
ForkJoinTask#uncheckedThrow(Throwable):::The sneaky part of sneaky throw, relying on generics limitations to evade compiler complaints about rethrowing unchecked exceptions.:::
ForkJoinTask#fork():::Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool#commonPool() if not #inForkJoinPool:::Thread.currentThread->ForkJoinPool.common.externalPush->((ForkJoinWorkerThread) t).workQueue.push
ForkJoinTask#join():::Returns the result of the computation when it #isDone is done:::this.doJoin->this.reportException->this.getRawResult
ForkJoinTask#invoke():::Commences performing this task, awaits its completion if necessary, and returns its result, or throws an (unchecked) RuntimeException or Error if the underlying computation did so.:::this.doInvoke->this.reportException->this.getRawResult
ForkJoinTask#invokeAll(ForkJoinTask, ForkJoinTask):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::t2.fork->t1.doInvoke->t1.reportException->t2.doJoin->t2.reportException
ForkJoinTask#invokeAll(ForkJoinTask...):::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::t.doInvoke->t.getException->t.fork->t.doJoin->t.getException->t.cancel->this.rethrow
ForkJoinTask#invokeAll(Collection):::Forks all tasks in the specified collection, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown:::tasks.toArray->this.invokeAll->ts.size->ts.get->t.doInvoke->t.getException->t.fork->ts.get->t.doJoin->t.getException->t.cancel->this.rethrow
ForkJoinTask#cancel(boolean):::Attempts to cancel execution of this task:::this.abnormalCompletion
ForkJoinTask#isCompletedAbnormally():::Returns true if this task threw an exception or was cancelled.:::
ForkJoinTask#isCompletedNormally():::Returns true if this task completed without throwing an exception and was not cancelled.:::
ForkJoinTask#getException():::Returns the exception thrown by the base computation, or a CancellationException if cancelled, or null if none or if the method has not yet completed.:::this.getThrowableException
ForkJoinTask#completeExceptionally(Throwable):::Completes this task abnormally, and if not already aborted or cancelled, causes it to throw the given exception upon join and related operations:::this.setExceptionalCompletion
ForkJoinTask#complete(V):::Completes this task, and if not already aborted or cancelled, returning the given value as the result of subsequent invocations of join and related operations:::this.setExceptionalCompletion->this.setRawResult->this.setDone
ForkJoinTask#quietlyComplete():::Completes this task normally without setting a value:::this.setDone
ForkJoinTask#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::Thread.currentThread->this.externalInterruptibleAwaitDone->this.doJoin->this.getRawResult->this.getThrowableException
ForkJoinTask#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::unit.toNanos->Thread.interrupted->System.nanoTime->Thread.currentThread->ForkJoinPool.common.tryExternalUnpush->this.doExec->ForkJoinPool.common.externalHelpComplete->TimeUnit.NANOSECONDS.toMillis->STATUS.getAndBitwiseOr->this.notifyAll->this.wait->System.nanoTime->wt.pool.awaitJoin->this.getRawResult->this.getThrowableException
ForkJoinTask#quietlyJoin():::Joins this task, without returning its result or throwing its exception:::this.doJoin
ForkJoinTask#quietlyInvoke():::Commences performing this task and awaits its completion if necessary, without returning its result or throwing its exception.:::this.doInvoke
ForkJoinTask#helpQuiesce():::Possibly executes tasks until the pool hosting the current task ForkJoinPool#isQuiescent is quiescent:::Thread.currentThread->ForkJoinPool.quiesceCommonPool->wt.pool.helpQuiescePool
ForkJoinTask#reinitialize():::Resets the internal bookkeeping state of this task, allowing a subsequent fork:::this.clearExceptionalCompletion
ForkJoinTask#getPool():::Returns the pool hosting the current thread, or null if the current thread is executing outside of any ForkJoinPool:::Thread.currentThread
ForkJoinTask#inForkJoinPool():::Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.:::Thread.currentThread
ForkJoinTask#tryUnfork():::Tries to unschedule this task for execution:::Thread.currentThread->ForkJoinPool.common.tryExternalUnpush->((ForkJoinWorkerThread) t).workQueue.tryUnpush
ForkJoinTask#getQueuedTaskCount():::Returns an estimate of the number of tasks that have been forked by the current worker thread but not yet executed:::Thread.currentThread->ForkJoinPool.commonSubmitterQueue->q.queueSize
ForkJoinTask#getSurplusQueuedTaskCount():::Returns an estimate of how many more locally queued tasks are held by the current worker thread than there are other worker threads that might steal them, or zero if this thread is not operating in a ForkJoinPool:::ForkJoinPool.getSurplusQueuedTaskCount
ForkJoinTask#getRawResult():::Returns the result that would be returned by #join, even if this task completed abnormally, or null if this task is not known to have been completed:::
ForkJoinTask#setRawResult(V):::Forces the given value to be returned as a result:::
ForkJoinTask#exec():::Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally:::
ForkJoinTask#peekNextLocalTask():::Returns, but does not unschedule or execute, a task queued by the current thread but not yet executed, if one is immediately available:::Thread.currentThread->ForkJoinPool.commonSubmitterQueue->q.peek
ForkJoinTask#pollNextLocalTask():::Unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if the current thread is operating in a ForkJoinPool:::Thread.currentThread->((ForkJoinWorkerThread) t).workQueue.nextLocalTask
ForkJoinTask#pollTask():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available:::Thread.currentThread->(wt = (ForkJoinWorkerThread) t).pool.nextTaskFor
ForkJoinTask#pollSubmission():::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available:::Thread.currentThread->((ForkJoinWorkerThread) t).pool.pollSubmission
ForkJoinTask#getForkJoinTaskTag():::Returns the tag for this task.:::
ForkJoinTask#setForkJoinTaskTag(short):::Atomically sets the tag value for this task and returns the old value.:::STATUS.weakCompareAndSet
ForkJoinTask#compareAndSetForkJoinTaskTag(short, short):::Atomically conditionally sets the tag value for this task:::STATUS.weakCompareAndSet
ForkJoinTask#adapt(Runnable):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns a null result upon #join.:::
ForkJoinTask#adapt(Runnable, T):::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns the given result upon #join.:::
ForkJoinTask#adapt(Callable):::Returns a new ForkJoinTask that performs the call method of the given Callable as its action, and returns its result upon #join, translating any checked exceptions encountered into RuntimeException.:::
ForkJoinWorkerThread#getPool():::Returns the pool hosting this thread.:::
ForkJoinWorkerThread#getPoolIndex():::Returns the unique index number of this thread in its pool:::workQueue.getPoolIndex
ForkJoinWorkerThread#onStart():::Initializes internal state after construction but before processing any tasks:::
ForkJoinWorkerThread#onTermination(Throwable):::Performs cleanup associated with termination of this worker thread:::
ForkJoinWorkerThread#run():::This method is required to be public, but should never be called explicitly:::pool.deregisterWorker->this.onTermination->this.onStart->pool.runWorker
ForkJoinWorkerThread#afterTopLevelExec():::Non-public hook method for InnocuousForkJoinWorkerThread.:::
Future#cancel(boolean):::Attempts to cancel execution of this task:::
Future#isCancelled():::Returns true if this task was cancelled before it completed normally.:::
Future#isDone():::Returns true if this task completed:::
Future#get():::Waits if necessary for the computation to complete, and then retrieves its result.:::
Future#get(long, TimeUnit):::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.:::
FutureTask#done():::Protected method invoked when this task transitions to state isDone (whether normally or via cancellation):::
FutureTask#set(V):::Sets the result of this future to the given value unless this future has already been set or has been cancelled:::STATE.compareAndSet->STATE.setRelease->this.finishCompletion
FutureTask#setException(Throwable):::Causes this future to report an ExecutionException with the given throwable as its cause, unless this future has already been set or has been cancelled:::STATE.compareAndSet->STATE.setRelease->this.finishCompletion
FutureTask#runAndReset():::Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled:::Thread.currentThread->RUNNER.compareAndSet->this.handlePossibleCancellationInterrupt->this.setException->c.call
FutureTask#toString():::Returns a string representation of this FutureTask.:::super.toString
Helpers#collectionToString(Collection):::An implementation of Collection.toString() suitable for classes with locks:::c.toArray->this.objectToString->s.length->this.toString
Helpers#toString(Object[], int, int):::Like Arrays.toString(), but caller guarantees that size > 0, each element with index 0 <= i < size is a non-null String, and charLength is the sum of the lengths of the input Strings.:::s.length->s.getChars
Helpers#mapEntryToString(Object, Object):::Optimized form of: key + "=" + val:::(k = objectToString(key)).length->(v = objectToString(val)).length->k.getChars->v.getChars
LinkedBlockingDeque#unlink(Node):::Unlinks x.:::notFull.signal->this.unlinkLast->this.unlinkFirst
LinkedBlockingDeque#add(E):::Inserts the specified element at the end of this deque unless it would violate capacity restrictions:::this.addLast
LinkedBlockingDeque#remove():::Retrieves and removes the head of the queue represented by this deque:::this.removeFirst
LinkedBlockingDeque#element():::Retrieves, but does not remove, the head of the queue represented by this deque:::this.getFirst
LinkedBlockingDeque#remainingCapacity():::Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking:::lock.lock->lock.unlock
LinkedBlockingDeque#remove(Object):::Removes the first occurrence of the specified element from this deque:::this.removeFirstOccurrence
LinkedBlockingDeque#size():::Returns the number of elements in this deque.:::lock.lock->lock.unlock
LinkedBlockingDeque#contains(Object):::Returns true if this deque contains the specified element:::lock.lock->lock.unlock->o.equals
LinkedBlockingDeque#addAll(Collection):::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator:::Objects.requireNonNull->lock.lock->lock.unlock->notEmpty.signalAll->super.addAll
LinkedBlockingDeque#toArray():::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element):::lock.lock->lock.unlock
LinkedBlockingDeque#toArray(T[]):::Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array:::lock.lock->lock.unlock->a.getClass().getComponentType->java.lang.reflect.Array.newInstance
LinkedBlockingDeque#clear():::Atomically removes all of the elements from this deque:::lock.lock->lock.unlock->notFull.signalAll
LinkedBlockingDeque#succ(Node):::Used for any element traversal that is not entirely under lock:::
LinkedBlockingDeque#iterator():::Returns an iterator over the elements in this deque in proper sequence:::
LinkedBlockingDeque#descendingIterator():::Returns an iterator over the elements in this deque in reverse sequential order:::
LinkedBlockingDeque#spliterator():::Returns a Spliterator over the elements in this deque:::
LinkedBlockingDeque#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::lock.lock->lock.unlock->this.succ->this.succ->action.accept
LinkedBlockingQueue#fullyLock():::Locks to prevent both puts and takes.:::putLock.lock->takeLock.lock
LinkedBlockingQueue#fullyUnlock():::Unlocks to allow both puts and takes.:::takeLock.unlock->putLock.unlock
LinkedBlockingQueue#size():::Returns the number of elements in this queue.:::count.get
LinkedBlockingQueue#remainingCapacity():::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking:::count.get
LinkedBlockingQueue#put(E):::Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.:::putLock.lockInterruptibly->putLock.unlock->notFull.await->count.get->this.enqueue->count.getAndIncrement->notFull.signal->this.signalNotEmpty
LinkedBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.:::unit.toNanos->putLock.lockInterruptibly->putLock.unlock->notFull.awaitNanos->count.get->this.enqueue->count.getAndIncrement->notFull.signal->this.signalNotEmpty
LinkedBlockingQueue#offer(E):::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full:::count.get->putLock.lock->putLock.unlock->count.get->this.enqueue->count.getAndIncrement->notFull.signal->this.signalNotEmpty
LinkedBlockingQueue#unlink(Node, Node):::Unlinks interior Node p with predecessor pred.:::count.getAndDecrement->notFull.signal
LinkedBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::this.fullyLock->this.fullyUnlock->o.equals->this.unlink
LinkedBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::this.fullyLock->this.fullyUnlock->o.equals
LinkedBlockingQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::this.fullyLock->this.fullyUnlock->count.get
LinkedBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::this.fullyLock->this.fullyUnlock->count.get->a.getClass().getComponentType->java.lang.reflect.Array.newInstance
LinkedBlockingQueue#clear():::Atomically removes all of the elements from this queue:::this.fullyLock->this.fullyUnlock->count.getAndSet->notFull.signal
LinkedBlockingQueue#succ(Node):::Used for any element traversal that is not entirely under lock:::
LinkedBlockingQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::
LinkedBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::
LinkedBlockingQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::this.fullyLock->this.fullyUnlock->this.succ->this.succ->action.accept
LinkedBlockingQueue#findPred(Node, Node):::Returns the predecessor of live node p, given a node that was once a live ancestor of p (or head); allows unlinking of p.:::
LinkedTransferQueue.Node#selfLink():::Links node to itself to avoid garbage retention:::NEXT.setRelease
LinkedTransferQueue.Node#forgetContents():::Sets item (of a request node) to self and waiter to null, to avoid garbage retention after matching or cancelling:::ITEM.set->WAITER.set
LinkedTransferQueue.Node#isMatched():::Returns true if this node has been matched, including the case of artificial matches due to cancellation.:::
LinkedTransferQueue.Node#tryMatch(Object, Object):::Tries to CAS-match this node; if successful, wakes waiter.:::this.casItem->LockSupport.unpark
LinkedTransferQueue.Node#cannotPrecede(boolean):::Returns true if a node with the given mode cannot be appended to this node because this node is unmatched and has opposite data mode.:::
LinkedTransferQueue#firstDataNode():::Returns the first unmatched data node, or null if none:::this.casHead->h.selfLink
LinkedTransferQueue#toArray():::Returns an array containing all of the elements in this queue, in proper sequence:::this.toArrayInternal
LinkedTransferQueue#toArray(T[]):::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array:::Objects.requireNonNull->this.toArrayInternal
LinkedTransferQueue#spliterator():::Returns a Spliterator over the elements in this queue:::
LinkedTransferQueue#unsplice(Node, Node):::Unsplices (now or later) the given deleted/cancelled node with the given predecessor.:::pred.casNext->pred.isMatched->h.isMatched->this.casHead->h.selfLink->this.incSweepVotes->this.sweep
LinkedTransferQueue#put(E):::Inserts the specified element at the tail of this queue:::this.xfer
LinkedTransferQueue#offer(E, long, TimeUnit):::Inserts the specified element at the tail of this queue:::this.xfer
LinkedTransferQueue#offer(E):::Inserts the specified element at the tail of this queue:::this.xfer
LinkedTransferQueue#add(E):::Inserts the specified element at the tail of this queue:::this.xfer
LinkedTransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::this.xfer
LinkedTransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::this.xfer->Thread.interrupted
LinkedTransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::unit.toNanos->this.xfer->Thread.interrupted
LinkedTransferQueue#iterator():::Returns an iterator over the elements in this queue in proper sequence:::
LinkedTransferQueue#isEmpty():::Returns true if this queue contains no elements.:::this.firstDataNode
LinkedTransferQueue#size():::Returns the number of elements in this queue:::this.countOfMode
LinkedTransferQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::o.equals->p.tryMatch->this.skipDeadNodes->q.isMatched->this.skipDeadNodes
LinkedTransferQueue#contains(Object):::Returns true if this queue contains the specified element:::o.equals->q.isMatched->this.skipDeadNodes
LinkedTransferQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a LinkedTransferQueue is not capacity constrained.:::
LinkedTransferQueue#forEachFrom(Consumer, Node):::Runs action on each element found during a traversal starting at p:::action.accept->q.isMatched->this.skipDeadNodes
Phaser#register():::Adds a new unarrived party to this phaser:::this.doRegister
Phaser#bulkRegister(int):::Adds the given number of new unarrived parties to this phaser:::this.getPhase->this.doRegister
Phaser#arrive():::Arrives at this phaser, without waiting for others to arrive:::this.doArrive
Phaser#arriveAndDeregister():::Arrives at this phaser and deregisters from it without waiting for others to arrive:::this.doArrive
Phaser#arriveAndAwaitAdvance():::Arrives at this phaser and awaits others:::this.reconcileState->this.badArrive->STATE.compareAndSet->root.internalAwaitAdvance->parent.arriveAndAwaitAdvance->this.onAdvance->STATE.compareAndSet->this.releaseWaiters
Phaser#awaitAdvance(int):::Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::this.reconcileState->root.internalAwaitAdvance
Phaser#awaitAdvanceInterruptibly(int):::Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::this.reconcileState->root.internalAwaitAdvance
Phaser#awaitAdvanceInterruptibly(int, long, TimeUnit):::Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.:::unit.toNanos->this.reconcileState->root.internalAwaitAdvance
Phaser#forceTermination():::Forces this phaser to enter termination state:::STATE.compareAndSet->this.releaseWaiters->this.releaseWaiters
Phaser#getPhase():::Returns the current phase number:::
Phaser#getRegisteredParties():::Returns the number of parties registered at this phaser.:::this.partiesOf
Phaser#getArrivedParties():::Returns the number of registered parties that have arrived at the current phase of this phaser:::this.reconcileState->this.arrivedOf
Phaser#getUnarrivedParties():::Returns the number of registered parties that have not yet arrived at the current phase of this phaser:::this.reconcileState->this.unarrivedOf
Phaser#getParent():::Returns the parent of this phaser, or null if none.:::
Phaser#getRoot():::Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.:::
Phaser#isTerminated():::Returns true if this phaser has been terminated.:::
Phaser#onAdvance(int, int):::Overridable method to perform an action upon impending phase advance, and to control termination:::
Phaser#toString():::Returns a string identifying this phaser, as well as its state:::this.reconcileState->this.stateToString
PriorityBlockingQueue#add(E):::Inserts the specified element into this priority queue.:::this.offer
PriorityBlockingQueue#offer(E):::Inserts the specified element into this priority queue:::lock.lock->this.tryGrow->lock.unlock->this.siftUpUsingComparator->this.siftUpComparable->notEmpty.signal
PriorityBlockingQueue#put(E):::Inserts the specified element into this priority queue:::this.offer
PriorityBlockingQueue#offer(E, long, TimeUnit):::Inserts the specified element into this priority queue:::this.offer
PriorityBlockingQueue#comparator():::Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.:::
PriorityBlockingQueue#remainingCapacity():::Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.:::
PriorityBlockingQueue#remove(Object):::Removes a single instance of the specified element from this queue, if it is present:::lock.lock->lock.unlock->this.indexOf->this.removeAt
PriorityBlockingQueue#removeEq(Object):::Identity-based version for use in Itr.remove.:::lock.lock->lock.unlock->this.removeAt
PriorityBlockingQueue#contains(Object):::Returns true if this queue contains the specified element:::lock.lock->lock.unlock->this.indexOf
PriorityBlockingQueue#clear():::Atomically removes all of the elements from this queue:::lock.lock->lock.unlock
PriorityBlockingQueue#toArray():::Returns an array containing all of the elements in this queue:::lock.lock->lock.unlock->Arrays.copyOf
PriorityBlockingQueue#toArray(T[]):::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array:::lock.lock->lock.unlock->a.getClass->Arrays.copyOf->System.arraycopy
PriorityBlockingQueue#iterator():::Returns an iterator over the elements in this queue:::this.toArray
PriorityBlockingQueue#spliterator():::Returns a Spliterator over the elements in this queue:::
RecursiveAction#compute():::The main computation performed by this task.:::
RecursiveAction#getRawResult():::Always returns null.:::
RecursiveAction#setRawResult(Void):::Requires null completion value.:::
RecursiveAction#exec():::Implements execution conventions for RecursiveActions.:::this.compute
RecursiveTask#compute():::The main computation performed by this task.:::
RecursiveTask#exec():::Implements execution conventions for RecursiveTask.:::this.compute
RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor):::Method that may be invoked by a ThreadPoolExecutor when ThreadPoolExecutor#execute execute cannot accept a task:::
RunnableFuture#run():::Sets this Future to the result of its computation unless it has been cancelled.:::
RunnableScheduledFuture#isPeriodic():::Returns true if this task is periodic:::
ScheduledExecutorService#schedule(Runnable, long, TimeUnit):::Submits a one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#schedule(Callable, long, TimeUnit):::Submits a value-returning one-shot task that becomes enabled after the given delay.:::
ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::
ScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::
ScheduledThreadPoolExecutor#canRunInCurrentRunState(RunnableScheduledFuture):::Returns true if can run a task given current run state and run-after-shutdown parameters.:::this.isShutdown->this.isStopped->task.isPeriodic->task.getDelay
ScheduledThreadPoolExecutor#reExecutePeriodic(RunnableScheduledFuture):::Requeues a periodic task unless current run state precludes it:::this.canRunInCurrentRunState->super.getQueue().add->this.canRunInCurrentRunState->this.remove->this.ensurePrestart->task.cancel
ScheduledThreadPoolExecutor#onShutdown():::Cancels and clears the queue of all tasks that should not be run due to shutdown policy:::super.getQueue->this.getExecuteExistingDelayedTasksAfterShutdownPolicy->this.getContinueExistingPeriodicTasksAfterShutdownPolicy->t.isPeriodic->t.getDelay->t.isCancelled->q.remove->t.cancel->q.toArray->this.tryTerminate
ScheduledThreadPoolExecutor#decorateTask(Runnable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a runnable:::
ScheduledThreadPoolExecutor#decorateTask(Callable, RunnableScheduledFuture):::Modifies or replaces the task used to execute a callable:::
ScheduledThreadPoolExecutor#triggerTime(long):::Returns the nanoTime-based trigger time of a delayed action.:::System.nanoTime->this.overflowFree
ScheduledThreadPoolExecutor#scheduleAtFixedRate(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on:::this.triggerTime->unit.toNanos->sequencer.getAndIncrement->this.decorateTask->this.delayedExecute
ScheduledThreadPoolExecutor#scheduleWithFixedDelay(Runnable, long, long, TimeUnit):::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next:::this.triggerTime->unit.toNanos->sequencer.getAndIncrement->this.decorateTask->this.delayedExecute
ScheduledThreadPoolExecutor#execute(Runnable):::Executes command with zero required delay:::this.schedule
ScheduledThreadPoolExecutor#setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::this.isShutdown->this.onShutdown
ScheduledThreadPoolExecutor#getContinueExistingPeriodicTasksAfterShutdownPolicy():::Gets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown:::
ScheduledThreadPoolExecutor#setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean):::Sets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::this.isShutdown->this.onShutdown
ScheduledThreadPoolExecutor#getExecuteExistingDelayedTasksAfterShutdownPolicy():::Gets the policy on whether to execute existing delayed tasks even when this executor has been shutdown:::
ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean):::Sets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::
ScheduledThreadPoolExecutor#getRemoveOnCancelPolicy():::Gets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation:::
ScheduledThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::super.shutdown
ScheduledThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::super.shutdownNow
ScheduledThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::super.getQueue
Semaphore#acquire():::Acquires a permit from this semaphore, blocking until one is available, or the thread is Thread#interrupt interrupted:::sync.acquireSharedInterruptibly
Semaphore#acquireUninterruptibly():::Acquires a permit from this semaphore, blocking until one is available:::sync.acquireShared
Semaphore#tryAcquire():::Acquires a permit from this semaphore, only if one is available at the time of invocation:::sync.nonfairTryAcquireShared
Semaphore#tryAcquire(long, TimeUnit):::Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::unit.toNanos->sync.tryAcquireSharedNanos
Semaphore#release():::Releases a permit, returning it to the semaphore:::sync.releaseShared
Semaphore#acquire(int):::Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is Thread#interrupt interrupted:::sync.acquireSharedInterruptibly
Semaphore#acquireUninterruptibly(int):::Acquires the given number of permits from this semaphore, blocking until all are available:::sync.acquireShared
Semaphore#tryAcquire(int):::Acquires the given number of permits from this semaphore, only if all are available at the time of invocation:::sync.nonfairTryAcquireShared
Semaphore#tryAcquire(int, long, TimeUnit):::Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been Thread#interrupt interrupted:::unit.toNanos->sync.tryAcquireSharedNanos
Semaphore#release(int):::Releases the given number of permits, returning them to the semaphore:::sync.releaseShared
Semaphore#availablePermits():::Returns the current number of permits available in this semaphore:::sync.getPermits
Semaphore#drainPermits():::Acquires and returns all permits that are immediately available, or if negative permits are available, releases them:::sync.drainPermits
Semaphore#reducePermits(int):::Shrinks the number of available permits by the indicated reduction:::sync.reducePermits
Semaphore#isFair():::Returns true if this semaphore has fairness set true.:::
Semaphore#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::sync.hasQueuedThreads
Semaphore#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::sync.getQueueLength
Semaphore#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::sync.getQueuedThreads
Semaphore#toString():::Returns a string identifying this semaphore, as well as its state:::super.toString->sync.getPermits
SubmissionPublisher#roundCapacity(int):::Round capacity to power of 2, at most limit.:::
SubmissionPublisher#subscribe(Subscriber):::Adds the given Subscriber unless already subscribed:::Thread.currentThread->subscription.onSubscribe->subscription.onComplete->subscription.onError->b.isClosed->subscriber.equals->b.onError
SubmissionPublisher#submit(T):::Publishes the given item to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking uninterruptibly while resources for any subscriber are unavailable:::this.doOffer
SubmissionPublisher#offer(T, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method:::this.doOffer
SubmissionPublisher#offer(T, long, TimeUnit, BiPredicate, ? super T>):::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking while resources for any subscription are unavailable, up to the specified timeout or until the caller thread is interrupted, at which point the given handler (if non-null) is invoked, and if it returns true, retried once:::unit.toNanos->this.doOffer
SubmissionPublisher#close():::Unless already closed, issues Flow.Subscriber#onComplete() onComplete signals to current subscribers, and disallows subsequent attempts to publish:::b.onComplete
SubmissionPublisher#closeExceptionally(Throwable):::Unless already closed, issues Flow.Subscriber#onError(Throwable) onError signals to current subscribers with the given error, and disallows subsequent attempts to publish:::b.onError
SubmissionPublisher#isClosed():::Returns true if this publisher is not accepting submissions.:::
SubmissionPublisher#getClosedException():::Returns the exception associated with #closeExceptionally(Throwable) closeExceptionally, or null if not closed or if closed normally.:::
SubmissionPublisher#hasSubscribers():::Returns true if this publisher has any subscribers.:::b.isClosed
SubmissionPublisher#getNumberOfSubscribers():::Returns the number of current subscribers.:::this.cleanAndCount
SubmissionPublisher#getExecutor():::Returns the Executor used for asynchronous delivery.:::
SubmissionPublisher#getMaxBufferCapacity():::Returns the maximum per-subscriber buffer capacity.:::
SubmissionPublisher#getSubscribers():::Returns a list of current subscribers for monitoring and tracking purposes, not for invoking Flow.Subscriber methods on the subscribers.:::b.isClosed->subs.add
SubmissionPublisher#isSubscribed(Subscriber):::Returns true if the given Subscriber is currently subscribed.:::b.isClosed->subscriber.equals
SubmissionPublisher#estimateMinimumDemand():::Returns an estimate of the minimum number of items requested (via Flow.Subscription#request(long) request) but not yet produced, among all current subscribers.:::b.estimateLag
SubmissionPublisher#estimateMaximumLag():::Returns an estimate of the maximum number of items produced but not yet consumed among all current subscribers.:::b.estimateLag
SubmissionPublisher#consume(Consumer):::Processes all published items using the given Consumer function:::this.subscribe
SubmissionPublisher.BufferedSubscription#isClosed():::Returns true if closed (consumer task may still be running).:::
SubmissionPublisher.BufferedSubscription#estimateLag():::Returns estimated number of buffered items, or negative if closed.:::
SubmissionPublisher.BufferedSubscription#offer(T, boolean):::Tries to add item and start consumer task if necessary.:::QA.setRelease->QA.compareAndSet->this.growAndOffer->this.startOnOffer
SubmissionPublisher.BufferedSubscription#growAndOffer(T, Object[], int):::Tries to expand buffer and add item, returning true on success:::QA.getAndSet->VarHandle.releaseFence
SubmissionPublisher.BufferedSubscription#retryOffer(T):::Version of offer for retries (no resize or bias):::QA.compareAndSet->this.startOnOffer
SubmissionPublisher.BufferedSubscription#startOnOffer(int):::Tries to start consumer task after offer.:::this.getAndBitwiseOrCtl->this.tryStart
SubmissionPublisher.BufferedSubscription#tryStart():::Tries to start consumer task:::this.getAndBitwiseOrCtl->e.execute
SubmissionPublisher.BufferedSubscription#startOnSignal(int):::Sets the given control bits, starting task if not running or closed.:::this.getAndBitwiseOrCtl->this.tryStart
SubmissionPublisher.BufferedSubscription#consume():::Consumer loop, called from ConsumerTask, or indirectly when helping during submit.:::this.subscribeOnOpen->this.takeItems->this.weakCasCtl->this.closeOnComplete->this.weakCasCtl->this.weakCasCtl->this.subtractDemand->this.closeOnError
SubmissionPublisher.BufferedSubscription#takeItems(Subscriber, long, int):::Consumes some items until unavailable or bound or error.:::QA.getAndSet->this.signalWaiter->this.consumeNext
SubmissionPublisher.BufferedSubscription#handleOnNext(Subscriber, Throwable):::Processes exception in Subscriber.onNext.:::h.accept->this.closeOnError
SubmissionPublisher.BufferedSubscription#subscribeOnOpen(Subscriber):::Issues subscriber.onSubscribe if this is first signal.:::this.getAndBitwiseOrCtl->this.consumeSubscribe
SubmissionPublisher.BufferedSubscription#closeOnComplete(Subscriber):::Issues subscriber.onComplete unless already closed.:::this.getAndBitwiseOrCtl->this.consumeComplete
SubmissionPublisher.BufferedSubscription#closeOnError(Subscriber, Throwable):::Issues subscriber.onError, and unblocks producer if needed.:::this.getAndBitwiseOrCtl->this.signalWaiter->this.consumeError
SubmissionPublisher.BufferedSubscription#signalWaiter():::Unblocks waiting producer.:::LockSupport.unpark
SubmissionPublisher.BufferedSubscription#isReleasable():::Returns true if closed or space available:::QA.getAcquire
SubmissionPublisher.BufferedSubscription#awaitSpace(long):::Helps or blocks until timeout, closed, or space available.:::this.isReleasable->ForkJoinPool.helpAsyncBlocker->this.isReleasable->ForkJoinPool.managedBlock->Thread.currentThread().interrupt
SubmissionPublisher.BufferedSubscription#block():::Blocks until closed, space available or timeout:::System.nanoTime->Thread.interrupted->System.nanoTime->LockSupport.park->LockSupport.parkNanos->Thread.currentThread->this.isReleasable
SynchronousQueue.Transferer#transfer(E, boolean, long):::Performs a put or take.:::
SynchronousQueue.TransferStack#isFulfilling(int):::Returns true if m has fulfilling bit set.:::
SynchronousQueue.TransferStack.SNode#tryMatch(SNode):::Tries to match node s to this node, if so, waking up thread:::SMATCH.compareAndSet->LockSupport.unpark
SynchronousQueue.TransferStack.SNode#tryCancel():::Tries to cancel a wait by matching node to itself.:::SMATCH.compareAndSet
SynchronousQueue.TransferStack#snode(SNode, Object, SNode, int):::Creates or resets fields of a node:::
SynchronousQueue.TransferStack#transfer(E, boolean, long):::Puts or takes an item.:::this.isFulfilling->m.tryMatch->h.casNext->this.casHead->this.casHead->h.isCancelled->this.casHead->this.casHead->m.tryMatch->s.casNext->this.casHead->this.casHead->this.casHead->this.awaitFulfill->this.clean->this.casHead->h.isCancelled->this.casHead
SynchronousQueue.TransferStack#awaitFulfill(SNode, boolean, long):::Spins/blocks until node s is matched by a fulfill operation.:::System.nanoTime->Thread.currentThread->this.shouldSpin->w.isInterrupted->s.tryCancel->System.nanoTime->s.tryCancel->LockSupport.parkNanos->LockSupport.park->Thread.onSpinWait->this.shouldSpin
SynchronousQueue.TransferStack#shouldSpin(SNode):::Returns true if node s is at head or there is an active fulfiller.:::this.isFulfilling
SynchronousQueue.TransferStack#clean(SNode):::Unlinks s from the stack.:::past.isCancelled->this.casHead->p.isCancelled->n.isCancelled->p.casNext
SynchronousQueue.TransferQueue.QNode#tryCancel(Object):::Tries to cancel by CAS'ing ref to this as item.:::QITEM.compareAndSet
SynchronousQueue.TransferQueue.QNode#isOffList():::Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.:::
SynchronousQueue.TransferQueue#advanceHead(QNode, QNode):::Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.:::QHEAD.compareAndSet
SynchronousQueue.TransferQueue#advanceTail(QNode, QNode):::Tries to cas nt as new tail.:::QTAIL.compareAndSet
SynchronousQueue.TransferQueue#casCleanMe(QNode, QNode):::Tries to CAS cleanMe slot.:::QCLEANME.compareAndSet
SynchronousQueue.TransferQueue#transfer(E, boolean, long):::Puts or takes an item.:::m.casItem->this.advanceHead->this.advanceHead->LockSupport.unpark->this.advanceTail->t.casNext->this.advanceTail->this.awaitFulfill->this.clean->s.isOffList->this.advanceHead
SynchronousQueue.TransferQueue#awaitFulfill(QNode, E, boolean, long):::Spins/blocks until node s is fulfilled.:::System.nanoTime->Thread.currentThread->w.isInterrupted->s.tryCancel->System.nanoTime->s.tryCancel->LockSupport.parkNanos->LockSupport.park->Thread.onSpinWait
SynchronousQueue.TransferQueue#clean(QNode, QNode):::Gets rid of cancelled node s with original predecessor pred.:::hn.isCancelled->this.advanceHead->this.advanceTail->pred.casNext->this.casCleanMe->d.isCancelled->dp.casNext->this.casCleanMe
SynchronousQueue#put(E):::Adds the specified element to this queue, waiting if necessary for another thread to receive it.:::transferer.transfer->Thread.interrupted
SynchronousQueue#offer(E, long, TimeUnit):::Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.:::unit.toNanos->transferer.transfer->Thread.interrupted
SynchronousQueue#offer(E):::Inserts the specified element into this queue, if another thread is waiting to receive it.:::transferer.transfer
SynchronousQueue#take():::Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.:::transferer.transfer->Thread.interrupted
SynchronousQueue#poll(long, TimeUnit):::Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.:::unit.toNanos->transferer.transfer->Thread.interrupted
SynchronousQueue#poll():::Retrieves and removes the head of this queue, if another thread is currently making an element available.:::transferer.transfer
SynchronousQueue#isEmpty():::Always returns true:::
SynchronousQueue#size():::Always returns zero:::
SynchronousQueue#remainingCapacity():::Always returns zero:::
SynchronousQueue#clear():::Does nothing:::
SynchronousQueue#contains(Object):::Always returns false:::
SynchronousQueue#remove(Object):::Always returns false:::
SynchronousQueue#containsAll(Collection):::Returns false unless the given collection is empty:::c.isEmpty
SynchronousQueue#removeAll(Collection):::Always returns false:::
SynchronousQueue#retainAll(Collection):::Always returns false:::
SynchronousQueue#peek():::Always returns null:::
SynchronousQueue#iterator():::Returns an empty iterator in which hasNext always returns false.:::Collections.emptyIterator
SynchronousQueue#spliterator():::Returns an empty spliterator in which calls to Spliterator#trySplit() trySplit always return null.:::Spliterators.emptySpliterator
SynchronousQueue#toArray():::Returns a zero-length array.:::
SynchronousQueue#toArray(T[]):::Sets the zeroth element of the specified array to null (if the array has non-zero length) and returns it.:::
SynchronousQueue#toString():::Always returns "[]".:::
ThreadFactory#newThread(Runnable):::Constructs a new Thread:::
ThreadLocalRandom#localInit():::Initialize Thread fields for the current thread:::probeGenerator.addAndGet->seeder.getAndAdd->this.mix64->Thread.currentThread->U.putLong->U.putInt
ThreadLocalRandom#current():::Returns the current thread's ThreadLocalRandom.:::Thread.currentThread->U.getInt->this.localInit
ThreadLocalRandom#setSeed(long):::Throws UnsupportedOperationException:::
ThreadLocalRandom#next(int):::Generates a pseudorandom number with the indicated number of low-order bits:::this.nextInt
ThreadLocalRandom#internalNextLong(long, long):::The form of nextLong used by LongStream Spliterators:::this.nextSeed->this.mix64->this.nextSeed->this.mix64->this.nextSeed->this.mix64
ThreadLocalRandom#internalNextInt(int, int):::The form of nextInt used by IntStream Spliterators:::this.nextSeed->this.mix32->this.nextSeed->this.mix32->this.nextSeed->this.mix32
ThreadLocalRandom#internalNextDouble(double, double):::The form of nextDouble used by DoubleStream Spliterators.:::this.nextLong->Double.doubleToLongBits->Double.longBitsToDouble
ThreadLocalRandom#nextInt():::Returns a pseudorandom int value.:::this.nextSeed->this.mix32
ThreadLocalRandom#nextInt(int):::Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).:::this.nextSeed->this.mix32->this.nextSeed->this.mix32
ThreadLocalRandom#nextInt(int, int):::Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).:::this.internalNextInt
ThreadLocalRandom#nextLong():::Returns a pseudorandom long value.:::this.nextSeed->this.mix64
ThreadLocalRandom#nextLong(long):::Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).:::this.nextSeed->this.mix64->this.nextSeed->this.mix64
ThreadLocalRandom#nextLong(long, long):::Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).:::this.internalNextLong
ThreadLocalRandom#nextDouble():::Returns a pseudorandom double value between zero (inclusive) and one (exclusive).:::this.nextSeed->this.mix64
ThreadLocalRandom#nextDouble(double):::Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).:::this.nextSeed->this.mix64->Double.doubleToLongBits->Double.longBitsToDouble
ThreadLocalRandom#nextDouble(double, double):::Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).:::this.internalNextDouble
ThreadLocalRandom#nextBoolean():::Returns a pseudorandom boolean value.:::this.nextSeed->this.mix32
ThreadLocalRandom#nextFloat():::Returns a pseudorandom float value between zero (inclusive) and one (exclusive).:::this.nextSeed->this.mix32
ThreadLocalRandom#ints(long):::Returns a stream producing the given streamSize number of pseudorandom int values.:::StreamSupport.intStream
ThreadLocalRandom#ints():::Returns an effectively unlimited stream of pseudorandom int values.:::StreamSupport.intStream
ThreadLocalRandom#ints(long, int, int):::Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.intStream
ThreadLocalRandom#ints(int, int):::Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.intStream
ThreadLocalRandom#longs(long):::Returns a stream producing the given streamSize number of pseudorandom long values.:::StreamSupport.longStream
ThreadLocalRandom#longs():::Returns an effectively unlimited stream of pseudorandom long values.:::StreamSupport.longStream
ThreadLocalRandom#longs(long, long, long):::Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.longStream
ThreadLocalRandom#longs(long, long):::Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.longStream
ThreadLocalRandom#doubles(long):::Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::StreamSupport.doubleStream
ThreadLocalRandom#doubles():::Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive).:::StreamSupport.doubleStream
ThreadLocalRandom#doubles(long, double, double):::Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.doubleStream
ThreadLocalRandom#doubles(double, double):::Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).:::StreamSupport.doubleStream
ThreadLocalRandom#getProbe():::Returns the probe value for the current thread without forcing initialization:::Thread.currentThread->U.getInt
ThreadLocalRandom#advanceProbe(int):::Pseudo-randomly advances and records the given probe value for the given thread.:::Thread.currentThread->U.putInt
ThreadLocalRandom#nextSecondarySeed():::Returns the pseudo-randomly initialized or updated secondary seed.:::Thread.currentThread->U.getInt->seeder.getAndAdd->this.mix32->U.putInt
ThreadLocalRandom#eraseThreadLocals(Thread):::Erases ThreadLocals by nulling out Thread maps.:::U.putObject->U.putObject
ThreadPoolExecutor#tryTerminate():::Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty):::ctl.get->this.isRunning->this.runStateAtLeast->this.runStateLessThan->workQueue.isEmpty->this.workerCountOf->this.interruptIdleWorkers->mainLock.lock->mainLock.unlock->this.ctlOf->ctl.compareAndSet->this.ctlOf->ctl.set->termination.signalAll->this.terminated
ThreadPoolExecutor#reject(Runnable):::Invokes the rejected execution handler for the given command:::handler.rejectedExecution
ThreadPoolExecutor#onShutdown():::Performs any further cleanup following run state transition on invocation of shutdown:::
ThreadPoolExecutor#runWorker(Worker):::Main worker run loop:::Thread.currentThread->w.unlock->this.processWorkerExit->w.lock->ctl.get->this.runStateAtLeast->Thread.interrupted->ctl.get->this.runStateAtLeast->wt.isInterrupted->wt.interrupt->w.unlock->this.beforeExecute->this.afterExecute->task.run->this.afterExecute->this.getTask
ThreadPoolExecutor#execute(Runnable):::Executes the given task sometime in the future:::ctl.get->this.workerCountOf->this.addWorker->ctl.get->this.isRunning->workQueue.offer->this.addWorker->this.reject->ctl.get->this.isRunning->this.remove->this.workerCountOf->this.addWorker->this.reject
ThreadPoolExecutor#shutdown():::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted:::mainLock.lock->mainLock.unlock->this.checkShutdownAccess->this.advanceRunState->this.interruptIdleWorkers->this.onShutdown->this.tryTerminate
ThreadPoolExecutor#shutdownNow():::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution:::mainLock.lock->mainLock.unlock->this.checkShutdownAccess->this.advanceRunState->this.interruptWorkers->this.drainQueue->this.tryTerminate
ThreadPoolExecutor#isStopped():::Used by ScheduledThreadPoolExecutor.:::ctl.get->this.runStateAtLeast
ThreadPoolExecutor#isTerminating():::Returns true if this executor is in the process of terminating after #shutdown or #shutdownNow but has not completely terminated:::ctl.get->this.runStateAtLeast->this.runStateLessThan
ThreadPoolExecutor#setThreadFactory(ThreadFactory):::Sets the thread factory used to create new threads.:::
ThreadPoolExecutor#getThreadFactory():::Returns the thread factory used to create new threads.:::
ThreadPoolExecutor#setRejectedExecutionHandler(RejectedExecutionHandler):::Sets a new handler for unexecutable tasks.:::
ThreadPoolExecutor#getRejectedExecutionHandler():::Returns the current handler for unexecutable tasks.:::
ThreadPoolExecutor#setCorePoolSize(int):::Sets the core number of threads:::ctl.get->this.workerCountOf->workQueue.size->Math.min->workQueue.isEmpty->this.addWorker->this.interruptIdleWorkers
ThreadPoolExecutor#getCorePoolSize():::Returns the core number of threads.:::
ThreadPoolExecutor#prestartCoreThread():::Starts a core thread, causing it to idly wait for work:::ctl.get->this.workerCountOf->this.addWorker
ThreadPoolExecutor#ensurePrestart():::Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.:::ctl.get->this.workerCountOf->this.addWorker->this.addWorker
ThreadPoolExecutor#prestartAllCoreThreads():::Starts all core threads, causing them to idly wait for work:::this.addWorker
ThreadPoolExecutor#allowsCoreThreadTimeOut():::Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive:::
ThreadPoolExecutor#allowCoreThreadTimeOut(boolean):::Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive:::this.interruptIdleWorkers
ThreadPoolExecutor#setMaximumPoolSize(int):::Sets the maximum allowed number of threads:::ctl.get->this.workerCountOf->this.interruptIdleWorkers
ThreadPoolExecutor#getMaximumPoolSize():::Returns the maximum allowed number of threads.:::
ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit):::Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::this.allowsCoreThreadTimeOut->unit.toNanos->this.interruptIdleWorkers
ThreadPoolExecutor#getKeepAliveTime(TimeUnit):::Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated:::unit.convert
ThreadPoolExecutor#getQueue():::Returns the task queue used by this executor:::
ThreadPoolExecutor#remove(Runnable):::Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started:::workQueue.remove->this.tryTerminate
ThreadPoolExecutor#purge():::Tries to remove from the work queue all Future tasks that have been cancelled:::((Future<?>) r).isCancelled->q.remove->q.toArray->q.iterator->it.next->((Future<?>) r).isCancelled->it.remove->it.hasNext->this.tryTerminate
ThreadPoolExecutor#getPoolSize():::Returns the current number of threads in the pool.:::mainLock.lock->mainLock.unlock->ctl.get->this.runStateAtLeast->workers.size
ThreadPoolExecutor#getActiveCount():::Returns the approximate number of threads that are actively executing tasks.:::mainLock.lock->mainLock.unlock->w.isLocked
ThreadPoolExecutor#getLargestPoolSize():::Returns the largest number of threads that have ever simultaneously been in the pool.:::mainLock.lock->mainLock.unlock
ThreadPoolExecutor#getTaskCount():::Returns the approximate total number of tasks that have ever been scheduled for execution:::mainLock.lock->mainLock.unlock->w.isLocked->workQueue.size
ThreadPoolExecutor#getCompletedTaskCount():::Returns the approximate total number of tasks that have completed execution:::mainLock.lock->mainLock.unlock
ThreadPoolExecutor#toString():::Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.:::mainLock.lock->mainLock.unlock->workers.size->w.isLocked->ctl.get->this.isRunning->this.runStateAtLeast->super.toString->workQueue.size
ThreadPoolExecutor#beforeExecute(Thread, Runnable):::Method invoked prior to executing the given Runnable in the given thread:::
ThreadPoolExecutor#afterExecute(Runnable, Throwable):::Method invoked upon completion of execution of the given Runnable:::
ThreadPoolExecutor#terminated():::Method invoked when the Executor has terminated:::
ThreadPoolExecutor.CallerRunsPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.:::e.isShutdown->r.run
ThreadPoolExecutor.AbortPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Always throws RejectedExecutionException.:::r.toString->e.toString
ThreadPoolExecutor.DiscardPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Does nothing, which has the effect of discarding task r.:::
ThreadPoolExecutor.DiscardOldestPolicy#rejectedExecution(Runnable, ThreadPoolExecutor):::Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.:::e.isShutdown->e.getQueue().poll->e.execute
TransferQueue#tryTransfer(E):::Transfers the element to a waiting consumer immediately, if possible:::
TransferQueue#transfer(E):::Transfers the element to a consumer, waiting if necessary to do so:::
TransferQueue#tryTransfer(E, long, TimeUnit):::Transfers the element to a consumer if it is possible to do so before the timeout elapses:::
TransferQueue#hasWaitingConsumer():::Returns true if there is at least one consumer waiting to receive an element via #take or timed #poll(long,TimeUnit) poll:::
TransferQueue#getWaitingConsumerCount():::Returns an estimate of the number of consumers waiting to receive elements via #take or timed #poll(long,TimeUnit) poll:::
