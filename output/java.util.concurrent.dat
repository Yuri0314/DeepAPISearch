java.util.concurrent.AbstractExecutorService#newTaskFor(Runnable, T)->RunnableFuture:::Returns a RunnableFuture for the given runnable and default value.
java.util.concurrent.AbstractExecutorService#newTaskFor(Callable)->RunnableFuture:::Returns a RunnableFuture for the given callable task.
java.util.concurrent.AbstractExecutorService#submit(Runnable)->Future::: abstract executor service submit
java.util.concurrent.AbstractExecutorService#submit(Runnable, T)->Future::: abstract executor service submit
java.util.concurrent.AbstractExecutorService#submit(Callable)->Future::: abstract executor service submit
java.util.concurrent.AbstractExecutorService#invokeAny(Collection>)->T::: abstract executor service invoke any
java.util.concurrent.AbstractExecutorService#invokeAny(Collection>, long, TimeUnit)->T::: abstract executor service invoke any
java.util.concurrent.AbstractExecutorService#invokeAll(Collection>)->List>::: abstract executor service invoke all
java.util.concurrent.AbstractExecutorService#invokeAll(Collection>, long, TimeUnit)->List>::: abstract executor service invoke all
java.util.concurrent.ArrayBlockingQueue#inc(int, int)->int:::Increments i, mod modulus
java.util.concurrent.ArrayBlockingQueue#dec(int, int)->int:::Decrements i, mod modulus
java.util.concurrent.ArrayBlockingQueue#itemAt(int)->E:::Returns item at index i.
java.util.concurrent.ArrayBlockingQueue#itemAt(Object[], int)->E:::Returns element at array index i
java.util.concurrent.ArrayBlockingQueue#removeAt(int)->void:::Deletes item at array index removeIndex
java.util.concurrent.ArrayBlockingQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.
java.util.concurrent.ArrayBlockingQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full
java.util.concurrent.ArrayBlockingQueue#put(E)->void:::Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue#poll()->E::: array blocking queue poll
java.util.concurrent.ArrayBlockingQueue#take()->E::: array blocking queue take
java.util.concurrent.ArrayBlockingQueue#poll(long, TimeUnit)->E::: array blocking queue poll
java.util.concurrent.ArrayBlockingQueue#peek()->E::: array blocking queue peek
java.util.concurrent.ArrayBlockingQueue#size()->int:::Returns the number of elements in this queue.
java.util.concurrent.ArrayBlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking
java.util.concurrent.ArrayBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.ArrayBlockingQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.ArrayBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in proper sequence
java.util.concurrent.ArrayBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array
java.util.concurrent.ArrayBlockingQueue#toString()->String::: array blocking queue to string
java.util.concurrent.ArrayBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.ArrayBlockingQueue#drainTo(Collection)->int::: array blocking queue drain to
java.util.concurrent.ArrayBlockingQueue#drainTo(Collection, int)->int::: array blocking queue drain to
java.util.concurrent.ArrayBlockingQueue#iterator()->Iterator:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.ArrayBlockingQueue.Itrs#doSomeSweeping(boolean)->void:::Sweeps itrs, looking for and expunging stale iterators
java.util.concurrent.ArrayBlockingQueue.Itrs#register(Itr)->void:::Adds a new iterator to the linked list of tracked iterators.
java.util.concurrent.ArrayBlockingQueue.Itrs#takeIndexWrapped()->void:::Called whenever takeIndex wraps around to 0
java.util.concurrent.ArrayBlockingQueue.Itrs#removedAt(int)->void:::Called whenever an interior remove (not at takeIndex) occurred
java.util.concurrent.ArrayBlockingQueue.Itrs#queueIsEmpty()->void:::Called whenever the queue becomes empty
java.util.concurrent.ArrayBlockingQueue.Itrs#elementDequeued()->void:::Called whenever an element has been dequeued (at takeIndex).
java.util.concurrent.ArrayBlockingQueue#spliterator()->Spliterator:::Returns a Spliterator over the elements in this queue
java.util.concurrent.ArrayBlockingQueue#forEach(Consumer)->void::: array blocking queue for each
java.util.concurrent.ArrayBlockingQueue#removeIf(Predicate)->boolean::: array blocking queue remove if
java.util.concurrent.ArrayBlockingQueue#removeAll(Collection)->boolean::: array blocking queue remove all
java.util.concurrent.ArrayBlockingQueue#retainAll(Collection)->boolean::: array blocking queue retain all
java.util.concurrent.ArrayBlockingQueue#checkInvariants()->void:::debugging
java.util.concurrent.BlockingDeque#addFirst(E)->void:::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available
java.util.concurrent.BlockingDeque#addLast(E)->void:::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available
java.util.concurrent.BlockingDeque#offerFirst(E)->boolean:::Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available
java.util.concurrent.BlockingDeque#offerLast(E)->boolean:::Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available
java.util.concurrent.BlockingDeque#putFirst(E)->void:::Inserts the specified element at the front of this deque, waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque#putLast(E)->void:::Inserts the specified element at the end of this deque, waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque#offerFirst(E, long, TimeUnit)->boolean:::Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingDeque#offerLast(E, long, TimeUnit)->boolean:::Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingDeque#takeFirst()->E:::Retrieves and removes the first element of this deque, waiting if necessary until an element becomes available.
java.util.concurrent.BlockingDeque#takeLast()->E:::Retrieves and removes the last element of this deque, waiting if necessary until an element becomes available.
java.util.concurrent.BlockingDeque#pollFirst(long, TimeUnit)->E:::Retrieves and removes the first element of this deque, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingDeque#pollLast(long, TimeUnit)->E:::Retrieves and removes the last element of this deque, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingDeque#removeFirstOccurrence(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#removeLastOccurrence(Object)->boolean:::Removes the last occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#add(E)->boolean:::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available
java.util.concurrent.BlockingDeque#offer(E)->boolean:::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available
java.util.concurrent.BlockingDeque#put(E)->void:::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available
java.util.concurrent.BlockingDeque#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available
java.util.concurrent.BlockingDeque#remove()->E:::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque)
java.util.concurrent.BlockingDeque#poll()->E:::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty
java.util.concurrent.BlockingDeque#take()->E:::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting if necessary until an element becomes available
java.util.concurrent.BlockingDeque#poll(long, TimeUnit)->E:::Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting up to the specified wait time if necessary for an element to become available
java.util.concurrent.BlockingDeque#element()->E:::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque)
java.util.concurrent.BlockingDeque#peek()->E:::Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty
java.util.concurrent.BlockingDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.BlockingDeque#contains(Object)->boolean:::Returns true if this deque contains the specified element
java.util.concurrent.BlockingDeque#size()->int:::Returns the number of elements in this deque.
java.util.concurrent.BlockingDeque#iterator()->Iterator:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.BlockingDeque#push(E)->void:::Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available
java.util.concurrent.BlockingQueue#add(E)->boolean:::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available
java.util.concurrent.BlockingQueue#offer(E)->boolean:::Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available
java.util.concurrent.BlockingQueue#put(E)->void:::Inserts the specified element into this queue, waiting if necessary for space to become available.
java.util.concurrent.BlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
java.util.concurrent.BlockingQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit
java.util.concurrent.BlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.BlockingQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.BlockingQueue#drainTo(Collection)->int:::Removes all available elements from this queue and adds them to the given collection
java.util.concurrent.BlockingQueue#drainTo(Collection, int)->int:::Removes at most the given number of available elements from this queue and adds them to the given collection
java.util.concurrent.Callable#call()->V:::Computes a result, or throws an exception if unable to do so.
java.util.concurrent.CompletableFuture#internalComplete(Object)->boolean::: completable future internal complete
java.util.concurrent.CompletableFuture#tryPushStack(Completion)->boolean:::Returns true if successfully pushed c onto stack.
java.util.concurrent.CompletableFuture#pushStack(Completion)->void:::Unconditionally pushes c onto stack, retrying if necessary.
java.util.concurrent.CompletableFuture#completeNull()->boolean:::Completes with the null value, unless already completed.
java.util.concurrent.CompletableFuture#encodeValue(T)->Object:::Returns the encoding of the given non-exceptional value.
java.util.concurrent.CompletableFuture#completeValue(T)->boolean:::Completes with a non-exceptional result, unless already completed.
java.util.concurrent.CompletableFuture#encodeThrowable(Throwable)->AltResult:::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already.
java.util.concurrent.CompletableFuture#completeThrowable(Throwable)->boolean:::Completes with an exceptional result, unless already completed.
java.util.concurrent.CompletableFuture#encodeThrowable(Throwable, Object)->Object:::Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already
java.util.concurrent.CompletableFuture#completeThrowable(Throwable, Object)->boolean:::Completes with the given (non-null) exceptional result as a wrapped CompletionException unless it is one already, unless already completed
java.util.concurrent.CompletableFuture#encodeOutcome(T, Throwable)->Object:::Returns the encoding of the given arguments: if the exception is non-null, encodes as AltResult
java.util.concurrent.CompletableFuture#encodeRelay(Object)->Object:::Returns the encoding of a copied outcome; if exceptional, rewraps as a CompletionException, else returns argument.
java.util.concurrent.CompletableFuture#completeRelay(Object)->boolean:::Completes with r or a copy of r, unless already completed
java.util.concurrent.CompletableFuture.ThreadPerTaskExecutor#execute(Runnable)->void::: thread per task executor execute
java.util.concurrent.CompletableFuture#screenExecutor(Executor)->Executor:::Null-checks user executor argument, and translates uses of commonPool to ASYNC_POOL in case parallelism disabled.
java.util.concurrent.CompletableFuture.Completion#tryFire(int)->CompletableFuture:::Performs completion action if triggered, returning a dependent that may need propagation, if one exists.
java.util.concurrent.CompletableFuture.Completion#isLive()->boolean:::Returns true if possibly still triggerable
java.util.concurrent.CompletableFuture.Completion#run()->void::: completion run
java.util.concurrent.CompletableFuture.Completion#exec()->boolean::: completion exec
java.util.concurrent.CompletableFuture.Completion#getRawResult()->Void::: completion get raw result
java.util.concurrent.CompletableFuture.Completion#setRawResult(Void)->void::: completion set raw result
java.util.concurrent.CompletableFuture#postComplete()->void:::Pops and tries to trigger all reachable dependents
java.util.concurrent.CompletableFuture#cleanStack()->void:::Traverses stack and unlinks one or more dead Completions, if found.
java.util.concurrent.CompletableFuture.UniCompletion#claim()->boolean:::Returns true if action can be run
java.util.concurrent.CompletableFuture.UniCompletion#isLive()->boolean::: uni completion is live
java.util.concurrent.CompletableFuture#unipush(Completion)->void:::Pushes the given completion unless it completes while trying
java.util.concurrent.CompletableFuture#postFire(CompletableFuture, int)->CompletableFuture:::Post-processing by dependent after successful UniCompletion tryFire
java.util.concurrent.CompletableFuture.UniApply#tryFire(int)->CompletableFuture::: uni apply try fire
java.util.concurrent.CompletableFuture.UniAccept#tryFire(int)->CompletableFuture::: uni accept try fire
java.util.concurrent.CompletableFuture.UniRun#tryFire(int)->CompletableFuture::: uni run try fire
java.util.concurrent.CompletableFuture.UniWhenComplete#tryFire(int)->CompletableFuture::: uni when complete try fire
java.util.concurrent.CompletableFuture#uniWhenComplete(Object, BiConsumer, UniWhenComplete)->boolean::: completable future uni when complete
java.util.concurrent.CompletableFuture.UniHandle#tryFire(int)->CompletableFuture::: uni handle try fire
java.util.concurrent.CompletableFuture#uniHandle(Object, BiFunction, UniHandle)->boolean::: completable future uni handle
java.util.concurrent.CompletableFuture.UniExceptionally#tryFire(int)->CompletableFuture::: uni exceptionally try fire
java.util.concurrent.CompletableFuture#uniExceptionally(Object, Function, UniExceptionally)->boolean::: completable future uni exceptionally
java.util.concurrent.CompletableFuture.UniRelay#tryFire(int)->CompletableFuture::: uni relay try fire
java.util.concurrent.CompletableFuture.UniCompose#tryFire(int)->CompletableFuture::: uni compose try fire
java.util.concurrent.CompletableFuture.CoCompletion#tryFire(int)->CompletableFuture::: co completion try fire
java.util.concurrent.CompletableFuture.CoCompletion#isLive()->boolean::: co completion is live
java.util.concurrent.CompletableFuture#bipush(CompletableFuture, BiCompletion)->void:::Pushes completion to this and b unless both done
java.util.concurrent.CompletableFuture#postFire(CompletableFuture, CompletableFuture, int)->CompletableFuture:::Post-processing after successful BiCompletion tryFire.
java.util.concurrent.CompletableFuture.BiApply#tryFire(int)->CompletableFuture::: bi apply try fire
java.util.concurrent.CompletableFuture#biApply(Object, Object, BiFunction, BiApply)->boolean::: completable future bi apply
java.util.concurrent.CompletableFuture.BiAccept#tryFire(int)->CompletableFuture::: bi accept try fire
java.util.concurrent.CompletableFuture#biAccept(Object, Object, BiConsumer, BiAccept)->boolean::: completable future bi accept
java.util.concurrent.CompletableFuture.BiRun#tryFire(int)->CompletableFuture::: bi run try fire
java.util.concurrent.CompletableFuture#biRun(Object, Object, Runnable, BiRun)->boolean::: completable future bi run
java.util.concurrent.CompletableFuture.BiRelay#tryFire(int)->CompletableFuture::: bi relay try fire
java.util.concurrent.CompletableFuture#andTree(CompletableFuture[], int, int)->CompletableFuture:::Recursively constructs a tree of completions.
java.util.concurrent.CompletableFuture#orpush(CompletableFuture, BiCompletion)->void:::Pushes completion to this and b unless either done
java.util.concurrent.CompletableFuture.OrApply#tryFire(int)->CompletableFuture::: or apply try fire
java.util.concurrent.CompletableFuture.OrAccept#tryFire(int)->CompletableFuture::: or accept try fire
java.util.concurrent.CompletableFuture.OrRun#tryFire(int)->CompletableFuture::: or run try fire
java.util.concurrent.CompletableFuture.AnyOf#tryFire(int)->CompletableFuture::: any of try fire
java.util.concurrent.CompletableFuture.AnyOf#isLive()->boolean::: any of is live
java.util.concurrent.CompletableFuture.AsyncSupply#getRawResult()->Void::: async supply get raw result
java.util.concurrent.CompletableFuture.AsyncSupply#setRawResult(Void)->void::: async supply set raw result
java.util.concurrent.CompletableFuture.AsyncSupply#exec()->boolean::: async supply exec
java.util.concurrent.CompletableFuture.AsyncSupply#run()->void::: async supply run
java.util.concurrent.CompletableFuture#asyncSupplyStage(Executor, Supplier)->CompletableFuture::: completable future async supply stage
java.util.concurrent.CompletableFuture.AsyncRun#getRawResult()->Void::: async run get raw result
java.util.concurrent.CompletableFuture.AsyncRun#setRawResult(Void)->void::: async run set raw result
java.util.concurrent.CompletableFuture.AsyncRun#exec()->boolean::: async run exec
java.util.concurrent.CompletableFuture.AsyncRun#run()->void::: async run run
java.util.concurrent.CompletableFuture#asyncRunStage(Executor, Runnable)->CompletableFuture::: completable future async run stage
java.util.concurrent.CompletableFuture.Signaller#tryFire(int)->CompletableFuture::: signaller try fire
java.util.concurrent.CompletableFuture.Signaller#isReleasable()->boolean::: signaller is releasable
java.util.concurrent.CompletableFuture.Signaller#block()->boolean::: signaller block
java.util.concurrent.CompletableFuture.Signaller#isLive()->boolean::: signaller is live
java.util.concurrent.CompletableFuture#supplyAsync(Supplier)->CompletableFuture:::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() with the value obtained by calling the given Supplier.
java.util.concurrent.CompletableFuture#supplyAsync(Supplier, Executor)->CompletableFuture:::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.
java.util.concurrent.CompletableFuture#runAsync(Runnable)->CompletableFuture:::Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool#commonPool() after it runs the given action.
java.util.concurrent.CompletableFuture#runAsync(Runnable, Executor)->CompletableFuture:::Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor after it runs the given action.
java.util.concurrent.CompletableFuture#completedFuture(U)->CompletableFuture:::Returns a new CompletableFuture that is already completed with the given value.
java.util.concurrent.CompletableFuture#isDone()->boolean:::Returns true if completed in any fashion: normally, exceptionally, or via cancellation.
java.util.concurrent.CompletableFuture#get()->T:::Waits if necessary for this future to complete, and then returns its result.
java.util.concurrent.CompletableFuture#get(long, TimeUnit)->T:::Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.
java.util.concurrent.CompletableFuture#join()->T:::Returns the result value when complete, or throws an (unchecked) exception if completed exceptionally
java.util.concurrent.CompletableFuture#getNow(T)->T:::Returns the result value (or throws any encountered exception) if completed, else returns the given valueIfAbsent.
java.util.concurrent.CompletableFuture#complete(T)->boolean:::If not already completed, sets the value returned by #get() and related methods to the given value.
java.util.concurrent.CompletableFuture#completeExceptionally(Throwable)->boolean:::If not already completed, causes invocations of #get() and related methods to throw the given exception.
java.util.concurrent.CompletableFuture#thenApply(Function)->CompletableFuture::: completable future then apply
java.util.concurrent.CompletableFuture#thenApplyAsync(Function)->CompletableFuture::: completable future then apply async
java.util.concurrent.CompletableFuture#thenApplyAsync(Function, Executor)->CompletableFuture::: completable future then apply async
java.util.concurrent.CompletableFuture#thenAccept(Consumer)->CompletableFuture::: completable future then accept
java.util.concurrent.CompletableFuture#thenAcceptAsync(Consumer)->CompletableFuture::: completable future then accept async
java.util.concurrent.CompletableFuture#thenAcceptAsync(Consumer, Executor)->CompletableFuture::: completable future then accept async
java.util.concurrent.CompletableFuture#thenRun(Runnable)->CompletableFuture::: completable future then run
java.util.concurrent.CompletableFuture#thenRunAsync(Runnable)->CompletableFuture::: completable future then run async
java.util.concurrent.CompletableFuture#thenRunAsync(Runnable, Executor)->CompletableFuture::: completable future then run async
java.util.concurrent.CompletableFuture#thenCombine(CompletionStage, BiFunction)->CompletableFuture::: completable future then combine
java.util.concurrent.CompletableFuture#thenCombineAsync(CompletionStage, BiFunction)->CompletableFuture::: completable future then combine async
java.util.concurrent.CompletableFuture#thenCombineAsync(CompletionStage, BiFunction, Executor)->CompletableFuture::: completable future then combine async
java.util.concurrent.CompletableFuture#thenAcceptBoth(CompletionStage, BiConsumer)->CompletableFuture::: completable future then accept both
java.util.concurrent.CompletableFuture#thenAcceptBothAsync(CompletionStage, BiConsumer)->CompletableFuture::: completable future then accept both async
java.util.concurrent.CompletableFuture#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor)->CompletableFuture::: completable future then accept both async
java.util.concurrent.CompletableFuture#runAfterBoth(CompletionStage, Runnable)->CompletableFuture::: completable future run after both
java.util.concurrent.CompletableFuture#runAfterBothAsync(CompletionStage, Runnable)->CompletableFuture::: completable future run after both async
java.util.concurrent.CompletableFuture#runAfterBothAsync(CompletionStage, Runnable, Executor)->CompletableFuture::: completable future run after both async
java.util.concurrent.CompletableFuture#applyToEither(CompletionStage, Function)->CompletableFuture::: completable future apply to either
java.util.concurrent.CompletableFuture#applyToEitherAsync(CompletionStage, Function)->CompletableFuture::: completable future apply to either async
java.util.concurrent.CompletableFuture#applyToEitherAsync(CompletionStage, Function, Executor)->CompletableFuture::: completable future apply to either async
java.util.concurrent.CompletableFuture#acceptEither(CompletionStage, Consumer)->CompletableFuture::: completable future accept either
java.util.concurrent.CompletableFuture#acceptEitherAsync(CompletionStage, Consumer)->CompletableFuture::: completable future accept either async
java.util.concurrent.CompletableFuture#acceptEitherAsync(CompletionStage, Consumer, Executor)->CompletableFuture::: completable future accept either async
java.util.concurrent.CompletableFuture#runAfterEither(CompletionStage, Runnable)->CompletableFuture::: completable future run after either
java.util.concurrent.CompletableFuture#runAfterEitherAsync(CompletionStage, Runnable)->CompletableFuture::: completable future run after either async
java.util.concurrent.CompletableFuture#runAfterEitherAsync(CompletionStage, Runnable, Executor)->CompletableFuture::: completable future run after either async
java.util.concurrent.CompletableFuture#thenCompose(Function>)->CompletableFuture::: completable future then compose
java.util.concurrent.CompletableFuture#thenComposeAsync(Function>)->CompletableFuture::: completable future then compose async
java.util.concurrent.CompletableFuture#thenComposeAsync(Function>, Executor)->CompletableFuture::: completable future then compose async
java.util.concurrent.CompletableFuture#whenComplete(BiConsumer)->CompletableFuture::: completable future when complete
java.util.concurrent.CompletableFuture#whenCompleteAsync(BiConsumer)->CompletableFuture::: completable future when complete async
java.util.concurrent.CompletableFuture#whenCompleteAsync(BiConsumer, Executor)->CompletableFuture::: completable future when complete async
java.util.concurrent.CompletableFuture#handle(BiFunction)->CompletableFuture::: completable future handle
java.util.concurrent.CompletableFuture#handleAsync(BiFunction)->CompletableFuture::: completable future handle async
java.util.concurrent.CompletableFuture#handleAsync(BiFunction, Executor)->CompletableFuture::: completable future handle async
java.util.concurrent.CompletableFuture#toCompletableFuture()->CompletableFuture:::Returns this CompletableFuture.
java.util.concurrent.CompletableFuture#exceptionally(Function)->CompletableFuture:::Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value
java.util.concurrent.CompletableFuture#allOf(CompletableFuture...)->CompletableFuture:::Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete
java.util.concurrent.CompletableFuture#anyOf(CompletableFuture...)->CompletableFuture:::Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result
java.util.concurrent.CompletableFuture#cancel(boolean)->boolean:::If not already completed, completes this CompletableFuture with a CancellationException
java.util.concurrent.CompletableFuture#isCancelled()->boolean:::Returns true if this CompletableFuture was cancelled before it completed normally.
java.util.concurrent.CompletableFuture#isCompletedExceptionally()->boolean:::Returns true if this CompletableFuture completed exceptionally, in any way
java.util.concurrent.CompletableFuture#obtrudeValue(T)->void:::Forcibly sets or resets the value subsequently returned by method #get() and related methods, whether or not already completed
java.util.concurrent.CompletableFuture#obtrudeException(Throwable)->void:::Forcibly causes subsequent invocations of method #get() and related methods to throw the given exception, whether or not already completed
java.util.concurrent.CompletableFuture#getNumberOfDependents()->int:::Returns the estimated number of CompletableFutures whose completions are awaiting completion of this CompletableFuture
java.util.concurrent.CompletableFuture#toString()->String:::Returns a string identifying this CompletableFuture, as well as its completion state
java.util.concurrent.CompletableFuture#newIncompleteFuture()->CompletableFuture:::Returns a new incomplete CompletableFuture of the type to be returned by a CompletionStage method
java.util.concurrent.CompletableFuture#defaultExecutor()->Executor:::Returns the default Executor used for async methods that do not specify an Executor
java.util.concurrent.CompletableFuture#copy()->CompletableFuture:::Returns a new CompletableFuture that is completed normally with the same value as this CompletableFuture when it completes normally
java.util.concurrent.CompletableFuture#minimalCompletionStage()->CompletionStage:::Returns a new CompletionStage that is completed normally with the same value as this CompletableFuture when it completes normally, and cannot be independently completed or otherwise used in ways not defined by the methods of interface CompletionStage
java.util.concurrent.CompletableFuture#completeAsync(Supplier, Executor)->CompletableFuture:::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the given executor.
java.util.concurrent.CompletableFuture#completeAsync(Supplier)->CompletableFuture:::Completes this CompletableFuture with the result of the given Supplier function invoked from an asynchronous task using the default executor.
java.util.concurrent.CompletableFuture#orTimeout(long, TimeUnit)->CompletableFuture:::Exceptionally completes this CompletableFuture with a TimeoutException if not otherwise completed before the given timeout.
java.util.concurrent.CompletableFuture#completeOnTimeout(T, long, TimeUnit)->CompletableFuture:::Completes this CompletableFuture with the given value if not otherwise completed before the given timeout.
java.util.concurrent.CompletableFuture#delayedExecutor(long, TimeUnit, Executor)->Executor:::Returns a new Executor that submits a task to the given base executor after the given delay (or no delay if non-positive)
java.util.concurrent.CompletableFuture#delayedExecutor(long, TimeUnit)->Executor:::Returns a new Executor that submits a task to the default executor after the given delay (or no delay if non-positive)
java.util.concurrent.CompletableFuture#completedStage(U)->CompletionStage:::Returns a new CompletionStage that is already completed with the given value and supports only those methods in interface CompletionStage.
java.util.concurrent.CompletableFuture#failedFuture(Throwable)->CompletableFuture:::Returns a new CompletableFuture that is already completed exceptionally with the given exception.
java.util.concurrent.CompletableFuture#failedStage(Throwable)->CompletionStage:::Returns a new CompletionStage that is already completed exceptionally with the given exception and supports only those methods in interface CompletionStage.
java.util.concurrent.CompletableFuture.Delayer#delay(Runnable, long, TimeUnit)->ScheduledFuture::: delayer delay
java.util.concurrent.CompletableFuture.Delayer.DaemonThreadFactory#newThread(Runnable)->Thread::: daemon thread factory new thread
java.util.concurrent.CompletableFuture.DelayedExecutor#execute(Runnable)->void::: delayed executor execute
java.util.concurrent.CompletableFuture.TaskSubmitter#run()->void::: task submitter run
java.util.concurrent.CompletableFuture.Timeout#run()->void::: timeout run
java.util.concurrent.CompletableFuture.DelayedCompleter#run()->void::: delayed completer run
java.util.concurrent.CompletableFuture.Canceller#accept(Object, Throwable)->void::: canceller accept
java.util.concurrent.CompletableFuture.MinimalStage#newIncompleteFuture()->CompletableFuture::: minimal stage new incomplete future
java.util.concurrent.CompletableFuture.MinimalStage#get()->T::: minimal stage get
java.util.concurrent.CompletableFuture.MinimalStage#get(long, TimeUnit)->T::: minimal stage get
java.util.concurrent.CompletableFuture.MinimalStage#getNow(T)->T::: minimal stage get now
java.util.concurrent.CompletableFuture.MinimalStage#join()->T::: minimal stage join
java.util.concurrent.CompletableFuture.MinimalStage#complete(T)->boolean::: minimal stage complete
java.util.concurrent.CompletableFuture.MinimalStage#completeExceptionally(Throwable)->boolean::: minimal stage complete exceptionally
java.util.concurrent.CompletableFuture.MinimalStage#cancel(boolean)->boolean::: minimal stage cancel
java.util.concurrent.CompletableFuture.MinimalStage#obtrudeValue(T)->void::: minimal stage obtrude value
java.util.concurrent.CompletableFuture.MinimalStage#obtrudeException(Throwable)->void::: minimal stage obtrude exception
java.util.concurrent.CompletableFuture.MinimalStage#isDone()->boolean::: minimal stage is done
java.util.concurrent.CompletableFuture.MinimalStage#isCancelled()->boolean::: minimal stage is cancelled
java.util.concurrent.CompletableFuture.MinimalStage#isCompletedExceptionally()->boolean::: minimal stage is completed exceptionally
java.util.concurrent.CompletableFuture.MinimalStage#getNumberOfDependents()->int::: minimal stage get number of dependents
java.util.concurrent.CompletableFuture.MinimalStage#completeAsync(Supplier, Executor)->CompletableFuture::: minimal stage complete async
java.util.concurrent.CompletableFuture.MinimalStage#completeAsync(Supplier)->CompletableFuture::: minimal stage complete async
java.util.concurrent.CompletableFuture.MinimalStage#orTimeout(long, TimeUnit)->CompletableFuture::: minimal stage or timeout
java.util.concurrent.CompletableFuture.MinimalStage#completeOnTimeout(T, long, TimeUnit)->CompletableFuture::: minimal stage complete on timeout
java.util.concurrent.CompletableFuture.MinimalStage#toCompletableFuture()->CompletableFuture::: minimal stage to completable future
java.util.concurrent.CompletionService#submit(Callable)->Future:::Submits a value-returning task for execution and returns a Future representing the pending results of the task
java.util.concurrent.CompletionService#submit(Runnable, V)->Future:::Submits a Runnable task for execution and returns a Future representing that task
java.util.concurrent.CompletionService#take()->Future:::Retrieves and removes the Future representing the next completed task, waiting if none are yet present.
java.util.concurrent.CompletionService#poll()->Future:::Retrieves and removes the Future representing the next completed task, or null if none are present.
java.util.concurrent.CompletionService#poll(long, TimeUnit)->Future:::Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.
java.util.concurrent.CompletionStage#thenApply(Function)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function
java.util.concurrent.CompletionStage#thenApplyAsync(Function)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied function
java.util.concurrent.CompletionStage#thenApplyAsync(Function, Executor)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function
java.util.concurrent.CompletionStage#thenAccept(Consumer)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied action
java.util.concurrent.CompletionStage#thenAcceptAsync(Consumer)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied action
java.util.concurrent.CompletionStage#thenAcceptAsync(Consumer, Executor)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied action
java.util.concurrent.CompletionStage#thenRun(Runnable)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, executes the given action
java.util.concurrent.CompletionStage#thenRunAsync(Runnable)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, executes the given action using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#thenRunAsync(Runnable, Executor)->CompletionStage:::Returns a new CompletionStage that, when this stage completes normally, executes the given action using the supplied Executor
java.util.concurrent.CompletionStage#thenCombine(CompletionStage, BiFunction)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function
java.util.concurrent.CompletionStage#thenCombineAsync(CompletionStage, BiFunction)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied function
java.util.concurrent.CompletionStage#thenCombineAsync(CompletionStage, BiFunction, Executor)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function
java.util.concurrent.CompletionStage#thenAcceptBoth(CompletionStage, BiConsumer)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied action
java.util.concurrent.CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied action
java.util.concurrent.CompletionStage#thenAcceptBothAsync(CompletionStage, BiConsumer, Executor)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed using the supplied executor, with the two results as arguments to the supplied action
java.util.concurrent.CompletionStage#runAfterBoth(CompletionStage, Runnable)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action
java.util.concurrent.CompletionStage#runAfterBothAsync(CompletionStage, Runnable)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#runAfterBothAsync(CompletionStage, Runnable, Executor)->CompletionStage:::Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action using the supplied executor
java.util.concurrent.CompletionStage#applyToEither(CompletionStage, Function)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied function
java.util.concurrent.CompletionStage#applyToEitherAsync(CompletionStage, Function)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied function
java.util.concurrent.CompletionStage#applyToEitherAsync(CompletionStage, Function, Executor)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function
java.util.concurrent.CompletionStage#acceptEither(CompletionStage, Consumer)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied action
java.util.concurrent.CompletionStage#acceptEitherAsync(CompletionStage, Consumer)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied action
java.util.concurrent.CompletionStage#acceptEitherAsync(CompletionStage, Consumer, Executor)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied action
java.util.concurrent.CompletionStage#runAfterEither(CompletionStage, Runnable)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action
java.util.concurrent.CompletionStage#runAfterEitherAsync(CompletionStage, Runnable)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#runAfterEitherAsync(CompletionStage, Runnable, Executor)->CompletionStage:::Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using the supplied executor
java.util.concurrent.CompletionStage#thenCompose(Function>)->CompletionStage:::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function
java.util.concurrent.CompletionStage#thenComposeAsync(Function>)->CompletionStage:::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using this stage's default asynchronous execution facility
java.util.concurrent.CompletionStage#thenComposeAsync(Function>, Executor)->CompletionStage:::Returns a new CompletionStage that is completed with the same value as the CompletionStage returned by the given function, executed using the supplied Executor
java.util.concurrent.CompletionStage#handle(BiFunction)->CompletionStage:::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed with this stage's result and exception as arguments to the supplied function
java.util.concurrent.CompletionStage#handleAsync(BiFunction)->CompletionStage:::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using this stage's default asynchronous execution facility, with this stage's result and exception as arguments to the supplied function
java.util.concurrent.CompletionStage#handleAsync(BiFunction, Executor)->CompletionStage:::Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using the supplied executor, with this stage's result and exception as arguments to the supplied function
java.util.concurrent.CompletionStage#whenComplete(BiConsumer)->CompletionStage:::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action when this stage completes
java.util.concurrent.CompletionStage#whenCompleteAsync(BiConsumer)->CompletionStage:::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using this stage's default asynchronous execution facility when this stage completes
java.util.concurrent.CompletionStage#whenCompleteAsync(BiConsumer, Executor)->CompletionStage:::Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using the supplied Executor when this stage completes
java.util.concurrent.CompletionStage#exceptionally(Function)->CompletionStage:::Returns a new CompletionStage that, when this stage completes exceptionally, is executed with this stage's exception as the argument to the supplied function
java.util.concurrent.CompletionStage#toCompletableFuture()->CompletableFuture:::Returns a CompletableFuture maintaining the same completion properties as this stage
java.util.concurrent.ConcurrentHashMap.Node#getKey()->K::: node get key
java.util.concurrent.ConcurrentHashMap.Node#getValue()->V::: node get value
java.util.concurrent.ConcurrentHashMap.Node#hashCode()->int::: node hash code
java.util.concurrent.ConcurrentHashMap.Node#toString()->String::: node to string
java.util.concurrent.ConcurrentHashMap.Node#setValue(V)->V::: node set value
java.util.concurrent.ConcurrentHashMap.Node#equals(Object)->boolean::: node equals
java.util.concurrent.ConcurrentHashMap.Node#find(int, Object)->Node:::Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap#spread(int)->int:::Spreads (XORs) higher bits of hash to lower and also forces top bit to 0
java.util.concurrent.ConcurrentHashMap#comparableClassFor(Object)->Class:::Returns x's Class if it is of the form "class C implements Comparable<C>", else null.
java.util.concurrent.ConcurrentHashMap#compareComparables(Class, Object, Object)->int:::Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.concurrent.ConcurrentHashMap#tabAt(Node[], int)->Node::: concurrent hash map tab at
java.util.concurrent.ConcurrentHashMap#casTabAt(Node[], int, Node, Node)->boolean::: concurrent hash map cas tab at
java.util.concurrent.ConcurrentHashMap#setTabAt(Node[], int, Node)->void::: concurrent hash map set tab at
java.util.concurrent.ConcurrentHashMap#size()->int::: concurrent hash map size
java.util.concurrent.ConcurrentHashMap#isEmpty()->boolean::: concurrent hash map is empty
java.util.concurrent.ConcurrentHashMap#get(Object)->V:::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key
java.util.concurrent.ConcurrentHashMap#containsKey(Object)->boolean:::Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap#containsValue(Object)->boolean:::Returns true if this map maps one or more keys to the specified value
java.util.concurrent.ConcurrentHashMap#put(K, V)->V:::Maps the specified key to the specified value in this table
java.util.concurrent.ConcurrentHashMap#putVal(K, V, boolean)->V:::Implementation for put and putIfAbsent
java.util.concurrent.ConcurrentHashMap#putAll(Map)->void:::Copies all of the mappings from the specified map to this one
java.util.concurrent.ConcurrentHashMap#remove(Object)->V:::Removes the key (and its corresponding value) from this map
java.util.concurrent.ConcurrentHashMap#replaceNode(Object, V, Object)->V:::Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null
java.util.concurrent.ConcurrentHashMap#clear()->void:::Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap#keySet()->KeySetView:::Returns a Set view of the keys contained in this map
java.util.concurrent.ConcurrentHashMap#values()->Collection:::Returns a Collection view of the values contained in this map
java.util.concurrent.ConcurrentHashMap#entrySet()->Set>:::Returns a Set view of the mappings contained in this map
java.util.concurrent.ConcurrentHashMap#hashCode()->int:::Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().
java.util.concurrent.ConcurrentHashMap#toString()->String:::Returns a string representation of this map
java.util.concurrent.ConcurrentHashMap#equals(Object)->boolean:::Compares the specified object with this map for equality
java.util.concurrent.ConcurrentHashMap#putIfAbsent(K, V)->V::: concurrent hash map put if absent
java.util.concurrent.ConcurrentHashMap#remove(Object, Object)->boolean::: concurrent hash map remove
java.util.concurrent.ConcurrentHashMap#replace(K, V, V)->boolean::: concurrent hash map replace
java.util.concurrent.ConcurrentHashMap#replace(K, V)->V::: concurrent hash map replace
java.util.concurrent.ConcurrentHashMap#getOrDefault(Object, V)->V:::Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.
java.util.concurrent.ConcurrentHashMap#forEach(BiConsumer)->void::: concurrent hash map for each
java.util.concurrent.ConcurrentHashMap#replaceAll(BiFunction)->void::: concurrent hash map replace all
java.util.concurrent.ConcurrentHashMap#removeEntryIf(Predicate>)->boolean:::Helper method for EntrySetView.removeIf.
java.util.concurrent.ConcurrentHashMap#removeValueIf(Predicate)->boolean:::Helper method for ValuesView.removeIf.
java.util.concurrent.ConcurrentHashMap#computeIfAbsent(K, Function)->V:::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null
java.util.concurrent.ConcurrentHashMap#computeIfPresent(K, BiFunction)->V:::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value
java.util.concurrent.ConcurrentHashMap#compute(K, BiFunction)->V:::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping)
java.util.concurrent.ConcurrentHashMap#merge(K, V, BiFunction)->V:::If the specified key is not already associated with a (non-null) value, associates it with the given value
java.util.concurrent.ConcurrentHashMap#contains(Object)->boolean:::Tests if some key maps into the specified value in this table
java.util.concurrent.ConcurrentHashMap#keys()->Enumeration:::Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap#elements()->Enumeration:::Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap#mappingCount()->long:::Returns the number of mappings
java.util.concurrent.ConcurrentHashMap#newKeySet()->KeySetView:::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap#newKeySet(int)->KeySetView:::Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap#keySet(V)->KeySetView:::Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., Collection#add and Collection#addAll(Collection))
java.util.concurrent.ConcurrentHashMap.ForwardingNode#find(int, Object)->Node::: forwarding node find
java.util.concurrent.ConcurrentHashMap.ReservationNode#find(int, Object)->Node::: reservation node find
java.util.concurrent.ConcurrentHashMap#resizeStamp(int)->int:::Returns the stamp bits for resizing a table of size n
java.util.concurrent.ConcurrentHashMap#helpTransfer(Node[], Node)->Node[]:::Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap#sumCount()->long::: concurrent hash map sum count
java.util.concurrent.ConcurrentHashMap#untreeify(Node)->Node:::Returns a list of non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap.TreeNode#find(int, Object)->Node::: tree node find
java.util.concurrent.ConcurrentHashMap.TreeNode#findTreeNode(int, Object, Class)->TreeNode:::Returns the TreeNode (or null if not found) for the given key starting at given root.
java.util.concurrent.ConcurrentHashMap.TreeBin#tieBreakOrder(Object, Object)->int:::Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable
java.util.concurrent.ConcurrentHashMap.TreeBin#find(int, Object)->Node:::Returns matching node or null if none
java.util.concurrent.ConcurrentHashMap.TreeBin#putTreeVal(int, K, V)->TreeNode:::Finds or adds a node.
java.util.concurrent.ConcurrentHashMap.TreeBin#removeTreeNode(TreeNode)->boolean:::Removes the given node, that must be present before this call
java.util.concurrent.ConcurrentHashMap.TreeBin#rotateLeft(TreeNode, TreeNode)->TreeNode::: tree bin rotate left
java.util.concurrent.ConcurrentHashMap.TreeBin#rotateRight(TreeNode, TreeNode)->TreeNode::: tree bin rotate right
java.util.concurrent.ConcurrentHashMap.TreeBin#balanceInsertion(TreeNode, TreeNode)->TreeNode::: tree bin balance insertion
java.util.concurrent.ConcurrentHashMap.TreeBin#balanceDeletion(TreeNode, TreeNode)->TreeNode::: tree bin balance deletion
java.util.concurrent.ConcurrentHashMap.TreeBin#checkInvariants(TreeNode)->boolean:::Checks invariants recursively for the tree of Nodes rooted at t.
java.util.concurrent.ConcurrentHashMap.Traverser#advance()->Node:::Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap.BaseIterator#hasNext()->boolean::: base iterator has next
java.util.concurrent.ConcurrentHashMap.BaseIterator#hasMoreElements()->boolean::: base iterator has more elements
java.util.concurrent.ConcurrentHashMap.BaseIterator#remove()->void::: base iterator remove
java.util.concurrent.ConcurrentHashMap.KeyIterator#next()->K::: key iterator next
java.util.concurrent.ConcurrentHashMap.KeyIterator#nextElement()->K::: key iterator next element
java.util.concurrent.ConcurrentHashMap.ValueIterator#next()->V::: value iterator next
java.util.concurrent.ConcurrentHashMap.ValueIterator#nextElement()->V::: value iterator next element
java.util.concurrent.ConcurrentHashMap.EntryIterator#next()->Map.Entry::: entry iterator next
java.util.concurrent.ConcurrentHashMap.MapEntry#getKey()->K::: map entry get key
java.util.concurrent.ConcurrentHashMap.MapEntry#getValue()->V::: map entry get value
java.util.concurrent.ConcurrentHashMap.MapEntry#hashCode()->int::: map entry hash code
java.util.concurrent.ConcurrentHashMap.MapEntry#toString()->String::: map entry to string
java.util.concurrent.ConcurrentHashMap.MapEntry#equals(Object)->boolean::: map entry equals
java.util.concurrent.ConcurrentHashMap.MapEntry#setValue(V)->V:::Sets our entry's value and writes through to the map
java.util.concurrent.ConcurrentHashMap.KeySpliterator#trySplit()->KeySpliterator::: key spliterator try split
java.util.concurrent.ConcurrentHashMap.KeySpliterator#forEachRemaining(Consumer)->void::: key spliterator for each remaining
java.util.concurrent.ConcurrentHashMap.KeySpliterator#tryAdvance(Consumer)->boolean::: key spliterator try advance
java.util.concurrent.ConcurrentHashMap.KeySpliterator#estimateSize()->long::: key spliterator estimate size
java.util.concurrent.ConcurrentHashMap.KeySpliterator#characteristics()->int::: key spliterator characteristics
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#trySplit()->ValueSpliterator::: value spliterator try split
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#forEachRemaining(Consumer)->void::: value spliterator for each remaining
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#tryAdvance(Consumer)->boolean::: value spliterator try advance
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#estimateSize()->long::: value spliterator estimate size
java.util.concurrent.ConcurrentHashMap.ValueSpliterator#characteristics()->int::: value spliterator characteristics
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#trySpliterator trySplit()->En::: entry spliterator try split
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#forEachRemaining(Consumer>)->void::: entry spliterator for each remaining
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#tryAdvance(Consumer>)->boolean::: entry spliterator try advance
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#estimateSize()->long::: entry spliterator estimate size
java.util.concurrent.ConcurrentHashMap.EntrySpliterator#characteristics()->int::: entry spliterator characteristics
java.util.concurrent.ConcurrentHashMap#batchFor(long)->int:::Computes initial batch value for bulk tasks
java.util.concurrent.ConcurrentHashMap#forEach(long, BiConsumer)->void:::Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap#forEach(long, BiFunction, Consumer)->void:::Performs the given action for each non-null transformation of each (key, value).
java.util.concurrent.ConcurrentHashMap#search(long, BiFunction)->U:::Returns a non-null result from applying the given search function on each (key, value), or null if none
java.util.concurrent.ConcurrentHashMap#reduce(long, BiFunction, BiFunction)->U:::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceToLong(long, ToLongBiFunction, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceToInt(long, ToIntBiFunction, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Consumer)->void:::Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Function, Consumer)->void:::Performs the given action for each non-null transformation of each key.
java.util.concurrent.ConcurrentHashMap#searchKeys(long, Function)->U:::Returns a non-null result from applying the given search function on each key, or null if none
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, BiFunction)->K:::Returns the result of accumulating all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, Function, BiFunction)->U:::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Consumer)->void:::Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Function, Consumer)->void:::Performs the given action for each non-null transformation of each value.
java.util.concurrent.ConcurrentHashMap#searchValues(long, Function)->U:::Returns a non-null result from applying the given search function on each value, or null if none
java.util.concurrent.ConcurrentHashMap#reduceValues(long, BiFunction)->V:::Returns the result of accumulating all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceValues(long, Function, BiFunction)->U:::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Consumer>)->void:::Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Function, ? extends U>, Consumer)->void:::Performs the given action for each non-null transformation of each entry.
java.util.concurrent.ConcurrentHashMap#searchEntries(long, Function, ? extends U>)->U:::Returns a non-null result from applying the given search function on each entry, or null if none
java.util.concurrent.ConcurrentHashMap#reduceEntries(long, BiFunction, Map.Entry, ? extends Map.Entry>)->Map.Entry:::Returns the result of accumulating all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceEntries(long, Function, ? extends U>, BiFunction)->U:::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction>, double, DoubleBinaryOperator)->double:::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction>, long, LongBinaryOperator)->long:::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction>, int, IntBinaryOperator)->int:::Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.CollectionView#getMap()->ConcurrentHashMap:::Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView#clear()->void:::Removes all of the elements from this view, by removing all the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView#size()->int::: collection view size
java.util.concurrent.ConcurrentHashMap.CollectionView#isEmpty()->boolean::: collection view is empty
java.util.concurrent.ConcurrentHashMap.CollectionView#iterator()->Iterator:::Returns an iterator over the elements in this collection
java.util.concurrent.ConcurrentHashMap.CollectionView#contains(Object)->boolean::: collection view contains
java.util.concurrent.ConcurrentHashMap.CollectionView#remove(Object)->boolean::: collection view remove
java.util.concurrent.ConcurrentHashMap.CollectionView#toArray()->Object[]::: collection view to array
java.util.concurrent.ConcurrentHashMap.CollectionView#toArray(T[])->T[]::: collection view to array
java.util.concurrent.ConcurrentHashMap.CollectionView#toString()->String:::Returns a string representation of this collection
java.util.concurrent.ConcurrentHashMap.CollectionView#containsAll(Collection)->boolean::: collection view contains all
java.util.concurrent.ConcurrentHashMap.CollectionView#removeAll(Collection)->boolean::: collection view remove all
java.util.concurrent.ConcurrentHashMap.CollectionView#retainAll(Collection)->boolean::: collection view retain all
java.util.concurrent.ConcurrentHashMap.KeySetView#getMappedValue()->V:::Returns the default mapped value for additions, or null if additions are not supported.
java.util.concurrent.ConcurrentHashMap.KeySetView#contains(Object)->boolean::: key set view contains
java.util.concurrent.ConcurrentHashMap.KeySetView#remove(Object)->boolean:::Removes the key from this map view, by removing the key (and its corresponding value) from the backing map
java.util.concurrent.ConcurrentHashMap.KeySetView#iterator()->Iterator::: key set view iterator
java.util.concurrent.ConcurrentHashMap.KeySetView#add(K)->boolean:::Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap.KeySetView#addAll(Collection)->boolean:::Adds all of the elements in the specified collection to this set, as if by calling #add on each one.
java.util.concurrent.ConcurrentHashMap.KeySetView#hashCode()->int::: key set view hash code
java.util.concurrent.ConcurrentHashMap.KeySetView#equals(Object)->boolean::: key set view equals
java.util.concurrent.ConcurrentHashMap.KeySetView#spliterator()->Spliterator::: key set view spliterator
java.util.concurrent.ConcurrentHashMap.KeySetView#forEach(Consumer)->void::: key set view for each
java.util.concurrent.ConcurrentHashMap.ValuesView#contains(Object)->boolean::: values view contains
java.util.concurrent.ConcurrentHashMap.ValuesView#remove(Object)->boolean::: values view remove
java.util.concurrent.ConcurrentHashMap.ValuesView#iterator()->Iterator::: values view iterator
java.util.concurrent.ConcurrentHashMap.ValuesView#add(V)->boolean::: values view add
java.util.concurrent.ConcurrentHashMap.ValuesView#addAll(Collection)->boolean::: values view add all
java.util.concurrent.ConcurrentHashMap.ValuesView#removeAll(Collection)->boolean::: values view remove all
java.util.concurrent.ConcurrentHashMap.ValuesView#removeIf(Predicate)->boolean::: values view remove if
java.util.concurrent.ConcurrentHashMap.ValuesView#spliterator()->Spliterator::: values view spliterator
java.util.concurrent.ConcurrentHashMap.ValuesView#forEach(Consumer)->void::: values view for each
java.util.concurrent.ConcurrentHashMap.EntrySetView#contains(Object)->boolean::: entry set view contains
java.util.concurrent.ConcurrentHashMap.EntrySetView#remove(Object)->boolean::: entry set view remove
java.util.concurrent.ConcurrentHashMap.EntrySetView#iterator()->Iterator>::: entry set view iterator
java.util.concurrent.ConcurrentHashMap.EntrySetView#add(Entry)->boolean::: entry set view add
java.util.concurrent.ConcurrentHashMap.EntrySetView#addAll(Collection>)->boolean::: entry set view add all
java.util.concurrent.ConcurrentHashMap.EntrySetView#removeIf(Predicate>)->boolean::: entry set view remove if
java.util.concurrent.ConcurrentHashMap.EntrySetView#hashCode()->int::: entry set view hash code
java.util.concurrent.ConcurrentHashMap.EntrySetView#equals(Object)->boolean::: entry set view equals
java.util.concurrent.ConcurrentHashMap.EntrySetView#spliterator()->Spliterator>::: entry set view spliterator
java.util.concurrent.ConcurrentHashMap.EntrySetView#forEach(Consumer>)->void::: entry set view for each
java.util.concurrent.ConcurrentHashMap.BulkTask#advance()->Node:::Same as Traverser version.
java.util.concurrent.ConcurrentHashMap.ForEachKeyTask#compute()->void::: for each key task compute
java.util.concurrent.ConcurrentHashMap.ForEachValueTask#compute()->void::: for each value task compute
java.util.concurrent.ConcurrentHashMap.ForEachEntryTask#compute()->void::: for each entry task compute
java.util.concurrent.ConcurrentHashMap.ForEachMappingTask#compute()->void::: for each mapping task compute
java.util.concurrent.ConcurrentHashMap.ForEachTransformedKeyTask#compute()->void::: for each transformed key task compute
java.util.concurrent.ConcurrentHashMap.ForEachTransformedValueTask#compute()->void::: for each transformed value task compute
java.util.concurrent.ConcurrentHashMap.ForEachTransformedEntryTask#compute()->void::: for each transformed entry task compute
java.util.concurrent.ConcurrentHashMap.ForEachTransformedMappingTask#compute()->void::: for each transformed mapping task compute
java.util.concurrent.ConcurrentHashMap.SearchKeysTask#getRawResult()->U::: search keys task get raw result
java.util.concurrent.ConcurrentHashMap.SearchKeysTask#compute()->void::: search keys task compute
java.util.concurrent.ConcurrentHashMap.SearchValuesTask#getRawResult()->U::: search values task get raw result
java.util.concurrent.ConcurrentHashMap.SearchValuesTask#compute()->void::: search values task compute
java.util.concurrent.ConcurrentHashMap.SearchEntriesTask#getRawResult()->U::: search entries task get raw result
java.util.concurrent.ConcurrentHashMap.SearchEntriesTask#compute()->void::: search entries task compute
java.util.concurrent.ConcurrentHashMap.SearchMappingsTask#getRawResult()->U::: search mappings task get raw result
java.util.concurrent.ConcurrentHashMap.SearchMappingsTask#compute()->void::: search mappings task compute
java.util.concurrent.ConcurrentHashMap.ReduceKeysTask#getRawResult()->K::: reduce keys task get raw result
java.util.concurrent.ConcurrentHashMap.ReduceKeysTask#compute()->void::: reduce keys task compute
java.util.concurrent.ConcurrentHashMap.ReduceValuesTask#getRawResult()->V::: reduce values task get raw result
java.util.concurrent.ConcurrentHashMap.ReduceValuesTask#compute()->void::: reduce values task compute
java.util.concurrent.ConcurrentHashMap.ReduceEntriesTask#getRawResult()->Map.Entry::: reduce entries task get raw result
java.util.concurrent.ConcurrentHashMap.ReduceEntriesTask#compute()->void::: reduce entries task compute
java.util.concurrent.ConcurrentHashMap.MapReduceKeysTask#getRawResult()->U::: map reduce keys task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceKeysTask#compute()->void::: map reduce keys task compute
java.util.concurrent.ConcurrentHashMap.MapReduceValuesTask#getRawResult()->U::: map reduce values task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceValuesTask#compute()->void::: map reduce values task compute
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesTask#getRawResult()->U::: map reduce entries task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesTask#compute()->void::: map reduce entries task compute
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsTask#getRawResult()->U::: map reduce mappings task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsTask#compute()->void::: map reduce mappings task compute
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToDoubleTask#getRawResult()->Double::: map reduce keys to double task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToDoubleTask#compute()->void::: map reduce keys to double task compute
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToDoubleTask#getRawResult()->Double::: map reduce values to double task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToDoubleTask#compute()->void::: map reduce values to double task compute
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToDoubleTask#getRawResult()->Double::: map reduce entries to double task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToDoubleTask#compute()->void::: map reduce entries to double task compute
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToDoubleTask#getRawResult()->Double::: map reduce mappings to double task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToDoubleTask#compute()->void::: map reduce mappings to double task compute
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToLongTask#getRawResult()->Long::: map reduce keys to long task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToLongTask#compute()->void::: map reduce keys to long task compute
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToLongTask#getRawResult()->Long::: map reduce values to long task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToLongTask#compute()->void::: map reduce values to long task compute
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToLongTask#getRawResult()->Long::: map reduce entries to long task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToLongTask#compute()->void::: map reduce entries to long task compute
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToLongTask#getRawResult()->Long::: map reduce mappings to long task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToLongTask#compute()->void::: map reduce mappings to long task compute
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToIntTask#getRawResult()->Integer::: map reduce keys to int task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceKeysToIntTask#compute()->void::: map reduce keys to int task compute
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToIntTask#getRawResult()->Integer::: map reduce values to int task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceValuesToIntTask#compute()->void::: map reduce values to int task compute
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToIntTask#getRawResult()->Integer::: map reduce entries to int task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceEntriesToIntTask#compute()->void::: map reduce entries to int task compute
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToIntTask#getRawResult()->Integer::: map reduce mappings to int task get raw result
java.util.concurrent.ConcurrentHashMap.MapReduceMappingsToIntTask#compute()->void::: map reduce mappings to int task compute
java.util.concurrent.ConcurrentLinkedDeque#prevTerminator()->Node::: concurrent linked deque prev terminator
java.util.concurrent.ConcurrentLinkedDeque#nextTerminator()->Node::: concurrent linked deque next terminator
java.util.concurrent.ConcurrentLinkedDeque#newNode(E)->Node:::Returns a new node holding item
java.util.concurrent.ConcurrentLinkedDeque#unlink(Node)->void:::Unlinks non-null node x.
java.util.concurrent.ConcurrentLinkedDeque#succ(Node)->Node:::Returns the successor of p, or the first node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque#pred(Node)->Node:::Returns the predecessor of p, or the last node if p.prev has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque#first()->Node:::Returns the first node, the unique node p for which:     p.prev == null && p.next != p The returned node may or may not be logically deleted
java.util.concurrent.ConcurrentLinkedDeque#last()->Node:::Returns the last node, the unique node p for which:     p.next == null && p.prev != p The returned node may or may not be logically deleted
java.util.concurrent.ConcurrentLinkedDeque#addFirst(E)->void:::Inserts the specified element at the front of this deque
java.util.concurrent.ConcurrentLinkedDeque#addLast(E)->void:::Inserts the specified element at the end of this deque
java.util.concurrent.ConcurrentLinkedDeque#offerFirst(E)->boolean:::Inserts the specified element at the front of this deque
java.util.concurrent.ConcurrentLinkedDeque#offerLast(E)->boolean:::Inserts the specified element at the end of this deque
java.util.concurrent.ConcurrentLinkedDeque#peekFirst()->E::: concurrent linked deque peek first
java.util.concurrent.ConcurrentLinkedDeque#peekLast()->E::: concurrent linked deque peek last
java.util.concurrent.ConcurrentLinkedDeque#getFirst()->E::: concurrent linked deque get first
java.util.concurrent.ConcurrentLinkedDeque#getLast()->E::: concurrent linked deque get last
java.util.concurrent.ConcurrentLinkedDeque#pollFirst()->E::: concurrent linked deque poll first
java.util.concurrent.ConcurrentLinkedDeque#pollLast()->E::: concurrent linked deque poll last
java.util.concurrent.ConcurrentLinkedDeque#removeFirst()->E::: concurrent linked deque remove first
java.util.concurrent.ConcurrentLinkedDeque#removeLast()->E::: concurrent linked deque remove last
java.util.concurrent.ConcurrentLinkedDeque#offer(E)->boolean:::Inserts the specified element at the tail of this deque
java.util.concurrent.ConcurrentLinkedDeque#add(E)->boolean:::Inserts the specified element at the tail of this deque
java.util.concurrent.ConcurrentLinkedDeque#poll()->E::: concurrent linked deque poll
java.util.concurrent.ConcurrentLinkedDeque#peek()->E::: concurrent linked deque peek
java.util.concurrent.ConcurrentLinkedDeque#remove()->E::: concurrent linked deque remove
java.util.concurrent.ConcurrentLinkedDeque#pop()->E::: concurrent linked deque pop
java.util.concurrent.ConcurrentLinkedDeque#element()->E::: concurrent linked deque element
java.util.concurrent.ConcurrentLinkedDeque#push(E)->void::: concurrent linked deque push
java.util.concurrent.ConcurrentLinkedDeque#removeFirstOccurrence(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#removeLastOccurrence(Object)->boolean:::Removes the last occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#contains(Object)->boolean:::Returns true if this deque contains the specified element
java.util.concurrent.ConcurrentLinkedDeque#isEmpty()->boolean:::Returns true if this collection contains no elements.
java.util.concurrent.ConcurrentLinkedDeque#size()->int:::Returns the number of elements in this deque
java.util.concurrent.ConcurrentLinkedDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.ConcurrentLinkedDeque#addAll(Collection)->boolean:::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator
java.util.concurrent.ConcurrentLinkedDeque#clear()->void:::Removes all of the elements from this deque.
java.util.concurrent.ConcurrentLinkedDeque#toString()->String::: concurrent linked deque to string
java.util.concurrent.ConcurrentLinkedDeque#toArray()->Object[]:::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element)
java.util.concurrent.ConcurrentLinkedDeque#toArray(T[])->T[]:::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array
java.util.concurrent.ConcurrentLinkedDeque#iterator()->Iterator:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.ConcurrentLinkedDeque#descendingIterator()->Iterator:::Returns an iterator over the elements in this deque in reverse sequential order
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#trySplit()->Spliterator::: spliterator try split
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#forEachRemaining(Consumer)->void::: spliterator for each remaining
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#tryAdvance(Consumer)->boolean::: spliterator try advance
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#estimateSize()->long::: spliterator estimate size
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator#characteristics()->int::: spliterator characteristics
java.util.concurrent.ConcurrentLinkedDeque#spliterator()->Spliterator:::Returns a Spliterator over the elements in this deque
java.util.concurrent.ConcurrentLinkedDeque#removeIf(Predicate)->boolean::: concurrent linked deque remove if
java.util.concurrent.ConcurrentLinkedDeque#removeAll(Collection)->boolean::: concurrent linked deque remove all
java.util.concurrent.ConcurrentLinkedDeque#retainAll(Collection)->boolean::: concurrent linked deque retain all
java.util.concurrent.ConcurrentLinkedDeque#forEach(Consumer)->void::: concurrent linked deque for each
java.util.concurrent.ConcurrentLinkedQueue.Node#appendRelaxed(Node)->void::: node append relaxed
java.util.concurrent.ConcurrentLinkedQueue.Node#casItem(E, E)->boolean::: node cas item
java.util.concurrent.ConcurrentLinkedQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.ConcurrentLinkedQueue#updateHead(Node, Node)->void:::Tries to CAS head to p
java.util.concurrent.ConcurrentLinkedQueue#succ(Node)->Node:::Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.ConcurrentLinkedQueue#poll()->E::: concurrent linked queue poll
java.util.concurrent.ConcurrentLinkedQueue#peek()->E::: concurrent linked queue peek
java.util.concurrent.ConcurrentLinkedQueue#first()->Node:::Returns the first live (non-deleted) node on list, or null if none
java.util.concurrent.ConcurrentLinkedQueue#isEmpty()->boolean:::Returns true if this queue contains no elements.
java.util.concurrent.ConcurrentLinkedQueue#size()->int:::Returns the number of elements in this queue
java.util.concurrent.ConcurrentLinkedQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.ConcurrentLinkedQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.ConcurrentLinkedQueue#addAll(Collection)->boolean:::Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator
java.util.concurrent.ConcurrentLinkedQueue#toString()->String::: concurrent linked queue to string
java.util.concurrent.ConcurrentLinkedQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in proper sequence
java.util.concurrent.ConcurrentLinkedQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array
java.util.concurrent.ConcurrentLinkedQueue#iterator()->Iterator:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#trySplit()->Spliterator::: spliterator try split
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#forEachRemaining(Consumer)->void::: spliterator for each remaining
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#tryAdvance(Consumer)->boolean::: spliterator try advance
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#estimateSize()->long::: spliterator estimate size
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator#characteristics()->int::: spliterator characteristics
java.util.concurrent.ConcurrentLinkedQueue#spliterator()->Spliterator:::Returns a Spliterator over the elements in this queue
java.util.concurrent.ConcurrentLinkedQueue#removeIf(Predicate)->boolean::: concurrent linked queue remove if
java.util.concurrent.ConcurrentLinkedQueue#removeAll(Collection)->boolean::: concurrent linked queue remove all
java.util.concurrent.ConcurrentLinkedQueue#retainAll(Collection)->boolean::: concurrent linked queue retain all
java.util.concurrent.ConcurrentLinkedQueue#clear()->void::: concurrent linked queue clear
java.util.concurrent.ConcurrentLinkedQueue#forEachFrom(Consumer, Node)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.ConcurrentLinkedQueue#forEach(Consumer)->void::: concurrent linked queue for each
java.util.concurrent.ConcurrentMap#getOrDefault(Object, V)->V::: concurrent map get or default
java.util.concurrent.ConcurrentMap#forEach(BiConsumer)->void::: concurrent map for each
java.util.concurrent.ConcurrentMap#putIfAbsent(K, V)->V:::If the specified key is not already associated with a value, associates it with the given value
java.util.concurrent.ConcurrentMap#remove(Object, Object)->boolean:::Removes the entry for a key only if currently mapped to a given value
java.util.concurrent.ConcurrentMap#replace(K, V, V)->boolean:::Replaces the entry for a key only if currently mapped to a given value
java.util.concurrent.ConcurrentMap#replace(K, V)->V:::Replaces the entry for a key only if currently mapped to some value
java.util.concurrent.ConcurrentMap#replaceAll(BiFunction)->void::: concurrent map replace all
java.util.concurrent.ConcurrentMap#computeIfAbsent(K, Function)->V::: concurrent map compute if absent
java.util.concurrent.ConcurrentMap#computeIfPresent(K, BiFunction)->V::: concurrent map compute if present
java.util.concurrent.ConcurrentMap#compute(K, BiFunction)->V::: concurrent map compute
java.util.concurrent.ConcurrentMap#merge(K, V, BiFunction)->V::: concurrent map merge
java.util.concurrent.ConcurrentNavigableMap#subMap(K, boolean, K, boolean)->ConcurrentNavigableMap::: concurrent navigable map sub map
java.util.concurrent.ConcurrentNavigableMap#headMap(K, boolean)->ConcurrentNavigableMap::: concurrent navigable map head map
java.util.concurrent.ConcurrentNavigableMap#tailMap(K, boolean)->ConcurrentNavigableMap::: concurrent navigable map tail map
java.util.concurrent.ConcurrentNavigableMap#subMap(K, K)->ConcurrentNavigableMap::: concurrent navigable map sub map
java.util.concurrent.ConcurrentNavigableMap#headMap(K)->ConcurrentNavigableMap::: concurrent navigable map head map
java.util.concurrent.ConcurrentNavigableMap#tailMap(K)->ConcurrentNavigableMap::: concurrent navigable map tail map
java.util.concurrent.ConcurrentNavigableMap#descendingMap()->ConcurrentNavigableMap:::Returns a reverse order view of the mappings contained in this map
java.util.concurrent.ConcurrentNavigableMap#navigableKeySet()->NavigableSet:::Returns a NavigableSet view of the keys contained in this map
java.util.concurrent.ConcurrentNavigableMap#keySet()->NavigableSet:::Returns a NavigableSet view of the keys contained in this map
java.util.concurrent.ConcurrentNavigableMap#descendingKeySet()->NavigableSet:::Returns a reverse order NavigableSet view of the keys contained in this map
java.util.concurrent.ConcurrentSkipListMap#cpr(Comparator, Object, Object)->int:::Compares using comparator or natural ordering if null
java.util.concurrent.ConcurrentSkipListMap#baseHead()->Node:::Returns the header for base node list, or null if uninitialized
java.util.concurrent.ConcurrentSkipListMap#unlinkNode(Node, Node)->void:::Tries to unlink deleted node n from predecessor b (if both exist), by first splicing in a marker if not already present
java.util.concurrent.ConcurrentSkipListMap#getAdderCount()->long:::Returns element count, initializing adder if necessary.
java.util.concurrent.ConcurrentSkipListMap#addIndices(Index, int, Index, Comparator)->boolean:::Add indices after an insertion
java.util.concurrent.ConcurrentSkipListMap#doRemove(Object, Object)->V:::Main deletion method
java.util.concurrent.ConcurrentSkipListMap#findFirst()->Node:::Gets first valid node, unlinking deleted nodes if encountered.
java.util.concurrent.ConcurrentSkipListMap#findFirstEntry()->AbstractMap.SimpleImmutableEntry:::Entry snapshot version of findFirst
java.util.concurrent.ConcurrentSkipListMap#findLast()->Node:::Specialized version of find to get last valid node.
java.util.concurrent.ConcurrentSkipListMap#findLastEntry()->AbstractMap.SimpleImmutableEntry:::Entry version of findLast
java.util.concurrent.ConcurrentSkipListMap#findNear(K, int, Comparator)->Node:::Utility for ceiling, floor, lower, higher methods.
java.util.concurrent.ConcurrentSkipListMap#findNearEntry(K, int, Comparator)->AbstractMap.SimpleImmutableEntry:::Variant of findNear returning SimpleImmutableEntry
java.util.concurrent.ConcurrentSkipListMap#clone()->ConcurrentSkipListMap:::Returns a shallow copy of this ConcurrentSkipListMap instance
java.util.concurrent.ConcurrentSkipListMap#containsKey(Object)->boolean:::Returns true if this map contains a mapping for the specified key.
java.util.concurrent.ConcurrentSkipListMap#get(Object)->V:::Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key
java.util.concurrent.ConcurrentSkipListMap#getOrDefault(Object, V)->V:::Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentSkipListMap#put(K, V)->V:::Associates the specified value with the specified key in this map
java.util.concurrent.ConcurrentSkipListMap#remove(Object)->V:::Removes the mapping for the specified key from this map if present.
java.util.concurrent.ConcurrentSkipListMap#containsValue(Object)->boolean:::Returns true if this map maps one or more keys to the specified value
java.util.concurrent.ConcurrentSkipListMap#size()->int::: concurrent skip list map size
java.util.concurrent.ConcurrentSkipListMap#isEmpty()->boolean::: concurrent skip list map is empty
java.util.concurrent.ConcurrentSkipListMap#clear()->void:::Removes all of the mappings from this map.
java.util.concurrent.ConcurrentSkipListMap#computeIfAbsent(K, Function)->V:::If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null
java.util.concurrent.ConcurrentSkipListMap#computeIfPresent(K, BiFunction)->V:::If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value
java.util.concurrent.ConcurrentSkipListMap#compute(K, BiFunction)->V:::Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping)
java.util.concurrent.ConcurrentSkipListMap#merge(K, V, BiFunction)->V:::If the specified key is not already associated with a value, associates it with the given value
java.util.concurrent.ConcurrentSkipListMap#keySet()->NavigableSet:::Returns a NavigableSet view of the keys contained in this map
java.util.concurrent.ConcurrentSkipListMap#navigableKeySet()->NavigableSet::: concurrent skip list map navigable key set
java.util.concurrent.ConcurrentSkipListMap#values()->Collection:::Returns a Collection view of the values contained in this map
java.util.concurrent.ConcurrentSkipListMap#entrySet()->Set>:::Returns a Set view of the mappings contained in this map
java.util.concurrent.ConcurrentSkipListMap#descendingMap()->ConcurrentNavigableMap::: concurrent skip list map descending map
java.util.concurrent.ConcurrentSkipListMap#descendingKeySet()->NavigableSet::: concurrent skip list map descending key set
java.util.concurrent.ConcurrentSkipListMap#equals(Object)->boolean:::Compares the specified object with this map for equality
java.util.concurrent.ConcurrentSkipListMap#putIfAbsent(K, V)->V::: concurrent skip list map put if absent
java.util.concurrent.ConcurrentSkipListMap#remove(Object, Object)->boolean::: concurrent skip list map remove
java.util.concurrent.ConcurrentSkipListMap#replace(K, V, V)->boolean::: concurrent skip list map replace
java.util.concurrent.ConcurrentSkipListMap#replace(K, V)->V::: concurrent skip list map replace
java.util.concurrent.ConcurrentSkipListMap#comparator()->Comparator::: concurrent skip list map comparator
java.util.concurrent.ConcurrentSkipListMap#firstKey()->K::: concurrent skip list map first key
java.util.concurrent.ConcurrentSkipListMap#lastKey()->K::: concurrent skip list map last key
java.util.concurrent.ConcurrentSkipListMap#subMap(K, boolean, K, boolean)->ConcurrentNavigableMap::: concurrent skip list map sub map
java.util.concurrent.ConcurrentSkipListMap#headMap(K, boolean)->ConcurrentNavigableMap::: concurrent skip list map head map
java.util.concurrent.ConcurrentSkipListMap#tailMap(K, boolean)->ConcurrentNavigableMap::: concurrent skip list map tail map
java.util.concurrent.ConcurrentSkipListMap#subMap(K, K)->ConcurrentNavigableMap::: concurrent skip list map sub map
java.util.concurrent.ConcurrentSkipListMap#headMap(K)->ConcurrentNavigableMap::: concurrent skip list map head map
java.util.concurrent.ConcurrentSkipListMap#tailMap(K)->ConcurrentNavigableMap::: concurrent skip list map tail map
java.util.concurrent.ConcurrentSkipListMap#lowerEntry(K)->Map.Entry:::Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key
java.util.concurrent.ConcurrentSkipListMap#lowerKey(K)->K::: concurrent skip list map lower key
java.util.concurrent.ConcurrentSkipListMap#floorEntry(K)->Map.Entry:::Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key
java.util.concurrent.ConcurrentSkipListMap#floorKey(K)->K::: concurrent skip list map floor key
java.util.concurrent.ConcurrentSkipListMap#ceilingEntry(K)->Map.Entry:::Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such entry
java.util.concurrent.ConcurrentSkipListMap#ceilingKey(K)->K::: concurrent skip list map ceiling key
java.util.concurrent.ConcurrentSkipListMap#higherEntry(K)->Map.Entry:::Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key
java.util.concurrent.ConcurrentSkipListMap#higherKey(K)->K::: concurrent skip list map higher key
java.util.concurrent.ConcurrentSkipListMap#firstEntry()->Map.Entry:::Returns a key-value mapping associated with the least key in this map, or null if the map is empty
java.util.concurrent.ConcurrentSkipListMap#lastEntry()->Map.Entry:::Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty
java.util.concurrent.ConcurrentSkipListMap#pollFirstEntry()->Map.Entry:::Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty
java.util.concurrent.ConcurrentSkipListMap#pollLastEntry()->Map.Entry:::Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty
java.util.concurrent.ConcurrentSkipListMap.Iter#hasNext()->boolean::: iter has next
java.util.concurrent.ConcurrentSkipListMap.Iter#advance(Node)->void:::Advances next to higher entry.
java.util.concurrent.ConcurrentSkipListMap.Iter#remove()->void::: iter remove
java.util.concurrent.ConcurrentSkipListMap.ValueIterator#next()->V::: value iterator next
java.util.concurrent.ConcurrentSkipListMap.KeyIterator#next()->K::: key iterator next
java.util.concurrent.ConcurrentSkipListMap.EntryIterator#next()->Map.Entry::: entry iterator next
java.util.concurrent.ConcurrentSkipListMap#toList(Collection)->List::: concurrent skip list map to list
java.util.concurrent.ConcurrentSkipListMap.KeySet#size()->int::: key set size
java.util.concurrent.ConcurrentSkipListMap.KeySet#isEmpty()->boolean::: key set is empty
java.util.concurrent.ConcurrentSkipListMap.KeySet#contains(Object)->boolean::: key set contains
java.util.concurrent.ConcurrentSkipListMap.KeySet#remove(Object)->boolean::: key set remove
java.util.concurrent.ConcurrentSkipListMap.KeySet#clear()->void::: key set clear
java.util.concurrent.ConcurrentSkipListMap.KeySet#lower(K)->K::: key set lower
java.util.concurrent.ConcurrentSkipListMap.KeySet#floor(K)->K::: key set floor
java.util.concurrent.ConcurrentSkipListMap.KeySet#ceiling(K)->K::: key set ceiling
java.util.concurrent.ConcurrentSkipListMap.KeySet#higher(K)->K::: key set higher
java.util.concurrent.ConcurrentSkipListMap.KeySet#comparator()->Comparator::: key set comparator
java.util.concurrent.ConcurrentSkipListMap.KeySet#first()->K::: key set first
java.util.concurrent.ConcurrentSkipListMap.KeySet#last()->K::: key set last
java.util.concurrent.ConcurrentSkipListMap.KeySet#pollFirst()->K::: key set poll first
java.util.concurrent.ConcurrentSkipListMap.KeySet#pollLast()->K::: key set poll last
java.util.concurrent.ConcurrentSkipListMap.KeySet#iterator()->Iterator::: key set iterator
java.util.concurrent.ConcurrentSkipListMap.KeySet#equals(Object)->boolean::: key set equals
java.util.concurrent.ConcurrentSkipListMap.KeySet#toArray()->Object[]::: key set to array
java.util.concurrent.ConcurrentSkipListMap.KeySet#toArray(T[])->T[]::: key set to array
java.util.concurrent.ConcurrentSkipListMap.KeySet#descendingIterator()->Iterator::: key set descending iterator
java.util.concurrent.ConcurrentSkipListMap.KeySet#subSet(K, boolean, K, boolean)->NavigableSet::: key set sub set
java.util.concurrent.ConcurrentSkipListMap.KeySet#headSet(K, boolean)->NavigableSet::: key set head set
java.util.concurrent.ConcurrentSkipListMap.KeySet#tailSet(K, boolean)->NavigableSet::: key set tail set
java.util.concurrent.ConcurrentSkipListMap.KeySet#subSet(K, K)->NavigableSet::: key set sub set
java.util.concurrent.ConcurrentSkipListMap.KeySet#headSet(K)->NavigableSet::: key set head set
java.util.concurrent.ConcurrentSkipListMap.KeySet#tailSet(K)->NavigableSet::: key set tail set
java.util.concurrent.ConcurrentSkipListMap.KeySet#descendingSet()->NavigableSet::: key set descending set
java.util.concurrent.ConcurrentSkipListMap.KeySet#spliterator()->Spliterator::: key set spliterator
java.util.concurrent.ConcurrentSkipListMap.Values#iterator()->Iterator::: values iterator
java.util.concurrent.ConcurrentSkipListMap.Values#size()->int::: values size
java.util.concurrent.ConcurrentSkipListMap.Values#isEmpty()->boolean::: values is empty
java.util.concurrent.ConcurrentSkipListMap.Values#contains(Object)->boolean::: values contains
java.util.concurrent.ConcurrentSkipListMap.Values#clear()->void::: values clear
java.util.concurrent.ConcurrentSkipListMap.Values#toArray()->Object[]::: values to array
java.util.concurrent.ConcurrentSkipListMap.Values#toArray(T[])->T[]::: values to array
java.util.concurrent.ConcurrentSkipListMap.Values#spliterator()->Spliterator::: values spliterator
java.util.concurrent.ConcurrentSkipListMap.Values#removeIf(Predicate)->boolean::: values remove if
java.util.concurrent.ConcurrentSkipListMap.EntrySet#iterator()->Iterator>::: entry set iterator
java.util.concurrent.ConcurrentSkipListMap.EntrySet#contains(Object)->boolean::: entry set contains
java.util.concurrent.ConcurrentSkipListMap.EntrySet#remove(Object)->boolean::: entry set remove
java.util.concurrent.ConcurrentSkipListMap.EntrySet#isEmpty()->boolean::: entry set is empty
java.util.concurrent.ConcurrentSkipListMap.EntrySet#size()->int::: entry set size
java.util.concurrent.ConcurrentSkipListMap.EntrySet#clear()->void::: entry set clear
java.util.concurrent.ConcurrentSkipListMap.EntrySet#equals(Object)->boolean::: entry set equals
java.util.concurrent.ConcurrentSkipListMap.EntrySet#toArray()->Object[]::: entry set to array
java.util.concurrent.ConcurrentSkipListMap.EntrySet#toArray(T[])->T[]::: entry set to array
java.util.concurrent.ConcurrentSkipListMap.EntrySet#spliterator()->Spliterator>::: entry set spliterator
java.util.concurrent.ConcurrentSkipListMap.EntrySet#removeIf(Predicate>)->boolean::: entry set remove if
java.util.concurrent.ConcurrentSkipListMap.SubMap#tooLow(Object, Comparator)->boolean::: sub map too low
java.util.concurrent.ConcurrentSkipListMap.SubMap#tooHigh(Object, Comparator)->boolean::: sub map too high
java.util.concurrent.ConcurrentSkipListMap.SubMap#inBounds(Object, Comparator)->boolean::: sub map in bounds
java.util.concurrent.ConcurrentSkipListMap.SubMap#checkKeyBounds(K, Comparator)->void::: sub map check key bounds
java.util.concurrent.ConcurrentSkipListMap.SubMap#isBeforeEnd(ConcurrentSkipListMap.Node, Comparator)->boolean:::Returns true if node key is less than upper bound of range.
java.util.concurrent.ConcurrentSkipListMap.SubMap#loNode(Comparator)->ConcurrentSkipListMap.Node:::Returns lowest node
java.util.concurrent.ConcurrentSkipListMap.SubMap#hiNode(Comparator)->ConcurrentSkipListMap.Node:::Returns highest node
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowestKey()->K:::Returns lowest absolute key (ignoring directionality).
java.util.concurrent.ConcurrentSkipListMap.SubMap#highestKey()->K:::Returns highest absolute key (ignoring directionality).
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowestEntry()->Map.Entry::: sub map lowest entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#highestEntry()->Map.Entry::: sub map highest entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#removeLowest()->Map.Entry::: sub map remove lowest
java.util.concurrent.ConcurrentSkipListMap.SubMap#removeHighest()->Map.Entry::: sub map remove highest
java.util.concurrent.ConcurrentSkipListMap.SubMap#getNearEntry(K, int)->Map.Entry:::Submap version of ConcurrentSkipListMap.findNearEntry.
java.util.concurrent.ConcurrentSkipListMap.SubMap#getNearKey(K, int)->K::: sub map get near key
java.util.concurrent.ConcurrentSkipListMap.SubMap#containsKey(Object)->boolean::: sub map contains key
java.util.concurrent.ConcurrentSkipListMap.SubMap#get(Object)->V::: sub map get
java.util.concurrent.ConcurrentSkipListMap.SubMap#put(K, V)->V::: sub map put
java.util.concurrent.ConcurrentSkipListMap.SubMap#remove(Object)->V::: sub map remove
java.util.concurrent.ConcurrentSkipListMap.SubMap#size()->int::: sub map size
java.util.concurrent.ConcurrentSkipListMap.SubMap#isEmpty()->boolean::: sub map is empty
java.util.concurrent.ConcurrentSkipListMap.SubMap#containsValue(Object)->boolean::: sub map contains value
java.util.concurrent.ConcurrentSkipListMap.SubMap#clear()->void::: sub map clear
java.util.concurrent.ConcurrentSkipListMap.SubMap#putIfAbsent(K, V)->V::: sub map put if absent
java.util.concurrent.ConcurrentSkipListMap.SubMap#remove(Object, Object)->boolean::: sub map remove
java.util.concurrent.ConcurrentSkipListMap.SubMap#replace(K, V, V)->boolean::: sub map replace
java.util.concurrent.ConcurrentSkipListMap.SubMap#replace(K, V)->V::: sub map replace
java.util.concurrent.ConcurrentSkipListMap.SubMap#comparator()->Comparator::: sub map comparator
java.util.concurrent.ConcurrentSkipListMap.SubMap#newSubMap(K, boolean, K, boolean)->SubMap:::Utility to create submaps, where given bounds override unbounded(null) ones and/or are checked against bounded ones.
java.util.concurrent.ConcurrentSkipListMap.SubMap#subMap(K, boolean, K, boolean)->SubMap::: sub map sub map
java.util.concurrent.ConcurrentSkipListMap.SubMap#headMap(K, boolean)->SubMap::: sub map head map
java.util.concurrent.ConcurrentSkipListMap.SubMap#tailMap(K, boolean)->SubMap::: sub map tail map
java.util.concurrent.ConcurrentSkipListMap.SubMap#subMap(K, K)->SubMap::: sub map sub map
java.util.concurrent.ConcurrentSkipListMap.SubMap#headMap(K)->SubMap::: sub map head map
java.util.concurrent.ConcurrentSkipListMap.SubMap#tailMap(K)->SubMap::: sub map tail map
java.util.concurrent.ConcurrentSkipListMap.SubMap#descendingMap()->SubMap::: sub map descending map
java.util.concurrent.ConcurrentSkipListMap.SubMap#ceilingEntry(K)->Map.Entry::: sub map ceiling entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#ceilingKey(K)->K::: sub map ceiling key
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowerEntry(K)->Map.Entry::: sub map lower entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#lowerKey(K)->K::: sub map lower key
java.util.concurrent.ConcurrentSkipListMap.SubMap#floorEntry(K)->Map.Entry::: sub map floor entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#floorKey(K)->K::: sub map floor key
java.util.concurrent.ConcurrentSkipListMap.SubMap#higherEntry(K)->Map.Entry::: sub map higher entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#higherKey(K)->K::: sub map higher key
java.util.concurrent.ConcurrentSkipListMap.SubMap#firstKey()->K::: sub map first key
java.util.concurrent.ConcurrentSkipListMap.SubMap#lastKey()->K::: sub map last key
java.util.concurrent.ConcurrentSkipListMap.SubMap#firstEntry()->Map.Entry::: sub map first entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#lastEntry()->Map.Entry::: sub map last entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#pollFirstEntry()->Map.Entry::: sub map poll first entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#pollLastEntry()->Map.Entry::: sub map poll last entry
java.util.concurrent.ConcurrentSkipListMap.SubMap#keySet()->NavigableSet::: sub map key set
java.util.concurrent.ConcurrentSkipListMap.SubMap#navigableKeySet()->NavigableSet::: sub map navigable key set
java.util.concurrent.ConcurrentSkipListMap.SubMap#values()->Collection::: sub map values
java.util.concurrent.ConcurrentSkipListMap.SubMap#entrySet()->Set>::: sub map entry set
java.util.concurrent.ConcurrentSkipListMap.SubMap#descendingKeySet()->NavigableSet::: sub map descending key set
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#hasNext()->boolean::: sub map iter has next
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#advance()->void::: sub map iter advance
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#remove()->void::: sub map iter remove
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#trySplit()->Spliterator::: sub map iter try split
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#tryAdvance(Consumer)->boolean::: sub map iter try advance
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#forEachRemaining(Consumer)->void::: sub map iter for each remaining
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter#estimateSize()->long::: sub map iter estimate size
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapValueIterator#next()->V::: sub map value iterator next
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapValueIterator#characteristics()->int::: sub map value iterator characteristics
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#next()->K::: sub map key iterator next
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#characteristics()->int::: sub map key iterator characteristics
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapKeyIterator#getComparator()->Comparator::: sub map key iterator get comparator
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapEntryIterator#next()->Map.Entry::: sub map entry iterator next
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapEntryIterator#characteristics()->int::: sub map entry iterator characteristics
java.util.concurrent.ConcurrentSkipListMap#forEach(BiConsumer)->void::: concurrent skip list map for each
java.util.concurrent.ConcurrentSkipListMap#replaceAll(BiFunction)->void::: concurrent skip list map replace all
java.util.concurrent.ConcurrentSkipListMap#removeEntryIf(Predicate>)->boolean:::Helper method for EntrySet.removeIf.
java.util.concurrent.ConcurrentSkipListMap#removeValueIf(Predicate)->boolean:::Helper method for Values.removeIf.
java.util.concurrent.ConcurrentSkipListMap.CSLMSpliterator#estimateSize()->long::: spliterator estimate size
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#trySplit()->KeySpliterator::: key spliterator try split
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#forEachRemaining(Consumer)->void::: key spliterator for each remaining
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#tryAdvance(Consumer)->boolean::: key spliterator try advance
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#characteristics()->int::: key spliterator characteristics
java.util.concurrent.ConcurrentSkipListMap.KeySpliterator#getComparator()->Comparator::: key spliterator get comparator
java.util.concurrent.ConcurrentSkipListMap#keySpliterator()->KeySpliterator::: concurrent skip list map key spliterator
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#trySplit()->ValueSpliterator::: value spliterator try split
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#forEachRemaining(Consumer)->void::: value spliterator for each remaining
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#tryAdvance(Consumer)->boolean::: value spliterator try advance
java.util.concurrent.ConcurrentSkipListMap.ValueSpliterator#characteristics()->int::: value spliterator characteristics
java.util.concurrent.ConcurrentSkipListMap#valueSpliterator()->ValueSpliterator::: concurrent skip list map value spliterator
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#trySpliterator trySplit()->En::: entry spliterator try split
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#forEachRemaining(Consumer>)->void::: entry spliterator for each remaining
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#tryAdvance(Consumer>)->boolean::: entry spliterator try advance
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#characteristics()->int::: entry spliterator characteristics
java.util.concurrent.ConcurrentSkipListMap.EntrySpliterator#getComparator()->Comparator>::: entry spliterator get comparator
java.util.concurrent.ConcurrentSkipListMap#entrySpliterator()->EntrySpliterator::: concurrent skip list map entry spliterator
java.util.concurrent.ConcurrentSkipListSet#clone()->ConcurrentSkipListSet:::Returns a shallow copy of this ConcurrentSkipListSet instance
java.util.concurrent.ConcurrentSkipListSet#size()->int:::Returns the number of elements in this set
java.util.concurrent.ConcurrentSkipListSet#isEmpty()->boolean:::Returns true if this set contains no elements.
java.util.concurrent.ConcurrentSkipListSet#contains(Object)->boolean:::Returns true if this set contains the specified element
java.util.concurrent.ConcurrentSkipListSet#add(E)->boolean:::Adds the specified element to this set if it is not already present
java.util.concurrent.ConcurrentSkipListSet#remove(Object)->boolean:::Removes the specified element from this set if it is present
java.util.concurrent.ConcurrentSkipListSet#clear()->void:::Removes all of the elements from this set.
java.util.concurrent.ConcurrentSkipListSet#iterator()->Iterator:::Returns an iterator over the elements in this set in ascending order.
java.util.concurrent.ConcurrentSkipListSet#descendingIterator()->Iterator:::Returns an iterator over the elements in this set in descending order.
java.util.concurrent.ConcurrentSkipListSet#equals(Object)->boolean:::Compares the specified object with this set for equality
java.util.concurrent.ConcurrentSkipListSet#removeAll(Collection)->boolean:::Removes from this set all of its elements that are contained in the specified collection
java.util.concurrent.ConcurrentSkipListSet#lower(E)->E::: concurrent skip list set lower
java.util.concurrent.ConcurrentSkipListSet#floor(E)->E::: concurrent skip list set floor
java.util.concurrent.ConcurrentSkipListSet#ceiling(E)->E::: concurrent skip list set ceiling
java.util.concurrent.ConcurrentSkipListSet#higher(E)->E::: concurrent skip list set higher
java.util.concurrent.ConcurrentSkipListSet#pollFirst()->E::: concurrent skip list set poll first
java.util.concurrent.ConcurrentSkipListSet#pollLast()->E::: concurrent skip list set poll last
java.util.concurrent.ConcurrentSkipListSet#comparator()->Comparator::: concurrent skip list set comparator
java.util.concurrent.ConcurrentSkipListSet#first()->E::: concurrent skip list set first
java.util.concurrent.ConcurrentSkipListSet#last()->E::: concurrent skip list set last
java.util.concurrent.ConcurrentSkipListSet#subSet(E, boolean, E, boolean)->NavigableSet::: concurrent skip list set sub set
java.util.concurrent.ConcurrentSkipListSet#headSet(E, boolean)->NavigableSet::: concurrent skip list set head set
java.util.concurrent.ConcurrentSkipListSet#tailSet(E, boolean)->NavigableSet::: concurrent skip list set tail set
java.util.concurrent.ConcurrentSkipListSet#subSet(E, E)->NavigableSet::: concurrent skip list set sub set
java.util.concurrent.ConcurrentSkipListSet#headSet(E)->NavigableSet::: concurrent skip list set head set
java.util.concurrent.ConcurrentSkipListSet#tailSet(E)->NavigableSet::: concurrent skip list set tail set
java.util.concurrent.ConcurrentSkipListSet#descendingSet()->NavigableSet:::Returns a reverse order view of the elements contained in this set
java.util.concurrent.ConcurrentSkipListSet#spliterator()->Spliterator:::Returns a Spliterator over the elements in this set
java.util.concurrent.CopyOnWriteArrayList#getArray()->Object[]:::Gets the array
java.util.concurrent.CopyOnWriteArrayList#setArray(Object[])->void:::Sets the array.
java.util.concurrent.CopyOnWriteArrayList#size()->int:::Returns the number of elements in this list.
java.util.concurrent.CopyOnWriteArrayList#isEmpty()->boolean:::Returns true if this list contains no elements.
java.util.concurrent.CopyOnWriteArrayList#contains(Object)->boolean:::Returns true if this list contains the specified element
java.util.concurrent.CopyOnWriteArrayList#indexOf(Object)->int::: copy on write array list index of
java.util.concurrent.CopyOnWriteArrayList#indexOf(E, int)->int:::Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found
java.util.concurrent.CopyOnWriteArrayList#lastIndexOf(Object)->int::: copy on write array list last index of
java.util.concurrent.CopyOnWriteArrayList#lastIndexOf(E, int)->int:::Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found
java.util.concurrent.CopyOnWriteArrayList#clone()->Object:::Returns a shallow copy of this list
java.util.concurrent.CopyOnWriteArrayList#toArray()->Object[]:::Returns an array containing all of the elements in this list in proper sequence (from first to last element)
java.util.concurrent.CopyOnWriteArrayList#toArray(T[])->T[]:::Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array
java.util.concurrent.CopyOnWriteArrayList#elementAt(Object[], int)->E::: copy on write array list element at
java.util.concurrent.CopyOnWriteArrayList#outOfBounds(int, int)->String::: copy on write array list out of bounds
java.util.concurrent.CopyOnWriteArrayList#get(int)->E::: copy on write array list get
java.util.concurrent.CopyOnWriteArrayList#set(int, E)->E:::Replaces the element at the specified position in this list with the specified element.
java.util.concurrent.CopyOnWriteArrayList#add(E)->boolean:::Appends the specified element to the end of this list.
java.util.concurrent.CopyOnWriteArrayList#add(int, E)->void:::Inserts the specified element at the specified position in this list
java.util.concurrent.CopyOnWriteArrayList#remove(int)->E:::Removes the element at the specified position in this list
java.util.concurrent.CopyOnWriteArrayList#remove(Object)->boolean:::Removes the first occurrence of the specified element from this list, if it is present
java.util.concurrent.CopyOnWriteArrayList#removeRange(int, int)->void:::Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive
java.util.concurrent.CopyOnWriteArrayList#addIfAbsent(E)->boolean:::Appends the element, if not present.
java.util.concurrent.CopyOnWriteArrayList#containsAll(Collection)->boolean:::Returns true if this list contains all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArrayList#removeAll(Collection)->boolean:::Removes from this list all of its elements that are contained in the specified collection
java.util.concurrent.CopyOnWriteArrayList#retainAll(Collection)->boolean:::Retains only the elements in this list that are contained in the specified collection
java.util.concurrent.CopyOnWriteArrayList#addAllAbsent(Collection)->int:::Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList#clear()->void:::Removes all of the elements from this list
java.util.concurrent.CopyOnWriteArrayList#addAll(Collection)->boolean:::Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList#addAll(int, Collection)->boolean:::Inserts all of the elements in the specified collection into this list, starting at the specified position
java.util.concurrent.CopyOnWriteArrayList#forEach(Consumer)->void::: copy on write array list for each
java.util.concurrent.CopyOnWriteArrayList#removeIf(Predicate)->boolean::: copy on write array list remove if
java.util.concurrent.CopyOnWriteArrayList#bulkRemove(Predicate, int, int)->boolean::: copy on write array list bulk remove
java.util.concurrent.CopyOnWriteArrayList#replaceAll(UnaryOperator)->void::: copy on write array list replace all
java.util.concurrent.CopyOnWriteArrayList#replaceAllRange(UnaryOperator, int, int)->void::: copy on write array list replace all range
java.util.concurrent.CopyOnWriteArrayList#sort(Comparator)->void::: copy on write array list sort
java.util.concurrent.CopyOnWriteArrayList#sortRange(Comparator, int, int)->void::: copy on write array list sort range
java.util.concurrent.CopyOnWriteArrayList#toString()->String:::Returns a string representation of this list
java.util.concurrent.CopyOnWriteArrayList#equals(Object)->boolean:::Compares the specified object with this list for equality
java.util.concurrent.CopyOnWriteArrayList#hashCode()->int:::Returns the hash code value for this list
java.util.concurrent.CopyOnWriteArrayList#iterator()->Iterator:::Returns an iterator over the elements in this list in proper sequence
java.util.concurrent.CopyOnWriteArrayList#listIterator()->ListIterator:::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed
java.util.concurrent.CopyOnWriteArrayList#listIterator(int)->ListIterator:::  The returned iterator provides a snapshot of the state of the list when the iterator was constructed
java.util.concurrent.CopyOnWriteArrayList#spliterator()->Spliterator:::Returns a Spliterator over the elements in this list
java.util.concurrent.CopyOnWriteArrayList.COWIterator#hasNext()->boolean::: iterator has next
java.util.concurrent.CopyOnWriteArrayList.COWIterator#hasPrevious()->boolean::: iterator has previous
java.util.concurrent.CopyOnWriteArrayList.COWIterator#next()->E::: iterator next
java.util.concurrent.CopyOnWriteArrayList.COWIterator#previous()->E::: iterator previous
java.util.concurrent.CopyOnWriteArrayList.COWIterator#nextIndex()->int::: iterator next index
java.util.concurrent.CopyOnWriteArrayList.COWIterator#previousIndex()->int::: iterator previous index
java.util.concurrent.CopyOnWriteArrayList.COWIterator#remove()->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#set(E)->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#add(E)->void:::Not supported
java.util.concurrent.CopyOnWriteArrayList.COWIterator#forEachRemaining(Consumer)->void::: iterator for each remaining
java.util.concurrent.CopyOnWriteArrayList#subList(int, int)->List:::Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive
java.util.concurrent.CopyOnWriteArraySet#size()->int:::Returns the number of elements in this set.
java.util.concurrent.CopyOnWriteArraySet#isEmpty()->boolean:::Returns true if this set contains no elements.
java.util.concurrent.CopyOnWriteArraySet#contains(Object)->boolean:::Returns true if this set contains the specified element
java.util.concurrent.CopyOnWriteArraySet#toArray()->Object[]:::Returns an array containing all of the elements in this set
java.util.concurrent.CopyOnWriteArraySet#toArray(T[])->T[]:::Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array
java.util.concurrent.CopyOnWriteArraySet#clear()->void:::Removes all of the elements from this set
java.util.concurrent.CopyOnWriteArraySet#remove(Object)->boolean:::Removes the specified element from this set if it is present
java.util.concurrent.CopyOnWriteArraySet#add(E)->boolean:::Adds the specified element to this set if it is not already present
java.util.concurrent.CopyOnWriteArraySet#containsAll(Collection)->boolean:::Returns true if this set contains all of the elements of the specified collection
java.util.concurrent.CopyOnWriteArraySet#addAll(Collection)->boolean:::Adds all of the elements in the specified collection to this set if they're not already present
java.util.concurrent.CopyOnWriteArraySet#removeAll(Collection)->boolean:::Removes from this set all of its elements that are contained in the specified collection
java.util.concurrent.CopyOnWriteArraySet#retainAll(Collection)->boolean:::Retains only the elements in this set that are contained in the specified collection
java.util.concurrent.CopyOnWriteArraySet#iterator()->Iterator:::Returns an iterator over the elements contained in this set in the order in which these elements were added
java.util.concurrent.CopyOnWriteArraySet#equals(Object)->boolean:::Compares the specified object with this set for equality
java.util.concurrent.CopyOnWriteArraySet#removeIf(Predicate)->boolean::: copy on write array set remove if
java.util.concurrent.CopyOnWriteArraySet#forEach(Consumer)->void::: copy on write array set for each
java.util.concurrent.CopyOnWriteArraySet#spliterator()->Spliterator:::Returns a Spliterator over the elements in this set in the order in which these elements were added
java.util.concurrent.CountDownLatch#await()->void:::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted
java.util.concurrent.CountDownLatch#await(long, TimeUnit)->boolean:::Causes the current thread to wait until the latch has counted down to zero, unless the thread is Thread#interrupt interrupted, or the specified waiting time elapses
java.util.concurrent.CountDownLatch#countDown()->void:::Decrements the count of the latch, releasing all waiting threads if the count reaches zero
java.util.concurrent.CountDownLatch#getCount()->long:::Returns the current count
java.util.concurrent.CountDownLatch#toString()->String:::Returns a string identifying this latch, as well as its state
java.util.concurrent.CountedCompleter#compute()->void:::The main computation performed by this task.
java.util.concurrent.CountedCompleter#onCompletion(CountedCompleter)->void:::Performs an action when method #tryComplete is invoked and the pending count is zero, or when the unconditional method #complete is invoked
java.util.concurrent.CountedCompleter#onExceptionalCompletion(Throwable, CountedCompleter)->boolean:::Performs an action when method #completeExceptionally(Throwable) is invoked or method #compute throws an exception, and this task has not already otherwise completed normally
java.util.concurrent.CountedCompleter#getCompleter()->CountedCompleter:::Returns the completer established in this task's constructor, or null if none.
java.util.concurrent.CountedCompleter#getPendingCount()->int:::Returns the current pending count.
java.util.concurrent.CountedCompleter#setPendingCount(int)->void:::Sets the pending count to the given value.
java.util.concurrent.CountedCompleter#addToPendingCount(int)->void:::Adds (atomically) the given value to the pending count.
java.util.concurrent.CountedCompleter#compareAndSetPendingCount(int, int)->boolean:::Sets (atomically) the pending count to the given count only if it currently holds the given expected value.
java.util.concurrent.CountedCompleter#decrementPendingCountUnlessZero()->int:::If the pending count is nonzero, (atomically) decrements it.
java.util.concurrent.CountedCompleter#getRoot()->CountedCompleter:::Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.
java.util.concurrent.CountedCompleter#tryComplete()->void:::If the pending count is nonzero, decrements the count; otherwise invokes #onCompletion(CountedCompleter) and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.
java.util.concurrent.CountedCompleter#propagateCompletion()->void:::Equivalent to #tryComplete but does not invoke #onCompletion(CountedCompleter) along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete
java.util.concurrent.CountedCompleter#complete(T)->void:::Regardless of pending count, invokes #onCompletion(CountedCompleter), marks this task as complete and further triggers #tryComplete on this task's completer, if one exists
java.util.concurrent.CountedCompleter#firstComplete()->CountedCompleter:::If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null
java.util.concurrent.CountedCompleter#nextComplete()->CountedCompleter:::If this task does not have a completer, invokes ForkJoinTask#quietlyComplete and returns null
java.util.concurrent.CountedCompleter#quietlyCompleteRoot()->void:::Equivalent to getRoot().quietlyComplete().
java.util.concurrent.CountedCompleter#helpComplete(int)->void:::If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.
java.util.concurrent.CountedCompleter#internalPropagateException(Throwable)->void:::Supports ForkJoinTask exception propagation.
java.util.concurrent.CountedCompleter#exec()->boolean:::Implements execution conventions for CountedCompleters.
java.util.concurrent.CountedCompleter#getRawResult()->T:::Returns the result of the computation
java.util.concurrent.CountedCompleter#setRawResult(T)->void:::A method that result-bearing CountedCompleters may optionally use to help maintain result data
java.util.concurrent.CyclicBarrier#getParties()->int:::Returns the number of parties required to trip this barrier.
java.util.concurrent.CyclicBarrier#await()->int:::Waits until all #getParties parties have invoked await on this barrier
java.util.concurrent.CyclicBarrier#await(long, TimeUnit)->int:::Waits until all #getParties parties have invoked await on this barrier, or the specified waiting time elapses
java.util.concurrent.CyclicBarrier#isBroken()->boolean:::Queries if this barrier is in a broken state.
java.util.concurrent.CyclicBarrier#reset()->void:::Resets the barrier to its initial state
java.util.concurrent.CyclicBarrier#getNumberWaiting()->int:::Returns the number of parties currently waiting at the barrier
java.util.concurrent.Delayed#getDelay(TimeUnit)->long:::Returns the remaining delay associated with this object, in the given time unit.
java.util.concurrent.DelayQueue#add(E)->boolean:::Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue#offer(E)->boolean:::Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue#put(E)->void:::Inserts the specified element into this delay queue
java.util.concurrent.DelayQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this delay queue
java.util.concurrent.DelayQueue#poll()->E:::Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.
java.util.concurrent.DelayQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.
java.util.concurrent.DelayQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.
java.util.concurrent.DelayQueue#peek()->E:::Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty
java.util.concurrent.DelayQueue#size()->int::: delay queue size
java.util.concurrent.DelayQueue#drainTo(Collection)->int::: delay queue drain to
java.util.concurrent.DelayQueue#drainTo(Collection, int)->int::: delay queue drain to
java.util.concurrent.DelayQueue#clear()->void:::Atomically removes all of the elements from this delay queue
java.util.concurrent.DelayQueue#remainingCapacity()->int:::Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.
java.util.concurrent.DelayQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue
java.util.concurrent.DelayQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array
java.util.concurrent.DelayQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.
java.util.concurrent.DelayQueue#removeEQ(Object)->void:::Identity-based version for use in Itr.remove.
java.util.concurrent.DelayQueue#iterator()->Iterator:::Returns an iterator over all the elements (both expired and unexpired) in this queue
java.util.concurrent.Exchanger.Participant#initialValue()->Node::: participant initial value
java.util.concurrent.Exchanger#exchange(V)->V:::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted), and then transfers the given object to it, receiving its object in return
java.util.concurrent.Exchanger#exchange(V, long, TimeUnit)->V:::Waits for another thread to arrive at this exchange point (unless the current thread is Thread#interrupt interrupted or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return
java.util.concurrent.Executor#execute(Runnable)->void:::Executes the given command at some time in the future
java.util.concurrent.ExecutorCompletionService#submit(Callable)->Future::: executor completion service submit
java.util.concurrent.ExecutorCompletionService#submit(Runnable, V)->Future::: executor completion service submit
java.util.concurrent.ExecutorCompletionService#take()->Future::: executor completion service take
java.util.concurrent.ExecutorCompletionService#poll()->Future::: executor completion service poll
java.util.concurrent.ExecutorCompletionService#poll(long, TimeUnit)->Future::: executor completion service poll
java.util.concurrent.Executors#newFixedThreadPool(int)->ExecutorService:::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue
java.util.concurrent.Executors#newWorkStealingPool(int)->ExecutorService:::Creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention
java.util.concurrent.Executors#newWorkStealingPool()->ExecutorService:::Creates a work-stealing thread pool using the number of Runtime#availableProcessors available processors as its target parallelism level.
java.util.concurrent.Executors#newFixedThreadPool(int, ThreadFactory)->ExecutorService:::Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue, using the provided ThreadFactory to create new threads when needed
java.util.concurrent.Executors#newSingleThreadExecutor()->ExecutorService:::Creates an Executor that uses a single worker thread operating off an unbounded queue
java.util.concurrent.Executors#newSingleThreadExecutor(ThreadFactory)->ExecutorService:::Creates an Executor that uses a single worker thread operating off an unbounded queue, and uses the provided ThreadFactory to create a new thread when needed
java.util.concurrent.Executors#newCachedThreadPool()->ExecutorService:::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available
java.util.concurrent.Executors#newCachedThreadPool(ThreadFactory)->ExecutorService:::Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available, and uses the provided ThreadFactory to create new threads when needed.
java.util.concurrent.Executors#newSingleThreadScheduledExecutor()->ScheduledExecutorService:::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically
java.util.concurrent.Executors#newSingleThreadScheduledExecutor(ThreadFactory)->ScheduledExecutorService:::Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically
java.util.concurrent.Executors#newScheduledThreadPool(int)->ScheduledExecutorService:::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
java.util.concurrent.Executors#newScheduledThreadPool(int, ThreadFactory)->ScheduledExecutorService:::Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
java.util.concurrent.Executors#unconfigurableExecutorService(ExecutorService)->ExecutorService:::Returns an object that delegates all defined ExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts
java.util.concurrent.Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService)->ScheduledExecutorService:::Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts
java.util.concurrent.Executors#defaultThreadFactory()->ThreadFactory:::Returns a default thread factory used to create new threads
java.util.concurrent.Executors#privilegedThreadFactory()->ThreadFactory:::Returns a thread factory used to create new threads that have the same permissions as the current thread
java.util.concurrent.Executors#callable(Runnable, T)->Callable:::Returns a Callable object that, when called, runs the given task and returns the given result
java.util.concurrent.Executors#callable(Runnable)->Callable:::Returns a Callable object that, when called, runs the given task and returns null.
java.util.concurrent.Executors#callable(PrivilegedAction)->Callable:::Returns a Callable object that, when called, runs the given privileged action and returns its result.
java.util.concurrent.Executors#callable(PrivilegedExceptionAction)->Callable:::Returns a Callable object that, when called, runs the given privileged exception action and returns its result.
java.util.concurrent.Executors#privilegedCallable(Callable)->Callable:::Returns a Callable object that will, when called, execute the given callable under the current access control context
java.util.concurrent.Executors#privilegedCallableUsingCurrentClassLoader(Callable)->Callable:::Returns a Callable object that will, when called, execute the given callable under the current access control context, with the current context class loader as the context class loader
java.util.concurrent.ExecutorService#shutdown()->void:::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted
java.util.concurrent.ExecutorService#shutdownNow()->List:::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution
java.util.concurrent.ExecutorService#isShutdown()->boolean:::Returns true if this executor has been shut down.
java.util.concurrent.ExecutorService#isTerminated()->boolean:::Returns true if all tasks have completed following shut down
java.util.concurrent.ExecutorService#awaitTermination(long, TimeUnit)->boolean:::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.
java.util.concurrent.ExecutorService#submit(Callable)->Future:::Submits a value-returning task for execution and returns a Future representing the pending results of the task
java.util.concurrent.ExecutorService#submit(Runnable, T)->Future:::Submits a Runnable task for execution and returns a Future representing that task
java.util.concurrent.ExecutorService#submit(Runnable)->Future:::Submits a Runnable task for execution and returns a Future representing that task
java.util.concurrent.ExecutorService#invokeAll(Collection>)->List>:::Executes the given tasks, returning a list of Futures holding their status and results when all complete
java.util.concurrent.ExecutorService#invokeAll(Collection>, long, TimeUnit)->List>:::Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first
java.util.concurrent.ExecutorService#invokeAny(Collection>)->T:::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do
java.util.concurrent.ExecutorService#invokeAny(Collection>, long, TimeUnit)->T:::Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses
java.util.concurrent.Flow.Publisher#subscribe(Subscriber)->void:::Adds the given Subscriber if possible
java.util.concurrent.Flow.Subscriber#onSubscribe(Subscription)->void:::Method invoked prior to invoking any other Subscriber methods for the given Subscription
java.util.concurrent.Flow.Subscriber#onNext(T)->void:::Method invoked with a Subscription's next item
java.util.concurrent.Flow.Subscriber#onError(Throwable)->void:::Method invoked upon an unrecoverable error encountered by a Publisher or Subscription, after which no other Subscriber methods are invoked by the Subscription
java.util.concurrent.Flow.Subscriber#onComplete()->void:::Method invoked when it is known that no additional Subscriber method invocations will occur for a Subscription that is not already terminated by error, after which no other Subscriber methods are invoked by the Subscription
java.util.concurrent.Flow.Subscription#request(long)->void:::Adds the given number n of items to the current unfulfilled demand for this subscription
java.util.concurrent.Flow.Subscription#cancel()->void:::Causes the Subscriber to (eventually) stop receiving messages
java.util.concurrent.Flow#defaultBufferSize()->int:::Returns a default value for Publisher or Subscriber buffering, that may be used in the absence of other constraints.
java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory#newThread(ForkJoinPool)->ForkJoinWorkerThread:::Returns a new worker thread operating in the given pool
java.util.concurrent.ForkJoinPool#contextWithPermissions(Permission...)->AccessControlContext::: fork join pool context with permissions
java.util.concurrent.ForkJoinPool.WorkQueue#tryLockPhase()->boolean:::Tries to lock shared queue by CASing phase field.
java.util.concurrent.ForkJoinPool.WorkQueue#releasePhaseLock()->void::: work queue release phase lock
java.util.concurrent.ForkJoinPool.WorkQueue#getPoolIndex()->int:::Returns an exportable index (used by ForkJoinWorkerThread).
java.util.concurrent.ForkJoinPool.WorkQueue#queueSize()->int:::Returns the approximate number of tasks in the queue.
java.util.concurrent.ForkJoinPool.WorkQueue#isEmpty()->boolean:::Provides a more accurate estimate of whether this queue has any tasks than does queueSize, by checking whether a near-empty queue has at least one unclaimed task.
java.util.concurrent.ForkJoinPool.WorkQueue#push(ForkJoinTask)->void:::Pushes a task
java.util.concurrent.ForkJoinPool.WorkQueue#lockedPush(ForkJoinTask)->boolean:::Version of push for shared queues
java.util.concurrent.ForkJoinPool.WorkQueue#growArray(boolean)->void:::Doubles the capacity of array
java.util.concurrent.ForkJoinPool.WorkQueue#poll()->ForkJoinTask:::Takes next task, if one exists, in FIFO order.
java.util.concurrent.ForkJoinPool.WorkQueue#nextLocalTask()->ForkJoinTask:::Takes next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue#peek()->ForkJoinTask:::Returns next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue#tryUnpush(ForkJoinTask)->boolean:::Pops the given task only if it is at the current top.
java.util.concurrent.ForkJoinPool.WorkQueue#tryLockedUnpush(ForkJoinTask)->boolean:::Shared version of tryUnpush.
java.util.concurrent.ForkJoinPool.WorkQueue#cancelAll()->void:::Removes and cancels all known tasks, ignoring any exceptions.
java.util.concurrent.ForkJoinPool.WorkQueue#topLevelExec(ForkJoinTask, WorkQueue, int)->void:::Runs the given (stolen) task if nonnull, as well as remaining local tasks and others available from the given queue, up to bound n (to avoid infinite unfairness).
java.util.concurrent.ForkJoinPool.WorkQueue#tryRemoveAndExec(ForkJoinTask)->void:::If present, removes task from queue and executes it.
java.util.concurrent.ForkJoinPool.WorkQueue#helpCC(CountedCompleter, int, boolean)->int:::Tries to pop and run tasks within the target's computation until done, not found, or limit exceeded.
java.util.concurrent.ForkJoinPool.WorkQueue#helpAsyncBlocker(ManagedBlocker)->void:::Tries to poll and run AsynchronousCompletionTasks until none found or blocker is released
java.util.concurrent.ForkJoinPool.WorkQueue#isApparentlyUnblocked()->boolean:::Returns true if owned and not known to be blocked.
java.util.concurrent.ForkJoinPool#registerWorker(ForkJoinWorkerThread)->WorkQueue:::Callback from ForkJoinWorkerThread constructor to establish and record its WorkQueue.
java.util.concurrent.ForkJoinPool#deregisterWorker(ForkJoinWorkerThread, Throwable)->void:::Final callback from terminating worker, as well as upon failure to construct or start a worker
java.util.concurrent.ForkJoinPool#signalWork()->void:::Tries to create or release a worker if too few are running.
java.util.concurrent.ForkJoinPool#runWorker(WorkQueue)->void:::Top-level runloop for workers, called by ForkJoinWorkerThread.run
java.util.concurrent.ForkJoinPool#awaitJoin(WorkQueue, ForkJoinTask, long)->int:::Helps and/or blocks until the given task is done or timeout
java.util.concurrent.ForkJoinPool#helpQuiescePool(WorkQueue)->void:::Runs tasks until isQuiescent()
java.util.concurrent.ForkJoinPool#nextTaskFor(WorkQueue)->ForkJoinTask:::Gets and removes a local or stolen task for the given worker.
java.util.concurrent.ForkJoinPool#externalPush(ForkJoinTask)->void:::Adds the given task to a submission queue at submitter's current queue, creating one if null or contended.
java.util.concurrent.ForkJoinPool#commonSubmitterQueue()->WorkQueue:::Returns common pool queue for an external thread.
java.util.concurrent.ForkJoinPool#tryExternalUnpush(ForkJoinTask)->boolean:::Performs tryUnpush for an external submitter.
java.util.concurrent.ForkJoinPool#externalHelpComplete(CountedCompleter, int)->int:::Performs helpComplete for an external submitter.
java.util.concurrent.ForkJoinPool#helpComplete(WorkQueue, CountedCompleter, int)->int:::Tries to steal and run tasks within the target's computation
java.util.concurrent.ForkJoinPool#getSurplusQueuedTaskCount()->int:::Returns a cheap heuristic guide for task partitioning when programmers, frameworks, tools, or languages have little or no idea about task granularity
java.util.concurrent.ForkJoinPool#commonPool()->ForkJoinPool:::Returns the common pool instance
java.util.concurrent.ForkJoinPool#invoke(ForkJoinTask)->T:::Performs the given task, returning its result upon completion
java.util.concurrent.ForkJoinPool#execute(ForkJoinTask)->void:::Arranges for (asynchronous) execution of the given task.
java.util.concurrent.ForkJoinPool#execute(Runnable)->void::: fork join pool execute
java.util.concurrent.ForkJoinPool#submit(ForkJoinTask)->ForkJoinTask:::Submits a ForkJoinTask for execution.
java.util.concurrent.ForkJoinPool#submit(Callable)->ForkJoinTask::: fork join pool submit
java.util.concurrent.ForkJoinPool#submit(Runnable, T)->ForkJoinTask::: fork join pool submit
java.util.concurrent.ForkJoinPool#submit(Runnable)->ForkJoinTask::: fork join pool submit
java.util.concurrent.ForkJoinPool#invokeAll(Collection>)->List>::: fork join pool invoke all
java.util.concurrent.ForkJoinPool#getFactory()->ForkJoinWorkerThreadFactory:::Returns the factory used for constructing new workers.
java.util.concurrent.ForkJoinPool#getUncaughtExceptionHandler()->UncaughtExceptionHandler:::Returns the handler for internal worker threads that terminate due to unrecoverable errors encountered while executing tasks.
java.util.concurrent.ForkJoinPool#getParallelism()->int:::Returns the targeted parallelism level of this pool.
java.util.concurrent.ForkJoinPool#getCommonPoolParallelism()->int:::Returns the targeted parallelism level of the common pool.
java.util.concurrent.ForkJoinPool#getPoolSize()->int:::Returns the number of worker threads that have started but not yet terminated
java.util.concurrent.ForkJoinPool#getAsyncMode()->boolean:::Returns true if this pool uses local first-in-first-out scheduling mode for forked tasks that are never joined.
java.util.concurrent.ForkJoinPool#getRunningThreadCount()->int:::Returns an estimate of the number of worker threads that are not blocked waiting to join tasks or for other managed synchronization
java.util.concurrent.ForkJoinPool#getActiveThreadCount()->int:::Returns an estimate of the number of threads that are currently stealing or executing tasks
java.util.concurrent.ForkJoinPool#isQuiescent()->boolean:::Returns true if all worker threads are currently idle
java.util.concurrent.ForkJoinPool#getStealCount()->long:::Returns an estimate of the total number of tasks stolen from one thread's work queue by another
java.util.concurrent.ForkJoinPool#getQueuedTaskCount()->long:::Returns an estimate of the total number of tasks currently held in queues by worker threads (but not including tasks submitted to the pool that have not begun executing)
java.util.concurrent.ForkJoinPool#getQueuedSubmissionCount()->int:::Returns an estimate of the number of tasks submitted to this pool that have not yet begun executing
java.util.concurrent.ForkJoinPool#hasQueuedSubmissions()->boolean:::Returns true if there are any tasks submitted to this pool that have not yet begun executing.
java.util.concurrent.ForkJoinPool#pollSubmission()->ForkJoinTask:::Removes and returns the next unexecuted submission if one is available
java.util.concurrent.ForkJoinPool#drainTasksTo(Collection>)->int:::Removes all available unexecuted submitted and forked tasks from scheduling queues and adds them to the given collection, without altering their execution status
java.util.concurrent.ForkJoinPool#toString()->String:::Returns a string identifying this pool, as well as its state, including indications of run state, parallelism level, and worker and task counts.
java.util.concurrent.ForkJoinPool#shutdown()->void:::Possibly initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted
java.util.concurrent.ForkJoinPool#shutdownNow()->List:::Possibly attempts to cancel and/or stop all tasks, and reject all subsequently submitted tasks
java.util.concurrent.ForkJoinPool#isTerminated()->boolean:::Returns true if all tasks have completed following shut down.
java.util.concurrent.ForkJoinPool#isTerminating()->boolean:::Returns true if the process of termination has commenced but not yet completed
java.util.concurrent.ForkJoinPool#isShutdown()->boolean:::Returns true if this pool has been shut down.
java.util.concurrent.ForkJoinPool#awaitTermination(long, TimeUnit)->boolean:::Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first
java.util.concurrent.ForkJoinPool#awaitQuiescence(long, TimeUnit)->boolean:::If called by a ForkJoinTask operating in this pool, equivalent in effect to ForkJoinTask#helpQuiesce
java.util.concurrent.ForkJoinPool#quiesceCommonPool()->void:::Waits and/or attempts to assist performing tasks indefinitely until the #commonPool() #isQuiescent.
java.util.concurrent.ForkJoinPool.ManagedBlocker#block()->boolean:::Possibly blocks the current thread, for example waiting for a lock or condition.
java.util.concurrent.ForkJoinPool.ManagedBlocker#isReleasable()->boolean:::Returns true if blocking is unnecessary.
java.util.concurrent.ForkJoinPool#managedBlock(ManagedBlocker)->void:::Runs the given possibly blocking task
java.util.concurrent.ForkJoinPool#helpAsyncBlocker(Executor, ManagedBlocker)->void:::If the given executor is a ForkJoinPool, poll and execute AsynchronousCompletionTasks from worker's queue until none are available or blocker is released.
java.util.concurrent.ForkJoinPool#newTaskFor(Runnable, T)->RunnableFuture::: fork join pool new task for
java.util.concurrent.ForkJoinPool#newTaskFor(Callable)->RunnableFuture::: fork join pool new task for
java.util.concurrent.ForkJoinTask#isExceptionalStatus(int)->boolean::: fork join task is exceptional status
java.util.concurrent.ForkJoinTask#doExec()->int:::Primary execution method for stolen tasks
java.util.concurrent.ForkJoinTask#internalWait(long)->void:::If not done, sets SIGNAL status and performs Object.wait(timeout)
java.util.concurrent.ForkJoinTask#recordExceptionalCompletion(Throwable)->int:::Records exception and sets status.
java.util.concurrent.ForkJoinTask#internalPropagateException(Throwable)->void:::Hook for exception propagation support for tasks with completers.
java.util.concurrent.ForkJoinTask#cancelIgnoringExceptions(ForkJoinTask)->void:::Cancels, ignoring any exceptions thrown by cancel
java.util.concurrent.ForkJoinTask#helpExpungeStaleExceptions()->void:::If lock is available, polls stale refs and removes them
java.util.concurrent.ForkJoinTask#rethrow(Throwable)->void:::A version of "sneaky throw" to relay exceptions.
java.util.concurrent.ForkJoinTask#uncheckedThrow(Throwable)->void:::The sneaky part of sneaky throw, relying on generics limitations to evade compiler complaints about rethrowing unchecked exceptions.
java.util.concurrent.ForkJoinTask#fork()->ForkJoinTask:::Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool#commonPool() if not #inForkJoinPool
java.util.concurrent.ForkJoinTask#join()->V:::Returns the result of the computation when it #isDone is done
java.util.concurrent.ForkJoinTask#invoke()->V:::Commences performing this task, awaits its completion if necessary, and returns its result, or throws an (unchecked) RuntimeException or Error if the underlying computation did so.
java.util.concurrent.ForkJoinTask#invokeAll(ForkJoinTask, ForkJoinTask)->void:::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown
java.util.concurrent.ForkJoinTask#invokeAll(ForkJoinTask...)->void:::Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown
java.util.concurrent.ForkJoinTask#invokeAll(Collection)->Collection:::Forks all tasks in the specified collection, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown
java.util.concurrent.ForkJoinTask#cancel(boolean)->boolean:::Attempts to cancel execution of this task
java.util.concurrent.ForkJoinTask#isDone()->boolean::: fork join task is done
java.util.concurrent.ForkJoinTask#isCancelled()->boolean::: fork join task is cancelled
java.util.concurrent.ForkJoinTask#isCompletedAbnormally()->boolean:::Returns true if this task threw an exception or was cancelled.
java.util.concurrent.ForkJoinTask#isCompletedNormally()->boolean:::Returns true if this task completed without throwing an exception and was not cancelled.
java.util.concurrent.ForkJoinTask#getException()->Throwable:::Returns the exception thrown by the base computation, or a CancellationException if cancelled, or null if none or if the method has not yet completed.
java.util.concurrent.ForkJoinTask#completeExceptionally(Throwable)->void:::Completes this task abnormally, and if not already aborted or cancelled, causes it to throw the given exception upon join and related operations
java.util.concurrent.ForkJoinTask#complete(V)->void:::Completes this task, and if not already aborted or cancelled, returning the given value as the result of subsequent invocations of join and related operations
java.util.concurrent.ForkJoinTask#quietlyComplete()->void:::Completes this task normally without setting a value
java.util.concurrent.ForkJoinTask#get()->V:::Waits if necessary for the computation to complete, and then retrieves its result.
java.util.concurrent.ForkJoinTask#get(long, TimeUnit)->V:::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
java.util.concurrent.ForkJoinTask#quietlyJoin()->void:::Joins this task, without returning its result or throwing its exception
java.util.concurrent.ForkJoinTask#quietlyInvoke()->void:::Commences performing this task and awaits its completion if necessary, without returning its result or throwing its exception.
java.util.concurrent.ForkJoinTask#helpQuiesce()->void:::Possibly executes tasks until the pool hosting the current task ForkJoinPool#isQuiescent is quiescent
java.util.concurrent.ForkJoinTask#reinitialize()->void:::Resets the internal bookkeeping state of this task, allowing a subsequent fork
java.util.concurrent.ForkJoinTask#getPool()->ForkJoinPool:::Returns the pool hosting the current thread, or null if the current thread is executing outside of any ForkJoinPool
java.util.concurrent.ForkJoinTask#inForkJoinPool()->boolean:::Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.
java.util.concurrent.ForkJoinTask#tryUnfork()->boolean:::Tries to unschedule this task for execution
java.util.concurrent.ForkJoinTask#getQueuedTaskCount()->int:::Returns an estimate of the number of tasks that have been forked by the current worker thread but not yet executed
java.util.concurrent.ForkJoinTask#getSurplusQueuedTaskCount()->int:::Returns an estimate of how many more locally queued tasks are held by the current worker thread than there are other worker threads that might steal them, or zero if this thread is not operating in a ForkJoinPool
java.util.concurrent.ForkJoinTask#getRawResult()->V:::Returns the result that would be returned by #join, even if this task completed abnormally, or null if this task is not known to have been completed
java.util.concurrent.ForkJoinTask#setRawResult(V)->void:::Forces the given value to be returned as a result
java.util.concurrent.ForkJoinTask#exec()->boolean:::Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally
java.util.concurrent.ForkJoinTask#peekNextLocalTask()->ForkJoinTask:::Returns, but does not unschedule or execute, a task queued by the current thread but not yet executed, if one is immediately available
java.util.concurrent.ForkJoinTask#pollNextLocalTask()->ForkJoinTask:::Unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if the current thread is operating in a ForkJoinPool
java.util.concurrent.ForkJoinTask#pollTask()->ForkJoinTask:::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available
java.util.concurrent.ForkJoinTask#pollSubmission()->ForkJoinTask:::If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available
java.util.concurrent.ForkJoinTask#getForkJoinTaskTag()->short:::Returns the tag for this task.
java.util.concurrent.ForkJoinTask#setForkJoinTaskTag(short)->short:::Atomically sets the tag value for this task and returns the old value.
java.util.concurrent.ForkJoinTask#compareAndSetForkJoinTaskTag(short, short)->boolean:::Atomically conditionally sets the tag value for this task
java.util.concurrent.ForkJoinTask.AdaptedRunnable#getRawResult()->T::: adapted runnable get raw result
java.util.concurrent.ForkJoinTask.AdaptedRunnable#setRawResult(T)->void::: adapted runnable set raw result
java.util.concurrent.ForkJoinTask.AdaptedRunnable#exec()->boolean::: adapted runnable exec
java.util.concurrent.ForkJoinTask.AdaptedRunnable#run()->void::: adapted runnable run
java.util.concurrent.ForkJoinTask.AdaptedRunnable#toString()->String::: adapted runnable to string
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#getRawResult()->Void::: adapted runnable action get raw result
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#setRawResult(Void)->void::: adapted runnable action set raw result
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#exec()->boolean::: adapted runnable action exec
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#run()->void::: adapted runnable action run
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction#toString()->String::: adapted runnable action to string
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#getRawResult()->Void::: runnable execute action get raw result
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#setRawResult(Void)->void::: runnable execute action set raw result
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#exec()->boolean::: runnable execute action exec
java.util.concurrent.ForkJoinTask.RunnableExecuteAction#internalPropagateException(Throwable)->void::: runnable execute action internal propagate exception
java.util.concurrent.ForkJoinTask.AdaptedCallable#getRawResult()->T::: adapted callable get raw result
java.util.concurrent.ForkJoinTask.AdaptedCallable#setRawResult(T)->void::: adapted callable set raw result
java.util.concurrent.ForkJoinTask.AdaptedCallable#exec()->boolean::: adapted callable exec
java.util.concurrent.ForkJoinTask.AdaptedCallable#run()->void::: adapted callable run
java.util.concurrent.ForkJoinTask.AdaptedCallable#toString()->String::: adapted callable to string
java.util.concurrent.ForkJoinTask#adapt(Runnable)->ForkJoinTask:::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns a null result upon #join.
java.util.concurrent.ForkJoinTask#adapt(Runnable, T)->ForkJoinTask:::Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns the given result upon #join.
java.util.concurrent.ForkJoinTask#adapt(Callable)->ForkJoinTask:::Returns a new ForkJoinTask that performs the call method of the given Callable as its action, and returns its result upon #join, translating any checked exceptions encountered into RuntimeException.
java.util.concurrent.ForkJoinWorkerThread#getPool()->ForkJoinPool:::Returns the pool hosting this thread.
java.util.concurrent.ForkJoinWorkerThread#getPoolIndex()->int:::Returns the unique index number of this thread in its pool
java.util.concurrent.ForkJoinWorkerThread#onStart()->void:::Initializes internal state after construction but before processing any tasks
java.util.concurrent.ForkJoinWorkerThread#onTermination(Throwable)->void:::Performs cleanup associated with termination of this worker thread
java.util.concurrent.ForkJoinWorkerThread#run()->void:::This method is required to be public, but should never be called explicitly
java.util.concurrent.ForkJoinWorkerThread#afterTopLevelExec()->void:::Non-public hook method for InnocuousForkJoinWorkerThread.
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#afterTopLevelExec()->void::: innocuous fork join worker thread after top level exec
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setUncaughtExceptionHandler(UncaughtExceptionHandler)->void::: innocuous fork join worker thread set uncaught exception handler
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread#setContextClassLoader(ClassLoader)->void::: innocuous fork join worker thread set context class loader
java.util.concurrent.Future#cancel(boolean)->boolean:::Attempts to cancel execution of this task
java.util.concurrent.Future#isCancelled()->boolean:::Returns true if this task was cancelled before it completed normally.
java.util.concurrent.Future#isDone()->boolean:::Returns true if this task completed
java.util.concurrent.Future#get()->V:::Waits if necessary for the computation to complete, and then retrieves its result.
java.util.concurrent.Future#get(long, TimeUnit)->V:::Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
java.util.concurrent.FutureTask#isCancelled()->boolean::: future task is cancelled
java.util.concurrent.FutureTask#isDone()->boolean::: future task is done
java.util.concurrent.FutureTask#cancel(boolean)->boolean::: future task cancel
java.util.concurrent.FutureTask#get()->V::: future task get
java.util.concurrent.FutureTask#get(long, TimeUnit)->V::: future task get
java.util.concurrent.FutureTask#done()->void:::Protected method invoked when this task transitions to state isDone (whether normally or via cancellation)
java.util.concurrent.FutureTask#set(V)->void:::Sets the result of this future to the given value unless this future has already been set or has been cancelled
java.util.concurrent.FutureTask#setException(Throwable)->void:::Causes this future to report an ExecutionException with the given throwable as its cause, unless this future has already been set or has been cancelled
java.util.concurrent.FutureTask#run()->void::: future task run
java.util.concurrent.FutureTask#runAndReset()->boolean:::Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled
java.util.concurrent.FutureTask#toString()->String:::Returns a string representation of this FutureTask.
java.util.concurrent.Helpers#collectionToString(Collection)->String:::An implementation of Collection.toString() suitable for classes with locks
java.util.concurrent.Helpers#toString(Object[], int, int)->String:::Like Arrays.toString(), but caller guarantees that size > 0, each element with index 0 <= i < size is a non-null String, and charLength is the sum of the lengths of the input Strings.
java.util.concurrent.Helpers#mapEntryToString(Object, Object)->String:::Optimized form of: key + "=" + val
java.util.concurrent.LinkedBlockingDeque#unlink(Node)->void:::Unlinks x.
java.util.concurrent.LinkedBlockingDeque#addFirst(E)->void::: linked blocking deque add first
java.util.concurrent.LinkedBlockingDeque#addLast(E)->void::: linked blocking deque add last
java.util.concurrent.LinkedBlockingDeque#offerFirst(E)->boolean::: linked blocking deque offer first
java.util.concurrent.LinkedBlockingDeque#offerLast(E)->boolean::: linked blocking deque offer last
java.util.concurrent.LinkedBlockingDeque#putFirst(E)->void::: linked blocking deque put first
java.util.concurrent.LinkedBlockingDeque#putLast(E)->void::: linked blocking deque put last
java.util.concurrent.LinkedBlockingDeque#offerFirst(E, long, TimeUnit)->boolean::: linked blocking deque offer first
java.util.concurrent.LinkedBlockingDeque#offerLast(E, long, TimeUnit)->boolean::: linked blocking deque offer last
java.util.concurrent.LinkedBlockingDeque#removeFirst()->E::: linked blocking deque remove first
java.util.concurrent.LinkedBlockingDeque#removeLast()->E::: linked blocking deque remove last
java.util.concurrent.LinkedBlockingDeque#pollFirst()->E::: linked blocking deque poll first
java.util.concurrent.LinkedBlockingDeque#pollLast()->E::: linked blocking deque poll last
java.util.concurrent.LinkedBlockingDeque#takeFirst()->E::: linked blocking deque take first
java.util.concurrent.LinkedBlockingDeque#takeLast()->E::: linked blocking deque take last
java.util.concurrent.LinkedBlockingDeque#pollFirst(long, TimeUnit)->E::: linked blocking deque poll first
java.util.concurrent.LinkedBlockingDeque#pollLast(long, TimeUnit)->E::: linked blocking deque poll last
java.util.concurrent.LinkedBlockingDeque#getFirst()->E::: linked blocking deque get first
java.util.concurrent.LinkedBlockingDeque#getLast()->E::: linked blocking deque get last
java.util.concurrent.LinkedBlockingDeque#peekFirst()->E::: linked blocking deque peek first
java.util.concurrent.LinkedBlockingDeque#peekLast()->E::: linked blocking deque peek last
java.util.concurrent.LinkedBlockingDeque#removeFirstOccurrence(Object)->boolean::: linked blocking deque remove first occurrence
java.util.concurrent.LinkedBlockingDeque#removeLastOccurrence(Object)->boolean::: linked blocking deque remove last occurrence
java.util.concurrent.LinkedBlockingDeque#add(E)->boolean:::Inserts the specified element at the end of this deque unless it would violate capacity restrictions
java.util.concurrent.LinkedBlockingDeque#offer(E)->boolean::: linked blocking deque offer
java.util.concurrent.LinkedBlockingDeque#put(E)->void::: linked blocking deque put
java.util.concurrent.LinkedBlockingDeque#offer(E, long, TimeUnit)->boolean::: linked blocking deque offer
java.util.concurrent.LinkedBlockingDeque#remove()->E:::Retrieves and removes the head of the queue represented by this deque
java.util.concurrent.LinkedBlockingDeque#poll()->E::: linked blocking deque poll
java.util.concurrent.LinkedBlockingDeque#take()->E::: linked blocking deque take
java.util.concurrent.LinkedBlockingDeque#poll(long, TimeUnit)->E::: linked blocking deque poll
java.util.concurrent.LinkedBlockingDeque#element()->E:::Retrieves, but does not remove, the head of the queue represented by this deque
java.util.concurrent.LinkedBlockingDeque#peek()->E::: linked blocking deque peek
java.util.concurrent.LinkedBlockingDeque#remainingCapacity()->int:::Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking
java.util.concurrent.LinkedBlockingDeque#drainTo(Collection)->int::: linked blocking deque drain to
java.util.concurrent.LinkedBlockingDeque#drainTo(Collection, int)->int::: linked blocking deque drain to
java.util.concurrent.LinkedBlockingDeque#push(E)->void::: linked blocking deque push
java.util.concurrent.LinkedBlockingDeque#pop()->E::: linked blocking deque pop
java.util.concurrent.LinkedBlockingDeque#remove(Object)->boolean:::Removes the first occurrence of the specified element from this deque
java.util.concurrent.LinkedBlockingDeque#size()->int:::Returns the number of elements in this deque.
java.util.concurrent.LinkedBlockingDeque#contains(Object)->boolean:::Returns true if this deque contains the specified element
java.util.concurrent.LinkedBlockingDeque#addAll(Collection)->boolean:::Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator
java.util.concurrent.LinkedBlockingDeque#toArray()->Object[]:::Returns an array containing all of the elements in this deque, in proper sequence (from first to last element)
java.util.concurrent.LinkedBlockingDeque#toArray(T[])->T[]:::Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array
java.util.concurrent.LinkedBlockingDeque#toString()->String::: linked blocking deque to string
java.util.concurrent.LinkedBlockingDeque#clear()->void:::Atomically removes all of the elements from this deque
java.util.concurrent.LinkedBlockingDeque#succ(Node)->Node:::Used for any element traversal that is not entirely under lock
java.util.concurrent.LinkedBlockingDeque#iterator()->Iterator:::Returns an iterator over the elements in this deque in proper sequence
java.util.concurrent.LinkedBlockingDeque#descendingIterator()->Iterator:::Returns an iterator over the elements in this deque in reverse sequential order
java.util.concurrent.LinkedBlockingDeque#spliterator()->Spliterator:::Returns a Spliterator over the elements in this deque
java.util.concurrent.LinkedBlockingDeque#forEach(Consumer)->void::: linked blocking deque for each
java.util.concurrent.LinkedBlockingDeque#forEachFrom(Consumer, Node)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedBlockingDeque#removeIf(Predicate)->boolean::: linked blocking deque remove if
java.util.concurrent.LinkedBlockingDeque#removeAll(Collection)->boolean::: linked blocking deque remove all
java.util.concurrent.LinkedBlockingDeque#retainAll(Collection)->boolean::: linked blocking deque retain all
java.util.concurrent.LinkedBlockingDeque#checkInvariants()->void::: linked blocking deque check invariants
java.util.concurrent.LinkedBlockingQueue#fullyLock()->void:::Locks to prevent both puts and takes.
java.util.concurrent.LinkedBlockingQueue#fullyUnlock()->void:::Unlocks to allow both puts and takes.
java.util.concurrent.LinkedBlockingQueue#size()->int:::Returns the number of elements in this queue.
java.util.concurrent.LinkedBlockingQueue#remainingCapacity()->int:::Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking
java.util.concurrent.LinkedBlockingQueue#put(E)->void:::Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.
java.util.concurrent.LinkedBlockingQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full
java.util.concurrent.LinkedBlockingQueue#take()->E::: linked blocking queue take
java.util.concurrent.LinkedBlockingQueue#poll(long, TimeUnit)->E::: linked blocking queue poll
java.util.concurrent.LinkedBlockingQueue#poll()->E::: linked blocking queue poll
java.util.concurrent.LinkedBlockingQueue#peek()->E::: linked blocking queue peek
java.util.concurrent.LinkedBlockingQueue#unlink(Node, Node)->void:::Unlinks interior Node p with predecessor pred.
java.util.concurrent.LinkedBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.LinkedBlockingQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.LinkedBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in proper sequence
java.util.concurrent.LinkedBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array
java.util.concurrent.LinkedBlockingQueue#toString()->String::: linked blocking queue to string
java.util.concurrent.LinkedBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.LinkedBlockingQueue#drainTo(Collection)->int::: linked blocking queue drain to
java.util.concurrent.LinkedBlockingQueue#drainTo(Collection, int)->int::: linked blocking queue drain to
java.util.concurrent.LinkedBlockingQueue#succ(Node)->Node:::Used for any element traversal that is not entirely under lock
java.util.concurrent.LinkedBlockingQueue#iterator()->Iterator:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.LinkedBlockingQueue#spliterator()->Spliterator:::Returns a Spliterator over the elements in this queue
java.util.concurrent.LinkedBlockingQueue#forEach(Consumer)->void::: linked blocking queue for each
java.util.concurrent.LinkedBlockingQueue#forEachFrom(Consumer, Node)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedBlockingQueue#removeIf(Predicate)->boolean::: linked blocking queue remove if
java.util.concurrent.LinkedBlockingQueue#removeAll(Collection)->boolean::: linked blocking queue remove all
java.util.concurrent.LinkedBlockingQueue#retainAll(Collection)->boolean::: linked blocking queue retain all
java.util.concurrent.LinkedBlockingQueue#findPred(Node, Node)->Node:::Returns the predecessor of live node p, given a node that was once a live ancestor of p (or head); allows unlinking of p.
java.util.concurrent.LinkedTransferQueue.Node#casNext(Node, Node)->boolean::: node cas next
java.util.concurrent.LinkedTransferQueue.Node#casItem(Object, Object)->boolean::: node cas item
java.util.concurrent.LinkedTransferQueue.Node#selfLink()->void:::Links node to itself to avoid garbage retention
java.util.concurrent.LinkedTransferQueue.Node#appendRelaxed(Node)->void::: node append relaxed
java.util.concurrent.LinkedTransferQueue.Node#forgetContents()->void:::Sets item (of a request node) to self and waiter to null, to avoid garbage retention after matching or cancelling
java.util.concurrent.LinkedTransferQueue.Node#isMatched()->boolean:::Returns true if this node has been matched, including the case of artificial matches due to cancellation.
java.util.concurrent.LinkedTransferQueue.Node#tryMatch(Object, Object)->boolean:::Tries to CAS-match this node; if successful, wakes waiter.
java.util.concurrent.LinkedTransferQueue.Node#cannotPrecede(boolean)->boolean:::Returns true if a node with the given mode cannot be appended to this node because this node is unmatched and has opposite data mode.
java.util.concurrent.LinkedTransferQueue#firstDataNode()->Node:::Returns the first unmatched data node, or null if none
java.util.concurrent.LinkedTransferQueue#toString()->String::: linked transfer queue to string
java.util.concurrent.LinkedTransferQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue, in proper sequence
java.util.concurrent.LinkedTransferQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array
java.util.concurrent.LinkedTransferQueue.Itr#hasNext()->boolean::: itr has next
java.util.concurrent.LinkedTransferQueue.Itr#next()->E::: itr next
java.util.concurrent.LinkedTransferQueue.Itr#forEachRemaining(Consumer)->void::: itr for each remaining
java.util.concurrent.LinkedTransferQueue.Itr#remove()->void::: itr remove
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#trySplit()->Spliterator::: spliterator try split
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#forEachRemaining(Consumer)->void::: spliterator for each remaining
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#tryAdvance(Consumer)->boolean::: spliterator try advance
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#estimateSize()->long::: spliterator estimate size
java.util.concurrent.LinkedTransferQueue.LTQSpliterator#characteristics()->int::: spliterator characteristics
java.util.concurrent.LinkedTransferQueue#spliterator()->Spliterator:::Returns a Spliterator over the elements in this queue
java.util.concurrent.LinkedTransferQueue#unsplice(Node, Node)->void:::Unsplices (now or later) the given deleted/cancelled node with the given predecessor.
java.util.concurrent.LinkedTransferQueue#put(E)->void:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#offer(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#add(E)->boolean:::Inserts the specified element at the tail of this queue
java.util.concurrent.LinkedTransferQueue#tryTransfer(E)->boolean:::Transfers the element to a waiting consumer immediately, if possible
java.util.concurrent.LinkedTransferQueue#transfer(E)->void:::Transfers the element to a consumer, waiting if necessary to do so
java.util.concurrent.LinkedTransferQueue#tryTransfer(E, long, TimeUnit)->boolean:::Transfers the element to a consumer if it is possible to do so before the timeout elapses
java.util.concurrent.LinkedTransferQueue#take()->E::: linked transfer queue take
java.util.concurrent.LinkedTransferQueue#poll(long, TimeUnit)->E::: linked transfer queue poll
java.util.concurrent.LinkedTransferQueue#poll()->E::: linked transfer queue poll
java.util.concurrent.LinkedTransferQueue#drainTo(Collection)->int::: linked transfer queue drain to
java.util.concurrent.LinkedTransferQueue#drainTo(Collection, int)->int::: linked transfer queue drain to
java.util.concurrent.LinkedTransferQueue#iterator()->Iterator:::Returns an iterator over the elements in this queue in proper sequence
java.util.concurrent.LinkedTransferQueue#peek()->E::: linked transfer queue peek
java.util.concurrent.LinkedTransferQueue#isEmpty()->boolean:::Returns true if this queue contains no elements.
java.util.concurrent.LinkedTransferQueue#hasWaitingConsumer()->boolean::: linked transfer queue has waiting consumer
java.util.concurrent.LinkedTransferQueue#size()->int:::Returns the number of elements in this queue
java.util.concurrent.LinkedTransferQueue#getWaitingConsumerCount()->int::: linked transfer queue get waiting consumer count
java.util.concurrent.LinkedTransferQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.LinkedTransferQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.LinkedTransferQueue#remainingCapacity()->int:::Always returns Integer.MAX_VALUE because a LinkedTransferQueue is not capacity constrained.
java.util.concurrent.LinkedTransferQueue#removeIf(Predicate)->boolean::: linked transfer queue remove if
java.util.concurrent.LinkedTransferQueue#removeAll(Collection)->boolean::: linked transfer queue remove all
java.util.concurrent.LinkedTransferQueue#retainAll(Collection)->boolean::: linked transfer queue retain all
java.util.concurrent.LinkedTransferQueue#clear()->void::: linked transfer queue clear
java.util.concurrent.LinkedTransferQueue#forEachFrom(Consumer, Node)->void:::Runs action on each element found during a traversal starting at p
java.util.concurrent.LinkedTransferQueue#forEach(Consumer)->void::: linked transfer queue for each
java.util.concurrent.Phaser#register()->int:::Adds a new unarrived party to this phaser
java.util.concurrent.Phaser#bulkRegister(int)->int:::Adds the given number of new unarrived parties to this phaser
java.util.concurrent.Phaser#arrive()->int:::Arrives at this phaser, without waiting for others to arrive
java.util.concurrent.Phaser#arriveAndDeregister()->int:::Arrives at this phaser and deregisters from it without waiting for others to arrive
java.util.concurrent.Phaser#arriveAndAwaitAdvance()->int:::Arrives at this phaser and awaits others
java.util.concurrent.Phaser#awaitAdvance(int)->int:::Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser#awaitAdvanceInterruptibly(int)->int:::Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser#awaitAdvanceInterruptibly(int, long, TimeUnit)->int:::Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser#forceTermination()->void:::Forces this phaser to enter termination state
java.util.concurrent.Phaser#getPhase()->int:::Returns the current phase number
java.util.concurrent.Phaser#getRegisteredParties()->int:::Returns the number of parties registered at this phaser.
java.util.concurrent.Phaser#getArrivedParties()->int:::Returns the number of registered parties that have arrived at the current phase of this phaser
java.util.concurrent.Phaser#getUnarrivedParties()->int:::Returns the number of registered parties that have not yet arrived at the current phase of this phaser
java.util.concurrent.Phaser#getParent()->Phaser:::Returns the parent of this phaser, or null if none.
java.util.concurrent.Phaser#getRoot()->Phaser:::Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.
java.util.concurrent.Phaser#isTerminated()->boolean:::Returns true if this phaser has been terminated.
java.util.concurrent.Phaser#onAdvance(int, int)->boolean:::Overridable method to perform an action upon impending phase advance, and to control termination
java.util.concurrent.Phaser#toString()->String:::Returns a string identifying this phaser, as well as its state
java.util.concurrent.Phaser.QNode#isReleasable()->boolean::: node is releasable
java.util.concurrent.Phaser.QNode#block()->boolean::: node block
java.util.concurrent.PriorityBlockingQueue#add(E)->boolean:::Inserts the specified element into this priority queue.
java.util.concurrent.PriorityBlockingQueue#offer(E)->boolean:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#put(E)->void:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this priority queue
java.util.concurrent.PriorityBlockingQueue#poll()->E::: priority blocking queue poll
java.util.concurrent.PriorityBlockingQueue#take()->E::: priority blocking queue take
java.util.concurrent.PriorityBlockingQueue#poll(long, TimeUnit)->E::: priority blocking queue poll
java.util.concurrent.PriorityBlockingQueue#peek()->E::: priority blocking queue peek
java.util.concurrent.PriorityBlockingQueue#comparator()->Comparator:::Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue#size()->int::: priority blocking queue size
java.util.concurrent.PriorityBlockingQueue#remainingCapacity()->int:::Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.
java.util.concurrent.PriorityBlockingQueue#remove(Object)->boolean:::Removes a single instance of the specified element from this queue, if it is present
java.util.concurrent.PriorityBlockingQueue#removeEq(Object)->void:::Identity-based version for use in Itr.remove.
java.util.concurrent.PriorityBlockingQueue#contains(Object)->boolean:::Returns true if this queue contains the specified element
java.util.concurrent.PriorityBlockingQueue#toString()->String::: priority blocking queue to string
java.util.concurrent.PriorityBlockingQueue#drainTo(Collection)->int::: priority blocking queue drain to
java.util.concurrent.PriorityBlockingQueue#drainTo(Collection, int)->int::: priority blocking queue drain to
java.util.concurrent.PriorityBlockingQueue#clear()->void:::Atomically removes all of the elements from this queue
java.util.concurrent.PriorityBlockingQueue#toArray()->Object[]:::Returns an array containing all of the elements in this queue
java.util.concurrent.PriorityBlockingQueue#toArray(T[])->T[]:::Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array
java.util.concurrent.PriorityBlockingQueue#iterator()->Iterator:::Returns an iterator over the elements in this queue
java.util.concurrent.PriorityBlockingQueue.Itr#hasNext()->boolean::: itr has next
java.util.concurrent.PriorityBlockingQueue.Itr#next()->E::: itr next
java.util.concurrent.PriorityBlockingQueue.Itr#remove()->void::: itr remove
java.util.concurrent.PriorityBlockingQueue.Itr#forEachRemaining(Consumer)->void::: itr for each remaining
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#trySplit()->PBQSpliterator::: spliterator try split
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#forEachRemaining(Consumer)->void::: spliterator for each remaining
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#tryAdvance(Consumer)->boolean::: spliterator try advance
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#estimateSize()->long::: spliterator estimate size
java.util.concurrent.PriorityBlockingQueue.PBQSpliterator#characteristics()->int::: spliterator characteristics
java.util.concurrent.PriorityBlockingQueue#spliterator()->Spliterator:::Returns a Spliterator over the elements in this queue
java.util.concurrent.PriorityBlockingQueue#removeIf(Predicate)->boolean::: priority blocking queue remove if
java.util.concurrent.PriorityBlockingQueue#removeAll(Collection)->boolean::: priority blocking queue remove all
java.util.concurrent.PriorityBlockingQueue#retainAll(Collection)->boolean::: priority blocking queue retain all
java.util.concurrent.PriorityBlockingQueue#forEach(Consumer)->void::: priority blocking queue for each
java.util.concurrent.RecursiveAction#compute()->void:::The main computation performed by this task.
java.util.concurrent.RecursiveAction#getRawResult()->Void:::Always returns null.
java.util.concurrent.RecursiveAction#setRawResult(Void)->void:::Requires null completion value.
java.util.concurrent.RecursiveAction#exec()->boolean:::Implements execution conventions for RecursiveActions.
java.util.concurrent.RecursiveTask#compute()->V:::The main computation performed by this task.
java.util.concurrent.RecursiveTask#getRawResult()->V::: recursive task get raw result
java.util.concurrent.RecursiveTask#setRawResult(V)->void::: recursive task set raw result
java.util.concurrent.RecursiveTask#exec()->boolean:::Implements execution conventions for RecursiveTask.
java.util.concurrent.RejectedExecutionHandler#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Method that may be invoked by a ThreadPoolExecutor when ThreadPoolExecutor#execute execute cannot accept a task
java.util.concurrent.RunnableFuture#run()->void:::Sets this Future to the result of its computation unless it has been cancelled.
java.util.concurrent.RunnableScheduledFuture#isPeriodic()->boolean:::Returns true if this task is periodic
java.util.concurrent.ScheduledExecutorService#schedule(Runnable, long, TimeUnit)->ScheduledFuture:::Submits a one-shot task that becomes enabled after the given delay.
java.util.concurrent.ScheduledExecutorService#schedule(Callable, long, TimeUnit)->ScheduledFuture:::Submits a value-returning one-shot task that becomes enabled after the given delay.
java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)->ScheduledFuture:::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on
java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)->ScheduledFuture:::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next
java.util.concurrent.ScheduledThreadPoolExecutor#canRunInCurrentRunState(RunnableScheduledFuture)->boolean:::Returns true if can run a task given current run state and run-after-shutdown parameters.
java.util.concurrent.ScheduledThreadPoolExecutor#reExecutePeriodic(RunnableScheduledFuture)->void:::Requeues a periodic task unless current run state precludes it
java.util.concurrent.ScheduledThreadPoolExecutor#onShutdown()->void:::Cancels and clears the queue of all tasks that should not be run due to shutdown policy
java.util.concurrent.ScheduledThreadPoolExecutor#decorateTask(Runnable, RunnableScheduledFuture)->RunnableScheduledFuture:::Modifies or replaces the task used to execute a runnable
java.util.concurrent.ScheduledThreadPoolExecutor#decorateTask(Callable, RunnableScheduledFuture)->RunnableScheduledFuture:::Modifies or replaces the task used to execute a callable
java.util.concurrent.ScheduledThreadPoolExecutor#triggerTime(long)->long:::Returns the nanoTime-based trigger time of a delayed action.
java.util.concurrent.ScheduledThreadPoolExecutor#schedule(Runnable, long, TimeUnit)->ScheduledFuture::: scheduled thread pool executor schedule
java.util.concurrent.ScheduledThreadPoolExecutor#schedule(Callable, long, TimeUnit)->ScheduledFuture::: scheduled thread pool executor schedule
java.util.concurrent.ScheduledThreadPoolExecutor#scheduleAtFixedRate(Runnable, long, long, TimeUnit)->ScheduledFuture:::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is, executions will commence after initialDelay, then initialDelay + period, then initialDelay + 2 * period, and so on
java.util.concurrent.ScheduledThreadPoolExecutor#scheduleWithFixedDelay(Runnable, long, long, TimeUnit)->ScheduledFuture:::Submits a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next
java.util.concurrent.ScheduledThreadPoolExecutor#execute(Runnable)->void:::Executes command with zero required delay
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Runnable)->Future::: scheduled thread pool executor submit
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Runnable, T)->Future::: scheduled thread pool executor submit
java.util.concurrent.ScheduledThreadPoolExecutor#submit(Callable)->Future::: scheduled thread pool executor submit
java.util.concurrent.ScheduledThreadPoolExecutor#setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean)->void:::Sets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown
java.util.concurrent.ScheduledThreadPoolExecutor#getContinueExistingPeriodicTasksAfterShutdownPolicy()->boolean:::Gets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown
java.util.concurrent.ScheduledThreadPoolExecutor#setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean)->void:::Sets the policy on whether to execute existing delayed tasks even when this executor has been shutdown
java.util.concurrent.ScheduledThreadPoolExecutor#getExecuteExistingDelayedTasksAfterShutdownPolicy()->boolean:::Gets the policy on whether to execute existing delayed tasks even when this executor has been shutdown
java.util.concurrent.ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean)->void:::Sets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation
java.util.concurrent.ScheduledThreadPoolExecutor#getRemoveOnCancelPolicy()->boolean:::Gets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation
java.util.concurrent.ScheduledThreadPoolExecutor#shutdown()->void:::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted
java.util.concurrent.ScheduledThreadPoolExecutor#shutdownNow()->List:::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution
java.util.concurrent.ScheduledThreadPoolExecutor#getQueue()->BlockingQueue:::Returns the task queue used by this executor
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#contains(Object)->boolean::: delayed work queue contains
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#remove(Object)->boolean::: delayed work queue remove
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#size()->int::: delayed work queue size
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#isEmpty()->boolean::: delayed work queue is empty
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#remainingCapacity()->int::: delayed work queue remaining capacity
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#peek()->RunnableScheduledFuture::: delayed work queue peek
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable)->boolean::: delayed work queue offer
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#put(Runnable)->void::: delayed work queue put
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#add(Runnable)->boolean::: delayed work queue add
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#offer(Runnable, long, TimeUnit)->boolean::: delayed work queue offer
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#poll()->RunnableScheduledFuture::: delayed work queue poll
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#take()->RunnableScheduledFuture::: delayed work queue take
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#poll(long, TimeUnit)->RunnableScheduledFuture::: delayed work queue poll
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#clear()->void::: delayed work queue clear
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection)->int::: delayed work queue drain to
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#drainTo(Collection, int)->int::: delayed work queue drain to
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray()->Object[]::: delayed work queue to array
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#toArray(T[])->T[]::: delayed work queue to array
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue#iterator()->Iterator::: delayed work queue iterator
java.util.concurrent.Semaphore.Sync#getPermits()->int::: sync get permits
java.util.concurrent.Semaphore.Sync#nonfairTryAcquireShared(int)->int::: sync nonfair try acquire shared
java.util.concurrent.Semaphore.Sync#tryReleaseShared(int)->boolean::: sync try release shared
java.util.concurrent.Semaphore.Sync#reducePermits(int)->void::: sync reduce permits
java.util.concurrent.Semaphore.Sync#drainPermits()->int::: sync drain permits
java.util.concurrent.Semaphore.NonfairSync#tryAcquireShared(int)->int::: nonfair sync try acquire shared
java.util.concurrent.Semaphore.FairSync#tryAcquireShared(int)->int::: fair sync try acquire shared
java.util.concurrent.Semaphore#acquire()->void:::Acquires a permit from this semaphore, blocking until one is available, or the thread is Thread#interrupt interrupted
java.util.concurrent.Semaphore#acquireUninterruptibly()->void:::Acquires a permit from this semaphore, blocking until one is available
java.util.concurrent.Semaphore#tryAcquire()->boolean:::Acquires a permit from this semaphore, only if one is available at the time of invocation
java.util.concurrent.Semaphore#tryAcquire(long, TimeUnit)->boolean:::Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.Semaphore#release()->void:::Releases a permit, returning it to the semaphore
java.util.concurrent.Semaphore#acquire(int)->void:::Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is Thread#interrupt interrupted
java.util.concurrent.Semaphore#acquireUninterruptibly(int)->void:::Acquires the given number of permits from this semaphore, blocking until all are available
java.util.concurrent.Semaphore#tryAcquire(int)->boolean:::Acquires the given number of permits from this semaphore, only if all are available at the time of invocation
java.util.concurrent.Semaphore#tryAcquire(int, long, TimeUnit)->boolean:::Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.Semaphore#release(int)->void:::Releases the given number of permits, returning them to the semaphore
java.util.concurrent.Semaphore#availablePermits()->int:::Returns the current number of permits available in this semaphore
java.util.concurrent.Semaphore#drainPermits()->int:::Acquires and returns all permits that are immediately available, or if negative permits are available, releases them
java.util.concurrent.Semaphore#reducePermits(int)->void:::Shrinks the number of available permits by the indicated reduction
java.util.concurrent.Semaphore#isFair()->boolean:::Returns true if this semaphore has fairness set true.
java.util.concurrent.Semaphore#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire
java.util.concurrent.Semaphore#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire
java.util.concurrent.Semaphore#getQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire
java.util.concurrent.Semaphore#toString()->String:::Returns a string identifying this semaphore, as well as its state
java.util.concurrent.SubmissionPublisher#roundCapacity(int)->int:::Round capacity to power of 2, at most limit.
java.util.concurrent.SubmissionPublisher#subscribe(Subscriber)->void:::Adds the given Subscriber unless already subscribed
java.util.concurrent.SubmissionPublisher#submit(T)->int:::Publishes the given item to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking uninterruptibly while resources for any subscriber are unavailable
java.util.concurrent.SubmissionPublisher#offer(T, BiPredicate, ? super T>)->int:::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method
java.util.concurrent.SubmissionPublisher#offer(T, long, TimeUnit, BiPredicate, ? super T>)->int:::Publishes the given item, if possible, to each current subscriber by asynchronously invoking its Flow.Subscriber#onNext(Object) onNext method, blocking while resources for any subscription are unavailable, up to the specified timeout or until the caller thread is interrupted, at which point the given handler (if non-null) is invoked, and if it returns true, retried once
java.util.concurrent.SubmissionPublisher#close()->void:::Unless already closed, issues Flow.Subscriber#onComplete() onComplete signals to current subscribers, and disallows subsequent attempts to publish
java.util.concurrent.SubmissionPublisher#closeExceptionally(Throwable)->void:::Unless already closed, issues Flow.Subscriber#onError(Throwable) onError signals to current subscribers with the given error, and disallows subsequent attempts to publish
java.util.concurrent.SubmissionPublisher#isClosed()->boolean:::Returns true if this publisher is not accepting submissions.
java.util.concurrent.SubmissionPublisher#getClosedException()->Throwable:::Returns the exception associated with #closeExceptionally(Throwable) closeExceptionally, or null if not closed or if closed normally.
java.util.concurrent.SubmissionPublisher#hasSubscribers()->boolean:::Returns true if this publisher has any subscribers.
java.util.concurrent.SubmissionPublisher#getNumberOfSubscribers()->int:::Returns the number of current subscribers.
java.util.concurrent.SubmissionPublisher#getExecutor()->Executor:::Returns the Executor used for asynchronous delivery.
java.util.concurrent.SubmissionPublisher#getMaxBufferCapacity()->int:::Returns the maximum per-subscriber buffer capacity.
java.util.concurrent.SubmissionPublisher#getSubscribers()->List>:::Returns a list of current subscribers for monitoring and tracking purposes, not for invoking Flow.Subscriber methods on the subscribers.
java.util.concurrent.SubmissionPublisher#isSubscribed(Subscriber)->boolean:::Returns true if the given Subscriber is currently subscribed.
java.util.concurrent.SubmissionPublisher#estimateMinimumDemand()->long:::Returns an estimate of the minimum number of items requested (via Flow.Subscription#request(long) request) but not yet produced, among all current subscribers.
java.util.concurrent.SubmissionPublisher#estimateMaximumLag()->int:::Returns an estimate of the maximum number of items produced but not yet consumed among all current subscribers.
java.util.concurrent.SubmissionPublisher#consume(Consumer)->CompletableFuture:::Processes all published items using the given Consumer function
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onSubscribe(Subscription)->void::: consumer subscriber on subscribe
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onError(Throwable)->void::: consumer subscriber on error
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onComplete()->void::: consumer subscriber on complete
java.util.concurrent.SubmissionPublisher.ConsumerSubscriber#onNext(T)->void::: consumer subscriber on next
java.util.concurrent.SubmissionPublisher.ConsumerTask#getRawResult()->Void::: consumer task get raw result
java.util.concurrent.SubmissionPublisher.ConsumerTask#setRawResult(Void)->void::: consumer task set raw result
java.util.concurrent.SubmissionPublisher.ConsumerTask#exec()->boolean::: consumer task exec
java.util.concurrent.SubmissionPublisher.ConsumerTask#run()->void::: consumer task run
java.util.concurrent.SubmissionPublisher.BufferedSubscription#weakCasCtl(int, int)->boolean::: buffered subscription weak cas ctl
java.util.concurrent.SubmissionPublisher.BufferedSubscription#getAndBitwiseOrCtl(int)->int::: buffered subscription get and bitwise or ctl
java.util.concurrent.SubmissionPublisher.BufferedSubscription#subtractDemand(int)->long::: buffered subscription subtract demand
java.util.concurrent.SubmissionPublisher.BufferedSubscription#casDemand(long, long)->boolean::: buffered subscription cas demand
java.util.concurrent.SubmissionPublisher.BufferedSubscription#isClosed()->boolean:::Returns true if closed (consumer task may still be running).
java.util.concurrent.SubmissionPublisher.BufferedSubscription#estimateLag()->int:::Returns estimated number of buffered items, or negative if closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#offer(T, boolean)->int:::Tries to add item and start consumer task if necessary.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#growAndOffer(T, Object[], int)->boolean:::Tries to expand buffer and add item, returning true on success
java.util.concurrent.SubmissionPublisher.BufferedSubscription#retryOffer(T)->int:::Version of offer for retries (no resize or bias)
java.util.concurrent.SubmissionPublisher.BufferedSubscription#startOnOffer(int)->int:::Tries to start consumer task after offer.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#tryStart()->void:::Tries to start consumer task
java.util.concurrent.SubmissionPublisher.BufferedSubscription#startOnSignal(int)->void:::Sets the given control bits, starting task if not running or closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onSubscribe()->void::: buffered subscription on subscribe
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onComplete()->void::: buffered subscription on complete
java.util.concurrent.SubmissionPublisher.BufferedSubscription#onError(Throwable)->void::: buffered subscription on error
java.util.concurrent.SubmissionPublisher.BufferedSubscription#cancel()->void::: buffered subscription cancel
java.util.concurrent.SubmissionPublisher.BufferedSubscription#request(long)->void::: buffered subscription request
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consume()->void:::Consumer loop, called from ConsumerTask, or indirectly when helping during submit.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#takeItems(Subscriber, long, int)->int:::Consumes some items until unavailable or bound or error.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeNext(Subscriber, Object)->boolean::: buffered subscription consume next
java.util.concurrent.SubmissionPublisher.BufferedSubscription#handleOnNext(Subscriber, Throwable)->void:::Processes exception in Subscriber.onNext.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#subscribeOnOpen(Subscriber)->void:::Issues subscriber.onSubscribe if this is first signal.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeSubscribe(Subscriber)->void::: buffered subscription consume subscribe
java.util.concurrent.SubmissionPublisher.BufferedSubscription#closeOnComplete(Subscriber)->void:::Issues subscriber.onComplete unless already closed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeComplete(Subscriber)->void::: buffered subscription consume complete
java.util.concurrent.SubmissionPublisher.BufferedSubscription#closeOnError(Subscriber, Throwable)->void:::Issues subscriber.onError, and unblocks producer if needed.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#consumeError(Subscriber, Throwable)->void::: buffered subscription consume error
java.util.concurrent.SubmissionPublisher.BufferedSubscription#signalWaiter()->void:::Unblocks waiting producer.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#isReleasable()->boolean:::Returns true if closed or space available
java.util.concurrent.SubmissionPublisher.BufferedSubscription#awaitSpace(long)->void:::Helps or blocks until timeout, closed, or space available.
java.util.concurrent.SubmissionPublisher.BufferedSubscription#block()->boolean:::Blocks until closed, space available or timeout
java.util.concurrent.SynchronousQueue.Transferer#transfer(E, boolean, long)->E:::Performs a put or take.
java.util.concurrent.SynchronousQueue.TransferStack#isFulfilling(int)->boolean:::Returns true if m has fulfilling bit set.
java.util.concurrent.SynchronousQueue.TransferStack.SNode#casNext(SNode, SNode)->boolean::: node cas next
java.util.concurrent.SynchronousQueue.TransferStack.SNode#tryMatch(SNode)->boolean:::Tries to match node s to this node, if so, waking up thread
java.util.concurrent.SynchronousQueue.TransferStack.SNode#tryCancel()->void:::Tries to cancel a wait by matching node to itself.
java.util.concurrent.SynchronousQueue.TransferStack.SNode#isCancelled()->boolean::: node is cancelled
java.util.concurrent.SynchronousQueue.TransferStack#casHead(SNode, SNode)->boolean::: transfer stack cas head
java.util.concurrent.SynchronousQueue.TransferStack#snode(SNode, Object, SNode, int)->SNode:::Creates or resets fields of a node
java.util.concurrent.SynchronousQueue.TransferStack#transfer(E, boolean, long)->E:::Puts or takes an item.
java.util.concurrent.SynchronousQueue.TransferStack#awaitFulfill(SNode, boolean, long)->SNode:::Spins/blocks until node s is matched by a fulfill operation.
java.util.concurrent.SynchronousQueue.TransferStack#shouldSpin(SNode)->boolean:::Returns true if node s is at head or there is an active fulfiller.
java.util.concurrent.SynchronousQueue.TransferStack#clean(SNode)->void:::Unlinks s from the stack.
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#casNext(QNode, QNode)->boolean::: node cas next
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#casItem(Object, Object)->boolean::: node cas item
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#tryCancel(Object)->void:::Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#isCancelled()->boolean::: node is cancelled
java.util.concurrent.SynchronousQueue.TransferQueue.QNode#isOffList()->boolean:::Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.
java.util.concurrent.SynchronousQueue.TransferQueue#advanceHead(QNode, QNode)->void:::Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue.TransferQueue#advanceTail(QNode, QNode)->void:::Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue.TransferQueue#casCleanMe(QNode, QNode)->boolean:::Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue.TransferQueue#transfer(E, boolean, long)->E:::Puts or takes an item.
java.util.concurrent.SynchronousQueue.TransferQueue#awaitFulfill(QNode, E, boolean, long)->Object:::Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue.TransferQueue#clean(QNode, QNode)->void:::Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue#put(E)->void:::Adds the specified element to this queue, waiting if necessary for another thread to receive it.
java.util.concurrent.SynchronousQueue#offer(E, long, TimeUnit)->boolean:::Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.
java.util.concurrent.SynchronousQueue#offer(E)->boolean:::Inserts the specified element into this queue, if another thread is waiting to receive it.
java.util.concurrent.SynchronousQueue#take()->E:::Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.
java.util.concurrent.SynchronousQueue#poll(long, TimeUnit)->E:::Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.
java.util.concurrent.SynchronousQueue#poll()->E:::Retrieves and removes the head of this queue, if another thread is currently making an element available.
java.util.concurrent.SynchronousQueue#isEmpty()->boolean:::Always returns true
java.util.concurrent.SynchronousQueue#size()->int:::Always returns zero
java.util.concurrent.SynchronousQueue#remainingCapacity()->int:::Always returns zero
java.util.concurrent.SynchronousQueue#clear()->void:::Does nothing
java.util.concurrent.SynchronousQueue#contains(Object)->boolean:::Always returns false
java.util.concurrent.SynchronousQueue#remove(Object)->boolean:::Always returns false
java.util.concurrent.SynchronousQueue#containsAll(Collection)->boolean:::Returns false unless the given collection is empty
java.util.concurrent.SynchronousQueue#removeAll(Collection)->boolean:::Always returns false
java.util.concurrent.SynchronousQueue#retainAll(Collection)->boolean:::Always returns false
java.util.concurrent.SynchronousQueue#peek()->E:::Always returns null
java.util.concurrent.SynchronousQueue#iterator()->Iterator:::Returns an empty iterator in which hasNext always returns false.
java.util.concurrent.SynchronousQueue#spliterator()->Spliterator:::Returns an empty spliterator in which calls to Spliterator#trySplit() trySplit always return null.
java.util.concurrent.SynchronousQueue#toArray()->Object[]:::Returns a zero-length array.
java.util.concurrent.SynchronousQueue#toArray(T[])->T[]:::Sets the zeroth element of the specified array to null (if the array has non-zero length) and returns it.
java.util.concurrent.SynchronousQueue#toString()->String:::Always returns "[]".
java.util.concurrent.SynchronousQueue#drainTo(Collection)->int::: synchronous queue drain to
java.util.concurrent.SynchronousQueue#drainTo(Collection, int)->int::: synchronous queue drain to
java.util.concurrent.ThreadFactory#newThread(Runnable)->Thread:::Constructs a new Thread
java.util.concurrent.ThreadLocalRandom#localInit()->void:::Initialize Thread fields for the current thread
java.util.concurrent.ThreadLocalRandom#current()->ThreadLocalRandom:::Returns the current thread's ThreadLocalRandom.
java.util.concurrent.ThreadLocalRandom#setSeed(long)->void:::Throws UnsupportedOperationException
java.util.concurrent.ThreadLocalRandom#nextSeed()->long::: thread local random next seed
java.util.concurrent.ThreadLocalRandom#next(int)->int:::Generates a pseudorandom number with the indicated number of low-order bits
java.util.concurrent.ThreadLocalRandom#internalNextLong(long, long)->long:::The form of nextLong used by LongStream Spliterators
java.util.concurrent.ThreadLocalRandom#internalNextInt(int, int)->int:::The form of nextInt used by IntStream Spliterators
java.util.concurrent.ThreadLocalRandom#internalNextDouble(double, double)->double:::The form of nextDouble used by DoubleStream Spliterators.
java.util.concurrent.ThreadLocalRandom#nextInt()->int:::Returns a pseudorandom int value.
java.util.concurrent.ThreadLocalRandom#nextInt(int)->int:::Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextInt(int, int)->int:::Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextLong()->long:::Returns a pseudorandom long value.
java.util.concurrent.ThreadLocalRandom#nextLong(long)->long:::Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextLong(long, long)->long:::Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble()->double:::Returns a pseudorandom double value between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble(double)->double:::Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextDouble(double, double)->double:::Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#nextBoolean()->boolean:::Returns a pseudorandom boolean value.
java.util.concurrent.ThreadLocalRandom#nextFloat()->float:::Returns a pseudorandom float value between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#nextGaussian()->double::: thread local random next gaussian
java.util.concurrent.ThreadLocalRandom#ints(long)->IntStream:::Returns a stream producing the given streamSize number of pseudorandom int values.
java.util.concurrent.ThreadLocalRandom#ints()->IntStream:::Returns an effectively unlimited stream of pseudorandom int values.
java.util.concurrent.ThreadLocalRandom#ints(long, int, int)->IntStream:::Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#ints(int, int)->IntStream:::Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#longs(long)->LongStream:::Returns a stream producing the given streamSize number of pseudorandom long values.
java.util.concurrent.ThreadLocalRandom#longs()->LongStream:::Returns an effectively unlimited stream of pseudorandom long values.
java.util.concurrent.ThreadLocalRandom#longs(long, long, long)->LongStream:::Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#longs(long, long)->LongStream:::Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(long)->DoubleStream:::Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles()->DoubleStream:::Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(long, double, double)->DoubleStream:::Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#doubles(double, double)->DoubleStream:::Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom#getProbe()->int:::Returns the probe value for the current thread without forcing initialization
java.util.concurrent.ThreadLocalRandom#advanceProbe(int)->int:::Pseudo-randomly advances and records the given probe value for the given thread.
java.util.concurrent.ThreadLocalRandom#nextSecondarySeed()->int:::Returns the pseudo-randomly initialized or updated secondary seed.
java.util.concurrent.ThreadLocalRandom#eraseThreadLocals(Thread)->void:::Erases ThreadLocals by nulling out Thread maps.
java.util.concurrent.ThreadLocalRandom#setInheritedAccessControlContext(Thread, AccessControlContext)->void::: thread local random set inherited access control context
java.util.concurrent.ThreadPoolExecutor#tryTerminate()->void:::Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)
java.util.concurrent.ThreadPoolExecutor#reject(Runnable)->void:::Invokes the rejected execution handler for the given command
java.util.concurrent.ThreadPoolExecutor#onShutdown()->void:::Performs any further cleanup following run state transition on invocation of shutdown
java.util.concurrent.ThreadPoolExecutor#runWorker(Worker)->void:::Main worker run loop
java.util.concurrent.ThreadPoolExecutor#execute(Runnable)->void:::Executes the given task sometime in the future
java.util.concurrent.ThreadPoolExecutor#shutdown()->void:::Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted
java.util.concurrent.ThreadPoolExecutor#shutdownNow()->List:::Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution
java.util.concurrent.ThreadPoolExecutor#isShutdown()->boolean::: thread pool executor is shutdown
java.util.concurrent.ThreadPoolExecutor#isStopped()->boolean:::Used by ScheduledThreadPoolExecutor.
java.util.concurrent.ThreadPoolExecutor#isTerminating()->boolean:::Returns true if this executor is in the process of terminating after #shutdown or #shutdownNow but has not completely terminated
java.util.concurrent.ThreadPoolExecutor#isTerminated()->boolean::: thread pool executor is terminated
java.util.concurrent.ThreadPoolExecutor#awaitTermination(long, TimeUnit)->boolean::: thread pool executor await termination
java.util.concurrent.ThreadPoolExecutor#finalize()->void::: thread pool executor finalize
java.util.concurrent.ThreadPoolExecutor#setThreadFactory(ThreadFactory)->void:::Sets the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor#getThreadFactory()->ThreadFactory:::Returns the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor#setRejectedExecutionHandler(RejectedExecutionHandler)->void:::Sets a new handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor#getRejectedExecutionHandler()->RejectedExecutionHandler:::Returns the current handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor#setCorePoolSize(int)->void:::Sets the core number of threads
java.util.concurrent.ThreadPoolExecutor#getCorePoolSize()->int:::Returns the core number of threads.
java.util.concurrent.ThreadPoolExecutor#prestartCoreThread()->boolean:::Starts a core thread, causing it to idly wait for work
java.util.concurrent.ThreadPoolExecutor#ensurePrestart()->void:::Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.
java.util.concurrent.ThreadPoolExecutor#prestartAllCoreThreads()->int:::Starts all core threads, causing them to idly wait for work
java.util.concurrent.ThreadPoolExecutor#allowsCoreThreadTimeOut()->boolean:::Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive
java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)->void:::Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive
java.util.concurrent.ThreadPoolExecutor#setMaximumPoolSize(int)->void:::Sets the maximum allowed number of threads
java.util.concurrent.ThreadPoolExecutor#getMaximumPoolSize()->int:::Returns the maximum allowed number of threads.
java.util.concurrent.ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit)->void:::Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated
java.util.concurrent.ThreadPoolExecutor#getKeepAliveTime(TimeUnit)->long:::Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated
java.util.concurrent.ThreadPoolExecutor#getQueue()->BlockingQueue:::Returns the task queue used by this executor
java.util.concurrent.ThreadPoolExecutor#remove(Runnable)->boolean:::Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started
java.util.concurrent.ThreadPoolExecutor#purge()->void:::Tries to remove from the work queue all Future tasks that have been cancelled
java.util.concurrent.ThreadPoolExecutor#getPoolSize()->int:::Returns the current number of threads in the pool.
java.util.concurrent.ThreadPoolExecutor#getActiveCount()->int:::Returns the approximate number of threads that are actively executing tasks.
java.util.concurrent.ThreadPoolExecutor#getLargestPoolSize()->int:::Returns the largest number of threads that have ever simultaneously been in the pool.
java.util.concurrent.ThreadPoolExecutor#getTaskCount()->long:::Returns the approximate total number of tasks that have ever been scheduled for execution
java.util.concurrent.ThreadPoolExecutor#getCompletedTaskCount()->long:::Returns the approximate total number of tasks that have completed execution
java.util.concurrent.ThreadPoolExecutor#toString()->String:::Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.
java.util.concurrent.ThreadPoolExecutor#beforeExecute(Thread, Runnable)->void:::Method invoked prior to executing the given Runnable in the given thread
java.util.concurrent.ThreadPoolExecutor#afterExecute(Runnable, Throwable)->void:::Method invoked upon completion of execution of the given Runnable
java.util.concurrent.ThreadPoolExecutor#terminated()->void:::Method invoked when the Executor has terminated
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
java.util.concurrent.ThreadPoolExecutor.AbortPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Always throws RejectedExecutionException.
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Does nothing, which has the effect of discarding task r.
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy#rejectedExecution(Runnable, ThreadPoolExecutor)->void:::Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.
java.util.concurrent.TransferQueue#tryTransfer(E)->boolean:::Transfers the element to a waiting consumer immediately, if possible
java.util.concurrent.TransferQueue#transfer(E)->void:::Transfers the element to a consumer, waiting if necessary to do so
java.util.concurrent.TransferQueue#tryTransfer(E, long, TimeUnit)->boolean:::Transfers the element to a consumer if it is possible to do so before the timeout elapses
java.util.concurrent.TransferQueue#hasWaitingConsumer()->boolean:::Returns true if there is at least one consumer waiting to receive an element via #take or timed #poll(long,TimeUnit) poll
java.util.concurrent.TransferQueue#getWaitingConsumerCount()->int:::Returns an estimate of the number of consumers waiting to receive elements via #take or timed #poll(long,TimeUnit) poll
