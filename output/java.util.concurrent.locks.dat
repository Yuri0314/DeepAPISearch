AbstractOwnableSynchronizer#setExclusiveOwnerThread(Thread):::Sets the thread that currently owns exclusive access:::
AbstractOwnableSynchronizer#getExclusiveOwnerThread():::Returns the thread last set by setExclusiveOwnerThread, or null if never set:::
AbstractQueuedLongSynchronizer#getState():::Returns the current value of synchronization state:::
AbstractQueuedLongSynchronizer#setState(long):::Sets the value of synchronization state:::STATE.setVolatile
AbstractQueuedLongSynchronizer#compareAndSetState(long, long):::Atomically sets synchronization state to the given updated value if the current state value equals the expected value:::STATE.compareAndSet
AbstractQueuedLongSynchronizer#selfInterrupt():::Convenience method to interrupt current thread.:::Thread.currentThread().interrupt
AbstractQueuedLongSynchronizer#acquireQueued(Node, long):::Acquires in exclusive uninterruptible mode for thread already in queue:::this.cancelAcquire->this.selfInterrupt->node.predecessor->this.tryAcquire->this.setHead->this.shouldParkAfterFailedAcquire->this.parkAndCheckInterrupt
AbstractQueuedLongSynchronizer#tryAcquire(long):::Attempts to acquire in exclusive mode:::
AbstractQueuedLongSynchronizer#tryRelease(long):::Attempts to set the state to reflect a release in exclusive mode:::
AbstractQueuedLongSynchronizer#tryAcquireShared(long):::Attempts to acquire in shared mode:::
AbstractQueuedLongSynchronizer#tryReleaseShared(long):::Attempts to set the state to reflect a release in shared mode:::
AbstractQueuedLongSynchronizer#isHeldExclusively():::Returns true if synchronization is held exclusively with respect to the current (calling) thread:::
AbstractQueuedLongSynchronizer#acquire(long):::Acquires in exclusive mode, ignoring interrupts:::this.tryAcquire->this.addWaiter->this.acquireQueued->this.selfInterrupt
AbstractQueuedLongSynchronizer#acquireInterruptibly(long):::Acquires in exclusive mode, aborting if interrupted:::Thread.interrupted->this.tryAcquire->this.doAcquireInterruptibly
AbstractQueuedLongSynchronizer#tryAcquireNanos(long, long):::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses:::Thread.interrupted->this.tryAcquire->this.doAcquireNanos
AbstractQueuedLongSynchronizer#release(long):::Releases in exclusive mode:::this.tryRelease->this.unparkSuccessor
AbstractQueuedLongSynchronizer#acquireShared(long):::Acquires in shared mode, ignoring interrupts:::this.tryAcquireShared->this.doAcquireShared
AbstractQueuedLongSynchronizer#acquireSharedInterruptibly(long):::Acquires in shared mode, aborting if interrupted:::Thread.interrupted->this.tryAcquireShared->this.doAcquireSharedInterruptibly
AbstractQueuedLongSynchronizer#tryAcquireSharedNanos(long, long):::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses:::Thread.interrupted->this.tryAcquireShared->this.doAcquireSharedNanos
AbstractQueuedLongSynchronizer#releaseShared(long):::Releases in shared mode:::this.tryReleaseShared->this.doReleaseShared
AbstractQueuedLongSynchronizer#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::
AbstractQueuedLongSynchronizer#hasContended():::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked:::
AbstractQueuedLongSynchronizer#getFirstQueuedThread():::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued:::this.fullGetFirstQueuedThread
AbstractQueuedLongSynchronizer#isQueued(Thread):::Returns true if the given thread is currently queued:::
AbstractQueuedLongSynchronizer#apparentlyFirstQueuedIsExclusive():::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode:::s.isShared
AbstractQueuedLongSynchronizer#hasQueuedPredecessors():::Queries whether any threads have been waiting to acquire longer than the current thread:::Thread.currentThread
AbstractQueuedLongSynchronizer#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::
AbstractQueuedLongSynchronizer#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::list.add
AbstractQueuedLongSynchronizer#getExclusiveQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in exclusive mode:::p.isShared->list.add
AbstractQueuedLongSynchronizer#getSharedQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in shared mode:::p.isShared->list.add
AbstractQueuedLongSynchronizer#toString():::Returns a string identifying this synchronizer, as well as its state:::super.toString->this.getState->this.hasQueuedThreads
AbstractQueuedLongSynchronizer#isOnSyncQueue(Node):::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.:::this.findNodeFromTail
AbstractQueuedLongSynchronizer#transferForSignal(Node):::Transfers a node from a condition queue onto sync queue:::node.compareAndSetWaitStatus->this.enq->p.compareAndSetWaitStatus->LockSupport.unpark
AbstractQueuedLongSynchronizer#transferAfterCancelledWait(Node):::Transfers node, if necessary, to sync queue after a cancelled wait:::node.compareAndSetWaitStatus->this.enq->Thread.yield->this.isOnSyncQueue
AbstractQueuedLongSynchronizer#fullyRelease(Node):::Invokes release with current state value; returns saved state:::this.getState->this.release
AbstractQueuedLongSynchronizer#owns(ConditionObject):::Queries whether the given ConditionObject uses this synchronizer as its lock.:::condition.isOwnedBy
AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject):::Queries whether any threads are waiting on the given condition associated with this synchronizer:::this.owns->condition.hasWaiters
AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject):::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer:::this.owns->condition.getWaitQueueLength
AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject):::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer:::this.owns->condition.getWaitingThreads
AbstractQueuedLongSynchronizer.ConditionObject#signal():::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.:::this.isHeldExclusively->this.doSignal
AbstractQueuedLongSynchronizer.ConditionObject#signalAll():::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.:::this.isHeldExclusively->this.doSignalAll
AbstractQueuedLongSynchronizer.ConditionObject#awaitUninterruptibly():::Implements uninterruptible condition wait:::this.addConditionWaiter->this.fullyRelease->LockSupport.park->Thread.interrupted->this.isOnSyncQueue->this.acquireQueued->this.selfInterrupt
AbstractQueuedLongSynchronizer.ConditionObject#await():::Implements interruptible condition wait:::Thread.interrupted->this.addConditionWaiter->this.fullyRelease->LockSupport.park->this.checkInterruptWhileWaiting->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedLongSynchronizer.ConditionObject#awaitNanos(long):::Implements timed condition wait:::Thread.interrupted->System.nanoTime->this.addConditionWaiter->this.fullyRelease->this.transferAfterCancelledWait->LockSupport.parkNanos->this.checkInterruptWhileWaiting->System.nanoTime->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait->System.nanoTime
AbstractQueuedLongSynchronizer.ConditionObject#awaitUntil(Date):::Implements absolute timed condition wait:::deadline.getTime->Thread.interrupted->this.addConditionWaiter->this.fullyRelease->System.currentTimeMillis->this.transferAfterCancelledWait->LockSupport.parkUntil->this.checkInterruptWhileWaiting->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedLongSynchronizer.ConditionObject#await(long, TimeUnit):::Implements timed condition wait:::unit.toNanos->Thread.interrupted->System.nanoTime->this.addConditionWaiter->this.fullyRelease->this.transferAfterCancelledWait->LockSupport.parkNanos->this.checkInterruptWhileWaiting->System.nanoTime->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedLongSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedLongSynchronizer):::Returns true if this condition was created by the given synchronization object.:::
AbstractQueuedLongSynchronizer.ConditionObject#hasWaiters():::Queries whether any threads are waiting on this condition:::this.isHeldExclusively
AbstractQueuedLongSynchronizer.ConditionObject#getWaitQueueLength():::Returns an estimate of the number of threads waiting on this condition:::this.isHeldExclusively
AbstractQueuedLongSynchronizer.ConditionObject#getWaitingThreads():::Returns a collection containing those threads that may be waiting on this Condition:::this.isHeldExclusively->list.add
AbstractQueuedSynchronizer.Node#isShared():::Returns true if node is waiting in shared mode.:::
AbstractQueuedSynchronizer.Node#predecessor():::Returns previous node, or throws NullPointerException if null:::
AbstractQueuedSynchronizer.Node#compareAndSetWaitStatus(int, int):::CASes waitStatus field.:::WAITSTATUS.compareAndSet
AbstractQueuedSynchronizer.Node#compareAndSetNext(Node, Node):::CASes next field.:::NEXT.compareAndSet
AbstractQueuedSynchronizer#getState():::Returns the current value of synchronization state:::
AbstractQueuedSynchronizer#setState(int):::Sets the value of synchronization state:::
AbstractQueuedSynchronizer#compareAndSetState(int, int):::Atomically sets synchronization state to the given updated value if the current state value equals the expected value:::STATE.compareAndSet
AbstractQueuedSynchronizer#selfInterrupt():::Convenience method to interrupt current thread.:::Thread.currentThread().interrupt
AbstractQueuedSynchronizer#acquireQueued(Node, int):::Acquires in exclusive uninterruptible mode for thread already in queue:::this.cancelAcquire->this.selfInterrupt->node.predecessor->this.tryAcquire->this.setHead->this.shouldParkAfterFailedAcquire->this.parkAndCheckInterrupt
AbstractQueuedSynchronizer#tryAcquire(int):::Attempts to acquire in exclusive mode:::
AbstractQueuedSynchronizer#tryRelease(int):::Attempts to set the state to reflect a release in exclusive mode:::
AbstractQueuedSynchronizer#tryAcquireShared(int):::Attempts to acquire in shared mode:::
AbstractQueuedSynchronizer#tryReleaseShared(int):::Attempts to set the state to reflect a release in shared mode:::
AbstractQueuedSynchronizer#isHeldExclusively():::Returns true if synchronization is held exclusively with respect to the current (calling) thread:::
AbstractQueuedSynchronizer#acquire(int):::Acquires in exclusive mode, ignoring interrupts:::this.tryAcquire->this.addWaiter->this.acquireQueued->this.selfInterrupt
AbstractQueuedSynchronizer#acquireInterruptibly(int):::Acquires in exclusive mode, aborting if interrupted:::Thread.interrupted->this.tryAcquire->this.doAcquireInterruptibly
AbstractQueuedSynchronizer#tryAcquireNanos(int, long):::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses:::Thread.interrupted->this.tryAcquire->this.doAcquireNanos
AbstractQueuedSynchronizer#release(int):::Releases in exclusive mode:::this.tryRelease->this.unparkSuccessor
AbstractQueuedSynchronizer#acquireShared(int):::Acquires in shared mode, ignoring interrupts:::this.tryAcquireShared->this.doAcquireShared
AbstractQueuedSynchronizer#acquireSharedInterruptibly(int):::Acquires in shared mode, aborting if interrupted:::Thread.interrupted->this.tryAcquireShared->this.doAcquireSharedInterruptibly
AbstractQueuedSynchronizer#tryAcquireSharedNanos(int, long):::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses:::Thread.interrupted->this.tryAcquireShared->this.doAcquireSharedNanos
AbstractQueuedSynchronizer#releaseShared(int):::Releases in shared mode:::this.tryReleaseShared->this.doReleaseShared
AbstractQueuedSynchronizer#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::
AbstractQueuedSynchronizer#hasContended():::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked:::
AbstractQueuedSynchronizer#getFirstQueuedThread():::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued:::this.fullGetFirstQueuedThread
AbstractQueuedSynchronizer#isQueued(Thread):::Returns true if the given thread is currently queued:::
AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive():::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode:::s.isShared
AbstractQueuedSynchronizer#hasQueuedPredecessors():::Queries whether any threads have been waiting to acquire longer than the current thread:::Thread.currentThread
AbstractQueuedSynchronizer#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::
AbstractQueuedSynchronizer#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::list.add
AbstractQueuedSynchronizer#getExclusiveQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in exclusive mode:::p.isShared->list.add
AbstractQueuedSynchronizer#getSharedQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in shared mode:::p.isShared->list.add
AbstractQueuedSynchronizer#toString():::Returns a string identifying this synchronizer, as well as its state:::super.toString->this.getState->this.hasQueuedThreads
AbstractQueuedSynchronizer#isOnSyncQueue(Node):::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.:::this.findNodeFromTail
AbstractQueuedSynchronizer#transferForSignal(Node):::Transfers a node from a condition queue onto sync queue:::node.compareAndSetWaitStatus->this.enq->p.compareAndSetWaitStatus->LockSupport.unpark
AbstractQueuedSynchronizer#transferAfterCancelledWait(Node):::Transfers node, if necessary, to sync queue after a cancelled wait:::node.compareAndSetWaitStatus->this.enq->Thread.yield->this.isOnSyncQueue
AbstractQueuedSynchronizer#fullyRelease(Node):::Invokes release with current state value; returns saved state:::this.getState->this.release
AbstractQueuedSynchronizer#owns(ConditionObject):::Queries whether the given ConditionObject uses this synchronizer as its lock.:::condition.isOwnedBy
AbstractQueuedSynchronizer#hasWaiters(ConditionObject):::Queries whether any threads are waiting on the given condition associated with this synchronizer:::this.owns->condition.hasWaiters
AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject):::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer:::this.owns->condition.getWaitQueueLength
AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject):::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer:::this.owns->condition.getWaitingThreads
AbstractQueuedSynchronizer.ConditionObject#signal():::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.:::this.isHeldExclusively->this.doSignal
AbstractQueuedSynchronizer.ConditionObject#signalAll():::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.:::this.isHeldExclusively->this.doSignalAll
AbstractQueuedSynchronizer.ConditionObject#awaitUninterruptibly():::Implements uninterruptible condition wait:::this.addConditionWaiter->this.fullyRelease->LockSupport.park->Thread.interrupted->this.isOnSyncQueue->this.acquireQueued->this.selfInterrupt
AbstractQueuedSynchronizer.ConditionObject#await():::Implements interruptible condition wait:::Thread.interrupted->this.addConditionWaiter->this.fullyRelease->LockSupport.park->this.checkInterruptWhileWaiting->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedSynchronizer.ConditionObject#awaitNanos(long):::Implements timed condition wait:::Thread.interrupted->System.nanoTime->this.addConditionWaiter->this.fullyRelease->this.transferAfterCancelledWait->LockSupport.parkNanos->this.checkInterruptWhileWaiting->System.nanoTime->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait->System.nanoTime
AbstractQueuedSynchronizer.ConditionObject#awaitUntil(Date):::Implements absolute timed condition wait:::deadline.getTime->Thread.interrupted->this.addConditionWaiter->this.fullyRelease->System.currentTimeMillis->this.transferAfterCancelledWait->LockSupport.parkUntil->this.checkInterruptWhileWaiting->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedSynchronizer.ConditionObject#await(long, TimeUnit):::Implements timed condition wait:::unit.toNanos->Thread.interrupted->System.nanoTime->this.addConditionWaiter->this.fullyRelease->this.transferAfterCancelledWait->LockSupport.parkNanos->this.checkInterruptWhileWaiting->System.nanoTime->this.isOnSyncQueue->this.acquireQueued->this.unlinkCancelledWaiters->this.reportInterruptAfterWait
AbstractQueuedSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedSynchronizer):::Returns true if this condition was created by the given synchronization object.:::
AbstractQueuedSynchronizer.ConditionObject#hasWaiters():::Queries whether any threads are waiting on this condition:::this.isHeldExclusively
AbstractQueuedSynchronizer.ConditionObject#getWaitQueueLength():::Returns an estimate of the number of threads waiting on this condition:::this.isHeldExclusively
AbstractQueuedSynchronizer.ConditionObject#getWaitingThreads():::Returns a collection containing those threads that may be waiting on this Condition:::this.isHeldExclusively->list.add
Condition#await():::Causes the current thread to wait until it is signalled or Thread#interrupt interrupted:::
Condition#awaitUninterruptibly():::Causes the current thread to wait until it is signalled:::
Condition#awaitNanos(long):::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses:::
Condition#await(long, TimeUnit):::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses:::
Condition#awaitUntil(Date):::Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses:::
Condition#signal():::Wakes up one waiting thread:::
Condition#signalAll():::Wakes up all waiting threads:::
Lock#lock():::Acquires the lock:::
Lock#lockInterruptibly():::Acquires the lock unless the current thread is Thread#interrupt interrupted:::
Lock#tryLock():::Acquires the lock only if it is free at the time of invocation:::
Lock#tryLock(long, TimeUnit):::Acquires the lock if it is free within the given waiting time and the current thread has not been Thread#interrupt interrupted:::
Lock#unlock():::Releases the lock:::
Lock#newCondition():::Returns a new Condition instance that is bound to this Lock instance:::
LockSupport#unpark(Thread):::Makes available the permit for the given thread, if it was not already available:::U.unpark
LockSupport#park(Object):::Disables the current thread for thread scheduling purposes unless the permit is available:::Thread.currentThread->this.setBlocker->U.park->this.setBlocker
LockSupport#parkNanos(Object, long):::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available:::Thread.currentThread->this.setBlocker->U.park->this.setBlocker
LockSupport#parkUntil(Object, long):::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available:::Thread.currentThread->this.setBlocker->U.park->this.setBlocker
LockSupport#getBlocker(Thread):::Returns the blocker object supplied to the most recent invocation of a park method that has not yet unblocked, or null if not blocked:::U.getObjectVolatile
LockSupport#park():::Disables the current thread for thread scheduling purposes unless the permit is available:::U.park
LockSupport#parkNanos(long):::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available:::U.park
LockSupport#parkUntil(long):::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available:::U.park
LockSupport#nextSecondarySeed():::Returns the pseudo-randomly initialized or updated secondary seed:::Thread.currentThread->U.getInt->java.util.concurrent.ThreadLocalRandom.current().nextInt->U.putInt
LockSupport#getThreadId(Thread):::Returns the thread id for the given thread:::U.getLong
ReadWriteLock#readLock():::Returns the lock used for reading.:::
ReadWriteLock#writeLock():::Returns the lock used for writing.:::
ReentrantLock.Sync#nonfairTryAcquire(int):::Performs non-fair tryLock:::Thread.currentThread->this.getState->this.getExclusiveOwnerThread->this.setState->this.compareAndSetState->this.setExclusiveOwnerThread
ReentrantLock.FairSync#tryAcquire(int):::Fair version of tryAcquire:::Thread.currentThread->this.getState->this.getExclusiveOwnerThread->this.setState->this.hasQueuedPredecessors->this.compareAndSetState->this.setExclusiveOwnerThread
ReentrantLock#lock():::Acquires the lock:::sync.acquire
ReentrantLock#lockInterruptibly():::Acquires the lock unless the current thread is Thread#interrupt interrupted:::sync.acquireInterruptibly
ReentrantLock#tryLock():::Acquires the lock only if it is not held by another thread at the time of invocation:::sync.nonfairTryAcquire
ReentrantLock#tryLock(long, TimeUnit):::Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::unit.toNanos->sync.tryAcquireNanos
ReentrantLock#unlock():::Attempts to release this lock:::sync.release
ReentrantLock#newCondition():::Returns a Condition instance for use with this Lock instance:::sync.newCondition
ReentrantLock#getHoldCount():::Queries the number of holds on this lock by the current thread:::sync.getHoldCount
ReentrantLock#isHeldByCurrentThread():::Queries if this lock is held by the current thread:::sync.isHeldExclusively
ReentrantLock#isLocked():::Queries if this lock is held by any thread:::sync.isLocked
ReentrantLock#isFair():::Returns true if this lock has fairness set true.:::
ReentrantLock#getOwner():::Returns the thread that currently owns this lock, or null if not owned:::sync.getOwner
ReentrantLock#hasQueuedThreads():::Queries whether any threads are waiting to acquire this lock:::sync.hasQueuedThreads
ReentrantLock#hasQueuedThread(Thread):::Queries whether the given thread is waiting to acquire this lock:::sync.isQueued
ReentrantLock#getQueueLength():::Returns an estimate of the number of threads waiting to acquire this lock:::sync.getQueueLength
ReentrantLock#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire this lock:::sync.getQueuedThreads
ReentrantLock#hasWaiters(Condition):::Queries whether any threads are waiting on the given condition associated with this lock:::sync.hasWaiters
ReentrantLock#getWaitQueueLength(Condition):::Returns an estimate of the number of threads waiting on the given condition associated with this lock:::sync.getWaitQueueLength
ReentrantLock#getWaitingThreads(Condition):::Returns a collection containing those threads that may be waiting on the given condition associated with this lock:::sync.getWaitingThreads
ReentrantLock#toString():::Returns a string identifying this lock, as well as its lock state:::sync.getOwner->super.toString->o.getName
ReentrantReadWriteLock.Sync#sharedCount(int):::Returns the number of shared holds represented in count.:::
ReentrantReadWriteLock.Sync#exclusiveCount(int):::Returns the number of exclusive holds represented in count.:::
ReentrantReadWriteLock.Sync#readerShouldBlock():::Returns true if the current thread, when trying to acquire the read lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.:::
ReentrantReadWriteLock.Sync#writerShouldBlock():::Returns true if the current thread, when trying to acquire the write lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.:::
ReentrantReadWriteLock.Sync#fullTryAcquireShared(Thread):::Full version of acquire for reads, that handles CAS misses and reentrant reads not dealt with in tryAcquireShared.:::this.getState->this.exclusiveCount->this.readerShouldBlock->LockSupport.getThreadId->readHolds.get->readHolds.remove->this.getExclusiveOwnerThread->this.sharedCount->this.compareAndSetState->this.sharedCount->LockSupport.getThreadId->readHolds.set->readHolds.get
ReentrantReadWriteLock.Sync#tryWriteLock():::Performs tryLock for write, enabling barging in both modes:::Thread.currentThread->this.getState->this.exclusiveCount->this.getExclusiveOwnerThread->this.compareAndSetState->this.setExclusiveOwnerThread
ReentrantReadWriteLock.Sync#tryReadLock():::Performs tryLock for read, enabling barging in both modes:::Thread.currentThread->this.getState->this.exclusiveCount->this.getExclusiveOwnerThread->this.sharedCount->this.compareAndSetState->LockSupport.getThreadId->readHolds.set->readHolds.get
ReentrantReadWriteLock.ReadLock#lock():::Acquires the read lock:::sync.acquireShared
ReentrantReadWriteLock.ReadLock#lockInterruptibly():::Acquires the read lock unless the current thread is Thread#interrupt interrupted:::sync.acquireSharedInterruptibly
ReentrantReadWriteLock.ReadLock#tryLock():::Acquires the read lock only if the write lock is not held by another thread at the time of invocation:::sync.tryReadLock
ReentrantReadWriteLock.ReadLock#tryLock(long, TimeUnit):::Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::unit.toNanos->sync.tryAcquireSharedNanos
ReentrantReadWriteLock.ReadLock#unlock():::Attempts to release this lock:::sync.releaseShared
ReentrantReadWriteLock.ReadLock#newCondition():::Throws UnsupportedOperationException because ReadLocks do not support conditions.:::
ReentrantReadWriteLock.ReadLock#toString():::Returns a string identifying this lock, as well as its lock state:::sync.getReadLockCount->super.toString
ReentrantReadWriteLock.WriteLock#lock():::Acquires the write lock:::sync.acquire
ReentrantReadWriteLock.WriteLock#lockInterruptibly():::Acquires the write lock unless the current thread is Thread#interrupt interrupted:::sync.acquireInterruptibly
ReentrantReadWriteLock.WriteLock#tryLock():::Acquires the write lock only if it is not held by another thread at the time of invocation:::sync.tryWriteLock
ReentrantReadWriteLock.WriteLock#tryLock(long, TimeUnit):::Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::unit.toNanos->sync.tryAcquireNanos
ReentrantReadWriteLock.WriteLock#unlock():::Attempts to release this lock:::sync.release
ReentrantReadWriteLock.WriteLock#newCondition():::Returns a Condition instance for use with this Lock instance:::sync.newCondition
ReentrantReadWriteLock.WriteLock#toString():::Returns a string identifying this lock, as well as its lock state:::sync.getOwner->super.toString->o.getName
ReentrantReadWriteLock.WriteLock#isHeldByCurrentThread():::Queries if this write lock is held by the current thread:::sync.isHeldExclusively
ReentrantReadWriteLock.WriteLock#getHoldCount():::Queries the number of holds on this write lock by the current thread:::sync.getWriteHoldCount
ReentrantReadWriteLock#isFair():::Returns true if this lock has fairness set true.:::
ReentrantReadWriteLock#getOwner():::Returns the thread that currently owns the write lock, or null if not owned:::sync.getOwner
ReentrantReadWriteLock#getReadLockCount():::Queries the number of read locks held for this lock:::sync.getReadLockCount
ReentrantReadWriteLock#isWriteLocked():::Queries if the write lock is held by any thread:::sync.isWriteLocked
ReentrantReadWriteLock#isWriteLockedByCurrentThread():::Queries if the write lock is held by the current thread.:::sync.isHeldExclusively
ReentrantReadWriteLock#getWriteHoldCount():::Queries the number of reentrant write holds on this lock by the current thread:::sync.getWriteHoldCount
ReentrantReadWriteLock#getReadHoldCount():::Queries the number of reentrant read holds on this lock by the current thread:::sync.getReadHoldCount
ReentrantReadWriteLock#getQueuedWriterThreads():::Returns a collection containing threads that may be waiting to acquire the write lock:::sync.getExclusiveQueuedThreads
ReentrantReadWriteLock#getQueuedReaderThreads():::Returns a collection containing threads that may be waiting to acquire the read lock:::sync.getSharedQueuedThreads
ReentrantReadWriteLock#hasQueuedThreads():::Queries whether any threads are waiting to acquire the read or write lock:::sync.hasQueuedThreads
ReentrantReadWriteLock#hasQueuedThread(Thread):::Queries whether the given thread is waiting to acquire either the read or write lock:::sync.isQueued
ReentrantReadWriteLock#getQueueLength():::Returns an estimate of the number of threads waiting to acquire either the read or write lock:::sync.getQueueLength
ReentrantReadWriteLock#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire either the read or write lock:::sync.getQueuedThreads
ReentrantReadWriteLock#hasWaiters(Condition):::Queries whether any threads are waiting on the given condition associated with the write lock:::sync.hasWaiters
ReentrantReadWriteLock#getWaitQueueLength(Condition):::Returns an estimate of the number of threads waiting on the given condition associated with the write lock:::sync.getWaitQueueLength
ReentrantReadWriteLock#getWaitingThreads(Condition):::Returns a collection containing those threads that may be waiting on the given condition associated with the write lock:::sync.getWaitingThreads
ReentrantReadWriteLock#toString():::Returns a string identifying this lock, as well as its lock state:::sync.getCount->Sync.exclusiveCount->Sync.sharedCount->super.toString
StampedLock#writeLock():::Exclusively acquires the lock, blocking if necessary until available.:::this.tryWriteLock->this.acquireWrite
StampedLock#tryWriteLock():::Exclusively acquires the lock if it is immediately available.:::this.tryWriteLock
StampedLock#tryWriteLock(long, TimeUnit):::Exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted:::unit.toNanos->Thread.interrupted->this.tryWriteLock->System.nanoTime->this.acquireWrite
StampedLock#writeLockInterruptibly():::Exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted:::Thread.interrupted->this.acquireWrite
StampedLock#readLock():::Non-exclusively acquires the lock, blocking if necessary until available.:::this.casState->this.acquireRead
StampedLock#tryReadLock():::Non-exclusively acquires the lock if it is immediately available.:::this.tryIncReaderOverflow->this.casState
StampedLock#tryReadLock(long, TimeUnit):::Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted:::unit.toNanos->Thread.interrupted->this.tryIncReaderOverflow->this.casState->System.nanoTime->this.acquireRead
StampedLock#readLockInterruptibly():::Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted:::Thread.interrupted->this.casState->this.acquireRead
StampedLock#tryOptimisticRead():::Returns a stamp that can later be validated, or zero if exclusively locked.:::
StampedLock#validate(long):::Returns true if the lock has not been exclusively acquired since issuance of the given stamp:::VarHandle.acquireFence
StampedLock#unlockWrite(long):::If the lock state matches the given stamp, releases the exclusive lock.:::this.unlockWriteInternal
StampedLock#unlockRead(long):::If the lock state matches the given stamp, releases the non-exclusive lock.:::this.tryDecReaderOverflow->this.casState->this.release
StampedLock#unlock(long):::If the lock state matches the given stamp, releases the corresponding mode of the lock.:::this.unlockRead->this.unlockWrite
StampedLock#tryConvertToWriteLock(long):::If the lock state matches the given stamp, atomically performs one of the following actions:::this.casState->VarHandle.storeStoreFence->this.tryWriteLock
StampedLock#tryConvertToReadLock(long):::If the lock state matches the given stamp, atomically performs one of the following actions:::this.tryIncReaderOverflow->this.casState->STATE.setVolatile->this.release
StampedLock#tryConvertToOptimisticRead(long):::If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp:::VarHandle.acquireFence->this.tryDecReaderOverflow->this.casState->this.release->this.unlockWriteInternal
StampedLock#tryUnlockWrite():::Releases the write lock if it is held, without requiring a stamp value:::this.unlockWriteInternal
StampedLock#tryUnlockRead():::Releases one hold of the read lock if it is held, without requiring a stamp value:::this.tryDecReaderOverflow->this.casState->this.release
StampedLock#isWriteLocked():::Returns true if the lock is currently held exclusively.:::
StampedLock#isReadLocked():::Returns true if the lock is currently held non-exclusively.:::
StampedLock#isWriteLockStamp(long):::Tells whether a stamp represents holding a lock exclusively:::
StampedLock#isReadLockStamp(long):::Tells whether a stamp represents holding a lock non-exclusively:::
StampedLock#isLockStamp(long):::Tells whether a stamp represents holding a lock:::
StampedLock#isOptimisticReadStamp(long):::Tells whether a stamp represents a successful optimistic read.:::
StampedLock#getReadLockCount():::Queries the number of read locks held for this lock:::this.getReadLockCount
StampedLock#toString():::Returns a string identifying this lock, as well as its lock state:::super.toString->this.getReadLockCount
StampedLock#asReadLock():::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #readLock, and similarly for other methods:::
StampedLock#asWriteLock():::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #writeLock, and similarly for other methods:::
StampedLock#asReadWriteLock():::Returns a ReadWriteLock view of this StampedLock in which the ReadWriteLock#readLock() method is mapped to #asReadLock(), and ReadWriteLock#writeLock() to #asWriteLock().:::
