AbstractOwnableSynchronizer#setExclusiveOwnerThread(Thread):::Sets the thread that currently owns exclusive access:::
AbstractOwnableSynchronizer#getExclusiveOwnerThread():::Returns the thread last set by setExclusiveOwnerThread, or null if never set:::return
AbstractQueuedLongSynchronizer#getState():::Returns the current value of synchronization state:::return
AbstractQueuedLongSynchronizer#setState(long):::Sets the value of synchronization state:::STATE->setVolatile
AbstractQueuedLongSynchronizer#compareAndSetState(long, long):::Atomically sets synchronization state to the given updated value if the current state value equals the expected value:::return->STATE->compareAndSet
AbstractQueuedLongSynchronizer#selfInterrupt():::Convenience method to interrupt current thread.:::Thread->currentThread->interrupt
AbstractQueuedLongSynchronizer#acquireQueued(Node, long):::Acquires in exclusive uninterruptible mode for thread already in queue:::interrupted->try->for->catch->cancelAcquire->if->selfInterrupt->throw->finally
AbstractQueuedLongSynchronizer#tryAcquire(long):::Attempts to acquire in exclusive mode:::throw->new->UnsupportedOperationException
AbstractQueuedLongSynchronizer#tryRelease(long):::Attempts to set the state to reflect a release in exclusive mode:::throw->new->UnsupportedOperationException
AbstractQueuedLongSynchronizer#tryAcquireShared(long):::Attempts to acquire in shared mode:::throw->new->UnsupportedOperationException
AbstractQueuedLongSynchronizer#tryReleaseShared(long):::Attempts to set the state to reflect a release in shared mode:::throw->new->UnsupportedOperationException
AbstractQueuedLongSynchronizer#isHeldExclusively():::Returns true if synchronization is held exclusively with respect to the current (calling) thread:::throw->new->UnsupportedOperationException
AbstractQueuedLongSynchronizer#acquire(long):::Acquires in exclusive mode, ignoring interrupts:::if->tryAcquire->addWaiter->acquireQueued->selfInterrupt
AbstractQueuedLongSynchronizer#acquireInterruptibly(long):::Acquires in exclusive mode, aborting if interrupted:::if->Thread->interrupted->throw->new->InterruptedException->if->tryAcquire->doAcquireInterruptibly
AbstractQueuedLongSynchronizer#tryAcquireNanos(long, long):::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses:::if->Thread->interrupted->throw->new->InterruptedException->return->tryAcquire->doAcquireNanos
AbstractQueuedLongSynchronizer#release(long):::Releases in exclusive mode:::if->tryRelease->h->if->unparkSuccessor->return->return
AbstractQueuedLongSynchronizer#acquireShared(long):::Acquires in shared mode, ignoring interrupts:::if->tryAcquireShared->doAcquireShared
AbstractQueuedLongSynchronizer#acquireSharedInterruptibly(long):::Acquires in shared mode, aborting if interrupted:::if->Thread->interrupted->throw->new->InterruptedException->if->tryAcquireShared->doAcquireSharedInterruptibly
AbstractQueuedLongSynchronizer#tryAcquireSharedNanos(long, long):::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses:::if->Thread->interrupted->throw->new->InterruptedException->return->tryAcquireShared->doAcquireSharedNanos
AbstractQueuedLongSynchronizer#releaseShared(long):::Releases in shared mode:::if->tryReleaseShared->doReleaseShared->return->return
AbstractQueuedLongSynchronizer#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::for->p->h->return
AbstractQueuedLongSynchronizer#hasContended():::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked:::return
AbstractQueuedLongSynchronizer#getFirstQueuedThread():::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued:::return->fullGetFirstQueuedThread
AbstractQueuedLongSynchronizer#isQueued(Thread):::Returns true if the given thread is currently queued:::if->throw->new->NullPointerException->for->p->return
AbstractQueuedLongSynchronizer#apparentlyFirstQueuedIsExclusive():::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode:::h->s->return->s->isShared
AbstractQueuedLongSynchronizer#hasQueuedPredecessors():::Queries whether any threads have been waiting to acquire longer than the current thread:::h->s->if->if->for->p->if->Thread->currentThread->return->return
AbstractQueuedLongSynchronizer#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::n->for->p->return
AbstractQueuedLongSynchronizer#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::list->new->ArrayList<>->for->p->return
AbstractQueuedLongSynchronizer#getExclusiveQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in exclusive mode:::list->new->ArrayList<>->for->p->return
AbstractQueuedLongSynchronizer#getSharedQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in shared mode:::list->new->ArrayList<>->for->p->return
AbstractQueuedLongSynchronizer#toString():::Returns a string identifying this synchronizer, as well as its state:::return->super->toString->getState->hasQueuedThreads
AbstractQueuedLongSynchronizer#isOnSyncQueue(Node):::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.:::if->return->if->return->return->findNodeFromTail
AbstractQueuedLongSynchronizer#transferForSignal(Node):::Transfers a node from a condition queue onto sync queue:::if->node->compareAndSetWaitStatus->return->p->enq->ws->if->p->compareAndSetWaitStatus->LockSupport->unpark->return
AbstractQueuedLongSynchronizer#transferAfterCancelledWait(Node):::Transfers node, if necessary, to sync queue after a cancelled wait:::if->node->compareAndSetWaitStatus->enq->return->while->isOnSyncQueue->Thread->yield->return
AbstractQueuedLongSynchronizer#fullyRelease(Node):::Invokes release with current state value; returns saved state:::try->savedState->getState->if->release->return->throw->new->IllegalMonitorStateException->catch->throw->finally
AbstractQueuedLongSynchronizer#owns(ConditionObject):::Queries whether the given ConditionObject uses this synchronizer as its lock.:::return->condition->isOwnedBy
AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject):::Queries whether any threads are waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->hasWaiters
AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject):::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->getWaitQueueLength
AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject):::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->getWaitingThreads
AbstractQueuedLongSynchronizer.ConditionObject#signal():::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->first->if->doSignal
AbstractQueuedLongSynchronizer.ConditionObject#signalAll():::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->first->if->doSignalAll
AbstractQueuedLongSynchronizer.ConditionObject#awaitUninterruptibly():::Implements uninterruptible condition wait:::node->addConditionWaiter->savedState->fullyRelease->interrupted->while->isOnSyncQueue->LockSupport->park->if->Thread->interrupted->if->acquireQueued->selfInterrupt
AbstractQueuedLongSynchronizer.ConditionObject#await():::Implements interruptible condition wait:::if->Thread->interrupted->throw->new->InterruptedException->node->addConditionWaiter->savedState->fullyRelease->interruptMode->while->isOnSyncQueue->LockSupport->park->if->checkInterruptWhileWaiting->break->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait
AbstractQueuedLongSynchronizer.ConditionObject#awaitNanos(long):::Implements timed condition wait:::if->Thread->interrupted->throw->new->InterruptedException->deadline->System->nanoTime->initialNanos->node->addConditionWaiter->savedState->fullyRelease->interruptMode->while->isOnSyncQueue->if->transferAfterCancelledWait->break->if->LockSupport->parkNanos->if->checkInterruptWhileWaiting->break->System->nanoTime->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->remaining->System->nanoTime->return
AbstractQueuedLongSynchronizer.ConditionObject#awaitUntil(Date):::Implements absolute timed condition wait:::abstime->deadline->getTime->if->Thread->interrupted->throw->new->InterruptedException->node->addConditionWaiter->savedState->fullyRelease->timedout->interruptMode->while->isOnSyncQueue->if->System->currentTimeMillis->transferAfterCancelledWait->break->LockSupport->parkUntil->if->checkInterruptWhileWaiting->break->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->return
AbstractQueuedLongSynchronizer.ConditionObject#await(long, TimeUnit):::Implements timed condition wait:::nanosTimeout->unit->toNanos->if->Thread->interrupted->throw->new->InterruptedException->deadline->System->nanoTime->node->addConditionWaiter->savedState->fullyRelease->timedout->interruptMode->while->isOnSyncQueue->if->transferAfterCancelledWait->break->if->LockSupport->parkNanos->if->checkInterruptWhileWaiting->break->System->nanoTime->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->return
AbstractQueuedLongSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedLongSynchronizer):::Returns true if this condition was created by the given synchronization object.:::return
AbstractQueuedLongSynchronizer.ConditionObject#hasWaiters():::Queries whether any threads are waiting on this condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->for->w->return
AbstractQueuedLongSynchronizer.ConditionObject#getWaitQueueLength():::Returns an estimate of the number of threads waiting on this condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->n->for->w->return
AbstractQueuedLongSynchronizer.ConditionObject#getWaitingThreads():::Returns a collection containing those threads that may be waiting on this Condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->list->new->ArrayList<>->for->w->return
AbstractQueuedSynchronizer.Node#isShared():::Returns true if node is waiting in shared mode.:::return
AbstractQueuedSynchronizer.Node#predecessor():::Returns previous node, or throws NullPointerException if null:::p->if->throw->new->NullPointerException->else->return
AbstractQueuedSynchronizer.Node#compareAndSetWaitStatus(int, int):::CASes waitStatus field.:::return->WAITSTATUS->compareAndSet
AbstractQueuedSynchronizer.Node#compareAndSetNext(Node, Node):::CASes next field.:::return->NEXT->compareAndSet
AbstractQueuedSynchronizer#getState():::Returns the current value of synchronization state:::return
AbstractQueuedSynchronizer#setState(int):::Sets the value of synchronization state:::
AbstractQueuedSynchronizer#compareAndSetState(int, int):::Atomically sets synchronization state to the given updated value if the current state value equals the expected value:::return->STATE->compareAndSet
AbstractQueuedSynchronizer#selfInterrupt():::Convenience method to interrupt current thread.:::Thread->currentThread->interrupt
AbstractQueuedSynchronizer#acquireQueued(Node, int):::Acquires in exclusive uninterruptible mode for thread already in queue:::interrupted->try->for->catch->cancelAcquire->if->selfInterrupt->throw->finally
AbstractQueuedSynchronizer#tryAcquire(int):::Attempts to acquire in exclusive mode:::throw->new->UnsupportedOperationException
AbstractQueuedSynchronizer#tryRelease(int):::Attempts to set the state to reflect a release in exclusive mode:::throw->new->UnsupportedOperationException
AbstractQueuedSynchronizer#tryAcquireShared(int):::Attempts to acquire in shared mode:::throw->new->UnsupportedOperationException
AbstractQueuedSynchronizer#tryReleaseShared(int):::Attempts to set the state to reflect a release in shared mode:::throw->new->UnsupportedOperationException
AbstractQueuedSynchronizer#isHeldExclusively():::Returns true if synchronization is held exclusively with respect to the current (calling) thread:::throw->new->UnsupportedOperationException
AbstractQueuedSynchronizer#acquire(int):::Acquires in exclusive mode, ignoring interrupts:::if->tryAcquire->addWaiter->acquireQueued->selfInterrupt
AbstractQueuedSynchronizer#acquireInterruptibly(int):::Acquires in exclusive mode, aborting if interrupted:::if->Thread->interrupted->throw->new->InterruptedException->if->tryAcquire->doAcquireInterruptibly
AbstractQueuedSynchronizer#tryAcquireNanos(int, long):::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses:::if->Thread->interrupted->throw->new->InterruptedException->return->tryAcquire->doAcquireNanos
AbstractQueuedSynchronizer#release(int):::Releases in exclusive mode:::if->tryRelease->h->if->unparkSuccessor->return->return
AbstractQueuedSynchronizer#acquireShared(int):::Acquires in shared mode, ignoring interrupts:::if->tryAcquireShared->doAcquireShared
AbstractQueuedSynchronizer#acquireSharedInterruptibly(int):::Acquires in shared mode, aborting if interrupted:::if->Thread->interrupted->throw->new->InterruptedException->if->tryAcquireShared->doAcquireSharedInterruptibly
AbstractQueuedSynchronizer#tryAcquireSharedNanos(int, long):::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses:::if->Thread->interrupted->throw->new->InterruptedException->return->tryAcquireShared->doAcquireSharedNanos
AbstractQueuedSynchronizer#releaseShared(int):::Releases in shared mode:::if->tryReleaseShared->doReleaseShared->return->return
AbstractQueuedSynchronizer#hasQueuedThreads():::Queries whether any threads are waiting to acquire:::for->p->h->return
AbstractQueuedSynchronizer#hasContended():::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked:::return
AbstractQueuedSynchronizer#getFirstQueuedThread():::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued:::return->fullGetFirstQueuedThread
AbstractQueuedSynchronizer#isQueued(Thread):::Returns true if the given thread is currently queued:::if->throw->new->NullPointerException->for->p->return
AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive():::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode:::h->s->return->s->isShared
AbstractQueuedSynchronizer#hasQueuedPredecessors():::Queries whether any threads have been waiting to acquire longer than the current thread:::h->s->if->if->for->p->if->Thread->currentThread->return->return
AbstractQueuedSynchronizer#getQueueLength():::Returns an estimate of the number of threads waiting to acquire:::n->for->p->return
AbstractQueuedSynchronizer#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire:::list->new->ArrayList<>->for->p->return
AbstractQueuedSynchronizer#getExclusiveQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in exclusive mode:::list->new->ArrayList<>->for->p->return
AbstractQueuedSynchronizer#getSharedQueuedThreads():::Returns a collection containing threads that may be waiting to acquire in shared mode:::list->new->ArrayList<>->for->p->return
AbstractQueuedSynchronizer#toString():::Returns a string identifying this synchronizer, as well as its state:::return->super->toString->getState->hasQueuedThreads
AbstractQueuedSynchronizer#isOnSyncQueue(Node):::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.:::if->return->if->return->return->findNodeFromTail
AbstractQueuedSynchronizer#transferForSignal(Node):::Transfers a node from a condition queue onto sync queue:::if->node->compareAndSetWaitStatus->return->p->enq->ws->if->p->compareAndSetWaitStatus->LockSupport->unpark->return
AbstractQueuedSynchronizer#transferAfterCancelledWait(Node):::Transfers node, if necessary, to sync queue after a cancelled wait:::if->node->compareAndSetWaitStatus->enq->return->while->isOnSyncQueue->Thread->yield->return
AbstractQueuedSynchronizer#fullyRelease(Node):::Invokes release with current state value; returns saved state:::try->savedState->getState->if->release->return->throw->new->IllegalMonitorStateException->catch->throw->finally
AbstractQueuedSynchronizer#owns(ConditionObject):::Queries whether the given ConditionObject uses this synchronizer as its lock.:::return->condition->isOwnedBy
AbstractQueuedSynchronizer#hasWaiters(ConditionObject):::Queries whether any threads are waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->hasWaiters
AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject):::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->getWaitQueueLength
AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject):::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer:::if->owns->throw->new->IllegalArgumentException->return->condition->getWaitingThreads
AbstractQueuedSynchronizer.ConditionObject#signal():::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->first->if->doSignal
AbstractQueuedSynchronizer.ConditionObject#signalAll():::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->first->if->doSignalAll
AbstractQueuedSynchronizer.ConditionObject#awaitUninterruptibly():::Implements uninterruptible condition wait:::node->addConditionWaiter->savedState->fullyRelease->interrupted->while->isOnSyncQueue->LockSupport->park->if->Thread->interrupted->if->acquireQueued->selfInterrupt
AbstractQueuedSynchronizer.ConditionObject#await():::Implements interruptible condition wait:::if->Thread->interrupted->throw->new->InterruptedException->node->addConditionWaiter->savedState->fullyRelease->interruptMode->while->isOnSyncQueue->LockSupport->park->if->checkInterruptWhileWaiting->break->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait
AbstractQueuedSynchronizer.ConditionObject#awaitNanos(long):::Implements timed condition wait:::if->Thread->interrupted->throw->new->InterruptedException->deadline->System->nanoTime->initialNanos->node->addConditionWaiter->savedState->fullyRelease->interruptMode->while->isOnSyncQueue->if->transferAfterCancelledWait->break->if->LockSupport->parkNanos->if->checkInterruptWhileWaiting->break->System->nanoTime->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->remaining->System->nanoTime->return
AbstractQueuedSynchronizer.ConditionObject#awaitUntil(Date):::Implements absolute timed condition wait:::abstime->deadline->getTime->if->Thread->interrupted->throw->new->InterruptedException->node->addConditionWaiter->savedState->fullyRelease->timedout->interruptMode->while->isOnSyncQueue->if->System->currentTimeMillis->transferAfterCancelledWait->break->LockSupport->parkUntil->if->checkInterruptWhileWaiting->break->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->return
AbstractQueuedSynchronizer.ConditionObject#await(long, TimeUnit):::Implements timed condition wait:::nanosTimeout->unit->toNanos->if->Thread->interrupted->throw->new->InterruptedException->deadline->System->nanoTime->node->addConditionWaiter->savedState->fullyRelease->timedout->interruptMode->while->isOnSyncQueue->if->transferAfterCancelledWait->break->if->LockSupport->parkNanos->if->checkInterruptWhileWaiting->break->System->nanoTime->if->acquireQueued->if->unlinkCancelledWaiters->if->reportInterruptAfterWait->return
AbstractQueuedSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedSynchronizer):::Returns true if this condition was created by the given synchronization object.:::return
AbstractQueuedSynchronizer.ConditionObject#hasWaiters():::Queries whether any threads are waiting on this condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->for->w->return
AbstractQueuedSynchronizer.ConditionObject#getWaitQueueLength():::Returns an estimate of the number of threads waiting on this condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->n->for->w->return
AbstractQueuedSynchronizer.ConditionObject#getWaitingThreads():::Returns a collection containing those threads that may be waiting on this Condition:::if->isHeldExclusively->throw->new->IllegalMonitorStateException->list->new->ArrayList<>->for->w->return
Condition#await():::Causes the current thread to wait until it is signalled or Thread#interrupt interrupted:::
Condition#awaitUninterruptibly():::Causes the current thread to wait until it is signalled:::
Condition#awaitNanos(long):::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses:::
Condition#await(long, TimeUnit):::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses:::
Condition#awaitUntil(Date):::Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses:::
Condition#signal():::Wakes up one waiting thread:::
Condition#signalAll():::Wakes up all waiting threads:::
Lock#lock():::Acquires the lock:::
Lock#lockInterruptibly():::Acquires the lock unless the current thread is Thread#interrupt interrupted:::
Lock#tryLock():::Acquires the lock only if it is free at the time of invocation:::
Lock#tryLock(long, TimeUnit):::Acquires the lock if it is free within the given waiting time and the current thread has not been Thread#interrupt interrupted:::
Lock#unlock():::Releases the lock:::
Lock#newCondition():::Returns a new Condition instance that is bound to this Lock instance:::
LockSupport#unpark(Thread):::Makes available the permit for the given thread, if it was not already available:::if->U->unpark
LockSupport#park(Object):::Disables the current thread for thread scheduling purposes unless the permit is available:::t->Thread->currentThread->setBlocker->U->park->setBlocker
LockSupport#parkNanos(Object, long):::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available:::if->t->Thread->currentThread->setBlocker->U->park->setBlocker
LockSupport#parkUntil(Object, long):::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available:::t->Thread->currentThread->setBlocker->U->park->setBlocker
LockSupport#getBlocker(Thread):::Returns the blocker object supplied to the most recent invocation of a park method that has not yet unblocked, or null if not blocked:::if->throw->new->NullPointerException->return->U->getObjectVolatile
LockSupport#park():::Disables the current thread for thread scheduling purposes unless the permit is available:::U->park
LockSupport#parkNanos(long):::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available:::if->U->park
LockSupport#parkUntil(long):::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available:::U->park
LockSupport#nextSecondarySeed():::Returns the pseudo-randomly initialized or updated secondary seed:::r->t->Thread->currentThread->if->U->getInt->else->if->current->nextInt->U->putInt->return
LockSupport#getThreadId(Thread):::Returns the thread id for the given thread:::return->U->getLong
ReadWriteLock#readLock():::Returns the lock used for reading.:::
ReadWriteLock#writeLock():::Returns the lock used for writing.:::
ReentrantLock.Sync#nonfairTryAcquire(int):::Performs non-fair tryLock:::current->Thread->currentThread->c->getState->if->if->compareAndSetState->setExclusiveOwnerThread->return->else->if->getExclusiveOwnerThread->nextc->if->throw->new->Error->setState->return->return
ReentrantLock.FairSync#tryAcquire(int):::Fair version of tryAcquire:::current->Thread->currentThread->c->getState->if->if->hasQueuedPredecessors->compareAndSetState->setExclusiveOwnerThread->return->else->if->getExclusiveOwnerThread->nextc->if->throw->new->Error->setState->return->return
ReentrantLock#lock():::Acquires the lock:::sync->acquire
ReentrantLock#lockInterruptibly():::Acquires the lock unless the current thread is Thread#interrupt interrupted:::sync->acquireInterruptibly
ReentrantLock#tryLock():::Acquires the lock only if it is not held by another thread at the time of invocation:::return->sync->nonfairTryAcquire
ReentrantLock#tryLock(long, TimeUnit):::Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::return->sync->unit->toNanos->tryAcquireNanos
ReentrantLock#unlock():::Attempts to release this lock:::sync->release
ReentrantLock#newCondition():::Returns a Condition instance for use with this Lock instance:::return->sync->newCondition
ReentrantLock#getHoldCount():::Queries the number of holds on this lock by the current thread:::return->sync->getHoldCount
ReentrantLock#isHeldByCurrentThread():::Queries if this lock is held by the current thread:::return->sync->isHeldExclusively
ReentrantLock#isLocked():::Queries if this lock is held by any thread:::return->sync->isLocked
ReentrantLock#isFair():::Returns true if this lock has fairness set true.:::return
ReentrantLock#getOwner():::Returns the thread that currently owns this lock, or null if not owned:::return->sync->getOwner
ReentrantLock#hasQueuedThreads():::Queries whether any threads are waiting to acquire this lock:::return->sync->hasQueuedThreads
ReentrantLock#hasQueuedThread(Thread):::Queries whether the given thread is waiting to acquire this lock:::return->sync->isQueued
ReentrantLock#getQueueLength():::Returns an estimate of the number of threads waiting to acquire this lock:::return->sync->getQueueLength
ReentrantLock#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire this lock:::return->sync->getQueuedThreads
ReentrantLock#hasWaiters(Condition):::Queries whether any threads are waiting on the given condition associated with this lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->hasWaiters
ReentrantLock#getWaitQueueLength(Condition):::Returns an estimate of the number of threads waiting on the given condition associated with this lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->getWaitQueueLength
ReentrantLock#getWaitingThreads(Condition):::Returns a collection containing those threads that may be waiting on the given condition associated with this lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->getWaitingThreads
ReentrantLock#toString():::Returns a string identifying this lock, as well as its lock state:::o->sync->getOwner->return->super->toString->o->getName
ReentrantReadWriteLock.Sync#sharedCount(int):::Returns the number of shared holds represented in count.:::return
ReentrantReadWriteLock.Sync#exclusiveCount(int):::Returns the number of exclusive holds represented in count.:::return
ReentrantReadWriteLock.Sync#readerShouldBlock():::Returns true if the current thread, when trying to acquire the read lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.:::
ReentrantReadWriteLock.Sync#writerShouldBlock():::Returns true if the current thread, when trying to acquire the write lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.:::
ReentrantReadWriteLock.Sync#fullTryAcquireShared(Thread):::Full version of acquire for reads, that handles CAS misses and reentrant reads not dealt with in tryAcquireShared.:::rh->for
ReentrantReadWriteLock.Sync#tryWriteLock():::Performs tryLock for write, enabling barging in both modes:::current->Thread->currentThread->c->getState->if->w->exclusiveCount->if->getExclusiveOwnerThread->return->if->throw->new->Error->if->compareAndSetState->return->setExclusiveOwnerThread->return
ReentrantReadWriteLock.Sync#tryReadLock():::Performs tryLock for read, enabling barging in both modes:::current->Thread->currentThread->for
ReentrantReadWriteLock.ReadLock#lock():::Acquires the read lock:::sync->acquireShared
ReentrantReadWriteLock.ReadLock#lockInterruptibly():::Acquires the read lock unless the current thread is Thread#interrupt interrupted:::sync->acquireSharedInterruptibly
ReentrantReadWriteLock.ReadLock#tryLock():::Acquires the read lock only if the write lock is not held by another thread at the time of invocation:::return->sync->tryReadLock
ReentrantReadWriteLock.ReadLock#tryLock(long, TimeUnit):::Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::return->sync->unit->toNanos->tryAcquireSharedNanos
ReentrantReadWriteLock.ReadLock#unlock():::Attempts to release this lock:::sync->releaseShared
ReentrantReadWriteLock.ReadLock#newCondition():::Throws UnsupportedOperationException because ReadLocks do not support conditions.:::throw->new->UnsupportedOperationException
ReentrantReadWriteLock.ReadLock#toString():::Returns a string identifying this lock, as well as its lock state:::r->sync->getReadLockCount->return->super->toString
ReentrantReadWriteLock.WriteLock#lock():::Acquires the write lock:::sync->acquire
ReentrantReadWriteLock.WriteLock#lockInterruptibly():::Acquires the write lock unless the current thread is Thread#interrupt interrupted:::sync->acquireInterruptibly
ReentrantReadWriteLock.WriteLock#tryLock():::Acquires the write lock only if it is not held by another thread at the time of invocation:::return->sync->tryWriteLock
ReentrantReadWriteLock.WriteLock#tryLock(long, TimeUnit):::Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted:::return->sync->unit->toNanos->tryAcquireNanos
ReentrantReadWriteLock.WriteLock#unlock():::Attempts to release this lock:::sync->release
ReentrantReadWriteLock.WriteLock#newCondition():::Returns a Condition instance for use with this Lock instance:::return->sync->newCondition
ReentrantReadWriteLock.WriteLock#toString():::Returns a string identifying this lock, as well as its lock state:::o->sync->getOwner->return->super->toString->o->getName
ReentrantReadWriteLock.WriteLock#isHeldByCurrentThread():::Queries if this write lock is held by the current thread:::return->sync->isHeldExclusively
ReentrantReadWriteLock.WriteLock#getHoldCount():::Queries the number of holds on this write lock by the current thread:::return->sync->getWriteHoldCount
ReentrantReadWriteLock#isFair():::Returns true if this lock has fairness set true.:::return
ReentrantReadWriteLock#getOwner():::Returns the thread that currently owns the write lock, or null if not owned:::return->sync->getOwner
ReentrantReadWriteLock#getReadLockCount():::Queries the number of read locks held for this lock:::return->sync->getReadLockCount
ReentrantReadWriteLock#isWriteLocked():::Queries if the write lock is held by any thread:::return->sync->isWriteLocked
ReentrantReadWriteLock#isWriteLockedByCurrentThread():::Queries if the write lock is held by the current thread.:::return->sync->isHeldExclusively
ReentrantReadWriteLock#getWriteHoldCount():::Queries the number of reentrant write holds on this lock by the current thread:::return->sync->getWriteHoldCount
ReentrantReadWriteLock#getReadHoldCount():::Queries the number of reentrant read holds on this lock by the current thread:::return->sync->getReadHoldCount
ReentrantReadWriteLock#getQueuedWriterThreads():::Returns a collection containing threads that may be waiting to acquire the write lock:::return->sync->getExclusiveQueuedThreads
ReentrantReadWriteLock#getQueuedReaderThreads():::Returns a collection containing threads that may be waiting to acquire the read lock:::return->sync->getSharedQueuedThreads
ReentrantReadWriteLock#hasQueuedThreads():::Queries whether any threads are waiting to acquire the read or write lock:::return->sync->hasQueuedThreads
ReentrantReadWriteLock#hasQueuedThread(Thread):::Queries whether the given thread is waiting to acquire either the read or write lock:::return->sync->isQueued
ReentrantReadWriteLock#getQueueLength():::Returns an estimate of the number of threads waiting to acquire either the read or write lock:::return->sync->getQueueLength
ReentrantReadWriteLock#getQueuedThreads():::Returns a collection containing threads that may be waiting to acquire either the read or write lock:::return->sync->getQueuedThreads
ReentrantReadWriteLock#hasWaiters(Condition):::Queries whether any threads are waiting on the given condition associated with the write lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->hasWaiters
ReentrantReadWriteLock#getWaitQueueLength(Condition):::Returns an estimate of the number of threads waiting on the given condition associated with the write lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->getWaitQueueLength
ReentrantReadWriteLock#getWaitingThreads(Condition):::Returns a collection containing those threads that may be waiting on the given condition associated with the write lock:::if->throw->new->NullPointerException->if->throw->new->IllegalArgumentException->return->sync->getWaitingThreads
ReentrantReadWriteLock#toString():::Returns a string identifying this lock, as well as its lock state:::c->sync->getCount->w->Sync->exclusiveCount->r->Sync->sharedCount->return->super->toString
StampedLock#writeLock():::Exclusively acquires the lock, blocking if necessary until available.:::next->return->tryWriteLock->acquireWrite
StampedLock#tryWriteLock():::Exclusively acquires the lock if it is immediately available.:::s->return->tryWriteLock
StampedLock#tryWriteLock(long, TimeUnit):::Exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted:::nanos->unit->toNanos->if->Thread->interrupted->next->deadline->if->tryWriteLock->return->if->return->if->System->nanoTime->if->acquireWrite->return->throw->new->InterruptedException
StampedLock#writeLockInterruptibly():::Exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted:::next->if->Thread->interrupted->acquireWrite->return->throw->new->InterruptedException
StampedLock#readLock():::Non-exclusively acquires the lock, blocking if necessary until available.:::s->next->return->casState->acquireRead
StampedLock#tryReadLock():::Non-exclusively acquires the lock if it is immediately available.:::s->m->next->while->if->if->casState->return->else->if->tryIncReaderOverflow->return->return
StampedLock#tryReadLock(long, TimeUnit):::Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted:::s->m->next->deadline->nanos->unit->toNanos->if->Thread->interrupted->if->if->if->casState->return->else->if->tryIncReaderOverflow->return->if->return->if->System->nanoTime->if->acquireRead->return->throw->new->InterruptedException
StampedLock#readLockInterruptibly():::Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted:::s->next->if->Thread->interrupted->casState->acquireRead->return->throw->new->InterruptedException
StampedLock#tryOptimisticRead():::Returns a stamp that can later be validated, or zero if exclusively locked.:::s->return
StampedLock#validate(long):::Returns true if the lock has not been exclusively acquired since issuance of the given stamp:::VarHandle->acquireFence->return
StampedLock#unlockWrite(long):::If the lock state matches the given stamp, releases the exclusive lock.:::if->throw->new->IllegalMonitorStateException->unlockWriteInternal
StampedLock#unlockRead(long):::If the lock state matches the given stamp, releases the non-exclusive lock.:::s->m->h->while->if->if->casState->if->release->return->else->if->tryDecReaderOverflow->return->throw->new->IllegalMonitorStateException
StampedLock#unlock(long):::If the lock state matches the given stamp, releases the corresponding mode of the lock.:::if->unlockWrite->else->unlockRead
StampedLock#tryConvertToWriteLock(long):::If the lock state matches the given stamp, atomically performs one of the following actions:::a->m->s->next->while->if->if->break->if->tryWriteLock->return->else->if->if->break->return->else->if->if->casState->VarHandle->storeStoreFence->return->else->break->return
StampedLock#tryConvertToReadLock(long):::If the lock state matches the given stamp, atomically performs one of the following actions:::a->s->next->h->while->if->if->break->STATE->unlockWriteState->setVolatile->if->release->return->else->if->if->if->casState->return->else->if->tryIncReaderOverflow->return->else->if->break->return->return
StampedLock#tryConvertToOptimisticRead(long):::If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp:::a->m->s->next->h->VarHandle->acquireFence->while->if->if->break->return->unlockWriteInternal->else->if->return->else->if->break->else->if->if->casState->if->release->return->else->if->tryDecReaderOverflow->return->return
StampedLock#tryUnlockWrite():::Releases the write lock if it is held, without requiring a stamp value:::s->if->unlockWriteInternal->return->return
StampedLock#tryUnlockRead():::Releases one hold of the read lock if it is held, without requiring a stamp value:::s->m->h->while->if->if->casState->if->release->return->else->if->tryDecReaderOverflow->return->return
StampedLock#isWriteLocked():::Returns true if the lock is currently held exclusively.:::return
StampedLock#isReadLocked():::Returns true if the lock is currently held non-exclusively.:::return
StampedLock#isWriteLockStamp(long):::Tells whether a stamp represents holding a lock exclusively:::return
StampedLock#isReadLockStamp(long):::Tells whether a stamp represents holding a lock non-exclusively:::return
StampedLock#isLockStamp(long):::Tells whether a stamp represents holding a lock:::return
StampedLock#isOptimisticReadStamp(long):::Tells whether a stamp represents a successful optimistic read.:::return
StampedLock#getReadLockCount():::Queries the number of read locks held for this lock:::return->getReadLockCount
StampedLock#toString():::Returns a string identifying this lock, as well as its lock state:::s->return->super->toString->getReadLockCount
StampedLock#asReadLock():::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #readLock, and similarly for other methods:::v->if->return->return->new->ReadLockView
StampedLock#asWriteLock():::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #writeLock, and similarly for other methods:::v->if->return->return->new->WriteLockView
StampedLock#asReadWriteLock():::Returns a ReadWriteLock view of this StampedLock in which the ReadWriteLock#readLock() method is mapped to #asReadLock(), and ReadWriteLock#writeLock() to #asWriteLock().:::v->if->return->return->new->ReadWriteLockView
