java.util.concurrent.locks.AbstractOwnableSynchronizer#setExclusiveOwnerThread(Thread)->void:::Sets the thread that currently owns exclusive access
java.util.concurrent.locks.AbstractOwnableSynchronizer#getExclusiveOwnerThread()->Thread:::Returns the thread last set by setExclusiveOwnerThread, or null if never set
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getState()->long:::Returns the current value of synchronization state
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#setState(long)->void:::Sets the value of synchronization state
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#compareAndSetState(long, long)->boolean:::Atomically sets synchronization state to the given updated value if the current state value equals the expected value
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#selfInterrupt()->void:::Convenience method to interrupt current thread.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#acquireQueued(Node, long)->boolean:::Acquires in exclusive uninterruptible mode for thread already in queue
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryAcquire(long)->boolean:::Attempts to acquire in exclusive mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryRelease(long)->boolean:::Attempts to set the state to reflect a release in exclusive mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryAcquireShared(long)->long:::Attempts to acquire in shared mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryReleaseShared(long)->boolean:::Attempts to set the state to reflect a release in shared mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#isHeldExclusively()->boolean:::Returns true if synchronization is held exclusively with respect to the current (calling) thread
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#acquire(long)->void:::Acquires in exclusive mode, ignoring interrupts
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#acquireInterruptibly(long)->void:::Acquires in exclusive mode, aborting if interrupted
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryAcquireNanos(long, long)->boolean:::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#release(long)->boolean:::Releases in exclusive mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#acquireShared(long)->void:::Acquires in shared mode, ignoring interrupts
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#acquireSharedInterruptibly(long)->void:::Acquires in shared mode, aborting if interrupted
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#tryAcquireSharedNanos(long, long)->boolean:::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#releaseShared(long)->boolean:::Releases in shared mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#hasContended()->boolean:::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getFirstQueuedThread()->Thread:::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#isQueued(Thread)->boolean:::Returns true if the given thread is currently queued
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#apparentlyFirstQueuedIsExclusive()->boolean:::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#hasQueuedPredecessors()->boolean:::Queries whether any threads have been waiting to acquire longer than the current thread
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getExclusiveQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire in exclusive mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getSharedQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire in shared mode
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#toString()->String:::Returns a string identifying this synchronizer, as well as its state
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#isOnSyncQueue(Node)->boolean:::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#transferForSignal(Node)->boolean:::Transfers a node from a condition queue onto sync queue
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#transferAfterCancelledWait(Node)->boolean:::Transfers node, if necessary, to sync queue after a cancelled wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#fullyRelease(Node)->long:::Invokes release with current state value; returns saved state
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#owns(ConditionObject)->boolean:::Queries whether the given ConditionObject uses this synchronizer as its lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)->boolean:::Queries whether any threads are waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)->int:::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)->Collection:::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#signal()->void:::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#signalAll()->void:::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#awaitUninterruptibly()->void:::Implements uninterruptible condition wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#await()->void:::Implements interruptible condition wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#awaitNanos(long)->long:::Implements timed condition wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#awaitUntil(Date)->boolean:::Implements absolute timed condition wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#await(long, TimeUnit)->boolean:::Implements timed condition wait
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedLongSynchronizer)->boolean:::Returns true if this condition was created by the given synchronization object.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#hasWaiters()->boolean:::Queries whether any threads are waiting on this condition
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#getWaitQueueLength()->int:::Returns an estimate of the number of threads waiting on this condition
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject#getWaitingThreads()->Collection:::Returns a collection containing those threads that may be waiting on this Condition
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#isShared()->boolean:::Returns true if node is waiting in shared mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#predecessor()->Node:::Returns previous node, or throws NullPointerException if null
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#compareAndSetWaitStatus(int, int)->boolean:::CASes waitStatus field.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#compareAndSetNext(Node, Node)->boolean:::CASes next field.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node#setPrevRelaxed(Node)->void::: node set prev relaxed
java.util.concurrent.locks.AbstractQueuedSynchronizer#getState()->int:::Returns the current value of synchronization state
java.util.concurrent.locks.AbstractQueuedSynchronizer#setState(int)->void:::Sets the value of synchronization state
java.util.concurrent.locks.AbstractQueuedSynchronizer#compareAndSetState(int, int)->boolean:::Atomically sets synchronization state to the given updated value if the current state value equals the expected value
java.util.concurrent.locks.AbstractQueuedSynchronizer#selfInterrupt()->void:::Convenience method to interrupt current thread.
java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued(Node, int)->boolean:::Acquires in exclusive uninterruptible mode for thread already in queue
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire(int)->boolean:::Attempts to acquire in exclusive mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryRelease(int)->boolean:::Attempts to set the state to reflect a release in exclusive mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquireShared(int)->int:::Attempts to acquire in shared mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryReleaseShared(int)->boolean:::Attempts to set the state to reflect a release in shared mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#isHeldExclusively()->boolean:::Returns true if synchronization is held exclusively with respect to the current (calling) thread
java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire(int)->void:::Acquires in exclusive mode, ignoring interrupts
java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireInterruptibly(int)->void:::Acquires in exclusive mode, aborting if interrupted
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquireNanos(int, long)->boolean:::Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses
java.util.concurrent.locks.AbstractQueuedSynchronizer#release(int)->boolean:::Releases in exclusive mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireShared(int)->void:::Acquires in shared mode, ignoring interrupts
java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireSharedInterruptibly(int)->void:::Acquires in shared mode, aborting if interrupted
java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquireSharedNanos(int, long)->boolean:::Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses
java.util.concurrent.locks.AbstractQueuedSynchronizer#releaseShared(int)->boolean:::Releases in shared mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire
java.util.concurrent.locks.AbstractQueuedSynchronizer#hasContended()->boolean:::Queries whether any threads have ever contended to acquire this synchronizer; that is, if an acquire method has ever blocked
java.util.concurrent.locks.AbstractQueuedSynchronizer#getFirstQueuedThread()->Thread:::Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued
java.util.concurrent.locks.AbstractQueuedSynchronizer#isQueued(Thread)->boolean:::Returns true if the given thread is currently queued
java.util.concurrent.locks.AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive()->boolean:::Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors()->boolean:::Queries whether any threads have been waiting to acquire longer than the current thread
java.util.concurrent.locks.AbstractQueuedSynchronizer#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire
java.util.concurrent.locks.AbstractQueuedSynchronizer#getQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire
java.util.concurrent.locks.AbstractQueuedSynchronizer#getExclusiveQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire in exclusive mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#getSharedQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire in shared mode
java.util.concurrent.locks.AbstractQueuedSynchronizer#toString()->String:::Returns a string identifying this synchronizer, as well as its state
java.util.concurrent.locks.AbstractQueuedSynchronizer#isOnSyncQueue(Node)->boolean:::Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.
java.util.concurrent.locks.AbstractQueuedSynchronizer#transferForSignal(Node)->boolean:::Transfers a node from a condition queue onto sync queue
java.util.concurrent.locks.AbstractQueuedSynchronizer#transferAfterCancelledWait(Node)->boolean:::Transfers node, if necessary, to sync queue after a cancelled wait
java.util.concurrent.locks.AbstractQueuedSynchronizer#fullyRelease(Node)->int:::Invokes release with current state value; returns saved state
java.util.concurrent.locks.AbstractQueuedSynchronizer#owns(ConditionObject)->boolean:::Queries whether the given ConditionObject uses this synchronizer as its lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer#hasWaiters(ConditionObject)->boolean:::Queries whether any threads are waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)->int:::Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)->Collection:::Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#signal()->void:::Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#signalAll()->void:::Moves all threads from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#awaitUninterruptibly()->void:::Implements uninterruptible condition wait
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#await()->void:::Implements interruptible condition wait
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#awaitNanos(long)->long:::Implements timed condition wait
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#awaitUntil(Date)->boolean:::Implements absolute timed condition wait
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#await(long, TimeUnit)->boolean:::Implements timed condition wait
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#isOwnedBy(AbstractQueuedSynchronizer)->boolean:::Returns true if this condition was created by the given synchronization object.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#hasWaiters()->boolean:::Queries whether any threads are waiting on this condition
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#getWaitQueueLength()->int:::Returns an estimate of the number of threads waiting on this condition
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#getWaitingThreads()->Collection:::Returns a collection containing those threads that may be waiting on this Condition
java.util.concurrent.locks.Condition#await()->void:::Causes the current thread to wait until it is signalled or Thread#interrupt interrupted
java.util.concurrent.locks.Condition#awaitUninterruptibly()->void:::Causes the current thread to wait until it is signalled
java.util.concurrent.locks.Condition#awaitNanos(long)->long:::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses
java.util.concurrent.locks.Condition#await(long, TimeUnit)->boolean:::Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses
java.util.concurrent.locks.Condition#awaitUntil(Date)->boolean:::Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses
java.util.concurrent.locks.Condition#signal()->void:::Wakes up one waiting thread
java.util.concurrent.locks.Condition#signalAll()->void:::Wakes up all waiting threads
java.util.concurrent.locks.Lock#lock()->void:::Acquires the lock
java.util.concurrent.locks.Lock#lockInterruptibly()->void:::Acquires the lock unless the current thread is Thread#interrupt interrupted
java.util.concurrent.locks.Lock#tryLock()->boolean:::Acquires the lock only if it is free at the time of invocation
java.util.concurrent.locks.Lock#tryLock(long, TimeUnit)->boolean:::Acquires the lock if it is free within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.locks.Lock#unlock()->void:::Releases the lock
java.util.concurrent.locks.Lock#newCondition()->Condition:::Returns a new Condition instance that is bound to this Lock instance
java.util.concurrent.locks.LockSupport#unpark(Thread)->void:::Makes available the permit for the given thread, if it was not already available
java.util.concurrent.locks.LockSupport#park(Object)->void:::Disables the current thread for thread scheduling purposes unless the permit is available
java.util.concurrent.locks.LockSupport#parkNanos(Object, long)->void:::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available
java.util.concurrent.locks.LockSupport#parkUntil(Object, long)->void:::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available
java.util.concurrent.locks.LockSupport#getBlocker(Thread)->Object:::Returns the blocker object supplied to the most recent invocation of a park method that has not yet unblocked, or null if not blocked
java.util.concurrent.locks.LockSupport#park()->void:::Disables the current thread for thread scheduling purposes unless the permit is available
java.util.concurrent.locks.LockSupport#parkNanos(long)->void:::Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available
java.util.concurrent.locks.LockSupport#parkUntil(long)->void:::Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available
java.util.concurrent.locks.LockSupport#nextSecondarySeed()->int:::Returns the pseudo-randomly initialized or updated secondary seed
java.util.concurrent.locks.LockSupport#getThreadId(Thread)->long:::Returns the thread id for the given thread
java.util.concurrent.locks.ReadWriteLock#readLock()->Lock:::Returns the lock used for reading.
java.util.concurrent.locks.ReadWriteLock#writeLock()->Lock:::Returns the lock used for writing.
java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire(int)->boolean:::Performs non-fair tryLock
java.util.concurrent.locks.ReentrantLock.Sync#tryRelease(int)->boolean::: sync try release
java.util.concurrent.locks.ReentrantLock.Sync#isHeldExclusively()->boolean::: sync is held exclusively
java.util.concurrent.locks.ReentrantLock.Sync#newCondition()->ConditionObject::: sync new condition
java.util.concurrent.locks.ReentrantLock.Sync#getOwner()->Thread::: sync get owner
java.util.concurrent.locks.ReentrantLock.Sync#getHoldCount()->int::: sync get hold count
java.util.concurrent.locks.ReentrantLock.Sync#isLocked()->boolean::: sync is locked
java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire(int)->boolean::: nonfair sync try acquire
java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire(int)->boolean:::Fair version of tryAcquire
java.util.concurrent.locks.ReentrantLock#lock()->void:::Acquires the lock
java.util.concurrent.locks.ReentrantLock#lockInterruptibly()->void:::Acquires the lock unless the current thread is Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantLock#tryLock()->boolean:::Acquires the lock only if it is not held by another thread at the time of invocation
java.util.concurrent.locks.ReentrantLock#tryLock(long, TimeUnit)->boolean:::Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantLock#unlock()->void:::Attempts to release this lock
java.util.concurrent.locks.ReentrantLock#newCondition()->Condition:::Returns a Condition instance for use with this Lock instance
java.util.concurrent.locks.ReentrantLock#getHoldCount()->int:::Queries the number of holds on this lock by the current thread
java.util.concurrent.locks.ReentrantLock#isHeldByCurrentThread()->boolean:::Queries if this lock is held by the current thread
java.util.concurrent.locks.ReentrantLock#isLocked()->boolean:::Queries if this lock is held by any thread
java.util.concurrent.locks.ReentrantLock#isFair()->boolean:::Returns true if this lock has fairness set true.
java.util.concurrent.locks.ReentrantLock#getOwner()->Thread:::Returns the thread that currently owns this lock, or null if not owned
java.util.concurrent.locks.ReentrantLock#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire this lock
java.util.concurrent.locks.ReentrantLock#hasQueuedThread(Thread)->boolean:::Queries whether the given thread is waiting to acquire this lock
java.util.concurrent.locks.ReentrantLock#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire this lock
java.util.concurrent.locks.ReentrantLock#getQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire this lock
java.util.concurrent.locks.ReentrantLock#hasWaiters(Condition)->boolean:::Queries whether any threads are waiting on the given condition associated with this lock
java.util.concurrent.locks.ReentrantLock#getWaitQueueLength(Condition)->int:::Returns an estimate of the number of threads waiting on the given condition associated with this lock
java.util.concurrent.locks.ReentrantLock#getWaitingThreads(Condition)->Collection:::Returns a collection containing those threads that may be waiting on the given condition associated with this lock
java.util.concurrent.locks.ReentrantLock#toString()->String:::Returns a string identifying this lock, as well as its lock state
java.util.concurrent.locks.ReentrantReadWriteLock#writeLock()->ReentrantReadWriteLock.WriteLock::: reentrant read write lock write lock
java.util.concurrent.locks.ReentrantReadWriteLock#readLock()->ReentrantReadWriteLock.ReadLock::: reentrant read write lock read lock
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#sharedCount(int)->int:::Returns the number of shared holds represented in count.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#exclusiveCount(int)->int:::Returns the number of exclusive holds represented in count.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter#initialValue()->HoldCounter::: thread local hold counter initial value
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#readerShouldBlock()->boolean:::Returns true if the current thread, when trying to acquire the read lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#writerShouldBlock()->boolean:::Returns true if the current thread, when trying to acquire the write lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryRelease(int)->boolean::: sync try release
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryAcquire(int)->boolean::: sync try acquire
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryReleaseShared(int)->boolean::: sync try release shared
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryAcquireShared(int)->int::: sync try acquire shared
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#fullTryAcquireShared(Thread)->int:::Full version of acquire for reads, that handles CAS misses and reentrant reads not dealt with in tryAcquireShared.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryWriteLock()->boolean:::Performs tryLock for write, enabling barging in both modes
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryReadLock()->boolean:::Performs tryLock for read, enabling barging in both modes
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#isHeldExclusively()->boolean::: sync is held exclusively
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#newCondition()->ConditionObject::: sync new condition
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#getOwner()->Thread::: sync get owner
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#getReadLockCount()->int::: sync get read lock count
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#isWriteLocked()->boolean::: sync is write locked
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#getWriteHoldCount()->int::: sync get write hold count
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#getReadHoldCount()->int::: sync get read hold count
java.util.concurrent.locks.ReentrantReadWriteLock.Sync#getCount()->int::: sync get count
java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync#writerShouldBlock()->boolean::: nonfair sync writer should block
java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync#readerShouldBlock()->boolean::: nonfair sync reader should block
java.util.concurrent.locks.ReentrantReadWriteLock.FairSync#writerShouldBlock()->boolean::: fair sync writer should block
java.util.concurrent.locks.ReentrantReadWriteLock.FairSync#readerShouldBlock()->boolean::: fair sync reader should block
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#lock()->void:::Acquires the read lock
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#lockInterruptibly()->void:::Acquires the read lock unless the current thread is Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#tryLock()->boolean:::Acquires the read lock only if the write lock is not held by another thread at the time of invocation
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#tryLock(long, TimeUnit)->boolean:::Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#unlock()->void:::Attempts to release this lock
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#newCondition()->Condition:::Throws UnsupportedOperationException because ReadLocks do not support conditions.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#toString()->String:::Returns a string identifying this lock, as well as its lock state
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#lock()->void:::Acquires the write lock
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#lockInterruptibly()->void:::Acquires the write lock unless the current thread is Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#tryLock()->boolean:::Acquires the write lock only if it is not held by another thread at the time of invocation
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#tryLock(long, TimeUnit)->boolean:::Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been Thread#interrupt interrupted
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#unlock()->void:::Attempts to release this lock
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#newCondition()->Condition:::Returns a Condition instance for use with this Lock instance
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#toString()->String:::Returns a string identifying this lock, as well as its lock state
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#isHeldByCurrentThread()->boolean:::Queries if this write lock is held by the current thread
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock#getHoldCount()->int:::Queries the number of holds on this write lock by the current thread
java.util.concurrent.locks.ReentrantReadWriteLock#isFair()->boolean:::Returns true if this lock has fairness set true.
java.util.concurrent.locks.ReentrantReadWriteLock#getOwner()->Thread:::Returns the thread that currently owns the write lock, or null if not owned
java.util.concurrent.locks.ReentrantReadWriteLock#getReadLockCount()->int:::Queries the number of read locks held for this lock
java.util.concurrent.locks.ReentrantReadWriteLock#isWriteLocked()->boolean:::Queries if the write lock is held by any thread
java.util.concurrent.locks.ReentrantReadWriteLock#isWriteLockedByCurrentThread()->boolean:::Queries if the write lock is held by the current thread.
java.util.concurrent.locks.ReentrantReadWriteLock#getWriteHoldCount()->int:::Queries the number of reentrant write holds on this lock by the current thread
java.util.concurrent.locks.ReentrantReadWriteLock#getReadHoldCount()->int:::Queries the number of reentrant read holds on this lock by the current thread
java.util.concurrent.locks.ReentrantReadWriteLock#getQueuedWriterThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire the write lock
java.util.concurrent.locks.ReentrantReadWriteLock#getQueuedReaderThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire the read lock
java.util.concurrent.locks.ReentrantReadWriteLock#hasQueuedThreads()->boolean:::Queries whether any threads are waiting to acquire the read or write lock
java.util.concurrent.locks.ReentrantReadWriteLock#hasQueuedThread(Thread)->boolean:::Queries whether the given thread is waiting to acquire either the read or write lock
java.util.concurrent.locks.ReentrantReadWriteLock#getQueueLength()->int:::Returns an estimate of the number of threads waiting to acquire either the read or write lock
java.util.concurrent.locks.ReentrantReadWriteLock#getQueuedThreads()->Collection:::Returns a collection containing threads that may be waiting to acquire either the read or write lock
java.util.concurrent.locks.ReentrantReadWriteLock#hasWaiters(Condition)->boolean:::Queries whether any threads are waiting on the given condition associated with the write lock
java.util.concurrent.locks.ReentrantReadWriteLock#getWaitQueueLength(Condition)->int:::Returns an estimate of the number of threads waiting on the given condition associated with the write lock
java.util.concurrent.locks.ReentrantReadWriteLock#getWaitingThreads(Condition)->Collection:::Returns a collection containing those threads that may be waiting on the given condition associated with the write lock
java.util.concurrent.locks.ReentrantReadWriteLock#toString()->String:::Returns a string identifying this lock, as well as its lock state
java.util.concurrent.locks.StampedLock#writeLock()->long:::Exclusively acquires the lock, blocking if necessary until available.
java.util.concurrent.locks.StampedLock#tryWriteLock()->long:::Exclusively acquires the lock if it is immediately available.
java.util.concurrent.locks.StampedLock#tryWriteLock(long, TimeUnit)->long:::Exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted
java.util.concurrent.locks.StampedLock#writeLockInterruptibly()->long:::Exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted
java.util.concurrent.locks.StampedLock#readLock()->long:::Non-exclusively acquires the lock, blocking if necessary until available.
java.util.concurrent.locks.StampedLock#tryReadLock()->long:::Non-exclusively acquires the lock if it is immediately available.
java.util.concurrent.locks.StampedLock#tryReadLock(long, TimeUnit)->long:::Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted
java.util.concurrent.locks.StampedLock#readLockInterruptibly()->long:::Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted
java.util.concurrent.locks.StampedLock#tryOptimisticRead()->long:::Returns a stamp that can later be validated, or zero if exclusively locked.
java.util.concurrent.locks.StampedLock#validate(long)->boolean:::Returns true if the lock has not been exclusively acquired since issuance of the given stamp
java.util.concurrent.locks.StampedLock#unlockWrite(long)->void:::If the lock state matches the given stamp, releases the exclusive lock.
java.util.concurrent.locks.StampedLock#unlockRead(long)->void:::If the lock state matches the given stamp, releases the non-exclusive lock.
java.util.concurrent.locks.StampedLock#unlock(long)->void:::If the lock state matches the given stamp, releases the corresponding mode of the lock.
java.util.concurrent.locks.StampedLock#tryConvertToWriteLock(long)->long:::If the lock state matches the given stamp, atomically performs one of the following actions
java.util.concurrent.locks.StampedLock#tryConvertToReadLock(long)->long:::If the lock state matches the given stamp, atomically performs one of the following actions
java.util.concurrent.locks.StampedLock#tryConvertToOptimisticRead(long)->long:::If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp
java.util.concurrent.locks.StampedLock#tryUnlockWrite()->boolean:::Releases the write lock if it is held, without requiring a stamp value
java.util.concurrent.locks.StampedLock#tryUnlockRead()->boolean:::Releases one hold of the read lock if it is held, without requiring a stamp value
java.util.concurrent.locks.StampedLock#isWriteLocked()->boolean:::Returns true if the lock is currently held exclusively.
java.util.concurrent.locks.StampedLock#isReadLocked()->boolean:::Returns true if the lock is currently held non-exclusively.
java.util.concurrent.locks.StampedLock#isWriteLockStamp(long)->boolean:::Tells whether a stamp represents holding a lock exclusively
java.util.concurrent.locks.StampedLock#isReadLockStamp(long)->boolean:::Tells whether a stamp represents holding a lock non-exclusively
java.util.concurrent.locks.StampedLock#isLockStamp(long)->boolean:::Tells whether a stamp represents holding a lock
java.util.concurrent.locks.StampedLock#isOptimisticReadStamp(long)->boolean:::Tells whether a stamp represents a successful optimistic read.
java.util.concurrent.locks.StampedLock#getReadLockCount()->int:::Queries the number of read locks held for this lock
java.util.concurrent.locks.StampedLock#toString()->String:::Returns a string identifying this lock, as well as its lock state
java.util.concurrent.locks.StampedLock#asReadLock()->Lock:::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #readLock, and similarly for other methods
java.util.concurrent.locks.StampedLock#asWriteLock()->Lock:::Returns a plain Lock view of this StampedLock in which the Lock#lock method is mapped to #writeLock, and similarly for other methods
java.util.concurrent.locks.StampedLock#asReadWriteLock()->ReadWriteLock:::Returns a ReadWriteLock view of this StampedLock in which the ReadWriteLock#readLock() method is mapped to #asReadLock(), and ReadWriteLock#writeLock() to #asWriteLock().
java.util.concurrent.locks.StampedLock.ReadLockView#lock()->void::: read lock view lock
java.util.concurrent.locks.StampedLock.ReadLockView#lockInterruptibly()->void::: read lock view lock interruptibly
java.util.concurrent.locks.StampedLock.ReadLockView#tryLock()->boolean::: read lock view try lock
java.util.concurrent.locks.StampedLock.ReadLockView#tryLock(long, TimeUnit)->boolean::: read lock view try lock
java.util.concurrent.locks.StampedLock.ReadLockView#unlock()->void::: read lock view unlock
java.util.concurrent.locks.StampedLock.ReadLockView#newCondition()->Condition::: read lock view new condition
java.util.concurrent.locks.StampedLock.WriteLockView#lock()->void::: write lock view lock
java.util.concurrent.locks.StampedLock.WriteLockView#lockInterruptibly()->void::: write lock view lock interruptibly
java.util.concurrent.locks.StampedLock.WriteLockView#tryLock()->boolean::: write lock view try lock
java.util.concurrent.locks.StampedLock.WriteLockView#tryLock(long, TimeUnit)->boolean::: write lock view try lock
java.util.concurrent.locks.StampedLock.WriteLockView#unlock()->void::: write lock view unlock
java.util.concurrent.locks.StampedLock.WriteLockView#newCondition()->Condition::: write lock view new condition
java.util.concurrent.locks.StampedLock.ReadWriteLockView#readLock()->Lock::: read write lock view read lock
java.util.concurrent.locks.StampedLock.ReadWriteLockView#writeLock()->Lock::: read write lock view write lock
java.util.concurrent.locks.StampedLock#unstampedUnlockWrite()->void::: stamped lock unstamped unlock write
java.util.concurrent.locks.StampedLock#unstampedUnlockRead()->void::: stamped lock unstamped unlock read
