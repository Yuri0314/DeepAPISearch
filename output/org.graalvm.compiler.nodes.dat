org.graalvm.compiler.nodes.Plugin_BreakpointNode_breakpoint#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ breakpoint node_breakpoint execute
org.graalvm.compiler.nodes.Plugin_BreakpointNode_breakpoint#getSource()->Class::: plugin_ breakpoint node_breakpoint get source
org.graalvm.compiler.nodes.PluginFactory_BreakpointNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ breakpoint node register plugins
org.graalvm.compiler.nodes.Plugin_ComputeObjectAddressNode_get#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ compute object address node_get execute
org.graalvm.compiler.nodes.Plugin_ComputeObjectAddressNode_get#getSource()->Class::: plugin_ compute object address node_get get source
org.graalvm.compiler.nodes.PluginFactory_ComputeObjectAddressNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ compute object address node register plugins
org.graalvm.compiler.nodes.Plugin_ConstantNode_forClass#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ constant node_for class execute
org.graalvm.compiler.nodes.Plugin_ConstantNode_forClass#getSource()->Class::: plugin_ constant node_for class get source
org.graalvm.compiler.nodes.PluginFactory_ConstantNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ constant node register plugins
org.graalvm.compiler.nodes.Plugin_DeoptimizeNode_deopt#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ deoptimize node_deopt execute
org.graalvm.compiler.nodes.Plugin_DeoptimizeNode_deopt#getSource()->Class::: plugin_ deoptimize node_deopt get source
org.graalvm.compiler.nodes.PluginFactory_DeoptimizeNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ deoptimize node register plugins
org.graalvm.compiler.nodes.Plugin_GetObjectAddressNode_get#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ get object address node_get execute
org.graalvm.compiler.nodes.Plugin_GetObjectAddressNode_get#getSource()->Class::: plugin_ get object address node_get get source
org.graalvm.compiler.nodes.PluginFactory_GetObjectAddressNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ get object address node register plugins
org.graalvm.compiler.nodes.Plugin_PauseNode_pause#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pause node_pause execute
org.graalvm.compiler.nodes.Plugin_PauseNode_pause#getSource()->Class::: plugin_ pause node_pause get source
org.graalvm.compiler.nodes.PluginFactory_PauseNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ pause node register plugins
org.graalvm.compiler.nodes.Plugin_PiArrayNode_piArrayCastToSnippetReplaceeStamp#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi array node_pi array cast to snippet replacee stamp execute
org.graalvm.compiler.nodes.Plugin_PiArrayNode_piArrayCastToSnippetReplaceeStamp#getSource()->Class::: plugin_ pi array node_pi array cast to snippet replacee stamp get source
org.graalvm.compiler.nodes.PluginFactory_PiArrayNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ pi array node register plugins
org.graalvm.compiler.nodes.Plugin_PiNode_asNonNullClassIntrinsic#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi node_as non null class intrinsic execute
org.graalvm.compiler.nodes.Plugin_PiNode_asNonNullClassIntrinsic#getSource()->Class::: plugin_ pi node_as non null class intrinsic get source
org.graalvm.compiler.nodes.Plugin_PiNode_piCast#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi node_pi cast execute
org.graalvm.compiler.nodes.Plugin_PiNode_piCast#getSource()->Class::: plugin_ pi node_pi cast get source
org.graalvm.compiler.nodes.Plugin_PiNode_piCastNonNull#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi node_pi cast non null execute
org.graalvm.compiler.nodes.Plugin_PiNode_piCastNonNull#getSource()->Class::: plugin_ pi node_pi cast non null get source
org.graalvm.compiler.nodes.Plugin_PiNode_piCastNonNullClass#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi node_pi cast non null class execute
org.graalvm.compiler.nodes.Plugin_PiNode_piCastNonNullClass#getSource()->Class::: plugin_ pi node_pi cast non null class get source
org.graalvm.compiler.nodes.Plugin_PiNode_piCastToSnippetReplaceeStamp#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ pi node_pi cast to snippet replacee stamp execute
org.graalvm.compiler.nodes.Plugin_PiNode_piCastToSnippetReplaceeStamp#getSource()->Class::: plugin_ pi node_pi cast to snippet replacee stamp get source
org.graalvm.compiler.nodes.PluginFactory_PiNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ pi node register plugins
org.graalvm.compiler.nodes.Plugin_PrefetchAllocateNode_prefetch#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ prefetch allocate node_prefetch execute
org.graalvm.compiler.nodes.Plugin_PrefetchAllocateNode_prefetch#getSource()->Class::: plugin_ prefetch allocate node_prefetch get source
org.graalvm.compiler.nodes.PluginFactory_PrefetchAllocateNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ prefetch allocate node register plugins
org.graalvm.compiler.nodes.Plugin_SnippetAnchorNode_anchor#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])->boolean::: plugin_ snippet anchor node_anchor execute
org.graalvm.compiler.nodes.Plugin_SnippetAnchorNode_anchor#getSource()->Class::: plugin_ snippet anchor node_anchor get source
org.graalvm.compiler.nodes.PluginFactory_SnippetAnchorNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)->void::: plugin factory_ snippet anchor node register plugins
org.graalvm.compiler.nodes.AbstractBeginNode#prevBegin(FixedNode)->AbstractBeginNode::: abstract begin node prev begin
org.graalvm.compiler.nodes.AbstractBeginNode#prepareDelete()->void::: abstract begin node prepare delete
org.graalvm.compiler.nodes.AbstractBeginNode#prepareDelete(FixedNode)->void::: abstract begin node prepare delete
org.graalvm.compiler.nodes.AbstractBeginNode#verify()->boolean::: abstract begin node verify
org.graalvm.compiler.nodes.AbstractBeginNode#generate(NodeLIRBuilderTool)->void::: abstract begin node generate
org.graalvm.compiler.nodes.AbstractBeginNode#guards()->NodeIterable::: abstract begin node guards
org.graalvm.compiler.nodes.AbstractBeginNode#anchored()->NodeIterable::: abstract begin node anchored
org.graalvm.compiler.nodes.AbstractBeginNode#getBlockNodes()->NodeIterable::: abstract begin node get block nodes
org.graalvm.compiler.nodes.AbstractBeginNode#setWithSpeculationFence()->void:::Set this begin node to be a speculation fence
org.graalvm.compiler.nodes.AbstractDeoptimizeNode#canDeoptimize()->boolean::: abstract deoptimize node can deoptimize
org.graalvm.compiler.nodes.AbstractDeoptimizeNode#stateBefore()->FrameState::: abstract deoptimize node state before
org.graalvm.compiler.nodes.AbstractDeoptimizeNode#setStateBefore(FrameState)->void::: abstract deoptimize node set state before
org.graalvm.compiler.nodes.AbstractDeoptimizeNode#getActionAndReason(MetaAccessProvider)->ValueNode::: abstract deoptimize node get action and reason
org.graalvm.compiler.nodes.AbstractDeoptimizeNode#getSpeculation(MetaAccessProvider)->ValueNode::: abstract deoptimize node get speculation
org.graalvm.compiler.nodes.AbstractEndNode#generate(NodeLIRBuilderTool)->void::: abstract end node generate
org.graalvm.compiler.nodes.AbstractEndNode#merge()->AbstractMergeNode::: abstract end node merge
org.graalvm.compiler.nodes.AbstractEndNode#verify()->boolean::: abstract end node verify
org.graalvm.compiler.nodes.AbstractEndNode#cfgSuccessors()->Iterable::: abstract end node cfg successors
org.graalvm.compiler.nodes.AbstractFixedGuardNode#getCondition()->LogicNode::: abstract fixed guard node get condition
org.graalvm.compiler.nodes.AbstractFixedGuardNode#condition()->LogicNode::: abstract fixed guard node condition
org.graalvm.compiler.nodes.AbstractFixedGuardNode#setCondition(LogicNode, boolean)->void::: abstract fixed guard node set condition
org.graalvm.compiler.nodes.AbstractFixedGuardNode#getReason()->DeoptimizationReason::: abstract fixed guard node get reason
org.graalvm.compiler.nodes.AbstractFixedGuardNode#getAction()->DeoptimizationAction::: abstract fixed guard node get action
org.graalvm.compiler.nodes.AbstractFixedGuardNode#getSpeculation()->Speculation::: abstract fixed guard node get speculation
org.graalvm.compiler.nodes.AbstractFixedGuardNode#isNegated()->boolean::: abstract fixed guard node is negated
org.graalvm.compiler.nodes.AbstractFixedGuardNode#toString(Verbosity)->String::: abstract fixed guard node to string
org.graalvm.compiler.nodes.AbstractFixedGuardNode#simplify(SimplifierTool)->void::: abstract fixed guard node simplify
org.graalvm.compiler.nodes.AbstractFixedGuardNode#lowerToIf()->DeoptimizeNode::: abstract fixed guard node lower to if
org.graalvm.compiler.nodes.AbstractFixedGuardNode#canDeoptimize()->boolean::: abstract fixed guard node can deoptimize
org.graalvm.compiler.nodes.AbstractFixedGuardNode#setAction(DeoptimizationAction)->void::: abstract fixed guard node set action
org.graalvm.compiler.nodes.AbstractFixedGuardNode#setReason(DeoptimizationReason)->void::: abstract fixed guard node set reason
org.graalvm.compiler.nodes.AbstractFixedGuardNode#getNoDeoptSuccessorPosition()->NodeSourcePosition::: abstract fixed guard node get no deopt successor position
org.graalvm.compiler.nodes.AbstractFixedGuardNode#setNoDeoptSuccessorPosition(NodeSourcePosition)->void::: abstract fixed guard node set no deopt successor position
org.graalvm.compiler.nodes.AbstractLocalNode#index()->int:::Gets the index of this local in the array of parameters
org.graalvm.compiler.nodes.AbstractLocalNode#toString(Verbosity)->String::: abstract local node to string
org.graalvm.compiler.nodes.AbstractMergeNode#generate(NodeLIRBuilderTool)->void::: abstract merge node generate
org.graalvm.compiler.nodes.AbstractMergeNode#forwardEndIndex(EndNode)->int::: abstract merge node forward end index
org.graalvm.compiler.nodes.AbstractMergeNode#addForwardEnd(EndNode)->void::: abstract merge node add forward end
org.graalvm.compiler.nodes.AbstractMergeNode#forwardEndCount()->int::: abstract merge node forward end count
org.graalvm.compiler.nodes.AbstractMergeNode#forwardEndAt(int)->EndNode::: abstract merge node forward end at
org.graalvm.compiler.nodes.AbstractMergeNode#cfgPredecessors()->NodeIterable::: abstract merge node cfg predecessors
org.graalvm.compiler.nodes.AbstractMergeNode#isPhiAtMerge(Node)->boolean:::Determines if a given node is a phi whose PhiNode#merge() merge is this node.
org.graalvm.compiler.nodes.AbstractMergeNode#removeEnd(AbstractEndNode)->void:::Removes the given end from the merge, along with the entries corresponding to this end in the phis connected to the merge.
org.graalvm.compiler.nodes.AbstractMergeNode#deleteEnd(AbstractEndNode)->void::: abstract merge node delete end
org.graalvm.compiler.nodes.AbstractMergeNode#clearEnds()->void::: abstract merge node clear ends
org.graalvm.compiler.nodes.AbstractMergeNode#forwardEnds()->NodeInputList::: abstract merge node forward ends
org.graalvm.compiler.nodes.AbstractMergeNode#phiPredecessorCount()->int::: abstract merge node phi predecessor count
org.graalvm.compiler.nodes.AbstractMergeNode#phiPredecessorIndex(AbstractEndNode)->int::: abstract merge node phi predecessor index
org.graalvm.compiler.nodes.AbstractMergeNode#phiPredecessorAt(int)->AbstractEndNode::: abstract merge node phi predecessor at
org.graalvm.compiler.nodes.AbstractMergeNode#phis()->NodeIterable::: abstract merge node phis
org.graalvm.compiler.nodes.AbstractMergeNode#valuePhis()->NodeIterable::: abstract merge node value phis
org.graalvm.compiler.nodes.AbstractMergeNode#memoryPhis()->NodeIterable::: abstract merge node memory phis
org.graalvm.compiler.nodes.AbstractMergeNode#anchored()->NodeIterable::: abstract merge node anchored
org.graalvm.compiler.nodes.AbstractMergeNode#simplify(SimplifierTool)->void:::This simplify method can deal with a null value for tool, so that it can be used outside of canonicalization.
org.graalvm.compiler.nodes.AbstractStateSplit#stateAfter()->FrameState::: abstract state split state after
org.graalvm.compiler.nodes.AbstractStateSplit#setStateAfter(FrameState)->void::: abstract state split set state after
org.graalvm.compiler.nodes.AbstractStateSplit#hasSideEffect()->boolean::: abstract state split has side effect
org.graalvm.compiler.nodes.ArithmeticOperation#getArithmeticOp()->Op::: arithmetic operation get arithmetic op
org.graalvm.compiler.nodes.BeginNode#trySimplify()->void::: begin node try simplify
org.graalvm.compiler.nodes.BeginNode#simplify(SimplifierTool)->void::: begin node simplify
org.graalvm.compiler.nodes.BeginNode#begin(FixedNode)->AbstractBeginNode::: begin node begin
org.graalvm.compiler.nodes.BeginStateSplitNode#stateAfter()->FrameState::: begin state split node state after
org.graalvm.compiler.nodes.BeginStateSplitNode#setStateAfter(FrameState)->void::: begin state split node set state after
org.graalvm.compiler.nodes.BeginStateSplitNode#hasSideEffect()->boolean:::A begin node has no side effect.
org.graalvm.compiler.nodes.BinaryOpLogicNode#getX()->ValueNode::: binary op logic node get x
org.graalvm.compiler.nodes.BinaryOpLogicNode#getY()->ValueNode::: binary op logic node get y
org.graalvm.compiler.nodes.BinaryOpLogicNode#verify()->boolean::: binary op logic node verify
org.graalvm.compiler.nodes.BinaryOpLogicNode#generate(NodeLIRBuilderTool)->void::: binary op logic node generate
org.graalvm.compiler.nodes.BinaryOpLogicNode#maybeCommuteInputs()->LogicNode:::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results
org.graalvm.compiler.nodes.BinaryOpLogicNode#getSucceedingStampForX(boolean, Stamp, Stamp)->Stamp::: binary op logic node get succeeding stamp for x
org.graalvm.compiler.nodes.BinaryOpLogicNode#getSucceedingStampForY(boolean, Stamp, Stamp)->Stamp::: binary op logic node get succeeding stamp for y
org.graalvm.compiler.nodes.BinaryOpLogicNode#tryFold(Stamp, Stamp)->TriState::: binary op logic node try fold
org.graalvm.compiler.nodes.BreakpointNode#generate(NodeLIRBuilderTool)->void::: breakpoint node generate
org.graalvm.compiler.nodes.BreakpointNode#arguments()->NodeInputList::: breakpoint node arguments
org.graalvm.compiler.nodes.BreakpointNode#breakpoint()->void::: breakpoint node breakpoint
org.graalvm.compiler.nodes.CallTargetNode#arguments()->NodeInputList::: call target node arguments
org.graalvm.compiler.nodes.CallTargetNode#createReturnStamp(Assumptions, JavaType)->Stamp::: call target node create return stamp
org.graalvm.compiler.nodes.CallTargetNode#returnStamp()->StampPair::: call target node return stamp
org.graalvm.compiler.nodes.CallTargetNode#targetName()->String:::A human-readable representation of the target, used for debug printing only.
org.graalvm.compiler.nodes.CallTargetNode#generate(NodeLIRBuilderTool)->void::: call target node generate
org.graalvm.compiler.nodes.CallTargetNode#setTargetMethod(ResolvedJavaMethod)->void::: call target node set target method
org.graalvm.compiler.nodes.CallTargetNode#targetMethod()->ResolvedJavaMethod:::Gets the target method for this invocation instruction.
org.graalvm.compiler.nodes.CallTargetNode#invokeKind()->InvokeKind::: call target node invoke kind
org.graalvm.compiler.nodes.CallTargetNode#setInvokeKind(InvokeKind)->void::: call target node set invoke kind
org.graalvm.compiler.nodes.CallTargetNode#invoke()->Invoke::: call target node invoke
org.graalvm.compiler.nodes.Cancellable#isCancelled()->boolean:::Determines if this task has been cancelled.
org.graalvm.compiler.nodes.CanonicalizableLocation#canonicalizeRead(ValueNode, AddressNode, ValueNode, CanonicalizerTool)->ValueNode::: canonicalizable location canonicalize read
org.graalvm.compiler.nodes.CompressionNode#foldStamp(Stamp)->Stamp::: compression node fold stamp
org.graalvm.compiler.nodes.CompressionNode#compress(Constant)->Constant::: compression node compress
org.graalvm.compiler.nodes.CompressionNode#uncompress(Constant)->Constant::: compression node uncompress
org.graalvm.compiler.nodes.CompressionNode#nullConstant()->JavaConstant::: compression node null constant
org.graalvm.compiler.nodes.CompressionNode#convert(Constant, ConstantReflectionProvider)->Constant::: compression node convert
org.graalvm.compiler.nodes.CompressionNode#reverse(Constant, ConstantReflectionProvider)->Constant::: compression node reverse
org.graalvm.compiler.nodes.CompressionNode#isLossless()->boolean::: compression node is lossless
org.graalvm.compiler.nodes.CompressionNode#mkStamp(Stamp)->Stamp::: compression node mk stamp
org.graalvm.compiler.nodes.CompressionNode#getOp()->CompressionOp::: compression node get op
org.graalvm.compiler.nodes.CompressionNode#getEncoding()->CompressEncoding::: compression node get encoding
org.graalvm.compiler.nodes.CompressionNode#canonical(CanonicalizerTool, ValueNode)->ValueNode::: compression node canonical
org.graalvm.compiler.nodes.CompressionNode#generate(NodeLIRBuilderTool)->void::: compression node generate
org.graalvm.compiler.nodes.CompressionNode#mayNullCheckSkipConversion()->boolean::: compression node may null check skip conversion
org.graalvm.compiler.nodes.ComputeObjectAddressNode#get(Object, long)->long::: compute object address node get
org.graalvm.compiler.nodes.ComputeObjectAddressNode#lower(LoweringTool)->void::: compute object address node lower
org.graalvm.compiler.nodes.ComputeObjectAddressNode#getObject()->ValueNode::: compute object address node get object
org.graalvm.compiler.nodes.ComputeObjectAddressNode#getOffset()->ValueNode::: compute object address node get offset
org.graalvm.compiler.nodes.ConditionAnchorNode#condition()->LogicNode::: condition anchor node condition
org.graalvm.compiler.nodes.ConditionAnchorNode#isNegated()->boolean::: condition anchor node is negated
org.graalvm.compiler.nodes.ConditionAnchorNode#toString(Verbosity)->String::: condition anchor node to string
org.graalvm.compiler.nodes.ConditionAnchorNode#canonical(CanonicalizerTool, Node)->Node::: condition anchor node canonical
org.graalvm.compiler.nodes.ConditionAnchorNode#lower(LoweringTool)->void::: condition anchor node lower
org.graalvm.compiler.nodes.ConditionAnchorNode#getValue()->Node::: condition anchor node get value
org.graalvm.compiler.nodes.ConstantNode#getValue()->Constant::: constant node get value
org.graalvm.compiler.nodes.ConstantNode#getStableDimension()->int::: constant node get stable dimension
org.graalvm.compiler.nodes.ConstantNode#isDefaultStable()->boolean::: constant node is default stable
org.graalvm.compiler.nodes.ConstantNode#getConstantNodes(StructuredGraph)->NodeIterable:::Gathers all the ConstantNodes that are inputs to the StructuredGraph#getNodes() live nodes in a given graph.
org.graalvm.compiler.nodes.ConstantNode#replace(StructuredGraph, Node)->void:::Replaces this node at its usages with another node.
org.graalvm.compiler.nodes.ConstantNode#generate(NodeLIRBuilderTool)->void::: constant node generate
org.graalvm.compiler.nodes.ConstantNode#forConstant(JavaConstant, MetaAccessProvider, StructuredGraph)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forConstant(JavaConstant, int, boolean, MetaAccessProvider)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forConstant(JavaConstant, MetaAccessProvider)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forConstant(Stamp, Constant, MetaAccessProvider, StructuredGraph)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forConstant(Stamp, Constant, int, boolean, MetaAccessProvider)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forConstant(Stamp, Constant, MetaAccessProvider)->ConstantNode::: constant node for constant
org.graalvm.compiler.nodes.ConstantNode#forPrimitive(JavaConstant, StructuredGraph)->ConstantNode:::Returns a node for a Java primitive.
org.graalvm.compiler.nodes.ConstantNode#forPrimitive(JavaConstant)->ConstantNode:::Returns a node for a Java primitive.
org.graalvm.compiler.nodes.ConstantNode#forPrimitive(Stamp, JavaConstant, StructuredGraph)->ConstantNode:::Returns a node for a primitive of a given type.
org.graalvm.compiler.nodes.ConstantNode#forPrimitive(Stamp, Constant)->ConstantNode:::Returns a node for a primitive of a given type.
org.graalvm.compiler.nodes.ConstantNode#forDouble(double, StructuredGraph)->ConstantNode:::Returns a node for a double constant.
org.graalvm.compiler.nodes.ConstantNode#forDouble(double)->ConstantNode:::Returns a node for a double constant.
org.graalvm.compiler.nodes.ConstantNode#forFloat(float, StructuredGraph)->ConstantNode:::Returns a node for a float constant.
org.graalvm.compiler.nodes.ConstantNode#forFloat(float)->ConstantNode:::Returns a node for a float constant.
org.graalvm.compiler.nodes.ConstantNode#forLong(long, StructuredGraph)->ConstantNode:::Returns a node for an long constant.
org.graalvm.compiler.nodes.ConstantNode#forLong(long)->ConstantNode:::Returns a node for an long constant.
org.graalvm.compiler.nodes.ConstantNode#forInt(int, StructuredGraph)->ConstantNode:::Returns a node for an integer constant.
org.graalvm.compiler.nodes.ConstantNode#forInt(int)->ConstantNode:::Returns a node for an integer constant.
org.graalvm.compiler.nodes.ConstantNode#forBoolean(boolean, StructuredGraph)->ConstantNode:::Returns a node for a boolean constant.
org.graalvm.compiler.nodes.ConstantNode#forBoolean(boolean)->ConstantNode:::Returns a node for a boolean constant.
org.graalvm.compiler.nodes.ConstantNode#forByte(byte, StructuredGraph)->ConstantNode:::Returns a node for a byte constant.
org.graalvm.compiler.nodes.ConstantNode#forChar(char, StructuredGraph)->ConstantNode:::Returns a node for a char constant.
org.graalvm.compiler.nodes.ConstantNode#forShort(short, StructuredGraph)->ConstantNode:::Returns a node for a short constant.
org.graalvm.compiler.nodes.ConstantNode#forIntegerBits(int, long, StructuredGraph)->ConstantNode:::Returns a node for a constant integer that's not directly representable as Java primitive (e.g
org.graalvm.compiler.nodes.ConstantNode#forIntegerBits(int, long)->ConstantNode:::Returns a node for a constant integer that's not directly representable as Java primitive (e.g
org.graalvm.compiler.nodes.ConstantNode#forIntegerStamp(Stamp, long, StructuredGraph)->ConstantNode:::Returns a node for a constant integer that's compatible to a given stamp.
org.graalvm.compiler.nodes.ConstantNode#forIntegerStamp(Stamp, long)->ConstantNode:::Returns a node for a constant integer that's compatible to a given stamp.
org.graalvm.compiler.nodes.ConstantNode#forIntegerKind(JavaKind, long, StructuredGraph)->ConstantNode::: constant node for integer kind
org.graalvm.compiler.nodes.ConstantNode#forIntegerKind(JavaKind, long)->ConstantNode::: constant node for integer kind
org.graalvm.compiler.nodes.ConstantNode#forFloatingKind(JavaKind, double, StructuredGraph)->ConstantNode::: constant node for floating kind
org.graalvm.compiler.nodes.ConstantNode#forFloatingKind(JavaKind, double)->ConstantNode::: constant node for floating kind
org.graalvm.compiler.nodes.ConstantNode#forFloatingStamp(Stamp, double, StructuredGraph)->ConstantNode:::Returns a node for a constant double that's compatible to a given stamp.
org.graalvm.compiler.nodes.ConstantNode#forFloatingStamp(Stamp, double)->ConstantNode:::Returns a node for a constant double that's compatible to a given stamp.
org.graalvm.compiler.nodes.ConstantNode#defaultForKind(JavaKind, StructuredGraph)->ConstantNode::: constant node default for kind
org.graalvm.compiler.nodes.ConstantNode#defaultForKind(JavaKind)->ConstantNode::: constant node default for kind
org.graalvm.compiler.nodes.ConstantNode#getDebugProperties(Map)->Map::: constant node get debug properties
org.graalvm.compiler.nodes.ConstantNode#toString(Verbosity)->String::: constant node to string
org.graalvm.compiler.nodes.ConstantNode#findLength(FindLengthMode, ConstantReflectionProvider)->ValueNode::: constant node find length
org.graalvm.compiler.nodes.ConstantNode#forClass(ResolvedJavaType)->Class::: constant node for class
org.graalvm.compiler.nodes.ControlSplitNode#probability(AbstractBeginNode)->double::: control split node probability
org.graalvm.compiler.nodes.ControlSplitNode#setProbability(AbstractBeginNode, double)->boolean:::Attempts to set the probability for the given successor to the passed value (which has to be in the range of 0.0 and 1.0)
org.graalvm.compiler.nodes.ControlSplitNode#getPrimarySuccessor()->AbstractBeginNode:::Primary successor of the control split
org.graalvm.compiler.nodes.ControlSplitNode#getSuccessorCount()->int:::Returns the number of successors.
org.graalvm.compiler.nodes.DeoptimizeNode#getAction()->DeoptimizationAction::: deoptimize node get action
org.graalvm.compiler.nodes.DeoptimizeNode#setAction(DeoptimizationAction)->void::: deoptimize node set action
org.graalvm.compiler.nodes.DeoptimizeNode#getReason()->DeoptimizationReason::: deoptimize node get reason
org.graalvm.compiler.nodes.DeoptimizeNode#setReason(DeoptimizationReason)->void::: deoptimize node set reason
org.graalvm.compiler.nodes.DeoptimizeNode#lower(LoweringTool)->void::: deoptimize node lower
org.graalvm.compiler.nodes.DeoptimizeNode#getDebugId()->int::: deoptimize node get debug id
org.graalvm.compiler.nodes.DeoptimizeNode#setDebugId(int)->void::: deoptimize node set debug id
org.graalvm.compiler.nodes.DeoptimizeNode#generate(NodeLIRBuilderTool)->void::: deoptimize node generate
org.graalvm.compiler.nodes.DeoptimizeNode#getActionAndReason(MetaAccessProvider)->ValueNode::: deoptimize node get action and reason
org.graalvm.compiler.nodes.DeoptimizeNode#getSpeculation(MetaAccessProvider)->ValueNode::: deoptimize node get speculation
org.graalvm.compiler.nodes.DeoptimizeNode#getSpeculation()->Speculation::: deoptimize node get speculation
org.graalvm.compiler.nodes.DeoptimizeNode#deopt(DeoptimizationAction, DeoptimizationReason)->void::: deoptimize node deopt
org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode#stateBefore()->FrameState::: deoptimizing fixed with next node state before
org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode#setStateBefore(FrameState)->void::: deoptimizing fixed with next node set state before
org.graalvm.compiler.nodes.DeoptimizingGuard#getCondition()->LogicNode::: deoptimizing guard get condition
org.graalvm.compiler.nodes.DeoptimizingGuard#setCondition(LogicNode, boolean)->void::: deoptimizing guard set condition
org.graalvm.compiler.nodes.DeoptimizingGuard#isNegated()->boolean::: deoptimizing guard is negated
org.graalvm.compiler.nodes.DeoptimizingGuard#getNoDeoptSuccessorPosition()->NodeSourcePosition::: deoptimizing guard get no deopt successor position
org.graalvm.compiler.nodes.DeoptimizingGuard#setNoDeoptSuccessorPosition(NodeSourcePosition)->void::: deoptimizing guard set no deopt successor position
org.graalvm.compiler.nodes.DeoptimizingGuard#addCallerToNoDeoptSuccessorPosition(NodeSourcePosition)->void::: deoptimizing guard add caller to no deopt successor position
org.graalvm.compiler.nodes.DeoptimizingNode#canDeoptimize()->boolean:::Determines if this node needs deoptimization information.
org.graalvm.compiler.nodes.DeoptimizingNode.DeoptBefore#setStateBefore(FrameState)->void:::Sets the FrameState describing the program state before the execution of this node.
org.graalvm.compiler.nodes.DeoptimizingNode.DeoptBefore#stateBefore()->FrameState::: deopt before state before
org.graalvm.compiler.nodes.DeoptimizingNode.DeoptDuring#stateDuring()->FrameState::: deopt during state during
org.graalvm.compiler.nodes.DeoptimizingNode.DeoptDuring#setStateDuring(FrameState)->void:::Sets the FrameState describing the program state during the execution of this node.
org.graalvm.compiler.nodes.DeoptimizingNode.DeoptDuring#computeStateDuring(FrameState)->void:::Compute the FrameState describing the program state during the execution of this node from an input FrameState describing the program state after finishing the execution of this node.
org.graalvm.compiler.nodes.DirectCallTargetNode#targetName()->String::: direct call target node target name
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#getActionAndReason()->ValueNode::: dynamic deoptimize node get action and reason
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#getSpeculation()->ValueNode::: dynamic deoptimize node get speculation
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#getActionAndReason(MetaAccessProvider)->ValueNode::: dynamic deoptimize node get action and reason
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#getSpeculation(MetaAccessProvider)->ValueNode::: dynamic deoptimize node get speculation
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#lower(LoweringTool)->void::: dynamic deoptimize node lower
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#generate(NodeLIRBuilderTool)->void::: dynamic deoptimize node generate
org.graalvm.compiler.nodes.DynamicDeoptimizeNode#canonical(CanonicalizerTool)->Node::: dynamic deoptimize node canonical
org.graalvm.compiler.nodes.DynamicPiNode#create(Assumptions, ConstantReflectionProvider, ValueNode, GuardingNode, ValueNode, boolean)->ValueNode::: dynamic pi node create
org.graalvm.compiler.nodes.DynamicPiNode#create(Assumptions, ConstantReflectionProvider, ValueNode, GuardingNode, ValueNode)->ValueNode::: dynamic pi node create
org.graalvm.compiler.nodes.DynamicPiNode#isExact()->boolean::: dynamic pi node is exact
org.graalvm.compiler.nodes.DynamicPiNode#canonical(CanonicalizerTool)->Node::: dynamic pi node canonical
org.graalvm.compiler.nodes.EncodedGraph#getEncoding()->byte[]::: encoded graph get encoding
org.graalvm.compiler.nodes.EncodedGraph#getStartOffset()->int::: encoded graph get start offset
org.graalvm.compiler.nodes.EncodedGraph#getObjects()->Object[]::: encoded graph get objects
org.graalvm.compiler.nodes.EncodedGraph#getNumObjects()->int::: encoded graph get num objects
org.graalvm.compiler.nodes.EncodedGraph#getObject(int)->Object::: encoded graph get object
org.graalvm.compiler.nodes.EncodedGraph#getNodeClasses()->NodeClass[]::: encoded graph get node classes
org.graalvm.compiler.nodes.EncodedGraph#getAssumptions()->Assumptions::: encoded graph get assumptions
org.graalvm.compiler.nodes.EncodedGraph#getInlinedMethods()->List::: encoded graph get inlined methods
org.graalvm.compiler.nodes.EncodedGraph#trackNodeSourcePosition()->boolean::: encoded graph track node source position
org.graalvm.compiler.nodes.EncodedGraph#getFields()->EconomicSet::: encoded graph get fields
org.graalvm.compiler.nodes.EncodedGraph#hasUnsafeAccess()->boolean::: encoded graph has unsafe access
org.graalvm.compiler.nodes.EncodedGraph#isCallToOriginal(ResolvedJavaMethod)->boolean::: encoded graph is call to original
org.graalvm.compiler.nodes.EntryMarkerNode#generate(NodeLIRBuilderTool)->void::: entry marker node generate
org.graalvm.compiler.nodes.EntryMarkerNode#anchored()->NodeIterable::: entry marker node anchored
org.graalvm.compiler.nodes.EntryMarkerNode#prepareDelete(FixedNode)->void::: entry marker node prepare delete
org.graalvm.compiler.nodes.EntryProxyNode#value()->ValueNode::: entry proxy node value
org.graalvm.compiler.nodes.EntryProxyNode#getOriginalNode()->ValueNode::: entry proxy node get original node
org.graalvm.compiler.nodes.EntryProxyNode#getGuard()->GuardingNode::: entry proxy node get guard
org.graalvm.compiler.nodes.FieldLocationIdentity#isImmutable()->boolean::: field location identity is immutable
org.graalvm.compiler.nodes.FieldLocationIdentity#equals(Object)->boolean::: field location identity equals
org.graalvm.compiler.nodes.FieldLocationIdentity#getField()->ResolvedJavaField::: field location identity get field
org.graalvm.compiler.nodes.FieldLocationIdentity#hashCode()->int::: field location identity hash code
org.graalvm.compiler.nodes.FieldLocationIdentity#toString()->String::: field location identity to string
org.graalvm.compiler.nodes.FixedGuardNode#simplify(SimplifierTool)->void::: fixed guard node simplify
org.graalvm.compiler.nodes.FixedGuardNode#lower(LoweringTool)->void::: fixed guard node lower
org.graalvm.compiler.nodes.FixedGuardNode#canDeoptimize()->boolean::: fixed guard node can deoptimize
org.graalvm.compiler.nodes.FixedGuardNode#getNextSwitchFoldableBranch()->Node::: fixed guard node get next switch foldable branch
org.graalvm.compiler.nodes.FixedGuardNode#isInSwitch(ValueNode)->boolean::: fixed guard node is in switch
org.graalvm.compiler.nodes.FixedGuardNode#cutOffCascadeNode()->void::: fixed guard node cut off cascade node
org.graalvm.compiler.nodes.FixedGuardNode#cutOffLowestCascadeNode()->void::: fixed guard node cut off lowest cascade node
org.graalvm.compiler.nodes.FixedGuardNode#isDefaultSuccessor(AbstractBeginNode)->boolean::: fixed guard node is default successor
org.graalvm.compiler.nodes.FixedGuardNode#getDefault()->AbstractBeginNode::: fixed guard node get default
org.graalvm.compiler.nodes.FixedGuardNode#switchValue()->ValueNode::: fixed guard node switch value
org.graalvm.compiler.nodes.FixedGuardNode#isNonInitializedProfile()->boolean::: fixed guard node is non initialized profile
org.graalvm.compiler.nodes.FixedGuardNode#intKeyAt(int)->int::: fixed guard node int key at
org.graalvm.compiler.nodes.FixedGuardNode#keyProbability(int)->double::: fixed guard node key probability
org.graalvm.compiler.nodes.FixedGuardNode#keySuccessor(int)->AbstractBeginNode::: fixed guard node key successor
org.graalvm.compiler.nodes.FixedGuardNode#defaultProbability()->double::: fixed guard node default probability
org.graalvm.compiler.nodes.FixedNode#verify()->boolean::: fixed node verify
org.graalvm.compiler.nodes.FixedNode#asNode()->FixedNode::: fixed node as node
org.graalvm.compiler.nodes.FixedNodeInterface#asNode()->FixedNode::: fixed node interface as node
org.graalvm.compiler.nodes.FixedWithNextNode#next()->FixedNode::: fixed with next node next
org.graalvm.compiler.nodes.FixedWithNextNode#setNext(FixedNode)->void::: fixed with next node set next
org.graalvm.compiler.nodes.FixedWithNextNode#asNode()->FixedWithNextNode::: fixed with next node as node
org.graalvm.compiler.nodes.FloatingAnchoredNode#getAnchor()->AnchoringNode::: floating anchored node get anchor
org.graalvm.compiler.nodes.FloatingAnchoredNode#setAnchor(AnchoringNode)->void::: floating anchored node set anchor
org.graalvm.compiler.nodes.FloatingGuardedNode#getGuard()->GuardingNode::: floating guarded node get guard
org.graalvm.compiler.nodes.FloatingGuardedNode#setGuard(GuardingNode)->void::: floating guarded node set guard
org.graalvm.compiler.nodes.FrameState#values()->NodeInputList::: frame state values
org.graalvm.compiler.nodes.FrameState#monitorIds()->NodeInputList::: frame state monitor ids
org.graalvm.compiler.nodes.FrameState#outerFrameState()->FrameState::: frame state outer frame state
org.graalvm.compiler.nodes.FrameState#setOuterFrameState(FrameState)->void::: frame state set outer frame state
org.graalvm.compiler.nodes.FrameState#toSourcePosition(FrameState)->NodeSourcePosition::: frame state to source position
org.graalvm.compiler.nodes.FrameState#rethrowException()->boolean::: frame state rethrow exception
org.graalvm.compiler.nodes.FrameState#duringCall()->boolean::: frame state during call
org.graalvm.compiler.nodes.FrameState#getCode()->Bytecode::: frame state get code
org.graalvm.compiler.nodes.FrameState#getMethod()->ResolvedJavaMethod::: frame state get method
org.graalvm.compiler.nodes.FrameState#canProduceBytecodeFrame()->boolean:::Determines if this frame state can be converted to a BytecodeFrame
org.graalvm.compiler.nodes.FrameState#addVirtualObjectMapping(EscapeObjectState)->void::: frame state add virtual object mapping
org.graalvm.compiler.nodes.FrameState#virtualObjectMappingCount()->int::: frame state virtual object mapping count
org.graalvm.compiler.nodes.FrameState#virtualObjectMappingAt(int)->EscapeObjectState::: frame state virtual object mapping at
org.graalvm.compiler.nodes.FrameState#virtualObjectMappings()->NodeInputList::: frame state virtual object mappings
org.graalvm.compiler.nodes.FrameState#duplicate(int)->FrameState:::Gets a copy of this frame state.
org.graalvm.compiler.nodes.FrameState#duplicate()->FrameState:::Gets a copy of this frame state.
org.graalvm.compiler.nodes.FrameState#duplicateWithVirtualState()->FrameState:::Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer FrameStates, VirtualObjectStates, ...).
org.graalvm.compiler.nodes.FrameState#duplicateModifiedDuringCall(int, JavaKind)->FrameState:::Creates a copy of this frame state with one stack element of type popKind popped from the stack.
org.graalvm.compiler.nodes.FrameState#duplicateModifiedBeforeCall(int, JavaKind, JavaKind[], ValueNode[])->FrameState::: frame state duplicate modified before call
org.graalvm.compiler.nodes.FrameState#duplicateModified(int, boolean, JavaKind, JavaKind[], ValueNode[])->FrameState:::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack
org.graalvm.compiler.nodes.FrameState#duplicateModified(int, boolean, boolean, JavaKind, JavaKind[], ValueNode[])->FrameState::: frame state duplicate modified
org.graalvm.compiler.nodes.FrameState#duplicateModified(JavaKind, JavaKind, ValueNode)->FrameState:::Creates a copy of this frame state with the top of stack replaced with with pushedValue which must be of type popKind.
org.graalvm.compiler.nodes.FrameState#duplicateModified(StructuredGraph, int, boolean, boolean, JavaKind, JavaKind[], ValueNode[])->FrameState:::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack
org.graalvm.compiler.nodes.FrameState#localsSize()->int:::Gets the size of the local variables.
org.graalvm.compiler.nodes.FrameState#stackSize()->int:::Gets the current size (height) of the stack.
org.graalvm.compiler.nodes.FrameState#locksSize()->int:::Gets the number of locked monitors in this frame state.
org.graalvm.compiler.nodes.FrameState#nestedLockDepth()->int:::Gets the number of locked monitors in this frame state and all #outerFrameState() outer frame states.
org.graalvm.compiler.nodes.FrameState#localAt(int)->ValueNode:::Gets the value in the local variables at the specified index.
org.graalvm.compiler.nodes.FrameState#stackAt(int)->ValueNode:::Get the value on the stack at the specified stack index.
org.graalvm.compiler.nodes.FrameState#lockAt(int)->ValueNode:::Get the monitor owner at the specified index.
org.graalvm.compiler.nodes.FrameState#monitorIdAt(int)->MonitorIdNode:::Get the MonitorIdNode that corresponds to the locked object at the specified index.
org.graalvm.compiler.nodes.FrameState#monitorIdCount()->int::: frame state monitor id count
org.graalvm.compiler.nodes.FrameState#innerFrameStates()->NodeIterable::: frame state inner frame states
org.graalvm.compiler.nodes.FrameState#toString(Verbosity)->String::: frame state to string
org.graalvm.compiler.nodes.FrameState#getDebugProperties(Map)->Map::: frame state get debug properties
org.graalvm.compiler.nodes.FrameState#verify()->boolean::: frame state verify
org.graalvm.compiler.nodes.FrameState#applyToNonVirtual(NodeClosure)->void::: frame state apply to non virtual
org.graalvm.compiler.nodes.FrameState#applyToVirtual(VirtualClosure)->void::: frame state apply to virtual
org.graalvm.compiler.nodes.FrameState#isPartOfThisState(VirtualState)->boolean::: frame state is part of this state
org.graalvm.compiler.nodes.FrameState#isExceptionHandlingBCI()->boolean::: frame state is exception handling i
org.graalvm.compiler.nodes.FullInfopointNode#getReason()->InfopointReason::: full infopoint node get reason
org.graalvm.compiler.nodes.FullInfopointNode#simplify(SimplifierTool)->void::: full infopoint node simplify
org.graalvm.compiler.nodes.FullInfopointNode#generate(NodeLIRBuilderTool)->void::: full infopoint node generate
org.graalvm.compiler.nodes.FullInfopointNode#getState()->FrameState::: full infopoint node get state
org.graalvm.compiler.nodes.FullInfopointNode#verify()->boolean::: full infopoint node verify
org.graalvm.compiler.nodes.GetObjectAddressNode#get(Object)->long::: get object address node get
org.graalvm.compiler.nodes.GetObjectAddressNode#generate(NodeLIRBuilderTool)->void::: get object address node generate
org.graalvm.compiler.nodes.GetObjectAddressNode#verify()->boolean::: get object address node verify
org.graalvm.compiler.nodes.GraphDecoder.MethodScope#isInlinedMethod()->boolean::: method scope is inlined method
org.graalvm.compiler.nodes.GraphDecoder.MethodScope#getCallerBytecodePosition()->NodeSourcePosition::: method scope get caller bytecode position
org.graalvm.compiler.nodes.GraphDecoder.MethodScope#getCallerBytecodePosition(NodeSourcePosition)->NodeSourcePosition::: method scope get caller bytecode position
org.graalvm.compiler.nodes.GraphDecoder.LoopScope#toString()->String::: loop scope to string
org.graalvm.compiler.nodes.GraphDecoder.LoopExplosionState#equals(Object)->boolean::: loop explosion state equals
org.graalvm.compiler.nodes.GraphDecoder.LoopExplosionState#hashCode()->int::: loop explosion state hash code
org.graalvm.compiler.nodes.GraphDecoder.ProxyPlaceholder#setValue(ValueNode)->void::: proxy placeholder set value
org.graalvm.compiler.nodes.GraphDecoder.ProxyPlaceholder#canonical(CanonicalizerTool)->Node::: proxy placeholder canonical
org.graalvm.compiler.nodes.GraphDecoder.ProxyPlaceholder#unwrap(ValueNode)->ValueNode::: proxy placeholder unwrap
org.graalvm.compiler.nodes.GraphDecoder#decode(EncodedGraph)->void::: graph decoder decode
org.graalvm.compiler.nodes.GraphDecoder#createInitialLoopScope(MethodScope, FixedWithNextNode)->LoopScope::: graph decoder create initial loop scope
org.graalvm.compiler.nodes.GraphDecoder#decode(LoopScope)->void::: graph decoder decode
org.graalvm.compiler.nodes.GraphDecoder#finishInlining(MethodScope)->void::: graph decoder finish inlining
org.graalvm.compiler.nodes.GraphDecoder#processNextNode(MethodScope, LoopScope)->LoopScope::: graph decoder process next node
org.graalvm.compiler.nodes.GraphDecoder#readInvokeData(MethodScope, int, Invoke)->InvokeData::: graph decoder read invoke data
org.graalvm.compiler.nodes.GraphDecoder#handleInvoke(MethodScope, LoopScope, InvokeData)->LoopScope:::Invoke nodes do not have the CallTargetNode, FrameState, and successors encoded
org.graalvm.compiler.nodes.GraphDecoder#appendInvoke(MethodScope, LoopScope, InvokeData, CallTargetNode)->void::: graph decoder append invoke
org.graalvm.compiler.nodes.GraphDecoder#handleMergeNode(MergeNode)->void:::Hook for subclasses to perform simplifications for a non-loop-header control flow merge.
org.graalvm.compiler.nodes.GraphDecoder#handleLoopExplosionBegin(MethodScope, LoopScope, LoopBeginNode)->void::: graph decoder handle loop explosion begin
org.graalvm.compiler.nodes.GraphDecoder#checkLoopExplosionIteration(MethodScope, LoopScope)->void:::Hook for subclasses.
org.graalvm.compiler.nodes.GraphDecoder#handleLoopExplosionEnd(MethodScope, LoopScope, LoopEndNode)->FixedNode::: graph decoder handle loop explosion end
org.graalvm.compiler.nodes.GraphDecoder#handleFixedNode(MethodScope, LoopScope, int, FixedNode)->void:::Hook for subclasses.
org.graalvm.compiler.nodes.GraphDecoder#handleProxyNodes(MethodScope, LoopScope, LoopExitNode)->void::: graph decoder handle proxy nodes
org.graalvm.compiler.nodes.GraphDecoder#handleLoopExplosionProxyNodes(MethodScope, LoopScope, LoopScope, LoopExitNode, int)->void::: graph decoder handle loop explosion proxy nodes
org.graalvm.compiler.nodes.GraphDecoder#handlePhiFunctions(MethodScope, LoopScope, LoopScope, AbstractEndNode, AbstractMergeNode)->void::: graph decoder handle phi functions
org.graalvm.compiler.nodes.GraphDecoder#allowLazyPhis()->boolean::: graph decoder allow lazy phis
org.graalvm.compiler.nodes.GraphDecoder#readProperties(MethodScope, Node)->void::: graph decoder read properties
org.graalvm.compiler.nodes.GraphDecoder#makeFixedNodeInputs(MethodScope, LoopScope, Node)->void:::Process the input edges of a node
org.graalvm.compiler.nodes.GraphDecoder#makeFloatingNodeInputs(MethodScope, LoopScope, Node)->void::: graph decoder make floating node inputs
org.graalvm.compiler.nodes.GraphDecoder#ensureNodeCreated(MethodScope, LoopScope, int)->Node::: graph decoder ensure node created
org.graalvm.compiler.nodes.GraphDecoder#addFloatingNode(MethodScope, Node)->Node::: graph decoder add floating node
org.graalvm.compiler.nodes.GraphDecoder#decodeFloatingNode(MethodScope, LoopScope, int)->Node:::Decodes a non-fixed node, but does not do any post-processing and does not register it.
org.graalvm.compiler.nodes.GraphDecoder#handleFloatingNodeBeforeAdd(MethodScope, LoopScope, Node)->Node:::Hook for subclasses to process a non-fixed node before it is added to the graph.
org.graalvm.compiler.nodes.GraphDecoder#handleFloatingNodeAfterAdd(MethodScope, LoopScope, Node)->Node:::Hook for subclasses to process a non-fixed node after it is added to the graph
org.graalvm.compiler.nodes.GraphDecoder#makeSuccessorStubs(MethodScope, LoopScope, Node, boolean)->void:::Process successor edges of a node
org.graalvm.compiler.nodes.GraphDecoder#makeStubNode(MethodScope, LoopScope, int)->FixedNode::: graph decoder make stub node
org.graalvm.compiler.nodes.GraphDecoder#skipDirectEdge(Node, Edges, int)->boolean::: graph decoder skip direct edge
org.graalvm.compiler.nodes.GraphDecoder#lookupNode(LoopScope, int)->Node::: graph decoder lookup node
org.graalvm.compiler.nodes.GraphDecoder#registerNode(LoopScope, int, Node, boolean, boolean)->void::: graph decoder register node
org.graalvm.compiler.nodes.GraphDecoder#readOrderId(MethodScope)->int::: graph decoder read order id
org.graalvm.compiler.nodes.GraphDecoder#readObject(MethodScope)->Object::: graph decoder read object
org.graalvm.compiler.nodes.GraphDecoder#cleanupGraph(MethodScope)->void:::Removes unnecessary nodes from the graph after decoding.
org.graalvm.compiler.nodes.GraphDecoder#verifyEdges()->boolean::: graph decoder verify edges
org.graalvm.compiler.nodes.LoopDetector#run()->void::: loop detector run
org.graalvm.compiler.nodes.GraphEncoder#encodeSingleGraph(StructuredGraph, Architecture)->EncodedGraph:::Utility method that does everything necessary to encode a single graph.
org.graalvm.compiler.nodes.GraphEncoder#prepare(StructuredGraph)->void:::Must be invoked before #finishPrepare() and #encode.
org.graalvm.compiler.nodes.GraphEncoder#finishPrepare()->void::: graph encoder finish prepare
org.graalvm.compiler.nodes.GraphEncoder#getObjects()->Object[]::: graph encoder get objects
org.graalvm.compiler.nodes.GraphEncoder#getNodeClasses()->NodeClass[]::: graph encoder get node classes
org.graalvm.compiler.nodes.GraphEncoder#encode(StructuredGraph)->int:::Compresses a graph to a byte array
org.graalvm.compiler.nodes.GraphEncoder#getEncoding()->byte[]::: graph encoder get encoding
org.graalvm.compiler.nodes.GraphEncoder#writeProperties(Node, Fields)->void::: graph encoder write properties
org.graalvm.compiler.nodes.GraphEncoder#writeEdges(Node, Edges, NodeOrder)->void::: graph encoder write edges
org.graalvm.compiler.nodes.GraphEncoder#writeOrderId(Node, NodeOrder)->void::: graph encoder write order id
org.graalvm.compiler.nodes.GraphEncoder#writeObjectId(Object)->void::: graph encoder write object id
org.graalvm.compiler.nodes.GraphEncoder#verifyEncoding(StructuredGraph, EncodedGraph)->boolean:::Verification code that checks that the decoding of an encode graph is the same as the original graph.
org.graalvm.compiler.nodes.GraphComparison#verifyGraphsEqual(StructuredGraph, StructuredGraph)->boolean::: graph comparison verify graphs equal
org.graalvm.compiler.nodes.GraphComparison#verifyPhi(PhiNode, PhiNode, NodeMap, Deque>)->void::: graph comparison verify phi
org.graalvm.compiler.nodes.GraphComparison#verifyPhis(AbstractEndNode, AbstractEndNode, NodeMap, Deque>)->void::: graph comparison verify phis
org.graalvm.compiler.nodes.GraphComparison#verifyNodeEqual(Node, Node, NodeMap, Deque>, boolean)->void::: graph comparison verify node equal
org.graalvm.compiler.nodes.GraphComparison#pushToWorklist(Node, Node, NodeMap, Deque>)->void::: graph comparison push to worklist
org.graalvm.compiler.nodes.GuardedValueNode#object()->ValueNode::: guarded value node object
org.graalvm.compiler.nodes.GuardedValueNode#generate(NodeLIRBuilderTool)->void::: guarded value node generate
org.graalvm.compiler.nodes.GuardedValueNode#inferStamp()->boolean::: guarded value node infer stamp
org.graalvm.compiler.nodes.GuardedValueNode#virtualize(VirtualizerTool)->void::: guarded value node virtualize
org.graalvm.compiler.nodes.GuardedValueNode#canonical(CanonicalizerTool)->Node::: guarded value node canonical
org.graalvm.compiler.nodes.GuardedValueNode#getOriginalNode()->ValueNode::: guarded value node get original node
org.graalvm.compiler.nodes.GuardNode#getCondition()->LogicNode:::The instruction that produces the tested boolean value.
org.graalvm.compiler.nodes.GuardNode#setCondition(LogicNode, boolean)->void::: guard node set condition
org.graalvm.compiler.nodes.GuardNode#isNegated()->boolean::: guard node is negated
org.graalvm.compiler.nodes.GuardNode#getReason()->DeoptimizationReason::: guard node get reason
org.graalvm.compiler.nodes.GuardNode#getAction()->DeoptimizationAction::: guard node get action
org.graalvm.compiler.nodes.GuardNode#getSpeculation()->Speculation::: guard node get speculation
org.graalvm.compiler.nodes.GuardNode#setSpeculation(Speculation)->void::: guard node set speculation
org.graalvm.compiler.nodes.GuardNode#toString(Verbosity)->String::: guard node to string
org.graalvm.compiler.nodes.GuardNode#canonical(CanonicalizerTool)->Node::: guard node canonical
org.graalvm.compiler.nodes.GuardNode#lowerGuard()->FixedWithNextNode::: guard node lower guard
org.graalvm.compiler.nodes.GuardNode#negate()->void::: guard node negate
org.graalvm.compiler.nodes.GuardNode#setAction(DeoptimizationAction)->void::: guard node set action
org.graalvm.compiler.nodes.GuardNode#setReason(DeoptimizationReason)->void::: guard node set reason
org.graalvm.compiler.nodes.GuardNode#getNoDeoptSuccessorPosition()->NodeSourcePosition::: guard node get no deopt successor position
org.graalvm.compiler.nodes.GuardNode#setNoDeoptSuccessorPosition(NodeSourcePosition)->void::: guard node set no deopt successor position
org.graalvm.compiler.nodes.GuardPhiNode#values()->NodeInputList::: guard phi node values
org.graalvm.compiler.nodes.GuardProxyNode#generate(NodeLIRBuilderTool)->void::: guard proxy node generate
org.graalvm.compiler.nodes.GuardProxyNode#setValue(GuardingNode)->void::: guard proxy node set value
org.graalvm.compiler.nodes.GuardProxyNode#value()->ValueNode::: guard proxy node value
org.graalvm.compiler.nodes.GuardProxyNode#createPhi(AbstractMergeNode)->PhiNode::: guard proxy node create phi
org.graalvm.compiler.nodes.GuardProxyNode#getOriginalNode()->Node::: guard proxy node get original node
org.graalvm.compiler.nodes.GuardProxyNode#canonical(CanonicalizerTool)->Node::: guard proxy node canonical
org.graalvm.compiler.nodes.IfNode#condition()->LogicNode::: if node condition
org.graalvm.compiler.nodes.IfNode#setCondition(LogicNode)->void::: if node set condition
org.graalvm.compiler.nodes.IfNode#trueSuccessor()->AbstractBeginNode:::Gets the true successor.
org.graalvm.compiler.nodes.IfNode#falseSuccessor()->AbstractBeginNode:::Gets the false successor.
org.graalvm.compiler.nodes.IfNode#getTrueSuccessorProbability()->double::: if node get true successor probability
org.graalvm.compiler.nodes.IfNode#setTrueSuccessor(AbstractBeginNode)->void::: if node set true successor
org.graalvm.compiler.nodes.IfNode#setFalseSuccessor(AbstractBeginNode)->void::: if node set false successor
org.graalvm.compiler.nodes.IfNode#successor(boolean)->AbstractBeginNode:::Gets the node corresponding to the specified outcome of the branch.
org.graalvm.compiler.nodes.IfNode#setTrueSuccessorProbability(double)->void::: if node set true successor probability
org.graalvm.compiler.nodes.IfNode#probability(AbstractBeginNode)->double::: if node probability
org.graalvm.compiler.nodes.IfNode#generate(NodeLIRBuilderTool)->void::: if node generate
org.graalvm.compiler.nodes.IfNode#verify()->boolean::: if node verify
org.graalvm.compiler.nodes.IfNode#verifySourcePosition()->boolean::: if node verify source position
org.graalvm.compiler.nodes.IfNode#eliminateNegation()->void::: if node eliminate negation
org.graalvm.compiler.nodes.IfNode#simplify(SimplifierTool)->void::: if node simplify
org.graalvm.compiler.nodes.IfNode#getNextSwitchFoldableBranch()->Node::: if node get next switch foldable branch
org.graalvm.compiler.nodes.IfNode#isInSwitch(ValueNode)->boolean::: if node is in switch
org.graalvm.compiler.nodes.IfNode#cutOffCascadeNode()->void::: if node cut off cascade node
org.graalvm.compiler.nodes.IfNode#cutOffLowestCascadeNode()->void::: if node cut off lowest cascade node
org.graalvm.compiler.nodes.IfNode#getDefault()->AbstractBeginNode::: if node get default
org.graalvm.compiler.nodes.IfNode#switchValue()->ValueNode::: if node switch value
org.graalvm.compiler.nodes.IfNode#isNonInitializedProfile()->boolean::: if node is non initialized profile
org.graalvm.compiler.nodes.IfNode#intKeyAt(int)->int::: if node int key at
org.graalvm.compiler.nodes.IfNode#keyProbability(int)->double::: if node key probability
org.graalvm.compiler.nodes.IfNode#keySuccessor(int)->AbstractBeginNode::: if node key successor
org.graalvm.compiler.nodes.IfNode#defaultProbability()->double::: if node default probability
org.graalvm.compiler.nodes.IfNode#removeThroughFalseBranch(SimplifierTool, AbstractMergeNode)->void::: if node remove through false branch
org.graalvm.compiler.nodes.IfNode#constantValues(ValueNode, AbstractMergeNode, boolean)->Constant[]:::Gets an array of constants derived from a node that is either a ConstantNode or a PhiNode whose input values are all constants
org.graalvm.compiler.nodes.IfNode#getPrimarySuccessor()->AbstractBeginNode::: if node get primary successor
org.graalvm.compiler.nodes.IfNode#getSuccessor(boolean)->AbstractBeginNode::: if node get successor
org.graalvm.compiler.nodes.IfNode#setProbability(AbstractBeginNode, double)->boolean::: if node set probability
org.graalvm.compiler.nodes.IfNode#getSuccessorCount()->int::: if node get successor count
org.graalvm.compiler.nodes.IndirectCallTargetNode#computedAddress()->ValueNode::: indirect call target node computed address
org.graalvm.compiler.nodes.IndirectCallTargetNode#targetName()->String::: indirect call target node target name
org.graalvm.compiler.nodes.InliningLog.Decision#isPositive()->boolean::: decision is positive
org.graalvm.compiler.nodes.InliningLog.Decision#getReason()->String::: decision get reason
org.graalvm.compiler.nodes.InliningLog.Decision#getPhase()->String::: decision get phase
org.graalvm.compiler.nodes.InliningLog.Decision#getTarget()->ResolvedJavaMethod::: decision get target
org.graalvm.compiler.nodes.InliningLog.Decision#toString()->String::: decision to string
org.graalvm.compiler.nodes.InliningLog#addDecision(Invokable, boolean, String, EconomicMap, InliningLog, String, Object...)->void:::Add an inlining decision for the specified invoke
org.graalvm.compiler.nodes.InliningLog#addLog(UnmodifiableEconomicMap, InliningLog)->void:::Append the inlining decision tree from the specified log
org.graalvm.compiler.nodes.InliningLog#replaceLog(UnmodifiableEconomicMap, InliningLog)->void:::Completely replace the current log with the copy of the specified log
org.graalvm.compiler.nodes.InliningLog#checkInvariants(StructuredGraph)->void::: inlining log check invariants
org.graalvm.compiler.nodes.InliningLog.UpdateScope#activate()->void::: update scope activate
org.graalvm.compiler.nodes.InliningLog.UpdateScope#close()->void::: update scope close
org.graalvm.compiler.nodes.InliningLog.UpdateScope#getUpdater()->BiConsumer::: update scope get updater
org.graalvm.compiler.nodes.InliningLog#getUpdateScope()->BiConsumer::: inlining log get update scope
org.graalvm.compiler.nodes.InliningLog#openUpdateScope(BiConsumer)->UpdateScope:::Creates and sets a new update scope for the log
org.graalvm.compiler.nodes.InliningLog#openDefaultUpdateScope()->UpdateScope:::Creates a new update scope that does not update the log
org.graalvm.compiler.nodes.InliningLog.RootScope#activate()->void::: root scope activate
org.graalvm.compiler.nodes.InliningLog.RootScope#getInvoke()->Invokable::: root scope get invoke
org.graalvm.compiler.nodes.InliningLog.RootScope#close()->void::: root scope close
org.graalvm.compiler.nodes.InliningLog.PlaceholderInvokable#getTargetMethod()->ResolvedJavaMethod::: placeholder invokable get target method
org.graalvm.compiler.nodes.InliningLog.PlaceholderInvokable#bci()->int::: placeholder invokable bci
org.graalvm.compiler.nodes.InliningLog.PlaceholderInvokable#isAlive()->boolean::: placeholder invokable is alive
org.graalvm.compiler.nodes.InliningLog.PlaceholderInvokable#asFixedNode()->FixedNode::: placeholder invokable as fixed node
org.graalvm.compiler.nodes.InliningLog#openRootScope(ResolvedJavaMethod, int)->RootScope::: inlining log open root scope
org.graalvm.compiler.nodes.InliningLog#openRootScope(Invokable)->RootScope::: inlining log open root scope
org.graalvm.compiler.nodes.InliningLog#containsLeafCallsite(Invokable)->boolean::: inlining log contains leaf callsite
org.graalvm.compiler.nodes.InliningLog#removeLeafCallsite(Invokable)->void::: inlining log remove leaf callsite
org.graalvm.compiler.nodes.InliningLog#trackNewCallsite(Invokable)->void::: inlining log track new callsite
org.graalvm.compiler.nodes.InliningLog#trackDuplicatedCallsite(Invokable, Invokable)->void::: inlining log track duplicated callsite
org.graalvm.compiler.nodes.InliningLog#updateExistingCallsite(Invokable, Invokable)->void::: inlining log update existing callsite
org.graalvm.compiler.nodes.InliningLog#formatAsTree(boolean)->String:::Formats the inlining log as a hierarchical tree.
org.graalvm.compiler.nodes.Invokable#getTargetMethod()->ResolvedJavaMethod::: invokable get target method
org.graalvm.compiler.nodes.Invokable#bci()->int::: invokable bci
org.graalvm.compiler.nodes.Invokable#isAlive()->boolean::: invokable is alive
org.graalvm.compiler.nodes.Invokable#asFixedNode()->FixedNode::: invokable as fixed node
org.graalvm.compiler.nodes.Invokable#updateInliningLogAfterRegister(StructuredGraph)->void:::Called on a Invokable node after it is registered with a graph
org.graalvm.compiler.nodes.Invokable#updateInliningLogAfterClone(Node)->void:::Called on a Invokable node after it was cloned from another node
org.graalvm.compiler.nodes.Invoke#next()->FixedNode::: invoke next
org.graalvm.compiler.nodes.Invoke#setNext(FixedNode)->void::: invoke set next
org.graalvm.compiler.nodes.Invoke#callTarget()->CallTargetNode::: invoke call target
org.graalvm.compiler.nodes.Invoke#bci()->int::: invoke bci
org.graalvm.compiler.nodes.Invoke#predecessor()->Node::: invoke predecessor
org.graalvm.compiler.nodes.Invoke#classInit()->ValueNode::: invoke class init
org.graalvm.compiler.nodes.Invoke#setClassInit(ValueNode)->void::: invoke set class init
org.graalvm.compiler.nodes.Invoke#useForInlining()->boolean::: invoke use for inlining
org.graalvm.compiler.nodes.Invoke#setUseForInlining(boolean)->void::: invoke set use for inlining
org.graalvm.compiler.nodes.Invoke#isPolymorphic()->boolean:::True if this invocation is almost certainly polymorphic, false when in doubt.
org.graalvm.compiler.nodes.Invoke#setPolymorphic(boolean)->void::: invoke set polymorphic
org.graalvm.compiler.nodes.Invoke#getTargetMethod()->ResolvedJavaMethod::: invoke get target method
org.graalvm.compiler.nodes.Invoke#getContextMethod()->ResolvedJavaMethod:::Returns the ResolvedJavaMethod method from which this invoke is executed
org.graalvm.compiler.nodes.Invoke#getContextType()->ResolvedJavaType:::Returns the ResolvedJavaType type from which this invoke is executed
org.graalvm.compiler.nodes.Invoke#computeStateDuring(FrameState)->void::: invoke compute state during
org.graalvm.compiler.nodes.Invoke#getReceiver()->ValueNode::: invoke get receiver
org.graalvm.compiler.nodes.Invoke#getReceiverType()->ResolvedJavaType::: invoke get receiver type
org.graalvm.compiler.nodes.Invoke#getInvokeKind()->InvokeKind::: invoke get invoke kind
org.graalvm.compiler.nodes.Invoke#replaceBci(int)->void::: invoke replace bci
org.graalvm.compiler.nodes.InvokeNode#replaceBci(int)->void::: invoke node replace bci
org.graalvm.compiler.nodes.InvokeNode#afterClone(Node)->void::: invoke node after clone
org.graalvm.compiler.nodes.InvokeNode#asFixedNode()->FixedNode::: invoke node as fixed node
org.graalvm.compiler.nodes.InvokeNode#callTarget()->CallTargetNode::: invoke node call target
org.graalvm.compiler.nodes.InvokeNode#setCallTarget(CallTargetNode)->void::: invoke node set call target
org.graalvm.compiler.nodes.InvokeNode#isPolymorphic()->boolean::: invoke node is polymorphic
org.graalvm.compiler.nodes.InvokeNode#setPolymorphic(boolean)->void::: invoke node set polymorphic
org.graalvm.compiler.nodes.InvokeNode#useForInlining()->boolean::: invoke node use for inlining
org.graalvm.compiler.nodes.InvokeNode#setUseForInlining(boolean)->void::: invoke node set use for inlining
org.graalvm.compiler.nodes.InvokeNode#isAllowedUsageType(InputType)->boolean::: invoke node is allowed usage type
org.graalvm.compiler.nodes.InvokeNode#getDebugProperties(Map)->Map::: invoke node get debug properties
org.graalvm.compiler.nodes.InvokeNode#getLocationIdentity()->LocationIdentity::: invoke node get location identity
org.graalvm.compiler.nodes.InvokeNode#lower(LoweringTool)->void::: invoke node lower
org.graalvm.compiler.nodes.InvokeNode#generate(NodeLIRBuilderTool)->void::: invoke node generate
org.graalvm.compiler.nodes.InvokeNode#toString(Verbosity)->String::: invoke node to string
org.graalvm.compiler.nodes.InvokeNode#bci()->int::: invoke node bci
org.graalvm.compiler.nodes.InvokeNode#canDeoptimize()->boolean::: invoke node can deoptimize
org.graalvm.compiler.nodes.InvokeNode#stateDuring()->FrameState::: invoke node state during
org.graalvm.compiler.nodes.InvokeNode#setStateDuring(FrameState)->void::: invoke node set state during
org.graalvm.compiler.nodes.InvokeNode#uncheckedStamp()->Stamp::: invoke node unchecked stamp
org.graalvm.compiler.nodes.InvokeNode#setClassInit(ValueNode)->void::: invoke node set class init
org.graalvm.compiler.nodes.InvokeNode#classInit()->ValueNode::: invoke node class init
org.graalvm.compiler.nodes.InvokeNode#estimatedNodeCycles()->NodeCycles::: invoke node estimated node cycles
org.graalvm.compiler.nodes.InvokeNode#estimatedNodeSize()->NodeSize::: invoke node estimated node size
org.graalvm.compiler.nodes.InvokeWithExceptionNode#afterClone(Node)->void::: invoke with exception node after clone
org.graalvm.compiler.nodes.InvokeWithExceptionNode#asFixedNode()->FixedNode::: invoke with exception node as fixed node
org.graalvm.compiler.nodes.InvokeWithExceptionNode#exceptionEdge()->AbstractBeginNode::: invoke with exception node exception edge
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setExceptionEdge(AbstractBeginNode)->void::: invoke with exception node set exception edge
org.graalvm.compiler.nodes.InvokeWithExceptionNode#next()->AbstractBeginNode::: invoke with exception node next
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setNext(AbstractBeginNode)->void::: invoke with exception node set next
org.graalvm.compiler.nodes.InvokeWithExceptionNode#callTarget()->CallTargetNode::: invoke with exception node call target
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setCallTarget(CallTargetNode)->void::: invoke with exception node set call target
org.graalvm.compiler.nodes.InvokeWithExceptionNode#methodCallTarget()->MethodCallTargetNode::: invoke with exception node method call target
org.graalvm.compiler.nodes.InvokeWithExceptionNode#isPolymorphic()->boolean::: invoke with exception node is polymorphic
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setPolymorphic(boolean)->void::: invoke with exception node set polymorphic
org.graalvm.compiler.nodes.InvokeWithExceptionNode#useForInlining()->boolean::: invoke with exception node use for inlining
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setUseForInlining(boolean)->void::: invoke with exception node set use for inlining
org.graalvm.compiler.nodes.InvokeWithExceptionNode#toString(Verbosity)->String::: invoke with exception node to string
org.graalvm.compiler.nodes.InvokeWithExceptionNode#bci()->int::: invoke with exception node bci
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setNext(FixedNode)->void::: invoke with exception node set next
org.graalvm.compiler.nodes.InvokeWithExceptionNode#lower(LoweringTool)->void::: invoke with exception node lower
org.graalvm.compiler.nodes.InvokeWithExceptionNode#generate(NodeLIRBuilderTool)->void::: invoke with exception node generate
org.graalvm.compiler.nodes.InvokeWithExceptionNode#stateAfter()->FrameState::: invoke with exception node state after
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setStateAfter(FrameState)->void::: invoke with exception node set state after
org.graalvm.compiler.nodes.InvokeWithExceptionNode#hasSideEffect()->boolean::: invoke with exception node has side effect
org.graalvm.compiler.nodes.InvokeWithExceptionNode#getLocationIdentity()->LocationIdentity::: invoke with exception node get location identity
org.graalvm.compiler.nodes.InvokeWithExceptionNode#getDebugProperties(Map)->Map::: invoke with exception node get debug properties
org.graalvm.compiler.nodes.InvokeWithExceptionNode#killExceptionEdge()->void::: invoke with exception node kill exception edge
org.graalvm.compiler.nodes.InvokeWithExceptionNode#killKillingBegin()->AbstractBeginNode::: invoke with exception node kill killing begin
org.graalvm.compiler.nodes.InvokeWithExceptionNode#replaceBci(int)->void::: invoke with exception node replace bci
org.graalvm.compiler.nodes.InvokeWithExceptionNode#probability(AbstractBeginNode)->double::: invoke with exception node probability
org.graalvm.compiler.nodes.InvokeWithExceptionNode#canDeoptimize()->boolean::: invoke with exception node can deoptimize
org.graalvm.compiler.nodes.InvokeWithExceptionNode#stateDuring()->FrameState::: invoke with exception node state during
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setStateDuring(FrameState)->void::: invoke with exception node set state during
org.graalvm.compiler.nodes.InvokeWithExceptionNode#getPrimarySuccessor()->AbstractBeginNode::: invoke with exception node get primary successor
org.graalvm.compiler.nodes.InvokeWithExceptionNode#uncheckedStamp()->Stamp::: invoke with exception node unchecked stamp
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setClassInit(ValueNode)->void::: invoke with exception node set class init
org.graalvm.compiler.nodes.InvokeWithExceptionNode#classInit()->ValueNode::: invoke with exception node class init
org.graalvm.compiler.nodes.InvokeWithExceptionNode#setProbability(AbstractBeginNode, double)->boolean::: invoke with exception node set probability
org.graalvm.compiler.nodes.InvokeWithExceptionNode#getSuccessorCount()->int::: invoke with exception node get successor count
org.graalvm.compiler.nodes.InvokeWithExceptionNode#replaceWithInvoke()->InvokeNode:::Replaces this InvokeWithExceptionNode with a normal InvokeNode
org.graalvm.compiler.nodes.KillingBeginNode#begin(FixedNode, LocationIdentity)->AbstractBeginNode::: killing begin node begin
org.graalvm.compiler.nodes.KillingBeginNode#create(LocationIdentity)->AbstractBeginNode::: killing begin node create
org.graalvm.compiler.nodes.KillingBeginNode#getLocationIdentity()->LocationIdentity::: killing begin node get location identity
org.graalvm.compiler.nodes.LogicConstantNode#forBoolean(boolean, Graph)->LogicConstantNode:::Returns a node for a boolean constant.
org.graalvm.compiler.nodes.LogicConstantNode#forBoolean(boolean)->LogicConstantNode:::Returns a node for a boolean constant.
org.graalvm.compiler.nodes.LogicConstantNode#tautology(Graph)->LogicConstantNode:::Gets a constant for true.
org.graalvm.compiler.nodes.LogicConstantNode#contradiction(Graph)->LogicConstantNode:::Gets a constant for false.
org.graalvm.compiler.nodes.LogicConstantNode#tautology()->LogicConstantNode:::Gets a constant for true.
org.graalvm.compiler.nodes.LogicConstantNode#contradiction()->LogicConstantNode:::Gets a constant for false.
org.graalvm.compiler.nodes.LogicConstantNode#getValue()->boolean::: logic constant node get value
org.graalvm.compiler.nodes.LogicConstantNode#generate(NodeLIRBuilderTool)->void::: logic constant node generate
org.graalvm.compiler.nodes.LogicNegationNode#create(LogicNode)->LogicNode::: logic negation node create
org.graalvm.compiler.nodes.LogicNegationNode#getValue()->LogicNode::: logic negation node get value
org.graalvm.compiler.nodes.LogicNegationNode#canonical(CanonicalizerTool, LogicNode)->LogicNode::: logic negation node canonical
org.graalvm.compiler.nodes.LogicNegationNode#implies(boolean, LogicNode)->TriState::: logic negation node implies
org.graalvm.compiler.nodes.LogicNode#and(LogicNode, LogicNode, double)->LogicNode::: logic node and
org.graalvm.compiler.nodes.LogicNode#and(LogicNode, boolean, LogicNode, boolean, double)->LogicNode::: logic node and
org.graalvm.compiler.nodes.LogicNode#or(LogicNode, LogicNode, double)->LogicNode::: logic node or
org.graalvm.compiler.nodes.LogicNode#or(LogicNode, boolean, LogicNode, boolean, double)->LogicNode::: logic node or
org.graalvm.compiler.nodes.LogicNode#isTautology()->boolean::: logic node is tautology
org.graalvm.compiler.nodes.LogicNode#isContradiction()->boolean::: logic node is contradiction
org.graalvm.compiler.nodes.LogicNode#implies(boolean, LogicNode)->TriState:::Determines what this condition implies about the other
org.graalvm.compiler.nodes.LoopBeginNode#isSimpleLoop()->boolean::: loop begin node is simple loop
org.graalvm.compiler.nodes.LoopBeginNode#setPreLoop()->void::: loop begin node set pre loop
org.graalvm.compiler.nodes.LoopBeginNode#isPreLoop()->boolean::: loop begin node is pre loop
org.graalvm.compiler.nodes.LoopBeginNode#setMainLoop()->void::: loop begin node set main loop
org.graalvm.compiler.nodes.LoopBeginNode#isMainLoop()->boolean::: loop begin node is main loop
org.graalvm.compiler.nodes.LoopBeginNode#setPostLoop()->void::: loop begin node set post loop
org.graalvm.compiler.nodes.LoopBeginNode#isPostLoop()->boolean::: loop begin node is post loop
org.graalvm.compiler.nodes.LoopBeginNode#getUnrollFactor()->int::: loop begin node get unroll factor
org.graalvm.compiler.nodes.LoopBeginNode#setUnrollFactor(int)->void::: loop begin node set unroll factor
org.graalvm.compiler.nodes.LoopBeginNode#disableSafepoint()->void:::Disables safepoint for the whole loop, i.e., for all LoopEndNode loop ends.
org.graalvm.compiler.nodes.LoopBeginNode#loopOrigFrequency()->double::: loop begin node loop orig frequency
org.graalvm.compiler.nodes.LoopBeginNode#setLoopOrigFrequency(double)->void::: loop begin node set loop orig frequency
org.graalvm.compiler.nodes.LoopBeginNode#loopFrequency()->double::: loop begin node loop frequency
org.graalvm.compiler.nodes.LoopBeginNode#setLoopFrequency(double)->void::: loop begin node set loop frequency
org.graalvm.compiler.nodes.LoopBeginNode#loopEnds()->NodeIterable:::Returns the unordered set of LoopEndNode that correspond to back-edges for this loop
org.graalvm.compiler.nodes.LoopBeginNode#loopExits()->NodeIterable::: loop begin node loop exits
org.graalvm.compiler.nodes.LoopBeginNode#anchored()->NodeIterable::: loop begin node anchored
org.graalvm.compiler.nodes.LoopBeginNode#orderedLoopEnds()->LoopEndNode[]:::Returns the set of LoopEndNode that correspond to back-edges for this loop, in increasing #phiPredecessorIndex order
org.graalvm.compiler.nodes.LoopBeginNode#isSingleEntryLoop()->boolean::: loop begin node is single entry loop
org.graalvm.compiler.nodes.LoopBeginNode#forwardEnd()->AbstractEndNode::: loop begin node forward end
org.graalvm.compiler.nodes.LoopBeginNode#splits()->int::: loop begin node splits
org.graalvm.compiler.nodes.LoopBeginNode#incrementSplits()->void::: loop begin node increment splits
org.graalvm.compiler.nodes.LoopBeginNode#generate(NodeLIRBuilderTool)->void::: loop begin node generate
org.graalvm.compiler.nodes.LoopBeginNode#deleteEnd(AbstractEndNode)->void::: loop begin node delete end
org.graalvm.compiler.nodes.LoopBeginNode#phiPredecessorCount()->int::: loop begin node phi predecessor count
org.graalvm.compiler.nodes.LoopBeginNode#phiPredecessorIndex(AbstractEndNode)->int::: loop begin node phi predecessor index
org.graalvm.compiler.nodes.LoopBeginNode#phiPredecessorAt(int)->AbstractEndNode::: loop begin node phi predecessor at
org.graalvm.compiler.nodes.LoopBeginNode#verify()->boolean::: loop begin node verify
org.graalvm.compiler.nodes.LoopBeginNode#nextEndIndex()->int::: loop begin node next end index
org.graalvm.compiler.nodes.LoopBeginNode#getLoopEndCount()->int::: loop begin node get loop end count
org.graalvm.compiler.nodes.LoopBeginNode#unswitches()->int::: loop begin node unswitches
org.graalvm.compiler.nodes.LoopBeginNode#incrementUnswitches()->void::: loop begin node increment unswitches
org.graalvm.compiler.nodes.LoopBeginNode#getInversionCount()->int::: loop begin node get inversion count
org.graalvm.compiler.nodes.LoopBeginNode#setInversionCount(int)->void::: loop begin node set inversion count
org.graalvm.compiler.nodes.LoopBeginNode#simplify(SimplifierTool)->void::: loop begin node simplify
org.graalvm.compiler.nodes.LoopBeginNode#isLoopExit(AbstractBeginNode)->boolean::: loop begin node is loop exit
org.graalvm.compiler.nodes.LoopBeginNode#getSingleLoopEnd()->LoopEndNode::: loop begin node get single loop end
org.graalvm.compiler.nodes.LoopBeginNode#removeExits()->void::: loop begin node remove exits
org.graalvm.compiler.nodes.LoopBeginNode#getOverflowGuard()->GuardingNode::: loop begin node get overflow guard
org.graalvm.compiler.nodes.LoopBeginNode#setOverflowGuard(GuardingNode)->void::: loop begin node set overflow guard
org.graalvm.compiler.nodes.LoopBeginNode#canonicalizePhis(SimplifierTool)->void:::Coalesces loop phis that represent the same value (which is not handled by normal Global Value Numbering).
org.graalvm.compiler.nodes.LoopBeginNode#markOsrLoop()->void::: loop begin node mark osr loop
org.graalvm.compiler.nodes.LoopBeginNode#isOsrLoop()->boolean::: loop begin node is osr loop
org.graalvm.compiler.nodes.LoopEndNode#merge()->AbstractMergeNode::: loop end node merge
org.graalvm.compiler.nodes.LoopEndNode#loopBegin()->LoopBeginNode::: loop end node loop begin
org.graalvm.compiler.nodes.LoopEndNode#setLoopBegin(LoopBeginNode)->void::: loop end node set loop begin
org.graalvm.compiler.nodes.LoopEndNode#disableSafepoint()->void:::Disables safepoints for only this loop end (in contrast to disabling it for LoopBeginNode#disableSafepoint() the whole loop.
org.graalvm.compiler.nodes.LoopEndNode#canSafepoint()->boolean::: loop end node can safepoint
org.graalvm.compiler.nodes.LoopEndNode#generate(NodeLIRBuilderTool)->void::: loop end node generate
org.graalvm.compiler.nodes.LoopEndNode#verify()->boolean::: loop end node verify
org.graalvm.compiler.nodes.LoopEndNode#endIndex()->int:::Returns the index of this loop end amongst its LoopBeginNode's loop ends.<br>  Since a LoopBeginNode also has LoopBeginNode#forwardEnds() forward ends, this is not the index into PhiNode values at the loop begin
org.graalvm.compiler.nodes.LoopEndNode#setEndIndex(int)->void::: loop end node set end index
org.graalvm.compiler.nodes.LoopEndNode#cfgSuccessors()->Iterable::: loop end node cfg successors
org.graalvm.compiler.nodes.LoopEndNode#estimatedNodeCycles()->NodeCycles::: loop end node estimated node cycles
org.graalvm.compiler.nodes.LoopEndNode#estimatedNodeSize()->NodeSize::: loop end node estimated node size
org.graalvm.compiler.nodes.LoopExitNode#loopBegin()->LoopBeginNode::: loop exit node loop begin
org.graalvm.compiler.nodes.LoopExitNode#anchored()->NodeIterable::: loop exit node anchored
org.graalvm.compiler.nodes.LoopExitNode#prepareDelete(FixedNode)->void::: loop exit node prepare delete
org.graalvm.compiler.nodes.LoopExitNode#removeProxies()->void::: loop exit node remove proxies
org.graalvm.compiler.nodes.LoopExitNode#proxies()->NodeIterable::: loop exit node proxies
org.graalvm.compiler.nodes.LoopExitNode#removeExit()->void::: loop exit node remove exit
org.graalvm.compiler.nodes.LoopExitNode#simplify(SimplifierTool)->void::: loop exit node simplify
org.graalvm.compiler.nodes.LoweredCallTargetNode#signature()->JavaType[]::: lowered call target node signature
org.graalvm.compiler.nodes.LoweredCallTargetNode#callType()->CallingConvention.Type::: lowered call target node call type
org.graalvm.compiler.nodes.MergeNode#removeMergeIfDegenerated(MergeNode)->void::: merge node remove merge if degenerated
org.graalvm.compiler.nodes.MergeNode#verify()->boolean::: merge node verify
org.graalvm.compiler.nodes.NamedLocationIdentity.DB#checkUnique(String)->boolean::: b check unique
org.graalvm.compiler.nodes.NamedLocationIdentity#mutable(String)->NamedLocationIdentity:::Creates a named unique location identity for read and write operations against mutable memory.
org.graalvm.compiler.nodes.NamedLocationIdentity#immutable(String)->NamedLocationIdentity:::Creates a named unique location identity for read operations against immutable memory
org.graalvm.compiler.nodes.NamedLocationIdentity#isImmutable()->boolean::: named location identity is immutable
org.graalvm.compiler.nodes.NamedLocationIdentity#toString()->String::: named location identity to string
org.graalvm.compiler.nodes.NamedLocationIdentity#getArrayLocation(JavaKind)->LocationIdentity:::Returns the named location identity for an array of the given element kind
org.graalvm.compiler.nodes.NamedLocationIdentity#isArrayLocation(LocationIdentity)->boolean::: named location identity is array location
org.graalvm.compiler.nodes.NodeView.Default#stamp(ValueNode)->Stamp::: default stamp
org.graalvm.compiler.nodes.NodeView#stamp(ValueNode)->Stamp:::Return a view-specific stamp of the node
org.graalvm.compiler.nodes.NodeView#from(CanonicalizerTool)->NodeView::: node view from
org.graalvm.compiler.nodes.ParameterNode#uncheckedStamp()->Stamp::: parameter node unchecked stamp
org.graalvm.compiler.nodes.PauseNode#generate(NodeLIRBuilderTool)->void::: pause node generate
org.graalvm.compiler.nodes.PauseNode#pause()->void::: pause node pause
org.graalvm.compiler.nodes.PhiNode#values()->NodeInputList::: phi node values
org.graalvm.compiler.nodes.PhiNode#merge()->AbstractMergeNode::: phi node merge
org.graalvm.compiler.nodes.PhiNode#setMerge(AbstractMergeNode)->void::: phi node set merge
org.graalvm.compiler.nodes.PhiNode#verify()->boolean::: phi node verify
org.graalvm.compiler.nodes.PhiNode#valueAt(int)->ValueNode:::Get the instruction that produces the value associated with the i'th predecessor of the merge.
org.graalvm.compiler.nodes.PhiNode#initializeValueAt(int, ValueNode)->void:::Sets the value at the given index and makes sure that the values list is large enough.
org.graalvm.compiler.nodes.PhiNode#setValueAt(int, ValueNode)->void::: phi node set value at
org.graalvm.compiler.nodes.PhiNode#setValueAt(AbstractEndNode, ValueNode)->void::: phi node set value at
org.graalvm.compiler.nodes.PhiNode#valueAt(AbstractEndNode)->ValueNode::: phi node value at
org.graalvm.compiler.nodes.PhiNode#valueCount()->int:::Get the number of inputs to this phi (i.e
org.graalvm.compiler.nodes.PhiNode#clearValues()->void::: phi node clear values
org.graalvm.compiler.nodes.PhiNode#toString(Verbosity)->String::: phi node to string
org.graalvm.compiler.nodes.PhiNode#valueDescription()->String:::String describing the kind of value this Phi merges
org.graalvm.compiler.nodes.PhiNode#addInput(ValueNode)->void::: phi node add input
org.graalvm.compiler.nodes.PhiNode#removeInput(int)->void::: phi node remove input
org.graalvm.compiler.nodes.PhiNode#backValues()->NodeIterable::: phi node back values
org.graalvm.compiler.nodes.PhiNode#singleValueOrThis()->ValueNode:::If all inputs are the same value, this value is returned, otherwise this
org.graalvm.compiler.nodes.PhiNode#singleBackValueOrThis()->ValueNode:::If all inputs (but the first one) are the same value, the value is returned, otherwise this
org.graalvm.compiler.nodes.PhiNode#canonical(CanonicalizerTool)->ValueNode::: phi node canonical
org.graalvm.compiler.nodes.PhiNode#firstValue()->ValueNode::: phi node first value
org.graalvm.compiler.nodes.PhiNode#isLoopPhi()->boolean::: phi node is loop phi
org.graalvm.compiler.nodes.PiArrayNode#findLength(FindLengthMode, ConstantReflectionProvider)->ValueNode::: pi array node find length
org.graalvm.compiler.nodes.PiArrayNode#canonical(CanonicalizerTool)->Node::: pi array node canonical
org.graalvm.compiler.nodes.PiArrayNode#piArrayCastToSnippetReplaceeStamp(Object, int)->Object:::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
org.graalvm.compiler.nodes.PiArrayNode.Placeholder#makeReplacement(Stamp)->void::: placeholder make replacement
org.graalvm.compiler.nodes.PiNode#object()->ValueNode::: pi node object
org.graalvm.compiler.nodes.PiNode#create(ValueNode, Stamp)->ValueNode::: pi node create
org.graalvm.compiler.nodes.PiNode#create(ValueNode, Stamp, ValueNode)->ValueNode::: pi node create
org.graalvm.compiler.nodes.PiNode#create(ValueNode, ValueNode)->ValueNode::: pi node create
org.graalvm.compiler.nodes.PiNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ValueNode, ValueNode)->boolean::: pi node intrinsify
org.graalvm.compiler.nodes.PiNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ValueNode, ResolvedJavaType, boolean, boolean)->boolean::: pi node intrinsify
org.graalvm.compiler.nodes.PiNode#piStamp()->Stamp::: pi node pi stamp
org.graalvm.compiler.nodes.PiNode#strengthenPiStamp(Stamp)->void::: pi node strengthen pi stamp
org.graalvm.compiler.nodes.PiNode#generate(NodeLIRBuilderTool)->void::: pi node generate
org.graalvm.compiler.nodes.PiNode#inferStamp()->boolean::: pi node infer stamp
org.graalvm.compiler.nodes.PiNode#virtualize(VirtualizerTool)->void::: pi node virtualize
org.graalvm.compiler.nodes.PiNode#canonical(ValueNode, Stamp, GuardingNode, PiNode)->ValueNode::: pi node canonical
org.graalvm.compiler.nodes.PiNode#canonical(CanonicalizerTool)->Node::: pi node canonical
org.graalvm.compiler.nodes.PiNode#getOriginalNode()->ValueNode::: pi node get original node
org.graalvm.compiler.nodes.PiNode#setOriginalNode(ValueNode)->void::: pi node set original node
org.graalvm.compiler.nodes.PiNode#asNonNullClass(Object)->Class:::Casts an object to have an exact, non-null stamp representing Class.
org.graalvm.compiler.nodes.PiNode#asNonNullObject(Object)->Class:::Casts an object to have an exact, non-null stamp representing Class.
org.graalvm.compiler.nodes.PiNode#piCastToSnippetReplaceeStamp(Object)->Object:::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
org.graalvm.compiler.nodes.PiNode#piCastNonNull(Object, GuardingNode)->Object:::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.
org.graalvm.compiler.nodes.PiNode#piCastNonNullClass(Class, GuardingNode)->Class:::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.
org.graalvm.compiler.nodes.PiNode#piCastNonNull(Object, ResolvedJavaType)->Object:::Changes the stamp of an object to represent a given type and to indicate that the object is not null.
org.graalvm.compiler.nodes.PiNode#piCast(Object, ResolvedJavaType, boolean, boolean)->Object::: pi node pi cast
org.graalvm.compiler.nodes.PiNode.Placeholder#object()->ValueNode::: placeholder object
org.graalvm.compiler.nodes.PiNode.Placeholder#makeReplacement(Stamp)->void:::Replaces this node with a PiNode during snippet instantiation.
org.graalvm.compiler.nodes.PiNode.PlaceholderStamp#singleton()->PlaceholderStamp::: placeholder stamp singleton
org.graalvm.compiler.nodes.PiNode.PlaceholderStamp#hashCode()->int::: placeholder stamp hash code
org.graalvm.compiler.nodes.PiNode.PlaceholderStamp#equals(Object)->boolean::: placeholder stamp equals
org.graalvm.compiler.nodes.PiNode.PlaceholderStamp#toString()->String::: placeholder stamp to string
org.graalvm.compiler.nodes.PrefetchAllocateNode#generate(NodeLIRBuilderTool)->void::: prefetch allocate node generate
org.graalvm.compiler.nodes.PrefetchAllocateNode#prefetch(Address)->void::: prefetch allocate node prefetch
org.graalvm.compiler.nodes.ProxyNode#value()->ValueNode::: proxy node value
org.graalvm.compiler.nodes.ProxyNode#setProxyPoint(LoopExitNode)->void::: proxy node set proxy point
org.graalvm.compiler.nodes.ProxyNode#proxyPoint()->LoopExitNode::: proxy node proxy point
org.graalvm.compiler.nodes.ProxyNode#verify()->boolean::: proxy node verify
org.graalvm.compiler.nodes.ProxyNode#forValue(ValueNode, LoopExitNode, StructuredGraph)->ValueProxyNode::: proxy node for value
org.graalvm.compiler.nodes.ProxyNode#forGuard(GuardingNode, LoopExitNode, StructuredGraph)->GuardProxyNode::: proxy node for guard
org.graalvm.compiler.nodes.ProxyNode#createPhi(AbstractMergeNode)->PhiNode::: proxy node create phi
org.graalvm.compiler.nodes.ReturnNode#result()->ValueNode::: return node result
org.graalvm.compiler.nodes.ReturnNode#generate(NodeLIRBuilderTool)->void::: return node generate
org.graalvm.compiler.nodes.ReturnNode#setMemoryMap(MemoryMapNode)->void::: return node set memory map
org.graalvm.compiler.nodes.ReturnNode#getMemoryMap()->MemoryMapNode::: return node get memory map
org.graalvm.compiler.nodes.SafepointNode#lower(LoweringTool)->void::: safepoint node lower
org.graalvm.compiler.nodes.SafepointNode#generate(NodeLIRBuilderTool)->void::: safepoint node generate
org.graalvm.compiler.nodes.SafepointNode#canDeoptimize()->boolean::: safepoint node can deoptimize
org.graalvm.compiler.nodes.ShortCircuitOrNode#create(LogicNode, boolean, LogicNode, boolean, double)->LogicNode::: short circuit or node create
org.graalvm.compiler.nodes.ShortCircuitOrNode#getX()->LogicNode::: short circuit or node get x
org.graalvm.compiler.nodes.ShortCircuitOrNode#getY()->LogicNode::: short circuit or node get y
org.graalvm.compiler.nodes.ShortCircuitOrNode#isXNegated()->boolean::: short circuit or node is negated
org.graalvm.compiler.nodes.ShortCircuitOrNode#isYNegated()->boolean::: short circuit or node is negated
org.graalvm.compiler.nodes.ShortCircuitOrNode#getShortCircuitProbability()->double:::Gets the probability that the #getY() y part of this binary node is not evaluated
org.graalvm.compiler.nodes.ShortCircuitOrNode#canonicalizeNegation(LogicNode, LogicNode)->ShortCircuitOrNode::: short circuit or node canonicalize negation
org.graalvm.compiler.nodes.ShortCircuitOrNode#canonical(CanonicalizerTool, LogicNode, LogicNode)->LogicNode::: short circuit or node canonical
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#getOptions()->OptionValues::: canonicalizer tool get options
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#getMetaAccess()->MetaAccessProvider::: canonicalizer tool get meta access
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#getConstantReflection()->ConstantReflectionProvider::: canonicalizer tool get constant reflection
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#getConstantFieldProvider()->ConstantFieldProvider::: canonicalizer tool get constant field provider
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#canonicalizeReads()->boolean::: canonicalizer tool canonicalize reads
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#allUsagesAvailable()->boolean::: canonicalizer tool all usages available
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#getAssumptions()->Assumptions::: canonicalizer tool get assumptions
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.PECanonicalizerTool#smallestCompareWidth()->Integer::: canonicalizer tool smallest compare width
org.graalvm.compiler.nodes.SimplifyingGraphDecoder.CanonicalizeToNullNode#canonical(CanonicalizerTool)->Node::: canonicalize to null node canonical
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#cleanupGraph(MethodScope)->void::: simplifying graph decoder cleanup graph
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#allowLazyPhis()->boolean::: simplifying graph decoder allow lazy phis
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#handleMergeNode(MergeNode)->void::: simplifying graph decoder handle merge node
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#handleFixedNode(MethodScope, LoopScope, int, FixedNode)->void::: simplifying graph decoder handle fixed node
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#canonicalizeFixedNode(MethodScope, Node)->Node:::Canonicalizes the provided node, which was originally a FixedNode but can already be canonicalized (and therefore be a non-fixed node).
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#handleFloatingNodeBeforeAdd(MethodScope, LoopScope, Node)->Node::: simplifying graph decoder handle floating node before add
org.graalvm.compiler.nodes.SimplifyingGraphDecoder#addFloatingNode(MethodScope, Node)->Node::: simplifying graph decoder add floating node
org.graalvm.compiler.nodes.SnippetAnchorNode#simplify(SimplifierTool)->void::: snippet anchor node simplify
org.graalvm.compiler.nodes.SnippetAnchorNode#anchor()->GuardingNode::: snippet anchor node anchor
org.graalvm.compiler.nodes.StartNode#getLocationIdentity()->LocationIdentity::: start node get location identity
org.graalvm.compiler.nodes.StateSplit#stateAfter()->FrameState:::Gets the FrameState corresponding to the state of the JVM after execution of this node.
org.graalvm.compiler.nodes.StateSplit#setStateAfter(FrameState)->void:::Sets the FrameState corresponding to the state of the JVM after execution of this node.
org.graalvm.compiler.nodes.StateSplit#hasSideEffect()->boolean:::Determines if this node has a side-effect
org.graalvm.compiler.nodes.StaticDeoptimizingNode#getReason()->DeoptimizationReason::: static deoptimizing node get reason
org.graalvm.compiler.nodes.StaticDeoptimizingNode#setReason(DeoptimizationReason)->void::: static deoptimizing node set reason
org.graalvm.compiler.nodes.StaticDeoptimizingNode#getAction()->DeoptimizationAction::: static deoptimizing node get action
org.graalvm.compiler.nodes.StaticDeoptimizingNode#setAction(DeoptimizationAction)->void::: static deoptimizing node set action
org.graalvm.compiler.nodes.StaticDeoptimizingNode#getSpeculation()->Speculation::: static deoptimizing node get speculation
org.graalvm.compiler.nodes.StaticDeoptimizingNode#computePriority()->GuardPriority::: static deoptimizing node compute priority
org.graalvm.compiler.nodes.StaticDeoptimizingNode#mergeActions(DeoptimizationAction, DeoptimizationAction)->DeoptimizationAction::: static deoptimizing node merge actions
org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult#getCFG()->ControlFlowGraph::: schedule result get g
org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult#getNodeToBlockMap()->NodeMap::: schedule result get node to block map
org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult#getBlockToNodesMap()->BlockMap>::: schedule result get block to nodes map
org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult#nodesFor(Block)->List::: schedule result nodes for
org.graalvm.compiler.nodes.StructuredGraph.Builder#getName()->String::: builder get name
org.graalvm.compiler.nodes.StructuredGraph.Builder#name(String)->Builder::: builder name
org.graalvm.compiler.nodes.StructuredGraph.Builder#setIsSubstitution(boolean)->Builder::: builder set is substitution
org.graalvm.compiler.nodes.StructuredGraph.Builder#getMethod()->ResolvedJavaMethod::: builder get method
org.graalvm.compiler.nodes.StructuredGraph.Builder#method(ResolvedJavaMethod)->Builder::: builder method
org.graalvm.compiler.nodes.StructuredGraph.Builder#getDebug()->DebugContext::: builder get debug
org.graalvm.compiler.nodes.StructuredGraph.Builder#getSpeculationLog()->SpeculationLog::: builder get speculation log
org.graalvm.compiler.nodes.StructuredGraph.Builder#speculationLog(SpeculationLog)->Builder::: builder speculation log
org.graalvm.compiler.nodes.StructuredGraph.Builder#getCompilationId()->CompilationIdentifier::: builder get compilation id
org.graalvm.compiler.nodes.StructuredGraph.Builder#compilationId(CompilationIdentifier)->Builder::: builder compilation id
org.graalvm.compiler.nodes.StructuredGraph.Builder#getCancellable()->Cancellable::: builder get cancellable
org.graalvm.compiler.nodes.StructuredGraph.Builder#cancellable(Cancellable)->Builder::: builder cancellable
org.graalvm.compiler.nodes.StructuredGraph.Builder#getEntryBCI()->int::: builder get entry i
org.graalvm.compiler.nodes.StructuredGraph.Builder#entryBCI(int)->Builder::: builder entry i
org.graalvm.compiler.nodes.StructuredGraph.Builder#getUseProfilingInfo()->boolean::: builder get use profiling info
org.graalvm.compiler.nodes.StructuredGraph.Builder#useProfilingInfo(boolean)->Builder::: builder use profiling info
org.graalvm.compiler.nodes.StructuredGraph.Builder#getRecordInlinedMethods()->boolean::: builder get record inlined methods
org.graalvm.compiler.nodes.StructuredGraph.Builder#recordInlinedMethods(boolean)->Builder::: builder record inlined methods
org.graalvm.compiler.nodes.StructuredGraph.Builder#trackNodeSourcePosition(boolean)->Builder::: builder track node source position
org.graalvm.compiler.nodes.StructuredGraph.Builder#callerContext(NodeSourcePosition)->Builder::: builder caller context
org.graalvm.compiler.nodes.StructuredGraph.Builder#build()->StructuredGraph::: builder build
org.graalvm.compiler.nodes.StructuredGraph#setLastSchedule(ScheduleResult)->void::: structured graph set last schedule
org.graalvm.compiler.nodes.StructuredGraph#getLastSchedule()->ScheduleResult::: structured graph get last schedule
org.graalvm.compiler.nodes.StructuredGraph#clearLastSchedule()->void::: structured graph clear last schedule
org.graalvm.compiler.nodes.StructuredGraph#maybeCompress()->boolean::: structured graph maybe compress
org.graalvm.compiler.nodes.StructuredGraph#getReturnStamp()->Stamp::: structured graph get return stamp
org.graalvm.compiler.nodes.StructuredGraph#toString()->String::: structured graph to string
org.graalvm.compiler.nodes.StructuredGraph#start()->StartNode::: structured graph start
org.graalvm.compiler.nodes.StructuredGraph#method()->ResolvedJavaMethod:::Gets the root method from which this graph was built.
org.graalvm.compiler.nodes.StructuredGraph#getEntryBCI()->int::: structured graph get entry i
org.graalvm.compiler.nodes.StructuredGraph#getCancellable()->Cancellable::: structured graph get cancellable
org.graalvm.compiler.nodes.StructuredGraph#checkCancellation()->void::: structured graph check cancellation
org.graalvm.compiler.nodes.StructuredGraph#isOSR()->boolean::: structured graph is r
org.graalvm.compiler.nodes.StructuredGraph#graphId()->long::: structured graph graph id
org.graalvm.compiler.nodes.StructuredGraph#compilationId()->CompilationIdentifier::: structured graph compilation id
org.graalvm.compiler.nodes.StructuredGraph#setStart(StartNode)->void::: structured graph set start
org.graalvm.compiler.nodes.StructuredGraph#getInliningLog()->InliningLog::: structured graph get inlining log
org.graalvm.compiler.nodes.StructuredGraph#logInliningTree()->void::: structured graph log inlining tree
org.graalvm.compiler.nodes.StructuredGraph#copy(String, Consumer>, DebugContext)->Graph:::Creates a copy of this graph.
org.graalvm.compiler.nodes.StructuredGraph#copyWithIdentifier(CompilationIdentifier, DebugContext)->StructuredGraph::: structured graph copy with identifier
org.graalvm.compiler.nodes.StructuredGraph#getParameter(int)->ParameterNode::: structured graph get parameter
org.graalvm.compiler.nodes.StructuredGraph#getInvokes()->Iterable::: structured graph get invokes
org.graalvm.compiler.nodes.StructuredGraph#hasLoops()->boolean::: structured graph has loops
org.graalvm.compiler.nodes.StructuredGraph#removeFixed(FixedWithNextNode)->void:::Unlinks a node from all its control flow neighbors and then removes it from its graph
org.graalvm.compiler.nodes.StructuredGraph#replaceFixed(FixedWithNextNode, Node)->void::: structured graph replace fixed
org.graalvm.compiler.nodes.StructuredGraph#replaceFixedWithFixed(FixedWithNextNode, FixedWithNextNode)->void::: structured graph replace fixed with fixed
org.graalvm.compiler.nodes.StructuredGraph#replaceFixedWithFloating(FixedWithNextNode, ValueNode)->void::: structured graph replace fixed with floating
org.graalvm.compiler.nodes.StructuredGraph#removeSplit(ControlSplitNode, AbstractBeginNode)->void::: structured graph remove split
org.graalvm.compiler.nodes.StructuredGraph#removeSplitPropagate(ControlSplitNode, AbstractBeginNode)->void::: structured graph remove split propagate
org.graalvm.compiler.nodes.StructuredGraph#replaceSplit(ControlSplitNode, Node, AbstractBeginNode)->void::: structured graph replace split
org.graalvm.compiler.nodes.StructuredGraph#replaceSplitWithFixed(ControlSplitNode, FixedWithNextNode, AbstractBeginNode)->void::: structured graph replace split with fixed
org.graalvm.compiler.nodes.StructuredGraph#replaceSplitWithFloating(ControlSplitNode, FloatingNode, AbstractBeginNode)->void::: structured graph replace split with floating
org.graalvm.compiler.nodes.StructuredGraph#addAfterFixed(FixedWithNextNode, FixedNode)->void::: structured graph add after fixed
org.graalvm.compiler.nodes.StructuredGraph#addBeforeFixed(FixedNode, FixedWithNextNode)->void::: structured graph add before fixed
org.graalvm.compiler.nodes.StructuredGraph#reduceDegenerateLoopBegin(LoopBeginNode)->void::: structured graph reduce degenerate loop begin
org.graalvm.compiler.nodes.StructuredGraph#reduceTrivialMerge(AbstractMergeNode)->void::: structured graph reduce trivial merge
org.graalvm.compiler.nodes.StructuredGraph#getGuardsStage()->GuardsStage::: structured graph get guards stage
org.graalvm.compiler.nodes.StructuredGraph#setGuardsStage(GuardsStage)->void::: structured graph set guards stage
org.graalvm.compiler.nodes.StructuredGraph#isAfterFloatingReadPhase()->boolean::: structured graph is after floating read phase
org.graalvm.compiler.nodes.StructuredGraph#isAfterFixedReadPhase()->boolean::: structured graph is after fixed read phase
org.graalvm.compiler.nodes.StructuredGraph#setAfterFloatingReadPhase(boolean)->void::: structured graph set after floating read phase
org.graalvm.compiler.nodes.StructuredGraph#setAfterFixReadPhase(boolean)->void::: structured graph set after fix read phase
org.graalvm.compiler.nodes.StructuredGraph#hasValueProxies()->boolean::: structured graph has value proxies
org.graalvm.compiler.nodes.StructuredGraph#setHasValueProxies(boolean)->void::: structured graph set has value proxies
org.graalvm.compiler.nodes.StructuredGraph#isAfterExpandLogic()->boolean::: structured graph is after expand logic
org.graalvm.compiler.nodes.StructuredGraph#setAfterExpandLogic()->void::: structured graph set after expand logic
org.graalvm.compiler.nodes.StructuredGraph#useProfilingInfo()->boolean:::Determines if ProfilingInfo is used during construction of this graph.
org.graalvm.compiler.nodes.StructuredGraph#isSubstitution()->boolean:::Returns true if this graph is built without parsing the #method() root method or if the root method is annotated by Snippet or MethodSubstitution
org.graalvm.compiler.nodes.StructuredGraph#getProfilingInfo()->ProfilingInfo:::Gets the profiling info for the #method() root method of this graph.
org.graalvm.compiler.nodes.StructuredGraph#getProfilingInfo(ResolvedJavaMethod)->ProfilingInfo:::Gets the profiling info for a given method that is or will be part of this graph, taking into account #useProfilingInfo().
org.graalvm.compiler.nodes.StructuredGraph#getAssumptions()->Assumptions:::Gets the object for recording assumptions while constructing of this graph.
org.graalvm.compiler.nodes.StructuredGraph#getMethods()->List:::Gets an unmodifiable view of the methods that were inlined while constructing this graph.
org.graalvm.compiler.nodes.StructuredGraph#recordMethod(ResolvedJavaMethod)->void:::Records that method was used to build this graph.
org.graalvm.compiler.nodes.StructuredGraph#updateMethods(StructuredGraph)->void:::Updates the #getMethods() methods used to build this graph with the methods used to build another graph.
org.graalvm.compiler.nodes.StructuredGraph#getFields()->EconomicSet:::Gets an unmodifiable view of the fields that were accessed while constructing this graph.
org.graalvm.compiler.nodes.StructuredGraph#recordField(ResolvedJavaField)->void:::Records that field was accessed in this graph.
org.graalvm.compiler.nodes.StructuredGraph#updateFields(StructuredGraph)->void:::Updates the #getFields() fields of this graph with the accessed fields of another graph.
org.graalvm.compiler.nodes.StructuredGraph#getBytecodeSize()->int:::Gets the input bytecode ResolvedJavaMethod#getCodeSize() size from which this graph is constructed
org.graalvm.compiler.nodes.StructuredGraph#asJavaMethod()->JavaMethod::: structured graph as java method
org.graalvm.compiler.nodes.StructuredGraph#hasUnsafeAccess()->boolean::: structured graph has unsafe access
org.graalvm.compiler.nodes.StructuredGraph#markUnsafeAccess()->void::: structured graph mark unsafe access
org.graalvm.compiler.nodes.StructuredGraph#disableUnsafeAccessTracking()->void::: structured graph disable unsafe access tracking
org.graalvm.compiler.nodes.StructuredGraph#isUnsafeAccessTrackingEnabled()->boolean::: structured graph is unsafe access tracking enabled
org.graalvm.compiler.nodes.StructuredGraph#getSpeculationLog()->SpeculationLog::: structured graph get speculation log
org.graalvm.compiler.nodes.StructuredGraph#clearAllStateAfter()->void::: structured graph clear all state after
org.graalvm.compiler.nodes.StructuredGraph#hasVirtualizableAllocation()->boolean::: structured graph has virtualizable allocation
org.graalvm.compiler.nodes.StructuredGraph#afterRegister(Node)->void::: structured graph after register
org.graalvm.compiler.nodes.StructuredGraph#getCallerContext()->NodeSourcePosition::: structured graph get caller context
org.graalvm.compiler.nodes.UnaryOpLogicNode#getValue()->ValueNode::: unary op logic node get value
org.graalvm.compiler.nodes.UnaryOpLogicNode#generate(NodeLIRBuilderTool)->void::: unary op logic node generate
org.graalvm.compiler.nodes.UnaryOpLogicNode#getSucceedingStampForValue(boolean, Stamp)->Stamp:::In general the input stamp cannot be trusted, this method is reserved for the cases when it's "safe" to use the input stamp
org.graalvm.compiler.nodes.UnaryOpLogicNode#getSucceedingStampForValue(boolean)->Stamp:::The input stamp cannot be trusted, the returned stamp cannot use the input stamp to narrow itself or derive any assumptions
org.graalvm.compiler.nodes.UnaryOpLogicNode#tryFold(Stamp)->TriState::: unary op logic node try fold
org.graalvm.compiler.nodes.UnaryOpLogicNode#implies(boolean, LogicNode)->TriState::: unary op logic node implies
org.graalvm.compiler.nodes.UnwindNode#exception()->ValueNode::: unwind node exception
org.graalvm.compiler.nodes.UnwindNode#lower(LoweringTool)->void::: unwind node lower
org.graalvm.compiler.nodes.UnwindNode#generate(NodeLIRBuilderTool)->void::: unwind node generate
org.graalvm.compiler.nodes.ValueNode#stamp(NodeView)->Stamp::: value node stamp
org.graalvm.compiler.nodes.ValueNode#setStamp(Stamp)->void::: value node set stamp
org.graalvm.compiler.nodes.ValueNode#graph()->StructuredGraph::: value node graph
org.graalvm.compiler.nodes.ValueNode#updateStamp(Stamp)->boolean:::Checks if the given stamp is different than the current one ( newStamp.equals(oldStamp) == false)
org.graalvm.compiler.nodes.ValueNode#inferStamp()->boolean:::This method can be overridden by subclasses of ValueNode if they need to recompute their stamp if their inputs change
org.graalvm.compiler.nodes.ValueNode#getStackKind()->JavaKind::: value node get stack kind
org.graalvm.compiler.nodes.ValueNode#isConstant()->boolean:::Checks whether this value is a constant (i.e
org.graalvm.compiler.nodes.ValueNode#isConstantPredicate()->NodePredicate::: value node is constant predicate
org.graalvm.compiler.nodes.ValueNode#isNullConstant()->boolean:::Checks whether this value represents the null constant.
org.graalvm.compiler.nodes.ValueNode#isDefaultConstant()->boolean::: value node is default constant
org.graalvm.compiler.nodes.ValueNode#asConstant()->Constant:::Convert this value to a constant if it is a constant, otherwise return null.
org.graalvm.compiler.nodes.ValueNode#isJavaConstant()->boolean::: value node is java constant
org.graalvm.compiler.nodes.ValueNode#asJavaConstant()->JavaConstant::: value node as java constant
org.graalvm.compiler.nodes.ValueNode#asNode()->ValueNode::: value node as node
org.graalvm.compiler.nodes.ValueNode#isAllowedUsageType(InputType)->boolean::: value node is allowed usage type
org.graalvm.compiler.nodes.ValueNode#hasUsagesOtherThan(ValueNode, NodeValueMap)->boolean:::Checks if this node has usages other than the given node node.
org.graalvm.compiler.nodes.ValueNode#replaceAtUsages(Node, Predicate, Node)->void::: value node replace at usages
org.graalvm.compiler.nodes.ValueNodeInterface#asNode()->ValueNode::: value node interface as node
org.graalvm.compiler.nodes.ValueNodeUtil#assertKind(JavaKind, ValueNode)->ValueNode::: value node util assert kind
org.graalvm.compiler.nodes.ValueNodeUtil#shouldNotReachHere(String)->RuntimeException::: value node util should not reach here
org.graalvm.compiler.nodes.ValueNodeUtil#shouldNotReachHere()->RuntimeException::: value node util should not reach here
org.graalvm.compiler.nodes.ValueNodeUtil#assertLong(ValueNode)->ValueNode::: value node util assert long
org.graalvm.compiler.nodes.ValueNodeUtil#assertInt(ValueNode)->ValueNode::: value node util assert int
org.graalvm.compiler.nodes.ValueNodeUtil#assertFloat(ValueNode)->ValueNode::: value node util assert float
org.graalvm.compiler.nodes.ValueNodeUtil#assertObject(ValueNode)->ValueNode::: value node util assert object
org.graalvm.compiler.nodes.ValueNodeUtil#assertDouble(ValueNode)->ValueNode::: value node util assert double
org.graalvm.compiler.nodes.ValueNodeUtil#assertHigh(ValueNode)->void::: value node util assert high
org.graalvm.compiler.nodes.ValueNodeUtil#filter(Iterable, Class)->Collection::: value node util filter
org.graalvm.compiler.nodes.ValueNodeUtil#valueString(ValueNode)->String:::Converts a given instruction to a value string
org.graalvm.compiler.nodes.ValueNodeUtil#asNode(MemoryNode)->ValueNode::: value node util as node
org.graalvm.compiler.nodes.ValuePhiNode#values()->NodeInputList::: value phi node values
org.graalvm.compiler.nodes.ValuePhiNode#inferStamp()->boolean::: value phi node infer stamp
org.graalvm.compiler.nodes.ValuePhiNode#verify()->boolean::: value phi node verify
org.graalvm.compiler.nodes.ValuePhiNode#valueDescription()->String::: value phi node value description
org.graalvm.compiler.nodes.ValuePhiNode#getDebugProperties(Map)->Map::: value phi node get debug properties
org.graalvm.compiler.nodes.ValueProxyNode#value()->ValueNode::: value proxy node value
org.graalvm.compiler.nodes.ValueProxyNode#createPhi(AbstractMergeNode)->PhiNode::: value proxy node create phi
org.graalvm.compiler.nodes.ValueProxyNode#inferStamp()->boolean::: value proxy node infer stamp
org.graalvm.compiler.nodes.ValueProxyNode#canonical(CanonicalizerTool)->Node::: value proxy node canonical
org.graalvm.compiler.nodes.ValueProxyNode#virtualize(VirtualizerTool)->void::: value proxy node virtualize
org.graalvm.compiler.nodes.ValueProxyNode#getOriginalNode()->ValueNode::: value proxy node get original node
org.graalvm.compiler.nodes.ValueProxyNode#getGuard()->GuardingNode::: value proxy node get guard
org.graalvm.compiler.nodes.VirtualState.NodeClosure#apply(Node, T)->void::: node closure apply
org.graalvm.compiler.nodes.VirtualState.VirtualClosure#apply(VirtualState)->void::: virtual closure apply
org.graalvm.compiler.nodes.VirtualState#duplicateWithVirtualState()->VirtualState::: virtual state duplicate with virtual state
org.graalvm.compiler.nodes.VirtualState#applyToNonVirtual(NodeClosure)->void::: virtual state apply to non virtual
org.graalvm.compiler.nodes.VirtualState#applyToVirtual(VirtualClosure)->void:::Performs a pre-order iteration over all elements reachable from this state that are a subclass of VirtualState.
org.graalvm.compiler.nodes.VirtualState#isPartOfThisState(VirtualState)->boolean::: virtual state is part of this state
org.graalvm.compiler.nodes.VirtualState#graph()->StructuredGraph::: virtual state graph
