Plugin_BreakpointNode_breakpoint#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ breakpoint node_breakpoint execute:::node->new->org.graalvm.compiler.nodes.BreakpointNode->b->add->return
Plugin_BreakpointNode_breakpoint#getSource()::: plugin_ breakpoint node_breakpoint get source:::return
PluginFactory_BreakpointNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ breakpoint node register plugins:::plugins->new->Plugin_BreakpointNode_breakpoint->register
Plugin_ComputeObjectAddressNode_get#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ compute object address node_get execute:::arg0->arg1->node->new->org.graalvm.compiler.nodes.ComputeObjectAddressNode->b->addPush->return
Plugin_ComputeObjectAddressNode_get#getSource()::: plugin_ compute object address node_get get source:::return
PluginFactory_ComputeObjectAddressNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ compute object address node register plugins:::plugins->new->Plugin_ComputeObjectAddressNode_get->register
Plugin_ConstantNode_forClass#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ constant node_for class execute:::arg0->arg1->b->getConstantReflection->arg2->if->isConstant->cst->asJavaConstant->b->getConstantReflection->asJavaType->if->snippetReflection->asObject->else->return->node->new->org.graalvm.compiler.nodes.ConstantNode->b->addPush->return
Plugin_ConstantNode_forClass#getSource()::: plugin_ constant node_for class get source:::return
PluginFactory_ConstantNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ constant node register plugins:::plugins->new->Plugin_ConstantNode_forClass->register
Plugin_DeoptimizeNode_deopt#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ deoptimize node_deopt execute:::arg0->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg1->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.DeoptimizeNode->b->add->return
Plugin_DeoptimizeNode_deopt#getSource()::: plugin_ deoptimize node_deopt get source:::return
PluginFactory_DeoptimizeNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ deoptimize node register plugins:::plugins->new->Plugin_DeoptimizeNode_deopt->register
Plugin_GetObjectAddressNode_get#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ get object address node_get execute:::arg0->node->new->org.graalvm.compiler.nodes.GetObjectAddressNode->b->addPush->return
Plugin_GetObjectAddressNode_get#getSource()::: plugin_ get object address node_get get source:::return
PluginFactory_GetObjectAddressNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ get object address node register plugins:::plugins->new->Plugin_GetObjectAddressNode_get->register
Plugin_PauseNode_pause#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pause node_pause execute:::node->new->org.graalvm.compiler.nodes.PauseNode->b->add->return
Plugin_PauseNode_pause#getSource()::: plugin_ pause node_pause get source:::return
PluginFactory_PauseNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ pause node register plugins:::plugins->new->Plugin_PauseNode_pause->register
Plugin_PiArrayNode_piArrayCastToSnippetReplaceeStamp#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi array node_pi array cast to snippet replacee stamp execute:::arg0->arg1->node->new->org.graalvm.compiler.nodes.PiArrayNode.Placeholder->b->addPush->return
Plugin_PiArrayNode_piArrayCastToSnippetReplaceeStamp#getSource()::: plugin_ pi array node_pi array cast to snippet replacee stamp get source:::return
PluginFactory_PiArrayNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ pi array node register plugins:::plugins->new->Plugin_PiArrayNode_piArrayCastToSnippetReplaceeStamp->register
Plugin_PiNode_asNonNullClassIntrinsic#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi node_as non null class intrinsic execute:::arg0->arg1->if->isConstant->cst->asJavaConstant->b->getConstantReflection->asJavaType->if->snippetReflection->asObject->else->return->arg2->if->isConstant->asJavaConstant->asInt->else->return->arg3->if->isConstant->asJavaConstant->asInt->else->return->return->intrinsify
Plugin_PiNode_asNonNullClassIntrinsic#getSource()::: plugin_ pi node_as non null class intrinsic get source:::return
Plugin_PiNode_piCast#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi node_pi cast execute:::arg0->arg1->if->isConstant->cst->asJavaConstant->b->getConstantReflection->asJavaType->if->snippetReflection->asObject->else->return->arg2->if->isConstant->asJavaConstant->asInt->else->return->arg3->if->isConstant->asJavaConstant->asInt->else->return->return->intrinsify
Plugin_PiNode_piCast#getSource()::: plugin_ pi node_pi cast get source:::return
Plugin_PiNode_piCastNonNull#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi node_pi cast non null execute:::arg0->arg1->return->intrinsify
Plugin_PiNode_piCastNonNull#getSource()::: plugin_ pi node_pi cast non null get source:::return
Plugin_PiNode_piCastNonNullClass#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi node_pi cast non null class execute:::arg0->arg1->return->intrinsify
Plugin_PiNode_piCastNonNullClass#getSource()::: plugin_ pi node_pi cast non null class get source:::return
Plugin_PiNode_piCastToSnippetReplaceeStamp#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ pi node_pi cast to snippet replacee stamp execute:::arg0->node->new->org.graalvm.compiler.nodes.PiNode.Placeholder->b->addPush->return
Plugin_PiNode_piCastToSnippetReplaceeStamp#getSource()::: plugin_ pi node_pi cast to snippet replacee stamp get source:::return
PluginFactory_PiNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ pi node register plugins:::plugins->new->Plugin_PiNode_asNonNullClassIntrinsic->register->plugins->new->Plugin_PiNode_piCast->register->plugins->new->Plugin_PiNode_piCastNonNull->register->plugins->new->Plugin_PiNode_piCastNonNullClass->register->plugins->new->Plugin_PiNode_piCastToSnippetReplaceeStamp->register
Plugin_PrefetchAllocateNode_prefetch#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ prefetch allocate node_prefetch execute:::arg0->node->new->org.graalvm.compiler.nodes.PrefetchAllocateNode->b->add->return
Plugin_PrefetchAllocateNode_prefetch#getSource()::: plugin_ prefetch allocate node_prefetch get source:::return
PluginFactory_PrefetchAllocateNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ prefetch allocate node register plugins:::plugins->new->Plugin_PrefetchAllocateNode_prefetch->register
Plugin_SnippetAnchorNode_anchor#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ snippet anchor node_anchor execute:::node->new->org.graalvm.compiler.nodes.SnippetAnchorNode->b->addPush->return
Plugin_SnippetAnchorNode_anchor#getSource()::: plugin_ snippet anchor node_anchor get source:::return
PluginFactory_SnippetAnchorNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ snippet anchor node register plugins:::plugins->new->Plugin_SnippetAnchorNode_anchor->register
AbstractBeginNode#prevBegin(FixedNode)::: abstract begin node prev begin:::next->while->if->return->next->predecessor->return
AbstractBeginNode#evacuateAnchored(FixedNode)::: abstract begin node evacuate anchored:::if->hasNoUsages->prevBegin->prevBegin->replaceAtUsages->replaceAtUsages
AbstractBeginNode#prepareDelete()::: abstract begin node prepare delete:::predecessor->prepareDelete
AbstractBeginNode#prepareDelete(FixedNode)::: abstract begin node prepare delete:::evacuateAnchored
AbstractBeginNode#verify()::: abstract begin node verify:::predecessor->graph->start->assertTrue->return->super->verify
AbstractBeginNode#generate(NodeLIRBuilderTool)::: abstract begin node generate:::if->gen->getLIRGeneratorTool->emitSpeculationFence
AbstractBeginNode#guards()::: abstract begin node guards:::return->usages->filter
AbstractBeginNode#anchored()::: abstract begin node anchored:::return->usages
AbstractBeginNode#getBlockNodes()::: abstract begin node get block nodes:::return->new->NodeIterable<FixedNode>
AbstractBeginNode#setWithSpeculationFence():::Set this begin node to be a speculation fence:::
AbstractBeginNode.BlockNodeIterator#hasNext()::: block node iterator has next:::return
AbstractBeginNode.BlockNodeIterator#next()::: block node iterator next:::ret->if->throw->new->NoSuchElementException->if->next->if->else->return
AbstractBeginNode.BlockNodeIterator#remove()::: block node iterator remove:::throw->new->UnsupportedOperationException
AbstractDeoptimizeNode#canDeoptimize()::: abstract deoptimize node can deoptimize:::return
AbstractDeoptimizeNode#stateBefore()::: abstract deoptimize node state before:::return
AbstractDeoptimizeNode#setStateBefore(FrameState)::: abstract deoptimize node set state before:::updateUsages
AbstractDeoptimizeNode#getActionAndReason(MetaAccessProvider)::: abstract deoptimize node get action and reason:::
AbstractDeoptimizeNode#getSpeculation(MetaAccessProvider)::: abstract deoptimize node get speculation:::
AbstractEndNode#generate(NodeLIRBuilderTool)::: abstract end node generate:::gen->visitEndNode
AbstractEndNode#merge()::: abstract end node merge:::return->usages->first
AbstractEndNode#verify()::: abstract end node verify:::getUsageCount->assertTrue->return->super->verify
AbstractEndNode#cfgSuccessors()::: abstract end node cfg successors:::merge->merge->if->return->Collections->singletonList->return->Collections->emptyList
AbstractFixedGuardNode#getCondition()::: abstract fixed guard node get condition:::return
AbstractFixedGuardNode#condition()::: abstract fixed guard node condition:::return->getCondition
AbstractFixedGuardNode#setCondition(LogicNode, boolean)::: abstract fixed guard node set condition:::updateUsages
AbstractFixedGuardNode#getReason()::: abstract fixed guard node get reason:::return
AbstractFixedGuardNode#getAction()::: abstract fixed guard node get action:::return
AbstractFixedGuardNode#getSpeculation()::: abstract fixed guard node get speculation:::return
AbstractFixedGuardNode#isNegated()::: abstract fixed guard node is negated:::return
AbstractFixedGuardNode#toString(Verbosity)::: abstract fixed guard node to string:::if->return->super->toString->else->return->super->toString
AbstractFixedGuardNode#simplify(SimplifierTool)::: abstract fixed guard node simplify:::while->negation->negation->getValue->setCondition
AbstractFixedGuardNode#lowerToIf()::: abstract fixed guard node lower to if:::try->position->this->withNodeSourcePosition->currentNext->next->setNext->if->stateAfter->begin->graph->new->BeginNode->add->begin->getNoDeoptSuccessorPosition->setNodeSourcePosition->begin->setNext->deopt->graph->new->DeoptimizeNode->add->deopt->stateBefore->setStateBefore->ifNode->noDeoptSuccessor->if->graph->new->IfNode->add->ifNode->falseSuccessor->else->graph->new->IfNode->add->ifNode->trueSuccessor->noDeoptSuccessor->getNoDeoptSuccessorPosition->setNodeSourcePosition->predecessor->setNext->this->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs->return->catch->finally
AbstractFixedGuardNode#canDeoptimize()::: abstract fixed guard node can deoptimize:::return
AbstractFixedGuardNode#setAction(DeoptimizationAction)::: abstract fixed guard node set action:::
AbstractFixedGuardNode#setReason(DeoptimizationReason)::: abstract fixed guard node set reason:::
AbstractFixedGuardNode#getNoDeoptSuccessorPosition()::: abstract fixed guard node get no deopt successor position:::return
AbstractFixedGuardNode#setNoDeoptSuccessorPosition(NodeSourcePosition)::: abstract fixed guard node set no deopt successor position:::
AbstractLocalNode#index():::Gets the index of this local in the array of parameters:::return
AbstractLocalNode#toString(Verbosity)::: abstract local node to string:::if->return->super->toString->else->return->super->toString
AbstractMergeNode#generate(NodeLIRBuilderTool)::: abstract merge node generate:::gen->visitMerge
AbstractMergeNode#forwardEndIndex(EndNode)::: abstract merge node forward end index:::return->ends->indexOf
AbstractMergeNode#addForwardEnd(EndNode)::: abstract merge node add forward end:::ends->add
AbstractMergeNode#forwardEndCount()::: abstract merge node forward end count:::return->ends->size
AbstractMergeNode#forwardEndAt(int)::: abstract merge node forward end at:::return->ends->get
AbstractMergeNode#cfgPredecessors()::: abstract merge node cfg predecessors:::return
AbstractMergeNode#isPhiAtMerge(Node):::Determines if a given node is a phi whose PhiNode#merge() merge is this node.:::return->merge
AbstractMergeNode#removeEnd(AbstractEndNode):::Removes the given end from the merge, along with the entries corresponding to this end in the phis connected to the merge.:::predIndex->phiPredecessorIndex->deleteEnd->foreach->phis->snapshot->if->phi->isDeleted->continue->removedValue->phi->valueAt->phi->removeInput->if->GraphUtil->tryKillUnused
AbstractMergeNode#deleteEnd(AbstractEndNode)::: abstract merge node delete end:::ends->remove
AbstractMergeNode#clearEnds()::: abstract merge node clear ends:::ends->clear
AbstractMergeNode#forwardEnds()::: abstract merge node forward ends:::return
AbstractMergeNode#phiPredecessorCount()::: abstract merge node phi predecessor count:::return->forwardEndCount
AbstractMergeNode#phiPredecessorIndex(AbstractEndNode)::: abstract merge node phi predecessor index:::return->forwardEndIndex
AbstractMergeNode#phiPredecessorAt(int)::: abstract merge node phi predecessor at:::return->forwardEndAt
AbstractMergeNode#phis()::: abstract merge node phis:::return->this->usages->filter->this->isPhiAtMerge->filter
AbstractMergeNode#valuePhis()::: abstract merge node value phis:::return->this->usages->filter
AbstractMergeNode#memoryPhis()::: abstract merge node memory phis:::return->this->usages->filter
AbstractMergeNode#anchored()::: abstract merge node anchored:::return->super->anchored->isPhiAtMerge->filter
AbstractMergeNode#simplify(SimplifierTool):::This simplify method can deal with a null value for tool, so that it can be used outside of canonicalization.:::currentNext->next->if->origLoopEnd->merge->origLoopEnd->merge->if->return->if->this->anchored->isNotEmpty->return->if->merge->stateAfter->this->stateAfter->return->foreach->phis->foreach->phi->usages->if->merge->isPhiAtMerge->return->getDebug->log->numEnds->this->forwardEndCount->for->i->graph->reduceTrivialMerge->else->if->returnNode->if->anchored->isNotEmpty->returnNode->getMemoryMap->return->phis->phis->snapshot->foreach->foreach->phi->usages->if->return->returnValuePhi->returnNode->result->returnNode->result->isPhiAtMerge->returnNode->result->endNodes->forwardEnds->snapshot->foreach->try->position->returnNode->withNodeSourcePosition->newReturn->graph->returnNode->result->returnValuePhi->valueAt->new->ReturnNode->add->if->tool->end->predecessor->addToWorkList->end->replaceAtPredecessor->catch->finally->GraphUtil->killCFG->foreach->end->safeDelete->foreach->if->tool->allUsagesAvailable->phi->isAlive->phi->hasNoUsages->GraphUtil->killWithUnusedFloatingInputs
AbstractStateSplit#stateAfter()::: abstract state split state after:::return
AbstractStateSplit#setStateAfter(FrameState)::: abstract state split set state after:::updateUsages
AbstractStateSplit#hasSideEffect()::: abstract state split has side effect:::return
ArithmeticOperation#getArithmeticOp()::: arithmetic operation get arithmetic op:::
BeginNode#trySimplify()::: begin node try simplify:::prev->this->predecessor->if->else->prepareDelete->graph->removeFixed
BeginNode#simplify(SimplifierTool)::: begin node simplify:::prev->this->predecessor->if->else->if->else->prepareDelete->tool->next->addToWorkList->graph->removeFixed
BeginNode#begin(FixedNode)::: begin node begin:::try->position->with->withNodeSourcePosition->if->return->begin->with->graph->new->BeginNode->add->begin->setNext->return->catch->finally
BeginStateSplitNode#stateAfter()::: begin state split node state after:::return
BeginStateSplitNode#setStateAfter(FrameState)::: begin state split node set state after:::updateUsages
BeginStateSplitNode#hasSideEffect():::A begin node has no side effect.:::return
BinaryOpLogicNode#getX()::: binary op logic node get x:::return
BinaryOpLogicNode#getY()::: binary op logic node get y:::return
BinaryOpLogicNode#verify()::: binary op logic node verify:::return->super->verify
BinaryOpLogicNode#generate(NodeLIRBuilderTool)::: binary op logic node generate:::
BinaryOpLogicNode#maybeCommuteInputs():::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results:::if->y->isConstant->x->isConstant->x->getId->y->getId->tmp->if->graph->duplicate->graph->findDuplicate->if->return->return
BinaryOpLogicNode#getSucceedingStampForX(boolean, Stamp, Stamp)::: binary op logic node get succeeding stamp for x:::
BinaryOpLogicNode#getSucceedingStampForY(boolean, Stamp, Stamp)::: binary op logic node get succeeding stamp for y:::
BinaryOpLogicNode#tryFold(Stamp, Stamp)::: binary op logic node try fold:::
BreakpointNode#generate(NodeLIRBuilderTool)::: breakpoint node generate:::gen->visitBreakpointNode
BreakpointNode#arguments()::: breakpoint node arguments:::return
BreakpointNode#breakpoint()::: breakpoint node breakpoint:::
CallTargetNode#arguments()::: call target node arguments:::return
CallTargetNode#createReturnStamp(Assumptions, JavaType)::: call target node create return stamp:::kind->returnType->getJavaKind->if->return->StampFactory->TypeReference->create->object->else->return->StampFactory->forKind
CallTargetNode#returnStamp()::: call target node return stamp:::return
CallTargetNode#targetName():::A human-readable representation of the target, used for debug printing only.:::
CallTargetNode#generate(NodeLIRBuilderTool)::: call target node generate:::
CallTargetNode#setTargetMethod(ResolvedJavaMethod)::: call target node set target method:::
CallTargetNode#targetMethod():::Gets the target method for this invocation instruction.:::return
CallTargetNode#invokeKind()::: call target node invoke kind:::return
CallTargetNode#setInvokeKind(InvokeKind)::: call target node set invoke kind:::
CallTargetNode#invoke()::: call target node invoke:::return->this->usages->first
Cancellable#isCancelled():::Determines if this task has been cancelled.:::
CanonicalizableLocation#canonicalizeRead(ValueNode, AddressNode, ValueNode, CanonicalizerTool)::: canonicalizable location canonicalize read:::
CompressionNode#foldStamp(Stamp)::: compression node fold stamp:::return->mkStamp
CompressionNode#compress(Constant)::: compression node compress:::
CompressionNode#uncompress(Constant)::: compression node uncompress:::
CompressionNode#nullConstant()::: compression node null constant:::return
CompressionNode#convert(Constant, ConstantReflectionProvider)::: compression node convert:::switch->return->compress->return->uncompress->throw->GraalError->shouldNotReachHere
CompressionNode#reverse(Constant, ConstantReflectionProvider)::: compression node reverse:::switch->return->uncompress->return->compress->throw->GraalError->shouldNotReachHere
CompressionNode#isLossless()::: compression node is lossless:::return
CompressionNode#mkStamp(Stamp)::: compression node mk stamp:::
CompressionNode#getOp()::: compression node get op:::return
CompressionNode#getEncoding()::: compression node get encoding:::return
CompressionNode#canonical(CanonicalizerTool, ValueNode)::: compression node canonical:::if->forValue->isConstant->if->GeneratePIC->tool->getOptions->getValue->return->constant->return->ConstantNode->stamp->constant->getValue->tool->getConstantReflection->convert->constant->getStableDimension->constant->isDefaultStable->tool->getMetaAccess->forConstant->else->if->other->if->encoding->equals->return->other->getValue->return
CompressionNode#generate(NodeLIRBuilderTool)::: compression node generate:::nonNull->if->value->stamp->StampTool->value->stamp->isPointerNonNull->else->tool->gen->getLIRGeneratorTool->result->switch->tool->gen->operand->emitCompress->break->tool->gen->operand->emitUncompress->break->throw->GraalError->shouldNotReachHere->gen->setResult
CompressionNode#mayNullCheckSkipConversion()::: compression node may null check skip conversion:::return
ComputeObjectAddressNode#get(Object, long)::: compute object address node get:::
ComputeObjectAddressNode#lower(LoweringTool)::: compute object address node lower:::tool->getLowerer->lower
ComputeObjectAddressNode#getObject()::: compute object address node get object:::return
ComputeObjectAddressNode#getOffset()::: compute object address node get offset:::return
ConditionAnchorNode#condition()::: condition anchor node condition:::return
ConditionAnchorNode#isNegated()::: condition anchor node is negated:::return
ConditionAnchorNode#toString(Verbosity)::: condition anchor node to string:::if->return->super->toString->else->return->super->toString
ConditionAnchorNode#canonical(CanonicalizerTool, Node)::: condition anchor node canonical:::if->negation->return->negation->getValue->new->ConditionAnchorNode->if->c->if->c->getValue->return->else->return->new->ValueAnchorNode->if->tool->allUsagesAvailable->this->hasNoUsages->return->return
ConditionAnchorNode#lower(LoweringTool)::: condition anchor node lower:::if->graph->getGuardsStage->newAnchor->graph->new->ValueAnchorNode->add->graph->replaceFixedWithFixed
ConditionAnchorNode#getValue()::: condition anchor node get value:::return
ConstantNode#createPrimitive(JavaConstant)::: constant node create primitive:::return->StampFactory->forConstant->new->ConstantNode
ConstantNode#getValue()::: constant node get value:::return
ConstantNode#getStableDimension()::: constant node get stable dimension:::return
ConstantNode#isDefaultStable()::: constant node is default stable:::return
ConstantNode#getConstantNodes(StructuredGraph):::Gathers all the ConstantNodes that are inputs to the StructuredGraph#getNodes() live nodes in a given graph.:::return->graph->getNodes->filter
ConstantNode#replace(StructuredGraph, Node):::Replaces this node at its usages with another node.:::replaceAtUsagesAndDelete
ConstantNode#generate(NodeLIRBuilderTool)::: constant node generate:::lirTool->gen->getLIRGeneratorTool->kind->lirTool->stamp->getLIRKind->if->onlyUsedInVirtualState->gen->new->ConstantValue->setResult->else->if->lirTool->canInlineConstant->lirTool->mayEmbedConstantLoad->hasExactlyOneUsage->onlyUsedInCurrentBlock->gen->lirTool->toRegisterKind->new->ConstantValue->setResult->else->gen->gen->getLIRGeneratorTool->emitConstant->setResult
ConstantNode#onlyUsedInCurrentBlock():::Expecting false for loop invariant.:::nodeBlockMap->graph->getLastSchedule->getNodeToBlockMap->currentBlock->nodeBlockMap->get->foreach->usages->if->nodeBlockMap->get->return->return
ConstantNode#onlyUsedInVirtualState()::: constant node only used in virtual state:::foreach->this->usages->if->else->return->return
ConstantNode#forConstant(JavaConstant, MetaAccessProvider, StructuredGraph)::: constant node for constant:::if->constant->getJavaKind->getStackKind->constant->getJavaKind->return->constant->asInt->forInt->if->constant->getJavaKind->return->StampFactory->forConstant->new->ConstantNode->unique->else->return->createPrimitive->unique
ConstantNode#forConstant(JavaConstant, int, boolean, MetaAccessProvider)::: constant node for constant:::if->constant->getJavaKind->getStackKind->constant->getJavaKind->return->constant->asInt->forInt->if->constant->getJavaKind->return->StampFactory->forConstant->new->ConstantNode->else->return->createPrimitive
ConstantNode#forConstant(JavaConstant, MetaAccessProvider)::: constant node for constant:::return->forConstant
ConstantNode#forConstant(Stamp, Constant, MetaAccessProvider, StructuredGraph)::: constant node for constant:::return->graph->stamp->constant->new->ConstantNode->unique
ConstantNode#forConstant(Stamp, Constant, int, boolean, MetaAccessProvider)::: constant node for constant:::return->stamp->constant->new->ConstantNode
ConstantNode#forConstant(Stamp, Constant, MetaAccessProvider)::: constant node for constant:::return->stamp->constant->new->ConstantNode
ConstantNode#forPrimitive(JavaConstant, StructuredGraph):::Returns a node for a Java primitive.:::return->forConstant
ConstantNode#forPrimitive(JavaConstant):::Returns a node for a Java primitive.:::return->forConstant
ConstantNode#forPrimitive(Stamp, JavaConstant, StructuredGraph):::Returns a node for a primitive of a given type.:::if->istamp->return->istamp->getBits->forIntegerBits->else->return->forPrimitive
ConstantNode#forPrimitive(Stamp, Constant):::Returns a node for a primitive of a given type.:::if->primitive->istamp->return->istamp->getBits->forIntegerBits->else->if->primitive->return->forConstant->else->return->stamp->constant->new->ConstantNode
ConstantNode#forDouble(double, StructuredGraph):::Returns a node for a double constant.:::return->JavaConstant->forDouble->createPrimitive->unique
ConstantNode#forDouble(double):::Returns a node for a double constant.:::return->JavaConstant->forDouble->createPrimitive
ConstantNode#forFloat(float, StructuredGraph):::Returns a node for a float constant.:::return->JavaConstant->forFloat->createPrimitive->unique
ConstantNode#forFloat(float):::Returns a node for a float constant.:::return->JavaConstant->forFloat->createPrimitive
ConstantNode#forLong(long, StructuredGraph):::Returns a node for an long constant.:::return->JavaConstant->forLong->createPrimitive->unique
ConstantNode#forLong(long):::Returns a node for an long constant.:::return->JavaConstant->forLong->createPrimitive
ConstantNode#forInt(int, StructuredGraph):::Returns a node for an integer constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forInt(int):::Returns a node for an integer constant.:::return->JavaConstant->forInt->createPrimitive
ConstantNode#forBoolean(boolean, StructuredGraph):::Returns a node for a boolean constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forBoolean(boolean):::Returns a node for a boolean constant.:::return->JavaConstant->forInt->createPrimitive
ConstantNode#forByte(byte, StructuredGraph):::Returns a node for a byte constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forChar(char, StructuredGraph):::Returns a node for a char constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forShort(short, StructuredGraph):::Returns a node for a short constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#unique(StructuredGraph, ConstantNode)::: constant node unique:::return->graph->unique
ConstantNode#forIntegerBits(int, JavaConstant, StructuredGraph)::: constant node for integer bits:::value->constant->asLong->bounds->CodeUtil->signExtend->return->StampFactory->forInteger->new->ConstantNode->unique
ConstantNode#forIntegerBits(int, long, StructuredGraph):::Returns a node for a constant integer that's not directly representable as Java primitive (e.g:::return->JavaConstant->forPrimitiveInt->forIntegerBits
ConstantNode#forIntegerBits(int, JavaConstant)::: constant node for integer bits:::value->constant->asLong->bounds->CodeUtil->signExtend->return->StampFactory->forInteger->new->ConstantNode
ConstantNode#forIntegerBits(int, long):::Returns a node for a constant integer that's not directly representable as Java primitive (e.g:::return->JavaConstant->forPrimitiveInt->forIntegerBits
ConstantNode#forIntegerStamp(Stamp, long, StructuredGraph):::Returns a node for a constant integer that's compatible to a given stamp.:::if->intStamp->return->intStamp->getBits->forIntegerBits->else->return->stamp->getStackKind->forIntegerKind
ConstantNode#forIntegerStamp(Stamp, long):::Returns a node for a constant integer that's compatible to a given stamp.:::if->intStamp->return->intStamp->getBits->forIntegerBits->else->return->stamp->getStackKind->forIntegerKind
ConstantNode#forIntegerKind(JavaKind, long, StructuredGraph)::: constant node for integer kind:::switch->return->ConstantNode->forInt->return->ConstantNode->forLong->throw->GraalError->shouldNotReachHere
ConstantNode#forIntegerKind(JavaKind, long)::: constant node for integer kind:::switch->return->JavaConstant->forInt->createPrimitive->return->JavaConstant->forLong->createPrimitive->throw->GraalError->shouldNotReachHere
ConstantNode#forFloatingKind(JavaKind, double, StructuredGraph)::: constant node for floating kind:::switch->return->ConstantNode->forFloat->return->ConstantNode->forDouble->throw->GraalError->shouldNotReachHere
ConstantNode#forFloatingKind(JavaKind, double)::: constant node for floating kind:::switch->return->ConstantNode->forFloat->return->ConstantNode->forDouble->throw->GraalError->shouldNotReachHere
ConstantNode#forFloatingStamp(Stamp, double, StructuredGraph):::Returns a node for a constant double that's compatible to a given stamp.:::return->stamp->getStackKind->forFloatingKind
ConstantNode#forFloatingStamp(Stamp, double):::Returns a node for a constant double that's compatible to a given stamp.:::return->stamp->getStackKind->forFloatingKind
ConstantNode#defaultForKind(JavaKind, StructuredGraph)::: constant node default for kind:::return->defaultForKind->unique
ConstantNode#defaultForKind(JavaKind)::: constant node default for kind:::switch->return->ConstantNode->forInt->return->ConstantNode->forDouble->return->ConstantNode->forFloat->return->ConstantNode->forLong->return->ConstantNode->forConstant->return
ConstantNode#getDebugProperties(Map)::: constant node get debug properties:::properties->super->getDebugProperties->properties->value->toValueString->put->properties->stamp->unrestricted->toString->put->return
ConstantNode#toString(Verbosity)::: constant node to string:::if->return->super->toString->value->toValueString->stamp->unrestricted->toString->else->return->super->toString
ConstantNode#findLength(FindLengthMode, ConstantReflectionProvider)::: constant node find length:::if->isNull->return->length->constantReflection->readArrayLength->if->return->return->ConstantNode->forInt
ConstantNode#forClass(ResolvedJavaType)::: constant node for class:::
ControlSplitNode#probability(AbstractBeginNode)::: control split node probability:::
ControlSplitNode#setProbability(AbstractBeginNode, double):::Attempts to set the probability for the given successor to the passed value (which has to be in the range of 0.0 and 1.0):::
ControlSplitNode#getPrimarySuccessor():::Primary successor of the control split:::
ControlSplitNode#getSuccessorCount():::Returns the number of successors.:::
DeoptimizeNode#getAction()::: deoptimize node get action:::return
DeoptimizeNode#setAction(DeoptimizationAction)::: deoptimize node set action:::
DeoptimizeNode#getReason()::: deoptimize node get reason:::return
DeoptimizeNode#setReason(DeoptimizationReason)::: deoptimize node set reason:::
DeoptimizeNode#lower(LoweringTool)::: deoptimize node lower:::tool->getLowerer->lower
DeoptimizeNode#getDebugId()::: deoptimize node get debug id:::deoptDebugId->if->debug->getDebug->if->debug->isDumpEnabledForMethod->debug->isLogEnabledForMethod->this->getId->return
DeoptimizeNode#setDebugId(int)::: deoptimize node set debug id:::
DeoptimizeNode#generate(NodeLIRBuilderTool)::: deoptimize node generate:::tool->gen->getLIRGeneratorTool->actionAndReason->tool->tool->getMetaAccess->getDebugId->encodeDeoptActionAndReason->emitJavaConstant->speculationValue->tool->tool->getMetaAccess->encodeSpeculation->emitJavaConstant->gen->getLIRGeneratorTool->gen->state->emitDeoptimize
DeoptimizeNode#getActionAndReason(MetaAccessProvider)::: deoptimize node get action and reason:::return->ConstantNode->metaAccess->getDebugId->encodeDeoptActionAndReason->graph->forConstant
DeoptimizeNode#getSpeculation(MetaAccessProvider)::: deoptimize node get speculation:::return->ConstantNode->metaAccess->encodeSpeculation->graph->forConstant
DeoptimizeNode#getSpeculation()::: deoptimize node get speculation:::return
DeoptimizeNode#deopt(DeoptimizationAction, DeoptimizationReason)::: deoptimize node deopt:::
DeoptimizingFixedWithNextNode#stateBefore()::: deoptimizing fixed with next node state before:::return
DeoptimizingFixedWithNextNode#setStateBefore(FrameState)::: deoptimizing fixed with next node set state before:::updateUsages
DeoptimizingGuard#getCondition()::: deoptimizing guard get condition:::
DeoptimizingGuard#setCondition(LogicNode, boolean)::: deoptimizing guard set condition:::
DeoptimizingGuard#isNegated()::: deoptimizing guard is negated:::
DeoptimizingGuard#getNoDeoptSuccessorPosition()::: deoptimizing guard get no deopt successor position:::
DeoptimizingGuard#setNoDeoptSuccessorPosition(NodeSourcePosition)::: deoptimizing guard set no deopt successor position:::
DeoptimizingGuard#addCallerToNoDeoptSuccessorPosition(NodeSourcePosition)::: deoptimizing guard add caller to no deopt successor position:::noDeoptSuccessorPosition->getNoDeoptSuccessorPosition->if->return->noDeoptSuccessorPosition->getMethod->noDeoptSuccessorPosition->getBCI->new->NodeSourcePosition->setNoDeoptSuccessorPosition
DeoptimizingNode#canDeoptimize():::Determines if this node needs deoptimization information.:::
DeoptimizingNode.DeoptBefore#setStateBefore(FrameState):::Sets the FrameState describing the program state before the execution of this node.:::
DeoptimizingNode.DeoptBefore#stateBefore()::: deopt before state before:::
DeoptimizingNode.DeoptDuring#stateDuring()::: deopt during state during:::
DeoptimizingNode.DeoptDuring#setStateDuring(FrameState):::Sets the FrameState describing the program state during the execution of this node.:::
DeoptimizingNode.DeoptDuring#computeStateDuring(FrameState):::Compute the FrameState describing the program state during the execution of this node from an input FrameState describing the program state after finishing the execution of this node.:::
DirectCallTargetNode#targetName()::: direct call target node target name:::return->targetMethod->format
DynamicDeoptimizeNode#getActionAndReason()::: dynamic deoptimize node get action and reason:::return
DynamicDeoptimizeNode#getSpeculation()::: dynamic deoptimize node get speculation:::return
DynamicDeoptimizeNode#getActionAndReason(MetaAccessProvider)::: dynamic deoptimize node get action and reason:::return->getActionAndReason
DynamicDeoptimizeNode#getSpeculation(MetaAccessProvider)::: dynamic deoptimize node get speculation:::return->getSpeculation
DynamicDeoptimizeNode#lower(LoweringTool)::: dynamic deoptimize node lower:::tool->getLowerer->lower
DynamicDeoptimizeNode#generate(NodeLIRBuilderTool)::: dynamic deoptimize node generate:::generator->getLIRGeneratorTool->generator->operand->generator->operand->generator->state->emitDeoptimize
DynamicDeoptimizeNode#canonical(CanonicalizerTool)::: dynamic deoptimize node canonical:::if->actionAndReason->isConstant->speculation->isConstant->constant->actionAndReason->asJavaConstant->speculationConstant->speculation->asJavaConstant->newDeopt->tool->getMetaAccess->decodeDeoptAction->tool->getMetaAccess->decodeDeoptReason->tool->getMetaAccess->decodeDebugId->tool->getMetaAccess->graph->getSpeculationLog->decodeSpeculation->stateBefore->new->DeoptimizeNode->return->return
DynamicPiNode#create(Assumptions, ConstantReflectionProvider, ValueNode, GuardingNode, ValueNode, boolean)::: dynamic pi node create:::synonym->findSynonym->if->return->return->new->DynamicPiNode
DynamicPiNode#create(Assumptions, ConstantReflectionProvider, ValueNode, GuardingNode, ValueNode)::: dynamic pi node create:::return->create
DynamicPiNode#isExact()::: dynamic pi node is exact:::return
DynamicPiNode#findSynonym(Assumptions, ConstantReflectionProvider, ValueNode, GuardingNode, ValueNode, boolean)::: dynamic pi node find synonym:::if->typeMirror->isConstant->t->constantReflection->typeMirror->asConstant->asJavaType->if->staticPiStamp->if->t->isPrimitive->StampFactory->alwaysNull->else->type->TypeReference->createExactTrusted->TypeReference->createTrusted->StampFactory->object->return->PiNode->create->return
DynamicPiNode#canonical(CanonicalizerTool)::: dynamic pi node canonical:::synonym->tool->getAssumptions->tool->getConstantReflection->findSynonym->if->return->return
EncodedGraph#getEncoding()::: encoded graph get encoding:::return
EncodedGraph#getStartOffset()::: encoded graph get start offset:::return
EncodedGraph#getObjects()::: encoded graph get objects:::return
EncodedGraph#getNumObjects()::: encoded graph get num objects:::return
EncodedGraph#getObject(int)::: encoded graph get object:::return
EncodedGraph#getNodeClasses()::: encoded graph get node classes:::return
EncodedGraph#getAssumptions()::: encoded graph get assumptions:::return
EncodedGraph#getInlinedMethods()::: encoded graph get inlined methods:::return
EncodedGraph#trackNodeSourcePosition()::: encoded graph track node source position:::return
EncodedGraph#getFields()::: encoded graph get fields:::return
EncodedGraph#hasUnsafeAccess()::: encoded graph has unsafe access:::return
EncodedGraph#isCallToOriginal(ResolvedJavaMethod)::: encoded graph is call to original:::return
EntryMarkerNode#generate(NodeLIRBuilderTool)::: entry marker node generate:::throw->new->GraalError
EntryMarkerNode#anchored()::: entry marker node anchored:::return->super->anchored->if->proxyNode->return->return->filter
EntryMarkerNode#prepareDelete(FixedNode)::: entry marker node prepare delete:::foreach->usages->filter->snapshot->proxy->proxy->proxy->value->replaceAndDelete->super->prepareDelete
EntryProxyNode#value()::: entry proxy node value:::return
EntryProxyNode#getOriginalNode()::: entry proxy node get original node:::return->value
EntryProxyNode#getGuard()::: entry proxy node get guard:::return
FieldLocationIdentity#isImmutable()::: field location identity is immutable:::return
FieldLocationIdentity#equals(Object)::: field location identity equals:::if->return->if->fieldLocationIdentity->return->inner->equals->return
FieldLocationIdentity#getField()::: field location identity get field:::return
FieldLocationIdentity#hashCode()::: field location identity hash code:::return->inner->hashCode
FieldLocationIdentity#toString()::: field location identity to string:::return->inner->format->isImmutable
FixedGuardNode#simplify(SimplifierTool)::: fixed guard node simplify:::super->simplify->if->getCondition->c->getCondition->if->c->getValue->isNegated->currentNext->this->next->if->tool->deleteBranch->deopt->graph->getAction->getReason->getSpeculation->new->DeoptimizeNode->add->deopt->stateBefore->setStateBefore->setNext->this->replaceAtUsages->graph->removeFixed->else->if->getCondition->shortCircuitOr->getCondition->if->isNegated->hasNoUsages->graph->graph->shortCircuitOr->getY->getReason->getAction->getSpeculation->shortCircuitOr->isYNegated->getNoDeoptSuccessorPosition->new->FixedGuardNode->add->addAfterFixed->graph->graph->shortCircuitOr->getX->getReason->getAction->getSpeculation->shortCircuitOr->isXNegated->getNoDeoptSuccessorPosition->new->FixedGuardNode->add->replaceFixedWithFixed
FixedGuardNode#lower(LoweringTool)::: fixed guard node lower:::try->position->this->withNodeSourcePosition->if->graph->getGuardsStage->allowsFloatingGuards->if->getAction->guard->tool->getCondition->getReason->getAction->getSpeculation->isNegated->getNoDeoptSuccessorPosition->createGuard->asNode->this->replaceAtUsages->graph->removeFixed->else->lowerToIf->lower->catch->finally
FixedGuardNode#canDeoptimize()::: fixed guard node can deoptimize:::return
FixedGuardNode#getNextSwitchFoldableBranch()::: fixed guard node get next switch foldable branch:::return->next
FixedGuardNode#isInSwitch(ValueNode)::: fixed guard node is in switch:::return->hasNoUsages->isNegated->SwitchFoldable->condition->maybeIsInSwitch->SwitchFoldable->condition->sameSwitchValue
FixedGuardNode#cutOffCascadeNode()::: fixed guard node cut off cascade node:::
FixedGuardNode#cutOffLowestCascadeNode()::: fixed guard node cut off lowest cascade node:::setNext
FixedGuardNode#isDefaultSuccessor(AbstractBeginNode)::: fixed guard node is default successor:::return->beginNode->next->next
FixedGuardNode#getDefault()::: fixed guard node get default:::defaultNode->next->setNext->return->BeginNode->begin
FixedGuardNode#switchValue()::: fixed guard node switch value:::if->SwitchFoldable->condition->maybeIsInSwitch->return->condition->getX->return
FixedGuardNode#isNonInitializedProfile()::: fixed guard node is non initialized profile:::return
FixedGuardNode#intKeyAt(int)::: fixed guard node int key at:::return->condition->getY->asJavaConstant->asInt
FixedGuardNode#keyProbability(int)::: fixed guard node key probability:::return
FixedGuardNode#keySuccessor(int)::: fixed guard node key successor:::deopt->getAction->getReason->getSpeculation->new->DeoptimizeNode->deopt->getNodeSourcePosition->setNodeSourcePosition->begin->new->BeginNode->return
FixedGuardNode#defaultProbability()::: fixed guard node default probability:::return
FixedNode#verify()::: fixed node verify:::this->successors->isNotEmpty->this->predecessor->assertTrue->return->super->verify
FixedNode#asNode()::: fixed node as node:::return
FixedNodeInterface#asNode()::: fixed node interface as node:::
FixedWithNextNode#next()::: fixed with next node next:::return
FixedWithNextNode#setNext(FixedNode)::: fixed with next node set next:::updatePredecessor
FixedWithNextNode#asNode()::: fixed with next node as node:::return
FloatingAnchoredNode#getAnchor()::: floating anchored node get anchor:::return
FloatingAnchoredNode#setAnchor(AnchoringNode)::: floating anchored node set anchor:::updateUsagesInterface
FloatingGuardedNode#getGuard()::: floating guarded node get guard:::return
FloatingGuardedNode#setGuard(GuardingNode)::: floating guarded node set guard:::updateUsagesInterface
FrameState#verifyAfterExceptionState()::: frame state verify after exception state:::if->for->i
FrameState#createValues(ValueNode[], ValueNode[], ValueNode[])::: frame state create values:::index->for->i->for->i->for->i
FrameState#values()::: frame state values:::return
FrameState#monitorIds()::: frame state monitor ids:::return
FrameState#outerFrameState()::: frame state outer frame state:::return
FrameState#setOuterFrameState(FrameState)::: frame state set outer frame state:::updateUsages
FrameState#toSourcePosition(FrameState)::: frame state to source position:::if->return->return->fs->outerFrameState->toSourcePosition->getMethod->new->NodeSourcePosition
FrameState#rethrowException()::: frame state rethrow exception:::return
FrameState#duringCall()::: frame state during call:::return
FrameState#getCode()::: frame state get code:::return
FrameState#getMethod()::: frame state get method:::return->code->getMethod
FrameState#canProduceBytecodeFrame():::Determines if this frame state can be converted to a BytecodeFrame:::return->code->getCode->code->getMethod->getCode
FrameState#addVirtualObjectMapping(EscapeObjectState)::: frame state add virtual object mapping:::if->new->NodeInputList<>->virtualObjectMappings->add
FrameState#virtualObjectMappingCount()::: frame state virtual object mapping count:::if->return->return->virtualObjectMappings->size
FrameState#virtualObjectMappingAt(int)::: frame state virtual object mapping at:::return->virtualObjectMappings->get
FrameState#virtualObjectMappings()::: frame state virtual object mappings:::return
FrameState#duplicate(int):::Gets a copy of this frame state.:::return->graph->outerFrameState->new->FrameState->add
FrameState#duplicate():::Gets a copy of this frame state.:::return->duplicate
FrameState#duplicateWithVirtualState():::Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer FrameStates, VirtualObjectStates, ...).:::newOuterFrameState->outerFrameState->if->newOuterFrameState->duplicateWithVirtualState->newVirtualMappings->if->virtualObjectMappings->size->new->ArrayList<>->foreach->newVirtualMappings->state->duplicateWithVirtualState->add->return->graph->new->FrameState->add
FrameState#duplicateModifiedDuringCall(int, JavaKind):::Creates a copy of this frame state with one stack element of type popKind popped from the stack.:::return->graph->duplicateModified
FrameState#duplicateModifiedBeforeCall(int, JavaKind, JavaKind[], ValueNode[])::: frame state duplicate modified before call:::return->graph->duplicateModified
FrameState#duplicateModified(int, boolean, JavaKind, JavaKind[], ValueNode[]):::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack:::return->graph->duplicateModified
FrameState#duplicateModified(int, boolean, boolean, JavaKind, JavaKind[], ValueNode[])::: frame state duplicate modified:::return->graph->duplicateModified
FrameState#duplicateModified(JavaKind, JavaKind, ValueNode):::Creates a copy of this frame state with the top of stack replaced with with pushedValue which must be of type popKind.:::return->graph->new->JavaKindArr->new->ValueNodeArr->duplicateModified
FrameState#duplicateModified(StructuredGraph, int, boolean, boolean, JavaKind, JavaKind[], ValueNode[]):::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack:::copy->if->values->subList->new->ArrayList<>->else->values->subList->new->ArrayList<>->if->if->stackSize->stackAt->copy->copy->size->remove->lastSlot->copy->copy->size->get->copy->copy->size->remove->if->for->i->newStackSize->copy->size->copy->values->values->size->subList->addAll->return->graph->outerFrameState->new->FrameState->add
FrameState#checkStackDepth(int, int, boolean, boolean, int, int, boolean, boolean):::Perform a few sanity checks on the transformation of the stack state:::if->BytecodeFrame->isPlaceholderBci->return->codes->code->getCode->if->return->newCode->if->else->oldCode->return
FrameState#localsSize():::Gets the size of the local variables.:::return
FrameState#stackSize():::Gets the current size (height) of the stack.:::return
FrameState#locksSize():::Gets the number of locked monitors in this frame state.:::return->values->size
FrameState#nestedLockDepth():::Gets the number of locked monitors in this frame state and all #outerFrameState() outer frame states.:::depth->locksSize->for->outer->outerFrameState->outer->outerFrameState->return
FrameState#localAt(int):::Gets the value in the local variables at the specified index.:::return->values->get
FrameState#stackAt(int):::Get the value on the stack at the specified stack index.:::return->values->get
FrameState#lockAt(int):::Get the monitor owner at the specified index.:::return->values->get
FrameState#monitorIdAt(int):::Get the MonitorIdNode that corresponds to the locked object at the specified index.:::return->monitorIds->get
FrameState#monitorIdCount()::: frame state monitor id count:::if->return->else->return->monitorIds->size
FrameState#innerFrameStates()::: frame state inner frame states:::return->usages->filter
FrameState#toString(FrameState)::: frame state to string:::sb->new->StringBuilder->nl->fs->while->Bytecode->fs->getCode->appendLocation->if->BytecodeFrame->isPlaceholderBci->sb->append->getPlaceholderBciName->append->sb->append->sb->append->for->i->fs->localsSize->sb->append->append->append->for->i->fs->stackSize->sb->append->append->append->for->i->fs->locksSize->sb->append->append->fs->outerFrameState->return->sb->toString
FrameState#toString(Verbosity)::: frame state to string:::if->return->toString->else->if->res->super->toString->if->BytecodeFrame->isPlaceholderBci->getPlaceholderBciName->return->else->return->super->toString
FrameState#getDebugProperties(Map)::: frame state get debug properties:::properties->super->getDebugProperties->if->ste->code->asStackTraceElement->if->ste->getFileName->ste->getLineNumber->properties->ste->getFileName->put->properties->ste->getLineNumber->put->if->isPlaceholderBci->properties->getPlaceholderBciName->put->properties->values->size->put->return
FrameState#verify()::: frame state verify:::if->virtualObjectMappingCount->foreach->virtualObjectMappings->assertTrue->graph->graph->method->Objects->graph->method->code->getMethod->equals->graph->method->getAnnotation->code->getMethod->graph->method->assertTrue->if->monitorIds->monitorIds->size->depth->outerLockDepth->foreach->monitorIds->monitor->getLockDepth->assertTrue->locksSize->monitorIdCount->assertTrue->foreach->value->isDeleted->assertTrue->value->getStackKind->assertTrue->verifyAfterExceptionState->return->super->verify
FrameState#outerLockDepth()::: frame state outer lock depth:::depth->outer->while->outer->monitorIdCount->return
FrameState#applyToNonVirtual(NodeClosure)::: frame state apply to non virtual:::foreach->if->closure->apply->if->foreach->if->closure->apply->if->foreach->state->applyToNonVirtual->if->outerFrameState->outerFrameState->applyToNonVirtual
FrameState#applyToVirtual(VirtualClosure)::: frame state apply to virtual:::closure->apply->if->foreach->state->applyToVirtual->if->outerFrameState->outerFrameState->applyToVirtual
FrameState#isPartOfThisState(VirtualState)::: frame state is part of this state:::if->return->if->outerFrameState->outerFrameState->isPartOfThisState->return->if->foreach->if->objectState->isPartOfThisState->return->return
FrameState#isExceptionHandlingBCI()::: frame state is exception handling i:::return
FullInfopointNode#getReason()::: full infopoint node get reason:::return
FullInfopointNode#setEscapedReturnValue(ValueNode)::: full infopoint node set escaped return value:::updateUsages
FullInfopointNode#simplify(SimplifierTool)::: full infopoint node simplify:::if->state->outerFrameState->returnValue->setEscapedReturnValue->tool->removeIfUnused
FullInfopointNode#generate(NodeLIRBuilderTool)::: full infopoint node generate:::generator->visitFullInfopointNode
FullInfopointNode#getState()::: full infopoint node get state:::return
FullInfopointNode#verify()::: full infopoint node verify:::return->super->verify
GetObjectAddressNode#get(Object)::: get object address node get:::
GetObjectAddressNode#generate(NodeLIRBuilderTool)::: get object address node generate:::obj->gen->getLIRGeneratorTool->LIRKind->gen->getLIRGeneratorTool->target->getWordKind->unknownReference->newVariable->gen->getLIRGeneratorTool->gen->operand->emitMove->gen->setResult
GetObjectAddressNode#verify()::: get object address node verify:::return->super->verify
GraphDecoder.MethodScope#isInlinedMethod()::: method scope is inlined method:::return
GraphDecoder.MethodScope#getCallerBytecodePosition()::: method scope get caller bytecode position:::return->getCallerBytecodePosition
GraphDecoder.MethodScope#getCallerBytecodePosition(NodeSourcePosition)::: method scope get caller bytecode position:::return
GraphDecoder.LoopScope#toString()::: loop scope to string:::return
GraphDecoder.LoopExplosionState#equals(Object)::: loop explosion state equals:::if->return->otherState->thisState->thisIter->thisState->values->iterator->otherIter->otherState->values->iterator->while->thisIter->hasNext->otherIter->hasNext->thisValue->ProxyPlaceholder->thisIter->next->unwrap->otherValue->ProxyPlaceholder->otherIter->next->unwrap->if->return->return->thisIter->hasNext->otherIter->hasNext
GraphDecoder.LoopExplosionState#hashCode()::: loop explosion state hash code:::return
GraphDecoder.ProxyPlaceholder#setValue(ValueNode)::: proxy placeholder set value:::updateUsages
GraphDecoder.ProxyPlaceholder#canonical(CanonicalizerTool)::: proxy placeholder canonical:::if->tool->allUsagesAvailable->return->else->return
GraphDecoder.ProxyPlaceholder#unwrap(ValueNode)::: proxy placeholder unwrap:::result->while->return
GraphDecoder#decode(EncodedGraph)::: graph decoder decode:::try->scope->debug->scope->methodScope->new->MethodScope->createInitialLoopScope->decode->cleanupGraph->catch->debug->handle->finally
GraphDecoder#createInitialLoopScope(MethodScope, FixedWithNextNode)::: graph decoder create initial loop scope:::loopScope->new->LoopScope->firstNode->if->AbstractBeginNode->prevBegin->registerNode->makeStubNode->startNode->setNext->set->else->graph->start->registerNode->set->return
GraphDecoder#decode(LoopScope)::: graph decoder decode:::loopScope->while->methodScope->while->while->isEmpty->processNextNode->if->isEmpty->removeFirst->else->propagateCreatedNodes->if->loopDetector->new->LoopDetector->loopDetector->run->if->methodScope->isInlinedMethod->finishInlining
GraphDecoder#finishInlining(MethodScope)::: graph decoder finish inlining:::
GraphDecoder#propagateCreatedNodes(LoopScope)::: graph decoder propagate created nodes:::if->return->for->i
GraphDecoder#processNextNode(MethodScope, LoopScope)::: graph decoder process next node:::nodeOrderId->nextSetBit->clear->node->lookupNode->if->node->isDeleted->return->if->forwardEndCount->merge->singleEnd->merge->forwardEndAt->AbstractBeginNode->prevBegin->registerNode->next->makeStubNode->singleEnd->replaceAtPredecessor->merge->safeDelete->singleEnd->safeDelete->return->successorAddScope->updatePredecessors->if->if->outerScope->nextIterationNumber->isEmpty->getLast->Arrays->copyOf->Arrays->copyOf->new->LoopScope->checkLoopExplosionIteration->for->id->nextSetBit->nextSetBit->addLast->else->setByteIndex->typeId->getUVInt->makeFixedNodeInputs->readProperties->makeSuccessorStubs->resultScope->if->if->handleLoopExplosionBegin->else->if->if->handleLoopExplosionProxyNodes->else->handleProxyNodes->else->if->handleMergeNode->else->if->phiInputScope->phiNodeScope->if->handleLoopExplosionEnd->getLast->mergeOrderId->readOrderId->merge->lookupNode->if->makeStubNode->if->Arrays->copyOf->Arrays->copyOf->new->ArrayDeque<>->EconomicMap->create->new->LoopScope->if->registerNode->clear->set->handlePhiFunctions->else->if->invokeData->readInvokeData->handleInvoke->else->if->add->else->handleFixedNode->return
GraphDecoder#readInvokeData(MethodScope, int, Invoke)::: graph decoder read invoke data:::contextType->readObject->callTargetOrderId->readOrderId->stateAfterOrderId->readOrderId->nextOrderId->readOrderId->if->nextNextOrderId->readOrderId->exceptionOrderId->readOrderId->exceptionStateOrderId->readOrderId->exceptionNextOrderId->readOrderId->return->new->InvokeData->else->return->new->InvokeData
GraphDecoder#handleInvoke(MethodScope, LoopScope, InvokeData):::Invoke nodes do not have the CallTargetNode, FrameState, and successors encoded:::callTarget->ensureNodeCreated->appendInvoke->return
GraphDecoder#appendInvoke(MethodScope, LoopScope, InvokeData, CallTargetNode)::: graph decoder append invoke:::if->setCallTarget->else->setCallTarget->ensureNodeCreated->setStateAfter->makeStubNode->setNext->if->makeStubNode->setExceptionEdge
GraphDecoder#handleMergeNode(MergeNode):::Hook for subclasses to perform simplifications for a non-loop-header control flow merge.:::
GraphDecoder#handleLoopExplosionBegin(MethodScope, LoopScope, LoopBeginNode)::: graph decoder handle loop explosion begin:::checkLoopExplosionIteration->predecessors->loopBegin->forwardEnds->snapshot->successor->loopBegin->next->frameState->loopBegin->stateAfter->if->queryState->new->LoopExplosionState->existingState->get->if->loopBegin->replaceAtUsagesAndDelete->successor->safeDelete->foreach->addForwardEnd->return->merge->graph->new->MergeNode->add->add->if->if->size->if->throw->new->PermanentBailoutException->newFrameStateValues->new->ArrayList<>->foreach->if->frameStateValue->isConstant->graph->isNew->newFrameStateValues->add->else->newFrameStateValue->graph->new->ProxyPlaceholder->unique->newFrameStateValues->add->for->i->if->for->i->newFrameState->graph->frameState->outerFrameState->frameState->getCode->frameState->localsSize->frameState->stackSize->frameState->rethrowException->frameState->duringCall->frameState->monitorIds->frameState->virtualObjectMappings->new->FrameState->add->frameState->replaceAtUsagesAndDelete->loopBegin->replaceAtUsagesAndDelete->merge->setStateAfter->merge->setNext->foreach->merge->addForwardEnd->if->explosionState->new->LoopExplosionState->put
GraphDecoder#checkLoopExplosionIteration(MethodScope, LoopScope):::Hook for subclasses.:::throw->shouldNotReachHere
GraphDecoder#handleLoopExplosionEnd(MethodScope, LoopScope, LoopEndNode)::: graph decoder handle loop explosion end:::replacementNode->graph->new->EndNode->add->loopEnd->replaceAtPredecessor->loopEnd->safeDelete->if->isEmpty->nextIterationNumber->isEmpty->getLast->nextIterationScope->Arrays->copyOf->Arrays->copyOf->new->LoopScope->checkLoopExplosionIteration->addLast->registerNode->makeStubNode->return
GraphDecoder#handleFixedNode(MethodScope, LoopScope, int, FixedNode):::Hook for subclasses.:::
GraphDecoder#handleProxyNodes(MethodScope, LoopScope, LoopExitNode)::: graph decoder handle proxy nodes:::stateAfterOrderId->readOrderId->loopExit->ensureNodeCreated->setStateAfter->numProxies->getUVInt->for->i
GraphDecoder#handleLoopExplosionProxyNodes(MethodScope, LoopScope, LoopScope, LoopExitNode, int)::: graph decoder handle loop explosion proxy nodes:::stateAfterOrderId->readOrderId->begin->graph->new->BeginNode->add->loopExitSuccessor->loopExit->next->loopExit->replaceAtPredecessor->loopExitPlaceholder->if->graph->new->MergeNode->add->add->end->graph->new->EndNode->add->begin->setNext->loopExitPlaceholder->addForwardEnd->graph->new->BeginNode->add->loopExitPlaceholder->setNext->merge->existingExit->lookupNode->if->registerNode->begin->setNext->else->if->graph->new->MergeNode->add->registerNode->firstEnd->graph->new->EndNode->add->setNext->merge->addForwardEnd->merge->setNext->else->if->end->graph->new->EndNode->add->begin->setNext->merge->addForwardEnd->numProxies->getUVInt->phiCreated->for->i->if->registerNode->loopExitPlaceholder->ensureNodeCreated->setStateAfter->if->merge->stateAfter->oldStateAfter->merge->stateAfter->registerNode->merge->ensureNodeCreated->setStateAfter->if->oldStateAfter->safeDelete->loopExit->safeDelete->if->merge->getNodeClass->getSuccessorEdges->update->else->begin->getNodeClass->getSuccessorEdges->update
GraphDecoder#handlePhiFunctions(MethodScope, LoopScope, LoopScope, AbstractEndNode, AbstractMergeNode)::: graph decoder handle phi functions:::if->numEnds->loopEnds->count->else->if->new->NodeInputList<>->merge->addForwardEnd->lazyPhi->allowLazyPhis->numPhis->getUVInt->for->i
GraphDecoder#allowLazyPhis()::: graph decoder allow lazy phis:::return
GraphDecoder#readProperties(MethodScope, Node)::: graph decoder read properties:::position->readObject->fields->node->getNodeClass->getData->for->pos->fields->getCount->if->graph->trackNodeSourcePosition->callerBytecodePosition->methodScope->getCallerBytecodePosition->node->setNodeSourcePosition->if->callerBytecodePosition->getCaller->addCallerToNoDeoptSuccessorPosition
GraphDecoder#makeFixedNodeInputs(MethodScope, LoopScope, Node):::Process the input edges of a node:::edges->node->getNodeClass->getInputEdges->for->index->edges->getDirectCount->if->else->for->index->edges->getDirectCount->edges->getCount
GraphDecoder#makeFloatingNodeInputs(MethodScope, LoopScope, Node)::: graph decoder make floating node inputs:::edges->node->getNodeClass->getInputEdges->if->edges->edges->getDirectCount->new->NodeInputList<>->initializeList->else->for->index->edges->getDirectCount->for->index->edges->getDirectCount->edges->getCount
GraphDecoder#ensureNodeCreated(MethodScope, LoopScope, int)::: graph decoder ensure node created:::if->return->node->lookupNode->if->return->decodeFloatingNode->if->graph->addWithoutUnique->else->newNode->handleFloatingNodeBeforeAdd->if->releaseFloatingNode->if->newNode->isAlive->addFloatingNode->handleFloatingNodeAfterAdd->registerNode->return
GraphDecoder#addFloatingNode(MethodScope, Node)::: graph decoder add floating node:::return->graph->addWithoutUnique
GraphDecoder#decodeFloatingNode(MethodScope, LoopScope, int):::Decodes a non-fixed node, but does not do any post-processing and does not register it.:::readerByteIndex->getByteIndex->setByteIndex->nodeClass->getNodeClasses->getUVInt->node->allocateFloatingNode->if->throw->node->getClass->getName->shouldNotReachHere->makeFloatingNodeInputs->readProperties->setByteIndex->return
GraphDecoder#allocateFloatingNode(NodeClass)::: graph decoder allocate floating node:::cachedNodes->reusableFloatingNodes->get->if->node->cachedNodes->poll->if->return->return->nodeClass->allocateInstance
GraphDecoder#releaseFloatingNode(Node)::: graph decoder release floating node:::cachedNodes->reusableFloatingNodes->node->getNodeClass->get->if->new->ArrayDeque<>->reusableFloatingNodes->node->getNodeClass->put->cachedNodes->push
GraphDecoder#handleFloatingNodeBeforeAdd(MethodScope, LoopScope, Node):::Hook for subclasses to process a non-fixed node before it is added to the graph.:::return
GraphDecoder#handleFloatingNodeAfterAdd(MethodScope, LoopScope, Node):::Hook for subclasses to process a non-fixed node after it is added to the graph:::return
GraphDecoder#makeSuccessorStubs(MethodScope, LoopScope, Node, boolean):::Process successor edges of a node:::edges->node->getNodeClass->getSuccessorEdges->for->index->edges->getDirectCount->for->index->edges->getDirectCount->edges->getCount
GraphDecoder#makeStubNode(MethodScope, LoopScope, int)::: graph decoder make stub node:::if->return->node->lookupNode->if->return->readerByteIndex->getByteIndex->setByteIndex->nodeClass->getNodeClasses->getUVInt->stubNode->nodeClass->allocateInstance->if->graph->trackNodeSourcePosition->stubNode->NodeSourcePosition->graph->method->placeholder->setNodeSourcePosition->graph->add->setByteIndex->registerNode->set->return
GraphDecoder#skipDirectEdge(Node, Edges, int)::: graph decoder skip direct edge:::if->if->edges->type->return->else->if->edges->getType->return->else->if->edges->getType->return->else->if->edges->type->edges->getType->return->return
GraphDecoder#lookupNode(LoopScope, int)::: graph decoder lookup node:::return
GraphDecoder#registerNode(LoopScope, int, Node, boolean, boolean)::: graph decoder register node:::
GraphDecoder#readOrderId(MethodScope)::: graph decoder read order id:::return->getUVInt
GraphDecoder#readObject(MethodScope)::: graph decoder read object:::return->getUVInt->getObject
GraphDecoder#cleanupGraph(MethodScope):::Removes unnecessary nodes from the graph after decoding.:::foreach->graph->getNodes->foreach->merge->usages->filter->snapshot->placeholder->replaceAndDelete
GraphDecoder#verifyEdges()::: graph decoder verify edges:::foreach->graph->getNodes->foreach->node->inputs->foreach->node->successors->foreach->node->usages->if->node->predecessor->return
LoopDetector#run()::: loop detector run:::debug->graph->getDebug->debug->dump->if->return->orderedLoops->findLoops->foreach->if->isEmpty->continue->findLoopExits->if->handleIrreducibleLoop->else->insertLoopNodes->debug->dump->logIrreducibleLoops->debug->dump
LoopDetector#findLoops()::: loop detector find loops:::unorderedLoops->EconomicMap->create->orderedLoops->new->ArrayList<>->findOrCreateLoop->visited->graph->createNodeBitMap->active->graph->createNodeBitMap->stack->new->ArrayDeque<>->visited->mark->stack->push->while->stack->isEmpty->current->stack->peek->if->active->isMarked->stack->pop->active->clear->if->loop->unorderedLoops->get->if->orderedLoops->add->else->active->mark->foreach->current->cfgSuccessors->if->active->isMarked->loop->findOrCreateLoop->add->else->if->visited->isMarked->else->visited->mark->stack->push->return
LoopDetector#findOrCreateLoop(EconomicMap, MergeNode)::: loop detector find or create loop:::loop->unorderedLoops->get->if->new->Loop->unorderedLoops->put->return
LoopDetector#findLoopExits(Loop)::: loop detector find loop exits:::possibleExits->new->ArrayList<>->visited->graph->createNodeBitMap->stack->new->ArrayDeque<>->foreach->stack->push->visited->mark->while->stack->isEmpty->current->stack->pop->if->continue->if->graph->isNew->return->foreach->current->cfgPredecessors->if->innerLoopBegin->loopBegin->if->visited->isMarked->stack->push->visited->mark->foreach->innerLoopBegin->loopExits->possibleExits->add->else->if->visited->isMarked->stack->push->visited->mark->if->foreach->predecessor->cfgSuccessors->possibleExits->add->foreach->if->visited->contains->stack->push->visited->mark->while->stack->isEmpty->current->stack->pop->foreach->current->cfgSuccessors->if->visited->isMarked->else->if->contains->add->else->visited->mark->stack->push
LoopDetector#insertLoopNodes(Loop)::: loop detector insert loop nodes:::merge->stateAfter->merge->stateAfter->duplicate->afterMerge->merge->next->merge->setNext->preLoopEnd->graph->new->EndNode->add->loopBegin->graph->new->LoopBeginNode->add->merge->setNext->loopBegin->addForwardEnd->loopBegin->setNext->loopBegin->setStateAfter->mergePhis->merge->phis->snapshot->loopBeginPhis->mergePhis->size->new->ArrayList<>->for->i->mergePhis->size->foreach->for->i->mergePhis->size->merge->removeEnd->loopEnd->graph->new->LoopEndNode->add->endNode->replaceAndDelete->foreach->loopExplosionMerge->exit->merge->loopExit->graph->new->LoopExitNode->add->exit->replaceAtPredecessor->loopExit->setNext->assignLoopExitState
LoopDetector#assignLoopExitState(LoopExitNode, AbstractMergeNode, AbstractEndNode):::During graph decoding, we create a FrameState for every exploded loop iteration:::oldState->loopExplosionMerge->stateAfter->loopBeginValues->EconomicSet->create->for->state->loopExit->loopBegin->stateAfter->state->outerFrameState->newValues->oldState->values->size->new->ArrayList<>->foreach->oldState->values->value->realValue->ProxyPlaceholder->unwrap->if->loopExplosionMerge->isPhiAtMerge->valueAt->ProxyPlaceholder->unwrap->if->realValue->isConstant->loopBeginValues->contains->graph->isNew->newValues->add->else->GraalError->guarantee->proxyPlaceholder->proxy->ProxyNode->forValue->proxyPlaceholder->setValue->newValues->add->newState->oldState->outerFrameState->oldState->getCode->oldState->localsSize->oldState->stackSize->oldState->rethrowException->oldState->duringCall->oldState->monitorIds->oldState->virtualObjectMappings->new->FrameState->loopExit->graph->add->setStateAfter
LoopDetector#handleIrreducibleLoop(Loop):::Graal does not support irreducible loops (loops with more than one entry point):::loopState->stateAfter->explosionHeadState->stateAfter->loopValues->loopState->values->explosionHeadValues->explosionHeadState->values->loopVariableIndex->loopValue->explosionHeadValue->for->i->loopValues->size->loopVariablePhi->dispatchTable->new->TreeMap<>->unreachableDefaultSuccessor->if->graph->explosionHeadValue->stamp->unrestricted->new->ValuePhiNode->addWithoutUnique->for->i->phiPredecessorCount->oldFrameState->newFrameStateValues->explosionHeadValues->size->new->ArrayList<>->for->i->explosionHeadValues->size->newFrameState->graph->oldFrameState->outerFrameState->oldFrameState->getCode->oldFrameState->localsSize->oldFrameState->stackSize->oldFrameState->rethrowException->oldFrameState->duringCall->oldFrameState->monitorIds->oldFrameState->virtualObjectMappings->new->FrameState->add->oldFrameState->replaceAtUsages->handlerNext->next->setNext->handlerBegin->graph->new->BeginNode->add->handlerBegin->setNext->dispatchTable->asInt->put->graph->new->BeginNode->add->deopt->graph->new->DeoptimizeNode->add->unreachableDefaultSuccessor->setNext->else->for->i->irreducibleLoopSwitch->keyCount->irreducibleLoopSwitch->defaultSuccessor->setNext->irreducibleLoopSwitch->clearSuccessors->irreducibleLoopSwitch->safeDelete->dispatchBegin->graph->new->BeginNode->add->dispatchEnd->graph->new->EndNode->add->dispatchBegin->setNext->addForwardEnd->intLoopValue->asInt->dispatchTable->put->foreach->removeEnd->add->addForwardEnd->loopVariablePhi->addInput->graph->createSwitch->add->setNext
LoopDetector#asInt(ValueNode)::: loop detector as int:::if->node->isConstant->node->asJavaConstant->getJavaKind->throw->bailout->return->node->asJavaConstant->asInt
LoopDetector#bailout(String)::: loop detector bailout:::throw->new->PermanentBailoutException
LoopDetector#createSwitch(ValuePhiNode, SortedMap, AbstractBeginNode)::: loop detector create switch:::numKeys->dispatchTable->size->numSuccessors->switchSuccessors->new->AbstractBeginNodeArr->switchKeys->new->intArr->switchKeyProbabilities->new->doubleArr->switchKeySuccessors->new->intArr->idx->foreach->dispatchTable->entrySet->entry->getValue->entry->getKey->return->new->IntegerSwitchNode
LoopDetector#logIrreducibleLoops():::Print information about irreducible loops, when enabled with -Dgraal.Log=IrreducibleLoops.:::debug->graph->getDebug->try->s->debug->scope->if->debug->isLogEnabled->msg->new->StringBuilder->sep->for->i->irreducibleLoopSwitch->keyCount->debug->log->catch->finally
GraphEncoder#encodeSingleGraph(StructuredGraph, Architecture):::Utility method that does everything necessary to encode a single graph.:::encoder->new->GraphEncoder->encoder->prepare->encoder->finishPrepare->startOffset->encoder->encode->return->encoder->getEncoding->encoder->getObjects->encoder->getNodeClasses->new->EncodedGraph
GraphEncoder#prepare(StructuredGraph):::Must be invoked before #finishPrepare() and #encode.:::objects->graph->getGuardsStage->addObject->foreach->graph->getNodes->nodeClass->node->getNodeClass->nodeClasses->addObject->objects->node->getNodeSourcePosition->addObject->for->i->nodeClass->getData->getCount->if->objects->getContextType->addObject
GraphEncoder#finishPrepare()::: graph encoder finish prepare:::objects->objects->getLength->new->ObjectArr->encodeAll->nodeClasses->nodeClasses->getLength->new->NodeClass<?>Arr->encodeAll
GraphEncoder#getObjects()::: graph encoder get objects:::return
GraphEncoder#getNodeClasses()::: graph encoder get node classes:::return
GraphEncoder#encode(StructuredGraph):::Compresses a graph to a byte array:::nodeOrder->new->NodeOrder->nodeCount->nodeStartOffsets->new->longArr->cursor->getEntries->while->cursor->advance->node->cursor->getKey->orderId->cursor->getValue->writer->getBytesWritten->nodeClass->node->getNodeClass->writer->nodeClasses->getIndex->putUV->nodeClass->getEdges->writeEdges->nodeClass->getData->writeProperties->nodeClass->getEdges->writeEdges->if->end->merge->end->merge->writeOrderId->writer->merge->phis->count->putUV->foreach->merge->phis->phi->valueAt->writeOrderId->writeOrderId->else->if->exit->exit->stateAfter->writeOrderId->writer->exit->proxies->count->putUV->foreach->exit->proxies->writeOrderId->else->if->invoke->invoke->getContextType->writeObjectId->invoke->callTarget->writeOrderId->invoke->stateAfter->writeOrderId->invoke->next->writeOrderId->if->invokeWithExcpetion->exceptionEdge->invokeWithExcpetion->exceptionEdge->invokeWithExcpetion->next->next->writeOrderId->invokeWithExcpetion->exceptionEdge->writeOrderId->exceptionEdge->stateAfter->writeOrderId->exceptionEdge->next->writeOrderId->metadataStart->TypeConversion->writer->getBytesWritten->asS4->writer->putUV->writer->putUV->for->i->graph->getGuardsStage->writeObjectId->return
GraphEncoder#getEncoding()::: graph encoder get encoding:::return->writer->TypeConversion->writer->getBytesWritten->asS4->new->byteArr->toArray
GraphEncoder.NodeOrder#add(Node)::: node order add:::if->orderIds->get->orderIds->set
GraphEncoder#writeProperties(Node, Fields)::: graph encoder write properties:::node->getNodeSourcePosition->writeObjectId->for->idx->fields->getCount
GraphEncoder#writeEdges(Node, Edges, NodeOrder)::: graph encoder write edges:::if->return->for->idx->edges->getDirectCount->if->edges->type->else->for->idx->edges->getDirectCount->edges->getCount
GraphEncoder#writeOrderId(Node, NodeOrder)::: graph encoder write order id:::writer->get->putUV
GraphEncoder#writeObjectId(Object)::: graph encoder write object id:::writer->objects->getIndex->putUV
GraphEncoder#verifyEncoding(StructuredGraph, EncodedGraph):::Verification code that checks that the decoding of an encode graph is the same as the original graph.:::debugContext->originalGraph->getDebug->decodedGraph->originalGraph->getOptions->new->StructuredGraph.Builder->originalGraph->method->method->originalGraph->isSubstitution->setIsSubstitution->originalGraph->trackNodeSourcePosition->trackNodeSourcePosition->build->decoder->new->GraphDecoder->decoder->decode->decodedGraph->verify->try->GraphComparison->verifyGraphsEqual->catch->originalGraph->getDebug->try->scope->debugContext->scope->debugContext->dump->debugContext->dump->catch->finally->throw->finally->return
GraphComparison#verifyGraphsEqual(StructuredGraph, StructuredGraph)::: graph comparison verify graphs equal:::nodeMapping->new->NodeMap<>->workList->new->ArrayDeque<>->expectedGraph->start->actualGraph->start->pushToWorklist->while->workList->isEmpty->pair->workList->removeFirst->expectedNode->pair->getLeft->actualNode->pair->getRight->nodeClass->expectedNode->getNodeClass->if->expectedNode->inputs->actualNode->inputs->verifyNodesEqual->else->if->verifyPhi->else->expectedNode->inputs->actualNode->inputs->verifyNodesEqual->expectedNode->successors->actualNode->successors->verifyNodesEqual->if->actualLoopEnd->else->for->i->nodeClass->getData->getCount->if->expectedNode->usages->actualNode->usages->verifyNodesEqual->if->verifyPhis->return
GraphComparison#verifyPhi(PhiNode, PhiNode, NodeMap, Deque>)::: graph comparison verify phi:::expectedMergeNode->expectedPhi->merge->actualMergeNode->actualPhi->merge->foreach->actualEndNode->nodeMapping->get->if->expectedPhiInput->expectedPhi->valueAt->actualPhiInput->actualPhi->valueAt->verifyNodeEqual
GraphComparison#verifyPhis(AbstractEndNode, AbstractEndNode, NodeMap, Deque>)::: graph comparison verify phis:::expectedMergeNode->expectedEndNode->merge->actualMergeNode->nodeMapping->get->foreach->expectedMergeNode->phis->actualPhi->nodeMapping->get->if->expectedPhiInput->expectedPhi->valueAt->actualPhiInput->actualPhi->valueAt->verifyNodeEqual
GraphComparison#verifyNodesEqual(NodeIterable, NodeIterable, NodeMap, Deque>, boolean)::: graph comparison verify nodes equal:::actualIter->actualNodes->iterator->foreach->actualIter->next->verifyNodeEqual
GraphComparison#verifyNodeEqual(Node, Node, NodeMap, Deque>, boolean)::: graph comparison verify node equal:::if->return->existing->nodeMapping->get->if->else->pushToWorklist
GraphComparison#pushToWorklist(Node, Node, NodeMap, Deque>)::: graph comparison push to worklist:::nodeMapping->set->if->workList->Pair->create->addLast->else->workList->Pair->create->addFirst
GuardedValueNode#object()::: guarded value node object:::return
GuardedValueNode#generate(NodeLIRBuilderTool)::: guarded value node generate:::if->object->getStackKind->object->getStackKind->generator->generator->operand->setResult
GuardedValueNode#inferStamp()::: guarded value node infer stamp:::return->object->stamp->updateStamp
GuardedValueNode#virtualize(VirtualizerTool)::: guarded value node virtualize:::alias->tool->object->getAlias->if->tool->replaceWithVirtual
GuardedValueNode#canonical(CanonicalizerTool)::: guarded value node canonical:::if->getGuard->if->stamp->object->stamp->equals->return->object->else->return->PiNode->object->stamp->create->return
GuardedValueNode#getOriginalNode()::: guarded value node get original node:::return
GuardNode#getCondition():::The instruction that produces the tested boolean value.:::return
GuardNode#setCondition(LogicNode, boolean)::: guard node set condition:::updateUsages
GuardNode#isNegated()::: guard node is negated:::return
GuardNode#getReason()::: guard node get reason:::return
GuardNode#getAction()::: guard node get action:::return
GuardNode#getSpeculation()::: guard node get speculation:::return
GuardNode#setSpeculation(Speculation)::: guard node set speculation:::
GuardNode#toString(Verbosity)::: guard node to string:::if->return->super->toString->else->return->super->toString
GuardNode#canonical(CanonicalizerTool)::: guard node canonical:::if->getCondition->negation->getCondition->return->negation->getValue->getAnchor->new->GuardNode->if->getCondition->c->getCondition->if->c->getValue->return->return
GuardNode#lowerGuard()::: guard node lower guard:::return
GuardNode#negate()::: guard node negate:::
GuardNode#setAction(DeoptimizationAction)::: guard node set action:::
GuardNode#setReason(DeoptimizationReason)::: guard node set reason:::
GuardNode#getNoDeoptSuccessorPosition()::: guard node get no deopt successor position:::return
GuardNode#setNoDeoptSuccessorPosition(NodeSourcePosition)::: guard node set no deopt successor position:::
GuardPhiNode#values()::: guard phi node values:::return
GuardProxyNode#generate(NodeLIRBuilderTool)::: guard proxy node generate:::
GuardProxyNode#setValue(GuardingNode)::: guard proxy node set value:::this->value->asNode->newValue->asNode->updateUsages
GuardProxyNode#value()::: guard proxy node value:::return->value->asNode
GuardProxyNode#createPhi(AbstractMergeNode)::: guard proxy node create phi:::return->graph->new->GuardPhiNode->addWithoutUnique
GuardProxyNode#getOriginalNode()::: guard proxy node get original node:::return->value->asNode
GuardProxyNode#canonical(CanonicalizerTool)::: guard proxy node canonical:::if->return->return
IfNode#condition()::: if node condition:::return
IfNode#setCondition(LogicNode)::: if node set condition:::updateUsages
IfNode#trueSuccessor():::Gets the true successor.:::return
IfNode#falseSuccessor():::Gets the false successor.:::return
IfNode#getTrueSuccessorProbability()::: if node get true successor probability:::return
IfNode#setTrueSuccessor(AbstractBeginNode)::: if node set true successor:::updatePredecessor
IfNode#setFalseSuccessor(AbstractBeginNode)::: if node set false successor:::updatePredecessor
IfNode#successor(boolean):::Gets the node corresponding to the specified outcome of the branch.:::return
IfNode#setTrueSuccessorProbability(double)::: if node set true successor probability:::Math->Math->max->min
IfNode#probability(AbstractBeginNode)::: if node probability:::return
IfNode#generate(NodeLIRBuilderTool)::: if node generate:::gen->emitIf
IfNode#verify()::: if node verify:::condition->assertTrue->trueSuccessor->assertTrue->falseSuccessor->assertTrue->return->super->verify
IfNode#compareCallContext(NodeSourcePosition)::: if node compare call context:::position->getNodeSourcePosition->successor->while->Objects->position->getMethod->successor->getMethod->equals->assertTrue->position->getCaller->successor->getCaller->assertTrue->return
IfNode#verifySourcePosition()::: if node verify source position:::sourcePosition->getNodeSourcePosition->assertTrue->trueSuccessorPosition->trueSuccessor->getNodeSourcePosition->assertTrue->falseSuccessorPosition->falseSuccessor->getNodeSourcePosition->assertTrue->bci->sourcePosition->getBCI->method->sourcePosition->getMethod->bytecode->BytecodeDisassembler->getBytecodeAt->if->Bytecodes->isIfBytecode->return->code->new->ResolvedJavaMethodBytecode->getCode->targetBCI->Bytes->beS2->nextBCI->Bytecodes->lengthOf->matchingSuccessorFound->if->trueSuccessorPosition->getBCI->trueSuccessorPosition->getBCI->compareCallContext->assertTrue->if->falseSuccessorPosition->getBCI->falseSuccessorPosition->getBCI->compareCallContext->assertTrue->assertTrue->trueSuccessorPosition->getBCI->falseSuccessorPosition->getBCI->assertTrue->return
IfNode#eliminateNegation()::: if node eliminate negation:::oldTrueSuccessor->oldFalseSuccessor->getValue->setCondition
IfNode#simplify(SimplifierTool)::: if node simplify:::if->trueSuccessor->next->if->CORRECTED_PROBABILITIES->getDebug->increment->else->if->falseSuccessor->next->if->CORRECTED_PROBABILITIES->getDebug->increment->if->condition->eliminateNegation->if->condition->c->condition->if->c->getValue->tool->falseSuccessor->deleteBranch->tool->trueSuccessor->addToWorkList->graph->trueSuccessor->removeSplit->else->tool->trueSuccessor->deleteBranch->tool->falseSuccessor->addToWorkList->graph->falseSuccessor->removeSplit->return->if->tool->allUsagesAvailable->trueSuccessor->hasNoUsages->falseSuccessor->hasNoUsages->pushNodesThroughIf->if->checkForUnsignedCompare->removeOrMaterializeIf->return->if->removeIntermediateMaterialization->return->if->splitIfAtPhi->return->if->conditionalNodeOptimization->return->if->switchTransformationOptimization->return->if->falseSuccessor->hasNoUsages->falseSuccessor->falseSuccessor->next->falseSuccessor->next->falseSuccessor->intermediateBegin->falseSuccessor->nextIf->intermediateBegin->next->probabilityB->if->if->condition->nextIf->condition->prepareForSwap->bothFalseBegin->nextIf->falseSuccessor->nextIf->setFalseSuccessor->intermediateBegin->setNext->this->setFalseSuccessor->this->replaceAtPredecessor->nextIf->setFalseSuccessor->intermediateBegin->setNext->this->setFalseSuccessor->intermediateBeginPosition->intermediateBegin->getNodeSourcePosition->intermediateBegin->bothFalseBegin->getNodeSourcePosition->setNodeSourcePosition->bothFalseBegin->setNodeSourcePosition->nextIf->setTrueSuccessorProbability->if->this->setTrueSuccessorProbability->else->newProbability->this->Math->min->setTrueSuccessorProbability->return->if->tryEliminateBoxedReferenceEquals->return
IfNode#isUnboxedFrom(MetaAccessProvider, NodeView, ValueNode, ValueNode)::: if node is unboxed from:::if->return->else->if->return->getValue->isUnboxedFrom->else->if->pi->return->pi->getOriginalNode->isUnboxedFrom->else->if->load->integerType->meta->lookupJavaType->if->load->getValue->stamp->javaType->equals->return->load->getValue->isUnboxedFrom->else->return->else->return
IfNode#tryEliminateBoxedReferenceEquals(SimplifierTool):::Attempts to replace the following pattern:   Integer x = ...; Integer y = ...; if ((x == y) || x.equals(y)) { ..:::if->return->meta->tool->getMetaAccess->equalsCondition->x->equalsCondition->getX->y->equalsCondition->getY->integerType->meta->lookupJavaType->view->NodeView->from->if->x->stamp->javaType->equals->y->stamp->javaType->equals->return->if->getTrueSuccessorProbability->return->if->if->trueSuccessor->next->else->return->else->return->unbox->unboxCheck->foreach->falseSuccessor->getBlockNodes->if->return->if->if->else->return->if->continue->fixed->if->fixed->condition->continue->equals->fixed->condition->if->equals->getX->isUnboxedFrom->equals->getY->isUnboxedFrom->equals->getX->isUnboxedFrom->equals->getY->isUnboxedFrom->if->return->graph->LogicConstantNode->contradiction->addOrUniqueWithInputs->setCondition->return
IfNode#getNextSwitchFoldableBranch()::: if node get next switch foldable branch:::return->falseSuccessor
IfNode#isInSwitch(ValueNode)::: if node is in switch:::return->SwitchFoldable->condition->maybeIsInSwitch->SwitchFoldable->condition->sameSwitchValue
IfNode#cutOffCascadeNode()::: if node cut off cascade node:::setTrueSuccessor
IfNode#cutOffLowestCascadeNode()::: if node cut off lowest cascade node:::setFalseSuccessor->setTrueSuccessor
IfNode#getDefault()::: if node get default:::return->falseSuccessor
IfNode#switchValue()::: if node switch value:::if->SwitchFoldable->condition->maybeIsInSwitch->return->condition->getX->return
IfNode#isNonInitializedProfile()::: if node is non initialized profile:::return->getTrueSuccessorProbability
IfNode#intKeyAt(int)::: if node int key at:::return->condition->getY->asJavaConstant->asInt
IfNode#keyProbability(int)::: if node key probability:::return->getTrueSuccessorProbability
IfNode#keySuccessor(int)::: if node key successor:::return->trueSuccessor
IfNode#defaultProbability()::: if node default probability:::return->getTrueSuccessorProbability
IfNode#conditionalNodeOptimization(SimplifierTool):::Try to optimize this as if it were a ConditionalNode.:::if->trueSuccessor->next->falseSuccessor->next->trueEnd->trueSuccessor->next->falseEnd->falseSuccessor->next->if->trueEnd->merge->falseEnd->merge->return->if->trueEnd->merge->return->merge->trueEnd->merge->if->merge->hasExactlyOneUsage->merge->phis->count->return->if->trueSuccessor->anchored->isNotEmpty->falseSuccessor->anchored->isNotEmpty->return->phi->merge->phis->first->falseValue->phi->valueAt->trueValue->phi->valueAt->view->NodeView->from->result->ConditionalNode->phi->stamp->canonicalizeConditional->if->if->result->graph->graph->addOrUniqueWithInputs->proxyReplacement->phi->setValueAt->removeThroughFalseBranch->return->return
IfNode#pushNodesThroughIf(SimplifierTool)::: if node push nodes through if:::do->trueSucc->trueSuccessor->falseSucc->falseSuccessor->if->trueSucc->next->falseSucc->next->trueNext->trueSucc->next->falseNext->falseSucc->next->nodeClass->trueNext->getNodeClass->if->trueNext->getClass->falseNext->getClass->if->else->if->nodeClass->equalInputs->trueNext->valueEquals->falseNext->replaceAtUsages->graph->removeFixed->GraphUtil->unlinkFixedNode->graph->addBeforeFixed->foreach->trueNext->usages->snapshot->if->usage->isAlive->usageNodeClass->usage->getNodeClass->if->usageNodeClass->valueNumberable->usageNodeClass->isLeafNode->newNode->graph->findDuplicate->if->usage->replaceAtUsagesAndDelete->if->usage->isAlive->tool->addToWorkList->continue->break->while
IfNode#checkForUnsignedCompare(SimplifierTool):::Recognize a couple patterns that can be merged into an unsigned compare.:::if->condition->view->NodeView->from->lessThan->condition->y->lessThan->getY->stamp->asConstant->if->asLong->falseSuccessor->next->ifNode2->falseSuccessor->next->if->ifNode2->condition->lessThan2->ifNode2->condition->falseSucc->ifNode2->falseSuccessor->trueSucc->ifNode2->trueSuccessor->below->if->lessThan2->getX->lessThan->getX->lessThan2->getY->stamp->lessThan2->getY->stamp->isPositive->trueSuccessor->sameDestination->graph->lessThan2->getX->lessThan2->getY->new->IntegerBelowNode->unique->tmp->else->if->lessThan2->getY->lessThan->getX->trueSuccessor->sameDestination->positive->lessThan2->getX->asJavaConstant->if->positive->asLong->positive->asLong->positive->getJavaKind->getMaxValue->newLimit->ConstantNode->lessThan2->getX->stamp->positive->asLong->graph->forIntegerStamp->graph->lessThan->getX->new->IntegerBelowNode->unique->if->try->position->ifNode2->withNodeSourcePosition->ifNode2->setTrueSuccessor->ifNode2->setFalseSuccessor->newIfNode->graph->new->IfNode->add->tool->deleteBranch->graph->removeSplit->ifNode2->predecessor->replaceFirstSuccessor->ifNode2->safeDelete->return->catch->finally->else->if->asLong->falseSuccessor->next->ifNode2->falseSuccessor->next->falseSucc->ifNode2->falseSuccessor->trueSucc->ifNode2->trueSuccessor->below->if->ifNode2->condition->x->lessThan->getX->lessThan2->ifNode2->condition->c2->lessThan2->getY->stamp->asConstant->if->lessThan2->getX->asLong->x->stamp->lessThan->getY->stamp->isCompatible->x->stamp->lessThan2->getY->stamp->isCompatible->trueSuccessor->sameDestination->newLimitValue->asLong->asLong->if->CodeUtil->PrimitiveStamp->x->stamp->getBits->maxValue->newLimit->ConstantNode->x->stamp->graph->forIntegerStamp->c1->ConstantNode->x->stamp->asLong->graph->forIntegerStamp->addNode->graph->AddNode->create->addOrUniqueWithInputs->graph->new->IntegerBelowNode->unique->if->try->position->ifNode2->withNodeSourcePosition->ifNode2->setTrueSuccessor->ifNode2->setFalseSuccessor->newIfNode->graph->new->IfNode->add->tool->deleteBranch->graph->removeSplit->ifNode2->predecessor->replaceFirstSuccessor->ifNode2->safeDelete->return->catch->finally->return
IfNode#sameDestination(AbstractBeginNode, AbstractBeginNode):::Check it these two blocks end up at the same place:::next1->succ1->next->next2->succ2->next->if->end1->end2->if->end1->merge->end2->merge->foreach->end1->merge->phis->if->phi->valueAt->phi->valueAt->return->return->else->if->deopt1->deopt2->if->deopt1->getReason->deopt2->getReason->deopt1->getAction->deopt2->getAction->return->else->if->exit1->exit2->if->exit1->loopBegin->exit2->loopBegin->exit1->stateAfter->exit2->stateAfter->exit1->stateAfter->sameDestination->return->else->if->exit1->exit2->if->exit1->result->exit2->result->return->return
IfNode#prepareForSwap(SimplifierTool, LogicNode, LogicNode)::: if node prepare for swap:::debug->a->getDebug->if->instanceOfA->if->isNullNode->if->isNullNode->getValue->instanceOfA->getValue->debug->log->return->else->if->instanceOfB->if->instanceOfA->getValue->instanceOfB->getValue->instanceOfA->type->getType->isInterface->instanceOfB->type->getType->isInterface->instanceOfA->type->getType->instanceOfB->type->getType->isAssignableFrom->instanceOfB->type->getType->instanceOfA->type->getType->isAssignableFrom->debug->instanceOfA->type->instanceOfB->type->log->return->else->if->compareA->conditionA->compareA->condition->asCondition->if->compareA->unorderedIsTrue->return->if->compareB->if->debug->log->return->if->compareB->unorderedIsTrue->return->comparableCondition->conditionB->compareB->condition->asCondition->if->compareB->getX->compareA->getX->compareB->getY->compareA->getY->else->if->compareB->getX->compareA->getY->compareB->getY->compareA->getX->conditionB->mirror->if->combined->conditionA->join->if->debug->log->return->else->if->canSwap->if->compareA->getX->compareB->getX->compareA->getY->compareB->getY->valuesDistinct->else->if->compareA->getX->compareB->getY->compareA->getY->compareB->getX->valuesDistinct->else->if->compareA->getY->compareB->getX->compareA->getX->compareB->getY->valuesDistinct->else->if->compareA->getY->compareB->getY->compareA->getX->compareB->getX->valuesDistinct->if->debug->log->return->return
IfNode#valuesDistinct(SimplifierTool, ValueNode, ValueNode)::: if node values distinct:::if->a->isConstant->b->isConstant->equal->tool->getConstantReflection->a->asConstant->b->asConstant->constantEquals->if->return->equal->booleanValue->view->NodeView->from->stampA->a->stamp->stampB->b->stamp->return->stampA->alwaysDistinct
IfNode#removeOrMaterializeIf(SimplifierTool):::Tries to remove an empty if construct or replace an if construct with a materialization.:::if->trueSuccessor->next->falseSuccessor->next->trueEnd->trueSuccessor->next->falseEnd->falseSuccessor->next->merge->trueEnd->merge->if->falseEnd->merge->trueSuccessor->anchored->isEmpty->falseSuccessor->anchored->isEmpty->singlePhi->distinct->foreach->merge->phis->trueValue->phi->valueAt->falseValue->phi->valueAt->if->if->removeThroughFalseBranch->return->else->if->trueValue->singlePhi->valueAt->falseValue->singlePhi->valueAt->conditional->canonicalizeConditionalCascade->if->proxyReplacement->singlePhi->setValueAt->removeThroughFalseBranch->return->if->trueSuccessor->next->falseSuccessor->next->trueEnd->trueSuccessor->next->falseEnd->falseSuccessor->next->trueValue->trueEnd->result->falseValue->falseEnd->result->value->needsProxy->if->if->else->canonicalizeConditionalCascade->if->return->if->trueSuccessor->loopBegin->trueSuccessor->loopBegin->loopExitNode->graph->new->LoopExitNode->add->graph->addBeforeFixed->if->graph->hasValueProxies->graph->new->ValueProxyNode->addOrUnique->newReturn->graph->new->ReturnNode->add->replaceAtPredecessor->GraphUtil->killCFG->return->return
IfNode#proxyReplacement(ValueNode)::: if node proxy replacement:::if->this->graph->hasValueProxies->if->if->falseSuccessor->anchored->isEmpty->falseSuccessor->hasUsages->foreach->falseSuccessor->usages->snapshot->setProxyPoint->return->this->graph->new->ValueProxyNode->addOrUnique->return
IfNode#removeThroughFalseBranch(SimplifierTool, AbstractMergeNode)::: if node remove through false branch:::trueBegin->trueSuccessor->conditionNode->condition->graph->removeSplitPropagate->tool->addToWorkList->if->GraphUtil->tryKillUnused->if->merge->isAlive->merge->forwardEndCount->foreach->merge->forwardEnds->cur->while->cur->predecessor->cur->predecessor->if->cur->predecessor->tool->cur->predecessor->addToWorkList
IfNode#canonicalizeConditionalViaImplies(ValueNode, ValueNode)::: if node canonicalize conditional via implies:::collapsedTrue->collapsedFalse->simplify->if->result->condition->condition->implies->if->result->isKnown->result->toBoolean->trueValue->falseValue->if->result->condition->condition->implies->if->result->isKnown->result->toBoolean->trueValue->falseValue->if->return->graph->condition->new->ConditionalNode->unique->return
IfNode#canonicalizeConditionalCascade(SimplifierTool, ValueNode, ValueNode)::: if node canonicalize conditional cascade:::if->trueValue->getStackKind->falseValue->getStackKind->return->if->trueValue->getStackKind->trueValue->getStackKind->return->if->trueValue->isConstant->falseValue->isConstant->return->graph->condition->new->ConditionalNode->unique->value->canonicalizeConditionalViaImplies->if->return->if->graph->isAfterExpandLogic->conditional->constant->negateCondition->if->falseValue->isConstant->else->if->trueValue->isConstant->else->return->negateConditionalCondition->otherValue->if->conditional->trueValue->conditional->falseValue->else->if->conditional->falseValue->conditional->trueValue->if->otherValue->isConstant->shortCutProbability->trueSuccessor->probability->newCondition->LogicNode->condition->conditional->condition->or->return->graph->new->ConditionalNode->unique->if->constant->isJavaConstant->conditional->trueValue->isJavaConstant->conditional->falseValue->isJavaConstant->condition->conditional->condition->condition1->condition->cond1->condition1->condition->asCondition->if->cond1->negate->condition2->conditional->condition->cond2->condition2->condition->asCondition->x->condition1->getX->y->condition1->getY->x2->condition2->getX->y2->condition2->getY->sameVars->if->cond2->mirror->if->stackKind->conditional->trueValue->NodeView->from->stamp->getStackKind->c1->constant->asJavaConstant->asLong->c2->conditional->trueValue->asJavaConstant->asLong->c3->conditional->falseValue->asJavaConstant->asLong->cond2->cond1->negate->join->if->return->cond3->cond1->negate->cond2->negate->join->if->return->unsigned->cond1->isUnsigned->cond2->isUnsigned->expected1->expectedConstantForNormalize->expected2->expectedConstantForNormalize->expected3->expectedConstantForNormalize->if->else->if->tmp->else->return->if->minValue->graph->ConstantNode->getStackKind->getMinValue->forIntegerStamp->unique->graph->new->AddNode->unique->graph->new->AddNode->unique->unorderedLess->if->canBeNaN->canBeNaN->unorderedValue->condition1->unorderedIsTrue->condition2->unorderedIsTrue->if->return->return->graph->new->NormalizeCompareNode->unique->return
IfNode#expectedConstantForNormalize(Condition)::: if node expected constant for normalize:::if->return->else->if->return->else->return
IfNode#splitIfAtPhi(SimplifierTool):::Take an if that is immediately dominated by a merge with a single phi and split off any paths where the test would be statically decidable creating a new merge below the appropriate side of the IfNode:::if->predecessor->return->merge->predecessor->if->merge->forwardEndCount->return->if->merge->getUsageCount->merge->phis->count->return->if->graph->getGuardsStage->areFrameStatesAtSideEffects->merge->stateAfter->return->phi->merge->phis->first->if->phi->getUsageCount->return->if->condition->conditionUses->return->trueMerge->falseMerge->foreach->merge->forwardEnds->snapshot->value->phi->valueAt->result->computeCondition->if->merge->removeEnd->if->getValue->if->trueSuccessor->merge->stateAfter->insertMerge->trueMerge->addForwardEnd->else->if->falseSuccessor->merge->stateAfter->insertMerge->falseMerge->addForwardEnd->else->if->trueBegin->graph->new->BeginNode->add->trueBegin->trueSuccessor->getNodeSourcePosition->setNodeSourcePosition->falseBegin->graph->new->BeginNode->add->falseBegin->falseSuccessor->getNodeSourcePosition->setNodeSourcePosition->if->result->graph->graph->addOrUniqueWithInputs->result->condition->getNodeSourcePosition->setNodeSourcePosition->newIfNode->graph->new->IfNode->add->newIfNode->getNodeSourcePosition->setNodeSourcePosition->merge->removeEnd->end->predecessor->setNext->if->trueSuccessor->merge->stateAfter->insertMerge->trueBegin->graph->new->EndNode->add->setNext->trueMerge->trueBegin->next->addForwardEnd->if->falseSuccessor->merge->stateAfter->insertMerge->falseBegin->graph->new->EndNode->add->setNext->falseMerge->falseBegin->next->addForwardEnd->end->safeDelete->trueSuccessor->transferProxies->falseSuccessor->transferProxies->cleanupMerge->cleanupMerge->cleanupMerge->return
IfNode#conditionUses(LogicNode, PhiNode)::: if node condition uses:::if->condition->hasExactlyOneUsage->return->if->if->condition->graph->getGuardsStage->areDeoptsFixed->orNode->return->conditionUses->conditionUses->else->if->unary->return->unary->getValue->else->if->binary->return->binary->getX->binary->getY->return
IfNode#computeCondition(SimplifierTool, LogicNode, PhiNode, Node):::Canonicalize condition using {@code value in place of phi.:::if->if->condition->graph->getGuardsStage->areDeoptsFixed->condition->graph->isAfterExpandLogic->orNode->resultX->computeCondition->resultY->computeCondition->if->result->orNode->canonical->if->return->newOr->orNode->getShortCircuitProbability->new->ShortCircuitOrNode->return->newOr->canonical->return->else->if->compare->if->compare->getX->return->compare->compare->getY->canonical->else->if->compare->getY->return->compare->compare->getX->canonical->else->if->compare->if->compare->getValue->return->compare->canonical->if->return->canonical->return
IfNode#transferProxies(AbstractBeginNode, MergeNode)::: if node transfer proxies:::if->loopExitNode->foreach->loopExitNode->proxies->snapshot->proxy->replaceFirstInput
IfNode#cleanupMerge(MergeNode)::: if node cleanup merge:::if->merge->isAlive->if->merge->forwardEndCount->GraphUtil->killCFG->else->if->merge->forwardEndCount->graph->reduceTrivialMerge
IfNode#insertMerge(AbstractBeginNode, FrameState)::: if node insert merge:::merge->graph->new->MergeNode->add->if->begin->anchored->isEmpty->before->begin->anchored->snapshot->begin->replaceAtUsages->begin->replaceAtUsages->theBegin->if->try->position->begin->withNodeSourcePosition->graph->new->BeginNode->add->begin->replaceAtPredecessor->theBegin->setNext->catch->finally->next->theBegin->next->next->replaceAtPredecessor->theBegin->graph->new->EndNode->add->setNext->merge->theBegin->next->addForwardEnd->merge->setStateAfter->merge->setNext->return
IfNode#removeIntermediateMaterialization(SimplifierTool):::Tries to connect code that initializes a variable directly with the successors of an if construct that switches on the variable:::if->predecessor->predecessor->return->merge->predecessor->if->condition->return->compare->condition->if->compare->getUsageCount->return->mergeUsages->merge->usages->if->mergeUsages->count->return->singleUsage->mergeUsages->first->if->compare->getX->compare->getY->return->phi->phiUsages->phi->usages->if->phiUsages->count->return->foreach->if->merge->stateAfter->return->mergePredecessors->merge->cfgPredecessors->snapshot->xs->compare->getX->constantValues->ys->compare->getY->constantValues->if->return->if->trueSuccessor->checkFrameState->falseSuccessor->checkFrameState->return->falseEnds->mergePredecessors->size->new->ArrayList<>->trueEnds->mergePredecessors->size->new->ArrayList<>->phiValues->EconomicMap->mergePredecessors->size->create->oldFalseSuccessor->falseSuccessor->oldTrueSuccessor->trueSuccessor->setFalseSuccessor->setTrueSuccessor->ends->mergePredecessors->iterator->for->i->connectEnds->connectEnds->if->foreach->propagateZeroProbability->if->foreach->propagateZeroProbability->if->falseEnds->isEmpty->GraphUtil->killCFG->if->trueEnds->isEmpty->GraphUtil->killCFG->GraphUtil->killCFG->return
IfNode#propagateZeroProbability(FixedNode)::: if node propagate zero probability:::prev->foreach->GraphUtil->predecessorIterable->if->ifNode->if->ifNode->trueSuccessor->if->return->else->if->continue->else->ifNode->setTrueSuccessorProbability->return->else->if->ifNode->falseSuccessor->if->return->else->if->continue->else->ifNode->setTrueSuccessorProbability->return->else->throw->new->GraalError->else->if->foreach->cfgPredecessors->propagateZeroProbability->return
IfNode#checkFrameState(FixedNode)::: if node check frame state:::node->while->if->mergeNode->if->mergeNode->stateAfter->return->else->return->else->if->stateSplitNode->if->stateSplitNode->stateAfter->return->if->controlSplitNode->foreach->controlSplitNode->cfgSuccessors->if->checkFrameState->return->return->else->if->fixedWithNextNode->fixedWithNextNode->next->else->if->endNode->endNode->merge->else->if->return->else->return
IfNode#connectEnds(List, EconomicMap, AbstractBeginNode, AbstractMergeNode, SimplifierTool):::Connects a set of ends to a given successor, inserting a merge node if there is more than one end:::if->ends->isEmpty->if->ends->size->end->ends->get->end->predecessor->setNext->oldMerge->removeEnd->GraphUtil->killCFG->else->view->NodeView->from->newMerge->graph->new->MergeNode->add->oldPhi->oldMerge->usages->first->newPhi->graph->oldPhi->stamp->new->ValuePhiNode->addWithoutUnique->foreach->newPhi->phiValues->get->addInput->newMerge->addForwardEnd->stateAfter->oldMerge->stateAfter->if->stateAfter->duplicate->stateAfter->replaceFirstInput->newMerge->setStateAfter->newMerge->setNext->tool->addToWorkList
IfNode#constantValues(ValueNode, AbstractMergeNode, boolean):::Gets an array of constants derived from a node that is either a ConstantNode or a PhiNode whose input values are all constants:::if->node->isConstant->result->merge->forwardEndCount->new->ConstantArr->Arrays->node->asConstant->fill->return->if->phi->if->phi->merge->phi->valueCount->merge->forwardEndCount->result->merge->forwardEndCount->new->ConstantArr->i->foreach->phi->values->if->n->isConstant->return->n->asConstant->return->return
IfNode#getPrimarySuccessor()::: if node get primary successor:::return
IfNode#getSuccessor(boolean)::: if node get successor:::return->this->trueSuccessor->this->falseSuccessor
IfNode#setProbability(AbstractBeginNode, double)::: if node set probability:::if->this->trueSuccessor->this->setTrueSuccessorProbability->return->else->if->this->falseSuccessor->this->setTrueSuccessorProbability->return->return
IfNode#getSuccessorCount()::: if node get successor count:::return
IndirectCallTargetNode#computedAddress()::: indirect call target node computed address:::return
IndirectCallTargetNode#targetName()::: indirect call target node target name:::if->targetMethod->return->return->targetMethod->format
InliningLog.Decision#isPositive()::: decision is positive:::return
InliningLog.Decision#getReason()::: decision get reason:::return
InliningLog.Decision#getPhase()::: decision get phase:::return
InliningLog.Decision#getTarget()::: decision get target:::return
InliningLog.Decision#toString()::: decision to string:::return->String->target->format->format
InliningLog.Callsite#addChild(Invokable)::: callsite add child:::child->new->Callsite->children->add->return
InliningLog.Callsite#positionString()::: callsite position string:::if->if->return->target->format->else->if->invoke->getTargetMethod->return->invoke->getTargetMethod->getName->getBci->else->return->getBci->position->if->MetaUtil->new->StringBuilder->getBci->appendLocation->toString->else->if->invoke->getTargetMethod->invoke->getTargetMethod->getName->getBci->else->getBci->return
InliningLog.Callsite#getBci()::: callsite get bci:::return->invoke->bci
InliningLog#addDecision(Invokable, boolean, String, EconomicMap, InliningLog, String, Object...):::Add an inlining decision for the specified invoke:::if->return->callsite->leaves->get->getTargetMethod->decision->String->format->invoke->getTargetMethod->new->Decision->add->if->leaves->removeKey->if->return->mapping->EconomicMap->create->foreach->child->callsite->addChild->copyTree->entries->getEntries->while->entries->advance->invokeFromCallee->entries->getKey->callsiteFromCallee->entries->getValue->if->invokeFromCallee->asFixedNode->isDeleted->continue->inlinedInvokeFromCallee->replacements->invokeFromCallee->asFixedNode->get->descendant->mapping->get->leaves->put
InliningLog#addLog(UnmodifiableEconomicMap, InliningLog):::Append the inlining decision tree from the specified log:::mapping->EconomicMap->create->foreach->child->root->addChild->copyTree->entries->getEntries->while->entries->advance->replacementInvoke->entries->getKey->replacementCallsite->entries->getValue->if->replacementInvoke->asFixedNode->isDeleted->continue->invoke->replacements->replacementInvoke->asFixedNode->get->callsite->mapping->get->leaves->put
InliningLog#replaceLog(UnmodifiableEconomicMap, InliningLog):::Completely replace the current log with the copy of the specified log:::mapping->EconomicMap->create->copyTree->replacementEntries->getEntries->while->replacementEntries->advance->replacementInvoke->replacementEntries->getKey->replacementSite->replacementEntries->getValue->if->replacementInvoke->isAlive->invoke->replacements->get->site->mapping->get->leaves->put
InliningLog#copyTree(Callsite, Callsite, UnmodifiableEconomicMap, EconomicMap)::: inlining log copy tree:::mapping->put->addAll->isAlive->replacements->asFixedNode->get->foreach->child->new->Callsite->add->copyTree
InliningLog#checkInvariants(StructuredGraph)::: inlining log check invariants:::foreach->graph->getInvokes->checkTreeInvariants
InliningLog#checkTreeInvariants(Callsite)::: inlining log check tree invariants:::foreach->checkTreeInvariants
InliningLog.UpdateScope#activate()::: update scope activate:::if->throw->GraalError->shouldNotReachHere
InliningLog.UpdateScope#close()::: update scope close:::if
InliningLog.UpdateScope#getUpdater()::: update scope get updater:::return
InliningLog#getUpdateScope()::: inlining log get update scope:::if->return->return->currentUpdateScope->getUpdater
InliningLog#openUpdateScope(BiConsumer):::Creates and sets a new update scope for the log:::if->scope->new->UpdateScope->scope->activate->return->else->return
InliningLog#openDefaultUpdateScope():::Creates a new update scope that does not update the log:::if->noUpdates->activate->return->else->return
InliningLog.RootScope#activate()::: root scope activate:::
InliningLog.RootScope#getInvoke()::: root scope get invoke:::return
InliningLog.RootScope#close()::: root scope close:::if->removeLeafCallsite
InliningLog.PlaceholderInvokable#getTargetMethod()::: placeholder invokable get target method:::return
InliningLog.PlaceholderInvokable#bci()::: placeholder invokable bci:::return
InliningLog.PlaceholderInvokable#isAlive()::: placeholder invokable is alive:::return
InliningLog.PlaceholderInvokable#asFixedNode()::: placeholder invokable as fixed node:::throw->new->UnsupportedOperationException
InliningLog#openRootScope(ResolvedJavaMethod, int)::: inlining log open root scope:::return->new->PlaceholderInvokable->openRootScope
InliningLog#openRootScope(Invokable)::: inlining log open root scope:::if->if->leaves->containsKey->trackNewCallsite->scope->leaves->get->new->RootScope->invoke->getTargetMethod->scope->activate->return->else->return
InliningLog#containsLeafCallsite(Invokable)::: inlining log contains leaf callsite:::return->leaves->containsKey
InliningLog#removeLeafCallsite(Invokable)::: inlining log remove leaf callsite:::leaves->removeKey
InliningLog#trackNewCallsite(Invokable)::: inlining log track new callsite:::currentRoot->findCurrentRoot->callsite->new->Callsite->add->leaves->put
InliningLog#findCurrentRoot()::: inlining log find current root:::return
InliningLog#trackDuplicatedCallsite(Invokable, Invokable)::: inlining log track duplicated callsite:::siblingCallsite->leaves->get->parentCallsite->callsite->parentCallsite->addChild->leaves->put
InliningLog#updateExistingCallsite(Invokable, Invokable)::: inlining log update existing callsite:::callsite->leaves->get->leaves->removeKey->leaves->put
InliningLog#formatAsTree(boolean):::Formats the inlining log as a hierarchical tree.:::if->isEmpty->return->builder->new->StringBuilder->formatAsTree->return->builder->toString
InliningLog#formatAsTree(Callsite, String, StringBuilder)::: inlining log format as tree:::position->site->positionString->builder->append->append->append->if->isEmpty->if->builder->append->format->append->append->builder->System->lineSeparator->append->else->if->size->builder->get->toString->append->builder->System->lineSeparator->append->else->builder->System->lineSeparator->append->foreach->node->size->get->builder->append->decision->toString->append->builder->System->lineSeparator->append->foreach->formatAsTree
Invokable#getTargetMethod()::: invokable get target method:::
Invokable#bci()::: invokable bci:::
Invokable#isAlive()::: invokable is alive:::return->asFixedNode->isAlive
Invokable#asFixedNode()::: invokable as fixed node:::
Invokable#updateInliningLogAfterRegister(StructuredGraph):::Called on a Invokable node after it is registered with a graph:::log->newGraph->getInliningLog->if->log->getUpdateScope->log->getUpdateScope->accept->else->log->trackNewCallsite
Invokable#updateInliningLogAfterClone(Node):::Called on a Invokable node after it was cloned from another node:::if->asFixedNode->getOptions->getValue->log->asFixedNode->graph->getInliningLog->if->log->getUpdateScope->log->getUpdateScope->accept->else->if->other->graph->this->asFixedNode->graph->log->removeLeafCallsite->log->trackDuplicatedCallsite->else->throw->GraalError->shouldNotReachHere
Invoke#next()::: invoke next:::
Invoke#setNext(FixedNode)::: invoke set next:::
Invoke#callTarget()::: invoke call target:::
Invoke#bci()::: invoke bci:::
Invoke#predecessor()::: invoke predecessor:::
Invoke#classInit()::: invoke class init:::
Invoke#setClassInit(ValueNode)::: invoke set class init:::
Invoke#useForInlining()::: invoke use for inlining:::
Invoke#setUseForInlining(boolean)::: invoke set use for inlining:::
Invoke#isPolymorphic():::True if this invocation is almost certainly polymorphic, false when in doubt.:::
Invoke#setPolymorphic(boolean)::: invoke set polymorphic:::
Invoke#getTargetMethod()::: invoke get target method:::return->callTarget->callTarget->targetMethod
Invoke#getContextMethod():::Returns the ResolvedJavaMethod method from which this invoke is executed:::state->stateAfter->if->stateDuring->return->state->getMethod
Invoke#getContextType():::Returns the ResolvedJavaType type from which this invoke is executed:::contextMethod->getContextMethod->if->return->return->contextMethod->getDeclaringClass
Invoke#computeStateDuring(FrameState)::: invoke compute state during:::newStateDuring->stateAfter->bci->asNode->getStackKind->duplicateModifiedDuringCall->setStateDuring
Invoke#getReceiver()::: invoke get receiver:::return->callTarget->arguments->get
Invoke#getReceiverType()::: invoke get receiver type:::receiverType->StampTool->getReceiver->typeOrNull->if->callTarget->targetMethod->getDeclaringClass->return
Invoke#getInvokeKind()::: invoke get invoke kind:::return->callTarget->invokeKind
Invoke#replaceBci(int)::: invoke replace bci:::
InvokeNode#replaceBci(int)::: invoke node replace bci:::
InvokeNode#afterClone(Node)::: invoke node after clone:::updateInliningLogAfterClone
InvokeNode#asFixedNode()::: invoke node as fixed node:::return
InvokeNode#callTarget()::: invoke node call target:::return
InvokeNode#setCallTarget(CallTargetNode)::: invoke node set call target:::updateUsages
InvokeNode#isPolymorphic()::: invoke node is polymorphic:::return
InvokeNode#setPolymorphic(boolean)::: invoke node set polymorphic:::
InvokeNode#useForInlining()::: invoke node use for inlining:::return
InvokeNode#setUseForInlining(boolean)::: invoke node set use for inlining:::
InvokeNode#isAllowedUsageType(InputType)::: invoke node is allowed usage type:::if->super->isAllowedUsageType->if->getStackKind->if->targetMethod->getAnnotation->return->return->return
InvokeNode#getDebugProperties(Map)::: invoke node get debug properties:::debugProperties->super->getDebugProperties->if->debugProperties->callTarget->targetName->put->return
InvokeNode#getLocationIdentity()::: invoke node get location identity:::return
InvokeNode#lower(LoweringTool)::: invoke node lower:::tool->getLowerer->lower
InvokeNode#generate(NodeLIRBuilderTool)::: invoke node generate:::gen->emitInvoke
InvokeNode#toString(Verbosity)::: invoke node to string:::if->return->super->toString->bci->else->if->return->callTarget->targetName->else->return->super->toString
InvokeNode#bci()::: invoke node bci:::return
InvokeNode#canDeoptimize()::: invoke node can deoptimize:::return
InvokeNode#stateDuring()::: invoke node state during:::return
InvokeNode#setStateDuring(FrameState)::: invoke node set state during:::updateUsages
InvokeNode#uncheckedStamp()::: invoke node unchecked stamp:::return->returnStamp->getUncheckedStamp
InvokeNode#setClassInit(ValueNode)::: invoke node set class init:::updateUsages
InvokeNode#classInit()::: invoke node class init:::return
InvokeNode#estimatedNodeCycles()::: invoke node estimated node cycles:::if->return->switch->callTarget->invokeKind->return->return->return->return
InvokeNode#estimatedNodeSize()::: invoke node estimated node size:::if->return->switch->callTarget->invokeKind->return->return->return->return
InvokeWithExceptionNode#afterClone(Node)::: invoke with exception node after clone:::updateInliningLogAfterClone
InvokeWithExceptionNode#asFixedNode()::: invoke with exception node as fixed node:::return
InvokeWithExceptionNode#exceptionEdge()::: invoke with exception node exception edge:::return
InvokeWithExceptionNode#setExceptionEdge(AbstractBeginNode)::: invoke with exception node set exception edge:::updatePredecessor
InvokeWithExceptionNode#next()::: invoke with exception node next:::return
InvokeWithExceptionNode#setNext(AbstractBeginNode)::: invoke with exception node set next:::updatePredecessor
InvokeWithExceptionNode#callTarget()::: invoke with exception node call target:::return
InvokeWithExceptionNode#setCallTarget(CallTargetNode)::: invoke with exception node set call target:::updateUsages
InvokeWithExceptionNode#methodCallTarget()::: invoke with exception node method call target:::return
InvokeWithExceptionNode#isPolymorphic()::: invoke with exception node is polymorphic:::return
InvokeWithExceptionNode#setPolymorphic(boolean)::: invoke with exception node set polymorphic:::
InvokeWithExceptionNode#useForInlining()::: invoke with exception node use for inlining:::return
InvokeWithExceptionNode#setUseForInlining(boolean)::: invoke with exception node set use for inlining:::
InvokeWithExceptionNode#toString(Verbosity)::: invoke with exception node to string:::if->return->super->toString->bci->else->if->return->callTarget->targetName->else->return->super->toString
InvokeWithExceptionNode#bci()::: invoke with exception node bci:::return
InvokeWithExceptionNode#setNext(FixedNode)::: invoke with exception node set next:::if->this->KillingBeginNode->getLocationIdentity->begin->setNext->else->this->setNext
InvokeWithExceptionNode#lower(LoweringTool)::: invoke with exception node lower:::tool->getLowerer->lower
InvokeWithExceptionNode#generate(NodeLIRBuilderTool)::: invoke with exception node generate:::gen->emitInvoke
InvokeWithExceptionNode#stateAfter()::: invoke with exception node state after:::return
InvokeWithExceptionNode#setStateAfter(FrameState)::: invoke with exception node set state after:::updateUsages
InvokeWithExceptionNode#hasSideEffect()::: invoke with exception node has side effect:::return
InvokeWithExceptionNode#getLocationIdentity()::: invoke with exception node get location identity:::return->LocationIdentity->any
InvokeWithExceptionNode#getDebugProperties(Map)::: invoke with exception node get debug properties:::debugProperties->super->getDebugProperties->if->debugProperties->callTarget->targetName->put->return
InvokeWithExceptionNode#killExceptionEdge()::: invoke with exception node kill exception edge:::edge->exceptionEdge->setExceptionEdge->GraphUtil->killCFG
InvokeWithExceptionNode#killKillingBegin()::: invoke with exception node kill killing begin:::begin->next->if->try->position->begin->withNodeSourcePosition->newBegin->new->BeginNode->graph->graph->add->addAfterFixed->begin->replaceAtUsages->graph->removeFixed->return->catch->finally->return
InvokeWithExceptionNode#replaceBci(int)::: invoke with exception node replace bci:::
InvokeWithExceptionNode#probability(AbstractBeginNode)::: invoke with exception node probability:::return
InvokeWithExceptionNode#canDeoptimize()::: invoke with exception node can deoptimize:::return
InvokeWithExceptionNode#stateDuring()::: invoke with exception node state during:::return
InvokeWithExceptionNode#setStateDuring(FrameState)::: invoke with exception node set state during:::updateUsages
InvokeWithExceptionNode#getPrimarySuccessor()::: invoke with exception node get primary successor:::return->this->next
InvokeWithExceptionNode#uncheckedStamp()::: invoke with exception node unchecked stamp:::return->returnStamp->getUncheckedStamp
InvokeWithExceptionNode#setClassInit(ValueNode)::: invoke with exception node set class init:::updateUsages
InvokeWithExceptionNode#classInit()::: invoke with exception node class init:::return
InvokeWithExceptionNode#setProbability(AbstractBeginNode, double)::: invoke with exception node set probability:::return
InvokeWithExceptionNode#getSuccessorCount()::: invoke with exception node get successor count:::return
InvokeWithExceptionNode#replaceWithInvoke():::Replaces this InvokeWithExceptionNode with a normal InvokeNode:::newInvoke->graph->getLocationIdentity->new->InvokeNode->add->newInvoke->setStateAfter->newInvoke->setStateDuring->oldException->graph->this->next->replaceSplitWithFixed->GraphUtil->killCFG->return
KillingBeginNode#begin(FixedNode, LocationIdentity)::: killing begin node begin:::if->return->begin->with->graph->KillingBeginNode->create->add->begin->setNext->return
KillingBeginNode#create(LocationIdentity)::: killing begin node create:::return->new->KillingBeginNode
KillingBeginNode#getLocationIdentity()::: killing begin node get location identity:::return
LogicConstantNode#forBoolean(boolean, Graph):::Returns a node for a boolean constant.:::return->graph->new->LogicConstantNode->unique
LogicConstantNode#forBoolean(boolean):::Returns a node for a boolean constant.:::return->new->LogicConstantNode
LogicConstantNode#tautology(Graph):::Gets a constant for true.:::return->forBoolean
LogicConstantNode#contradiction(Graph):::Gets a constant for false.:::return->forBoolean
LogicConstantNode#tautology():::Gets a constant for true.:::return->forBoolean
LogicConstantNode#contradiction():::Gets a constant for false.:::return->forBoolean
LogicConstantNode#getValue()::: logic constant node get value:::return
LogicConstantNode#generate(NodeLIRBuilderTool)::: logic constant node generate:::
LogicNegationNode#create(LogicNode)::: logic negation node create:::synonym->findSynonym->if->return->return->new->LogicNegationNode
LogicNegationNode#findSynonym(LogicNode)::: logic negation node find synonym:::if->logicConstantNode->return->LogicConstantNode->logicConstantNode->getValue->forBoolean->else->if->return->getValue->return
LogicNegationNode#getValue()::: logic negation node get value:::return
LogicNegationNode#canonical(CanonicalizerTool, LogicNode)::: logic negation node canonical:::synonym->findSynonym->if->return->return
LogicNegationNode#implies(boolean, LogicNode)::: logic negation node implies:::if->getValue->return->TriState->get->return->getValue->implies
LogicNode#and(LogicNode, LogicNode, double)::: logic node and:::return->and
LogicNode#and(LogicNode, boolean, LogicNode, boolean, double)::: logic node and:::graph->a->graph->notAorNotB->graph->new->ShortCircuitOrNode->unique->return->graph->new->LogicNegationNode->unique
LogicNode#or(LogicNode, LogicNode, double)::: logic node or:::return->or
LogicNode#or(LogicNode, boolean, LogicNode, boolean, double)::: logic node or:::return->a->graph->new->ShortCircuitOrNode->unique
LogicNode#isTautology()::: logic node is tautology:::if->logicConstantNode->return->logicConstantNode->getValue->return
LogicNode#isContradiction()::: logic node is contradiction:::if->logicConstantNode->return->logicConstantNode->getValue->return
LogicNode#implies(boolean, LogicNode):::Determines what this condition implies about the other:::if->return->TriState->get->if->return->this->getValue->implies->flip->return
LogicNode#flip(TriState)::: logic node flip:::return->triState->isUnknown->TriState->triState->toBoolean->get
LoopBeginNode#isSimpleLoop()::: loop begin node is simple loop:::return
LoopBeginNode#setPreLoop()::: loop begin node set pre loop:::
LoopBeginNode#isPreLoop()::: loop begin node is pre loop:::return
LoopBeginNode#setMainLoop()::: loop begin node set main loop:::
LoopBeginNode#isMainLoop()::: loop begin node is main loop:::return
LoopBeginNode#setPostLoop()::: loop begin node set post loop:::
LoopBeginNode#isPostLoop()::: loop begin node is post loop:::return
LoopBeginNode#getUnrollFactor()::: loop begin node get unroll factor:::return
LoopBeginNode#setUnrollFactor(int)::: loop begin node set unroll factor:::
LoopBeginNode#disableSafepoint():::Disables safepoint for the whole loop, i.e., for all LoopEndNode loop ends.:::foreach->loopEnds->loopEnd->disableSafepoint
LoopBeginNode#loopOrigFrequency()::: loop begin node loop orig frequency:::return
LoopBeginNode#setLoopOrigFrequency(double)::: loop begin node set loop orig frequency:::
LoopBeginNode#loopFrequency()::: loop begin node loop frequency:::return
LoopBeginNode#setLoopFrequency(double)::: loop begin node set loop frequency:::
LoopBeginNode#loopEnds():::Returns the unordered set of LoopEndNode that correspond to back-edges for this loop:::return->usages->filter
LoopBeginNode#loopExits()::: loop begin node loop exits:::return->usages->filter
LoopBeginNode#anchored()::: loop begin node anchored:::return->super->anchored->isNotA->nor->filter
LoopBeginNode#orderedLoopEnds():::Returns the set of LoopEndNode that correspond to back-edges for this loop, in increasing #phiPredecessorIndex order:::result->this->getLoopEndCount->new->LoopEndNodeArr->foreach->loopEnds->end->endIndex->return
LoopBeginNode#isSingleEntryLoop()::: loop begin node is single entry loop:::return->forwardEndCount
LoopBeginNode#forwardEnd()::: loop begin node forward end:::return->forwardEndAt
LoopBeginNode#splits()::: loop begin node splits:::return
LoopBeginNode#incrementSplits()::: loop begin node increment splits:::
LoopBeginNode#generate(NodeLIRBuilderTool)::: loop begin node generate:::
LoopBeginNode#deleteEnd(AbstractEndNode)::: loop begin node delete end:::if->loopEnd->loopEnd->setLoopBegin->idx->loopEnd->endIndex->foreach->loopEnds->leIdx->le->endIndex->if->le->setEndIndex->else->super->deleteEnd
LoopBeginNode#phiPredecessorCount()::: loop begin node phi predecessor count:::return->forwardEndCount->loopEnds->count
LoopBeginNode#phiPredecessorIndex(AbstractEndNode)::: loop begin node phi predecessor index:::if->loopEnd->if->loopEnd->loopBegin->return->loopEnd->endIndex->forwardEndCount->else->return->super->forwardEndIndex->throw->ValueNodeUtil->shouldNotReachHere
LoopBeginNode#phiPredecessorAt(int)::: loop begin node phi predecessor at:::if->forwardEndCount->return->forwardEndAt->foreach->loopEnds->idx->forwardEndCount->if->end->endIndex->return->throw->ValueNodeUtil->shouldNotReachHere
LoopBeginNode#verify()::: loop begin node verify:::loopEnds->isNotEmpty->assertTrue->return->super->verify
LoopBeginNode#nextEndIndex()::: loop begin node next end index:::return
LoopBeginNode#getLoopEndCount()::: loop begin node get loop end count:::return
LoopBeginNode#unswitches()::: loop begin node unswitches:::return
LoopBeginNode#incrementUnswitches()::: loop begin node increment unswitches:::
LoopBeginNode#getInversionCount()::: loop begin node get inversion count:::return
LoopBeginNode#setInversionCount(int)::: loop begin node set inversion count:::
LoopBeginNode#simplify(SimplifierTool)::: loop begin node simplify:::canonicalizePhis
LoopBeginNode#isLoopExit(AbstractBeginNode)::: loop begin node is loop exit:::return->loopBegin
LoopBeginNode#getSingleLoopEnd()::: loop begin node get single loop end:::return->loopEnds->first
LoopBeginNode#removeExits()::: loop begin node remove exits:::foreach->loopExits->snapshot->try->position->graph->withNodeSourcePosition->loopexit->removeExit->catch->finally
LoopBeginNode#getOverflowGuard()::: loop begin node get overflow guard:::return
LoopBeginNode#setOverflowGuard(GuardingNode)::: loop begin node set overflow guard:::updateUsagesInterface
LoopBeginNode#getSelfIncrements(PhiNode):::Returns an array with one entry for each input of the phi, which is either #NO_INCREMENT or the increment, i.e., the value by which the phi is incremented in the corresponding branch.:::selfIncrement->phi->valueCount->new->intArr->for->i->phi->valueCount->return
LoopBeginNode#canonicalizePhis(SimplifierTool):::Coalesces loop phis that represent the same value (which is not handled by normal Global Value Numbering).:::phiCount->phis->count->if->phiInputCount->phiPredecessorCount->phiIndex->selfIncrement->new->intArrs->phis->this->phis->snapshot->new->PhiNodeArr->toArray->for
LoopBeginNode#markOsrLoop()::: loop begin node mark osr loop:::
LoopBeginNode#isOsrLoop()::: loop begin node is osr loop:::return
LoopEndNode#merge()::: loop end node merge:::return->loopBegin
LoopEndNode#loopBegin()::: loop end node loop begin:::return
LoopEndNode#setLoopBegin(LoopBeginNode)::: loop end node set loop begin:::updateUsages
LoopEndNode#disableSafepoint():::Disables safepoints for only this loop end (in contrast to disabling it for LoopBeginNode#disableSafepoint() the whole loop.:::
LoopEndNode#canSafepoint()::: loop end node can safepoint:::return
LoopEndNode#generate(NodeLIRBuilderTool)::: loop end node generate:::gen->visitLoopEnd->super->generate
LoopEndNode#verify()::: loop end node verify:::assertTrue->hasNoUsages->assertTrue->return->super->verify
LoopEndNode#endIndex():::Returns the index of this loop end amongst its LoopBeginNode's loop ends.<br>  Since a LoopBeginNode also has LoopBeginNode#forwardEnds() forward ends, this is not the index into PhiNode values at the loop begin:::return
LoopEndNode#setEndIndex(int)::: loop end node set end index:::
LoopEndNode#cfgSuccessors()::: loop end node cfg successors:::return->Collections->emptyList
LoopEndNode#estimatedNodeCycles()::: loop end node estimated node cycles:::if->loopBegin->return->if->canSafepoint->return->return->super->estimatedNodeCycles
LoopEndNode#estimatedNodeSize()::: loop end node estimated node size:::if->loopBegin->return->if->canSafepoint->return->return->super->estimatedNodeSize
LoopExitNode#loopBegin()::: loop exit node loop begin:::return
LoopExitNode#anchored()::: loop exit node anchored:::return->super->anchored->if->proxyNode->return->proxyNode->proxyPoint->return->filter
LoopExitNode#prepareDelete(FixedNode)::: loop exit node prepare delete:::removeProxies->super->prepareDelete
LoopExitNode#removeProxies()::: loop exit node remove proxies:::if->this->hasUsages->while->foreach->proxies->snapshot->value->vpn->value->vpn->replaceAtUsagesAndDelete->if->continue->break
LoopExitNode#proxies()::: loop exit node proxies:::return->usages->if->proxyNode->return->proxyNode->proxyPoint->return->filter
LoopExitNode#removeExit()::: loop exit node remove exit:::this->removeProxies->loopStateAfter->this->stateAfter->graph->graph->new->BeginNode->add->replaceFixedWithFixed->if->GraphUtil->tryKillUnused
LoopExitNode#simplify(SimplifierTool)::: loop exit node simplify:::prev->this->predecessor->while->tool->allUsagesAvailable->prev->hasNoUsages->begin->this->begin->getNodeSourcePosition->setNodeSourcePosition->prev->predecessor->graph->removeFixed
LoweredCallTargetNode#signature()::: lowered call target node signature:::return
LoweredCallTargetNode#callType()::: lowered call target node call type:::return
MergeNode#removeMergeIfDegenerated(MergeNode)::: merge node remove merge if degenerated:::if->node->forwardEndCount->node->hasNoUsages->currentNext->node->next->node->setNext->forwardEnd->node->forwardEndAt->forwardEnd->replaceAtPredecessor->node->markDeleted->forwardEnd->markDeleted
MergeNode#verify()::: merge node verify:::this->forwardEndCount->assertTrue->return
NamedLocationIdentity.DB#checkUnique(String)::: b check unique:::if->map->add->throw->new->AssertionError->return
NamedLocationIdentity#mutable(String):::Creates a named unique location identity for read and write operations against mutable memory.:::return->create
NamedLocationIdentity#immutable(String):::Creates a named unique location identity for read operations against immutable memory:::return->create
NamedLocationIdentity#create(String, boolean):::Creates a named unique location identity for read and write operations.:::return->new->NamedLocationIdentity
NamedLocationIdentity#isImmutable()::: named location identity is immutable:::return
NamedLocationIdentity#toString()::: named location identity to string:::return->isImmutable
NamedLocationIdentity#getArrayLocation(JavaKind):::Returns the named location identity for an array of the given element kind:::return->ARRAY_LOCATIONS->get
NamedLocationIdentity#initArrayLocations()::: named location identity init array locations:::result->new->EnumMap<>->foreach->JavaKind->values->result->NamedLocationIdentity->kind->getJavaName->mutable->put->return
NamedLocationIdentity#isArrayLocation(LocationIdentity)::: named location identity is array location:::return->ARRAY_LOCATIONS->containsValue
NodeView.Default#stamp(ValueNode)::: default stamp:::return
NodeView#stamp(ValueNode):::Return a view-specific stamp of the node:::
NodeView#from(CanonicalizerTool)::: node view from:::if->return->return
ParameterNode#uncheckedStamp()::: parameter node unchecked stamp:::return
PauseNode#generate(NodeLIRBuilderTool)::: pause node generate:::gen->getLIRGeneratorTool->emitPause
PauseNode#pause()::: pause node pause:::
PhiNode#values()::: phi node values:::
PhiNode#merge()::: phi node merge:::return
PhiNode#setMerge(AbstractMergeNode)::: phi node set merge:::updateUsages
PhiNode#verify()::: phi node verify:::merge->assertTrue->merge->phiPredecessorCount->valueCount->merge->phiPredecessorCount->valueCount->assertTrue->return->super->verify
PhiNode#valueAt(int):::Get the instruction that produces the value associated with the i'th predecessor of the merge.:::return->values->get
PhiNode#initializeValueAt(int, ValueNode):::Sets the value at the given index and makes sure that the values list is large enough.:::while->values->size->values->add->values->set
PhiNode#setValueAt(int, ValueNode)::: phi node set value at:::values->set
PhiNode#setValueAt(AbstractEndNode, ValueNode)::: phi node set value at:::merge->phiPredecessorIndex->setValueAt
PhiNode#valueAt(AbstractEndNode)::: phi node value at:::return->merge->phiPredecessorIndex->valueAt
PhiNode#valueCount():::Get the number of inputs to this phi (i.e:::return->values->size
PhiNode#clearValues()::: phi node clear values:::values->clear
PhiNode#toString(Verbosity)::: phi node to string:::if->str->new->StringBuilder->for->i->valueCount->description->valueDescription->if->description->length->str->append->append->return->super->toString->else->return->super->toString
PhiNode#valueDescription():::String describing the kind of value this Phi merges:::return
PhiNode#addInput(ValueNode)::: phi node add input:::values->add
PhiNode#removeInput(int)::: phi node remove input:::values->remove
PhiNode#backValues()::: phi node back values:::return->values->merge->forwardEndCount->subList
PhiNode#singleValueOrThis():::If all inputs are the same value, this value is returned, otherwise this:::singleValue->valueAt->count->valueCount->for->i->return
PhiNode#singleBackValueOrThis():::If all inputs (but the first one) are the same value, the value is returned, otherwise this:::valueCount->valueCount->singleValue->valueAt->for->i->return
PhiNode#canonical(CanonicalizerTool)::: phi node canonical:::if->isLoopPhi->valueCount->valueCount->i->for->if->return->firstValue->onlySelfUsage->foreach->this->usages->if->break->if->return->return->singleValueOrThis
PhiNode#firstValue()::: phi node first value:::return->valueAt
PhiNode#isLoopPhi()::: phi node is loop phi:::return->merge
PiArrayNode#findLength(FindLengthMode, ConstantReflectionProvider)::: pi array node find length:::return
PiArrayNode#canonical(CanonicalizerTool)::: pi array node canonical:::if->GraphUtil->object->tool->getConstantReflection->arrayLength->return->return->super->canonical
PiArrayNode#piArrayCastToSnippetReplaceeStamp(Object, int):::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.:::
PiArrayNode.Placeholder#makeReplacement(Stamp)::: placeholder make replacement:::piArray->graph->object->new->PiArrayNode->addOrUnique->replaceAndDelete
PiNode#object()::: pi node object:::return
PiNode#create(ValueNode, Stamp)::: pi node create:::value->canonical->if->return->return->new->PiNode
PiNode#create(ValueNode, Stamp, ValueNode)::: pi node create:::value->canonical->if->return->return->new->PiNode
PiNode#create(ValueNode, ValueNode)::: pi node create:::stamp->AbstractPointerStamp->object->stamp->pointerNonNull->value->canonical->if->return->return->new->PiNode
PiNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ValueNode, ValueNode)::: pi node intrinsify:::stamp->AbstractPointerStamp->object->stamp->pointerNonNull->value->canonical->if->new->PiNode->b->b->append->push->return
PiNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ValueNode, ResolvedJavaType, boolean, boolean)::: pi node intrinsify:::stamp->StampFactory->TypeReference->createExactTrusted->TypeReference->createWithoutAssumptions->StampTool->object->stamp->isPointerNonNull->object->value->canonical->if->new->PiNode->b->b->append->push->return
PiNode#piStamp()::: pi node pi stamp:::return
PiNode#strengthenPiStamp(Stamp)::: pi node strengthen pi stamp:::
PiNode#generate(NodeLIRBuilderTool)::: pi node generate:::if->generator->hasOperand->generator->generator->operand->setResult
PiNode#inferStamp()::: pi node infer stamp:::return->computeStamp->updateStamp
PiNode#computeStamp()::: pi node compute stamp:::return->piStamp->object->stamp->improveWith
PiNode#virtualize(VirtualizerTool)::: pi node virtualize:::alias->tool->object->getAlias->if->virtual->type->StampTool->tool->getMetaAccess->typeOrNull->if->type->virtual->type->isAssignableFrom->tool->replaceWithVirtual->else->tool->getDebug->virtual->type->log
PiNode#canonical(ValueNode, Stamp, GuardingNode, PiNode)::: pi node canonical:::computedStamp->stamp->object->stamp->improveWith->if->computedStamp->object->stamp->equals->return->if->if->object->hasMoreThanOneUsage->readNode->readNode->readNode->stamp->improveWith->setStamp->return->else->foreach->guard->asNode->usages->if->otherPi->if->otherPi->object->computedStamp->otherPi->stamp->equals->newStamp->stamp->join->if->newStamp->equals->return->return
PiNode#canonical(CanonicalizerTool)::: pi node canonical:::value->object->piStamp->getGuard->canonical->if->return->return
PiNode#getOriginalNode()::: pi node get original node:::return
PiNode#setOriginalNode(ValueNode)::: pi node set original node:::this->updateUsages
PiNode#asNonNullClass(Object):::Casts an object to have an exact, non-null stamp representing Class.:::return->asNonNullClassIntrinsic
PiNode#asNonNullObject(Object):::Casts an object to have an exact, non-null stamp representing Class.:::return->asNonNullClassIntrinsic
PiNode#asNonNullClassIntrinsic(Object, Class, boolean, boolean)::: pi node as non null class intrinsic:::
PiNode#piCastToSnippetReplaceeStamp(Object):::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.:::
PiNode#piCastNonNull(Object, GuardingNode):::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.:::
PiNode#piCastNonNullClass(Class, GuardingNode):::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.:::
PiNode#piCastNonNull(Object, ResolvedJavaType):::Changes the stamp of an object to represent a given type and to indicate that the object is not null.:::return->piCast
PiNode#piCast(Object, ResolvedJavaType, boolean, boolean)::: pi node pi cast:::
PiNode.Placeholder#object()::: placeholder object:::return
PiNode.Placeholder#makeReplacement(Stamp):::Replaces this node with a PiNode during snippet instantiation.:::value->graph->PiNode->object->create->maybeAddOrUnique->replaceAndDelete
PiNode.PlaceholderStamp#singleton()::: placeholder stamp singleton:::return
PiNode.PlaceholderStamp#hashCode()::: placeholder stamp hash code:::return->System->identityHashCode
PiNode.PlaceholderStamp#equals(Object)::: placeholder stamp equals:::return
PiNode.PlaceholderStamp#toString()::: placeholder stamp to string:::return
PrefetchAllocateNode#generate(NodeLIRBuilderTool)::: prefetch allocate node generate:::gen->getLIRGeneratorTool->gen->operand->emitPrefetchAllocate
PrefetchAllocateNode#prefetch(Address)::: prefetch allocate node prefetch:::
ProxyNode#value()::: proxy node value:::
ProxyNode#setProxyPoint(LoopExitNode)::: proxy node set proxy point:::this->updateUsages
ProxyNode#proxyPoint()::: proxy node proxy point:::return
ProxyNode#verify()::: proxy node verify:::return->super->verify
ProxyNode#forValue(ValueNode, LoopExitNode, StructuredGraph)::: proxy node for value:::return->graph->new->ValueProxyNode->unique
ProxyNode#forGuard(GuardingNode, LoopExitNode, StructuredGraph)::: proxy node for guard:::return->graph->new->GuardProxyNode->unique
ProxyNode#createPhi(AbstractMergeNode)::: proxy node create phi:::
ReturnNode#result()::: return node result:::return
ReturnNode#generate(NodeLIRBuilderTool)::: return node generate:::if->gen->getLIRGeneratorTool->emitReturn->else->gen->getLIRGeneratorTool->result->getStackKind->gen->operand->emitReturn
ReturnNode#setMemoryMap(MemoryMapNode)::: return node set memory map:::updateUsages
ReturnNode#getMemoryMap()::: return node get memory map:::return
ReturnNode#verifyReturn(TargetDescription)::: return node verify return:::if->graph->method->actual->result->getStackKind->expected->graph->method->getSignature->getReturnKind->getStackKind->if->return->return
SafepointNode#lower(LoweringTool)::: safepoint node lower:::tool->getLowerer->lower
SafepointNode#generate(NodeLIRBuilderTool)::: safepoint node generate:::gen->visitSafepointNode
SafepointNode#canDeoptimize()::: safepoint node can deoptimize:::return
ShortCircuitOrNode#create(LogicNode, boolean, LogicNode, boolean, double)::: short circuit or node create:::return->new->ShortCircuitOrNode
ShortCircuitOrNode#getX()::: short circuit or node get x:::return
ShortCircuitOrNode#getY()::: short circuit or node get y:::return
ShortCircuitOrNode#isXNegated()::: short circuit or node is negated:::return
ShortCircuitOrNode#isYNegated()::: short circuit or node is negated:::return
ShortCircuitOrNode#getShortCircuitProbability():::Gets the probability that the #getY() y part of this binary node is not evaluated:::return
ShortCircuitOrNode#canonicalizeNegation(LogicNode, LogicNode)::: short circuit or node canonicalize negation:::xCond->xNeg->while->getValue->yCond->yNeg->while->getValue->if->return->new->ShortCircuitOrNode->else->return
ShortCircuitOrNode#canonical(CanonicalizerTool, LogicNode, LogicNode)::: short circuit or node canonical:::ret->canonicalizeNegation->if->return->view->NodeView->from->if->if->isXNegated->if->isYNegated->return->LogicNegationNode->create->else->return->LogicConstantNode->tautology->else->if->isYNegated->return->LogicConstantNode->tautology->else->return->if->if->getValue->isXNegated->return->LogicConstantNode->tautology->else->if->isYNegated->return->new->LogicNegationNode->else->return->if->if->getValue->isYNegated->return->LogicConstantNode->tautology->else->if->isXNegated->return->new->LogicNegationNode->else->return->if->inner->if->inner->getX->return->optimizeShortCircuit->else->if->inner->getY->return->optimizeShortCircuit->else->if->inner->if->inner->getX->return->optimizeShortCircuit->else->if->inner->getY->return->optimizeShortCircuit->impliedForY->forX->isXNegated->implies->if->impliedForY->isKnown->yResult->impliedForY->toBoolean->isYNegated->return->LogicConstantNode->tautology->isXNegated->LogicNegationNode->create->if->isXNegated->isYNegated->sym->simplifyComparison->if->return->if->isXNegated->isYNegated->xNode->yNode->xxNode->xNode->getX->yxNode->yNode->getX->if->xxNode->stamp->isPositive->xyNode->xNode->getY->yyNode->yNode->getY->if->return->if->isXNegated->isYNegated->yNode->if->yNode->isXNegated->sym->yNode->getX->simplifyComparison->if->p1->getShortCircuitProbability->p2->yNode->getShortCircuitProbability->return->isXNegated->yNode->getY->yNode->isYNegated->new->ShortCircuitOrNode->if->xCompare->yCompare->if->xCompare->getX->yCompare->getX->xCompare->getX->yCompare->getY->succeedingStampX->xCompare->xCompare->getX->stamp->xCompare->getY->stamp->getSucceedingStampForX->if->succeedingStampX->isUnrestricted->proxyTool->xCompare->getX->new->ProxyCanonicalizerTool->result->yCompare->canonical->if->return->ShortCircuitOrNode->create->return
ShortCircuitOrNode.ProxyCanonicalizerTool#stamp(ValueNode)::: proxy canonicalizer tool stamp:::if->return->return->view->stamp
ShortCircuitOrNode.ProxyCanonicalizerTool#getAssumptions()::: proxy canonicalizer tool get assumptions:::return->tool->getAssumptions
ShortCircuitOrNode.ProxyCanonicalizerTool#getMetaAccess()::: proxy canonicalizer tool get meta access:::return->tool->getMetaAccess
ShortCircuitOrNode.ProxyCanonicalizerTool#getConstantReflection()::: proxy canonicalizer tool get constant reflection:::return->tool->getConstantReflection
ShortCircuitOrNode.ProxyCanonicalizerTool#getConstantFieldProvider()::: proxy canonicalizer tool get constant field provider:::return->tool->getConstantFieldProvider
ShortCircuitOrNode.ProxyCanonicalizerTool#canonicalizeReads()::: proxy canonicalizer tool canonicalize reads:::return->tool->canonicalizeReads
ShortCircuitOrNode.ProxyCanonicalizerTool#allUsagesAvailable()::: proxy canonicalizer tool all usages available:::return->tool->allUsagesAvailable
ShortCircuitOrNode.ProxyCanonicalizerTool#smallestCompareWidth()::: proxy canonicalizer tool smallest compare width:::return->tool->smallestCompareWidth
ShortCircuitOrNode.ProxyCanonicalizerTool#getOptions()::: proxy canonicalizer tool get options:::return->tool->getOptions
ShortCircuitOrNode#simplifyComparison(LogicNode, LogicNode)::: short circuit or node simplify comparison:::sym->simplifyComparisonOrdered->if->return->simplifyComparisonOrdered->return
ShortCircuitOrNode#simplifyComparisonOrdered(LogicNode, LogicNode)::: short circuit or node simplify comparison ordered:::if->xNode->yNode->xyNode->xNode->getY->if->xyNode->isConstant->getAdd->xyNode->asConstant->isNeutral->yxNode->yNode->getX->stamp->yxNode->stamp->if->stamp->isPositive->if->xNode->getX->yNode->getY->u->xNode->getX->return->IntegerBelowNode->create->return
ShortCircuitOrNode#optimizeShortCircuit(ShortCircuitOrNode, boolean, boolean, boolean)::: short circuit or node optimize short circuit:::innerMatchNegated->if->inner->isXNegated->else->inner->isYNegated->if->if->return->else->return->LogicConstantNode->tautology->else->if->newInnerXNegated->inner->isXNegated->newInnerYNegated->inner->isYNegated->newProbability->inner->getShortCircuitProbability->if->else->return->inner->getX->inner->getY->new->ShortCircuitOrNode->else->result->inner->getY->if->inner->getX->if->return->LogicNegationNode->create->else->return
SimplifyingGraphDecoder.PECanonicalizerTool#getOptions()::: canonicalizer tool get options:::return
SimplifyingGraphDecoder.PECanonicalizerTool#getMetaAccess()::: canonicalizer tool get meta access:::return->providers->getMetaAccess
SimplifyingGraphDecoder.PECanonicalizerTool#getConstantReflection()::: canonicalizer tool get constant reflection:::return->providers->getConstantReflection
SimplifyingGraphDecoder.PECanonicalizerTool#getConstantFieldProvider()::: canonicalizer tool get constant field provider:::return->providers->getConstantFieldProvider
SimplifyingGraphDecoder.PECanonicalizerTool#canonicalizeReads()::: canonicalizer tool canonicalize reads:::return
SimplifyingGraphDecoder.PECanonicalizerTool#allUsagesAvailable()::: canonicalizer tool all usages available:::return
SimplifyingGraphDecoder.PECanonicalizerTool#getAssumptions()::: canonicalizer tool get assumptions:::return
SimplifyingGraphDecoder.PECanonicalizerTool#smallestCompareWidth()::: canonicalizer tool smallest compare width:::return
SimplifyingGraphDecoder.CanonicalizeToNullNode#canonical(CanonicalizerTool)::: canonicalize to null node canonical:::return
SimplifyingGraphDecoder#cleanupGraph(MethodScope)::: simplifying graph decoder cleanup graph:::GraphUtil->normalizeLoops->super->cleanupGraph->foreach->graph->getNewNodes->if->mergeNode->if->mergeNode->forwardEndCount->graph->reduceTrivialMerge->else->if->if->node->predecessor->node->hasNoUsages->GraphUtil->unlinkFixedNode->node->safeDelete->foreach->graph->getNewNodes->GraphUtil->tryKillUnused
SimplifyingGraphDecoder#allowLazyPhis()::: simplifying graph decoder allow lazy phis:::return
SimplifyingGraphDecoder#handleMergeNode(MergeNode)::: simplifying graph decoder handle merge node:::foreach->merge->valuePhis->phi->inferStamp
SimplifyingGraphDecoder#handleFixedNode(MethodScope, LoopScope, int, FixedNode)::: simplifying graph decoder handle fixed node:::canonical->canonicalizeFixedNode->if->handleCanonicalization
SimplifyingGraphDecoder#canonicalizeFixedNode(MethodScope, Node):::Canonicalizes the provided node, which was originally a FixedNode but can already be canonicalized (and therefore be a non-fixed node).:::if->loadFieldNode->return->loadFieldNode->canonical->else->if->guard->if->guard->getCondition->condition->guard->getCondition->if->condition->getValue->guard->isNegated->deopt->guard->getAction->guard->getReason->guard->getSpeculation->new->DeoptimizeNode->if->guard->stateBefore->deopt->guard->stateBefore->setStateBefore->return->else->return->return->else->if->ifNode->if->ifNode->condition->ifNode->eliminateNegation->if->ifNode->condition->condition->ifNode->condition->getValue->survivingSuccessor->ifNode->getSuccessor->deadSuccessor->ifNode->getSuccessor->graph->removeSplit->deadSuccessor->safeDelete->return->else->if->loadIndexedNode->return->loadIndexedNode->canonical->else->if->arrayLengthNode->return->arrayLengthNode->canonical->else->if->value->isConstant->switchNode->value->switchNode->value->asJavaConstant->asInt->survivingSuccessor->switchNode->successorAtKey->allSuccessors->switchNode->successors->snapshot->graph->removeSplit->foreach->if->successor->safeDelete->return->else->if->return->canonical->else->return
SimplifyingGraphDecoder#canonicalizeFixedNodeToNull(FixedNode)::: simplifying graph decoder canonicalize fixed node to null:::return->new->CanonicalizeToNullNode
SimplifyingGraphDecoder#handleCanonicalization(LoopScope, int, FixedNode, Node)::: simplifying graph decoder handle canonicalization:::try->position->graph->withNodeSourcePosition->canonical->canonicalizeFixedNodeToNull->if->canonical->isAlive->graph->addOrUniqueWithInputs->if->graph->addBeforeFixed->else->if->predecessor->node->predecessor->predecessor->setNext->successorSnapshot->node->successors->snapshot->node->safeDelete->foreach->successor->safeDelete->else->if->node->isDeleted->GraphUtil->unlinkFixedNode->node->replaceAtUsagesAndDelete->registerNode->catch->finally
SimplifyingGraphDecoder#handleFloatingNodeBeforeAdd(MethodScope, LoopScope, Node)::: simplifying graph decoder handle floating node before add:::if->inferStamp->if->try->context->graph->withNodeSourcePosition->canonical->canonical->if->else->if->if->canonical->isAlive->graph->addOrUniqueWithInputs->return->catch->finally->return
SimplifyingGraphDecoder#addFloatingNode(MethodScope, Node)::: simplifying graph decoder add floating node:::return->graph->addOrUnique
SnippetAnchorNode#simplify(SimplifierTool)::: snippet anchor node simplify:::prevBegin->AbstractBeginNode->prevBegin->replaceAtUsages->replaceAtUsages->if->tool->allUsagesAvailable->hasNoUsages->graph->removeFixed
SnippetAnchorNode#anchor()::: snippet anchor node anchor:::
StartNode#getLocationIdentity()::: start node get location identity:::return->LocationIdentity->any
StateSplit#stateAfter():::Gets the FrameState corresponding to the state of the JVM after execution of this node.:::
StateSplit#setStateAfter(FrameState):::Sets the FrameState corresponding to the state of the JVM after execution of this node.:::
StateSplit#hasSideEffect():::Determines if this node has a side-effect:::
StaticDeoptimizingNode#getReason()::: static deoptimizing node get reason:::
StaticDeoptimizingNode#setReason(DeoptimizationReason)::: static deoptimizing node set reason:::
StaticDeoptimizingNode#getAction()::: static deoptimizing node get action:::
StaticDeoptimizingNode#setAction(DeoptimizationAction)::: static deoptimizing node set action:::
StaticDeoptimizingNode#getSpeculation()::: static deoptimizing node get speculation:::
StaticDeoptimizingNode#computePriority()::: static deoptimizing node compute priority:::if->getSpeculation->equals->return->switch->getAction->return->return->throw->GraalError->shouldNotReachHere
StaticDeoptimizingNode#mergeActions(DeoptimizationAction, DeoptimizationAction)::: static deoptimizing node merge actions:::if->return->if->return->return
StructuredGraph.ScheduleResult#getCFG()::: schedule result get g:::return
StructuredGraph.ScheduleResult#getNodeToBlockMap()::: schedule result get node to block map:::return
StructuredGraph.ScheduleResult#getBlockToNodesMap()::: schedule result get block to nodes map:::return
StructuredGraph.ScheduleResult#nodesFor(Block)::: schedule result nodes for:::return->blockToNodesMap->get
StructuredGraph.Builder#getName()::: builder get name:::return
StructuredGraph.Builder#name(String)::: builder name:::return
StructuredGraph.Builder#setIsSubstitution(boolean)::: builder set is substitution:::return
StructuredGraph.Builder#getMethod()::: builder get method:::return
StructuredGraph.Builder#method(ResolvedJavaMethod)::: builder method:::return
StructuredGraph.Builder#getDebug()::: builder get debug:::return
StructuredGraph.Builder#getSpeculationLog()::: builder get speculation log:::return
StructuredGraph.Builder#speculationLog(SpeculationLog)::: builder speculation log:::return
StructuredGraph.Builder#getCompilationId()::: builder get compilation id:::return
StructuredGraph.Builder#compilationId(CompilationIdentifier)::: builder compilation id:::return
StructuredGraph.Builder#getCancellable()::: builder get cancellable:::return
StructuredGraph.Builder#cancellable(Cancellable)::: builder cancellable:::return
StructuredGraph.Builder#getEntryBCI()::: builder get entry i:::return
StructuredGraph.Builder#entryBCI(int)::: builder entry i:::return
StructuredGraph.Builder#getUseProfilingInfo()::: builder get use profiling info:::return
StructuredGraph.Builder#useProfilingInfo(boolean)::: builder use profiling info:::return
StructuredGraph.Builder#getRecordInlinedMethods()::: builder get record inlined methods:::return
StructuredGraph.Builder#recordInlinedMethods(boolean)::: builder record inlined methods:::return
StructuredGraph.Builder#trackNodeSourcePosition(boolean)::: builder track node source position:::if->return
StructuredGraph.Builder#callerContext(NodeSourcePosition)::: builder caller context:::return
StructuredGraph.Builder#build()::: builder build:::inlinedMethods->new->ArrayList<>->return->new->StructuredGraph
StructuredGraph#checkIsSubstitutionInvariants(ResolvedJavaMethod, boolean)::: structured graph check is substitution invariants:::if->if->method->getAnnotation->method->getAnnotation->return
StructuredGraph#setLastSchedule(ScheduleResult)::: structured graph set last schedule:::
StructuredGraph#getLastSchedule()::: structured graph get last schedule:::return
StructuredGraph#clearLastSchedule()::: structured graph clear last schedule:::setLastSchedule
StructuredGraph#maybeCompress()::: structured graph maybe compress:::if->super->maybeCompress->clearLastSchedule->return->return
StructuredGraph#getReturnStamp()::: structured graph get return stamp:::returnStamp->foreach->getNodes->result->returnNode->result->if->if->result->stamp->else->returnStamp->result->stamp->meet->return
StructuredGraph#toString()::: structured graph to string:::buf->getClass->getSimpleName->new->StringBuilder->sep->if->buf->append->buf->append->if->method->buf->append->buf->method->append->if->sep->equals->buf->append->return->buf->toString
StructuredGraph#start()::: structured graph start:::return
StructuredGraph#method():::Gets the root method from which this graph was built.:::return
StructuredGraph#getEntryBCI()::: structured graph get entry i:::return
StructuredGraph#getCancellable()::: structured graph get cancellable:::return
StructuredGraph#checkCancellation()::: structured graph check cancellation:::if->cancellable->isCancelled->CancellationBailoutException->cancelCompilation
StructuredGraph#isOSR()::: structured graph is r:::return
StructuredGraph#graphId()::: structured graph graph id:::return
StructuredGraph#compilationId()::: structured graph compilation id:::return
StructuredGraph#setStart(StartNode)::: structured graph set start:::
StructuredGraph#getInliningLog()::: structured graph get inlining log:::return
StructuredGraph#logInliningTree()::: structured graph log inlining tree:::if->getOptions->getValue->formattedTree->getInliningLog->formatAsTree->if->TTY->println
StructuredGraph#copy(String, Consumer>, DebugContext):::Creates a copy of this graph.:::return->copy
StructuredGraph#copy(String, Consumer>, CompilationIdentifier, DebugContext)::: structured graph copy:::allowAssumptions->AllowAssumptions->ifNonNull->copy->method->new->Assumptions->new->ArrayList<>->getOptions->new->StructuredGraph->if->record->copy->getGuardsStage->setGuardsStage->if->createFieldSet->replacements->EconomicMap->create->replacements->put->duplicates->try->scope->copy->getInliningLog->openDefaultUpdateScope->copy->getNodes->this->getNodeCount->addDuplicates->if->copy->getInliningLog->this->getInliningLog->replaceLog->catch->finally->if->duplicationMapCallback->accept->return
StructuredGraph#copyWithIdentifier(CompilationIdentifier, DebugContext)::: structured graph copy with identifier:::return->copy
StructuredGraph#getParameter(int)::: structured graph get parameter:::foreach->getNodes->if->param->index->return->return
StructuredGraph#getInvokes()::: structured graph get invokes:::callTargets->getNodes->iterator->return->new->Iterable<Invoke>
StructuredGraph#hasLoops()::: structured graph has loops:::return->hasNode
StructuredGraph#removeFixed(FixedWithNextNode):::Unlinks a node from all its control flow neighbors and then removes it from its graph:::if->prepareDelete->GraphUtil->unlinkFixedNode->node->safeDelete
StructuredGraph#replaceFixed(FixedWithNextNode, Node)::: structured graph replace fixed:::if->replaceFixedWithFixed->else->replaceFixedWithFloating
StructuredGraph#replaceFixedWithFixed(FixedWithNextNode, FixedWithNextNode)::: structured graph replace fixed with fixed:::next->node->next->node->setNext->replacement->setNext->node->replaceAndDelete->if->setStart
StructuredGraph#replaceFixedWithFloating(FixedWithNextNode, ValueNode)::: structured graph replace fixed with floating:::GraphUtil->unlinkFixedNode->node->replaceAtUsagesAndDelete
StructuredGraph#removeSplit(ControlSplitNode, AbstractBeginNode)::: structured graph remove split:::node->clearSuccessors->node->replaceAtPredecessor->node->safeDelete
StructuredGraph#removeSplitPropagate(ControlSplitNode, AbstractBeginNode)::: structured graph remove split propagate:::snapshot->node->successors->snapshot->node->clearSuccessors->node->replaceAtPredecessor->node->safeDelete->foreach->if->successor->isAlive->if->GraphUtil->killCFG
StructuredGraph#replaceSplit(ControlSplitNode, Node, AbstractBeginNode)::: structured graph replace split:::if->replaceSplitWithFixed->else->replaceSplitWithFloating
StructuredGraph#replaceSplitWithFixed(ControlSplitNode, FixedWithNextNode, AbstractBeginNode)::: structured graph replace split with fixed:::node->clearSuccessors->replacement->setNext->node->replaceAndDelete
StructuredGraph#replaceSplitWithFloating(ControlSplitNode, FloatingNode, AbstractBeginNode)::: structured graph replace split with floating:::node->clearSuccessors->node->replaceAtPredecessor->node->replaceAtUsagesAndDelete
StructuredGraph#addAfterFixed(FixedWithNextNode, FixedNode)::: structured graph add after fixed:::next->node->next->node->setNext->if->newFixedWithNext->newFixedWithNext->setNext
StructuredGraph#addBeforeFixed(FixedNode, FixedWithNextNode)::: structured graph add before fixed:::pred->node->predecessor->pred->setNext->newNode->setNext
StructuredGraph#reduceDegenerateLoopBegin(LoopBeginNode)::: structured graph reduce degenerate loop begin:::if->begin->forwardEndCount->reduceTrivialMerge->else->merge->this->new->MergeNode->add->foreach->begin->forwardEnds->merge->addForwardEnd->this->replaceFixedWithFixed
StructuredGraph#reduceTrivialMerge(AbstractMergeNode)::: structured graph reduce trivial merge:::foreach->merge->phis->snapshot->singleValue->phi->valueAt->if->phi->hasUsages->phi->replaceAtUsagesAndDelete->else->phi->safeDelete->if->GraphUtil->tryKillUnused->if->removeExits->singleEnd->merge->forwardEndAt->sux->merge->next->stateAfter->merge->stateAfter->merge->singleEnd->predecessor->prepareDelete->merge->safeDelete->if->GraphUtil->tryKillUnused->if->singleEnd->replaceAtPredecessor->singleEnd->safeDelete->else->singleEnd->replaceAndDelete
StructuredGraph#getGuardsStage()::: structured graph get guards stage:::return
StructuredGraph#setGuardsStage(GuardsStage)::: structured graph set guards stage:::
StructuredGraph#isAfterFloatingReadPhase()::: structured graph is after floating read phase:::return
StructuredGraph#isAfterFixedReadPhase()::: structured graph is after fixed read phase:::return
StructuredGraph#setAfterFloatingReadPhase(boolean)::: structured graph set after floating read phase:::
StructuredGraph#setAfterFixReadPhase(boolean)::: structured graph set after fix read phase:::
StructuredGraph#hasValueProxies()::: structured graph has value proxies:::return
StructuredGraph#setHasValueProxies(boolean)::: structured graph set has value proxies:::
StructuredGraph#isAfterExpandLogic()::: structured graph is after expand logic:::return
StructuredGraph#setAfterExpandLogic()::: structured graph set after expand logic:::
StructuredGraph#useProfilingInfo():::Determines if ProfilingInfo is used during construction of this graph.:::return
StructuredGraph#isSubstitution():::Returns true if this graph is built without parsing the #method() root method or if the root method is annotated by Snippet or MethodSubstitution:::return
StructuredGraph#getProfilingInfo():::Gets the profiling info for the #method() root method of this graph.:::return->method->getProfilingInfo
StructuredGraph#getProfilingInfo(ResolvedJavaMethod):::Gets the profiling info for a given method that is or will be part of this graph, taking into account #useProfilingInfo().:::if->return->m->getProfilingInfo->else->return->DefaultProfilingInfo->get
StructuredGraph#getAssumptions():::Gets the object for recording assumptions while constructing of this graph.:::return
StructuredGraph#checkFrameStatesAgainstInlinedMethods():::Checks that any method referenced from a FrameState is also in the set of methods parsed while building this graph.:::foreach->getNodes->if->BytecodeFrame->isPlaceholderBci->m->getMethod->if->m->equals->methods->contains->haystack->new->TreeSet<>->if->methods->contains->haystack->rootMethod->format->add->foreach->haystack->e->format->add->throw->String->m->format->haystack->stream->Collectors->System->lineSeparator->joining->collect->format->new->AssertionError->return
StructuredGraph#createFieldSet(EconomicSet)::: structured graph create field set:::if->return->EconomicSet->create->return->EconomicSet->create
StructuredGraph#getMethods():::Gets an unmodifiable view of the methods that were inlined while constructing this graph.:::if->return->Collections->unmodifiableList->return->Collections->emptyList
StructuredGraph#recordMethod(ResolvedJavaMethod):::Records that method was used to build this graph.:::if->methods->add
StructuredGraph#updateMethods(StructuredGraph):::Updates the #getMethods() methods used to build this graph with the methods used to build another graph.:::if->if->methods->add->foreach->methods->add
StructuredGraph#getFields():::Gets an unmodifiable view of the fields that were accessed while constructing this graph.:::return
StructuredGraph#recordField(ResolvedJavaField):::Records that field was accessed in this graph.:::if->createFieldSet->fields->add
StructuredGraph#updateFields(StructuredGraph):::Updates the #getFields() fields of this graph with the accessed fields of another graph.:::if->if->createFieldSet->addAll
StructuredGraph#getBytecodeSize():::Gets the input bytecode ResolvedJavaMethod#getCodeSize() size from which this graph is constructed:::res->if->rootMethod->getCodeSize->if->foreach->e->getCodeSize->return
StructuredGraph#asJavaMethod()::: structured graph as java method:::return->method
StructuredGraph#hasUnsafeAccess()::: structured graph has unsafe access:::return
StructuredGraph#markUnsafeAccess()::: structured graph mark unsafe access:::if->return
StructuredGraph#disableUnsafeAccessTracking()::: structured graph disable unsafe access tracking:::
StructuredGraph#isUnsafeAccessTrackingEnabled()::: structured graph is unsafe access tracking enabled:::return
StructuredGraph#getSpeculationLog()::: structured graph get speculation log:::return
StructuredGraph#clearAllStateAfter()::: structured graph clear all state after:::foreach->getNodes->if->stateAfter->stateAfter->if->setStateAfter->if->stateAfter->isAlive->GraphUtil->killWithUnusedFloatingInputs
StructuredGraph#hasVirtualizableAllocation()::: structured graph has virtualizable allocation:::foreach->getNodes->if->return->return
StructuredGraph#afterRegister(Node)::: structured graph after register:::if->getOptions->getValue->if->updateInliningLogAfterRegister
StructuredGraph#getCallerContext()::: structured graph get caller context:::return
TypeCheckHints#makeHints(TypeReference, JavaTypeProfile, double, int, Double[])::: type check hints make hints:::hitProb->hintsBuf->if->notRecordedTypes->profile->getNotRecordedProbability->ptypes->profile->getTypes->if->new->HintArr->hintCount->foreach->if->hintType->ptype->getType->targetType->getType->isAssignableFrom->new->Hint->ptype->getProbability->if->break->if->if->Arrays->Math->min->copyOf->else->return
UnaryOpLogicNode#getValue()::: unary op logic node get value:::return
UnaryOpLogicNode#generate(NodeLIRBuilderTool)::: unary op logic node generate:::
UnaryOpLogicNode#getSucceedingStampForValue(boolean, Stamp):::In general the input stamp cannot be trusted, this method is reserved for the cases when it's "safe" to use the input stamp:::succStamp->getSucceedingStampForValue->if->succStamp->join->return
UnaryOpLogicNode#getSucceedingStampForValue(boolean):::The input stamp cannot be trusted, the returned stamp cannot use the input stamp to narrow itself or derive any assumptions:::
UnaryOpLogicNode#tryFold(Stamp)::: unary op logic node try fold:::
UnaryOpLogicNode#implies(boolean, LogicNode)::: unary op logic node implies:::if->unaryY->if->this->getValue->unaryY->getValue->this->getValue->skipThroughPisAndProxies->unaryY->getValue->skipThroughPisAndProxies->succStamp->this->getSucceedingStampForValue->fold->unaryY->tryFold->if->fold->isKnown->return->return->super->implies
UnaryOpLogicNode#skipThroughPisAndProxies(ValueNode)::: unary op logic node skip through pis and proxies:::n->while->if->getOriginalNode->else->if->getOriginalNode->else->break->return
UnwindNode#exception()::: unwind node exception:::return
UnwindNode#lower(LoweringTool)::: unwind node lower:::tool->getLowerer->lower
UnwindNode#generate(NodeLIRBuilderTool)::: unwind node generate:::gen->getLIRGeneratorTool->gen->exception->operand->emitUnwind
ValueNode#stamp(NodeView)::: value node stamp:::return->view->stamp
ValueNode#setStamp(Stamp)::: value node set stamp:::
ValueNode#graph()::: value node graph:::return->super->graph
ValueNode#updateStamp(Stamp):::Checks if the given stamp is different than the current one ( newStamp.equals(oldStamp) == false):::if->newStamp->equals->return->else->return
ValueNode#inferStamp():::This method can be overridden by subclasses of ValueNode if they need to recompute their stamp if their inputs change:::return
ValueNode#getStackKind()::: value node get stack kind:::return->stamp->getStackKind
ValueNode#isConstant():::Checks whether this value is a constant (i.e:::return
ValueNode#isConstantPredicate()::: value node is constant predicate:::return
ValueNode#isNullConstant():::Checks whether this value represents the null constant.:::value->asJavaConstant->return->value->isNull
ValueNode#isDefaultConstant()::: value node is default constant:::value->asConstant->return->value->isDefaultForKind
ValueNode#asConstant():::Convert this value to a constant if it is a constant, otherwise return null.:::if->return->getValue->else->return
ValueNode#isJavaConstant()::: value node is java constant:::return->isConstant->asConstant
ValueNode#asJavaConstant()::: value node as java constant:::value->asConstant->if->return->else->return
ValueNode#asNode()::: value node as node:::return
ValueNode#isAllowedUsageType(InputType)::: value node is allowed usage type:::if->getStackKind->return->else->return->super->isAllowedUsageType
ValueNode#hasUsagesOtherThan(ValueNode, NodeValueMap):::Checks if this node has usages other than the given node node.:::foreach->usages->if->nodeValueMap->hasOperand->return->return
ValueNode#replaceAtUsages(Node, Predicate, Node)::: value node replace at usages:::super->replaceAtUsages
ValueNode#checkReplaceAtUsagesInvariants(Node)::: value node check replace at usages invariants:::if->this->hasUsages->this->stamp->isEmpty->morePrecise->stamp->stamp->join->stamp->equals->return
ValueNodeInterface#asNode()::: value node interface as node:::
ValueNodeUtil#assertKind(JavaKind, ValueNode)::: value node util assert kind:::return
ValueNodeUtil#shouldNotReachHere(String)::: value node util should not reach here:::throw->new->InternalError
ValueNodeUtil#shouldNotReachHere()::: value node util should not reach here:::throw->new->InternalError
ValueNodeUtil#assertLong(ValueNode)::: value node util assert long:::return
ValueNodeUtil#assertInt(ValueNode)::: value node util assert int:::return
ValueNodeUtil#assertFloat(ValueNode)::: value node util assert float:::return
ValueNodeUtil#assertObject(ValueNode)::: value node util assert object:::return
ValueNodeUtil#assertDouble(ValueNode)::: value node util assert double:::return
ValueNodeUtil#assertHigh(ValueNode)::: value node util assert high:::
ValueNodeUtil#filter(Iterable, Class)::: value node util filter:::phis->new->ArrayList<>->foreach->if->clazz->isInstance->phis->add->return
ValueNodeUtil#valueString(ValueNode):::Converts a given instruction to a value string:::return->value->getStackKind->getTypeChar->toLowerCase->value->toString
ValueNodeUtil#asNode(MemoryNode)::: value node util as node:::if->return->else->return->node->asNode
ValuePhiNode#values()::: value phi node values:::return
ValuePhiNode#inferStamp()::: value phi node infer stamp:::valuesStamp->StampTool->values->meetOrNull->if->else->if->stamp->isCompatible->stamp->join->return->updateStamp
ValuePhiNode#verify()::: value phi node verify:::s->foreach->values->if->input->stamp->else->if->s->input->stamp->isCompatible->CollectionsUtil->values->x->toString->x->stamp->mapAndJoin->fail->return->super->verify
ValuePhiNode#valueDescription()::: value phi node value description:::return->stamp->unrestricted->toString
ValuePhiNode#getDebugProperties(Map)::: value phi node get debug properties:::properties->super->getDebugProperties->properties->valueDescription->put->return
ValueProxyNode#value()::: value proxy node value:::return
ValueProxyNode#createPhi(AbstractMergeNode)::: value proxy node create phi:::return->graph->stamp->new->ValuePhiNode->addWithoutUnique
ValueProxyNode#inferStamp()::: value proxy node infer stamp:::return->value->stamp->updateStamp
ValueProxyNode#canonical(CanonicalizerTool)::: value proxy node canonical:::curValue->if->curValue->isConstant->return->if->loopExit->loopBegin->isPhiAtMerge->return->return
ValueProxyNode#virtualize(VirtualizerTool)::: value proxy node virtualize:::alias->tool->getAlias->if->tool->replaceWithVirtual
ValueProxyNode#getOriginalNode()::: value proxy node get original node:::return->value
ValueProxyNode#getGuard()::: value proxy node get guard:::return->this->proxyPoint
VirtualState.NodeClosure#apply(Node, T)::: node closure apply:::
VirtualState.VirtualClosure#apply(VirtualState)::: virtual closure apply:::
VirtualState#duplicateWithVirtualState()::: virtual state duplicate with virtual state:::
VirtualState#applyToNonVirtual(NodeClosure)::: virtual state apply to non virtual:::
VirtualState#applyToVirtual(VirtualClosure):::Performs a pre-order iteration over all elements reachable from this state that are a subclass of VirtualState.:::
VirtualState#isPartOfThisState(VirtualState)::: virtual state is part of this state:::
VirtualState#graph()::: virtual state graph:::return->super->graph
