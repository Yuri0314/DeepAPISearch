AbstractBeginNode#setWithSpeculationFence():::Set this begin node to be a speculation fence:::
AbstractLocalNode#index():::Gets the index of this local in the array of parameters:::return
AbstractMergeNode#isPhiAtMerge(Node):::Determines if a given node is a phi whose PhiNode#merge() merge is this node.:::return->merge
AbstractMergeNode#removeEnd(AbstractEndNode):::Removes the given end from the merge, along with the entries corresponding to this end in the phis connected to the merge.:::predIndex->phiPredecessorIndex->deleteEnd->foreach->phis->snapshot->if->phi->isDeleted->continue->removedValue->phi->valueAt->phi->removeInput->if->GraphUtil->tryKillUnused
AbstractMergeNode#simplify(SimplifierTool):::This simplify method can deal with a null value for tool, so that it can be used outside of canonicalization.:::currentNext->next->if->origLoopEnd->merge->origLoopEnd->merge->if->return->if->this->anchored->isNotEmpty->return->if->merge->stateAfter->this->stateAfter->return->foreach->phis->foreach->phi->usages->if->merge->isPhiAtMerge->return->getDebug->log->numEnds->this->forwardEndCount->for->i->graph->reduceTrivialMerge->else->if->returnNode->if->anchored->isNotEmpty->returnNode->getMemoryMap->return->phis->phis->snapshot->foreach->foreach->phi->usages->if->return->returnValuePhi->returnNode->result->returnNode->result->isPhiAtMerge->returnNode->result->endNodes->forwardEnds->snapshot->foreach->try->position->returnNode->withNodeSourcePosition->newReturn->graph->returnNode->result->returnValuePhi->valueAt->new->ReturnNode->add->if->tool->end->predecessor->addToWorkList->end->replaceAtPredecessor->catch->finally->GraphUtil->killCFG->foreach->end->safeDelete->foreach->if->tool->allUsagesAvailable->phi->isAlive->phi->hasNoUsages->GraphUtil->killWithUnusedFloatingInputs
BeginStateSplitNode#hasSideEffect():::A begin node has no side effect.:::return
BinaryOpLogicNode#maybeCommuteInputs():::Ensure a canonical ordering of inputs for commutative nodes to improve GVN results:::if->y->isConstant->x->isConstant->x->getId->y->getId->tmp->if->graph->duplicate->graph->findDuplicate->if->return->return
CallTargetNode#targetName():::A human-readable representation of the target, used for debug printing only.:::
CallTargetNode#targetMethod():::Gets the target method for this invocation instruction.:::return
Cancellable#isCancelled():::Determines if this task has been cancelled.:::
ConstantNode#getConstantNodes(StructuredGraph):::Gathers all the ConstantNodes that are inputs to the StructuredGraph#getNodes() live nodes in a given graph.:::return->graph->getNodes->filter
ConstantNode#replace(StructuredGraph, Node):::Replaces this node at its usages with another node.:::replaceAtUsagesAndDelete
ConstantNode#forPrimitive(JavaConstant, StructuredGraph):::Returns a node for a Java primitive.:::return->forConstant
ConstantNode#forPrimitive(JavaConstant):::Returns a node for a Java primitive.:::return->forConstant
ConstantNode#forPrimitive(Stamp, JavaConstant, StructuredGraph):::Returns a node for a primitive of a given type.:::if->istamp->return->istamp->getBits->forIntegerBits->else->return->forPrimitive
ConstantNode#forPrimitive(Stamp, Constant):::Returns a node for a primitive of a given type.:::if->primitive->istamp->return->istamp->getBits->forIntegerBits->else->if->primitive->return->forConstant->else->return->stamp->constant->new->ConstantNode
ConstantNode#forDouble(double, StructuredGraph):::Returns a node for a double constant.:::return->JavaConstant->forDouble->createPrimitive->unique
ConstantNode#forDouble(double):::Returns a node for a double constant.:::return->JavaConstant->forDouble->createPrimitive
ConstantNode#forFloat(float, StructuredGraph):::Returns a node for a float constant.:::return->JavaConstant->forFloat->createPrimitive->unique
ConstantNode#forFloat(float):::Returns a node for a float constant.:::return->JavaConstant->forFloat->createPrimitive
ConstantNode#forLong(long, StructuredGraph):::Returns a node for an long constant.:::return->JavaConstant->forLong->createPrimitive->unique
ConstantNode#forLong(long):::Returns a node for an long constant.:::return->JavaConstant->forLong->createPrimitive
ConstantNode#forInt(int, StructuredGraph):::Returns a node for an integer constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forInt(int):::Returns a node for an integer constant.:::return->JavaConstant->forInt->createPrimitive
ConstantNode#forBoolean(boolean, StructuredGraph):::Returns a node for a boolean constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forBoolean(boolean):::Returns a node for a boolean constant.:::return->JavaConstant->forInt->createPrimitive
ConstantNode#forByte(byte, StructuredGraph):::Returns a node for a byte constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forChar(char, StructuredGraph):::Returns a node for a char constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forShort(short, StructuredGraph):::Returns a node for a short constant.:::return->JavaConstant->forInt->createPrimitive->unique
ConstantNode#forIntegerBits(int, long, StructuredGraph):::Returns a node for a constant integer that's not directly representable as Java primitive (e.g:::return->JavaConstant->forPrimitiveInt->forIntegerBits
ConstantNode#forIntegerBits(int, long):::Returns a node for a constant integer that's not directly representable as Java primitive (e.g:::return->JavaConstant->forPrimitiveInt->forIntegerBits
ConstantNode#forIntegerStamp(Stamp, long, StructuredGraph):::Returns a node for a constant integer that's compatible to a given stamp.:::if->intStamp->return->intStamp->getBits->forIntegerBits->else->return->stamp->getStackKind->forIntegerKind
ConstantNode#forIntegerStamp(Stamp, long):::Returns a node for a constant integer that's compatible to a given stamp.:::if->intStamp->return->intStamp->getBits->forIntegerBits->else->return->stamp->getStackKind->forIntegerKind
ConstantNode#forFloatingStamp(Stamp, double, StructuredGraph):::Returns a node for a constant double that's compatible to a given stamp.:::return->stamp->getStackKind->forFloatingKind
ConstantNode#forFloatingStamp(Stamp, double):::Returns a node for a constant double that's compatible to a given stamp.:::return->stamp->getStackKind->forFloatingKind
ControlSplitNode#setProbability(AbstractBeginNode, double):::Attempts to set the probability for the given successor to the passed value (which has to be in the range of 0.0 and 1.0):::
ControlSplitNode#getPrimarySuccessor():::Primary successor of the control split:::
ControlSplitNode#getSuccessorCount():::Returns the number of successors.:::
DeoptimizingNode#canDeoptimize():::Determines if this node needs deoptimization information.:::
DeoptimizingNode.DeoptBefore#setStateBefore(FrameState):::Sets the FrameState describing the program state before the execution of this node.:::
DeoptimizingNode.DeoptDuring#setStateDuring(FrameState):::Sets the FrameState describing the program state during the execution of this node.:::
DeoptimizingNode.DeoptDuring#computeStateDuring(FrameState):::Compute the FrameState describing the program state during the execution of this node from an input FrameState describing the program state after finishing the execution of this node.:::
FrameState#canProduceBytecodeFrame():::Determines if this frame state can be converted to a BytecodeFrame:::return->code->getCode->code->getMethod->getCode
FrameState#duplicate(int):::Gets a copy of this frame state.:::return->graph->outerFrameState->new->FrameState->add
FrameState#duplicate():::Gets a copy of this frame state.:::return->duplicate
FrameState#duplicateWithVirtualState():::Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer FrameStates, VirtualObjectStates, ...).:::newOuterFrameState->outerFrameState->if->newOuterFrameState->duplicateWithVirtualState->newVirtualMappings->if->virtualObjectMappings->size->new->ArrayList<>->foreach->newVirtualMappings->state->duplicateWithVirtualState->add->return->graph->new->FrameState->add
FrameState#duplicateModifiedDuringCall(int, JavaKind):::Creates a copy of this frame state with one stack element of type popKind popped from the stack.:::return->graph->duplicateModified
FrameState#duplicateModified(int, boolean, JavaKind, JavaKind[], ValueNode[]):::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack:::return->graph->duplicateModified
FrameState#duplicateModified(JavaKind, JavaKind, ValueNode):::Creates a copy of this frame state with the top of stack replaced with with pushedValue which must be of type popKind.:::return->graph->new->JavaKindArr->new->ValueNodeArr->duplicateModified
FrameState#duplicateModified(StructuredGraph, int, boolean, boolean, JavaKind, JavaKind[], ValueNode[]):::Creates a copy of this frame state with one stack element of type popKind popped from the stack and the values in pushedValues pushed on the stack:::copy->if->values->subList->new->ArrayList<>->else->values->subList->new->ArrayList<>->if->if->stackSize->stackAt->copy->copy->size->remove->lastSlot->copy->copy->size->get->copy->copy->size->remove->if->for->i->newStackSize->copy->size->copy->values->values->size->subList->addAll->return->graph->outerFrameState->new->FrameState->add
FrameState#localsSize():::Gets the size of the local variables.:::return
FrameState#stackSize():::Gets the current size (height) of the stack.:::return
FrameState#locksSize():::Gets the number of locked monitors in this frame state.:::return->values->size
FrameState#nestedLockDepth():::Gets the number of locked monitors in this frame state and all #outerFrameState() outer frame states.:::depth->locksSize->for->outer->outerFrameState->outer->outerFrameState->return
FrameState#localAt(int):::Gets the value in the local variables at the specified index.:::return->values->get
FrameState#stackAt(int):::Get the value on the stack at the specified stack index.:::return->values->get
FrameState#lockAt(int):::Get the monitor owner at the specified index.:::return->values->get
FrameState#monitorIdAt(int):::Get the MonitorIdNode that corresponds to the locked object at the specified index.:::return->monitorIds->get
GraphDecoder#handleInvoke(MethodScope, LoopScope, InvokeData):::Invoke nodes do not have the CallTargetNode, FrameState, and successors encoded:::callTarget->ensureNodeCreated->appendInvoke->return
GraphDecoder#handleMergeNode(MergeNode):::Hook for subclasses to perform simplifications for a non-loop-header control flow merge.:::
GraphDecoder#checkLoopExplosionIteration(MethodScope, LoopScope):::Hook for subclasses.:::throw->shouldNotReachHere
GraphDecoder#handleFixedNode(MethodScope, LoopScope, int, FixedNode):::Hook for subclasses.:::
GraphDecoder#makeFixedNodeInputs(MethodScope, LoopScope, Node):::Process the input edges of a node:::edges->node->getNodeClass->getInputEdges->for->index->edges->getDirectCount->if->else->for->index->edges->getDirectCount->edges->getCount
GraphDecoder#decodeFloatingNode(MethodScope, LoopScope, int):::Decodes a non-fixed node, but does not do any post-processing and does not register it.:::readerByteIndex->getByteIndex->setByteIndex->nodeClass->getNodeClasses->getUVInt->node->allocateFloatingNode->if->throw->node->getClass->getName->shouldNotReachHere->makeFloatingNodeInputs->readProperties->setByteIndex->return
GraphDecoder#handleFloatingNodeBeforeAdd(MethodScope, LoopScope, Node):::Hook for subclasses to process a non-fixed node before it is added to the graph.:::return
GraphDecoder#handleFloatingNodeAfterAdd(MethodScope, LoopScope, Node):::Hook for subclasses to process a non-fixed node after it is added to the graph:::return
GraphDecoder#makeSuccessorStubs(MethodScope, LoopScope, Node, boolean):::Process successor edges of a node:::edges->node->getNodeClass->getSuccessorEdges->for->index->edges->getDirectCount->for->index->edges->getDirectCount->edges->getCount
GraphDecoder#cleanupGraph(MethodScope):::Removes unnecessary nodes from the graph after decoding.:::foreach->graph->getNodes->foreach->merge->usages->filter->snapshot->placeholder->replaceAndDelete
GraphEncoder#encodeSingleGraph(StructuredGraph, Architecture):::Utility method that does everything necessary to encode a single graph.:::encoder->new->GraphEncoder->encoder->prepare->encoder->finishPrepare->startOffset->encoder->encode->return->encoder->getEncoding->encoder->getObjects->encoder->getNodeClasses->new->EncodedGraph
GraphEncoder#prepare(StructuredGraph):::Must be invoked before #finishPrepare() and #encode.:::objects->graph->getGuardsStage->addObject->foreach->graph->getNodes->nodeClass->node->getNodeClass->nodeClasses->addObject->objects->node->getNodeSourcePosition->addObject->for->i->nodeClass->getData->getCount->if->objects->getContextType->addObject
GraphEncoder#encode(StructuredGraph):::Compresses a graph to a byte array:::nodeOrder->new->NodeOrder->nodeCount->nodeStartOffsets->new->longArr->cursor->getEntries->while->cursor->advance->node->cursor->getKey->orderId->cursor->getValue->writer->getBytesWritten->nodeClass->node->getNodeClass->writer->nodeClasses->getIndex->putUV->nodeClass->getEdges->writeEdges->nodeClass->getData->writeProperties->nodeClass->getEdges->writeEdges->if->end->merge->end->merge->writeOrderId->writer->merge->phis->count->putUV->foreach->merge->phis->phi->valueAt->writeOrderId->writeOrderId->else->if->exit->exit->stateAfter->writeOrderId->writer->exit->proxies->count->putUV->foreach->exit->proxies->writeOrderId->else->if->invoke->invoke->getContextType->writeObjectId->invoke->callTarget->writeOrderId->invoke->stateAfter->writeOrderId->invoke->next->writeOrderId->if->invokeWithExcpetion->exceptionEdge->invokeWithExcpetion->exceptionEdge->invokeWithExcpetion->next->next->writeOrderId->invokeWithExcpetion->exceptionEdge->writeOrderId->exceptionEdge->stateAfter->writeOrderId->exceptionEdge->next->writeOrderId->metadataStart->TypeConversion->writer->getBytesWritten->asS4->writer->putUV->writer->putUV->for->i->graph->getGuardsStage->writeObjectId->return
GraphEncoder#verifyEncoding(StructuredGraph, EncodedGraph):::Verification code that checks that the decoding of an encode graph is the same as the original graph.:::debugContext->originalGraph->getDebug->decodedGraph->originalGraph->getOptions->new->StructuredGraph.Builder->originalGraph->method->method->originalGraph->isSubstitution->setIsSubstitution->originalGraph->trackNodeSourcePosition->trackNodeSourcePosition->build->decoder->new->GraphDecoder->decoder->decode->decodedGraph->verify->try->GraphComparison->verifyGraphsEqual->catch->originalGraph->getDebug->try->scope->debugContext->scope->debugContext->dump->debugContext->dump->catch->finally->throw->finally->return
GuardNode#getCondition():::The instruction that produces the tested boolean value.:::return
IfNode#trueSuccessor():::Gets the true successor.:::return
IfNode#falseSuccessor():::Gets the false successor.:::return
IfNode#successor(boolean):::Gets the node corresponding to the specified outcome of the branch.:::return
IfNode#constantValues(ValueNode, AbstractMergeNode, boolean):::Gets an array of constants derived from a node that is either a ConstantNode or a PhiNode whose input values are all constants:::if->node->isConstant->result->merge->forwardEndCount->new->ConstantArr->Arrays->node->asConstant->fill->return->if->phi->if->phi->merge->phi->valueCount->merge->forwardEndCount->result->merge->forwardEndCount->new->ConstantArr->i->foreach->phi->values->if->n->isConstant->return->n->asConstant->return->return
InliningLog#addDecision(Invokable, boolean, String, EconomicMap, InliningLog, String, Object...):::Add an inlining decision for the specified invoke:::if->return->callsite->leaves->get->getTargetMethod->decision->String->format->invoke->getTargetMethod->new->Decision->add->if->leaves->removeKey->if->return->mapping->EconomicMap->create->foreach->child->callsite->addChild->copyTree->entries->getEntries->while->entries->advance->invokeFromCallee->entries->getKey->callsiteFromCallee->entries->getValue->if->invokeFromCallee->asFixedNode->isDeleted->continue->inlinedInvokeFromCallee->replacements->invokeFromCallee->asFixedNode->get->descendant->mapping->get->leaves->put
InliningLog#addLog(UnmodifiableEconomicMap, InliningLog):::Append the inlining decision tree from the specified log:::mapping->EconomicMap->create->foreach->child->root->addChild->copyTree->entries->getEntries->while->entries->advance->replacementInvoke->entries->getKey->replacementCallsite->entries->getValue->if->replacementInvoke->asFixedNode->isDeleted->continue->invoke->replacements->replacementInvoke->asFixedNode->get->callsite->mapping->get->leaves->put
InliningLog#replaceLog(UnmodifiableEconomicMap, InliningLog):::Completely replace the current log with the copy of the specified log:::mapping->EconomicMap->create->copyTree->replacementEntries->getEntries->while->replacementEntries->advance->replacementInvoke->replacementEntries->getKey->replacementSite->replacementEntries->getValue->if->replacementInvoke->isAlive->invoke->replacements->get->site->mapping->get->leaves->put
InliningLog#openUpdateScope(BiConsumer):::Creates and sets a new update scope for the log:::if->scope->new->UpdateScope->scope->activate->return->else->return
InliningLog#openDefaultUpdateScope():::Creates a new update scope that does not update the log:::if->noUpdates->activate->return->else->return
InliningLog#formatAsTree(boolean):::Formats the inlining log as a hierarchical tree.:::if->isEmpty->return->builder->new->StringBuilder->formatAsTree->return->builder->toString
Invokable#updateInliningLogAfterRegister(StructuredGraph):::Called on a Invokable node after it is registered with a graph:::log->newGraph->getInliningLog->if->log->getUpdateScope->log->getUpdateScope->accept->else->log->trackNewCallsite
Invokable#updateInliningLogAfterClone(Node):::Called on a Invokable node after it was cloned from another node:::if->asFixedNode->getOptions->getValue->log->asFixedNode->graph->getInliningLog->if->log->getUpdateScope->log->getUpdateScope->accept->else->if->other->graph->this->asFixedNode->graph->log->removeLeafCallsite->log->trackDuplicatedCallsite->else->throw->GraalError->shouldNotReachHere
Invoke#isPolymorphic():::True if this invocation is almost certainly polymorphic, false when in doubt.:::
Invoke#getContextMethod():::Returns the ResolvedJavaMethod method from which this invoke is executed:::state->stateAfter->if->stateDuring->return->state->getMethod
Invoke#getContextType():::Returns the ResolvedJavaType type from which this invoke is executed:::contextMethod->getContextMethod->if->return->return->contextMethod->getDeclaringClass
InvokeWithExceptionNode#replaceWithInvoke():::Replaces this InvokeWithExceptionNode with a normal InvokeNode:::newInvoke->graph->getLocationIdentity->new->InvokeNode->add->newInvoke->setStateAfter->newInvoke->setStateDuring->oldException->graph->this->next->replaceSplitWithFixed->GraphUtil->killCFG->return
LogicConstantNode#forBoolean(boolean, Graph):::Returns a node for a boolean constant.:::return->graph->new->LogicConstantNode->unique
LogicConstantNode#forBoolean(boolean):::Returns a node for a boolean constant.:::return->new->LogicConstantNode
LogicConstantNode#tautology(Graph):::Gets a constant for true.:::return->forBoolean
LogicConstantNode#contradiction(Graph):::Gets a constant for false.:::return->forBoolean
LogicConstantNode#tautology():::Gets a constant for true.:::return->forBoolean
LogicConstantNode#contradiction():::Gets a constant for false.:::return->forBoolean
LogicNode#implies(boolean, LogicNode):::Determines what this condition implies about the other:::if->return->TriState->get->if->return->this->getValue->implies->flip->return
LoopBeginNode#disableSafepoint():::Disables safepoint for the whole loop, i.e., for all LoopEndNode loop ends.:::foreach->loopEnds->loopEnd->disableSafepoint
LoopBeginNode#loopEnds():::Returns the unordered set of LoopEndNode that correspond to back-edges for this loop:::return->usages->filter
LoopBeginNode#orderedLoopEnds():::Returns the set of LoopEndNode that correspond to back-edges for this loop, in increasing #phiPredecessorIndex order:::result->this->getLoopEndCount->new->LoopEndNodeArr->foreach->loopEnds->end->endIndex->return
LoopBeginNode#canonicalizePhis(SimplifierTool):::Coalesces loop phis that represent the same value (which is not handled by normal Global Value Numbering).:::phiCount->phis->count->if->phiInputCount->phiPredecessorCount->phiIndex->selfIncrement->new->intArrs->phis->this->phis->snapshot->new->PhiNodeArr->toArray->for
LoopEndNode#disableSafepoint():::Disables safepoints for only this loop end (in contrast to disabling it for LoopBeginNode#disableSafepoint() the whole loop.:::
LoopEndNode#endIndex():::Returns the index of this loop end amongst its LoopBeginNode's loop ends.<br>  Since a LoopBeginNode also has LoopBeginNode#forwardEnds() forward ends, this is not the index into PhiNode values at the loop begin:::return
NamedLocationIdentity#mutable(String):::Creates a named unique location identity for read and write operations against mutable memory.:::return->create
NamedLocationIdentity#immutable(String):::Creates a named unique location identity for read operations against immutable memory:::return->create
NamedLocationIdentity#getArrayLocation(JavaKind):::Returns the named location identity for an array of the given element kind:::return->ARRAY_LOCATIONS->get
NodeView#stamp(ValueNode):::Return a view-specific stamp of the node:::
PhiNode#valueAt(int):::Get the instruction that produces the value associated with the i'th predecessor of the merge.:::return->values->get
PhiNode#initializeValueAt(int, ValueNode):::Sets the value at the given index and makes sure that the values list is large enough.:::while->values->size->values->add->values->set
PhiNode#valueCount():::Get the number of inputs to this phi (i.e:::return->values->size
PhiNode#valueDescription():::String describing the kind of value this Phi merges:::return
PhiNode#singleValueOrThis():::If all inputs are the same value, this value is returned, otherwise this:::singleValue->valueAt->count->valueCount->for->i->return
PhiNode#singleBackValueOrThis():::If all inputs (but the first one) are the same value, the value is returned, otherwise this:::valueCount->valueCount->singleValue->valueAt->for->i->return
PiArrayNode#piArrayCastToSnippetReplaceeStamp(Object, int):::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.:::
PiNode#asNonNullClass(Object):::Casts an object to have an exact, non-null stamp representing Class.:::return->asNonNullClassIntrinsic
PiNode#asNonNullObject(Object):::Casts an object to have an exact, non-null stamp representing Class.:::return->asNonNullClassIntrinsic
PiNode#piCastToSnippetReplaceeStamp(Object):::Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.:::
PiNode#piCastNonNull(Object, GuardingNode):::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.:::
PiNode#piCastNonNullClass(Class, GuardingNode):::Changes the stamp of an object and ensures the newly stamped value is non-null and does not float above a given guard.:::
PiNode#piCastNonNull(Object, ResolvedJavaType):::Changes the stamp of an object to represent a given type and to indicate that the object is not null.:::return->piCast
PiNode.Placeholder#makeReplacement(Stamp):::Replaces this node with a PiNode during snippet instantiation.:::value->graph->PiNode->object->create->maybeAddOrUnique->replaceAndDelete
ShortCircuitOrNode#getShortCircuitProbability():::Gets the probability that the #getY() y part of this binary node is not evaluated:::return
SimplifyingGraphDecoder#canonicalizeFixedNode(MethodScope, Node):::Canonicalizes the provided node, which was originally a FixedNode but can already be canonicalized (and therefore be a non-fixed node).:::if->loadFieldNode->return->loadFieldNode->canonical->else->if->guard->if->guard->getCondition->condition->guard->getCondition->if->condition->getValue->guard->isNegated->deopt->guard->getAction->guard->getReason->guard->getSpeculation->new->DeoptimizeNode->if->guard->stateBefore->deopt->guard->stateBefore->setStateBefore->return->else->return->return->else->if->ifNode->if->ifNode->condition->ifNode->eliminateNegation->if->ifNode->condition->condition->ifNode->condition->getValue->survivingSuccessor->ifNode->getSuccessor->deadSuccessor->ifNode->getSuccessor->graph->removeSplit->deadSuccessor->safeDelete->return->else->if->loadIndexedNode->return->loadIndexedNode->canonical->else->if->arrayLengthNode->return->arrayLengthNode->canonical->else->if->value->isConstant->switchNode->value->switchNode->value->asJavaConstant->asInt->survivingSuccessor->switchNode->successorAtKey->allSuccessors->switchNode->successors->snapshot->graph->removeSplit->foreach->if->successor->safeDelete->return->else->if->return->canonical->else->return
StateSplit#stateAfter():::Gets the FrameState corresponding to the state of the JVM after execution of this node.:::
StateSplit#setStateAfter(FrameState):::Sets the FrameState corresponding to the state of the JVM after execution of this node.:::
StateSplit#hasSideEffect():::Determines if this node has a side-effect:::
StructuredGraph#method():::Gets the root method from which this graph was built.:::return
StructuredGraph#copy(String, Consumer>, DebugContext):::Creates a copy of this graph.:::return->copy
StructuredGraph#removeFixed(FixedWithNextNode):::Unlinks a node from all its control flow neighbors and then removes it from its graph:::if->prepareDelete->GraphUtil->unlinkFixedNode->node->safeDelete
StructuredGraph#useProfilingInfo():::Determines if ProfilingInfo is used during construction of this graph.:::return
StructuredGraph#isSubstitution():::Returns true if this graph is built without parsing the #method() root method or if the root method is annotated by Snippet or MethodSubstitution:::return
StructuredGraph#getProfilingInfo():::Gets the profiling info for the #method() root method of this graph.:::return->method->getProfilingInfo
StructuredGraph#getProfilingInfo(ResolvedJavaMethod):::Gets the profiling info for a given method that is or will be part of this graph, taking into account #useProfilingInfo().:::if->return->m->getProfilingInfo->else->return->DefaultProfilingInfo->get
StructuredGraph#getAssumptions():::Gets the object for recording assumptions while constructing of this graph.:::return
StructuredGraph#getMethods():::Gets an unmodifiable view of the methods that were inlined while constructing this graph.:::if->return->Collections->unmodifiableList->return->Collections->emptyList
StructuredGraph#recordMethod(ResolvedJavaMethod):::Records that method was used to build this graph.:::if->methods->add
StructuredGraph#updateMethods(StructuredGraph):::Updates the #getMethods() methods used to build this graph with the methods used to build another graph.:::if->if->methods->add->foreach->methods->add
StructuredGraph#getFields():::Gets an unmodifiable view of the fields that were accessed while constructing this graph.:::return
StructuredGraph#recordField(ResolvedJavaField):::Records that field was accessed in this graph.:::if->createFieldSet->fields->add
StructuredGraph#updateFields(StructuredGraph):::Updates the #getFields() fields of this graph with the accessed fields of another graph.:::if->if->createFieldSet->addAll
StructuredGraph#getBytecodeSize():::Gets the input bytecode ResolvedJavaMethod#getCodeSize() size from which this graph is constructed:::res->if->rootMethod->getCodeSize->if->foreach->e->getCodeSize->return
UnaryOpLogicNode#getSucceedingStampForValue(boolean, Stamp):::In general the input stamp cannot be trusted, this method is reserved for the cases when it's "safe" to use the input stamp:::succStamp->getSucceedingStampForValue->if->succStamp->join->return
UnaryOpLogicNode#getSucceedingStampForValue(boolean):::The input stamp cannot be trusted, the returned stamp cannot use the input stamp to narrow itself or derive any assumptions:::
ValueNode#updateStamp(Stamp):::Checks if the given stamp is different than the current one ( newStamp.equals(oldStamp) == false):::if->newStamp->equals->return->else->return
ValueNode#inferStamp():::This method can be overridden by subclasses of ValueNode if they need to recompute their stamp if their inputs change:::return
ValueNode#isConstant():::Checks whether this value is a constant (i.e:::return
ValueNode#isNullConstant():::Checks whether this value represents the null constant.:::value->asJavaConstant->return->value->isNull
ValueNode#asConstant():::Convert this value to a constant if it is a constant, otherwise return null.:::if->return->getValue->else->return
ValueNode#hasUsagesOtherThan(ValueNode, NodeValueMap):::Checks if this node has usages other than the given node node.:::foreach->usages->if->nodeValueMap->hasOperand->return->return
ValueNodeUtil#valueString(ValueNode):::Converts a given instruction to a value string:::return->value->getStackKind->getTypeChar->toLowerCase->value->toString
VirtualState#applyToVirtual(VirtualClosure):::Performs a pre-order iteration over all elements reachable from this state that are a subclass of VirtualState.:::
