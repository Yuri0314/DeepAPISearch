BMPattern#matches(CharacterIterator, int, int)::: pattern matches:::if->return->this->matchesIgnoreCase->plength->if->return->index->while->pindex->nindex->ch->do->if->iterator->setIndex->break->if->return->while->if->return
BMPattern#matches(String, int, int)::: pattern matches:::if->return->this->matchesIgnoreCase->plength->if->return->index->while->pindex->nindex->ch->do->if->str->charAt->break->if->return->while->if->return
BMPattern#matches(char[], int, int)::: pattern matches:::if->return->this->matchesIgnoreCase->plength->if->return->index->while->pindex->nindex->ch->do->if->break->if->return->while->if->return
BMPattern#matchesIgnoreCase(CharacterIterator, int, int)::: pattern matches ignore case:::plength->if->return->index->while->pindex->nindex->ch->do->ch1->iterator->setIndex->ch2->if->Character->toUpperCase->Character->toUpperCase->if->Character->toLowerCase->Character->toLowerCase->break->if->return->while->if->return
BMPattern#matchesIgnoreCase(String, int, int)::: pattern matches ignore case:::plength->if->return->index->while->pindex->nindex->ch->do->ch1->text->charAt->ch2->if->Character->toUpperCase->Character->toUpperCase->if->Character->toLowerCase->Character->toLowerCase->break->if->return->while->if->return
BMPattern#matchesIgnoreCase(char[], int, int)::: pattern matches ignore case:::plength->if->return->index->while->pindex->nindex->ch->do->ch1->ch2->if->Character->toUpperCase->Character->toUpperCase->if->Character->toLowerCase->Character->toLowerCase->break->if->return->while->if->return
CaseInsensitiveMap#get(int)::: Return a list of code point characters (not including the input value)  that can be substituted in a case insensitive match:::return->getMapping
CaseInsensitiveMap#getMapping(int)::: case insensitive map get mapping:::chunk->offset->return
CaseInsensitiveMap#buildCaseInsensitiveMap()::: case insensitive map build case insensitive map:::new->intArrs->lc->uc->for->i
CaseInsensitiveMap#expandMap(int[], int)::: case insensitive map expand map:::oldLen->newMap->new->intArr->System->arraycopy->return
CaseInsensitiveMap#set(int, int[])::: case insensitive map set:::chunk->offset
CaseInsensitiveMap#updateMap(int, int[], int, int[], int)::: case insensitive map update map:::for->i->if->contains->expandAndAdd->set->return
CaseInsensitiveMap#contains(int[], int)::: case insensitive map contains:::for->i->return
CaseInsensitiveMap#contains(int[], int, int)::: case insensitive map contains:::for->i->return
CaseInsensitiveMap#expandAndAdd(int[], int, int)::: case insensitive map expand and add:::oldLen->newMap->new->intArr->System->arraycopy->return
Match#clone()::: match clone:::ma->new->Match->if->ma->setNumberOfGroups->if->ma->setSource->if->ma->setSource->for->i->return
Match#setNumberOfGroups(int)::: match set number of groups:::oldn->if->new->intArr->new->intArr->for->i
Match#setSource(CharacterIterator)::: match set source:::
Match#setSource(String)::: match set source:::
Match#setSource(char[])::: match set source:::
Match#setBeginning(int, int)::: match set beginning:::
Match#setEnd(int, int)::: match set end:::
Match#getNumberOfGroups():::Return the number of regular expression groups:::if->throw->new->IllegalStateException->return
Match#getBeginning(int):::Return a start position in the target text matched to specified regular expression group.:::if->throw->new->IllegalStateException->if->throw->new->IllegalArgumentException->return
Match#getEnd(int):::Return an end position in the target text matched to specified regular expression group.:::if->throw->new->IllegalStateException->if->throw->new->IllegalArgumentException->return
Match#getCapturedText(int):::Return an substring of the target text matched to specified regular expression group.:::if->throw->new->IllegalStateException->if->throw->new->IllegalArgumentException->ret->begin->end->if->return->if->REUtil->substring->else->if->substring->else->new->String->return
Op#createDot()::: op create dot:::if->return->new->Op
Op#createChar(int)::: op create char:::if->return->new->CharOp
Op#createAnchor(int)::: op create anchor:::if->return->new->CharOp
Op#createCapture(int, Op)::: op create capture:::if->op->new->CharOp->return
Op#createUnion(int)::: op create union:::if->return->new->UnionOp
Op#createClosure(int)::: op create closure:::if->return->new->ModifierOp
Op#createNonGreedyClosure()::: op create non greedy closure:::if->return->new->ChildOp
Op#createQuestion(boolean)::: op create question:::if->return->new->ChildOp
Op#createRange(Token)::: op create range:::if->return->new->RangeOp
Op#createLook(int, Op, Op)::: op create look:::if->op->new->ChildOp->op->setChild->return
Op#createBackReference(int)::: op create back reference:::if->return->new->CharOp
Op#createString(String)::: op create string:::if->return->new->StringOp
Op#createIndependent(Op, Op)::: op create independent:::if->op->new->ChildOp->op->setChild->return
Op#createModifier(Op, Op, int, int)::: op create modifier:::if->op->new->ModifierOp->op->setChild->return
Op#createCondition(Op, int, Op, Op, Op)::: op create condition:::if->op->new->ConditionOp->return
Op#size()::: op size:::return
Op#elementAt(int)::: op element at:::throw->new->RuntimeException
Op#getChild()::: op get child:::throw->new->RuntimeException
Op#getData()::: op get data:::throw->new->RuntimeException
Op#getData2()::: op get data2:::throw->new->RuntimeException
Op#getToken()::: op get token:::throw->new->RuntimeException
Op#getString()::: op get string:::throw->new->RuntimeException
Op.CharOp#getData()::: char op get data:::return
Op.UnionOp#addElement(Op)::: union op add element:::add
Op.UnionOp#size()::: union op size:::return->size
Op.UnionOp#elementAt(int)::: union op element at:::return->get
Op.ChildOp#setChild(Op)::: child op set child:::
Op.ChildOp#getChild()::: child op get child:::return
Op.ModifierOp#getData()::: modifier op get data:::return
Op.ModifierOp#getData2()::: modifier op get data2:::return
Op.RangeOp#getToken()::: range op get token:::return
Op.StringOp#getString()::: string op get string:::return
ParseException#getLocation()::: parse exception get location:::return
ParserForXMLSchema#processCaret()::: parser for schema process caret:::this->next->return->Token->createChar
ParserForXMLSchema#processDollar()::: parser for schema process dollar:::this->next->return->Token->createChar
ParserForXMLSchema#processLookahead()::: parser for schema process lookahead:::throw->ex
ParserForXMLSchema#processNegativelookahead()::: parser for schema process negativelookahead:::throw->ex
ParserForXMLSchema#processLookbehind()::: parser for schema process lookbehind:::throw->ex
ParserForXMLSchema#processNegativelookbehind()::: parser for schema process negativelookbehind:::throw->ex
ParserForXMLSchema#processBacksolidus_A()::: parser for schema process backsolidus_ a:::throw->ex
ParserForXMLSchema#processBacksolidus_Z()::: parser for schema process backsolidus_ z:::throw->ex
ParserForXMLSchema#processBacksolidus_z()::: parser for schema process backsolidus_z:::throw->ex
ParserForXMLSchema#processBacksolidus_b()::: parser for schema process backsolidus_b:::throw->ex
ParserForXMLSchema#processBacksolidus_B()::: parser for schema process backsolidus_ b:::throw->ex
ParserForXMLSchema#processBacksolidus_lt()::: parser for schema process backsolidus_lt:::throw->ex
ParserForXMLSchema#processBacksolidus_gt()::: parser for schema process backsolidus_gt:::throw->ex
ParserForXMLSchema#processStar(Token)::: parser for schema process star:::this->next->return->Token->createClosure
ParserForXMLSchema#processPlus(Token)::: parser for schema process plus:::this->next->return->Token->Token->createClosure->createConcat
ParserForXMLSchema#processQuestion(Token)::: parser for schema process question:::this->next->par->Token->createUnion->par->addChild->par->Token->createEmpty->addChild->return
ParserForXMLSchema#checkQuestion(int)::: parser for schema check question:::return
ParserForXMLSchema#processParen()::: parser for schema process paren:::this->next->tok->Token->this->parseRegex->createParen->if->this->read->throw->ex->this->next->return
ParserForXMLSchema#processParen2()::: parser for schema process paren2:::throw->ex
ParserForXMLSchema#processCondition()::: parser for schema process condition:::throw->ex
ParserForXMLSchema#processModifiers()::: parser for schema process modifiers:::throw->ex
ParserForXMLSchema#processIndependent()::: parser for schema process independent:::throw->ex
ParserForXMLSchema#processBacksolidus_c()::: parser for schema process backsolidus_c:::this->next->return->this->getTokenForShorthand
ParserForXMLSchema#processBacksolidus_C()::: parser for schema process backsolidus_ c:::this->next->return->this->getTokenForShorthand
ParserForXMLSchema#processBacksolidus_i()::: parser for schema process backsolidus_i:::this->next->return->this->getTokenForShorthand
ParserForXMLSchema#processBacksolidus_I()::: parser for schema process backsolidus_ i:::this->next->return->this->getTokenForShorthand
ParserForXMLSchema#processBacksolidus_g()::: parser for schema process backsolidus_g:::throw->this->ex
ParserForXMLSchema#processBacksolidus_X()::: parser for schema process backsolidus_ x:::throw->ex
ParserForXMLSchema#processBackreference()::: parser for schema process backreference:::throw->ex
ParserForXMLSchema#processCIinCharacterClass(RangeToken, int)::: parser for schema process iin character class:::tok->this->getTokenForShorthand->mergeRanges->return
ParserForXMLSchema#parseCharacterClass(boolean):::Parses a character-class-expression, not a character-class-escape:::this->setContext->this->next->nrange->wasDecoded->base->tok->if->this->read->this->next->Token->createRange->base->addRange->Token->createRange->else->Token->createRange->type->firstloop->while->this->read->if->if->base->subtractRanges->break->c->end->if->switch->tok->this->getTokenForShorthand->mergeRanges->break->this->processCIinCharacterClass->if->break->pstart->tok2->this->processBacksolidus_pP->if->throw->this->ex->tok->mergeRanges->break->this->decodeEscaped->break->this->decodeEscaped->else->if->if->base->subtractRanges->range2->this->parseCharacterClass->tok->subtractRanges->if->this->read->throw->this->ex->break->this->next->if->if->if->throw->this->ex->if->throw->this->ex->if->throw->this->ex->if->this->read->if->this->isSet->tok->addRange->else->addCaseInsensitiveChar->else->this->next->if->this->read->throw->this->ex->if->if->this->isSet->tok->addRange->else->addCaseInsensitiveChar->tok->addRange->else->if->throw->this->ex->else->rangeend->if->if->throw->this->ex->if->throw->this->ex->if->throw->this->ex->else->if->this->decodeEscaped->this->next->if->throw->this->ex->if->this->isSet->tok->addRange->else->addCaseInsensitiveCharRange->if->this->read->throw->this->ex->tok->sortRanges->tok->compactRanges->this->setContext->this->next->return
ParserForXMLSchema#parseSetOperations()::: parser for schema parse set operations:::throw->this->ex
ParserForXMLSchema#getTokenForShorthand(int)::: parser for schema get token for shorthand:::switch->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->return->ParserForXMLSchema->getRange->throw->Integer->toString->new->RuntimeException
ParserForXMLSchema#decodeEscaped()::: parser for schema decode escaped:::if->this->read->throw->ex->c->switch->break->break->break->break->throw->ex->return
ParserForXMLSchema#getRange(String, boolean)::: parser for schema get range:::if->new->HashMap<>->new->HashMap<>->tok->Token->createRange->setupRange->ranges->put->ranges2->Token->complementRanges->put->Token->createRange->setupRange->ranges->put->ranges2->Token->complementRanges->put->Token->createRange->tok->Token->getRange->mergeRanges->tok->Token->getRange->mergeRanges->tok->Token->getRange->mergeRanges->ranges2->put->ranges->Token->complementRanges->put->Token->createRange->setupRange->ranges->put->ranges2->Token->complementRanges->put->Token->createRange->setupRange->setupRange->tok->addRange->tok->addRange->ranges->put->ranges2->Token->complementRanges->put->tok->ranges->get->ranges2->get->return
ParserForXMLSchema#setupRange(Token, String)::: parser for schema setup range:::len->src->length->for->i
ParserForXMLSchema#setupRange(Token, int[])::: parser for schema setup range:::len->for->i
RangeToken#addRange(int, int)::: range token add range:::r1->r2->if->else->pos->if->new->intArr->this->setSorted->else->if->return->temp->new->intArr->System->arraycopy->if->this->setSorted->if->this->sortRanges
RangeToken#isSorted()::: range token is sorted:::return
RangeToken#setSorted(boolean)::: range token set sorted:::if
RangeToken#isCompacted()::: range token is compacted:::return
RangeToken#setCompacted()::: range token set compacted:::
RangeToken#sortRanges()::: range token sort ranges:::if->this->isSorted->return->if->return->for->i->this->setSorted
RangeToken#compactRanges():::this.ranges is sorted.:::DEBUG->if->return->if->this->isCompacted->return->base->target->while->if->else->baseend->while->if->break->if->if->println->else->if->if->println->else->if->if->println->else->throw->new->RuntimeException->if->result->new->intArr->System->arraycopy->this->setCompacted
RangeToken#mergeRanges(Token)::: range token merge ranges:::tok->this->sortRanges->tok->sortRanges->if->return->this->setSorted->if->new->intArr->System->arraycopy->return->result->new->intArr->for->i->j->k
RangeToken#subtractRanges(Token)::: range token subtract ranges:::if->this->intersectRanges->return->tok->if->return->this->sortRanges->this->compactRanges->tok->sortRanges->tok->compactRanges->result->new->intArr->wp->src->sub->while->srcbegin->srcend->subbegin->subend->if->else->if->if->else->if->else->if->else->else->if->else->throw->new->RuntimeException->while->new->intArr->System->arraycopy
RangeToken#intersectRanges(Token)::: range token intersect ranges:::tok->if->return->this->sortRanges->this->compactRanges->tok->sortRanges->tok->compactRanges->result->new->intArr->wp->src1->src2->while->src1begin->src1end->src2begin->src2end->if->else->if->if->else->if->else->if->else->else->if->else->throw->new->RuntimeException->new->intArr->System->arraycopy
RangeToken#complementRanges(Token):::for RANGE: Creates complement:::if->throw->new->IllegalArgumentException->tok->tok->sortRanges->tok->compactRanges->len->if->last->if->ret->Token->createRange->new->intArr->wp->if->for->i->if->ret->setCompacted->return
RangeToken#getCaseInsensitiveToken()::: range token get case insensitive token:::if->return->uppers->Token->createRange->Token->createNRange->for->i->lowers->Token->createRange->Token->createNRange->for->i->lowers->mergeRanges->lowers->mergeRanges->lowers->compactRanges->return
RangeToken#dumpRanges()::: range token dump ranges:::print->if->println->return->for->i->println
RangeToken#match(int)::: range token match:::if->this->createMap->ret->if->if->return->for->i->else->if->return->for->i->return
RangeToken#createMap()::: range token create map:::asize->map->new->intArr->nonMapIndex->for->i->for->i
RangeToken#toString(int)::: range token to string:::ret->if->if->else->if->else->if->else->if->else->sb->new->StringBuilder->sb->append->for->i->sb->append->sb->toString->else->if->else->if->else->if->else->sb->new->StringBuffer->sb->append->for->i->sb->append->sb->toString->return
RangeToken#escapeCharInCharClass(int)::: range token escape char in char class:::ret->switch->break->break->break->break->break->break->if->pre->Integer->toHexString->pre->pre->length->pre->length->substring->else->if->pre->Integer->toHexString->pre->pre->length->pre->length->substring->else->return
RegexParser#setLocale(Locale)::: regex parser set locale:::try->if->SecuritySupport->getResourceBundle->else->SecuritySupport->getResourceBundle->catch->throw->mre->getMessage->new->RuntimeException->finally
RegexParser#ex(String, int)::: regex parser ex:::return->getString->new->ParseException
RegexParser#isSet(int)::: regex parser is set:::return
RegexParser#parse(String, int)::: regex parser parse:::this->setContext->if->this->isSet->REUtil->stripExtendedComment->length->this->next->ret->this->parseRegex->if->throw->ex->if->this->read->throw->ex->if->for->i->size->clear->return
RegexParser#setContext(int)::: regex parser set context:::
RegexParser#read()::: regex parser read:::return
RegexParser#next()::: regex parser next:::if->return->ret->ch->charAt->if->switch->if->throw->ex->charAt->break->if->charAt->else->break->if->this->isSet->charAt->break->if->REUtil->isHighSurrogate->low->charAt->if->REUtil->isLowSurrogate->REUtil->composeFromSurrogates->return->switch->break->break->break->break->break->break->break->if->this->isSet->else->break->if->this->isSet->else->break->if->break->if->charAt->break->if->throw->ex->charAt->switch->break->break->break->break->break->if->throw->ex->charAt->if->else->if->else->throw->ex->break->while->charAt->if->break->if->throw->ex->break->if->break->else->if->break->throw->ex->break->if->throw->ex->charAt->break
RegexParser#parseRegex():::regex ::= term (`|` term)* term ::= factor+ factor ::= ('^' | '$' | '\A' | '\Z' | '\z' | '\b' | '\B' | '\<' | '\>'            | atom (('*' | '+' | '?' | minmax ) '?'? )?)            | '(?=' regex ')'  | '(?!' regex ')'  | '(?<=' regex ')'  | '(?<!' regex ')' atom ::= char | '.' | range | '(' regex ')' | '(?:' regex ')' | '\' [0-9]          | '\w' | '\W' | '\d' | '\D' | '\s' | '\S' | category-block:::tok->this->parseTerm->parent->while->this->read->this->next->if->Token->createUnion->parent->addChild->tok->this->parseTerm->addChild->return
RegexParser#parseTerm():::term ::= factor+:::ch->this->read->if->return->Token->createEmpty->else->tok->this->parseFactor->concat->while->this->read->if->Token->createConcat->concat->addChild->concat->this->parseFactor->addChild->return
RegexParser#processCaret()::: regex parser process caret:::this->next->return
RegexParser#processDollar()::: regex parser process dollar:::this->next->return
RegexParser#processLookahead()::: regex parser process lookahead:::this->next->tok->Token->this->parseRegex->createLook->if->this->read->throw->ex->this->next->return
RegexParser#processNegativelookahead()::: regex parser process negativelookahead:::this->next->tok->Token->this->parseRegex->createLook->if->this->read->throw->ex->this->next->return
RegexParser#processLookbehind()::: regex parser process lookbehind:::this->next->tok->Token->this->parseRegex->createLook->if->this->read->throw->ex->this->next->return
RegexParser#processNegativelookbehind()::: regex parser process negativelookbehind:::this->next->tok->Token->this->parseRegex->createLook->if->this->read->throw->ex->this->next->return
RegexParser#processBacksolidus_A()::: regex parser process backsolidus_ a:::this->next->return
RegexParser#processBacksolidus_Z()::: regex parser process backsolidus_ z:::this->next->return
RegexParser#processBacksolidus_z()::: regex parser process backsolidus_z:::this->next->return
RegexParser#processBacksolidus_b()::: regex parser process backsolidus_b:::this->next->return
RegexParser#processBacksolidus_B()::: regex parser process backsolidus_ b:::this->next->return
RegexParser#processBacksolidus_lt()::: regex parser process backsolidus_lt:::this->next->return
RegexParser#processBacksolidus_gt()::: regex parser process backsolidus_gt:::this->next->return
RegexParser#processStar(Token)::: regex parser process star:::this->next->if->this->read->this->next->return->Token->createNGClosure->else->return->Token->createClosure
RegexParser#processPlus(Token)::: regex parser process plus:::this->next->if->this->read->this->next->return->Token->Token->createNGClosure->createConcat->else->return->Token->Token->createClosure->createConcat
RegexParser#processQuestion(Token)::: regex parser process question:::this->next->par->Token->createUnion->if->this->read->this->next->par->Token->createEmpty->addChild->par->addChild->else->par->addChild->par->Token->createEmpty->addChild->return
RegexParser#checkQuestion(int)::: regex parser check question:::return->charAt
RegexParser#processParen()::: regex parser process paren:::this->next->p->tok->Token->this->parseRegex->createParen->if->this->read->throw->ex->this->next->return
RegexParser#processParen2()::: regex parser process paren2:::this->next->tok->Token->this->parseRegex->createParen->if->this->read->throw->ex->this->next->return
RegexParser#processCondition()::: regex parser process condition:::if->throw->ex->refno->condition->ch->charAt->if->finalRefno->if->throw->ex->while->charAt->if->if->else->break->else->break->if->new->ArrayList<>->new->ReferencePosition->add->if->charAt->throw->ex->else->if->this->next->this->parseFactor->switch->break->if->this->read->throw->ex->break->throw->ex->this->next->yesPattern->this->parseRegex->noPattern->if->if->yesPattern->size->throw->ex->yesPattern->getChild->yesPattern->getChild->if->this->read->throw->ex->this->next->return->Token->createCondition
RegexParser#processModifiers()::: regex parser process modifiers:::add->mask->ch->while->charAt->v->REUtil->getOptionValue->if->break->if->throw->ex->if->while->charAt->v->REUtil->getOptionValue->if->break->if->throw->ex->tok->if->this->next->Token->this->parseRegex->createModifierGroup->if->this->read->throw->ex->this->next->else->if->this->next->Token->this->parseRegex->createModifierGroup->else->throw->ex->return
RegexParser#processIndependent()::: regex parser process independent:::this->next->tok->Token->this->parseRegex->createLook->if->this->read->throw->ex->this->next->return
RegexParser#processBacksolidus_c()::: regex parser process backsolidus_c:::ch2->if->charAt->throw->ex->this->next->return->Token->createChar
RegexParser#processBacksolidus_C()::: regex parser process backsolidus_ c:::throw->ex
RegexParser#processBacksolidus_i()::: regex parser process backsolidus_i:::tok->Token->createChar->this->next->return
RegexParser#processBacksolidus_I()::: regex parser process backsolidus_ i:::throw->ex
RegexParser#processBacksolidus_g()::: regex parser process backsolidus_g:::this->next->return->Token->getGraphemePattern
RegexParser#processBacksolidus_X()::: regex parser process backsolidus_ x:::this->next->return->Token->getCombiningCharacterSequence
RegexParser#processBackreference()::: regex parser process backreference:::refnum->finalRefnum->if->throw->ex->while->ch->charAt->if->if->else->break->else->break->tok->Token->createBackReference->if->new->ArrayList<>->new->ReferencePosition->add->this->next->return
RegexParser#parseFactor():::factor ::= ('^' | '$' | '\A' | '\Z' | '\z' | '\b' | '\B' | '\<' | '\>'            | atom (('*' | '+' | '?' | minmax ) '?'? )?)            | '(?=' regex ')'  | '(?!' regex ')'  | '(?<=' regex ')'  | '(?<!' regex ')'            | '(?#' [^)]* ')' minmax ::= '{' min (',' max?)? '}' min ::= [0-9]+ max ::= [0-9]+:::ch->this->read->tok->switch->return->this->processCaret->return->this->processDollar->return->this->processLookahead->return->this->processNegativelookahead->return->this->processLookbehind->return->this->processNegativelookbehind->this->next->return->Token->createEmpty->switch->return->this->processBacksolidus_A->return->this->processBacksolidus_Z->return->this->processBacksolidus_z->return->this->processBacksolidus_b->return->this->processBacksolidus_B->return->this->processBacksolidus_lt->return->this->processBacksolidus_gt->this->parseAtom->this->read->switch->return->this->processStar->return->this->processPlus->return->this->processQuestion->if->off->min->max->if->charAt->while->charAt->if->throw->ex->else->throw->ex->if->if->throw->ex->else->if->charAt->while->charAt->if->throw->ex->if->throw->ex->else->if->throw->ex->if->this->checkQuestion->Token->createNGClosure->else->Token->createClosure->tok->setMin->tok->setMax->this->next->return
RegexParser#parseAtom():::atom ::= char | '.' | char-class | '(' regex ')' | '(?:' regex ')' | '\' [0-9]          | '\w' | '\W' | '\d' | '\D' | '\s' | '\S' | category-block          | '(?>' regex ')' char ::= '\\' | '\' [efnrt] | bmp-code | character-1:::ch->this->read->tok->switch->return->this->processParen->return->this->processParen2->return->this->processCondition->return->this->processModifiers->return->this->processIndependent->this->next->break->return->this->parseCharacterClass->return->this->parseSetOperations->switch->this->getTokenForShorthand->this->next->return->ch2->this->decodeEscaped->if->Token->createChar->else->Token->REUtil->decomposeToSurrogates->createString->break->return->this->processBacksolidus_c->return->this->processBacksolidus_C->return->this->processBacksolidus_i->return->this->processBacksolidus_I->return->this->processBacksolidus_g->return->this->processBacksolidus_X->return->this->processBackreference->pstart->processBacksolidus_pP->if->throw->this->ex->break->Token->createChar->this->next->break->if->throw->this->ex->Token->createChar->high->this->next->if->REUtil->isHighSurrogate->this->read->REUtil->isLowSurrogate->sur->new->charArr->Token->Token->new->String->createString->createParen->this->next->break->throw->this->ex->return
RegexParser#processBacksolidus_pP(int)::: regex parser process backsolidus_p p:::this->next->if->this->read->throw->this->ex->positive->namestart->nameend->indexOf->if->throw->this->ex->pname->substring->return->Token->this->isSet->getRange
RegexParser#processCIinCharacterClass(RangeToken, int)::: regex parser process iin character class:::return->this->decodeEscaped
RegexParser#parseCharacterClass(boolean):::char-class ::= '[' ( '^'? range ','?)+ ']' range ::= '\d' | '\w' | '\s' | category-block | range-char           | range-char '-' range-char range-char ::= '\[' | '\]' | '\\' | '\' [,-efnrtv] | bmp-code | character-2 bmp-code ::= '\' 'u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]:::this->setContext->this->next->nrange->base->tok->if->this->read->this->next->if->Token->createNRange->else->Token->createRange->base->addRange->Token->createRange->else->Token->createRange->type->firstloop->while->this->read->if->break->c->end->if->switch->tok->this->getTokenForShorthand->mergeRanges->break->this->processCIinCharacterClass->if->break->pstart->tok2->this->processBacksolidus_pP->if->throw->this->ex->tok->mergeRanges->break->this->decodeEscaped->else->if->nameend->indexOf->if->throw->this->ex->positive->if->charAt->name->substring->range->Token->this->isSet->getRange->if->throw->this->ex->tok->mergeRanges->if->charAt->throw->this->ex->else->if->if->if->Token->complementRanges->else->base->subtractRanges->range2->this->parseCharacterClass->tok->subtractRanges->if->this->read->throw->this->ex->break->this->next->if->if->this->read->if->this->isSet->tok->addRange->else->addCaseInsensitiveChar->else->if->throw->this->ex->else->this->next->if->this->read->throw->this->ex->if->if->this->isSet->tok->addRange->else->addCaseInsensitiveChar->tok->addRange->else->rangeend->if->this->decodeEscaped->this->next->if->throw->this->ex->if->this->isSet->tok->addRange->else->addCaseInsensitiveCharRange->if->this->isSet->this->read->this->next->if->this->read->throw->this->ex->if->base->subtractRanges->tok->sortRanges->tok->compactRanges->this->setContext->this->next->return
RegexParser#parseSetOperations():::'(?[' ..:::tok->this->parseCharacterClass->type->while->this->read->ch->if->this->next->if->this->read->throw->ex->t2->this->parseCharacterClass->if->tok->mergeRanges->else->if->tok->subtractRanges->else->if->tok->intersectRanges->else->throw->new->RuntimeException->else->throw->ex->this->next->return
RegexParser#getTokenForShorthand(int)::: regex parser get token for shorthand:::tok->switch->this->isSet->Token->getRange->break->this->isSet->Token->getRange->break->this->isSet->Token->getRange->break->this->isSet->Token->getRange->break->this->isSet->Token->getRange->break->this->isSet->Token->getRange->break->throw->Integer->toString->new->RuntimeException->return
RegexParser#decodeEscaped()::: regex parser decode escaped:::if->this->read->throw->ex->c->switch->break->break->break->break->break->this->next->if->this->read->throw->ex->if->v1->uv->do->this->next->if->this->read->throw->ex->if->hexChar->break->if->throw->ex->while->if->throw->ex->if->throw->ex->else->v1->if->this->read->hexChar->throw->ex->uv->this->next->if->this->read->hexChar->throw->ex->break->v1->this->next->if->this->read->hexChar->throw->ex->uv->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->break->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->this->next->if->this->read->hexChar->throw->ex->if->throw->ex->break->throw->ex->return
RegexParser#hexChar(int)::: regex parser hex char:::if->return->if->return->if->return->if->return->if->return->if->return->return
RegexParser#addCaseInsensitiveChar(RangeToken, int)::: regex parser add case insensitive char:::caseMap->CaseInsensitiveMap->get->tok->addRange->if->for->i
RegexParser#addCaseInsensitiveCharRange(RangeToken, int, int)::: regex parser add case insensitive char range:::caseMap->r1->r2->if->else->tok->addRange->for->ch
RegularExpression#compile(Token):::Compiles a token tree into an operation flow.:::if->return->this->compile
RegularExpression#compile(Token, Op, boolean):::Converts a token to an operation.:::ret->switch->Op->createDot->break->Op->tok->getChar->createChar->break->Op->tok->getChar->createAnchor->break->Op->createRange->break->if->for->i->tok->size->else->for->i->tok->size->break->uni->Op->tok->size->createUnion->for->i->tok->size->break->child->tok->getChild->min->tok->getMin->max->tok->getMax->if->for->i->break->if->if->for->i->else->op->if->Op->createNonGreedyClosure->else->Op->createClosure->op->compile->setChild->if->for->i->break->break->Op->tok->getString->createString->break->Op->tok->getReferenceNumber->createBackReference->break->if->tok->getParenNumber->tok->getChild->compile->else->if->Op->tok->getParenNumber->createCapture->tok->getChild->compile->Op->tok->getParenNumber->createCapture->else->Op->tok->getParenNumber->createCapture->tok->getChild->compile->Op->tok->getParenNumber->createCapture->break->Op->tok->getChild->compile->createLook->break->Op->tok->getChild->compile->createLook->break->Op->tok->getChild->compile->createLook->break->Op->tok->getChild->compile->createLook->break->Op->tok->getChild->compile->createIndependent->break->Op->tok->getChild->compile->getOptions->getOptionsMask->createModifier->break->ctok->ref->condition->compile->yes->compile->no->compile->Op->createCondition->break->throw->new->RuntimeException->return
RegularExpression#matches(char[]):::Checks whether the <var>target</var> text contains this pattern or not.:::return->this->matches
RegularExpression#matches(char[], int, int):::Checks whether the <var>target</var> text contains this pattern in specified range or not.:::return->this->matches
RegularExpression#matches(char[], Match):::Checks whether the <var>target</var> text contains this pattern or not.:::return->this->matches
RegularExpression#matches(char[], int, int, Match):::Checks whether the <var>target</var> text contains this pattern in specified range or not.:::synchronized->if->this->prepare->if->new->Context->con->synchronized->new->Context->con->reset->if->match->setNumberOfGroups->match->setSource->else->if->new->Match->match->setNumberOfGroups->if->RegularExpression->isSet->matchEnd->this->match->if->if->setBeginning->setEnd->con->setInUse->return->return->if->o->matches->if->if->setBeginning->length->setEnd->con->setInUse->return->con->setInUse->return->if->o->matches->if->con->setInUse->return->limit->matchStart->matchEnd->if->getChild->if->isSet->this->match->else->previousIsEOL->for->else->if->range->for->else->for->if->if->setBeginning->setEnd->con->setInUse->return->else->con->setInUse->return
RegularExpression#matches(String):::Checks whether the <var>target</var> text contains this pattern or not.:::return->this->target->length->matches
RegularExpression#matches(String, int, int):::Checks whether the <var>target</var> text contains this pattern in specified range or not.:::return->this->matches
RegularExpression#matches(String, Match):::Checks whether the <var>target</var> text contains this pattern or not.:::return->this->target->length->matches
RegularExpression#matches(String, int, int, Match):::Checks whether the <var>target</var> text contains this pattern in specified range or not.:::synchronized->if->this->prepare->if->new->Context->con->synchronized->new->Context->con->reset->if->match->setNumberOfGroups->match->setSource->else->if->new->Match->match->setNumberOfGroups->if->RegularExpression->isSet->if->println->matchEnd->this->match->if->println->println->if->if->setBeginning->setEnd->con->setInUse->return->return->if->o->matches->if->if->setBeginning->length->setEnd->con->setInUse->return->con->setInUse->return->if->o->matches->if->con->setInUse->return->limit->matchStart->matchEnd->if->getChild->if->isSet->this->match->else->previousIsEOL->for->else->if->range->for->else->for->if->if->setBeginning->setEnd->con->setInUse->return->else->con->setInUse->return
RegularExpression#match(Context, Op, int, int, int)::: regular expression match:::target->opStack->new->Stack<>->dataStack->new->IntStack->isSetIgnoreCase->isSet->retValue->returned->for
RegularExpression#matchChar(int, int, boolean)::: regular expression match char:::return->matchIgnoreCase
RegularExpression#matchAnchor(ExpressionTarget, Op, Context, int, int)::: regular expression match anchor:::go->switch->op->getData->if->isSet->if->target->charAt->isEOLChar->return->else->if->return->break->if->target->charAt->isEOLChar->return->break->if->isSet->if->target->charAt->isEOLChar->return->else->if->target->charAt->isEOLChar->target->charAt->target->charAt->return->break->if->return->break->if->target->charAt->isEOLChar->target->charAt->target->charAt->return->break->if->return->break->if->return->after->getWordType->if->return->before->getPreviousWordType->if->return->break->if->else->after->getWordType->getPreviousWordType->if->return->break->if->return->if->getWordType->getPreviousWordType->return->break->if->return->if->getWordType->getPreviousWordType->return->break->return
RegularExpression#getPreviousWordType(ExpressionTarget, int, int, int, int)::: regular expression get previous word type:::ret->getWordType->while->getWordType->return
RegularExpression#getWordType(ExpressionTarget, int, int, int, int)::: regular expression get word type:::if->return->return->target->charAt->getWordType0
RegularExpression#matches(CharacterIterator):::Checks whether the <var>target</var> text contains this pattern or not.:::return->this->matches
RegularExpression#matches(CharacterIterator, Match):::Checks whether the <var>target</var> text contains this pattern or not.:::start->target->getBeginIndex->end->target->getEndIndex->synchronized->if->this->prepare->if->new->Context->con->synchronized->new->Context->con->reset->if->match->setNumberOfGroups->match->setSource->else->if->new->Match->match->setNumberOfGroups->if->RegularExpression->isSet->matchEnd->this->match->if->if->setBeginning->setEnd->con->setInUse->return->return->if->o->matches->if->if->setBeginning->length->setEnd->con->setInUse->return->con->setInUse->return->if->o->matches->if->con->setInUse->return->limit->matchStart->matchEnd->if->getChild->if->isSet->this->match->else->previousIsEOL->for->else->if->range->for->else->for->if->if->setBeginning->setEnd->con->setInUse->return->else->con->setInUse->return
RegularExpression.ExpressionTarget#charAt(int)::: expression target char at:::
RegularExpression.ExpressionTarget#regionMatches(boolean, int, int, String, int)::: expression target region matches:::
RegularExpression.ExpressionTarget#regionMatches(boolean, int, int, int, int)::: expression target region matches:::
RegularExpression.StringTarget#resetTarget(String)::: string target reset target:::
RegularExpression.StringTarget#charAt(int)::: string target char at:::return->target->charAt
RegularExpression.StringTarget#regionMatches(boolean, int, int, String, int)::: string target region matches:::if->return->return->target->regionMatches->target->regionMatches
RegularExpression.StringTarget#regionMatches(boolean, int, int, int, int)::: string target region matches:::if->return->return->target->regionMatches->target->regionMatches
RegularExpression.CharArrayTarget#resetTarget(char[])::: char array target reset target:::
RegularExpression.CharArrayTarget#charAt(int)::: char array target char at:::return
RegularExpression.CharArrayTarget#regionMatches(boolean, int, int, String, int)::: char array target region matches:::if->return->return->regionMatchesIgnoreCase->regionMatches
RegularExpression.CharArrayTarget#regionMatches(int, int, String, int)::: char array target region matches:::i->while->if->part->charAt->return->return
RegularExpression.CharArrayTarget#regionMatchesIgnoreCase(int, int, String, int)::: char array target region matches ignore case:::i->while->ch1->ch2->part->charAt->if->continue->uch1->Character->toUpperCase->uch2->Character->toUpperCase->if->continue->if->Character->toLowerCase->Character->toLowerCase->return->return
RegularExpression.CharArrayTarget#regionMatches(boolean, int, int, int, int)::: char array target region matches:::if->return->return->regionMatchesIgnoreCase->regionMatches
RegularExpression.CharArrayTarget#regionMatches(int, int, int, int)::: char array target region matches:::i->while->if->return->return
RegularExpression.CharArrayTarget#regionMatchesIgnoreCase(int, int, int, int)::: char array target region matches ignore case:::i->while->ch1->ch2->if->continue->uch1->Character->toUpperCase->uch2->Character->toUpperCase->if->continue->if->Character->toLowerCase->Character->toLowerCase->return->return
RegularExpression.CharacterIteratorTarget#resetTarget(CharacterIterator)::: character iterator target reset target:::
RegularExpression.CharacterIteratorTarget#charAt(int)::: character iterator target char at:::return->target->setIndex
RegularExpression.CharacterIteratorTarget#regionMatches(boolean, int, int, String, int)::: character iterator target region matches:::if->return->return->regionMatchesIgnoreCase->regionMatches
RegularExpression.CharacterIteratorTarget#regionMatches(int, int, String, int)::: character iterator target region matches:::i->while->if->target->setIndex->part->charAt->return->return
RegularExpression.CharacterIteratorTarget#regionMatchesIgnoreCase(int, int, String, int)::: character iterator target region matches ignore case:::i->while->ch1->target->setIndex->ch2->part->charAt->if->continue->uch1->Character->toUpperCase->uch2->Character->toUpperCase->if->continue->if->Character->toLowerCase->Character->toLowerCase->return->return
RegularExpression.CharacterIteratorTarget#regionMatches(boolean, int, int, int, int)::: character iterator target region matches:::if->return->return->regionMatchesIgnoreCase->regionMatches
RegularExpression.CharacterIteratorTarget#regionMatches(int, int, int, int)::: character iterator target region matches:::i->while->if->target->setIndex->target->setIndex->return->return
RegularExpression.CharacterIteratorTarget#regionMatchesIgnoreCase(int, int, int, int)::: character iterator target region matches ignore case:::i->while->ch1->target->setIndex->ch2->target->setIndex->if->continue->uch1->Character->toUpperCase->uch2->Character->toUpperCase->if->continue->if->Character->toLowerCase->Character->toLowerCase->return->return
RegularExpression.ClosureContext#contains(int)::: closure context contains:::for->i->return
RegularExpression.ClosureContext#reset()::: closure context reset:::
RegularExpression.ClosureContext#addOffset(int)::: closure context add offset:::if->expandOffsets
RegularExpression.ClosureContext#expandOffsets()::: closure context expand offsets:::len->newLen->newOffsets->new->intArr->System->arraycopy->return
RegularExpression.Context#resetCommon(int)::: context reset common:::setInUse->if->new->ClosureContextArr->for->i
RegularExpression.Context#reset(CharacterIterator, int, int, int)::: context reset:::if->new->CharacterIteratorTarget->else->characterIteratorTarget->resetTarget->this->resetCommon
RegularExpression.Context#reset(String, int, int, int)::: context reset:::if->new->StringTarget->else->stringTarget->resetTarget->this->resetCommon
RegularExpression.Context#reset(char[], int, int, int)::: context reset:::if->new->CharArrayTarget->else->charArrayTarget->resetTarget->this->resetCommon
RegularExpression.Context#setInUse(boolean)::: context set in use:::
RegularExpression#prepare():::Prepares for matching:::if->this->compile->if->println->getMinLength->if->isSet->isSet->firstChar->Token->createRange->fresult->analyzeFirstCharacter->if->firstChar->compactRanges->if->println->if->if->print->if->getString->else->if->getData->REUtil->getData->decomposeToSurrogates->else->ac->new->charArr->getData->new->String->isSet->new->BMPattern->else->if->isSet->isSet->container->new->Token.FixedStringContainer->findFixedString->getString->if->length->if->isSet->new->BMPattern->if->length->REUtil->createOptionString->println->print->REUtil->dumpString
RegularExpression#isSet(int, int)::: regular expression is set:::return
RegularExpression#setPattern(String)::: regular expression set pattern:::this->Locale->getDefault->setPattern
RegularExpression#setPattern(String, Locale)::: regular expression set pattern:::this->setPattern
RegularExpression#setPattern(String, int, Locale)::: regular expression set pattern:::rp->RegularExpression->isSet->new->ParserForXMLSchema->new->RegexParser->rp->parse
RegularExpression#setPattern(String, String)::: regular expression set pattern:::this->Locale->getDefault->setPattern
RegularExpression#setPattern(String, String, Locale)::: regular expression set pattern:::this->REUtil->parseOptions->setPattern
RegularExpression#getPattern()::: regular expression get pattern:::return
RegularExpression#toString():::Represents this instence in String.:::return->toString
RegularExpression#getOptions():::Returns a option string:::return->REUtil->createOptionString
RegularExpression#equals(Object)::: Return true if patterns are the same and the options are equivalent.:::if->return->if->return->r->return->equals
RegularExpression#equals(String, int)::: regular expression equals:::return->equals
RegularExpression#hashCode()::: regular expression hash code:::return->this->getOptions->hashCode
RegularExpression#getNumberOfGroups():::Return the number of regular expression groups:::return
RegularExpression#getWordType0(char, int)::: regular expression get word type0:::if->isSet->if->isSet->return->Token->getRange->match->return->isWordChar->switch->Character->getType->return->return->switch->return->return->return
RegularExpression#isEOLChar(int)::: regular expression is char:::return
RegularExpression#isWordChar(int)::: regular expression is word char:::if->return->if->return->if->return->if->return->if->return->if->return->if->return->return
RegularExpression#matchIgnoreCase(int, int)::: regular expression match ignore case:::if->return->if->return->uch1->Character->toUpperCase->uch2->Character->toUpperCase->if->return->return->Character->toLowerCase->Character->toLowerCase
REUtil#composeFromSurrogates(int, int)::: util compose from surrogates:::return
REUtil#isLowSurrogate(int)::: util is low surrogate:::return
REUtil#isHighSurrogate(int)::: util is high surrogate:::return
REUtil#decomposeToSurrogates(int)::: util decompose to surrogates:::chs->new->charArr->return->new->String
REUtil#substring(CharacterIterator, int, int)::: util substring:::src->new->charArr->for->i->return->new->String
REUtil#getOptionValue(int)::: util get option value:::ret->switch->break->break->break->break->break->break->break->break->break->break->return
REUtil#parseOptions(String)::: util parse options:::if->return->options->for->i->opts->length->return
REUtil#createOptionString(int)::: util create option string:::sb->new->StringBuilder->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->if->sb->append->return->sb->toString->intern
REUtil#stripExtendedComment(String)::: util strip extended comment:::len->regex->length->buffer->new->StringBuilder->offset->charClass->while->ch->regex->charAt->if->if->buffer->append->continue->if->while->regex->charAt->if->break->continue->next->if->if->regex->charAt->buffer->append->else->buffer->append->buffer->append->else->if->buffer->append->if->regex->charAt->if->buffer->append->else->if->regex->charAt->if->buffer->append->buffer->append->else->if->buffer->append->return->buffer->toString
REUtil#main(String[]):::Sample entry:::pattern->try->options->target->if->println->System->exit->for->i->reg->new->RegularExpression->println->match->new->Match->reg->matches->for->i->match->getNumberOfGroups->catch->if->pe->printStackTrace->else->pe->getMessage->println->indent->println->loc->pe->getLocation->if->print->for->i->println->e->printStackTrace->finally
REUtil#createRegex(String, String):::Creates a RegularExpression instance:::re->intOptions->REUtil->parseOptions->synchronized->i->for->if->if->System->arraycopy->else->new->RegularExpression->System->arraycopy->return
REUtil#matches(String, String)::: util matches:::return->REUtil->createRegex->matches
REUtil#matches(String, String, String)::: util matches:::return->REUtil->createRegex->matches
REUtil#quoteMeta(String)::: util quote meta:::len->literal->length->buffer->for->i->return->buffer->toString
REUtil#dumpString(String)::: util dump string:::for->i->v->length->println
Token#createLook(int, Token)::: token create look:::if->return->new->Token.ParenToken
Token#createParen(Token, int)::: token create paren:::if->return->new->Token.ParenToken
Token#createClosure(Token)::: token create closure:::if->return->new->Token.ClosureToken
Token#createNGClosure(Token)::: token create closure:::if->return->new->Token.ClosureToken
Token#createConcat(Token, Token)::: token create concat:::if->return->new->Token.ConcatToken
Token#createConcat()::: token create concat:::if->return->new->Token.UnionToken
Token#createUnion()::: token create union:::if->return->new->Token.UnionToken
Token#createEmpty()::: token create empty:::return
Token#createRange()::: token create range:::if->return->new->RangeToken
Token#createNRange()::: token create range:::if->return->new->RangeToken
Token#createChar(int)::: token create char:::if->return->new->Token.CharToken
Token#createAnchor(int)::: token create anchor:::if->return->new->Token.CharToken
Token#createBackReference(int)::: token create back reference:::if->return->new->Token.StringToken
Token#createString(String)::: token create string:::if->return->new->Token.StringToken
Token#createModifierGroup(Token, int, int)::: token create modifier group:::if->return->new->Token.ModifierToken
Token#createCondition(int, Token, Token, Token)::: token create condition:::if->return->new->Token.ConditionToken
Token#size():::A number of children.:::return
Token#getChild(int)::: token get child:::return
Token#addChild(Token)::: token add child:::throw->new->RuntimeException
Token#addRange(int, int)::: token add range:::throw->new->RuntimeException
Token#sortRanges()::: token sort ranges:::throw->new->RuntimeException
Token#compactRanges()::: token compact ranges:::throw->new->RuntimeException
Token#mergeRanges(Token)::: token merge ranges:::throw->new->RuntimeException
Token#subtractRanges(Token)::: token subtract ranges:::throw->new->RuntimeException
Token#intersectRanges(Token)::: token intersect ranges:::throw->new->RuntimeException
Token#complementRanges(Token)::: token complement ranges:::return->RangeToken->complementRanges
Token#setMin(int)::: token set min:::
Token#setMax(int)::: token set max:::
Token#getMin()::: token get min:::return
Token#getMax()::: token get max:::return
Token#getReferenceNumber()::: token get reference number:::return
Token#getString()::: token get string:::return
Token#getParenNumber()::: token get paren number:::return
Token#getChar()::: token get char:::return
Token#toString()::: token to string:::return->this->toString
Token#toString(int)::: token to string:::return
Token#getMinLength():::How many characters are needed?:::switch->sum->for->i->this->size->return->if->this->size->return->ret->this->getChild->getMinLength->for->i->this->size->return->if->this->getMin->return->this->getMin->this->getChild->getMinLength->return->return->return->return->this->getChild->getMinLength->return->return->this->getString->length->return->throw->new->RuntimeException
Token#getMaxLength()::: token get max length:::switch->sum->for->i->this->size->return->if->this->size->return->ret->this->getChild->getMaxLength->for->i->this->size->return->if->this->getMax->return->this->getMax->this->getChild->getMaxLength->return->return->return->return->return->this->getChild->getMaxLength->return->return->this->getString->length->return->throw->new->RuntimeException
Token#isSet(int, int)::: token is set:::return
Token#analyzeFirstCharacter(RangeToken, int)::: token analyze first character:::switch->ret->for->i->this->size->return->if->this->size->return->ret2->hasEmpty->for->i->this->size->return->ret3->this->getChild->analyzeFirstCharacter->if->this->size->return->if->return->ret4->this->getChild->analyzeFirstCharacter->if->return->return->this->getChild->analyzeFirstCharacter->return->return->ch->this->getChar->result->addRange->if->isSet->Character->toUpperCase->result->addRange->Character->toLowerCase->result->addRange->return->return->result->mergeRanges->return->result->Token->complementRanges->mergeRanges->return->return->this->getChild->analyzeFirstCharacter->getOptions->getOptionsMask->return->this->getChild->analyzeFirstCharacter->result->addRange->return->cha->this->getString->charAt->ch2->if->REUtil->isHighSurrogate->this->getString->length->REUtil->this->getString->charAt->isLowSurrogate->REUtil->composeFromSurrogates->result->addRange->if->isSet->Character->toUpperCase->result->addRange->Character->toLowerCase->result->addRange->return->return->throw->new->RuntimeException
Token#isShorterThan(Token)::: token is shorter than:::if->return->mylength->if->this->getString->length->else->throw->new->RuntimeException->otherlength->if->tok->getString->length->else->throw->new->RuntimeException->return
Token#findFixedString(FixedStringContainer, int)::: token find fixed string:::switch->prevToken->prevOptions->for->i->this->size->return->return->return->return->this->getChild->findFixedString->return->getOptions->getOptionsMask->this->getChild->findFixedString->return->throw->new->RuntimeException
Token#match(int)::: token match:::throw->new->RuntimeException
Token#getRange(String, boolean)::: token get range:::localCat->if->synchronized->if->tmpCat->new->HashMap<>->tmpCat2->new->HashMap<>->ranges->new->TokenArr->for->i->type->for->i->addRange->for->i->buffer->new->StringBuilder->for->i->Token->setAlias->Token->setAlias->all->Token->createRange->all->addRange->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->isalpha->Token->createRange->isalpha->mergeRanges->isalpha->mergeRanges->isalpha->mergeRanges->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->isalnum->Token->createRange->isalnum->mergeRanges->isalnum->mergeRanges->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->isspace->Token->createRange->isspace->mergeRanges->isspace->mergeRanges->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->isword->Token->createRange->isword->mergeRanges->isword->addRange->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->isascii->Token->createRange->isascii->addRange->tmpCat->put->tmpCat2->Token->complementRanges->put->Token->registerNonXS->isnotgraph->Token->createRange->isnotgraph->mergeRanges->isnotgraph->addRange->tmpCat->Token->complementRanges->put->tmpCat2->put->Token->registerNonXS->isxdigit->Token->createRange->isxdigit->addRange->isxdigit->addRange->isxdigit->addRange->tmpCat->Token->complementRanges->put->tmpCat2->put->Token->registerNonXS->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->setAlias->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Token->registerNonXS->Collections->unmodifiableMap->Collections->unmodifiableMap->return->localCat->get->get
Token#getRange(String, boolean, boolean)::: token get range:::range->Token->getRange->if->Token->isRegisterNonXS->return
Token#registerNonXS(String):::This method is called by only getRange():::add
Token#isRegisterNonXS(String)::: token is register non s:::return->contains
Token#setAlias(Map, Map, String, String, boolean)::: token set alias:::t1->tmpCat->get->t2->tmpCat2->get->if->tmpCat->put->tmpCat2->put->else->tmpCat2->put->tmpCat->put
Token#getGraphemePattern()::: token get grapheme pattern:::if->return->base_char->Token->createRange->base_char->Token->getRange->mergeRanges->base_char->Token->getRange->subtractRanges->base_char->Token->getRange->subtractRanges->virama->Token->createRange->for->i->length->combiner_wo_virama->Token->createRange->combiner_wo_virama->Token->getRange->mergeRanges->combiner_wo_virama->addRange->combiner_wo_virama->addRange->left->Token->createUnion->left->addChild->left->addChild->foo->Token->createUnion->foo->Token->Token->getRange->createConcat->addChild->foo->addChild->Token->createClosure->Token->createConcat->return
Token#getCombiningCharacterSequence()::: token get combining character sequence:::if->return->foo->Token->Token->getRange->createClosure->Token->Token->getRange->createConcat->return
Token.StringToken#getReferenceNumber()::: string token get reference number:::return
Token.StringToken#getString()::: string token get string:::return
Token.StringToken#toString(int)::: string token to string:::if->return->else->return->REUtil->quoteMeta
Token.ConcatToken#size()::: concat token size:::return
Token.ConcatToken#getChild(int)::: concat token get child:::return
Token.ConcatToken#toString(int)::: concat token to string:::ret->if->getChild->toString->else->if->getChild->toString->else->toString->toString->return
Token.CharToken#getChar()::: char token get char:::return
Token.CharToken#toString(int)::: char token to string:::ret->switch->switch->break->break->break->break->break->break->if->pre->Integer->toHexString->pre->pre->length->pre->length->substring->else->break->if->else->break->return
Token.CharToken#match(int)::: char token match:::if->return->else->throw->new->RuntimeException
Token.ClosureToken#size()::: closure token size:::return
Token.ClosureToken#getChild(int)::: closure token get child:::return
Token.ClosureToken#setMin(int)::: closure token set min:::
Token.ClosureToken#setMax(int)::: closure token set max:::
Token.ClosureToken#getMin()::: closure token get min:::return
Token.ClosureToken#getMax()::: closure token get max:::return
Token.ClosureToken#toString(int)::: closure token to string:::ret->if->if->this->getMin->this->getMax->toString->else->if->this->getMin->this->getMax->toString->this->getMin->else->if->this->getMin->this->getMax->toString->this->getMin->this->getMax->else->if->this->getMin->this->getMax->toString->this->getMin->else->throw->this->getMin->this->getMax->new->RuntimeException->else->if->this->getMin->this->getMax->toString->else->if->this->getMin->this->getMax->toString->this->getMin->else->if->this->getMin->this->getMax->toString->this->getMin->this->getMax->else->if->this->getMin->this->getMax->toString->this->getMin->else->throw->this->getMin->this->getMax->new->RuntimeException->return
Token.ParenToken#size()::: paren token size:::return
Token.ParenToken#getChild(int)::: paren token get child:::return
Token.ParenToken#getParenNumber()::: paren token get paren number:::return
Token.ParenToken#toString(int)::: paren token to string:::ret->switch->if->toString->else->toString->break->toString->break->toString->break->toString->break->toString->break->toString->break->return
Token.ConditionToken#size()::: condition token size:::return
Token.ConditionToken#getChild(int)::: condition token get child:::if->return->if->return->throw->new->RuntimeException
Token.ConditionToken#toString(int)::: condition token to string:::ret->if->else->if->else->if->else->return
Token.ModifierToken#size()::: modifier token size:::return
Token.ModifierToken#getChild(int)::: modifier token get child:::return
Token.ModifierToken#getOptions()::: modifier token get options:::return
Token.ModifierToken#getOptionsMask()::: modifier token get options mask:::return
Token.ModifierToken#toString(int)::: modifier token to string:::return->REUtil->createOptionString->REUtil->createOptionString->toString
Token.UnionToken#addChild(Token)::: union token add child:::if->return->if->new->ArrayList<>->if->add->return->if->for->i->tok->size->return->size->size->if->add->return->previous->get->if->add->return->buffer->nextMaxLength->tok->getString->length->if->new->StringBuilder->ch->previous->getChar->if->buffer->REUtil->decomposeToSurrogates->append->else->buffer->append->Token->createString->set->else->previous->getString->length->new->StringBuilder->buffer->previous->getString->append->if->ch->tok->getChar->if->buffer->REUtil->decomposeToSurrogates->append->else->buffer->append->else->buffer->tok->getString->append->new->String
Token.UnionToken#size()::: union token size:::return->size
Token.UnionToken#getChild(int)::: union token get child:::return->get
Token.UnionToken#toString(int)::: union token to string:::ret->if->if->size->ch->this->getChild->ch2->this->getChild->if->ch2->getChild->ch->toString->else->if->ch2->getChild->ch->toString->else->ch->toString->ch2->toString->else->sb->new->StringBuilder->stream->sb->toString->append->forEach->sb->toString->return->if->size->this->getChild->this->getChild->toString->else->if->size->this->getChild->this->getChild->toString->else->sb->new->StringBuilder->sb->get->toString->append->for->i->size->sb->toString->return
Token.UnionToken#writeObject(ObjectOutputStream)::: union token write object:::vChildren->new->Vector<>->pf->out->putFields->pf->put->out->writeFields
Token.UnionToken#readObject(ObjectInputStream)::: union token read object:::gf->in->readFields->vChildren->gf->get->if->new->ArrayList<>
