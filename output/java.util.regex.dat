java.util.regex.ASCII#getType(int)->int::: i get type
java.util.regex.ASCII#isType(int, int)->boolean::: i is type
java.util.regex.ASCII#isAscii(int)->boolean::: i is ascii
java.util.regex.ASCII#isAlpha(int)->boolean::: i is alpha
java.util.regex.ASCII#isDigit(int)->boolean::: i is digit
java.util.regex.ASCII#isAlnum(int)->boolean::: i is alnum
java.util.regex.ASCII#isGraph(int)->boolean::: i is graph
java.util.regex.ASCII#isPrint(int)->boolean::: i is print
java.util.regex.ASCII#isPunct(int)->boolean::: i is punct
java.util.regex.ASCII#isSpace(int)->boolean::: i is space
java.util.regex.ASCII#isHexDigit(int)->boolean::: i is hex digit
java.util.regex.ASCII#isOctDigit(int)->boolean::: i is oct digit
java.util.regex.ASCII#isCntrl(int)->boolean::: i is cntrl
java.util.regex.ASCII#isLower(int)->boolean::: i is lower
java.util.regex.ASCII#isUpper(int)->boolean::: i is upper
java.util.regex.ASCII#isWord(int)->boolean::: i is word
java.util.regex.ASCII#toDigit(int)->int::: i to digit
java.util.regex.ASCII#toLower(int)->int::: i to lower
java.util.regex.ASCII#toUpper(int)->int::: i to upper
java.util.regex.CharPredicates#ALPHABETIC()->CharPredicate::: char predicates  c
java.util.regex.CharPredicates#DIGIT()->CharPredicate::: char predicates  t
java.util.regex.CharPredicates#LETTER()->CharPredicate::: char predicates  r
java.util.regex.CharPredicates#IDEOGRAPHIC()->CharPredicate::: char predicates  c
java.util.regex.CharPredicates#LOWERCASE()->CharPredicate::: char predicates  e
java.util.regex.CharPredicates#UPPERCASE()->CharPredicate::: char predicates  e
java.util.regex.CharPredicates#TITLECASE()->CharPredicate::: char predicates  e
java.util.regex.CharPredicates#WHITE_SPACE()->CharPredicate::: char predicates  e_ e
java.util.regex.CharPredicates#CONTROL()->CharPredicate::: char predicates  l
java.util.regex.CharPredicates#PUNCTUATION()->CharPredicate::: char predicates  n
java.util.regex.CharPredicates#HEX_DIGIT()->CharPredicate::: char predicates  x_ t
java.util.regex.CharPredicates#ASSIGNED()->CharPredicate::: char predicates  d
java.util.regex.CharPredicates#NONCHARACTER_CODE_POINT()->CharPredicate::: char predicates  r_ e_ t
java.util.regex.CharPredicates#ALNUM()->CharPredicate::: char predicates  m
java.util.regex.CharPredicates#BLANK()->CharPredicate::: char predicates  k
java.util.regex.CharPredicates#GRAPH()->CharPredicate::: char predicates  h
java.util.regex.CharPredicates#PRINT()->CharPredicate::: char predicates  t
java.util.regex.CharPredicates#JOIN_CONTROL()->CharPredicate::: char predicates  n_ l
java.util.regex.CharPredicates#WORD()->CharPredicate::: char predicates  d
java.util.regex.CharPredicates#forUnicodeProperty(String)->CharPredicate::: char predicates for unicode property
java.util.regex.CharPredicates#forPOSIXName(String)->CharPredicate::: char predicates for name
java.util.regex.CharPredicates#forUnicodeScript(String)->CharPredicate:::Returns a predicate matching all characters belong to a named UnicodeScript.
java.util.regex.CharPredicates#forUnicodeBlock(String)->CharPredicate:::Returns a predicate matching all characters in a UnicodeBlock.
java.util.regex.CharPredicates#forProperty(String)->CharPredicate::: char predicates for property
java.util.regex.CharPredicates#ASCII_DIGIT()->BmpCharPredicate:::Posix ASCII variants, not in the lookup map
java.util.regex.CharPredicates#ASCII_WORD()->BmpCharPredicate::: char predicates  i_ d
java.util.regex.CharPredicates#ASCII_SPACE()->BmpCharPredicate::: char predicates  i_ e
java.util.regex.Grapheme#isBoundary(int, int)->boolean:::Determines if there is an extended  grapheme cluster boundary between two continuing characters cp1 and cp2
java.util.regex.IntHashSet#contains(int)->boolean::: int hash set contains
java.util.regex.IntHashSet#add(int)->void::: int hash set add
java.util.regex.IntHashSet#clear()->void::: int hash set clear
java.util.regex.Matcher#pattern()->Pattern:::Returns the pattern that is interpreted by this matcher.
java.util.regex.Matcher#toMatchResult()->MatchResult:::Returns the match state of this matcher as a MatchResult
java.util.regex.Matcher#usePattern(Pattern)->Matcher:::Changes the Pattern that this Matcher uses to find matches with
java.util.regex.Matcher#reset()->Matcher:::Resets this matcher
java.util.regex.Matcher#reset(CharSequence)->Matcher:::Resets this matcher with a new input sequence
java.util.regex.Matcher#start()->int:::Returns the start index of the previous match.
java.util.regex.Matcher#start(int)->int:::Returns the start index of the subsequence captured by the given group during the previous match operation
java.util.regex.Matcher#start(String)->int:::Returns the start index of the subsequence captured by the given named-capturing group during the previous match operation.
java.util.regex.Matcher#end()->int:::Returns the offset after the last character matched.
java.util.regex.Matcher#end(int)->int:::Returns the offset after the last character of the subsequence captured by the given group during the previous match operation
java.util.regex.Matcher#end(String)->int:::Returns the offset after the last character of the subsequence captured by the given named-capturing group during the previous match operation.
java.util.regex.Matcher#group()->String:::Returns the input subsequence matched by the previous match
java.util.regex.Matcher#group(int)->String:::Returns the input subsequence captured by the given group during the previous match operation
java.util.regex.Matcher#group(String)->String:::Returns the input subsequence captured by the given named-capturing group during the previous match operation
java.util.regex.Matcher#groupCount()->int:::Returns the number of capturing groups in this matcher's pattern
java.util.regex.Matcher#matches()->boolean:::Attempts to match the entire region against the pattern
java.util.regex.Matcher#find()->boolean:::Attempts to find the next subsequence of the input sequence that matches the pattern
java.util.regex.Matcher#find(int)->boolean:::Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index
java.util.regex.Matcher#lookingAt()->boolean:::Attempts to match the input sequence, starting at the beginning of the region, against the pattern
java.util.regex.Matcher#quoteReplacement(String)->String:::Returns a literal replacement String for the specified String
java.util.regex.Matcher#appendReplacement(StringBuffer, String)->Matcher:::Implements a non-terminal append-and-replace step
java.util.regex.Matcher#appendReplacement(StringBuilder, String)->Matcher:::Implements a non-terminal append-and-replace step
java.util.regex.Matcher#appendTail(StringBuffer)->StringBuffer:::Implements a terminal append-and-replace step
java.util.regex.Matcher#appendTail(StringBuilder)->StringBuilder:::Implements a terminal append-and-replace step
java.util.regex.Matcher#replaceAll(String)->String:::Replaces every subsequence of the input sequence that matches the pattern with the given replacement string
java.util.regex.Matcher#replaceAll(Function)->String:::Replaces every subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence
java.util.regex.Matcher#results()->Stream:::Returns a stream of match results for each subsequence of the input sequence that matches the pattern
java.util.regex.Matcher#replaceFirst(String)->String:::Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string
java.util.regex.Matcher#replaceFirst(Function)->String:::Replaces the first subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence
java.util.regex.Matcher#region(int, int)->Matcher:::Sets the limits of this matcher's region
java.util.regex.Matcher#regionStart()->int:::Reports the start index of this matcher's region
java.util.regex.Matcher#regionEnd()->int:::Reports the end index (exclusive) of this matcher's region
java.util.regex.Matcher#hasTransparentBounds()->boolean:::Queries the transparency of region bounds for this matcher
java.util.regex.Matcher#useTransparentBounds(boolean)->Matcher:::Sets the transparency of region bounds for this matcher
java.util.regex.Matcher#hasAnchoringBounds()->boolean:::Queries the anchoring of region bounds for this matcher
java.util.regex.Matcher#useAnchoringBounds(boolean)->Matcher:::Sets the anchoring of region bounds for this matcher
java.util.regex.Matcher#toString()->String:::Returns the string representation of this matcher
java.util.regex.Matcher#hitEnd()->boolean:::Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher
java.util.regex.Matcher#requireEnd()->boolean:::Returns true if more input could change a positive match into a negative one
java.util.regex.Matcher#search(int)->boolean:::Initiates a search to find a Pattern within the given bounds
java.util.regex.Matcher#match(int, int)->boolean:::Initiates a search for an anchored match to a Pattern within the given bounds
java.util.regex.Matcher#getTextLength()->int:::Returns the end index of the text.
java.util.regex.Matcher#getSubSequence(int, int)->CharSequence:::Generates a String from this matcher's input in the specified range.
java.util.regex.Matcher#charAt(int)->char:::Returns this matcher's input character at index i.
java.util.regex.Matcher#getMatchedGroupIndex(String)->int:::Returns the group index of the matched capturing group.
java.util.regex.MatchResult#start()->int:::Returns the start index of the match.
java.util.regex.MatchResult#start(int)->int:::Returns the start index of the subsequence captured by the given group during this match
java.util.regex.MatchResult#end()->int:::Returns the offset after the last character matched.
java.util.regex.MatchResult#end(int)->int:::Returns the offset after the last character of the subsequence captured by the given group during this match
java.util.regex.MatchResult#group()->String:::Returns the input subsequence matched by the previous match
java.util.regex.MatchResult#group(int)->String:::Returns the input subsequence captured by the given group during the previous match operation
java.util.regex.MatchResult#groupCount()->int:::Returns the number of capturing groups in this match result's pattern
java.util.regex.Pattern#compile(String)->Pattern:::Compiles the given regular expression into a pattern.
java.util.regex.Pattern#compile(String, int)->Pattern:::Compiles the given regular expression into a pattern with the given flags.
java.util.regex.Pattern#pattern()->String:::Returns the regular expression from which this pattern was compiled.
java.util.regex.Pattern#toString()->String:::Returns the string representation of this pattern
java.util.regex.Pattern#matcher(CharSequence)->Matcher:::Creates a matcher that will match the given input against this pattern.
java.util.regex.Pattern#flags()->int:::Returns this pattern's match flags.
java.util.regex.Pattern#matches(String, CharSequence)->boolean:::Compiles the given regular expression and attempts to match the given input against it
java.util.regex.Pattern#split(CharSequence, int)->String[]:::Splits the given input sequence around matches of this pattern
java.util.regex.Pattern#split(CharSequence)->String[]:::Splits the given input sequence around matches of this pattern
java.util.regex.Pattern#quote(String)->String:::Returns a literal pattern String for the specified String
java.util.regex.Pattern#namedGroups()->Map::: pattern named groups
java.util.regex.Pattern.TreeInfo#reset()->void::: tree info reset
java.util.regex.Pattern.BitClass#add(int, int)->BitClass::: bit class add
java.util.regex.Pattern.Node#match(Matcher, int, CharSequence)->boolean:::This method implements the classic accept node.
java.util.regex.Pattern.Node#study(TreeInfo)->boolean:::This method is good for all zero length assertions.
java.util.regex.Pattern.LastNode#match(Matcher, int, CharSequence)->boolean:::This method implements the classic accept node with the addition of a check to see if the match occurred using all of the input.
java.util.regex.Pattern.Start#match(Matcher, int, CharSequence)->boolean::: start match
java.util.regex.Pattern.Start#study(TreeInfo)->boolean::: start study
java.util.regex.Pattern.StartS#match(Matcher, int, CharSequence)->boolean::: start s match
java.util.regex.Pattern.Begin#match(Matcher, int, CharSequence)->boolean::: begin match
java.util.regex.Pattern.End#match(Matcher, int, CharSequence)->boolean::: end match
java.util.regex.Pattern.Caret#match(Matcher, int, CharSequence)->boolean::: caret match
java.util.regex.Pattern.UnixCaret#match(Matcher, int, CharSequence)->boolean::: unix caret match
java.util.regex.Pattern.LastMatch#match(Matcher, int, CharSequence)->boolean::: last match match
java.util.regex.Pattern.Dollar#match(Matcher, int, CharSequence)->boolean::: dollar match
java.util.regex.Pattern.Dollar#study(TreeInfo)->boolean::: dollar study
java.util.regex.Pattern.UnixDollar#match(Matcher, int, CharSequence)->boolean::: unix dollar match
java.util.regex.Pattern.UnixDollar#study(TreeInfo)->boolean::: unix dollar study
java.util.regex.Pattern.LineEnding#match(Matcher, int, CharSequence)->boolean::: line ending match
java.util.regex.Pattern.LineEnding#study(TreeInfo)->boolean::: line ending study
java.util.regex.Pattern.CharProperty#match(Matcher, int, CharSequence)->boolean::: char property match
java.util.regex.Pattern.CharProperty#study(TreeInfo)->boolean::: char property study
java.util.regex.Pattern.XGrapheme#match(Matcher, int, CharSequence)->boolean::: grapheme match
java.util.regex.Pattern.XGrapheme#study(TreeInfo)->boolean::: grapheme study
java.util.regex.Pattern.GraphemeBound#match(Matcher, int, CharSequence)->boolean::: grapheme bound match
java.util.regex.Pattern.SliceNode#study(TreeInfo)->boolean::: slice node study
java.util.regex.Pattern.Slice#match(Matcher, int, CharSequence)->boolean::: slice match
java.util.regex.Pattern.SliceI#match(Matcher, int, CharSequence)->boolean::: slice i match
java.util.regex.Pattern.SliceU#match(Matcher, int, CharSequence)->boolean::: slice u match
java.util.regex.Pattern.SliceS#match(Matcher, int, CharSequence)->boolean::: slice s match
java.util.regex.Pattern.SliceIS#toLower(int)->int::: slice s to lower
java.util.regex.Pattern.SliceIS#match(Matcher, int, CharSequence)->boolean::: slice s match
java.util.regex.Pattern.SliceUS#toLower(int)->int::: slice s to lower
java.util.regex.Pattern.Ques#match(Matcher, int, CharSequence)->boolean::: ques match
java.util.regex.Pattern.Ques#study(TreeInfo)->boolean::: ques study
java.util.regex.Pattern.CharPropertyGreedy#match(Matcher, int, CharSequence)->boolean::: char property greedy match
java.util.regex.Pattern.CharPropertyGreedy#study(TreeInfo)->boolean::: char property greedy study
java.util.regex.Pattern.BmpCharPropertyGreedy#match(Matcher, int, CharSequence)->boolean::: bmp char property greedy match
java.util.regex.Pattern.Curly#match(Matcher, int, CharSequence)->boolean::: curly match
java.util.regex.Pattern.Curly#match0(Matcher, int, int, CharSequence)->boolean::: curly match0
java.util.regex.Pattern.Curly#match1(Matcher, int, int, CharSequence)->boolean::: curly match1
java.util.regex.Pattern.Curly#match2(Matcher, int, int, CharSequence)->boolean::: curly match2
java.util.regex.Pattern.Curly#study(TreeInfo)->boolean::: curly study
java.util.regex.Pattern.GroupCurly#match(Matcher, int, CharSequence)->boolean::: group curly match
java.util.regex.Pattern.GroupCurly#match0(Matcher, int, int, CharSequence)->boolean::: group curly match0
java.util.regex.Pattern.GroupCurly#match1(Matcher, int, int, CharSequence)->boolean::: group curly match1
java.util.regex.Pattern.GroupCurly#match2(Matcher, int, int, CharSequence)->boolean::: group curly match2
java.util.regex.Pattern.GroupCurly#study(TreeInfo)->boolean::: group curly study
java.util.regex.Pattern.BranchConn#match(Matcher, int, CharSequence)->boolean::: branch conn match
java.util.regex.Pattern.BranchConn#study(TreeInfo)->boolean::: branch conn study
java.util.regex.Pattern.Branch#add(Node)->void::: branch add
java.util.regex.Pattern.Branch#match(Matcher, int, CharSequence)->boolean::: branch match
java.util.regex.Pattern.Branch#study(TreeInfo)->boolean::: branch study
java.util.regex.Pattern.GroupHead#match(Matcher, int, CharSequence)->boolean::: group head match
java.util.regex.Pattern.GroupHead#matchRef(Matcher, int, CharSequence)->boolean::: group head match ref
java.util.regex.Pattern.GroupRef#match(Matcher, int, CharSequence)->boolean::: group ref match
java.util.regex.Pattern.GroupRef#study(TreeInfo)->boolean::: group ref study
java.util.regex.Pattern.GroupTail#match(Matcher, int, CharSequence)->boolean::: group tail match
java.util.regex.Pattern.Prolog#match(Matcher, int, CharSequence)->boolean::: prolog match
java.util.regex.Pattern.Prolog#study(TreeInfo)->boolean::: prolog study
java.util.regex.Pattern.Loop#match(Matcher, int, CharSequence)->boolean::: loop match
java.util.regex.Pattern.Loop#matchInit(Matcher, int, CharSequence)->boolean::: loop match init
java.util.regex.Pattern.Loop#study(TreeInfo)->boolean::: loop study
java.util.regex.Pattern.LazyLoop#match(Matcher, int, CharSequence)->boolean::: lazy loop match
java.util.regex.Pattern.LazyLoop#matchInit(Matcher, int, CharSequence)->boolean::: lazy loop match init
java.util.regex.Pattern.LazyLoop#study(TreeInfo)->boolean::: lazy loop study
java.util.regex.Pattern.BackRef#match(Matcher, int, CharSequence)->boolean::: back ref match
java.util.regex.Pattern.BackRef#study(TreeInfo)->boolean::: back ref study
java.util.regex.Pattern.CIBackRef#match(Matcher, int, CharSequence)->boolean::: back ref match
java.util.regex.Pattern.CIBackRef#study(TreeInfo)->boolean::: back ref study
java.util.regex.Pattern.First#match(Matcher, int, CharSequence)->boolean::: first match
java.util.regex.Pattern.First#study(TreeInfo)->boolean::: first study
java.util.regex.Pattern.Conditional#match(Matcher, int, CharSequence)->boolean::: conditional match
java.util.regex.Pattern.Conditional#study(TreeInfo)->boolean::: conditional study
java.util.regex.Pattern.Pos#match(Matcher, int, CharSequence)->boolean::: pos match
java.util.regex.Pattern.Neg#match(Matcher, int, CharSequence)->boolean::: neg match
java.util.regex.Pattern.Behind#match(Matcher, int, CharSequence)->boolean::: behind match
java.util.regex.Pattern.BehindS#match(Matcher, int, CharSequence)->boolean::: behind s match
java.util.regex.Pattern.NotBehind#match(Matcher, int, CharSequence)->boolean::: not behind match
java.util.regex.Pattern.NotBehindS#match(Matcher, int, CharSequence)->boolean::: not behind s match
java.util.regex.Pattern.Bound#isWord(int)->boolean::: bound is word
java.util.regex.Pattern.Bound#check(Matcher, int, CharSequence)->int::: bound check
java.util.regex.Pattern.Bound#match(Matcher, int, CharSequence)->boolean::: bound match
java.util.regex.Pattern.BnM#optimize(Node)->Node:::Pre calculates arrays needed to generate the bad character shift and the good suffix shift
java.util.regex.Pattern.BnM#match(Matcher, int, CharSequence)->boolean::: bn m match
java.util.regex.Pattern.BnM#study(TreeInfo)->boolean::: bn m study
java.util.regex.Pattern.BnMS#match(Matcher, int, CharSequence)->boolean::: bn s match
java.util.regex.Pattern.CharPredicate#is(int)->boolean::: char predicate is
java.util.regex.Pattern.CharPredicate#and(CharPredicate)->CharPredicate::: char predicate and
java.util.regex.Pattern.CharPredicate#union(CharPredicate)->CharPredicate::: char predicate union
java.util.regex.Pattern.CharPredicate#union(CharPredicate, CharPredicate)->CharPredicate::: char predicate union
java.util.regex.Pattern.CharPredicate#negate()->CharPredicate::: char predicate negate
java.util.regex.Pattern.BmpCharPredicate#and(CharPredicate)->CharPredicate::: bmp char predicate and
java.util.regex.Pattern.BmpCharPredicate#union(CharPredicate)->CharPredicate::: bmp char predicate union
java.util.regex.Pattern.BmpCharPredicate#union(CharPredicate...)->CharPredicate::: bmp char predicate union
java.util.regex.Pattern#VertWS()->BmpCharPredicate:::matches a Perl vertical whitespace
java.util.regex.Pattern#HorizWS()->BmpCharPredicate:::matches a Perl horizontal whitespace
java.util.regex.Pattern#ALL()->CharPredicate::: for the Unicode category ALL and the dot metacharacter when  in dotall mode.
java.util.regex.Pattern#DOT()->CharPredicate:::for the dot metacharacter when dotall is not enabled.
java.util.regex.Pattern#UNIXDOT()->CharPredicate::: the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.
java.util.regex.Pattern#SingleS(int)->CharPredicate:::Indicate that matches a Supplementary Unicode character
java.util.regex.Pattern#Single(int)->BmpCharPredicate:::A bmp/optimized predicate of single
java.util.regex.Pattern#SingleI(int, int)->BmpCharPredicate:::Case insensitive matches a given BMP character
java.util.regex.Pattern#SingleU(int)->CharPredicate:::Unicode case insensitive matches a given Unicode character
java.util.regex.Pattern#Range(int, int)->CharPredicate:::Charactrs within a explicit value range
java.util.regex.Pattern#CIRange(int, int)->CharPredicate:::Charactrs within a explicit value range in a case insensitive manner.
java.util.regex.Pattern#CIRangeU(int, int)->CharPredicate::: pattern  range u
java.util.regex.Pattern#asPredicate()->Predicate:::Creates a predicate that tests if this pattern is found in a given input string.
java.util.regex.Pattern#asMatchPredicate()->Predicate:::Creates a predicate that tests if this pattern matches a given input string.
java.util.regex.Pattern#splitAsStream(CharSequence)->Stream:::Creates a stream from the given input sequence around matches of this pattern
java.util.regex.PatternSyntaxException#getIndex()->int:::Retrieves the error index.
java.util.regex.PatternSyntaxException#getDescription()->String:::Retrieves the description of the error.
java.util.regex.PatternSyntaxException#getPattern()->String:::Retrieves the erroneous regular-expression pattern.
java.util.regex.PatternSyntaxException#getMessage()->String:::Returns a multi-line string containing the description of the syntax error and its index, the erroneous regular-expression pattern, and a visual indication of the error index within the pattern.
java.util.regex.PrintPattern#walk(Pattern.Node, int)->void::: print pattern walk
java.util.regex.PrintPattern#main(String[])->void::: print pattern main
