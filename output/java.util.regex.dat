java.util.regex.ASCII#getType(int)->int:::
java.util.regex.ASCII#isType(int, int)->boolean:::
java.util.regex.ASCII#isAscii(int)->boolean:::
java.util.regex.ASCII#isAlpha(int)->boolean:::
java.util.regex.ASCII#isDigit(int)->boolean:::
java.util.regex.ASCII#isAlnum(int)->boolean:::
java.util.regex.ASCII#isGraph(int)->boolean:::
java.util.regex.ASCII#isPrint(int)->boolean:::
java.util.regex.ASCII#isPunct(int)->boolean:::
java.util.regex.ASCII#isSpace(int)->boolean:::
java.util.regex.ASCII#isHexDigit(int)->boolean:::
java.util.regex.ASCII#isOctDigit(int)->boolean:::
java.util.regex.ASCII#isCntrl(int)->boolean:::
java.util.regex.ASCII#isLower(int)->boolean:::
java.util.regex.ASCII#isUpper(int)->boolean:::
java.util.regex.ASCII#isWord(int)->boolean:::
java.util.regex.ASCII#toDigit(int)->int:::
java.util.regex.ASCII#toLower(int)->int:::
java.util.regex.ASCII#toUpper(int)->int:::
java.util.regex.CharPredicates#ALPHABETIC()->CharPredicate:::
java.util.regex.CharPredicates#DIGIT()->CharPredicate:::
java.util.regex.CharPredicates#LETTER()->CharPredicate:::
java.util.regex.CharPredicates#IDEOGRAPHIC()->CharPredicate:::
java.util.regex.CharPredicates#LOWERCASE()->CharPredicate:::
java.util.regex.CharPredicates#UPPERCASE()->CharPredicate:::
java.util.regex.CharPredicates#TITLECASE()->CharPredicate:::
java.util.regex.CharPredicates#WHITE_SPACE()->CharPredicate:::
java.util.regex.CharPredicates#CONTROL()->CharPredicate:::
java.util.regex.CharPredicates#PUNCTUATION()->CharPredicate:::
java.util.regex.CharPredicates#HEX_DIGIT()->CharPredicate:::
java.util.regex.CharPredicates#ASSIGNED()->CharPredicate:::
java.util.regex.CharPredicates#NONCHARACTER_CODE_POINT()->CharPredicate:::
java.util.regex.CharPredicates#ALNUM()->CharPredicate:::
java.util.regex.CharPredicates#BLANK()->CharPredicate:::
java.util.regex.CharPredicates#GRAPH()->CharPredicate:::
java.util.regex.CharPredicates#PRINT()->CharPredicate:::
java.util.regex.CharPredicates#JOIN_CONTROL()->CharPredicate:::
java.util.regex.CharPredicates#WORD()->CharPredicate:::
java.util.regex.CharPredicates#forUnicodeProperty(String)->CharPredicate:::
java.util.regex.CharPredicates#forPOSIXName(String)->CharPredicate:::
java.util.regex.CharPredicates#forUnicodeScript(String)->CharPredicate:::Returns a predicate matching all characters belong to a named  UnicodeScript.
java.util.regex.CharPredicates#forUnicodeBlock(String)->CharPredicate:::Returns a predicate matching all characters in a UnicodeBlock.
java.util.regex.CharPredicates#forProperty(String)->CharPredicate:::
java.util.regex.CharPredicates#ASCII_DIGIT()->BmpCharPredicate:::Posix ASCII variants, not in the lookup map
java.util.regex.CharPredicates#ASCII_WORD()->BmpCharPredicate:::
java.util.regex.CharPredicates#ASCII_SPACE()->BmpCharPredicate:::
java.util.regex.Grapheme#isBoundary(int, int)->boolean:::Determines if there is an extended  grapheme cluster boundary between two  continuing characters {@code cp1} and {@code cp2}
java.util.regex.IntHashSet#contains(int)->boolean:::
java.util.regex.IntHashSet#add(int)->void:::
java.util.regex.IntHashSet#clear()->void:::
java.util.regex.Matcher#pattern()->Pattern:::Returns the pattern that is interpreted by this matcher.
java.util.regex.Matcher#toMatchResult()->MatchResult:::Returns the match state of this matcher as a {@link MatchResult}
java.util.regex.Matcher.ImmutableMatchResult#start()->int:::
java.util.regex.Matcher.ImmutableMatchResult#start(int)->int:::
java.util.regex.Matcher.ImmutableMatchResult#end()->int:::
java.util.regex.Matcher.ImmutableMatchResult#end(int)->int:::
java.util.regex.Matcher.ImmutableMatchResult#groupCount()->int:::
java.util.regex.Matcher.ImmutableMatchResult#group()->String:::
java.util.regex.Matcher.ImmutableMatchResult#group(int)->String:::
java.util.regex.Matcher#usePattern(Pattern)->Matcher:::Changes the {@code Pattern} that this {@code Matcher} uses to  find matches with
java.util.regex.Matcher#reset()->Matcher:::Resets this matcher
java.util.regex.Matcher#reset(CharSequence)->Matcher:::Resets this matcher with a new input sequence
java.util.regex.Matcher#start()->int:::Returns the start index of the previous match.
java.util.regex.Matcher#start(int)->int:::Returns the start index of the subsequence captured by the given group  during the previous match operation
java.util.regex.Matcher#start(String)->int:::Returns the start index of the subsequence captured by the given  <a href="Pattern.html#groupname">named-capturing group</a> during the  previous match operation.
java.util.regex.Matcher#end()->int:::Returns the offset after the last character matched.
java.util.regex.Matcher#end(int)->int:::Returns the offset after the last character of the subsequence  captured by the given group during the previous match operation
java.util.regex.Matcher#end(String)->int:::Returns the offset after the last character of the subsequence  captured by the given <a href="Pattern.html#groupname">named-capturing  group</a> during the previous match operation.
java.util.regex.Matcher#group()->String:::Returns the input subsequence matched by the previous match
java.util.regex.Matcher#group(int)->String:::Returns the input subsequence captured by the given group during the  previous match operation
java.util.regex.Matcher#group(String)->String:::Returns the input subsequence captured by the given  <a href="Pattern.html#groupname">named-capturing group</a> during the  previous match operation
java.util.regex.Matcher#groupCount()->int:::Returns the number of capturing groups in this matcher's pattern
java.util.regex.Matcher#matches()->boolean:::Attempts to match the entire region against the pattern
java.util.regex.Matcher#find()->boolean:::Attempts to find the next subsequence of the input sequence that matches  the pattern
java.util.regex.Matcher#find(int)->boolean:::Resets this matcher and then attempts to find the next subsequence of  the input sequence that matches the pattern, starting at the specified  index
java.util.regex.Matcher#lookingAt()->boolean:::Attempts to match the input sequence, starting at the beginning of the  region, against the pattern
java.util.regex.Matcher#quoteReplacement(String)->String:::Returns a literal replacement {@code String} for the specified  {@code String}
java.util.regex.Matcher#appendReplacement(StringBuffer, String)->Matcher:::Implements a non-terminal append-and-replace step
java.util.regex.Matcher#appendReplacement(StringBuilder, String)->Matcher:::Implements a non-terminal append-and-replace step
java.util.regex.Matcher#appendTail(StringBuffer)->StringBuffer:::Implements a terminal append-and-replace step
java.util.regex.Matcher#appendTail(StringBuilder)->StringBuilder:::Implements a terminal append-and-replace step
java.util.regex.Matcher#replaceAll(String)->String:::Replaces every subsequence of the input sequence that matches the  pattern with the given replacement string
java.util.regex.Matcher#replaceAll(Function<MatchResult, String>)->String:::Replaces every subsequence of the input sequence that matches the  pattern with the result of applying the given replacer function to the  match result of this matcher corresponding to that subsequence
java.util.regex.Matcher#results()->Stream<MatchResult>:::Returns a stream of match results for each subsequence of the input  sequence that matches the pattern
java.util.regex.Matcher#replaceFirst(String)->String:::Replaces the first subsequence of the input sequence that matches the  pattern with the given replacement string
java.util.regex.Matcher#replaceFirst(Function<MatchResult, String>)->String:::Replaces the first subsequence of the input sequence that matches the  pattern with the result of applying the given replacer function to the  match result of this matcher corresponding to that subsequence
java.util.regex.Matcher#region(int, int)->Matcher:::Sets the limits of this matcher's region
java.util.regex.Matcher#regionStart()->int:::Reports the start index of this matcher's region
java.util.regex.Matcher#regionEnd()->int:::Reports the end index (exclusive) of this matcher's region
java.util.regex.Matcher#hasTransparentBounds()->boolean:::Queries the transparency of region bounds for this matcher
java.util.regex.Matcher#useTransparentBounds(boolean)->Matcher:::Sets the transparency of region bounds for this matcher
java.util.regex.Matcher#hasAnchoringBounds()->boolean:::Queries the anchoring of region bounds for this matcher
java.util.regex.Matcher#useAnchoringBounds(boolean)->Matcher:::Sets the anchoring of region bounds for this matcher
java.util.regex.Matcher#toString()->String:::<p>Returns the string representation of this matcher
java.util.regex.Matcher#hitEnd()->boolean:::<p>Returns true if the end of input was hit by the search engine in  the last match operation performed by this matcher
java.util.regex.Matcher#requireEnd()->boolean:::<p>Returns true if more input could change a positive match into a  negative one
java.util.regex.Matcher#search(int)->boolean:::Initiates a search to find a Pattern within the given bounds
java.util.regex.Matcher#match(int, int)->boolean:::Initiates a search for an anchored match to a Pattern within the given  bounds
java.util.regex.Matcher#getTextLength()->int:::Returns the end index of the text.
java.util.regex.Matcher#getSubSequence(int, int)->CharSequence:::Generates a String from this matcher's input in the specified range.
java.util.regex.Matcher#charAt(int)->char:::Returns this matcher's input character at index i.
java.util.regex.Matcher#getMatchedGroupIndex(String)->int:::Returns the group index of the matched capturing group.
java.util.regex.MatchResult#start()->int:::Returns the start index of the match.
java.util.regex.MatchResult#start(int)->int:::Returns the start index of the subsequence captured by the given group  during this match
java.util.regex.MatchResult#end()->int:::Returns the offset after the last character matched.
java.util.regex.MatchResult#end(int)->int:::Returns the offset after the last character of the subsequence  captured by the given group during this match
java.util.regex.MatchResult#group()->String:::Returns the input subsequence matched by the previous match
java.util.regex.MatchResult#group(int)->String:::Returns the input subsequence captured by the given group during the  previous match operation
java.util.regex.MatchResult#groupCount()->int:::Returns the number of capturing groups in this match result's pattern
java.util.regex.Pattern#compile(String)->Pattern:::Compiles the given regular expression into a pattern.
java.util.regex.Pattern#compile(String, int)->Pattern:::Compiles the given regular expression into a pattern with the given  flags.
java.util.regex.Pattern#pattern()->String:::Returns the regular expression from which this pattern was compiled.
java.util.regex.Pattern#toString()->String:::<p>Returns the string representation of this pattern
java.util.regex.Pattern#matcher(CharSequence)->Matcher:::Creates a matcher that will match the given input against this pattern.
java.util.regex.Pattern#flags()->int:::Returns this pattern's match flags.
java.util.regex.Pattern#matches(String, CharSequence)->boolean:::Compiles the given regular expression and attempts to match the given  input against it
java.util.regex.Pattern#split(CharSequence, int)->String[]:::Splits the given input sequence around matches of this pattern
java.util.regex.Pattern#split(CharSequence)->String[]:::Splits the given input sequence around matches of this pattern
java.util.regex.Pattern#quote(String)->String:::Returns a literal pattern {@code String} for the specified  {@code String}
java.util.regex.Pattern#Integer> namedGroups()->Map<String,:::
java.util.regex.Pattern.TreeInfo#reset()->void:::
java.util.regex.Pattern.BitClass#add(int, int)->BitClass:::
java.util.regex.Pattern.Node#match(Matcher, int, CharSequence)->boolean:::This method implements the classic accept node.
java.util.regex.Pattern.Node#study(TreeInfo)->boolean:::This method is good for all zero length assertions.
java.util.regex.Pattern.LastNode#match(Matcher, int, CharSequence)->boolean:::This method implements the classic accept node with  the addition of a check to see if the match occurred  using all of the input.
java.util.regex.Pattern.Start#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Start#study(TreeInfo)->boolean:::
java.util.regex.Pattern.StartS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Begin#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.End#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Caret#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.UnixCaret#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.LastMatch#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Dollar#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Dollar#study(TreeInfo)->boolean:::
java.util.regex.Pattern.UnixDollar#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.UnixDollar#study(TreeInfo)->boolean:::
java.util.regex.Pattern.LineEnding#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.LineEnding#study(TreeInfo)->boolean:::
java.util.regex.Pattern.CharProperty#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.CharProperty#study(TreeInfo)->boolean:::
java.util.regex.Pattern.BmpCharProperty#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.NFCCharProperty#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.NFCCharProperty#study(TreeInfo)->boolean:::
java.util.regex.Pattern.XGrapheme#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.XGrapheme#study(TreeInfo)->boolean:::
java.util.regex.Pattern.GraphemeBound#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceNode#study(TreeInfo)->boolean:::
java.util.regex.Pattern.Slice#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceI#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceU#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceIS#toLower(int)->int:::
java.util.regex.Pattern.SliceIS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.SliceUS#toLower(int)->int:::
java.util.regex.Pattern.Ques#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Ques#study(TreeInfo)->boolean:::
java.util.regex.Pattern.CharPropertyGreedy#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.CharPropertyGreedy#study(TreeInfo)->boolean:::
java.util.regex.Pattern.BmpCharPropertyGreedy#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Curly#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Curly#match0(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.Curly#match1(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.Curly#match2(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.Curly#study(TreeInfo)->boolean:::
java.util.regex.Pattern.GroupCurly#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupCurly#match0(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupCurly#match1(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupCurly#match2(Matcher, int, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupCurly#study(TreeInfo)->boolean:::
java.util.regex.Pattern.BranchConn#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.BranchConn#study(TreeInfo)->boolean:::
java.util.regex.Pattern.Branch#add(Node)->void:::
java.util.regex.Pattern.Branch#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Branch#study(TreeInfo)->boolean:::
java.util.regex.Pattern.GroupHead#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupHead#matchRef(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupRef#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.GroupRef#study(TreeInfo)->boolean:::
java.util.regex.Pattern.GroupTail#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Prolog#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Prolog#study(TreeInfo)->boolean:::
java.util.regex.Pattern.Loop#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Loop#matchInit(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Loop#study(TreeInfo)->boolean:::
java.util.regex.Pattern.LazyLoop#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.LazyLoop#matchInit(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.LazyLoop#study(TreeInfo)->boolean:::
java.util.regex.Pattern.BackRef#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.BackRef#study(TreeInfo)->boolean:::
java.util.regex.Pattern.CIBackRef#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.CIBackRef#study(TreeInfo)->boolean:::
java.util.regex.Pattern.First#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.First#study(TreeInfo)->boolean:::
java.util.regex.Pattern.Conditional#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Conditional#study(TreeInfo)->boolean:::
java.util.regex.Pattern.Pos#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Neg#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Behind#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.BehindS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.NotBehind#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.NotBehindS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.Bound#isWord(int)->boolean:::
java.util.regex.Pattern.Bound#check(Matcher, int, CharSequence)->int:::
java.util.regex.Pattern.Bound#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.BnM#optimize(Node)->Node:::Pre calculates arrays needed to generate the bad character  shift and the good suffix shift
java.util.regex.Pattern.BnM#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.BnM#study(TreeInfo)->boolean:::
java.util.regex.Pattern.BnMS#match(Matcher, int, CharSequence)->boolean:::
java.util.regex.Pattern.CharPredicate#is(int)->boolean:::
java.util.regex.Pattern.CharPredicate#and(CharPredicate)->CharPredicate:::
java.util.regex.Pattern.CharPredicate#union(CharPredicate)->CharPredicate:::
java.util.regex.Pattern.CharPredicate#union(CharPredicate, CharPredicate)->CharPredicate:::
java.util.regex.Pattern.CharPredicate#negate()->CharPredicate:::
java.util.regex.Pattern.BmpCharPredicate#and(CharPredicate)->CharPredicate:::
java.util.regex.Pattern.BmpCharPredicate#union(CharPredicate)->CharPredicate:::
java.util.regex.Pattern.BmpCharPredicate#union(CharPredicate...)->CharPredicate:::
java.util.regex.Pattern#VertWS()->BmpCharPredicate:::matches a Perl vertical whitespace
java.util.regex.Pattern#HorizWS()->BmpCharPredicate:::matches a Perl horizontal whitespace
java.util.regex.Pattern#ALL()->CharPredicate::: for the Unicode category ALL and the dot metacharacter when   in dotall mode.
java.util.regex.Pattern#DOT()->CharPredicate:::for the dot metacharacter when dotall is not enabled.
java.util.regex.Pattern#UNIXDOT()->CharPredicate::: the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.
java.util.regex.Pattern#SingleS(int)->CharPredicate:::Indicate that matches a Supplementary Unicode character
java.util.regex.Pattern#Single(int)->BmpCharPredicate:::A bmp/optimized predicate of single
java.util.regex.Pattern#SingleI(int, int)->BmpCharPredicate:::Case insensitive matches a given BMP character
java.util.regex.Pattern#SingleU(int)->CharPredicate:::Unicode case insensitive matches a given Unicode character
java.util.regex.Pattern#Range(int, int)->CharPredicate:::Charactrs within a explicit value range
java.util.regex.Pattern#CIRange(int, int)->CharPredicate:::Charactrs within a explicit value range in a case insensitive manner.
java.util.regex.Pattern#CIRangeU(int, int)->CharPredicate:::
java.util.regex.Pattern#asPredicate()->Predicate<String>:::Creates a predicate that tests if this pattern is found in a given input  string.
java.util.regex.Pattern#asMatchPredicate()->Predicate<String>:::Creates a predicate that tests if this pattern matches a given input string.
java.util.regex.Pattern#splitAsStream(CharSequence)->Stream<String>:::Creates a stream from the given input sequence around matches of this  pattern
java.util.regex.PatternSyntaxException#getIndex()->int:::Retrieves the error index.
java.util.regex.PatternSyntaxException#getDescription()->String:::Retrieves the description of the error.
java.util.regex.PatternSyntaxException#getPattern()->String:::Retrieves the erroneous regular-expression pattern.
java.util.regex.PatternSyntaxException#getMessage()->String:::Returns a multi-line string containing the description of the syntax  error and its index, the erroneous regular-expression pattern, and a  visual indication of the error index within the pattern.
java.util.regex.PrintPattern#walk(Pattern.Node, int)->void:::
java.util.regex.PrintPattern#main(String[])->void:::
