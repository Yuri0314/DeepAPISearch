ASCII#getType(int)::: i get type:::return
ASCII#isType(int, int)::: i is type:::return->getType
ASCII#isAscii(int)::: i is ascii:::return
ASCII#isAlpha(int)::: i is alpha:::return->isType
ASCII#isDigit(int)::: i is digit:::return
ASCII#isAlnum(int)::: i is alnum:::return->isType
ASCII#isGraph(int)::: i is graph:::return->isType
ASCII#isPrint(int)::: i is print:::return
ASCII#isPunct(int)::: i is punct:::return->isType
ASCII#isSpace(int)::: i is space:::return->isType
ASCII#isHexDigit(int)::: i is hex digit:::return->isType
ASCII#isOctDigit(int)::: i is oct digit:::return
ASCII#isCntrl(int)::: i is cntrl:::return->isType
ASCII#isLower(int)::: i is lower:::return
ASCII#isUpper(int)::: i is upper:::return
ASCII#isWord(int)::: i is word:::return->isType
ASCII#toDigit(int)::: i to digit:::return
ASCII#toLower(int)::: i to lower:::return->isUpper
ASCII#toUpper(int)::: i to upper:::return->isLower
CharPredicates#ALPHABETIC()::: char predicates  c:::return->Character->isAlphabetic
CharPredicates#DIGIT()::: char predicates  t:::return->Character->isDigit
CharPredicates#LETTER()::: char predicates  r:::return->Character->isLetter
CharPredicates#IDEOGRAPHIC()::: char predicates  c:::return->Character->isIdeographic
CharPredicates#LOWERCASE()::: char predicates  e:::return->Character->isLowerCase
CharPredicates#UPPERCASE()::: char predicates  e:::return->Character->isUpperCase
CharPredicates#TITLECASE()::: char predicates  e:::return->Character->isTitleCase
CharPredicates#WHITE_SPACE()::: char predicates  e_ e:::return->Character->getType
CharPredicates#CONTROL()::: char predicates  l:::return->Character->getType
CharPredicates#PUNCTUATION()::: char predicates  n:::return->Character->getType
CharPredicates#HEX_DIGIT()::: char predicates  x_ t:::return->DIGIT->union
CharPredicates#ASSIGNED()::: char predicates  d:::return->Character->getType
CharPredicates#NONCHARACTER_CODE_POINT()::: char predicates  r_ e_ t:::return
CharPredicates#ALNUM()::: char predicates  m:::return->ALPHABETIC->DIGIT->union
CharPredicates#BLANK()::: char predicates  k:::return->Character->getType
CharPredicates#GRAPH()::: char predicates  h:::return->Character->getType
CharPredicates#PRINT()::: char predicates  t:::return->GRAPH->BLANK->union->CONTROL->negate->and
CharPredicates#JOIN_CONTROL()::: char predicates  n_ l:::return
CharPredicates#WORD()::: char predicates  d:::return->ALPHABETIC->Character->getType->JOIN_CONTROL->union
CharPredicates#getPosixPredicate(String)::: char predicates get posix predicate:::switch->return->ALPHABETIC->return->LOWERCASE->return->UPPERCASE->return->WHITE_SPACE->return->PUNCTUATION->return->HEX_DIGIT->return->ALNUM->return->CONTROL->return->DIGIT->return->BLANK->return->GRAPH->return->PRINT->return
CharPredicates#getUnicodePredicate(String)::: char predicates get unicode predicate:::switch->return->ALPHABETIC->return->ASSIGNED->return->CONTROL->return->HEX_DIGIT->return->IDEOGRAPHIC->return->JOIN_CONTROL->return->LETTER->return->LOWERCASE->return->NONCHARACTER_CODE_POINT->return->TITLECASE->return->PUNCTUATION->return->UPPERCASE->return->WHITE_SPACE->return->WORD->return->WHITE_SPACE->return->HEX_DIGIT->return->NONCHARACTER_CODE_POINT->return->JOIN_CONTROL->return
CharPredicates#forUnicodeProperty(String)::: char predicates for unicode property:::propName->toUpperCase->p->getUnicodePredicate->if->return->return->getPosixPredicate
CharPredicates#forPOSIXName(String)::: char predicates for name:::return->propName->toUpperCase->getPosixPredicate
CharPredicates#forUnicodeScript(String):::Returns a predicate matching all characters belong to a named UnicodeScript.:::script->try->forName->return->of->catch->finally->return
CharPredicates#forUnicodeBlock(String):::Returns a predicate matching all characters in a UnicodeBlock.:::block->try->forName->return->of->catch->finally->return
CharPredicates#forProperty(String)::: char predicates for property:::switch->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->category->return->range->return->Pattern->ALL->return->range->return->ctype->return->ctype->return->ctype->return->ctype->return->range->return->ctype->return->range->return->range->return->ctype->return->ctype->return->range->return->ctype->return->java.lang.Character->isLowerCase->return->Character->isUpperCase->return->java.lang.Character->isAlphabetic->return->java.lang.Character->isIdeographic->return->java.lang.Character->isTitleCase->return->java.lang.Character->isDigit->return->java.lang.Character->isDefined->return->java.lang.Character->isLetter->return->java.lang.Character->isLetterOrDigit->return->java.lang.Character->isJavaIdentifierStart->return->java.lang.Character->isJavaIdentifierPart->return->java.lang.Character->isUnicodeIdentifierStart->return->java.lang.Character->isUnicodeIdentifierPart->return->java.lang.Character->isIdentifierIgnorable->return->java.lang.Character->isSpaceChar->return->java.lang.Character->isWhitespace->return->java.lang.Character->isISOControl->return->java.lang.Character->isMirrored->return
CharPredicates#category(int)::: char predicates category:::return->Character->getType
CharPredicates#range(int, int)::: char predicates range:::return
CharPredicates#ctype(int)::: char predicates ctype:::return->ASCII->isType
CharPredicates#ASCII_DIGIT():::Posix ASCII variants, not in the lookup map:::return->ASCII->isDigit
CharPredicates#ASCII_WORD()::: char predicates  i_ d:::return->ASCII->isWord
CharPredicates#ASCII_SPACE()::: char predicates  i_ e:::return->ASCII->isSpace
Grapheme#isBoundary(int, int):::Determines if there is an extended  grapheme cluster boundary between two continuing characters cp1 and cp2:::return->getType->getType
Grapheme#isExcludedSpacingMark(int)::: grapheme is excluded spacing mark:::return
Grapheme#getType(int)::: grapheme get type:::type->Character->getType->switch->if->return->if->return->return->if->return->return->if->return->return->return->if->isExcludedSpacingMark->return->return->if->return->return->if->return->return->if->return->if->if->return->if->return->return->sindex->if->if->return->return->if->return->if->return->if->return->return
IntHashSet#contains(int)::: int hash set contains:::h->while->if->return->return
IntHashSet#add(int)::: int hash set add:::h0->next->next0->while->if->return->if->expand
IntHashSet#clear()::: int hash set clear:::Arrays->fill->Arrays->fill
IntHashSet#expand()::: int hash set expand:::old->es->new->intArr->hlen->hs->new->intArr->Arrays->fill->Arrays->fill->for->n
Matcher#pattern():::Returns the pattern that is interpreted by this matcher.:::return
Matcher#toMatchResult():::Returns the match state of this matcher as a MatchResult:::return->text->toString->toMatchResult
Matcher#toMatchResult(String)::: matcher to match result:::return->groupCount->clone->new->ImmutableMatchResult
Matcher.ImmutableMatchResult#start()::: immutable match result start:::checkMatch->return
Matcher.ImmutableMatchResult#start(int)::: immutable match result start:::checkMatch->if->throw->new->IndexOutOfBoundsException->return
Matcher.ImmutableMatchResult#end()::: immutable match result end:::checkMatch->return
Matcher.ImmutableMatchResult#end(int)::: immutable match result end:::checkMatch->if->throw->new->IndexOutOfBoundsException->return
Matcher.ImmutableMatchResult#groupCount()::: immutable match result group count:::return
Matcher.ImmutableMatchResult#group()::: immutable match result group:::checkMatch->return->group
Matcher.ImmutableMatchResult#group(int)::: immutable match result group:::checkMatch->if->throw->new->IndexOutOfBoundsException->if->return->return->text->subSequence->toString
Matcher.ImmutableMatchResult#checkMatch()::: immutable match result check match:::if->throw->new->IllegalStateException
Matcher#usePattern(Pattern):::Changes the Pattern that this Matcher uses to find matches with:::if->throw->new->IllegalArgumentException->parentGroupCount->Math->max->new->intArr->new->intArr->for->i->for->i->new->IntHashSetArr->return
Matcher#reset():::Resets this matcher:::for->i->for->i->for->i->getTextLength->return
Matcher#reset(CharSequence):::Resets this matcher with a new input sequence:::return->reset
Matcher#start():::Returns the start index of the previous match.:::if->throw->new->IllegalStateException->return
Matcher#start(int):::Returns the start index of the subsequence captured by the given group during the previous match operation:::if->throw->new->IllegalStateException->if->groupCount->throw->new->IndexOutOfBoundsException->return
Matcher#start(String):::Returns the start index of the subsequence captured by the given named-capturing group during the previous match operation.:::return->getMatchedGroupIndex
Matcher#end():::Returns the offset after the last character matched.:::if->throw->new->IllegalStateException->return
Matcher#end(int):::Returns the offset after the last character of the subsequence captured by the given group during the previous match operation:::if->throw->new->IllegalStateException->if->groupCount->throw->new->IndexOutOfBoundsException->return
Matcher#end(String):::Returns the offset after the last character of the subsequence captured by the given named-capturing group during the previous match operation.:::return->getMatchedGroupIndex
Matcher#group():::Returns the input subsequence matched by the previous match:::return->group
Matcher#group(int):::Returns the input subsequence captured by the given group during the previous match operation:::if->throw->new->IllegalStateException->if->groupCount->throw->new->IndexOutOfBoundsException->if->return->return->getSubSequence->toString
Matcher#group(String):::Returns the input subsequence captured by the given named-capturing group during the previous match operation:::group->getMatchedGroupIndex->if->return->return->getSubSequence->toString
Matcher#groupCount():::Returns the number of capturing groups in this matcher's pattern:::return
Matcher#matches():::Attempts to match the entire region against the pattern:::return->match
Matcher#find():::Attempts to find the next subsequence of the input sequence that matches the pattern:::nextSearchIndex->if->if->if->for->i->return->return->search
Matcher#find(int):::Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index:::limit->getTextLength->if->throw->new->IndexOutOfBoundsException->reset->return->search
Matcher#lookingAt():::Attempts to match the input sequence, starting at the beginning of the region, against the pattern:::return->match
Matcher#quoteReplacement(String):::Returns a literal replacement String for the specified String:::if->s->indexOf->s->indexOf->return->sb->new->StringBuilder->for->i->s->length->return->sb->toString
Matcher#appendReplacement(StringBuffer, String):::Implements a non-terminal append-and-replace step:::if->throw->new->IllegalStateException->result->new->StringBuilder->appendExpandedReplacement->sb->append->sb->append->return
Matcher#appendReplacement(StringBuilder, String):::Implements a non-terminal append-and-replace step:::if->throw->new->IllegalStateException->result->new->StringBuilder->appendExpandedReplacement->sb->append->sb->append->return
Matcher#appendExpandedReplacement(String, StringBuilder):::Processes replacement string to replace group references with groups.:::cursor->while->replacement->length->nextChar->replacement->charAt->if->if->replacement->length->throw->new->IllegalArgumentException->replacement->charAt->result->append->else->if->if->replacement->length->throw->new->IllegalArgumentException->replacement->charAt->refNum->if->gsb->new->StringBuilder->while->replacement->length->replacement->charAt->if->ASCII->isLower->ASCII->isUpper->ASCII->isDigit->gsb->append->else->break->if->gsb->length->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->gname->gsb->toString->if->ASCII->gname->charAt->isDigit->throw->new->IllegalArgumentException->if->parentPattern->namedGroups->containsKey->throw->new->IllegalArgumentException->parentPattern->namedGroups->get->else->if->throw->new->IllegalArgumentException->done->while->if->replacement->length->break->nextDigit->replacement->charAt->if->break->newRefNum->if->groupCount->else->if->start->end->result->start->end->append->else->result->append->return
Matcher#appendTail(StringBuffer):::Implements a terminal append-and-replace step:::sb->getTextLength->append->return
Matcher#appendTail(StringBuilder):::Implements a terminal append-and-replace step:::sb->getTextLength->append->return
Matcher#replaceAll(String):::Replaces every subsequence of the input sequence that matches the pattern with the given replacement string:::reset->result->find->if->sb->new->StringBuilder->do->appendReplacement->find->while->appendTail->return->sb->toString->return->text->toString
Matcher#replaceAll(Function):::Replaces every subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence:::Objects->requireNonNull->reset->result->find->if->sb->new->StringBuilder->do->ec->replacement->replacer->apply->if->throw->new->ConcurrentModificationException->appendReplacement->find->while->appendTail->return->sb->toString->return->text->toString
Matcher#results():::Returns a stream of match results for each subsequence of the input sequence that matches the pattern:::return->StreamSupport->Spliterators->new->MatchResultIterator->spliteratorUnknownSize->stream
Matcher#replaceFirst(String):::Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string:::if->throw->new->NullPointerException->reset->if->find->return->text->toString->sb->new->StringBuilder->appendReplacement->appendTail->return->sb->toString
Matcher#replaceFirst(Function):::Replaces the first subsequence of the input sequence that matches the pattern with the result of applying the given replacer function to the match result of this matcher corresponding to that subsequence:::Objects->requireNonNull->reset->if->find->return->text->toString->sb->new->StringBuilder->ec->replacement->replacer->apply->if->throw->new->ConcurrentModificationException->appendReplacement->appendTail->return->sb->toString
Matcher#region(int, int):::Sets the limits of this matcher's region:::if->getTextLength->throw->new->IndexOutOfBoundsException->if->getTextLength->throw->new->IndexOutOfBoundsException->if->throw->new->IndexOutOfBoundsException->reset->return
Matcher#regionStart():::Reports the start index of this matcher's region:::return
Matcher#regionEnd():::Reports the end index (exclusive) of this matcher's region:::return
Matcher#hasTransparentBounds():::Queries the transparency of region bounds for this matcher:::return
Matcher#useTransparentBounds(boolean):::Sets the transparency of region bounds for this matcher:::return
Matcher#hasAnchoringBounds():::Queries the anchoring of region bounds for this matcher:::return
Matcher#useAnchoringBounds(boolean):::Sets the anchoring of region bounds for this matcher:::return
Matcher#toString():::Returns the string representation of this matcher:::sb->new->StringBuilder->sb->append->append->pattern->append->append->regionStart->append->append->regionEnd->append->append->if->group->sb->group->append->sb->append->return->sb->toString
Matcher#hitEnd():::Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher:::return
Matcher#requireEnd():::Returns true if more input could change a positive match into a negative one:::return
Matcher#search(int):::Initiates a search to find a Pattern within the given bounds:::for->i->for->i->result->match->if->return
Matcher#match(int, int):::Initiates a search for an anchored match to a Pattern within the given bounds:::for->i->for->i->result->match->if->return
Matcher#getTextLength():::Returns the end index of the text.:::return->text->length
Matcher#getSubSequence(int, int):::Generates a String from this matcher's input in the specified range.:::return->text->subSequence
Matcher#charAt(int):::Returns this matcher's input character at index i.:::return->text->charAt
Matcher#getMatchedGroupIndex(String):::Returns the group index of the matched capturing group.:::Objects->requireNonNull->if->throw->new->IllegalStateException->if->parentPattern->namedGroups->containsKey->throw->new->IllegalArgumentException->return->parentPattern->namedGroups->get
MatchResult#start():::Returns the start index of the match.:::
MatchResult#start(int):::Returns the start index of the subsequence captured by the given group during this match:::
MatchResult#end():::Returns the offset after the last character matched.:::
MatchResult#end(int):::Returns the offset after the last character of the subsequence captured by the given group during this match:::
MatchResult#group():::Returns the input subsequence matched by the previous match:::
MatchResult#group(int):::Returns the input subsequence captured by the given group during the previous match operation:::
MatchResult#groupCount():::Returns the number of capturing groups in this match result's pattern:::
Pattern#compile(String):::Compiles the given regular expression into a pattern.:::return->new->Pattern
Pattern#compile(String, int):::Compiles the given regular expression into a pattern with the given flags.:::return->new->Pattern
Pattern#pattern():::Returns the regular expression from which this pattern was compiled.:::return
Pattern#toString():::Returns the string representation of this pattern:::return
Pattern#matcher(CharSequence):::Creates a matcher that will match the given input against this pattern.:::if->synchronized->if->compile->m->new->Matcher->return
Pattern#flags():::Returns this pattern's match flags.:::return
Pattern#matches(String, CharSequence):::Compiles the given regular expression and attempts to match the given input against it:::p->Pattern->compile->m->p->matcher->return->m->matches
Pattern#split(CharSequence, int):::Splits the given input sequence around matches of this pattern:::index->matchLimited->matchList->new->ArrayList<>->m->matcher->while->m->find->if->matchList->size->if->m->start->m->start->m->end->continue->match->input->m->start->subSequence->toString->matchList->add->m->end->else->if->matchList->size->match->input->input->length->subSequence->toString->matchList->add->m->end->if->return->new->StringArr->input->toString->if->matchList->size->matchList->input->input->length->subSequence->toString->add->resultSize->matchList->size->if->while->matchList->get->equals->result->new->StringArr->return->matchList->subList->toArray
Pattern#split(CharSequence):::Splits the given input sequence around matches of this pattern:::return->split
Pattern#quote(String):::Returns a literal pattern String for the specified String:::slashEIndex->s->indexOf->if->return->lenHint->s->length->sb->new->StringBuilder->sb->append->current->do->sb->append->append->while->s->indexOf->return->sb->s->length->append->append->toString
Pattern#readObject(java.io.ObjectInputStream):::Recompile the Pattern instance from a stream:::s->defaultReadObject->if->pattern->length->new->Start
Pattern#normalize(String):::The pattern is converted to normalized form (java.text.Normalizer.Form.NFC NFC, canonical decomposition, followed by canonical composition for the character class part, and java.text.Normalizer.Form.NFD NFD, canonical decomposition) for the rest), and then a pure group is constructed to match canonical equivalences of the characters.:::plen->pattern->length->pbuf->new->StringBuilder->last->lastStart->cc->for->i->if->normalizeSlice->return->pbuf->toString
Pattern#normalizeSlice(String, int, int, StringBuilder)::: pattern normalize slice:::len->src->length->off0->while->ASCII->src->charAt->isAscii->if->dst->append->return->if->else->dst->append->while->ch0->src->codePointAt->if->indexOf->dst->append->continue->j->Character->charCount->ch1->while->src->codePointAt->if->Grapheme->isBoundary->break->Character->charCount->seq->src->substring->nfd->Normalizer->normalize->if->nfd->length->nfd->codePointAt->nfd->Character->charCount->codePointAt->if->Character->getType->altns->new->LinkedHashSet<>->altns->add->produceEquivalentAlternation->dst->append->altns->dst->append->append->forEach->dst->dst->length->dst->length->delete->dst->append->continue->nfc->Normalizer->normalize->if->seq->equals->nfd->equals->dst->append->else->if->seq->equals->dst->append->else->dst->append
Pattern#normalizeClazz(String, int, int, StringBuilder)::: pattern normalize clazz:::dst->Normalizer->src->substring->normalize->append
Pattern#produceEquivalentAlternation(String, Set):::Given a specific sequence composed of a regular character and combining marks that follow it, produce the alternation that will match all canonical equivalences of that sequence.:::len->countChars->if->src->length->dst->add->return->base->src->substring->combiningMarks->src->substring->perms->producePermutations->for->x
Pattern#producePermutations(String):::Returns an array of strings that have all the possible permutations of the characters in the input string:::if->input->length->countChars->return->new->StringArr->if->input->length->countChars->c0->Character->codePointAt->c1->Character->Character->charCount->codePointAt->if->getClass->getClass->return->new->StringArr->result->new->StringArr->sb->new->StringBuilder->sb->appendCodePoint->sb->appendCodePoint->sb->toString->return->length->nCodePoints->countCodePoints->for->x->temp->new->StringArr->combClass->new->intArr->for->x->i->index->len->for->x->offset->result->new->StringArr->System->arraycopy->return
Pattern#getClass(int)::: pattern get class:::return->getCombiningClass
Pattern#composeOneStep(String):::Attempts to compose input by combining the first character with the first combining mark following it:::len->countChars->firstTwoCharacters->input->substring->result->Normalizer->normalize->if->result->equals->return->else->remainder->input->substring->return
Pattern#RemoveQEQuoting():::Preprocess any \Q...\E sequences in `temp', meta-quoting them:::pLen->i->while->if->else->if->else->break->if->return->j->newtemp->new->intArr->System->arraycopy->inQuote->beginQuote->while->c->if->ASCII->isAscii->ASCII->isAlpha->else->if->ASCII->isDigit->if->else->if->if->else->if->if->else->else->if->continue->else->if->Arrays->copyOf
Pattern#compile():::Copies regular expression to an int array and invokes the parsing of the expression which will create the object tree.:::if->has->has->normalize->else->normalizedPattern->length->new->intArr->c->count->for->x->Character->charCount->if->has->RemoveQEQuoting->new->intArr->new->GroupHeadArr->new->ArrayList<>->if->has->newSlice->else->expr->if->if->peek->throw->error->else->throw->error->if->BnM->optimize->if->new->StartS->new->Start->else->if->else->new->StartS->new->Start->if->foreach->if
Pattern#namedGroups()::: pattern named groups:::groups->if->new->HashMap<>->return
Pattern.TreeInfo#reset()::: tree info reset:::
Pattern#has(int):::Indicates whether a particular flag is set or not.:::return
Pattern#accept(int, String):::Match next character, signal error if failed.:::testChar->if->has->parsePastWhitespace->if->throw->error
Pattern#mark(int):::Mark the end of pattern with a specific character.:::
Pattern#peek():::Peek the next character, and do not advance the cursor.:::ch->if->has->peekPastWhitespace->return
Pattern#read():::Read the next character, and advance the cursor by one.:::ch->if->has->parsePastWhitespace->return
Pattern#readEscaped():::Read the next character, and advance the cursor by one, ignoring the COMMENTS setting:::ch->return
Pattern#next():::Advance the cursor by one, and peek the next character.:::ch->if->has->peekPastWhitespace->return
Pattern#nextEscaped():::Advance the cursor by one, and peek the next character, ignoring the COMMENTS setting:::ch->return
Pattern#peekPastWhitespace(int):::If in xmode peek past whitespace and comments.:::while->ASCII->isSpace->while->ASCII->isSpace->if->peekPastLine->return
Pattern#parsePastWhitespace(int):::If in xmode parse past whitespace and comments.:::while->ASCII->isSpace->while->ASCII->isSpace->if->parsePastLine->return
Pattern#parsePastLine():::xmode parse past comment to end of line.:::ch->while->isLineSeparator->if->return
Pattern#peekPastLine():::xmode peek past comment to end of line.:::ch->while->isLineSeparator->if->return
Pattern#isLineSeparator(int):::Determines if character is a line separator in the current mode:::if->has->return->else->return
Pattern#skip():::Read the character after the next one, and advance the cursor by two.:::i->ch->return
Pattern#unread():::Unread one next character, and retreat cursor by one.:::
Pattern#error(String):::Internal method used for handling all syntax errors:::return->new->PatternSyntaxException
Pattern#findSupplementary(int, int):::Determines if there is any supplementary character or unpaired surrogate in the specified range.:::for->i->return
Pattern#isSupplementary(int):::Determines if the specified code point is a supplementary character or unpaired surrogate.:::return->Character->isSurrogate
Pattern#expr(Node):::The expression is parsed with branch nodes added for alternations:::prev->firstTail->branch->branchConn->for
Pattern#sequence(Node)::: pattern sequence:::head->tail->node->for->if->return->return
Pattern#atom()::: pattern atom:::first->prev->hasSupplementary->ch->peek->for->if->return->single->newCharProperty->else->return->newSlice
Pattern#append(int, int)::: pattern append:::if->tmp->new->intArr->System->arraycopy
Pattern#ref(int):::Parses a backref greedily, taking as many numbers as it can:::done->while->ch->peek->switch->newRefNum->if->break->read->break->break->if->has->return->has->new->CIBackRef->else->return->new->BackRef
Pattern#escape(boolean, boolean, boolean):::Parses an escape sequence to determine the actual value that needs to be matched:::ch->skip->switch->return->o->if->break->if->ref->return->if->break->if->new->Begin->return->if->break->if->has->new->Bound->return->break->if->has->CharPredicates->DIGIT->CharPredicates->ASCII_DIGIT->predicate->negate->if->newCharProperty->return->break->if->break->if->new->LastMatch->return->if->HorizWS->negate->if->newCharProperty->return->break->return->N->break->if->break->if->new->LineEnding->return->if->has->CharPredicates->WHITE_SPACE->CharPredicates->ASCII_SPACE->predicate->negate->if->newCharProperty->return->break->if->VertWS->negate->if->newCharProperty->return->if->has->CharPredicates->WORD->CharPredicates->ASCII_WORD->predicate->negate->if->newCharProperty->return->if->break->if->new->XGrapheme->return->break->if->break->if->if->has->new->UnixDollar->else->new->Dollar->return->return->if->break->if->if->peek->if->skip->if->read->new->GraphemeBound->return->break->unread->unread->has->new->Bound->return->return->c->if->has->CharPredicates->DIGIT->CharPredicates->ASCII_DIGIT->if->newCharProperty->return->return->return->break->if->HorizWS->if->newCharProperty->return->break->if->break->if->read->throw->error->name->read->groupname->if->namedGroups->containsKey->throw->error->if->if->has->namedGroups->get->has->new->CIBackRef->else->namedGroups->get->new->BackRef->return->break->return->break->return->if->has->CharPredicates->WHITE_SPACE->CharPredicates->ASCII_SPACE->if->newCharProperty->return->return->return->u->if->return->if->VertWS->if->newCharProperty->return->if->has->CharPredicates->WORD->CharPredicates->ASCII_WORD->if->newCharProperty->return->return->x->break->if->break->if->new->End->return->return->throw->error
Pattern#clazz(boolean):::Parse a character class, and return the node that matches it:::prev->curr->bits->new->BitClass->bitsP->isNeg->hasBits->ch->next->if->next->for
Pattern#bitsOrSingle(BitClass, int)::: pattern bits or single:::if->has->has->bits->add->return->return->single
Pattern#single(int)::: Returns a suitably optimized, single character predicate:::if->has->lower->upper->if->has->Character->toUpperCase->Character->toLowerCase->if->return->SingleU->else->if->ASCII->isAscii->ASCII->toLower->ASCII->toUpper->if->return->SingleI->if->isSupplementary->return->SingleS->return->Single
Pattern#range(BitClass):::Parse a single character or a character range in a character class and return its representative node.:::ch->peek->if->nextEscaped->if->comp->oneLetter->next->if->unread->else->return->family->else->isrange->unread->escape->if->return->else->next->if->if->peek->endRange->if->return->bitsOrSingle->if->next->m->peek->if->escape->else->next->if->throw->error->if->has->if->has->return->CIRangeU->return->CIRange->else->return->Range->return->bitsOrSingle->throw->error
Pattern#family(boolean, boolean):::Parses a Unicode character family and returns its representative node.:::next->name->p->if->c->if->Character->isSupplementaryCodePoint->String->valueOf->else->new->String->read->else->i->mark->while->read->mark->j->if->throw->error->if->throw->error->new->String->i->name->indexOf->if->value->name->substring->name->substring->toLowerCase->switch->CharPredicates->forUnicodeScript->break->CharPredicates->forUnicodeBlock->break->CharPredicates->forProperty->break->break->if->throw->error->else->if->name->startsWith->CharPredicates->name->substring->forUnicodeBlock->else->if->name->startsWith->name->substring->CharPredicates->forUnicodeProperty->if->CharPredicates->forProperty->if->CharPredicates->forUnicodeScript->else->if->has->CharPredicates->forPOSIXName->if->CharPredicates->forProperty->if->throw->error->if->p->negate->return
Pattern#newCharProperty(CharPredicate)::: pattern new char property:::if->return->if->return->new->BmpCharProperty->else->return->new->CharProperty
Pattern#groupname(int):::Parses and returns the name of a "named capturing group", the trailing ">" is consumed after parsing.:::sb->new->StringBuilder->if->ASCII->isAlpha->throw->error->do->sb->append->while->ASCII->read->isAlnum->if->throw->error->return->sb->toString
Pattern#group0():::Parses a group and returns the head node of a set of nodes that process the group:::capturingGroup->head->tail->save->saveTCNCount->topClosureNodes->size->ch->next->if->skip->switch->createGroup->expr->break->createGroup->expr->if->new->Pos->else->new->Neg->break->createGroup->expr->new->Ques->break->read->if->name->groupname->if->namedGroups->containsKey->throw->error->createGroup->namedGroups->put->expr->break->start->createGroup->expr->info->new->TreeInfo->head->study->if->throw->error->hasSupplementary->findSupplementary->if->new->BehindS->new->Behind->else->new->NotBehindS->new->NotBehind->if->topClosureNodes->size->topClosureNodes->topClosureNodes->size->subList->clear->break->throw->error->unread->addFlag->read->if->return->if->throw->error->createGroup->expr->break->else->createGroup->expr->accept->node->closure->if->return->if->return->if->topClosureNodes->size->topClosureNodes->topClosureNodes->size->subList->clear->if->ques->if->return->new->BranchConn->if->new->Branch->else->new->Branch->return->else->if->curly->if->return->info->new->TreeInfo->if->head->study->temp->new->GroupCurly->return->else->temp->loop->if->new->Loop->if->topClosureNodes->add->else->new->LazyLoop->prolog->new->Prolog->return->throw->error
Pattern#createGroup(boolean):::Create group head and tail nodes using double return:::localIndex->groupIndex->if->head->new->GroupHead->new->GroupTail->if->return
Pattern#addFlag()::: pattern add flag:::ch->peek->for
Pattern#subFlag()::: pattern sub flag:::ch->peek->for
Pattern#curly(Node, int)::: pattern curly:::ch->next->if->next->return->new->Curly->else->if->next->return->new->Curly->if->return->new->BmpCharPropertyGreedy->else->if->return->new->CharPropertyGreedy->return->new->Curly
Pattern#closure(Node):::Processes repetition:::atom->ch->peek->switch->next->if->next->return->new->Ques->else->if->next->return->new->Ques->return->new->Ques->return->curly->return->curly->if->ASCII->isDigit->skip->cmin->do->while->ASCII->read->isDigit->cmax->if->read->if->while->ASCII->isDigit->read->if->throw->error->if->throw->error->curly->peek->if->next->new->Curly->else->if->next->new->Curly->else->new->Curly->return->else->throw->error->return
Pattern#c()::: Utility method for parsing control escape sequences.:::if->return->read->throw->error
Pattern#o()::: Utility method for parsing octal escape sequences.:::n->read->if->m->read->if->o->read->if->return->unread->return->unread->return->throw->error
Pattern#x()::: Utility method for parsing hexadecimal escape sequences.:::n->read->if->ASCII->isHexDigit->m->read->if->ASCII->isHexDigit->return->ASCII->toDigit->ASCII->toDigit->else->if->ASCII->peek->isHexDigit->ch->while->ASCII->read->isHexDigit->ASCII->toDigit->if->throw->error->if->throw->error->return->throw->error
Pattern#cursor()::: Utility method for parsing unicode escape sequences.:::return
Pattern#setcursor(int)::: pattern setcursor:::
Pattern#uxxxx()::: pattern uxxxx:::n->for->i->return
Pattern#u()::: pattern u:::n->uxxxx->if->Character->isHighSurrogate->cur->cursor->if->read->read->n2->uxxxx->if->Character->isLowSurrogate->return->Character->toCodePoint->setcursor->return
Pattern#N()::: pattern  n:::if->read->i->while->read->if->throw->error->name->new->String->try->return->Character->codePointOf->catch->throw->error->finally->throw->error
Pattern#countChars(CharSequence, int, int)::: pattern count chars:::if->Character->seq->charAt->isHighSurrogate->return->length->seq->length->x->if->for->i->return->if->return->len->for->i->return
Pattern#countCodePoints(CharSequence)::: pattern count code points:::length->seq->length->n->for->i->return
Pattern.BitClass#add(int, int)::: bit class add:::if->if->ASCII->isAscii->ASCII->toUpper->ASCII->toLower->else->if->Character->toLowerCase->Character->toUpperCase->return
Pattern#newSlice(int[], int, boolean)::: Utility method for creating a string slice matcher.:::tmp->new->intArr->if->has->if->has->for->i->return->new->SliceUS->new->SliceU->for->i->return->new->SliceIS->new->SliceI->for->i->return->new->SliceS->new->Slice
Pattern.Node#match(Matcher, int, CharSequence):::This method implements the classic accept node.:::return
Pattern.Node#study(TreeInfo):::This method is good for all zero length assertions.:::if->return->next->study->else->return
Pattern.LastNode#match(Matcher, int, CharSequence):::This method implements the classic accept node with the addition of a check to see if the match occurred using all of the input.:::if->return->return
Pattern.Start#match(Matcher, int, CharSequence)::: start match:::if->return->guard->for->return
Pattern.Start#study(TreeInfo)::: start study:::next->study->return
Pattern.StartS#match(Matcher, int, CharSequence)::: start s match:::if->return->guard->while->if->next->match->return->if->break->if->Character->seq->charAt->isHighSurrogate->if->seq->length->Character->seq->charAt->isLowSurrogate->return
Pattern.Begin#match(Matcher, int, CharSequence)::: begin match:::fromIndex->if->next->match->return->else->return
Pattern.End#match(Matcher, int, CharSequence)::: end match:::endIndex->matcher->getTextLength->if->return->next->match->return
Pattern.Caret#match(Matcher, int, CharSequence)::: caret match:::startIndex->endIndex->if->matcher->getTextLength->if->return->if->ch->seq->charAt->if->return->if->seq->charAt->return->return->next->match
Pattern.UnixCaret#match(Matcher, int, CharSequence)::: unix caret match:::startIndex->endIndex->if->matcher->getTextLength->if->return->if->ch->seq->charAt->if->return->return->next->match
Pattern.LastMatch#match(Matcher, int, CharSequence)::: last match match:::if->return->return->next->match
Pattern.Dollar#match(Matcher, int, CharSequence)::: dollar match:::endIndex->matcher->getTextLength->if->if->return->if->ch->seq->charAt->if->return->seq->charAt->if->return->if->ch->seq->charAt->if->if->seq->charAt->return->if->return->next->match->else->if->if->return->next->match->else->return->return->next->match
Pattern.Dollar#study(TreeInfo)::: dollar study:::next->study->return
Pattern.UnixDollar#match(Matcher, int, CharSequence)::: unix dollar match:::endIndex->matcher->getTextLength->if->ch->seq->charAt->if->if->return->if->return->next->match->else->return->return->next->match
Pattern.UnixDollar#study(TreeInfo)::: unix dollar study:::next->study->return
Pattern.LineEnding#match(Matcher, int, CharSequence)::: line ending match:::if->ch->seq->charAt->if->return->next->match->if->if->if->seq->charAt->next->match->return->else->return->next->match->else->return
Pattern.LineEnding#study(TreeInfo)::: line ending study:::return->next->study
Pattern.CharProperty#match(Matcher, int, CharSequence)::: char property match:::if->ch->Character->codePointAt->return->predicate->is->next->Character->charCount->match->else->return
Pattern.CharProperty#study(TreeInfo)::: char property study:::return->next->study
Pattern.BmpCharProperty#match(Matcher, int, CharSequence)::: bmp char property match:::if->return->predicate->seq->charAt->is->next->match->else->return
Pattern.NFCCharProperty#match(Matcher, int, CharSequence)::: char property match:::if->ch0->Character->codePointAt->n->Character->charCount->j->while->ch1->Character->codePointAt->if->Grapheme->isBoundary->break->Character->charCount->if->if->predicate->is->return->next->match->else->while->nfc->Normalizer->seq->toString->substring->normalize->if->nfc->nfc->length->codePointCount->if->predicate->nfc->codePointAt->is->next->match->return->Character->codePointBefore->Character->charCount->if->return->return
Pattern.NFCCharProperty#study(TreeInfo)::: char property study:::return->next->study
Pattern.XGrapheme#match(Matcher, int, CharSequence)::: grapheme match:::if->ch0->Character->codePointAt->Character->charCount->while->ch1->Character->codePointAt->if->Grapheme->isBoundary->break->Character->charCount->return->next->match->return
Pattern.XGrapheme#study(TreeInfo)::: grapheme study:::return->next->study
Pattern.GraphemeBound#match(Matcher, int, CharSequence)::: grapheme bound match:::startIndex->endIndex->if->matcher->getTextLength->if->return->next->match->if->if->Character->seq->charAt->seq->charAt->isSurrogatePair->Grapheme->Character->codePointBefore->Character->codePointAt->isBoundary->return->else->return->next->match
Pattern.SliceNode#study(TreeInfo)::: slice node study:::return->next->study
Pattern.Slice#match(Matcher, int, CharSequence)::: slice match:::buf->len->for->j->return->next->match
Pattern.SliceI#match(Matcher, int, CharSequence)::: slice i match:::buf->len->for->j->return->next->match
Pattern.SliceU#match(Matcher, int, CharSequence)::: slice u match:::buf->len->for->j->return->next->match
Pattern.SliceS#match(Matcher, int, CharSequence)::: slice s match:::buf->x->for->j->return->next->match
Pattern.SliceIS#toLower(int)::: slice s to lower:::return->ASCII->toLower
Pattern.SliceIS#match(Matcher, int, CharSequence)::: slice s match:::buf->x->for->j->return->next->match
Pattern.SliceUS#toLower(int)::: slice s to lower:::return->Character->Character->toUpperCase->toLowerCase
Pattern.Ques#match(Matcher, int, CharSequence)::: ques match:::switch->return->atom->match->next->match->next->match->return->next->match->atom->match->next->match->if->atom->match->return->next->match->return->atom->match->next->match
Pattern.Ques#study(TreeInfo)::: ques study:::if->minL->atom->study->return->next->study->else->atom->study->return->next->study
Pattern.CharPropertyGreedy#match(Matcher, int, CharSequence)::: char property greedy match:::n->to->while->ch->Character->codePointAt->if->predicate->is->break->Character->charCount->if->while->if->next->match->return->if->return->ch->Character->codePointBefore->Character->charCount->return
Pattern.CharPropertyGreedy#study(TreeInfo)::: char property greedy study:::if->return->next->study
Pattern.BmpCharPropertyGreedy#match(Matcher, int, CharSequence)::: bmp char property greedy match:::n->to->while->predicate->seq->charAt->is->if->while->if->next->match->return->return
Pattern.Curly#match(Matcher, int, CharSequence)::: curly match:::j->for->if->return->match0->else->if->return->match1->else->return->match2
Pattern.Curly#match0(Matcher, int, int, CharSequence)::: curly match0:::if->return->next->match->backLimit->while->atom->match->k->if->break->while->if->atom->match->break->if->if->match0->return->break->while->if->next->match->return->return->return->next->match
Pattern.Curly#match1(Matcher, int, int, CharSequence)::: curly match1:::for
Pattern.Curly#match2(Matcher, int, int, CharSequence)::: curly match2:::for->return->next->match
Pattern.Curly#study(TreeInfo)::: curly study:::minL->maxL->maxV->detm->info->reset->atom->study->temp->if->if->if->else->if->else->return->next->study
Pattern.GroupCurly#match(Matcher, int, CharSequence)::: group curly match:::groups->locals->save0->save1->save2->if->ret->for->j->if->if->match0->else->if->match1->else->match2->if->if->return
Pattern.GroupCurly#match0(Matcher, int, int, CharSequence)::: group curly match0:::min->groups->save0->save1->if->for->if->return->next->match
Pattern.GroupCurly#match1(Matcher, int, int, CharSequence)::: group curly match1:::for
Pattern.GroupCurly#match2(Matcher, int, int, CharSequence)::: group curly match2:::for->return->next->match
Pattern.GroupCurly#study(TreeInfo)::: group curly study:::minL->maxL->maxV->detm->info->reset->atom->study->temp->if->if->if->else->if->else->return->next->study
Pattern.BranchConn#match(Matcher, int, CharSequence)::: branch conn match:::return->next->match
Pattern.BranchConn#study(TreeInfo)::: branch conn study:::return
Pattern.Branch#add(Node)::: branch add:::if->tmp->new->NodeArr->System->arraycopy
Pattern.Branch#match(Matcher, int, CharSequence)::: branch match:::for->n->return
Pattern.Branch#study(TreeInfo)::: branch study:::minL->maxL->maxV->minL2->maxL2->for->n->info->reset->study->return
Pattern.GroupHead#match(Matcher, int, CharSequence)::: group head match:::save->ret->next->match->return
Pattern.GroupHead#matchRef(Matcher, int, CharSequence)::: group head match ref:::save->ret->next->match->return
Pattern.GroupRef#match(Matcher, int, CharSequence)::: group ref match:::return->head->matchRef->next->match
Pattern.GroupRef#study(TreeInfo)::: group ref study:::return->next->study
Pattern.GroupTail#match(Matcher, int, CharSequence)::: group tail match:::tmp->if->groupStart->groupEnd->if->next->match->return->return->else->return
Pattern.Prolog#match(Matcher, int, CharSequence)::: prolog match:::return->loop->matchInit
Pattern.Prolog#study(TreeInfo)::: prolog study:::return->loop->study
Pattern.Loop#match(Matcher, int, CharSequence)::: loop match:::if->count->if->b->body->match->if->return->if->if->contains->return->next->match->b->body->match->if->return->if->add->return->next->match
Pattern.Loop#matchInit(Matcher, int, CharSequence)::: loop match init:::save->ret->if->new->IntHashSet->if->body->match->else->if->body->match->if->next->match->else->next->match->return
Pattern.Loop#study(TreeInfo)::: loop study:::return
Pattern.LazyLoop#match(Matcher, int, CharSequence)::: lazy loop match:::if->count->if->result->body->match->if->return->if->next->match->return->if->result->body->match->if->return->return->return->next->match
Pattern.LazyLoop#matchInit(Matcher, int, CharSequence)::: lazy loop match init:::save->ret->if->body->match->else->if->next->match->else->if->body->match->return
Pattern.LazyLoop#study(TreeInfo)::: lazy loop study:::return
Pattern.BackRef#match(Matcher, int, CharSequence)::: back ref match:::j->k->groupSize->if->return->if->return->for->index->return->next->match
Pattern.BackRef#study(TreeInfo)::: back ref study:::return->next->study
Pattern.CIBackRef#match(Matcher, int, CharSequence)::: back ref match:::j->k->groupSize->if->return->if->return->x->for->index->return->next->match
Pattern.CIBackRef#study(TreeInfo)::: back ref study:::return->next->study
Pattern.First#match(Matcher, int, CharSequence)::: first match:::if->return->atom->match->next->match->for
Pattern.First#study(TreeInfo)::: first study:::atom->study->return->next->study
Pattern.Conditional#match(Matcher, int, CharSequence)::: conditional match:::if->cond->match->return->yes->match->else->return->not->match
Pattern.Conditional#study(TreeInfo)::: conditional study:::minL->maxL->maxV->info->reset->yes->study->minL2->maxL2->maxV2->info->reset->not->study->Math->min->Math->max->return->next->study
Pattern.Pos#match(Matcher, int, CharSequence)::: pos match:::savedTo->conditionMatched->if->matcher->getTextLength->try->cond->match->catch->finally->return->next->match
Pattern.Neg#match(Matcher, int, CharSequence)::: neg match:::savedTo->conditionMatched->if->matcher->getTextLength->try->if->cond->match->else->cond->match->catch->finally->return->next->match
Pattern.Behind#match(Matcher, int, CharSequence)::: behind match:::savedFrom->conditionMatched->startIndex->from->Math->max->savedLBT->if->for->j->return->next->match
Pattern.BehindS#match(Matcher, int, CharSequence)::: behind s match:::rmaxChars->countChars->rminChars->countChars->savedFrom->startIndex->conditionMatched->from->Math->max->savedLBT->if->for->j->countChars->return->next->match
Pattern.NotBehind#match(Matcher, int, CharSequence)::: not behind match:::savedLBT->savedFrom->conditionMatched->startIndex->from->Math->max->if->for->j->return->next->match
Pattern.NotBehindS#match(Matcher, int, CharSequence)::: not behind s match:::rmaxChars->countChars->rminChars->countChars->savedFrom->savedLBT->conditionMatched->startIndex->from->Math->max->if->for->j->countChars->return->next->match
Pattern.Bound#isWord(int)::: bound is word:::return->CharPredicates->WORD->is->Character->isLetterOrDigit
Pattern.Bound#check(Matcher, int, CharSequence)::: bound check:::ch->left->startIndex->endIndex->if->matcher->getTextLength->if->Character->codePointBefore->isWord->Character->getType->hasBaseCharacter->right->if->Character->codePointAt->isWord->Character->getType->hasBaseCharacter->else->return
Pattern.Bound#match(Matcher, int, CharSequence)::: bound match:::return->check->next->match
Pattern#hasBaseCharacter(Matcher, int, CharSequence):::Non spacing marks only count as word characters in bounds calculations if they have a base character.:::start->for->x->return
Pattern.BnM#optimize(Node):::Pre calculates arrays needed to generate the bad character shift and the good suffix shift:::if->return->src->patternLength->if->return->i->j->k->lastOcc->new->intArr->optoSft->new->intArr->for->for->if->return->new->BnMS->return->new->BnM
Pattern.BnM#match(Matcher, int, CharSequence)::: bn m match:::src->patternLength->last->while->for->j->ret->next->match->if->return->return
Pattern.BnM#study(TreeInfo)::: bn m study:::return->next->study
Pattern.BnMS#match(Matcher, int, CharSequence)::: bn s match:::src->patternLength->last->while->ch->for->j->countChars->x->Character->charCount->ret->next->match->if->return->countChars->return
Pattern.CharPredicate#is(int)::: char predicate is:::
Pattern.CharPredicate#and(CharPredicate)::: char predicate and:::return->is->p->is
Pattern.CharPredicate#union(CharPredicate)::: char predicate union:::return->is->p->is
Pattern.CharPredicate#union(CharPredicate, CharPredicate)::: char predicate union:::return->is->p1->is->p2->is
Pattern.CharPredicate#negate()::: char predicate negate:::return->is
Pattern.BmpCharPredicate#and(CharPredicate)::: bmp char predicate and:::if->return->is->p->is->return->is->p->is
Pattern.BmpCharPredicate#union(CharPredicate)::: bmp char predicate union:::if->return->is->p->is->return->is->p->is
Pattern.BmpCharPredicate#union(CharPredicate...)::: bmp char predicate union:::cp->foreach->if->p->is->return->return->foreach->if->return->return
Pattern#VertWS():::matches a Perl vertical whitespace:::return
Pattern#HorizWS():::matches a Perl horizontal whitespace:::return
Pattern#ALL()::: for the Unicode category ALL and the dot metacharacter when  in dotall mode.:::return
Pattern#DOT():::for the dot metacharacter when dotall is not enabled.:::return
Pattern#UNIXDOT()::: the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.:::return
Pattern#SingleS(int):::Indicate that matches a Supplementary Unicode character:::return
Pattern#Single(int):::A bmp/optimized predicate of single:::return
Pattern#SingleI(int, int):::Case insensitive matches a given BMP character:::return
Pattern#SingleU(int):::Unicode case insensitive matches a given Unicode character:::return->Character->Character->toUpperCase->toLowerCase
Pattern#inRange(int, int, int)::: pattern in range:::return
Pattern#Range(int, int):::Charactrs within a explicit value range:::if->return->inRange->return->inRange
Pattern#CIRange(int, int):::Charactrs within a explicit value range in a case insensitive manner.:::return->inRange->ASCII->isAscii->ASCII->toUpper->inRange->ASCII->toLower->inRange
Pattern#CIRangeU(int, int)::: pattern  range u:::return->if->inRange->return->up->Character->toUpperCase->return->inRange->Character->toLowerCase->inRange
Pattern#asPredicate():::Creates a predicate that tests if this pattern is found in a given input string.:::return->matcher->find
Pattern#asMatchPredicate():::Creates a predicate that tests if this pattern matches a given input string.:::return->matcher->matches
Pattern#splitAsStream(CharSequence):::Creates a stream from the given input sequence around matches of this pattern:::return->StreamSupport->Spliterators->new->MatcherIterator->spliteratorUnknownSize->stream
PatternSyntaxException#getIndex():::Retrieves the error index.:::return
PatternSyntaxException#getDescription():::Retrieves the description of the error.:::return
PatternSyntaxException#getPattern():::Retrieves the erroneous regular-expression pattern.:::return
PatternSyntaxException#getMessage():::Returns a multi-line string containing the description of the syntax error and its index, the erroneous regular-expression pattern, and a visual indication of the error index within the pattern.:::sb->new->StringBuilder->sb->append->if->sb->append->sb->append->sb->System->lineSeparator->append->sb->append->if->pattern->length->sb->System->lineSeparator->append->for->i->sb->append->return->sb->toString
PrintPattern#print(Pattern.Node, String, int)::: print pattern print:::if->ids->containsKey->ids->ids->size->put->ids->get->print->if->ids->containsKey->ids->get->print->print
PrintPattern#print(String, int)::: print pattern print:::print
PrintPattern#print(String, Object...)::: print pattern print:::printf
PrintPattern#toStringCPS(int[])::: print pattern to string s:::sb->new->StringBuilder->foreach->sb->toStringCP->append->return->sb->toString
PrintPattern#toStringCP(int)::: print pattern to string p:::return->isPrint->Integer->toString
PrintPattern#toStringRange(int, int)::: print pattern to string range:::if->if->return->else->if->return->return->return
PrintPattern#toStringCtype(int)::: print pattern to string ctype:::switch->return->return->return->return->return->return->return->return->return->return->return->return->return->return->return
PrintPattern#toString(Pattern.Node)::: print pattern to string:::name->node->getClass->getName->return->name->name->lastIndexOf->substring
PrintPattern#walk(Pattern.Node, int)::: print pattern walk:::while->name->toString->str->if->print->loop->toString->toStringRange->print->walk->print->else->if->return->else->if->c->toStringRange->print->walk->print->else->if->gc->toStringRange->print->walk->print->else->if->head->tail->print->walk->print->else->if->return->else->if->print->walk->print->else->if->b->print->i->while->if->walk->else->print->if->break->print->print->else->if->return->else->if->pmap->get->if->toString->else->print->else->if->toStringCPS->print->else->if->gcp->pstr->pmap->get->if->toString->else->print->else->if->print->else->if->print->else->if->return->else->print
PrintPattern#main(String[])::: print pattern main:::p->Pattern->compile->println->walk
