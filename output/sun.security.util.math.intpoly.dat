IntegerPolynomial#reduce(long[]):::Reduce an IntegerPolynomial representation (a) and store the result in a:::
IntegerPolynomial#multByInt(long[], long):::Multiply an IntegerPolynomial representation (a) with a long (b) and store the result in an IntegerPolynomial representation in a:::for->i->reduce
IntegerPolynomial#mult(long[], long[], long[]):::Multiply two IntegerPolynomial representations (a and b) and store the result in an IntegerPolynomial representation (r):::
IntegerPolynomial#square(long[], long[]):::Multiply an IntegerPolynomial representation (a) with itself and store the result in an IntegerPolynomialRepresentation (r):::
IntegerPolynomial#encode(ByteBuffer, int, byte, long[]):::This version of encode takes a ByteBuffer that is properly ordered, and may extract larger values (e.g:::numHighBits->Integer->numberOfLeadingZeros->numBits->requiredLimbs->if->temp->new->longArr->encodeSmall->System->arraycopy->else->encodeSmall
IntegerPolynomial#carryOut(long[], int):::Carry out of the specified position and return the carry value.:::carry->carryValue->return
IntegerPolynomial#finalCarryReduceLast(long[]):::Carry out of the last limb and reduce back in:::
IntegerPolynomial#finalReduce(long[]):::Convert reduced limbs into a number between 0 and MODULUS-1:::for->pass->smallerNonNegative->smaller->new->longArr->for->i->conditionalSwap
IntegerPolynomial#decode(long[], byte[], int, int):::Decode the value in v and store it in dst:::nextLimbIndex->curLimbValue->bitPos->for->i
IntegerPolynomial#addLimbs(long[], long[], long[]):::Add two IntegerPolynomial representations (a and b) and store the result in an IntegerPolynomialRepresentation (dst):::for->i
IntegerPolynomial#conditionalAssign(int, long[], long[]):::Branch-free conditional assignment of b to a:::maskValue->for->i
IntegerPolynomial#conditionalSwap(int, long[], long[]):::Branch-free conditional swap of a and b:::maskValue->for->i
IntegerPolynomial#limbsToByteArray(long[], byte[]):::Stores the reduced, little-endian value of limbs in result.:::reducedLimbs->limbs->clone->finalReduce->decode
IntegerPolynomial#addLimbsModPowerTwo(long[], long[], byte[]):::Add the reduced number corresponding to limbs and other, and store the low-order bytes of the sum in result:::reducedOther->other->clone->reducedLimbs->limbs->clone->finalReduce->finalReduce->addLimbs->carry->for->i->decode
