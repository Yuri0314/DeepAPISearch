jdk.nashorn.internal.codegen.ApplySpecialization#getLogger()->DebugLogger::: apply specialization get logger
jdk.nashorn.internal.codegen.ApplySpecialization#initLogger(Context)->DebugLogger::: apply specialization init logger
jdk.nashorn.internal.codegen.ApplySpecialization#enterCallNode(CallNode)->boolean::: apply specialization enter call node
jdk.nashorn.internal.codegen.ApplySpecialization#leaveCallNode(CallNode)->Node::: apply specialization leave call node
jdk.nashorn.internal.codegen.ApplySpecialization#enterFunctionNode(FunctionNode)->boolean::: apply specialization enter function node
jdk.nashorn.internal.codegen.ApplySpecialization#leaveFunctionNode(FunctionNode)->Node:::Try to do the apply to call transformation
jdk.nashorn.internal.codegen.AssignSymbols#getLogger()->DebugLogger::: assign symbols get logger
jdk.nashorn.internal.codegen.AssignSymbols#initLogger(Context)->DebugLogger::: assign symbols init logger
jdk.nashorn.internal.codegen.AssignSymbols#enterBlock(Block)->boolean::: assign symbols enter block
jdk.nashorn.internal.codegen.AssignSymbols#enterCatchNode(CatchNode)->boolean::: assign symbols enter catch node
jdk.nashorn.internal.codegen.AssignSymbols#enterFunctionNode(FunctionNode)->boolean::: assign symbols enter function node
jdk.nashorn.internal.codegen.AssignSymbols#enterVarNode(VarNode)->boolean::: assign symbols enter var node
jdk.nashorn.internal.codegen.AssignSymbols#leaveVarNode(VarNode)->Node::: assign symbols leave var node
jdk.nashorn.internal.codegen.AssignSymbols#leaveBinaryNode(BinaryNode)->Node::: assign symbols leave binary node
jdk.nashorn.internal.codegen.AssignSymbols#leaveUnaryNode(UnaryNode)->Node::: assign symbols leave unary node
jdk.nashorn.internal.codegen.AssignSymbols#leaveForNode(ForNode)->Node::: assign symbols leave for node
jdk.nashorn.internal.codegen.AssignSymbols#leaveFunctionNode(FunctionNode)->Node::: assign symbols leave function node
jdk.nashorn.internal.codegen.AssignSymbols#leaveIdentNode(IdentNode)->Node::: assign symbols leave ident node
jdk.nashorn.internal.codegen.AssignSymbols#leaveSwitchNode(SwitchNode)->Node::: assign symbols leave switch node
jdk.nashorn.internal.codegen.AssignSymbols#leaveTryNode(TryNode)->Node::: assign symbols leave try node
jdk.nashorn.internal.codegen.BranchOptimizer#execute(Expression, Label, boolean)->void::: branch optimizer execute
jdk.nashorn.internal.codegen.CacheAst#enterFunctionNode(FunctionNode)->boolean::: cache ast enter function node
jdk.nashorn.internal.codegen.CacheAst#leaveFunctionNode(FunctionNode)->Node::: cache ast leave function node
jdk.nashorn.internal.codegen.ClassEmitter#getMethodNames()->Set:::Return the method names encountered.
jdk.nashorn.internal.codegen.ClassEmitter#getContext()->Context::: class emitter get context
jdk.nashorn.internal.codegen.ClassEmitter#getUnitClassName()->String::: class emitter get unit class name
jdk.nashorn.internal.codegen.ClassEmitter#getMethodCount()->int:::Get the method count, including init and clinit methods.
jdk.nashorn.internal.codegen.ClassEmitter#getClinitCount()->int:::Get the clinit count.
jdk.nashorn.internal.codegen.ClassEmitter#getInitCount()->int:::Get the init count.
jdk.nashorn.internal.codegen.ClassEmitter#getFieldCount()->int:::Get the field count.
jdk.nashorn.internal.codegen.ClassEmitter#getArrayMethodName(Class)->String:::Generate the name of a get array from constant pool method.
jdk.nashorn.internal.codegen.ClassEmitter#needGetConstantMethod(Class)->void:::Ensure a get constant method is issued for the class.
jdk.nashorn.internal.codegen.ClassEmitter#begin()->void:::Call at beginning of class emission.
jdk.nashorn.internal.codegen.ClassEmitter#end()->void:::Call at end of class emission.
jdk.nashorn.internal.codegen.ClassEmitter#disassemble(byte[])->String:::Disassemble an array of byte code.
jdk.nashorn.internal.codegen.ClassEmitter#beginMethod(MethodEmitter)->void:::Call back from MethodEmitter for method start.
jdk.nashorn.internal.codegen.ClassEmitter#endMethod(MethodEmitter)->void:::Call back from MethodEmitter for method end.
jdk.nashorn.internal.codegen.ClassEmitter#method(String, Class, Class...)->MethodEmitter:::Add a new method to the class - defaults to public method.
jdk.nashorn.internal.codegen.ClassEmitter#method(EnumSet, String, Class, Class...)->MethodEmitter:::Add a new method to the class - defaults to public method.
jdk.nashorn.internal.codegen.ClassEmitter#method(String, String)->MethodEmitter:::Add a new method to the class - defaults to public method.
jdk.nashorn.internal.codegen.ClassEmitter#method(EnumSet, String, String)->MethodEmitter:::Add a new method to the class - defaults to public method.
jdk.nashorn.internal.codegen.ClassEmitter#method(FunctionNode)->MethodEmitter:::Add a new method to the class, representing a function node.
jdk.nashorn.internal.codegen.ClassEmitter#restOfMethod(FunctionNode)->MethodEmitter:::Add a new method to the class, representing a rest-of version of the function node.
jdk.nashorn.internal.codegen.ClassEmitter#clinit()->MethodEmitter:::Start generating the <clinit> method in the class.
jdk.nashorn.internal.codegen.ClassEmitter#init()->MethodEmitter:::Start generating an <init>()V method in the class.
jdk.nashorn.internal.codegen.ClassEmitter#init(Class...)->MethodEmitter:::Start generating an <init>()V method in the class.
jdk.nashorn.internal.codegen.ClassEmitter#init(EnumSet, Class...)->MethodEmitter:::Start generating an <init>(...)V method in the class.
jdk.nashorn.internal.codegen.ClassEmitter#field(EnumSet, String, Class, Object)->void:::Add a field to the class, initialized to a value.
jdk.nashorn.internal.codegen.ClassEmitter#field(EnumSet, String, Class)->void:::Add a field to the class.
jdk.nashorn.internal.codegen.ClassEmitter#field(String, Class)->void:::Add a field to the class - defaults to public.
jdk.nashorn.internal.codegen.ClassEmitter#toByteArray()->byte[]:::Return a bytecode array from this ClassEmitter
jdk.nashorn.internal.codegen.CodeGenerator#getLogger()->DebugLogger::: code generator get logger
jdk.nashorn.internal.codegen.CodeGenerator#initLogger(Context)->DebugLogger::: code generator init logger
jdk.nashorn.internal.codegen.CodeGenerator#getCallSiteFlags()->int:::Gets the call site flags, adding the strict flag if the current function being generated is in strict mode
jdk.nashorn.internal.codegen.CodeGenerator#isEvalCode()->boolean:::Are we generating code for 'eval' code?
jdk.nashorn.internal.codegen.CodeGenerator#useDualFields()->boolean:::Are we using dual primitive/object field representation?
jdk.nashorn.internal.codegen.CodeGenerator#loadExpressionAsBoolean(Expression)->MethodEmitter::: code generator load expression as boolean
jdk.nashorn.internal.codegen.CodeGenerator#loadBinaryOperands(BinaryNode)->MethodEmitter::: code generator load binary operands
jdk.nashorn.internal.codegen.CodeGenerator#loadComparisonOperands(BinaryNode)->MethodEmitter:::Similar to #loadBinaryOperands(BinaryNode) but used specifically for loading operands of relational and equality comparison operators where at least one argument is non-object
jdk.nashorn.internal.codegen.CodeGenerator#loadExpressionAsType(Expression, Type)->MethodEmitter::: code generator load expression as type
jdk.nashorn.internal.codegen.CodeGenerator#enterBlock(Block)->boolean::: code generator enter block
jdk.nashorn.internal.codegen.CodeGenerator#useOptimisticTypes()->boolean::: code generator use optimistic types
jdk.nashorn.internal.codegen.CodeGenerator#leaveBlock(Block)->Node::: code generator leave block
jdk.nashorn.internal.codegen.CodeGenerator#enterBreakNode(BreakNode)->boolean::: code generator enter break node
jdk.nashorn.internal.codegen.CodeGenerator#enterJumpToInlinedFinally(JumpToInlinedFinally)->boolean::: code generator enter jump to inlined finally
jdk.nashorn.internal.codegen.CodeGenerator#nonOptimisticFlags(int)->int:::Returns the flags with optimistic flag and program point removed.
jdk.nashorn.internal.codegen.CodeGenerator#enterContinueNode(ContinueNode)->boolean::: code generator enter continue node
jdk.nashorn.internal.codegen.CodeGenerator#enterEmptyNode(EmptyNode)->boolean::: code generator enter empty node
jdk.nashorn.internal.codegen.CodeGenerator#enterExpressionStatement(ExpressionStatement)->boolean::: code generator enter expression statement
jdk.nashorn.internal.codegen.CodeGenerator#enterBlockStatement(BlockStatement)->boolean::: code generator enter block statement
jdk.nashorn.internal.codegen.CodeGenerator#enterForNode(ForNode)->boolean::: code generator enter for node
jdk.nashorn.internal.codegen.CodeGenerator#enterFunctionNode(FunctionNode)->boolean::: code generator enter function node
jdk.nashorn.internal.codegen.CodeGenerator#leaveFunctionNode(FunctionNode)->Node::: code generator leave function node
jdk.nashorn.internal.codegen.CodeGenerator#enterIfNode(IfNode)->boolean::: code generator enter if node
jdk.nashorn.internal.codegen.CodeGenerator#getLastLineNumber()->int::: code generator get last line number
jdk.nashorn.internal.codegen.CodeGenerator#loadConstant(String)->void:::Load a constant from the constant array
jdk.nashorn.internal.codegen.CodeGenerator#loadConstant(Object)->void:::Load a constant from the constant array
jdk.nashorn.internal.codegen.CodeGenerator#enterReturnNode(ReturnNode)->boolean::: code generator enter return node
jdk.nashorn.internal.codegen.CodeGenerator#enterSplitReturn(SplitReturn)->boolean::: code generator enter split return
jdk.nashorn.internal.codegen.CodeGenerator#enterSetSplitState(SetSplitState)->boolean::: code generator enter set split state
jdk.nashorn.internal.codegen.CodeGenerator#enterSwitchNode(SwitchNode)->boolean::: code generator enter switch node
jdk.nashorn.internal.codegen.CodeGenerator#enterThrowNode(ThrowNode)->boolean::: code generator enter throw node
jdk.nashorn.internal.codegen.CodeGenerator#enterTryNode(TryNode)->boolean::: code generator enter try node
jdk.nashorn.internal.codegen.CodeGenerator#enterVarNode(VarNode)->boolean::: code generator enter var node
jdk.nashorn.internal.codegen.CodeGenerator#enterWhileNode(WhileNode)->boolean::: code generator enter while node
jdk.nashorn.internal.codegen.CodeGenerator#enterWithNode(WithNode)->boolean::: code generator enter with node
jdk.nashorn.internal.codegen.CodeGenerator#loadVOID(UnaryNode, TypeBounds)->void::: code generator load d
jdk.nashorn.internal.codegen.CodeGenerator#loadDELETE(UnaryNode)->void::: code generator load e
jdk.nashorn.internal.codegen.CodeGenerator#loadADD(BinaryNode, TypeBounds)->void::: code generator load d
jdk.nashorn.internal.codegen.CodeGenerator#enterLabelNode(LabelNode)->boolean::: code generator enter label node
jdk.nashorn.internal.codegen.CodeGenerator#enterDefault(Node)->boolean::: code generator enter default
jdk.nashorn.internal.codegen.CodeGenerator#generateScopeCalls()->void:::Generate all shared scope calls generated during codegen.
jdk.nashorn.internal.codegen.CodeGenerator.SplitLiteralCreator#populateRange(MethodEmitter, Type, int, int, int)->void:::Generate code to populate a range of the literal object
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#push(T)->T::: code generator lexical context push
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#enterSplitLiteral()->void::: code generator lexical context enter split literal
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#exitSplitLiteral()->void::: code generator lexical context exit split literal
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#pop(T)->T::: code generator lexical context pop
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#inDynamicScope()->boolean::: code generator lexical context in dynamic scope
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#inSplitLiteral()->boolean::: code generator lexical context in split literal
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#pushMethodEmitter(MethodEmitter)->MethodEmitter::: code generator lexical context push method emitter
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#popMethodEmitter(MethodEmitter)->MethodEmitter::: code generator lexical context pop method emitter
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#pushUnwarrantedOptimismHandlers()->void::: code generator lexical context push unwarranted optimism handlers
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getUnwarrantedOptimismHandlers()->Map>::: code generator lexical context get unwarranted optimism handlers
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#popUnwarrantedOptimismHandlers()->Map>::: code generator lexical context pop unwarranted optimism handlers
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#pushCompileUnit(CompileUnit)->CompileUnit::: code generator lexical context push compile unit
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#popCompileUnit(CompileUnit)->CompileUnit::: code generator lexical context pop compile unit
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#hasCompileUnits()->boolean::: code generator lexical context has compile units
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getScopeCalls()->Collection::: code generator lexical context get scope calls
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getScopeCall(CompileUnit, Symbol, Type, Type, Type[], int, boolean)->SharedScopeCall:::Get a shared static method representing a dynamic scope callsite.
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getScopeGet(CompileUnit, Symbol, Type, int, boolean)->SharedScopeCall:::Get a shared static method representing a dynamic scope get access.
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#onEnterBlock(Block)->void::: code generator lexical context on enter block
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getUsedSlotCount()->int::: code generator lexical context get used slot count
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#releaseSlots()->void::: code generator lexical context release slots
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#getTypeForSlotDescriptor(char)->Type::: code generator lexical context get type for slot descriptor
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#pushDiscard(Expression)->void::: code generator lexical context push discard
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#popDiscardIfCurrent(Expression)->boolean::: code generator lexical context pop discard if current
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#isCurrentDiscard(Expression)->boolean::: code generator lexical context is current discard
jdk.nashorn.internal.codegen.CodeGeneratorLexicalContext#quickSlot(Type)->int::: code generator lexical context quick slot
jdk.nashorn.internal.codegen.CompilationPhase#begin(Compiler, FunctionNode)->FunctionNode:::Start a compilation phase
jdk.nashorn.internal.codegen.CompilationPhase#end(Compiler, FunctionNode)->FunctionNode:::End a compilation phase
jdk.nashorn.internal.codegen.CompilationPhase#isFinished()->boolean::: compilation phase is finished
jdk.nashorn.internal.codegen.CompilationPhase#getStartTime()->long::: compilation phase get start time
jdk.nashorn.internal.codegen.CompilationPhase#getEndTime()->long::: compilation phase get end time
jdk.nashorn.internal.codegen.CompilationPhase#transform(Compiler, CompilationPhases, FunctionNode)->FunctionNode::: compilation phase transform
jdk.nashorn.internal.codegen.CompilationPhase#apply(Compiler, CompilationPhases, FunctionNode)->FunctionNode:::Apply a transform to a function node, returning the transformed function node
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#toString()->String::: compilation phases to string
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#contains(CompilationPhase)->boolean::: compilation phases contains
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#iterator()->Iterator::: compilation phases iterator
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#isRestOfCompilation()->boolean::: compilation phases is rest of compilation
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#getDesc()->String::: compilation phases get desc
jdk.nashorn.internal.codegen.Compiler.CompilationPhases#toString(String)->String::: compilation phases to string
jdk.nashorn.internal.codegen.Compiler#forInitialCompilation(CodeInstaller, Source, ErrorManager, boolean)->Compiler:::Creates a new compiler instance for initial compilation of a script.
jdk.nashorn.internal.codegen.Compiler#forNoInstallerCompilation(Context, Source, boolean)->Compiler:::Creates a compiler without a code installer
jdk.nashorn.internal.codegen.Compiler#forOnDemandCompilation(CodeInstaller, Source, boolean, RecompilableScriptFunctionData, TypeMap, Map, Object, int[], ScriptObject)->Compiler:::Creates a compiler for an on-demand compilation job.
jdk.nashorn.internal.codegen.Compiler#declareLocalSymbol(String)->void::: compiler declare local symbol
jdk.nashorn.internal.codegen.Compiler#setData(RecompilableScriptFunctionData)->void::: compiler set data
jdk.nashorn.internal.codegen.Compiler#getLogger()->DebugLogger::: compiler get logger
jdk.nashorn.internal.codegen.Compiler#initLogger(Context)->DebugLogger::: compiler init logger
jdk.nashorn.internal.codegen.Compiler#getScriptEnvironment()->ScriptEnvironment::: compiler get script environment
jdk.nashorn.internal.codegen.Compiler#isOnDemandCompilation()->boolean::: compiler is on demand compilation
jdk.nashorn.internal.codegen.Compiler#useOptimisticTypes()->boolean::: compiler use optimistic types
jdk.nashorn.internal.codegen.Compiler#getContext()->Context::: compiler get context
jdk.nashorn.internal.codegen.Compiler#getOptimisticType(Optimistic)->Type::: compiler get optimistic type
jdk.nashorn.internal.codegen.Compiler#hasStringPropertyIterator(Expression)->boolean:::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object)
jdk.nashorn.internal.codegen.Compiler#addInvalidatedProgramPoint(int, Type)->void::: compiler add invalidated program point
jdk.nashorn.internal.codegen.Compiler#getInvalidatedProgramPoints()->Map:::Returns a copy of this compiler's current mapping of invalidated optimistic program points to their types
jdk.nashorn.internal.codegen.Compiler#getTypeMap()->TypeMap::: compiler get type map
jdk.nashorn.internal.codegen.Compiler#getCallSiteType(FunctionNode)->MethodType::: compiler get call site type
jdk.nashorn.internal.codegen.Compiler#getParamType(FunctionNode, int)->Type::: compiler get param type
jdk.nashorn.internal.codegen.Compiler#getReturnType()->Type::: compiler get return type
jdk.nashorn.internal.codegen.Compiler#compile(FunctionNode, CompilationPhases)->FunctionNode:::Do a compilation job
jdk.nashorn.internal.codegen.Compiler#getSource()->Source::: compiler get source
jdk.nashorn.internal.codegen.Compiler#getBytecode()->Map::: compiler get bytecode
jdk.nashorn.internal.codegen.Compiler#clearBytecode()->void:::Reset bytecode cache for compiler reuse.
jdk.nashorn.internal.codegen.Compiler#getFirstCompileUnit()->CompileUnit::: compiler get first compile unit
jdk.nashorn.internal.codegen.Compiler#getCompileUnits()->Set::: compiler get compile units
jdk.nashorn.internal.codegen.Compiler#getConstantData()->ConstantData::: compiler get constant data
jdk.nashorn.internal.codegen.Compiler#getCodeInstaller()->CodeInstaller::: compiler get code installer
jdk.nashorn.internal.codegen.Compiler#addClass(String, byte[])->void::: compiler add class
jdk.nashorn.internal.codegen.Compiler#nextCompileUnitName()->String::: compiler next compile unit name
jdk.nashorn.internal.codegen.Compiler#persistClassInfo(String, FunctionNode)->void:::Persist current compilation with the given cacheKey.
jdk.nashorn.internal.codegen.Compiler#updateCompilationId(int)->void:::Make sure the next compilation id is greater than value.
jdk.nashorn.internal.codegen.Compiler#addCompileUnit(long)->CompileUnit::: compiler add compile unit
jdk.nashorn.internal.codegen.Compiler#createCompileUnit(String, long)->CompileUnit::: compiler create compile unit
jdk.nashorn.internal.codegen.Compiler#isStrict()->boolean::: compiler is strict
jdk.nashorn.internal.codegen.Compiler#replaceCompileUnits(Set)->void::: compiler replace compile units
jdk.nashorn.internal.codegen.Compiler#findUnit(long)->CompileUnit::: compiler find unit
jdk.nashorn.internal.codegen.Compiler#binaryName(String)->String:::Convert a package/class name to a binary name.
jdk.nashorn.internal.codegen.Compiler#getScriptFunctionData(int)->RecompilableScriptFunctionData::: compiler get script function data
jdk.nashorn.internal.codegen.Compiler#isGlobalSymbol(FunctionNode, String)->boolean::: compiler is global symbol
jdk.nashorn.internal.codegen.Compiler#getContinuationEntryPoints()->int[]::: compiler get continuation entry points
jdk.nashorn.internal.codegen.Compiler#getInvalidatedProgramPointType(int)->Type::: compiler get invalidated program point type
jdk.nashorn.internal.codegen.CompileUnit#createCompileUnitSet()->Set::: compile unit create compile unit set
jdk.nashorn.internal.codegen.CompileUnit#increaseEmitCount()->void::: compile unit increase emit count
jdk.nashorn.internal.codegen.CompileUnit#getEmittedUnitCount()->int:::Get the amount of emitted compile units so far in the system
jdk.nashorn.internal.codegen.CompileUnit#isUsed()->boolean:::Check if this compile unit is used
jdk.nashorn.internal.codegen.CompileUnit#hasCode()->boolean:::Check if a compile unit has code, not counting inits and clinits
jdk.nashorn.internal.codegen.CompileUnit#setUsed()->void:::Tag this compile unit as used
jdk.nashorn.internal.codegen.CompileUnit#getCode()->Class:::Return the class that contains the code for this unit, null if not generated yet
jdk.nashorn.internal.codegen.CompileUnit#setCode(Class)->void:::Set class when it exists
jdk.nashorn.internal.codegen.CompileUnit#addFunctionInitializer(RecompilableScriptFunctionData, FunctionNode)->void::: compile unit add function initializer
jdk.nashorn.internal.codegen.CompileUnit#isInitializing(RecompilableScriptFunctionData, FunctionNode)->boolean:::Returns true if this compile unit is responsible for initializing the specified function data with specified function node.
jdk.nashorn.internal.codegen.CompileUnit#initializeFunctionsCode()->void::: compile unit initialize functions code
jdk.nashorn.internal.codegen.CompileUnit#getFunctionNodes()->Collection::: compile unit get function nodes
jdk.nashorn.internal.codegen.CompileUnit#addWeight(long)->void:::Add weight to this compile unit
jdk.nashorn.internal.codegen.CompileUnit#canHold(long)->boolean:::Check if this compile unit can hold weight more units of weight
jdk.nashorn.internal.codegen.CompileUnit#getClassEmitter()->ClassEmitter:::Get the class emitter for this compile unit
jdk.nashorn.internal.codegen.CompileUnit#getUnitClassName()->String:::Get the class name for this compile unit
jdk.nashorn.internal.codegen.CompileUnit#toString()->String::: compile unit to string
jdk.nashorn.internal.codegen.CompileUnit#compareTo(CompileUnit)->int::: compile unit compare to
jdk.nashorn.internal.codegen.ConstantData#add(String)->int:::Add a string to the constant data
jdk.nashorn.internal.codegen.ConstantData#add(Object)->int:::Add an object to the constant data
jdk.nashorn.internal.codegen.ConstantData#toArray()->Object[]::: constant data to array
jdk.nashorn.internal.codegen.DumpBytecode#dumpBytecode(ScriptEnvironment, DebugLogger, byte[], String)->void:::Dump bytecode to console and potentially disk.
jdk.nashorn.internal.codegen.FieldObjectCreator#createObject(MethodEmitter)->void::: field object creator create object
jdk.nashorn.internal.codegen.FieldObjectCreator#createForInIterationScope(MethodEmitter)->void:::Create a scope for a for-in/of loop as defined in ES6 13.7.5.13 step 5.g.iii
jdk.nashorn.internal.codegen.FieldObjectCreator#populateRange(MethodEmitter, Type, int, int, int)->void::: field object creator populate range
jdk.nashorn.internal.codegen.FieldObjectCreator#makeMap()->PropertyMap::: field object creator make map
jdk.nashorn.internal.codegen.FieldObjectCreator#getAllocatorClass()->Class::: field object creator get allocator class
jdk.nashorn.internal.codegen.FieldObjectCreator#getClassName()->String:::Get the class name for the object class, e.g
jdk.nashorn.internal.codegen.FindScopeDepths#getLogger()->DebugLogger::: find scope depths get logger
jdk.nashorn.internal.codegen.FindScopeDepths#initLogger(Context)->DebugLogger::: find scope depths init logger
jdk.nashorn.internal.codegen.FindScopeDepths#findScopesToStart(LexicalContext, FunctionNode, Block)->int::: find scope depths find scopes to start
jdk.nashorn.internal.codegen.FindScopeDepths#findInternalDepth(LexicalContext, FunctionNode, Block, Symbol)->int::: find scope depths find internal depth
jdk.nashorn.internal.codegen.FindScopeDepths#findBodyBlock(LexicalContext, FunctionNode, Block)->Block::: find scope depths find body block
jdk.nashorn.internal.codegen.FindScopeDepths#enterFunctionNode(FunctionNode)->boolean::: find scope depths enter function node
jdk.nashorn.internal.codegen.FindScopeDepths#leaveFunctionNode(FunctionNode)->Node::: find scope depths leave function node
jdk.nashorn.internal.codegen.FindScopeDepths#enterWithNode(WithNode)->boolean::: find scope depths enter with node
jdk.nashorn.internal.codegen.FindScopeDepths#enterBlock(Block)->boolean::: find scope depths enter block
jdk.nashorn.internal.codegen.FindScopeDepths#leaveBlock(Block)->Node::: find scope depths leave block
jdk.nashorn.internal.codegen.FoldConstants#getLogger()->DebugLogger::: fold constants get logger
jdk.nashorn.internal.codegen.FoldConstants#initLogger(Context)->DebugLogger::: fold constants init logger
jdk.nashorn.internal.codegen.FoldConstants#leaveUnaryNode(UnaryNode)->Node::: fold constants leave unary node
jdk.nashorn.internal.codegen.FoldConstants#leaveBinaryNode(BinaryNode)->Node::: fold constants leave binary node
jdk.nashorn.internal.codegen.FoldConstants#leaveFunctionNode(FunctionNode)->Node::: fold constants leave function node
jdk.nashorn.internal.codegen.FoldConstants#leaveIfNode(IfNode)->Node::: fold constants leave if node
jdk.nashorn.internal.codegen.FoldConstants#leaveTernaryNode(TernaryNode)->Node::: fold constants leave ternary node
jdk.nashorn.internal.codegen.FoldConstants#leaveSwitchNode(SwitchNode)->Node::: fold constants leave switch node
jdk.nashorn.internal.codegen.FoldConstants.ConstantEvaluator#eval()->LiteralNode:::Returns a literal node that replaces the given parent node, or null if replacement is impossible
jdk.nashorn.internal.codegen.FoldConstants#extractVarNodesFromDeadCode(Node, List)->void:::When we eliminate dead code, we must preserve var declarations as they are scoped to the whole function
jdk.nashorn.internal.codegen.FunctionSignature#toString()->String::: function signature to string
jdk.nashorn.internal.codegen.FunctionSignature#size()->int::: function signature size
jdk.nashorn.internal.codegen.FunctionSignature#getParamTypes()->Type[]:::Get the param types for this function signature
jdk.nashorn.internal.codegen.FunctionSignature#getMethodType()->MethodType:::Return the MethodType for this function signature
jdk.nashorn.internal.codegen.FunctionSignature#getReturnType()->Type:::Return the return type for this function signature
jdk.nashorn.internal.codegen.Label.Stack#isEmpty()->boolean::: stack is empty
jdk.nashorn.internal.codegen.Label.Stack#size()->int::: stack size
jdk.nashorn.internal.codegen.Label.Stack#clear()->void::: stack clear
jdk.nashorn.internal.codegen.Label.Stack#push(Type)->void::: stack push
jdk.nashorn.internal.codegen.Label.Stack#peek()->Type::: stack peek
jdk.nashorn.internal.codegen.Label.Stack#peek(int)->Type::: stack peek
jdk.nashorn.internal.codegen.Label.Stack#getTopTypes(int)->Type[]:::Retrieve the top count types on the stack without modifying it.
jdk.nashorn.internal.codegen.Label.Stack#getLocalLoads(int, int)->int[]::: stack get local loads
jdk.nashorn.internal.codegen.Label.Stack#getUsedSlotsWithLiveTemporaries()->int:::Returns the number of used local variable slots, including all live stack-store temporaries.
jdk.nashorn.internal.codegen.Label.Stack#joinFrom(Stack, boolean)->void::: stack join from
jdk.nashorn.internal.codegen.Label.Stack#joinFromTry(Stack)->void::: stack join from try
jdk.nashorn.internal.codegen.Label.Stack#markDeadLocalVariables(int, int)->void::: stack mark dead local variables
jdk.nashorn.internal.codegen.Label.Stack#getLocalVariableTypesCopy()->List::: stack get local variable types copy
jdk.nashorn.internal.codegen.Label.Stack#getSymbolBoundaryCopy()->BitSet::: stack get symbol boundary copy
jdk.nashorn.internal.codegen.Label.Stack#getWidestLiveLocals(List)->List:::Returns a list of local variable slot types, but for those symbols that have multiple values, only the slot holding the widest type is marked as live.
jdk.nashorn.internal.codegen.Label.Stack#markSymbolBoundariesInLvarTypesDescriptor(String)->String::: stack mark symbol boundaries in lvar types descriptor
jdk.nashorn.internal.codegen.Label.Stack#pop()->Type::: stack pop
jdk.nashorn.internal.codegen.Label.Stack#clone()->Stack::: stack clone
jdk.nashorn.internal.codegen.Label.Stack#getTopLocalLoad()->int::: stack get top local load
jdk.nashorn.internal.codegen.Label.Stack#markLocalLoad(int)->void::: stack mark local load
jdk.nashorn.internal.codegen.Label.Stack#onLocalStore(Type, int, boolean)->void:::Performs various bookeeping when a value is stored in a local variable slot.
jdk.nashorn.internal.codegen.Label.Stack#defineBlockLocalVariable(int, int)->void:::Marks a range of slots as belonging to a defined local variable
jdk.nashorn.internal.codegen.Label.Stack#defineTemporaryLocalVariable(int)->int:::Defines a new temporary local variable and returns its allocated index.
jdk.nashorn.internal.codegen.Label.Stack#defineTemporaryLocalVariable(int, int)->void:::Marks a range of slots as belonging to a defined temporary local variable
jdk.nashorn.internal.codegen.Label.Stack#undefineLocalVariables(int, boolean)->void:::Undefines all local variables past the specified slot.
jdk.nashorn.internal.codegen.Label.Stack#hasLoadsOnStack(int, int)->boolean:::Returns true if any loads on the stack come from the specified slot range.
jdk.nashorn.internal.codegen.Label.Stack#toString()->String::: stack to string
jdk.nashorn.internal.codegen.Label#getLabel()->jdk.internal.org.objectweb.asm.Label::: label get label
jdk.nashorn.internal.codegen.Label#getStack()->Label.Stack::: label get stack
jdk.nashorn.internal.codegen.Label#joinFrom(Label.Stack)->void::: label join from
jdk.nashorn.internal.codegen.Label#joinFromTry(Label.Stack, boolean)->void::: label join from try
jdk.nashorn.internal.codegen.Label#markAsBreakTarget()->void::: label mark as break target
jdk.nashorn.internal.codegen.Label#isBreakTarget()->boolean::: label is break target
jdk.nashorn.internal.codegen.Label#onCatch()->void::: label on catch
jdk.nashorn.internal.codegen.Label#markAsOptimisticCatchHandler(Label.Stack, int)->void::: label mark as optimistic catch handler
jdk.nashorn.internal.codegen.Label#markAsOptimisticContinuationHandlerFor(Label)->void::: label mark as optimistic continuation handler for
jdk.nashorn.internal.codegen.Label#isReachable()->boolean::: label is reachable
jdk.nashorn.internal.codegen.Label#isAfter(Label)->boolean::: label is after
jdk.nashorn.internal.codegen.Label#toString()->String::: label to string
jdk.nashorn.internal.codegen.LocalStateRestorationInfo#getLocalVariableTypes()->Type[]:::Returns the types of the local variables at the continuation of a program point.
jdk.nashorn.internal.codegen.LocalStateRestorationInfo#getStackLoads()->int[]:::Returns the indices of local variables that need to be loaded on stack before jumping to the continuation of the program point.
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterAccessNode(AccessNode)->boolean::: local variable types calculator enter access node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterBinaryNode(BinaryNode)->boolean::: local variable types calculator enter binary node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterBlock(Block)->boolean::: local variable types calculator enter block
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterBreakNode(BreakNode)->boolean::: local variable types calculator enter break node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterCallNode(CallNode)->boolean::: local variable types calculator enter call node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterContinueNode(ContinueNode)->boolean::: local variable types calculator enter continue node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterDefault(Node)->boolean::: local variable types calculator enter default
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterExpressionStatement(ExpressionStatement)->boolean::: local variable types calculator enter expression statement
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#leaveDefault(Node)->Node::: local variable types calculator leave default
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterForNode(ForNode)->boolean::: local variable types calculator enter for node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterFunctionNode(FunctionNode)->boolean::: local variable types calculator enter function node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterGetSplitState(GetSplitState)->boolean::: local variable types calculator enter get split state
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterIdentNode(IdentNode)->boolean::: local variable types calculator enter ident node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterIfNode(IfNode)->boolean::: local variable types calculator enter if node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterIndexNode(IndexNode)->boolean::: local variable types calculator enter index node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterJoinPredecessorExpression(JoinPredecessorExpression)->boolean::: local variable types calculator enter join predecessor expression
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterJumpToInlinedFinally(JumpToInlinedFinally)->boolean::: local variable types calculator enter jump to inlined finally
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterLiteralNode(LiteralNode)->boolean::: local variable types calculator enter literal node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterObjectNode(ObjectNode)->boolean::: local variable types calculator enter object node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterPropertyNode(PropertyNode)->boolean::: local variable types calculator enter property node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterReturnNode(ReturnNode)->boolean::: local variable types calculator enter return node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterRuntimeNode(RuntimeNode)->boolean::: local variable types calculator enter runtime node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterSplitReturn(SplitReturn)->boolean::: local variable types calculator enter split return
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterSwitchNode(SwitchNode)->boolean::: local variable types calculator enter switch node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterTernaryNode(TernaryNode)->boolean::: local variable types calculator enter ternary node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterThrowNode(ThrowNode)->boolean::: local variable types calculator enter throw node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterTryNode(TryNode)->boolean::: local variable types calculator enter try node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterUnaryNode(UnaryNode)->boolean::: local variable types calculator enter unary node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterVarNode(VarNode)->boolean::: local variable types calculator enter var node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterWhileNode(WhileNode)->boolean::: local variable types calculator enter while node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#enterWithNode(WithNode)->boolean::: local variable types calculator enter with node
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#leaveBlock(Block)->Node::: local variable types calculator leave block
jdk.nashorn.internal.codegen.LocalVariableTypesCalculator#leaveFunctionNode(FunctionNode)->Node::: local variable types calculator leave function node
jdk.nashorn.internal.codegen.Lower#getLogger()->DebugLogger::: lower get logger
jdk.nashorn.internal.codegen.Lower#initLogger(Context)->DebugLogger::: lower init logger
jdk.nashorn.internal.codegen.Lower#enterBreakNode(BreakNode)->boolean::: lower enter break node
jdk.nashorn.internal.codegen.Lower#leaveCallNode(CallNode)->Node::: lower leave call node
jdk.nashorn.internal.codegen.Lower#enterCatchNode(CatchNode)->boolean::: lower enter catch node
jdk.nashorn.internal.codegen.Lower#leaveCatchNode(CatchNode)->Node::: lower leave catch node
jdk.nashorn.internal.codegen.Lower#enterContinueNode(ContinueNode)->boolean::: lower enter continue node
jdk.nashorn.internal.codegen.Lower#enterDebuggerNode(DebuggerNode)->boolean::: lower enter debugger node
jdk.nashorn.internal.codegen.Lower#enterJumpToInlinedFinally(JumpToInlinedFinally)->boolean::: lower enter jump to inlined finally
jdk.nashorn.internal.codegen.Lower#enterEmptyNode(EmptyNode)->boolean::: lower enter empty node
jdk.nashorn.internal.codegen.Lower#leaveIndexNode(IndexNode)->Node::: lower leave index node
jdk.nashorn.internal.codegen.Lower#leaveDELETE(UnaryNode)->Node::: lower leave e
jdk.nashorn.internal.codegen.Lower#leaveExpressionStatement(ExpressionStatement)->Node::: lower leave expression statement
jdk.nashorn.internal.codegen.Lower#leaveBlockStatement(BlockStatement)->Node::: lower leave block statement
jdk.nashorn.internal.codegen.Lower#enterForNode(ForNode)->boolean::: lower enter for node
jdk.nashorn.internal.codegen.Lower#leaveForNode(ForNode)->Node::: lower leave for node
jdk.nashorn.internal.codegen.Lower#enterFunctionNode(FunctionNode)->boolean::: lower enter function node
jdk.nashorn.internal.codegen.Lower#leaveFunctionNode(FunctionNode)->Node::: lower leave function node
jdk.nashorn.internal.codegen.Lower#leaveIfNode(IfNode)->Node::: lower leave if node
jdk.nashorn.internal.codegen.Lower#leaveIN(BinaryNode)->Node::: lower leave n
jdk.nashorn.internal.codegen.Lower#leaveINSTANCEOF(BinaryNode)->Node::: lower leave f
jdk.nashorn.internal.codegen.Lower#leaveLabelNode(LabelNode)->Node::: lower leave label node
jdk.nashorn.internal.codegen.Lower#leaveReturnNode(ReturnNode)->Node::: lower leave return node
jdk.nashorn.internal.codegen.Lower#leaveCaseNode(CaseNode)->Node::: lower leave case node
jdk.nashorn.internal.codegen.Lower#leaveSwitchNode(SwitchNode)->Node::: lower leave switch node
jdk.nashorn.internal.codegen.Lower#leaveThrowNode(ThrowNode)->Node::: lower leave throw node
jdk.nashorn.internal.codegen.Lower#leaveTryNode(TryNode)->Node::: lower leave try node
jdk.nashorn.internal.codegen.Lower#enterUnaryNode(UnaryNode)->boolean::: lower enter unary node
jdk.nashorn.internal.codegen.Lower#enterASSIGN(BinaryNode)->boolean::: lower enter n
jdk.nashorn.internal.codegen.Lower#leaveVarNode(VarNode)->Node::: lower leave var node
jdk.nashorn.internal.codegen.Lower#leaveWhileNode(WhileNode)->Node::: lower leave while node
jdk.nashorn.internal.codegen.Lower#leaveWithNode(WithNode)->Node::: lower leave with node
jdk.nashorn.internal.codegen.Lower#enterClassNode(ClassNode)->boolean::: lower enter class node
jdk.nashorn.internal.codegen.MapCreator#makeFieldMap(boolean, boolean, int, int, boolean)->PropertyMap:::Constructs a property map based on a set of fields.
jdk.nashorn.internal.codegen.MapCreator#makeSpillMap(boolean, boolean)->PropertyMap::: map creator make spill map
jdk.nashorn.internal.codegen.MapCreator#getPropertyFlags(Symbol, boolean, boolean, boolean)->int:::Compute property flags given local state of a field
jdk.nashorn.internal.codegen.MapTuple#getValueType()->Class::: map tuple get value type
jdk.nashorn.internal.codegen.MapTuple#isPrimitive()->boolean::: map tuple is primitive
jdk.nashorn.internal.codegen.MapTuple#toString()->String::: map tuple to string
jdk.nashorn.internal.codegen.MethodEmitter#begin()->void:::Begin a method
jdk.nashorn.internal.codegen.MethodEmitter#end()->void:::End a method
jdk.nashorn.internal.codegen.MethodEmitter#isReachable()->boolean::: method emitter is reachable
jdk.nashorn.internal.codegen.MethodEmitter#toString()->String::: method emitter to string
jdk.nashorn.internal.codegen.MethodEmitter#pushType(Type)->void:::Push a type to the existing stack
jdk.nashorn.internal.codegen.MethodEmitter#peekType(int)->Type:::Peek a given number of slots from the top of the stack and return the type in that slot
jdk.nashorn.internal.codegen.MethodEmitter#peekType()->Type:::Peek at the type at the top of the stack
jdk.nashorn.internal.codegen.MethodEmitter#_new(String, Type)->MethodEmitter:::Generate code a for instantiating a new object and push the object type on the stack
jdk.nashorn.internal.codegen.MethodEmitter#_new(Class)->MethodEmitter:::Generate code a for instantiating a new object and push the object type on the stack
jdk.nashorn.internal.codegen.MethodEmitter#newInstance(Class)->MethodEmitter:::Generate code to call the empty constructor for a class
jdk.nashorn.internal.codegen.MethodEmitter#dup(int)->MethodEmitter:::Perform a dup, that is, duplicate the top element and push the duplicate down a given number of positions on the stack
jdk.nashorn.internal.codegen.MethodEmitter#dup2()->MethodEmitter:::Perform a dup2, that is, duplicate the top element if it is a category 2 type, or two top elements if they are category 1 types, and push them on top of the stack
jdk.nashorn.internal.codegen.MethodEmitter#dup()->MethodEmitter:::Duplicate the top element on the stack and push it
jdk.nashorn.internal.codegen.MethodEmitter#pop()->MethodEmitter:::Pop the top element of the stack and throw it away
jdk.nashorn.internal.codegen.MethodEmitter#pop2()->MethodEmitter:::Pop the top element of the stack if category 2 type, or the two top elements of the stack if category 1 types
jdk.nashorn.internal.codegen.MethodEmitter#swap()->MethodEmitter:::Swap the top two elements of the stack
jdk.nashorn.internal.codegen.MethodEmitter#pack()->void::: method emitter pack
jdk.nashorn.internal.codegen.MethodEmitter#initializeMethodParameter(Symbol, Type, Label)->void:::Initializes a bytecode method parameter
jdk.nashorn.internal.codegen.MethodEmitter#newStringBuilder()->MethodEmitter:::Create a new string builder, call the constructor and push the instance to the stack.
jdk.nashorn.internal.codegen.MethodEmitter#stringBuilderAppend()->MethodEmitter:::Pop a string and a StringBuilder from the top of the stack and call the append function of the StringBuilder, appending the string
jdk.nashorn.internal.codegen.MethodEmitter#and()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise and and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#or()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise or and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#xor()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise xor and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#shr()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise logic shift right and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#shl()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise shift left and and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#sar()->MethodEmitter:::Pops two integer types from the stack, performs a bitwise arithmetic shift right and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#neg(int)->MethodEmitter:::Pops a numeric type from the stack, negates it and pushes the result
jdk.nashorn.internal.codegen.MethodEmitter#_catch(Label)->void:::Add label for the start of a catch block and push the exception to the stack
jdk.nashorn.internal.codegen.MethodEmitter#_catch(Collection)->void:::Add any number of labels for the start of a catch block and push the exception to the stack
jdk.nashorn.internal.codegen.MethodEmitter#_try(Label, Label, Label, Class, boolean)->void:::Start a try/catch block.
jdk.nashorn.internal.codegen.MethodEmitter#_try(Label, Label, Label, Class)->void:::Start a try/catch block.
jdk.nashorn.internal.codegen.MethodEmitter#_try(Label, Label, Label)->void:::Start a try/catch block
jdk.nashorn.internal.codegen.MethodEmitter#markLabelAsOptimisticCatchHandler(Label, int)->void::: method emitter mark label as optimistic catch handler
jdk.nashorn.internal.codegen.MethodEmitter#loadConstants()->MethodEmitter:::Load the constants array
jdk.nashorn.internal.codegen.MethodEmitter#loadUndefined(Type)->MethodEmitter:::Push the undefined value for the given type, i.e
jdk.nashorn.internal.codegen.MethodEmitter#loadForcedInitializer(Type)->MethodEmitter::: method emitter load forced initializer
jdk.nashorn.internal.codegen.MethodEmitter#loadEmpty(Type)->MethodEmitter:::Push the empty value for the given type, i.e
jdk.nashorn.internal.codegen.MethodEmitter#loadNull()->MethodEmitter:::Push null to stack
jdk.nashorn.internal.codegen.MethodEmitter#loadType(String)->MethodEmitter:::Push a handle representing this class top stack
jdk.nashorn.internal.codegen.MethodEmitter#load(boolean)->MethodEmitter:::Push a boolean constant to the stack.
jdk.nashorn.internal.codegen.MethodEmitter#load(int)->MethodEmitter:::Push an int constant to the stack
jdk.nashorn.internal.codegen.MethodEmitter#load(double)->MethodEmitter:::Push a double constant to the stack
jdk.nashorn.internal.codegen.MethodEmitter#load(long)->MethodEmitter:::Push an long constant to the stack
jdk.nashorn.internal.codegen.MethodEmitter#arraylength()->MethodEmitter:::Fetch the length of an array.
jdk.nashorn.internal.codegen.MethodEmitter#load(String)->MethodEmitter:::Push a String constant to the stack
jdk.nashorn.internal.codegen.MethodEmitter#load(IdentNode)->MethodEmitter:::Pushes the value of an identifier to the stack
jdk.nashorn.internal.codegen.MethodEmitter#load(Symbol, Type)->MethodEmitter:::Pushes the value of the symbol to the stack with the specified type
jdk.nashorn.internal.codegen.MethodEmitter#load(Type, int)->MethodEmitter:::Push a local variable to the stack, given an explicit bytecode slot
jdk.nashorn.internal.codegen.MethodEmitter#loadHandle(String, String, String, EnumSet)->MethodEmitter:::Push a method handle to the stack
jdk.nashorn.internal.codegen.MethodEmitter#hasScope()->boolean:::True if this method has a slot allocated for the scope variable (meaning, something in the method actually needs the scope).
jdk.nashorn.internal.codegen.MethodEmitter#loadCompilerConstant(CompilerConstants)->MethodEmitter::: method emitter load compiler constant
jdk.nashorn.internal.codegen.MethodEmitter#loadCompilerConstant(CompilerConstants, Type)->MethodEmitter::: method emitter load compiler constant
jdk.nashorn.internal.codegen.MethodEmitter#loadScope()->MethodEmitter::: method emitter load scope
jdk.nashorn.internal.codegen.MethodEmitter#setSplitState(int)->MethodEmitter::: method emitter set split state
jdk.nashorn.internal.codegen.MethodEmitter#storeCompilerConstant(CompilerConstants)->void::: method emitter store compiler constant
jdk.nashorn.internal.codegen.MethodEmitter#storeCompilerConstant(CompilerConstants, Type)->void::: method emitter store compiler constant
jdk.nashorn.internal.codegen.MethodEmitter#arrayload()->MethodEmitter:::Load an element from an array, determining type automatically
jdk.nashorn.internal.codegen.MethodEmitter#arraystore()->void:::Pop a value, an index and an array from the stack and store the value at the given index in the array.
jdk.nashorn.internal.codegen.MethodEmitter#store(IdentNode)->void:::Pop a value from the stack and store it in a local variable represented by the given identifier
jdk.nashorn.internal.codegen.MethodEmitter#closeLocalVariable(Symbol, Label)->void::: method emitter close local variable
jdk.nashorn.internal.codegen.MethodEmitter#markDeadLocalVariable(Symbol)->void::: method emitter mark dead local variable
jdk.nashorn.internal.codegen.MethodEmitter#markDeadSlots(int, int)->void::: method emitter mark dead slots
jdk.nashorn.internal.codegen.MethodEmitter#store(Symbol, Type)->void::: method emitter store
jdk.nashorn.internal.codegen.MethodEmitter#store(Symbol, Type, boolean)->void:::Pop a value from the stack and store it in a variable denoted by the given symbol
jdk.nashorn.internal.codegen.MethodEmitter#storeHidden(Type, int)->void:::Pop a value from the stack and store it in a local variable slot
jdk.nashorn.internal.codegen.MethodEmitter#storeHidden(Type, int, boolean)->void::: method emitter store hidden
jdk.nashorn.internal.codegen.MethodEmitter#storeTemp(Type, int)->void::: method emitter store temp
jdk.nashorn.internal.codegen.MethodEmitter#onLocalStore(Type, int)->void::: method emitter on local store
jdk.nashorn.internal.codegen.MethodEmitter#defineBlockLocalVariable(int, int)->void:::Marks a range of slots as belonging to a defined local variable
jdk.nashorn.internal.codegen.MethodEmitter#defineTemporaryLocalVariable(int, int)->void:::Marks a range of slots as belonging to a defined temporary local variable
jdk.nashorn.internal.codegen.MethodEmitter#defineTemporaryLocalVariable(int)->int:::Defines a new temporary local variable and returns its allocated index.
jdk.nashorn.internal.codegen.MethodEmitter#undefineLocalVariables(int, boolean)->void::: method emitter undefine local variables
jdk.nashorn.internal.codegen.MethodEmitter#getLocalVariableTypes()->List::: method emitter get local variable types
jdk.nashorn.internal.codegen.MethodEmitter#getWidestLiveLocals(List)->List::: method emitter get widest live locals
jdk.nashorn.internal.codegen.MethodEmitter#markSymbolBoundariesInLvarTypesDescriptor(String)->String::: method emitter mark symbol boundaries in lvar types descriptor
jdk.nashorn.internal.codegen.MethodEmitter#iinc(int, int)->void:::Increment/Decrement a local integer by the given value.
jdk.nashorn.internal.codegen.MethodEmitter#athrow()->void:::Pop an exception object from the stack and generate code for throwing it
jdk.nashorn.internal.codegen.MethodEmitter#_instanceof(String)->MethodEmitter:::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to
jdk.nashorn.internal.codegen.MethodEmitter#_instanceof(Class)->MethodEmitter:::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to
jdk.nashorn.internal.codegen.MethodEmitter#checkcast(String)->MethodEmitter:::Perform a checkcast operation on the object at the top of the stack.
jdk.nashorn.internal.codegen.MethodEmitter#checkcast(Class)->MethodEmitter:::Perform a checkcast operation on the object at the top of the stack.
jdk.nashorn.internal.codegen.MethodEmitter#newarray(ArrayType)->MethodEmitter:::Instantiate a new array given a length that is popped from the stack and the array type
jdk.nashorn.internal.codegen.MethodEmitter#multinewarray(ArrayType, int)->MethodEmitter:::Instantiate a multidimensional array with a given number of dimensions
jdk.nashorn.internal.codegen.MethodEmitter#invoke(Call)->MethodEmitter:::Generate an invocation to a Call structure
jdk.nashorn.internal.codegen.MethodEmitter#invokespecial(String, String, String)->MethodEmitter:::Pop receiver from stack, perform an invoke special
jdk.nashorn.internal.codegen.MethodEmitter#invokevirtual(String, String, String)->MethodEmitter:::Pop receiver from stack, perform an invoke virtual, push return value if any
jdk.nashorn.internal.codegen.MethodEmitter#invokestatic(String, String, String)->MethodEmitter:::Perform an invoke static and push the return value if any
jdk.nashorn.internal.codegen.MethodEmitter#invokestatic(String, String, String, Type)->MethodEmitter:::Perform an invoke static and replace the return type if we know better, e.g
jdk.nashorn.internal.codegen.MethodEmitter#invokeinterface(String, String, String)->MethodEmitter:::Pop receiver from stack, perform an invoke interface and push return value if any
jdk.nashorn.internal.codegen.MethodEmitter#getLabels(Label...)->jdk.internal.org.objectweb.asm.Label[]::: method emitter get labels
jdk.nashorn.internal.codegen.MethodEmitter#lookupswitch(Label, int[], Label...)->void:::Generate a lookup switch, popping the switch value from the stack
jdk.nashorn.internal.codegen.MethodEmitter#tableswitch(int, int, Label, Label...)->void:::Generate a table switch
jdk.nashorn.internal.codegen.MethodEmitter#conditionalJump(Condition, Label)->void:::Abstraction for performing a conditional jump of any type
jdk.nashorn.internal.codegen.MethodEmitter#conditionalJump(Condition, boolean, Label)->void:::Abstraction for performing a conditional jump of any type, including a dcmpg/dcmpl semantic for doubles.
jdk.nashorn.internal.codegen.MethodEmitter#_return(Type)->void:::Perform a non void return, popping the type from the stack
jdk.nashorn.internal.codegen.MethodEmitter#_return()->void:::Perform a return using the stack top value as the guide for the type
jdk.nashorn.internal.codegen.MethodEmitter#returnVoid()->void:::Perform a void return.
jdk.nashorn.internal.codegen.MethodEmitter#cmp(boolean)->MethodEmitter:::Perform a comparison of two number types that are popped from the stack
jdk.nashorn.internal.codegen.MethodEmitter#if_acmpeq(Label)->void:::Generate an if_acmpeq
jdk.nashorn.internal.codegen.MethodEmitter#if_acmpne(Label)->void:::Generate an if_acmpne
jdk.nashorn.internal.codegen.MethodEmitter#ifnull(Label)->void:::Generate an ifnull
jdk.nashorn.internal.codegen.MethodEmitter#ifnonnull(Label)->void:::Generate an ifnonnull
jdk.nashorn.internal.codegen.MethodEmitter#ifeq(Label)->void:::Generate an ifeq
jdk.nashorn.internal.codegen.MethodEmitter#if_icmpeq(Label)->void:::Generate an if_icmpeq
jdk.nashorn.internal.codegen.MethodEmitter#ifne(Label)->void:::Generate an if_ne
jdk.nashorn.internal.codegen.MethodEmitter#if_icmpne(Label)->void:::Generate an if_icmpne
jdk.nashorn.internal.codegen.MethodEmitter#iflt(Label)->void:::Generate an iflt
jdk.nashorn.internal.codegen.MethodEmitter#if_icmplt(Label)->void:::Generate an if_icmplt
jdk.nashorn.internal.codegen.MethodEmitter#ifle(Label)->void:::Generate an ifle
jdk.nashorn.internal.codegen.MethodEmitter#if_icmple(Label)->void:::Generate an if_icmple
jdk.nashorn.internal.codegen.MethodEmitter#ifgt(Label)->void:::Generate an ifgt
jdk.nashorn.internal.codegen.MethodEmitter#if_icmpgt(Label)->void:::Generate an if_icmpgt
jdk.nashorn.internal.codegen.MethodEmitter#ifge(Label)->void:::Generate an ifge
jdk.nashorn.internal.codegen.MethodEmitter#if_icmpge(Label)->void:::Generate an if_icmpge
jdk.nashorn.internal.codegen.MethodEmitter#_goto(Label)->void:::Unconditional jump to a label
jdk.nashorn.internal.codegen.MethodEmitter#gotoLoopStart(Label)->void:::Unconditional jump to the start label of a loop
jdk.nashorn.internal.codegen.MethodEmitter#uncheckedGoto(Label)->void:::Unconditional jump without any control flow and data flow testing
jdk.nashorn.internal.codegen.MethodEmitter#canThrow(Label)->void:::Potential transfer of control to a catch block.
jdk.nashorn.internal.codegen.MethodEmitter#label(Label)->void:::Register a new label, enter it here.
jdk.nashorn.internal.codegen.MethodEmitter#breakLabel(Label, int)->void:::Register a new break target label, enter it here.
jdk.nashorn.internal.codegen.MethodEmitter#convert(Type)->MethodEmitter:::Pop element from stack, convert to given type
jdk.nashorn.internal.codegen.MethodEmitter#add(int)->MethodEmitter:::Pop two numbers, perform addition and push result
jdk.nashorn.internal.codegen.MethodEmitter#sub(int)->MethodEmitter:::Pop two numbers, perform subtraction and push result
jdk.nashorn.internal.codegen.MethodEmitter#mul(int)->MethodEmitter:::Pop two numbers, perform multiplication and push result
jdk.nashorn.internal.codegen.MethodEmitter#div(int)->MethodEmitter:::Pop two numbers, perform division and push result
jdk.nashorn.internal.codegen.MethodEmitter#rem(int)->MethodEmitter:::Pop two numbers, calculate remainder and push result
jdk.nashorn.internal.codegen.MethodEmitter#getTypesFromStack(int)->Type[]:::Retrieve the top count types on the stack without modifying it.
jdk.nashorn.internal.codegen.MethodEmitter#getLocalLoadsOnStack(int, int)->int[]::: method emitter get local loads on stack
jdk.nashorn.internal.codegen.MethodEmitter#getStackSize()->int::: method emitter get stack size
jdk.nashorn.internal.codegen.MethodEmitter#getFirstTemp()->int::: method emitter get first temp
jdk.nashorn.internal.codegen.MethodEmitter#getUsedSlotsWithLiveTemporaries()->int::: method emitter get used slots with live temporaries
jdk.nashorn.internal.codegen.MethodEmitter#invalidateSpecialName(String)->MethodEmitter::: method emitter invalidate special name
jdk.nashorn.internal.codegen.MethodEmitter#dynamicNew(int, int)->MethodEmitter:::Generate a dynamic new
jdk.nashorn.internal.codegen.MethodEmitter#dynamicNew(int, int, String)->MethodEmitter:::Generate a dynamic new
jdk.nashorn.internal.codegen.MethodEmitter#dynamicCall(Type, int, int)->MethodEmitter:::Generate a dynamic call
jdk.nashorn.internal.codegen.MethodEmitter#dynamicCall(Type, int, int, String)->MethodEmitter:::Generate a dynamic call
jdk.nashorn.internal.codegen.MethodEmitter#dynamicArrayPopulatorCall(int, int)->MethodEmitter::: method emitter dynamic array populator call
jdk.nashorn.internal.codegen.MethodEmitter#dynamicGet(Type, String, int, boolean, boolean)->MethodEmitter:::Generate dynamic getter
jdk.nashorn.internal.codegen.MethodEmitter#dynamicSet(String, int, boolean)->void:::Generate dynamic setter
jdk.nashorn.internal.codegen.MethodEmitter#dynamicRemove(String, int, boolean)->MethodEmitter:::Generate dynamic remover
jdk.nashorn.internal.codegen.MethodEmitter#dynamicGetIndex(Type, int, boolean)->MethodEmitter:::Dynamic getter for indexed structures
jdk.nashorn.internal.codegen.MethodEmitter#dynamicSetIndex(int)->void:::Dynamic setter for indexed structures
jdk.nashorn.internal.codegen.MethodEmitter#dynamicRemoveIndex(int)->MethodEmitter:::Dynamic remover for indexed structures
jdk.nashorn.internal.codegen.MethodEmitter#loadKey(Object)->MethodEmitter::: method emitter load key
jdk.nashorn.internal.codegen.MethodEmitter#getField(FieldAccess)->MethodEmitter:::Generate get for a field access
jdk.nashorn.internal.codegen.MethodEmitter#putField(FieldAccess)->void:::Generate set for a field access
jdk.nashorn.internal.codegen.MethodEmitter#getField(String, String, String)->MethodEmitter:::Get the value of a non-static field, pop the receiver from the stack, push value to the stack
jdk.nashorn.internal.codegen.MethodEmitter#getStatic(String, String, String)->MethodEmitter:::Get the value of a static field, push it to the stack
jdk.nashorn.internal.codegen.MethodEmitter#putField(String, String, String)->void:::Pop value and field from stack and write to a non-static field
jdk.nashorn.internal.codegen.MethodEmitter#putStatic(String, String, String)->void:::Pop value from stack and write to a static field
jdk.nashorn.internal.codegen.MethodEmitter#lineNumber(int)->void:::Register line number at a label
jdk.nashorn.internal.codegen.MethodEmitter#beforeJoinPoint(JoinPredecessor)->void::: method emitter before join point
jdk.nashorn.internal.codegen.MethodEmitter#beforeTry(TryNode, Label)->void::: method emitter before try
jdk.nashorn.internal.codegen.MethodEmitter#print()->void:::Emit a System.err.print statement of whatever is on top of the bytecode stack
jdk.nashorn.internal.codegen.MethodEmitter#println()->void:::Emit a System.err.println statement of whatever is on top of the bytecode stack
jdk.nashorn.internal.codegen.MethodEmitter#print(String)->void:::Emit a System.err.print statement
jdk.nashorn.internal.codegen.MethodEmitter#println(String)->void:::Emit a System.err.println statement
jdk.nashorn.internal.codegen.MethodEmitter#stacktrace()->void:::Print a stacktrace to S
jdk.nashorn.internal.codegen.MethodEmitter#setFunctionNode(FunctionNode)->void:::Set the current function node being emitted
jdk.nashorn.internal.codegen.MethodEmitter#setPreventUndefinedLoad()->void:::Invoke to enforce assertions preventing load from a local variable slot that's known to not have been written to
jdk.nashorn.internal.codegen.Namespace#getParent()->Namespace:::Return the parent Namespace of this space.
jdk.nashorn.internal.codegen.Namespace#uniqueName(String)->String:::Create a uniqueName name in the namespace in the form base-n where n varies
jdk.nashorn.internal.codegen.Namespace#toString()->String::: namespace to string
jdk.nashorn.internal.codegen.ObjectClassGenerator#getLogger()->DebugLogger::: object class generator get logger
jdk.nashorn.internal.codegen.ObjectClassGenerator#initLogger(Context)->DebugLogger::: object class generator init logger
jdk.nashorn.internal.codegen.ObjectClassGenerator#pack(Number)->long:::Pack a number into a primitive long field
jdk.nashorn.internal.codegen.ObjectClassGenerator#getClassName(int, boolean)->String:::Returns the class name for JavaScript objects with fieldCount fields.
jdk.nashorn.internal.codegen.ObjectClassGenerator#getClassName(int, int, boolean)->String:::Returns the class name for JavaScript scope with fieldCount fields and paramCount parameters.
jdk.nashorn.internal.codegen.ObjectClassGenerator#getFieldCount(Class)->int:::Returns the number of fields in the JavaScript scope class
jdk.nashorn.internal.codegen.ObjectClassGenerator#getFieldName(int, Type)->String:::Returns the name of a field based on number and type.
jdk.nashorn.internal.codegen.ObjectClassGenerator#generate(String)->byte[]:::Generate the byte codes for a JavaScript object class or scope
jdk.nashorn.internal.codegen.ObjectClassGenerator#generate(int)->byte[]:::Generate the byte codes for a JavaScript object class with fieldCount fields.
jdk.nashorn.internal.codegen.ObjectClassGenerator#generate(int, int)->byte[]:::Generate the byte codes for a JavaScript scope class with fieldCount fields and paramCount parameters.
jdk.nashorn.internal.codegen.ObjectClassGenerator#createGetter(Class, Class, MethodHandle, MethodHandle, int)->MethodHandle:::Given a primitiveGetter (optional for non dual fields) and an objectSetter that retrieve the primitive and object version of a field respectively, return one with the correct method type and the correct filters
jdk.nashorn.internal.codegen.ObjectClassGenerator#createSetter(Class, Class, MethodHandle, MethodHandle)->MethodHandle:::This is similar to the ObjectClassGenerator#createGetter function
jdk.nashorn.internal.codegen.ObjectClassGenerator#createGuardBoxedPrimitiveSetter(Class, MethodHandle, MethodHandle)->MethodHandle:::If we are setting boxed types (because the compiler couldn't determine which they were) to a primitive field, we can reuse the primitive field getter, as long as we are setting an element of the same boxed type as the primitive type representation
jdk.nashorn.internal.codegen.ObjectClassGenerator#getPaddedFieldCount(int)->int:::Add padding to field count to avoid creating too many classes and have some spare fields
jdk.nashorn.internal.codegen.ObjectClassGenerator#createAllocationStrategy(int, boolean)->AllocationStrategy:::Creates the allocator class name and property map for a constructor function with the specified number of "this" properties that it initializes.
jdk.nashorn.internal.codegen.ObjectCreator#makeObject(MethodEmitter)->void:::Generate code for making the object.
jdk.nashorn.internal.codegen.ObjectCreator#createObject(MethodEmitter)->void:::Generate code for creating and initializing the object.
jdk.nashorn.internal.codegen.ObjectCreator#makeMap()->PropertyMap:::Construct the property map appropriate for the object.
jdk.nashorn.internal.codegen.ObjectCreator#newMapCreator(Class)->MapCreator:::Create a new MapCreator
jdk.nashorn.internal.codegen.ObjectCreator#loadScope(MethodEmitter)->void:::Loads the scope on the stack through the passed method emitter.
jdk.nashorn.internal.codegen.ObjectCreator#loadMap(MethodEmitter)->MethodEmitter:::Emit the correct map for the object.
jdk.nashorn.internal.codegen.ObjectCreator#getMap()->PropertyMap::: object creator get map
jdk.nashorn.internal.codegen.ObjectCreator#isScope()->boolean:::Is this a scope object
jdk.nashorn.internal.codegen.ObjectCreator#hasArguments()->boolean:::Does the created object have an "arguments" property
jdk.nashorn.internal.codegen.ObjectCreator#getAllocatorClass()->Class:::Get the class of objects created by this ObjectCreator
jdk.nashorn.internal.codegen.ObjectCreator#loadValue(T, Type)->void:::Technique for loading an initial value
jdk.nashorn.internal.codegen.ObjectCreator#loadTuple(MethodEmitter, MapTuple, boolean)->MethodEmitter::: object creator load tuple
jdk.nashorn.internal.codegen.ObjectCreator#loadIndex(MethodEmitter, long)->MethodEmitter::: object creator load index
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterAccessNode(AccessNode)->boolean::: optimistic types calculator enter access node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterPropertyNode(PropertyNode)->boolean::: optimistic types calculator enter property node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterBinaryNode(BinaryNode)->boolean::: optimistic types calculator enter binary node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterCallNode(CallNode)->boolean::: optimistic types calculator enter call node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterCatchNode(CatchNode)->boolean::: optimistic types calculator enter catch node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterExpressionStatement(ExpressionStatement)->boolean::: optimistic types calculator enter expression statement
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterForNode(ForNode)->boolean::: optimistic types calculator enter for node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterFunctionNode(FunctionNode)->boolean::: optimistic types calculator enter function node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterIfNode(IfNode)->boolean::: optimistic types calculator enter if node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterIndexNode(IndexNode)->boolean::: optimistic types calculator enter index node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterTernaryNode(TernaryNode)->boolean::: optimistic types calculator enter ternary node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterUnaryNode(UnaryNode)->boolean::: optimistic types calculator enter unary node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterVarNode(VarNode)->boolean::: optimistic types calculator enter var node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterObjectNode(ObjectNode)->boolean::: optimistic types calculator enter object node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterLiteralNode(LiteralNode)->boolean::: optimistic types calculator enter literal node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#enterWhileNode(WhileNode)->boolean::: optimistic types calculator enter while node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#leaveDefault(Node)->Node::: optimistic types calculator leave default
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#leaveFunctionNode(FunctionNode)->Node::: optimistic types calculator leave function node
jdk.nashorn.internal.codegen.OptimisticTypesCalculator#leaveIdentNode(IdentNode)->Node::: optimistic types calculator leave ident node
jdk.nashorn.internal.codegen.OptimisticTypesPersistence#getLocationDescriptor(Source, int, Type[])->Object:::Retrieves an opaque descriptor for the persistence location for a given function
jdk.nashorn.internal.codegen.OptimisticTypesPersistence#store(Object, Map)->void:::Stores the map of optimistic types for a given function.
jdk.nashorn.internal.codegen.OptimisticTypesPersistence#load(Object)->Map:::Loads the map of optimistic types for a given function.
jdk.nashorn.internal.codegen.OptimisticTypesPersistence#getVersionDirName()->String:::In order to ensure that changes in Nashorn code don't cause corruption in the data, we'll create a per-code-version directory
jdk.nashorn.internal.codegen.ProgramPoints#enterFunctionNode(FunctionNode)->boolean::: program points enter function node
jdk.nashorn.internal.codegen.ProgramPoints#leaveFunctionNode(FunctionNode)->Node::: program points leave function node
jdk.nashorn.internal.codegen.ProgramPoints#enterVarNode(VarNode)->boolean::: program points enter var node
jdk.nashorn.internal.codegen.ProgramPoints#enterIdentNode(IdentNode)->boolean::: program points enter ident node
jdk.nashorn.internal.codegen.ProgramPoints#leaveIdentNode(IdentNode)->Node::: program points leave ident node
jdk.nashorn.internal.codegen.ProgramPoints#leaveCallNode(CallNode)->Node::: program points leave call node
jdk.nashorn.internal.codegen.ProgramPoints#leaveAccessNode(AccessNode)->Node::: program points leave access node
jdk.nashorn.internal.codegen.ProgramPoints#leaveIndexNode(IndexNode)->Node::: program points leave index node
jdk.nashorn.internal.codegen.ProgramPoints#leaveBinaryNode(BinaryNode)->Node::: program points leave binary node
jdk.nashorn.internal.codegen.ProgramPoints#leaveUnaryNode(UnaryNode)->Node::: program points leave unary node
jdk.nashorn.internal.codegen.ReplaceCompileUnits#getReplacement(CompileUnit)->CompileUnit:::Override to provide a replacement for an old compile unit.
jdk.nashorn.internal.codegen.ReplaceCompileUnits#getExistingReplacement(CompileUnitHolder)->CompileUnit::: replace compile units get existing replacement
jdk.nashorn.internal.codegen.ReplaceCompileUnits#leaveFunctionNode(FunctionNode)->Node::: replace compile units leave function node
jdk.nashorn.internal.codegen.ReplaceCompileUnits#leaveLiteralNode(LiteralNode)->Node::: replace compile units leave literal node
jdk.nashorn.internal.codegen.ReplaceCompileUnits#leaveObjectNode(ObjectNode)->Node::: replace compile units leave object node
jdk.nashorn.internal.codegen.SharedScopeCall#hashCode()->int::: shared scope call hash code
jdk.nashorn.internal.codegen.SharedScopeCall#equals(Object)->boolean::: shared scope call equals
jdk.nashorn.internal.codegen.SharedScopeCall#setClassAndName(CompileUnit, String)->void:::Set the compile unit and method name.
jdk.nashorn.internal.codegen.SharedScopeCall#generateInvoke(MethodEmitter)->void:::Generate the invoke instruction for this shared scope call.
jdk.nashorn.internal.codegen.SharedScopeCall#generateScopeCall()->void:::Generate the method that implements the scope get or call.
jdk.nashorn.internal.codegen.SharedScopeCall#toString()->String::: shared scope call to string
jdk.nashorn.internal.codegen.SpillObjectCreator#createObject(MethodEmitter)->void::: spill object creator create object
jdk.nashorn.internal.codegen.SpillObjectCreator#populateRange(MethodEmitter, Type, int, int, int)->void::: spill object creator populate range
jdk.nashorn.internal.codegen.SpillObjectCreator#makeMap()->PropertyMap::: spill object creator make map
jdk.nashorn.internal.codegen.SpillObjectCreator#loadValue(Expression, Type)->void::: spill object creator load value
jdk.nashorn.internal.codegen.SpillObjectCreator#getAllocatorClass()->Class::: spill object creator get allocator class
jdk.nashorn.internal.codegen.SplitIntoFunctions#enterFunctionNode(FunctionNode)->boolean::: split into functions enter function node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveFunctionNode(FunctionNode)->Node::: split into functions leave function node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveDefault(Node)->Node::: split into functions leave default
jdk.nashorn.internal.codegen.SplitIntoFunctions#enterSplitNode(SplitNode)->boolean::: split into functions enter split node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveSplitNode(SplitNode)->Node::: split into functions leave split node
jdk.nashorn.internal.codegen.SplitIntoFunctions#enterVarNode(VarNode)->boolean::: split into functions enter var node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveBlock(Block)->Node::: split into functions leave block
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveBreakNode(BreakNode)->Node::: split into functions leave break node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveContinueNode(ContinueNode)->Node::: split into functions leave continue node
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveJumpToInlinedFinally(JumpToInlinedFinally)->Node::: split into functions leave jump to inlined finally
jdk.nashorn.internal.codegen.SplitIntoFunctions#leaveReturnNode(ReturnNode)->Node::: split into functions leave return node
jdk.nashorn.internal.codegen.Splitter#initLogger(Context)->DebugLogger::: splitter init logger
jdk.nashorn.internal.codegen.Splitter#getLogger()->DebugLogger::: splitter get logger
jdk.nashorn.internal.codegen.Splitter#split(FunctionNode, boolean)->FunctionNode:::Execute the split.
jdk.nashorn.internal.codegen.Splitter#findUnit(long)->CompileUnit:::Override this logic to look up compile units in a different way
jdk.nashorn.internal.codegen.Splitter#enterBlock(Block)->boolean::: splitter enter block
jdk.nashorn.internal.codegen.Splitter#leaveBlock(Block)->Node::: splitter leave block
jdk.nashorn.internal.codegen.Splitter#leaveLiteralNode(LiteralNode)->Node::: splitter leave literal node
jdk.nashorn.internal.codegen.Splitter#leaveObjectNode(ObjectNode)->Node::: splitter leave object node
jdk.nashorn.internal.codegen.Splitter#enterFunctionNode(FunctionNode)->boolean::: splitter enter function node
jdk.nashorn.internal.codegen.TypeEvaluator#hasStringPropertyIterator(Expression)->boolean:::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object)
jdk.nashorn.internal.codegen.TypeEvaluator#getOptimisticType(Optimistic)->Type::: type evaluator get optimistic type
jdk.nashorn.internal.codegen.TypeEvaluator#declareLocalSymbol(String)->void:::Declares a symbol name as belonging to a non-scoped local variable during an on-demand compilation of a single function
jdk.nashorn.internal.codegen.TypeMap#getParameterTypes(int)->Type[]:::Returns the array of parameter types for a particular function node
jdk.nashorn.internal.codegen.TypeMap#getCallSiteType(FunctionNode)->MethodType::: type map get call site type
jdk.nashorn.internal.codegen.TypeMap#needsCallee()->boolean:::Does the function using this TypeMap need a callee argument
jdk.nashorn.internal.codegen.TypeMap#get(FunctionNode, int)->Type:::Get the parameter type for this parameter position, or null if now known
jdk.nashorn.internal.codegen.TypeMap#getReturnType()->Type:::Get the return type required for the call site we're compiling for
jdk.nashorn.internal.codegen.TypeMap#toString()->String::: type map to string
jdk.nashorn.internal.codegen.TypeMap#toString(String)->String::: type map to string
jdk.nashorn.internal.codegen.WeighNodes#weigh(Node)->long::: weigh nodes weigh
jdk.nashorn.internal.codegen.WeighNodes#weigh(Node, Map)->long::: weigh nodes weigh
jdk.nashorn.internal.codegen.WeighNodes#leaveAccessNode(AccessNode)->Node::: weigh nodes leave access node
jdk.nashorn.internal.codegen.WeighNodes#enterBlock(Block)->boolean::: weigh nodes enter block
jdk.nashorn.internal.codegen.WeighNodes#leaveBreakNode(BreakNode)->Node::: weigh nodes leave break node
jdk.nashorn.internal.codegen.WeighNodes#leaveCallNode(CallNode)->Node::: weigh nodes leave call node
jdk.nashorn.internal.codegen.WeighNodes#leaveCatchNode(CatchNode)->Node::: weigh nodes leave catch node
jdk.nashorn.internal.codegen.WeighNodes#leaveContinueNode(ContinueNode)->Node::: weigh nodes leave continue node
jdk.nashorn.internal.codegen.WeighNodes#leaveExpressionStatement(ExpressionStatement)->Node::: weigh nodes leave expression statement
jdk.nashorn.internal.codegen.WeighNodes#leaveForNode(ForNode)->Node::: weigh nodes leave for node
jdk.nashorn.internal.codegen.WeighNodes#enterFunctionNode(FunctionNode)->boolean::: weigh nodes enter function node
jdk.nashorn.internal.codegen.WeighNodes#leaveIdentNode(IdentNode)->Node::: weigh nodes leave ident node
jdk.nashorn.internal.codegen.WeighNodes#leaveIfNode(IfNode)->Node::: weigh nodes leave if node
jdk.nashorn.internal.codegen.WeighNodes#leaveIndexNode(IndexNode)->Node::: weigh nodes leave index node
jdk.nashorn.internal.codegen.WeighNodes#leaveJumpToInlinedFinally(JumpToInlinedFinally)->Node::: weigh nodes leave jump to inlined finally
jdk.nashorn.internal.codegen.WeighNodes#enterLiteralNode(LiteralNode)->boolean::: weigh nodes enter literal node
jdk.nashorn.internal.codegen.WeighNodes#enterObjectNode(ObjectNode)->boolean::: weigh nodes enter object node
jdk.nashorn.internal.codegen.WeighNodes#leavePropertyNode(PropertyNode)->Node::: weigh nodes leave property node
jdk.nashorn.internal.codegen.WeighNodes#leaveReturnNode(ReturnNode)->Node::: weigh nodes leave return node
jdk.nashorn.internal.codegen.WeighNodes#leaveRuntimeNode(RuntimeNode)->Node::: weigh nodes leave runtime node
jdk.nashorn.internal.codegen.WeighNodes#enterSplitNode(SplitNode)->boolean::: weigh nodes enter split node
jdk.nashorn.internal.codegen.WeighNodes#leaveSwitchNode(SwitchNode)->Node::: weigh nodes leave switch node
jdk.nashorn.internal.codegen.WeighNodes#leaveThrowNode(ThrowNode)->Node::: weigh nodes leave throw node
jdk.nashorn.internal.codegen.WeighNodes#leaveTryNode(TryNode)->Node::: weigh nodes leave try node
jdk.nashorn.internal.codegen.WeighNodes#leaveVarNode(VarNode)->Node::: weigh nodes leave var node
jdk.nashorn.internal.codegen.WeighNodes#leaveWhileNode(WhileNode)->Node::: weigh nodes leave while node
jdk.nashorn.internal.codegen.WeighNodes#leaveWithNode(WithNode)->Node::: weigh nodes leave with node
jdk.nashorn.internal.codegen.WeighNodes#leavePOS(UnaryNode)->Node::: weigh nodes leave s
jdk.nashorn.internal.codegen.WeighNodes#leaveBIT_NOT(UnaryNode)->Node::: weigh nodes leave t_ t
jdk.nashorn.internal.codegen.WeighNodes#leaveDECINC(UnaryNode)->Node::: weigh nodes leave c
jdk.nashorn.internal.codegen.WeighNodes#leaveDELETE(UnaryNode)->Node::: weigh nodes leave e
jdk.nashorn.internal.codegen.WeighNodes#leaveNEW(UnaryNode)->Node::: weigh nodes leave w
jdk.nashorn.internal.codegen.WeighNodes#leaveNOT(UnaryNode)->Node::: weigh nodes leave t
jdk.nashorn.internal.codegen.WeighNodes#leaveNEG(UnaryNode)->Node::: weigh nodes leave g
jdk.nashorn.internal.codegen.WeighNodes#leaveTYPEOF(UnaryNode)->Node::: weigh nodes leave f
jdk.nashorn.internal.codegen.WeighNodes#leaveVOID(UnaryNode)->Node::: weigh nodes leave d
jdk.nashorn.internal.codegen.WeighNodes#leaveADD(BinaryNode)->Node::: weigh nodes leave d
jdk.nashorn.internal.codegen.WeighNodes#leaveAND(BinaryNode)->Node::: weigh nodes leave d
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN(BinaryNode)->Node::: weigh nodes leave n
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_ADD(BinaryNode)->Node::: weigh nodes leave n_ d
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_BIT_AND(BinaryNode)->Node::: weigh nodes leave n_ t_ d
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_BIT_OR(BinaryNode)->Node::: weigh nodes leave n_ t_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_BIT_XOR(BinaryNode)->Node::: weigh nodes leave n_ t_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_DIV(BinaryNode)->Node::: weigh nodes leave n_ v
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_MOD(BinaryNode)->Node::: weigh nodes leave n_ d
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_MUL(BinaryNode)->Node::: weigh nodes leave n_ l
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_SAR(BinaryNode)->Node::: weigh nodes leave n_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_SHL(BinaryNode)->Node::: weigh nodes leave n_ l
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_SHR(BinaryNode)->Node::: weigh nodes leave n_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveASSIGN_SUB(BinaryNode)->Node::: weigh nodes leave n_ b
jdk.nashorn.internal.codegen.WeighNodes#leaveARROW(BinaryNode)->Node::: weigh nodes leave w
jdk.nashorn.internal.codegen.WeighNodes#leaveBIT_AND(BinaryNode)->Node::: weigh nodes leave t_ d
jdk.nashorn.internal.codegen.WeighNodes#leaveBIT_OR(BinaryNode)->Node::: weigh nodes leave t_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveBIT_XOR(BinaryNode)->Node::: weigh nodes leave t_ r
jdk.nashorn.internal.codegen.WeighNodes#leaveCOMMARIGHT(BinaryNode)->Node::: weigh nodes leave t
jdk.nashorn.internal.codegen.WeighNodes#leaveDIV(BinaryNode)->Node::: weigh nodes leave v
jdk.nashorn.internal.codegen.WeighNodes#leaveEQ(BinaryNode)->Node::: weigh nodes leave q
jdk.nashorn.internal.codegen.WeighNodes#leaveEQ_STRICT(BinaryNode)->Node::: weigh nodes leave q_ t
jdk.nashorn.internal.codegen.WeighNodes#leaveGE(BinaryNode)->Node::: weigh nodes leave e
jdk.nashorn.internal.codegen.WeighNodes#leaveGT(BinaryNode)->Node::: weigh nodes leave t
jdk.nashorn.internal.codegen.WeighNodes#leaveIN(BinaryNode)->Node::: weigh nodes leave n
jdk.nashorn.internal.codegen.WeighNodes#leaveINSTANCEOF(BinaryNode)->Node::: weigh nodes leave f
jdk.nashorn.internal.codegen.WeighNodes#leaveLE(BinaryNode)->Node::: weigh nodes leave e
jdk.nashorn.internal.codegen.WeighNodes#leaveLT(BinaryNode)->Node::: weigh nodes leave t
jdk.nashorn.internal.codegen.WeighNodes#leaveMOD(BinaryNode)->Node::: weigh nodes leave d
jdk.nashorn.internal.codegen.WeighNodes#leaveMUL(BinaryNode)->Node::: weigh nodes leave l
jdk.nashorn.internal.codegen.WeighNodes#leaveNE(BinaryNode)->Node::: weigh nodes leave e
jdk.nashorn.internal.codegen.WeighNodes#leaveNE_STRICT(BinaryNode)->Node::: weigh nodes leave e_ t
jdk.nashorn.internal.codegen.WeighNodes#leaveOR(BinaryNode)->Node::: weigh nodes leave r
jdk.nashorn.internal.codegen.WeighNodes#leaveSAR(BinaryNode)->Node::: weigh nodes leave r
jdk.nashorn.internal.codegen.WeighNodes#leaveSHL(BinaryNode)->Node::: weigh nodes leave l
jdk.nashorn.internal.codegen.WeighNodes#leaveSHR(BinaryNode)->Node::: weigh nodes leave r
jdk.nashorn.internal.codegen.WeighNodes#leaveSUB(BinaryNode)->Node::: weigh nodes leave b
