ApplySpecialization#getLogger()::: apply specialization get logger:::return
ApplySpecialization#initLogger(Context)::: apply specialization init logger:::return->context->this->getClass->getLogger
ApplySpecialization#hasApplies(FunctionNode)::: apply specialization has applies:::try->functionNode->new->SimpleNodeVisitor->accept->catch->return->finally->log->DebugLogger->functionNode->getName->quote->fine->return
ApplySpecialization#checkValidTransform(FunctionNode):::Arguments may only be used as args to the apply:::argumentsFound->new->HashSet<>->stack->new->ArrayDeque<>->functionNode->new->SimpleNodeVisitor->accept
ApplySpecialization#enterCallNode(CallNode)::: apply specialization enter call node:::return->explodedArguments->isEmpty
ApplySpecialization#leaveCallNode(CallNode)::: apply specialization leave call node:::newParams->explodedArguments->peek->if->isApply->newArgs->new->ArrayList<>->foreach->callNode->getArgs->if->ARGUMENTS->getName->equals->newArgs->addAll->else->newArgs->add->changed->lc->getCurrentFunction->getId->add->newCallNode->callNode->setArgs->setIsApplyToCall->if->log->isEnabled->log->DebugLogger->lc->getCurrentFunction->getName->quote->fine->return->return
ApplySpecialization#pushExplodedArgs(FunctionNode)::: apply specialization push exploded args:::start->actualCallSiteType->compiler->getCallSiteType->if->throw->lc->getCurrentFunction->new->TransformFailedException->ptm->compiler->getTypeMap->if->ptm->needsCallee->newParams->new->ArrayList<>->to->actualCallSiteType->parameterCount->for->i->callSiteTypes->push->explodedArguments->push
ApplySpecialization#enterFunctionNode(FunctionNode)::: apply specialization enter function node:::if->compiler->isOnDemandCompilation->functionNode->needsArguments->functionNode->hasEval->functionNode->getNumOfParams->return->if->Global->isBuiltinFunctionPrototypeApply->log->fine->return->if->hasApplies->return->if->log->isEnabled->log->functionNode->getName->functionNode->getParameters->functionNode->getId->functionNode->getSource->getURL->massageURL->info->try->checkValidTransform->pushExplodedArgs->catch->log->e->getMessage->info->return->finally->return
ApplySpecialization#leaveFunctionNode(FunctionNode):::Try to do the apply to call transformation:::newFunctionNode->functionName->newFunctionNode->getName->if->changed->newFunctionNode->getId->contains->newFunctionNode->clearFlag->setFlag->explodedArguments->peek->setParameters->if->log->isEnabled->log->newFunctionNode->getSource->getURL->massageURL->newFunctionNode->getId->callSiteTypes->peek->info->callSiteTypes->pop->explodedArguments->pop->return
ApplySpecialization#isApply(CallNode)::: apply specialization is apply:::f->callNode->getFunction->return->getProperty->equals
ApplySpecialization#massageURL(URL)::: apply specialization massage l:::if->return->str->url->toString->slash->str->lastIndexOf->if->return->return->str->substring
AssignSymbols#isParamOrVar(IdentNode)::: assign symbols is param or var:::symbol->identNode->getSymbol->return->symbol->isParam->symbol->isVar
AssignSymbols#name(Node)::: assign symbols name:::cn->node->getClass->getName->lastDot->cn->lastIndexOf->if->return->return->cn->substring
AssignSymbols#removeUnusedSlots(FunctionNode):::Checks if various symbols that were provisionally marked as needing a slot ended up unused, and marks them as not needing a slot after all.:::if->functionNode->needsCallee->functionNode->compilerConstant->setNeedsSlot->if->functionNode->hasScopeBlock->functionNode->needsParentScope->functionNode->compilerConstant->setNeedsSlot->if->functionNode->isNamedFunctionExpression->functionNode->usesSelfSymbol->selfSymbol->functionNode->getBody->functionNode->getIdent->getName->getExistingSymbol->if->selfSymbol->isFunctionSelf->selfSymbol->setNeedsSlot->selfSymbol->clearFlag->return
AssignSymbols#getLogger()::: assign symbols get logger:::return
AssignSymbols#initLogger(Context)::: assign symbols init logger:::return->context->this->getClass->getLogger
AssignSymbols#acceptDeclarations(FunctionNode, Block):::Define symbols for all variable declarations at the top of the function scope:::body->new->SimpleNodeVisitor->accept
AssignSymbols#compilerConstantIdentifier(CompilerConstants)::: assign symbols compiler constant identifier:::return->cc->symbolName->createImplicitIdentifier->lc->getCurrentFunction->compilerConstant->setSymbol
AssignSymbols#createImplicitIdentifier(String):::Creates an ident node for an implicit identifier within the function (one not declared in the script source code):::fn->lc->getCurrentFunction->return->fn->getToken->fn->getFinish->new->IdentNode
AssignSymbols#createSymbol(String, int)::: assign symbols create symbol:::if->global->globalSymbols->get->if->new->Symbol->globalSymbols->put->return->return->new->Symbol
AssignSymbols#createSyntheticInitializer(IdentNode, CompilerConstants, FunctionNode):::Creates a synthetic initializer for a variable (a var statement that doesn't occur in the source code):::init->compilerConstantIdentifier->synthVar->fn->getLineNumber->fn->getToken->fn->getFinish->new->VarNode->nameSymbol->fn->getBody->name->getName->getExistingSymbol->return->synthVar->name->setSymbol->setName->accept
AssignSymbols#createSyntheticInitializers(FunctionNode)::: assign symbols create synthetic initializers:::syntheticInitializers->new->ArrayList<>->body->functionNode->getBody->lc->push->try->if->functionNode->usesSelfSymbol->syntheticInitializers->functionNode->getIdent->createSyntheticInitializer->add->if->functionNode->needsArguments->syntheticInitializers->ARGUMENTS_VAR->symbolName->createImplicitIdentifier->createSyntheticInitializer->add->if->syntheticInitializers->isEmpty->return->for->it->syntheticInitializers->listIterator->it->hasNext->catch->finally->lc->pop->stmts->body->getStatements->newStatements->stmts->size->syntheticInitializers->size->new->ArrayList<>->newStatements->addAll->newStatements->addAll->return->functionNode->body->setStatements->setBody
AssignSymbols#defineSymbol(Block, String, Node, int):::Defines a new symbol in the given block.:::flags->isBlockScope->isGlobal->symbol->function->if->block->getExistingSymbol->lc->getCurrentFunction->else->findSymbol->lc->getFunction->if->if->lc->getCurrentFunction->isProgram->isParam->isVar->if->if->if->isLocal->else->if->symbol->isParam->ECMAErrors->getMessage->throwParserException->else->if->if->if->symbol->hasBeenDeclared->ECMAErrors->getMessage->throwParserException->else->symbol->setHasBeenDeclared->if->function->isProgram->function->getBody->symbol->setIsScope->else->if->else->if->symbol->isBlockScoped->lc->getCurrentFunction->isLocal->ECMAErrors->getMessage->throwParserException->if->isLocal->symbol->less->if->symbolBlock->if->else->if->lc->getOutermostFunction->getBody->else->lc->getFunctionBody->createSymbol->symbolBlock->putSymbol->if->symbol->setNeedsSlot->else->if->symbol->less->symbol->setFlags->return
AssignSymbols#end(T)::: assign symbols end:::return->end
AssignSymbols#end(T, boolean)::: assign symbols end:::if->sb->new->StringBuilder->sb->append->name->append->append->node->toString->append->append->lc->getCurrentFunction->getName->append->append->if->symbol->getSymbol->if->sb->append->else->sb->append->append->append->log->unindent->log->info->return
AssignSymbols#enterBlock(Block)::: assign symbols enter block:::start->if->lc->isFunctionBody->fn->lc->getCurrentFunction->if->isUnparsedFunction->foreach->compiler->fn->getId->getScriptFunctionData->getExternalSymbolNames->nameIsUsed->return->enterFunctionBody->return
AssignSymbols#isUnparsedFunction(FunctionNode)::: assign symbols is unparsed function:::return->lc->getOutermostFunction
AssignSymbols#enterCatchNode(CatchNode)::: assign symbols enter catch node:::exception->catchNode->getExceptionIdentifier->block->lc->getCurrentBlock->start->exname->exception->getName->isInternal->exname->EXCEPTION_PREFIX->symbolName->startsWith->symbol->defineSymbol->symbol->clearFlag->return
AssignSymbols#enterFunctionBody()::: assign symbols enter function body:::functionNode->lc->getCurrentFunction->body->lc->getCurrentBlock->initFunctionWideVariables->acceptDeclarations->defineFunctionSelfSymbol
AssignSymbols#defineFunctionSelfSymbol(FunctionNode, Block)::: assign symbols define function self symbol:::if->functionNode->isNamedFunctionExpression->return->name->functionNode->getIdent->getName->if->body->getExistingSymbol->return->defineSymbol->if->functionNode->allVarsInScope->lc->setFlag
AssignSymbols#enterFunctionNode(FunctionNode)::: assign symbols enter function node:::start->thisProperties->new->HashSet<String>->push->return
AssignSymbols#enterVarNode(VarNode)::: assign symbols enter var node:::start->if->varNode->isFunctionDeclaration->defineVarIdent->return
AssignSymbols#leaveVarNode(VarNode)::: assign symbols leave var node:::if->varNode->isFunctionDeclaration->defineVarIdent->return->super->leaveVarNode
AssignSymbols#defineVarIdent(VarNode)::: assign symbols define var ident:::ident->varNode->getName->flags->if->varNode->isBlockScoped->lc->getCurrentFunction->isProgram->else->lc->getCurrentBlock->ident->getName->varNode->getSymbolFlags->defineSymbol
AssignSymbols#exceptionSymbol()::: assign symbols exception symbol:::return->newObjectInternal
AssignSymbols#finalizeParameters(FunctionNode):::This has to run before fix assignment types, store any type specializations for parameters, then turn them into objects for the generic version of this method.:::newParams->new->ArrayList<>->isVarArg->functionNode->isVarArg->body->functionNode->getBody->foreach->functionNode->getParameters->paramSymbol->body->param->getName->getExistingSymbol->newParams->param->setSymbol->add->if->paramSymbol->setNeedsSlot->return->functionNode->setParameters
AssignSymbols#findSymbol(Block, String):::Search for symbol in the lexical context starting from the given block.:::for->blocks->lc->getBlocks->blocks->hasNext->return
AssignSymbols#functionUsesGlobalSymbol():::Marks the current function as one using any global symbol:::for->fns->lc->getFunctions->fns->hasNext
AssignSymbols#functionUsesScopeSymbol(Symbol):::Marks the current function as one using a scoped symbol:::name->symbol->getName->for->contextNodeIter->lc->getAllNodes->contextNodeIter->hasNext
AssignSymbols#functionUsesSymbol(Symbol):::Declares that the current function is using the symbol.:::if->symbol->isScope->if->symbol->isGlobal->functionUsesGlobalSymbol->else->functionUsesScopeSymbol->else
AssignSymbols#initCompileConstant(CompilerConstants, Block, int)::: assign symbols init compile constant:::cc->symbolName->defineSymbol->setNeedsSlot
AssignSymbols#initFunctionWideVariables(FunctionNode, Block)::: assign symbols init function wide variables:::initCompileConstant->initCompileConstant->if->functionNode->isVarArg->initCompileConstant->if->functionNode->needsArguments->initCompileConstant->ARGUMENTS_VAR->symbolName->defineSymbol->initParameters->initCompileConstant->initCompileConstant
AssignSymbols#initParameters(FunctionNode, Block):::Initialize parameters for function node.:::isVarArg->functionNode->isVarArg->scopeParams->functionNode->allVarsInScope->foreach->functionNode->getParameters->symbol->param->getName->defineSymbol->if->symbol->setIsScope->if->symbol->setNeedsSlot
AssignSymbols#isLocal(FunctionNode, Symbol):::Is the symbol local to (that is, defined in) the specified function?:::definingFn->lc->getDefiningFunction->return
AssignSymbols#leaveBinaryNode(BinaryNode)::: assign symbols leave binary node:::if->binaryNode->isTokenType->return->leaveASSIGN->return->super->leaveBinaryNode
AssignSymbols#leaveASSIGN(BinaryNode)::: assign symbols leave n:::lhs->binaryNode->lhs->if->accessNode->base->accessNode->getBase->if->symbol->getSymbol->if->symbol->isThis->thisProperties->peek->accessNode->getProperty->add->return
AssignSymbols#leaveUnaryNode(UnaryNode)::: assign symbols leave unary node:::if->unaryNode->tokenType->return->leaveTYPEOF->else->return->super->leaveUnaryNode
AssignSymbols#leaveForNode(ForNode)::: assign symbols leave for node:::if->forNode->isForInOrOf->return->forNode->newObjectInternal->setIterator->return->end
AssignSymbols#leaveFunctionNode(FunctionNode)::: assign symbols leave function node:::finalizedFunction->if->isUnparsedFunction->else->lc->applyTopFlags->finalizeParameters->createSyntheticInitializers->removeUnusedSlots->thisProperties->pop->size->setThisProperties->markProgramBlock->return
AssignSymbols#leaveIdentNode(IdentNode)::: assign symbols leave ident node:::if->identNode->isPropertyName->return->symbol->identNode->getName->nameIsUsed->if->identNode->isInitializedHere->symbol->increaseUseCount->newIdentNode->identNode->setSymbol->if->symbol->isBlockScoped->symbol->hasBeenDeclared->identNode->isDeclaredHere->lc->getCurrentFunction->isLocal->newIdentNode->markDead->return->end
AssignSymbols#nameIsUsed(String, IdentNode)::: assign symbols name is used:::block->lc->getCurrentBlock->symbol->findSymbol->if->log->info->if->symbol->isFunctionSelf->functionNode->lc->getDefiningFunction->lc->setFlag->maybeForceScope->else->log->info->defineSymbol->functionUsesSymbol->return
AssignSymbols#leaveSwitchNode(SwitchNode)::: assign symbols leave switch node:::if->switchNode->isUniqueInteger->return->switchNode->newObjectInternal->setTag->return
AssignSymbols#leaveTryNode(TryNode)::: assign symbols leave try node:::end->return->tryNode->exceptionSymbol->setException
AssignSymbols#leaveTYPEOF(UnaryNode)::: assign symbols leave f:::rhs->unaryNode->getExpression->args->new->ArrayList<>->if->isParamOrVar->args->compilerConstantIdentifier->add->args->LiteralNode->getName->newInstance->add->else->args->add->args->LiteralNode->newInstance->add->runtimeNode->new->RuntimeNode->end->return
AssignSymbols#markProgramBlock(FunctionNode)::: assign symbols mark program block:::if->functionNode->isProgram->return->return->functionNode->functionNode->getBody->setFlag->setBody
AssignSymbols#maybeForceScope(Symbol):::If the symbol isn't already a scope symbol, but it needs to be (see #symbolNeedsToBeScope(Symbol), it is promoted to a scope symbol and its block marked as needing a scope.:::if->symbol->isScope->symbolNeedsToBeScope->Symbol->setSymbolIsScope
AssignSymbols#newInternal(CompilerConstants, int)::: assign symbols new internal:::return->lc->getCurrentBlock->lc->getCurrentFunction->cc->symbolName->uniqueName->defineSymbol
AssignSymbols#newObjectInternal(CompilerConstants)::: assign symbols new object internal:::return->newInternal
AssignSymbols#start(Node)::: assign symbols start:::return->start
AssignSymbols#start(Node, boolean)::: assign symbols start:::if->sb->new->StringBuilder->sb->append->name->append->append->node->toString->append->append->lc->getCurrentFunction->getName->append->append->log->info->log->indent->return
AssignSymbols#symbolNeedsToBeScope(Symbol):::Determines if the symbol has to be a scope symbol:::if->symbol->isThis->symbol->isInternal->return->func->lc->getCurrentFunction->if->func->allVarsInScope->symbol->isBlockScoped->func->isProgram->return->previousWasBlock->for->it->lc->getAllNodes->it->hasNext->throw->new->AssertionError
AssignSymbols#isSplitLiteral(LexicalContextNode)::: assign symbols is split literal:::return->getSplitRanges
AssignSymbols#throwUnprotectedSwitchError(VarNode)::: assign symbols throw unprotected switch error:::msg->ECMAErrors->varNode->isLet->getMessage->throwParserException
AssignSymbols#throwParserException(String, Node)::: assign symbols throw parser exception:::if->throw->new->ParserException->source->compiler->getSource->token->origin->getToken->line->source->origin->getStart->getLine->column->source->origin->getStart->getColumn->formatted->ErrorManager->format->throw->new->ParserException
BranchOptimizer#execute(Expression, Label, boolean)::: branch optimizer execute:::branchOptimizer
BranchOptimizer#branchOptimizer(UnaryNode, Label, boolean)::: branch optimizer branch optimizer:::if->unaryNode->isTokenType->unaryNode->getExpression->branchOptimizer->else->loadTestAndJump
BranchOptimizer#branchOptimizer(BinaryNode, Label, boolean)::: branch optimizer branch optimizer:::lhs->binaryNode->lhs->rhs->binaryNode->rhs->switch->binaryNode->tokenType->if->skip->new->Label->optimizeLogicalOperand->optimizeLogicalOperand->method->label->else->optimizeLogicalOperand->optimizeLogicalOperand->return->if->optimizeLogicalOperand->optimizeLogicalOperand->else->skip->new->Label->optimizeLogicalOperand->optimizeLogicalOperand->method->label->return->codegen->loadComparisonOperands->method->conditionalJump->return->codegen->loadComparisonOperands->method->conditionalJump->return->codegen->loadComparisonOperands->method->conditionalJump->return->codegen->loadComparisonOperands->method->conditionalJump->return->codegen->loadComparisonOperands->method->conditionalJump->return->codegen->loadComparisonOperands->method->conditionalJump->return->break->loadTestAndJump
BranchOptimizer#optimizeLogicalOperand(Expression, Label, boolean, boolean)::: branch optimizer optimize logical operand:::jpexpr->if->LocalVariableConversion->hasLiveConversion->after->new->Label->jpexpr->getExpression->branchOptimizer->method->beforeJoinPoint->method->_goto->method->label->if->method->beforeJoinPoint->else->jpexpr->getExpression->branchOptimizer
BranchOptimizer#branchOptimizer(Expression, Label, boolean)::: branch optimizer branch optimizer:::if->branchOptimizer->return->if->branchOptimizer->return->loadTestAndJump
BranchOptimizer#loadTestAndJump(Expression, Label, boolean)::: branch optimizer load test and jump:::codegen->loadExpressionAsBoolean->if->method->ifne->else->method->ifeq
CacheAst#enterFunctionNode(FunctionNode)::: cache ast enter function node:::id->functionNode->getId->dataStack->dataStack->isEmpty->compiler->getScriptFunctionData->dataStack->peek->getScriptFunctionData->push->return
CacheAst#leaveFunctionNode(FunctionNode)::: cache ast leave function node:::data->dataStack->pop->if->functionNode->isSplit->data->setCachedAst->if->dataStack->isEmpty->dataStack->peek->getFunctionFlags->return->functionNode->functionNode->getBody->Collections->emptyList->setStatements->setBody->return
ClassEmitter#getMethodNames():::Return the method names encountered.:::return->Collections->unmodifiableSet
ClassEmitter#getContext()::: class emitter get context:::return
ClassEmitter#getUnitClassName()::: class emitter get unit class name:::return
ClassEmitter#getMethodCount():::Get the method count, including init and clinit methods.:::return
ClassEmitter#getClinitCount():::Get the clinit count.:::return
ClassEmitter#getInitCount():::Get the init count.:::return
ClassEmitter#getFieldCount():::Get the field count.:::return
ClassEmitter#pathName(String):::Convert a binary name to a package/class name.:::return->name->replace
ClassEmitter#defineCommonStatics(boolean):::Define the static fields common in all scripts.:::EnumSet->of->SOURCE->symbolName->field->EnumSet->of->CONSTANTS->symbolName->field->EnumSet->of->STRICT_MODE->symbolName->field
ClassEmitter#defineCommonUtilities():::Define static utilities common needed in scripts:::if->constantMethodNeeded->contains->getStringMethod->EnumSet->of->GET_STRING->symbolName->method->getStringMethod->begin->getStringMethod->CONSTANTS->symbolName->CONSTANTS->descriptor->getStatic->load->arrayload->checkcast->_return->getStringMethod->end->if->constantMethodNeeded->contains->getMapMethod->EnumSet->of->GET_MAP->symbolName->method->getMapMethod->begin->getMapMethod->loadConstants->load->arrayload->checkcast->_return->getMapMethod->end->setMapMethod->EnumSet->of->SET_MAP->symbolName->method->setMapMethod->begin->setMapMethod->loadConstants->load->load->arraystore->setMapMethod->returnVoid->setMapMethod->end->foreach->if->clazz->isArray->defineGetArrayMethod
ClassEmitter#defineGetArrayMethod(Class):::Constructs a primitive specific method for getting the ith entry from the constants table as an array.:::methodName->getArrayMethodName->getArrayMethod->EnumSet->of->method->getArrayMethod->begin->getArrayMethod->CONSTANTS->symbolName->CONSTANTS->descriptor->getStatic->load->arrayload->checkcast->virtualCallNoLookup->invoke->checkcast->_return->getArrayMethod->end
ClassEmitter#getArrayMethodName(Class):::Generate the name of a get array from constant pool method.:::return->GET_ARRAY_PREFIX->symbolName->clazz->getComponentType->getSimpleName->GET_ARRAY_SUFFIX->symbolName
ClassEmitter#needGetConstantMethod(Class):::Ensure a get constant method is issued for the class.:::constantMethodNeeded->add
ClassEmitter#isScriptObject(String, String):::Inspect class name and decide whether we are generating a ScriptObject class.:::if->type->startsWith->return->else->if->type->CompilerConstants->className->equals->return->else->if->type->startsWith->return->return
ClassEmitter#begin():::Call at beginning of class emission.:::
ClassEmitter#end():::Call at end of class emission.:::if->initMethod->EnumSet->of->init->initMethod->begin->initMethod->load->initMethod->newInstance->initMethod->returnVoid->initMethod->end->defineCommonUtilities->cw->visitEnd
ClassEmitter#disassemble(byte[]):::Disassemble an array of byte code.:::baos->new->ByteArrayOutputStream->try->pw->new->PrintWriter->cr->new->NashornClassReader->ctx->AccessController->new->PrivilegedAction<Context>->doPrivileged->tcv->ctx->getEnv->new->NashornTextifier->new->TraceClassVisitor->cr->accept->catch->finally->str->baos->toByteArray->new->String->return
ClassEmitter#beginMethod(MethodEmitter):::Call back from MethodEmitter for method start.:::methodsStarted->add
ClassEmitter#endMethod(MethodEmitter):::Call back from MethodEmitter for method end.:::methodsStarted->remove
ClassEmitter#method(String, Class, Class...):::Add a new method to the class - defaults to public method.:::return->method
ClassEmitter#method(EnumSet, String, Class, Class...):::Add a new method to the class - defaults to public method.:::methodNames->add->return->methodVisitor->new->MethodEmitter
ClassEmitter#method(String, String):::Add a new method to the class - defaults to public method.:::return->method
ClassEmitter#method(EnumSet, String, String):::Add a new method to the class - defaults to public method.:::methodNames->add->return->cw->Flag->getValue->visitMethod->new->MethodEmitter
ClassEmitter#method(FunctionNode):::Add a new method to the class, representing a function node.:::methodNames->functionNode->getName->add->signature->new->FunctionSignature->mv->cw->functionNode->isVarArg->functionNode->getName->signature->toString->visitMethod->return->new->MethodEmitter
ClassEmitter#restOfMethod(FunctionNode):::Add a new method to the class, representing a rest-of version of the function node.:::methodNames->functionNode->getName->add->mv->cw->functionNode->getName->Type->functionNode->getReturnType->getTypeClass->getMethodDescriptor->visitMethod->return->new->MethodEmitter
ClassEmitter#clinit():::Start generating the <clinit> method in the class.:::return->EnumSet->of->CLINIT->symbolName->method
ClassEmitter#init():::Start generating an <init>()V method in the class.:::return->INIT->symbolName->method
ClassEmitter#init(Class...):::Start generating an <init>()V method in the class.:::return->INIT->symbolName->method
ClassEmitter#init(EnumSet, Class...):::Start generating an <init>(...)V method in the class.:::return->INIT->symbolName->method
ClassEmitter#field(EnumSet, String, Class, Object):::Add a field to the class, initialized to a value.:::cw->Flag->getValue->typeDescriptor->visitField->visitEnd
ClassEmitter#field(EnumSet, String, Class):::Add a field to the class.:::field
ClassEmitter#field(String, Class):::Add a field to the class - defaults to public.:::EnumSet->of->field
ClassEmitter#toByteArray():::Return a bytecode array from this ClassEmitter:::if->return->return->cw->toByteArray
ClassEmitter#methodVisitor(EnumSet, String, Class, Class...)::: class emitter method visitor:::return->cw->Flag->getValue->methodDescriptor->visitMethod
CodeGenerator#getLogger()::: code generator get logger:::return
CodeGenerator#initLogger(Context)::: code generator init logger:::return->context->this->getClass->getLogger
CodeGenerator#getCallSiteFlags():::Gets the call site flags, adding the strict flag if the current function being generated is in strict mode:::return->lc->getCurrentFunction->getCallSiteFlags
CodeGenerator#getScopeCallSiteFlags(Symbol):::Gets the flags for a scope call site.:::flags->getCallSiteFlags->if->isEvalCode->symbol->isGlobal->return->return->isFastScope
CodeGenerator#isEvalCode():::Are we generating code for 'eval' code?:::return
CodeGenerator#useDualFields():::Are we using dual primitive/object field representation?:::return->compiler->getContext->useDualFields
CodeGenerator#loadIdent(IdentNode, TypeBounds):::Load an identity node:::checkTemporalDeadZone->symbol->identNode->getSymbol->if->symbol->isScope->type->identNode->getType->if->return->method->loadUndefined->return->method->load->flags->getScopeCallSiteFlags->if->isFastScope->new->LoadScopeVar->emit->else->if->identNode->isCompileTimePropertyName->symbol->getUseCount->new->LoadFastScopeVar->emit->else->new->OptimisticOperation->emit->return
CodeGenerator#checkTemporalDeadZone(IdentNode)::: code generator check temporal dead zone:::if->identNode->isDead->method->identNode->getSymbol->getName->load->invoke
CodeGenerator#checkAssignTarget(Expression)::: code generator check assign target:::if->getSymbol->isConst->method->getSymbol->getName->load->invoke
CodeGenerator#isRestOf()::: code generator is rest of:::return
CodeGenerator#isCurrentContinuationEntryPoint(int)::: code generator is current continuation entry point:::return->isRestOf->getCurrentContinuationEntryPoint
CodeGenerator#getContinuationEntryPoints()::: code generator get continuation entry points:::return->isRestOf
CodeGenerator#getCurrentContinuationEntryPoint()::: code generator get current continuation entry point:::return->isRestOf
CodeGenerator#isContinuationEntryPoint(int)::: code generator is continuation entry point:::if->isRestOf->foreach->if->return->return
CodeGenerator#isFastScope(Symbol):::Check if this symbol can be accessed directly with a putfield or getfield or dynamic load:::if->symbol->isScope->return->if->lc->inDynamicScope->return->if->symbol->isGlobal->return->name->symbol->getName->previousWasBlock->for->it->lc->getAllNodes->it->hasNext->throw->new->AssertionError
CodeGenerator.LoadScopeVar#loadStack()::: load scope var load stack:::method->loadCompilerConstant->getProto
CodeGenerator.LoadScopeVar#getProto()::: load scope var get proto:::
CodeGenerator.LoadScopeVar#consumeStack()::: load scope var consume stack:::if->identNode->isCompileTimePropertyName->method->identNode->getSymbol->getName->identNode->isFunction->dynamicGet->replaceCompileTimeProperty->else->identNode->getSymbol->getName->identNode->isFunction->dynamicGet
CodeGenerator.LoadFastScopeVar#getProto()::: load fast scope var get proto:::identNode->getSymbol->loadFastScopeProto
CodeGenerator#storeFastScopeVar(Symbol, int)::: code generator store fast scope var:::loadFastScopeProto->method->symbol->getName->dynamicSet->return
CodeGenerator#getScopeProtoDepth(Block, Symbol)::: code generator get scope proto depth:::fn->lc->getCurrentFunction->externalDepth->compiler->fn->getId->getScriptFunctionData->symbol->getName->getExternalSymbolDepth->internalDepth->FindScopeDepths->findInternalDepth->scopesToStart->FindScopeDepths->findScopesToStart->depth->if->else->return
CodeGenerator#loadFastScopeProto(Symbol, boolean)::: code generator load fast scope proto:::depth->lc->getCurrentBlock->getScopeProtoDepth->if->if->method->swap->invokeGetProto->if->method->swap
CodeGenerator#invokeGetProto(int)::: code generator invoke get proto:::if->method->load->method->invoke->else->method->invoke
CodeGenerator#loadExpressionUnbounded(Expression):::Generate code that loads this node to the stack, not constraining its type:::return->loadExpression
CodeGenerator#loadExpressionAsObject(Expression)::: code generator load expression as object:::return->loadExpression
CodeGenerator#loadExpressionAsBoolean(Expression)::: code generator load expression as boolean:::return->loadExpression
CodeGenerator#noToPrimitiveConversion(Type, Type)::: code generator no to primitive conversion:::return->source->isJSPrimitive->target->isJSPrimitive->target->isBoolean
CodeGenerator#loadBinaryOperands(BinaryNode)::: code generator load binary operands:::return->binaryNode->lhs->binaryNode->rhs->binaryNode->getWidestOperandType->notWiderThan->loadBinaryOperands
CodeGenerator#loadBinaryOperands(Expression, Expression, TypeBounds, boolean, boolean)::: code generator load binary operands:::lhsType->lhs->getType->undefinedToNumber->rhsType->rhs->getType->undefinedToNumber->narrowestOperandType->Type->Type->widest->narrowest->operandBounds->explicitOperandBounds->notNarrowerThan->if->noToPrimitiveConversion->rhs->isLocal->if->safeConvertBounds->notNarrowerThan->loadExpression->method->operandBounds->method->peekType->within->convert->loadExpression->method->operandBounds->method->peekType->within->convert->else->loadExpression->loadExpression->else->safeConvertBounds->notNarrowerThan->loadExpression->lhsLoadedType->method->peekType->loadExpression->convertedLhsType->operandBounds->method->peekType->within->if->method->swap->convert->swap->method->operandBounds->method->peekType->within->convert->return
CodeGenerator#loadComparisonOperands(BinaryNode):::Similar to #loadBinaryOperands(BinaryNode) but used specifically for loading operands of relational and equality comparison operators where at least one argument is non-object:::lhs->cmp->lhs->rhs->cmp->rhs->lhsType->lhs->getType->rhsType->rhs->getType->if->lhsType->isObject->rhsType->isObject->canReorder->lhsType->isPrimitive->rhs->isLocal->canCombineLoadAndConvert->cmp->isRelational->lhs->isOptimistic->loadExpression->lhsLoadedType->method->peekType->tt->cmp->tokenType->if->emitObjectToNumberComparisonConversion->rhs->isOptimistic->loadExpression->else->loadExpression->if->method->swap->emitObjectToNumberComparisonConversion->method->swap->emitObjectToNumberComparisonConversion->return->return->loadBinaryOperands
CodeGenerator#emitObjectToNumberComparisonConversion(MethodEmitter, TokenType)::: code generator emit object to number comparison conversion:::switch->if->method->peekType->isObject->TO_NUMBER_FOR_EQ->invoke->return->break->if->method->peekType->isObject->TO_NUMBER_FOR_STRICT_EQ->invoke->return->break->break->method->convert
CodeGenerator#undefinedToNumber(Type)::: code generator undefined to number:::return
CodeGenerator.TypeBounds#exact(Type)::: type bounds exact:::return->new->TypeBounds
CodeGenerator.TypeBounds#notNarrowerThan(Type)::: type bounds not narrower than:::return->Type->Type->widest->narrowest->maybeNew
CodeGenerator.TypeBounds#notWiderThan(Type)::: type bounds not wider than:::return->Type->narrowest->Type->narrowest->maybeNew
CodeGenerator.TypeBounds#canBeNarrowerThan(Type)::: type bounds can be narrower than:::return->narrowest->narrowerThan
CodeGenerator.TypeBounds#maybeNew(Type, Type)::: type bounds maybe new:::if->return->return->new->TypeBounds
CodeGenerator.TypeBounds#booleanToInt()::: type bounds boolean to int:::return->CodeGenerator->booleanToInt->CodeGenerator->booleanToInt->maybeNew
CodeGenerator.TypeBounds#objectToNumber()::: type bounds object to number:::return->CodeGenerator->objectToNumber->CodeGenerator->objectToNumber->maybeNew
CodeGenerator.TypeBounds#within(Type)::: type bounds within:::if->type->narrowerThan->return->if->type->widerThan->return->return
CodeGenerator.TypeBounds#toString()::: type bounds to string:::return
CodeGenerator#booleanToInt(Type)::: code generator boolean to int:::return
CodeGenerator#objectToNumber(Type)::: code generator object to number:::return->t->isObject
CodeGenerator#loadExpressionAsType(Expression, Type)::: code generator load expression as type:::if->return->loadExpressionAsBoolean->else->if->return->loadExpressionAsObject->return->notNarrowerThan->loadExpression->convert
CodeGenerator#loadExpression(Expression, TypeBounds)::: code generator load expression:::return->loadExpression
CodeGenerator#loadExpression(Expression, TypeBounds, boolean):::Emits code for evaluating an expression and leaving its value on top of the stack, narrowing or widening it if necessary.:::codegen->isCurrentDiscard->isCurrentDiscard->expr->new->LexicalContext->new->NodeOperatorVisitor<LexicalContext>->accept->if->coerceStackTop->return
CodeGenerator#coerceStackTop(TypeBounds)::: code generator coerce stack top:::return->method->typeBounds->method->peekType->within->convert
CodeGenerator#closeBlockVariables(Block):::Closes any still open entries for this block's local variables in the bytecode local variable table.:::foreach->block->getSymbols->if->symbol->isBytecodeLocal->method->block->getBreakLabel->closeLocalVariable
CodeGenerator#enterBlock(Block)::: code generator enter block:::entryLabel->block->getEntryLabel->if->entryLabel->isBreakTarget->method->lc->getUsedSlotCount->breakLabel->else->method->label->if->method->isReachable->return->if->lc->isFunctionBody->emittedMethods->lc->getCurrentFunction->getName->contains->return->initLocals->return
CodeGenerator#useOptimisticTypes()::: code generator use optimistic types:::return->lc->inSplitLiteral->compiler->useOptimisticTypes
CodeGenerator#leaveBlock(Block)::: code generator leave block:::popBlockScope->method->beforeJoinPoint->closeBlockVariables->lc->releaseSlots->return
CodeGenerator#popBlockScope(Block)::: code generator pop block scope:::breakLabel->block->getBreakLabel->if->block->providesScopeCreator->scopeObjectCreators->pop->if->block->needsScope->lc->isFunctionBody->emitBlockBreakLabel->return->beginTryLabel->scopeEntryLabels->pop->recoveryLabel->new->Label->emitBlockBreakLabel->bodyCanThrow->breakLabel->isAfter->if->method->_try->afterCatchLabel->if->method->isReachable->popScope->if->new->Label->method->_goto->if->method->_catch->popScopeException->method->athrow->if->method->label
CodeGenerator#emitBlockBreakLabel(Label)::: code generator emit block break label:::labelNode->lc->getCurrentBlockLabelNode->if->method->beforeJoinPoint->method->labeledBlockBreakLiveLocals->pop->breakLabel->else->method->label
CodeGenerator#popScope()::: code generator pop scope:::popScopes
CodeGenerator#popScopeException():::Pop scope as part of an exception handler:::popScope->ci->getContinuationInfo->if->catchLabel->if->catchLabels->peek
CodeGenerator#popScopesUntil(LexicalContextNode)::: code generator pop scopes until:::lc->getScopeNestingLevelTo->popScopes
CodeGenerator#popScopes(int)::: code generator pop scopes:::if->return->if->method->hasScope->return->method->loadCompilerConstant->invokeGetProto->method->storeCompilerConstant
CodeGenerator#enterBreakNode(BreakNode)::: code generator enter break node:::return->enterJumpStatement
CodeGenerator#enterJumpToInlinedFinally(JumpToInlinedFinally)::: code generator enter jump to inlined finally:::return->enterJumpStatement
CodeGenerator#enterJumpStatement(JumpStatement)::: code generator enter jump statement:::if->method->isReachable->return->enterStatement->method->beforeJoinPoint->jump->getPopScopeLimit->popScopesUntil->targetLabel->jump->getTargetLabel->targetLabel->markAsBreakTarget->method->_goto->return
CodeGenerator#loadArgs(List)::: code generator load args:::argCount->args->size->if->loadArgsArray->return->foreach->loadExpressionUnbounded->return
CodeGenerator#loadCallNode(CallNode, TypeBounds)::: code generator load call node:::callNode->getLineNumber->lineNumber->args->callNode->getArgs->function->callNode->getFunction->currentBlock->lc->getCurrentBlock->codegenLexicalContext->function->new->SimpleNodeVisitor->accept->return
CodeGenerator#nonOptimisticFlags(int):::Returns the flags with optimistic flag and program point removed.:::return
CodeGenerator#enterContinueNode(ContinueNode)::: code generator enter continue node:::return->enterJumpStatement
CodeGenerator#enterEmptyNode(EmptyNode)::: code generator enter empty node:::return
CodeGenerator#enterExpressionStatement(ExpressionStatement)::: code generator enter expression statement:::if->method->isReachable->return->enterStatement->expressionStatement->getExpression->loadAndDiscard->return
CodeGenerator#enterBlockStatement(BlockStatement)::: code generator enter block statement:::if->method->isReachable->return->enterStatement->blockStatement->getBlock->accept->return
CodeGenerator#enterForNode(ForNode)::: code generator enter for node:::if->method->isReachable->return->enterStatement->if->forNode->isForInOrOf->enterForIn->else->init->forNode->getInit->if->loadAndDiscard->forNode->getModify->enterForOrWhile->return
CodeGenerator#enterForIn(ForNode)::: code generator enter for in:::forNode->getModify->loadExpression->if->forNode->isForEach->method->invoke->else->if->forNode->isForIn->method->invoke->else->if->forNode->isForOf->method->invoke->else->throw->new->IllegalArgumentException->iterSymbol->forNode->getIterator->iterSlot->iterSymbol->getSlot->method->store->method->beforeJoinPoint->continueLabel->forNode->getContinueLabel->breakLabel->forNode->getBreakLabel->method->label->method->load->method->interfaceCallNoLookup->invoke->test->forNode->getTest->body->forNode->getBody->if->LocalVariableConversion->hasLiveConversion->afterConversion->new->Label->method->ifne->method->beforeJoinPoint->method->_goto->method->label->else->method->ifeq->forNode->getInit->new->Store<Expression>->store->body->accept->if->forNode->needsScopeCreator->lc->getCurrentBlock->providesScopeCreator->creator->scopeObjectCreators->peek->creator->createForInIterationScope->method->storeCompilerConstant->if->method->isReachable->method->_goto->method->label
CodeGenerator#initLocals(Block):::Initialize the slots in a frame to undefined.:::lc->onEnterBlock->isFunctionBody->lc->isFunctionBody->function->lc->getCurrentFunction->if->initializeMethodParameters->if->function->isVarArg->expandParameterSlots->if->method->hasScope->if->function->needsParentScope->method->loadCompilerConstant->method->invoke->else->method->loadNull->method->storeCompilerConstant->if->function->needsArguments->initArguments->if->block->needsScope->varsInScope->function->allVarsInScope->hasArguments->function->needsArguments->tuples->new->ArrayList<>->paramIter->function->getParameters->iterator->foreach->block->getSymbols->if->symbol->isInternal->symbol->isThis->continue->if->symbol->isVar->if->symbol->isScope->tuples->symbol->getName->new->MapTuple<Symbol>->add->else->else->if->symbol->isParam->symbol->isScope->paramType->paramSymbol->if->else->for->tuples->symbol->getName->new->MapTuple<Symbol>->add->creator->new->FieldObjectCreator<Symbol>->creator->makeObject->if->block->providesScopeCreator->scopeObjectCreators->push->if->function->isProgram->method->invoke->method->storeCompilerConstant->if->scopeEntryLabel->new->Label->scopeEntryLabels->push->method->label->else->if->function->isVarArg->nextParam->foreach->function->getParameters->param->getSymbol->setFieldIndex->function->getIdent->function->getIdent->getName->printSymbols
CodeGenerator#initializeMethodParameters(FunctionNode):::Incoming method parameters are always declared on method entry; declare them in the local variable table.:::functionStart->new->Label->method->label->nextSlot->if->function->needsCallee->initializeInternalFunctionParameter->initializeInternalFunctionParameter->if->function->isVarArg->initializeInternalFunctionParameter->else->foreach->function->getParameters->symbol->param->getSymbol->if->symbol->isBytecodeLocal->method->param->getType->initializeMethodParameter
CodeGenerator#initializeInternalFunctionParameter(CompilerConstants, FunctionNode, Label, int)::: code generator initialize internal function parameter:::symbol->initializeInternalFunctionOrSplitParameter
CodeGenerator#initializeInternalFunctionOrSplitParameter(CompilerConstants, FunctionNode, Label, int)::: code generator initialize internal function or split parameter:::symbol->fn->getBody->cc->symbolName->getExistingSymbol->type->Type->cc->type->typeFor->method->initializeMethodParameter->method->onLocalStore->return
CodeGenerator#expandParameterSlots(FunctionNode):::Parameters come into the method packed into local variable slots next to each other:::parameters->function->getParameters->currentIncomingSlot->function->needsCallee->foreach->parameter->getType->getSlots->for->i->parameters->size
CodeGenerator#initArguments(FunctionNode)::: code generator init arguments:::method->loadCompilerConstant->if->function->needsCallee->method->loadCompilerConstant->else->method->loadNull->method->function->getParameters->size->load->globalAllocateArguments->method->storeCompilerConstant
CodeGenerator#skipFunction(FunctionNode)::: code generator skip function:::env->compiler->getScriptEnvironment->lazy->onDemand->compiler->isOnDemandCompilation->if->lc->getOutermostFunction->return->return->functionNode->isProgram
CodeGenerator#enterFunctionNode(FunctionNode)::: code generator enter function node:::if->skipFunction->newFunctionObject->return->fnName->functionNode->getName->if->emittedMethods->contains->log->info->lc->functionNode->getCompileUnit->pushCompileUnit->classEmitter->unit->getClassEmitter->isRestOf->classEmitter->restOfMethod->classEmitter->method->pushMethodEmitter->method->setPreventUndefinedLoad->if->useOptimisticTypes->lc->pushUnwarrantedOptimismHandlers->method->begin->if->isRestOf->new->ContinuationInfo->method->continuationInfo->getHandlerLabel->gotoLoopStart->return
CodeGenerator#pushMethodEmitter(MethodEmitter)::: code generator push method emitter:::lc->pushMethodEmitter->catchLabels->push
CodeGenerator#popMethodEmitter()::: code generator pop method emitter:::lc->popMethodEmitter->catchLabels->pop
CodeGenerator#leaveFunctionNode(FunctionNode)::: code generator leave function node:::try->markOptimistic->if->emittedMethods->functionNode->getName->add->generateUnwarrantedOptimismExceptionHandlers->generateContinuationHandler->method->end->lc->functionNode->getCompileUnit->popCompileUnit->popMethodEmitter->log->functionNode->getName->info->else->newFunctionNode->if->newFunctionNode->setFlag->newFunctionObject->return->catch->Context->printStackTrace->e->functionNode->getName->functionNode->getSource->getName->new->VerifyError->e->initCause->throw->finally
CodeGenerator#enterIfNode(IfNode)::: code generator enter if node:::if->method->isReachable->return->enterStatement->test->ifNode->getTest->pass->ifNode->getPass->fail->ifNode->getFail->if->Expression->isAlwaysTrue->loadAndDiscard->pass->accept->return->else->if->Expression->isAlwaysFalse->loadAndDiscard->if->fail->accept->return->hasFailConversion->LocalVariableConversion->hasLiveConversion->failLabel->new->Label->afterLabel->new->Label->emitBranch->pass->accept->if->method->isReachable->method->_goto->method->label->if->fail->accept->else->if->method->beforeJoinPoint->if->afterLabel->isReachable->method->label->return
CodeGenerator#emitBranch(Expression, Label, boolean)::: code generator emit branch:::new->BranchOptimizer->execute
CodeGenerator#enterStatement(Statement)::: code generator enter statement:::lineNumber
CodeGenerator#lineNumber(Statement)::: code generator line number:::statement->getLineNumber->lineNumber
CodeGenerator#lineNumber(int)::: code generator line number:::if->method->lineNumber
CodeGenerator#getLastLineNumber()::: code generator get last line number:::return
CodeGenerator#loadArray(ArrayLiteralNode, ArrayType):::Load a list of nodes as an array of a specific type The array will contain the visited nodes.:::nodes->arrayLiteralNode->getValue->presets->arrayLiteralNode->getPresets->postsets->arrayLiteralNode->getPostsets->ranges->arrayLiteralNode->getSplitRanges->loadConstant->elementType->arrayType->getElementType->if->new->SplitLiteralCreator->loadSplitLiteral->return->if->arraySlot->method->getUsedSlotsWithLiveTemporaries->method->storeTemp->foreach->method->load->storeElement->method->load
CodeGenerator#storeElement(Expression[], Type, int)::: code generator store element:::method->load->element->if->method->loadEmpty->else->loadExpressionAsType->method->arraystore
CodeGenerator#loadArgsArray(List)::: code generator load args array:::array->args->size->new->ObjectArr->loadConstant->for->i->args->size->return
CodeGenerator#loadConstant(String):::Load a constant from the constant array:::unitClassName->unit->getUnitClassName->classEmitter->unit->getClassEmitter->index->compiler->getConstantData->add->method->load->method->GET_STRING->symbolName->methodDescriptor->invokestatic->classEmitter->needGetConstantMethod
CodeGenerator#loadConstant(Object):::Load a constant from the constant array:::loadConstant
CodeGenerator#loadConstant(Object, CompileUnit, MethodEmitter)::: code generator load constant:::unitClassName->compileUnit->getUnitClassName->classEmitter->compileUnit->getClassEmitter->index->compiler->getConstantData->add->cls->object->getClass->if->methodEmitter->load->methodEmitter->GET_MAP->symbolName->methodDescriptor->invokestatic->classEmitter->needGetConstantMethod->else->if->cls->isArray->methodEmitter->load->methodName->ClassEmitter->getArrayMethodName->methodEmitter->methodDescriptor->invokestatic->classEmitter->needGetConstantMethod->else->methodEmitter->loadConstants->load->arrayload->if->methodEmitter->checkcast->methodEmitter->virtualCallNoLookup->invoke->else->if->methodEmitter->checkcast
CodeGenerator#loadConstantsAndIndex(Object, MethodEmitter)::: code generator load constants and index:::methodEmitter->loadConstants->compiler->getConstantData->add->load
CodeGenerator#loadLiteral(LiteralNode, TypeBounds)::: code generator load literal:::value->node->getValue->if->method->loadNull->else->if->method->resultBounds->within->loadUndefined->else->if->string->if->string->length->loadConstant->else->method->load->else->if->loadRegex->else->if->method->load->else->if->if->resultBounds->canBeNarrowerThan->method->load->method->convert->else->if->resultBounds->canBeNarrowerThan->method->doubleValue->load->else->method->load->else->if->if->resultBounds->canBeNarrowerThan->method->load->method->convert->else->method->load->else->if->arrayLiteral->atype->arrayLiteral->getArrayType->loadArray->globalAllocateArray->else->throw->node->getClass->value->getClass->new->UnsupportedOperationException
CodeGenerator#loadRegexToken(RegexToken)::: code generator load regex token:::method->value->getExpression->load->method->value->getOptions->load->return->globalNewRegExp
CodeGenerator#loadRegex(RegexToken)::: code generator load regex:::if->return->loadRegexToken->regexName->lc->getCurrentFunction->REGEX_PREFIX->symbolName->uniqueName->classEmitter->unit->getClassEmitter->classEmitter->EnumSet->of->field->method->unit->getUnitClassName->typeDescriptor->getStatic->method->dup->cachedLabel->new->Label->method->ifnonnull->method->pop->loadRegexToken->method->dup->method->unit->getUnitClassName->typeDescriptor->putStatic->method->label->globalRegExpCopy->return
CodeGenerator#propertyValueContains(Expression, int):::Check if a property value contains a particular program point:::return->new->Supplier<Boolean>->get
CodeGenerator#loadObjectNode(ObjectNode)::: code generator load object node:::elements->objectNode->getElements->tuples->new->ArrayList<>->specialProperties->new->ArrayList<>->ccp->getCurrentContinuationEntryPoint->ranges->objectNode->getSplitRanges->protoNode->restOfProperty->foreach->value->propertyNode->getValue->key->propertyNode->getKeyName->isComputedOrAccessor->propertyNode->isComputed->symbol->new->Symbol->if->specialProperties->add->else->if->propertyNode->getKey->key->equals->continue->isValid->propertyValueContains->valueType->useDualFields->value->getType->isBoolean->value->getType->getTypeClass->tuples->Type->typeFor->new->MapTuple<Expression>->add->oc->if->elements->size->new->SpillObjectCreator->else->new->FieldObjectCreator<Expression>->if->oc->createObject->Type->oc->getAllocatorClass->typeFor->loadSplitLiteral->else->oc->makeObject->if->ci->getContinuationInfo->ci->method->getStackSize->oc->getMap->setObjectLiteralMap->method->dup->if->loadExpressionAsObject->method->convert->method->invoke->else->method->invoke->foreach->method->dup->if->propertyNode->isComputed->propertyNode->getKey->loadExpressionAsObject->else->method->propertyNode->getKey->loadKey->if->propertyNode->getValue->propertyNode->getValue->loadExpressionAsObject->method->load->method->invoke->else->getter->propertyNode->getGetter->setter->propertyNode->getSetter->if->method->loadNull->else->getter->accept->if->method->loadNull->else->setter->accept->method->invoke
CodeGenerator#enterReturnNode(ReturnNode)::: code generator enter return node:::if->method->isReachable->return->enterStatement->returnType->lc->getCurrentFunction->getReturnType->expression->returnNode->getExpression->if->loadExpressionUnbounded->else->method->loadUndefined->method->_return->return
CodeGenerator#undefinedCheck(RuntimeNode, List)::: code generator undefined check:::request->runtimeNode->getRequest->if->Request->isUndefinedCheck->return->lhs->args->get->rhs->args->get->lhsSymbol->getSymbol->rhsSymbol->getSymbol->undefinedSymbol->if->isUndefinedSymbol->else->if->undefinedSymbol->isScope->return->if->lhs->getType->isPrimitive->return->if->containsOptimisticExpression->return->if->compiler->lc->getCurrentFunction->isGlobalSymbol->return->isUndefinedCheck->expr->if->expr->getType->isPrimitive->loadAndDiscard->method->load->else->checkTrue->new->Label->end->new->Label->loadExpressionAsObject->method->loadUndefined->method->if_acmpeq->method->load->method->_goto->method->label->method->load->method->label->return
CodeGenerator#isUndefinedSymbol(Symbol)::: code generator is undefined symbol:::return->symbol->getName->equals
CodeGenerator#isNullLiteral(Node)::: code generator is null literal:::return->isNull
CodeGenerator#nullCheck(RuntimeNode, List)::: code generator null check:::request->runtimeNode->getRequest->if->Request->isEQ->Request->isNE->return->lhs->args->get->rhs->args->get->if->isNullLiteral->tmp->if->isNullLiteral->return->if->lhs->getType->isObject->return->if->containsOptimisticExpression->return->trueLabel->new->Label->falseLabel->new->Label->endLabel->new->Label->loadExpressionUnbounded->popLabel->if->Request->isStrict->method->dup->new->Label->else->if->Request->isEQ->method->Request->isStrict->ifnull->if->Request->isStrict->method->loadUndefined->method->if_acmpeq->method->label->method->load->method->_goto->if->Request->isStrict->method->label->method->pop->method->label->method->load->method->label->else->if->Request->isNE->method->Request->isStrict->ifnull->if->Request->isStrict->method->loadUndefined->method->if_acmpeq->method->label->method->load->method->_goto->if->Request->isStrict->method->label->method->pop->method->label->method->load->method->label->method->runtimeNode->getType->convert->return
CodeGenerator#containsOptimisticExpression(Expression):::Is this expression or any of its subexpressions optimistic? This includes formerly optimistic expressions that have been deoptimized in a subsequent compilation.:::if->useOptimisticTypes->return->return->new->Supplier<Boolean>->get
CodeGenerator#loadRuntimeNode(RuntimeNode)::: code generator load runtime node:::args->runtimeNode->getArgs->new->ArrayList<>->if->nullCheck->return->else->if->undefinedCheck->return->newRuntimeNode->request->runtimeNode->getRequest->if->Request->isUndefinedCheck->runtimeNode->setRequest->else->foreach->loadExpression->method->CompilerConstants->className->newRuntimeNode->getRequest->toString->newRuntimeNode->getType->args->size->new->FunctionSignature->toString->invokestatic->method->newRuntimeNode->getType->convert
CodeGenerator#defineCommonSplitMethodParameters()::: code generator define common split method parameters:::defineSplitMethodParameter->defineSplitMethodParameter->defineSplitMethodParameter
CodeGenerator#defineSplitMethodParameter(int, CompilerConstants)::: code generator define split method parameter:::Type->cc->type->typeFor->defineSplitMethodParameter
CodeGenerator#defineSplitMethodParameter(int, Type)::: code generator define split method parameter:::method->type->getSlots->defineBlockLocalVariable->method->onLocalStore
CodeGenerator#loadSplitLiteral(SplitLiteralCreator, List, Type)::: code generator load split literal:::savedMethod->currentFunction->lc->getCurrentFunction->foreach->lc->splitRange->getCompileUnit->pushCompileUnit->className->unit->getUnitClassName->name->currentFunction->SPLIT_PREFIX->symbolName->uniqueName->clazz->literalType->getTypeClass->signature->methodDescriptor->unit->getClassEmitter->EnumSet->of->method->pushMethodEmitter->method->setFunctionNode->method->begin->defineCommonSplitMethodParameters->slot->defineSplitMethodParameter->literalSlot->fixScopeSlot->lc->enterSplitLiteral->creator->splitRange->getLow->splitRange->getHigh->populateRange->method->_return->lc->exitSplitLiteral->method->end->lc->releaseSlots->popMethodEmitter->method->loadCompilerConstant->swap->method->loadCompilerConstant->swap->method->loadCompilerConstant->swap->method->invokestatic->lc->popCompileUnit
CodeGenerator#fixScopeSlot(FunctionNode, int)::: code generator fix scope slot:::actualScopeSlot->functionNode->compilerConstant->getSlot->defaultScopeSlot->SCOPE->slot->newExtraSlot->if->if->method->defineBlockLocalVariable->method->load->method->storeHidden->else->method->defineBlockLocalVariable->method->load->method->storeCompilerConstant->return
CodeGenerator#enterSplitReturn(SplitReturn)::: code generator enter split return:::if->method->isReachable->method->lc->getCurrentFunction->getReturnType->loadUndefined->_return->return
CodeGenerator#enterSetSplitState(SetSplitState)::: code generator enter set split state:::if->method->isReachable->method->setSplitState->getState->setSplitState->return
CodeGenerator#enterSwitchNode(SwitchNode)::: code generator enter switch node:::if->method->isReachable->return->enterStatement->expression->switchNode->getExpression->cases->switchNode->getCases->if->cases->isEmpty->loadAndDiscard->return->defaultCase->switchNode->getDefaultCase->breakLabel->switchNode->getBreakLabel->liveLocalsOnBreak->method->getUsedSlotsWithLiveTemporaries->if->cases->size->loadAndDiscard->defaultCase->getBody->accept->method->breakLabel->return->defaultLabel->defaultCase->getEntry->hasSkipConversion->LocalVariableConversion->hasLiveConversion->if->switchNode->isUniqueInteger->tree->new->TreeMap<>->foreach->test->caseNode->getTest->if->value->getValue->entry->caseNode->getEntry->if->tree->containsKey->tree->put->size->tree->size->values->tree->keySet->new->IntegerArr->toArray->labels->tree->values->new->LabelArr->toArray->lo->hi->range->deflt->foreach->if->else->if->break->loadExpressionUnbounded->type->expression->getType->if->type->isInteger->method->load->exprClass->type->getTypeClass->method->exprClass->isPrimitive->staticCallNoLookup->invoke->if->new->Label->if->table->new->LabelArr->Arrays->fill->for->i->method->tableswitch->else->ints->new->intArr->for->i->method->lookupswitch->if->method->label->method->beforeJoinPoint->method->_goto->else->tagSymbol->switchNode->getTag->tagSlot->tagSymbol->getSlot->loadExpressionAsObject->method->store->foreach->test->caseNode->getTest->if->method->load->loadExpressionAsObject->method->invoke->method->caseNode->getEntry->ifne->if->method->_goto->else->method->beforeJoinPoint->method->_goto->foreach->fallThroughLabel->if->caseNode->getLocalVariableConversion->method->isReachable->new->Label->method->_goto->else->method->caseNode->getEntry->label->method->beforeJoinPoint->if->method->label->caseNode->getBody->accept->method->breakLabel->return
CodeGenerator#enterThrowNode(ThrowNode)::: code generator enter throw node:::if->method->isReachable->return->enterStatement->if->throwNode->isSyntheticRethrow->method->beforeJoinPoint->exceptionExpr->throwNode->getExpression->exceptionSymbol->exceptionExpr->getSymbol->method->load->method->EXCEPTION_TYPE->getTypeClass->checkcast->method->athrow->return->source->getCurrentSource->expression->throwNode->getExpression->position->throwNode->position->line->throwNode->getLineNumber->column->source->getColumn->loadExpressionAsObject->method->source->getName->load->method->load->method->load->method->invoke->method->beforeJoinPoint->method->athrow->return
CodeGenerator#getCurrentSource()::: code generator get current source:::return->lc->getCurrentFunction->getSource
CodeGenerator#enterTryNode(TryNode)::: code generator enter try node:::if->method->isReachable->return->enterStatement->body->tryNode->getBody->catchBlocks->tryNode->getCatchBlocks->vmException->tryNode->getException->entry->new->Label->recovery->new->Label->exit->new->Label->skip->new->Label->method->canThrow->method->beforeTry->method->label->catchLabels->push->try->body->accept->catch->finally->catchLabels->pop->method->label->bodyCanThrow->exit->isAfter->if->return->method->_try->if->method->isReachable->method->_goto->foreach->tryNode->getInlinedFinallies->TryNode->getLabelledInlinedFinallyBlock->accept->method->_catch->method->store->catchBlockCount->catchBlocks->size->afterCatch->new->Label->for->i->method->label->if->method->isReachable->method->markDeadLocalVariable->method->label->return
CodeGenerator#enterVarNode(VarNode)::: code generator enter var node:::if->method->isReachable->return->init->varNode->getInit->identNode->varNode->getName->identSymbol->identNode->getSymbol->needsScope->identSymbol->isScope->if->if->varNode->isLet->method->loadCompilerConstant->method->loadUndefined->flags->getScopeCallSiteFlags->storeFastScopeVar->return->enterStatement->if->method->loadCompilerConstant->loadExpressionUnbounded->flags->getScopeCallSiteFlags->varNode->isBlockScoped->if->isFastScope->storeFastScopeVar->else->method->identNode->getName->dynamicSet->else->identType->identNode->getType->if->loadAndDiscard->return->loadExpressionAsType->storeIdentWithCatchConversion->return
CodeGenerator#storeIdentWithCatchConversion(IdentNode, Type)::: code generator store ident with catch conversion:::conversion->identNode->getLocalVariableConversion->symbol->identNode->getSymbol->if->conversion->isLive->catchLabel->catchLabels->peek->joinType->conversion->getTo->catchStack->catchLabel->getStack->joinSlot->symbol->getSlot->if->catchStack->getUsedSlotsWithLiveTemporaries->method->dup->method->convert->method->store->catchLabel->getStack->onLocalStore->method->canThrow->method->store->return->method->store
CodeGenerator#enterWhileNode(WhileNode)::: code generator enter while node:::if->method->isReachable->return->if->whileNode->isDoWhile->enterDoWhile->else->enterStatement->enterForOrWhile->return
CodeGenerator#enterForOrWhile(LoopNode, JoinPredecessorExpression)::: code generator enter for or while:::liveLocalsOnBreak->method->getUsedSlotsWithLiveTemporaries->test->loopNode->getTest->if->Expression->isAlwaysFalse->loadAndDiscard->return->method->beforeJoinPoint->continueLabel->loopNode->getContinueLabel->repeatLabel->new->Label->method->label->liveLocalsOnContinue->method->getUsedSlotsWithLiveTemporaries->body->loopNode->getBody->breakLabel->loopNode->getBreakLabel->testHasLiveConversion->LocalVariableConversion->hasLiveConversion->if->Expression->isAlwaysTrue->if->loadAndDiscard->if->method->beforeJoinPoint->else->if->if->test->getExpression->body->getEntryLabel->emitBranch->method->beforeJoinPoint->method->_goto->else->test->getExpression->emitBranch->body->accept->if->emitContinueLabel->if->loopNode->hasPerIterationScope->lc->getCurrentBlock->needsScope->method->loadCompilerConstant->method->virtualCallNoLookup->invoke->method->storeCompilerConstant->if->method->isReachable->if->lineNumber->loadAndDiscard->method->beforeJoinPoint->method->_goto->method->breakLabel
CodeGenerator#emitContinueLabel(Label, int)::: code generator emit continue label:::reachable->method->isReachable->method->breakLabel->if->method->lc->getUsedSlotCount->undefineLocalVariables
CodeGenerator#enterDoWhile(WhileNode)::: code generator enter do while:::liveLocalsOnContinueOrBreak->method->getUsedSlotsWithLiveTemporaries->method->beforeJoinPoint->body->whileNode->getBody->body->accept->whileNode->getContinueLabel->emitContinueLabel->if->method->isReachable->lineNumber->test->whileNode->getTest->bodyEntryLabel->body->getEntryLabel->testHasLiveConversion->LocalVariableConversion->hasLiveConversion->if->Expression->isAlwaysFalse->loadAndDiscard->if->method->beforeJoinPoint->else->if->beforeExit->new->Label->test->getExpression->emitBranch->method->beforeJoinPoint->method->_goto->method->label->method->beforeJoinPoint->else->test->getExpression->emitBranch->method->whileNode->getBreakLabel->breakLabel
CodeGenerator#enterWithNode(WithNode)::: code generator enter with node:::if->method->isReachable->return->enterStatement->expression->withNode->getExpression->body->withNode->getBody->hasScope->method->hasScope->if->method->loadCompilerConstant->loadExpressionAsObject->tryLabel->if->method->invoke->method->storeCompilerConstant->new->Label->method->label->else->globalCheckObjectCoercible->body->accept->if->endLabel->new->Label->catchLabel->new->Label->exitLabel->new->Label->method->label->bodyCanThrow->endLabel->isAfter->if->method->_try->reachable->method->isReachable->if->popScope->if->method->_goto->if->method->_catch->popScopeException->method->athrow->if->method->label->return
CodeGenerator#loadADD(UnaryNode, TypeBounds)::: code generator load d:::unaryNode->getExpression->resultBounds->booleanToInt->notWiderThan->loadExpression->if->method->peekType->method->convert
CodeGenerator#loadBIT_NOT(UnaryNode)::: code generator load t_ t:::unaryNode->getExpression->loadExpression->load->xor
CodeGenerator#loadDECINC(UnaryNode)::: code generator load c:::operand->unaryNode->getExpression->type->unaryNode->getType->typeBounds->new->TypeBounds->tokenType->unaryNode->tokenType->isPostfix->isIncrement->new->SelfModifyingStore<UnaryNode>->store
CodeGenerator#getOptimisticIgnoreCountForSelfModifyingExpression(Expression)::: code generator get optimistic ignore count for self modifying expression:::return
CodeGenerator#loadAndDiscard(Expression)::: code generator load and discard:::if->isLocalVariable->return->lc->pushDiscard->loadExpression->if->lc->popDiscardIfCurrent->method->pop
CodeGenerator#loadMaybeDiscard(Expression, Expression, TypeBounds):::Loads the expression with the specified type bounds, but if the parent expression is the current discard, then instead loads and discards the expression.:::lc->popDiscardIfCurrent->loadMaybeDiscard
CodeGenerator#loadMaybeDiscard(boolean, Expression, TypeBounds):::Loads the expression with the specified type bounds, or loads and discards the expression, depending on the value of the discard flag:::if->loadAndDiscard->else->loadExpression
CodeGenerator#loadNEW(UnaryNode)::: code generator load w:::callNode->unaryNode->getExpression->args->callNode->getArgs->func->callNode->getFunction->loadExpressionAsObject->method->loadArgs->getCallSiteFlags->func->toString->dynamicNew
CodeGenerator#loadNOT(UnaryNode)::: code generator load t:::expr->unaryNode->getExpression->if->expr->isTokenType->getExpression->loadExpressionAsBoolean->else->trueLabel->new->Label->afterLabel->new->Label->emitBranch->method->load->method->_goto->method->label->method->load->method->label
CodeGenerator#loadSUB(UnaryNode, TypeBounds)::: code generator load b:::type->unaryNode->getType->numericBounds->resultBounds->booleanToInt->new->OptimisticOperation->emit
CodeGenerator#loadVOID(UnaryNode, TypeBounds)::: code generator load d:::unaryNode->getExpression->loadAndDiscard->if->lc->popDiscardIfCurrent->method->loadUndefined
CodeGenerator#loadDELETE(UnaryNode)::: code generator load e:::expression->unaryNode->getExpression->if->ident->symbol->ident->getSymbol->name->ident->getName->if->symbol->isThis->if->lc->popDiscardIfCurrent->method->load->else->if->lc->getCurrentFunction->isStrict->method->load->method->invoke->else->if->symbol->isScope->symbol->isParam->symbol->isVar->symbol->isProgramLevel->if->lc->popDiscardIfCurrent->method->load->else->method->loadCompilerConstant->method->load->if->symbol->isGlobal->symbol->isFunctionDeclaration->symbol->isProgramLevel->method->invoke->else->method->load->method->invoke->else->if->getBase->loadExpressionAsObject->if->accessNode->method->accessNode->getProperty->getCallSiteFlags->accessNode->isIndex->dynamicRemove->else->if->getIndex->loadExpressionAsObject->method->getCallSiteFlags->dynamicRemoveIndex->else->throw->expression->getClass->getName->new->AssertionError->else->throw->expression->getClass->getName->new->AssertionError
CodeGenerator#loadADD(BinaryNode, TypeBounds)::: code generator load d:::new->OptimisticOperation->emit
CodeGenerator#loadAND_OR(BinaryNode, TypeBounds, boolean)::: code generator load d_ r:::narrowestOperandType->Type->binaryNode->lhs->getType->binaryNode->rhs->getType->widestReturnType->isCurrentDiscard->lc->popDiscardIfCurrent->skip->new->Label->if->onTrue->new->Label->emitBranch->if->method->label->else->method->load->method->_goto->method->label->method->load->method->label->return->outBounds->resultBounds->notNarrowerThan->lhs->binaryNode->lhs->lhsConvert->LocalVariableConversion->hasLiveConversion->evalRhs->new->Label->loadExpression->if->method->dup->method->convert->if->if->method->ifne->else->method->ifeq->else->if->method->ifeq->else->method->ifne->if->method->beforeJoinPoint->method->_goto->method->label->if->method->pop->rhs->binaryNode->rhs->loadMaybeDiscard->method->beforeJoinPoint->method->label
CodeGenerator#isLocalVariable(Expression)::: code generator is local variable:::return->isLocalVariable
CodeGenerator#isLocalVariable(IdentNode)::: code generator is local variable:::return->lhs->getSymbol->isBytecodeLocal
CodeGenerator#loadASSIGN(BinaryNode)::: code generator load n:::lhs->binaryNode->lhs->rhs->binaryNode->rhs->rhsType->rhs->getType->if->symbol->getSymbol->if->symbol->isScope->symbol->hasSlotFor->lc->popDiscardIfCurrent->loadAndDiscard->method->markDeadLocalVariable->return->new->Store<BinaryNode>->store
CodeGenerator.BinaryOptimisticSelfAssignment#op(OptimisticOperation)::: binary optimistic self assignment op:::
CodeGenerator.BinaryOptimisticSelfAssignment#evaluate()::: binary optimistic self assignment evaluate:::lhs->assignNode->lhs->rhs->assignNode->rhs->widestOperationType->assignNode->getWidestOperationType->bounds->assignNode->getType->new->TypeBounds->new->OptimisticOperation->getOptimisticIgnoreCountForSelfModifyingExpression->emit->method->assignNode->getType->convert
CodeGenerator.BinarySelfAssignment#op()::: binary self assignment op:::
CodeGenerator.BinarySelfAssignment#evaluate()::: binary self assignment evaluate:::assignNode->lhs->assignNode->rhs->assignNode->getWidestOperandType->notWiderThan->loadBinaryOperands->op
CodeGenerator#loadASSIGN_ADD(BinaryNode)::: code generator load n_ d:::new->BinaryOptimisticSelfAssignment->store
CodeGenerator#loadASSIGN_BIT_AND(BinaryNode)::: code generator load n_ t_ d:::new->BinarySelfAssignment->store
CodeGenerator#loadASSIGN_BIT_OR(BinaryNode)::: code generator load n_ t_ r:::new->BinarySelfAssignment->store
CodeGenerator#loadASSIGN_BIT_XOR(BinaryNode)::: code generator load n_ t_ r:::new->BinarySelfAssignment->store
CodeGenerator#loadASSIGN_DIV(BinaryNode)::: code generator load n_ v:::new->BinaryOptimisticSelfAssignment->store
CodeGenerator#loadASSIGN_MOD(BinaryNode)::: code generator load n_ d:::new->BinaryOptimisticSelfAssignment->store
CodeGenerator#loadASSIGN_MUL(BinaryNode)::: code generator load n_ l:::new->BinaryOptimisticSelfAssignment->store
CodeGenerator#loadASSIGN_SAR(BinaryNode)::: code generator load n_ r:::new->BinarySelfAssignment->store
CodeGenerator#loadASSIGN_SHL(BinaryNode)::: code generator load n_ l:::new->BinarySelfAssignment->store
CodeGenerator#loadASSIGN_SHR(BinaryNode)::: code generator load n_ r:::binaryNode->lhs->new->SelfModifyingStore<BinaryNode>->store
CodeGenerator#doSHR(BinaryNode)::: code generator do r:::new->TypeBounds->new->OptimisticOperation->emit
CodeGenerator#toUint32Optimistic(int)::: code generator to uint32 optimistic:::method->load->invoke
CodeGenerator#toUint32Double()::: code generator to uint32 double:::invoke
CodeGenerator#loadASSIGN_SUB(BinaryNode)::: code generator load n_ b:::new->BinaryOptimisticSelfAssignment->store
CodeGenerator.BinaryArith#op(int)::: binary arith op:::
CodeGenerator.BinaryArith#evaluate(BinaryNode, TypeBounds)::: binary arith evaluate:::numericBounds->resultBounds->booleanToInt->objectToNumber->new->OptimisticOperation->emit
CodeGenerator#loadBIT_AND(BinaryNode)::: code generator load t_ d:::loadBinaryOperands->method->and
CodeGenerator#loadBIT_OR(BinaryNode)::: code generator load t_ r:::if->isRhsZero->binaryNode->lhs->loadExpressionAsType->else->loadBinaryOperands->method->or
CodeGenerator#isRhsZero(BinaryNode)::: code generator is rhs zero:::rhs->binaryNode->rhs->return->INT_ZERO->getValue->equals
CodeGenerator#loadBIT_XOR(BinaryNode)::: code generator load t_ r:::loadBinaryOperands->method->xor
CodeGenerator#loadCOMMARIGHT(BinaryNode, TypeBounds)::: code generator load t:::binaryNode->lhs->loadAndDiscard->binaryNode->rhs->loadMaybeDiscard
CodeGenerator#loadDIV(BinaryNode, TypeBounds)::: code generator load v:::new->BinaryArith->evaluate
CodeGenerator#loadCmp(BinaryNode, Condition)::: code generator load cmp:::loadComparisonOperands->trueLabel->new->Label->afterLabel->new->Label->method->conditionalJump->method->load->method->_goto->method->label->method->load->method->label
CodeGenerator#loadMOD(BinaryNode, TypeBounds)::: code generator load d:::new->BinaryArith->evaluate
CodeGenerator#loadMUL(BinaryNode, TypeBounds)::: code generator load l:::new->BinaryArith->evaluate
CodeGenerator#loadSAR(BinaryNode)::: code generator load r:::loadBinaryOperands->method->sar
CodeGenerator#loadSHL(BinaryNode)::: code generator load l:::loadBinaryOperands->method->shl
CodeGenerator#loadSHR(BinaryNode)::: code generator load r:::doSHR
CodeGenerator#loadSUB(BinaryNode, TypeBounds)::: code generator load b:::new->BinaryArith->evaluate
CodeGenerator#enterLabelNode(LabelNode)::: code generator enter label node:::labeledBlockBreakLiveLocals->lc->getUsedSlotCount->push->return
CodeGenerator#enterDefault(Node)::: code generator enter default:::throw->node->getClass->getName->new->AssertionError
CodeGenerator#loadTernaryNode(TernaryNode, TypeBounds)::: code generator load ternary node:::test->ternaryNode->getTest->trueExpr->ternaryNode->getTrueExpression->falseExpr->ternaryNode->getFalseExpression->falseLabel->new->Label->exitLabel->new->Label->outNarrowest->Type->Type->Type->trueExpr->getType->falseExpr->getType->widestReturnType->generic->narrowest->outBounds->resultBounds->notNarrowerThan->emitBranch->isCurrentDiscard->lc->popDiscardIfCurrent->trueExpr->getExpression->loadMaybeDiscard->method->beforeJoinPoint->method->_goto->method->label->falseExpr->getExpression->loadMaybeDiscard->method->beforeJoinPoint->method->label
CodeGenerator#generateScopeCalls():::Generate all shared scope calls generated during codegen.:::foreach->lc->getScopeCalls->scopeAccess->generateScopeCall
CodeGenerator#printSymbols(Block, FunctionNode, String):::Debug code used to print symbols:::if->compiler->getScriptEnvironment->function->getDebugFlag->out->compiler->getScriptEnvironment->getErr->out->println->if->block->printSymbols->out->println->out->println
CodeGenerator.SelfModifyingStore#isSelfModifying()::: self modifying store is self modifying:::return
CodeGenerator.Store#isSelfModifying():::Is this a self modifying store operation, e.g:::return
CodeGenerator.Store#prologue()::: store prologue:::target->new->SimpleNodeVisitor->accept
CodeGenerator.Store#quickLocalVariable(Type):::Generates an extra local variable, always using the same slot, one that is available after the end of the frame.:::name->lc->getCurrentFunction->QUICK_PREFIX->symbolName->uniqueName->symbol->new->Symbol->symbol->setHasSlotFor->symbol->lc->quickSlot->setFirstSlot->quickIdent->IdentNode->createInternalIdentifier->setType->return
CodeGenerator.Store#storeNonDiscard()::: store store non discard:::if->lc->popDiscardIfCurrent->return->if->method->dup->method->dup->quickType->method->peekType->quickLocalVariable->quickSymbol->quick->getSymbol->method->quickSymbol->getFirstSlot->storeTemp
CodeGenerator.Store#epilogue()::: store epilogue:::target->new->SimpleNodeVisitor->accept
CodeGenerator.Store#evaluate()::: store evaluate:::
CodeGenerator.Store#store()::: store store:::if->checkTemporalDeadZone->prologue->evaluate->storeNonDiscard->epilogue->if->method->load
CodeGenerator#newFunctionObject(FunctionNode, boolean)::: code generator new function object:::data->compiler->functionNode->getId->getScriptFunctionData->if->functionNode->isProgram->compiler->isOnDemandCompilation->createFunction->functionNode->getCompileUnit->getClassEmitter->EnumSet->of->CREATE_PROGRAM_FUNCTION->symbolName->method->createFunction->begin->loadConstantsAndIndex->createFunction->load->createFunction->invoke->createFunction->_return->createFunction->end->if->compiler->isOnDemandCompilation->functionNode->getCompileUnit->addFunctionInitializer->if->lc->getOutermostFunction->return->loadConstantsAndIndex->if->functionNode->needsParentScope->method->loadCompilerConstant->method->invoke->else->method->invoke
CodeGenerator#globalInstance()::: code generator global instance:::return->method->invokestatic
CodeGenerator#globalAllocateArguments()::: code generator global allocate arguments:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalNewRegExp()::: code generator global new reg exp:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalRegExpCopy()::: code generator global reg exp copy:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalAllocateArray(ArrayType)::: code generator global allocate array:::return->method->type->getDescriptor->invokestatic
CodeGenerator#globalIsEval()::: code generator global is eval:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalReplaceLocationPropertyPlaceholder()::: code generator global replace location property placeholder:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalCheckObjectCoercible()::: code generator global check object coercible:::return->method->methodDescriptor->invokestatic
CodeGenerator#globalDirectEval()::: code generator global direct eval:::return->method->methodDescriptor->invokestatic
CodeGenerator.OptimisticOperation#emit()::: optimistic operation emit:::return->emit
CodeGenerator.OptimisticOperation#emit(int)::: optimistic operation emit:::programPoint->optimistic->getProgramPoint->optimisticOrContinuation->isContinuationEntryPoint->currentContinuationEntryPoint->isCurrentContinuationEntryPoint->stackSizeOnEntry->method->getStackSize->storeStack->loadStack->liveLocalsCount->method->getStackSize->storeStack->beginTry->catchLabel->afterConsumeStack->new->Label->if->new->Label->catchLabelName->afterConsumeStack->toString->new->Label->method->label->else->consumeStack->if->method->_try->if->method->label->localLoads->method->getLocalLoadsOnStack->localTypesList->method->getLocalVariableTypes->usedLocals->method->getUsedSlotsWithLiveTemporaries->localTypes->method->localTypesList->subList->getWidestLiveLocals->if->addUnwarrantedOptimismHandlerLabel->if->ci->getContinuationInfo->ci->setTargetLabel->ci->getHandlerLabel->markAsOptimisticContinuationHandlerFor->localTypes->size->ci->setStackStoreSpec->ci->Arrays->method->method->getStackSize->getTypesFromStack->copyOf->setStackTypes->ci->method->peekType->setReturnValueType->getLastLineNumber->catchLabels->peek->return
CodeGenerator.OptimisticOperation#storeStack(int, boolean):::Stores the current contents of the stack into local variables so they are not lost before invoking something that can result in an UnwarantedOptimizationException.:::if->return->stackSize->method->getStackSize->stackTypes->method->getTypesFromStack->localLoadsOnStack->method->getLocalLoadsOnStack->usedSlots->method->getUsedSlotsWithLiveTemporaries->firstIgnored->firstNonLoad->while->if->return->tempSlotsNeeded->for->i->lastTempSlot->ignoreSlotCount->for->i->localTypesList->method->getLocalVariableTypes->for->i->return
CodeGenerator.OptimisticOperation#addUnwarrantedOptimismHandlerLabel(List, Label)::: optimistic operation add unwarranted optimism handler label:::lvarTypesDescriptor->getLvarTypesDescriptor->unwarrantedOptimismHandlers->lc->getUnwarrantedOptimismHandlers->labels->unwarrantedOptimismHandlers->get->if->new->LinkedList<>->unwarrantedOptimismHandlers->put->method->localTypes->size->markLabelAsOptimisticCatchHandler->labels->add
CodeGenerator.OptimisticOperation#loadStack()::: optimistic operation load stack:::
CodeGenerator.OptimisticOperation#consumeStack()::: optimistic operation consume stack:::
CodeGenerator.OptimisticOperation#dynamicGet(String, int, boolean, boolean):::Emits the correct dynamic getter code:::if->return->method->getOptimisticCoercedType->getOptimisticFlags->dynamicGet->return->method->resultBounds->expression->getType->within->nonOptimisticFlags->dynamicGet
CodeGenerator.OptimisticOperation#dynamicGetIndex(int, boolean)::: optimistic operation dynamic get index:::if->return->method->getOptimisticCoercedType->getOptimisticFlags->dynamicGetIndex->return->method->resultBounds->expression->getType->within->nonOptimisticFlags->dynamicGetIndex
CodeGenerator.OptimisticOperation#dynamicCall(int, int, String)::: optimistic operation dynamic call:::if->return->method->getOptimisticCoercedType->getOptimisticFlags->dynamicCall->return->method->resultBounds->expression->getType->within->nonOptimisticFlags->dynamicCall
CodeGenerator.OptimisticOperation#getOptimisticFlags(int)::: optimistic operation get optimistic flags:::return->optimistic->getProgramPoint
CodeGenerator.OptimisticOperation#getProgramPoint()::: optimistic operation get program point:::return->optimistic->getProgramPoint
CodeGenerator.OptimisticOperation#convertOptimisticReturnValue()::: optimistic operation convert optimistic return value:::if->optimisticType->getOptimisticCoercedType->if->optimisticType->isObject->method->optimistic->getProgramPoint->load->if->optimisticType->isInteger->method->invoke->else->if->optimisticType->isNumber->method->invoke->else->throw->new->AssertionError
CodeGenerator.OptimisticOperation#replaceCompileTimeProperty()::: optimistic operation replace compile time property:::identNode->name->identNode->getSymbol->getName->if->name->equals->getCurrentSource->getName->replaceCompileTimeProperty->else->if->name->equals->getCurrentSource->getBase->replaceCompileTimeProperty->else->if->name->equals->getCurrentSource->identNode->position->getLine->replaceCompileTimeProperty
CodeGenerator.OptimisticOperation#replaceCompileTimeProperty(Object):::When an ident with name __FILE__, __DIR__, or __LINE__ is loaded, we'll try to look it up as any other identifier:::if->method->load->else->if->method->load->method->convert->else->throw->new->AssertionError->globalReplaceLocationPropertyPlaceholder->convertOptimisticReturnValue
CodeGenerator.OptimisticOperation#getOptimisticCoercedType():::Returns the type that should be used as the return type of the dynamic invocation that is emitted as the code for the current optimistic operation:::optimisticType->expression->getType->narrowest->if->narrowest->isBoolean->narrowest->narrowerThan->return->return
CodeGenerator#isOptimistic(Optimistic)::: code generator is optimistic:::if->optimistic->canBeOptimistic->return->expr->return->expr->getType->expr->getWidestOperationType->narrowerThan
CodeGenerator#everyLocalLoadIsValid(int[], int)::: code generator every local load is valid:::foreach->if->return->return
CodeGenerator#everyStackValueIsLocalLoad(int[])::: code generator every stack value is local load:::foreach->if->return->return
CodeGenerator#getLvarTypesDescriptor(List)::: code generator get lvar types descriptor:::count->localVarTypes->size->desc->new->StringBuilder->for->i->return->method->desc->toString->markSymbolBoundariesInLvarTypesDescriptor
CodeGenerator#appendType(StringBuilder, Type)::: code generator append type:::b->t->getBytecodeStackType->append->return->t->getSlots
CodeGenerator#countSymbolsInLvarTypeDescriptor(String)::: code generator count symbols in lvar type descriptor:::count->for->i->lvarTypeDescriptor->length->return
CodeGenerator#generateUnwarrantedOptimismExceptionHandlers(FunctionNode):::Generates all the required UnwarrantedOptimismException handlers for the current function:::if->useOptimisticTypes->return->unwarrantedOptimismHandlers->lc->popUnwarrantedOptimismHandlers->if->unwarrantedOptimismHandlers->isEmpty->return->method->lineNumber->handlerSpecs->unwarrantedOptimismHandlers->size->new->ArrayList<>->foreach->unwarrantedOptimismHandlers->keySet->handlerSpecs->new->OptimismExceptionHandlerSpec->add->Collections->Collections->reverseOrder->sort->delegationLabels->new->HashMap<>->for->handlerIndex->handlerSpecs->size->return
CodeGenerator#getByteCodeSymbolNames(FunctionNode)::: code generator get byte code symbol names:::names->new->ArrayList<>->foreach->fn->getBody->getSymbols->if->symbol->hasSlot->if->symbol->isScope->names->add->else->names->symbol->getName->add->return->names->new->StringArr->toArray
CodeGenerator#commonPrefix(String, String)::: code generator common prefix:::l1->s1->length->l->Math->s2->length->min->lms->for->i->return
CodeGenerator.OptimismExceptionHandlerSpec#compareTo(OptimismExceptionHandlerSpec)::: optimism exception handler spec compare to:::return->lvarSpec->compareTo
CodeGenerator.OptimismExceptionHandlerSpec#toString()::: optimism exception handler spec to string:::b->new->StringBuilder->append->append->if->b->append->if->b->append->return->b->append->toString
CodeGenerator.ContinuationInfo#getHandlerLabel()::: continuation info get handler label:::return
CodeGenerator.ContinuationInfo#hasTargetLabel()::: continuation info has target label:::return
CodeGenerator.ContinuationInfo#getTargetLabel()::: continuation info get target label:::return
CodeGenerator.ContinuationInfo#setTargetLabel(Label)::: continuation info set target label:::
CodeGenerator.ContinuationInfo#getStackStoreSpec()::: continuation info get stack store spec:::return->stackStoreSpec->clone
CodeGenerator.ContinuationInfo#setStackStoreSpec(int[])::: continuation info set stack store spec:::
CodeGenerator.ContinuationInfo#getStackTypes()::: continuation info get stack types:::return->stackTypes->clone
CodeGenerator.ContinuationInfo#setStackTypes(Type[])::: continuation info set stack types:::
CodeGenerator.ContinuationInfo#getReturnValueType()::: continuation info get return value type:::return
CodeGenerator.ContinuationInfo#setReturnValueType(Type)::: continuation info set return value type:::
CodeGenerator.ContinuationInfo#setObjectLiteralMap(int, PropertyMap)::: continuation info set object literal map:::if->new->HashMap<>->objectLiteralMaps->put
CodeGenerator.ContinuationInfo#getObjectLiteralMap(int)::: continuation info get object literal map:::return->objectLiteralMaps->get
CodeGenerator.ContinuationInfo#toString()::: continuation info to string:::return->targetLabel->getStack->getLocalVariableTypesCopy->Arrays->toString
CodeGenerator#getContinuationInfo()::: code generator get continuation info:::return
CodeGenerator#generateContinuationHandler()::: code generator generate continuation handler:::if->isRestOf->return->ci->getContinuationInfo->method->ci->getHandlerLabel->label->method->lineNumber->stack->ci->getTargetLabel->getStack->lvarTypes->stack->getLocalVariableTypesCopy->symbolBoundary->stack->getSymbolBoundaryCopy->lvarCount->rewriteExceptionType->Type->typeFor->method->load->method->storeTemp->method->load->method->invoke->arrayIndex->for->lvarIndex->if->AssertsEnabled->assertsEnabled->method->load->method->invoke->else->method->pop->stackStoreSpec->ci->getStackStoreSpec->stackTypes->ci->getStackTypes->isStackEmpty->replacedObjectLiteralMaps->if->for->i->method->load->method->loadNull->method->storeHidden->method->getSlots->markDeadSlots->method->invoke->returnValueType->ci->getReturnValueType->needsCatch->targetCatchLabel->_try->if->returnValueType->isPrimitive->method->lineNumber->if->new->Label->method->label->method->convert->scopePopCount->catchLabel->new->Label->if->_end_try->new->Label->method->label->method->_try->method->ci->getTargetLabel->_goto->if->method->lineNumber->method->_catch->popScopes->method->uncheckedGoto
CodeGenerator.SplitLiteralCreator#populateRange(MethodEmitter, Type, int, int, int):::Generate code to populate a range of the literal object:::
CodeGeneratorLexicalContext#isWithBoundary(Object)::: code generator lexical context is with boundary:::return->isEmpty->peek
CodeGeneratorLexicalContext#push(T)::: code generator lexical context push:::if->isWithBoundary->else->if->if->inDynamicContext->splitLiterals->push->return->super->push
CodeGeneratorLexicalContext#enterSplitLiteral()::: code generator lexical context enter split literal:::splitLiterals->getAndIncrement->methodEmitters->peek->getUsedSlotsWithLiveTemporaries->pushFreeSlots
CodeGeneratorLexicalContext#exitSplitLiteral()::: code generator lexical context exit split literal:::count->splitLiterals->decrementAndGet
CodeGeneratorLexicalContext#pop(T)::: code generator lexical context pop:::popped->super->pop->if->isWithBoundary->else->if->if->inDynamicContext->splitLiterals->pop->return
CodeGeneratorLexicalContext#inDynamicScope()::: code generator lexical context in dynamic scope:::return
CodeGeneratorLexicalContext#inSplitLiteral()::: code generator lexical context in split literal:::return->splitLiterals->isEmpty->splitLiterals->peek
CodeGeneratorLexicalContext#pushMethodEmitter(MethodEmitter)::: code generator lexical context push method emitter:::methodEmitters->push->return
CodeGeneratorLexicalContext#popMethodEmitter(MethodEmitter)::: code generator lexical context pop method emitter:::methodEmitters->pop->return->methodEmitters->isEmpty->methodEmitters->peek
CodeGeneratorLexicalContext#pushUnwarrantedOptimismHandlers()::: code generator lexical context push unwarranted optimism handlers:::unwarrantedOptimismHandlers->new->HashMap<String,Collection<Label>>->push->slotTypesDescriptors->new->StringBuilder->push
CodeGeneratorLexicalContext#getUnwarrantedOptimismHandlers()::: code generator lexical context get unwarranted optimism handlers:::return->unwarrantedOptimismHandlers->peek
CodeGeneratorLexicalContext#popUnwarrantedOptimismHandlers()::: code generator lexical context pop unwarranted optimism handlers:::slotTypesDescriptors->pop->return->unwarrantedOptimismHandlers->pop
CodeGeneratorLexicalContext#pushCompileUnit(CompileUnit)::: code generator lexical context push compile unit:::compileUnits->push->return
CodeGeneratorLexicalContext#popCompileUnit(CompileUnit)::: code generator lexical context pop compile unit:::unit->compileUnits->pop->unit->setUsed->return->compileUnits->isEmpty->compileUnits->peek
CodeGeneratorLexicalContext#hasCompileUnits()::: code generator lexical context has compile units:::return->compileUnits->isEmpty
CodeGeneratorLexicalContext#getScopeCalls()::: code generator lexical context get scope calls:::return->Collections->scopeCalls->values->unmodifiableCollection
CodeGeneratorLexicalContext#getScopeCall(CompileUnit, Symbol, Type, Type, Type[], int, boolean):::Get a shared static method representing a dynamic scope callsite.:::scopeCall->new->SharedScopeCall->if->scopeCalls->containsKey->return->scopeCalls->get->scopeCall->getCurrentFunction->uniqueName->setClassAndName->scopeCalls->put->return
CodeGeneratorLexicalContext#getScopeGet(CompileUnit, Symbol, Type, int, boolean):::Get a shared static method representing a dynamic scope get access.:::return->getScopeCall
CodeGeneratorLexicalContext#onEnterBlock(Block)::: code generator lexical context on enter block:::isFunctionBody->getUsedSlotCount->assignSlots->pushFreeSlots
CodeGeneratorLexicalContext#pushFreeSlots(int)::: code generator lexical context push free slots:::if->newNextFreeSlots->new->intArr->System->arraycopy
CodeGeneratorLexicalContext#getUsedSlotCount()::: code generator lexical context get used slot count:::return
CodeGeneratorLexicalContext#releaseSlots()::: code generator lexical context release slots:::undefinedFromSlot->if->slotTypesDescriptors->isEmpty->slotTypesDescriptors->peek->setLength->methodEmitters->peek->undefineLocalVariables
CodeGeneratorLexicalContext#assignSlots(Block, int)::: code generator lexical context assign slots:::fromSlot->method->methodEmitters->peek->foreach->block->getSymbols->if->symbol->hasSlot->symbol->setFirstSlot->toSlot->symbol->slotCount->method->defineBlockLocalVariable->return
CodeGeneratorLexicalContext#getTypeForSlotDescriptor(char)::: code generator lexical context get type for slot descriptor:::switch->return->return->return->return->return->throw->new->AssertionError
CodeGeneratorLexicalContext#pushDiscard(Expression)::: code generator lexical context push discard:::discard->push
CodeGeneratorLexicalContext#popDiscardIfCurrent(Expression)::: code generator lexical context pop discard if current:::if->isCurrentDiscard->discard->pop->return->return
CodeGeneratorLexicalContext#isCurrentDiscard(Expression)::: code generator lexical context is current discard:::return->discard->peek
CodeGeneratorLexicalContext#quickSlot(Type)::: code generator lexical context quick slot:::return->methodEmitters->peek->type->getSlots->defineTemporaryLocalVariable
CompilationPhase.ConstantFoldingPhase#transform(Compiler, CompilationPhases, FunctionNode)::: constant folding phase transform:::return->new->FoldConstants->transformFunction
CompilationPhase.ConstantFoldingPhase#toString()::: constant folding phase to string:::return
CompilationPhase.LoweringPhase#transform(Compiler, CompilationPhases, FunctionNode)::: lowering phase transform:::return->new->Lower->transformFunction
CompilationPhase.LoweringPhase#toString()::: lowering phase to string:::return
CompilationPhase.ApplySpecializationPhase#transform(Compiler, CompilationPhases, FunctionNode)::: apply specialization phase transform:::return->new->ApplySpecialization->transformFunction
CompilationPhase.ApplySpecializationPhase#toString()::: apply specialization phase to string:::return
CompilationPhase.SplittingPhase#transform(Compiler, CompilationPhases, FunctionNode)::: splitting phase transform:::outermostCompileUnit->compiler->addCompileUnit->newFunctionNode->new->SimpleNodeVisitor->transformFunction->new->Splitter->split->new->SplitIntoFunctions->transformFunction->return
CompilationPhase.SplittingPhase#toString()::: splitting phase to string:::return
CompilationPhase.ProgramPointPhase#transform(Compiler, CompilationPhases, FunctionNode)::: program point phase transform:::return->new->ProgramPoints->transformFunction
CompilationPhase.ProgramPointPhase#toString()::: program point phase to string:::return
CompilationPhase.CacheAstPhase#transform(Compiler, CompilationPhases, FunctionNode)::: cache ast phase transform:::if->compiler->isOnDemandCompilation->new->CacheAst->transformFunction->return
CompilationPhase.CacheAstPhase#toString()::: cache ast phase to string:::return
CompilationPhase.SymbolAssignmentPhase#transform(Compiler, CompilationPhases, FunctionNode)::: symbol assignment phase transform:::return->new->AssignSymbols->transformFunction
CompilationPhase.SymbolAssignmentPhase#toString()::: symbol assignment phase to string:::return
CompilationPhase.ScopeDepthComputationPhase#transform(Compiler, CompilationPhases, FunctionNode)::: scope depth computation phase transform:::return->new->FindScopeDepths->transformFunction
CompilationPhase.ScopeDepthComputationPhase#toString()::: scope depth computation phase to string:::return
CompilationPhase.DeclareLocalSymbolsPhase#transform(Compiler, CompilationPhases, FunctionNode)::: declare local symbols phase transform:::if->compiler->useOptimisticTypes->compiler->isOnDemandCompilation->fn->getBody->new->SimpleNodeVisitor->accept->return
CompilationPhase.DeclareLocalSymbolsPhase#toString()::: declare local symbols phase to string:::return
CompilationPhase.OptimisticTypeAssignmentPhase#transform(Compiler, CompilationPhases, FunctionNode)::: optimistic type assignment phase transform:::if->compiler->useOptimisticTypes->return->new->OptimisticTypesCalculator->transformFunction->return
CompilationPhase.OptimisticTypeAssignmentPhase#toString()::: optimistic type assignment phase to string:::return
CompilationPhase.LocalVariableTypeCalculationPhase#transform(Compiler, CompilationPhases, FunctionNode)::: local variable type calculation phase transform:::newFunctionNode->compiler->getReturnType->new->LocalVariableTypesCalculator->transformFunction->senv->compiler->getScriptEnvironment->err->senv->getErr->if->fn->getDebugFlag->err->newFunctionNode->getName->quote->println->err->new->ASTWriter->println->if->fn->getDebugFlag->err->newFunctionNode->getName->quote->println->err->new->PrintVisitor->println->return
CompilationPhase.LocalVariableTypeCalculationPhase#toString()::: local variable type calculation phase to string:::return
CompilationPhase.ReuseCompileUnitsPhase#transform(Compiler, CompilationPhases, FunctionNode)::: reuse compile units phase transform:::map->new->HashMap<>->newUnits->CompileUnit->createCompileUnitSet->log->compiler->getLogger->log->fine->compiler->clearBytecode->foreach->compiler->getCompileUnits->newUnit->createNewCompileUnit->log->fine->map->put->newUnits->add->log->fine->compiler->replaceCompileUnits->log->fine->newFunctionNode->new->ReplaceCompileUnits->transformFunction->return
CompilationPhase.ReuseCompileUnitsPhase#toString()::: reuse compile units phase to string:::return
CompilationPhase.ReinitializeCachedPhase#transform(Compiler, CompilationPhases, FunctionNode)::: reinitialize cached phase transform:::unitSet->CompileUnit->createCompileUnitSet->unitMap->new->HashMap<>->fn->getCompileUnit->createCompileUnit->newFn->new->ReplaceCompileUnits->transformFunction->compiler->replaceCompileUnits->return
CompilationPhase.ReinitializeCachedPhase#createCompileUnit(CompileUnit, Set, Map, Compiler, CompilationPhases)::: reinitialize cached phase create compile unit:::newUnit->createNewCompileUnit->unitMap->put->unitSet->add->return
CompilationPhase.ReinitializeCachedPhase#toString()::: reinitialize cached phase to string:::return
CompilationPhase.BytecodeGenerationPhase#transform(Compiler, CompilationPhases, FunctionNode)::: bytecode generation phase transform:::senv->compiler->getScriptEnvironment->newFunctionNode->fn->getCompileUnit->setUsed->compiler->getLogger->fn->getName->quote->phases->isRestOfCompilation->fine->codegen->phases->isRestOfCompilation->compiler->getContinuationEntryPoints->new->CodeGenerator->try->transformFunction->codegen->generateScopeCalls->catch->if->senv->getErr->e->getClass->getSimpleName->e->getMessage->println->if->e->senv->getErr->printStackTrace->else->throw->throw->fn->getSourceName->codegen->getLastLineNumber->new->AssertionError->finally->foreach->compiler->getCompileUnits->classEmitter->compileUnit->getClassEmitter->classEmitter->end->if->compileUnit->isUsed->compiler->getLogger->fine->continue->bytecode->classEmitter->toByteArray->className->compileUnit->getUnitClassName->compiler->addClass->CompileUnit->increaseEmitCount->if->compiler->getCodeInstaller->verify->DumpBytecode->compiler->getLogger->dumpBytecode->return
CompilationPhase.BytecodeGenerationPhase#toString()::: bytecode generation phase to string:::return
CompilationPhase.InstallPhase#transform(Compiler, CompilationPhases, FunctionNode)::: install phase transform:::log->compiler->getLogger->installedClasses->new->LinkedHashMap<>->first->rootClass->length->origCodeInstaller->compiler->getCodeInstaller->bytecode->compiler->getBytecode->codeInstaller->bytecode->size->origCodeInstaller->getMultiClassCodeInstaller->foreach->bytecode->entrySet->className->entry->getKey->code->entry->getValue->clazz->codeInstaller->install->if->installedClasses->put->if->throw->new->CompilationException->constants->compiler->getConstantData->toArray->codeInstaller->installedClasses->values->compiler->getSource->initialize->foreach->if->compiler->getSource->initTransients->foreach->compiler->getCompileUnits->if->unit->isUsed->continue->unit->installedClasses->unit->getUnitClassName->get->setCode->unit->initializeFunctionsCode->if->log->isEnabled->sb->new->StringBuilder->sb->append->rootClass->getSimpleName->append->append->append->rootClass->getName->append->append->append->append->compiler->getCompileUnits->size->append->append->log->sb->toString->fine->return->fn->setRootClass
CompilationPhase.InstallPhase#toString()::: install phase to string:::return
CompilationPhase#begin(Compiler, FunctionNode):::Start a compilation phase:::compiler->getLogger->indent->System->nanoTime->return
CompilationPhase#end(Compiler, FunctionNode):::End a compilation phase:::compiler->getLogger->unindent->System->nanoTime->compiler->getScriptEnvironment->toString->accumulateTime->return
CompilationPhase#isFinished()::: compilation phase is finished:::return
CompilationPhase#getStartTime()::: compilation phase get start time:::return
CompilationPhase#getEndTime()::: compilation phase get end time:::return
CompilationPhase#transform(Compiler, CompilationPhases, FunctionNode)::: compilation phase transform:::
CompilationPhase#apply(Compiler, CompilationPhases, FunctionNode):::Apply a transform to a function node, returning the transformed function node:::return->begin->transform->end
CompilationPhase#transformFunction(FunctionNode, NodeVisitor)::: compilation phase transform function:::return->fn->accept
CompilationPhase#createNewCompileUnit(Compiler, CompilationPhases)::: compilation phase create new compile unit:::sb->compiler->nextCompileUnitName->new->StringBuilder->if->phases->isRestOfCompilation->sb->append->return->compiler->sb->toString->createCompileUnit
Compiler.CompilationPhases#concatPhases(CompilationPhases[])::: compilation phases concat phases:::l->new->ArrayList<>->foreach->l->addAll->l->trimToSize->return
Compiler.CompilationPhases#concat(List, List)::: compilation phases concat:::l->new->ArrayList<>->l->addAll->l->trimToSize->return
Compiler.CompilationPhases#toString()::: compilation phases to string:::return->phases->toString
Compiler.CompilationPhases#contains(CompilationPhase)::: compilation phases contains:::return->phases->contains
Compiler.CompilationPhases#iterator()::: compilation phases iterator:::return->phases->iterator
Compiler.CompilationPhases#isRestOfCompilation()::: compilation phases is rest of compilation:::return
Compiler.CompilationPhases#getDesc()::: compilation phases get desc:::return
Compiler.CompilationPhases#toString(String)::: compilation phases to string:::sb->new->StringBuilder->foreach->sb->append->append->append->return->sb->toString
Compiler#forInitialCompilation(CodeInstaller, Source, ErrorManager, boolean):::Creates a new compiler instance for initial compilation of a script.:::return->installer->getContext->new->Compiler
Compiler#forNoInstallerCompilation(Context, Source, boolean):::Creates a compiler without a code installer:::return->context->getErrorManager->new->Compiler
Compiler#forOnDemandCompilation(CodeInstaller, Source, boolean, RecompilableScriptFunctionData, TypeMap, Map, Object, int[], ScriptObject):::Creates a compiler for an on-demand compilation job.:::context->installer->getContext->return->context->getErrorManager->new->Compiler
Compiler#safeSourceName()::: compiler safe source name:::baseName->source->getName->new->File->getName->index->baseName->lastIndexOf->if->baseName->substring->baseName->replace->replace->if->installer->getUniqueScriptId->mangled->replaceDangerChars->NameCodec->encode->return
Compiler#replaceDangerChars(String)::: compiler replace danger chars:::len->name->length->buf->new->StringBuilder->for->i->return->buf->toString
Compiler#firstCompileUnitName()::: compiler first compile unit name:::sb->new->StringBuilder->append->symbolName->append->append->if->isOnDemandCompilation->sb->append->if->sb->append->append->if->compiledFunction->getFunctionNodeId->sb->compiledFunction->getFunctionNodeId->append->paramTypes->types->compiledFunction->getFunctionNodeId->getParameterTypes->foreach->sb->Type->getShortSignatureDescriptor->append->sb->append->sb->safeSourceName->append->return->sb->toString
Compiler#declareLocalSymbol(String)::: compiler declare local symbol:::typeEvaluator->declareLocalSymbol
Compiler#setData(RecompilableScriptFunctionData)::: compiler set data:::
Compiler#getLogger()::: compiler get logger:::return
Compiler#initLogger(Context)::: compiler init logger:::optimisticTypes->lazyCompilation->return->ctxt->this->getClass->new->Consumer<DebugLogger>->getLogger
Compiler#getScriptEnvironment()::: compiler get script environment:::return
Compiler#isOnDemandCompilation()::: compiler is on demand compilation:::return
Compiler#useOptimisticTypes()::: compiler use optimistic types:::return
Compiler#getContext()::: compiler get context:::return
Compiler#getOptimisticType(Optimistic)::: compiler get optimistic type:::return->typeEvaluator->getOptimisticType
Compiler#hasStringPropertyIterator(Expression):::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object):::return->typeEvaluator->hasStringPropertyIterator
Compiler#addInvalidatedProgramPoint(int, Type)::: compiler add invalidated program point:::invalidatedProgramPoints->put
Compiler#getInvalidatedProgramPoints():::Returns a copy of this compiler's current mapping of invalidated optimistic program points to their types:::return->invalidatedProgramPoints->isEmpty->new->TreeMap<>
Compiler#getTypeMap()::: compiler get type map:::return
Compiler#getCallSiteType(FunctionNode)::: compiler get call site type:::if->isOnDemandCompilation->return->return->types->getCallSiteType
Compiler#getParamType(FunctionNode, int)::: compiler get param type:::return->types->get
Compiler#getReturnType()::: compiler get return type:::return->isOnDemandCompilation->types->getReturnType
Compiler#compile(FunctionNode, CompilationPhases):::Do a compilation job:::if->log->isEnabled->log->DebugLogger->functionNode->getName->quote->phases->getDesc->quote->info->log->indent->name->DebugLogger->functionNode->getName->quote->newFunctionNode->foreach->newFunctionNode->uniqueName->info->log->isLoggable->timeLogger->env->isTimingEnabled->getLogger->time->foreach->log->fine->try->phase->apply->catch->errors->error->if->error->env->getErr->printStackTrace->return->finally->log->quote->fine->env->isTimingEnabled->phase->getEndTime->phase->getStartTime->if->phases->isRestOfCompilation->OptimisticTypesPersistence->store->log->unindent->if->sb->new->StringBuilder->sb->newFunctionNode->getSource->append->append->newFunctionNode->getName->quote->append->if->sb->append->toMillis->append->append->log->info->return
Compiler#getSource()::: compiler get source:::return
Compiler#getBytecode()::: compiler get bytecode:::return->Collections->unmodifiableMap
Compiler#clearBytecode():::Reset bytecode cache for compiler reuse.:::bytecode->clear
Compiler#getFirstCompileUnit()::: compiler get first compile unit:::return->compileUnits->iterator->next
Compiler#getCompileUnits()::: compiler get compile units:::return
Compiler#getConstantData()::: compiler get constant data:::return
Compiler#getCodeInstaller()::: compiler get code installer:::return
Compiler#addClass(String, byte[])::: compiler add class:::bytecode->put
Compiler#nextCompileUnitName()::: compiler next compile unit name:::sb->new->StringBuilder->sb->append->cuid->nextCompileUnitId->getAndIncrement->if->sb->append->append->return->sb->toString
Compiler#persistClassInfo(String, FunctionNode):::Persist current compilation with the given cacheKey.:::if->initializers->new->HashMap<>->if->isOnDemandCompilation->initializers->functionNode->getId->getInvalidatedProgramPoints->new->FunctionInitializer->put->else->foreach->getCompileUnits->foreach->compileUnit->getFunctionNodes->initializers->fn->getId->new->FunctionInitializer->put->mainClassName->getFirstCompileUnit->getUnitClassName->installer->constantData->toArray->storeScript
Compiler#updateCompilationId(int):::Make sure the next compilation id is greater than value.:::if->COMPILATION_ID->get->COMPILATION_ID->set
Compiler#addCompileUnit(long)::: compiler add compile unit:::compileUnit->createCompileUnit->compileUnits->add->log->fine->return
Compiler#createCompileUnit(String, long)::: compiler create compile unit:::classEmitter->isStrict->new->ClassEmitter->compileUnit->new->CompileUnit->classEmitter->begin->return
Compiler#createCompileUnit(long)::: compiler create compile unit:::return->nextCompileUnitName->createCompileUnit
Compiler#isStrict()::: compiler is strict:::return
Compiler#replaceCompileUnits(Set)::: compiler replace compile units:::compileUnits->clear->compileUnits->addAll
Compiler#findUnit(long)::: compiler find unit:::foreach->if->unit->canHold->unit->addWeight->return->return->addCompileUnit
Compiler#binaryName(String):::Convert a package/class name to a binary name.:::return->name->replace
Compiler#getScriptFunctionData(int)::: compiler get script function data:::fn->compiledFunction->getScriptFunctionData->return
Compiler#isGlobalSymbol(FunctionNode, String)::: compiler is global symbol:::return->fn->getId->getScriptFunctionData->isGlobalSymbol
Compiler#getContinuationEntryPoints()::: compiler get continuation entry points:::return
Compiler#getInvalidatedProgramPointType(int)::: compiler get invalidated program point type:::return->invalidatedProgramPoints->get
CompileUnit#createCompileUnitSet()::: compile unit create compile unit set:::return->new->TreeSet<>
CompileUnit#increaseEmitCount()::: compile unit increase emit count:::
CompileUnit#getEmittedUnitCount():::Get the amount of emitted compile units so far in the system:::return
CompileUnit#isUsed():::Check if this compile unit is used:::return
CompileUnit#hasCode():::Check if a compile unit has code, not counting inits and clinits:::return->classEmitter->getMethodCount->classEmitter->getInitCount->classEmitter->getClinitCount
CompileUnit#setUsed():::Tag this compile unit as used:::
CompileUnit#getCode():::Return the class that contains the code for this unit, null if not generated yet:::return
CompileUnit#setCode(Class):::Set class when it exists:::Objects->requireNonNull
CompileUnit#addFunctionInitializer(RecompilableScriptFunctionData, FunctionNode)::: compile unit add function initializer:::functions->put
CompileUnit#isInitializing(RecompilableScriptFunctionData, FunctionNode):::Returns true if this compile unit is responsible for initializing the specified function data with specified function node.:::return->functions->get
CompileUnit#initializeFunctionsCode()::: compile unit initialize functions code:::foreach->functions->entrySet->entry->getValue->entry->getKey->initializeCode
CompileUnit#getFunctionNodes()::: compile unit get function nodes:::return->Collections->functions->keySet->unmodifiableCollection
CompileUnit#addWeight(long):::Add weight to this compile unit:::
CompileUnit#canHold(long):::Check if this compile unit can hold weight more units of weight:::return
CompileUnit#getClassEmitter():::Get the class emitter for this compile unit:::return
CompileUnit#getUnitClassName():::Get the class name for this compile unit:::return
CompileUnit#shortName(String)::: compile unit short name:::return->name->lastIndexOf->name->name->lastIndexOf->substring
CompileUnit#toString()::: compile unit to string:::methods->classEmitter->getMethodNames->toString->return->shortName
CompileUnit#compareTo(CompileUnit)::: compile unit compare to:::return->className->compareTo
ConstantData.ArrayWrapper#calcHashCode():::Calculate a shallow hashcode for the array.:::cls->array->getClass->if->cls->getComponentType->isPrimitive->return->Arrays->hashCode->else->if->return->Arrays->hashCode->if->return->Arrays->hashCode->if->return->Arrays->hashCode->throw->new->AssertionError
ConstantData.ArrayWrapper#equals(Object)::: array wrapper equals:::if->return->otherArray->if->return->cls->array->getClass->if->otherArray->getClass->if->cls->getComponentType->isPrimitive->return->Arrays->equals->else->if->return->Arrays->equals->else->if->return->Arrays->equals->else->if->return->Arrays->equals->return
ConstantData.ArrayWrapper#hashCode()::: array wrapper hash code:::return
ConstantData.PropertyMapWrapper#hashCode()::: property map wrapper hash code:::return
ConstantData.PropertyMapWrapper#equals(Object)::: property map wrapper equals:::if->return->otherMap->return->Arrays->propertyMap->getProperties->otherMap->getProperties->equals->Objects->propertyMap->getClassName->otherMap->getClassName->equals
ConstantData#add(String):::Add a string to the constant data:::value->stringMap->get->if->return->constants->add->index->constants->size->stringMap->put->return
ConstantData#add(Object):::Add an object to the constant data:::entry->if->object->getClass->isArray->new->ArrayWrapper->else->if->new->PropertyMapWrapper->else->value->objectMap->get->if->return->constants->add->index->constants->size->objectMap->put->return
ConstantData#toArray()::: constant data to array:::return->constants->toArray
DumpBytecode#dumpBytecode(ScriptEnvironment, DebugLogger, byte[], String):::Dump bytecode to console and potentially disk.:::dir->try->if->sb->new->StringBuilder->sb->append->append->append->ClassEmitter->disassemble->append->append->if->name->dollar->name->lastIndexOf->if->name->substring->new->File->if->dir->exists->dir->mkdirs->throw->dir->toString->new->IOException->file->fileName->uniqueId->do->new->File->while->file->exists->try->pw->new->FileOutputStream->new->PrintWriter->pw->sb->toString->print->pw->flush->catch->finally->else->env->getErr->println->if->fileName->className->replace->index->fileName->lastIndexOf->if->fileName->substring->new->File->else->new->File->if->dir->exists->dir->mkdirs->throw->dir->toString->new->IOException->file->new->File->try->fos->new->FileOutputStream->fos->write->catch->finally->logger->file->getAbsolutePath->info->catch->logger->ECMAErrors->dir->toString->getMessage->warning->finally
FieldObjectCreator#createObject(MethodEmitter)::: field object creator create object:::makeMap->className->getClassName->method->_new->dup->loadMap->if->isScope->loadScope->if->hasArguments->method->loadCompilerConstant->method->ARGUMENTS->type->constructorNoLookup->invoke->else->method->constructorNoLookup->invoke->else->method->constructorNoLookup->invoke
FieldObjectCreator#createForInIterationScope(MethodEmitter):::Create a scope for a for-in/of loop as defined in ES6 13.7.5.13 step 5.g.iii:::className->getClassName->method->_new->dup->loadMap->loadScope->method->invoke->method->constructorNoLookup->invoke
FieldObjectCreator#populateRange(MethodEmitter, Type, int, int, int)::: field object creator populate range:::method->load->for->i
FieldObjectCreator#makeMap()::: field object creator make map:::newMapCreator->hasArguments->codegen->useDualFields->makeFieldMap->return
FieldObjectCreator#putField(MethodEmitter, String, int, MapTuple):::Store a value in a field of the generated class object.:::fieldType->codegen->useDualFields->tuple->isPrimitive->fieldClass->getClassName->fieldName->getFieldName->fieldDesc->fieldType->getTypeClass->typeDescriptor->loadTuple->method->putField
FieldObjectCreator#putSlot(MethodEmitter, long, MapTuple):::Store a value in an indexed slot of a generated class object.:::loadIndex->loadTuple->method->dynamicSetIndex
FieldObjectCreator#findClass():::Locate (or indirectly create) the object container class.:::isScope->ObjectClassGenerator->codegen->useDualFields->getClassName->ObjectClassGenerator->codegen->useDualFields->getClassName->try->Context->Compiler->binaryName->forStructureClass->catch->throw->new->AssertionError->finally
FieldObjectCreator#getAllocatorClass()::: field object creator get allocator class:::return
FieldObjectCreator#getClassName():::Get the class name for the object class, e.g:::return
FieldObjectCreator#countFields():::Tally the number of fields and parameters.:::foreach->symbol->if->if->hasArguments->symbol->isParam->symbol->setFieldIndex->else->if->getArrayIndex->isValidArrayIndex->symbol->setFieldIndex->getPaddedFieldCount
FindScopeDepths#getLogger()::: find scope depths get logger:::return
FindScopeDepths#initLogger(Context)::: find scope depths init logger:::return->context->this->getClass->getLogger
FindScopeDepths#findScopesToStart(LexicalContext, FunctionNode, Block)::: find scope depths find scopes to start:::bodyBlock->findBodyBlock->iter->lc->getBlocks->b->iter->next->scopesToStart->while->if->b->needsScope->if->break->iter->next->return
FindScopeDepths#findInternalDepth(LexicalContext, FunctionNode, Block, Symbol)::: find scope depths find internal depth:::bodyBlock->findBodyBlock->iter->lc->getBlocks->b->iter->next->scopesToStart->while->if->definedInBlock->return->if->b->needsScope->if->break->iter->next->return
FindScopeDepths#definedInBlock(Block, Symbol)::: find scope depths defined in block:::if->symbol->isGlobal->return->block->isGlobalScope->return->block->symbol->getName->getExistingSymbol
FindScopeDepths#findBodyBlock(LexicalContext, FunctionNode, Block)::: find scope depths find body block:::iter->lc->getBlocks->while->iter->hasNext->next->iter->next->if->fn->getBody->return->return
FindScopeDepths#findGlobalBlock(LexicalContext, Block)::: find scope depths find global block:::iter->lc->getBlocks->globalBlock->while->iter->hasNext->iter->next->return
FindScopeDepths#isDynamicScopeBoundary(FunctionNode)::: find scope depths is dynamic scope boundary:::return->fn->needsDynamicScope
FindScopeDepths#isDynamicScopeBoundary(Block)::: find scope depths is dynamic scope boundary:::return->withBodies->contains
FindScopeDepths#enterFunctionNode(FunctionNode)::: find scope depths enter function node:::if->compiler->isOnDemandCompilation->return->if->isDynamicScopeBoundary->increaseDynamicScopeCount->fnId->functionNode->getId->nestedFunctions->fnIdToNestedFunctions->get->if->new->HashMap<>->fnIdToNestedFunctions->put->return
FindScopeDepths#leaveFunctionNode(FunctionNode)::: find scope depths leave function node:::name->functionNode->getName->newFunctionNode->if->compiler->isOnDemandCompilation->data->compiler->newFunctionNode->getId->getScriptFunctionData->if->data->inDynamicContext->log->quote->fine->newFunctionNode->setInDynamicContext->if->lc->getOutermostFunction->newFunctionNode->hasApplyToCallSpecialization->data->setCachedAst->return->if->inDynamicScope->log->quote->fine->newFunctionNode->setInDynamicContext->fnId->newFunctionNode->getId->nestedFunctions->fnIdToNestedFunctions->remove->data->compiler->getCodeInstaller->ObjectClassGenerator->newFunctionNode->getThisProperties->compiler->getContext->useDualFields->createAllocationStrategy->externalSymbolDepths->get->internalSymbols->get->new->RecompilableScriptFunctionData->if->lc->getOutermostFunction->parentFn->lc->getParentFunction->if->fnIdToNestedFunctions->parentFn->getId->get->put->else->compiler->setData->if->isDynamicScopeBoundary->decreaseDynamicScopeCount->return
FindScopeDepths#inDynamicScope()::: find scope depths in dynamic scope:::return
FindScopeDepths#increaseDynamicScopeCount(Node)::: find scope depths increase dynamic scope count:::if->log->isEnabled->log->lc->getCurrentFunction->getName->quote->node->getClass->finest
FindScopeDepths#decreaseDynamicScopeCount(Node)::: find scope depths decrease dynamic scope count:::if->log->isEnabled->log->lc->getCurrentFunction->getName->quote->node->getClass->finest
FindScopeDepths#enterWithNode(WithNode)::: find scope depths enter with node:::withBodies->node->getBody->add->return
FindScopeDepths#enterBlock(Block)::: find scope depths enter block:::if->compiler->isOnDemandCompilation->return->if->isDynamicScopeBoundary->increaseDynamicScopeCount->if->lc->isFunctionBody->return->fn->lc->getCurrentFunction->symbols->new->HashSet<>->block->new->SimpleNodeVisitor->accept->internals->new->HashMap<>->globalBlock->findGlobalBlock->bodyBlock->findBodyBlock->foreach->iter->internalDepth->findInternalDepth->internal->if->internals->symbol->getName->put->if->depthAtStart->lc->getAncestorBlocks->while->iter->hasNext->b2->iter->next->if->definedInBlock->addExternalSymbol->break->if->b2->needsScope->internals->keySet->addInternalSymbols->if->log->isEnabled->log->fn->getName->externalSymbolDepths->fn->getId->get->info->return
FindScopeDepths#leaveBlock(Block)::: find scope depths leave block:::if->compiler->isOnDemandCompilation->return->if->isDynamicScopeBoundary->decreaseDynamicScopeCount->return
FindScopeDepths#addInternalSymbols(FunctionNode, Set)::: find scope depths add internal symbols:::fnId->functionNode->getId->internalSymbols->put
FindScopeDepths#addExternalSymbol(FunctionNode, Symbol, int)::: find scope depths add external symbol:::fnId->functionNode->getId->depths->externalSymbolDepths->get->if->new->HashMap<>->externalSymbolDepths->put->depths->symbol->getName->put
FoldConstants#getLogger()::: fold constants get logger:::return
FoldConstants#initLogger(Context)::: fold constants init logger:::return->context->this->getClass->getLogger
FoldConstants#leaveUnaryNode(UnaryNode)::: fold constants leave unary node:::literalNode->new->UnaryNodeConstantEvaluator->eval->if->log->info->return->return
FoldConstants#leaveBinaryNode(BinaryNode)::: fold constants leave binary node:::literalNode->new->BinaryNodeConstantEvaluator->eval->if->log->info->return->return
FoldConstants#leaveFunctionNode(FunctionNode)::: fold constants leave function node:::return
FoldConstants#leaveIfNode(IfNode)::: fold constants leave if node:::test->ifNode->getTest->if->isTrue->isTrue->executed->ifNode->getPass->ifNode->getFail->dropped->ifNode->getFail->ifNode->getPass->statements->new->ArrayList<>->if->statements->executed->getStatements->addAll->if->extractVarNodesFromDeadCode->if->statements->isEmpty->return->new->EmptyNode->return->BlockStatement->ifNode->getFinish->createReplacement->return
FoldConstants#leaveTernaryNode(TernaryNode)::: fold constants leave ternary node:::test->ternaryNode->getTest->if->return->isTrue->ternaryNode->getTrueExpression->ternaryNode->getFalseExpression->getExpression->return
FoldConstants#leaveSwitchNode(SwitchNode)::: fold constants leave switch node:::return->switchNode->isUniqueIntegerSwitchNode->setUniqueInteger
FoldConstants#isUniqueIntegerSwitchNode(SwitchNode)::: fold constants is unique integer switch node:::alreadySeen->new->HashSet<>->foreach->switchNode->getCases->test->caseNode->getTest->if->isUniqueIntegerLiteral->return->return
FoldConstants#isUniqueIntegerLiteral(Expression, Set)::: fold constants is unique integer literal:::if->value->getValue->if->return->alreadySeen->add->return
FoldConstants.ConstantEvaluator#eval():::Returns a literal node that replaces the given parent node, or null if replacement is impossible:::
FoldConstants#extractVarNodesFromDeadCode(Node, List):::When we eliminate dead code, we must preserve var declarations as they are scoped to the whole function:::deadCodeRoot->new->SimpleNodeVisitor->accept
FoldConstants.UnaryNodeConstantEvaluator#eval()::: unary node constant evaluator eval:::rhsNode->parent->getExpression->if->return->if->return->rhs->rhsType->rhs->getType->rhsInteger->rhsType->isInteger->rhsType->isBoolean->literalNode->switch->parent->tokenType->if->LiteralNode->rhs->getInt32->newInstance->else->if->rhsType->isLong->LiteralNode->rhs->getLong->newInstance->else->LiteralNode->rhs->getNumber->newInstance->break->if->rhs->getInt32->LiteralNode->rhs->getInt32->newInstance->else->if->rhsType->isLong->rhs->getLong->LiteralNode->rhs->getLong->newInstance->else->LiteralNode->rhs->getNumber->newInstance->break->LiteralNode->rhs->getBoolean->newInstance->break->LiteralNode->rhs->getInt32->newInstance->break->return->return
FoldConstants.BinaryNodeConstantEvaluator#eval()::: binary node constant evaluator eval:::result->reduceTwoLiterals->if->return->reduceOneLiteral->if->return->return
FoldConstants.BinaryNodeConstantEvaluator#reduceOneLiteral()::: binary node constant evaluator reduce one literal:::return
FoldConstants.BinaryNodeConstantEvaluator#reduceTwoLiterals()::: binary node constant evaluator reduce two literals:::if->parent->lhs->parent->rhs->return->lhs->parent->lhs->rhs->parent->rhs->if->return->widest->Type->lhs->getType->rhs->getType->widest->isInteger->widest->isInteger->value->switch->parent->tokenType->lhs->getNumber->rhs->getNumber->break->if->lhs->isString->rhs->isNumeric->rhs->isString->rhs->isNumeric->res->ScriptRuntime->lhs->getObject->rhs->getObject->ADD->if->doubleValue->break->return->LiteralNode->res->toString->newInstance->return->lhs->getNumber->rhs->getNumber->break->lhs->getNumber->rhs->getNumber->break->lhs->getNumber->rhs->getNumber->break->result->JSType->lhs->getInt32->rhs->getInt32->toUint32->return->LiteralNode->JSType->toNarrowestNumber->newInstance->return->LiteralNode->lhs->getInt32->rhs->getInt32->newInstance->return->LiteralNode->lhs->getInt32->rhs->getInt32->newInstance->return->LiteralNode->lhs->getInt32->rhs->getInt32->newInstance->return->LiteralNode->lhs->getInt32->rhs->getInt32->newInstance->return->LiteralNode->lhs->getInt32->rhs->getInt32->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->GE->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->LE->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->GT->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->LT->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->NE->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->NE_STRICT->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->EQ->newInstance->return->LiteralNode->ScriptRuntime->lhs->getObject->rhs->getObject->EQ_STRICT->newInstance->return->JSType->isStrictlyRepresentableAsInt->if->return->LiteralNode->newInstance->return->LiteralNode->newInstance
FunctionSignature#typeArray(List):::Internal function that converts an array of nodes to their Types:::if->return->typeArray->args->size->new->TypeArr->pos->foreach->arg->getType->return
FunctionSignature#toString()::: function signature to string:::return
FunctionSignature#size()::: function signature size:::return
FunctionSignature#getParamTypes():::Get the param types for this function signature:::return->paramTypes->clone
FunctionSignature#getMethodType():::Return the MethodType for this function signature:::return
FunctionSignature#getReturnType():::Return the return type for this function signature:::return
FunctionSignature#objectArgs(int)::: function signature object args:::array->new->TypeArr->for->i->return
Label.Stack#isEmpty()::: stack is empty:::return
Label.Stack#size()::: stack size:::return
Label.Stack#clear()::: stack clear:::
Label.Stack#push(Type)::: stack push:::if->newData->new->TypeArr->newLocalLoad->new->intArr->System->arraycopy->System->arraycopy
Label.Stack#peek()::: stack peek:::return->peek
Label.Stack#peek(int)::: stack peek:::pos->return
Label.Stack#getTopTypes(int):::Retrieve the top count types on the stack without modifying it.:::topTypes->new->TypeArr->System->arraycopy->return
Label.Stack#getLocalLoads(int, int)::: stack get local loads:::count->topLocalLoads->new->intArr->System->arraycopy->return
Label.Stack#getUsedSlotsWithLiveTemporaries():::Returns the number of used local variable slots, including all live stack-store temporaries.:::usedSlots->for->i->return
Label.Stack#joinFrom(Stack, boolean)::: stack join from:::if->Math->min->else->otherLoads->firstDeadTemp->for->i->undefineLocalVariables->mergeVariableTypes
Label.Stack#mergeVariableTypes(Stack, int)::: stack merge variable types:::it1->localVariableTypes->listIterator->it2->iterator->for->i
Label.Stack#joinFromTry(Stack)::: stack join from try:::Math->min->mergeVariableTypes
Label.Stack#getFirstDeadLocal(List)::: stack get first dead local:::i->types->size->for->it->types->listIterator->it->hasPrevious->it->previous->while->symbolBoundary->get->return
Label.Stack#isStackCompatible(Stack)::: stack is stack compatible:::if->return->for->i->return
Label.Stack#isVariablePartitioningEqual(Stack, int)::: stack is variable partitioning equal:::diff->other->getSymbolBoundaryCopy->diff->xor->return->diff->previousSetBit
Label.Stack#markDeadLocalVariables(int, int)::: stack mark dead local variables:::localCount->localVariableTypes->size->if->return->toSlot->Math->min->invalidateLocalLoadsOnStack->for->i
Label.Stack#getLocalVariableTypesCopy()::: stack get local variable types copy:::return->clone
Label.Stack#getSymbolBoundaryCopy()::: stack get symbol boundary copy:::return->symbolBoundary->clone
Label.Stack#getWidestLiveLocals(List):::Returns a list of local variable slot types, but for those symbols that have multiple values, only the slot holding the widest type is marked as live.:::widestLiveLocals->new->ArrayList<>->keepNextValue->size->widestLiveLocals->size->for->i->widestLiveLocals->Math->getFirstDeadLocal->max->widestLiveLocals->size->subList->clear->return
Label.Stack#markSymbolBoundariesInLvarTypesDescriptor(String)::: stack mark symbol boundaries in lvar types descriptor:::chars->lvarDescriptor->toCharArray->j->for->i->return->new->String
Label.Stack#pop()::: stack pop:::return
Label.Stack#clone()::: stack clone:::try->clone->super->clone->data->clone->localLoads->clone->getSymbolBoundaryCopy->getLocalVariableTypesCopy->return->catch->throw->new->AssertionError->finally
Label.Stack#cloneWithEmptyStack()::: stack clone with empty stack:::stack->clone->return
Label.Stack#getTopLocalLoad()::: stack get top local load:::return
Label.Stack#markLocalLoad(int)::: stack mark local load:::
Label.Stack#onLocalStore(Type, int, boolean):::Performs various bookeeping when a value is stored in a local variable slot.:::if->fromSlot->symbolBoundary->previousSetBit->toSlot->symbolBoundary->nextSetBit->for->i->invalidateLocalLoadsOnStack->else->type->getSlots->invalidateLocalLoadsOnStack->localVariableTypes->set->if->type->isCategory2->localVariableTypes->set
Label.Stack#invalidateLocalLoadsOnStack(int, int):::Given a slot range, invalidate knowledge about local loads on stack from these slots (because they're being killed).:::for->i
Label.Stack#defineBlockLocalVariable(int, int):::Marks a range of slots as belonging to a defined local variable:::defineLocalVariable
Label.Stack#defineTemporaryLocalVariable(int):::Defines a new temporary local variable and returns its allocated index.:::fromSlot->getUsedSlotsWithLiveTemporaries->defineLocalVariable->return
Label.Stack#defineTemporaryLocalVariable(int, int):::Marks a range of slots as belonging to a defined temporary local variable:::defineLocalVariable
Label.Stack#defineLocalVariable(int, int)::: stack define local variable:::symbolBoundary->clear->symbolBoundary->set->lastExisting->Math->localVariableTypes->size->min->for->i->for->i
Label.Stack#undefineLocalVariables(int, boolean):::Undefines all local variables past the specified slot.:::lvarCount->localVariableTypes->size->if->if->symbolBoundary->set->else->if->symbolBoundary->clear->localVariableTypes->subList->clear->Math->min
Label.Stack#markAsOptimisticCatchHandler(int)::: stack mark as optimistic catch handler:::undefineLocalVariables->localVariableTypes->localVariableTypes->size->subList->clear->for->it->localVariableTypes->listIterator->it->hasNext
Label.Stack#hasLoadsOnStack(int, int):::Returns true if any loads on the stack come from the specified slot range.:::for->i->return
Label.Stack#toString()::: stack to string:::return->Arrays->Arrays->copyOf->toString->String->valueOf->String->valueOf
Label#getLabel()::: label get label:::if->new->jdk.internal.org.objectweb.asm.Label->return
Label#getStack()::: label get stack:::return
Label#joinFrom(Label.Stack)::: label join from:::if->joinOrigin->clone->else->stack->joinFrom
Label#joinFromTry(Label.Stack, boolean)::: label join from try:::if->if->joinOrigin->cloneWithEmptyStack->stack->undefineLocalVariables->else->stack->joinFromTry
Label#markAsBreakTarget()::: label mark as break target:::
Label#isBreakTarget()::: label is break target:::return
Label#onCatch()::: label on catch:::if->stack->cloneWithEmptyStack
Label#markAsOptimisticCatchHandler(Label.Stack, int)::: label mark as optimistic catch handler:::currentStack->cloneWithEmptyStack->stack->markAsOptimisticCatchHandler
Label#markAsOptimisticContinuationHandlerFor(Label)::: label mark as optimistic continuation handler for:::cloneWithEmptyStack
Label#isReachable()::: label is reachable:::return
Label#isAfter(Label)::: label is after:::return->label->getOffset->getOffset
Label#toString()::: label to string:::if->return
LocalStateRestorationInfo#getLocalVariableTypes():::Returns the types of the local variables at the continuation of a program point.:::return->localVariableTypes->clone
LocalStateRestorationInfo#getStackLoads():::Returns the indices of local variables that need to be loaded on stack before jumping to the continuation of the program point.:::return->stackLoads->clone
LocalVariableTypesCalculator.JumpTarget#addOrigin(JoinPredecessor, Map, LocalVariableTypesCalculator)::: jump target add origin:::origins->new->JumpOrigin->add->calc->getUnionTypes
LocalVariableTypesCalculator.TypeHolderExpression#accept(NodeVisitor)::: type holder expression accept:::throw->new->AssertionError
LocalVariableTypesCalculator.TypeHolderExpression#getType()::: type holder expression get type:::return
LocalVariableTypesCalculator.TypeHolderExpression#toString(StringBuilder, boolean)::: type holder expression to string:::throw->new->AssertionError
LocalVariableTypesCalculator#cloneMap(Map)::: local variable types calculator clone map:::return->clone
LocalVariableTypesCalculator#createConversion(Symbol, LvarType, Map, LocalVariableConversion)::: local variable types calculator create conversion:::if->invalidatedSymbols->contains->return->targetType->joinLvarTypes->get->if->return->symbolIsConverted->return->new->LocalVariableConversion
LocalVariableTypesCalculator#getUnionTypes(Map, Map)::: local variable types calculator get union types:::if->types1->isEmpty->return->else->if->types2->isEmpty->return->commonSymbols->types1->keySet->new->HashSet<>->commonSymbols->types2->keySet->retainAll->commonSize->commonSymbols->size->types1Size->types1->size->types2Size->types2->size->if->matches1->matches2->union->foreach->type1->types1->get->type2->types2->get->widest->widestLvarType->if->if->cloneMap->if->if->cloneMap->if->union->put->return->union->if->cloneMap->union->putAll->else->cloneMap->union->putAll->foreach->type1->types1->get->type2->types2->get->union->widestLvarType->put->union->keySet->removeAll->return
LocalVariableTypesCalculator#symbolIsUsed(Symbol, LvarType)::: local variable types calculator symbol is used:::if->symbol->setHasSlotFor
LocalVariableTypesCalculator.SymbolConversions#recordConversion(LvarType, LvarType)::: symbol conversions record conversion:::switch->return->switch->recordConversion->return->recordConversion->return->illegalConversion->return->if->recordConversion->return->illegalConversion
LocalVariableTypesCalculator.SymbolConversions#illegalConversion(LvarType, LvarType)::: symbol conversions illegal conversion:::throw->new->AssertionError
LocalVariableTypesCalculator.SymbolConversions#recordConversion(byte)::: symbol conversions record conversion:::
LocalVariableTypesCalculator.SymbolConversions#hasConversion(byte)::: symbol conversions has conversion:::return
LocalVariableTypesCalculator.SymbolConversions#calculateTypeLiveness(Symbol)::: symbol conversions calculate type liveness:::if->symbol->hasSlotFor->if->hasConversion->symbol->setHasSlotFor->if->hasConversion->symbol->setHasSlotFor->if->symbol->hasSlotFor->if->hasConversion->symbol->setHasSlotFor
LocalVariableTypesCalculator#symbolIsConverted(Symbol, LvarType, LvarType)::: local variable types calculator symbol is converted:::conversions->symbolConversions->get->if->new->SymbolConversions->symbolConversions->put->conversions->recordConversion
LocalVariableTypesCalculator#toLvarType(Type)::: local variable types calculator to lvar type:::lvarType->TO_LVAR_TYPE->get->if->return->return
LocalVariableTypesCalculator#widestLvarType(LvarType, LvarType)::: local variable types calculator widest lvar type:::if->return->if->t1->ordinal->ordinal->t2->ordinal->ordinal->return->return->LvarType->values->Math->t1->ordinal->t2->ordinal->max
LocalVariableTypesCalculator#createJumpTarget(Label)::: local variable types calculator create jump target:::jumpTarget->new->JumpTarget->jumpTargets->put->return
LocalVariableTypesCalculator#doesNotContinueSequentially()::: local variable types calculator does not continue sequentially:::Collections->emptyMap->assertTypeStackIsEmpty
LocalVariableTypesCalculator#pushExpressionType(Expression)::: local variable types calculator push expression type:::typeStack->expr->getType->toLvarType->push->return
LocalVariableTypesCalculator#enterAccessNode(AccessNode)::: local variable types calculator enter access node:::accessNode->getBase->visitExpression->return->pushExpressionType
LocalVariableTypesCalculator#enterBinaryNode(BinaryNode)::: local variable types calculator enter binary node:::lhs->binaryNode->lhs->lhsType->if->binaryNode->isTokenType->visitExpression->else->isLogical->binaryNode->isLogical->joinLabel->new->Label->if->jumpToLabel->rhs->binaryNode->rhs->rhsType->visitExpression->if->jumpToLabel->joinOnLabel->type->binaryNode->setOperands->getType->toLvarType->if->binaryNode->isAssignment->if->binaryNode->isSelfModifying->onSelfAssignment->else->onAssignment->typeStack->push->return
LocalVariableTypesCalculator#enterBlock(Block)::: local variable types calculator enter block:::cloned->foreach->block->getSymbols->if->symbol->isBytecodeLocal->if->getLocalVariableTypeOrNull->if->cloneOrNewLocalVariableTypes->localVariableTypes->put->invalidatedSymbols->remove->return
LocalVariableTypesCalculator#enterBreakNode(BreakNode)::: local variable types calculator enter break node:::return->enterJumpStatement
LocalVariableTypesCalculator#enterCallNode(CallNode)::: local variable types calculator enter call node:::callNode->getFunction->visitExpression->callNode->getArgs->visitExpressions->evalArgs->callNode->getEvalArgs->if->evalArgs->getArgs->visitExpressions->return->pushExpressionType
LocalVariableTypesCalculator#enterContinueNode(ContinueNode)::: local variable types calculator enter continue node:::return->enterJumpStatement
LocalVariableTypesCalculator#enterJumpStatement(JumpStatement)::: local variable types calculator enter jump statement:::if->return->assertTypeStackIsEmpty->jump->getTargetLabel->jump->getPopScopeLimit->getBreakTargetTypes->jumpToLabel->doesNotContinueSequentially->return
LocalVariableTypesCalculator#enterDefault(Node)::: local variable types calculator enter default:::return
LocalVariableTypesCalculator#enterDoWhileLoop(WhileNode)::: local variable types calculator enter do while loop:::assertTypeStackIsEmpty->test->loopNode->getTest->body->loopNode->getBody->continueLabel->loopNode->getContinueLabel->breakLabel->loopNode->getBreakLabel->beforeLoopTypes->repeatLabel->new->Label->for->if->isAlwaysTrue->doesNotContinueSequentially->leaveBreakable
LocalVariableTypesCalculator#enterExpressionStatement(ExpressionStatement)::: local variable types calculator enter expression statement:::if->expressionStatement->getExpression->visitExpressionOnEmptyStack->return
LocalVariableTypesCalculator#assertTypeStackIsEmpty()::: local variable types calculator assert type stack is empty:::
LocalVariableTypesCalculator#leaveDefault(Node)::: local variable types calculator leave default:::return
LocalVariableTypesCalculator#visitExpressionOnEmptyStack(Expression)::: local variable types calculator visit expression on empty stack:::assertTypeStackIsEmpty->return->visitExpression
LocalVariableTypesCalculator#visitExpression(Expression)::: local variable types calculator visit expression:::stackSize->typeStack->size->expr->accept->return->typeStack->pop
LocalVariableTypesCalculator#visitExpressions(List)::: local variable types calculator visit expressions:::foreach->if->visitExpression
LocalVariableTypesCalculator#enterForNode(ForNode)::: local variable types calculator enter for node:::if->return->init->forNode->getInit->if->forNode->isForInOrOf->iterable->forNode->getModify->visitExpression->compiler->useOptimisticTypes->forNode->isForEach->compiler->iterable->getExpression->hasStringPropertyIterator->enterTestFirstLoop->else->if->visitExpressionOnEmptyStack->forNode->getModify->enterTestFirstLoop->assertTypeStackIsEmpty->return
LocalVariableTypesCalculator#enterFunctionNode(FunctionNode)::: local variable types calculator enter function node:::if->typeStack->push->return->pos->if->functionNode->isVarArg->foreach->functionNode->getParameters->symbol->param->getSymbol->callSiteParamType->compiler->getParamType->paramType->toLvarType->setType->symbolIsUsed->setIdentifierLvarType->setCompilerConstantAsObject->if->functionNode->hasScopeBlock->functionNode->needsParentScope->setCompilerConstantAsObject->if->functionNode->needsCallee->setCompilerConstantAsObject->if->functionNode->needsArguments->setCompilerConstantAsObject->return
LocalVariableTypesCalculator#enterGetSplitState(GetSplitState)::: local variable types calculator enter get split state:::return->pushExpressionType
LocalVariableTypesCalculator#enterIdentNode(IdentNode)::: local variable types calculator enter ident node:::symbol->identNode->getSymbol->if->symbol->isBytecodeLocal->symbolIsUsed->type->getLocalVariableType->setIdentifierLvarType->typeStack->push->else->pushExpressionType->return
LocalVariableTypesCalculator#enterIfNode(IfNode)::: local variable types calculator enter if node:::processIfNode->return
LocalVariableTypesCalculator#processIfNode(IfNode)::: local variable types calculator process if node:::if->return->test->ifNode->getTest->pass->ifNode->getPass->fail->ifNode->getFail->visitExpressionOnEmptyStack->passLvarTypes->reachableFromPass->isTestAlwaysTrue->isAlwaysTrue->if->isAlwaysFalse->else->afterTestLvarTypes->pass->accept->assertTypeStackIsEmpty->if->return->if->fail->accept->assertTypeStackIsEmpty->if->if->failLvarTypes->getUnionTypes->setConversion->setConversion->else->if
LocalVariableTypesCalculator#enterIndexNode(IndexNode)::: local variable types calculator enter index node:::indexNode->getBase->visitExpression->indexNode->getIndex->visitExpression->return->pushExpressionType
LocalVariableTypesCalculator#enterJoinPredecessorExpression(JoinPredecessorExpression)::: local variable types calculator enter join predecessor expression:::expr->joinExpr->getExpression->if->expr->accept->else->typeStack->push->return
LocalVariableTypesCalculator#enterJumpToInlinedFinally(JumpToInlinedFinally)::: local variable types calculator enter jump to inlined finally:::return->enterJumpStatement
LocalVariableTypesCalculator#enterLiteralNode(LiteralNode)::: local variable types calculator enter literal node:::if->expressions->getElementExpressions->if->visitExpressions->pushExpressionType->return
LocalVariableTypesCalculator#enterObjectNode(ObjectNode)::: local variable types calculator enter object node:::foreach->objectNode->getElements->value->propertyNode->getValue->if->visitExpression->return->pushExpressionType
LocalVariableTypesCalculator#enterPropertyNode(PropertyNode)::: local variable types calculator enter property node:::throw->new->AssertionError
LocalVariableTypesCalculator#enterReturnNode(ReturnNode)::: local variable types calculator enter return node:::if->return->returnExpr->returnNode->getExpression->returnExprType->if->visitExpressionOnEmptyStack->else->assertTypeStackIsEmpty->Type->widestReturnType->doesNotContinueSequentially->return
LocalVariableTypesCalculator#enterRuntimeNode(RuntimeNode)::: local variable types calculator enter runtime node:::runtimeNode->getArgs->visitExpressions->return->pushExpressionType
LocalVariableTypesCalculator#enterSplitReturn(SplitReturn)::: local variable types calculator enter split return:::doesNotContinueSequentially->return
LocalVariableTypesCalculator#enterSwitchNode(SwitchNode)::: local variable types calculator enter switch node:::if->return->switchNode->getExpression->visitExpressionOnEmptyStack->cases->switchNode->getCases->if->cases->isEmpty->return->isInteger->switchNode->isUniqueInteger->breakLabel->switchNode->getBreakLabel->hasDefault->switchNode->getDefaultCase->tagUsed->foreach->test->caseNode->getTest->if->visitExpressionOnEmptyStack->if->switchNode->getTag->symbolIsUsed->caseNode->getBody->getEntryLabel->jumpToLabel->if->jumpToLabel->doesNotContinueSequentially->previousBlock->foreach->body->caseNode->getBody->entryLabel->body->getEntryLabel->if->jumpToLabel->joinOnLabel->body->accept->if->jumpToLabel->leaveBreakable->return
LocalVariableTypesCalculator#enterTernaryNode(TernaryNode)::: local variable types calculator enter ternary node:::test->ternaryNode->getTest->trueExpr->ternaryNode->getTrueExpression->falseExpr->ternaryNode->getFalseExpression->visitExpression->testExitLvarTypes->trueType->if->isAlwaysFalse->visitExpression->else->trueExitLvarTypes->falseType->if->isAlwaysTrue->visitExpression->else->falseExitLvarTypes->getUnionTypes->setConversion->setConversion->typeStack->widestLvarType->assertNotNull->push->return
LocalVariableTypesCalculator#assertNotNull(T)::: local variable types calculator assert not null:::return
LocalVariableTypesCalculator#enterTestFirstLoop(LoopNode, JoinPredecessorExpression, Expression, boolean)::: local variable types calculator enter test first loop:::test->loopNode->getTest->if->isAlwaysFalse->visitExpressionOnEmptyStack->return->continueLabel->loopNode->getContinueLabel->breakLabel->loopNode->getBreakLabel->repeatLabel->new->Label->beforeLoopTypes->for->if->isAlwaysTrue->doesNotContinueSequentially->leaveBreakable
LocalVariableTypesCalculator#enterThrowNode(ThrowNode)::: local variable types calculator enter throw node:::if->return->throwNode->getExpression->visitExpressionOnEmptyStack->jumpToCatchBlock->doesNotContinueSequentially->return
LocalVariableTypesCalculator#enterTryNode(TryNode)::: local variable types calculator enter try node:::if->return->catchLabel->new->Label->catchLabels->push->jumpToLabel->body->tryNode->getBody->body->accept->catchLabels->pop->endLabel->new->Label->canExit->if->jumpToLabel->doesNotContinueSequentially->foreach->tryNode->getInlinedFinallies->finallyBody->TryNode->getLabelledInlinedFinallyBlock->finallyBody->getEntryLabel->joinOnLabel->if->finallyBody->accept->joinOnLabel->foreach->tryNode->getCatches->exception->catchNode->getExceptionIdentifier->onAssignment->condition->catchNode->getExceptionCondition->if->visitExpression->afterConditionTypes->catchBody->catchNode->getBody->catchBody->accept->if->jumpToLabel->doesNotContinueSequentially->if->joinOnLabel->return
LocalVariableTypesCalculator#enterUnaryNode(UnaryNode)::: local variable types calculator enter unary node:::expr->unaryNode->getExpression->unaryType->if->unaryNode->tokenType->unaryNode->getType->toLvarType->else->unaryNode->visitExpression->setExpression->getType->toLvarType->if->unaryNode->isSelfModifying->onSelfAssignment->typeStack->push->return
LocalVariableTypesCalculator#enterVarNode(VarNode)::: local variable types calculator enter var node:::if->return->init->varNode->getInit->if->varNode->getName->visitExpression->onAssignment->return
LocalVariableTypesCalculator#enterWhileNode(WhileNode)::: local variable types calculator enter while node:::if->return->if->whileNode->isDoWhile->enterDoWhileLoop->else->enterTestFirstLoop->return
LocalVariableTypesCalculator#enterWithNode(WithNode)::: local variable types calculator enter with node:::if->withNode->getExpression->visitExpression->withNode->getBody->accept->return
LocalVariableTypesCalculator#getBreakTargetTypes(LexicalContextNode)::: local variable types calculator get break target types:::types->for->it->lc->getAllNodes->it->hasNext->return
LocalVariableTypesCalculator#getLocalVariableType(Symbol):::Returns the current type of the local variable represented by the symbol:::type->getLocalVariableTypeOrNull->return
LocalVariableTypesCalculator#getLocalVariableTypeOrNull(Symbol):::Gets the type for a variable represented by a symbol, or null if the type is not know:::return->localVariableTypes->get
LocalVariableTypesCalculator#getOrCreateJumpTarget(Label)::: local variable types calculator get or create jump target:::jumpTarget->jumpTargets->get->if->createJumpTarget->return
LocalVariableTypesCalculator#joinOnLabel(Label):::If there's a join point associated with a label, insert the join point into the flow.:::jumpTarget->jumpTargets->remove->if->return->getUnionTypes->foreach->setConversion
LocalVariableTypesCalculator#jumpToCatchBlock(JoinPredecessor):::If we're in a try/catch block, add an edge from the specified node to the try node's pre-catch label.:::currentCatchLabel->catchLabels->peek->if->jumpToLabel
LocalVariableTypesCalculator#jumpToLabel(JoinPredecessor, Label)::: local variable types calculator jump to label:::jumpToLabel
LocalVariableTypesCalculator#jumpToLabel(JoinPredecessor, Label, Map)::: local variable types calculator jump to label:::getOrCreateJumpTarget->addOrigin
LocalVariableTypesCalculator#leaveBlock(Block)::: local variable types calculator leave block:::if->lc->isFunctionBody->if->createSyntheticReturn->calculateReturnType->cloned->foreach->block->getSymbols->if->symbol->hasSlot->if->symbol->isBytecodeLocal->if->localVariableTypes->containsKey->if->cloneMap->invalidateSymbol->conversions->symbolConversions->get->if->conversions->calculateTypeLiveness->if->symbol->slotCount->symbol->setNeedsSlot->if->labelNode->lc->getCurrentBlockLabelNode->if->block->getBreakLabel->jumpToLabel->leaveBreakable->return
LocalVariableTypesCalculator#calculateReturnType()::: local variable types calculator calculate return type:::if->returnType->isUnknown
LocalVariableTypesCalculator#createSyntheticReturn(Block)::: local variable types calculator create synthetic return:::functionNode->lc->getCurrentFunction->token->functionNode->getToken->finish->functionNode->getFinish->statements->body->getStatements->lineNumber->statements->isEmpty->functionNode->getLineNumber->statements->statements->size->get->getLineNumber->returnExpr->if->functionNode->isProgram->RETURN->symbolName->new->IdentNode->getCompilerConstantSymbol->setSymbol->else->new->ReturnNode->syntheticReturn->accept
LocalVariableTypesCalculator#leaveBreakable(BreakableNode):::Leave a breakable node:::breakable->getBreakLabel->joinOnLabel->assertTypeStackIsEmpty
LocalVariableTypesCalculator#leaveFunctionNode(FunctionNode)::: local variable types calculator leave function node:::newFunction->applyChangesVisitor->new->SimpleNodeVisitor->newFunction->newFunction->getBody->accept->setBody->newFunction->setReturnType->newFunction->newFunction->visitParameters->setParameters->return
LocalVariableTypesCalculator#createIsUndefined(Expression, Expression, Expression, Request)::: local variable types calculator create is undefined:::if->isUndefinedIdent->isUndefinedIdent->return->new->RuntimeNode->return
LocalVariableTypesCalculator#isUndefinedIdent(Expression)::: local variable types calculator is undefined ident:::return->getName->equals
LocalVariableTypesCalculator#identIsDeadAndHasNoLiveConversions(IdentNode)::: local variable types calculator ident is dead and has no live conversions:::conv->localVariableConversions->get->return->conv->isLive
LocalVariableTypesCalculator#onAssignment(IdentNode, LvarType)::: local variable types calculator on assignment:::symbol->identNode->getSymbol->if->symbol->isBytecodeLocal->return->finalType->if->getLocalVariableType->symbol->setFlag->else->setType->setIdentifierLvarType->jumpToCatchBlock
LocalVariableTypesCalculator#onSelfAssignment(IdentNode, LvarType)::: local variable types calculator on self assignment:::symbol->identNode->getSymbol->if->symbol->isBytecodeLocal->return->setType->jumpToCatchBlock
LocalVariableTypesCalculator#resetJoinPoint(Label)::: local variable types calculator reset join point:::jumpTargets->remove
LocalVariableTypesCalculator#setCompilerConstantAsObject(FunctionNode, CompilerConstants)::: local variable types calculator set compiler constant as object:::symbol->getCompilerConstantSymbol->setType->symbolIsUsed
LocalVariableTypesCalculator#getCompilerConstantSymbol(FunctionNode, CompilerConstants)::: local variable types calculator get compiler constant symbol:::return->functionNode->getBody->cc->symbolName->getExistingSymbol
LocalVariableTypesCalculator#setConversion(JoinPredecessor, Map, Map)::: local variable types calculator set conversion:::if->return->if->branchLvarTypes->isEmpty->joinLvarTypes->isEmpty->localVariableConversions->remove->conversion->if->symbol->getSymbol->branchLvarTypes->get->createConversion->else->foreach->branchLvarTypes->entrySet->symbol->entry->getKey->branchLvarType->entry->getValue->createConversion->if->localVariableConversions->put->else->localVariableConversions->remove
LocalVariableTypesCalculator#setIdentifierLvarType(IdentNode, LvarType)::: local variable types calculator set identifier lvar type:::identifierLvarTypes->put
LocalVariableTypesCalculator#setType(Symbol, LvarType):::Marks a local variable as having a specific type from this point onward:::if->getLocalVariableTypeOrNull->return->cloneOrNewLocalVariableTypes->localVariableTypes->put
LocalVariableTypesCalculator#cloneOrNewLocalVariableTypes()::: local variable types calculator clone or new local variable types:::localVariableTypes->isEmpty->new->HashMap<Symbol,LvarType>->cloneMap
LocalVariableTypesCalculator#invalidateSymbol(Symbol)::: local variable types calculator invalidate symbol:::localVariableTypes->remove->invalidatedSymbols->add
LocalVariableTypesCalculator#symbolIsUsed(Symbol):::Set a flag in the symbol marking it as needing to be able to store a value of a particular type:::getLocalVariableType->symbolIsUsed
Lower#getLogger()::: lower get logger:::return
Lower#initLogger(Context)::: lower init logger:::return->context->this->getClass->getLogger
Lower#enterBreakNode(BreakNode)::: lower enter break node:::addStatement->return
Lower#leaveCallNode(CallNode)::: lower leave call node:::return->callNode->callNode->getFunction->markerFunction->setFunction->checkEval
Lower#enterCatchNode(CatchNode)::: lower enter catch node:::exception->catchNode->getException->if->throwNotImplementedYet->return
Lower#leaveCatchNode(CatchNode)::: lower leave catch node:::return->addStatement
Lower#enterContinueNode(ContinueNode)::: lower enter continue node:::addStatement->return
Lower#enterDebuggerNode(DebuggerNode)::: lower enter debugger node:::line->debuggerNode->getLineNumber->token->debuggerNode->getToken->finish->debuggerNode->getFinish->new->ArrayList<Expression>->new->RuntimeNode->new->ExpressionStatement->addStatement->return
Lower#enterJumpToInlinedFinally(JumpToInlinedFinally)::: lower enter jump to inlined finally:::addStatement->return
Lower#enterEmptyNode(EmptyNode)::: lower enter empty node:::return
Lower#leaveIndexNode(IndexNode)::: lower leave index node:::name->indexNode->getIndex->getConstantPropertyName->if->return->indexNode->getToken->indexNode->getFinish->indexNode->getBase->new->AccessNode->return->super->leaveIndexNode
Lower#leaveDELETE(UnaryNode)::: lower leave e:::expression->delete->getExpression->if->return->return->Token->delete->getToken->recast->LiteralNode->delete->getToken->delete->getFinish->newInstance->new->BinaryNode
Lower#getConstantPropertyName(Expression)::: lower get constant property name:::if->value->getValue->if->SAFE_PROPERTY_NAME->matcher->matches->return->return
Lower#leaveExpressionStatement(ExpressionStatement)::: lower leave expression statement:::expr->expressionStatement->getExpression->node->currentFunction->lc->getCurrentFunction->if->currentFunction->isProgram->if->isInternalExpression->isEvalResultAssignment->expressionStatement->Token->expressionStatement->getToken->recast->compilerConstant->new->BinaryNode->setExpression->if->expressionStatement->destructuringDeclarationType->throwNotImplementedYet->return->addStatement
Lower#leaveBlockStatement(BlockStatement)::: lower leave block statement:::return->addStatement
Lower#enterForNode(ForNode)::: lower enter for node:::if->forNode->getInit->forNode->getInit->throwNotImplementedYet->return->super->enterForNode
Lower#leaveForNode(ForNode)::: lower leave for node:::newForNode->test->forNode->getTest->if->forNode->isForInOrOf->isAlwaysTrue->forNode->setTest->checkEscape->if->newForNode->isForInOrOf->addStatementEnclosedInBlock->else->addStatement->return
Lower#enterFunctionNode(FunctionNode)::: lower enter function node:::if->if->functionNode->getKind->throwNotImplementedYet->if->functionNode->getKind->throwNotImplementedYet->if->functionNode->usesSuper->throwNotImplementedYet->numParams->functionNode->getNumOfParams->if->lastParam->functionNode->getParameter->if->lastParam->isRestParameter->throwNotImplementedYet->foreach->functionNode->getParameters->if->param->isDestructuredParameter->throwNotImplementedYet->return->super->enterFunctionNode
Lower#leaveFunctionNode(FunctionNode)::: lower leave function node:::log->functionNode->getName->info->return
Lower#leaveIfNode(IfNode)::: lower leave if node:::return->addStatement
Lower#leaveIN(BinaryNode)::: lower leave n:::return->new->RuntimeNode
Lower#leaveINSTANCEOF(BinaryNode)::: lower leave f:::return->new->RuntimeNode
Lower#leaveLabelNode(LabelNode)::: lower leave label node:::return->addStatement
Lower#leaveReturnNode(ReturnNode)::: lower leave return node:::addStatement->return
Lower#leaveCaseNode(CaseNode)::: lower leave case node:::test->caseNode->getTest->if->lit->if->lit->isNumeric->lit->getValue->if->JSType->lit->getNumber->isRepresentableAsInt->return->caseNode->LiteralNode->lit->getInt32->newInstance->accept->setTest->return
Lower#leaveSwitchNode(SwitchNode)::: lower leave switch node:::if->switchNode->isUniqueInteger->addStatementEnclosedInBlock->else->addStatement->return
Lower#leaveThrowNode(ThrowNode)::: lower leave throw node:::return->addStatement
Lower#ensureUniqueNamesIn(T)::: lower ensure unique names in:::return->node->new->SimpleNodeVisitor->accept
Lower#createFinallyBlock(Block)::: lower create finally block:::newStatements->new->ArrayList<>->foreach->finallyBody->getStatements->newStatements->add->if->statement->hasTerminalFlags->break->return->finallyBody->setStatements
Lower#catchAllBlock(TryNode)::: lower catch all block:::lineNumber->tryNode->getLineNumber->token->tryNode->getToken->finish->tryNode->getFinish->exception->lc->getCurrentFunction->symbolName->uniqueName->new->IdentNode->catchBody->new->IdentNode->new->ThrowNode->new->Block->catchAllNode->new->IdentNode->new->CatchNode->catchAllBlock->new->Block->return->catchAllBlock->accept
Lower#compilerConstant(CompilerConstants)::: lower compiler constant:::functionNode->lc->getCurrentFunction->return->functionNode->getToken->functionNode->getFinish->cc->symbolName->new->IdentNode
Lower#isTerminalFinally(Block)::: lower is terminal finally:::return->finallyBlock->getLastStatement->hasTerminalFlags
Lower#spliceFinally(TryNode, ThrowNode, Block):::Splice finally code into all endpoints of a trynode:::finallyBlock->createFinallyBlock->inlinedFinallies->new->ArrayList<>->fn->lc->getCurrentFunction->newTryNode->tryNode->new->SimpleNodeVisitor->accept->inlinedFinallies->isEmpty->newTryNode->setInlinedFinallies->addStatement->new->BlockStatement->addStatement->return
Lower#createJumpToInlinedFinally(FunctionNode, List, Block)::: lower create jump to inlined finally:::labelName->fn->uniqueName->token->finallyBlock->getToken->finish->finallyBlock->getFinish->inlinedFinallies->finallyBlock->getFirstStatementLineNumber->new->LabelNode->new->Block->add->return->new->JumpToInlinedFinally
Lower#prependFinally(Block, Statement)::: lower prepend finally:::inlinedFinally->ensureUniqueNamesIn->if->isTerminalFinally->return->stmts->inlinedFinally->getStatements->newStmts->stmts->size->new->ArrayList<>->newStmts->addAll->newStmts->add->return->inlinedFinally->getToken->statement->getFinish->new->Block
Lower#leaveTryNode(TryNode)::: lower leave try node:::finallyBody->tryNode->getFinallyBody->newTryNode->tryNode->setFinallyBody->if->finallyBody->getStatementCount->catches->newTryNode->getCatches->if->catches->isEmpty->return->tryNode->getBody->new->BlockStatement->addStatement->return->ensureUnconditionalCatch->addStatement->catchAll->catchAllBlock->rethrows->new->ArrayList<>->catchAll->new->SimpleNodeVisitor->accept->if->tryNode->getCatchBlocks->isEmpty->outerBody->newTryNode->getToken->newTryNode->getFinish->ensureUnconditionalCatch->new->Block->newTryNode->setBody->setCatchBlocks->newTryNode->Arrays->asList->setCatchBlocks->return->lc->rethrows->get->spliceFinally->replace
Lower#ensureUnconditionalCatch(TryNode)::: lower ensure unconditional catch:::catches->tryNode->getCatches->if->catches->isEmpty->catches->catches->size->get->getExceptionCondition->return->newCatchBlocks->tryNode->getCatchBlocks->new->ArrayList<>->newCatchBlocks->catchAllBlock->add->return->tryNode->setCatchBlocks
Lower#enterUnaryNode(UnaryNode)::: lower enter unary node:::if->if->unaryNode->isTokenType->unaryNode->isTokenType->throwNotImplementedYet->else->if->unaryNode->isTokenType->unaryNode->isTokenType->throwNotImplementedYet->return->super->enterUnaryNode
Lower#enterASSIGN(BinaryNode)::: lower enter n:::if->binaryNode->lhs->binaryNode->lhs->throwNotImplementedYet->return->super->enterASSIGN
Lower#leaveVarNode(VarNode)::: lower leave var node:::addStatement->if->varNode->getFlag->lc->getCurrentFunction->isProgram->varNode->getInit->isAnonymous->varNode->getLineNumber->varNode->getToken->varNode->getFinish->varNode->getName->new->IdentNode->new->ExpressionStatement->accept->return
Lower#leaveWhileNode(WhileNode)::: lower leave while node:::test->whileNode->getTest->body->whileNode->getBody->if->isAlwaysTrue->forNode->whileNode->getLineNumber->whileNode->getToken->whileNode->getFinish->new->ForNode->accept->lc->replace->return->return->checkEscape->addStatement
Lower#leaveWithNode(WithNode)::: lower leave with node:::return->addStatement
Lower#enterClassNode(ClassNode)::: lower enter class node:::throwNotImplementedYet->return->super->enterClassNode
Lower#markerFunction(Expression):::Given a function node that is a callee in a CallNode, replace it with the appropriate marker function:::if->return->setIsFunction->else->if->return->setIsFunction->return
Lower#evalLocation(IdentNode):::Calculate a synthetic eval location for a node for the stacktrace, for example src#17<eval>:::source->lc->getCurrentFunction->getSource->pos->node->position->return->new->StringBuilder->source->getName->append->append->source->getLine->append->append->source->getColumn->append->append->toString
Lower#checkEval(CallNode):::Check whether a call node may be a call to eval:::if->callNode->getFunction->args->callNode->getArgs->callee->callNode->getFunction->if->args->size->EVAL->symbolName->callee->getName->equals->evalArgs->args->size->new->ArrayList<>->foreach->evalArgs->ensureUniqueNamesIn->accept->add->return->callNode->evalLocation->new->CallNode.EvalArgs->setEvalArgs->return
Lower#controlFlowEscapes(LexicalContext, Block):::Helper that given a loop body makes sure that it is not terminal if it has a continue that leads to the loop header or to outer loops' loop headers:::escapes->new->ArrayList<>->loopBody->new->SimpleNodeVisitor->accept->return->escapes->isEmpty
Lower#checkEscape(T)::: lower check escape:::escapes->loopNode->getBody->controlFlowEscapes->if->return->loopNode->loopNode->getBody->setIsTerminal->setBody->setControlFlowEscapes->return
Lower#addStatement(Statement)::: lower add statement:::lc->appendStatement->return
Lower#addStatementEnclosedInBlock(Statement)::: lower add statement enclosed in block:::b->BlockStatement->Collections->singletonList->createReplacement->if->stmt->isTerminal->b->b->getBlock->setIsTerminal->setBlock->addStatement
Lower#isInternalExpression(Expression):::An internal expression has a symbol that is tagged internal:::if->return->symbol->getSymbol->return->symbol->isInternal
Lower#isEvalResultAssignment(Node):::Is this an assignment to the special variable that hosts scripting eval results, i.e:::e->if->lhs->lhs->if->return->getName->RETURN->symbolName->equals->return
Lower#throwNotImplementedYet(String, Node)::: lower throw not implemented yet:::token->node->getToken->line->source->node->getStart->getLine->column->source->node->getStart->getColumn->message->ECMAErrors->getMessage->formatted->ErrorManager->format->throw->new->RuntimeException
MapCreator#makeFieldMap(boolean, boolean, int, int, boolean):::Constructs a property map based on a set of fields.:::properties->new->ArrayList<>->foreach->key->symbol->initialType->tuple->getValueType->if->getArrayIndex->isValidArrayIndex->flags->getPropertyFlags->property->symbol->getFieldIndex->new->AccessorProperty->properties->add->return->PropertyMap->structure->getName->newMap
MapCreator#makeSpillMap(boolean, boolean)::: map creator make spill map:::properties->new->ArrayList<>->spillIndex->foreach->key->symbol->initialType->tuple->getValueType->if->getArrayIndex->isValidArrayIndex->flags->getPropertyFlags->properties->new->SpillProperty->add->return->PropertyMap->structure->getName->newMap
MapCreator#getPropertyFlags(Symbol, boolean, boolean, boolean):::Compute property flags given local state of a field:::flags->if->symbol->isParam->if->if->symbol->isScope->if->symbol->isFunctionDeclaration->if->symbol->isConst->if->symbol->isBlockScoped->if->symbol->isBlockScoped->symbol->isScope->if->return
MapTuple#getValueType()::: map tuple get value type:::return
MapTuple#isPrimitive()::: map tuple is primitive:::return->getValueType->getValueType->isPrimitive->getValueType
MapTuple#toString()::: map tuple to string:::return->value->getClass->getSimpleName
MethodEmitter#begin():::Begin a method:::classEmitter->beginMethod->newStack->method->visitCode
MethodEmitter#end():::End a method:::method->visitMaxs->method->visitEnd->classEmitter->endMethod
MethodEmitter#isReachable()::: method emitter is reachable:::return
MethodEmitter#doesNotContinueSequentially()::: method emitter does not continue sequentially:::
MethodEmitter#newStack()::: method emitter new stack:::new->Label.Stack
MethodEmitter#toString()::: method emitter to string:::return->functionNode->getName->toString->Debug->id
MethodEmitter#pushType(Type):::Push a type to the existing stack:::if->stack->push
MethodEmitter#popType(Type):::Pop a type from the existing stack:::type->popType->return
MethodEmitter#popType():::Pop a type from the existing stack, no matter what it is.:::return->stack->pop
MethodEmitter#popNumeric():::Pop a type from the existing stack, ensuring that it is numeric:::type->popType->if->type->isBoolean->return->return
MethodEmitter#popBitwise():::Pop a type from the existing stack, ensuring that it is an integer type (integer or long):::type->popType->if->return->return
MethodEmitter#popInteger()::: method emitter pop integer:::type->popType->if->return->return
MethodEmitter#popArray():::Pop a type from the existing stack, ensuring that it is an array type, assert if not:::type->popType->return
MethodEmitter#peekType(int):::Peek a given number of slots from the top of the stack and return the type in that slot:::return->stack->peek
MethodEmitter#peekType():::Peek at the type at the top of the stack:::return->stack->peek
MethodEmitter#_new(String, Type):::Generate code a for instantiating a new object and push the object type on the stack:::debug->method->visitTypeInsn->pushType->return
MethodEmitter#_new(Class):::Generate code a for instantiating a new object and push the object type on the stack:::return->className->Type->typeFor->_new
MethodEmitter#newInstance(Class):::Generate code to call the empty constructor for a class:::return->constructorNoLookup->invoke
MethodEmitter#dup(int):::Perform a dup, that is, duplicate the top element and push the duplicate down a given number of positions on the stack:::if->peekType->dup->return->debug->switch->l0->stack->getTopLocalLoad->peekType->pushType->stack->markLocalLoad->break->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->break->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->l2->stack->getTopLocalLoad->p2->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->break->return->return
MethodEmitter#dup2():::Perform a dup2, that is, duplicate the top element if it is a category 2 type, or two top elements if they are category 1 types, and push them on top of the stack:::debug->if->peekType->isCategory2->l0->stack->getTopLocalLoad->peekType->pushType->stack->markLocalLoad->else->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->method->visitInsn->return
MethodEmitter#dup():::Duplicate the top element on the stack and push it:::return->dup
MethodEmitter#pop():::Pop the top element of the stack and throw it away:::peekType->debug->popType->pop->return
MethodEmitter#pop2():::Pop the top element of the stack if category 2 type, or the two top elements of the stack if category 1 types:::if->peekType->isCategory2->popType->else->get2n->return
MethodEmitter#swap():::Swap the top two elements of the stack:::debug->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->p0->swap->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->return
MethodEmitter#pack()::: method emitter pack:::type->peekType->if->type->isInteger->convert->else->if->type->isLong->else->if->type->isNumber->invokestatic->else
MethodEmitter#initializeMethodParameter(Symbol, Type, Label):::Initializes a bytecode method parameter:::localVariableDefs->start->getLabel->new->LocalVariableDef->put
MethodEmitter#newStringBuilder():::Create a new string builder, call the constructor and push the instance to the stack.:::return->constructorNoLookup->invoke->dup
MethodEmitter#stringBuilderAppend():::Pop a string and a StringBuilder from the top of the stack and call the append function of the StringBuilder, appending the string:::convert->return->virtualCallNoLookup->invoke
MethodEmitter#and():::Pops two integer types from the stack, performs a bitwise and and pushes the result:::debug->get2i->and->pushType->return
MethodEmitter#or():::Pops two integer types from the stack, performs a bitwise or and pushes the result:::debug->get2i->or->pushType->return
MethodEmitter#xor():::Pops two integer types from the stack, performs a bitwise xor and pushes the result:::debug->get2i->xor->pushType->return
MethodEmitter#shr():::Pops two integer types from the stack, performs a bitwise logic shift right and pushes the result:::debug->popInteger->popBitwise->shr->pushType->return
MethodEmitter#shl():::Pops two integer types from the stack, performs a bitwise shift left and and pushes the result:::debug->popInteger->popBitwise->shl->pushType->return
MethodEmitter#sar():::Pops two integer types from the stack, performs a bitwise arithmetic shift right and pushes the result:::debug->popInteger->popBitwise->sar->pushType->return
MethodEmitter#neg(int):::Pops a numeric type from the stack, negates it and pushes the result:::debug->popNumeric->neg->pushType->return
MethodEmitter#_catch(Label):::Add label for the start of a catch block and push the exception to the stack:::recovery->onCatch->label->beginCatchBlock
MethodEmitter#_catch(Collection):::Add any number of labels for the start of a catch block and push the exception to the stack:::foreach->label->beginCatchBlock
MethodEmitter#beginCatchBlock()::: method emitter begin catch block:::if->isReachable->newStack->Type->typeFor->pushType
MethodEmitter#_try(Label, Label, Label, Class, boolean):::Start a try/catch block.:::recovery->entry->getStack->joinFromTry->typeDescriptor->CompilerConstants->className->method->entry->getLabel->exit->getLabel->recovery->getLabel->visitTryCatchBlock
MethodEmitter#_try(Label, Label, Label, Class):::Start a try/catch block.:::_try
MethodEmitter#_try(Label, Label, Label):::Start a try/catch block:::_try
MethodEmitter#markLabelAsOptimisticCatchHandler(Label, int)::: method emitter mark label as optimistic catch handler:::label->markAsOptimisticCatchHandler
MethodEmitter#loadConstants():::Load the constants array:::classEmitter->getUnitClassName->CONSTANTS->symbolName->CONSTANTS->descriptor->getStatic->return
MethodEmitter#loadUndefined(Type):::Push the undefined value for the given type, i.e:::debug->type->loadUndefined->pushType->return
MethodEmitter#loadForcedInitializer(Type)::: method emitter load forced initializer:::debug->type->loadForcedInitializer->pushType->return
MethodEmitter#loadEmpty(Type):::Push the empty value for the given type, i.e:::debug->type->loadEmpty->pushType->return
MethodEmitter#loadNull():::Push null to stack:::debug->ldc->pushType->return
MethodEmitter#loadType(String):::Push a handle representing this class top stack:::debug->method->getObjectType->visitLdcInsn->pushType->return
MethodEmitter#load(boolean):::Push a boolean constant to the stack.:::debug->ldc->pushType->return
MethodEmitter#load(int):::Push an int constant to the stack:::debug->ldc->pushType->return
MethodEmitter#load(double):::Push a double constant to the stack:::debug->ldc->pushType->return
MethodEmitter#load(long):::Push an long constant to the stack:::debug->ldc->pushType->return
MethodEmitter#arraylength():::Fetch the length of an array.:::debug->popType->arraylength->pushType->return
MethodEmitter#load(String):::Push a String constant to the stack:::debug->if->loadNull->return->length->s->length->if->_new->dup->load->constructorNoLookup->invoke->for->n->virtualCallNoLookup->invoke->return->ldc->pushType->return
MethodEmitter#load(IdentNode):::Pushes the value of an identifier to the stack:::return->ident->getSymbol->ident->getType->load
MethodEmitter#load(Symbol, Type):::Pushes the value of the symbol to the stack with the specified type:::if->symbol->hasSlot->slot->symbol->getSlot->symbol->getName->debug->load->else->if->symbol->isParam->index->symbol->getFieldIndex->if->functionNode->needsArguments->symbol->getName->debug->loadCompilerConstant->load->invoke->else->symbol->getName->debug->loadCompilerConstant->symbol->getFieldIndex->load->arrayload->return
MethodEmitter#load(Type, int):::Push a local variable to the stack, given an explicit bytecode slot:::debug->loadType->type->load->isThisSlot->pushType->stack->markLocalLoad->return
MethodEmitter#isThisSlot(int)::: method emitter is this slot:::if->return->slot->thisSlot->getCompilerConstantSymbol->getSlot->return
MethodEmitter#loadHandle(String, String, String, EnumSet):::Push a method handle to the stack:::flag->Flag->getValue->debug->new->Handle->ldc->pushType->return
MethodEmitter#getCompilerConstantSymbol(CompilerConstants)::: method emitter get compiler constant symbol:::return->functionNode->getBody->cc->symbolName->getExistingSymbol
MethodEmitter#hasScope():::True if this method has a slot allocated for the scope variable (meaning, something in the method actually needs the scope).:::return->getCompilerConstantSymbol->hasSlot
MethodEmitter#loadCompilerConstant(CompilerConstants)::: method emitter load compiler constant:::return->loadCompilerConstant
MethodEmitter#loadCompilerConstant(CompilerConstants, Type)::: method emitter load compiler constant:::if->peekType->dup->return->return->getCompilerConstantSymbol->getCompilerConstantType->load
MethodEmitter#loadScope()::: method emitter load scope:::return->loadCompilerConstant->checkcast
MethodEmitter#setSplitState(int)::: method emitter set split state:::return->loadScope->load->invoke
MethodEmitter#storeCompilerConstant(CompilerConstants)::: method emitter store compiler constant:::storeCompilerConstant
MethodEmitter#storeCompilerConstant(CompilerConstants, Type)::: method emitter store compiler constant:::symbol->getCompilerConstantSymbol->if->symbol->hasSlot->return->debug->getCompilerConstantType->store
MethodEmitter#getCompilerConstantType(CompilerConstants)::: method emitter get compiler constant type:::constantType->cc->type->return->Type->typeFor
MethodEmitter#arrayload():::Load an element from an array, determining type automatically:::debug->popType->popArray->aload->pushType->return
MethodEmitter#arraystore():::Pop a value, an index and an array from the stack and store the value at the given index in the array.:::debug->value->popType->index->popType->array->popArray->array->astore
MethodEmitter#store(IdentNode):::Pop a value from the stack and store it in a local variable represented by the given identifier:::type->ident->getType->symbol->ident->getSymbol->if->store->else->store
MethodEmitter#closeLocalVariable(Symbol, Label)::: method emitter close local variable:::def->localVariableDefs->get->if->label->getLabel->endLocalValueDef->if->isReachable->markDeadLocalVariable
MethodEmitter#markDeadLocalVariable(Symbol)::: method emitter mark dead local variable:::if->symbol->isDead->symbol->getFirstSlot->symbol->slotCount->markDeadSlots
MethodEmitter#markDeadSlots(int, int)::: method emitter mark dead slots:::stack->markDeadLocalVariables
MethodEmitter#endLocalValueDef(Symbol, LocalVariableDef, jdk.internal.org.objectweb.asm.Label)::: method emitter end local value def:::name->symbol->getName->if->name->THIS->symbolName->equals->THIS_DEBUGGER->symbolName->method->getDescriptor->symbol->getSlot->visitLocalVariable
MethodEmitter#store(Symbol, Type)::: method emitter store:::store
MethodEmitter#store(Symbol, Type, boolean):::Pop a value from the stack and store it in a variable denoted by the given symbol:::if->symbol->hasSlot->isLiveType->symbol->hasSlotFor->existingDef->localVariableDefs->get->if->here->new->jdk.internal.org.objectweb.asm.Label->if->newDef->new->LocalVariableDef->localVariableDefs->put->method->visitLabel->if->endLocalValueDef->if->slot->symbol->getSlot->symbol->getName->debug->storeHidden->else->if->markDeadLocalVariable->symbol->getName->debug->pop->else->if->symbol->isParam->index->symbol->getFieldIndex->if->functionNode->needsArguments->convert->symbol->getName->debug->loadCompilerConstant->load->invoke->else->convert->symbol->getName->debug->loadCompilerConstant->load->invoke->else->symbol->getName->debug->pop
MethodEmitter#storeHidden(Type, int):::Pop a value from the stack and store it in a local variable slot:::storeHidden
MethodEmitter#storeHidden(Type, int, boolean)::: method emitter store hidden:::explicitStore->stack->onLocalStore
MethodEmitter#storeTemp(Type, int)::: method emitter store temp:::explicitStore->type->getSlots->defineTemporaryLocalVariable->onLocalStore
MethodEmitter#onLocalStore(Type, int)::: method emitter on local store:::stack->onLocalStore
MethodEmitter#explicitStore(Type, int)::: method emitter explicit store:::debug->popType->type->store
MethodEmitter#defineBlockLocalVariable(int, int):::Marks a range of slots as belonging to a defined local variable:::stack->defineBlockLocalVariable
MethodEmitter#defineTemporaryLocalVariable(int, int):::Marks a range of slots as belonging to a defined temporary local variable:::stack->defineTemporaryLocalVariable
MethodEmitter#defineTemporaryLocalVariable(int):::Defines a new temporary local variable and returns its allocated index.:::return->stack->defineTemporaryLocalVariable
MethodEmitter#undefineLocalVariables(int, boolean)::: method emitter undefine local variables:::if->isReachable->stack->undefineLocalVariables
MethodEmitter#getLocalVariableTypes()::: method emitter get local variable types:::return
MethodEmitter#getWidestLiveLocals(List)::: method emitter get widest live locals:::return->stack->getWidestLiveLocals
MethodEmitter#markSymbolBoundariesInLvarTypesDescriptor(String)::: method emitter mark symbol boundaries in lvar types descriptor:::return->stack->markSymbolBoundariesInLvarTypesDescriptor
MethodEmitter#iinc(int, int):::Increment/Decrement a local integer by the given value.:::debug->method->visitIincInsn
MethodEmitter#athrow():::Pop an exception object from the stack and generate code for throwing it:::debug->receiver->popType->method->visitInsn->doesNotContinueSequentially
MethodEmitter#_instanceof(String):::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to:::debug->popType->method->visitTypeInsn->pushType->return
MethodEmitter#_instanceof(Class):::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to:::return->CompilerConstants->className->_instanceof
MethodEmitter#checkcast(String):::Perform a checkcast operation on the object at the top of the stack.:::debug->method->visitTypeInsn->return
MethodEmitter#checkcast(Class):::Perform a checkcast operation on the object at the top of the stack.:::return->CompilerConstants->className->checkcast
MethodEmitter#newarray(ArrayType):::Instantiate a new array given a length that is popped from the stack and the array type:::debug->popType->arrayType->newarray->pushType->return
MethodEmitter#multinewarray(ArrayType, int):::Instantiate a multidimensional array with a given number of dimensions:::debug->for->i->arrayType->newarray->pushType->return
MethodEmitter#fixParamStack(String):::Helper function to pop and type check the appropriate arguments from the stack given a method signature:::params->Type->getMethodArguments->for->i->returnType->Type->getMethodReturnType->return
MethodEmitter#invoke(Call):::Generate an invocation to a Call structure:::return->call->invoke
MethodEmitter#invoke(int, String, String, String, boolean)::: method emitter invoke:::returnType->fixParamStack->if->popType->method->visitMethodInsn->if->pushType->return
MethodEmitter#invokespecial(String, String, String):::Pop receiver from stack, perform an invoke special:::debug->return->invoke
MethodEmitter#invokevirtual(String, String, String):::Pop receiver from stack, perform an invoke virtual, push return value if any:::debug->return->invoke
MethodEmitter#invokestatic(String, String, String):::Perform an invoke static and push the return value if any:::debug->invoke->return
MethodEmitter#invokestatic(String, String, String, Type):::Perform an invoke static and replace the return type if we know better, e.g:::invokestatic->popType->pushType->return
MethodEmitter#invokeinterface(String, String, String):::Pop receiver from stack, perform an invoke interface and push return value if any:::debug->return->invoke
MethodEmitter#getLabels(Label...)::: method emitter get labels:::internalLabels->new->jdk.internal.org.objectweb.asm.LabelArr->for->i->return
MethodEmitter#lookupswitch(Label, int[], Label...):::Generate a lookup switch, popping the switch value from the stack:::peekType->debug->adjustStackForSwitch->method->defaultLabel->getLabel->getLabels->visitLookupSwitchInsn->doesNotContinueSequentially
MethodEmitter#tableswitch(int, int, Label, Label...):::Generate a table switch:::peekType->debug->adjustStackForSwitch->method->defaultLabel->getLabel->getLabels->visitTableSwitchInsn->doesNotContinueSequentially
MethodEmitter#adjustStackForSwitch(Label, Label...)::: method emitter adjust stack for switch:::popType->joinTo->foreach->joinTo
MethodEmitter#conditionalJump(Condition, Label):::Abstraction for performing a conditional jump of any type:::conditionalJump
MethodEmitter#conditionalJump(Condition, boolean, Label):::Abstraction for performing a conditional jump of any type, including a dcmpg/dcmpl semantic for doubles.:::if->peekType->isCategory2->debug->get2n->cmp->pushType->Condition->toUnary->jump->else->debug->Condition->peekType->isObject->toBinary->jump
MethodEmitter#_return(Type):::Perform a non void return, popping the type from the stack:::debug->stackType->peekType->if->Type->areEquivalent->convert->popType->_return->doesNotContinueSequentially
MethodEmitter#_return():::Perform a return using the stack top value as the guide for the type:::peekType->_return
MethodEmitter#returnVoid():::Perform a void return.:::debug->method->visitInsn->doesNotContinueSequentially
MethodEmitter#cmp(boolean):::Perform a comparison of two number types that are popped from the stack:::get2n->cmp->pushType->return
MethodEmitter#jump(int, Label, int):::Helper function for jumps, conditional or not:::for->i->joinTo->method->label->getLabel->visitJumpInsn
MethodEmitter#if_acmpeq(Label):::Generate an if_acmpeq:::debug->jump
MethodEmitter#if_acmpne(Label):::Generate an if_acmpne:::debug->jump
MethodEmitter#ifnull(Label):::Generate an ifnull:::debug->jump
MethodEmitter#ifnonnull(Label):::Generate an ifnonnull:::debug->jump
MethodEmitter#ifeq(Label):::Generate an ifeq:::debug->jump
MethodEmitter#if_icmpeq(Label):::Generate an if_icmpeq:::debug->jump
MethodEmitter#ifne(Label):::Generate an if_ne:::debug->jump
MethodEmitter#if_icmpne(Label):::Generate an if_icmpne:::debug->jump
MethodEmitter#iflt(Label):::Generate an iflt:::debug->jump
MethodEmitter#if_icmplt(Label):::Generate an if_icmplt:::debug->jump
MethodEmitter#ifle(Label):::Generate an ifle:::debug->jump
MethodEmitter#if_icmple(Label):::Generate an if_icmple:::debug->jump
MethodEmitter#ifgt(Label):::Generate an ifgt:::debug->jump
MethodEmitter#if_icmpgt(Label):::Generate an if_icmpgt:::debug->jump
MethodEmitter#ifge(Label):::Generate an ifge:::debug->jump
MethodEmitter#if_icmpge(Label):::Generate an if_icmpge:::debug->jump
MethodEmitter#_goto(Label):::Unconditional jump to a label:::debug->jump->doesNotContinueSequentially
MethodEmitter#gotoLoopStart(Label):::Unconditional jump to the start label of a loop:::debug->jump
MethodEmitter#uncheckedGoto(Label):::Unconditional jump without any control flow and data flow testing:::method->target->getLabel->visitJumpInsn
MethodEmitter#canThrow(Label):::Potential transfer of control to a catch block.:::catchLabel->joinFromTry
MethodEmitter#joinTo(Label):::A join in control flow - helper function that makes sure all entry stacks discovered for the join point so far are equivalent  MergeStack: we are about to enter a label:::label->joinFrom
MethodEmitter#label(Label):::Register a new label, enter it here.:::breakLabel
MethodEmitter#breakLabel(Label, int):::Register a new break target label, enter it here.:::if->isReachable->else->joinTo->labelStack->label->getStack->labelStack->clone->if->label->isBreakTarget->debug_label->method->label->getLabel->visitLabel
MethodEmitter#convert(Type):::Pop element from stack, convert to given type:::from->peekType->type->from->convert->if->if->from->isEquivalentTo->debug->if->l0->stack->getTopLocalLoad->popType->pushType->if->from->isObject->stack->markLocalLoad->return
MethodEmitter#get2():::Helper function - expect two types that are equivalent:::p0->popType->p1->popType->return
MethodEmitter#get2i():::Helper function - expect two types that are integer types and equivalent:::p0->popBitwise->p1->popBitwise->return
MethodEmitter#get2n():::Helper function - expect two types that are numbers and equivalent:::p0->popNumeric->p1->popNumeric->return
MethodEmitter#add(int):::Pop two numbers, perform addition and push result:::debug->get2->add->pushType->return
MethodEmitter#sub(int):::Pop two numbers, perform subtraction and push result:::debug->get2n->sub->pushType->return
MethodEmitter#mul(int):::Pop two numbers, perform multiplication and push result:::debug->get2n->mul->pushType->return
MethodEmitter#div(int):::Pop two numbers, perform division and push result:::debug->get2n->div->pushType->return
MethodEmitter#rem(int):::Pop two numbers, calculate remainder and push result:::debug->get2n->rem->pushType->return
MethodEmitter#getTypesFromStack(int):::Retrieve the top count types on the stack without modifying it.:::return->stack->getTopTypes
MethodEmitter#getLocalLoadsOnStack(int, int)::: method emitter get local loads on stack:::return->stack->getLocalLoads
MethodEmitter#getStackSize()::: method emitter get stack size:::return->stack->size
MethodEmitter#getFirstTemp()::: method emitter get first temp:::return
MethodEmitter#getUsedSlotsWithLiveTemporaries()::: method emitter get used slots with live temporaries:::return->stack->getUsedSlotsWithLiveTemporaries
MethodEmitter#getDynamicSignature(Type, int):::Helper function to generate a function signature based on stack contents and argument count and return type:::paramTypes->new->TypeArr->pos->for->i->descriptor->Type->getMethodDescriptor->for->i->return
MethodEmitter#invalidateSpecialName(String)::: method emitter invalidate special name:::switch->debug->load->invoke->break->break->return
MethodEmitter#dynamicNew(int, int):::Generate a dynamic new:::return->dynamicNew
MethodEmitter#dynamicNew(int, int, String):::Generate a dynamic new:::debug->signature->getDynamicSignature->method->msg->length->NameCodec->encode->visitInvokeDynamicInsn->pushType->return
MethodEmitter#dynamicCall(Type, int, int):::Generate a dynamic call:::return->dynamicCall
MethodEmitter#dynamicCall(Type, int, int, String):::Generate a dynamic call:::debug->signature->getDynamicSignature->debug->method->msg->length->NameCodec->encode->visitInvokeDynamicInsn->pushType->return
MethodEmitter#dynamicArrayPopulatorCall(int, int)::: method emitter dynamic array populator call:::debug->signature->getDynamicSignature->method->visitInvokeDynamicInsn->pushType->return
MethodEmitter#dynamicGet(Type, String, int, boolean, boolean):::Generate dynamic getter:::if->name->length->return->load->dynamicGetIndex->getProgramPoint->debug->type->if->type->isObject->type->isBoolean->popType->method->NameCodec->encode->Type->getMethodDescriptor->dynGetOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#dynamicSet(String, int, boolean):::Generate dynamic setter:::if->name->length->load->swap->dynamicSetIndex->return->peekType->debug->type->peekType->if->type->isObject->type->isBoolean->convert->popType->popType->method->NameCodec->encode->type->getTypeClass->methodDescriptor->dynSetOperation->visitInvokeDynamicInsn
MethodEmitter#dynamicRemove(String, int, boolean):::Generate dynamic remover:::if->name->length->return->load->dynamicRemoveIndex->getProgramPoint->debug->popType->method->NameCodec->encode->Type->getMethodDescriptor->dynRemoveOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#dynamicGetIndex(Type, int, boolean):::Dynamic getter for indexed structures:::peekType->peekType->getProgramPoint->debug->resultType->if->result->isBoolean->index->peekType->if->index->isObject->index->isBoolean->convert->popType->popType->signature->Type->getMethodDescriptor->method->dynGetOperation->visitInvokeDynamicInsn->pushType->if->result->isBoolean->convert->return
MethodEmitter#getProgramPoint(int)::: method emitter get program point:::if->return->return->String->valueOf
MethodEmitter#dynamicSetIndex(int):::Dynamic setter for indexed structures:::peekType->peekType->peekType->debug->value->peekType->if->value->isObject->value->isBoolean->convert->popType->index->peekType->if->index->isObject->index->isBoolean->convert->popType->receiver->popType->method->receiver->getTypeClass->index->getTypeClass->value->getTypeClass->methodDescriptor->visitInvokeDynamicInsn
MethodEmitter#dynamicRemoveIndex(int):::Dynamic remover for indexed structures:::peekType->peekType->getProgramPoint->debug->index->peekType->if->index->isObject->index->isBoolean->convert->popType->popType->signature->Type->getMethodDescriptor->method->dynRemoveOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#loadKey(Object)::: method emitter load key:::if->method->getName->visitLdcInsn->else->if->method->getString->visitLdcInsn->else->method->JSType->toString->visitLdcInsn->pushType->return
MethodEmitter#fieldType(String)::: method emitter field type:::switch->return->return->return->switch->desc->charAt->return->return->Type->Array->desc->substring->fieldType->getTypeClass->newInstance->getClass->typeFor->return
MethodEmitter#getField(FieldAccess):::Generate get for a field access:::return->fa->get
MethodEmitter#putField(FieldAccess):::Generate set for a field access:::fa->put
MethodEmitter#getField(String, String, String):::Get the value of a non-static field, pop the receiver from the stack, push value to the stack:::peekType->debug->receiver->popType->method->visitFieldInsn->fieldType->pushType->return
MethodEmitter#getStatic(String, String, String):::Get the value of a static field, push it to the stack:::debug->method->visitFieldInsn->fieldType->pushType->return
MethodEmitter#putField(String, String, String):::Pop value and field from stack and write to a non-static field:::peekType->peekType->debug->fieldType->popType->popType->method->visitFieldInsn
MethodEmitter#putStatic(String, String, String):::Pop value from stack and write to a static field:::peekType->debug->fieldType->popType->method->visitFieldInsn
MethodEmitter#lineNumber(int):::Register line number at a label:::if->context->getEnv->debug_label->l->new->jdk.internal.org.objectweb.asm.Label->method->visitLabel->method->visitLineNumber
MethodEmitter#beforeJoinPoint(JoinPredecessor)::: method emitter before join point:::next->joinPredecessor->getLocalVariableConversion->while->symbol->next->getSymbol->if->next->isLive->emitLocalVariableConversion->else->markDeadLocalVariable->next->getNext
MethodEmitter#beforeTry(TryNode, Label)::: method emitter before try:::next->tryNode->getLocalVariableConversion->while->if->next->isLive->to->emitLocalVariableConversion->recovery->getStack->next->getSymbol->getSlot->onLocalStore->next->getNext
MethodEmitter#dynGetOperation(boolean, boolean)::: method emitter dyn get operation:::if->return->else->return
MethodEmitter#dynSetOperation(boolean)::: method emitter dyn set operation:::return
MethodEmitter#dynRemoveOperation(boolean)::: method emitter dyn remove operation:::return
MethodEmitter#emitLocalVariableConversion(LocalVariableConversion, boolean)::: method emitter emit local variable conversion:::from->conversion->getFrom->to->conversion->getTo->symbol->conversion->getSymbol->if->loadUndefined->else->load->convert->store->return
MethodEmitter#print():::Emit a System.err.print statement of whatever is on top of the bytecode stack:::getField->swap->convert->invoke
MethodEmitter#println():::Emit a System.err.println statement of whatever is on top of the bytecode stack:::getField->swap->convert->invoke
MethodEmitter#print(String):::Emit a System.err.print statement:::getField->load->invoke
MethodEmitter#println(String):::Emit a System.err.println statement:::getField->load->invoke
MethodEmitter#stacktrace():::Print a stacktrace to S:::_new->dup->constructorNoLookup->invoke->invoke
MethodEmitter#debug(Object...):::Debug function that outputs generated bytecode and stack contents:::if->debug
MethodEmitter#debug(String)::: method emitter debug:::if->debug
MethodEmitter#debug(Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug(Object, Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug(Object, Object, Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug(Object, Object, Object, Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug(Object, Object, Object, Object, Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug(Object, Object, Object, Object, Object, Object, Object)::: method emitter debug:::if->new->ObjectArr->debug
MethodEmitter#debug_label(Object...):::Debug function that outputs generated bytecode and stack contents for a label - indentation is currently the only thing that differs:::if->debug
MethodEmitter#debug(int, Object...)::: method emitter debug:::if->sb->new->StringBuilder->pad->sb->append->sb->append->sb->length->while->sb->append->if->isReachable->stack->isEmpty->sb->append->sb->stack->size->append->sb->append->for->pos->stack->size->sb->append->sb->append->sb->length->while->sb->append->foreach->sb->append->sb->append->if->context->getEnv->log->info->if->new->Throwable->log->getOutputStream->printStackTrace
MethodEmitter#setFunctionNode(FunctionNode):::Set the current function node being emitted:::
MethodEmitter#setPreventUndefinedLoad():::Invoke to enforce assertions preventing load from a local variable slot that's known to not have been written to:::
MethodEmitter#isOptimistic(int)::: method emitter is optimistic:::return
Namespace#getParent():::Return the parent Namespace of this space.:::return
Namespace#uniqueName(String):::Create a uniqueName name in the namespace in the form base-n where n varies:::truncatedBase->base->length->base->substring->for->namespace->namespace->getParent->directory->put->return
Namespace#toString()::: namespace to string:::return->directory->toString
ObjectClassGenerator#getLogger()::: object class generator get logger:::return
ObjectClassGenerator#initLogger(Context)::: object class generator init logger:::return->ctxt->this->getClass->getLogger
ObjectClassGenerator#pack(Number):::Pack a number into a primitive long field:::if->return->n->intValue->else->if->return->n->longValue->else->if->return->Double->n->doubleValue->doubleToRawLongBits->throw->new->AssertionError
ObjectClassGenerator#getPrefixName(boolean)::: object class generator get prefix name:::return->JS_OBJECT_DUAL_FIELD_PREFIX->symbolName->JS_OBJECT_SINGLE_FIELD_PREFIX->symbolName
ObjectClassGenerator#getPrefixName(String)::: object class generator get prefix name:::if->className->JS_OBJECT_DUAL_FIELD_PREFIX->symbolName->startsWith->return->getPrefixName->else->if->className->JS_OBJECT_SINGLE_FIELD_PREFIX->symbolName->startsWith->return->getPrefixName->throw->new->AssertionError
ObjectClassGenerator#getClassName(int, boolean):::Returns the class name for JavaScript objects with fieldCount fields.:::prefix->getPrefixName->return
ObjectClassGenerator#getClassName(int, int, boolean):::Returns the class name for JavaScript scope with fieldCount fields and paramCount parameters.:::return->getPrefixName
ObjectClassGenerator#getFieldCount(Class):::Returns the number of fields in the JavaScript scope class:::name->clazz->getSimpleName->prefix->getPrefixName->if->prefix->equals->return->scopeMarker->name->indexOf->return->Integer->name->prefix->length->substring->name->prefix->length->substring->parseInt
ObjectClassGenerator#getFieldName(int, Type):::Returns the name of a field based on number and type.:::return->type->getDescriptor->substring
ObjectClassGenerator#initializeToUndefined(MethodEmitter, String, List):::In the world of Object fields, we also have no undefined SwitchPoint, to reduce as much potential MethodHandle overhead as possible:::if->return->if->fieldNames->isEmpty->return->init->JAVA_THIS->slot->load->init->loadUndefined->iter->fieldNames->iterator->while->iter->hasNext->fieldName->iter->next->if->iter->hasNext->init->dup2->init->getDescriptor->putField
ObjectClassGenerator#generate(String):::Generate the byte codes for a JavaScript object class or scope:::counts->descriptor->split->fieldCount->Integer->valueOf->if->return->generate->paramCount->Integer->valueOf->return->generate
ObjectClassGenerator#generate(int):::Generate the byte codes for a JavaScript object class with fieldCount fields.:::className->getClassName->superName->className->classEmitter->newClassEmitter->addFields->init->newInitMethod->init->returnVoid->init->end->initWithSpillArrays->newInitWithSpillArraysMethod->initWithSpillArrays->returnVoid->initWithSpillArrays->end->newEmptyInit->newAllocate->return->toByteArray
ObjectClassGenerator#generate(int, int):::Generate the byte codes for a JavaScript scope class with fieldCount fields and paramCount parameters.:::className->getClassName->superName->className->classEmitter->newClassEmitter->initFields->addFields->init->newInitScopeMethod->initializeToUndefined->init->returnVoid->init->end->initWithSpillArrays->newInitWithSpillArraysMethod->initializeToUndefined->initWithSpillArrays->returnVoid->initWithSpillArrays->end->initWithArguments->newInitScopeWithArgumentsMethod->initializeToUndefined->initWithArguments->returnVoid->initWithArguments->end->return->toByteArray
ObjectClassGenerator#addFields(ClassEmitter, int):::Generates the needed fields.:::initFields->new->LinkedList<>->fieldTypes->for->i->return
ObjectClassGenerator#newClassEmitter(String, String):::Allocate and initialize a new class emitter.:::classEmitter->new->ClassEmitter->classEmitter->begin->return
ObjectClassGenerator#newInitMethod(ClassEmitter):::Allocate and initialize a new <init> method.:::init->classEmitter->init->init->begin->init->JAVA_THIS->slot->load->init->INIT_MAP->slot->load->init->constructorNoLookup->invoke->return
ObjectClassGenerator#newInitWithSpillArraysMethod(ClassEmitter, Class)::: object class generator new init with spill arrays method:::init->classEmitter->init->init->begin->init->JAVA_THIS->slot->load->init->INIT_MAP->slot->load->init->load->init->load->init->constructorNoLookup->invoke->return
ObjectClassGenerator#newInitScopeMethod(ClassEmitter):::Allocate and initialize a new <init> method for scopes.:::init->classEmitter->init->init->begin->init->JAVA_THIS->slot->load->init->INIT_MAP->slot->load->init->INIT_SCOPE->slot->load->init->constructorNoLookup->invoke->return
ObjectClassGenerator#newInitScopeWithArgumentsMethod(ClassEmitter):::Allocate and initialize a new <init> method for scopes with arguments.:::init->classEmitter->init->init->begin->init->JAVA_THIS->slot->load->init->INIT_MAP->slot->load->init->INIT_SCOPE->slot->load->init->INIT_ARGUMENTS->slot->load->init->constructorNoLookup->invoke->return
ObjectClassGenerator#newEmptyInit(String, ClassEmitter):::Add an empty <init> method to the JavaScript class.:::emptyInit->classEmitter->init->emptyInit->begin->emptyInit->JAVA_THIS->slot->load->emptyInit->loadNull->emptyInit->constructorNoLookup->invoke->emptyInit->returnVoid->emptyInit->end
ObjectClassGenerator#newAllocate(String, ClassEmitter):::Add an empty <init> method to the JavaScript class.:::allocate->classEmitter->EnumSet->of->ALLOCATE->symbolName->method->allocate->begin->allocate->Type->typeFor->_new->allocate->dup->allocate->Type->typeFor->load->allocate->constructorNoLookup->invoke->allocate->_return->allocate->end
ObjectClassGenerator#toByteArray(String, ClassEmitter):::Collects the byte codes for a generated JavaScript class.:::classEmitter->end->code->classEmitter->toByteArray->env->context->getEnv->DumpBytecode->dumpBytecode->if->context->verify->return
ObjectClassGenerator#getDifferent(Object, Class, MethodHandle, MethodHandle, int)::: object class generator get different:::sameTypeGetter->getterForType->mh->MH->sameTypeGetter->type->changeReturnType->asType->try->value->mh->invokeExact->throw->new->UnwarrantedOptimismException->catch->throw->throw->new->RuntimeException->finally
ObjectClassGenerator#getDifferentUndefined(int)::: object class generator get different undefined:::throw->Undefined->getUndefined->new->UnwarrantedOptimismException
ObjectClassGenerator#getterForType(Class, MethodHandle, MethodHandle)::: object class generator getter for type:::switch->getAccessorTypeIndex->return->MH->primitiveGetter->type->changeReturnType->explicitCastArguments->return->MH->filterReturnValue->return->throw->new->AssertionError
ObjectClassGenerator#createGetterInner(Class, Class, MethodHandle, MethodHandle, List, int)::: object class generator create getter inner:::fti->getAccessorTypeIndex->ti->getAccessorTypeIndex->isOptimistic->isPrimitiveStorage->forType->isPrimitive->getter->if->if->if->return->MH->GET_UNDEFINED->get->dropArguments->return->MH->MH->MH->insertArguments->dropArguments->getter->type->changeReturnType->asType->return->MH->GET_UNDEFINED->get->dropArguments->if->if->tgetter->getterForType->return->MH->tgetter->type->changeReturnType->asType->else->if->return->getterForType->else->if->return->MH->MH->converters->get->insertArguments->filterReturnValue->return->MH->MH->MH->insertArguments->filterArguments->objectGetter->type->changeReturnType->asType->tgetter->getterForType->if->if->return->MH->CONVERT_OBJECT->get->filterReturnValue->return->tgetterType->tgetter->type->switch->return->MH->tgetterType->changeReturnType->asType->switch->return->MH->filterReturnValue->return->return->MH->tgetterType->changeReturnType->asType->throw->new->UnsupportedOperationException
ObjectClassGenerator#createGetter(Class, Class, MethodHandle, MethodHandle, int):::Given a primitiveGetter (optional for non dual fields) and an objectSetter that retrieve the primitive and object version of a field respectively, return one with the correct method type and the correct filters:::return->isValid->createGetterInner
ObjectClassGenerator#createSetter(Class, Class, MethodHandle, MethodHandle):::This is similar to the ObjectClassGenerator#createGetter function:::fti->getAccessorTypeIndex->ti->getAccessorTypeIndex->if->if->return->return->MH->objectSetter->type->changeParameterType->asType->pmt->primitiveSetter->type->switch->switch->return->MH->pmt->changeParameterType->asType->return->MH->filterArguments->return->if->return->return->MH->MH->filterArguments->pmt->changeParameterType->asType->throw->new->UnsupportedOperationException
ObjectClassGenerator#isType(Class, Object)::: object class generator is type:::return->x->getClass
ObjectClassGenerator#getBoxedType(Class)::: object class generator get boxed type:::if->return->if->return->if->return->return
ObjectClassGenerator#createGuardBoxedPrimitiveSetter(Class, MethodHandle, MethodHandle):::If we are setting boxed types (because the compiler couldn't determine which they were) to a primitive field, we can reuse the primitive field getter, as long as we are setting an element of the same boxed type as the primitive type representation:::boxedForType->getBoxedType->return->MH->MH->MH->dropArguments->insertArguments->MH->objectSetter->type->asType->guardWithTest
ObjectClassGenerator#getPaddedFieldCount(int):::Add padding to field count to avoid creating too many classes and have some spare fields:::return
ObjectClassGenerator#findOwnMH(String, Class, Class...)::: object class generator find own h:::return->MH->MethodHandles->lookup->MH->type->findStatic
ObjectClassGenerator#createAllocationStrategy(int, boolean):::Creates the allocator class name and property map for a constructor function with the specified number of "this" properties that it initializes.:::paddedFieldCount->getPaddedFieldCount->return->new->AllocationStrategy
ObjectCreator#makeObject(MethodEmitter):::Generate code for making the object.:::createObject->objectSlot->method->getUsedSlotsWithLiveTemporaries->objectType->method->peekType->method->storeTemp->tuples->size->populateRange
ObjectCreator#createObject(MethodEmitter):::Generate code for creating and initializing the object.:::
ObjectCreator#makeMap():::Construct the property map appropriate for the object.:::
ObjectCreator#newMapCreator(Class):::Create a new MapCreator:::return->new->MapCreator<>
ObjectCreator#loadScope(MethodEmitter):::Loads the scope on the stack through the passed method emitter.:::method->loadCompilerConstant
ObjectCreator#loadMap(MethodEmitter):::Emit the correct map for the object.:::codegen->loadConstant->return
ObjectCreator#getMap()::: object creator get map:::return
ObjectCreator#isScope():::Is this a scope object:::return
ObjectCreator#hasArguments():::Does the created object have an "arguments" property:::return
ObjectCreator#getAllocatorClass():::Get the class of objects created by this ObjectCreator:::
ObjectCreator#loadValue(T, Type):::Technique for loading an initial value:::
ObjectCreator#loadTuple(MethodEmitter, MapTuple, boolean)::: object creator load tuple:::loadValue->if->codegen->useDualFields->tuple->isPrimitive->method->convert->else->if->method->pack->return
ObjectCreator#loadIndex(MethodEmitter, long)::: object creator load index:::return->JSType->isRepresentableAsInt->method->load->method->load
OptimisticTypesCalculator#enterAccessNode(AccessNode)::: optimistic types calculator enter access node:::accessNode->getBase->tagNeverOptimistic->return
OptimisticTypesCalculator#enterPropertyNode(PropertyNode)::: optimistic types calculator enter property node:::if->propertyNode->getKeyName->equals->propertyNode->getValue->tagNeverOptimistic->return->super->enterPropertyNode
OptimisticTypesCalculator#enterBinaryNode(BinaryNode)::: optimistic types calculator enter binary node:::if->binaryNode->isAssignment->lhs->binaryNode->lhs->if->binaryNode->isSelfModifying->tagNeverOptimistic->if->symbol->getSymbol->if->symbol->isInternal->binaryNode->rhs->isSelfModifying->binaryNode->rhs->tagNeverOptimistic->else->if->binaryNode->isTokenType->binaryNode->isTokenType->binaryNode->isTokenType->binaryNode->lhs->tagNeverOptimistic->binaryNode->rhs->tagNeverOptimistic->return
OptimisticTypesCalculator#enterCallNode(CallNode)::: optimistic types calculator enter call node:::callNode->getFunction->tagNeverOptimistic->return
OptimisticTypesCalculator#enterCatchNode(CatchNode)::: optimistic types calculator enter catch node:::catchNode->getExceptionCondition->tagNeverOptimistic->return
OptimisticTypesCalculator#enterExpressionStatement(ExpressionStatement)::: optimistic types calculator enter expression statement:::expr->expressionStatement->getExpression->if->expr->isSelfModifying->tagNeverOptimistic->return
OptimisticTypesCalculator#enterForNode(ForNode)::: optimistic types calculator enter for node:::if->forNode->isForInOrOf->forNode->getModify->tagNeverOptimistic->else->tagNeverOptimisticLoopTest->return
OptimisticTypesCalculator#enterFunctionNode(FunctionNode)::: optimistic types calculator enter function node:::if->neverOptimistic->isEmpty->compiler->isOnDemandCompilation->return->neverOptimistic->new->BitSet->push->return
OptimisticTypesCalculator#enterIfNode(IfNode)::: optimistic types calculator enter if node:::ifNode->getTest->tagNeverOptimistic->return
OptimisticTypesCalculator#enterIndexNode(IndexNode)::: optimistic types calculator enter index node:::indexNode->getBase->tagNeverOptimistic->return
OptimisticTypesCalculator#enterTernaryNode(TernaryNode)::: optimistic types calculator enter ternary node:::ternaryNode->getTest->tagNeverOptimistic->return
OptimisticTypesCalculator#enterUnaryNode(UnaryNode)::: optimistic types calculator enter unary node:::if->unaryNode->isTokenType->unaryNode->isTokenType->unaryNode->getExpression->tagNeverOptimistic->return
OptimisticTypesCalculator#enterVarNode(VarNode)::: optimistic types calculator enter var node:::varNode->getName->tagNeverOptimistic->return
OptimisticTypesCalculator#enterObjectNode(ObjectNode)::: optimistic types calculator enter object node:::if->objectNode->getSplitRanges->return->return->super->enterObjectNode
OptimisticTypesCalculator#enterLiteralNode(LiteralNode)::: optimistic types calculator enter literal node:::if->literalNode->isArray->getSplitRanges->return->return->super->enterLiteralNode
OptimisticTypesCalculator#enterWhileNode(WhileNode)::: optimistic types calculator enter while node:::tagNeverOptimisticLoopTest->return
OptimisticTypesCalculator#leaveDefault(Node)::: optimistic types calculator leave default:::if->return->leaveOptimistic->return
OptimisticTypesCalculator#leaveFunctionNode(FunctionNode)::: optimistic types calculator leave function node:::neverOptimistic->pop->return
OptimisticTypesCalculator#leaveIdentNode(IdentNode)::: optimistic types calculator leave ident node:::symbol->identNode->getSymbol->if->return->else->if->symbol->isBytecodeLocal->return->else->if->symbol->isParam->lc->getCurrentFunction->isVarArg->return->identNode->identNode->getMostPessimisticType->setType->else->return->leaveOptimistic
OptimisticTypesCalculator#leaveOptimistic(Optimistic)::: optimistic types calculator leave optimistic:::pp->opt->getProgramPoint->if->isValid->neverOptimistic->peek->get->return->opt->compiler->getOptimisticType->setType->return
OptimisticTypesCalculator#tagNeverOptimistic(Expression)::: optimistic types calculator tag never optimistic:::if->pp->getProgramPoint->if->isValid->neverOptimistic->peek->set
OptimisticTypesCalculator#tagNeverOptimisticLoopTest(LoopNode)::: optimistic types calculator tag never optimistic loop test:::test->loopNode->getTest->if->test->getExpression->tagNeverOptimistic
OptimisticTypesPersistence#getLocationDescriptor(Source, int, Type[]):::Retrieves an opaque descriptor for the persistence location for a given function:::if->return->b->new->StringBuilder->b->source->getDigest->append->append->append->if->b->append->foreach->b->Type->getShortSignatureDescriptor->append->return->b->toString->new->File->new->LocationDescriptor
OptimisticTypesPersistence#store(Object, Map):::Stores the map of optimistic types for a given function.:::if->optimisticTypes->isEmpty->return->file->AccessController->new->PrivilegedAction<Void>->doPrivileged
OptimisticTypesPersistence#load(Object):::Loads the map of optimistic types for a given function.:::if->return->file->return->AccessController->new->PrivilegedAction<Map<Integer,Type>>->doPrivileged
OptimisticTypesPersistence#reportError(String, File, Exception)::: optimistic types persistence report error:::now->System->currentTimeMillis->if->String->format->reportError
OptimisticTypesPersistence#reportError(String, Exception):::Logs an error message with warning severity (reasoning being that we're reporting an error that'll disable the type info cache, but it's only logged as a warning because that doesn't prevent Nashorn from running, it just disables a performance-enhancing cache).:::getLogger->exceptionToString->warning
OptimisticTypesPersistence#exceptionToString(Exception):::A helper that prints an exception stack trace into a string:::sw->new->StringWriter->pw->new->PrintWriter->e->printStackTrace->pw->flush->return->sw->toString
OptimisticTypesPersistence#createBaseCacheDir()::: optimistic types persistence create base cache dir:::if->Options->getBooleanProperty->return->try->return->createBaseCacheDirPrivileged->catch->reportError->return->finally
OptimisticTypesPersistence#createBaseCacheDirPrivileged()::: optimistic types persistence create base cache dir privileged:::return->AccessController->new->PrivilegedAction<File>->doPrivileged
OptimisticTypesPersistence#createCacheDir(File)::: optimistic types persistence create cache dir:::if->return->try->return->createCacheDirPrivileged->catch->reportError->return->finally
OptimisticTypesPersistence#createCacheDirPrivileged(File)::: optimistic types persistence create cache dir privileged:::return->AccessController->new->PrivilegedAction<File>->doPrivileged
OptimisticTypesPersistence#getSystemCacheDir():::Returns an operating system specific root directory for cache files.:::os->System->getProperty->if->equals->return->System->getProperty->new->File->new->File->else->if->os->startsWith->return->System->getProperty->new->File->else->return->System->getProperty->new->File
OptimisticTypesPersistence#getVersionDirName():::In order to ensure that changes in Nashorn code don't cause corruption in the data, we'll create a per-code-version directory:::url->getResource->protocol->url->getProtocol->if->protocol->equals->jarUrlFile->url->getFile->filePath->jarUrlFile->jarUrlFile->indexOf->substring->file->new->URL->try->in->file->openStream->buf->new->byteArr->digest->MessageDigest->getInstance->for->catch->finally->else->if->protocol->equals->fileStr->url->getFile->className->getName->packageNameLen->className->lastIndexOf->dirStr->fileStr->fileStr->length->ANCHOR_PROPS->length->substring->dir->new->File->return->new->SimpleDateFormat->getLastModifiedClassFile->new->Date->format->else->if->protocol->equals->return->getJrtVersionDirName->else->throw->new->AssertionError
OptimisticTypesPersistence#getLastModifiedClassFile(File, long)::: optimistic types persistence get last modified class file:::currentMax->foreach->dir->listFiles->if->f->getName->endsWith->lastModified->f->lastModified->if->else->if->f->isDirectory->lastModified->getLastModifiedClassFile->if->return
OptimisticTypesPersistence#isSymbolicLink(File):::Returns true if the specified file is a symbolic link, and also logs a warning if it is.:::if->Files->file->toPath->isSymbolicLink->getLogger->warning->return->return
OptimisticTypesPersistence#createLockArray()::: optimistic types persistence create lock array:::lockArray->Runtime->getRuntime->availableProcessors->new->ObjectArr->for->i->return
OptimisticTypesPersistence#getFileLock(File)::: optimistic types persistence get file lock:::return->file->hashCode
OptimisticTypesPersistence#getLogger()::: optimistic types persistence get logger:::try->return->Context->getContext->getLogger->catch->e->printStackTrace->finally->return
OptimisticTypesPersistence#scheduleCleanup()::: optimistic types persistence schedule cleanup:::if->scheduledCleanup->compareAndSet->cleanupTimer->new->TimerTask->toMillis->schedule
OptimisticTypesPersistence#doCleanup()::: optimistic types persistence do cleanup:::files->getAllRegularFilesInLastModifiedOrder->nFiles->filesToDelete->Math->max->filesDeleted->for->i
OptimisticTypesPersistence#getAllRegularFilesInLastModifiedOrder()::: optimistic types persistence get all regular files in last modified order:::try->filesStream->Files->baseCacheDir->toPath->walk->return->filesStream->new->Predicate<Path>->filter->new->Function<Path,PathAndTime>->map->sorted->new->Function<PathAndTime,Path>->map->new->IntFunction<Path[]>->toArray->catch->finally
OptimisticTypesPersistence.PathAndTime#compareTo(PathAndTime)::: path and time compare to:::return->Long->compare
OptimisticTypesPersistence.PathAndTime#getTime(Path)::: path and time get time:::try->return->Files->getLastModifiedTime->toMillis->catch->return->finally
OptimisticTypesPersistence#getMaxFiles()::: optimistic types persistence get max files:::str->Options->getStringProperty->if->return->else->if->equals->return->return->Math->Integer->parseInt->max
OptimisticTypesPersistence#getJrtVersionDirName()::: optimistic types persistence get jrt version dir name:::fs->getJrtFileSystem->nashorn->fs->getPath->if->Files->isDirectory->throw->new->FileNotFoundException->digest->MessageDigest->getInstance->Files->walk->new->Consumer<Path>->forEach->return->Base64->getUrlEncoder->withoutPadding->digest->digest->encodeToString
OptimisticTypesPersistence#getJrtFileSystem()::: optimistic types persistence get jrt file system:::return->AccessController->new->PrivilegedAction<FileSystem>->doPrivileged
ProgramPoints#next()::: program points next:::next->nextProgramPoint->getAndIncrement->if->throw->new->AssertionError->return
ProgramPoints#enterFunctionNode(FunctionNode)::: program points enter function node:::nextProgramPoint->push->return
ProgramPoints#leaveFunctionNode(FunctionNode)::: program points leave function node:::nextProgramPoint->pop->return
ProgramPoints#setProgramPoint(Optimistic)::: program points set program point:::if->noProgramPoint->contains->return->return->optimistic->canBeOptimistic->optimistic->next->setProgramPoint
ProgramPoints#enterVarNode(VarNode)::: program points enter var node:::noProgramPoint->varNode->getName->add->return
ProgramPoints#enterIdentNode(IdentNode)::: program points enter ident node:::if->identNode->isInternal->noProgramPoint->add->return
ProgramPoints#leaveIdentNode(IdentNode)::: program points leave ident node:::if->identNode->isPropertyName->return->return->setProgramPoint
ProgramPoints#leaveCallNode(CallNode)::: program points leave call node:::return->setProgramPoint
ProgramPoints#leaveAccessNode(AccessNode)::: program points leave access node:::return->setProgramPoint
ProgramPoints#leaveIndexNode(IndexNode)::: program points leave index node:::return->setProgramPoint
ProgramPoints#leaveBinaryNode(BinaryNode)::: program points leave binary node:::return->setProgramPoint
ProgramPoints#leaveUnaryNode(UnaryNode)::: program points leave unary node:::return->setProgramPoint
ReplaceCompileUnits#getReplacement(CompileUnit):::Override to provide a replacement for an old compile unit.:::
ReplaceCompileUnits#getExistingReplacement(CompileUnitHolder)::: replace compile units get existing replacement:::oldUnit->node->getCompileUnit->newUnit->getReplacement->return
ReplaceCompileUnits#leaveFunctionNode(FunctionNode)::: replace compile units leave function node:::return->node->getExistingReplacement->setCompileUnit
ReplaceCompileUnits#leaveLiteralNode(LiteralNode)::: replace compile units leave literal node:::if->aln->if->aln->getSplitRanges->return->newArrayUnits->new->ArrayList<>->foreach->aln->getSplitRanges->newArrayUnits->getExistingReplacement->au->getLow->au->getHigh->new->Splittable.SplitRange->add->return->aln->setSplitRanges->return
ReplaceCompileUnits#leaveObjectNode(ObjectNode)::: replace compile units leave object node:::ranges->objectNode->getSplitRanges->if->newRanges->new->ArrayList<>->foreach->newRanges->getExistingReplacement->range->getLow->range->getHigh->new->Splittable.SplitRange->add->return->objectNode->setSplitRanges->return->super->leaveObjectNode
SharedScopeCall#hashCode()::: shared scope call hash code:::return->symbol->hashCode->returnType->hashCode->Arrays->hashCode->Boolean->hashCode
SharedScopeCall#equals(Object)::: shared scope call equals:::if->c->return->symbol->equals->returnType->equals->Arrays->equals->return
SharedScopeCall#setClassAndName(CompileUnit, String):::Set the compile unit and method name.:::
SharedScopeCall#generateInvoke(MethodEmitter):::Generate the invoke instruction for this shared scope call.:::method->compileUnit->getUnitClassName->getStaticSignature->invokestatic
SharedScopeCall#generateScopeCall():::Generate the method that implements the scope get or call.:::classEmitter->compileUnit->getClassEmitter->methodFlags->EnumSet->of->method->classEmitter->getStaticSignature->method->method->begin->method->load->method->load->method->invoke->beginTry->endTry->catchLabel->if->new->Label->new->Label->new->Label->method->label->method->_try->else->getFlags->method->symbol->getName->dynamicGet->if->method->convert->method->loadUndefined->slot->foreach->method->load->type->getSlots->callFlags->method->symbol->getName->dynamicCall->if->method->label->method->_return->if->method->_catch->method->load->method->invoke->method->athrow->method->end
SharedScopeCall#getStaticSignature()::: shared scope call get static signature:::if->if->Type->Type->typeFor->getMethodDescriptor->else->params->new->TypeArr->Type->typeFor->System->arraycopy->Type->getMethodDescriptor->return
SharedScopeCall#toString()::: shared scope call to string:::return
SpillObjectCreator#createObject(MethodEmitter)::: spill object creator create object:::length->tuples->size->dualFields->codegen->useDualFields->spillLength->ScriptObject->spillAllocationLength->jpresetValues->new->longArr->opresetValues->new->ObjectArr->objectClass->getAllocatorClass->arrayData->ArrayData->allocate->pos->foreach->key->value->method->invalidateSpecialName->if->constantValue->LiteralNode->objectAsConstant->if->property->propertyMap->findProperty->if->property->JSType->unboxedFieldType->setType->slot->property->getSlot->if->ObjectClassGenerator->pack->else->else->oldLength->arrayData->length->index->ArrayIndex->getArrayIndex->longIndex->ArrayIndex->toLongIndex->if->arrayData->ensure->if->arrayData->intValue->set->else->if->arrayData->doubleValue->set->else->arrayData->set->if->arrayData->delete->method->_new->dup->codegen->loadConstant->if->codegen->loadConstant->else->method->loadNull->codegen->loadConstant->method->constructorNoLookup->invoke->if->arrayData->length->method->dup->codegen->loadConstant->method->virtualCallNoLookup->invoke
SpillObjectCreator#populateRange(MethodEmitter, Type, int, int, int)::: spill object creator populate range:::callSiteFlags->codegen->getCallSiteFlags->method->load->for->i
SpillObjectCreator#makeMap()::: spill object creator make map:::clazz->getAllocatorClass->new->MapCreator<>->codegen->useDualFields->makeSpillMap->return
SpillObjectCreator#loadValue(Expression, Type)::: spill object creator load value:::codegen->Type->generic->loadExpressionAsType
SpillObjectCreator#getAllocatorClass()::: spill object creator get allocator class:::return->codegen->useDualFields
SplitIntoFunctions#enterFunctionNode(FunctionNode)::: split into functions enter function node:::functionStates->new->FunctionState->push->return
SplitIntoFunctions#leaveFunctionNode(FunctionNode)::: split into functions leave function node:::functionStates->pop->return
SplitIntoFunctions#leaveDefault(Node)::: split into functions leave default:::if->appendStatement->return
SplitIntoFunctions#enterSplitNode(SplitNode)::: split into functions enter split node:::getCurrentFunctionState->splitStates->new->SplitState->push->return
SplitIntoFunctions#leaveSplitNode(SplitNode)::: split into functions leave split node:::fnState->getCurrentFunctionState->name->splitNode->getName->body->splitNode->getBody->firstLineNumber->body->getFirstStatementLineNumber->token->body->getToken->finish->body->getFinish->originalFn->isProgram->originalFn->isProgram->newFnToken->Token->toDesc->fn->originalFn->getSource->body->getFirstStatementLineNumber->createIdent->originalFn->getName->Collections->createReturnParamIdent->singletonList->Collections->emptyList->originalFn->getModule->originalFn->getDebugFlags->new->FunctionNode->splitNode->getCompileUnit->setCompileUnit->thisIdent->createIdent->callNode->new->AccessNode->Arrays->createReturnIdent->asList->Collections->singletonList->new->CallNode->splitState->splitStates->pop->callWithReturn->hasReturn->if->parentSplit->splitStates->peek->if->if->Token->recast->createReturnIdent->new->BinaryNode->else->new->ExpressionStatement->appendStatement->splitStateHandler->jumpStatements->jumpCount->jumpStatements->size->if->cases->new->ArrayList<>->if->createReturnFromSplit->addCase->i->foreach->enblockAndVisit->addCase->new->SwitchNode->else->if->new->BreakNode->enblockAndVisit->makeIfStateEquals->if->createReturnFromSplit->makeIfStateEquals->if->appendStatement->return
SplitIntoFunctions#addCase(List, int, Block)::: split into functions add case:::cases->intLiteral->new->CaseNode->add
SplitIntoFunctions#intLiteral(int)::: split into functions int literal:::return->LiteralNode->newInstance
SplitIntoFunctions#createReturnFromSplit()::: split into functions create return from split:::return->createReturnReturn->new->Block
SplitIntoFunctions#createReturnReturn()::: split into functions create return return:::return->createReturnIdent->new->ReturnNode
SplitIntoFunctions#createReturnIdent()::: split into functions create return ident:::return->createIdent
SplitIntoFunctions#createReturnParamIdent()::: split into functions create return param ident:::return->createIdent
SplitIntoFunctions#createIdent(String)::: split into functions create ident:::return->new->IdentNode
SplitIntoFunctions#enblockAndVisit(JumpStatement)::: split into functions enblock and visit:::block->new->Block->accept->return
SplitIntoFunctions#makeIfStateEquals(int, long, int, int, Block, Statement)::: split into functions make if state equals:::return->Token->recast->intLiteral->new->BinaryNode->new->Block->new->IfNode
SplitIntoFunctions#enterVarNode(VarNode)::: split into functions enter var node:::if->inSplitNode->varNode->isBlockScoped->return->super->enterVarNode->init->varNode->getInit->getCurrentFunctionState->varNode->setInit->add->if->token->Token->varNode->getToken->recast->varNode->getLineNumber->varNode->getFinish->varNode->getName->varNode->getInit->new->BinaryNode->new->ExpressionStatement->accept->return
SplitIntoFunctions#leaveBlock(Block)::: split into functions leave block:::if->if->lc->isFunctionBody->lc->getCurrentFunctionState->prependStatements->else->if->lc->isSplitBody->appendSplitReturn->if->getCurrentFunctionState->isProgram->lc->Token->toDesc->createReturnIdent->createReturnParamIdent->new->BinaryNode->new->ExpressionStatement->prependStatement->return
SplitIntoFunctions#leaveBreakNode(BreakNode)::: split into functions leave break node:::return->leaveJumpNode
SplitIntoFunctions#leaveContinueNode(ContinueNode)::: split into functions leave continue node:::return->leaveJumpNode
SplitIntoFunctions#leaveJumpToInlinedFinally(JumpToInlinedFinally)::: split into functions leave jump to inlined finally:::return->leaveJumpNode
SplitIntoFunctions#leaveJumpNode(JumpStatement)::: split into functions leave jump node:::if->inSplitNode->splitState->getCurrentSplitState->splitNode->if->lc->jump->getTarget->isExternalTarget->splitState->getSplitStateIndex->jump->getLineNumber->appendSplitReturn->return->appendStatement->return
SplitIntoFunctions#appendSplitReturn(int, int)::: split into functions append split return:::new->SetSplitState->appendStatement->if->getCurrentFunctionState->isProgram->createReturnReturn->appendStatement->else->appendStatement
SplitIntoFunctions#leaveReturnNode(ReturnNode)::: split into functions leave return node:::if->inSplitNode->returnNode->getLineNumber->new->SetSplitState->appendStatement->getCurrentSplitState->appendStatement->return
SplitIntoFunctions#appendStatement(Statement)::: split into functions append statement:::lc->appendStatement
SplitIntoFunctions#inSplitNode()::: split into functions in split node:::return->getCurrentFunctionState
SplitIntoFunctions#getCurrentFunctionState()::: split into functions get current function state:::return->functionStates->peek
SplitIntoFunctions#getCurrentSplitState()::: split into functions get current split state:::return->splitStates->peek
SplitIntoFunctions.SplitState#getSplitStateIndex(JumpStatement)::: split state get split state index:::if->jump->getLabelName->return->i->foreach->if->jump->getClass->exJump->getClass->Objects->jump->getLabelName->exJump->getLabelName->equals->return->jumpStatements->add->return
Splitter#initLogger(Context)::: splitter init logger:::return->context->this->getClass->getLogger
Splitter#getLogger()::: splitter get logger:::return
Splitter#split(FunctionNode, boolean):::Execute the split.:::functionNode->log->functionNode->getName->fine->weight->WeighNodes->weigh->if->log->functionNode->getName->info->functionNode->accept->if->functionNode->isSplit->WeighNodes->weigh->functionNode->functionNode->getBody->setNeedsScope->setBody->if->functionNode->functionNode->getBody->splitBlock->setBody->functionNode->setFlag->WeighNodes->functionNode->getBody->weigh->if->functionNode->setCompileUnit->outermostCompileUnit->addWeight->else->functionNode->findUnit->setCompileUnit->body->functionNode->getBody->dc->directChildren->newBody->body->new->SimpleNodeVisitor->accept->functionNode->setBody->return
Splitter#directChildren(FunctionNode)::: splitter direct children:::dc->new->ArrayList<>->functionNode->new->SimpleNodeVisitor->accept->return
Splitter#findUnit(long):::Override this logic to look up compile units in a different way:::return->compiler->findUnit
Splitter#splitBlock(Block, FunctionNode):::Split a block into sub methods.:::splits->new->ArrayList<>->statements->new->ArrayList<>->statementsWeight->foreach->block->getStatements->weight->WeighNodes->weigh->isBlockScopedVarNode->isBlockScopedVarNode->if->statement->isTerminal->if->statements->isEmpty->splits->createBlockSplitNode->add->new->ArrayList<>->if->statement->isTerminal->splits->add->else->statements->add->if->statements->isEmpty->splits->createBlockSplitNode->add->return->block->setStatements
Splitter#createBlockSplitNode(Block, FunctionNode, List, long):::Create a new split node from statements contained in a parent block.:::token->parent->getToken->finish->parent->getFinish->name->function->SPLIT_PREFIX->symbolName->uniqueName->newBlock->new->Block->return->compiler->findUnit->new->SplitNode
Splitter#isBlockScopedVarNode(Statement)::: splitter is block scoped var node:::return->isBlockScoped
Splitter#enterBlock(Block)::: splitter enter block:::if->block->isCatchBlock->return->weight->WeighNodes->weigh->if->weightCache->put->return->return
Splitter#leaveBlock(Block)::: splitter leave block:::newBlock->weight->WeighNodes->weigh->if->currentFunction->lc->getCurrentFunction->splitBlock->WeighNodes->weigh->lc->setFlag->weightCache->put->return
Splitter#leaveLiteralNode(LiteralNode)::: splitter leave literal node:::weight->WeighNodes->weigh->if->return->functionNode->lc->getCurrentFunction->lc->setFlag->if->arrayLiteralNode->value->arrayLiteralNode->getValue->postsets->arrayLiteralNode->getPostsets->ranges->new->ArrayList<>->totalWeight->lo->for->i->if->unit->compiler->findUnit->ranges->new->Splittable.SplitRange->add->log->functionNode->getName->info->return->arrayLiteralNode->setSplitRanges->return
Splitter#leaveObjectNode(ObjectNode)::: splitter leave object node:::weight->WeighNodes->weigh->if->return->functionNode->lc->getCurrentFunction->lc->setFlag->ranges->new->ArrayList<>->properties->objectNode->getElements->isSpillObject->properties->size->totalWeight->lo->for->i->properties->size->if->properties->size->unit->compiler->findUnit->ranges->properties->size->new->Splittable.SplitRange->add->log->functionNode->getName->info->return->objectNode->setSplitRanges
Splitter#enterFunctionNode(FunctionNode)::: splitter enter function node:::return
TypeEvaluator#hasStringPropertyIterator(Expression):::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object):::return->evaluateSafely
TypeEvaluator#getOptimisticType(Optimistic)::: type evaluator get optimistic type:::programPoint->node->getProgramPoint->validType->compiler->getInvalidatedProgramPointType->if->return->mostOptimisticType->node->getMostOptimisticType->evaluatedType->getEvaluatedType->if->if->evaluatedType->widerThan->newValidType->evaluatedType->isObject->evaluatedType->isBoolean->compiler->node->getProgramPoint->addInvalidatedProgramPoint->return->return
TypeEvaluator#getPropertyType(ScriptObject, String)::: type evaluator get property type:::find->sobj->findProperty->if->return->property->find->getProperty->propertyClass->property->getType->if->return->else->if->propertyClass->isPrimitive->return->Type->typeFor->owner->find->getOwner->if->property->hasGetterFunction->return->value->property->needsDeclaration->property->getObjectValue->if->return->return->Type->JSType->unboxedFieldType->typeFor
TypeEvaluator#declareLocalSymbol(String):::Declares a symbol name as belonging to a non-scoped local variable during an on-demand compilation of a single function:::if->runtimeScope->findProperty->runtimeScope->addOwnProperty
TypeEvaluator#evaluateSafely(Expression)::: type evaluator evaluate safely:::if->return->getName->evaluatePropertySafely->if->accessNode->base->accessNode->getBase->evaluateSafely->if->return->return->accessNode->getProperty->evaluatePropertySafely->return
TypeEvaluator#evaluatePropertySafely(ScriptObject, String)::: type evaluator evaluate property safely:::find->sobj->findProperty->if->return->property->find->getProperty->owner->find->getOwner->if->property->hasGetterFunction->return->return->property->getObjectValue
TypeEvaluator#getEvaluatedType(Optimistic)::: type evaluator get evaluated type:::if->if->return->return->getName->getPropertyType->else->if->accessNode->base->accessNode->getBase->evaluateSafely->if->return->return->accessNode->getProperty->getPropertyType->else->if->indexNode->base->indexNode->getBase->evaluateSafely->if->return->getArray->getOptimisticType->else->if->callExpr->fnExpr->callExpr->getFunction->if->compiler->getContext->getEnv->fn->if->callExpr->getArgs->isEmpty->data->compiler->fn->getId->getScriptFunctionData->if->returnType->Type->data->getReturnType->typeFor->if->return->return->return
TypeMap#getParameterTypes(int):::Returns the array of parameter types for a particular function node:::return->paramTypes->clone
TypeMap#getCallSiteType(FunctionNode)::: type map get call site type:::types->mt->MethodType->returnType->getTypeClass->methodType->if->mt->appendParameterTypes->mt->appendParameterTypes->foreach->if->return->mt->type->getTypeClass->appendParameterTypes->return
TypeMap#needsCallee():::Does the function using this TypeMap need a callee argument:::return
TypeMap#get(FunctionNode, int):::Get the parameter type for this parameter position, or null if now known:::types->if->return->return
TypeMap#getReturnType():::Get the return type required for the call site we're compiling for:::return->returnType->isObject
TypeMap#toString()::: type map to string:::return->toString
TypeMap#toString(String)::: type map to string:::sb->new->StringBuilder->id->sb->append->append->sb->append->append->append->sb->append->append->sb->Arrays->toString->append->sb->append->sb->append->append->ret->sb->append->sb->append->return->sb->toString
WeighNodes#weigh(Node)::: weigh nodes weigh:::return->weigh
WeighNodes#weigh(Node, Map)::: weigh nodes weigh:::weighNodes->new->WeighNodes->node->accept->return
WeighNodes#leaveAccessNode(AccessNode)::: weigh nodes leave access node:::return
WeighNodes#enterBlock(Block)::: weigh nodes enter block:::if->weightCache->containsKey->weightCache->get->return->return
WeighNodes#leaveBreakNode(BreakNode)::: weigh nodes leave break node:::return
WeighNodes#leaveCallNode(CallNode)::: weigh nodes leave call node:::return
WeighNodes#leaveCatchNode(CatchNode)::: weigh nodes leave catch node:::return
WeighNodes#leaveContinueNode(ContinueNode)::: weigh nodes leave continue node:::return
WeighNodes#leaveExpressionStatement(ExpressionStatement)::: weigh nodes leave expression statement:::return
WeighNodes#leaveForNode(ForNode)::: weigh nodes leave for node:::return
WeighNodes#enterFunctionNode(FunctionNode)::: weigh nodes enter function node:::if->return->return
WeighNodes#leaveIdentNode(IdentNode)::: weigh nodes leave ident node:::return
WeighNodes#leaveIfNode(IfNode)::: weigh nodes leave if node:::return
WeighNodes#leaveIndexNode(IndexNode)::: weigh nodes leave index node:::return
WeighNodes#leaveJumpToInlinedFinally(JumpToInlinedFinally)::: weigh nodes leave jump to inlined finally:::return
WeighNodes#enterLiteralNode(LiteralNode)::: weigh nodes enter literal node:::if->arrayLiteralNode->value->arrayLiteralNode->getValue->postsets->arrayLiteralNode->getPostsets->units->arrayLiteralNode->getSplitRanges->if->foreach->element->if->element->accept->return->return
WeighNodes#enterObjectNode(ObjectNode)::: weigh nodes enter object node:::properties->objectNode->getElements->isSpillObject->properties->size->foreach->if->LiteralNode->property->getValue->isConstant->property->getValue->accept->else->if->return
WeighNodes#leavePropertyNode(PropertyNode)::: weigh nodes leave property node:::return
WeighNodes#leaveReturnNode(ReturnNode)::: weigh nodes leave return node:::return
WeighNodes#leaveRuntimeNode(RuntimeNode)::: weigh nodes leave runtime node:::return
WeighNodes#enterSplitNode(SplitNode)::: weigh nodes enter split node:::return
WeighNodes#leaveSwitchNode(SwitchNode)::: weigh nodes leave switch node:::return
WeighNodes#leaveThrowNode(ThrowNode)::: weigh nodes leave throw node:::return
WeighNodes#leaveTryNode(TryNode)::: weigh nodes leave try node:::return
WeighNodes#leaveVarNode(VarNode)::: weigh nodes leave var node:::return
WeighNodes#leaveWhileNode(WhileNode)::: weigh nodes leave while node:::return
WeighNodes#leaveWithNode(WithNode)::: weigh nodes leave with node:::return
WeighNodes#leavePOS(UnaryNode)::: weigh nodes leave s:::return->unaryNodeWeight
WeighNodes#leaveBIT_NOT(UnaryNode)::: weigh nodes leave t_ t:::return->unaryNodeWeight
WeighNodes#leaveDECINC(UnaryNode)::: weigh nodes leave c:::return->unaryNodeWeight
WeighNodes#leaveDELETE(UnaryNode)::: weigh nodes leave e:::return->runtimeNodeWeight
WeighNodes#leaveNEW(UnaryNode)::: weigh nodes leave w:::return
WeighNodes#leaveNOT(UnaryNode)::: weigh nodes leave t:::return->unaryNodeWeight
WeighNodes#leaveNEG(UnaryNode)::: weigh nodes leave g:::return->unaryNodeWeight
WeighNodes#leaveTYPEOF(UnaryNode)::: weigh nodes leave f:::return->runtimeNodeWeight
WeighNodes#leaveVOID(UnaryNode)::: weigh nodes leave d:::return->unaryNodeWeight
WeighNodes#leaveADD(BinaryNode)::: weigh nodes leave d:::return
WeighNodes#leaveAND(BinaryNode)::: weigh nodes leave d:::return->binaryNodeWeight
WeighNodes#leaveASSIGN(BinaryNode)::: weigh nodes leave n:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_ADD(BinaryNode)::: weigh nodes leave n_ d:::return
WeighNodes#leaveASSIGN_BIT_AND(BinaryNode)::: weigh nodes leave n_ t_ d:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_BIT_OR(BinaryNode)::: weigh nodes leave n_ t_ r:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_BIT_XOR(BinaryNode)::: weigh nodes leave n_ t_ r:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_DIV(BinaryNode)::: weigh nodes leave n_ v:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_MOD(BinaryNode)::: weigh nodes leave n_ d:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_MUL(BinaryNode)::: weigh nodes leave n_ l:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_SAR(BinaryNode)::: weigh nodes leave n_ r:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_SHL(BinaryNode)::: weigh nodes leave n_ l:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_SHR(BinaryNode)::: weigh nodes leave n_ r:::return->binaryNodeWeight
WeighNodes#leaveASSIGN_SUB(BinaryNode)::: weigh nodes leave n_ b:::return->binaryNodeWeight
WeighNodes#leaveARROW(BinaryNode)::: weigh nodes leave w:::return->binaryNodeWeight
WeighNodes#leaveBIT_AND(BinaryNode)::: weigh nodes leave t_ d:::return->binaryNodeWeight
WeighNodes#leaveBIT_OR(BinaryNode)::: weigh nodes leave t_ r:::return->binaryNodeWeight
WeighNodes#leaveBIT_XOR(BinaryNode)::: weigh nodes leave t_ r:::return->binaryNodeWeight
WeighNodes#leaveCOMMARIGHT(BinaryNode)::: weigh nodes leave t:::return->binaryNodeWeight
WeighNodes#leaveDIV(BinaryNode)::: weigh nodes leave v:::return->binaryNodeWeight
WeighNodes#leaveEQ(BinaryNode)::: weigh nodes leave q:::return->compareWeight
WeighNodes#leaveEQ_STRICT(BinaryNode)::: weigh nodes leave q_ t:::return->compareWeight
WeighNodes#leaveGE(BinaryNode)::: weigh nodes leave e:::return->compareWeight
WeighNodes#leaveGT(BinaryNode)::: weigh nodes leave t:::return->compareWeight
WeighNodes#leaveIN(BinaryNode)::: weigh nodes leave n:::return
WeighNodes#leaveINSTANCEOF(BinaryNode)::: weigh nodes leave f:::return
WeighNodes#leaveLE(BinaryNode)::: weigh nodes leave e:::return->compareWeight
WeighNodes#leaveLT(BinaryNode)::: weigh nodes leave t:::return->compareWeight
WeighNodes#leaveMOD(BinaryNode)::: weigh nodes leave d:::return->binaryNodeWeight
WeighNodes#leaveMUL(BinaryNode)::: weigh nodes leave l:::return->binaryNodeWeight
WeighNodes#leaveNE(BinaryNode)::: weigh nodes leave e:::return->compareWeight
WeighNodes#leaveNE_STRICT(BinaryNode)::: weigh nodes leave e_ t:::return->compareWeight
WeighNodes#leaveOR(BinaryNode)::: weigh nodes leave r:::return->binaryNodeWeight
WeighNodes#leaveSAR(BinaryNode)::: weigh nodes leave r:::return->binaryNodeWeight
WeighNodes#leaveSHL(BinaryNode)::: weigh nodes leave l:::return->binaryNodeWeight
WeighNodes#leaveSHR(BinaryNode)::: weigh nodes leave r:::return->binaryNodeWeight
WeighNodes#leaveSUB(BinaryNode)::: weigh nodes leave b:::return->binaryNodeWeight
WeighNodes#unaryNodeWeight(UnaryNode)::: weigh nodes unary node weight:::return
WeighNodes#binaryNodeWeight(BinaryNode)::: weigh nodes binary node weight:::return
WeighNodes#runtimeNodeWeight(UnaryNode)::: weigh nodes runtime node weight:::return
WeighNodes#compareWeight(BinaryNode)::: weigh nodes compare weight:::return
