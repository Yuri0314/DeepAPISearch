ApplySpecialization#leaveFunctionNode(FunctionNode):::Try to do the apply to call transformation:::newFunctionNode->functionName->newFunctionNode->getName->if->changed->newFunctionNode->getId->contains->newFunctionNode->clearFlag->setFlag->explodedArguments->peek->setParameters->if->log->isEnabled->log->newFunctionNode->getSource->getURL->massageURL->newFunctionNode->getId->callSiteTypes->peek->info->callSiteTypes->pop->explodedArguments->pop->return
ClassEmitter#getMethodNames():::Return the method names encountered.:::return->Collections->unmodifiableSet
ClassEmitter#getMethodCount():::Get the method count, including init and clinit methods.:::return
ClassEmitter#getClinitCount():::Get the clinit count.:::return
ClassEmitter#getInitCount():::Get the init count.:::return
ClassEmitter#getFieldCount():::Get the field count.:::return
ClassEmitter#getArrayMethodName(Class):::Generate the name of a get array from constant pool method.:::return->GET_ARRAY_PREFIX->symbolName->clazz->getComponentType->getSimpleName->GET_ARRAY_SUFFIX->symbolName
ClassEmitter#needGetConstantMethod(Class):::Ensure a get constant method is issued for the class.:::constantMethodNeeded->add
ClassEmitter#begin():::Call at beginning of class emission.:::
ClassEmitter#end():::Call at end of class emission.:::if->initMethod->EnumSet->of->init->initMethod->begin->initMethod->load->initMethod->newInstance->initMethod->returnVoid->initMethod->end->defineCommonUtilities->cw->visitEnd
ClassEmitter#disassemble(byte[]):::Disassemble an array of byte code.:::baos->new->ByteArrayOutputStream->try->pw->new->PrintWriter->cr->new->NashornClassReader->ctx->AccessController->new->PrivilegedAction<Context>->doPrivileged->tcv->ctx->getEnv->new->NashornTextifier->new->TraceClassVisitor->cr->accept->catch->finally->str->baos->toByteArray->new->String->return
ClassEmitter#beginMethod(MethodEmitter):::Call back from MethodEmitter for method start.:::methodsStarted->add
ClassEmitter#endMethod(MethodEmitter):::Call back from MethodEmitter for method end.:::methodsStarted->remove
ClassEmitter#method(String, Class, Class...):::Add a new method to the class - defaults to public method.:::return->method
ClassEmitter#method(EnumSet, String, Class, Class...):::Add a new method to the class - defaults to public method.:::methodNames->add->return->methodVisitor->new->MethodEmitter
ClassEmitter#method(String, String):::Add a new method to the class - defaults to public method.:::return->method
ClassEmitter#method(EnumSet, String, String):::Add a new method to the class - defaults to public method.:::methodNames->add->return->cw->Flag->getValue->visitMethod->new->MethodEmitter
ClassEmitter#method(FunctionNode):::Add a new method to the class, representing a function node.:::methodNames->functionNode->getName->add->signature->new->FunctionSignature->mv->cw->functionNode->isVarArg->functionNode->getName->signature->toString->visitMethod->return->new->MethodEmitter
ClassEmitter#restOfMethod(FunctionNode):::Add a new method to the class, representing a rest-of version of the function node.:::methodNames->functionNode->getName->add->mv->cw->functionNode->getName->Type->functionNode->getReturnType->getTypeClass->getMethodDescriptor->visitMethod->return->new->MethodEmitter
ClassEmitter#clinit():::Start generating the <clinit> method in the class.:::return->EnumSet->of->CLINIT->symbolName->method
ClassEmitter#init():::Start generating an <init>()V method in the class.:::return->INIT->symbolName->method
ClassEmitter#init(Class...):::Start generating an <init>()V method in the class.:::return->INIT->symbolName->method
ClassEmitter#init(EnumSet, Class...):::Start generating an <init>(...)V method in the class.:::return->INIT->symbolName->method
ClassEmitter#field(EnumSet, String, Class, Object):::Add a field to the class, initialized to a value.:::cw->Flag->getValue->typeDescriptor->visitField->visitEnd
ClassEmitter#field(EnumSet, String, Class):::Add a field to the class.:::field
ClassEmitter#field(String, Class):::Add a field to the class - defaults to public.:::EnumSet->of->field
ClassEmitter#toByteArray():::Return a bytecode array from this ClassEmitter:::if->return->return->cw->toByteArray
CodeGenerator#getCallSiteFlags():::Gets the call site flags, adding the strict flag if the current function being generated is in strict mode:::return->lc->getCurrentFunction->getCallSiteFlags
CodeGenerator#isEvalCode():::Are we generating code for 'eval' code?:::return
CodeGenerator#useDualFields():::Are we using dual primitive/object field representation?:::return->compiler->getContext->useDualFields
CodeGenerator#loadComparisonOperands(BinaryNode):::Similar to #loadBinaryOperands(BinaryNode) but used specifically for loading operands of relational and equality comparison operators where at least one argument is non-object:::lhs->cmp->lhs->rhs->cmp->rhs->lhsType->lhs->getType->rhsType->rhs->getType->if->lhsType->isObject->rhsType->isObject->canReorder->lhsType->isPrimitive->rhs->isLocal->canCombineLoadAndConvert->cmp->isRelational->lhs->isOptimistic->loadExpression->lhsLoadedType->method->peekType->tt->cmp->tokenType->if->emitObjectToNumberComparisonConversion->rhs->isOptimistic->loadExpression->else->loadExpression->if->method->swap->emitObjectToNumberComparisonConversion->method->swap->emitObjectToNumberComparisonConversion->return->return->loadBinaryOperands
CodeGenerator#nonOptimisticFlags(int):::Returns the flags with optimistic flag and program point removed.:::return
CodeGenerator#loadConstant(String):::Load a constant from the constant array:::unitClassName->unit->getUnitClassName->classEmitter->unit->getClassEmitter->index->compiler->getConstantData->add->method->load->method->GET_STRING->symbolName->methodDescriptor->invokestatic->classEmitter->needGetConstantMethod
CodeGenerator#loadConstant(Object):::Load a constant from the constant array:::loadConstant
CodeGenerator#generateScopeCalls():::Generate all shared scope calls generated during codegen.:::foreach->lc->getScopeCalls->scopeAccess->generateScopeCall
CodeGenerator.SplitLiteralCreator#populateRange(MethodEmitter, Type, int, int, int):::Generate code to populate a range of the literal object:::
CodeGeneratorLexicalContext#getScopeCall(CompileUnit, Symbol, Type, Type, Type[], int, boolean):::Get a shared static method representing a dynamic scope callsite.:::scopeCall->new->SharedScopeCall->if->scopeCalls->containsKey->return->scopeCalls->get->scopeCall->getCurrentFunction->uniqueName->setClassAndName->scopeCalls->put->return
CodeGeneratorLexicalContext#getScopeGet(CompileUnit, Symbol, Type, int, boolean):::Get a shared static method representing a dynamic scope get access.:::return->getScopeCall
CompilationPhase#begin(Compiler, FunctionNode):::Start a compilation phase:::compiler->getLogger->indent->System->nanoTime->return
CompilationPhase#end(Compiler, FunctionNode):::End a compilation phase:::compiler->getLogger->unindent->System->nanoTime->compiler->getScriptEnvironment->toString->accumulateTime->return
CompilationPhase#apply(Compiler, CompilationPhases, FunctionNode):::Apply a transform to a function node, returning the transformed function node:::return->begin->transform->end
Compiler#forInitialCompilation(CodeInstaller, Source, ErrorManager, boolean):::Creates a new compiler instance for initial compilation of a script.:::return->installer->getContext->new->Compiler
Compiler#forNoInstallerCompilation(Context, Source, boolean):::Creates a compiler without a code installer:::return->context->getErrorManager->new->Compiler
Compiler#forOnDemandCompilation(CodeInstaller, Source, boolean, RecompilableScriptFunctionData, TypeMap, Map, Object, int[], ScriptObject):::Creates a compiler for an on-demand compilation job.:::context->installer->getContext->return->context->getErrorManager->new->Compiler
Compiler#hasStringPropertyIterator(Expression):::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object):::return->typeEvaluator->hasStringPropertyIterator
Compiler#getInvalidatedProgramPoints():::Returns a copy of this compiler's current mapping of invalidated optimistic program points to their types:::return->invalidatedProgramPoints->isEmpty->new->TreeMap<>
Compiler#compile(FunctionNode, CompilationPhases):::Do a compilation job:::if->log->isEnabled->log->DebugLogger->functionNode->getName->quote->phases->getDesc->quote->info->log->indent->name->DebugLogger->functionNode->getName->quote->newFunctionNode->foreach->newFunctionNode->uniqueName->info->log->isLoggable->timeLogger->env->isTimingEnabled->getLogger->time->foreach->log->fine->try->phase->apply->catch->errors->error->if->error->env->getErr->printStackTrace->return->finally->log->quote->fine->env->isTimingEnabled->phase->getEndTime->phase->getStartTime->if->phases->isRestOfCompilation->OptimisticTypesPersistence->store->log->unindent->if->sb->new->StringBuilder->sb->newFunctionNode->getSource->append->append->newFunctionNode->getName->quote->append->if->sb->append->toMillis->append->append->log->info->return
Compiler#clearBytecode():::Reset bytecode cache for compiler reuse.:::bytecode->clear
Compiler#persistClassInfo(String, FunctionNode):::Persist current compilation with the given cacheKey.:::if->initializers->new->HashMap<>->if->isOnDemandCompilation->initializers->functionNode->getId->getInvalidatedProgramPoints->new->FunctionInitializer->put->else->foreach->getCompileUnits->foreach->compileUnit->getFunctionNodes->initializers->fn->getId->new->FunctionInitializer->put->mainClassName->getFirstCompileUnit->getUnitClassName->installer->constantData->toArray->storeScript
Compiler#updateCompilationId(int):::Make sure the next compilation id is greater than value.:::if->COMPILATION_ID->get->COMPILATION_ID->set
Compiler#binaryName(String):::Convert a package/class name to a binary name.:::return->name->replace
CompileUnit#getEmittedUnitCount():::Get the amount of emitted compile units so far in the system:::return
CompileUnit#isUsed():::Check if this compile unit is used:::return
CompileUnit#hasCode():::Check if a compile unit has code, not counting inits and clinits:::return->classEmitter->getMethodCount->classEmitter->getInitCount->classEmitter->getClinitCount
CompileUnit#setUsed():::Tag this compile unit as used:::
CompileUnit#getCode():::Return the class that contains the code for this unit, null if not generated yet:::return
CompileUnit#setCode(Class):::Set class when it exists:::Objects->requireNonNull
CompileUnit#isInitializing(RecompilableScriptFunctionData, FunctionNode):::Returns true if this compile unit is responsible for initializing the specified function data with specified function node.:::return->functions->get
CompileUnit#addWeight(long):::Add weight to this compile unit:::
CompileUnit#canHold(long):::Check if this compile unit can hold weight more units of weight:::return
CompileUnit#getClassEmitter():::Get the class emitter for this compile unit:::return
CompileUnit#getUnitClassName():::Get the class name for this compile unit:::return
ConstantData#add(String):::Add a string to the constant data:::value->stringMap->get->if->return->constants->add->index->constants->size->stringMap->put->return
ConstantData#add(Object):::Add an object to the constant data:::entry->if->object->getClass->isArray->new->ArrayWrapper->else->if->new->PropertyMapWrapper->else->value->objectMap->get->if->return->constants->add->index->constants->size->objectMap->put->return
DumpBytecode#dumpBytecode(ScriptEnvironment, DebugLogger, byte[], String):::Dump bytecode to console and potentially disk.:::dir->try->if->sb->new->StringBuilder->sb->append->append->append->ClassEmitter->disassemble->append->append->if->name->dollar->name->lastIndexOf->if->name->substring->new->File->if->dir->exists->dir->mkdirs->throw->dir->toString->new->IOException->file->fileName->uniqueId->do->new->File->while->file->exists->try->pw->new->FileOutputStream->new->PrintWriter->pw->sb->toString->print->pw->flush->catch->finally->else->env->getErr->println->if->fileName->className->replace->index->fileName->lastIndexOf->if->fileName->substring->new->File->else->new->File->if->dir->exists->dir->mkdirs->throw->dir->toString->new->IOException->file->new->File->try->fos->new->FileOutputStream->fos->write->catch->finally->logger->file->getAbsolutePath->info->catch->logger->ECMAErrors->dir->toString->getMessage->warning->finally
FieldObjectCreator#createForInIterationScope(MethodEmitter):::Create a scope for a for-in/of loop as defined in ES6 13.7.5.13 step 5.g.iii:::className->getClassName->method->_new->dup->loadMap->loadScope->method->invoke->method->constructorNoLookup->invoke
FieldObjectCreator#getClassName():::Get the class name for the object class, e.g:::return
FoldConstants.ConstantEvaluator#eval():::Returns a literal node that replaces the given parent node, or null if replacement is impossible:::
FoldConstants#extractVarNodesFromDeadCode(Node, List):::When we eliminate dead code, we must preserve var declarations as they are scoped to the whole function:::deadCodeRoot->new->SimpleNodeVisitor->accept
FunctionSignature#getParamTypes():::Get the param types for this function signature:::return->paramTypes->clone
FunctionSignature#getMethodType():::Return the MethodType for this function signature:::return
FunctionSignature#getReturnType():::Return the return type for this function signature:::return
Label.Stack#getTopTypes(int):::Retrieve the top count types on the stack without modifying it.:::topTypes->new->TypeArr->System->arraycopy->return
Label.Stack#getUsedSlotsWithLiveTemporaries():::Returns the number of used local variable slots, including all live stack-store temporaries.:::usedSlots->for->i->return
Label.Stack#getWidestLiveLocals(List):::Returns a list of local variable slot types, but for those symbols that have multiple values, only the slot holding the widest type is marked as live.:::widestLiveLocals->new->ArrayList<>->keepNextValue->size->widestLiveLocals->size->for->i->widestLiveLocals->Math->getFirstDeadLocal->max->widestLiveLocals->size->subList->clear->return
Label.Stack#onLocalStore(Type, int, boolean):::Performs various bookeeping when a value is stored in a local variable slot.:::if->fromSlot->symbolBoundary->previousSetBit->toSlot->symbolBoundary->nextSetBit->for->i->invalidateLocalLoadsOnStack->else->type->getSlots->invalidateLocalLoadsOnStack->localVariableTypes->set->if->type->isCategory2->localVariableTypes->set
Label.Stack#defineBlockLocalVariable(int, int):::Marks a range of slots as belonging to a defined local variable:::defineLocalVariable
Label.Stack#defineTemporaryLocalVariable(int):::Defines a new temporary local variable and returns its allocated index.:::fromSlot->getUsedSlotsWithLiveTemporaries->defineLocalVariable->return
Label.Stack#defineTemporaryLocalVariable(int, int):::Marks a range of slots as belonging to a defined temporary local variable:::defineLocalVariable
Label.Stack#undefineLocalVariables(int, boolean):::Undefines all local variables past the specified slot.:::lvarCount->localVariableTypes->size->if->if->symbolBoundary->set->else->if->symbolBoundary->clear->localVariableTypes->subList->clear->Math->min
Label.Stack#hasLoadsOnStack(int, int):::Returns true if any loads on the stack come from the specified slot range.:::for->i->return
LocalStateRestorationInfo#getLocalVariableTypes():::Returns the types of the local variables at the continuation of a program point.:::return->localVariableTypes->clone
LocalStateRestorationInfo#getStackLoads():::Returns the indices of local variables that need to be loaded on stack before jumping to the continuation of the program point.:::return->stackLoads->clone
MapCreator#makeFieldMap(boolean, boolean, int, int, boolean):::Constructs a property map based on a set of fields.:::properties->new->ArrayList<>->foreach->key->symbol->initialType->tuple->getValueType->if->getArrayIndex->isValidArrayIndex->flags->getPropertyFlags->property->symbol->getFieldIndex->new->AccessorProperty->properties->add->return->PropertyMap->structure->getName->newMap
MapCreator#getPropertyFlags(Symbol, boolean, boolean, boolean):::Compute property flags given local state of a field:::flags->if->symbol->isParam->if->if->symbol->isScope->if->symbol->isFunctionDeclaration->if->symbol->isConst->if->symbol->isBlockScoped->if->symbol->isBlockScoped->symbol->isScope->if->return
MethodEmitter#begin():::Begin a method:::classEmitter->beginMethod->newStack->method->visitCode
MethodEmitter#end():::End a method:::method->visitMaxs->method->visitEnd->classEmitter->endMethod
MethodEmitter#pushType(Type):::Push a type to the existing stack:::if->stack->push
MethodEmitter#peekType(int):::Peek a given number of slots from the top of the stack and return the type in that slot:::return->stack->peek
MethodEmitter#peekType():::Peek at the type at the top of the stack:::return->stack->peek
MethodEmitter#_new(String, Type):::Generate code a for instantiating a new object and push the object type on the stack:::debug->method->visitTypeInsn->pushType->return
MethodEmitter#_new(Class):::Generate code a for instantiating a new object and push the object type on the stack:::return->className->Type->typeFor->_new
MethodEmitter#newInstance(Class):::Generate code to call the empty constructor for a class:::return->constructorNoLookup->invoke
MethodEmitter#dup(int):::Perform a dup, that is, duplicate the top element and push the duplicate down a given number of positions on the stack:::if->peekType->dup->return->debug->switch->l0->stack->getTopLocalLoad->peekType->pushType->stack->markLocalLoad->break->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->break->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->l2->stack->getTopLocalLoad->p2->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->break->return->return
MethodEmitter#dup2():::Perform a dup2, that is, duplicate the top element if it is a category 2 type, or two top elements if they are category 1 types, and push them on top of the stack:::debug->if->peekType->isCategory2->l0->stack->getTopLocalLoad->peekType->pushType->stack->markLocalLoad->else->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->method->visitInsn->return
MethodEmitter#dup():::Duplicate the top element on the stack and push it:::return->dup
MethodEmitter#pop():::Pop the top element of the stack and throw it away:::peekType->debug->popType->pop->return
MethodEmitter#pop2():::Pop the top element of the stack if category 2 type, or the two top elements of the stack if category 1 types:::if->peekType->isCategory2->popType->else->get2n->return
MethodEmitter#swap():::Swap the top two elements of the stack:::debug->l0->stack->getTopLocalLoad->p0->popType->l1->stack->getTopLocalLoad->p1->popType->p0->swap->pushType->stack->markLocalLoad->pushType->stack->markLocalLoad->return
MethodEmitter#initializeMethodParameter(Symbol, Type, Label):::Initializes a bytecode method parameter:::localVariableDefs->start->getLabel->new->LocalVariableDef->put
MethodEmitter#newStringBuilder():::Create a new string builder, call the constructor and push the instance to the stack.:::return->constructorNoLookup->invoke->dup
MethodEmitter#stringBuilderAppend():::Pop a string and a StringBuilder from the top of the stack and call the append function of the StringBuilder, appending the string:::convert->return->virtualCallNoLookup->invoke
MethodEmitter#and():::Pops two integer types from the stack, performs a bitwise and and pushes the result:::debug->get2i->and->pushType->return
MethodEmitter#or():::Pops two integer types from the stack, performs a bitwise or and pushes the result:::debug->get2i->or->pushType->return
MethodEmitter#xor():::Pops two integer types from the stack, performs a bitwise xor and pushes the result:::debug->get2i->xor->pushType->return
MethodEmitter#shr():::Pops two integer types from the stack, performs a bitwise logic shift right and pushes the result:::debug->popInteger->popBitwise->shr->pushType->return
MethodEmitter#shl():::Pops two integer types from the stack, performs a bitwise shift left and and pushes the result:::debug->popInteger->popBitwise->shl->pushType->return
MethodEmitter#sar():::Pops two integer types from the stack, performs a bitwise arithmetic shift right and pushes the result:::debug->popInteger->popBitwise->sar->pushType->return
MethodEmitter#neg(int):::Pops a numeric type from the stack, negates it and pushes the result:::debug->popNumeric->neg->pushType->return
MethodEmitter#_catch(Label):::Add label for the start of a catch block and push the exception to the stack:::recovery->onCatch->label->beginCatchBlock
MethodEmitter#_catch(Collection):::Add any number of labels for the start of a catch block and push the exception to the stack:::foreach->label->beginCatchBlock
MethodEmitter#_try(Label, Label, Label, Class, boolean):::Start a try/catch block.:::recovery->entry->getStack->joinFromTry->typeDescriptor->CompilerConstants->className->method->entry->getLabel->exit->getLabel->recovery->getLabel->visitTryCatchBlock
MethodEmitter#_try(Label, Label, Label, Class):::Start a try/catch block.:::_try
MethodEmitter#_try(Label, Label, Label):::Start a try/catch block:::_try
MethodEmitter#loadConstants():::Load the constants array:::classEmitter->getUnitClassName->CONSTANTS->symbolName->CONSTANTS->descriptor->getStatic->return
MethodEmitter#loadUndefined(Type):::Push the undefined value for the given type, i.e:::debug->type->loadUndefined->pushType->return
MethodEmitter#loadEmpty(Type):::Push the empty value for the given type, i.e:::debug->type->loadEmpty->pushType->return
MethodEmitter#loadNull():::Push null to stack:::debug->ldc->pushType->return
MethodEmitter#loadType(String):::Push a handle representing this class top stack:::debug->method->getObjectType->visitLdcInsn->pushType->return
MethodEmitter#load(boolean):::Push a boolean constant to the stack.:::debug->ldc->pushType->return
MethodEmitter#load(int):::Push an int constant to the stack:::debug->ldc->pushType->return
MethodEmitter#load(double):::Push a double constant to the stack:::debug->ldc->pushType->return
MethodEmitter#load(long):::Push an long constant to the stack:::debug->ldc->pushType->return
MethodEmitter#arraylength():::Fetch the length of an array.:::debug->popType->arraylength->pushType->return
MethodEmitter#load(String):::Push a String constant to the stack:::debug->if->loadNull->return->length->s->length->if->_new->dup->load->constructorNoLookup->invoke->for->n->virtualCallNoLookup->invoke->return->ldc->pushType->return
MethodEmitter#load(IdentNode):::Pushes the value of an identifier to the stack:::return->ident->getSymbol->ident->getType->load
MethodEmitter#load(Symbol, Type):::Pushes the value of the symbol to the stack with the specified type:::if->symbol->hasSlot->slot->symbol->getSlot->symbol->getName->debug->load->else->if->symbol->isParam->index->symbol->getFieldIndex->if->functionNode->needsArguments->symbol->getName->debug->loadCompilerConstant->load->invoke->else->symbol->getName->debug->loadCompilerConstant->symbol->getFieldIndex->load->arrayload->return
MethodEmitter#load(Type, int):::Push a local variable to the stack, given an explicit bytecode slot:::debug->loadType->type->load->isThisSlot->pushType->stack->markLocalLoad->return
MethodEmitter#loadHandle(String, String, String, EnumSet):::Push a method handle to the stack:::flag->Flag->getValue->debug->new->Handle->ldc->pushType->return
MethodEmitter#hasScope():::True if this method has a slot allocated for the scope variable (meaning, something in the method actually needs the scope).:::return->getCompilerConstantSymbol->hasSlot
MethodEmitter#arrayload():::Load an element from an array, determining type automatically:::debug->popType->popArray->aload->pushType->return
MethodEmitter#arraystore():::Pop a value, an index and an array from the stack and store the value at the given index in the array.:::debug->value->popType->index->popType->array->popArray->array->astore
MethodEmitter#store(IdentNode):::Pop a value from the stack and store it in a local variable represented by the given identifier:::type->ident->getType->symbol->ident->getSymbol->if->store->else->store
MethodEmitter#store(Symbol, Type, boolean):::Pop a value from the stack and store it in a variable denoted by the given symbol:::if->symbol->hasSlot->isLiveType->symbol->hasSlotFor->existingDef->localVariableDefs->get->if->here->new->jdk.internal.org.objectweb.asm.Label->if->newDef->new->LocalVariableDef->localVariableDefs->put->method->visitLabel->if->endLocalValueDef->if->slot->symbol->getSlot->symbol->getName->debug->storeHidden->else->if->markDeadLocalVariable->symbol->getName->debug->pop->else->if->symbol->isParam->index->symbol->getFieldIndex->if->functionNode->needsArguments->convert->symbol->getName->debug->loadCompilerConstant->load->invoke->else->convert->symbol->getName->debug->loadCompilerConstant->load->invoke->else->symbol->getName->debug->pop
MethodEmitter#storeHidden(Type, int):::Pop a value from the stack and store it in a local variable slot:::storeHidden
MethodEmitter#defineBlockLocalVariable(int, int):::Marks a range of slots as belonging to a defined local variable:::stack->defineBlockLocalVariable
MethodEmitter#defineTemporaryLocalVariable(int, int):::Marks a range of slots as belonging to a defined temporary local variable:::stack->defineTemporaryLocalVariable
MethodEmitter#defineTemporaryLocalVariable(int):::Defines a new temporary local variable and returns its allocated index.:::return->stack->defineTemporaryLocalVariable
MethodEmitter#iinc(int, int):::Increment/Decrement a local integer by the given value.:::debug->method->visitIincInsn
MethodEmitter#athrow():::Pop an exception object from the stack and generate code for throwing it:::debug->receiver->popType->method->visitInsn->doesNotContinueSequentially
MethodEmitter#_instanceof(String):::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to:::debug->popType->method->visitTypeInsn->pushType->return
MethodEmitter#_instanceof(Class):::Pop an object from the stack and perform an instanceof operation, given a classDescriptor to compare it to:::return->CompilerConstants->className->_instanceof
MethodEmitter#checkcast(String):::Perform a checkcast operation on the object at the top of the stack.:::debug->method->visitTypeInsn->return
MethodEmitter#checkcast(Class):::Perform a checkcast operation on the object at the top of the stack.:::return->CompilerConstants->className->checkcast
MethodEmitter#newarray(ArrayType):::Instantiate a new array given a length that is popped from the stack and the array type:::debug->popType->arrayType->newarray->pushType->return
MethodEmitter#multinewarray(ArrayType, int):::Instantiate a multidimensional array with a given number of dimensions:::debug->for->i->arrayType->newarray->pushType->return
MethodEmitter#invoke(Call):::Generate an invocation to a Call structure:::return->call->invoke
MethodEmitter#invokespecial(String, String, String):::Pop receiver from stack, perform an invoke special:::debug->return->invoke
MethodEmitter#invokevirtual(String, String, String):::Pop receiver from stack, perform an invoke virtual, push return value if any:::debug->return->invoke
MethodEmitter#invokestatic(String, String, String):::Perform an invoke static and push the return value if any:::debug->invoke->return
MethodEmitter#invokestatic(String, String, String, Type):::Perform an invoke static and replace the return type if we know better, e.g:::invokestatic->popType->pushType->return
MethodEmitter#invokeinterface(String, String, String):::Pop receiver from stack, perform an invoke interface and push return value if any:::debug->return->invoke
MethodEmitter#lookupswitch(Label, int[], Label...):::Generate a lookup switch, popping the switch value from the stack:::peekType->debug->adjustStackForSwitch->method->defaultLabel->getLabel->getLabels->visitLookupSwitchInsn->doesNotContinueSequentially
MethodEmitter#tableswitch(int, int, Label, Label...):::Generate a table switch:::peekType->debug->adjustStackForSwitch->method->defaultLabel->getLabel->getLabels->visitTableSwitchInsn->doesNotContinueSequentially
MethodEmitter#conditionalJump(Condition, Label):::Abstraction for performing a conditional jump of any type:::conditionalJump
MethodEmitter#conditionalJump(Condition, boolean, Label):::Abstraction for performing a conditional jump of any type, including a dcmpg/dcmpl semantic for doubles.:::if->peekType->isCategory2->debug->get2n->cmp->pushType->Condition->toUnary->jump->else->debug->Condition->peekType->isObject->toBinary->jump
MethodEmitter#_return(Type):::Perform a non void return, popping the type from the stack:::debug->stackType->peekType->if->Type->areEquivalent->convert->popType->_return->doesNotContinueSequentially
MethodEmitter#_return():::Perform a return using the stack top value as the guide for the type:::peekType->_return
MethodEmitter#returnVoid():::Perform a void return.:::debug->method->visitInsn->doesNotContinueSequentially
MethodEmitter#cmp(boolean):::Perform a comparison of two number types that are popped from the stack:::get2n->cmp->pushType->return
MethodEmitter#if_acmpeq(Label):::Generate an if_acmpeq:::debug->jump
MethodEmitter#if_acmpne(Label):::Generate an if_acmpne:::debug->jump
MethodEmitter#ifnull(Label):::Generate an ifnull:::debug->jump
MethodEmitter#ifnonnull(Label):::Generate an ifnonnull:::debug->jump
MethodEmitter#ifeq(Label):::Generate an ifeq:::debug->jump
MethodEmitter#if_icmpeq(Label):::Generate an if_icmpeq:::debug->jump
MethodEmitter#ifne(Label):::Generate an if_ne:::debug->jump
MethodEmitter#if_icmpne(Label):::Generate an if_icmpne:::debug->jump
MethodEmitter#iflt(Label):::Generate an iflt:::debug->jump
MethodEmitter#if_icmplt(Label):::Generate an if_icmplt:::debug->jump
MethodEmitter#ifle(Label):::Generate an ifle:::debug->jump
MethodEmitter#if_icmple(Label):::Generate an if_icmple:::debug->jump
MethodEmitter#ifgt(Label):::Generate an ifgt:::debug->jump
MethodEmitter#if_icmpgt(Label):::Generate an if_icmpgt:::debug->jump
MethodEmitter#ifge(Label):::Generate an ifge:::debug->jump
MethodEmitter#if_icmpge(Label):::Generate an if_icmpge:::debug->jump
MethodEmitter#_goto(Label):::Unconditional jump to a label:::debug->jump->doesNotContinueSequentially
MethodEmitter#gotoLoopStart(Label):::Unconditional jump to the start label of a loop:::debug->jump
MethodEmitter#uncheckedGoto(Label):::Unconditional jump without any control flow and data flow testing:::method->target->getLabel->visitJumpInsn
MethodEmitter#canThrow(Label):::Potential transfer of control to a catch block.:::catchLabel->joinFromTry
MethodEmitter#label(Label):::Register a new label, enter it here.:::breakLabel
MethodEmitter#breakLabel(Label, int):::Register a new break target label, enter it here.:::if->isReachable->else->joinTo->labelStack->label->getStack->labelStack->clone->if->label->isBreakTarget->debug_label->method->label->getLabel->visitLabel
MethodEmitter#convert(Type):::Pop element from stack, convert to given type:::from->peekType->type->from->convert->if->if->from->isEquivalentTo->debug->if->l0->stack->getTopLocalLoad->popType->pushType->if->from->isObject->stack->markLocalLoad->return
MethodEmitter#add(int):::Pop two numbers, perform addition and push result:::debug->get2->add->pushType->return
MethodEmitter#sub(int):::Pop two numbers, perform subtraction and push result:::debug->get2n->sub->pushType->return
MethodEmitter#mul(int):::Pop two numbers, perform multiplication and push result:::debug->get2n->mul->pushType->return
MethodEmitter#div(int):::Pop two numbers, perform division and push result:::debug->get2n->div->pushType->return
MethodEmitter#rem(int):::Pop two numbers, calculate remainder and push result:::debug->get2n->rem->pushType->return
MethodEmitter#getTypesFromStack(int):::Retrieve the top count types on the stack without modifying it.:::return->stack->getTopTypes
MethodEmitter#dynamicNew(int, int):::Generate a dynamic new:::return->dynamicNew
MethodEmitter#dynamicNew(int, int, String):::Generate a dynamic new:::debug->signature->getDynamicSignature->method->msg->length->NameCodec->encode->visitInvokeDynamicInsn->pushType->return
MethodEmitter#dynamicCall(Type, int, int):::Generate a dynamic call:::return->dynamicCall
MethodEmitter#dynamicCall(Type, int, int, String):::Generate a dynamic call:::debug->signature->getDynamicSignature->debug->method->msg->length->NameCodec->encode->visitInvokeDynamicInsn->pushType->return
MethodEmitter#dynamicGet(Type, String, int, boolean, boolean):::Generate dynamic getter:::if->name->length->return->load->dynamicGetIndex->getProgramPoint->debug->type->if->type->isObject->type->isBoolean->popType->method->NameCodec->encode->Type->getMethodDescriptor->dynGetOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#dynamicSet(String, int, boolean):::Generate dynamic setter:::if->name->length->load->swap->dynamicSetIndex->return->peekType->debug->type->peekType->if->type->isObject->type->isBoolean->convert->popType->popType->method->NameCodec->encode->type->getTypeClass->methodDescriptor->dynSetOperation->visitInvokeDynamicInsn
MethodEmitter#dynamicRemove(String, int, boolean):::Generate dynamic remover:::if->name->length->return->load->dynamicRemoveIndex->getProgramPoint->debug->popType->method->NameCodec->encode->Type->getMethodDescriptor->dynRemoveOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#dynamicGetIndex(Type, int, boolean):::Dynamic getter for indexed structures:::peekType->peekType->getProgramPoint->debug->resultType->if->result->isBoolean->index->peekType->if->index->isObject->index->isBoolean->convert->popType->popType->signature->Type->getMethodDescriptor->method->dynGetOperation->visitInvokeDynamicInsn->pushType->if->result->isBoolean->convert->return
MethodEmitter#dynamicSetIndex(int):::Dynamic setter for indexed structures:::peekType->peekType->peekType->debug->value->peekType->if->value->isObject->value->isBoolean->convert->popType->index->peekType->if->index->isObject->index->isBoolean->convert->popType->receiver->popType->method->receiver->getTypeClass->index->getTypeClass->value->getTypeClass->methodDescriptor->visitInvokeDynamicInsn
MethodEmitter#dynamicRemoveIndex(int):::Dynamic remover for indexed structures:::peekType->peekType->getProgramPoint->debug->index->peekType->if->index->isObject->index->isBoolean->convert->popType->popType->signature->Type->getMethodDescriptor->method->dynRemoveOperation->visitInvokeDynamicInsn->pushType->convert->return
MethodEmitter#getField(FieldAccess):::Generate get for a field access:::return->fa->get
MethodEmitter#putField(FieldAccess):::Generate set for a field access:::fa->put
MethodEmitter#getField(String, String, String):::Get the value of a non-static field, pop the receiver from the stack, push value to the stack:::peekType->debug->receiver->popType->method->visitFieldInsn->fieldType->pushType->return
MethodEmitter#getStatic(String, String, String):::Get the value of a static field, push it to the stack:::debug->method->visitFieldInsn->fieldType->pushType->return
MethodEmitter#putField(String, String, String):::Pop value and field from stack and write to a non-static field:::peekType->peekType->debug->fieldType->popType->popType->method->visitFieldInsn
MethodEmitter#putStatic(String, String, String):::Pop value from stack and write to a static field:::peekType->debug->fieldType->popType->method->visitFieldInsn
MethodEmitter#lineNumber(int):::Register line number at a label:::if->context->getEnv->debug_label->l->new->jdk.internal.org.objectweb.asm.Label->method->visitLabel->method->visitLineNumber
MethodEmitter#print():::Emit a System.err.print statement of whatever is on top of the bytecode stack:::getField->swap->convert->invoke
MethodEmitter#println():::Emit a System.err.println statement of whatever is on top of the bytecode stack:::getField->swap->convert->invoke
MethodEmitter#print(String):::Emit a System.err.print statement:::getField->load->invoke
MethodEmitter#println(String):::Emit a System.err.println statement:::getField->load->invoke
MethodEmitter#stacktrace():::Print a stacktrace to S:::_new->dup->constructorNoLookup->invoke->invoke
MethodEmitter#setFunctionNode(FunctionNode):::Set the current function node being emitted:::
MethodEmitter#setPreventUndefinedLoad():::Invoke to enforce assertions preventing load from a local variable slot that's known to not have been written to:::
Namespace#getParent():::Return the parent Namespace of this space.:::return
Namespace#uniqueName(String):::Create a uniqueName name in the namespace in the form base-n where n varies:::truncatedBase->base->length->base->substring->for->namespace->namespace->getParent->directory->put->return
ObjectClassGenerator#pack(Number):::Pack a number into a primitive long field:::if->return->n->intValue->else->if->return->n->longValue->else->if->return->Double->n->doubleValue->doubleToRawLongBits->throw->new->AssertionError
ObjectClassGenerator#getClassName(int, boolean):::Returns the class name for JavaScript objects with fieldCount fields.:::prefix->getPrefixName->return
ObjectClassGenerator#getClassName(int, int, boolean):::Returns the class name for JavaScript scope with fieldCount fields and paramCount parameters.:::return->getPrefixName
ObjectClassGenerator#getFieldCount(Class):::Returns the number of fields in the JavaScript scope class:::name->clazz->getSimpleName->prefix->getPrefixName->if->prefix->equals->return->scopeMarker->name->indexOf->return->Integer->name->prefix->length->substring->name->prefix->length->substring->parseInt
ObjectClassGenerator#getFieldName(int, Type):::Returns the name of a field based on number and type.:::return->type->getDescriptor->substring
ObjectClassGenerator#generate(String):::Generate the byte codes for a JavaScript object class or scope:::counts->descriptor->split->fieldCount->Integer->valueOf->if->return->generate->paramCount->Integer->valueOf->return->generate
ObjectClassGenerator#generate(int):::Generate the byte codes for a JavaScript object class with fieldCount fields.:::className->getClassName->superName->className->classEmitter->newClassEmitter->addFields->init->newInitMethod->init->returnVoid->init->end->initWithSpillArrays->newInitWithSpillArraysMethod->initWithSpillArrays->returnVoid->initWithSpillArrays->end->newEmptyInit->newAllocate->return->toByteArray
ObjectClassGenerator#generate(int, int):::Generate the byte codes for a JavaScript scope class with fieldCount fields and paramCount parameters.:::className->getClassName->superName->className->classEmitter->newClassEmitter->initFields->addFields->init->newInitScopeMethod->initializeToUndefined->init->returnVoid->init->end->initWithSpillArrays->newInitWithSpillArraysMethod->initializeToUndefined->initWithSpillArrays->returnVoid->initWithSpillArrays->end->initWithArguments->newInitScopeWithArgumentsMethod->initializeToUndefined->initWithArguments->returnVoid->initWithArguments->end->return->toByteArray
ObjectClassGenerator#createGetter(Class, Class, MethodHandle, MethodHandle, int):::Given a primitiveGetter (optional for non dual fields) and an objectSetter that retrieve the primitive and object version of a field respectively, return one with the correct method type and the correct filters:::return->isValid->createGetterInner
ObjectClassGenerator#createSetter(Class, Class, MethodHandle, MethodHandle):::This is similar to the ObjectClassGenerator#createGetter function:::fti->getAccessorTypeIndex->ti->getAccessorTypeIndex->if->if->return->return->MH->objectSetter->type->changeParameterType->asType->pmt->primitiveSetter->type->switch->switch->return->MH->pmt->changeParameterType->asType->return->MH->filterArguments->return->if->return->return->MH->MH->filterArguments->pmt->changeParameterType->asType->throw->new->UnsupportedOperationException
ObjectClassGenerator#createGuardBoxedPrimitiveSetter(Class, MethodHandle, MethodHandle):::If we are setting boxed types (because the compiler couldn't determine which they were) to a primitive field, we can reuse the primitive field getter, as long as we are setting an element of the same boxed type as the primitive type representation:::boxedForType->getBoxedType->return->MH->MH->MH->dropArguments->insertArguments->MH->objectSetter->type->asType->guardWithTest
ObjectClassGenerator#getPaddedFieldCount(int):::Add padding to field count to avoid creating too many classes and have some spare fields:::return
ObjectClassGenerator#createAllocationStrategy(int, boolean):::Creates the allocator class name and property map for a constructor function with the specified number of "this" properties that it initializes.:::paddedFieldCount->getPaddedFieldCount->return->new->AllocationStrategy
ObjectCreator#makeObject(MethodEmitter):::Generate code for making the object.:::createObject->objectSlot->method->getUsedSlotsWithLiveTemporaries->objectType->method->peekType->method->storeTemp->tuples->size->populateRange
ObjectCreator#createObject(MethodEmitter):::Generate code for creating and initializing the object.:::
ObjectCreator#makeMap():::Construct the property map appropriate for the object.:::
ObjectCreator#newMapCreator(Class):::Create a new MapCreator:::return->new->MapCreator<>
ObjectCreator#loadScope(MethodEmitter):::Loads the scope on the stack through the passed method emitter.:::method->loadCompilerConstant
ObjectCreator#loadMap(MethodEmitter):::Emit the correct map for the object.:::codegen->loadConstant->return
ObjectCreator#isScope():::Is this a scope object:::return
ObjectCreator#hasArguments():::Does the created object have an "arguments" property:::return
ObjectCreator#getAllocatorClass():::Get the class of objects created by this ObjectCreator:::
ObjectCreator#loadValue(T, Type):::Technique for loading an initial value:::
OptimisticTypesPersistence#getLocationDescriptor(Source, int, Type[]):::Retrieves an opaque descriptor for the persistence location for a given function:::if->return->b->new->StringBuilder->b->source->getDigest->append->append->append->if->b->append->foreach->b->Type->getShortSignatureDescriptor->append->return->b->toString->new->File->new->LocationDescriptor
OptimisticTypesPersistence#store(Object, Map):::Stores the map of optimistic types for a given function.:::if->optimisticTypes->isEmpty->return->file->AccessController->new->PrivilegedAction<Void>->doPrivileged
OptimisticTypesPersistence#load(Object):::Loads the map of optimistic types for a given function.:::if->return->file->return->AccessController->new->PrivilegedAction<Map<Integer,Type>>->doPrivileged
OptimisticTypesPersistence#getVersionDirName():::In order to ensure that changes in Nashorn code don't cause corruption in the data, we'll create a per-code-version directory:::url->getResource->protocol->url->getProtocol->if->protocol->equals->jarUrlFile->url->getFile->filePath->jarUrlFile->jarUrlFile->indexOf->substring->file->new->URL->try->in->file->openStream->buf->new->byteArr->digest->MessageDigest->getInstance->for->catch->finally->else->if->protocol->equals->fileStr->url->getFile->className->getName->packageNameLen->className->lastIndexOf->dirStr->fileStr->fileStr->length->ANCHOR_PROPS->length->substring->dir->new->File->return->new->SimpleDateFormat->getLastModifiedClassFile->new->Date->format->else->if->protocol->equals->return->getJrtVersionDirName->else->throw->new->AssertionError
ReplaceCompileUnits#getReplacement(CompileUnit):::Override to provide a replacement for an old compile unit.:::
SharedScopeCall#setClassAndName(CompileUnit, String):::Set the compile unit and method name.:::
SharedScopeCall#generateInvoke(MethodEmitter):::Generate the invoke instruction for this shared scope call.:::method->compileUnit->getUnitClassName->getStaticSignature->invokestatic
SharedScopeCall#generateScopeCall():::Generate the method that implements the scope get or call.:::classEmitter->compileUnit->getClassEmitter->methodFlags->EnumSet->of->method->classEmitter->getStaticSignature->method->method->begin->method->load->method->load->method->invoke->beginTry->endTry->catchLabel->if->new->Label->new->Label->new->Label->method->label->method->_try->else->getFlags->method->symbol->getName->dynamicGet->if->method->convert->method->loadUndefined->slot->foreach->method->load->type->getSlots->callFlags->method->symbol->getName->dynamicCall->if->method->label->method->_return->if->method->_catch->method->load->method->invoke->method->athrow->method->end
Splitter#split(FunctionNode, boolean):::Execute the split.:::functionNode->log->functionNode->getName->fine->weight->WeighNodes->weigh->if->log->functionNode->getName->info->functionNode->accept->if->functionNode->isSplit->WeighNodes->weigh->functionNode->functionNode->getBody->setNeedsScope->setBody->if->functionNode->functionNode->getBody->splitBlock->setBody->functionNode->setFlag->WeighNodes->functionNode->getBody->weigh->if->functionNode->setCompileUnit->outermostCompileUnit->addWeight->else->functionNode->findUnit->setCompileUnit->body->functionNode->getBody->dc->directChildren->newBody->body->new->SimpleNodeVisitor->accept->functionNode->setBody->return
Splitter#findUnit(long):::Override this logic to look up compile units in a different way:::return->compiler->findUnit
TypeEvaluator#hasStringPropertyIterator(Expression):::Returns true if the expression can be safely evaluated, and its value is an object known to always use String as the type of its property names retrieved through ScriptRuntime#toPropertyIterator(Object):::return->evaluateSafely
TypeEvaluator#declareLocalSymbol(String):::Declares a symbol name as belonging to a non-scoped local variable during an on-demand compilation of a single function:::if->runtimeScope->findProperty->runtimeScope->addOwnProperty
TypeMap#getParameterTypes(int):::Returns the array of parameter types for a particular function node:::return->paramTypes->clone
TypeMap#needsCallee():::Does the function using this TypeMap need a callee argument:::return
TypeMap#get(FunctionNode, int):::Get the parameter type for this parameter position, or null if now known:::types->if->return->return
TypeMap#getReturnType():::Get the return type required for the call site we're compiling for:::return->returnType->isObject
