Plugin_BranchProbabilityNode_probability#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ branch probability node_probability execute:::arg0->arg1->node->new->org.graalvm.compiler.nodes.extended.BranchProbabilityNode->b->addPush->return
Plugin_BranchProbabilityNode_probability#getSource()::: plugin_ branch probability node_probability get source:::return
PluginFactory_BranchProbabilityNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ branch probability node register plugins:::plugins->new->Plugin_BranchProbabilityNode_probability->register
Plugin_FixedValueAnchorNode_getObject#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ fixed value anchor node_get object execute:::arg0->node->new->org.graalvm.compiler.nodes.extended.FixedValueAnchorNode->b->addPush->return
Plugin_FixedValueAnchorNode_getObject#getSource()::: plugin_ fixed value anchor node_get object get source:::return
PluginFactory_FixedValueAnchorNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ fixed value anchor node register plugins:::plugins->new->Plugin_FixedValueAnchorNode_getObject->register
Plugin_GuardedUnsafeLoadNode_guardedLoad#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ guarded unsafe load node_guarded load execute:::arg0->arg1->arg2->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg3->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg4->node->new->org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode->b->addPush->return
Plugin_GuardedUnsafeLoadNode_guardedLoad#getSource()::: plugin_ guarded unsafe load node_guarded load get source:::return
PluginFactory_GuardedUnsafeLoadNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ guarded unsafe load node register plugins:::plugins->new->Plugin_GuardedUnsafeLoadNode_guardedLoad->register
Plugin_MembarNode_memoryBarrier__0#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ membar node_memory barrier__0 execute:::arg0->if->isConstant->asJavaConstant->asInt->else->return->node->new->org.graalvm.compiler.nodes.extended.MembarNode->b->add->return
Plugin_MembarNode_memoryBarrier__0#getSource()::: plugin_ membar node_memory barrier__0 get source:::return
Plugin_MembarNode_memoryBarrier__1#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ membar node_memory barrier__1 execute:::arg0->if->isConstant->asJavaConstant->asInt->else->return->arg1->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.extended.MembarNode->b->add->return
Plugin_MembarNode_memoryBarrier__1#getSource()::: plugin_ membar node_memory barrier__1 get source:::return
PluginFactory_MembarNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ membar node register plugins:::plugins->new->Plugin_MembarNode_memoryBarrier__0->register->plugins->new->Plugin_MembarNode_memoryBarrier__1->register
Plugin_NullCheckNode_nullCheck#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ null check node_null check execute:::arg0->node->new->org.graalvm.compiler.nodes.extended.NullCheckNode->b->add->return
Plugin_NullCheckNode_nullCheck#getSource()::: plugin_ null check node_null check get source:::return
PluginFactory_NullCheckNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ null check node register plugins:::plugins->new->Plugin_NullCheckNode_nullCheck->register
Plugin_RawLoadNode_load#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ raw load node_load execute:::arg0->arg1->arg2->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg3->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.extended.RawLoadNode->b->addPush->return
Plugin_RawLoadNode_load#getSource()::: plugin_ raw load node_load get source:::return
PluginFactory_RawLoadNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ raw load node register plugins:::plugins->new->Plugin_RawLoadNode_load->register
Plugin_RawStoreNode_storeByte#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ raw store node_store byte execute:::arg0->arg1->arg2->arg3->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg4->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.extended.RawStoreNode->b->addPush->return
Plugin_RawStoreNode_storeByte#getSource()::: plugin_ raw store node_store byte get source:::return
Plugin_RawStoreNode_storeChar#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ raw store node_store char execute:::arg0->arg1->arg2->arg3->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg4->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->node->new->org.graalvm.compiler.nodes.extended.RawStoreNode->b->addPush->return
Plugin_RawStoreNode_storeChar#getSource()::: plugin_ raw store node_store char get source:::return
Plugin_RawStoreNode_storeObject#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ raw store node_store object execute:::arg0->arg1->arg2->arg3->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg4->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg5->if->isConstant->asJavaConstant->asInt->else->return->node->new->org.graalvm.compiler.nodes.extended.RawStoreNode->b->addPush->return
Plugin_RawStoreNode_storeObject#getSource()::: plugin_ raw store node_store object get source:::return
PluginFactory_RawStoreNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ raw store node register plugins:::plugins->new->Plugin_RawStoreNode_storeByte->register->plugins->new->Plugin_RawStoreNode_storeChar->register->plugins->new->Plugin_RawStoreNode_storeObject->register
Plugin_StoreHubNode_write#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ store hub node_write execute:::arg0->arg1->node->new->org.graalvm.compiler.nodes.extended.StoreHubNode->b->add->return
Plugin_StoreHubNode_write#getSource()::: plugin_ store hub node_write get source:::return
PluginFactory_StoreHubNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ store hub node register plugins:::plugins->new->Plugin_StoreHubNode_write->register
Plugin_UnsafeCopyNode_copy#execute(GraphBuilderContext, ResolvedJavaMethod, InvocationPlugin.Receiver, ValueNode[])::: plugin_ unsafe copy node_copy execute:::arg0->arg1->arg2->arg3->arg4->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->arg5->if->isConstant->snippetReflection->asJavaConstant->asObject->else->return->return->intrinsify
Plugin_UnsafeCopyNode_copy#getSource()::: plugin_ unsafe copy node_copy get source:::return
PluginFactory_UnsafeCopyNode#registerPlugins(InvocationPlugins, NodeIntrinsicPluginFactory.InjectionProvider)::: plugin factory_ unsafe copy node register plugins:::plugins->new->Plugin_UnsafeCopyNode_copy->register
ArrayRangeWrite#getAddress()::: array range write get address:::
ArrayRangeWrite#getLength():::The length of the modified range.:::
ArrayRangeWrite#writesObjectArray():::Return true if the written array is an object array, false if it is a primitive array.:::
ArrayRangeWrite#isInitialization():::Returns whether this write is the initialization of the written location:::
ArrayRangeWrite#getElementStride()::: array range write get element stride:::
ArrayRangeWrite#asNode()::: array range write as node:::
BoxNode#getBoxingKind()::: box node get boxing kind:::return
BoxNode#getValue()::: box node get value:::return
BoxNode#lower(LoweringTool)::: box node lower:::tool->getLowerer->lower
BoxNode#canonical(CanonicalizerTool, ValueNode)::: box node canonical:::if->tool->allUsagesAvailable->hasNoUsages->return->return
BoxNode#createVirtualBoxingNode()::: box node create virtual boxing node:::node->StampTool->stamp->typeOrNull->new->VirtualBoxingNode->node->getNodeSourcePosition->setNodeSourcePosition->return
BoxNode#virtualize(VirtualizerTool)::: box node virtualize:::alias->tool->getValue->getAlias->newVirtual->createVirtualBoxingNode->tool->new->ValueNodeArr->Collections->emptyList->createVirtualObject->tool->replaceWithVirtual
BranchProbabilityNode#getProbability()::: branch probability node get probability:::return
BranchProbabilityNode#getCondition()::: branch probability node get condition:::return
BranchProbabilityNode#canonical(CanonicalizerTool)::: branch probability node canonical:::if->condition->isConstant->return->return
BranchProbabilityNode#simplify(SimplifierTool)::: branch probability node simplify:::if->hasUsages->return->if->probability->isConstant->probabilityValue->probability->asJavaConstant->asDouble->if->throw->new->GraalError->else->if->throw->new->GraalError->else->if->Double->isNaN->return->usageFound->foreach->this->usages->filter->other->node->getX->if->node->getX->node->getY->if->other->isConstant->probabilityToSet->if->other->asJavaConstant->asInt->foreach->node->usages->filter->ifNodeUsages->setTrueSuccessorProbability->if->node->usages->NodePredicates->isA->or->filter->isNotEmpty->if->currentCondition->currentStamp->currentCondition->stamp->if->currentStamp->lowerBound->currentStamp->upperBound->narrow->graph->NarrowNode->create->maybeAddOrUnique->graph->ZeroExtendNode->create->maybeAddOrUnique->replaceAndDelete->if->tool->currentCondition->usages->addToWorkList->else->if->isSubstitutionGraph->throw->new->GraalError
BranchProbabilityNode#isSubstitutionGraph()::: branch probability node is substitution graph:::return->hasExactlyOneUsage->usages->first
BranchProbabilityNode#probability(double, boolean):::This intrinsic should only be used for the condition of an if statement:::
BranchProbabilityNode#lower(LoweringTool)::: branch probability node lower:::throw->new->GraalError
BytecodeExceptionNode#getExceptionKind()::: bytecode exception node get exception kind:::return
BytecodeExceptionNode#toString(Verbosity)::: bytecode exception node to string:::if->return->super->toString->return->super->toString
BytecodeExceptionNode#getLocationIdentity()::: bytecode exception node get location identity:::return->LocationIdentity->any
BytecodeExceptionNode#canonical(CanonicalizerTool)::: bytecode exception node canonical:::if->tool->allUsagesAvailable->getUsageCount->return->return
BytecodeExceptionNode#lower(LoweringTool)::: bytecode exception node lower:::tool->getLowerer->lower
BytecodeExceptionNode#getArguments()::: bytecode exception node get arguments:::return
FixedValueAnchorNode#object()::: fixed value anchor node object:::return
FixedValueAnchorNode#inferStamp()::: fixed value anchor node infer stamp:::if->return->stamp->object->stamp->join->updateStamp->else->return
FixedValueAnchorNode#getObject(Object)::: fixed value anchor node get object:::
FixedValueAnchorNode#generate(NodeLIRBuilderTool)::: fixed value anchor node generate:::generator->generator->operand->setResult
FixedValueAnchorNode#getOriginalNode()::: fixed value anchor node get original node:::return
FixedValueAnchorNode#getGuard()::: fixed value anchor node get guard:::return
ForeignCallNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, Stamp, ForeignCallsProvider, ForeignCallDescriptor, ValueNode...)::: foreign call node intrinsify:::if->foreignCalls->isAvailable->return->node->new->ForeignCallNode->node->setStamp->nonIntrinsicAncestor->b->getNonIntrinsicAncestor->if->node->nonIntrinsicAncestor->bci->setBci->returnKind->targetMethod->getSignature->getReturnKind->if->b->add->else->b->addPush->return
ForeignCallNode#verifyDescriptor(GraphBuilderContext, ResolvedJavaMethod, ForeignCallDescriptor)::: foreign call node verify descriptor:::parameters->foreach->descriptor->getArgumentTypes->res->b->getMetaAccess->lookupJavaType->parameterType->targetMethod->getSignature->targetMethod->getDeclaringClass->getParameterType->return
ForeignCallNode#hasSideEffect()::: foreign call node has side effect:::return->foreignCalls->isReexecutable
ForeignCallNode#getDescriptor()::: foreign call node get descriptor:::return
ForeignCallNode#getLocationIdentities()::: foreign call node get location identities:::return->foreignCalls->getKilledLocations
ForeignCallNode#operands(NodeLIRBuilderTool)::: foreign call node operands:::operands->arguments->size->new->ValueArr->for->i->return
ForeignCallNode#generate(NodeLIRBuilderTool)::: foreign call node generate:::linkage->gen->getLIRGeneratorTool->getForeignCalls->lookupForeignCall->operands->operands->result->gen->getLIRGeneratorTool->gen->state->emitForeignCall->if->gen->setResult
ForeignCallNode#setStateAfter(FrameState)::: foreign call node set state after:::super->setStateAfter
ForeignCallNode#stateDuring()::: foreign call node state during:::return
ForeignCallNode#setStateDuring(FrameState)::: foreign call node set state during:::updateUsages
ForeignCallNode#getBci()::: foreign call node get bci:::return
ForeignCallNode#setBci(int):::Set the bci of the invoke bytecode for use when converting a stateAfter into a stateDuring.:::
ForeignCallNode#computeStateDuring(FrameState)::: foreign call node compute state during:::newStateDuring->if->currentStateAfter->stackSize->currentStateAfter->currentStateAfter->stackSize->stackAt->currentStateAfter->stackSize->currentStateAfter->currentStateAfter->stackSize->stackAt->currentStateAfter->this->getStackKind->duplicateModifiedDuringCall->else->setStateDuring
ForeignCallNode#toString(Verbosity)::: foreign call node to string:::if->return->super->toString->return->super->toString
ForeignCallNode#canDeoptimize()::: foreign call node can deoptimize:::return->foreignCalls->canDeoptimize
ForeignCallNode#isGuaranteedSafepoint()::: foreign call node is guaranteed safepoint:::return->foreignCalls->isGuaranteedSafepoint
ForeignCallNode#getArguments()::: foreign call node get arguments:::return
GetClassNode#getObject()::: get class node get object:::return
GetClassNode#lower(LoweringTool)::: get class node lower:::tool->getLowerer->lower
GetClassNode#tryFold(MetaAccessProvider, ConstantReflectionProvider, NodeView, ValueNode)::: get class node try fold:::if->object->stamp->objectStamp->object->stamp->if->objectStamp->isExactType->return->ConstantNode->constantReflection->objectStamp->type->asJavaClass->forConstant->return
GetClassNode#canonical(CanonicalizerTool)::: get class node canonical:::view->NodeView->from->folded->tool->getMetaAccess->tool->getConstantReflection->getObject->tryFold->return
GetClassNode#virtualize(VirtualizerTool)::: get class node virtualize:::alias->tool->getObject->getAlias->if->virtual->javaClass->tool->getConstantReflection->virtual->type->asJavaClass->tool->ConstantNode->stamp->tool->getMetaAccess->graph->forConstant->replaceWithValue
GuardedNode#getGuard()::: guarded node get guard:::
GuardedNode#setGuard(GuardingNode)::: guarded node set guard:::
GuardedUnsafeLoadNode#getGuard()::: guarded unsafe load node get guard:::return
GuardedUnsafeLoadNode#setGuard(GuardingNode)::: guarded unsafe load node set guard:::updateUsagesInterface
GuardedUnsafeLoadNode#guardedLoad(Object, long, JavaKind, LocationIdentity, GuardingNode)::: guarded unsafe load node guarded load:::
HubGetClassNodeInterface#getHub()::: hub get class node interface get hub:::
IntegerSwitchNode#assertSorted()::: integer switch node assert sorted:::for->i->return
IntegerSwitchNode#assertNoUntargettedSuccessor()::: integer switch node assert no untargetted successor:::checker->successors->size->new->booleanArr->foreach->defaultSuccessorIndex->foreach->return
IntegerSwitchNode#isSorted()::: integer switch node is sorted:::return
IntegerSwitchNode#keyAt(int):::Gets the key at the specified index.:::return->JavaConstant->forInt
IntegerSwitchNode#intKeyAt(int):::Gets the key at the specified index, as a java int.:::return
IntegerSwitchNode#keyCount()::: integer switch node key count:::return
IntegerSwitchNode#equalKeys(SwitchNode)::: integer switch node equal keys:::if->return->other->return->Arrays->equals
IntegerSwitchNode#generate(NodeLIRBuilderTool)::: integer switch node generate:::gen->emitSwitch
IntegerSwitchNode#successorAtKey(int)::: integer switch node successor at key:::return->successorIndexAtKey->blockSuccessor
IntegerSwitchNode#successorIndexAtKey(int)::: integer switch node successor index at key:::for->i->keyCount->return->keyCount->keySuccessorIndex
IntegerSwitchNode#simplify(SimplifierTool)::: integer switch node simplify:::view->NodeView->from->if->blockSuccessorCount->tool->defaultSuccessor->addToWorkList->graph->defaultSuccessor->removeSplitPropagate->else->if->value->value->asJavaConstant->asInt->successorIndexAtKey->killOtherSuccessors->else->if->tryOptimizeEnumSwitch->return->else->if->value->stamp->tryRemoveUnreachableKeys->return->else->if->switchTransformationOptimization->return
IntegerSwitchNode#addSuccessorForDeletion(AbstractBeginNode)::: integer switch node add successor for deletion:::successors->add
IntegerSwitchNode#getNextSwitchFoldableBranch()::: integer switch node get next switch foldable branch:::return->defaultSuccessor
IntegerSwitchNode#isInSwitch(ValueNode)::: integer switch node is in switch:::return
IntegerSwitchNode#cutOffCascadeNode()::: integer switch node cut off cascade node:::toKill->defaultSuccessor->clearSuccessors->addSuccessorForDeletion
IntegerSwitchNode#cutOffLowestCascadeNode()::: integer switch node cut off lowest cascade node:::clearSuccessors
IntegerSwitchNode#getDefault()::: integer switch node get default:::return->defaultSuccessor
IntegerSwitchNode#switchValue()::: integer switch node switch value:::return->value
IntegerSwitchNode#isNonInitializedProfile()::: integer switch node is non initialized profile:::nbSuccessors->getSuccessorCount->prob->for->i->return
IntegerSwitchNode#tryRemoveUnreachableKeys(SimplifierTool, Stamp):::Remove unreachable keys from the switch based on the stamp of the value, i.e., based on the known range of the switch value.:::if->return->integerStamp->if->integerStamp->isUnrestricted->return->newKeyDatas->new->ArrayList<>->newSuccessors->blockSuccessorCount->new->ArrayList<>->for->i->if->newKeyDatas->size->return->else->if->newKeyDatas->size->if->tool->defaultSuccessor->addToWorkList->graph->defaultSuccessor->removeSplitPropagate->return->else->newDefaultSuccessor->defaultSuccessor->addNewSuccessor->newDefaultProbability->value->doReplace->return
IntegerSwitchNode#tryOptimizeEnumSwitch(SimplifierTool):::For switch statements on enum values, the Java compiler has to generate complicated code: because Enum#ordinal() can change when recompiling an enum, it cannot be used directly as the value that is switched on:::if->value->return->loadIndexed->value->if->loadIndexed->hasMoreThanOneUsage->return->newValue->loadIndexed->index->arrayConstant->loadIndexed->array->asJavaConstant->if->loadIndexed->array->getStableDimension->loadIndexed->array->isDefaultStable->return->optionalArrayLength->tool->getConstantReflection->readArrayLength->if->return->arrayLength->reverseArrayMapping->new->HashMap<>->for->i->newKeyDatas->new->ArrayList<>->newSuccessors->blockSuccessorCount->new->ArrayList<>->for->i->newDefaultSuccessor->defaultSuccessor->addNewSuccessor->newDefaultProbability->boundsCheck->graph->ConstantNode->graph->forInt->new->IntegerBelowNode->unique->graph->graph->new->FixedGuardNode->add->addBeforeFixed->doReplace->GraphUtil->removeFixedWithUnusedInputs->return
IntegerSwitchNode#addNewSuccessor(AbstractBeginNode, ArrayList)::: integer switch node add new successor:::index->newSuccessors->indexOf->if->newSuccessors->size->newSuccessors->add->return
IntegerSwitchNode#doReplace(ValueNode, List, ArrayList, int, double)::: integer switch node do replace:::newKeyDatas->Comparator->comparingInt->sort->newKeyCount->newKeyDatas->size->newKeys->new->intArr->newKeyProbabilities->new->doubleArr->newKeySuccessors->new->intArr->for->i->totalProbability->foreach->if->for->i->else->for->i->deadSuccessors->successors->newSuccessors->contains->filter->snapshot->successors->clear->successorsArray->newSuccessors->newSuccessors->size->new->AbstractBeginNodeArr->toArray->newSwitch->graph->new->IntegerSwitchNode->add->foreach->GraphUtil->killCFG->predecessor->setNext->GraphUtil->killWithUnusedFloatingInputs
IntegerSwitchNode#getValueStampForSuccessor(AbstractBeginNode)::: integer switch node get value stamp for successor:::result->if->this->defaultSuccessor->for->i->keyCount->return
JavaReadNode#lower(LoweringTool)::: java read node lower:::tool->getLowerer->lower
JavaReadNode#canNullCheck()::: java read node can null check:::return
JavaReadNode#getReadKind()::: java read node get read kind:::return
JavaReadNode#isCompressible()::: java read node is compressible:::return
JavaReadNode#canonical(CanonicalizerTool)::: java read node canonical:::return->ReadNode->getAddress->getLocationIdentity->canonicalizeRead
JavaWriteNode#lower(LoweringTool)::: java write node lower:::tool->getLowerer->lower
JavaWriteNode#canNullCheck()::: java write node can null check:::return
JavaWriteNode#getWriteKind()::: java write node get write kind:::return
JavaWriteNode#isCompressible()::: java write node is compressible:::return
JavaWriteNode#getAccessStamp()::: java write node get access stamp:::return->StampFactory->forKind
LoadArrayComponentHubNode#create(ValueNode, StampProvider, MetaAccessProvider, ConstantReflectionProvider)::: load array component hub node create:::stamp->stampProvider->createHubStamp->return->findSynonym
LoadArrayComponentHubNode#getValue()::: load array component hub node get value:::return
LoadArrayComponentHubNode#lower(LoweringTool)::: load array component hub node lower:::tool->getLowerer->lower
LoadArrayComponentHubNode#canonical(CanonicalizerTool, ValueNode)::: load array component hub node canonical:::return->tool->getMetaAccess->tool->getConstantReflection->findSynonym
LoadArrayComponentHubNode#findSynonym(LoadArrayComponentHubNode, ValueNode, Stamp, MetaAccessProvider, ConstantReflectionProvider)::: load array component hub node find synonym:::if->forValue->isConstant->type->constantReflection->forValue->asConstant->asJavaType->if->return->ConstantNode->constantReflection->type->getComponentType->asObjectHub->forConstant->return->new->LoadArrayComponentHubNode
LoadHubNode#getValue()::: load hub node get value:::return
LoadHubNode#hubStamp(StampProvider, ValueNode)::: load hub node hub stamp:::return->stampProvider->value->stamp->createHubStamp
LoadHubNode#create(ValueNode, StampProvider, MetaAccessProvider, ConstantReflectionProvider)::: load hub node create:::stamp->hubStamp->synonym->findSynonym->if->return->return->new->LoadHubNode
LoadHubNode#lower(LoweringTool)::: load hub node lower:::tool->getLowerer->lower
LoadHubNode#canonical(CanonicalizerTool)::: load hub node canonical:::if->GeneratePIC->tool->getOptions->getValue->view->NodeView->from->metaAccess->tool->getMetaAccess->curValue->getValue->newNode->stamp->tool->getConstantReflection->findSynonym->if->return->return
LoadHubNode#findSynonym(ValueNode, Stamp, MetaAccessProvider, ConstantReflectionProvider)::: load hub node find synonym:::if->GeneratePIC->curValue->getOptions->getValue->type->StampTool->typeReferenceOrNull->if->type->isExact->return->ConstantNode->constantReflection->type->getType->asObjectHub->forConstant->return
LoadHubNode#virtualize(VirtualizerTool)::: load hub node virtualize:::if->GeneratePIC->tool->getOptions->getValue->alias->tool->getValue->getAlias->type->StampTool->typeReferenceOrNull->if->type->isExact->tool->ConstantNode->stamp->tool->getConstantReflection->type->getType->asObjectHub->tool->getMetaAccess->graph->forConstant->replaceWithValue
LoadMethodNode#getHub()::: load method node get hub:::return
LoadMethodNode#lower(LoweringTool)::: load method node lower:::tool->getLowerer->lower
LoadMethodNode#canonical(CanonicalizerTool)::: load method node canonical:::if->object->getValue->type->StampTool->typeReferenceOrNull->if->if->type->isExact->return->type->getType->resolveExactMethod->assumptions->graph->getAssumptions->resolvedMethod->type->getType->findUniqueConcreteMethod->if->resolvedMethod->canRecordTo->type->getType->isInterface->method->getDeclaringClass->type->getType->isAssignableFrom->view->NodeView->from->resolvedMethod->recordTo->return->ConstantNode->stamp->resolvedMethod->getResult->getEncoding->tool->getMetaAccess->forConstant->if->hub->isConstant->return->tool->getConstantReflection->hub->asConstant->asJavaType->resolveExactMethod->return
LoadMethodNode#resolveExactMethod(CanonicalizerTool, ResolvedJavaType):::Find the method which would be loaded.:::newMethod->type->resolveConcreteMethod->if->return->ConstantNode->stamp->forConstant->else->return->ConstantNode->stamp->newMethod->getEncoding->tool->getMetaAccess->forConstant
LoadMethodNode#getMethod()::: load method node get method:::return
LoadMethodNode#getReceiverType()::: load method node get receiver type:::return
LoadMethodNode#getCallerType()::: load method node get caller type:::return
MembarNode#getLocationIdentity()::: membar node get location identity:::return
MembarNode#generate(NodeLIRBuilderTool)::: membar node generate:::generator->getLIRGeneratorTool->emitMembar
MembarNode#memoryBarrier(int)::: membar node memory barrier:::
MembarNode#memoryBarrier(int, LocationIdentity)::: membar node memory barrier:::
MultiGuardNode#generate(NodeLIRBuilderTool)::: multi guard node generate:::
MultiGuardNode#simplify(SimplifierTool)::: multi guard node simplify:::if->usages->filter->isNotEmpty->singleFloatingGuard->foreach->if->GraphUtil->isFloatingNode->if->else->if->return->foreach->usages->snapshot->if->usage->replaceFirstInput->tool->addToWorkList->if->usages->isEmpty->GraphUtil->killWithUnusedFloatingInputs
MultiGuardNode#addGuard(GuardingNode)::: multi guard node add guard:::g->asNode->add
MultiGuardNode#combine(GuardingNode, GuardingNode)::: multi guard node combine:::if->return->else->if->return->else->graph->first->asNode->graph->return->graph->first->asNode->second->asNode->new->MultiGuardNode->unique
MultiGuardNode#addGuard(GuardingNode, GuardingNode)::: multi guard node add guard:::if->multi->multi->addGuard->return->else->return->combine
NullCheckNode#getObject()::: null check node get object:::return
NullCheckNode#generate(NodeLIRBuilderTool)::: null check node generate:::generator->getLIRGeneratorTool->generator->operand->generator->state->emitNullCheck
NullCheckNode#canDeoptimize()::: null check node can deoptimize:::return
NullCheckNode#nullCheck(Object)::: null check node null check:::
OpaqueNode#getValue()::: opaque node get value:::return
OpaqueNode#setValue(ValueNode)::: opaque node set value:::this->updateUsages
OpaqueNode#remove()::: opaque node remove:::getValue->replaceAndDelete
OpaqueNode#generate(NodeLIRBuilderTool)::: opaque node generate:::gen->gen->operand->setResult
OSRMonitorEnterNode#virtualize(VirtualizerTool)::: monitor enter node virtualize:::
OSRMonitorEnterNode#generate(NodeLIRBuilderTool)::: monitor enter node generate:::
OSRMonitorEnterNode#lower(LoweringTool)::: monitor enter node lower:::
OSRStartNode#lower(LoweringTool)::: start node lower:::tool->getLowerer->lower
OSRStartNode#getOSRLocals()::: start node get locals:::return->usages->filter
RawLoadNode#lower(LoweringTool)::: raw load node lower:::tool->getLowerer->lower
RawLoadNode#virtualize(VirtualizerTool)::: raw load node virtualize:::alias->tool->object->getAlias->if->virtual->offsetValue->tool->offset->getAlias->if->offsetValue->isConstant->off->offsetValue->asJavaConstant->asLong->entryIndex->virtual->tool->getMetaAccess->accessKind->entryIndexForOffset->if->entry->tool->getEntry->entryKind->virtual->entryKind->if->entry->getStackKind->getStackKind->accessKind->if->entry->stamp->stamp->isCompatible->if->entry->stamp->p1->p2->entry->stamp->width1->p1->getBits->width2->p2->getBits->if->replacement->ReinterpretNode->create->tool->replaceWith->return->else->return->else->return->tool->replaceWith
RawLoadNode#canonical(CanonicalizerTool)::: raw load node canonical:::if->isAnyLocationForced->getLocationIdentity->isAny->targetObject->object->if->offset->isConstant->targetObject->isConstant->targetObject->isNullConstant->objectConstant->type->StampTool->typeOrNull->if->type->isArray->arrayConstant->objectConstant->asJavaConstant->if->stableDimension->objectConstant->getStableDimension->if->view->NodeView->from->constantOffset->offset->asJavaConstant->asLong->constant->stamp->tool->getConstantReflection->getMemoryAccessProvider->readConstant->isDefaultStable->objectConstant->isDefaultStable->if->constant->isDefaultForKind->return->ConstantNode->stamp->tool->getMetaAccess->forConstant->return->super->canonical
RawLoadNode#cloneAsFieldAccess(Assumptions, ResolvedJavaField, boolean)::: raw load node clone as field access:::return->LoadFieldNode->object->create
RawLoadNode#cloneAsArrayAccess(ValueNode, LocationIdentity)::: raw load node clone as array access:::return->object->accessKind->new->RawLoadNode
RawLoadNode#load(Object, long, JavaKind, LocationIdentity)::: raw load node load:::
RawStoreNode#storeObject(Object, long, Object, JavaKind, LocationIdentity, boolean)::: raw store node store object:::
RawStoreNode#storeChar(Object, long, char, JavaKind, LocationIdentity)::: raw store node store char:::
RawStoreNode#storeByte(Object, long, byte, JavaKind, LocationIdentity)::: raw store node store byte:::
RawStoreNode#needsBarrier()::: raw store node needs barrier:::return
RawStoreNode#stateAfter()::: raw store node state after:::return
RawStoreNode#setStateAfter(FrameState)::: raw store node set state after:::updateUsages
RawStoreNode#hasSideEffect()::: raw store node has side effect:::return
RawStoreNode#value()::: raw store node value:::return
RawStoreNode#lower(LoweringTool)::: raw store node lower:::tool->getLowerer->lower
RawStoreNode#virtualize(VirtualizerTool)::: raw store node virtualize:::alias->tool->object->getAlias->if->virtual->indexValue->tool->offset->getAlias->if->indexValue->isConstant->off->indexValue->asJavaConstant->asLong->entryIndex->virtual->tool->getMetaAccess->accessKind->entryIndexForOffset->if->tool->value->accessKind->setVirtualEntry->tool->delete
RawStoreNode#cloneAsFieldAccess(Assumptions, ResolvedJavaField, boolean)::: raw store node clone as field access:::return->object->value->stateAfter->new->StoreFieldNode
RawStoreNode#cloneAsArrayAccess(ValueNode, LocationIdentity)::: raw store node clone as array access:::return->object->accessKind->stateAfter->isAnyLocationForced->new->RawStoreNode
RawStoreNode#getState()::: raw store node get state:::return
StateSplitProxyNode#stateAfter()::: state split proxy node state after:::return
StateSplitProxyNode#setStateAfter(FrameState)::: state split proxy node set state after:::updateUsages
StateSplitProxyNode#hasSideEffect()::: state split proxy node has side effect:::return
StateSplitProxyNode#canonical(CanonicalizerTool)::: state split proxy node canonical:::if->object->isConstant->return->return
StoreHubNode#getValue()::: store hub node get value:::return
StoreHubNode#getObject()::: store hub node get object:::return
StoreHubNode#lower(LoweringTool)::: store hub node lower:::tool->getLowerer->lower
StoreHubNode#write(Object, Object)::: store hub node write:::
SwitchNode#assertProbabilities()::: switch node assert probabilities:::total->foreach->return
SwitchNode#getSuccessorCount()::: switch node get successor count:::return->successors->count
SwitchNode#probability(AbstractBeginNode)::: switch node probability:::sum->for->i->return
SwitchNode#setProbability(AbstractBeginNode, double)::: switch node set probability:::sum->otherSum->for->i->if->return->delta->for->i->return
SwitchNode#value()::: switch node value:::return
SwitchNode#isSorted()::: switch node is sorted:::
SwitchNode#keyCount():::The number of distinct keys in this switch.:::
SwitchNode#keyAt(int):::The key at the specified position, encoded in a Constant.:::
SwitchNode#structureEquals(SwitchNode)::: switch node structure equals:::return->Arrays->equals->equalKeys
SwitchNode#equalKeys(SwitchNode):::Returns true if the switch has the same keys in the same order as this switch.:::
SwitchNode#keySuccessorIndex(int):::Returns the index of the successor belonging to the key at the specified index.:::return
SwitchNode#keySuccessor(int):::Returns the successor for the key at the given index.:::return->successors->get
SwitchNode#keyProbability(int):::Returns the probability of the key at the given index.:::return
SwitchNode#defaultProbability():::Returns the probability of taking the default branch.:::return
SwitchNode#defaultSuccessorIndex():::Returns the index of the default (fall through) successor of this switch.:::return
SwitchNode#blockSuccessor(int)::: switch node block successor:::return->successors->get
SwitchNode#setBlockSuccessor(int, AbstractBeginNode)::: switch node set block successor:::successors->set
SwitchNode#blockSuccessorCount()::: switch node block successor count:::return->successors->count
SwitchNode#defaultSuccessor():::Gets the successor corresponding to the default (fall through) case.:::if->defaultSuccessorIndex->throw->new->GraalError->return->successors->defaultSuccessorIndex->get
SwitchNode#getPrimarySuccessor()::: switch node get primary successor:::return
SwitchNode#killOtherSuccessors(SimplifierTool, int):::Delete all other successors except for the one reached by survivingEdge.:::foreach->successors->if->blockSuccessor->tool->deleteBranch->tool->blockSuccessor->addToWorkList->graph->blockSuccessor->removeSplit
SwitchNode#getValueStampForSuccessor(AbstractBeginNode)::: switch node get value stamp for successor:::
SwitchNode#estimatedNodeCycles()::: switch node estimated node cycles:::if->keyCount->return->else->if->isSorted->return->else->return
SwitchNode#estimatedNodeSize()::: switch node estimated node size:::if->keyCount->return->else->if->isSorted->return->else->return
UnboxNode#getValue()::: unbox node get value:::return
UnboxNode#create(MetaAccessProvider, ConstantReflectionProvider, ValueNode, JavaKind)::: unbox node create:::synonym->findSynonym->if->return->return->new->UnboxNode
UnboxNode#getBoxingKind()::: unbox node get boxing kind:::return
UnboxNode#lower(LoweringTool)::: unbox node lower:::tool->getLowerer->lower
UnboxNode#virtualize(VirtualizerTool)::: unbox node virtualize:::alias->tool->getValue->getAlias->if->virtual->objectType->virtual->type->expectedType->tool->getMetaAccess->boxingKind->toBoxedJavaClass->lookupJavaType->if->objectType->equals->tool->tool->getEntry->replaceWithValue
UnboxNode#canonical(CanonicalizerTool, ValueNode)::: unbox node canonical:::if->tool->allUsagesAvailable->hasNoUsages->StampTool->isPointerNonNull->return->synonym->tool->getMetaAccess->tool->getConstantReflection->findSynonym->if->return->return
UnboxNode#findSynonym(MetaAccessProvider, ConstantReflectionProvider, ValueNode, JavaKind)::: unbox node find synonym:::if->forValue->isConstant->constant->forValue->asJavaConstant->unboxed->constantReflection->unboxPrimitive->if->unboxed->getJavaKind->return->ConstantNode->forConstant->else->if->box->if->box->getBoxingKind->return->box->getValue->return
UnsafeAccessNode#getLocationIdentity()::: unsafe access node get location identity:::return
UnsafeAccessNode#isAnyLocationForced()::: unsafe access node is any location forced:::return
UnsafeAccessNode#object()::: unsafe access node object:::return
UnsafeAccessNode#offset()::: unsafe access node offset:::return
UnsafeAccessNode#accessKind()::: unsafe access node access kind:::return
UnsafeAccessNode#canonical(CanonicalizerTool)::: unsafe access node canonical:::if->isAnyLocationForced->getLocationIdentity->isAny->if->offset->isConstant->constantOffset->offset->asJavaConstant->asLong->receiverType->StampTool->object->typeOrNull->if->field->receiverType->accessKind->findInstanceFieldWithOffset->if->field->getJavaKind->this->accessKind->return->graph->getAssumptions->cloneAsFieldAccess->receiverType->StampTool->object->typeOrNull->if->receiverType->isArray->identity->NamedLocationIdentity->receiverType->getComponentType->getJavaKind->getArrayLocation->return->offset->cloneAsArrayAccess->return
UnsafeAccessNode#cloneAsFieldAccess(Assumptions, ResolvedJavaField)::: unsafe access node clone as field access:::return->field->isVolatile->cloneAsFieldAccess
UnsafeAccessNode#cloneAsFieldAccess(Assumptions, ResolvedJavaField, boolean)::: unsafe access node clone as field access:::
UnsafeAccessNode#cloneAsArrayAccess(ValueNode, LocationIdentity)::: unsafe access node clone as array access:::
UnsafeCopyNode#intrinsify(GraphBuilderContext, ResolvedJavaMethod, ValueNode, ValueNode, ValueNode, ValueNode, JavaKind, LocationIdentity)::: unsafe copy node intrinsify:::value->b->new->RawLoadNode->add->b->new->RawStoreNode->add->return
UnsafeCopyNode#copy(Object, long, Object, long, JavaKind, LocationIdentity)::: unsafe copy node copy:::
UnsafeMemoryLoadNode#getAddress()::: unsafe memory load node get address:::return
UnsafeMemoryLoadNode#getKind()::: unsafe memory load node get kind:::return
UnsafeMemoryLoadNode#lower(LoweringTool)::: unsafe memory load node lower:::tool->getLowerer->lower
UnsafeMemoryLoadNode#getLocationIdentity()::: unsafe memory load node get location identity:::return
UnsafeMemoryStoreNode#getValue()::: unsafe memory store node get value:::return
UnsafeMemoryStoreNode#getAddress()::: unsafe memory store node get address:::return
UnsafeMemoryStoreNode#getKind()::: unsafe memory store node get kind:::return
UnsafeMemoryStoreNode#lower(LoweringTool)::: unsafe memory store node lower:::tool->getLowerer->lower
UnsafeMemoryStoreNode#getLocationIdentity()::: unsafe memory store node get location identity:::return
ValueAnchorNode#generate(NodeLIRBuilderTool)::: value anchor node generate:::
ValueAnchorNode#getAnchoredNode()::: value anchor node get anchored node:::return
ValueAnchorNode#simplify(SimplifierTool)::: value anchor node simplify:::while->next->nextAnchor->next->if->nextAnchor->replaceAtUsages->GraphUtil->removeFixedWithUnusedInputs->else->break->if->tool->allUsagesAvailable->hasNoUsages->next->currentNext->next->if->currentNext->getGuard->GraphUtil->removeFixedWithUnusedInputs->return->if->anchored->isConstant->removeAnchoredNode->if->hasNoUsages->GraphUtil->removeFixedWithUnusedInputs
ValueAnchorNode#virtualize(VirtualizerTool)::: value anchor node virtualize:::if->tool->delete->else->alias->tool->getAlias->if->tool->delete
ValueAnchorNode#removeAnchoredNode()::: value anchor node remove anchored node:::this->updateUsages
