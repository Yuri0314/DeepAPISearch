org.graalvm.compiler.phases.graph.FixedNodeRelativeFrequencyCache#applyAsDouble(FixedNode)->double::: Given a FixedNode this method finds the most immediate AbstractBeginNode preceding it that either: <ul> <li>has no predecessor (ie, the begin-node is a merge, in particular a loop-begin, or the start-node)</li> <li>has a control-split predecessor</li> </ul>    The thus found AbstractBeginNode is equi-probable with the FixedNode it was obtained from
org.graalvm.compiler.phases.graph.InferStamps#inferStamps(StructuredGraph)->void:::Infer the stamps for all Object nodes in the graph, to make the stamps as precise as possible
org.graalvm.compiler.phases.graph.MergeableState#clone()->T::: mergeable state clone
org.graalvm.compiler.phases.graph.MergeableState#merge(AbstractMergeNode, List)->boolean:::This method is called on merge on the state of the first branch
org.graalvm.compiler.phases.graph.MergeableState#loopBegin(LoopBeginNode)->void:::This method is called before a loop is entered (before the LoopBeginNode is visited).
org.graalvm.compiler.phases.graph.MergeableState#loopEnds(LoopBeginNode, List)->void:::This method is called after all LoopEndNodes belonging to a loop have been visited.
org.graalvm.compiler.phases.graph.MergeableState#afterSplit(AbstractBeginNode)->void:::This method is called before the successors of a ControlSplitNode are visited.
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#apply()->void::: post order node iterator apply
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#node(FixedNode)->void::: post order node iterator node
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#end(EndNode)->void::: post order node iterator end
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#merge(AbstractMergeNode)->void::: post order node iterator merge
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#loopBegin(LoopBeginNode)->void::: post order node iterator loop begin
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#loopEnd(LoopEndNode)->void::: post order node iterator loop end
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#controlSplit(ControlSplitNode)->Set::: post order node iterator control split
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#invoke(Invoke)->void::: post order node iterator invoke
org.graalvm.compiler.phases.graph.PostOrderNodeIterator#finished()->void::: post order node iterator finished
org.graalvm.compiler.phases.graph.ReentrantBlockIterator.BlockIteratorClosure#getInitialState()->StateT::: block iterator closure get initial state
org.graalvm.compiler.phases.graph.ReentrantBlockIterator.BlockIteratorClosure#processBlock(Block, StateT)->StateT::: block iterator closure process block
org.graalvm.compiler.phases.graph.ReentrantBlockIterator.BlockIteratorClosure#merge(Block, List)->StateT::: block iterator closure merge
org.graalvm.compiler.phases.graph.ReentrantBlockIterator.BlockIteratorClosure#cloneState(StateT)->StateT::: block iterator closure clone state
org.graalvm.compiler.phases.graph.ReentrantBlockIterator.BlockIteratorClosure#processLoop(Loop, StateT)->List::: block iterator closure process loop
org.graalvm.compiler.phases.graph.ReentrantBlockIterator#processLoop(BlockIteratorClosure, Loop, StateT)->LoopInfo::: reentrant block iterator process loop
org.graalvm.compiler.phases.graph.ReentrantBlockIterator#apply(BlockIteratorClosure, Block)->void::: reentrant block iterator apply
org.graalvm.compiler.phases.graph.ReentrantBlockIterator#apply(BlockIteratorClosure, Block, StateT, Predicate)->EconomicMap::: reentrant block iterator apply
org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure#processNode(FixedNode, StateT)->StateT::: node iterator closure process node
org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure#merge(AbstractMergeNode, List)->StateT::: node iterator closure merge
org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure#afterSplit(AbstractBeginNode, StateT)->StateT::: node iterator closure after split
org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure#processLoop(LoopBeginNode, StateT)->EconomicMap::: node iterator closure process loop
org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure#continueIteration(StateT)->boolean:::Determine whether iteration should continue in the current state.
org.graalvm.compiler.phases.graph.ReentrantNodeIterator#processLoop(NodeIteratorClosure, LoopBeginNode, StateT)->LoopInfo::: reentrant node iterator process loop
org.graalvm.compiler.phases.graph.ReentrantNodeIterator#apply(NodeIteratorClosure, FixedNode, StateT)->void::: reentrant node iterator apply
org.graalvm.compiler.phases.graph.ScheduledNodeIterator#processNodes(Block, ScheduleResult)->void::: scheduled node iterator process nodes
org.graalvm.compiler.phases.graph.ScheduledNodeIterator#insert(FixedNode, FixedWithNextNode)->void::: scheduled node iterator insert
org.graalvm.compiler.phases.graph.ScheduledNodeIterator#replaceCurrent(FixedWithNextNode)->void::: scheduled node iterator replace current
org.graalvm.compiler.phases.graph.ScheduledNodeIterator#processNode(Node)->void::: scheduled node iterator process node
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#apply()->void::: scoped post order node iterator apply
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#processScope()->void::: scoped post order node iterator process scope
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#queueLoopBeginSuccessors(LoopBeginNode)->void::: scoped post order node iterator queue loop begin successors
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#queueLoopExitSuccessors(LoopExitNode)->void::: scoped post order node iterator queue loop exit successors
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#getScopes(StructuredGraph)->Deque::: scoped post order node iterator get scopes
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#initializeScope()->void::: scoped post order node iterator initialize scope
org.graalvm.compiler.phases.graph.ScopedPostOrderNodeIterator#invoke(Invoke)->void::: scoped post order node iterator invoke
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#apply()->void:::Performs a single-pass iteration
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#node(FixedNode)->void::: single pass node iterator node
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#end(EndNode)->void::: single pass node iterator end
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#merge(AbstractMergeNode)->void::: single pass node iterator merge
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#loopBegin(LoopBeginNode)->void::: single pass node iterator loop begin
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#loopEnd(LoopEndNode)->void::: single pass node iterator loop end
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#controlSplit(ControlSplitNode)->void::: single pass node iterator control split
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#invoke(Invoke)->void::: single pass node iterator invoke
org.graalvm.compiler.phases.graph.SinglePassNodeIterator#finished()->void:::The lifecycle that single-pass node iterators go through is described in #apply()   When overriding this method don't forget to invoke this implementation, otherwise the assertions will be skipped
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#apply()->void::: stateless post order node iterator apply
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#node(FixedNode)->void::: stateless post order node iterator node
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#end(EndNode)->void::: stateless post order node iterator end
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#merge(AbstractMergeNode)->void::: stateless post order node iterator merge
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#loopBegin(LoopBeginNode)->void::: stateless post order node iterator loop begin
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#loopEnd(LoopEndNode)->void::: stateless post order node iterator loop end
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#controlSplit(ControlSplitNode)->void::: stateless post order node iterator control split
org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator#finished()->void::: stateless post order node iterator finished
