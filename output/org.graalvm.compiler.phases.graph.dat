FixedNodeRelativeFrequencyCache#applyAsDouble(FixedNode)::: Given a FixedNode this method finds the most immediate AbstractBeginNode preceding it that either: <ul> <li>has no predecessor (ie, the begin-node is a merge, in particular a loop-begin, or the start-node)</li> <li>has a control-split predecessor</li> </ul>    The thus found AbstractBeginNode is equi-probable with the FixedNode it was obtained from:::computeNodeRelativeFrequencyCounter->node->getDebug->increment->current->findBegin->if->return->cachedValue->cache->get->if->return->relativeFrequency->if->current->predecessor->if->handleMerge->else->else->split->current->predecessor->split->probability->applyAsDouble->multiplyRelativeFrequencies->cache->put->return
FixedNodeRelativeFrequencyCache#handleMerge(FixedNode, double)::: fixed node relative frequency cache handle merge:::result->currentMerge->currentForwardEnds->currentMerge->forwardEnds->foreach->applyAsDouble->if->loopFrequency->multiplyRelativeFrequencies->return
FixedNodeRelativeFrequencyCache#findBegin(FixedNode)::: fixed node relative frequency cache find begin:::current->while->predecessor->current->predecessor->if->if->break->else->if->predecessor->successors->count->break->else->if->break->return
InferStamps#inferStamps(StructuredGraph):::Infer the stamps for all Object nodes in the graph, to make the stamps as precise as possible:::foreach->graph->getNodes->if->node->if->node->stamp->node->node->stamp->empty->setStamp->stampChanged->z->do->foreach->graph->getNodes->if->node->if->node->stamp->node->inferStamp->while
InferStamps#checkNoEmptyStamp(StructuredGraph)::: infer stamps check no empty stamp:::foreach->graph->getNodes->if->node->return
MergeableState#clone()::: mergeable state clone:::
MergeableState#merge(AbstractMergeNode, List):::This method is called on merge on the state of the first branch:::
MergeableState#loopBegin(LoopBeginNode):::This method is called before a loop is entered (before the LoopBeginNode is visited).:::
MergeableState#loopEnds(LoopBeginNode, List):::This method is called after all LoopEndNodes belonging to a loop have been visited.:::
MergeableState#afterSplit(AbstractBeginNode):::This method is called before the successors of a ControlSplitNode are visited.:::
PostOrderNodeIterator#apply()::: post order node iterator apply:::current->do->if->invoke->queueSuccessors->nextQueuedNode->else->if->state->loopBegin->nodeStates->put->state->clone->loopBegin->next->else->if->loopEnd->finishLoopEnds->nextQueuedNode->else->if->merge->next->else->if->next->next->node->else->if->end->queueMerge->nextQueuedNode->else->if->node->nextQueuedNode->else->if->successors->controlSplit->queueSuccessors->nextQueuedNode->else->while->finished
PostOrderNodeIterator#queueSuccessors(FixedNode, Set)::: post order node iterator queue successors:::nodeStates->put->if->foreach->if->nodeStates->node->predecessor->put->nodeQueue->addFirst->else->foreach->x->successors->if->nodeQueue->addFirst
PostOrderNodeIterator#nextQueuedNode()::: post order node iterator next queued node:::maxIterations->nodeQueue->size->while->node->nodeQueue->removeFirst->if->merge->nodeStates->merge->forwardEndAt->get->clone->states->merge->forwardEndCount->new->ArrayList<>->for->i->merge->forwardEndCount->ready->state->merge->if->return->else->nodeQueue->addLast->else->nodeStates->node->predecessor->get->clone->state->afterSplit->return->return
PostOrderNodeIterator#finishLoopEnds(LoopEndNode)::: post order node iterator finish loop ends:::nodeStates->put->visitedEnds->mark->begin->end->loopBegin->endsVisited->foreach->begin->loopEnds->if->visitedEnds->isMarked->break->if->states->begin->loopEnds->count->new->ArrayList<>->foreach->begin->orderedLoopEnds->states->nodeStates->get->add->loopBeginState->nodeStates->get->if->loopBeginState->loopEnds
PostOrderNodeIterator#queueMerge(EndNode)::: post order node iterator queue merge:::nodeStates->put->visitedEnds->mark->merge->end->merge->endsVisited->for->i->merge->forwardEndCount->if->nodeQueue->add
PostOrderNodeIterator#node(FixedNode)::: post order node iterator node:::
PostOrderNodeIterator#end(EndNode)::: post order node iterator end:::node
PostOrderNodeIterator#merge(AbstractMergeNode)::: post order node iterator merge:::node
PostOrderNodeIterator#loopBegin(LoopBeginNode)::: post order node iterator loop begin:::node
PostOrderNodeIterator#loopEnd(LoopEndNode)::: post order node iterator loop end:::node
PostOrderNodeIterator#controlSplit(ControlSplitNode)::: post order node iterator control split:::node->return
PostOrderNodeIterator#invoke(Invoke)::: post order node iterator invoke:::invoke->asNode->node
PostOrderNodeIterator#finished()::: post order node iterator finished:::
ReentrantBlockIterator.BlockIteratorClosure#getInitialState()::: block iterator closure get initial state:::
ReentrantBlockIterator.BlockIteratorClosure#processBlock(Block, StateT)::: block iterator closure process block:::
ReentrantBlockIterator.BlockIteratorClosure#merge(Block, List)::: block iterator closure merge:::
ReentrantBlockIterator.BlockIteratorClosure#cloneState(StateT)::: block iterator closure clone state:::
ReentrantBlockIterator.BlockIteratorClosure#processLoop(Loop, StateT)::: block iterator closure process loop:::
ReentrantBlockIterator#processLoop(BlockIteratorClosure, Loop, StateT)::: reentrant block iterator process loop:::blockEndStates->loop->getHeader->block->getLoop->block->isLoopHeader->apply->predecessors->loop->getHeader->getPredecessors->info->loop->getLoopExits->size->new->LoopInfo<>->for->i->foreach->loop->getLoopExits->exitState->blockEndStates->loopExit->getBeginNode->get->closure->cloneState->add->return
ReentrantBlockIterator#apply(BlockIteratorClosure, Block)::: reentrant block iterator apply:::closure->getInitialState->apply
ReentrantBlockIterator#apply(BlockIteratorClosure, Block, StateT, Predicate)::: reentrant block iterator apply:::blockQueue->new->ArrayDeque<>->states->EconomicMap->create->state->current->graph->start->getBeginNode->graph->compilationAlarm->CompilationAlarm->current->while->if->compilationAlarm->hasExpired->period->graph->getOptions->getValue->if->throw->new->PermanentBailoutException->else->throw->new->RetryableBailoutException->next->if->stopAtBlock->test->states->current->getBeginNode->put->else->closure->processBlock->successors->current->getSuccessors->if->else->if->successor->if->successor->isLoopHeader->if->current->isLoopEnd->states->current->getEndNode->put->else->recurseIntoLoop->else->if->current->getEndNode->end->current->getEndNode->merge->end->merge->if->allEndsVisited->mergedStates->mergeStates->closure->merge->else->states->put->else->else->processMultipleSuccessors->if->else->if->blockQueue->isEmpty->return->else->blockQueue->removeFirst->states->current->getBeginNode->removeKey
ReentrantBlockIterator#allEndsVisited(EconomicMap, Block, AbstractMergeNode)::: reentrant block iterator all ends visited:::foreach->merge->forwardEnds->if->current->getEndNode->states->containsKey->return->return
ReentrantBlockIterator#processMultipleSuccessors(BlockIteratorClosure, Deque, EconomicMap, StateT, Block[])::: reentrant block iterator process multiple successors:::for->i->return
ReentrantBlockIterator#mergeStates(EconomicMap, StateT, Block, Block, AbstractMergeNode)::: reentrant block iterator merge states:::mergedStates->merge->forwardEndCount->new->ArrayList<>->foreach->successor->getPredecessors->endState->states->predecessor->getEndNode->removeKey->mergedStates->add->return
ReentrantBlockIterator#recurseIntoLoop(BlockIteratorClosure, Deque, EconomicMap, StateT, Block)::: reentrant block iterator recurse into loop:::loop->successor->getLoop->loopBegin->loop->getHeader->getBeginNode->exitStates->closure->processLoop->i->foreach->loop->getLoopExits->states->exit->getBeginNode->exitStates->get->put->blockQueue->addFirst
ReentrantNodeIterator.NodeIteratorClosure#processNode(FixedNode, StateT)::: node iterator closure process node:::
ReentrantNodeIterator.NodeIteratorClosure#merge(AbstractMergeNode, List)::: node iterator closure merge:::
ReentrantNodeIterator.NodeIteratorClosure#afterSplit(AbstractBeginNode, StateT)::: node iterator closure after split:::
ReentrantNodeIterator.NodeIteratorClosure#processLoop(LoopBeginNode, StateT)::: node iterator closure process loop:::
ReentrantNodeIterator.NodeIteratorClosure#continueIteration(StateT):::Determine whether iteration should continue in the current state.:::return
ReentrantNodeIterator#processLoop(NodeIteratorClosure, LoopBeginNode, StateT)::: reentrant node iterator process loop:::blockEndStates->apply->info->loop->loopEnds->count->loop->loopExits->count->new->LoopInfo<>->foreach->loop->loopEnds->if->blockEndStates->containsKey->blockEndStates->get->put->foreach->loop->loopExits->if->blockEndStates->containsKey->blockEndStates->get->put->return
ReentrantNodeIterator#apply(NodeIteratorClosure, FixedNode, StateT)::: reentrant node iterator apply:::apply
ReentrantNodeIterator#apply(NodeIteratorClosure, FixedNode, StateT, LoopBeginNode)::: reentrant node iterator apply:::nodeQueue->new->ArrayDeque<>->blockEndStates->EconomicMap->create->state->current->do->while->if->loopBegin->blockEndStates->put->else->next->next->closure->processNode->closure->continueIteration->if->closure->processNode->if->closure->continueIteration->successors->current->successors->iterator->if->successors->hasNext->if->blockEndStates->put->else->if->merge->merge->if->loopExitState->closure->processLoop->entry->loopExitState->getEntries->while->entry->advance->blockEndStates->entry->getKey->entry->getValue->put->nodeQueue->entry->getKey->add->else->endsVisited->foreach->merge->forwardEnds->if->blockEndStates->containsKey->break->if->states->merge->forwardEndCount->new->ArrayList<>->for->i->merge->forwardEndCount->closure->merge->closure->continueIteration->continue->else->blockEndStates->put->else->firstSuccessor->successors->next->if->successors->hasNext->continue->else->do->successor->successors->next->successorState->closure->afterSplit->if->closure->continueIteration->blockEndStates->put->nodeQueue->add->while->successors->hasNext->closure->afterSplit->closure->continueIteration->continue->if->nodeQueue->isEmpty->return->else->nodeQueue->removeFirst->blockEndStates->removeKey->while
ScheduledNodeIterator#processNodes(Block, ScheduleResult)::: scheduled node iterator process nodes:::block->getBeginNode->schedule->nodesFor->listIterator->while->iterator->hasNext->node->iterator->next->if->node->isAlive->continue->if->reconnect->setNext->if->processNode->if->reconnect->block->getFirstSuccessor->getBeginNode->setNext
ScheduledNodeIterator#insert(FixedNode, FixedWithNextNode)::: scheduled node iterator insert:::setNext
ScheduledNodeIterator#replaceCurrent(FixedWithNextNode)::: scheduled node iterator replace current:::current->iterator->previous->iterator->next->current->replaceAndDelete->insert->iterator->set
ScheduledNodeIterator#processNode(Node)::: scheduled node iterator process node:::
ScopedPostOrderNodeIterator#apply()::: scoped post order node iterator apply:::while->scopes->isEmpty->queuedNodes->clearAll->scopes->pop->initializeScope->processScope
ScopedPostOrderNodeIterator#processScope()::: scoped post order node iterator process scope:::current->queue->while->nextQueuedNode->if->invoke->queueSuccessors->else->if->queueLoopBeginSuccessors->else->if->queueLoopExitSuccessors->else->if->else->if->queueSuccessors->else->if->queueSuccessors->else->if->queueMerge->else->if->else->if->queueSuccessors->else
ScopedPostOrderNodeIterator#queueLoopBeginSuccessors(LoopBeginNode)::: scoped post order node iterator queue loop begin successors:::if->node->next->queue->else->if->foreach->node->loopExits->if->loopExits->contains->queue->else->node->loopExits->queue
ScopedPostOrderNodeIterator#queueLoopExitSuccessors(LoopExitNode)::: scoped post order node iterator queue loop exit successors:::if->loopExits->contains->queueSuccessors
ScopedPostOrderNodeIterator#getScopes(StructuredGraph)::: scoped post order node iterator get scopes:::result->new->ArrayDeque<>->result->graph->start->push->foreach->graph->getNodes->result->push->return
ScopedPostOrderNodeIterator#queueSuccessors(FixedNode)::: scoped post order node iterator queue successors:::x->successors->queue
ScopedPostOrderNodeIterator#queue(NodeIterable)::: scoped post order node iterator queue:::foreach->queue
ScopedPostOrderNodeIterator#queue(Node)::: scoped post order node iterator queue:::if->queuedNodes->isMarked->queuedNodes->mark->nodeQueue->addFirst
ScopedPostOrderNodeIterator#nextQueuedNode()::: scoped post order node iterator next queued node:::if->nodeQueue->isEmpty->return->result->nodeQueue->removeFirst->return
ScopedPostOrderNodeIterator#queueMerge(AbstractEndNode)::: scoped post order node iterator queue merge:::merge->end->merge->if->queuedNodes->isMarked->visitedAllEnds->queue
ScopedPostOrderNodeIterator#visitedAllEnds(AbstractMergeNode)::: scoped post order node iterator visited all ends:::for->i->merge->forwardEndCount->return
ScopedPostOrderNodeIterator#initializeScope()::: scoped post order node iterator initialize scope:::
ScopedPostOrderNodeIterator#invoke(Invoke)::: scoped post order node iterator invoke:::
SinglePassNodeIterator.PathStart#repOK()::: path start rep k:::if->return->if->return->return
SinglePassNodeIterator#apply():::Performs a single-pass iteration:::current->do->if->invoke->queueSuccessors->nextQueuedNode->else->if->state->loopBegin->keepForLater->state->clone->loopBegin->next->else->if->loopEnd->finishLoopEnds->nextQueuedNode->else->if->merge->next->else->if->next->next->node->else->if->end->queueMerge->nextQueuedNode->else->if->node->nextQueuedNode->else->if->controlSplit->queueSuccessors->nextQueuedNode->else->while->finished
SinglePassNodeIterator#queueSuccessors(FixedNode):::Two methods enqueue items in #nodeQueue:::startState->curState->foreach->x->successors->if->if->startState->clone->begin->nodeQueue->new->PathStart<>->addFirst
SinglePassNodeIterator#nextQueuedNode():::This method is invoked upon not having a (single) next FixedNode to visit:::if->nodeQueue->isEmpty->return->elem->nodeQueue->removeFirst->if->merge->merge->forwardEndAt->pruneEntry->states->merge->forwardEndCount->new->ArrayList<>->for->i->merge->forwardEndCount->ready->state->merge->return->else->begin->state->afterSplit->return
SinglePassNodeIterator#finishLoopEnds(LoopEndNode):::Once all loop-end-nodes for a given loop-node have been visited:::visitedEnds->mark->keepForLater->begin->end->loopBegin->endsVisited->foreach->begin->loopEnds->if->visitedEnds->isMarked->break->if->states->begin->loopEnds->count->new->ArrayList<>->foreach->begin->orderedLoopEnds->leState->pruneEntry->states->add->loopBeginState->pruneEntry->loopBeginState->loopEnds
SinglePassNodeIterator#queueMerge(EndNode):::Once all end-nodes for a given merge-node have been visited, that merge-node is added to the #nodeQueue   #nextQueuedNode() is in charge of pruning entries (held by #nodeStates) for the forward-ends inserted by this method:::visitedEnds->mark->keepForLater->merge->end->merge->endsVisited->for->i->merge->forwardEndCount->if->nodeQueue->new->PathStart<>->add
SinglePassNodeIterator#node(FixedNode)::: single pass node iterator node:::
SinglePassNodeIterator#end(EndNode)::: single pass node iterator end:::node
SinglePassNodeIterator#merge(AbstractMergeNode)::: single pass node iterator merge:::node
SinglePassNodeIterator#loopBegin(LoopBeginNode)::: single pass node iterator loop begin:::node
SinglePassNodeIterator#loopEnd(LoopEndNode)::: single pass node iterator loop end:::node
SinglePassNodeIterator#controlSplit(ControlSplitNode)::: single pass node iterator control split:::node
SinglePassNodeIterator#invoke(Invoke)::: single pass node iterator invoke:::invoke->asNode->node
SinglePassNodeIterator#finished():::The lifecycle that single-pass node iterators go through is described in #apply()   When overriding this method don't forget to invoke this implementation, otherwise the assertions will be skipped:::
SinglePassNodeIterator#keepForLater(FixedNode, T)::: single pass node iterator keep for later:::nodeStates->put
SinglePassNodeIterator#pruneEntry(FixedNode)::: single pass node iterator prune entry:::result->nodeStates->removeKey->return
StatelessPostOrderNodeIterator#apply()::: stateless post order node iterator apply:::current->do->if->loopBegin->next->else->if->loopEnd->visitedEnds->mark->nodeQueue->pollFirst->else->if->merge->next->else->if->node->next->else->if->end->queueMerge->nodeQueue->pollFirst->else->if->node->nodeQueue->pollFirst->else->if->controlSplit->foreach->current->successors->nodeQueue->addFirst->nodeQueue->pollFirst->else->while->finished
StatelessPostOrderNodeIterator#queueMerge(EndNode)::: stateless post order node iterator queue merge:::visitedEnds->mark->merge->end->merge->endsVisited->for->i->merge->forwardEndCount->if->nodeQueue->add
StatelessPostOrderNodeIterator#node(FixedNode)::: stateless post order node iterator node:::
StatelessPostOrderNodeIterator#end(EndNode)::: stateless post order node iterator end:::node
StatelessPostOrderNodeIterator#merge(AbstractMergeNode)::: stateless post order node iterator merge:::node
StatelessPostOrderNodeIterator#loopBegin(LoopBeginNode)::: stateless post order node iterator loop begin:::node
StatelessPostOrderNodeIterator#loopEnd(LoopEndNode)::: stateless post order node iterator loop end:::node
StatelessPostOrderNodeIterator#controlSplit(ControlSplitNode)::: stateless post order node iterator control split:::node
StatelessPostOrderNodeIterator#finished()::: stateless post order node iterator finished:::
