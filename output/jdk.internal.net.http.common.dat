BufferSupplier#get():::Returns a buffer to read encrypted data off the socket.:::
BufferSupplier#recycle(ByteBuffer):::Returns a buffer to the pool.:::
Demand#increase(long):::Increases this demand by the specified positive value.:::if->throw->String->valueOf->new->IllegalArgumentException->prev->val->getAndAccumulate->return
Demand#increaseIfFulfilled():::Increases this demand by 1 but only if it is fulfilled.:::return->val->compareAndSet
Demand#decreaseAndGet(long):::Tries to decrease this demand by the specified positive value:::if->throw->String->valueOf->new->IllegalArgumentException->p->d->do->val->get->Math->min->while->val->compareAndSet->return
Demand#tryDecrement():::Tries to decrease this demand by 1.:::return->decreaseAndGet
Demand#reset():::Resets this object to its initial state.:::val->set
Demand#get():::Returns the current value of this demand.:::return->val->get
FlowTube.TubeSubscriber#dropSubscription():::Called when the flow is connected again, and the subscription is handed over to a new subscriber:::
FlowTube#connectFlows(TubePublisher, TubeSubscriber):::Connects the bidirectional flows to a write Publisher and a read Subscriber:::this->subscribe->writePublisher->subscribe
FlowTube#isFinished():::Returns true if this flow was completed, either exceptionally or normally (EOF reached).:::
FlowTube#asTubeSubscriber(Flow.Subscriber>):::Returns s if s is a TubeSubscriber, otherwise wraps it in a TubeSubscriber:::if->return->return->new->AbstractTubeSubscriber.TubeSubscriberWrapper
FlowTube#asTubePublisher(Flow.Publisher>):::Returns s if s is a TubePublisher, otherwise wraps it in a TubePublisher.:::if->return->return->new->AbstractTubePublisher.TubePublisherWrapper
Logger#on():::Tells whether this logger is on.:::return->isLoggable
Logger#log(String):::Logs a message.:::log
Logger#log(Supplier):::Logs a lazily supplied message.:::log
Logger#log(Object):::Logs a message produced from the given object.:::log
Logger#log(String, Throwable):::Logs a message associated with a given throwable.:::this->log
Logger#log(Supplier, Throwable):::Logs a lazily supplied message associated with a given throwable.:::log
Logger#log(String, Object...):::Logs a message with an optional list of parameters.:::log
OperationTrackers#getTracker(HttpClient):::Returns a tracker to track pending operations started on an HttpClient instance:::if->return->getOperationsTracker->else->return
SequentialScheduler.DeferredCompleter#complete():::Completes the task:::
SequentialScheduler.RestartableTask#run(DeferredCompleter):::The body of the task.:::
SequentialScheduler.CompleteRestartableTask#run():::The body of the task.:::
SequentialScheduler#runOrSchedule():::Runs or schedules the task to be run.:::runOrSchedule
SequentialScheduler#runOrSchedule(Executor):::Executes or schedules the task to be executed in the provided executor:::runOrSchedule
SequentialScheduler#isStopped():::Tells whether, or not, this scheduler has been permanently stopped:::return->state->get
SequentialScheduler#stop():::Stops this scheduler:::state->set
SequentialScheduler#synchronizedScheduler(Runnable):::Returns a new SequentialScheduler that executes the provided mainLoop from within a SynchronizedRestartableTask.:::return->new->SynchronizedRestartableTask->new->SequentialScheduler
SSLFlowDelegate#closeNotifyReceived():::Returns true if the SSLFlowDelegate has detected a TLS close_notify from the server.:::return
SSLFlowDelegate#connect(Subscriber>, Subscriber>):::Connects the read sink (downReader) to the SSLFlowDelegate Reader, and the write sink (downWriter) to the SSLFlowDelegate Writer:::subscribe->subscribe
SSLFlowDelegate#alpn():::Returns a CompletableFuture<String> which completes after the initial handshake completes, and which contains the negotiated alpn.:::return
SSLFlowDelegate.Reader#incoming(List, boolean):::entry point for buffers delivered from upstream Subscriber:::if->debugr->on->debugr->Utils->remaining->log->addToReadBuf->scheduler->runOrSchedule
SSLFlowDelegate#upstreamReader():::Returns the upstream Flow.Subscriber of the reading (incoming) side:::return
SSLFlowDelegate#upstreamWriter():::Returns the upstream Flow.Subscriber of the writing (outgoing) side:::return
SSLTube#isFinished():::Tells whether, or not, this FlowTube has finished receiving data.:::return
SubscriberWrapper#incoming(List, boolean):::Delivers data to be processed by this wrapper:::
SubscriberWrapper#upstreamWindowUpdate(long, long):::This method is called to determine the window size to use at any time:::if->return->if->return->else->return
SubscriberWrapper#onSubscribe():::Override this if anything needs to be done after the upstream subscriber has subscribed:::
SubscriberWrapper#enterScheduling():::Override this if anything needs to be done before checking for error and processing the input queue.:::return
SubscriberWrapper#outgoing(ByteBuffer, boolean):::Delivers buffers of data downstream:::Objects->requireNonNull->List->of->outgoing
SubscriberWrapper#closing():::Sometime it might be necessary to complete the downstream subscriber before the upstream completes:::return
SubscriberWrapper#completion():::Returns a CompletableFuture which completes when this wrapper completes:::return
SubscriberWrapper#addData(ByteBuffer):::Adds the given data to the input queue.:::if->throw->new->IllegalStateException->List->of->incomingCaller
SubscriptionBase#tryDecrement():::Returns true if the window was reduced by 1:::return->demand->tryDecrement
Utils#wrapWithExtraDetail(Throwable, Supplier):::Adds a more specific exception detail message, based on the given exception type and the message supplier:::if->return->msg->messageSupplier->get->if->return->if->ioe->t->getCause->new->IOException->new->ConnectionExpiredException->else->ioe->new->IOException->return
Utils#permissionForProxy(InetSocketAddress):::Returns the security permissions required to connect to the proxy, or null if none is required or applicable.:::if->return->sb->new->StringBuilder->sb->append->proxyAddress->getHostString->append->append->proxyAddress->getPort->append->urlString->sb->toString->return->new->URLPermission
Utils#permissionForServer(URI, String, Stream):::Returns the security permission required for the given details.:::urlString->new->StringBuilder->uri->getScheme->append->append->uri->getAuthority->append->uri->getPath->append->toString->actionStringBuilder->new->StringBuilder->collected->headers->joining->collect->if->collected->isEmpty->actionStringBuilder->append->append->return->actionStringBuilder->toString->new->URLPermission
Utils#getServerName(InetSocketAddress):::Analyse the given address and determine if it is literal or not, returning the address in String form.:::host->addr->getHostString->literal->IPAddressUtil->textToNumericFormatV4->if->IPAddressUtil->textToNumericFormatV6->return->new->ServerName->else->return->new->ServerName
Utils#flipToMark(ByteBuffer, int):::Set limit to position, and position to mark.:::buffer->buffer->position->limit->buffer->position
Utils#copy(ByteBuffer, ByteBuffer):::Copies as much of src to dst as possible:::srcLen->src->remaining->dstLen->dst->remaining->if->diff->limit->src->limit->src->limit->dst->put->src->limit->else->dst->put->return->src->remaining
Utils#accumulateBuffers(List, List):::Adds the data from buffersToAdd to currentList:::accumulatedBytes->foreach->remaining->bufferToAdd->remaining->if->continue->listSize->currentList->size->if->currentList->add->continue->lastBuffer->currentList->get->freeSpace->lastBuffer->capacity->lastBuffer->limit->if->position->lastBuffer->position->limit->lastBuffer->limit->lastBuffer->position->lastBuffer->limit->lastBuffer->put->lastBuffer->position->else->currentList->add->return
Utils#sliceWithLimitedCapacity(ByteBuffer, int):::Returns a slice of size amount from the given buffer:::index->buffer->position->limit->buffer->limit->if->buffer->limit->else->buffer->buffer->capacity->limit->newb->buffer->slice->buffer->position->buffer->limit->newb->limit->return
Utils#charsetFrom(HttpHeaders):::Get the Charset from the Content-encoding header:::type->headers->firstValue->orElse->i->type->indexOf->if->type->substring->try->parser->new->HeaderParser->value->parser->findValue->if->return->return->Charset->forName->catch->Log->logTrace->return->finally
Utils#getDebugLogger(Supplier):::Get a logger for debug HTTP traces:::return->getDebugLogger
Utils#getDebugLogger(Supplier, Level):::Get a logger for debug HTTP traces.The logger should only be used with levels whose severity is <= DEBUG:::return->DebugLogger->createHttpLogger
Utils#getDebugLogger(Supplier, boolean):::Get a logger for debug HTTP traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getDebugLogger
Utils#getHpackLogger(Supplier, Level):::Get a logger for debug HPACK traces.The logger should only be used with levels whose severity is <= DEBUG:::outLevel->return->DebugLogger->createHpackLogger
Utils#getHpackLogger(Supplier, boolean):::Get a logger for debug HPACK traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getHpackLogger
Utils#getWebSocketLogger(Supplier, Level):::Get a logger for debug WebSocket traces.The logger should only be used with levels whose severity is <= DEBUG:::outLevel->return->DebugLogger->createWebSocketLogger
Utils#getWebSocketLogger(Supplier, boolean):::Get a logger for debug WebSocket traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getWebSocketLogger
Utils#immutableSession(SSLSession):::SSLSessions returned to user are wrapped in an immutable object:::if->return->new->ImmutableExtendedSSLSession->else->return->new->ImmutableSSLSession
Utils#isHostnameVerificationDisabled():::Enabled by default:::return
Utils#pow2Size(int):::Returns the smallest (closest to zero) positive number m (which is also a power of 2) such that n <= m:::if->throw->new->IllegalArgumentException->else->if->return->else->if->return->else->return->Integer->numberOfLeadingZeros
