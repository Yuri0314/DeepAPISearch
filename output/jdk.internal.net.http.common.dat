BufferSupplier#get():::Returns a buffer to read encrypted data off the socket.:::
BufferSupplier#recycle(ByteBuffer):::Returns a buffer to the pool.:::
DebugLogger#getName()::: debug logger get name:::return->logger->getName
DebugLogger#isEnabled(Level)::: debug logger is enabled:::return->levelEnabledFor
DebugLogger#on()::: debug logger on:::return
DebugLogger#levelEnabledFor(Level, Level, Level, System.Logger)::: debug logger level enabled for:::if->return->severity->level->getSeverity->return->errLevel->getSeverity->outLevel->getSeverity->logger->isLoggable
DebugLogger#isLoggable(Level)::: debug logger is loggable:::if->return->if->return->return->isEnabled
DebugLogger#log(Level, ResourceBundle, String, Object...)::: debug logger log:::if->return->if->return->severity->level->getSeverity->if->errLevel->getSeverity->print->if->outLevel->getSeverity->print->if->logger->isLoggable->logger->new->StringBuilder->getFormat->toString->log
DebugLogger#log(Level, ResourceBundle, String, Throwable)::: debug logger log:::if->return->if->return->if->errLevel->getSeverity->level->getSeverity->print->if->outLevel->getSeverity->level->getSeverity->print->if->logger->isLoggable->logger->new->StringBuilder->getFormat->toString->log
DebugLogger#print(PrintStream, Level, String, Object[], Throwable)::: debug logger print:::sb->new->StringBuilder->sb->level->name->append->append->append->format->if->sb->append->t->toString->append->out->sb->toString->println->if->t->printStackTrace
DebugLogger#decorate(StringBuilder, String)::: debug logger decorate:::tag->dbgTag->get->res->elapsed->System->nanoTime->millis->secs->sb->append->Thread->currentThread->getName->append->append->append->append->if->sb->append->append->if->if->sb->append->sb->append->append->sb->append->append->if->sb->append->append->sb->append->return
DebugLogger#getFormat(StringBuilder, String, Object[])::: debug logger get format:::if->return->decorate->else->if->format->contains->format->contains->return->decorate->else->if->format->contains->format->contains->try->return->String->format->decorate->catch->return->decorate->finally->else->return->decorate
DebugLogger#format(StringBuilder, String, Object[])::: debug logger format:::if->return->decorate->else->if->format->contains->format->contains->return->format->decorate->else->if->format->contains->format->contains->try->return->String->format->decorate->catch->return->decorate->finally->else->return->decorate
DebugLogger#createHttpLogger(Supplier, Level, Level)::: debug logger create http logger:::if->levelEnabledFor->return->new->DebugLogger->else->return
DebugLogger#createWebSocketLogger(Supplier, Level, Level)::: debug logger create web socket logger:::if->levelEnabledFor->return->new->DebugLogger->else->return
DebugLogger#createHpackLogger(Supplier, Level, Level)::: debug logger create hpack logger:::if->levelEnabledFor->return->new->DebugLogger->else->return
Demand#increase(long):::Increases this demand by the specified positive value.:::if->throw->String->valueOf->new->IllegalArgumentException->prev->val->getAndAccumulate->return
Demand#increaseIfFulfilled():::Increases this demand by 1 but only if it is fulfilled.:::return->val->compareAndSet
Demand#decreaseAndGet(long):::Tries to decrease this demand by the specified positive value:::if->throw->String->valueOf->new->IllegalArgumentException->p->d->do->val->get->Math->min->while->val->compareAndSet->return
Demand#tryDecrement():::Tries to decrease this demand by 1.:::return->decreaseAndGet
Demand#isFulfilled()::: demand is fulfilled:::return->val->get
Demand#reset():::Resets this object to its initial state.:::val->set
Demand#get():::Returns the current value of this demand.:::return->val->get
Demand#toString()::: demand to string:::return->String->val->get->valueOf
FlowTube.TubeSubscriber#dropSubscription():::Called when the flow is connected again, and the subscription is handed over to a new subscriber:::
FlowTube.TubeSubscriber#supportsRecycling()::: tube subscriber supports recycling:::return
FlowTube#connectFlows(TubePublisher, TubeSubscriber):::Connects the bidirectional flows to a write Publisher and a read Subscriber:::this->subscribe->writePublisher->subscribe
FlowTube#isFinished():::Returns true if this flow was completed, either exceptionally or normally (EOF reached).:::
FlowTube#asTubeSubscriber(Flow.Subscriber>):::Returns s if s is a TubeSubscriber, otherwise wraps it in a TubeSubscriber:::if->return->return->new->AbstractTubeSubscriber.TubeSubscriberWrapper
FlowTube#asTubePublisher(Flow.Publisher>):::Returns s if s is a TubePublisher, otherwise wraps it in a TubePublisher.:::if->return->return->new->AbstractTubePublisher.TubePublisherWrapper
FlowTube.AbstractTubePublisher.TubePublisherWrapper#subscribe(Flow.Subscriber>)::: tube publisher wrapper subscribe:::delegate->subscribe
FlowTube.AbstractTubeSubscriber.TubeSubscriberWrapper#dropSubscription()::: tube subscriber wrapper drop subscription:::
FlowTube.AbstractTubeSubscriber.TubeSubscriberWrapper#onSubscribe(Flow.Subscription)::: tube subscriber wrapper on subscribe:::delegate->onSubscribe
FlowTube.AbstractTubeSubscriber.TubeSubscriberWrapper#onNext(List)::: tube subscriber wrapper on next:::delegate->onNext
FlowTube.AbstractTubeSubscriber.TubeSubscriberWrapper#onError(Throwable)::: tube subscriber wrapper on error:::delegate->onError
FlowTube.AbstractTubeSubscriber.TubeSubscriberWrapper#onComplete()::: tube subscriber wrapper on complete:::delegate->onComplete
HttpHeadersBuilder#structuralCopy()::: http headers builder structural copy:::builder->new->HttpHeadersBuilder->foreach->headersMap->entrySet->valuesCopy->entry->getValue->new->ArrayList<>->entry->getKey->put->return
HttpHeadersBuilder#addHeader(String, String)::: http headers builder add header:::headersMap->new->ArrayList<>->computeIfAbsent->add
HttpHeadersBuilder#setHeader(String, String)::: http headers builder set header:::values->new->ArrayList<>->values->add->headersMap->put
HttpHeadersBuilder#clear()::: http headers builder clear:::headersMap->clear
HttpHeadersBuilder#map()::: http headers builder map:::return
HttpHeadersBuilder#build()::: http headers builder build:::return->HttpHeaders->of
HttpHeadersBuilder#toString()::: http headers builder to string:::sb->new->StringBuilder->sb->super->toString->append->append->sb->map->append->sb->append->return->sb->toString
ImmutableExtendedSSLSession#getId()::: immutable extended session get id:::return->delegate->getId
ImmutableExtendedSSLSession#getSessionContext()::: immutable extended session get session context:::return->delegate->getSessionContext
ImmutableExtendedSSLSession#getCreationTime()::: immutable extended session get creation time:::return->delegate->getCreationTime
ImmutableExtendedSSLSession#getLastAccessedTime()::: immutable extended session get last accessed time:::return->delegate->getLastAccessedTime
ImmutableExtendedSSLSession#invalidate()::: immutable extended session invalidate:::throw->new->UnsupportedOperationException
ImmutableExtendedSSLSession#isValid()::: immutable extended session is valid:::return->delegate->isValid
ImmutableExtendedSSLSession#putValue(String, Object)::: immutable extended session put value:::throw->new->UnsupportedOperationException
ImmutableExtendedSSLSession#getValue(String)::: immutable extended session get value:::return->delegate->getValue
ImmutableExtendedSSLSession#removeValue(String)::: immutable extended session remove value:::throw->new->UnsupportedOperationException
ImmutableExtendedSSLSession#getValueNames()::: immutable extended session get value names:::return->delegate->getValueNames
ImmutableExtendedSSLSession#getPeerCertificates()::: immutable extended session get peer certificates:::return->delegate->getPeerCertificates
ImmutableExtendedSSLSession#getLocalCertificates()::: immutable extended session get local certificates:::return->delegate->getLocalCertificates
ImmutableExtendedSSLSession#getPeerCertificateChain()::: immutable extended session get peer certificate chain:::return->delegate->getPeerCertificateChain
ImmutableExtendedSSLSession#getPeerPrincipal()::: immutable extended session get peer principal:::return->delegate->getPeerPrincipal
ImmutableExtendedSSLSession#getLocalPrincipal()::: immutable extended session get local principal:::return->delegate->getLocalPrincipal
ImmutableExtendedSSLSession#getCipherSuite()::: immutable extended session get cipher suite:::return->delegate->getCipherSuite
ImmutableExtendedSSLSession#getProtocol()::: immutable extended session get protocol:::return->delegate->getProtocol
ImmutableExtendedSSLSession#getPeerHost()::: immutable extended session get peer host:::return->delegate->getPeerHost
ImmutableExtendedSSLSession#getPeerPort()::: immutable extended session get peer port:::return->delegate->getPeerPort
ImmutableExtendedSSLSession#getPacketBufferSize()::: immutable extended session get packet buffer size:::return->delegate->getPacketBufferSize
ImmutableExtendedSSLSession#getApplicationBufferSize()::: immutable extended session get application buffer size:::return->delegate->getApplicationBufferSize
ImmutableExtendedSSLSession#getLocalSupportedSignatureAlgorithms()::: immutable extended session get local supported signature algorithms:::return->delegate->getLocalSupportedSignatureAlgorithms
ImmutableExtendedSSLSession#getPeerSupportedSignatureAlgorithms()::: immutable extended session get peer supported signature algorithms:::return->delegate->getPeerSupportedSignatureAlgorithms
ImmutableExtendedSSLSession#getRequestedServerNames()::: immutable extended session get requested server names:::return->delegate->getRequestedServerNames
ImmutableExtendedSSLSession#getStatusResponses()::: immutable extended session get status responses:::return->delegate->getStatusResponses
ImmutableSSLSession#getId()::: immutable session get id:::return->delegate->getId
ImmutableSSLSession#getSessionContext()::: immutable session get session context:::return->delegate->getSessionContext
ImmutableSSLSession#getCreationTime()::: immutable session get creation time:::return->delegate->getCreationTime
ImmutableSSLSession#getLastAccessedTime()::: immutable session get last accessed time:::return->delegate->getLastAccessedTime
ImmutableSSLSession#invalidate()::: immutable session invalidate:::throw->new->UnsupportedOperationException
ImmutableSSLSession#isValid()::: immutable session is valid:::return->delegate->isValid
ImmutableSSLSession#putValue(String, Object)::: immutable session put value:::throw->new->UnsupportedOperationException
ImmutableSSLSession#getValue(String)::: immutable session get value:::return->delegate->getValue
ImmutableSSLSession#removeValue(String)::: immutable session remove value:::throw->new->UnsupportedOperationException
ImmutableSSLSession#getValueNames()::: immutable session get value names:::return->delegate->getValueNames
ImmutableSSLSession#getPeerCertificates()::: immutable session get peer certificates:::return->delegate->getPeerCertificates
ImmutableSSLSession#getLocalCertificates()::: immutable session get local certificates:::return->delegate->getLocalCertificates
ImmutableSSLSession#getPeerCertificateChain()::: immutable session get peer certificate chain:::return->delegate->getPeerCertificateChain
ImmutableSSLSession#getPeerPrincipal()::: immutable session get peer principal:::return->delegate->getPeerPrincipal
ImmutableSSLSession#getLocalPrincipal()::: immutable session get local principal:::return->delegate->getLocalPrincipal
ImmutableSSLSession#getCipherSuite()::: immutable session get cipher suite:::return->delegate->getCipherSuite
ImmutableSSLSession#getProtocol()::: immutable session get protocol:::return->delegate->getProtocol
ImmutableSSLSession#getPeerHost()::: immutable session get peer host:::return->delegate->getPeerHost
ImmutableSSLSession#getPeerPort()::: immutable session get peer port:::return->delegate->getPeerPort
ImmutableSSLSession#getPacketBufferSize()::: immutable session get packet buffer size:::return->delegate->getPacketBufferSize
ImmutableSSLSession#getApplicationBufferSize()::: immutable session get application buffer size:::return->delegate->getApplicationBufferSize
Log#errors()::: log errors:::return
Log#requests()::: log requests:::return
Log#headers()::: log headers:::return
Log#trace()::: log trace:::return
Log#ssl()::: log ssl:::return
Log#frames()::: log frames:::return
Log#channel()::: log channel:::return
Log#logError(String, Object...)::: log log error:::if->errors->logger->log
Log#logError(Throwable)::: log log error:::if->errors->s->Utils->stackTrace->logger->log
Log#logSSL(String, Object...)::: log log l:::if->ssl->logger->log
Log#logSSL(Supplier)::: log log l:::if->ssl->logger->msgSupplier->get->log
Log#logChannel(String, Object...)::: log log channel:::if->channel->logger->log
Log#logChannel(Supplier)::: log log channel:::if->channel->logger->msgSupplier->get->log
Log#logTrace(String, Object...)::: log log trace:::if->trace->format->logger->log
Log#logRequest(String, Object...)::: log log request:::if->requests->logger->log
Log#logResponse(Supplier)::: log log response:::if->requests->logger->supplier->get->log
Log#logHeaders(String, Object...)::: log log headers:::if->headers->logger->log
Log#loggingFrame(Class)::: log logging frame:::if->return->if->return->else->if->return->else->return
Log#logFrames(Http2Frame, String)::: log log frames:::if->frames->f->getClass->loggingFrame->logger->f->toString->log
Log#logParams(SSLParameters)::: log log params:::if->Log->ssl->return->if->Log->logSSL->return->sb->new->StringBuilder->params->new->ArrayList<>->if->p->getCipherSuites->foreach->p->getCipherSuites->sb->append->params->size->append->append->params->add->foreach->p->getApplicationProtocols->sb->append->params->size->append->append->params->add->if->p->getProtocols->foreach->p->getProtocols->sb->append->params->size->append->append->params->add->if->p->getEndpointIdentificationAlgorithm->sb->append->params->size->append->append->params->p->getEndpointIdentificationAlgorithm->add->if->p->getServerNames->foreach->p->getServerNames->sb->append->params->size->append->append->params->sname->toString->add->sb->append->Log->sb->toString->params->toArray->logSSL
Log#dumpHeaders(StringBuilder, String, HttpHeaders)::: log dump headers:::if->h->headers->map->entries->h->entrySet->sep->foreach->key->entry->getKey->values->entry->getValue->if->values->isEmpty->sb->append->sb->append->append->append->continue->foreach->sb->append->sb->append->append->append->sb->append->append->sb->append
Logger#on():::Tells whether this logger is on.:::return->isLoggable
Logger#log(String):::Logs a message.:::log
Logger#log(Supplier):::Logs a lazily supplied message.:::log
Logger#log(Object):::Logs a message produced from the given object.:::log
Logger#log(String, Throwable):::Logs a message associated with a given throwable.:::this->log
Logger#log(Supplier, Throwable):::Logs a lazily supplied message associated with a given throwable.:::log
Logger#log(String, Object...):::Logs a message with an optional list of parameters.:::log
MinimalFuture.ExceptionalSupplier#get()::: exceptional supplier get:::
MinimalFuture#completedFuture(U)::: minimal future completed future:::f->new->MinimalFuture<>->f->complete->return
MinimalFuture#failedFuture(Throwable)::: minimal future failed future:::requireNonNull->f->new->MinimalFuture<>->f->completeExceptionally->return
MinimalFuture#supply(ExceptionalSupplier)::: minimal future supply:::cf->new->MinimalFuture<>->try->value->supplier->get->cf->complete->catch->cf->completeExceptionally->finally->return
MinimalFuture#newIncompleteFuture()::: minimal future new incomplete future:::return->new->MinimalFuture<>
MinimalFuture#obtrudeValue(T)::: minimal future obtrude value:::throw->new->UnsupportedOperationException
MinimalFuture#obtrudeException(Throwable)::: minimal future obtrude exception:::throw->new->UnsupportedOperationException
MinimalFuture#toString()::: minimal future to string:::return->super->toString
MinimalFuture#of(CompletionStage)::: minimal future of:::cf->new->MinimalFuture<>->stage->complete->whenComplete->return
MinimalFuture#complete(CompletableFuture, U, Throwable)::: minimal future complete:::if->cf->complete->else->cf->completeExceptionally
OperationTrackers.Tracker#getOutstandingOperations()::: tracker get outstanding operations:::
OperationTrackers.Tracker#getOutstandingHttpOperations()::: tracker get outstanding http operations:::
OperationTrackers.Tracker#getOutstandingHttp2Streams()::: tracker get outstanding http2 streams:::
OperationTrackers.Tracker#getOutstandingWebSocketOperations()::: tracker get outstanding web socket operations:::
OperationTrackers.Tracker#isFacadeReferenced()::: tracker is facade referenced:::
OperationTrackers.Tracker#getName()::: tracker get name:::
OperationTrackers.Trackable#getOperationsTracker()::: trackable get operations tracker:::
OperationTrackers#getTracker(HttpClient):::Returns a tracker to track pending operations started on an HttpClient instance:::if->return->getOperationsTracker->else->return
Pair#pair(T, U)::: pair pair:::return->new->Pair<>
Pair#toString()::: pair to string:::return
SequentialScheduler.DeferredCompleter#complete():::Completes the task:::
SequentialScheduler.RestartableTask#run(DeferredCompleter):::The body of the task.:::
SequentialScheduler.CompleteRestartableTask#run(DeferredCompleter)::: complete restartable task run:::try->run->catch->finally->taskCompleter->complete
SequentialScheduler.CompleteRestartableTask#run():::The body of the task.:::
SequentialScheduler.SynchronizedRestartableTask#run()::: synchronized restartable task run:::synchronized->mainLoop->run
SequentialScheduler.SchedulableTask#run()::: schedulable task run:::restartableTask->run
SequentialScheduler#runOrSchedule():::Runs or schedules the task to be run.:::runOrSchedule
SequentialScheduler#runOrSchedule(Executor):::Executes or schedules the task to be executed in the provided executor:::runOrSchedule
SequentialScheduler#runOrSchedule(SchedulableTask, Executor)::: sequential scheduler run or schedule:::while->s->state->get->if->if->state->compareAndSet->break->else->if->if->state->compareAndSet->return->else->if->return->else->throw->String->valueOf->new->InternalError->if->task->run->else->executor->execute
SequentialScheduler.TryEndDeferredCompleter#complete()::: try end deferred completer complete:::while->s->while->state->get->if->state->compareAndSet->return->while->if->throw->String->valueOf->new->InternalError->if->if->state->compareAndSet->return->else->if->if->state->compareAndSet->break->else->if->return->else->if->throw->new->IllegalStateException->else->throw->String->valueOf->new->InternalError->state->get->restartableTask->run
SequentialScheduler#isStopped():::Tells whether, or not, this scheduler has been permanently stopped:::return->state->get
SequentialScheduler#stop():::Stops this scheduler:::state->set
SequentialScheduler#synchronizedScheduler(Runnable):::Returns a new SequentialScheduler that executes the provided mainLoop from within a SynchronizedRestartableTask.:::return->new->SynchronizedRestartableTask->new->SequentialScheduler
SSLFlowDelegate#closeNotifyReceived():::Returns true if the SSLFlowDelegate has detected a TLS close_notify from the server.:::return
SSLFlowDelegate#connect(Subscriber>, Subscriber>):::Connects the read sink (downReader) to the SSLFlowDelegate Reader, and the write sink (downWriter) to the SSLFlowDelegate Writer:::subscribe->subscribe
SSLFlowDelegate#alpn():::Returns a CompletableFuture<String> which completes after the initial handshake completes, and which contains the negotiated alpn.:::return
SSLFlowDelegate#setALPN()::: flow delegate set n:::if->alpnCF->isDone->return->alpn->engine->getApplicationProtocol->if->debug->on->debug->log->alpnCF->complete
SSLFlowDelegate#monitor()::: flow delegate monitor:::sb->new->StringBuilder->sb->append->append->sb->append->dbgString->append->sb->states->append->sb->engine->getHandshakeStatus->toString->append->if->sb->append->foreach->sb->append->append->sb->append->sb->append->reader->toString->append->sb->append->sb->append->writer->toString->append->sb->append->return->sb->toString
SSLFlowDelegate#enterReadScheduling()::: flow delegate enter read scheduling:::return
SSLFlowDelegate.Reader.ReaderDownstreamPusher#run()::: reader downstream pusher run:::processData
SSLFlowDelegate.Reader#supportsRecycling()::: reader supports recycling:::return
SSLFlowDelegate.Reader#enterScheduling()::: reader enter scheduling:::return->enterReadScheduling
SSLFlowDelegate.Reader#dbgString()::: reader dbg string:::return
SSLFlowDelegate.Reader#incoming(List, boolean):::entry point for buffers delivered from upstream Subscriber:::if->debugr->on->debugr->Utils->remaining->log->addToReadBuf->scheduler->runOrSchedule
SSLFlowDelegate.Reader#toString()::: reader to string:::return->super->toString->readBuf->toString->count->toString->scheduler->isStopped->handshakeState->get->engine->getHandshakeStatus
SSLFlowDelegate.Reader#reallocReadBuf()::: reader realloc read buf:::sz->readBuf->capacity->newb->ByteBuffer->allocate->readBuf->flip->Utils->copy
SSLFlowDelegate.Reader#upstreamWindowUpdate(long, long)::: reader upstream window update:::if->readBuf->remaining->if->debugr->on->debugr->readBuf->remaining->log->return->else->return->super->upstreamWindowUpdate
SSLFlowDelegate.Reader#addToReadBuf(List, boolean)::: reader add to read buf:::synchronized->foreach->readBuf->compact->while->readBuf->remaining->buf->remaining->reallocReadBuf->readBuf->put->readBuf->flip->if->recycler->accept->if
SSLFlowDelegate.Reader#schedule()::: reader schedule:::scheduler->runOrSchedule
SSLFlowDelegate.Reader#stop()::: reader stop:::if->debugr->on->debugr->log->scheduler->stop
SSLFlowDelegate.Reader#processData()::: reader process data:::try->if->debugr->on->debugr->readBuf->remaining->states->engine->getHandshakeStatus->log->len->complete->while->readBuf->remaining->handshaking->try->result->synchronized->if->debugr->on->debugr->readBuf->remaining->log->unwrapBuffer->readBuf->remaining->if->debugr->on->debugr->log->debugr->result->bytesConsumed->log->if->result->bytesProduced->if->debugr->on->debugr->result->bytesProduced->log->count->result->bytesProduced->addAndGet->outgoing->if->result->status->if->debugr->on->debugr->log->synchronized->if->readBuf->remaining->continue->else->if->if->debug->on->debugr->log->throw->new->IOException->requestMore->return->if->result->status->if->debugr->on->debugr->log->outgoing->setALPN->return->if->result->handshaking->if->debugr->on->debugr->log->if->doHandshake->continue->else->break->else->if->trySetALPN->resumeActivity->catch->errorCommon->handleError->return->finally->if->return->if->synchronized->readBuf->hasRemaining->if->if->debugr->on->debugr->log->setALPN->outgoing->catch->errorCommon->handleError->finally
SSLFlowDelegate.Reader#unwrapBuffer(ByteBuffer)::: reader unwrap buffer:::dst->getAppBuffer->len->src->remaining->while->sslResult->engine->unwrap->switch->sslResult->getStatus->appSize->engine->getSession->getApplicationBufferSize->b->ByteBuffer->dst->position->allocate->dst->flip->b->put->break->return->new->EngineResult->doClosure->return->new->EngineResult->size->dst->position->if->debug->on->debugr->dst->capacity->src->remaining->log->if->dst->flip->return->new->EngineResult
SSLFlowDelegate.Monitorable#getInfo()::: monitorable get info:::
SSLFlowDelegate.Monitor.FinalMonitorable#getInfo()::: final monitorable get info:::finalList->remove->return
SSLFlowDelegate.Monitor#addTarget(Monitorable)::: monitor add target:::list->new->WeakReference<>->add
SSLFlowDelegate.Monitor#removeTarget(Monitorable)::: monitor remove target:::synchronized->it->list->iterator->while->it->hasNext->m->it->next->get->if->it->remove->if->it->remove->break->m->new->FinalMonitorable->addTarget->Reference->reachabilityFence
SSLFlowDelegate.Monitor#add(Monitorable)::: monitor add:::themon->addTarget
SSLFlowDelegate.Monitor#remove(Monitorable)::: monitor remove:::themon->removeTarget
SSLFlowDelegate.Monitor#run()::: monitor run:::println->try->while->Thread->sleep->synchronized->expired->while->queue->poll->list->remove->foreach->o->ref->get->if->continue->if->ref->enqueue->o->getInfo->println->println->println->catch->println->finally
SSLFlowDelegate.Writer.WriterDownstreamPusher#run()::: writer downstream pusher run:::processData
SSLFlowDelegate.Writer#incoming(List, boolean)::: writer incoming:::if->if->debugw->on->debugw->log->writeList->add->else->writeList->addAll->if->debugw->on->debugw->buffers->size->Utils->remaining->log->scheduler->runOrSchedule
SSLFlowDelegate.Writer#dbgString()::: writer dbg string:::return
SSLFlowDelegate.Writer#onSubscribe()::: writer on subscribe:::if->debugw->on->debugw->log->addData
SSLFlowDelegate.Writer#schedule()::: writer schedule:::scheduler->runOrSchedule
SSLFlowDelegate.Writer#stop()::: writer stop:::if->debugw->on->debugw->log->scheduler->stop
SSLFlowDelegate.Writer#closing()::: writer closing:::return->closeNotifyReceived
SSLFlowDelegate.Writer#isCompleting()::: writer is completing:::return
SSLFlowDelegate.Writer#upstreamWindowUpdate(long, long)::: writer upstream window update:::if->writeList->size->return->else->return->super->upstreamWindowUpdate
SSLFlowDelegate.Writer#hsTriggered()::: writer hs triggered:::synchronized->foreach->if->return->return
SSLFlowDelegate.Writer#triggerWrite()::: writer trigger write:::synchronized->if->writeList->isEmpty->writeList->add->scheduler->runOrSchedule
SSLFlowDelegate.Writer#processData()::: writer process data:::completing->isCompleting->try->if->debugw->on->debugw->Utils->remaining->hsTriggered->needWrap->log->while->Utils->remaining->hsTriggered->needWrap->outbufs->writeList->toArray->result->wrapBuffers->if->debugw->on->debugw->log->if->result->status->if->upstreamSubscription->cancel->setALPN->if->result->bytesProduced->return->if->writeList->add->handshaking->if->result->handshaking->if->debugw->on->debugw->log->doHandshake->else->if->trySetALPN->resumeActivity->cleanList->sendResultBytes->if->if->needWrap->continue->else->return->if->Utils->remaining->if->writeList->clear->outgoing->return->if->writeList->isEmpty->needWrap->writer->addData->catch->errorCommon->handleError->finally
SSLFlowDelegate.Writer#wrapBuffers(ByteBuffer[])::: writer wrap buffers:::len->Utils->remaining->if->debugw->on->debugw->log->dst->if->getNetBuffer->while->sslResult->engine->wrap->if->debugw->on->debugw->log->switch->sslResult->getStatus->if->debugw->on->debugw->log->netSize->engine->getSession->getPacketBufferSize->b->ByteBuffer->dst->position->allocate->dst->flip->b->put->break->if->debugw->on->debugw->log->dest->if->dst->position->else->if->dst->position->dst->capacity->dst->flip->Utils->copyAligned->dst->clear->else->dst->flip->if->debugw->on->debugw->dest->remaining->dest->capacity->Utils->remaining->log->return->new->EngineResult->if->debug->on->debug->log->return->new->EngineResult->if->debugw->on->debugw->sslResult->getStatus->log
SSLFlowDelegate.Writer#needWrap()::: writer need wrap:::return->engine->getHandshakeStatus
SSLFlowDelegate.Writer#sendResultBytes(EngineResult)::: writer send result bytes:::if->result->bytesProduced->if->debugw->on->debugw->result->bytesProduced->log->outgoing
SSLFlowDelegate.Writer#toString()::: writer to string:::return->super->toString->Integer->writeList->size->toString->scheduler->isStopped
SSLFlowDelegate#handleError(Throwable)::: flow delegate handle error:::if->debug->on->debug->log->readerCF->completeExceptionally->writerCF->completeExceptionally->alpnCF->completeExceptionally->reader->stop->writer->stop
SSLFlowDelegate#normalStop()::: flow delegate normal stop:::if->return->reader->stop->writer->stop->if->alpnCF->isDone->alpn->new->SSLHandshakeException->alpnCF->completeExceptionally->if->Monitor->remove
SSLFlowDelegate#stopOnError(Throwable)::: flow delegate stop on error:::if->alpnCF->isDone->alpnCF->completeExceptionally->normalStop->return
SSLFlowDelegate#cleanList(List)::: flow delegate clean list:::synchronized->iter->l->iterator->while->iter->hasNext->b->iter->next->if->b->hasRemaining->iter->remove
SSLFlowDelegate#states(AtomicInteger)::: flow delegate states:::s->state->get->sb->new->StringBuilder->x->switch->sb->append->break->sb->append->break->throw->new->InternalError->if->sb->append->if->sb->append->return->sb->toString
SSLFlowDelegate#resumeActivity()::: flow delegate resume activity:::reader->schedule->writer->schedule
SSLFlowDelegate#doHandshake(EngineResult, int)::: flow delegate do handshake:::handshakeState->getAndAccumulate->if->debug->on->stateList->r->handshakeStatus->toString->add->stateList->Integer->toString->add->switch->r->handshakeStatus->s->handshakeState->accumulateAndGet->if->return->if->debug->on->debug->log->tasks->obtainTasks->executeTasks->return->if->writer->triggerWrite->return->break->if->reader->schedule->return->break->throw->r->handshakeStatus->new->InternalError->return
SSLFlowDelegate#obtainTasks()::: flow delegate obtain tasks:::l->new->ArrayList<>->r->while->engine->getDelegatedTask->l->add->return
SSLFlowDelegate#executeTasks(List)::: flow delegate execute tasks:::exec->try->nextTasks->if->debug->on->debug->Integer->nextTasks->size->toString->log->do->nextTasks->Runnable->run->forEach->if->engine->getHandshakeStatus->obtainTasks->else->s->handshakeState->accumulateAndGet->if->if->debug->on->debug->log->obtainTasks->continue->break->while->if->debug->on->debug->log->hs->engine->getHandshakeStatus->if->trySetALPN->resumeActivity->catch->handleError->finally->execute
SSLFlowDelegate#trySetALPN()::: flow delegate try set n:::if->handshakeState->getAndSet->engine->getSession->getApplicationBufferSize->engine->getSession->getPacketBufferSize->setALPN->return->return
SSLFlowDelegate#doClosure(EngineResult)::: flow delegate do closure:::if->debug->on->debug->engine->getHandshakeStatus->engine->isOutboundDone->engine->isInboundDone->log->if->engine->getHandshakeStatus->if->engine->isInboundDone->engine->isOutboundDone->if->debug->on->debug->log->if->isStopped->doHandshake->else->synchronized->return
SSLFlowDelegate#upstreamReader():::Returns the upstream Flow.Subscriber of the reading (incoming) side:::return
SSLFlowDelegate#upstreamWriter():::Returns the upstream Flow.Subscriber of the writing (outgoing) side:::return
SSLFlowDelegate#resumeReader()::: flow delegate resume reader:::return->reader->signalScheduling
SSLFlowDelegate#resetReaderDemand()::: flow delegate reset reader demand:::reader->resetDownstreamDemand
SSLFlowDelegate.EngineResult#handshaking()::: engine result handshaking:::s->result->getHandshakeStatus->return->result->getStatus
SSLFlowDelegate.EngineResult#needUnwrap()::: engine result need unwrap:::s->result->getHandshakeStatus->return
SSLFlowDelegate.EngineResult#bytesConsumed()::: engine result bytes consumed:::return->result->bytesConsumed
SSLFlowDelegate.EngineResult#bytesProduced()::: engine result bytes produced:::return->result->bytesProduced
SSLFlowDelegate.EngineResult#handshakeStatus()::: engine result handshake status:::return->result->getHandshakeStatus
SSLFlowDelegate.EngineResult#status()::: engine result status:::return->result->getStatus
SSLFlowDelegate#getNetBuffer()::: flow delegate get net buffer:::netSize->if->engine->getSession->getPacketBufferSize->return->ByteBuffer->allocate
SSLFlowDelegate#getAppBuffer()::: flow delegate get app buffer:::appSize->if->engine->getSession->getApplicationBufferSize->size->if->else->if->return->ByteBuffer->allocate
SSLFlowDelegate#dbgString()::: flow delegate dbg string:::return
SSLTube.SSLTubeFlowDelegate#enterReadScheduling()::: tube flow delegate enter read scheduling:::readSubscriber->processPendingSubscriber->return
SSLTube.SSLTubeFlowDelegate#connect(Flow.Subscriber>, Flow.Subscriber>)::: tube flow delegate connect:::reader->subscribe->tube->FlowTube->asTubePublisher->FlowTube->upstreamReader->asTubeSubscriber->connectFlows->upstreamWriter->onSubscribe
SSLTube#getALPN()::: tube get n:::return->sslDelegate->alpn
SSLTube#subscribe(Flow.Subscriber>)::: tube subscribe:::readSubscriber->dropSubscription->readSubscriber->setDelegate->s->onSubscribe
SSLTube#isFinished():::Tells whether, or not, this FlowTube has finished receiving data.:::return
SSLTube.DelegateWrapper#dropSubscription()::: delegate wrapper drop subscription:::if->delegate->dropSubscription
SSLTube.DelegateWrapper#onNext(List)::: delegate wrapper on next:::delegate->onNext
SSLTube.DelegateWrapper#onSubscribe(Flow.Subscription)::: delegate wrapper on subscribe:::delegate->onSubscribe->onSubscribe
SSLTube.DelegateWrapper#onSubscribe(Consumer, Flow.Subscription)::: delegate wrapper on subscribe:::method->accept->x->finished->synchronized->if->if->debug->on->debug->log->delegate->onError->else->if->if->debug->on->debug->log->delegate->onComplete
SSLTube.DelegateWrapper#onError(Throwable)::: delegate wrapper on error:::if->if->debug->on->debug->log->return->subscribed->synchronized->if->return->if->delegate->onError->else->if->debug->on->debug->log
SSLTube.DelegateWrapper#onComplete()::: delegate wrapper on complete:::if->return->subscribed->synchronized->if->return->if->if->debug->on->debug->log->delegate->onComplete->else->if->debug->on->debug->log
SSLTube.DelegateWrapper#toString()::: delegate wrapper to string:::return
SSLTube.SSLSubscriberWrapper#toString()::: subscriber wrapper to string:::sub->pend->pendingDelegate->get->sslFD->return->sslFD->alpn->errorRef->get
SSLTube.SSLSubscriberWrapper#setDelegate(Flow.Subscriber>)::: subscriber wrapper set delegate:::if->debug->on->debug->log->delegateWrapper->new->DelegateWrapper->previous->subscription->handleNow->synchronized->pendingDelegate->getAndSet->get->if->previous->dropSubscription->if->if->debug->on->debug->log->return->if->sslDelegate->resumeReader->processPendingSubscriber
SSLTube.SSLSubscriberWrapper#processPendingSubscriber()::: subscriber wrapper process pending subscriber:::subscription->delegateWrapper->previous->synchronized->pendingDelegate->get->if->return->if->if->debug->on->debug->log->return->pendingDelegate->getAndSet->if->return->if->previous->dropSubscription->onNewSubscription
SSLTube.SSLSubscriberWrapper#dropSubscription()::: subscriber wrapper drop subscription:::subscriberImpl->if->subscriberImpl->dropSubscription
SSLTube.SSLSubscriberWrapper#onSubscribe(Flow.Subscription)::: subscriber wrapper on subscribe:::if->debug->on->debug->log->onSubscribeImpl
SSLTube.SSLSubscriberWrapper#onSubscribeImpl(Flow.Subscription)::: subscriber wrapper on subscribe impl:::subscriberImpl->pending->synchronized->pendingDelegate->get->if->if->debug->on->debug->log->return->if->if->debug->on->debug->log->onNewSubscription->else->if->debug->on->debug->log->processPendingSubscriber
SSLTube.SSLSubscriberWrapper#complete(DelegateWrapper, Throwable)::: subscriber wrapper complete:::try->if->subscriberImpl->onComplete->else->subscriberImpl->onError->if->debug->on->debug->log->catch->finally->writeSubscription->cancel
SSLTube.SSLSubscriberWrapper#onNewSubscription(DelegateWrapper, Flow.Subscription)::: subscriber wrapper on new subscription:::failed->completed->sslDelegate->resetReaderDemand->subscriberImpl->onSubscribe->synchronized->get->if->if->debug->on->debug->log->complete->else->if->if->debug->on->debug->log->complete
SSLTube.SSLSubscriberWrapper#onNext(List)::: subscriber wrapper on next:::subscribed->onNext
SSLTube.SSLSubscriberWrapper#onErrorImpl(Throwable)::: subscriber wrapper on error impl:::errorRef->compareAndSet->failed->errorRef->get->if->debug->on->debug->log->subscriberImpl->synchronized->if->complete->else->if->debug->on->debug->log->processPendingSubscriber
SSLTube.SSLSubscriberWrapper#onError(Throwable)::: subscriber wrapper on error:::onErrorImpl
SSLTube.SSLSubscriberWrapper#handshaking()::: subscriber wrapper handshaking:::hs->engine->getHandshakeStatus->return
SSLTube.SSLSubscriberWrapper#handshakeFailed()::: subscriber wrapper handshake failed:::if->handshaking->sslDelegate->closeNotifyReceived->return->if->engine->getSession->getCipherSuite->equals->return->return
SSLTube.SSLSubscriberWrapper#onComplete()::: subscriber wrapper on complete:::subscriberImpl->synchronized->handshakeFailed->handshakeFailed->if->if->debug->on->debug->engine->getHandshakeStatus->engine->isInboundDone->engine->isOutboundDone->log->new->SSLHandshakeException->onErrorImpl->else->if->complete->else->processPendingSubscriber
SSLTube#connectFlows(TubePublisher, TubeSubscriber)::: tube connect flows:::if->debug->on->debug->log->readSubscriber->setDelegate->writePub->subscribe
SSLTube.SSLSubscriptionWrapper#setSubscription(Flow.Subscription)::: subscription wrapper set subscription:::demand->writeDemand->get->if->debug->on->debug->log->if->delegate->cancel->else->if->sub->request
SSLTube.SSLSubscriptionWrapper#request(long)::: subscription wrapper request:::writeDemand->increase->if->debug->on->debug->log->sub->if->sub->request
SSLTube.SSLSubscriptionWrapper#cancel()::: subscription wrapper cancel:::if->delegate->cancel
SSLTube#onSubscribe(Flow.Subscription)::: tube on subscribe:::Objects->requireNonNull->x->if->x->cancel->writeSubscription->setSubscription
SSLTube#onNext(List)::: tube on next:::Objects->requireNonNull->decremented->writeDemand->tryDecrement->if->debug->on->debug->item->size->log->sslDelegate->upstreamWriter->onNext
SSLTube#onError(Throwable)::: tube on error:::Objects->requireNonNull->sslDelegate->upstreamWriter->onError
SSLTube#onComplete()::: tube on complete:::sslDelegate->upstreamWriter->onComplete
SSLTube#toString()::: tube to string:::return->dbgString
SSLTube#dbgString()::: tube dbg string:::return
SubscriberWrapper#subscribe(Subscriber>)::: subscriber wrapper subscribe:::Objects->requireNonNull
SubscriberWrapper#incoming(List, boolean):::Delivers data to be processed by this wrapper:::
SubscriberWrapper#upstreamWindowUpdate(long, long):::This method is called to determine the window size to use at any time:::if->return->if->return->else->return
SubscriberWrapper#onSubscribe():::Override this if anything needs to be done after the upstream subscriber has subscribed:::
SubscriberWrapper#enterScheduling():::Override this if anything needs to be done before checking for error and processing the input queue.:::return
SubscriberWrapper#signalScheduling()::: subscriber wrapper signal scheduling:::if->pushScheduler->isStopped->return->pushScheduler->runOrSchedule->return
SubscriberWrapper#outgoing(ByteBuffer, boolean):::Delivers buffers of data downstream:::Objects->requireNonNull->List->of->outgoing
SubscriberWrapper#closing():::Sometime it might be necessary to complete the downstream subscriber before the upstream completes:::return
SubscriberWrapper#outgoing(List, boolean)::: subscriber wrapper outgoing:::Objects->requireNonNull->if->closing->closing->if->debug->on->debug->log->if->throw->new->IllegalStateException->else->if->debug->on->debug->Utils->remaining->log->outputQ->add->if->debug->on->debug->pushScheduler->isStopped->log->pushScheduler->runOrSchedule
SubscriberWrapper#completion():::Returns a CompletableFuture which completes when this wrapper completes:::return
SubscriberWrapper.DownstreamPusher#run()::: downstream pusher run:::try->run1->catch->if->debug->on->debug->log->errorCommon->finally
SubscriberWrapper.DownstreamPusher#run1()::: downstream pusher run1:::if->if->debug->on->debug->log->return->switch->enterScheduling->break->pushScheduler->runOrSchedule->return->return->errorRef->new->InternalError->compareAndSet->break->error->errorRef->get->if->outputQ->isEmpty->synchronized->if->return->if->debug->on->debug->log->pushScheduler->stop->outputQ->clear->downstreamSubscriber->onError->cf->completeExceptionally->return->if->outputQ->isEmpty->if->debug->on->debug->log->else->if->debug->on->debug->log->datasent->while->outputQ->isEmpty->downstreamSubscription->tryDecrement->b->outputQ->poll->if->debug->on->debug->Utils->remaining->log->downstreamSubscriber->onNext->if->upstreamWindowUpdate->checkCompletion
SubscriberWrapper#upstreamWindowUpdate()::: subscriber wrapper upstream window update:::downstreamQueueSize->outputQ->size->upstreamWindowSize->upstreamWindow->get->n->upstreamWindowUpdate->if->debug->on->debug->log->if->upstreamRequest
SubscriberWrapper#onSubscribe(Flow.Subscription)::: subscriber wrapper on subscribe:::if->throw->new->IllegalStateException->upstreamWindowUpdate->upstreamRequest->if->debug->on->debug->log->downstreamSubscriber->onSubscribe->onSubscribe
SubscriberWrapper#onNext(List)::: subscriber wrapper on next:::if->debug->on->debug->log->prev->upstreamWindow->getAndDecrement->if->throw->new->IllegalStateException->incomingCaller->upstreamWindowUpdate
SubscriberWrapper#upstreamRequest(long)::: subscriber wrapper upstream request:::if->debug->on->debug->log->upstreamWindow->getAndAdd->upstreamSubscription->request
SubscriberWrapper#requestMore()::: subscriber wrapper request more:::if->upstreamWindow->get->upstreamRequest
SubscriberWrapper#upstreamWindow()::: subscriber wrapper upstream window:::return->upstreamWindow->get
SubscriberWrapper#onError(Throwable)::: subscriber wrapper on error:::if->debug->on->debug->log->Objects->requireNonNull->errorCommon
SubscriberWrapper#errorCommon(Throwable)::: subscriber wrapper error common:::if->errorRef->compareAndSet->if->debug->on->debug->log->pushScheduler->runOrSchedule->return->return
SubscriberWrapper#close()::: subscriber wrapper close:::new->RuntimeException->errorCommon
SubscriberWrapper#close(Throwable)::: subscriber wrapper close:::errorCommon
SubscriberWrapper#incomingCaller(List, boolean)::: subscriber wrapper incoming caller:::try->incoming->catch->errorCommon->finally
SubscriberWrapper#onComplete()::: subscriber wrapper on complete:::if->debug->on->debug->toString->log->incomingCaller->pushScheduler->runOrSchedule
SubscriberWrapper#addData(ByteBuffer):::Adds the given data to the input queue.:::if->throw->new->IllegalStateException->List->of->incomingCaller
SubscriberWrapper#checkCompletion()::: subscriber wrapper check completion:::if->return->if->outputQ->isEmpty->return->if->errorRef->get->pushScheduler->runOrSchedule->return->if->if->debug->on->debug->log->downstreamSubscriber->onComplete->cf->complete
SubscriberWrapper#downstreamCompletion()::: subscriber wrapper downstream completion:::upstreamSubscription->cancel->cf->complete
SubscriberWrapper#resetDownstreamDemand()::: subscriber wrapper reset downstream demand:::reset
SubscriberWrapper#toString()::: subscriber wrapper to string:::sb->new->StringBuilder->sb->append->append->Boolean->toString->append->append->upstreamWindow->toString->append->append->Boolean->toString->append->append->Boolean->toString->append->append->Integer->outputQ->size->toString->append->append->cf->toString->append->append->append->append->append->return->sb->toString
SubscriberWrapper#dbgString()::: subscriber wrapper dbg string:::return
SubscriptionBase#request(long)::: subscription base request:::try->if->demand->increase->scheduler->runOrSchedule->catch->if->if->cancelled->getAndSet->return->onError->accept->else->throw->finally
SubscriptionBase#toString()::: subscription base to string:::return->demand->get->cancelled->toString
SubscriptionBase#tryDecrement():::Returns true if the window was reduced by 1:::return->demand->tryDecrement
SubscriptionBase#window()::: subscription base window:::return->demand->get
SubscriptionBase#cancel()::: subscription base cancel:::if->cancelled->getAndSet->return->scheduler->stop->cancelAction->run
Utils#hostnameVerificationDisabledValue()::: utils hostname verification disabled value:::prop->getProperty->if->return->return->prop->isEmpty->Boolean->parseBoolean
Utils#wrapForDebug(Logger, String, CompletableFuture)::: utils wrap for debug:::if->logger->on->return->cf->logger->log->return->handle->Function->identity->thenCompose->else->return
Utils#isAllowedForProxy(String, String, Set, Predicate)::: utils is allowed for proxy:::if->allowedKeys->test->return->if->disabledSchemes->isEmpty->return->if->name->equalsIgnoreCase->if->value->isEmpty->return->foreach->slen->scheme->length->vlen->value->length->if->if->value->equalsIgnoreCase->return->else->if->if->value->substring->equalsIgnoreCase->c->value->codePointAt->if->WSPACES->indexOf->Character->isSpaceChar->Character->isWhitespace->return->return
Utils#proxyHasDisabledSchemes(boolean)::: utils proxy has disabled schemes:::return->PROXY_AUTH_TUNNEL_DISABLED_SCHEMES->isEmpty->PROXY_AUTH_DISABLED_SCHEMES->isEmpty
Utils#newIAE(String, Object...)::: utils new e:::return->format->new->IllegalArgumentException
Utils#getBuffer()::: utils get buffer:::return->ByteBuffer->allocate
Utils#getCompletionCause(Throwable)::: utils get completion cause:::if->return->cause->x->getCause->if->throw->new->InternalError->return
Utils#getIOException(Throwable)::: utils get exception:::if->return->cause->t->getCause->if->return->getIOException->return->new->IOException
Utils#wrapWithExtraDetail(Throwable, Supplier):::Adds a more specific exception detail message, based on the given exception type and the message supplier:::if->return->msg->messageSupplier->get->if->return->if->ioe->t->getCause->new->IOException->new->ConnectionExpiredException->else->ioe->new->IOException->return
Utils#permissionForProxy(InetSocketAddress):::Returns the security permissions required to connect to the proxy, or null if none is required or applicable.:::if->return->sb->new->StringBuilder->sb->append->proxyAddress->getHostString->append->append->proxyAddress->getPort->append->urlString->sb->toString->return->new->URLPermission
Utils#permissionForServer(URI, String, Stream):::Returns the security permission required for the given details.:::urlString->new->StringBuilder->uri->getScheme->append->append->uri->getAuthority->append->uri->getPath->append->toString->actionStringBuilder->new->StringBuilder->collected->headers->joining->collect->if->collected->isEmpty->actionStringBuilder->append->append->return->actionStringBuilder->toString->new->URLPermission
Utils#isValidName(String)::: utils is valid name:::for->i->token->length->return->token->isEmpty
Utils.ServerName#getName()::: server name get name:::return
Utils.ServerName#isLiteral()::: server name is literal:::return
Utils#getServerName(InetSocketAddress):::Analyse the given address and determine if it is literal or not, returning the address in String form.:::host->addr->getHostString->literal->IPAddressUtil->textToNumericFormatV4->if->IPAddressUtil->textToNumericFormatV6->return->new->ServerName->else->return->new->ServerName
Utils#isLoopbackLiteral(byte[])::: utils is loopback literal:::if->return->else->if->for->i->if->return->return->else->throw->new->InternalError
Utils#isValidValue(String)::: utils is valid value:::for->i->token->length->return
Utils#getIntegerNetProperty(String, int)::: utils get integer net property:::return->AccessController->NetProperties->getInteger->doPrivileged
Utils#getNetProperty(String)::: utils get net property:::return->AccessController->NetProperties->get->doPrivileged
Utils#getBooleanProperty(String, boolean)::: utils get boolean property:::return->AccessController->Boolean->System->String->valueOf->getProperty->parseBoolean->doPrivileged
Utils#getProperty(String)::: utils get property:::return->AccessController->System->getProperty->doPrivileged
Utils#getIntegerProperty(String, int)::: utils get integer property:::return->AccessController->Integer->System->String->valueOf->getProperty->parseInt->doPrivileged
Utils#copySSLParameters(SSLParameters)::: utils copy parameters:::p1->new->SSLParameters->p1->p->getAlgorithmConstraints->setAlgorithmConstraints->p1->p->getCipherSuites->setCipherSuites->p1->p->getEnableRetransmissions->setEnableRetransmissions->p1->p->getMaximumPacketSize->setMaximumPacketSize->p1->p->getEndpointIdentificationAlgorithm->setEndpointIdentificationAlgorithm->p1->p->getNeedClientAuth->setNeedClientAuth->protocols->p->getProtocols->if->p1->protocols->clone->setProtocols->p1->p->getSNIMatchers->setSNIMatchers->p1->p->getServerNames->setServerNames->p1->p->getUseCipherSuitesOrder->setUseCipherSuitesOrder->p1->p->getWantClientAuth->setWantClientAuth->return
Utils#flipToMark(ByteBuffer, int):::Set limit to position, and position to mark.:::buffer->buffer->position->limit->buffer->position
Utils#stackTrace(Throwable)::: utils stack trace:::bos->new->ByteArrayOutputStream->s->try->p->new->PrintStream->t->printStackTrace->bos->toString->catch->throw->new->InternalError->finally->return
Utils#copy(ByteBuffer, ByteBuffer):::Copies as much of src to dst as possible:::srcLen->src->remaining->dstLen->dst->remaining->if->diff->limit->src->limit->src->limit->dst->put->src->limit->else->dst->put->return->src->remaining
Utils#accumulateBuffers(List, List):::Adds the data from buffersToAdd to currentList:::accumulatedBytes->foreach->remaining->bufferToAdd->remaining->if->continue->listSize->currentList->size->if->currentList->add->continue->lastBuffer->currentList->get->freeSpace->lastBuffer->capacity->lastBuffer->limit->if->position->lastBuffer->position->limit->lastBuffer->limit->lastBuffer->position->lastBuffer->limit->lastBuffer->put->lastBuffer->position->else->currentList->add->return
Utils#copy(ByteBuffer)::: utils copy:::dst->ByteBuffer->src->remaining->allocate->dst->put->dst->flip->return
Utils#copyAligned(ByteBuffer)::: utils copy aligned:::len->src->remaining->size->dst->ByteBuffer->allocate->dst->put->dst->flip->return
Utils#dump(Object...)::: utils dump:::return->Arrays->toString
Utils#stringOf(Collection)::: utils string of:::return->Arrays->source->toArray->toString
Utils#remaining(ByteBuffer[])::: utils remaining:::remain->foreach->buf->remaining->return
Utils#hasRemaining(List)::: utils has remaining:::synchronized->foreach->if->buf->hasRemaining->return->return
Utils#remaining(List)::: utils remaining:::remain->synchronized->foreach->buf->remaining->return
Utils#remaining(List, int)::: utils remaining:::remain->synchronized->foreach->buf->remaining->if->throw->new->IllegalArgumentException->return
Utils#remaining(ByteBuffer[], int)::: utils remaining:::remain->foreach->b->remaining->if->throw->new->IllegalArgumentException->return
Utils#close(Closeable...)::: utils close:::foreach->try->c->close->catch->finally
Utils#sliceWithLimitedCapacity(ByteBuffer, int):::Returns a slice of size amount from the given buffer:::index->buffer->position->limit->buffer->limit->if->buffer->limit->else->buffer->buffer->capacity->limit->newb->buffer->slice->buffer->position->buffer->limit->newb->limit->return
Utils#charsetFrom(HttpHeaders):::Get the Charset from the Content-encoding header:::type->headers->firstValue->orElse->i->type->indexOf->if->type->substring->try->parser->new->HeaderParser->value->parser->findValue->if->return->return->Charset->forName->catch->Log->logTrace->return->finally
Utils#unchecked(IOException)::: utils unchecked:::return->new->UncheckedIOException
Utils#getDebugLogger(Supplier):::Get a logger for debug HTTP traces:::return->getDebugLogger
Utils#getDebugLogger(Supplier, Level):::Get a logger for debug HTTP traces.The logger should only be used with levels whose severity is <= DEBUG:::return->DebugLogger->createHttpLogger
Utils#getDebugLogger(Supplier, boolean):::Get a logger for debug HTTP traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getDebugLogger
Utils#getHpackLogger(Supplier, Level):::Get a logger for debug HPACK traces.The logger should only be used with levels whose severity is <= DEBUG:::outLevel->return->DebugLogger->createHpackLogger
Utils#getHpackLogger(Supplier, boolean):::Get a logger for debug HPACK traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getHpackLogger
Utils#getWebSocketLogger(Supplier, Level):::Get a logger for debug WebSocket traces.The logger should only be used with levels whose severity is <= DEBUG:::outLevel->return->DebugLogger->createWebSocketLogger
Utils#getWebSocketLogger(Supplier, boolean):::Get a logger for debug WebSocket traces.The logger should only be used with levels whose severity is <= DEBUG:::errLevel->return->getWebSocketLogger
Utils#immutableSession(SSLSession):::SSLSessions returned to user are wrapped in an immutable object:::if->return->new->ImmutableExtendedSSLSession->else->return->new->ImmutableSSLSession
Utils#isHostnameVerificationDisabled():::Enabled by default:::return
Utils#resolveAddress(InetSocketAddress)::: utils resolve address:::if->address->isUnresolved->address->getHostString->address->getPort->new->InetSocketAddress->return
Utils#toConnectException(Throwable)::: utils to connect exception:::if->return->getCompletionCause->if->return->if->return->if->return->if->return->if->return->cause->e->getMessage->new->ConnectException->e->initCause->return
Utils#pow2Size(int):::Returns the smallest (closest to zero) positive number m (which is also a power of 2) such that n <= m:::if->throw->new->IllegalArgumentException->else->if->return->else->if->return->else->return->Integer->numberOfLeadingZeros
Utils#appendEscape(StringBuilder, byte)::: utils append escape:::sb->append->sb->append->sb->append
Utils#encode(String)::: utils encode:::n->s->length->if->return->for->i->ns->Normalizer->normalize->bb->try->newEncoder->onMalformedInput->onUnmappableCharacter->CharBuffer->wrap->encode->catch->finally->sb->new->StringBuilder->while->bb->hasRemaining->b->bb->get->if->appendEscape->else->sb->append->return->sb->toString
