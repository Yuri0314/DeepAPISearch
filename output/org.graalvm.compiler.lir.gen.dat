org.graalvm.compiler.lir.gen.LIRGenerator_OptionDescriptors#get(String)->OptionDescriptor::: generator_ option descriptors get
org.graalvm.compiler.lir.gen.LIRGenerator_OptionDescriptors#iterator()->Iterator::: generator_ option descriptors iterator
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#getLIRGen()->LIRGenerator::: arithmetic generator get gen
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#asAllocatable(Value)->AllocatableValue::: arithmetic generator as allocatable
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#getOptions()->OptionValues::: arithmetic generator get options
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#isNumericInteger(PlatformKind)->boolean::: arithmetic generator is numeric integer
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#emitAdd(LIRKind, Value, Value, boolean)->Variable::: arithmetic generator emit add
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#emitSub(LIRKind, Value, Value, boolean)->Variable::: arithmetic generator emit sub
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#emitAdd(Value, Value, boolean)->Variable::: arithmetic generator emit add
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#emitSub(Value, Value, boolean)->Variable::: arithmetic generator emit sub
org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator#emitRor(Value, Value)->Value::: arithmetic generator emit ror
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitNegate(Value)->Value::: arithmetic generator tool emit negate
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitAdd(Value, Value, boolean)->Value::: arithmetic generator tool emit add
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitSub(Value, Value, boolean)->Value::: arithmetic generator tool emit sub
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMul(Value, Value, boolean)->Value::: arithmetic generator tool emit mul
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMulHigh(Value, Value)->Value::: arithmetic generator tool emit mul high
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitUMulHigh(Value, Value)->Value::: arithmetic generator tool emit mul high
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitDiv(Value, Value, LIRFrameState)->Value::: arithmetic generator tool emit div
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitRem(Value, Value, LIRFrameState)->Value::: arithmetic generator tool emit rem
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitUDiv(Value, Value, LIRFrameState)->Value::: arithmetic generator tool emit div
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitURem(Value, Value, LIRFrameState)->Value::: arithmetic generator tool emit rem
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitNot(Value)->Value::: arithmetic generator tool emit not
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitAnd(Value, Value)->Value::: arithmetic generator tool emit and
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitOr(Value, Value)->Value::: arithmetic generator tool emit or
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitXor(Value, Value)->Value::: arithmetic generator tool emit xor
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitShl(Value, Value)->Value::: arithmetic generator tool emit shl
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitShr(Value, Value)->Value::: arithmetic generator tool emit shr
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitUShr(Value, Value)->Value::: arithmetic generator tool emit shr
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitFloatConvert(FloatConvert, Value)->Value::: arithmetic generator tool emit float convert
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitReinterpret(LIRKind, Value)->Value::: arithmetic generator tool emit reinterpret
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitNarrow(Value, int)->Value::: arithmetic generator tool emit narrow
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitSignExtend(Value, int, int)->Value::: arithmetic generator tool emit sign extend
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitZeroExtend(Value, int, int)->Value::: arithmetic generator tool emit zero extend
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathAbs(Value)->Value::: arithmetic generator tool emit math abs
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathSqrt(Value)->Value::: arithmetic generator tool emit math sqrt
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitBitCount(Value)->Value::: arithmetic generator tool emit bit count
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitBitScanForward(Value)->Value::: arithmetic generator tool emit bit scan forward
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitBitScanReverse(Value)->Value::: arithmetic generator tool emit bit scan reverse
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitLoad(LIRKind, Value, LIRFrameState)->Variable::: arithmetic generator tool emit load
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitStore(ValueKind, Value, Value, LIRFrameState)->void::: arithmetic generator tool emit store
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitFusedMultiplyAdd(Value, Value, Value)->Value::: arithmetic generator tool emit fused multiply add
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathLog(Value, boolean)->Value::: arithmetic generator tool emit math log
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathCos(Value)->Value::: arithmetic generator tool emit math cos
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathSin(Value)->Value::: arithmetic generator tool emit math sin
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathTan(Value)->Value::: arithmetic generator tool emit math tan
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathExp(Value)->Value::: arithmetic generator tool emit math exp
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitMathPow(Value, Value)->Value::: arithmetic generator tool emit math pow
org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool#emitZeroMemory(Value, Value)->void::: arithmetic generator tool emit zero memory
org.graalvm.compiler.lir.gen.BlockValueMap#accessOperand(Value, AbstractBlockBase)->void::: block value map access operand
org.graalvm.compiler.lir.gen.BlockValueMap#defineOperand(Value, AbstractBlockBase)->void::: block value map define operand
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#createBenchmarkCounter(String, String, Value)->LIRInstruction::: diagnostic generator tool create benchmark counter
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#createMultiBenchmarkCounter(String[], String[], Value[])->LIRInstruction::: diagnostic generator tool create multi benchmark counter
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#createZapRegisters(Register[], JavaConstant[])->SaveRegistersOp:::Creates a SaveRegistersOp that fills a given set of registers with known garbage value
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#createZapRegisters()->SaveRegistersOp:::Creates a SaveRegistersOp that fills all RegisterConfig#getAllocatableRegisters() allocatable registers with a LIRGenerator#zapValueForKind known garbage value
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#createZapArgumentSpace(StackSlot[], JavaConstant[])->LIRInstruction::: diagnostic generator tool create zap argument space
org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool#zapArgumentSpace()->LIRInstruction::: diagnostic generator tool zap argument space
org.graalvm.compiler.lir.gen.LIRGenerationResult#setComment(LIRInstruction, String)->void:::Adds a comment to a LIRInstruction
org.graalvm.compiler.lir.gen.LIRGenerationResult#getComment(LIRInstruction)->String:::Gets the comment attached to a LIRInstruction.
org.graalvm.compiler.lir.gen.LIRGenerationResult#getCallingConvention()->CallingConvention:::Returns the incoming calling convention for the parameters of the method that is compiled.
org.graalvm.compiler.lir.gen.LIRGenerationResult#getFrameMapBuilder()->FrameMapBuilder:::Returns the FrameMapBuilder for collecting the information to build a FrameMap
org.graalvm.compiler.lir.gen.LIRGenerationResult#buildFrameMap()->void:::Creates a FrameMap out of the FrameMapBuilder
org.graalvm.compiler.lir.gen.LIRGenerationResult#getFrameMap()->FrameMap:::Returns the FrameMap associated with this LIRGenerationResult
org.graalvm.compiler.lir.gen.LIRGenerationResult#getRegisterConfig()->RegisterConfig::: generation result get register config
org.graalvm.compiler.lir.gen.LIRGenerationResult#getLIR()->LIR::: generation result get r
org.graalvm.compiler.lir.gen.LIRGenerationResult#hasForeignCall()->boolean:::Determines whether the code being generated makes at least one foreign call.
org.graalvm.compiler.lir.gen.LIRGenerationResult#setForeignCall(boolean)->void::: generation result set foreign call
org.graalvm.compiler.lir.gen.LIRGenerationResult#getCompilationUnitName()->String::: generation result get compilation unit name
org.graalvm.compiler.lir.gen.LIRGenerationResult#getCompilationId()->CompilationIdentifier:::Returns a unique identifier of the current compilation.
org.graalvm.compiler.lir.gen.LIRGenerator#getArithmetic()->ArithmeticLIRGeneratorTool::: generator get arithmetic
org.graalvm.compiler.lir.gen.LIRGenerator#getMoveFactory()->MoveFactory::: generator get move factory
org.graalvm.compiler.lir.gen.LIRGenerator#getSpillMoveFactory()->MoveFactory::: generator get spill move factory
org.graalvm.compiler.lir.gen.LIRGenerator#getValueKind(JavaKind)->LIRKind::: generator get value kind
org.graalvm.compiler.lir.gen.LIRGenerator#target()->TargetDescription::: generator target
org.graalvm.compiler.lir.gen.LIRGenerator#getProviders()->CodeGenProviders::: generator get providers
org.graalvm.compiler.lir.gen.LIRGenerator#getMetaAccess()->MetaAccessProvider::: generator get meta access
org.graalvm.compiler.lir.gen.LIRGenerator#getCodeCache()->CodeCacheProvider::: generator get code cache
org.graalvm.compiler.lir.gen.LIRGenerator#getForeignCalls()->ForeignCallsProvider::: generator get foreign calls
org.graalvm.compiler.lir.gen.LIRGenerator#getLIRKindTool()->LIRKindTool::: generator get kind tool
org.graalvm.compiler.lir.gen.LIRGenerator.VariableProvider#numVariables()->int::: variable provider num variables
org.graalvm.compiler.lir.gen.LIRGenerator#newVariable(ValueKind)->Variable::: generator new variable
org.graalvm.compiler.lir.gen.LIRGenerator#getRegisterConfig()->RegisterConfig::: generator get register config
org.graalvm.compiler.lir.gen.LIRGenerator#attributes(Register)->RegisterAttributes::: generator attributes
org.graalvm.compiler.lir.gen.LIRGenerator#emitMove(Value)->Variable::: generator emit move
org.graalvm.compiler.lir.gen.LIRGenerator#emitMove(AllocatableValue, Value)->void::: generator emit move
org.graalvm.compiler.lir.gen.LIRGenerator#emitReadRegister(Register, ValueKind)->Variable::: generator emit read register
org.graalvm.compiler.lir.gen.LIRGenerator#emitWriteRegister(Register, Value, ValueKind)->void::: generator emit write register
org.graalvm.compiler.lir.gen.LIRGenerator#emitMoveConstant(AllocatableValue, Constant)->void::: generator emit move constant
org.graalvm.compiler.lir.gen.LIRGenerator#canInlineConstant(Constant)->boolean::: generator can inline constant
org.graalvm.compiler.lir.gen.LIRGenerator#mayEmbedConstantLoad(Constant)->boolean::: generator may embed constant load
org.graalvm.compiler.lir.gen.LIRGenerator#emitConstant(LIRKind, Constant)->Value::: generator emit constant
org.graalvm.compiler.lir.gen.LIRGenerator#emitJavaConstant(JavaConstant)->Value::: generator emit java constant
org.graalvm.compiler.lir.gen.LIRGenerator#emitLoadConstant(ValueKind, Constant)->AllocatableValue::: generator emit load constant
org.graalvm.compiler.lir.gen.LIRGenerator#asAllocatable(Value)->AllocatableValue::: generator as allocatable
org.graalvm.compiler.lir.gen.LIRGenerator#load(Value)->Variable::: generator load
org.graalvm.compiler.lir.gen.LIRGenerator#loadNonConst(Value)->Value::: generator load non const
org.graalvm.compiler.lir.gen.LIRGenerator#needOnlyOopMaps()->boolean:::Determines if only oop maps are required for the code generated from the LIR.
org.graalvm.compiler.lir.gen.LIRGenerator#resultOperandFor(JavaKind, ValueKind)->AllocatableValue:::Gets the ABI specific operand used to return a value of a given kind from a method.
org.graalvm.compiler.lir.gen.LIRGenerator#setSourcePosition(NodeSourcePosition)->void::: generator set source position
org.graalvm.compiler.lir.gen.LIRGenerator#append(I)->I::: generator append
org.graalvm.compiler.lir.gen.LIRGenerator#hasBlockEnd(AbstractBlockBase)->boolean::: generator has block end
org.graalvm.compiler.lir.gen.LIRGenerator#getBlockScope(AbstractBlockBase)->BlockScope::: generator get block scope
org.graalvm.compiler.lir.gen.LIRGenerator#getMatchScope(AbstractBlockBase)->DebugCloseable::: generator get match scope
org.graalvm.compiler.lir.gen.LIRGenerator#emitIncomingValues(Value[])->void::: generator emit incoming values
org.graalvm.compiler.lir.gen.LIRGenerator#emitJump(LabelRef)->void::: generator emit jump
org.graalvm.compiler.lir.gen.LIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)->void::: generator emit compare branch
org.graalvm.compiler.lir.gen.LIRGenerator#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)->void::: generator emit overflow check branch
org.graalvm.compiler.lir.gen.LIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double)->void::: generator emit integer test branch
org.graalvm.compiler.lir.gen.LIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value)->Variable::: generator emit conditional move
org.graalvm.compiler.lir.gen.LIRGenerator#emitIntegerTestMove(Value, Value, Value, Value)->Variable::: generator emit integer test move
org.graalvm.compiler.lir.gen.LIRGenerator#emitForeignCallOp(ForeignCallLinkage, Value, Value[], Value[], LIRFrameState)->void:::Emits the single call operation at the heart of generating LIR for a #emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...) foreign call.
org.graalvm.compiler.lir.gen.LIRGenerator#emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...)->Variable::: generator emit foreign call
org.graalvm.compiler.lir.gen.LIRGenerator#emitStrategySwitch(JavaConstant[], double[], LabelRef[], LabelRef, Variable)->void::: generator emit strategy switch
org.graalvm.compiler.lir.gen.LIRGenerator#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)->void::: generator emit strategy switch
org.graalvm.compiler.lir.gen.LIRGenerator#emitTableSwitch(int, LabelRef, LabelRef[], Value)->void::: generator emit table switch
org.graalvm.compiler.lir.gen.LIRGenerator#hasherFor(JavaConstant[], double)->Optional::: generator hasher for
org.graalvm.compiler.lir.gen.LIRGenerator#emitHashTableSwitch(Hasher, JavaConstant[], LabelRef, LabelRef[], Value)->void::: generator emit hash table switch
org.graalvm.compiler.lir.gen.LIRGenerator#beforeRegisterAllocation()->void::: generator before register allocation
org.graalvm.compiler.lir.gen.LIRGenerator#zapValueForKind(PlatformKind)->JavaConstant:::Gets a garbage value for a given kind.
org.graalvm.compiler.lir.gen.LIRGenerator#getLIRKind(Stamp)->LIRKind::: generator get kind
org.graalvm.compiler.lir.gen.LIRGenerator#getAddressKind(Value, long, Value)->LIRKind::: generator get address kind
org.graalvm.compiler.lir.gen.LIRGenerator#getCurrentBlock()->AbstractBlockBase::: generator get current block
org.graalvm.compiler.lir.gen.LIRGenerator#getResult()->LIRGenerationResult::: generator get result
org.graalvm.compiler.lir.gen.LIRGenerator#emitBlackhole(Value)->void::: generator emit blackhole
org.graalvm.compiler.lir.gen.LIRGenerator#createBenchmarkCounter(String, String, Value)->LIRInstruction::: generator create benchmark counter
org.graalvm.compiler.lir.gen.LIRGenerator#createMultiBenchmarkCounter(String[], String[], Value[])->LIRInstruction::: generator create multi benchmark counter
org.graalvm.compiler.lir.gen.LIRGenerator#createZapRegisters(Register[], JavaConstant[])->SaveRegistersOp::: generator create zap registers
org.graalvm.compiler.lir.gen.LIRGenerator#createZapRegisters()->SaveRegistersOp::: generator create zap registers
org.graalvm.compiler.lir.gen.LIRGenerator#createZapArgumentSpace(StackSlot[], JavaConstant[])->LIRInstruction::: generator create zap argument space
org.graalvm.compiler.lir.gen.LIRGenerator#zapArgumentSpace()->LIRInstruction::: generator zap argument space
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#mayEmbedConstantLoad(Constant)->boolean:::Checks whether the loading of the supplied constant can be deferred until usage.
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#canInlineConstant(Constant)->boolean:::Checks whether the supplied constant can be used without loading it into a register for most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#allowConstantToStackMove(Constant)->boolean::: move factory allow constant to stack move
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#createMove(AllocatableValue, Value)->LIRInstruction::: move factory create move
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#createStackMove(AllocatableValue, AllocatableValue)->LIRInstruction::: move factory create stack move
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#createLoad(AllocatableValue, Constant)->LIRInstruction::: move factory create load
org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory#createStackLoad(AllocatableValue, Constant)->LIRInstruction::: move factory create stack load
org.graalvm.compiler.lir.gen.LIRGeneratorTool.BlockScope#getCurrentBlock()->AbstractBlockBase::: block scope get current block
org.graalvm.compiler.lir.gen.LIRGeneratorTool.BlockScope#close()->void::: block scope close
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getArithmetic()->ArithmeticLIRGeneratorTool::: generator tool get arithmetic
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getProviders()->CodeGenProviders::: generator tool get providers
org.graalvm.compiler.lir.gen.LIRGeneratorTool#target()->TargetDescription::: generator tool target
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getMetaAccess()->MetaAccessProvider::: generator tool get meta access
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getCodeCache()->CodeCacheProvider::: generator tool get code cache
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getForeignCalls()->ForeignCallsProvider::: generator tool get foreign calls
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getCurrentBlock()->AbstractBlockBase::: generator tool get current block
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getResult()->LIRGenerationResult::: generator tool get result
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getRegisterConfig()->RegisterConfig::: generator tool get register config
org.graalvm.compiler.lir.gen.LIRGeneratorTool#hasBlockEnd(AbstractBlockBase)->boolean::: generator tool has block end
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getMoveFactory()->MoveFactory::: generator tool get move factory
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getSpillMoveFactory()->MoveFactory:::Get a special MoveFactory for spill moves
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getBlockScope(AbstractBlockBase)->BlockScope::: generator tool get block scope
org.graalvm.compiler.lir.gen.LIRGeneratorTool#canInlineConstant(Constant)->boolean::: generator tool can inline constant
org.graalvm.compiler.lir.gen.LIRGeneratorTool#mayEmbedConstantLoad(Constant)->boolean::: generator tool may embed constant load
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitConstant(LIRKind, Constant)->Value::: generator tool emit constant
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitJavaConstant(JavaConstant)->Value::: generator tool emit java constant
org.graalvm.compiler.lir.gen.LIRGeneratorTool#toRegisterKind(K)->K:::Some backends need to convert sub-word kinds to a larger kind in ArithmeticLIRGeneratorTool#emitLoad and #emitLoadConstant because sub-word registers can't be accessed
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitLoadConstant(ValueKind, Constant)->AllocatableValue::: generator tool emit load constant
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitNullCheck(Value, LIRFrameState)->void::: generator tool emit null check
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitLogicCompareAndSwap(LIRKind, Value, Value, Value, Value, Value)->Variable::: generator tool emit logic compare and swap
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitValueCompareAndSwap(LIRKind, Value, Value, Value)->Value::: generator tool emit value compare and swap
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitAtomicReadAndAdd(Value, ValueKind, Value)->Value:::Emit an atomic read-and-add instruction.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitAtomicReadAndWrite(Value, ValueKind, Value)->Value:::Emit an atomic read-and-write instruction.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitDeoptimize(Value, Value, LIRFrameState)->void::: generator tool emit deoptimize
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...)->Variable::: generator tool emit foreign call
org.graalvm.compiler.lir.gen.LIRGeneratorTool#attributes(Register)->RegisterAttributes::: generator tool attributes
org.graalvm.compiler.lir.gen.LIRGeneratorTool#newVariable(ValueKind)->Variable:::Create a new Variable.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitMove(Value)->Variable::: generator tool emit move
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitMove(AllocatableValue, Value)->void::: generator tool emit move
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitReadRegister(Register, ValueKind)->Variable::: generator tool emit read register
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitWriteRegister(Register, Value, ValueKind)->void::: generator tool emit write register
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitMoveConstant(AllocatableValue, Constant)->void::: generator tool emit move constant
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitAddress(AllocatableValue)->Variable::: generator tool emit address
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitMembar(int)->void::: generator tool emit membar
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitUnwind(Value)->void::: generator tool emit unwind
org.graalvm.compiler.lir.gen.LIRGeneratorTool#beforeRegisterAllocation()->void:::Called just before register allocation is performed on the LIR owned by this generator
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitIncomingValues(Value[])->void::: generator tool emit incoming values
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitReturn(JavaKind, Value)->void:::Emits a return instruction
org.graalvm.compiler.lir.gen.LIRGeneratorTool#asAllocatable(Value)->AllocatableValue::: generator tool as allocatable
org.graalvm.compiler.lir.gen.LIRGeneratorTool#load(Value)->Variable::: generator tool load
org.graalvm.compiler.lir.gen.LIRGeneratorTool#loadNonConst(Value)->Value::: generator tool load non const
org.graalvm.compiler.lir.gen.LIRGeneratorTool#needOnlyOopMaps()->boolean:::Determines if only oop maps are required for the code generated from the LIR.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#resultOperandFor(JavaKind, ValueKind)->AllocatableValue:::Gets the ABI specific operand used to return a value of a given kind from a method.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#append(I)->I::: generator tool append
org.graalvm.compiler.lir.gen.LIRGeneratorTool#setSourcePosition(NodeSourcePosition)->void::: generator tool set source position
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitJump(LabelRef)->void::: generator tool emit jump
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)->void::: generator tool emit compare branch
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)->void::: generator tool emit overflow check branch
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double)->void::: generator tool emit integer test branch
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value)->Variable::: generator tool emit conditional move
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitIntegerTestMove(Value, Value, Value, Value)->Variable::: generator tool emit integer test move
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitStrategySwitch(JavaConstant[], double[], LabelRef[], LabelRef, Variable)->void::: generator tool emit strategy switch
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)->void::: generator tool emit strategy switch
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitByteSwap(Value)->Variable::: generator tool emit byte swap
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitArrayCompareTo(JavaKind, JavaKind, Value, Value, Value, Value)->Variable::: generator tool emit array compare to
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitArrayEquals(JavaKind, Value, Value, Value, int, boolean)->Variable::: generator tool emit array equals
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitArrayEquals(JavaKind, JavaKind, Value, Value, Value, int, boolean)->Variable::: generator tool emit array equals
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitArrayIndexOf(JavaKind, JavaKind, boolean, Value, Value, Value, Value...)->Variable::: generator tool emit array index of
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitStringLatin1Inflate(Value, Value, Value)->void::: generator tool emit string latin1 inflate
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitStringUTF16Compress(Value, Value, Value)->Variable::: generator tool emit string f16 compress
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitBlackhole(Value)->void::: generator tool emit blackhole
org.graalvm.compiler.lir.gen.LIRGeneratorTool#getLIRKind(Stamp)->LIRKind::: generator tool get kind
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitPause()->void::: generator tool emit pause
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitPrefetchAllocate(Value)->void::: generator tool emit prefetch allocate
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitCompress(Value, CompressEncoding, boolean)->Value::: generator tool emit compress
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitUncompress(Value, CompressEncoding, boolean)->Value::: generator tool emit uncompress
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitConvertNullToZero(AllocatableValue, Value)->void::: generator tool emit convert null to zero
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitConvertZeroToNull(AllocatableValue, Value)->void::: generator tool emit convert zero to null
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitSpeculationFence()->void:::Emits an instruction that prevents speculative execution from proceeding: no instruction after this fence will execute until all previous instructions have retired.
org.graalvm.compiler.lir.gen.LIRGeneratorTool#allocateStackSlots(int)->VirtualStackSlot::: generator tool allocate stack slots
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitReadCallerStackPointer(Stamp)->Value::: generator tool emit read caller stack pointer
org.graalvm.compiler.lir.gen.LIRGeneratorTool#emitReadReturnAddress(Stamp, int)->Value::: generator tool emit read return address
org.graalvm.compiler.lir.gen.PhiResolver.PhiResolverNode#toString()->String::: phi resolver node to string
org.graalvm.compiler.lir.gen.PhiResolver#create(LIRGeneratorTool)->PhiResolver::: phi resolver create
org.graalvm.compiler.lir.gen.PhiResolver#create(LIRGeneratorTool, LIRInsertionBuffer, List, int)->PhiResolver::: phi resolver create
org.graalvm.compiler.lir.gen.PhiResolver#dispose()->void::: phi resolver dispose
org.graalvm.compiler.lir.gen.PhiResolver#move(Value, Value)->void::: phi resolver move
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#canInlineConstant(Constant)->boolean::: verifying move factory can inline constant
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#allowConstantToStackMove(Constant)->boolean::: verifying move factory allow constant to stack move
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#createMove(AllocatableValue, Value)->LIRInstruction::: verifying move factory create move
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#createStackMove(AllocatableValue, AllocatableValue)->LIRInstruction::: verifying move factory create stack move
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#createLoad(AllocatableValue, Constant)->LIRInstruction::: verifying move factory create load
org.graalvm.compiler.lir.gen.VerifyingMoveFactory#createStackLoad(AllocatableValue, Constant)->LIRInstruction::: verifying move factory create stack load
