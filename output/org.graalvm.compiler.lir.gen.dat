DiagnosticLIRGeneratorTool#createZapRegisters(Register[], JavaConstant[]):::Creates a SaveRegistersOp that fills a given set of registers with known garbage value:::
DiagnosticLIRGeneratorTool#createZapRegisters():::Creates a SaveRegistersOp that fills all RegisterConfig#getAllocatableRegisters() allocatable registers with a LIRGenerator#zapValueForKind known garbage value:::
LIRGenerationResult#setComment(LIRInstruction, String):::Adds a comment to a LIRInstruction:::debug->lir->getDebug->if->debug->isDumpEnabled->if->EconomicMap->create->comments->put
LIRGenerationResult#getComment(LIRInstruction):::Gets the comment attached to a LIRInstruction.:::if->return->return->comments->get
LIRGenerationResult#getCallingConvention():::Returns the incoming calling convention for the parameters of the method that is compiled.:::return
LIRGenerationResult#getFrameMapBuilder():::Returns the FrameMapBuilder for collecting the information to build a FrameMap:::return
LIRGenerationResult#buildFrameMap():::Creates a FrameMap out of the FrameMapBuilder:::frameMapBuilder->buildFrameMap
LIRGenerationResult#getFrameMap():::Returns the FrameMap associated with this LIRGenerationResult:::return
LIRGenerationResult#hasForeignCall():::Determines whether the code being generated makes at least one foreign call.:::return
LIRGenerationResult#getCompilationId():::Returns a unique identifier of the current compilation.:::return
LIRGenerator#needOnlyOopMaps():::Determines if only oop maps are required for the code generated from the LIR.:::return
LIRGenerator#resultOperandFor(JavaKind, ValueKind):::Gets the ABI specific operand used to return a value of a given kind from a method.:::reg->getRegisterConfig->getReturnRegister->return->reg->asValue
LIRGenerator#emitForeignCallOp(ForeignCallLinkage, Value, Value[], Value[], LIRFrameState):::Emits the single call operation at the heart of generating LIR for a #emitForeignCall(ForeignCallLinkage, LIRFrameState, Value...) foreign call.:::
LIRGenerator#zapValueForKind(PlatformKind):::Gets a garbage value for a given kind.:::
LIRGeneratorTool.MoveFactory#mayEmbedConstantLoad(Constant):::Checks whether the loading of the supplied constant can be deferred until usage.:::return
LIRGeneratorTool.MoveFactory#canInlineConstant(Constant):::Checks whether the supplied constant can be used without loading it into a register for most operations, i.e., for commonly used arithmetic, logical, and comparison operations.:::
LIRGeneratorTool#getSpillMoveFactory():::Get a special MoveFactory for spill moves:::
LIRGeneratorTool#toRegisterKind(K):::Some backends need to convert sub-word kinds to a larger kind in ArithmeticLIRGeneratorTool#emitLoad and #emitLoadConstant because sub-word registers can't be accessed:::
LIRGeneratorTool#emitAtomicReadAndAdd(Value, ValueKind, Value):::Emit an atomic read-and-add instruction.:::throw->GraalError->unimplemented
LIRGeneratorTool#emitAtomicReadAndWrite(Value, ValueKind, Value):::Emit an atomic read-and-write instruction.:::throw->GraalError->unimplemented
LIRGeneratorTool#newVariable(ValueKind):::Create a new Variable.:::
LIRGeneratorTool#beforeRegisterAllocation():::Called just before register allocation is performed on the LIR owned by this generator:::
LIRGeneratorTool#emitReturn(JavaKind, Value):::Emits a return instruction:::
LIRGeneratorTool#needOnlyOopMaps():::Determines if only oop maps are required for the code generated from the LIR.:::
LIRGeneratorTool#resultOperandFor(JavaKind, ValueKind):::Gets the ABI specific operand used to return a value of a given kind from a method.:::
LIRGeneratorTool#emitSpeculationFence():::Emits an instruction that prevents speculative execution from proceeding: no instruction after this fence will execute until all previous instructions have retired.:::
