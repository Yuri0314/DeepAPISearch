AttributeValues#applyIMHighlight():::If this has an imHighlight, create copy of this with those attributes applied to it:::if->hl->if->else->getValue->imStyles->hl->getStyle->if->tk->Toolkit->getDefaultToolkit->tk->mapInputMethodHighlight->if->return->clone->merge->return
BidiUtils#getLevels(Bidi, byte[], int):::Return the level of each character into the levels array starting at start:::limit->bidi->getLength->if->throw->new->IndexOutOfBoundsException->runCount->bidi->getRunCount->p->for->i
BidiUtils#getLevels(Bidi):::Return an array containing the resolved bidi level of each character, in logical order.:::levels->bidi->getLength->new->byteArr->getLevels->return
BidiUtils#createVisualToLogicalMap(byte[]):::Given level data, compute a a visual to logical mapping:::len->mapping->new->intArr->lowestOddLevel->highestLevel->for->i->while->i->for->return
BidiUtils#createInverseMap(int[]):::Return the inverse position map:::if->return->result->new->intArr->for->i->return
BidiUtils#createContiguousOrder(int[]):::Return an array containing contiguous values from 0 to length having the same ordering as the source array:::if->return->computeContiguousOrder->return
BidiUtils#createNormalizedMap(int[], byte[], int, int):::Return an array containing the data in the values array from start up to limit, normalized to fall within the range from 0 up to limit - start:::if->if->copyRange->canonical->primaryLevel->if->else->if->i->for->else->if->if->return->result->new->intArr->baseValue->if->else->if->System->arraycopy->else->for->j->return->else->return->computeContiguousOrder->else->return->return
BidiUtils#reorderVisually(byte[], Object[]):::Reorder the objects in the array into visual order based on their levels:::len->lowestOddLevel->highestLevel->for->i->while->i->for
Decoration#getPlainDecoration():::Return a Decoration which does nothing.:::return
Decoration#getDecoration(Map):::Return a Decoration appropriate for the given Map.:::if->return->return->AttributeValues->fromMap->getDecoration
ExtendedTextLabel#getNumCharacters():::Return the number of characters represented by this label.:::
ExtendedTextLabel#getCoreMetrics():::Return the line metrics for all text in this label.:::
ExtendedTextLabel#getCharX(int):::Return the x location of the character at the given logical index.:::
ExtendedTextLabel#getCharY(int):::Return the y location of the character at the given logical index.:::
ExtendedTextLabel#getCharAdvance(int):::Return the advance of the character at the given logical index.:::
ExtendedTextLabel#getCharVisualBounds(int, float, float):::Return the visual bounds of the character at the given logical index:::
ExtendedTextLabel#logicalToVisual(int):::Return the visual index of the character at the given logical index.:::
ExtendedTextLabel#visualToLogical(int):::Return the logical index of the character at the given visual index.:::
ExtendedTextLabel#getLineBreakIndex(int, float):::Return the logical index of the character, starting with the character at logicalStart, whose accumulated advance exceeds width:::
ExtendedTextLabel#getAdvanceBetween(int, int):::Return the accumulated advances of all characters between logicalStart and logicalLimit.:::
ExtendedTextLabel#caretAtOffsetIsValid(int):::Return whether a caret can exist on the leading edge of the character at offset:::
ExtendedTextLabel#getCharVisualBounds(int):::A convenience overload of getCharVisualBounds that defaults the label origin to 0, 0.:::return->getCharVisualBounds
ExtendedTextLabel#getNumJustificationInfos():::Return the number of justification records this uses.:::
ExtendedTextLabel#getJustificationInfos(GlyphJustificationInfo[], int, int, int):::Return GlyphJustificationInfo objects for the characters between charStart and charLimit, starting at offset infoStart:::
ExtendedTextLabel#applyJustificationDeltas(float[], int, boolean[]):::Apply deltas to the data in this component, starting at offset deltaStart, and return the new component:::
ExtendedTextSourceLabel#createLogicalBounds():::The logical bounds extends from the origin of the glyphvector to the position at which a following glyphvector's origin should be placed:::return->getGV->getLogicalBounds
ExtendedTextSourceLabel#createAlignBounds():::Like createLogicalBounds except ignore leading and logically trailing white space:::info->getCharinfo->al->at->aw->ah->if->return->new->Rectangle2D.Float->lineIsLTR->source->getLayoutFlags->rn->if->while->if->ln->while->Math->max->return->new->Rectangle2D.Float
ExtendedTextSourceLabel#l2v(int):::Map logical character index to visual character index:::return->source->getLayoutFlags->source->getLength
ExtendedTextSourceLabel#v2l(int):::Map visual character index to logical character index:::return->source->getLayoutFlags->source->getLength
FileFontStrike#getGlyphImageBounds(int, Point2D.Float, Rectangle):::Result and pt are both in device space.:::ptr->getGlyphImagePtr->topLeftX->topLeftY->if->Math->floor->Math->floor->return->getFloat->getFloat->Math->floor->Math->floor->getShort->getShort->if->minx->getGlyphImageMinX->if
Font2D#getFontMetrics(Font, AffineTransform, Object, Object, float[]):::The length of the metrics array must be >= 8:::aa->FontStrikeDesc->font->getSize->getAAHintIntVal->fm->FontStrikeDesc->getFMHintIntVal->strike->getStrike->strikeMetrics->strike->getFontMetrics->strikeMetrics->getAscent->strikeMetrics->getDescent->strikeMetrics->getLeading->strikeMetrics->getMaxAdvance->font->getSize2D->getStyleMetrics
Font2D#getStyleMetrics(float, float[], int):::The length of the metrics array must be >= offset+4, and offset must be >= 0:::
Font2D#getFontMetrics(Font, FontRenderContext, float[]):::The length of the metrics array must be >= 4:::strikeMetrics->getStrike->getFontMetrics->strikeMetrics->getAscent->strikeMetrics->getDescent->strikeMetrics->getLeading->strikeMetrics->getMaxAdvance
FontDesignMetrics#getSimpleBounds(char[], int, int):::This method is called from java.awt.Font only after verifying the arguments and that the text is simple and there are no layout attributes, font transform etc.:::width->limit->for->i->height->return->new->Rectangle2D.Float
FontManager#registerFont(Font):::Register a new font:::
FontManager#findFont2D(String, int, int):::The client supplies a name and a style:::
FontManager#createFont2D(File, int, boolean, boolean, CreatedFontTracker):::Creates a Font2D for the specified font file, that is expected to be in the specified font format (according to the constants in java.awt.Font):::
FontManager#usingPerAppContextComposites():::If usingPerAppContextComposites is true, we are in "applet" (eg browser) environment and at least one context has selected an alternate composite font behaviour.:::
FontManager#getNewComposite(String, int, Font2DHandle):::Creates a derived composite font from the specified font (handle).:::
FontManager#preferLocaleFonts():::Indicates a preference for locale-specific fonts in the mapping of logical fonts to physical fonts:::
FontManager#preferProportionalFonts():::preferLocaleFonts() and preferProportionalFonts() are called to inform that the application could be using an alternate set of composite fonts, and so the implementation should try to create a CompositeFonts with this directive in mind.:::
FontManagerFactory#getInstance():::Get a valid FontManager implementation for the current platform.:::if->return->AccessController->new->PrivilegedAction<Object>->doPrivileged->return
FontManagerForSGE#getCreatedFonts():::Return an array of created Fonts, or null, if no fonts were created yet.:::
FontManagerForSGE#getCreatedFontFamilyNames():::Similar to getCreatedFonts, but returns a TreeMap of fonts by family name.:::
FontManagerForSGE#getAllInstalledFonts():::Returns all fonts installed in this environment.:::
FontResolver#getFontIndex(char):::Return an index for the given character:::blockIndex->block->if->new->intArr->index->if->getIndexFor->return
FontResolver#nextFontRunIndex(CodePointIterator):::Determines the font index for the code point at the current position in the iterator, then advances the iterator to the first code point that has a different index or until the iterator is DONE, and returns the font index.:::cp->iter->next->fontIndex->if->getFontIndex->while->iter->next->if->getFontIndex->iter->prev->break->return
FontResolver#getFont(int, Map):::Return a Font from a given font index with properties from attributes:::font->if->return->font->deriveFont
FontResolver#getInstance():::Return a shared instance of FontResolver.:::if->new->FontResolver->return
FontScaler#disposeScaler():::Used when the native resources held by the scaler need to be released before the 2D disposer runs.:::
FontUtilities#getFont2D(Font):::Calls the private getFont2D() method in java.awt.Font objects.:::return->FontAccess->getFontAccess->getFont2D
FontUtilities#isComplexScript(char[], int, int):::Return true if there any characters which would trigger layout:::for->i->return
FontUtilities#isComplexText(char[], int, int):::If there is anything in the text which triggers a case where char->glyph does not map 1:1 in straightforward left->right ordering, then this method returns true:::for->i->return
FontUtilities#textLayoutIsCompatible(Font):::Used by windows printing to assess if a font is likely to be layout compatible with JDK TrueType fonts should be, but if they have no GPOS table, but do have a GSUB table, then they are probably older fonts GDI handles differently.:::font2D->getFont2D->if->ttf->return->ttf->getDirectoryEntry->ttf->getDirectoryEntry->else->return
GlyphLayout.LayoutEngineFactory#getEngine(Font2D, int, int):::Given a font, script, and language, determine a layout engine to use.:::
GlyphLayout.LayoutEngineFactory#getEngine(LayoutEngineKey):::Given a key, determine a layout engine to use.:::
GlyphLayout.LayoutEngine#layout(FontStrikeDesc, float[], float, int, int, TextRecord, int, Point2D.Float, GVData):::Given a strike descriptor, text, rtl flag, and starting point, append information about glyphs, positions, and character indices to the glyphvector data, and advance the point:::
GlyphLayout#get(LayoutEngineFactory):::Return a new instance of GlyphLayout, using the provided layout engine factory:::if->SunLayoutEngine->instance->result->synchronized->if->if->new->GlyphLayout->return
GlyphLayout#done(GlyphLayout):::Return the old instance of GlyphLayout when you are done:::
GlyphLayout#layout(Font, FontRenderContext, char[], int, int, int, StandardGlyphVector):::Create a glyph vector.:::if->throw->new->IllegalArgumentException->init->if->font->hasLayoutAttributes->values->font->getAttributes->getValues->if->values->getKerning->if->values->getLigatures->txinfo->SDCache->get->getScaleX->getShearY->getShearX->getScaleY->_pt->setLocation->font->getSize2D->lim->min->max->if->if->if->if->lang->font2D->FontUtilities->getFont2D->if->getCompositeFont2D->_textRecord->init->start->if->_scriptRuns->init->_fontRuns->init->while->_scriptRuns->next->limit->_scriptRuns->getScriptLimit->script->_scriptRuns->getScriptCode->while->_fontRuns->next->pfont->_fontRuns->getFont->if->getDelegateFont->gmask->_fontRuns->getGlyphMask->pos->_fontRuns->getPos->nextEngineRecord->else->_scriptRuns->init->while->_scriptRuns->next->limit->_scriptRuns->getScriptLimit->script->_scriptRuns->getScriptCode->nextEngineRecord->ix->stop->dir->if->for->gv->if->new->StandardGlyphVector->if->FontUtilities->debugFonts->FontUtilities->getLogger->warning->else->_gvdata->createGlyphVector->return
GraphicComponent#getNumJustificationInfos():::Return the number of justification records this uses.:::return
GraphicComponent#getJustificationInfos(GlyphJustificationInfo[], int, int, int):::Return GlyphJustificationInfo objects for the characters between charStart and charLimit, starting at offset infoStart:::
GraphicComponent#applyJustificationDeltas(float[], int, boolean[]):::Apply deltas to the data in this component, starting at offset deltaStart, and return the new component:::return
LayoutPathImpl#getPath(EndType, double...):::Return a path representing the path from the origin through the points in order.:::if->throw->new->IllegalArgumentException->return->SegmentPath->get
LayoutPathImpl.SegmentPathBuilder#reset(int):::Reset the builder for a new path:::if->new->doubleArr->else->if
LayoutPathImpl.SegmentPathBuilder#build(EndType, double...):::Automatically build from a list of points represented by pairs of doubles:::reset->for->i->return->complete
LayoutPathImpl.SegmentPathBuilder#moveTo(double, double):::Move to a new point:::nextPoint
LayoutPathImpl.SegmentPathBuilder#lineTo(double, double):::Connect to a new point:::nextPoint
LayoutPathImpl.SegmentPathBuilder#complete(EndType):::Complete building a SegmentPath:::result->if->return->if->new->SegmentPath->reset->else->dataToAdopt->new->doubleArr->System->arraycopy->new->SegmentPath->reset->return
LayoutPathImpl.SegmentPath.LineInfo#set(double, double, double, double):::Set the lineinfo to this line:::dx->if->else->dy
LayoutPathImpl.SegmentPath.LineInfo#pin(double, double, LineInfo):::Return true if we intersect the infinitely tall rectangle with lo <= x < hi:::result->set->if->if->if->if->if->if->return->else->if->if->if->if->if->return->return
LayoutPathImpl.SegmentPath.LineInfo#pin(int, LineInfo):::Return true if we intersect the segment at ix:::lo->hi->switch->break->if->if->break->break->return->pin
ScriptRun#getScriptStart():::Get the starting index of the current script run.:::return
ScriptRun#getScriptLimit():::Get the index of the first character after the current script run.:::return
ScriptRun#getScriptCode():::Get the script code for the script of the current script run.:::return
ScriptRun#next():::Find the next script run:::startSP->if->return->ch->while->nextCodePoint->sc->ScriptRunData->getScript->pairIndex->getPairIndex->if->if->if->new->intArr->else->if->newstack->new->intArr->System->arraycopy->else->if->pi->while->if->else->if->if->sameScript->if->while->if->else->pushback->break->return
StandardGlyphVector#hashCode():::As a concrete subclass of Object that implements equality, this must implement hashCode.:::return->font->hashCode
StandardGlyphVector#equals(Object):::Since we implement equality comparisons for GlyphVector, we implement the inherited Object.equals(Object) as well:::try->return->equals->catch->return->finally
StandardGlyphVector#copy():::Sometimes I wish java had covariant return types...:::return->clone
StandardGlyphVector#clone():::As a concrete subclass of GlyphVector, this must implement clone.:::try->result->super->clone->result->clearCaches->if->positions->clone->if->new->GlyphTransformInfo->return->catch->finally->return
StandardGlyphVector#setGlyphPositions(float[]):::Set all the glyph positions, including the 'after last glyph' position:::requiredLength->if->throw->new->IllegalArgumentException->srcPositions->clone->clearCaches->addFlags
StandardGlyphVector#getGlyphPositions(float[]):::This is a convenience overload that gets all the glyph positions, which is what you usually want to do if you're getting more than one:::return->internalGetGlyphPositions
StandardGlyphVector#getGlyphTransforms(int, int, AffineTransform[]):::Get transform information for the requested range of glyphs:::if->throw->new->IllegalArgumentException->if->return->if->new->AffineTransformArr->for->i->return
StandardGlyphVector#getGlyphTransforms():::Convenience overload for getGlyphTransforms(int, int, AffineTransform[], int);:::return->getGlyphTransforms
StandardGlyphVector#setGlyphTransforms(AffineTransform[], int, int, int):::Set a number of glyph transforms:::for->i->e
StandardGlyphVector#setGlyphTransforms(AffineTransform[]):::Convenience overload of setGlyphTransforms(AffineTransform[], int, int, int).:::setGlyphTransforms
StandardGlyphVector#getGlyphInfo():::For each glyph return posx, posy, advx, advy, visx, visy, visw, vish.:::setFRCTX->initPositions->result->new->floatArr->for->i->n->return
StandardGlyphVector#pixellate(FontRenderContext, Point2D, Point):::!!! not used currently, but might be by getPixelbounds?:::if->at->renderFRC->getTransform->at->transform->loc->getX->loc->getY->loc->setLocation->try->at->inverseTransform->catch->throw->new->IllegalArgumentException->finally
StandardGlyphVector.GlyphTransformInfo#setupGlyphImages(long[], float[], AffineTransform):::The strike cache works like this:::len->sl->getAllStrikes->for->i->tx->transform->return
SunFontManager#getInstance():::Returns the global SunFontManager instance:::fm->FontManagerFactory->getInstance->return
SunFontManager#getJDKFontDir():::If the module image layout changes the location of JDK fonts, this will be updated to reflect that.:::return
SunFontManager#populateHardcodedFileNameMap():::default implementation does nothing.:::return->new->HashMap<String,FamilyDescription>
SunFontManager#getDefaultPlatformFont():::Returns an array of two strings:::
SunFontManager#getFileNameFromPlatformName(String):::Returns a file name for the physical font represented by this platform font name:::return->fontConfig->getFileNameFromPlatformName
SunFontManager#getFontConfiguration():::Return the default font configuration.:::return
SunFontManager#getDefaultFontFile():::Returns file name for default font, either absolute or relative as needed by registerFontFile.:::return
SunFontManager#useAbsoluteFontFileNames():::Whether registerFontFile expects absolute or relative font file names.:::return
SunFontManager#createFontConfiguration():::Creates this environment's FontConfiguration.:::
SunFontManager#getDefaultFontFaceName():::Returns face name for default font, or null if no face names are used for CompositeFontDescriptors for this platform.:::return
SunFontManager#addFontToPlatformFontPath(String):::Notifies graphics environment that the logical font configuration uses the given platform font name:::
SunFontManager#getAllInstalledFonts():::Returns all fonts installed in this environment.:::if->loadFonts->fontMapNames->new->TreeMap<>->allfonts->getRegisteredFonts->for->i->platformNames->getFontNamesFromPlatform->if->for->i->fontNames->if->fontMapNames->size->fontMapNames->size->new->StringArr->keyNames->fontMapNames->keySet->toArray->for->i->fonts->new->FontArr->for->i->copyFonts->new->FontArr->System->arraycopy->return
SunFontManager#getInstalledFontFamilyNames(Locale):::Get a list of installed fonts in the requested Locale:::if->Locale->getDefault->if->requestedLocale->equals->copyFamilies->new->StringArr->System->arraycopy->return->familyNames->new->TreeMap<String,String>->str->familyNames->str->toLowerCase->put->familyNames->str->toLowerCase->put->familyNames->str->toLowerCase->put->familyNames->str->toLowerCase->put->familyNames->str->toLowerCase->put->if->requestedLocale->getSystemStartupLocale->equals->getFamilyNamesFromPlatform->getJREFontFamilyNames->else->loadFontFiles->physicalfonts->getPhysicalFonts->for->i->addNativeFontFamilyNames->retval->familyNames->size->new->StringArr->keyNames->familyNames->keySet->toArray->for->i->if->requestedLocale->Locale->getDefault->equals->new->StringArr->System->arraycopy->return
TextLabel#getVisualBounds(float, float):::Return a rectangle that surrounds the text outline when this label is rendered at x, y.:::
TextLabel#getLogicalBounds(float, float):::Return a rectangle that corresponds to the logical bounds of the text when this label is rendered at x, y:::
TextLabel#getAlignBounds(float, float):::Return a rectangle that corresponds to the alignment bounds of the text when this label is rendered at x, y:::
TextLabel#getItalicBounds(float, float):::Return a rectangle that corresponds to the logical bounds of the text, adjusted to angle the leading and trailing edges by the italic angle.:::
TextLabel#getOutline(float, float):::Return an outline of the characters in the label when rendered at x, y.:::
TextLabel#draw(Graphics2D, float, float):::Render the label at x, y in the graphics.:::
TextLabel#getVisualBounds():::A convenience method that returns the visual bounds when rendered at 0, 0.:::return->getVisualBounds
TextLabel#getLogicalBounds():::A convenience method that returns the logical bounds when rendered at 0, 0.:::return->getLogicalBounds
TextLabel#getAlignBounds():::A convenience method that returns the align bounds when rendered at 0, 0.:::return->getAlignBounds
TextLabel#getItalicBounds():::A convenience method that returns the italic bounds when rendered at 0, 0.:::return->getItalicBounds
TextLabel#getOutline():::A convenience method that returns the outline when rendered at 0, 0.:::return->getOutline
TextLabel#draw(Graphics2D):::A convenience method that renders the label at 0, 0.:::draw
TextLabelFactory#setLineContext(int, int):::Set a line context for the factory:::if->bidi->createLineBidi
TextLabelFactory#createExtended(Font, CoreMetrics, Decoration, int, int):::Create an extended glyph array for the text between start and limit.:::if->throw->new->IllegalArgumentException->level->lineBidi->getLevelAt->linedir->lineBidi->baseIsLeftToRight->layoutFlags->if->if->source->new->StandardTextSource->return->new->ExtendedTextSourceLabel
TextLabelFactory#createSimple(Font, CoreMetrics, int, int):::Create a simple glyph array for the text between start and limit.:::if->throw->new->IllegalArgumentException->level->lineBidi->getLevelAt->linedir->lineBidi->baseIsLeftToRight->layoutFlags->if->if->source->new->StandardTextSource->return->new->TextSourceLabel
TextLineComponent#getSubset(int, int, int):::Return a TextLineComponent for the characters in the range start, limit:::
TextLineComponent#getNumJustificationInfos():::Return the number of justification records this uses.:::
TextLineComponent#getJustificationInfos(GlyphJustificationInfo[], int, int, int):::Return GlyphJustificationInfo objects for the characters between charStart and charLimit, starting at offset infoStart:::
TextLineComponent#applyJustificationDeltas(float[], int, boolean[]):::Apply deltas to the data in this component, starting at offset deltaStart, and return the new component:::
TextSource#getChars():::Source character data.:::
TextSource#getStart():::Start of source data in char array returned from getChars.:::
TextSource#getLength():::Length of source data.:::
TextSource#getContextStart():::Start of context data in char array returned from getChars.:::
TextSource#getContextLength():::Length of context data.:::
TextSource#getLayoutFlags():::Return the layout flags:::
TextSource#getBidiLevel():::Bidi level of all the characters in context.:::
TextSource#getFont():::Font for source data.:::
TextSource#getFRC():::Font render context to use when measuring or rendering source data.:::
TextSource#getCoreMetrics():::Line metrics for source data.:::
TextSource#getSubSource(int, int, int):::Get subrange of this TextSource:::
TextSource#toString(boolean):::Get debugging info about this TextSource instance:::
Underline#drawUnderline(Graphics2D, float, float, float, float):::Draws the underline into g2d:::
Underline#getLowerDrawLimit(float):::Returns the bottom of the bounding rectangle for this underline.:::
Underline#getUnderlineShape(float, float, float, float):::Returns a Shape representing the underline:::
Underline#getUnderline(Object):::Return the Underline for the given value of TextAttribute.INPUT_METHOD_UNDERLINE or TextAttribute.UNDERLINE:::if->return->return->UNDERLINES->get
