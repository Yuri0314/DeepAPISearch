Signal#getName():::Returns the signal name.:::return->iSignal->getName
Signal#equals(Object):::Compares the equality of two Signal objects.:::if->return->if->return->other1->return->iSignal->equals
Signal#hashCode():::Returns a hashcode for this Signal.:::return->getNumber
Signal#toString():::Returns a string representation of this signal:::return->iSignal->toString
Signal#handle(Signal, SignalHandler):::Registers a signal handler.:::oldHandler->InternalMiscHandler->of->handle->return->SunMiscHandler->of
Signal#raise(Signal):::Raises a signal in the current process.:::raise
SignalHandler#handle(Signal):::Handle the given signal:::
Unsafe#getUnsafe():::Provides the caller with the capability of performing unsafe operations:::caller->Reflection->getCallerClass->if->VM->caller->getClassLoader->isSystemDomainLoader->throw->new->SecurityException->return
Unsafe#getInt(Object, long):::Fetches a value from a given Java variable:::return->theInternalUnsafe->getInt
Unsafe#putInt(Object, long, int):::Stores a value into a given Java variable:::theInternalUnsafe->putInt
Unsafe#getObject(Object, long):::Fetches a reference value from a given Java variable.:::return->theInternalUnsafe->getObject
Unsafe#putObject(Object, long, Object):::Stores a reference value into a given Java variable:::theInternalUnsafe->putObject
Unsafe#getByte(long):::Fetches a value from a given memory address:::return->theInternalUnsafe->getByte
Unsafe#putByte(long, byte):::Stores a value into a given memory address:::theInternalUnsafe->putByte
Unsafe#getAddress(long):::Fetches a native pointer from a given memory address:::return->theInternalUnsafe->getAddress
Unsafe#putAddress(long, long):::Stores a native pointer into a given memory address:::theInternalUnsafe->putAddress
Unsafe#allocateMemory(long):::Allocates a new block of native memory, of the given size in bytes:::return->theInternalUnsafe->allocateMemory
Unsafe#reallocateMemory(long, long):::Resizes a new block of native memory, to the given size in bytes:::return->theInternalUnsafe->reallocateMemory
Unsafe#setMemory(Object, long, long, byte):::Sets all bytes in a given block of memory to a fixed value (usually zero):::theInternalUnsafe->setMemory
Unsafe#setMemory(long, long, byte):::Sets all bytes in a given block of memory to a fixed value (usually zero):::theInternalUnsafe->setMemory
Unsafe#copyMemory(Object, long, Object, long, long):::Sets all bytes in a given block of memory to a copy of another block:::theInternalUnsafe->copyMemory
Unsafe#copyMemory(long, long, long):::Sets all bytes in a given block of memory to a copy of another block:::theInternalUnsafe->copyMemory
Unsafe#freeMemory(long):::Disposes of a block of native memory, as obtained from #allocateMemory or #reallocateMemory:::theInternalUnsafe->freeMemory
Unsafe#objectFieldOffset(Field):::Reports the location of a given field in the storage allocation of its class:::return->theInternalUnsafe->objectFieldOffset
Unsafe#staticFieldOffset(Field):::Reports the location of a given static field, in conjunction with #staticFieldBase:::return->theInternalUnsafe->staticFieldOffset
Unsafe#staticFieldBase(Field):::Reports the location of a given static field, in conjunction with #staticFieldOffset:::return->theInternalUnsafe->staticFieldBase
Unsafe#shouldBeInitialized(Class):::Detects if the given class may need to be initialized:::return->theInternalUnsafe->shouldBeInitialized
Unsafe#ensureClassInitialized(Class):::Ensures the given class has been initialized:::theInternalUnsafe->ensureClassInitialized
Unsafe#arrayBaseOffset(Class):::Reports the offset of the first element in the storage allocation of a given array class:::return->theInternalUnsafe->arrayBaseOffset
Unsafe#arrayIndexScale(Class):::Reports the scale factor for addressing elements in the storage allocation of a given array class:::return->theInternalUnsafe->arrayIndexScale
Unsafe#addressSize():::Reports the size in bytes of a native pointer, as stored via #putAddress:::return->theInternalUnsafe->addressSize
Unsafe#pageSize():::Reports the size in bytes of a native memory page (whatever that is):::return->theInternalUnsafe->pageSize
Unsafe#defineAnonymousClass(Class, byte[], Object[]):::Defines a class but does not make it known to the class loader or system dictionary:::return->theInternalUnsafe->defineAnonymousClass
Unsafe#allocateInstance(Class):::Allocates an instance but does not run any constructor:::return->theInternalUnsafe->allocateInstance
Unsafe#throwException(Throwable):::Throws the exception without telling the verifier.:::theInternalUnsafe->throwException
Unsafe#compareAndSwapObject(Object, long, Object, Object):::Atomically updates Java variable to x if it is currently holding expected:::return->theInternalUnsafe->compareAndSetObject
Unsafe#compareAndSwapInt(Object, long, int, int):::Atomically updates Java variable to x if it is currently holding expected:::return->theInternalUnsafe->compareAndSetInt
Unsafe#compareAndSwapLong(Object, long, long, long):::Atomically updates Java variable to x if it is currently holding expected:::return->theInternalUnsafe->compareAndSetLong
Unsafe#getObjectVolatile(Object, long):::Fetches a reference value from a given Java variable, with volatile load semantics:::return->theInternalUnsafe->getObjectVolatile
Unsafe#putObjectVolatile(Object, long, Object):::Stores a reference value into a given Java variable, with volatile store semantics:::theInternalUnsafe->putObjectVolatile
Unsafe#getIntVolatile(Object, long):::Volatile version of #getInt(Object, long):::return->theInternalUnsafe->getIntVolatile
Unsafe#putIntVolatile(Object, long, int):::Volatile version of #putInt(Object, long, int):::theInternalUnsafe->putIntVolatile
Unsafe#getBooleanVolatile(Object, long):::Volatile version of #getBoolean(Object, long):::return->theInternalUnsafe->getBooleanVolatile
Unsafe#putBooleanVolatile(Object, long, boolean):::Volatile version of #putBoolean(Object, long, boolean):::theInternalUnsafe->putBooleanVolatile
Unsafe#getByteVolatile(Object, long):::Volatile version of #getByte(Object, long):::return->theInternalUnsafe->getByteVolatile
Unsafe#putByteVolatile(Object, long, byte):::Volatile version of #putByte(Object, long, byte):::theInternalUnsafe->putByteVolatile
Unsafe#getShortVolatile(Object, long):::Volatile version of #getShort(Object, long):::return->theInternalUnsafe->getShortVolatile
Unsafe#putShortVolatile(Object, long, short):::Volatile version of #putShort(Object, long, short):::theInternalUnsafe->putShortVolatile
Unsafe#getCharVolatile(Object, long):::Volatile version of #getChar(Object, long):::return->theInternalUnsafe->getCharVolatile
Unsafe#putCharVolatile(Object, long, char):::Volatile version of #putChar(Object, long, char):::theInternalUnsafe->putCharVolatile
Unsafe#getLongVolatile(Object, long):::Volatile version of #getLong(Object, long):::return->theInternalUnsafe->getLongVolatile
Unsafe#putLongVolatile(Object, long, long):::Volatile version of #putLong(Object, long, long):::theInternalUnsafe->putLongVolatile
Unsafe#getFloatVolatile(Object, long):::Volatile version of #getFloat(Object, long):::return->theInternalUnsafe->getFloatVolatile
Unsafe#putFloatVolatile(Object, long, float):::Volatile version of #putFloat(Object, long, float):::theInternalUnsafe->putFloatVolatile
Unsafe#getDoubleVolatile(Object, long):::Volatile version of #getDouble(Object, long):::return->theInternalUnsafe->getDoubleVolatile
Unsafe#putDoubleVolatile(Object, long, double):::Volatile version of #putDouble(Object, long, double):::theInternalUnsafe->putDoubleVolatile
Unsafe#putOrderedObject(Object, long, Object):::Version of #putObjectVolatile(Object, long, Object) that does not guarantee immediate visibility of the store to other threads:::theInternalUnsafe->putObjectRelease
Unsafe#putOrderedInt(Object, long, int):::Ordered/Lazy version of #putIntVolatile(Object, long, int):::theInternalUnsafe->putIntRelease
Unsafe#putOrderedLong(Object, long, long):::Ordered/Lazy version of #putLongVolatile(Object, long, long):::theInternalUnsafe->putLongRelease
Unsafe#unpark(Object):::Unblocks the given thread blocked on park, or, if it is not blocked, causes the subsequent call to park not to block:::theInternalUnsafe->unpark
Unsafe#park(boolean, long):::Blocks current thread, returning when a balancing unpark occurs, or a balancing unpark has already occurred, or the thread is interrupted, or, if not absolute and time is not zero, the given time nanoseconds have elapsed, or if absolute, the given deadline in milliseconds since Epoch has passed, or spuriously (i.e., returning for no "reason"):::theInternalUnsafe->park
Unsafe#getLoadAverage(double[], int):::Gets the load average in the system run queue assigned to the available processors averaged over various periods of time:::return->theInternalUnsafe->getLoadAverage
Unsafe#getAndAddInt(Object, long, int):::Atomically adds the given value to the current value of a field or array element within the given object o at the given offset.:::return->theInternalUnsafe->getAndAddInt
Unsafe#getAndAddLong(Object, long, long):::Atomically adds the given value to the current value of a field or array element within the given object o at the given offset.:::return->theInternalUnsafe->getAndAddLong
Unsafe#getAndSetInt(Object, long, int):::Atomically exchanges the given value with the current value of a field or array element within the given object o at the given offset.:::return->theInternalUnsafe->getAndSetInt
Unsafe#getAndSetLong(Object, long, long):::Atomically exchanges the given value with the current value of a field or array element within the given object o at the given offset.:::return->theInternalUnsafe->getAndSetLong
Unsafe#getAndSetObject(Object, long, Object):::Atomically exchanges the given reference value with the current reference value of a field or array element within the given object o at the given offset.:::return->theInternalUnsafe->getAndSetObject
Unsafe#loadFence():::Ensures that loads before the fence will not be reordered with loads and stores after the fence; a "LoadLoad plus LoadStore barrier":::theInternalUnsafe->loadFence
Unsafe#storeFence():::Ensures that loads and stores before the fence will not be reordered with stores after the fence; a "StoreStore plus LoadStore barrier":::theInternalUnsafe->storeFence
Unsafe#fullFence():::Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence:::theInternalUnsafe->fullFence
Unsafe#invokeCleaner(java.nio.ByteBuffer):::Invokes the given direct byte buffer's cleaner, if any.:::if->directBuffer->isDirect->throw->new->IllegalArgumentException->theInternalUnsafe->invokeCleaner
