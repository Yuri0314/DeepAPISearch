AuthCache#put(String, AuthCacheValue):::Put an entry in the cache:::
AuthCache#get(String, String):::Get an entry from the cache based on pkey as described above, but also using a pathname (skey) and the cache must return an entry if skey is a sub-path of the AuthCacheValue.path field.:::
AuthCache#remove(String, AuthCacheValue):::remove the entry from the cache whose pkey is specified and whose path is equal to entry.path:::
AuthCacheImpl#setMap(HashMap>)::: auth cache impl set map:::
AuthCacheImpl#put(String, AuthCacheValue)::: auth cache impl put:::list->hashtable->get->skey->value->getPath->if->new->LinkedList<AuthCacheValue>->hashtable->put->iter->list->listIterator->while->iter->hasNext->inf->iter->next->if->startsWith->iter->remove->iter->add
AuthCacheImpl#get(String, String)::: auth cache impl get:::result->list->hashtable->get->if->list->size->return->if->return->list->get->iter->list->listIterator->while->iter->hasNext->inf->iter->next->if->skey->startsWith->return->return
AuthCacheImpl#remove(String, AuthCacheValue)::: auth cache impl remove:::list->hashtable->get->if->return->if->list->clear->return->iter->list->listIterator->while->iter->hasNext->inf->iter->next->if->entry->equals->iter->remove
AuthCacheValue#setAuthCache(AuthCache)::: auth cache value set auth cache:::
AuthCacheValue#getAuthType():::Proxy or Server:::
AuthCacheValue#getAuthScheme():::Authentication scheme:::
AuthCacheValue#getHost():::name of server/proxy:::
AuthCacheValue#getPort():::portnumber of server/proxy:::
AuthCacheValue#getRealm():::realm of authentication if known:::
AuthCacheValue#getPath():::root path of realm or the request path if the root is not known yet.:::
AuthCacheValue#getProtocolScheme():::returns http or https:::
AuthCacheValue#credentials():::the credentials associated with this authentication:::
AuthenticationHeader#toString()::: authentication header to string:::return
AuthenticationHeader#getHttpCallerInfo()::: authentication header get http caller info:::return
AuthenticationHeader#parse(Set)::: authentication header parse:::iter->rsp->multiValueIterator->while->iter->hasNext->raw->iter->next->hp->new->HeaderParser->keys->hp->keys->i->lastSchemeIndex->for->keys->hasNext->if->hpn->hp->subsequence->scheme->hpn->findKey->if->disabledSchemes->contains->schemes->new->SchemeMapValue->put->v->if->schemes->get->if->tmp->schemes->get->if->if->NegotiateAuthentication->new->HttpCallerInfo->isSupported->if->tmp->schemes->get->if->if->NegotiateAuthentication->new->HttpCallerInfo->isSupported->if->if->schemes->get->if->schemes->get->schemes->get->else->if->authPref->equals->if
AuthenticationHeader#headerParser():::return a header parser containing the preferred authentication scheme (only):::return
AuthenticationHeader#scheme():::return the name of the preferred scheme:::if->return->preferred->findKey->else->return
AuthenticationHeader#raw()::: authentication header raw:::return
AuthenticationHeader#isPresent():::returns true is the header exists and contains a recognised scheme:::return
AuthenticationInfo#credentials()::: authentication info credentials:::return
AuthenticationInfo#getAuthType()::: authentication info get auth type:::return
AuthenticationInfo#getAuthScheme()::: authentication info get auth scheme:::return
AuthenticationInfo#getHost()::: authentication info get host:::return
AuthenticationInfo#getPort()::: authentication info get port:::return
AuthenticationInfo#getRealm()::: authentication info get realm:::return
AuthenticationInfo#getPath()::: authentication info get path:::return
AuthenticationInfo#getProtocolScheme()::: authentication info get protocol scheme:::return
AuthenticationInfo#useAuthCache():::Whether we should cache this instance in the AuthCache:::return
AuthenticationInfo#requestIsInProgress(String)::: authentication info request is in progress:::if->return->synchronized->t->c->Thread->currentThread->if->requests->get->requests->put->return->if->return->while->requests->containsKey->try->requests->wait->catch->finally->return
AuthenticationInfo#requestCompleted(String)::: authentication info request completed:::synchronized->thread->requests->get->if->Thread->currentThread->waspresent->requests->remove->requests->notifyAll
AuthenticationInfo#clone()::: authentication info clone:::try->return->super->clone->catch->return->finally
AuthenticationInfo#getAuthenticatorKey():::The java.net.Authenticator#getKey(java.net.Authenticator) key of the authenticator that was used to obtain the credentials.:::return
AuthenticationInfo#reducePath(String)::: authentication info reduce path:::sepIndex->urlPath->lastIndexOf->targetSuffixIndex->urlPath->lastIndexOf->if->if->return->urlPath->substring->else->return->else->return
AuthenticationInfo#getServerAuth(URL, String):::Returns info for the URL, for an HTTP server auth:::port->url->getPort->if->url->getDefaultPort->key->url->getProtocol->toLowerCase->url->getHost->toLowerCase->return->getAuth
AuthenticationInfo#getServerAuthKey(URL, String, AuthScheme, String):::Returns info for the URL, for an HTTP server auth:::port->url->getPort->if->url->getDefaultPort->key->url->getProtocol->toLowerCase->url->getHost->toLowerCase->return
AuthenticationInfo#getServerAuth(String)::: authentication info get server auth:::cached->getAuth->if->requestIsInProgress->getAuth->return
AuthenticationInfo#getAuth(String, URL):::Return the AuthenticationInfo object from the cache if it's path is a substring of the supplied URLs path.:::if->return->cache->get->else->return->cache->url->getPath->get
AuthenticationInfo#getProxyAuth(String, int, String):::Returns a firewall authentication, for the given host/port:::key->host->toLowerCase->result->cache->get->return
AuthenticationInfo#getProxyAuthKey(String, int, String, AuthScheme, String):::Returns a firewall authentication, for the given host/port and realm:::key->host->toLowerCase->return
AuthenticationInfo#getProxyAuth(String)::: authentication info get proxy auth:::cached->cache->get->if->requestIsInProgress->cache->get->return
AuthenticationInfo#addToCache():::Add this authentication to the cache:::key->cacheKey->if->useAuthCache->cache->put->if->supportsPreemptiveAuthorization->cache->cacheKey->put->endAuthRequest
AuthenticationInfo#endAuthRequest(String)::: authentication info end auth request:::if->return->synchronized->requestCompleted
AuthenticationInfo#removeFromCache():::Remove this authentication from the cache:::cache->cacheKey->remove->if->supportsPreemptiveAuthorization->cache->cacheKey->remove
AuthenticationInfo#supportsPreemptiveAuthorization()::: authentication info supports preemptive authorization:::
AuthenticationInfo#getHeaderName()::: authentication info get header name:::if->return->else->return
AuthenticationInfo#getHeaderValue(URL, String):::Calculates and returns the authentication header value based on the stored authentication parameters:::
AuthenticationInfo#setHeaders(HttpURLConnection, HeaderParser, String):::Set header(s) on the given connection:::
AuthenticationInfo#isAuthorizationStale(String):::Check if the header indicates that the current auth:::
AuthenticationInfo#cacheKey(boolean):::Give a key for hash table lookups.:::authenticatorKey->getAuthenticatorKey->if->return->else->return
AuthenticationInfo#readObject(ObjectInputStream)::: authentication info read object:::s->defaultReadObject->s2->toCharArray->new->PasswordAuthentication->if
AuthenticationInfo#writeObject(java.io.ObjectOutputStream)::: authentication info write object:::Objects->requireNonNull->pw->getUserName->pw->getPassword->new->String->s->defaultWriteObject
AuthenticatorKeys#computeKey(Authenticator)::: authenticator keys compute key:::return->System->identityHashCode->IDS->incrementAndGet->a->getClass->getName
AuthenticatorKeys#getKey(Authenticator):::Returns a key for the given authenticator.:::if->return->return->authenticatorKeyAccess->getKey
AuthenticatorKeys.AuthenticatorKeyAccess#getKey(Authenticator)::: authenticator key access get key:::
AuthenticatorKeys#setAuthenticatorKeyAccess(AuthenticatorKeyAccess)::: authenticator keys set authenticator key access:::if
BasicAuthentication#supportsPreemptiveAuthorization()::: basic authentication supports preemptive authorization:::return
BasicAuthentication#setHeaders(HttpURLConnection, HeaderParser, String):::Set header(s) on the given connection:::conn->getHeaderName->getHeaderValue->setAuthenticationProperty->return
BasicAuthentication#getHeaderValue(URL, String)::: basic authentication get header value:::return
BasicAuthentication#isAuthorizationStale(String):::For Basic Authentication, the security parameters can never be stale:::return
BasicAuthentication#getRootPath(String, String)::: basic authentication get root path:::index->toindex->try->new->URI->normalize->getPath->new->URI->normalize->getPath->catch->finally->while->opath->length->opath->indexOf->if->opath->regionMatches->else->return->opath->substring->return
DigestAuthentication.Parameters#authQop()::: parameters auth qop:::return
DigestAuthentication.Parameters#incrementNC()::: parameters increment c:::
DigestAuthentication.Parameters#getNCCount()::: parameters get count:::return
DigestAuthentication.Parameters#getCnonce()::: parameters get cnonce:::if->setNewCnonce->return
DigestAuthentication.Parameters#setNewCnonce()::: parameters set new cnonce:::bb->new->byteArr->cc->new->charArr->random->nextBytes->for->i->new->String
DigestAuthentication.Parameters#setQop(String)::: parameters set qop:::if->items->qop->split->foreach->if->item->trim->equalsIgnoreCase->return
DigestAuthentication.Parameters#getOpaque()::: parameters get opaque:::return
DigestAuthentication.Parameters#setOpaque(String)::: parameters set opaque:::
DigestAuthentication.Parameters#getNonce()::: parameters get nonce:::return
DigestAuthentication.Parameters#setNonce(String)::: parameters set nonce:::if->s->equals
DigestAuthentication.Parameters#getCachedHA1()::: parameters get cached a1:::if->return->else->return
DigestAuthentication.Parameters#setCachedHA1(String)::: parameters set cached a1:::
DigestAuthentication.Parameters#getAlgorithm()::: parameters get algorithm:::return
DigestAuthentication.Parameters#setAlgorithm(String)::: parameters set algorithm:::
DigestAuthentication#supportsPreemptiveAuthorization()::: digest authentication supports preemptive authorization:::return
DigestAuthentication#getHeaderValue(URL, String):::Recalculates the request-digest and returns it:::return->url->getFile->getHeaderValueImpl
DigestAuthentication#getHeaderValue(String, String):::Recalculates the request-digest and returns it:::return->getHeaderValueImpl
DigestAuthentication#isAuthorizationStale(String):::Check if the header indicates that the current auth:::p->new->HeaderParser->s->p->findValue->if->s->equals->return->newNonce->p->findValue->if->equals->return->params->setNonce->return
DigestAuthentication#setHeaders(HttpURLConnection, HeaderParser, String):::Set header(s) on the given connection.:::params->p->findValue->setNonce->params->p->findValue->setOpaque->params->p->findValue->setQop->uri->method->if->conn->tunnelState->HttpURLConnection->conn->getURL->connectRequestURI->else->try->conn->getRequestURI->catch->finally->conn->getMethod->if->return->if->authMethod->length->Character->authMethod->charAt->toUpperCase->authMethod->substring->toLowerCase->algorithm->p->findValue->if->equals->params->setAlgorithm->if->params->authQop->params->setNewCnonce->value->getHeaderValueImpl->if->conn->getHeaderName->setAuthenticationProperty->return->else->return
DigestAuthentication#getHeaderValueImpl(String, String)::: digest authentication get header value impl:::response->passwd->pw->getPassword->qop->params->authQop->opaque->params->getOpaque->cnonce->params->getCnonce->nonce->params->getNonce->algorithm->params->getAlgorithm->params->incrementNC->nccount->params->getNCCount->ncstring->if->Integer->toHexString->toLowerCase->len->ncstring->length->if->try->pw->getUserName->computeDigest->catch->return->finally->ncfield->if->algoS->qopS->if->else->value->pw->getUserName->if->if->if->return
DigestAuthentication#checkResponse(String, String, URL)::: digest authentication check response:::url->getFile->checkResponse
DigestAuthentication#checkResponse(String, String, String)::: digest authentication check response:::passwd->pw->getPassword->username->pw->getUserName->qop->params->authQop->opaque->params->getOpaque->cnonce->nonce->params->getNonce->algorithm->params->getAlgorithm->nccount->params->getNCCount->ncstring->if->throw->new->ProtocolException->if->Integer->toHexString->toUpperCase->len->ncstring->length->if->try->expected->computeDigest->p->new->HeaderParser->rspauth->p->findValue->if->throw->new->ProtocolException->if->rspauth->equals->throw->new->ProtocolException->nextnonce->p->findValue->if->equals->params->setNonce->catch->throw->new->ProtocolException->finally
DigestAuthentication#computeDigest(boolean, String, char[], String, String, String, String, String, String)::: digest authentication compute digest:::A1->HashA1->algorithm->params->getAlgorithm->md5sess->algorithm->equalsIgnoreCase->md->MessageDigest->getInstance->if->if->params->getCachedHA1->s->s1->encode->encode->params->setCachedHA1->else->encode->A2->if->else->HashA2->encode->combo->finalHash->if->params->authQop->else->encode->return
DigestAuthentication#encode(String, char[], MessageDigest)::: digest authentication encode:::try->md->src->getBytes->update->catch->finally->if->passwdBytes->new->byteArr->for->i->md->update->Arrays->fill->digest->md->digest->res->new->StringBuilder->for->i->return->res->toString
Handler#getDefaultPort()::: handler get default port:::return
Handler#openConnection(URL)::: handler open connection:::return->openConnection
Handler#openConnection(URL, Proxy)::: handler open connection:::return->new->HttpURLConnection
HttpAuthenticator#schemeSupported(String)::: http authenticator scheme supported:::
HttpAuthenticator#authString(URL, String, String)::: http authenticator auth string:::
HttpURLConnection#getNetProperty(String)::: http connection get net property:::pa->NetProperties->get->return->AccessController->doPrivileged
HttpURLConnection#schemesListToSet(String)::: http connection schemes list to set:::if->list->isEmpty->return->Collections->emptySet->s->new->HashSet<>->parts->list->split->foreach->s->part->toLowerCase->add->return
HttpURLConnection#privilegedRequestPasswordAuthentication(Authenticator, String, InetAddress, int, String, String, String, URL, RequestorType)::: http connection privileged request password authentication:::return->new->java.security.PrivilegedAction<>->doPrivileged
HttpURLConnection#isRestrictedHeader(String, String)::: http connection is restricted header:::if->return->key->toLowerCase->if->restrictedHeaderSet->contains->if->key->equals->value->equalsIgnoreCase->return->return->else->if->key->startsWith->return->return
HttpURLConnection#isExternalMessageHeaderAllowed(String, String)::: http connection is external message header allowed:::checkMessageHeader->if->isRestrictedHeader->return->return
HttpURLConnection#getHttpLogger()::: http connection get http logger:::return
HttpURLConnection#authObj()::: http connection auth obj:::return
HttpURLConnection#authObj(Object)::: http connection auth obj:::
HttpURLConnection#setAuthenticator(Authenticator)::: http connection set authenticator:::if->throw->new->IllegalStateException->Objects->requireNonNull->AuthenticatorKeys->getKey
HttpURLConnection#getAuthenticatorKey()::: http connection get authenticator key:::k->if->return->AuthenticatorKeys->getKey->return
HttpURLConnection#checkMessageHeader(String, String)::: http connection check message header:::LF->index->key->indexOf->index1->key->indexOf->if->throw->new->IllegalArgumentException->else->if->return->value->indexOf->while->if->value->length->c->value->charAt->if->value->indexOf->continue->throw->new->IllegalArgumentException
HttpURLConnection#setRequestMethod(String)::: http connection set request method:::if->throw->new->IllegalStateException->super->setRequestMethod
HttpURLConnection#writeRequests()::: http connection write requests:::if->tunnelState->setPreemptiveProxyAuthentication->if->if->checkURLFile->requests->getRequestURI->prepend->if->getUseCaches->requests->setIfNotSet->requests->setIfNotSet->requests->setIfNotSet->port->url->getPort->host->url->getHost->stripIPv6ZoneId->if->url->getDefaultPort->String->valueOf->reqHost->requests->findValue->if->reqHost->equalsIgnoreCase->checkSetHost->requests->set->requests->setIfNotSet->if->http->getHttpKeepAliveSet->if->tunnelState->requests->setIfNotSet->else->requests->setIfNotSet->else->requests->setIfNotSet->modTime->getIfModifiedSince->if->date->new->Date->fo->new->SimpleDateFormat->fo->TimeZone->getTimeZone->setTimeZone->requests->fo->format->setIfNotSet->sauth->AuthenticationInfo->getAuthenticatorKey->getServerAuth->if->sauth->supportsPreemptiveAuthorization->requests->sauth->getHeaderName->sauth->getHeaderValue->setIfNotSet->if->method->equals->streaming->requests->setIfNotSet->chunked->if->streaming->if->requests->set->else->if->requests->String->valueOf->set->else->if->requests->String->valueOf->set->else->if->synchronized->poster->close->requests->String->poster->size->valueOf->set->if->if->requests->findValue->requests->remove->if->logger->isLoggable->logger->warning->setCookieHeader->if->logger->isLoggable->logger->requests->toString->fine->http->streaming->writeRequests->if->ps->checkError->proxyHost->http->getProxyHostUsed->proxyPort->http->getProxyPortUsed->disconnectInternal->if->throw->new->IOException->else->if->setProxiedClient->else->setNewClient->http->getOutputStream->new->MessageHeader->writeRequests
HttpURLConnection#checkSetHost()::: http connection check set host:::s->System->getSecurityManager->if->name->s->getClass->getName->if->name->equals->name->equals->name->equals->name->equals->CHECK_SET_HOST->try->s->url->toExternalForm->checkConnect->catch->return->finally->return
HttpURLConnection#checkURLFile()::: http connection check file:::s->System->getSecurityManager->if->name->s->getClass->getName->if->name->equals->name->equals->name->equals->name->equals->CHECK_SUBPATH->try->s->url->toExternalForm->checkConnect->catch->throw->new->SecurityException->finally
HttpURLConnection#setNewClient(URL):::Create a new HttpClient object, bypassing the cache of HTTP client objects/connections.:::setNewClient
HttpURLConnection#setNewClient(URL, boolean):::Obtain a HttpsClient object:::HttpClient->New->http->setReadTimeout
HttpURLConnection#setProxiedClient(URL, String, int):::Create a new HttpClient object, set up so that it uses per-instance proxying to the given HTTP proxy:::setProxiedClient
HttpURLConnection#setProxiedClient(URL, String, int, boolean):::Obtain a HttpClient object, set up so that it uses per-instance proxying to the given HTTP proxy:::proxiedConnect
HttpURLConnection#proxiedConnect(URL, String, int, boolean)::: http connection proxied connect:::HttpClient->New->http->setReadTimeout
HttpURLConnection#checkHost(String)::: http connection check host:::if->if->h->indexOf->throw->new->MalformedURLException->return
HttpURLConnection#checkURL(URL)::: http connection check l:::if->if->u->toExternalForm->indexOf->throw->new->MalformedURLException->s->IPAddressUtil->checkAuthority->if->throw->new->MalformedURLException->return
HttpURLConnection#setDefaultAuthenticator(HttpAuthenticator)::: http connection set default authenticator:::
HttpURLConnection#openConnectionCheckRedirects(URLConnection):::opens a stream allowing redirects only to the same host.:::redir->redirects->in->a->do->if->setInstanceFollowRedirects->if->c->getInputStream->if->http->stat->http->getResponseCode->if->base->http->getURL->loc->http->getHeaderField->target->if->new->URL->http->disconnect->if->base->getProtocol->target->getProtocol->equals->base->getPort->target->getPort->hostsEqual->throw->new->SecurityException->target->openConnection->if->setAuthenticator->while->return
HttpURLConnection#hostsEqual(URL, URL)::: http connection hosts equal:::h1->u1->getHost->h2->u2->getHost->if->return->else->if->return->else->if->h1->equalsIgnoreCase->return->result->new->java.security.PrivilegedAction<>->doPrivileged->return
HttpURLConnection#connect()::: http connection connect:::synchronized->plainConnect
HttpURLConnection#checkReuseConnection()::: http connection check reuse connection:::if->return->if->http->getReadTimeout->setReadTimeout->return->return
HttpURLConnection#getHostAndPort(URL)::: http connection get host and port:::host->url->getHost->hostarg->try->AccessController->new->PrivilegedExceptionAction<>->doPrivileged->catch->finally->port->url->getPort->if->scheme->url->getProtocol->if->equals->return->else->return->return->Integer->toString
HttpURLConnection#plainConnect()::: http connection plain connect:::synchronized->if->return->p->URLtoSocketPermission->if->try->AccessController->new->PrivilegedExceptionAction<>->doPrivilegedWithCombiner->catch->throw->e->getException->finally->else->plainConnect0
HttpURLConnection#URLtoSocketPermission(URL)::: if the caller has a URLPermission for connecting to the  given URL, then return a SocketPermission which permits  access to that destination:::if->return->sm->System->getSecurityManager->if->return->newPerm->getHostAndPort->new->SocketPermission->actions->getRequestMethod->getUserSetHeaders->getHeaderNamesInList->urlstring->url->getProtocol->url->getAuthority->url->getPath->p->new->URLPermission->try->sm->checkPermission->return->catch->finally->return
HttpURLConnection#plainConnect0()::: http connection plain connect0:::if->getUseCaches->try->uri->ParseUtil->toURI->if->cacheHandler->getRequestMethod->getUserSetHeaders->getHeaders->get->if->uri->getScheme->equalsIgnoreCase->if->logger->isLoggable->logger->getRequestMethod->finest->logger->cachedResponse->toString->finest->if->cachedResponse->getHeaders->mapToMessageHeader->cachedResponse->getBody->catch->finally->if->return->else->try->if->sel->new->java.security.PrivilegedAction<>->doPrivileged->if->uri->toURI->if->logger->isLoggable->logger->finest->it->sel->select->iterator->p->while->it->hasNext->it->next->try->if->getNewHttpClient->http->setReadTimeout->else->getNewHttpClient->http->setReadTimeout->if->logger->isLoggable->if->logger->p->toString->finest->break->catch->if->sel->p->address->connectFailed->if->it->hasNext->throw->else->throw->continue->finally->else->if->getNewHttpClient->http->setReadTimeout->else->getNewHttpClient->http->setReadTimeout->else->if->getNewHttpClient->http->setReadTimeout->else->getNewHttpClient->http->setReadTimeout->http->getOutputStream->catch->throw->finally
HttpURLConnection#getNewHttpClient(URL, Proxy, int)::: http connection get new http client:::return->HttpClient->New
HttpURLConnection#getNewHttpClient(URL, Proxy, int, boolean)::: http connection get new http client:::return->HttpClient->New
HttpURLConnection#expect100Continue()::: http connection expect100 continue:::oldTimeout->http->getReadTimeout->enforceTimeOut->timedOut->if->http->setReadTimeout->try->http->parseHTTP->catch->if->throw->http->setIgnoreContinue->finally->if->resp->responses->getValue->if->resp->startsWith->sa->resp->split->try->if->Integer->parseInt->catch->finally->if->throw->new->ProtocolException->http->setReadTimeout->responses->reset
HttpURLConnection#getOutputStream()::: http connection get output stream:::p->URLtoSocketPermission->if->try->return->AccessController->new->PrivilegedExceptionAction<>->doPrivilegedWithCombiner->catch->throw->e->getException->finally->else->return->getOutputStream0
HttpURLConnection#getOutputStream0()::: http connection get output stream0:::try->if->throw->new->ProtocolException->if->method->equals->if->equals->url->getProtocol->equals->throw->new->ProtocolException->if->throw->new->ProtocolException->if->checkReuseConnection->connect->expectContinue->expects->requests->findValue->if->equalsIgnoreCase->streaming->http->setIgnoreContinue->if->streaming->writeRequests->if->expect100Continue->http->getOutputStream->if->streaming->if->if->new->ChunkedOutputStream->new->StreamingOutputStream->else->length->if->else->if->new->StreamingOutputStream->return->else->if->new->PosterOutputStream->return->catch->disconnectInternal->throw->i->disconnectInternal->throw->disconnectInternal->throw->finally
HttpURLConnection#streaming()::: http connection streaming:::return
HttpURLConnection#setCookieHeader()::: http connection set cookie header:::if->synchronized->if->k->requests->getKey->if->requests->getValue->requests->getKey->if->requests->getValue->requests->remove->requests->remove->uri->ParseUtil->toURI->if->if->logger->isLoggable->logger->finest->cookies->cookieHandler->requests->getHeaders->get->if->cookies->isEmpty->if->logger->isLoggable->logger->cookies->toString->finest->foreach->cookies->entrySet->key->entry->getKey->if->equalsIgnoreCase->equalsIgnoreCase->continue->l->entry->getValue->if->l->isEmpty->cookieValue->new->StringJoiner->foreach->cookieValue->add->requests->cookieValue->toString->add->if->k->if->requests->getKey->requests->requests->getValue->set->else->requests->set->if->k->if->requests->getKey->requests->requests->getValue->set->else->requests->set
HttpURLConnection#getInputStream()::: http connection get input stream:::p->URLtoSocketPermission->if->try->return->AccessController->new->PrivilegedExceptionAction<>->doPrivilegedWithCombiner->catch->throw->e->getException->finally->else->return->getInputStream0
HttpURLConnection#getInputStream0()::: http connection get input stream0:::if->throw->new->ProtocolException->if->if->throw->new->RuntimeException->else->throw->getChainedException->if->return->if->streaming->if->getOutputStream->strOutputStream->close->if->strOutputStream->writtenOK->throw->new->IOException->redirects->respCode->cl->serverAuthentication->proxyAuthentication->srvHdr->inNegotiate->inNegotiateProxy->requests->getKey->requests->getKey->try->do->if->checkReuseConnection->connect->if->return->meteredInput->ProgressMonitor->getDefault->shouldMeterInput->if->new->ProgressSource->pi->beginTracking->http->getOutputStream->if->streaming->writeRequests->http->parseHTTP->if->logger->isLoggable->logger->responses->toString->fine->b1->responses->filterNTLMResponses->b2->responses->filterNTLMResponses->if->if->logger->isLoggable->logger->fine->logger->responses->toString->fine->http->getInputStream->getResponseCode->if->disconnectInternal->throw->new->IOException->if->if->streaming->disconnectInternal->throw->new->HttpRetryException->dontUseNegotiate->iter->responses->multiValueIterator->while->iter->hasNext->value->iter->next->trim->if->value->equalsIgnoreCase->value->equalsIgnoreCase->if->else->break->authhdr->http->getProxyHostUsed->http->getProxyPortUsed->new->HttpCallerInfo->new->AuthenticationHeader->if->resetProxyAuthentication->if->disconnectInternal->continue->else->raw->responses->findValue->reset->if->proxyAuthentication->authhdr->headerParser->setHeaders->disconnectInternal->throw->new->IOException->if->serverAuthentication->srvHdr->headerParser->setHeaders->disconnectInternal->throw->new->IOException->continue->else->if->requests->remove->if->proxyAuthentication->addToCache->if->if->streaming->disconnectInternal->throw->new->HttpRetryException->dontUseNegotiate->iter->responses->multiValueIterator->while->iter->hasNext->value->iter->next->trim->if->value->equalsIgnoreCase->value->equalsIgnoreCase->if->else->break->new->HttpCallerInfo->new->AuthenticationHeader->raw->srvHdr->raw->if->if->serverAuthentication->getAuthScheme->if->serverAuthentication->isAuthorizationStale->disconnectWeb->requests->serverAuthentication->getHeaderName->serverAuthentication->getHeaderValue->set->setCookieHeader->continue->else->serverAuthentication->removeFromCache->getServerAuthentication->if->disconnectWeb->setCookieHeader->continue->else->reset->if->serverAuthentication->setHeaders->disconnectWeb->throw->new->IOException->setCookieHeader->continue->if->if->if->npath->AuthenticationInfo->url->getPath->reducePath->opath->if->opath->startsWith->npath->length->opath->length->BasicAuthentication->getRootPath->a->serverAuthentication->clone->serverAuthentication->removeFromCache->serverAuthentication->addToCache->else->srv->tok->new->StringTokenizer->realm->pw->while->tok->hasMoreTokens->path->tok->nextToken->try->u->new->URL->d->new->DigestAuthentication->d->addToCache->catch->finally->if->requests->remove->if->requests->remove->if->checkResponseCredentials->else->if->followRedirect->setCookieHeader->continue->try->Long->responses->findValue->parseLong->catch->finally->if->method->equals->if->pi->finishTracking->http->finished->new->EmptyInputStream->if->if->getUseCaches->uri->ParseUtil->toURI->if->uconn->if->uri->getScheme->equalsIgnoreCase->try->this->getClass->getField->get->catch->finally->cacheRequest->cacheHandler->put->if->http->setCacheRequest->new->HttpInputStream->if->new->HttpInputStream->if->if->throw->url->toString->new->FileNotFoundException->else->throw->url->toString->new->java.io.IOException->return->while->throw->new->ProtocolException->catch->disconnectInternal->throw->te->responses->findValue->if->http->isKeepingAlive->te->equalsIgnoreCase->ErrorStream->getErrorStream->throw->finally->if->AuthenticationInfo->endAuthRequest->if->AuthenticationInfo->endAuthRequest
HttpURLConnection#getChainedException(IOException)::: http connection get chained exception:::try->args->rememberedException->getMessage->chainedException->new->java.security.PrivilegedExceptionAction<>->doPrivileged->chainedException->initCause->return->catch->return->finally
HttpURLConnection#getErrorStream()::: http connection get error stream:::if->if->return->else->if->return->return
HttpURLConnection#resetProxyAuthentication(AuthenticationInfo, AuthenticationHeader):::set or reset proxy authentication info in request headers after receiving a 407 error:::if->proxyAuthentication->getAuthScheme->raw->auth->raw->if->proxyAuthentication->isAuthorizationStale->value->if->digestProxy->if->tunnelState->digestProxy->connectRequestURI->getHeaderValue->else->digestProxy->getRequestURI->getHeaderValue->else->proxyAuthentication->getHeaderValue->requests->proxyAuthentication->getHeaderName->set->return->else->proxyAuthentication->removeFromCache->getHttpProxyAuthentication->return
HttpURLConnection#tunnelState():::Returns the tunnel state.:::return
HttpURLConnection#setTunnelState(TunnelState):::Set the tunneling status.:::
HttpURLConnection#doTunneling():::establish a tunnel through proxy server:::retryTunnel->statusLine->respCode->proxyAuthentication->proxyHost->proxyPort->savedRequests->new->MessageHeader->inNegotiateProxy->try->setTunnelState->do->if->checkReuseConnection->proxiedConnect->sendCONNECTRequest->responses->reset->http->parseHTTP->if->logger->isLoggable->logger->responses->toString->fine->if->responses->filterNTLMResponses->if->logger->isLoggable->logger->fine->logger->responses->toString->fine->responses->getValue->st->new->StringTokenizer->st->nextToken->Integer->st->nextToken->trim->parseInt->if->dontUseNegotiate->iter->responses->multiValueIterator->while->iter->hasNext->value->iter->next->trim->if->value->equalsIgnoreCase->value->equalsIgnoreCase->if->else->break->authhdr->http->getProxyHostUsed->http->getProxyPortUsed->new->HttpCallerInfo->new->AuthenticationHeader->if->resetProxyAuthentication->if->http->getProxyHostUsed->http->getProxyPortUsed->disconnectInternal->continue->else->raw->responses->findValue->reset->if->proxyAuthentication->authhdr->headerParser->setHeaders->disconnectInternal->throw->new->IOException->continue->if->proxyAuthentication->addToCache->if->setTunnelState->break->disconnectInternal->setTunnelState->break->while->if->if->responses->reset->throw->new->IOException->catch->finally->if->AuthenticationInfo->endAuthRequest->responses->reset
HttpURLConnection#connectRequestURI(URL)::: http connection connect request i:::host->url->getHost->port->url->getPort->url->getDefaultPort->return
HttpURLConnection#sendCONNECTRequest():::send a CONNECT request for establishing a tunnel to proxy server:::port->url->getPort->requests->connectRequestURI->set->requests->setIfNotSet->host->url->getHost->if->url->getDefaultPort->String->valueOf->requests->setIfNotSet->requests->setIfNotSet->if->http->getHttpKeepAliveSet->requests->setIfNotSet->setPreemptiveProxyAuthentication->if->logger->isLoggable->logger->requests->toString->fine->http->writeRequests
HttpURLConnection#setPreemptiveProxyAuthentication(MessageHeader):::Sets pre-emptive proxy authentication in header:::pauth->AuthenticationInfo->http->getProxyHostUsed->http->getProxyPortUsed->getAuthenticatorKey->getProxyAuth->if->pauth->supportsPreemptiveAuthorization->value->if->digestProxy->if->tunnelState->digestProxy->connectRequestURI->getHeaderValue->else->digestProxy->getRequestURI->getHeaderValue->else->pauth->getHeaderValue->requests->pauth->getHeaderName->set
HttpURLConnection#getHttpProxyAuthentication(AuthenticationHeader):::Gets the authentication for an HTTP proxy, and applies it to the connection.:::ret->raw->authhdr->raw->host->http->getProxyHostUsed->port->http->getProxyPortUsed->if->authhdr->isPresent->p->authhdr->headerParser->realm->p->findValue->scheme->authhdr->scheme->authScheme->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->if->AuthenticationInfo->getAuthenticatorKey->getProxyAuthKey->AuthenticationInfo->getProxyAuth->if->switch->addr->try->finalHost->new->java.security.PrivilegedExceptionAction<>->doPrivileged->catch->finally->a->privilegedRequestPasswordAuthentication->if->getAuthenticatorKey->new->BasicAuthentication->break->url->getProtocol->privilegedRequestPasswordAuthentication->if->params->new->DigestAuthentication.Parameters->getAuthenticatorKey->new->DigestAuthentication->break->if->if->if->if->logger->finest->else->url->getProtocol->privilegedRequestPasswordAuthentication->if->getAuthenticatorKey->create->break->authhdr->getHttpCallerInfo->new->HttpCallerInfo->new->NegotiateAuthentication->break->authhdr->getHttpCallerInfo->new->HttpCallerInfo->new->NegotiateAuthentication->break->if->logger->isLoggable->logger->finest->throw->new->AssertionError->if->defaultAuth->schemeSupported->try->u->new->URL->a->defaultAuth->authString->if->getAuthenticatorKey->new->BasicAuthentication->catch->finally->if->if->ret->setHeaders->if->logger->isLoggable->logger->authhdr->toString->ret->toString->finer->return
HttpURLConnection#getServerAuthentication(AuthenticationHeader):::Gets the authentication for an HTTP server, and applies it to the connection.:::ret->raw->authhdr->raw->if->authhdr->isPresent->p->authhdr->headerParser->realm->p->findValue->scheme->authhdr->scheme->authScheme->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->else->if->equalsIgnoreCase->p->findValue->if->AuthenticationInfo->getAuthenticatorKey->getServerAuthKey->AuthenticationInfo->getServerAuth->addr->if->try->InetAddress->url->getHost->getByName->catch->finally->port->url->getPort->if->url->getDefaultPort->if->switch->authhdr->getHttpCallerInfo->new->HttpCallerInfo->new->NegotiateAuthentication->break->authhdr->getHttpCallerInfo->new->HttpCallerInfo->new->NegotiateAuthentication->break->a->url->getHost->url->getProtocol->privilegedRequestPasswordAuthentication->if->getAuthenticatorKey->new->BasicAuthentication->break->url->getHost->url->getProtocol->privilegedRequestPasswordAuthentication->if->new->DigestAuthentication.Parameters->getAuthenticatorKey->new->DigestAuthentication->break->if->url1->try->new->URL->catch->finally->if->if->NTLMAuthenticationProxy->isTrustedSite->if->logger->finest->else->url->getHost->url->getProtocol->privilegedRequestPasswordAuthentication->if->getAuthenticatorKey->create->break->if->logger->isLoggable->logger->finest->throw->new->AssertionError->if->defaultAuth->schemeSupported->a->defaultAuth->authString->if->getAuthenticatorKey->new->BasicAuthentication->if->if->ret->setHeaders->if->logger->isLoggable->logger->authhdr->toString->ret->toString->finer->return
HttpURLConnection#checkResponseCredentials(boolean)::: http connection check response credentials:::try->if->return->if->raw->responses->findValue->if->da->da->getRequestURI->checkResponse->if->raw->responses->findValue->if->da->da->checkResponse->if->catch->disconnectInternal->throw->finally
HttpURLConnection#getRequestURI()::: http connection get request i:::if->http->getURLFile->return
HttpURLConnection#followRedirect()::: http connection follow redirect:::if->getInstanceFollowRedirects->return->stat->getResponseCode->if->return->loc->getHeaderField->if->return->locUrl->try->new->URL->if->url->getProtocol->locUrl->getProtocol->equalsIgnoreCase->return->catch->new->URL->finally->locUrl0->p->URLtoSocketPermission->if->try->return->AccessController->new->PrivilegedExceptionAction<>->doPrivilegedWithCombiner->catch->throw->e->getException->finally->else->return->followRedirect0
HttpURLConnection#followRedirect0(String, int, URL)::: http connection follow redirect0:::disconnectInternal->if->streaming->throw->new->HttpRetryException->if->logger->isLoggable->logger->fine->new->MessageHeader->if->proxyHost->locUrl->getHost->proxyPort->locUrl->getPort->security->System->getSecurityManager->if->security->checkConnect->setProxiedClient->requests->getRequestURI->set->else->prevURL->if->method->equals->Boolean->getBoolean->new->MessageHeader->super->setRequestMethod->if->checkReuseConnection->connect->if->sameDestination->else->if->checkReuseConnection->connect->if->requests->getRequestURI->set->port->url->getPort->host->url->getHost->stripIPv6ZoneId->if->url->getDefaultPort->String->valueOf->requests->set->if->sameDestination->requests->remove->requests->remove->requests->remove->sauth->AuthenticationInfo->getAuthenticatorKey->getServerAuth->if->sauth->supportsPreemptiveAuthorization->requests->sauth->getHeaderName->sauth->getHeaderValue->setIfNotSet->return
HttpURLConnection#sameDestination(URL, URL)::: http connection same destination:::if->firstURL->getHost->secondURL->getHost->equalsIgnoreCase->return->firstPort->firstURL->getPort->if->firstURL->getDefaultPort->secondPort->secondURL->getPort->if->secondURL->getDefaultPort->if->return->return
HttpURLConnection#reset():::Reset (without disconnecting the TCP conn) in order to do another transaction with this instance:::is->http->getInputStream->if->method->equals->try->if->while->is->read->else->cl->n->cls->responses->findValue->if->try->Long->parseLong->catch->finally->for->i->catch->disconnectInternal->return->finally->try->if->is->close->catch->finally->new->MessageHeader
HttpURLConnection#disconnectWeb():::Disconnect from the web server at the first 401 error:::if->usingProxy->http->isKeepingAlive->reset->else->disconnectInternal
HttpURLConnection#disconnectInternal():::Disconnect from the server (for internal use):::if->pi->finishTracking->if->http->closeServer
HttpURLConnection#disconnect():::Disconnect from the server (public API):::if->pi->finishTracking->if->if->hc->ka->hc->isKeepingAlive->try->inputStream->close->catch->finally->if->hc->closeIdleConnection->else->http->setDoNotRetry->http->closeServer->if->cachedHeaders->reset
HttpURLConnection#usingProxy()::: http connection using proxy:::if->return->http->getProxyHostUsed->return
HttpURLConnection#filterHeaderField(String, String):::Returns a filtered version of the given headers value:::if->return->if->SET_COOKIE->equalsIgnoreCase->SET_COOKIE2->equalsIgnoreCase->if->value->length->return->access->SharedSecrets->getJavaNetHttpCookieAccess->retValue->new->StringJoiner->cookies->access->parse->foreach->if->cookie->isHttpOnly->retValue->access->header->add->return->retValue->toString->return
HttpURLConnection#getFilteredHeaderFields()::: http connection get filtered header fields:::if->return->headers->tmpMap->new->HashMap<>->if->cachedHeaders->getHeaders->else->responses->getHeaders->foreach->headers->entrySet->key->e->getKey->values->e->getValue->filteredVals->new->ArrayList<>->foreach->fVal->filterHeaderField->if->filteredVals->add->if->filteredVals->isEmpty->tmpMap->Collections->unmodifiableList->put->return->Collections->unmodifiableMap
HttpURLConnection#getHeaderField(String):::Gets a header field by name:::try->getInputStream->catch->finally->if->return->cachedHeaders->findValue->filterHeaderField->return->responses->findValue->filterHeaderField
HttpURLConnection#getHeaderFields():::Returns an unmodifiable Map of the header fields:::try->getInputStream->catch->finally->return->getFilteredHeaderFields
HttpURLConnection#getHeaderField(int):::Gets a header field by index:::try->getInputStream->catch->finally->if->return->cachedHeaders->getKey->cachedHeaders->getValue->filterHeaderField->return->responses->getKey->responses->getValue->filterHeaderField
HttpURLConnection#getHeaderFieldKey(int):::Gets a header field by index:::try->getInputStream->catch->finally->if->return->cachedHeaders->getKey->return->responses->getKey
HttpURLConnection#setRequestProperty(String, String):::Sets request property:::if->throw->new->IllegalStateException->if->throw->new->NullPointerException->if->isExternalMessageHeaderAllowed->requests->set->if->key->equalsIgnoreCase->userHeaders->set
HttpURLConnection#getUserSetHeaders()::: http connection get user set headers:::return
HttpURLConnection#addRequestProperty(String, String):::Adds a general request property specified by a key-value pair:::if->throw->new->IllegalStateException->if->throw->new->NullPointerException->if->isExternalMessageHeaderAllowed->requests->add->if->key->equalsIgnoreCase->userHeaders->add
HttpURLConnection#setAuthenticationProperty(String, String)::: http connection set authentication property:::checkMessageHeader->requests->set
HttpURLConnection#getRequestProperty(String)::: http connection get request property:::if->return->for->i->if->if->key->equalsIgnoreCase->return->if->key->equalsIgnoreCase->return->return->requests->findValue
HttpURLConnection#getRequestProperties():::Returns an unmodifiable Map of general request properties for this connection:::if->throw->new->IllegalStateException->if->return->requests->getHeaders->userCookiesMap->if->new->HashMap<>->if->userCookiesMap->Arrays->asList->put->if->userCookiesMap->Arrays->asList->put->return->requests->filterAndAddHeaders
HttpURLConnection#setConnectTimeout(int)::: http connection set connect timeout:::if->throw->new->IllegalArgumentException
HttpURLConnection#getConnectTimeout():::Returns setting for connect timeout:::return
HttpURLConnection#setReadTimeout(int):::Sets the read timeout to a specified timeout, in milliseconds:::if->throw->new->IllegalArgumentException
HttpURLConnection#getReadTimeout():::Returns setting for read timeout:::return
HttpURLConnection#getCookieHandler()::: http connection get cookie handler:::return
HttpURLConnection#getMethod()::: http connection get method:::return
HttpURLConnection#mapToMessageHeader(Map>)::: http connection map to message header:::headers->new->MessageHeader->if->map->isEmpty->return->foreach->map->entrySet->key->entry->getKey->values->entry->getValue->foreach->if->headers->prepend->else->headers->add->return
HttpURLConnection#stripIPv6ZoneId(String):::Returns the given host, without the IPv6 Zone Id, if present:::if->host->charAt->return->i->host->lastIndexOf->if->return->return->host->substring
HttpURLConnection.HttpInputStream#mark(int):::Marks the current position in this input stream:::super->mark->if
HttpURLConnection.HttpInputStream#reset():::Repositions this stream to the position at the time the mark method was last called on this input stream:::super->reset->if
HttpURLConnection.HttpInputStream#ensureOpen()::: http input stream ensure open:::if->throw->new->IOException
HttpURLConnection.HttpInputStream#read()::: http input stream read:::ensureOpen->try->b->new->byteArr->ret->read->return->catch->if->cacheRequest->abort->throw->finally
HttpURLConnection.HttpInputStream#read(byte[])::: http input stream read:::return->read
HttpURLConnection.HttpInputStream#read(byte[], int, int)::: http input stream read:::ensureOpen->try->newLen->super->read->nWrite->if->if->else->else->if->outputStream->write->if->return->catch->if->cacheRequest->abort->throw->finally
HttpURLConnection.HttpInputStream#skip(long)::: http input stream skip:::ensureOpen->remaining->nr->if->new->byteArr->localSkipBuffer->if->return->while->Math->min->read->if->break->return
HttpURLConnection.HttpInputStream#close()::: http input stream close:::if->return->try->if->if->read->cacheRequest->abort->else->outputStream->close->super->close->catch->if->cacheRequest->abort->throw->finally->checkResponseCredentials
HttpURLConnection.StreamingOutputStream#write(int)::: streaming output stream write:::checkError->if->throw->new->IOException->out->write
HttpURLConnection.StreamingOutputStream#write(byte[])::: streaming output stream write:::write
HttpURLConnection.StreamingOutputStream#write(byte[], int, int)::: streaming output stream write:::checkError->if->out->close->throw->new->IOException->out->write
HttpURLConnection.StreamingOutputStream#checkError()::: streaming output stream check error:::if->throw->new->IOException->if->throw->if->checkError->throw->new->IOException
HttpURLConnection.StreamingOutputStream#writtenOK()::: streaming output stream written k:::return
HttpURLConnection.StreamingOutputStream#close()::: streaming output stream close:::if->return->if->if->new->IOException->out->close->throw->super->flush->else->super->close->o->http->getOutputStream->o->write->o->write->o->flush
HttpURLConnection.ErrorStream#getErrorStream(InputStream, long, HttpClient)::: error stream get error stream:::if->return->try->oldTimeout->http->getReadTimeout->http->setReadTimeout->expected->isChunked->if->else->if->exp->buffer->new->byteArr->count->time->len->do->try->is->read->if->if->break->throw->new->IOException->catch->finally->while->http->setReadTimeout->if->return->else->if->is->close->return->ByteBuffer->wrap->new->ErrorStream->else->return->ByteBuffer->wrap->new->ErrorStream->return->catch->return->finally
HttpURLConnection.ErrorStream#available()::: error stream available:::if->return->buffer->remaining->else->return->buffer->remaining->is->available
HttpURLConnection.ErrorStream#read()::: error stream read:::b->new->byteArr->ret->read->return
HttpURLConnection.ErrorStream#read(byte[])::: error stream read:::return->read
HttpURLConnection.ErrorStream#read(byte[], int, int)::: error stream read:::rem->buffer->remaining->if->ret->buffer->get->return->else->if->return->else->return->is->read
HttpURLConnection.ErrorStream#close()::: error stream close:::if->is->close
EmptyInputStream#available()::: empty input stream available:::return
EmptyInputStream#read()::: empty input stream read:::return
NegotiateAuthentication#supportsPreemptiveAuthorization()::: negotiate authentication supports preemptive authorization:::return
NegotiateAuthentication#isSupported(HttpCallerInfo):::Find out if the HttpCallerInfo supports Negotiate protocol:::if->new->HashMap<>->hostname->hostname->toLowerCase->if->supported->containsKey->return->supported->get->neg->Negotiator->getNegotiator->if->supported->put->if->new->ThreadLocal<>->cache->get->put->return->else->supported->put->return
NegotiateAuthentication#getCache()::: negotiate authentication get cache:::if->return->return->cache->get
NegotiateAuthentication#useAuthCache()::: negotiate authentication use auth cache:::return->super->useAuthCache
NegotiateAuthentication#getHeaderValue(URL, String):::Not supported:::throw->new->RuntimeException
NegotiateAuthentication#isAuthorizationStale(String):::Check if the header indicates that the current auth:::return
NegotiateAuthentication#setHeaders(HttpURLConnection, HeaderParser, String):::Set header(s) on the given connection.:::try->response->incoming->parts->raw->split->if->Base64->getDecoder->decode->Base64->getEncoder->firstToken->nextToken->encodeToString->conn->getHeaderName->setAuthenticationProperty->return->catch->return->finally
NegotiateAuthentication#firstToken():::return the first token.:::cachedMap->getCache->if->cachedMap->getHost->get->if->cachedMap->getHost->remove->if->Negotiator->getNegotiator->if->ioe->new->IOException->throw->return->negotiator->firstToken
NegotiateAuthentication#nextToken(byte[]):::return more tokens:::return->negotiator->nextToken
Negotiator#getNegotiator(HttpCallerInfo)::: negotiator get negotiator:::clazz->c->try->Class->ClassLoader->getPlatformClassLoader->forName->clazz->getConstructor->catch->finest->return->throw->new->AssertionError->finally->try->return->c->newInstance->catch->finest->t->roe->getCause->if->finest->return->finally
Negotiator#firstToken()::: negotiator first token:::
Negotiator#nextToken(byte[])::: negotiator next token:::
Negotiator#finest(Exception)::: negotiator finest:::logger->HttpURLConnection->getHttpLogger->if->logger->isLoggable->logger->finest
NTLMAuthenticationProxy#create(boolean, URL, PasswordAuthentication, String)::: authentication proxy create:::try->return->fourArgCtr->newInstance->catch->finest->finally->return
NTLMAuthenticationProxy#create(boolean, String, int, PasswordAuthentication, String)::: authentication proxy create:::try->return->sixArgCtr->newInstance->catch->finest->finally->return
NTLMAuthenticationProxy#supportsTransparentAuth()::: authentication proxy supports transparent auth:::try->return->supportsTA->invoke->catch->finest->finally->return
NTLMAuthenticationProxy#isTrustedSite(URL)::: authentication proxy is trusted site:::try->return->isTrustedSite->invoke->catch->finest->finally->return
NTLMAuthenticationProxy#tryLoadNTLMAuthentication():::Loads the NTLM authentiation implementation through reflection:::cl->fourArg->sixArg->try->Class->forName->if->cl->getConstructor->cl->getConstructor->cl->getDeclaredMethod->cl->getDeclaredMethod->return->new->NTLMAuthenticationProxy->catch->finest->throw->new->AssertionError->finally->return
NTLMAuthenticationProxy#finest(Exception)::: authentication proxy finest:::logger->HttpURLConnection->getHttpLogger->if->logger->isLoggable->logger->finest
