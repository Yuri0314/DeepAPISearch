CollectedHeap#start():::Returns the lowest address of the heap.:::return->reservedRegion->start
CompactibleSpace#compactionTop():::May be used temporarily during a compaction phase.:::return->compactionTopField->getValue
ContiguousSpace#capacity():::In bytes:::return->end->bottom->minus
ContiguousSpace#used():::In bytes:::return->top->bottom->minus
ContiguousSpace#free():::In bytes:::return->end->top->minus
ContiguousSpace#usedRegion():::In a contiguous space we have a more obvious bound on what parts       contain objects.:::return->bottom->top->new->MemRegion
ContiguousSpace#getLiveRegions():::Returns regions of Space where live objects live:::res->new->ArrayList->res->bottom->top->new->MemRegion->add->return
ContiguousSpace#contains(Address):::Testers:::return->bottom->lessThanOrEqual->top->greaterThan
GenCollectedHeap#spec(int):::Package-private access to GenerationSpecs:::if->Assert->that->if->return->if->return->VMObjectFactory->youngGenSpecField->getAddress->newObject->else->return->VMObjectFactory->oldGenSpecField->getAddress->newObject
Generation#capacity():::The maximum number of object bytes the generation can currently       hold.:::
Generation#used():::The number of used bytes in the gen.:::
Generation#free():::The number of free bytes in the gen.:::
Generation#contiguousAvailable():::The largest number of contiguous free words in the generation,       including expansion:::
Generation#usedRegion():::Returns a region guaranteed to contain all the objects in the       generation.:::return->reserved
Generation#isInReserved(Address):::Returns "TRUE" iff "p" points into the reserved area of the      generation.:::return->reserved->contains
Generation#spaceIterate(SpaceClosure):::Equivalent to spaceIterate(blk, false):::spaceIterate
Generation#spaceIterate(SpaceClosure, boolean):::Iteration - do not use for time critical operations:::
Space#usedRegion():::Returns a subregion of the space containing all the objects in       the space.:::return->bottom->end->new->MemRegion
Space#bottomAsOopHandle():::Support for iteration over heap -- not sure how this will       interact with GC in reflective system, but necessary for the       debugging mechanism:::return->bottomField->getOopHandle
Space#nextOopHandle(OopHandle, long):::Support for iteration over heap -- not sure how this will       interact with GC in reflective system, but necessary for the       debugging mechanism:::return->handle->addOffsetToAsOopHandle
Space#getLiveRegions():::returns all MemRegions where live objects are:::
Space#capacity():::Returned value is in bytes:::return->end->bottom->minus
Space#used():::Returned value is in bytes:::
Space#free():::Returned value is in bytes:::
Space#contains(Address):::Testers:::return->bottom->lessThanOrEqual->end->greaterThan
