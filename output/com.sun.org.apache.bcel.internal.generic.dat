AALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitAALOAD
AASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitAASTORE
ACONST_NULL#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitTypedInstruction->v->visitACONST_NULL
ALOAD#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitALOAD
ANEWARRAY#accept(Visitor):::Call corresponding visitor method(s):::v->visitLoadClass->v->visitAllocationInstruction->v->visitExceptionThrower->v->visitStackProducer->v->visitTypedInstruction->v->visitCPInstruction->v->visitANEWARRAY
AnnotationElementValueGen#getElementValue():::Return immutable variant of this AnnotationElementValueGen:::return->super->getElementValueType->a->getAnnotation->getConstantPool->getConstantPool->new->AnnotationElementValue
AnnotationEntryGen#getAnnotation():::Retrieve an immutable version of this AnnotationGen:::a->cpool->getConstantPool->new->AnnotationEntry->foreach->a->element->getElementNameValuePair->addElementNameValuePair->return
AnnotationEntryGen#getValues():::Returns list of ElementNameValuePair objects:::return
AnnotationEntryGen#getAnnotationAttributes(ConstantPoolGen, AnnotationEntryGen[]):::Converts a list of AnnotationGen objects into a set of attributes that can be attached to the class file.:::if->return->new->AttributeArr->try->countVisible->countInvisible->foreach->if->a->isRuntimeVisible->else->rvaBytes->new->ByteArrayOutputStream->riaBytes->new->ByteArrayOutputStream->try->rvaDos->new->DataOutputStream->riaDos->new->DataOutputStream->rvaDos->writeShort->riaDos->writeShort->foreach->if->a->isRuntimeVisible->a->dump->else->a->dump->catch->finally->rvaData->rvaBytes->toByteArray->riaData->riaBytes->toByteArray->rvaIndex->riaIndex->if->cp->addUtf8->if->cp->addUtf8->newAttributes->new->ArrayList<>->if->newAttributes->new->ByteArrayInputStream->new->DataInputStream->cp->getConstantPool->new->RuntimeVisibleAnnotations->add->if->newAttributes->new->ByteArrayInputStream->new->DataInputStream->cp->getConstantPool->new->RuntimeInvisibleAnnotations->add->return->newAttributes->newAttributes->size->new->AttributeArr->toArray->catch->println->e->printStackTrace->finally->return
AnnotationEntryGen#getParameterAnnotationAttributes(ConstantPoolGen, List[]):::Annotations against a class are stored in one of four attribute kinds: - RuntimeVisibleParameterAnnotations - RuntimeInvisibleParameterAnnotations:::visCount->new->intArr->totalVisCount->invisCount->new->intArr->totalInvisCount->try->for->i->rvaBytes->new->ByteArrayOutputStream->try->rvaDos->new->DataOutputStream->rvaDos->writeByte->for->i->catch->finally->riaBytes->new->ByteArrayOutputStream->try->riaDos->new->DataOutputStream->riaDos->writeByte->for->i->catch->finally->rvaData->rvaBytes->toByteArray->riaData->riaBytes->toByteArray->rvaIndex->riaIndex->if->cp->addUtf8->if->cp->addUtf8->newAttributes->new->ArrayList<>->if->newAttributes->new->ByteArrayInputStream->new->DataInputStream->cp->getConstantPool->new->RuntimeVisibleParameterAnnotations->add->if->newAttributes->new->ByteArrayInputStream->new->DataInputStream->cp->getConstantPool->new->RuntimeInvisibleParameterAnnotations->add->return->newAttributes->newAttributes->size->new->AttributeArr->toArray->catch->e->getMessage->println->finally->return
ARETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitARETURN
ArrayElementValueGen#getElementValue():::Return immutable variant of this ArrayElementValueGen:::immutableData->evalues->size->new->ElementValueArr->i->foreach->element->getElementValue->return->super->getElementValueType->getConstantPool->getConstantPool->new->ArrayElementValue
ARRAYLENGTH#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackProducer->v->visitARRAYLENGTH
ASTORE#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitASTORE
ATHROW#accept(Visitor):::Call corresponding visitor method(s):::v->visitUnconditionalBranch->v->visitExceptionThrower->v->visitATHROW
BALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitBALOAD
BASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitBASTORE
BIPUSH#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->dump->out->writeByte
BIPUSH#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->setLength->bytes->readByte
BIPUSH#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitBIPUSH
BranchHandle#getBranchHandle(BranchInstruction):::Factory method.:::return->new->BranchHandle
BranchHandle#setTarget(InstructionHandle):::Pass new target to instruction.:::bi->setTarget
BranchHandle#updateTarget(InstructionHandle, InstructionHandle):::Update target of instruction.:::bi->updateTarget
BranchHandle#setInstruction(Instruction):::Set new contents:::super->setInstruction->if->throw->new->ClassGenException
BranchInstruction#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->getTargetOffset->if->isValidShort->throw->new->ClassGenException->out->writeShort
BranchInstruction#updatePosition(int, int):::Called by InstructionList.setPositions when setting the position for every instruction:::return
BranchInstruction#toString(boolean):::Long output format:  &lt;position in byte code&gt; &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" "("&lt;length of instruction&gt;")" "&lt;"&lt;target instruction&gt;"&gt;" "@"&lt;branch target offset&gt;:::s->super->toString->t->if->if->if->target->getInstruction->else->if->target->getInstruction->else->target->getPosition->else->if->target->getPosition->return
BranchInstruction#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->setLength->bytes->readShort
BranchInstruction#setTarget(InstructionHandle):::Set branch target:::notifyTarget
BranchInstruction#notifyTarget(InstructionHandle, InstructionHandle, InstructionTargeter):::Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen:::if->old_ih->removeTargeter->if->new_ih->addTargeter
BranchInstruction#dispose():::Inform target that it's not targeted anymore.:::setTarget
BREAKPOINT#accept(Visitor):::Call corresponding visitor method(s):::v->visitBREAKPOINT
CALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitCALOAD
CASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitCASTORE
CHECKCAST#accept(Visitor):::Call corresponding visitor method(s):::v->visitLoadClass->v->visitExceptionThrower->v->visitStackProducer->v->visitStackConsumer->v->visitTypedInstruction->v->visitCPInstruction->v->visitCHECKCAST
ClassElementValueGen#getElementValue():::Return immutable variant of this ClassElementValueGen:::return->super->getElementValueType->getConstantPool->getConstantPool->new->ClassElementValue
ClassGen#addInterface(String):::Add an interface to this class, i.e., this class has to implement it.:::interface_vec->add
ClassGen#removeInterface(String):::Remove an interface from this class.:::interface_vec->remove
ClassGen#setMajor(int):::Set major version number of class file, default value is 45 (JDK 1.1):::
ClassGen#setMinor(int):::Set minor version number of class file, default value is 3 (JDK 1.1):::
ClassGen#addAttribute(Attribute):::Add an attribute to this class.:::attribute_vec->add
ClassGen#addMethod(Method):::Add a method to this class.:::method_vec->add
ClassGen#addEmptyConstructor(int):::Convenience method:::il->new->InstructionList->il->append->il->cp->addMethodref->new->INVOKESPECIAL->append->il->append->mg->new->MethodGen->mg->setMaxStack->mg->getMethod->addMethod
ClassGen#addField(Field):::Add a field to this class.:::field_vec->add
ClassGen#removeAttribute(Attribute):::Remove an attribute from this class.:::attribute_vec->remove
ClassGen#removeMethod(Method):::Remove a method from this class.:::method_vec->remove
ClassGen#replaceMethod(Method, Method):::Replace given method with new one:::if->throw->new->ClassGenException->i->method_vec->indexOf->if->method_vec->add->else->method_vec->set
ClassGen#replaceField(Field, Field):::Replace given field with new one:::if->throw->new->ClassGenException->i->field_vec->indexOf->if->field_vec->add->else->field_vec->set
ClassGen#removeField(Field):::Remove a field to this class.:::field_vec->remove
ClassGen#addObserver(ClassObserver):::Add observer for this object.:::if->new->ArrayList<>->observers->add
ClassGen#removeObserver(ClassObserver):::Remove observer for this object.:::if->observers->remove
ClassGen#update():::Call notify() method on all observers:::if->foreach->observer->notify
ClassGen#equals(Object):::Return value as defined by given BCELComparator strategy:::return->_cmp->equals
ClassGen#hashCode():::Return value as defined by given BCELComparator strategy:::return->_cmp->hashCode
CodeExceptionGen#getCodeException(ConstantPoolGen):::Get CodeException object.<BR>  This relies on that the instruction list has already been dumped to byte code or or that the `setPositions' methods has been called for the instruction list.:::return->start_pc->getPosition->end_pc->getPosition->end_pc->getInstruction->getLength->handler_pc->getPosition->cp->addClass->new->CodeException
CodeExceptionGen#setCatchType(ObjectType):::Sets the type of the Exception to catch:::
CodeExceptionGen#getCatchType():::Gets the type of the Exception to catch, 'null' for ANY.:::return
ConstantPoolGen#adjustSize():::Resize internal array of constants.:::if->cs->new->ConstantArr->System->arraycopy
ConstantPoolGen#lookupString(String):::Look for ConstantString in ConstantPool containing String `str'.:::index->string_table->get->return
ConstantPoolGen#addString(String):::Add a new String constant to the ConstantPool, if it is not already in there.:::ret->if->lookupString->return->utf8->addUtf8->adjustSize->s->new->ConstantString->if->string_table->containsKey->string_table->new->Index->put->return
ConstantPoolGen#lookupClass(String):::Look for ConstantClass in ConstantPool named `str'.:::index->class_table->str->replace->get->return
ConstantPoolGen#addClass(String):::Add a new Class reference to the ConstantPool, if it is not already in there.:::return->str->replace->addClass_
ConstantPoolGen#addClass(ObjectType):::Add a new Class reference to the ConstantPool for a given type.:::return->type->getClassName->addClass
ConstantPoolGen#addArrayClass(ArrayType):::Add a reference to an array class (e.g:::return->type->getSignature->addClass_
ConstantPoolGen#lookupInteger(int):::Look for ConstantInteger in ConstantPool.:::for->i->return
ConstantPoolGen#addInteger(int):::Add a new Integer constant to the ConstantPool, if it is not already in there.:::ret->if->lookupInteger->return->adjustSize->new->ConstantInteger->return
ConstantPoolGen#lookupFloat(float):::Look for ConstantFloat in ConstantPool.:::bits->Float->floatToIntBits->for->i->return
ConstantPoolGen#addFloat(float):::Add a new Float constant to the ConstantPool, if it is not already in there.:::ret->if->lookupFloat->return->adjustSize->new->ConstantFloat->return
ConstantPoolGen#lookupUtf8(String):::Look for ConstantUtf8 in ConstantPool.:::index->utf8_table->get->return
ConstantPoolGen#addUtf8(String):::Add a new Utf8 constant to the ConstantPool, if it is not already in there.:::ret->if->lookupUtf8->return->adjustSize->new->ConstantUtf8->if->utf8_table->containsKey->utf8_table->new->Index->put->return
ConstantPoolGen#lookupLong(long):::Look for ConstantLong in ConstantPool.:::for->i->return
ConstantPoolGen#addLong(long):::Add a new long constant to the ConstantPool, if it is not already in there.:::ret->if->lookupLong->return->adjustSize->new->ConstantLong->return
ConstantPoolGen#lookupDouble(double):::Look for ConstantDouble in ConstantPool.:::bits->Double->doubleToLongBits->for->i->return
ConstantPoolGen#addDouble(double):::Add a new double constant to the ConstantPool, if it is not already in there.:::ret->if->lookupDouble->return->adjustSize->new->ConstantDouble->return
ConstantPoolGen#lookupNameAndType(String, String):::Look for ConstantNameAndType in ConstantPool.:::_index->n_a_t_table->get->return
ConstantPoolGen#addNameAndType(String, String):::Add a new NameAndType constant to the ConstantPool if it is not already in there.:::ret->name_index->signature_index->if->lookupNameAndType->return->adjustSize->addUtf8->addUtf8->new->ConstantNameAndType->key->if->n_a_t_table->containsKey->n_a_t_table->new->Index->put->return
ConstantPoolGen#lookupMethodref(String, String, String):::Look for ConstantMethodref in ConstantPool.:::index->cp_table->get->return
ConstantPoolGen#addMethodref(String, String, String):::Add a new Methodref constant to the ConstantPool, if it is not already in there.:::ret->class_index->name_and_type_index->if->lookupMethodref->return->adjustSize->addNameAndType->addClass->new->ConstantMethodref->key->if->cp_table->containsKey->cp_table->new->Index->put->return
ConstantPoolGen#lookupInterfaceMethodref(String, String, String):::Look for ConstantInterfaceMethodref in ConstantPool.:::index->cp_table->get->return
ConstantPoolGen#addInterfaceMethodref(String, String, String):::Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there.:::ret->class_index->name_and_type_index->if->lookupInterfaceMethodref->return->adjustSize->addClass->addNameAndType->new->ConstantInterfaceMethodref->key->if->cp_table->containsKey->cp_table->new->Index->put->return
ConstantPoolGen#lookupFieldref(String, String, String):::Look for ConstantFieldref in ConstantPool.:::index->cp_table->get->return
ConstantPoolGen#addFieldref(String, String, String):::Add a new Fieldref constant to the ConstantPool, if it is not already in there.:::ret->class_index->name_and_type_index->if->lookupFieldref->return->adjustSize->addClass->addNameAndType->new->ConstantFieldref->key->if->cp_table->containsKey->cp_table->new->Index->put->return
ConstantPoolGen#setConstant(int, Constant):::Use with care!:::
ConstantPoolGen#addConstant(Constant, ConstantPoolGen):::Import constant from another ConstantPool and return new index.:::constants->cp->getConstantPool->getConstantPool->switch->c->getTag->s->u8->s->getStringIndex->return->u8->getBytes->addString->s->u8->s->getNameIndex->return->u8->getBytes->addClass->n->u8->n->getNameIndex->u8_2->n->getSignatureIndex->return->u8->getBytes->u8_2->getBytes->addNameAndType->return->getBytes->addUtf8->return->getBytes->addDouble->return->getBytes->addFloat->return->getBytes->addLong->return->getBytes->addInteger->m->clazz->m->getClassIndex->n->m->getNameAndTypeIndex->u8->clazz->getNameIndex->class_name->u8->getBytes->replace->n->getNameIndex->name->u8->getBytes->n->getSignatureIndex->signature->u8->getBytes->switch->c->getTag->return->addInterfaceMethodref->return->addMethodref->return->addFieldref->throw->new->RuntimeException->throw->new->RuntimeException
CPInstruction#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->writeShort
CPInstruction#toString(boolean):::Long output format:  &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" "("&lt;length of instruction&gt;")" "&lt;"&lt; constant pool index&gt;"&gt;":::return->super->toString
CPInstruction#initFromFile(ByteSequence, boolean):::Read needed data (i.e., index) from file.:::bytes->readUnsignedShort->setIndex->super->setLength
CPInstruction#setIndex(int):::Set the index to constant pool.:::if->throw->new->ClassGenException
D2F#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitD2F
D2I#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitD2I
D2L#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitD2L
DADD#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDADD
DALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitDALOAD
DASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitDASTORE
DCMPG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitDCMPG
DCMPL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitDCMPL
DCONST#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitDCONST
DDIV#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDDIV
DLOAD#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitDLOAD
DMUL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDMUL
DNEG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDNEG
DREM#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDREM
DRETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitDRETURN
DSTORE#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitDSTORE
DSUB#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitDSUB
DUP#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitStackInstruction->v->visitDUP
DUP2#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitStackInstruction->v->visitDUP2
DUP2_X1#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackInstruction->v->visitDUP2_X1
DUP2_X2#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackInstruction->v->visitDUP2_X2
DUP_X1#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackInstruction->v->visitDUP_X1
DUP_X2#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackInstruction->v->visitDUP_X2
ElementValueGen#getElementValue():::Subtypes return an immutable variant of the ElementValueGen:::
ElementValueGen#copy(ElementValue, ConstantPoolGen, boolean):::Creates an (modifiable) ElementValueGen copy of an (immutable) ElementValue - constant pool is assumed correct.:::switch->value->getElementValueType->return->new->SimpleElementValueGen->return->new->EnumElementValueGen->return->new->AnnotationElementValueGen->return->new->ArrayElementValueGen->return->new->ClassElementValueGen->throw->value->getElementValueType->new->RuntimeException
ElementValuePairGen#getElementNameValuePair():::Retrieve an immutable version of this ElementNameValuePairGen:::immutableValue->value->getElementValue->return->cpool->getConstantPool->new->ElementValuePair
EnumElementValueGen#getElementValue():::Return immutable variant of this EnumElementValue:::getEnumTypeString->getEnumValueString->println->return->super->getElementValueType->getConstantPool->getConstantPool->new->EnumElementValue
F2D#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitF2D
F2I#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitF2I
F2L#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitF2L
FADD#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFADD
FALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitFALOAD
FASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitFASTORE
FCMPG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitFCMPG
FCMPL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitFCMPL
FCONST#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitFCONST
FDIV#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFDIV
FieldGen#setInitValue(String):::Set (optional) initial value of field, otherwise it will be set to null/0/false by the JVM automatically.:::ObjectType->getInstance->checkType->if
FieldGen#cancelInitValue():::Remove any initial value.:::
FieldGen#getField():::Get field object after having set up all necessary values.:::signature->getSignature->name_index->super->getConstantPool->super->getName->addUtf8->signature_index->super->getConstantPool->addUtf8->if->super->getType->checkType->index->addConstant->super->getConstantPool->addUtf8->super->getConstantPool->getConstantPool->new->ConstantValue->addAttribute->super->getConstantPool->addAnnotationsAsAttribute->return->super->getAccessFlags->getAttributes->super->getConstantPool->getConstantPool->new->Field
FieldGen#addObserver(FieldObserver):::Add observer for this object.:::if->new->ArrayList<>->observers->add
FieldGen#removeObserver(FieldObserver):::Remove observer for this object.:::if->observers->remove
FieldGen#update():::Call notify() method on all observers:::if->foreach->observer->notify
FieldGen#toString():::Return string representation close to declaration format, `public static final short MAX = 100', e.g..:::name->signature->access->Utility->super->getAccessFlags->accessToString->access->isEmpty->super->getType->toString->getName->buf->new->StringBuilder->buf->append->append->append->append->value->getInitValue->if->buf->append->append->return->buf->toString
FieldGen#equals(Object):::Return value as defined by given BCELComparator strategy:::return->bcelComparator->equals
FieldGen#hashCode():::Return value as defined by given BCELComparator strategy:::return->bcelComparator->hashCode
FieldGenOrMethodGen#addAttribute(Attribute):::Add an attribute to this method:::attribute_vec->add
FieldGenOrMethodGen#removeAttribute(Attribute):::Remove an attribute.:::attribute_vec->remove
FieldGenOrMethodGen#removeAttributes():::Remove all attributes.:::attribute_vec->clear
FieldOrMethod#getReferenceType(ConstantPoolGen):::Return the reference type representing the class, interface, or array class referenced by the instruction.:::cp->cpg->getConstantPool->cmr->cp->super->getIndex->getConstant->className->cp->cmr->getClassIndex->getConstantString->if->className->startsWith->return->Type->getType->className->replace->return->ObjectType->getInstance
FieldOrMethod#getLoadClassType(ConstantPoolGen):::Get the ObjectType of the method return or field.:::rt->getReferenceType->if->return->throw->rt->getSignature->new->ClassGenException
FLOAD#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitFLOAD
FMUL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFMUL
FNEG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFNEG
FREM#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFREM
FRETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitFRETURN
FSTORE#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitFSTORE
FSUB#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitFSUB
GETFIELD#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackConsumer->v->visitStackProducer->v->visitTypedInstruction->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitFieldInstruction->v->visitGETFIELD
GETSTATIC#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitExceptionThrower->v->visitTypedInstruction->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitFieldInstruction->v->visitGETSTATIC
GOTO#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->getTargetOffset->setIndex->_opcode->getOpcode->if->super->dump->else->super->getTargetOffset->setIndex->out->writeByte->out->super->getIndex->writeInt
GOTO#updatePosition(int, int):::Called in pass 2 of InstructionList.setPositions() in order to update the branch target, that may shift due to variable length instructions.:::i->getTargetOffset->getPosition->setPosition->if->Math->abs->super->setOpcode->old_length->super->getLength->super->setLength->return->super->getLength->return
GOTO#accept(Visitor):::Call corresponding visitor method(s):::v->visitVariableLengthInstruction->v->visitUnconditionalBranch->v->visitBranchInstruction->v->visitGotoInstruction->v->visitGOTO
GOTO_W#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->getTargetOffset->setIndex->out->super->getOpcode->writeByte->out->super->getIndex->writeInt
GOTO_W#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->bytes->readInt->setIndex->super->setLength
GOTO_W#accept(Visitor):::Call corresponding visitor method(s):::v->visitUnconditionalBranch->v->visitBranchInstruction->v->visitGotoInstruction->v->visitGOTO_W
I2B#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2B
I2C#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2C
I2D#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2D
I2F#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2F
I2L#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2L
I2S#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitI2S
IADD#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIADD
IALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitIALOAD
IAND#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIAND
IASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitIASTORE
ICONST#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitICONST
IDIV#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIDIV
IFEQ#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFEQ
IFGE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFGE
IFGT#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFGT
IFLE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFLE
IFLT#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFLT
IFNE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFNE
IFNONNULL#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFNONNULL
IFNULL#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIFNULL
IF_ACMPEQ#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ACMPEQ
IF_ACMPNE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ACMPNE
IF_ICMPEQ#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPEQ
IF_ICMPGE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPGE
IF_ICMPGT#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPGT
IF_ICMPLE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPLE
IF_ICMPLT#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPLT
IF_ICMPNE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitBranchInstruction->v->visitIfInstruction->v->visitIF_ICMPNE
IINC#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::if->out->writeByte->out->super->getOpcode->writeByte->if->out->super->getIndex->writeShort->out->writeShort->else->out->super->getIndex->writeByte->out->writeByte
IINC#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::if->super->setLength->super->bytes->readUnsignedShort->setIndexOnly->bytes->readShort->else->super->setLength->super->bytes->readUnsignedByte->setIndexOnly->bytes->readByte
IINC#setIndex(int):::Set index of local variable.:::if->throw->new->ClassGenException->super->setIndexOnly->setWide
IINC#setIncrement(int):::Set increment factor.:::setWide
IINC#accept(Visitor):::Call corresponding visitor method(s):::v->visitLocalVariableInstruction->v->visitIINC
ILOAD#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitILOAD
IMPDEP1#accept(Visitor):::Call corresponding visitor method(s):::v->visitIMPDEP1
IMPDEP2#accept(Visitor):::Call corresponding visitor method(s):::v->visitIMPDEP2
IMUL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIMUL
INEG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitINEG
INSTANCEOF#accept(Visitor):::Call corresponding visitor method(s):::v->visitLoadClass->v->visitExceptionThrower->v->visitStackProducer->v->visitStackConsumer->v->visitTypedInstruction->v->visitCPInstruction->v->visitINSTANCEOF
Instruction#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->writeByte
Instruction#toString(boolean):::Long output format:  &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" "("&lt;length of instruction&gt;")":::if->return->getName->return->getName
Instruction#copy():::Use with caution, since `BranchInstruction's have a `target' reference which is not copied correctly (only basic types are):::i->if->InstructionConst->this->getOpcode->getInstruction->else->try->clone->catch->println->finally->return
Instruction#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::
Instruction#consumeStack(ConstantPoolGen):::This method also gives right results for instructions whose effect on the stack depends on the constant pool entry they reference.:::return->Const->getConsumeStack
Instruction#produceStack(ConstantPoolGen):::This method also gives right results for instructions whose effect on the stack depends on the constant pool entry they reference.:::return->Const->getProduceStack
Instruction#setOpcode(short):::Needed in readInstruction and subclasses in this package:::
Instruction#setLength(int):::Needed in readInstruction and subclasses in this package:::
Instruction#dispose():::Some instructions may be reused, so don't do anything by default.:::
Instruction#accept(Visitor):::Call corresponding visitor method(s):::
Instruction#getComparator():::Get Comparator object used in the equals() method to determine equality of instructions.:::return
Instruction#setComparator(InstructionComparator):::Set comparator to be used for equals().:::
Instruction#equals(Object):::Check for equality, delegated to comparator:::return->cmp->equals
Instruction#hashCode():::calculate the hashCode of this object:::return
Instruction#isValidByte(int):::Check if the value can fit in a byte (signed):::return
Instruction#isValidShort(int):::Check if the value can fit in a short (signed):::return
InstructionConst#getInstruction(int):::Gets the Instruction.:::return
InstructionFactory#createInvoke(String, String, Type, Type[], short):::Create an invoke instruction:::index->nargs->signature->Type->getMethodSignature->foreach->arg_type->getSize->if->cp->addInterfaceMethodref->else->cp->addMethodref->switch->return->new->INVOKESPECIAL->return->new->INVOKEVIRTUAL->return->new->INVOKESTATIC->return->new->INVOKEINTERFACE->return->new->INVOKEDYNAMIC->throw->new->RuntimeException
InstructionFactory#createPrintln(String):::Create a call to the most popular System.out.println() method.:::il->new->InstructionList->out->cp->addFieldref->println->cp->addMethodref->il->new->GETSTATIC->append->il->new->PUSH->append->il->new->INVOKEVIRTUAL->append->return
InstructionFactory#createConstant(Object):::Uses PUSH to push a constant value onto the stack.:::push->if->new->PUSH->else->if->new->PUSH->else->if->new->PUSH->else->if->new->PUSH->else->throw->value->getClass->new->ClassGenException->return->push->getInstruction
InstructionFactory#createFieldAccess(String, String, Type, short):::Create a field instruction.:::index->signature->type->getSignature->cp->addFieldref->switch->return->new->GETFIELD->return->new->PUTFIELD->return->new->GETSTATIC->return->new->PUTSTATIC->throw->new->RuntimeException
InstructionFactory#createThis():::Create reference to `this':::return->new->ALOAD
InstructionFactory#createReturn(Type):::Create typed return:::switch->type->getType->return->return->return->return->return->return->throw->new->RuntimeException
InstructionFactory#createBinaryOperation(String, Type):::Create binary operation for simple basic types, such as int and float.:::first->op->charAt->switch->type->getType->return->createBinaryIntOp->return->createBinaryLongOp->return->createBinaryFloatOp->return->createBinaryDoubleOp->throw->new->RuntimeException
InstructionFactory#createCast(Type, Type):::Create conversion operation for two stack operands, this may be an I2C, instruction, e.g., if the operands are basic types and CHECKCAST if they are reference types.:::if->dest->dest_type->getType->src->src_type->getType->if->name->i->try->forName->getDeclaredConstructor->newInstance->catch->throw->new->RuntimeException->finally->return->else->if->if->return->cp->addArrayClass->new->CHECKCAST->return->cp->getClassName->addClass->new->CHECKCAST->else->throw->new->RuntimeException
InstructionFactory#createNewArray(Type, short):::Create new array of given size and type.:::if->if->return->cp->addClass->new->ANEWARRAY->else->if->return->cp->addArrayClass->new->ANEWARRAY->else->return->t->getType->new->NEWARRAY->at->if->else->new->ArrayType->return->cp->addArrayClass->new->MULTIANEWARRAY
InstructionFactory#createNull(Type):::Create "null" value for reference types, 0 for basic types like int:::switch->type->getType->return->return->return->return->return->return->throw->new->RuntimeException
InstructionFactory#createBranchInstruction(short, InstructionHandle):::Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH:::switch->return->new->IFEQ->return->new->IFNE->return->new->IFLT->return->new->IFGE->return->new->IFGT->return->new->IFLE->return->new->IF_ICMPEQ->return->new->IF_ICMPNE->return->new->IF_ICMPLT->return->new->IF_ICMPGE->return->new->IF_ICMPGT->return->new->IF_ICMPLE->return->new->IF_ACMPEQ->return->new->IF_ACMPNE->return->new->GOTO->return->new->JSR->return->new->IFNULL->return->new->IFNONNULL->return->new->GOTO_W->return->new->JSR_W->throw->new->RuntimeException
InstructionHandle#addHandle():::Does nothing.:::
InstructionHandle#setInstruction(Instruction):::Replace current instruction contained in this handle:::if->throw->new->ClassGenException->if->this->getClass->throw->new->ClassGenException->if->instruction->dispose
InstructionHandle#getInstructionHandle(Instruction):::Factory method.:::return->new->InstructionHandle
InstructionHandle#updatePosition(int, int):::Called by InstructionList.setPositions when setting the position for every instruction:::return
InstructionHandle#setPosition(int):::Set the position, i.e., the byte code offset of the contained instruction.:::
InstructionHandle#dispose():::Delete contents, i.e., remove user access.:::instruction->dispose->removeAllTargeters
InstructionHandle#removeAllTargeters():::Remove all targeters, if any.:::if->targeters->clear
InstructionHandle#removeTargeter(InstructionTargeter):::Denote this handle isn't referenced anymore by t.:::if->targeters->remove
InstructionHandle#addTargeter(InstructionTargeter):::Denote this handle is being referenced by t.:::if->new->HashSet<>->targeters->add
InstructionHandle#addAttribute(Object, Object):::Add an attribute to an instruction handle.:::if->new->HashMap<>->attributes->put
InstructionHandle#removeAttribute(Object):::Delete an attribute of an instruction handle.:::if->attributes->remove
InstructionHandle#getAttribute(Object):::Get attribute of an instruction handle.:::if->return->attributes->get->return
InstructionHandle#accept(Visitor):::Convenience method, simply calls accept() on the contained instruction.:::instruction->accept
InstructionList#isEmpty():::Test for empty list.:::return
InstructionList#findHandle(InstructionHandle[], int[], int, int):::Find the target instruction (handle) that corresponds to the given target position (byte code offset).:::l->r->do->i->j->if->return->else->if->else->while->return
InstructionList#findHandle(int):::Get instruction handle for instruction at byte code position pos:::positions->ih->for->i->return
InstructionList#append(InstructionHandle, InstructionList):::Append another list after instruction (handle) ih contained in this list:::if->throw->new->ClassGenException->if->il->isEmpty->return->next->ih->getNext->ret->ih->setNext->setPrev->setNext->if->next->setPrev->else->il->clear->return
InstructionList#append(Instruction, InstructionList):::Append another list after instruction i contained in this list:::ih->if->findInstruction2->throw->new->ClassGenException->return->append
InstructionList#append(InstructionList):::Append another list to this one:::if->throw->new->ClassGenException->if->il->isEmpty->return->if->isEmpty->il->clear->return->return->append
InstructionList#append(Instruction):::Append an instruction to the end of this list.:::ih->InstructionHandle->getInstructionHandle->append->return
InstructionList#append(BranchInstruction):::Append a branch instruction to the end of this list.:::ih->BranchHandle->getBranchHandle->append->return
InstructionList#append(Instruction, Instruction):::Append a single instruction j after another instruction i, which must be in this list of course!:::return->new->InstructionList->append
InstructionList#append(Instruction, CompoundInstruction):::Append a compound instruction, after instruction i.:::return->c->getInstructionList->append
InstructionList#append(CompoundInstruction):::Append a compound instruction.:::return->c->getInstructionList->append
InstructionList#append(InstructionHandle, CompoundInstruction):::Append a compound instruction.:::return->c->getInstructionList->append
InstructionList#append(InstructionHandle, Instruction):::Append an instruction after instruction (handle) ih contained in this list.:::return->new->InstructionList->append
InstructionList#append(InstructionHandle, BranchInstruction):::Append an instruction after instruction (handle) ih contained in this list.:::bh->BranchHandle->getBranchHandle->il->new->InstructionList->il->append->append->return
InstructionList#insert(InstructionHandle, InstructionList):::Insert another list before Instruction handle ih contained in this list:::if->throw->new->ClassGenException->if->il->isEmpty->return->prev->ih->getPrev->ret->ih->setPrev->setNext->setPrev->if->prev->setNext->else->il->clear->return
InstructionList#insert(InstructionList):::Insert another list.:::if->isEmpty->append->return->return->insert
InstructionList#insert(Instruction, InstructionList):::Insert another list before Instruction i contained in this list:::ih->if->findInstruction1->throw->new->ClassGenException->return->insert
InstructionList#insert(Instruction):::Insert an instruction at start of this list.:::ih->InstructionHandle->getInstructionHandle->insert->return
InstructionList#insert(BranchInstruction):::Insert a branch instruction at start of this list.:::ih->BranchHandle->getBranchHandle->insert->return
InstructionList#insert(Instruction, Instruction):::Insert a single instruction j before another instruction i, which must be in this list of course!:::return->new->InstructionList->insert
InstructionList#insert(Instruction, CompoundInstruction):::Insert a compound instruction before instruction i.:::return->c->getInstructionList->insert
InstructionList#insert(CompoundInstruction):::Insert a compound instruction.:::return->c->getInstructionList->insert
InstructionList#insert(InstructionHandle, Instruction):::Insert an instruction before instruction (handle) ih contained in this list.:::return->new->InstructionList->insert
InstructionList#insert(InstructionHandle, CompoundInstruction):::Insert a compound instruction.:::return->c->getInstructionList->insert
InstructionList#insert(InstructionHandle, BranchInstruction):::Insert an instruction before instruction (handle) ih contained in this list.:::bh->BranchHandle->getBranchHandle->il->new->InstructionList->il->append->insert->return
InstructionList#move(InstructionHandle, InstructionHandle, InstructionHandle):::Take all instructions (handles) from "start" to "end" and append them after the new location "target":::if->throw->new->ClassGenException->if->throw->new->ClassGenException->for->ih->end->getNext->ih->getNext->prev->start->getPrev->next->end->getNext->if->prev->setNext->else->if->next->setPrev->else->start->end->setNext->setPrev->if->if->setPrev->end->setNext->else->target->getNext->target->setNext->start->setPrev->end->setNext->if->next->setPrev->else
InstructionList#move(InstructionHandle, InstructionHandle):::Move a single instruction (handle) to a new location.:::move
InstructionList#delete(InstructionHandle):::Remove instruction from this list:::ih->getPrev->ih->getNext->remove
InstructionList#delete(Instruction):::Remove instruction from this list:::ih->if->findInstruction1->throw->new->ClassGenException->delete
InstructionList#delete(InstructionHandle, InstructionHandle):::Remove instructions from instruction `from' to instruction `to' contained in this list:::from->getPrev->to->getNext->remove
InstructionList#delete(Instruction, Instruction):::Remove instructions from instruction `from' to instruction `to' contained in this list:::from_ih->to_ih->if->findInstruction1->throw->new->ClassGenException->if->findInstruction2->throw->new->ClassGenException->delete
InstructionList#setPositions(boolean):::Give all instructions their position number (offset in byte stream), i.e., make the list ready to be dumped.:::max_additional_bytes->additional_bytes->index->count->pos->new->intArr->if->for->ih->ih->getNext->for->ih->ih->getNext->for->ih->ih->getNext->for->ih->ih->getNext->if->else->new->intArr->System->arraycopy
InstructionList#getByteCode():::When everything is finished, use this method to convert the instruction list into an array of bytes.:::setPositions->b->new->ByteArrayOutputStream->out->new->DataOutputStream->try->for->ih->ih->getNext->out->flush->catch->println->return->new->byteArr->finally->return->b->toByteArray
InstructionList#getInstructionPositions():::Get positions (offsets) of all instructions in the list:::return
InstructionList#replaceConstantPool(ConstantPoolGen, ConstantPoolGen):::Replace all references to the old constant pool with references to the new constant pool:::for->ih->ih->getNext
InstructionList#dispose():::Delete contents of list:::for->ih->ih->getPrev->clear
InstructionList#redirectBranches(InstructionHandle, InstructionHandle):::Redirect all references from old_target to new_target, i.e., update targets of branch instructions.:::for->ih->ih->getNext
InstructionList#redirectLocalVariables(LocalVariableGen[], InstructionHandle, InstructionHandle):::Redirect all references of local variables from old_target to new_target.:::foreach->start->element->getStart->end->element->getEnd->if->element->setStart->if->element->setEnd
InstructionList#redirectExceptionHandlers(CodeExceptionGen[], InstructionHandle, InstructionHandle):::Redirect all references of exception handlers from old_target to new_target.:::foreach->if->exception->getStartPC->exception->setStartPC->if->exception->getEndPC->exception->setEndPC->if->exception->getHandlerPC->exception->setHandlerPC
InstructionList#addObserver(InstructionListObserver):::Add observer for this object.:::if->new->ArrayList<>->observers->add
InstructionList#removeObserver(InstructionListObserver):::Remove observer for this object.:::if->observers->remove
InstructionList#update():::Call notify() method on all observers:::if->foreach->observer->notify
InstructionTargeter#containsTarget(InstructionHandle):::Checks whether this targeter targets the specified instruction handle.:::
InstructionTargeter#updateTarget(InstructionHandle, InstructionHandle):::Replaces the target of this targeter from this old handle to the new handle.:::
INVOKEDYNAMIC#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort->out->writeByte->out->writeByte
INVOKEDYNAMIC#initFromFile(ByteSequence, boolean):::Read needed data (i.e., index) from file.:::super->initFromFile->super->setLength->bytes->readByte->bytes->readByte
INVOKEDYNAMIC#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitStackProducer->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitInvokeInstruction->v->visitINVOKEDYNAMIC
INVOKEDYNAMIC#getClassName(ConstantPoolGen):::Override the parent method because our classname is held elsewhere.:::cp->cpg->getConstantPool->cid->cp->super->getIndex->getConstant->return->cp->cid->getNameAndTypeIndex->getConstant->getName
INVOKEDYNAMIC#getReferenceType(ConstantPoolGen):::Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object, as that is the only type we can say for sure the reference will be.:::return->getName->new->ObjectType
InvokeInstruction#consumeStack(ConstantPoolGen):::Also works for instructions whose stack effect depends on the constant pool entry they reference.:::sum->if->super->getOpcode->super->getOpcode->else->signature->getSignature->Type->getArgumentTypesSize->return
InvokeInstruction#produceStack(ConstantPoolGen):::Also works for instructions whose stack effect depends on the constant pool entry they reference.:::signature->getSignature->return->Type->getReturnTypeSize
InvokeInstruction#getClassName(ConstantPoolGen):::This overrides the deprecated version as we know here that the referenced class may legally be an array.:::cp->cpg->getConstantPool->cmr->cp->super->getIndex->getConstant->className->cp->cmr->getClassIndex->getConstantString->return->className->replace
INVOKEINTERFACE#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort->out->writeByte->out->writeByte
INVOKEINTERFACE#getCount():::The <B>count</B> argument according to the Java Language Specification, Second Edition.:::return
INVOKEINTERFACE#initFromFile(ByteSequence, boolean):::Read needed data (i.e., index) from file.:::super->initFromFile->super->setLength->bytes->readUnsignedByte->bytes->readByte
INVOKEINTERFACE#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitStackProducer->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitInvokeInstruction->v->visitINVOKEINTERFACE
INVOKESPECIAL#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort
INVOKESPECIAL#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitStackProducer->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitInvokeInstruction->v->visitINVOKESPECIAL
INVOKESTATIC#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort
INVOKESTATIC#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitStackProducer->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitInvokeInstruction->v->visitINVOKESTATIC
INVOKEVIRTUAL#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort
INVOKEVIRTUAL#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitStackProducer->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitInvokeInstruction->v->visitINVOKEVIRTUAL
IOR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIOR
IREM#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIREM
IRETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitIRETURN
ISHL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitISHL
ISHR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitISHR
ISTORE#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitISTORE
ISUB#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitISUB
IUSHR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIUSHR
IXOR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitIXOR
JSR#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->getTargetOffset->setIndex->if->super->getOpcode->super->dump->else->super->getTargetOffset->setIndex->out->super->getOpcode->writeByte->out->super->getIndex->writeInt
JSR#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitVariableLengthInstruction->v->visitBranchInstruction->v->visitJsrInstruction->v->visitJSR
JsrInstruction#physicalSuccessor():::Returns an InstructionHandle to the physical successor of this JsrInstruction:::ih->super->getTarget->while->ih->getPrev->ih->getPrev->while->ih->getInstruction->ih->getNext->toThis->while->ih->getNext->if->ih->getInstruction->throw->new->RuntimeException->return->toThis->getNext
JSR_W#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->getTargetOffset->setIndex->out->super->getOpcode->writeByte->out->super->getIndex->writeInt
JSR_W#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->bytes->readInt->setIndex->super->setLength
JSR_W#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitBranchInstruction->v->visitJsrInstruction->v->visitJSR_W
L2D#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitL2D
L2F#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitL2F
L2I#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitConversionInstruction->v->visitL2I
LADD#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLADD
LALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitLALOAD
LAND#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLAND
LASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitLASTORE
LCMP#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitLCMP
LCONST#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitLCONST
LDC#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->if->super->getLength->out->super->getIndex->writeByte->else->out->super->getIndex->writeShort
LDC#setIndex(int):::Set the index to constant pool and adjust size.:::super->setIndex->setSize
LDC#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->setLength->super->bytes->readUnsignedByte->setIndex
LDC#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitExceptionThrower->v->visitTypedInstruction->v->visitCPInstruction->v->visitLDC
LDC2_W#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitTypedInstruction->v->visitCPInstruction->v->visitLDC2_W
LDC_W#initFromFile(ByteSequence, boolean):::Read needed data (i.e., index) from file.:::bytes->readUnsignedShort->setIndex->super->setOpcode->super->setLength
LDIV#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLDIV
LineNumberGen#getLineNumber():::Get LineNumber attribute :::return->ih->getPosition->new->LineNumber
LLOAD#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitLLOAD
LMUL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLMUL
LNEG#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLNEG
LoadClass#getLoadClassType(ConstantPoolGen):::Returns the ObjectType of the referenced class or interface that may be loaded and resolved.:::
LoadClass#getType(ConstantPoolGen):::Returns the type associated with this instruction:::
LoadInstruction#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitPushInstruction->v->visitTypedInstruction->v->visitLocalVariableInstruction->v->visitLoadInstruction
LocalVariableGen#getLocalVariable(ConstantPoolGen):::Get LocalVariable object:::start_pc->length->if->start->getPosition->end->getPosition->if->end->getNext->end->getInstruction->getLength->name_index->cp->addUtf8->signature_index->cp->type->getSignature->addUtf8->return->cp->getConstantPool->new->LocalVariable
LocalVariableGen#dispose():::Clear the references from and to this variable when it's removed.:::setStart->setEnd
LocalVariableGen#equals(Object):::We consider to local variables to be equal, if the use the same index and are valid in the same range.:::if->return->l->return
LocalVariableInstruction#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::if->wide->out->writeByte->out->super->getOpcode->writeByte->if->super->getLength->if->wide->out->writeShort->else->out->writeByte
LocalVariableInstruction#toString(boolean):::Long output format:  &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" "("&lt;length of instruction&gt;")" "&lt;"&lt; local variable index&gt;"&gt;":::_opcode->super->getOpcode->if->return->super->toString->return->super->toString
LocalVariableInstruction#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::if->bytes->readUnsignedShort->super->setLength->else->_opcode->super->getOpcode->if->bytes->readUnsignedByte->super->setLength->else->if->super->setLength->else->super->setLength
LocalVariableInstruction#setIndex(int):::Set the local variable index:::if->throw->new->ClassGenException->if->super->setOpcode->super->setLength->else->super->setOpcode->if->wide->super->setLength->else->super->setLength
LocalVariableInstruction#getType(ConstantPoolGen):::Returns the type associated with the instruction - in case of ALOAD or ASTORE Type.OBJECT is returned:::switch->return->return->return->return->return->throw->new->ClassGenException
LocalVariableInstruction#setIndexOnly(int):::Sets the index of the referenced variable (n) only:::
LOOKUPSWITCH#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->dump->_match_length->getMatch_length->out->writeInt->for->i
LOOKUPSWITCH#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->initFromFile->_match_length->bytes->readInt->setMatch_length->_fixed_length->setFixed_length->_length->super->getPadding->super->setLength->super->new->intArr->setMatches->super->new->intArr->setIndices->super->new->InstructionHandleArr->setTargets->for->i
LOOKUPSWITCH#accept(Visitor):::Call corresponding visitor method(s):::v->visitVariableLengthInstruction->v->visitStackConsumer->v->visitBranchInstruction->v->visitSelect->v->visitLOOKUPSWITCH
LOR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLOR
LREM#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLREM
LRETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitLRETURN
LSHL#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLSHL
LSHR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLSHR
LSTORE#accept(Visitor):::Call corresponding visitor method(s):::super->accept->v->visitLSTORE
LSUB#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLSUB
LUSHR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLUSHR
LXOR#accept(Visitor):::Call corresponding visitor method(s):::v->visitTypedInstruction->v->visitStackProducer->v->visitStackConsumer->v->visitArithmeticInstruction->v->visitLXOR
MethodGen#addLocalVariable(String, Type, int, InstructionHandle, InstructionHandle, int):::Adds a local variable to this method.:::t->type->getType->if->add->type->getSize->if->l->new->LocalVariableGen->i->if->variable_vec->indexOf->variable_vec->set->else->variable_vec->add->return->throw->new->IllegalArgumentException
MethodGen#addLocalVariable(String, Type, int, InstructionHandle, InstructionHandle):::Adds a local variable to this method.:::return->addLocalVariable
MethodGen#addLocalVariable(String, Type, InstructionHandle, InstructionHandle):::Adds a local variable to this method and assigns an index automatically.:::return->addLocalVariable
MethodGen#removeLocalVariable(LocalVariableGen):::Remove a local variable, its slot will not be reused, if you do not use addLocalVariable with an explicit index argument.:::variable_vec->remove
MethodGen#removeLocalVariables():::Remove all local variables.:::variable_vec->clear
MethodGen#addLineNumber(InstructionHandle, int):::Give an instruction a line number corresponding to the source code line.:::l->new->LineNumberGen->line_number_vec->add->return
MethodGen#removeLineNumber(LineNumberGen):::Remove a line number.:::line_number_vec->remove
MethodGen#removeLineNumbers():::Remove all line numbers.:::line_number_vec->clear
MethodGen#addExceptionHandler(InstructionHandle, InstructionHandle, InstructionHandle, ObjectType):::Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling is done.:::if->throw->new->ClassGenException->c->new->CodeExceptionGen->exception_vec->add->return
MethodGen#removeExceptionHandler(CodeExceptionGen):::Remove an exception handler.:::exception_vec->remove
MethodGen#removeExceptionHandlers():::Remove all line numbers.:::exception_vec->clear
MethodGen#addException(String):::Add an exception possibly thrown by this method.:::throws_vec->add
MethodGen#removeException(String):::Remove an exception.:::throws_vec->remove
MethodGen#removeExceptions():::Remove all exceptions.:::throws_vec->clear
MethodGen#addCodeAttribute(Attribute):::Add an attribute to the code:::code_attrs_vec->add
MethodGen#removeLocalVariableTypeTable():::Remove the LocalVariableTypeTable:::
MethodGen#removeCodeAttribute(Attribute):::Remove a code attribute.:::code_attrs_vec->remove
MethodGen#removeCodeAttributes():::Remove all code attributes.:::code_attrs_vec->clear
MethodGen#getMethod():::Get method object:::signature->getSignature->_cp->super->getConstantPool->name_index->_cp->super->getName->addUtf8->signature_index->_cp->addUtf8->byte_code->if->il->getByteCode->lnt->lvt->if->variable_vec->size->getLocalVariableTable->updateLocalVariableTable->getLocalVariableTable->addCodeAttribute->if->if->adjustLocalVariableTypeTable->addCodeAttribute->if->line_number_vec->size->getLineNumberTable->addCodeAttribute->code_attrs->getCodeAttributes->attrs_len->foreach->code_attr->getLength->c_exc->getCodeExceptions->exc_len->code->if->isAbstract->isNative->attributes->getAttributes->foreach->if->removeAttribute->_cp->addUtf8->_cp->getConstantPool->new->Code->addAttribute->addAnnotationsAsAttribute->addParameterAnnotationsAsAttribute->et->if->throws_vec->size->getExceptionTable->addAttribute->m->super->getAccessFlags->getAttributes->_cp->getConstantPool->new->Method->if->removeCodeAttribute->if->removeCodeAttribute->if->removeCodeAttribute->if->removeAttribute->if->removeAttribute->return
MethodGen#removeNOPs():::Remove all NOPs from the instruction list (if possible) and update every object referring to them, i.e., branch instructions, local variables and exception handlers.:::if->next->for->ih->il->getStart
MethodGen#setMaxLocals(int):::Set maximum number of local variables.:::
MethodGen#setMaxStack(int):::Set maximum stack size for this method.:::
MethodGen#setMaxStack():::Computes max:::if->super->getConstantPool->getExceptionHandlers->getMaxStack->else
MethodGen#setMaxLocals():::Compute maximum number of local variables.:::if->max->isStatic->if->foreach->arg_type->getSize->for->ih->il->getStart->ih->getNext->else
MethodGen#stripAttributes(boolean):::Do not/Do produce attributes code attributesLineNumberTable and LocalVariableTable, like javac -O:::
MethodGen#getMaxStack(ConstantPoolGen, InstructionList, CodeExceptionGen[]):::Computes stack usage of an instruction list by performing control flow analysis.:::branchTargets->new->BranchStack->foreach->handler_pc->element->getHandlerPC->if->branchTargets->push->stackDepth->maxStackDepth->ih->il->getStart->while->instruction->ih->getInstruction->opcode->instruction->getOpcode->delta->instruction->produceStack->instruction->consumeStack->if->if->branch->if->select->targets->select->getTargets->foreach->branchTargets->push->else->if->if->branchTargets->ih->getNext->push->branchTargets->branch->getTarget->push->else->if->if->ih->getNext->if->bt->branchTargets->pop->if->return
MethodGen#addObserver(MethodObserver):::Add observer for this object.:::if->new->ArrayList<>->observers->add
MethodGen#removeObserver(MethodObserver):::Remove observer for this object.:::if->observers->remove
MethodGen#update():::Call notify() method on all observers:::if->foreach->observer->notify
MethodGen#toString():::Return string representation close to declaration format, `public static void main(String[]) throws IOException', e.g.:::access->Utility->super->getAccessFlags->accessToString->signature->Type->super->getType->getMethodSignature->Utility->super->getName->super->getConstantPool->getLocalVariableTable->methodSignatureToString->buf->new->StringBuilder->foreach->getAttributes->if->buf->append->append->append->if->throws_vec->size->foreach->buf->append->append->return->buf->toString
MethodGen#getAnnotationsOnParameter(int):::Return a list of AnnotationGen objects representing parameter annotations:::ensureExistingParameterAnnotationsUnpacked->if->return->return
MethodGen#equals(Object):::Return value as defined by given BCELComparator strategy:::return->bcelComparator->equals
MethodGen#hashCode():::Return value as defined by given BCELComparator strategy:::return->bcelComparator->hashCode
MONITORENTER#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackConsumer->v->visitMONITORENTER
MONITOREXIT#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackConsumer->v->visitMONITOREXIT
MULTIANEWARRAY#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->super->getIndex->writeShort->out->writeByte
MULTIANEWARRAY#initFromFile(ByteSequence, boolean):::Read needed data (i.e., no:::super->initFromFile->bytes->readByte->super->setLength
MULTIANEWARRAY#consumeStack(ConstantPoolGen):::Also works for instructions whose stack effect depends on the constant pool entry they reference.:::return
MULTIANEWARRAY#accept(Visitor):::Call corresponding visitor method(s):::v->visitLoadClass->v->visitAllocationInstruction->v->visitExceptionThrower->v->visitTypedInstruction->v->visitCPInstruction->v->visitMULTIANEWARRAY
NEW#accept(Visitor):::Call corresponding visitor method(s):::v->visitLoadClass->v->visitAllocationInstruction->v->visitExceptionThrower->v->visitStackProducer->v->visitTypedInstruction->v->visitCPInstruction->v->visitNEW
NEWARRAY#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->out->writeByte
NEWARRAY#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::bytes->readByte->super->setLength
NEWARRAY#accept(Visitor):::Call corresponding visitor method(s):::v->visitAllocationInstruction->v->visitExceptionThrower->v->visitStackProducer->v->visitNEWARRAY
NOP#accept(Visitor):::Call corresponding visitor method(s):::v->visitNOP
ObjectType#referencesClass():::If "this" doesn't reference a class, it references an interface or a non-existant entity.:::try->jc->Repository->lookupClass->return->jc->isClass->catch->return->finally
ObjectType#referencesInterface():::If "this" doesn't reference an interface, it references a class or a non-existant entity.:::try->jc->Repository->lookupClass->return->jc->isClass->catch->return->finally
ObjectType#referencesClassExact():::Return true if this type references a class, false if it references an interface.:::jc->Repository->lookupClass->return->jc->isClass
ObjectType#referencesInterfaceExact():::Return true if this type references an interface, false if it references a class.:::jc->Repository->lookupClass->return->jc->isClass
ObjectType#subclassOf(ObjectType):::Return true if this type is a subclass of given ObjectType.:::if->this->referencesInterfaceExact->superclass->referencesInterfaceExact->return->return->Repository->instanceOf
ObjectType#accessibleTo(ObjectType):::Java Virtual Machine Specification edition 2,  5.4.4 Access Control:::jc->Repository->lookupClass->if->jc->isPublic->return->acc->Repository->lookupClass->return->acc->getPackageName->jc->getPackageName->equals
POP#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitPopInstruction->v->visitStackInstruction->v->visitPOP
POP2#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitPopInstruction->v->visitStackInstruction->v->visitPOP2
PUTFIELD#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackConsumer->v->visitPopInstruction->v->visitTypedInstruction->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitFieldInstruction->v->visitPUTFIELD
PUTSTATIC#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitStackConsumer->v->visitPopInstruction->v->visitTypedInstruction->v->visitLoadClass->v->visitCPInstruction->v->visitFieldOrMethod->v->visitFieldInstruction->v->visitPUTSTATIC
ReferenceType#isCastableTo(Type):::Return true iff this type is castable to another type t as defined in the JVM specification:::if->this->equals->return->return->isAssignmentCompatibleWith
ReferenceType#isAssignmentCompatibleWith(Type):::Return true iff this is assignment compatible with another type t as defined in the JVM specification; see the AASTORE definition there.:::if->return->T->if->this->equals->return->if->referencesClassExact->if->referencesClassExact->if->this->equals->return->if->Repository->getClassName->getClassName->instanceOf->return->if->referencesInterfaceExact->if->Repository->getClassName->getClassName->implementationOf->return->if->referencesInterfaceExact->if->referencesClassExact->if->T->equals->return->if->referencesInterfaceExact->if->this->equals->return->if->Repository->getClassName->getClassName->implementationOf->return->if->if->referencesClassExact->if->T->equals->return->if->sc->getElementType->tc->getElementType->if->sc->equals->return->if->isAssignmentCompatibleWith->return->if->referencesInterfaceExact->foreach->Const->getInterfacesImplementedByArrays->if->T->ObjectType->getInstance->equals->return->return
ReferenceType#getFirstCommonSuperclass(ReferenceType):::This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an interface):::if->this->equals->return->if->t->equals->return->if->this->equals->return->if->arrType1->arrType2->if->arrType1->getDimensions->arrType2->getDimensions->arrType1->getBasicType->arrType2->getBasicType->return->arrType1->getBasicType->arrType2->getBasicType->getFirstCommonSuperclass->arrType1->getDimensions->new->ArrayType->if->return->if->referencesInterfaceExact->referencesInterfaceExact->return->thiz->other->thiz_sups->Repository->thiz->getClassName->getSuperClasses->other_sups->Repository->other->getClassName->getSuperClasses->if->return->this_sups->new->JavaClassArr->t_sups->new->JavaClassArr->System->arraycopy->System->arraycopy->Repository->thiz->getClassName->lookupClass->Repository->other->getClassName->lookupClass->foreach->foreach->if->this_sup->equals->return->ObjectType->this_sup->getClassName->getInstance->return
ReferenceType#firstCommonSuperclass(ReferenceType):::This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an interface):::if->this->equals->return->if->t->equals->return->if->this->equals->return->if->return->if->referencesInterface->referencesInterface->return->thiz->other->thiz_sups->Repository->thiz->getClassName->getSuperClasses->other_sups->Repository->other->getClassName->getSuperClasses->if->return->this_sups->new->JavaClassArr->t_sups->new->JavaClassArr->System->arraycopy->System->arraycopy->Repository->thiz->getClassName->lookupClass->Repository->other->getClassName->lookupClass->foreach->foreach->if->this_sup->equals->return->ObjectType->this_sup->getClassName->getInstance->return
RET#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::if->out->writeByte->out->super->getOpcode->writeByte->if->out->writeShort->else->out->writeByte
RET#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::if->bytes->readUnsignedShort->super->setLength->else->bytes->readUnsignedByte->super->setLength
RET#setIndex(int):::Set index of local variable containg the return address:::if->throw->new->ClassGenException->setWide
RET#accept(Visitor):::Call corresponding visitor method(s):::v->visitRET
RETURN#accept(Visitor):::Call corresponding visitor method(s):::v->visitExceptionThrower->v->visitTypedInstruction->v->visitStackConsumer->v->visitReturnInstruction->v->visitRETURN
ReturnaddressType#equals(Object):::Returns if the two Returnaddresses refer to the same target.:::if->return->that->if->return->return->equals
SALOAD#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackProducer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitSALOAD
SASTORE#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitExceptionThrower->v->visitTypedInstruction->v->visitArrayInstruction->v->visitSASTORE
Select#updatePosition(int, int):::Since this is a variable length instruction, it may shift the following instructions which then need to update their position:::getPosition->setPosition->old_length->super->getLength->getPosition->super->setLength->return->super->getLength
Select#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::out->super->getOpcode->writeByte->for->i->super->getTargetOffset->setIndex->out->super->getIndex->writeInt
Select#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::bytes->getIndex->for->i->super->bytes->readInt->setIndex
Select#setTarget(int, InstructionHandle):::Set branch target for `i'th case:::notifyTarget
Select#dispose():::Inform targets that they're not targeted anymore.:::super->dispose->foreach->target2->removeTargeter
SimpleElementValueGen#getElementValue():::Return immutable variant:::return->super->getElementValueType->getConstantPool->getConstantPool->new->SimpleElementValue
SIPUSH#dump(DataOutputStream):::Dump instruction as short code to stream out.:::super->dump->out->writeShort
SIPUSH#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->setLength->bytes->readShort
SIPUSH#accept(Visitor):::Call corresponding visitor method(s):::v->visitPushInstruction->v->visitStackProducer->v->visitTypedInstruction->v->visitConstantPushInstruction->v->visitSIPUSH
StoreInstruction#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitPopInstruction->v->visitTypedInstruction->v->visitLocalVariableInstruction->v->visitStoreInstruction
SWAP#accept(Visitor):::Call corresponding visitor method(s):::v->visitStackConsumer->v->visitStackProducer->v->visitStackInstruction->v->visitSWAP
TABLESWITCH#dump(DataOutputStream):::Dump instruction as byte code to stream out.:::super->dump->_match_length->getMatch_length->low->super->getMatch->out->writeInt->high->super->getMatch->out->writeInt->for->i
TABLESWITCH#initFromFile(ByteSequence, boolean):::Read needed data (e.g:::super->initFromFile->low->bytes->readInt->high->bytes->readInt->_match_length->setMatch_length->_fixed_length->setFixed_length->super->super->getPadding->setLength->super->new->intArr->setMatches->super->new->intArr->setIndices->super->new->InstructionHandleArr->setTargets->for->i
TABLESWITCH#accept(Visitor):::Call corresponding visitor method(s):::v->visitVariableLengthInstruction->v->visitStackConsumer->v->visitBranchInstruction->v->visitSelect->v->visitTABLESWITCH
Type#normalizeForStackOrLocal():::boolean, short and char variable are considered as int in the stack or local variable area:::if->return->return
Type#getMethodSignature(Type, Type[]):::Convert type to Java method signature, e.g:::buf->new->StringBuilder->if->foreach->buf->arg_type->getSignature->append->buf->append->buf->return_type->getSignature->append->return->buf->toString
Type#getReturnType(String):::Convert return value of a method (signature) to a Type object.:::try->index->signature->lastIndexOf->return->signature->substring->getType->catch->throw->new->ClassFormatException->finally
Type#getArgumentTypes(String):::Convert arguments of a method (signature) to an array of Type objects.:::vec->new->ArrayList<>->index->types->try->if->signature->charAt->throw->new->ClassFormatException->while->signature->charAt->vec->signature->substring->getType->add->unwrap->catch->throw->new->ClassFormatException->finally->vec->size->new->TypeArr->vec->toArray->return
Type#getType(java.lang.Class):::Convert runtime java.lang.Class to BCEL Type object.:::if->throw->new->IllegalArgumentException->if->cl->isArray->return->cl->getName->getType->else->if->cl->isPrimitive->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->throw->new->IllegalStateException->else->return->ObjectType->cl->getName->getInstance
Type#getTypes(java.lang.Class[]):::Convert runtime java.lang.Class[] to BCEL Type objects.:::ret->new->TypeArr->for->i->return
