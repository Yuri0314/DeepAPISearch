BMPSet#span(CharSequence, int, SpanCondition, OutputInt):::Span the initial substring for which each character c has spanCondition==contains(c):::c->c2->i->limit->s->length->numSupplementary->if->while->s->charAt->if->if->break->else->if->if->break->else->if->s->charAt->lead->twoBits->if->if->break->else->if->containsSlow->break->else->supplementary->UCharacterProperty->getRawSupplementary->if->containsSlow->break->else->while->s->charAt->if->if->break->else->if->if->break->else->if->s->charAt->lead->twoBits->if->if->break->else->if->containsSlow->break->else->supplementary->UCharacterProperty->getRawSupplementary->if->containsSlow->break->if->spanLength->return
BMPSet#spanBack(CharSequence, int, SpanCondition):::Symmetrical with span():::c->c2->if->for->else->for->return
CharacterIteratorWrapper#clone():::Creates a clone of this iterator:::try->result->super->clone->clone->return->catch->return->finally
CharTrie#getCodePointValue(int):::Gets the value associated with the codepoint:::offset->if->return->getCodePointOffset->return
CharTrie#getLeadValue(char):::Gets the value to the data which this lead surrogate character points to:::return->getLeadOffset
CharTrie#unserialize(InputStream):::Parses the input stream and stores its trie content into a index and data array:::input->new->DataInputStream->indexDataLength->new->charArr->for->i
CharTrie#getSurrogateOffset(char, char):::Gets the offset to the data which the surrogate pair points to.:::if->throw->new->NullPointerException->offset->m_dataManipulate_->getLeadValue->getFoldingOffset->if->return->getRawOffset->return
ICUBinary.Authenticate#isDataVersionAcceptable(byte[]):::Method used in ICUBinary.readHeader() to provide data format authentication.:::
ICUBinary#getRequiredData(String):::Loads an ICU binary data file and returns it as a ByteBuffer:::root->try->is->AccessController->new->PrivilegedAction<InputStream>->doPrivileged->b->new->BufferedInputStream->inputStream->new->DataInputStream->bb->new->byteArr->n->inputStream->read->bytes->ByteBuffer->wrap->return->catch->throw->new->UncheckedIOException->finally
ICUBinary#readHeaderAndDataVersion(ByteBuffer, int, Authenticate):::Same as readHeader(), but returns a VersionInfo rather than a compact int.:::return->readHeader->getVersionInfoFromCompactInt
ICUBinary#readHeader(ByteBuffer, int, Authenticate):::Reads an ICU data header, checks the data format, and returns the data version:::magic1->bytes->get->magic2->bytes->get->if->throw->new->IOException->isBigEndian->bytes->get->charsetFamily->bytes->get->sizeofUChar->bytes->get->if->throw->new->IOException->bytes->order->headerSize->bytes->getChar->sizeofUDataInfo->bytes->getChar->if->throw->new->IOException->formatVersion->new->byteArr->bytes->get->bytes->get->bytes->get->bytes->get->if->bytes->get->bytes->get->bytes->get->bytes->get->authenticate->isDataVersionAcceptable->throw->String->bytes->get->bytes->get->bytes->get->bytes->get->format->new->IOException->bytes->position->return->bytes->get->bytes->get->bytes->get->bytes->get
ICUBinary#getVersionInfoFromCompactInt(int):::Returns a VersionInfo for the bytes in the compact version integer.:::return->VersionInfo->getInstance
Normalizer2#getNFCInstance():::Returns a Normalizer2 instance for Unicode NFC normalization:::return->Norm2AllModes->getNFCInstance
Normalizer2#getNFDInstance():::Returns a Normalizer2 instance for Unicode NFD normalization:::return->Norm2AllModes->getNFCInstance
Normalizer2#getNFKCInstance():::Returns a Normalizer2 instance for Unicode NFKC normalization:::return->Norm2AllModes->getNFKCInstance
Normalizer2#getNFKDInstance():::Returns a Normalizer2 instance for Unicode NFKD normalization:::return->Norm2AllModes->getNFKCInstance
Normalizer2#normalize(CharSequence):::Returns the normalized form of the source string.:::if->spanLength->spanQuickCheckYes->if->src->length->return->if->sb->src->length->new->StringBuilder->append->return->src->src->length->subSequence->normalizeSecondAndAppend->toString->return->src->length->new->StringBuilder->normalize->toString
Normalizer2#normalize(CharSequence, StringBuilder):::Writes the normalized form of the source string to the destination string (replacing its contents) and returns the destination string:::
Normalizer2#normalize(CharSequence, Appendable):::Writes the normalized form of the source string to the destination Appendable and returns the destination Appendable:::
Normalizer2#normalizeSecondAndAppend(StringBuilder, CharSequence):::Appends the normalized form of the second string to the first string (merging them at the boundary) and returns the first string:::
Normalizer2#append(StringBuilder, CharSequence):::Appends the second string to the first string (merging them at the boundary) and returns the first string:::
Normalizer2#getDecomposition(int):::Gets the decomposition mapping of c:::
Normalizer2#getCombiningClass(int):::Gets the combining class of c:::return
Normalizer2#isNormalized(CharSequence):::Tests if the string is normalized:::
Normalizer2#spanQuickCheckYes(CharSequence):::Returns the end of the normalized substring of the input string:::
Normalizer2#hasBoundaryBefore(int):::Tests if the character always has a normalization boundary before it, regardless of context:::
NormalizerBase#clone():::Clones this NormalizerBase object:::try->copy->super->clone->text->clone->new->StringBuilder->return->catch->throw->e->toString->new->InternalError->finally
NormalizerBase#normalize(String, Mode, int):::Normalizes a String using the given normalization operation:::return->mode->getNormalizer2->normalize
NormalizerBase#isNormalized(String, Mode, int):::Test if a string is in a given normalization form:::return->mode->getNormalizer2->isNormalized
NormalizerBase#current():::Return the current character in the normalized text.:::if->buffer->length->nextNormalize->return->buffer->codePointAt->else->return
NormalizerBase#next():::Return the next character in the normalized text and advance the iteration position by one:::if->buffer->length->nextNormalize->c->buffer->codePointAt->Character->charCount->return->else->return
NormalizerBase#previous():::Return the previous character in the normalized text and decrement the iteration position by one:::if->previousNormalize->c->buffer->codePointBefore->Character->charCount->return->else->return
NormalizerBase#reset():::Reset the index to the beginning of the text:::text->setIndex->clearBuffer
NormalizerBase#setIndexOnly(int):::Set the iteration position in the input text that is being normalized, without any immediate normalization:::text->setIndex->clearBuffer
NormalizerBase#setIndex(int):::Set the iteration position in the input text that is being normalized and return the first normalized character at that position:::setIndexOnly->return->current
NormalizerBase#getBeginIndex():::Retrieve the index of the start of the input text:::return
NormalizerBase#getEndIndex():::Retrieve the index of the end of the input text:::return->endIndex
NormalizerBase#getIndex():::Retrieve the current iteration position in the input text that is being normalized:::if->buffer->length->return->else->return
NormalizerBase#endIndex():::Retrieve the index of the end of the input text:::return->text->getLength
NormalizerBase#setMode(Mode):::Set the normalization mode for this object:::mode->getNormalizer2
NormalizerBase#getMode():::Return the basic operation performed by this NormalizerBase:::return
NormalizerBase#setText(String):::Set the input text over which this NormalizerBase will iterate:::newIter->UCharacterIterator->getInstance->if->throw->new->IllegalStateException->reset
NormalizerBase#setText(CharacterIterator):::Set the input text over which this NormalizerBase will iterate:::newIter->UCharacterIterator->getInstance->if->throw->new->IllegalStateException->clearBuffer
NormalizerImpl.Hangul#decompose(int, Appendable):::Decomposes c, which must be a Hangul syllable, into buffer and returns the length of the decomposition (2 or 3).:::try->c2->buffer->append->buffer->append->if->return->else->buffer->append->return->catch->throw->new->InternalError->finally
NormalizerImpl.ReorderingBuffer#flush():::Flushes from the intermediate StringBuilder to the Appendable, if they are different objects:::if->str->length->else->try->app->append->str->setLength->catch->throw->new->InternalError->finally
NormalizerImpl.ReorderingBuffer#flushAndAppendZeroCC(CharSequence, int, int):::Flushes from the intermediate StringBuilder to the Appendable, if they are different objects:::if->str->append->str->length->else->try->app->append->append->str->setLength->catch->throw->new->InternalError->finally->return
NormalizerImpl.UTF16Plus#isSurrogateLead(int):::Assuming c is a surrogate code point (UTF16.isSurrogate(c)), is it a lead surrogate?:::return
NormalizerImpl.UTF16Plus#equal(CharSequence, int, int, CharSequence, int, int):::Compares two CharSequence subsequences for binary equality.:::if->return->if->return->while->if->s1->charAt->s2->charAt->return->return
NormalizerImpl#getFCD16(int):::Returns the FCD data for code point c.:::if->return->else->if->if->singleLeadMightHaveNonZeroFCD16->return->return->getFCD16FromNormData
NormalizerImpl#singleLeadMightHaveNonZeroFCD16(int):::Returns true if the single-or-lead code unit c might have non-zero FCD data.:::bits->if->return->return
NormalizerImpl#getFCD16FromNormData(int):::Gets the FCD value from the regular normalization data.:::norm16->getNorm16->if->if->getCCFromNormalYesOrMaybe->return->else->if->return->else->deltaTrailCC->if->return->mapAlgorithmic->getNorm16->if->isHangulLVT->return->mapping->firstUnit->extraData->charAt->fcd16->if->extraData->charAt->return
NormalizerImpl#getDecomposition(int):::Gets the decomposition for one code point.:::norm16->if->getNorm16->isMaybeOrNonZeroCC->return->decomp->if->isDecompNoAlgorithmic->mapAlgorithmic->getNorm16->if->if->return->else->return->UTF16->valueOf->else->if->isHangulLV->isHangulLVT->buffer->new->StringBuilder->Hangul->decompose->return->buffer->toString->mapping->length->extraData->charAt->return->extraData->substring
NormalizerImpl#decompose(CharSequence, int, int, StringBuilder, int):::Decomposes s[src, limit[ and writes the result to dest:::if->dest->setLength->buffer->new->ReorderingBuffer->decompose
NormalizerImpl#composeQuickCheck(CharSequence, int, int, boolean, boolean):::Very similar to compose(): Make the same changes in both places if relevant:::qcResult->prevBoundary->minNoMaybeCP->for
NormalizerImpl#getDecompose(int[], String[]):::Get the canonical decomposition sherman  for ComposedCharIter:::impl->Normalizer2->getNFDInstance->length->norm16->ch->i->while->if->else->if->else->if->s->impl->getDecomposition->if->return
Replaceable#length():::Returns the number of 16-bit code units in the text.:::
Replaceable#charAt(int):::Returns the 16-bit code unit at the given offset into the text.:::
Replaceable#getChars(int, int, char[], int):::Copies characters from this object into the destination character array:::
ReplaceableString#length():::Return the number of characters contained in this object:::return->buf->length
ReplaceableString#charAt(int):::Return the character at the given position in this object:::return->buf->charAt
ReplaceableString#getChars(int, int, char[], int):::Copies characters from this object into the destination character array:::if->buf->getChars
ReplaceableUCharacterIterator#clone():::Creates a copy of this iterator, does not clone the underlying Replaceableobject:::try->return->super->clone->catch->return->finally
ReplaceableUCharacterIterator#current():::Returns the current UTF16 character.:::if->replaceable->length->return->replaceable->charAt->return
ReplaceableUCharacterIterator#getLength():::Returns the length of the text:::return->replaceable->length
ReplaceableUCharacterIterator#getIndex():::Gets the current currentIndex in text.:::return
ReplaceableUCharacterIterator#next():::Returns next UTF16 character and increments the iterator's currentIndex by 1:::if->replaceable->length->return->replaceable->charAt->return
ReplaceableUCharacterIterator#previous():::Returns previous UTF16 character and decrements the iterator's currentIndex by 1:::if->return->replaceable->charAt->return
ReplaceableUCharacterIterator#setIndex(int):::Sets the currentIndex to the specified currentIndex in the text and returns that single UTF16 character at currentIndex:::if->replaceable->length->throw->new->IllegalArgumentException
Trie.DataManipulate#getFoldingOffset(int):::Called by com.ibm.icu.impl.Trie to extract from a lead surrogate's data the index array offset of the indexes for that lead surrogate.:::
Trie#getSurrogateOffset(char, char):::Gets the offset to the data which the surrogate pair points to.:::
Trie#getRawOffset(int, char):::Gets the offset to the data which the index ch after variable offset points to:::return
Trie#getBMPOffset(char):::Gets the offset to data which the BMP character points to Treats a lead surrogate as a normal code point.:::return->getRawOffset->getRawOffset
Trie#getLeadOffset(char):::Gets the offset to the data which this lead surrogate character points to:::return->getRawOffset
Trie#getCodePointOffset(int):::Internal trie getter from a code point:::if->return->else->if->return->getRawOffset->else->if->return->getBMPOffset->else->if->return->UTF16->getLeadSurrogate->getSurrogateOffset->else->return
Trie#unserialize(InputStream):::Parses the inputstream and creates the trie index with it. This is overwritten by the child classes.:::new->charArr->input->new->DataInputStream->for->i
Trie#isCharTrie():::Determines if this is a 16 bit trie:::return
Trie2#createFromSerialized(ByteBuffer):::Create a Trie2 from its serialized form:::outerByteOrder->bytes->order->try->header->new->UTrie2Header->bytes->getInt->switch->break->isBigEndian->bytes->order->break->throw->new->IllegalArgumentException->bytes->getChar->bytes->getChar->bytes->getChar->bytes->getChar->bytes->getChar->bytes->getChar->if->throw->new->IllegalArgumentException->This->new->Trie2_16->indexArraySize->new->charArr->i->for->for->return->catch->finally->bytes->order
Trie2#get(int):::Get the value for a code point as stored in the Trie2.:::
Trie2#getFromU16SingleLead(char):::Get the trie value for a UTF-16 code unit:::
Trie2#iterator()::: Create an iterator over the value ranges in this Trie2:::return->iterator
Trie2#iterator(ValueMapper):::Create an iterator over the value ranges from this Trie2:::return->new->Trie2Iterator
Trie2.Trie2Iterator#next()::: The main next() function for Trie2 iterators:::if->hasNext->throw->new->NoSuchElementException->if->endOfRange->val->mappedVal->if->get->mapper->map->rangeEnd->for->else->getFromU16SingleLead->mapper->map->rangeEndLS->for->return
Trie2#rangeEnd(int, int, int):::Find the last character in a contiguous range of characters with the same Trie2 value as the input character.:::c->limit->Math->min->for->if->return
Trie2_16#createFromSerialized(ByteBuffer):::Create a Trie2 from its serialized form:::return->Trie2->createFromSerialized
Trie2_16#get(int):::Get the value for a code point as stored in the Trie2.:::value->ix->if->if->return->if->return->if->return->if->return->return
Trie2_16#getFromU16SingleLead(char):::Get a Trie2 value for a UTF-16 code unit:::value->ix->return
UCharacter#digit(int, int):::Returns the numeric value of a decimal digit code point:::if->value->digit->if->UCharacterProperty->getEuropeanDigit->return->else->return
UCharacter#digit(int):::Returns the numeric value of a decimal digit code point:::return->digit
UCharacter#getType(int):::Returns a value indicating a code point's Unicode category:::return->getType
UCharacter#getDirection(int):::Returns the Bidirection property of a code point:::return->getClass
UCharacter#getMirror(int):::Maps the specified code point to a "mirror-image" code point:::return->getMirror
UCharacter#getBidiPairedBracket(int):::Maps the specified character to its paired bracket character:::return->getPairedBracket
UCharacter#getCombiningClass(int):::Returns the combining class of the argument codepoint:::return->Normalizer2->getNFDInstance->getCombiningClass
UCharacter#getUnicodeVersion():::Returns the version of Unicode data used.:::return
UCharacter#getCodePoint(char, char):::Returns a code point corresponding to the two UTF16 characters.:::if->UTF16->isLeadSurrogate->UTF16->isTrailSurrogate->return->UCharacterProperty->getRawSupplementary->throw->new->IllegalArgumentException
UCharacter#getAge(int):::Returns the "age" of the code point. The "age" is the Unicode version when the code point was first designated (as a non-character or for Private Use) or assigned a character:::if->throw->new->IllegalArgumentException->return->getAge
UCharacterIterator#getInstance(String):::Returns a UCharacterIterator object given a source string.:::return->new->ReplaceableUCharacterIterator
UCharacterIterator#getInstance(StringBuffer):::Returns a UCharacterIterator object given a source StringBuffer.:::return->new->ReplaceableUCharacterIterator
UCharacterIterator#getInstance(CharacterIterator):::Returns a UCharacterIterator object given a CharacterIterator.:::return->new->CharacterIteratorWrapper
UCharacterIterator#getLength():::Returns the length of the text:::
UCharacterIterator#getIndex():::Gets the current index in text.:::
UCharacterIterator#next():::Returns the UTF16 code unit at index, and increments to the next code unit (post-increment semantics):::
UCharacterIterator#nextCodePoint():::Returns the code point at index, and increments to the next code point (post-increment semantics):::ch1->next->if->UTF16->isLeadSurrogate->ch2->next->if->UTF16->isTrailSurrogate->return->UCharacterProperty->getRawSupplementary->else->if->previous->return
UCharacterIterator#previous():::Decrement to the position of the previous code unit in the text, and return it (pre-decrement semantics):::
UCharacterIterator#previousCodePoint():::Retreat to the start of the previous code point in the text, and return it (pre-decrement semantics):::ch1->previous->if->UTF16->isTrailSurrogate->ch2->previous->if->UTF16->isLeadSurrogate->return->UCharacterProperty->getRawSupplementary->else->if->next->return
UCharacterIterator#setIndex(int):::Sets the index to the specified index in the text.:::
UCharacterIterator#setToStart():::Sets the current index to the start.:::setIndex
UCharacterIterator#getText(char[], int):::Fills the buffer with the underlying text storage of the iterator If the buffer capacity is not enough a exception is thrown:::
UCharacterIterator#getText(char[]):::Convenience override for getText(char[], int) that provides an offset of 0.:::return->getText
UCharacterIterator#getText():::Convenience method for returning the underlying text storage as a string:::text->getLength->new->charArr->getText->return->new->String
UCharacterIterator#moveCodePointIndex(int):::Moves the current position by the number of code points specified, either forward or backward depending on the sign of delta (positive or negative respectively):::if->while->nextCodePoint->else->while->previousCodePoint->if->throw->new->IndexOutOfBoundsException->return->getIndex
UCharacterIterator#clone():::Creates a copy of this iterator, independent from other iterators:::return->super->clone
UCharacterProperty#getProperty(int):::Gets the main property value for code point ch.:::return->m_trie_->get
UCharacterProperty#getAdditional(int, int):::Gets the unicode additional properties:::if->return->return->m_additionalTrie_->get
UCharacterProperty#getAge(int):::Get the "age" of the code point. The "age" is the Unicode version when the code point was first designated (as a non-character or for Private Use) or assigned a character. This can be useful to avoid emitting code points to receiving processes that do not accept newer characters. The data is from the UCD file DerivedAge.txt. This API does not check the validity of the codepoint.:::version->getAdditional->return->VersionInfo->getInstance
UCharacterProperty#getRawSupplementary(char, char):::Forms a supplementary code point from the argument character<br> Note this is for internal use hence no checks for the validity of the surrogate characters are done:::return
UCharacterProperty#getMask(int):::Gets the type mask:::return
UCharacterProperty#getEuropeanDigit(int):::Returns the digit values of characters like 'A' - 'Z', normal, half-width and full-width:::if->return->if->return->if->return->return
UnicodeSet#set(UnicodeSet):::Make this object represent the same set as other.:::checkFrozen->clone->new->TreeSet<String>->return
UnicodeSet#size():::Returns the number of elements in this set (its cardinality) Note than the elements of a set may include both individual codepoints and strings.:::n->count->getRangeCount->for->i->return->strings->size
UnicodeSet#add(int):::Adds the specified character to this set if it is not already present:::checkFrozen->return->add_unchecked
UnicodeSet#add(CharSequence):::Adds the specified multicharacter to this set if it is not already present:::checkFrozen->cp->getSingleCP->if->strings->s->toString->add->else->add_unchecked->return
UnicodeSet#complement(int, int):::Complements the specified range in this set:::checkFrozen->if->throw->Utility->hex->new->IllegalArgumentException->if->throw->Utility->hex->new->IllegalArgumentException->if->range->xor->return
UnicodeSet#contains(int):::Returns true if this set contains the given character.:::if->throw->Utility->hex->new->IllegalArgumentException->if->return->bmpSet->contains->if->return->stringSpan->contains->i->findCodePoint->return
UnicodeSet#retainAll(UnicodeSet):::Retains only the elements in this set that are contained in the specified set:::checkFrozen->retain->strings->retainAll->return
UnicodeSet#clear():::Removes all of the elements from this set:::checkFrozen->strings->clear->return
UnicodeSet#getRangeCount():::Iteration method that returns the number of ranges contained in this set.:::return
UnicodeSet#getRangeStart(int):::Iteration method that returns the first character in the specified range of this set.:::return
UnicodeSet#getRangeEnd(int):::Iteration method that returns the last character in the specified range of this set.:::return
UnicodeSet#isFrozen():::Is this frozen, according to the Freezable interface?:::return
UnicodeSet#freeze():::Freeze this class, according to the Freezable interface.:::if->isFrozen->if->capacity->oldList->new->intArr->for->i->if->strings->isEmpty->new->ArrayList<String>->new->UnicodeSetStringSpan->if->stringSpan->needsStringSpanUTF16->new->BMPSet->return
UnicodeSet#span(CharSequence, SpanCondition):::Span a string using this UnicodeSet:::return->span
UnicodeSet#span(CharSequence, int, SpanCondition):::Span a string using this UnicodeSet:::end->s->length->if->else->if->return->if->return->bmpSet->span->if->return->stringSpan->span->else->if->strings->isEmpty->which->strSpan->new->ArrayList<String>->new->UnicodeSetStringSpan->if->strSpan->needsStringSpanUTF16->return->strSpan->span->return->spanCodePointsAndCount
UnicodeSet#spanAndCount(CharSequence, int, SpanCondition, OutputInt):::Same as span() but also counts the smallest number of set elements on any path across the span:::if->throw->new->IllegalArgumentException->end->s->length->if->else->if->return->if->return->stringSpan->spanAndCount->else->if->return->bmpSet->span->else->if->strings->isEmpty->which->strSpan->new->ArrayList<String>->new->UnicodeSetStringSpan->return->strSpan->spanAndCount->return->spanCodePointsAndCount
UnicodeSet#spanBack(CharSequence, int, SpanCondition):::Span a string backwards (from the fromIndex) using this UnicodeSet:::if->return->if->s->length->s->length->if->return->bmpSet->spanBack->if->return->stringSpan->spanBack->else->if->strings->isEmpty->which->strSpan->new->ArrayList<String>->new->UnicodeSetStringSpan->if->strSpan->needsStringSpanUTF16->return->strSpan->spanBack->spanContained->c->prev->do->Character->codePointBefore->if->contains->break->Character->charCount->while->return
UnicodeSet#cloneAsThawed():::Clone a thawed version of this class, according to the Freezable interface.:::result->new->UnicodeSet->return
UnicodeSetStringSpan#needsStringSpanUTF16():::Do the strings need to be checked in span() etc.?:::return
UnicodeSetStringSpan#contains(int):::For fast UnicodeSet::contains(c).:::return->spanSet->contains
UnicodeSetStringSpan#span(CharSequence, int, SpanCondition):::Spans a string.:::if->return->spanNot->spanLimit->spanSet->span->if->s->length->return->return->spanWithStrings
UnicodeSetStringSpan#spanAndCount(CharSequence, int, SpanCondition, OutputInt):::Spans a string and counts the smallest number of set elements on any path across the span:::if->return->spanNot->if->return->spanContainedAndCount->stringsLength->strings->size->length->s->length->pos->rest->count->while->cpLength->spanOne->maxInc->for->i->if->return->return
UnicodeSetStringSpan#spanBack(CharSequence, int, SpanCondition):::Span a string backwards.:::if->return->spanNotBack->pos->spanSet->spanBack->if->return->spanLength->initSize->if->offsets->setMaxLength->i->stringsLength->strings->size->spanBackLengthsOffset->if->for
UnicodeSetStringSpan#matches16CPB(CharSequence, int, int, String, int):::Compare 16-bit Unicode strings (which may be malformed UTF-16) at code point boundaries:::return->matches16->Character->s->charAt->isHighSurrogate->Character->s->charAt->isLowSurrogate->Character->s->charAt->isHighSurrogate->Character->s->charAt->isLowSurrogate
UnicodeSetStringSpan#spanOne(UnicodeSet, CharSequence, int, int):::Does the set contain the next code point? If so, return its length; otherwise return its negative length.:::c->s->charAt->if->c2->s->charAt->if->UTF16->isTrailSurrogate->supplementary->UCharacterProperty->getRawSupplementary->return->set->contains->return->set->contains
UTF16#charAt(String, int):::Extract a single UTF-32 value from a string:::single->source->charAt->if->return->return->_charAt
UTF16#charAt(CharSequence, int):::Extract a single UTF-32 value from a string:::single->source->charAt->if->return->return->_charAt
UTF16#charAt(char[], int, int, int):::Extract a single UTF-32 value from a substring:::if->throw->new->ArrayIndexOutOfBoundsException->single->if->isSurrogate->return->if->if->return->trail->if->isTrailSurrogate->return->UCharacterProperty->getRawSupplementary->else->if->return->lead->if->isLeadSurrogate->return->UCharacterProperty->getRawSupplementary->return
UTF16#getCharCount(int):::Determines how many chars this char32 requires:::if->return->return
UTF16#isSurrogate(char):::Determines whether the code value is a surrogate.:::return
UTF16#isTrailSurrogate(char):::Determines whether the character is a trail surrogate.:::return
UTF16#isLeadSurrogate(char):::Determines whether the character is a lead surrogate.:::return
UTF16#getLeadSurrogate(int):::Returns the lead surrogate:::if->return->return
UTF16#getTrailSurrogate(int):::Returns the trail surrogate:::if->return->return
UTF16#valueOf(int):::Convenience method corresponding to String.valueOf(char):::if->throw->new->IllegalArgumentException->return->toString
UTF16#append(StringBuffer, int):::Append a single UTF-32 value to the end of a StringBuffer:::if->throw->Integer->toHexString->new->IllegalArgumentException->if->target->getLeadSurrogate->append->target->getTrailSurrogate->append->else->target->append->return
UTF16#moveCodePointOffset(char[], int, int, int, int):::Shifts offset16 by the argument number of codepoints within a subarray.:::size->count->ch->result->if->throw->new->StringIndexOutOfBoundsException->if->throw->new->StringIndexOutOfBoundsException->if->throw->new->StringIndexOutOfBoundsException->if->if->throw->new->StringIndexOutOfBoundsException->while->if->isLeadSurrogate->isTrailSurrogate->else->if->throw->new->StringIndexOutOfBoundsException->for->if->throw->new->StringIndexOutOfBoundsException->return
Utility#escape(String):::Convert characters outside the range U+0020 to U+007F to Unicode escapes, and convert backslash to a double backslash.:::buf->new->StringBuilder->for->i->s->length->return->buf->toString
Utility#unescapeAt(String, int[]):::Convert an escape to a 32-bit code point value:::c->result->n->minDig->maxDig->bitsPerDigit->dig->i->braces->offset->length->s->length->if->return->Character->codePointAt->UTF16->getCharCount->switch->break->break->if->UTF16->charAt->else->break->UCharacter->digit->if->break->if->while->UTF16->charAt->UCharacter->digit->if->break->UTF16->getCharCount->if->return->if->if->return->if->return->if->UTF16->isLeadSurrogate->ahead->s->charAt->if->o->new->intArr->unescapeAt->if->UTF16->isTrailSurrogate->UCharacterProperty->getRawSupplementary->return->for->if->UTF16->charAt->UTF16->getCharCount->return->return
Utility#hex(long, int):::Supplies a zero-padded hex representation of an integer (without 0x):::if->return->negative->if->result->Long->toString->toUpperCase->if->result->length->result->length->substring->if->return->return
Utility#isUnprintable(int):::Return true if the character is NOT printable ASCII:::return
Utility#escapeUnprintable(T, int):::Escape unprintable characters using <backslash>uxxxx notation for U+0000 to U+FFFF and <backslash>Uxxxxxxxx for U+10000 and above:::try->if->isUnprintable->result->append->if->result->append->result->append->result->append->result->append->result->append->else->result->append->result->append->result->append->result->append->result->append->return->return->catch->throw->new->IllegalArgumentException->finally
VersionInfo#getInstance(String):::Returns an instance of VersionInfo with the argument version.:::length->version->length->array->count->index->while->c->version->charAt->if->else->if->throw->new->IllegalArgumentException->if->throw->new->IllegalArgumentException->for->i->return->getInstance
VersionInfo#getInstance(int, int, int, int):::Returns an instance of VersionInfo with the argument version.:::if->throw->new->IllegalArgumentException->version->getInt->key->Integer->valueOf->result->MAP_->get->if->new->VersionInfo->MAP_->put->return
VersionInfo#compareTo(VersionInfo):::Compares other with this VersionInfo.:::return
