D3DBlitLoops#register()::: d3 blit loops register:::blitIntArgbPreToSurface->new->D3DSwToSurfaceBlit->blitIntArgbPreToTexture->new->D3DSwToTextureBlit->transformBlitIntArgbPreToSurface->new->D3DSwToSurfaceTransform->primitives->new->D3DSurfaceToGDIWindowSurfaceBlit->new->D3DSurfaceToGDIWindowSurfaceScale->new->D3DSurfaceToGDIWindowSurfaceTransform->new->D3DSurfaceToSurfaceBlit->new->D3DSurfaceToSurfaceScale->new->D3DSurfaceToSurfaceTransform->new->D3DRTTSurfaceToSurfaceBlit->new->D3DRTTSurfaceToSurfaceScale->new->D3DRTTSurfaceToSurfaceTransform->new->D3DSurfaceToSwBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DSwToSurfaceBlit->new->D3DGeneralBlit->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceScale->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DSwToSurfaceTransform->new->D3DGeneralTransformedBlit->new->D3DTextureToSurfaceBlit->new->D3DTextureToSurfaceScale->new->D3DTextureToSurfaceTransform->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DSwToTextureBlit->new->D3DGeneralBlit->GraphicsPrimitiveMgr->register
D3DBlitLoops#createPackedParams(boolean, boolean, boolean, boolean, int, int):::Packs the given parameters into a single int value in order to save space on the rendering queue.:::return
D3DBlitLoops#enqueueBlit(RenderQueue, SurfaceData, SurfaceData, int, int, int, int, int, double, double, double, double):::Enqueues a BLIT operation with the given parameters:::buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putDouble->putDouble->buf->putDouble->putDouble->buf->src->getNativeOps->putLong->buf->dst->getNativeOps->putLong
D3DBlitLoops#Blit(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, int, boolean)::: d3 blit loops  blit:::ctxflags->if->srcData->getTransparency->d3dDst->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->addReference->if->D3DContext->d3dDst->getContext->setScratchSurface->else->D3DContext->validateContext->packedParams->createPackedParams->enqueueBlit->rq->flushNow->catch->finally->rq->unlock->if->d3dDst->getType->mgr->ScreenUpdateManager->getInstance->mgr->runUpdateNow
D3DBlitLoops#IsoBlit(SurfaceData, SurfaceData, BufferedImage, BufferedImageOp, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, boolean):::Note: The srcImg and biop parameters are only used when invoked from the D3DBufImgOps.renderImageWithOp() method; in all other cases, this method can be called with null values for those two parameters, and they will be effectively ignored.:::ctxflags->if->srcData->getTransparency->d3dDst->rq->D3DRenderQueue->getInstance->rtt->rq->lock->try->d3dSrc->srctype->d3dSrc->getType->srcCtxData->if->else->D3DContext->validateContext->if->D3DBufImgOps->enableBufImgOp->packedParams->createPackedParams->enqueueBlit->if->D3DBufImgOps->disableBufImgOp->catch->finally->rq->unlock->if->d3dDst->getType->mgr->ScreenUpdateManager->getInstance->mgr->runUpdateNow
D3DSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 surface to surface blit  blit:::D3DBlitLoops->IsoBlit
D3DSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: d3 surface to surface scale  scale:::D3DBlitLoops->IsoBlit
D3DSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 surface to surface transform  transform:::D3DBlitLoops->IsoBlit
D3DRTTSurfaceToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 surface to surface blit  blit:::D3DBlitLoops->IsoBlit
D3DRTTSurfaceToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: d3 surface to surface scale  scale:::D3DBlitLoops->IsoBlit
D3DRTTSurfaceToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 surface to surface transform  transform:::D3DBlitLoops->IsoBlit
D3DSurfaceToSwBlit#complexClipBlit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 surface to sw blit complex clip blit:::cachedSrc->if->srcTmp->get->type->convertFrom->performop->Blit->src->getSurfaceType->dst->getSurfaceType->getFromCache->performop->Blit->if->new->WeakReference<>
D3DSurfaceToSwBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 surface to sw blit  blit:::if->clip->getIntersectionXYWH->if->clip->isEmpty->return->clip->getLoX->clip->getLoY->clip->getLoX->clip->getLoY->clip->getWidth->clip->getHeight->if->clip->isRectangular->complexClipBlit->return->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->addReference->buf->rq->getBuffer->D3DContext->getContext->setScratchSurface->rq->ensureCapacityAndAlignment->buf->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putInt->putInt->buf->putInt->buf->src->getNativeOps->putLong->buf->dst->getNativeOps->putLong->rq->flushNow->catch->finally->rq->unlock
D3DSwToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 sw to surface blit  blit:::D3DBlitLoops->Blit
D3DSwToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: d3 sw to surface scale  scale:::D3DBlitLoops->Blit
D3DSwToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 sw to surface transform  transform:::D3DBlitLoops->Blit
D3DSwToTextureBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 sw to texture blit  blit:::D3DBlitLoops->Blit
D3DTextureToSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 texture to surface blit  blit:::D3DBlitLoops->IsoBlit
D3DTextureToSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: d3 texture to surface scale  scale:::D3DBlitLoops->IsoBlit
D3DTextureToSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 texture to surface transform  transform:::D3DBlitLoops->IsoBlit
D3DGeneralBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 general blit  blit:::convertsrc->Blit->src->getSurfaceType->getFromCache->cachedSrc->if->srcTmp->get->convertFrom->performop->Blit->if->new->WeakReference<>
D3DGeneralTransformedBlit#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 general transformed blit  transform:::convertsrc->Blit->src->getSurfaceType->getFromCache->cachedSrc->srcTmp->get->convertFrom->performop->Transform->if->new->WeakReference<>
D3DSurfaceToGDIWindowSurfaceBlit#Blit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int)::: d3 surface to window surface blit  blit:::D3DVolatileSurfaceManager->handleVItoScreenOp
D3DSurfaceToGDIWindowSurfaceScale#Scale(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, double, double, double, double)::: d3 surface to window surface scale  scale:::D3DVolatileSurfaceManager->handleVItoScreenOp
D3DSurfaceToGDIWindowSurfaceTransform#Transform(SurfaceData, SurfaceData, Composite, Region, AffineTransform, int, int, int, int, int, int, int)::: d3 surface to window surface transform  transform:::D3DVolatileSurfaceManager->handleVItoScreenOp
D3DBufImgOps#renderImageWithOp(SunGraphics2D, BufferedImage, BufferedImageOp, int, int):::This method is called from D3DDrawImage.transformImage() only:::if->if->isConvolveOpValid->return->else->if->if->isRescaleOpValid->return->else->if->if->isLookupOpValid->return->else->return->dstData->if->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->d3dSrc->gd->d3dSrc->getDeviceConfiguration->getDevice->if->d3dSrc->getType->gd->isCapPresent->return->sw->img->getWidth->sh->img->getHeight->D3DBlitLoops->sg->getCompClip->IsoBlit->return
D3DContext#invalidateCurrentContext():::Invalidates the currentContext field to ensure that we properly revalidate the D3DContext (make it current, etc.) next time through the validate() method:::if->currentContext->invalidateContext->rq->D3DRenderQueue->getInstance->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow
D3DContext#setScratchSurface(D3DContext):::Sets the current context on the native level to be the one passed as the argument:::if->rq->D3DRenderQueue->getInstance->buf->rq->getBuffer->rq->ensureCapacity->buf->putInt->buf->d3dc->getDevice->getScreen->putInt
D3DContext#getRenderQueue()::: d3 context get render queue:::return->D3DRenderQueue->getInstance
D3DContext#saveState()::: d3 context save state:::invalidateContext->invalidateCurrentContext->setScratchSurface->rq->ensureCapacity->buf->putInt->rq->flushNow
D3DContext#restoreState()::: d3 context restore state:::invalidateContext->invalidateCurrentContext->setScratchSurface->rq->ensureCapacity->buf->putInt->rq->flushNow
D3DContext#getDevice()::: d3 context get device:::return
D3DContext.D3DContextCaps#toString()::: d3 context caps to string:::buf->super->toString->new->StringBuffer->if->buf->append->if->buf->append->if->buf->append->if->buf->append->return->buf->toString
D3DDrawImage#renderImageXform(SunGraphics2D, Image, AffineTransform, int, int, int, int, int, Color)::: d3 draw image render image xform:::if->dstData->srcData->dstData->getSourceSurfaceData->if->isBgOperation->srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blit->TransformBlit->getFromCache->if->blit->sg->getCompClip->Transform->return->super->renderImageXform
D3DDrawImage#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: d3 draw image transform image:::if->if->atop->atop->getTransform->atop->getInterpolationType->transformImage->return->else->if->D3DBufImgOps->renderImageWithOp->return->op->filter->copyImage
D3DGraphicsConfig#createManagedSurface(int, int, int)::: d3 graphics config create managed surface:::return->D3DSurfaceData->getColorModel->createData
D3DGraphicsConfig#displayChanged()::: d3 graphics config display changed:::super->displayChanged->rq->D3DRenderQueue->getInstance->rq->lock->try->D3DContext->invalidateCurrentContext->catch->finally->rq->unlock
D3DGraphicsConfig#getColorModel(int)::: d3 graphics config get color model:::switch->return->new->DirectColorModel->return->new->DirectColorModel->cs->ColorSpace->getInstance->return->new->DirectColorModel->return
D3DGraphicsConfig#toString()::: d3 graphics config to string:::return
D3DGraphicsConfig#createSurfaceData(WComponentPeer, int):::Creates a new SurfaceData that will be associated with the given WComponentPeer:::return->super->createSurfaceData
D3DGraphicsConfig#assertOperationSupported(Component, int, BufferCapabilities):::Checks that the requested configuration is natively supported; if not, an AWTException is thrown.:::if->throw->new->AWTException->if->caps->getFlipContents->throw->new->AWTException
D3DGraphicsConfig#createBackBuffer(WComponentPeer):::Creates a D3D-based backbuffer for the given peer and returns the image wrapper.:::target->peer->getTarget->w->Math->target->getWidth->max->h->Math->target->getHeight->max->return->new->SunVolatileImage
D3DGraphicsConfig#flip(WComponentPeer, Component, VolatileImage, int, int, int, int, BufferCapabilities.FlipContents):::Performs the native D3D flip operation for the given target Component.:::d3dvsm->SurfaceManager->getManager->sd->d3dvsm->getPrimarySurfaceData->if->d3dsd->scaleX->sd->getDefaultScaleX->scaleY->sd->getDefaultScaleY->if->sx1->Math->floor->sy1->Math->floor->sx2->Math->ceil->sy2->Math->ceil->D3DSurfaceData->swapBuffers->else->D3DSurfaceData->swapBuffers->else->g->peer->getGraphics->try->g->drawImage->catch->finally->g->dispose->if->g->backBuffer->getGraphics->try->g->target->getBackground->setColor->g->backBuffer->getWidth->backBuffer->getHeight->fillRect->catch->finally->g->dispose
D3DGraphicsConfig.D3DBufferCaps#isMultiBufferAvailable()::: d3 buffer caps is multi buffer available:::return
D3DGraphicsConfig#getBufferCapabilities()::: d3 graphics config get buffer capabilities:::if->new->D3DBufferCaps->return
D3DGraphicsConfig.D3DImageCaps#isTrueVolatile()::: d3 image caps is true volatile:::return
D3DGraphicsConfig#getImageCapabilities()::: d3 graphics config get image capabilities:::return
D3DGraphicsConfig#getD3DDevice()::: d3 graphics config get d3 device:::return
D3DGraphicsConfig#getContext()::: d3 graphics config get context:::return->device->getContext
D3DGraphicsConfig#createCompatibleVolatileImage(int, int, int, int)::: d3 graphics config create compatible volatile image:::if->return->isOpaque->if->cap->if->device->isCapPresent->return->else->if->if->device->isCapPresent->return->vi->new->AccelTypedVolatileImage->sd->vi->getDestSurface->if->getType->vi->flush->return
D3DGraphicsConfig#getContextCapabilities()::: d3 graphics config get context capabilities:::return->device->getContextCapabilities
D3DGraphicsDevice#initD3D()::: d3 graphics device init d3 d:::
D3DGraphicsDevice#createDevice(int):::Used to construct a Direct3D-enabled GraphicsDevice.:::if->return->d3dCaps->getDeviceCaps->if->d3dCaps->getCaps->if->WindowsFlags->isD3DVerbose->println->return->if->WindowsFlags->isD3DVerbose->println->gd->new->D3DGraphicsDevice->return
D3DGraphicsDevice#getDeviceCapsNative(int)::: d3 graphics device get device caps native:::
D3DGraphicsDevice#getDeviceIdNative(int)::: d3 graphics device get device id native:::
D3DGraphicsDevice#getDeviceCaps(int)::: d3 graphics device get device caps:::d3dCaps->rq->D3DRenderQueue->getInstance->rq->lock->try->res->new->Result->rq->new->Runnable->flushAndInvokeNow->new->D3DContextCaps->catch->finally->rq->unlock->return->new->D3DContextCaps
D3DGraphicsDevice#isCapPresent(int)::: d3 graphics device is cap present:::return->d3dCaps->getCaps
D3DGraphicsDevice#isD3DEnabledOnDevice()::: d3 graphics device is d3 enabled on device:::return->isValid->isCapPresent
D3DGraphicsDevice#isD3DAvailable():::Returns true if d3d pipeline has been successfully initialized.:::return
D3DGraphicsDevice#getToplevelOwner(Window):::Return the owning Frame for a given Window:::owner->while->owner->getOwner->if->return->return
D3DGraphicsDevice#enterFullScreenExclusiveNative(int, long)::: d3 graphics device enter full screen exclusive native:::
D3DGraphicsDevice#enterFullScreenExclusive(int, WindowPeer)::: d3 graphics device enter full screen exclusive:::wpeer->AWTAccessor->getComponentAccessor->getPeer->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock->if->super->enterFullScreenExclusive
D3DGraphicsDevice#exitFullScreenExclusiveNative(int)::: d3 graphics device exit full screen exclusive native:::
D3DGraphicsDevice#exitFullScreenExclusive(int, WindowPeer)::: d3 graphics device exit full screen exclusive:::if->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock->else->super->exitFullScreenExclusive
D3DGraphicsDevice.D3DFSWindowAdapter#windowDeactivated(WindowEvent)::: d3 window adapter window deactivated:::D3DRenderQueue->getInstance->restoreDevices
D3DGraphicsDevice.D3DFSWindowAdapter#windowActivated(WindowEvent)::: d3 window adapter window activated:::D3DRenderQueue->getInstance->restoreDevices
D3DGraphicsDevice#addFSWindowListener(Window)::: d3 graphics device add window listener:::acc->AWTAccessor->getComponentAccessor->if->getToplevelOwner->realFSWindow->getBounds->fp->acc->getPeer->realFSWindow->isVisible->r->w->getBounds->fp->reshape->fp->setVisible->else->realFSWindow->isAlwaysOnTop->acc->getPeer->setAlwaysOnTop->new->D3DFSWindowAdapter->realFSWindow->addWindowListener
D3DGraphicsDevice#removeFSWindowListener(Window)::: d3 graphics device remove window listener:::realFSWindow->removeWindowListener->wpeer->AWTAccessor->getComponentAccessor->getPeer->if->if->if->if->wpeer->reshape->if->wpeer->setVisible->if->wpeer->setAlwaysOnTop
D3DGraphicsDevice#getCurrentDisplayModeNative(int)::: d3 graphics device get current display mode native:::
D3DGraphicsDevice#getCurrentDisplayMode(int)::: d3 graphics device get current display mode:::rq->D3DRenderQueue->getInstance->rq->lock->try->res->new->Result->rq->new->Runnable->flushAndInvokeNow->if->return->super->getCurrentDisplayMode->return->catch->finally->rq->unlock
D3DGraphicsDevice#configDisplayModeNative(int, long, int, int, int, int)::: d3 graphics device config display mode native:::
D3DGraphicsDevice#configDisplayMode(int, WindowPeer, int, int, int, int)::: d3 graphics device config display mode:::if->super->configDisplayMode->return->wpeer->AWTAccessor->getComponentAccessor->getPeer->if->getFullScreenWindow->screenBounds->getDefaultConfiguration->getBounds->wpeer->reshape->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock
D3DGraphicsDevice#enumDisplayModesNative(int, ArrayList)::: d3 graphics device enum display modes native:::
D3DGraphicsDevice#enumDisplayModes(int, ArrayList)::: d3 graphics device enum display modes:::rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->if->modes->size->modes->getCurrentDisplayModeNative->add->catch->finally->rq->unlock
D3DGraphicsDevice#getAvailableAcceleratedMemoryNative(int)::: d3 graphics device get available accelerated memory native:::
D3DGraphicsDevice#getAvailableAcceleratedMemory()::: d3 graphics device get available accelerated memory:::rq->D3DRenderQueue->getInstance->rq->lock->try->res->new->Result->rq->new->Runnable->flushAndInvokeNow->return->catch->finally->rq->unlock
D3DGraphicsDevice#getConfigurations()::: d3 graphics device get configurations:::if->if->isD3DEnabledOnDevice->getDefaultConfiguration->if->new->GraphicsConfigurationArr->return->configs->clone->return->super->getConfigurations
D3DGraphicsDevice#getDefaultConfiguration()::: d3 graphics device get default configuration:::if->if->isD3DEnabledOnDevice->new->D3DGraphicsConfig->else->super->getDefaultConfiguration->return
D3DGraphicsDevice#isD3DAvailableOnDeviceNative(int)::: d3 graphics device is d3 available on device native:::
D3DGraphicsDevice#isD3DAvailableOnDevice(int)::: d3 graphics device is d3 available on device:::if->return->rq->D3DRenderQueue->getInstance->rq->lock->try->res->new->Result->rq->new->Runnable->flushAndInvokeNow->return->catch->finally->rq->unlock
D3DGraphicsDevice#getContext()::: d3 graphics device get context:::return
D3DGraphicsDevice#getContextCapabilities()::: d3 graphics device get context capabilities:::return
D3DGraphicsDevice#displayChanged()::: d3 graphics device display changed:::super->displayChanged->if->getScreen->getDeviceCaps
D3DGraphicsDevice#invalidate(int)::: d3 graphics device invalidate:::super->invalidate->new->D3DContextCaps
D3DMaskBlit#register()::: d3 mask blit register:::primitives->new->D3DMaskBlit->new->D3DMaskBlit->new->D3DMaskBlit->new->D3DMaskBlit->new->D3DMaskBlit->new->D3DMaskBlit->GraphicsPrimitiveMgr->register
D3DMaskBlit#validateContext(SurfaceData, Composite, Region)::: d3 mask blit validate context:::d3dDst->D3DContext->validateContext
D3DMaskFill#register()::: d3 mask fill register:::primitives->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->new->D3DMaskFill->GraphicsPrimitiveMgr->register
D3DMaskFill#maskFill(int, int, int, int, int, int, int, byte[])::: d3 mask fill mask fill:::
D3DMaskFill#validateContext(SunGraphics2D, Composite, int)::: d3 mask fill validate context:::dstData->try->catch->throw->new->InvalidPipeException->finally->D3DContext->sg2d->getCompClip->validateContext
D3DPaints#isValid(SunGraphics2D):::Attempts to locate an implementation corresponding to the paint state of the provided SunGraphics2D object:::impl->impls->get->return->impl->isPaintValid
D3DPaints#isPaintValid(SunGraphics2D):::Returns true if this implementation is able to accelerate the Paint object associated with, and under the conditions of, the provided SunGraphics2D instance; otherwise returns false.:::
D3DPaints.Gradient#isPaintValid(SunGraphics2D):::Returns true if the given GradientPaint instance can be used by the accelerated D3DPaints.Gradient implementation:::dstData->gd->dstData->getDeviceConfiguration->getDevice->return->gd->isCapPresent
D3DPaints.Texture#isPaintValid(SunGraphics2D):::Returns true if the given TexturePaint instance can be used by the accelerated BufferedPaints.Texture implementation:::paint->dstData->bi->paint->getImage->gd->dstData->getDeviceConfiguration->getDevice->imgw->bi->getWidth->imgh->bi->getHeight->if->gd->isCapPresent->if->return->if->gd->isCapPresent->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->d3dData->if->d3dData->getType->return->return
D3DPaints.MultiGradient#isPaintValid(SunGraphics2D):::Returns true if the given MultipleGradientPaint instance can be used by the accelerated D3DPaints.MultiGradient implementation:::paint->if->paint->getFractions->return->dstData->gd->dstData->getDeviceConfiguration->getDevice->if->gd->isCapPresent->return->return
D3DPaints.LinearGradient#isPaintValid(SunGraphics2D)::: linear gradient is paint valid:::paint->if->paint->getFractions->paint->getCycleMethod->paint->getColorSpace->dstData->gd->dstData->getDeviceConfiguration->getDevice->if->gd->isCapPresent->return->return->super->isPaintValid
D3DRenderer#validateContext(SunGraphics2D)::: d3 renderer validate context:::ctxflags->getTransparency->dstData->try->catch->throw->new->InvalidPipeException->finally->D3DContext->sg2d->getCompClip->validateContext
D3DRenderer#validateContextAA(SunGraphics2D)::: d3 renderer validate context a:::ctxflags->dstData->try->catch->throw->new->InvalidPipeException->finally->D3DContext->sg2d->getCompClip->validateContext
D3DRenderer#copyArea(SunGraphics2D, int, int, int, int, int, int)::: d3 renderer copy area:::rq->lock->try->ctxflags->getTransparency->dstData->try->catch->throw->new->InvalidPipeException->finally->D3DContext->sg2d->getCompClip->validateContext->rq->ensureCapacity->buf->putInt->buf->putInt->putInt->putInt->putInt->buf->putInt->putInt->catch->finally->rq->unlock
D3DRenderer#drawPoly(int[], int[], int, boolean, int, int)::: d3 renderer draw poly:::
D3DRenderer#traceWrap()::: d3 renderer trace wrap:::return->new->Tracer
D3DRenderer.Tracer#getAAParallelogramPipe()::: tracer get parallelogram pipe:::realpipe->d3dr->getAAParallelogramPipe->return->new->ParallelogramPipe
D3DRenderer.Tracer#validateContext(SunGraphics2D)::: tracer validate context:::d3dr->validateContext
D3DRenderer.Tracer#drawLine(SunGraphics2D, int, int, int, int)::: tracer draw line:::GraphicsPrimitive->tracePrimitive->d3dr->drawLine
D3DRenderer.Tracer#drawRect(SunGraphics2D, int, int, int, int)::: tracer draw rect:::GraphicsPrimitive->tracePrimitive->d3dr->drawRect
D3DRenderer.Tracer#drawPoly(SunGraphics2D, int[], int[], int, boolean)::: tracer draw poly:::GraphicsPrimitive->tracePrimitive->d3dr->drawPoly
D3DRenderer.Tracer#fillRect(SunGraphics2D, int, int, int, int)::: tracer fill rect:::GraphicsPrimitive->tracePrimitive->d3dr->fillRect
D3DRenderer.Tracer#drawPath(SunGraphics2D, Path2D.Float, int, int)::: tracer draw path:::GraphicsPrimitive->tracePrimitive->d3dr->drawPath
D3DRenderer.Tracer#fillPath(SunGraphics2D, Path2D.Float, int, int)::: tracer fill path:::GraphicsPrimitive->tracePrimitive->d3dr->fillPath
D3DRenderer.Tracer#fillSpans(SunGraphics2D, SpanIterator, int, int)::: tracer fill spans:::GraphicsPrimitive->tracePrimitive->d3dr->fillSpans
D3DRenderer.Tracer#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: tracer fill parallelogram:::GraphicsPrimitive->tracePrimitive->d3dr->fillParallelogram
D3DRenderer.Tracer#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: tracer draw parallelogram:::GraphicsPrimitive->tracePrimitive->d3dr->drawParallelogram
D3DRenderer.Tracer#copyArea(SunGraphics2D, int, int, int, int, int, int)::: tracer copy area:::GraphicsPrimitive->tracePrimitive->d3dr->copyArea
D3DRenderQueue#getInstance():::Returns the single D3DRenderQueue instance:::if->new->D3DRenderQueue->theInstance->new->Runnable->flushAndInvokeNow->return
D3DRenderQueue#sync():::Flushes the single D3DRenderQueue instance synchronously:::if->mgr->ScreenUpdateManager->getInstance->mgr->runUpdateNow->theInstance->lock->try->theInstance->ensureCapacity->theInstance->getBuffer->putInt->theInstance->flushNow->catch->finally->theInstance->unlock
D3DRenderQueue#restoreDevices():::Attempt to restore the devices if they're in the lost state:::rq->getInstance->rq->lock->try->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow->catch->finally->rq->unlock
D3DRenderQueue#isRenderQueueThread()::: d3 render queue is render queue thread:::return->Thread->currentThread
D3DRenderQueue#disposeGraphicsConfig(long):::Disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread.:::rq->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
D3DRenderQueue#flushNow()::: d3 render queue flush now:::flushBuffer
D3DRenderQueue#flushAndInvokeNow(Runnable)::: d3 render queue flush and invoke now:::flushBuffer
D3DRenderQueue#flushBuffer(long, int, Runnable)::: d3 render queue flush buffer:::
D3DRenderQueue#flushBuffer(Runnable)::: d3 render queue flush buffer:::limit->buf->position->if->buf->getAddress->flushBuffer->buf->clear->refSet->clear
D3DScreenUpdateManager#createScreenSurface(Win32GraphicsConfig, WComponentPeer, int, boolean):::If possible, creates a D3DWindowSurfaceData (which is actually a back-buffer surface):::if->return->super->createScreenSurface->sd->if->canUseD3DOnScreen->try->D3DSurfaceData->createData->catch->finally->if->GDIWindowSurfaceData->createData->if->repaintPeerTarget->return
D3DScreenUpdateManager#canUseD3DOnScreen(WComponentPeer, Win32GraphicsConfig, int):::Determines if we can use a d3d surface for onscreen rendering for this peer:::if->return->d3dgc->d3dgd->d3dgc->getD3DDevice->peerName->peer->getClass->getName->r->peer->getBounds->target->peer->getTarget->fsw->d3dgd->getFullScreenWindow->return->WindowsFlags->isD3DOnScreenEnabled->d3dgd->isD3DEnabledOnDevice->peer->isAccelCapable->hasHWChildren->peerName->equals->peerName->equals->peerName->equals->peerName->equals->peerName->equals->peerName->equals
D3DScreenUpdateManager#createGraphics(SurfaceData, WComponentPeer, Color, Color, Font):::Creates a graphics object for the passed in surface data:::if->d3dw->if->d3dw->isSurfaceLost->validate->trackScreenSurface->return->new->SunGraphics2D->getGdiSurface->return->super->createGraphics
D3DScreenUpdateManager#repaintPeerTarget(WComponentPeer):::Posts a repaint event for the peer's target to the EDT:::target->peer->getTarget->bounds->AWTAccessor->getComponentAccessor->getBounds->peer->handlePaint
D3DScreenUpdateManager#trackScreenSurface(SurfaceData):::Adds a surface to the list of tracked surfaces.:::if->synchronized->if->new->ArrayList<D3DWindowSurfaceData>->d3dw->if->d3dwSurfaces->contains->d3dwSurfaces->add->startUpdateThread
D3DScreenUpdateManager#dropScreenSurface(SurfaceData)::: d3 screen update manager drop screen surface:::if->d3dw->removeGdiSurface->d3dwSurfaces->remove
D3DScreenUpdateManager#getReplacementScreenSurface(WComponentPeer, SurfaceData)::: d3 screen update manager get replacement screen surface:::newSurface->super->getReplacementScreenSurface->trackScreenSurface->return
D3DScreenUpdateManager#removeGdiSurface(D3DWindowSurfaceData):::Remove the gdi surface corresponding to the passed d3dw surface from list of the cached gdi surfaces.:::if->gdisd->gdiSurfaces->get->if->gdisd->invalidate->gdiSurfaces->remove
D3DScreenUpdateManager#startUpdateThread():::If the update thread hasn't yet been created, it will be; otherwise it is awaken:::if->AccessController->name->t->ThreadGroupUtils->getRootThreadGroup->new->Thread->t->setPriority->t->setDaemon->return->doPrivileged->screenUpdater->start->else->wakeUpUpdateThread
D3DScreenUpdateManager#wakeUpUpdateThread():::Wakes up the screen updater thread:::synchronized->runLock->notifyAll
D3DScreenUpdateManager#runUpdateNow():::Wakes up the screen updater thread and waits for the completion of the update:::synchronized->if->d3dwSurfaces->size->return->synchronized->runLock->notifyAll->while->try->runLock->wait->catch->finally
D3DScreenUpdateManager#run()::: d3 screen update manager run:::while->synchronized->timeout->d3dwSurfaces->size->if->try->runLock->wait->catch->finally->surfaces->new->D3DWindowSurfaceDataArr->synchronized->d3dwSurfaces->toArray->foreach->if->sd->isValid->sd->isDirty->sd->isSurfaceLost->if->sd->isSurfaceLost->rq->D3DRenderQueue->getInstance->rq->lock->try->r->sd->getBounds->D3DSurfaceData->swapBuffers->sd->markClean->catch->finally->rq->unlock->else->if->validate->sd->getPeer->replaceSurfaceDataLater->synchronized->runLock->notifyAll
D3DScreenUpdateManager#validate(D3DWindowSurfaceData):::Restores the passed surface if it was lost, resets the lost status.:::if->sd->isSurfaceLost->try->sd->restoreSurface->bg->sd->getPeer->getBackgroundNoSync->sg2d->new->SunGraphics2D->sg2d->sd->getBounds->sd->getBounds->fillRect->sg2d->dispose->sd->markClean->sd->getPeer->repaintPeerTarget->catch->return->finally->return
D3DScreenUpdateManager#getGdiSurface(D3DWindowSurfaceData):::Creates (or returns a cached one) gdi surface for the same peer as the passed d3dw surface has.:::if->new->HashMap<D3DWindowSurfaceData,GDIWindowSurfaceData>->gdisd->gdiSurfaces->get->if->GDIWindowSurfaceData->d3dw->getPeer->createData->gdiSurfaces->put->return
D3DScreenUpdateManager#hasHWChildren(Component):::Returns true if the component has heavyweight children.:::acc->AWTAccessor->getComponentAccessor->if->foreach->getComponents->if->acc->getPeer->hasHWChildren->return->return
D3DSurfaceData#initTexture(long, boolean, boolean)::: d3 surface data init texture:::
D3DSurfaceData#initFlipBackbuffer(long, long, int, int, int)::: d3 surface data init flip backbuffer:::
D3DSurfaceData#initRTSurface(long, boolean)::: d3 surface data init surface:::
D3DSurfaceData#initOps(int, int, int)::: d3 surface data init ops:::
D3DSurfaceData#getDefaultScaleX()::: d3 surface data get default scale x:::return
D3DSurfaceData#getDefaultScaleY()::: d3 surface data get default scale y:::return
D3DSurfaceData#makeProxyFor(SurfaceData)::: d3 surface data make proxy for:::return->D3DSurfaceDataProxy->graphicsDevice->getDefaultConfiguration->createProxy
D3DSurfaceData#createData(WComponentPeer, Image):::Creates a SurfaceData object representing the back buffer of a double-buffered on-screen Window.:::gc->getGC->if->peer->isAccelCapable->return->caps->peer->getBackBufferCaps->vSyncType->if->getVSync->r->peer->getBounds->flip->caps->getFlipContents->swapEffect->if->else->if->else->return->peer->getColorModel->peer->getBackBuffersNum->new->D3DSurfaceData
D3DSurfaceData#createData(WComponentPeer):::Returns a WINDOW type of surface - a swap chain which serves as an on-screen surface, handled by the D3DScreenUpdateManager:::gc->getGC->if->peer->isAccelCapable->return->return->new->D3DWindowSurfaceData
D3DSurfaceData#createData(D3DGraphicsConfig, int, int, ColorModel, Image, int):::Creates a SurfaceData object representing an off-screen buffer (either a plain surface or Texture).:::if->isOpaque->cm->getTransparency->cap->if->gc->getD3DDevice->isCapPresent->ret->try->new->D3DSurfaceData->catch->if->if->getForcedAccelSurfaceType->new->D3DSurfaceData->finally->return
D3DSurfaceData#getCustomSurfaceType(int):::Returns the appropriate SurfaceType corresponding to the given D3D surface type constant (e.g:::switch->return->return->return
D3DSurfaceData#initSurfaceNow()::: d3 surface data init surface now:::isOpaque->getTransparency->switch->return->getNativeOps->initRTSurface->return->getNativeOps->initTexture->return->getNativeOps->initTexture->return->getNativeOps->peer->getData->syncType->id->initFlipBackbuffer->return
D3DSurfaceData#initSurface():::Initializes the appropriate D3D offscreen surface based on the value of the type parameter:::synchronized->status->new->Status->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->if->throw->new->InvalidPipeException->catch->finally->rq->unlock
D3DSurfaceData#getContext():::Returns the D3DContext for the GraphicsConfig associated with this surface.:::return->graphicsDevice->getContext
D3DSurfaceData#getType():::Returns one of the surface type constants defined above.:::return
D3DSurfaceData#dbGetPixelNative(long, int, int)::: d3 surface data db get pixel native:::
D3DSurfaceData#dbSetPixelNative(long, int, int, int)::: d3 surface data db set pixel native:::
D3DSurfaceData.D3DDataBufferNative#getElem(int, int, SurfaceData)::: d3 data buffer native get elem:::if->sData->isSurfaceLost->return->retPixel->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock->return
D3DSurfaceData.D3DDataBufferNative#setElem(int, int, int, SurfaceData)::: d3 data buffer native set elem:::if->sData->isSurfaceLost->return->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->sData->markDirty->catch->finally->rq->unlock
D3DSurfaceData#getRaster(int, int, int, int)::: d3 surface data get raster:::if->dcm->getColorModel->smHw->dataType->scanStride->if->dcm->getPixelSize->else->dcm->getMasks->new->SinglePixelPackedSampleModel->dbn->new->D3DDataBufferNative->WritableRasterNative->createNativeRaster->return
D3DSurfaceData#canRenderLCDText(SunGraphics2D):::For now, we can only render LCD text if:   - the pixel shaders are available, and   - blending is disabled, and   - the source color is opaque   - and the destination is opaque:::return->graphicsDevice->isCapPresent->getTransparency
D3DSurfaceData#disableAccelerationForSurface():::If acceleration should no longer be used for this surface:::if->sm->SurfaceManager->getManager->if->setSurfaceLost->setAccelerationEnabled
D3DSurfaceData#validatePipe(SunGraphics2D)::: d3 surface data validate pipe:::textpipe->validated->if->super->validatePipe->disableAccelerationForSurface->return->if->getRule->else->super->validatePipe->txPipe->nonTxPipe->if->if->if->else->if->if->D3DPaints->isValid->else->if->if->graphicsDevice->isCapPresent->if->super->validatePipe->aaConverter->new->PixelToParallelogramConverter->else->if->if->if->else->if->else->else->if->super->validatePipe
D3DSurfaceData#getMaskFill(SunGraphics2D)::: d3 surface data get mask fill:::if->if->D3DPaints->isValid->graphicsDevice->isCapPresent->return->return->super->getMaskFill
D3DSurfaceData#copyArea(SunGraphics2D, int, int, int, int, int, int)::: d3 surface data copy area:::if->return->d3dRenderPipe->copyArea->return
D3DSurfaceData#flush()::: d3 surface data flush:::rq->D3DRenderQueue->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->getNativeOps->putLong->rq->flushNow->catch->finally->rq->unlock
D3DSurfaceData#dispose(long):::Disposes the native resources associated with the given D3DSurfaceData (referenced by the pData parameter):::rq->D3DRenderQueue->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
D3DSurfaceData#swapBuffers(D3DSurfaceData, int, int, int, int)::: d3 surface data swap buffers:::pData->sd->getNativeOps->rq->D3DRenderQueue->getInstance->if->D3DRenderQueue->isRenderQueueThread->if->rq->tryLock->target->sd->getPeer->getTarget->SunToolkit->new->Runnable->executeOnEventHandlerThread->return->else->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->buf->putInt->buf->putInt->buf->putInt->buf->putInt->rq->flushNow->catch->finally->rq->unlock
D3DSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
D3DSurfaceData#getBounds()::: d3 surface data get bounds:::if->scaleX->getDefaultScaleX->scaleY->getDefaultScaleY->r->peer->getBounds->Region->clipRound->Region->clipRound->return->else->return->new->Rectangle
D3DSurfaceData#getNativeBounds()::: d3 surface data get native bounds:::rq->D3DRenderQueue->getInstance->rq->lock->try->return->new->Rectangle->catch->finally->rq->unlock
D3DSurfaceData#getDeviceConfiguration()::: d3 surface data get device configuration:::return->graphicsDevice->getDefaultConfiguration
D3DSurfaceData#getReplacement()::: d3 surface data get replacement:::return->restoreContents
D3DSurfaceData#getGC(WComponentPeer)::: d3 surface data get c:::gc->if->peer->getGraphicsConfiguration->else->env->GraphicsEnvironment->getLocalGraphicsEnvironment->gd->env->getDefaultScreenDevice->gd->getDefaultConfiguration->return
D3DSurfaceData#restoreSurface():::Attempts to restore the surface by initializing the native data:::initSurface
D3DSurfaceData#getPeer()::: d3 surface data get peer:::return
D3DSurfaceData#setSurfaceLost(boolean):::We need to let the surface manager know that the surface is lost so that for example BufferStrategy.contentsLost() returns correct result:::super->setSurfaceLost->if->sm->SurfaceManager->getManager->sm->acceleratedSurfaceLost
D3DSurfaceData#getNativeResourceNative(long, int)::: d3 surface data get native resource native:::
D3DSurfaceData#getNativeResource(int):::Returns a pointer to the native resource of specified resType associated with this surface:::return->getNativeOps->getNativeResourceNative
D3DSurfaceData.D3DWindowSurfaceData#getReplacement():::  Overridden to use ScreenUpdateManager to obtain the replacement surface.:::mgr->ScreenUpdateManager->getInstance->return->mgr->getReplacementScreenSurface
D3DSurfaceData.D3DWindowSurfaceData#getDestination():::Returns destination Component associated with this SurfaceData.:::return->peer->getTarget
D3DSurfaceData.D3DWindowSurfaceData#disableAccelerationForSurface()::: d3 window surface data disable acceleration for surface:::setSurfaceLost->invalidate->flush->peer->disableAcceleration->ScreenUpdateManager->getInstance->dropScreenSurface
D3DSurfaceData.D3DWindowSurfaceData#restoreSurface()::: d3 window surface data restore surface:::if->peer->isAccelCapable->throw->new->InvalidPipeException->fsw->graphicsDevice->getFullScreenWindow->if->peer->getTarget->throw->new->InvalidPipeException->super->restoreSurface->setSurfaceLost->rq->D3DRenderQueue->getInstance->rq->lock->try->getContext->invalidateContext->catch->finally->rq->unlock
D3DSurfaceData.D3DWindowSurfaceData#isDirty()::: d3 window surface data is dirty:::return->dirtyTracker->isCurrent
D3DSurfaceData.D3DWindowSurfaceData#markClean()::: d3 window surface data mark clean:::getStateTracker
D3DSurfaceData#updateWindowAccelImpl(long, long, int, int):::Updates the layered window with the contents of the surface.:::
D3DSurfaceDataProxy#createProxy(SurfaceData, D3DGraphicsConfig)::: d3 surface data proxy create proxy:::if->return->return->srcData->getTransparency->new->D3DSurfaceDataProxy
D3DSurfaceDataProxy#validateSurfaceData(SurfaceData, SurfaceData, int, int)::: d3 surface data proxy validate surface data:::if->cachedData->isSurfaceLost->try->d3dgc->createManagedSurface->catch->if->D3DGraphicsDevice->isD3DAvailable->invalidate->flush->return->finally->return
D3DSurfaceDataProxy#isSupportedOperation(SurfaceData, int, CompositeType, Color)::: d3 surface data proxy is supported operation:::return
D3DTextRenderer#drawGlyphList(int, boolean, boolean, boolean, int, float, float, long[], float[])::: d3 text renderer draw glyph list:::
D3DTextRenderer#validateContext(SunGraphics2D, Composite)::: d3 text renderer validate context:::d3dDst->D3DContext->sg2d->getCompClip->validateContext
D3DTextRenderer#traceWrap()::: d3 text renderer trace wrap:::return->new->Tracer
D3DTextRenderer.Tracer#drawGlyphList(SunGraphics2D, GlyphList)::: tracer draw glyph list:::GraphicsPrimitive->tracePrimitive->super->drawGlyphList
D3DVolatileSurfaceManager#isAccelerationEnabled()::: d3 volatile surface manager is acceleration enabled:::return
D3DVolatileSurfaceManager#setAccelerationEnabled(boolean)::: d3 volatile surface manager set acceleration enabled:::
D3DVolatileSurfaceManager#initAcceleratedSurface():::Create a pbuffer-based SurfaceData object (or init the backbuffer of an existing window if this is a double buffered GraphicsConfig).:::sData->comp->vImg->getComponent->acc->AWTAccessor->getComponentAccessor->peer->acc->getPeer->try->forceback->if->booleanValue->if->D3DSurfaceData->createData->else->gc->vImg->getGraphicsConfig->cm->gc->vImg->getTransparency->getColorModel->type->vImg->getForcedAccelSurfaceType->if->D3DSurfaceData->vImg->getWidth->vImg->getHeight->createData->catch->finally->return
D3DVolatileSurfaceManager#isConfigValid(GraphicsConfiguration)::: d3 volatile surface manager is config valid:::return->vImg->getGraphicsConfig
D3DVolatileSurfaceManager#setRestoreCountdown(int):::Set the number of iterations for restoreAcceleratedSurface to fail before attempting to restore the accelerated surface.:::
D3DVolatileSurfaceManager#restoreAcceleratedSurface():::Note that we create a new surface instead of restoring an old one:::synchronized->if->throw->new->InvalidPipeException->sData->initAcceleratedSurface->if->else->throw->new->InvalidPipeException
D3DVolatileSurfaceManager#restoreContents():::We're asked to restore contents by the accelerated surface, which means that it had been lost.:::acceleratedSurfaceLost->return->super->restoreContents
D3DVolatileSurfaceManager#handleVItoScreenOp(SurfaceData, SurfaceData):::If the destination surface's peer can potentially handle accelerated on-screen rendering then it is likely that the condition which resulted in VI to Screen operation is temporary, so this method sets the restore countdown in hope that the on-screen accelerated rendering will resume:::if->d3dsd->mgr->SurfaceManager->d3dsd->getDestination->getManager->if->vsm->if->d3dsd->setSurfaceLost->wsd->p->wsd->getPeer->if->D3DScreenUpdateManager->p->getGraphicsConfiguration->p->getBackBuffersNum->canUseD3DOnScreen->vsm->setRestoreCountdown->else->vsm->setAccelerationEnabled
D3DVolatileSurfaceManager#initContents()::: d3 volatile surface manager init contents:::if->vImg->getForcedAccelSurfaceType->super->initContents
