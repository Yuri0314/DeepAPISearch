D3DBlitLoops#IsoBlit(SurfaceData, SurfaceData, BufferedImage, BufferedImageOp, Composite, Region, AffineTransform, int, int, int, int, int, double, double, double, double, boolean):::Note: The srcImg and biop parameters are only used when invoked from the D3DBufImgOps.renderImageWithOp() method; in all other cases, this method can be called with null values for those two parameters, and they will be effectively ignored.:::ctxflags->if->srcData->getTransparency->d3dDst->rq->D3DRenderQueue->getInstance->rtt->rq->lock->try->d3dSrc->srctype->d3dSrc->getType->srcCtxData->if->else->D3DContext->validateContext->if->D3DBufImgOps->enableBufImgOp->packedParams->createPackedParams->enqueueBlit->if->D3DBufImgOps->disableBufImgOp->catch->finally->rq->unlock->if->d3dDst->getType->mgr->ScreenUpdateManager->getInstance->mgr->runUpdateNow
D3DBufImgOps#renderImageWithOp(SunGraphics2D, BufferedImage, BufferedImageOp, int, int):::This method is called from D3DDrawImage.transformImage() only:::if->if->isConvolveOpValid->return->else->if->if->isRescaleOpValid->return->else->if->if->isLookupOpValid->return->else->return->dstData->if->return->srcData->dstData->getSourceSurfaceData->if->dstData->getSourceSurfaceData->if->return->d3dSrc->gd->d3dSrc->getDeviceConfiguration->getDevice->if->d3dSrc->getType->gd->isCapPresent->return->sw->img->getWidth->sh->img->getHeight->D3DBlitLoops->sg->getCompClip->IsoBlit->return
D3DContext#invalidateCurrentContext():::Invalidates the currentContext field to ensure that we properly revalidate the D3DContext (make it current, etc.) next time through the validate() method:::if->currentContext->invalidateContext->rq->D3DRenderQueue->getInstance->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow
D3DContext#setScratchSurface(D3DContext):::Sets the current context on the native level to be the one passed as the argument:::if->rq->D3DRenderQueue->getInstance->buf->rq->getBuffer->rq->ensureCapacity->buf->putInt->buf->d3dc->getDevice->getScreen->putInt
D3DGraphicsConfig#createSurfaceData(WComponentPeer, int):::Creates a new SurfaceData that will be associated with the given WComponentPeer:::return->super->createSurfaceData
D3DGraphicsConfig#assertOperationSupported(Component, int, BufferCapabilities):::Checks that the requested configuration is natively supported; if not, an AWTException is thrown.:::if->throw->new->AWTException->if->caps->getFlipContents->throw->new->AWTException
D3DGraphicsConfig#createBackBuffer(WComponentPeer):::Creates a D3D-based backbuffer for the given peer and returns the image wrapper.:::target->peer->getTarget->w->Math->target->getWidth->max->h->Math->target->getHeight->max->return->new->SunVolatileImage
D3DGraphicsConfig#flip(WComponentPeer, Component, VolatileImage, int, int, int, int, BufferCapabilities.FlipContents):::Performs the native D3D flip operation for the given target Component.:::d3dvsm->SurfaceManager->getManager->sd->d3dvsm->getPrimarySurfaceData->if->d3dsd->scaleX->sd->getDefaultScaleX->scaleY->sd->getDefaultScaleY->if->sx1->Math->floor->sy1->Math->floor->sx2->Math->ceil->sy2->Math->ceil->D3DSurfaceData->swapBuffers->else->D3DSurfaceData->swapBuffers->else->g->peer->getGraphics->try->g->drawImage->catch->finally->g->dispose->if->g->backBuffer->getGraphics->try->g->target->getBackground->setColor->g->backBuffer->getWidth->backBuffer->getHeight->fillRect->catch->finally->g->dispose
D3DGraphicsDevice#createDevice(int):::Used to construct a Direct3D-enabled GraphicsDevice.:::if->return->d3dCaps->getDeviceCaps->if->d3dCaps->getCaps->if->WindowsFlags->isD3DVerbose->println->return->if->WindowsFlags->isD3DVerbose->println->gd->new->D3DGraphicsDevice->return
D3DGraphicsDevice#isD3DAvailable():::Returns true if d3d pipeline has been successfully initialized.:::return
D3DPaints#isValid(SunGraphics2D):::Attempts to locate an implementation corresponding to the paint state of the provided SunGraphics2D object:::impl->impls->get->return->impl->isPaintValid
D3DPaints#isPaintValid(SunGraphics2D):::Returns true if this implementation is able to accelerate the Paint object associated with, and under the conditions of, the provided SunGraphics2D instance; otherwise returns false.:::
D3DRenderQueue#getInstance():::Returns the single D3DRenderQueue instance:::if->new->D3DRenderQueue->theInstance->new->Runnable->flushAndInvokeNow->return
D3DRenderQueue#sync():::Flushes the single D3DRenderQueue instance synchronously:::if->mgr->ScreenUpdateManager->getInstance->mgr->runUpdateNow->theInstance->lock->try->theInstance->ensureCapacity->theInstance->getBuffer->putInt->theInstance->flushNow->catch->finally->theInstance->unlock
D3DRenderQueue#restoreDevices():::Attempt to restore the devices if they're in the lost state:::rq->getInstance->rq->lock->try->rq->ensureCapacity->rq->getBuffer->putInt->rq->flushNow->catch->finally->rq->unlock
D3DRenderQueue#disposeGraphicsConfig(long):::Disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread.:::rq->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
D3DScreenUpdateManager#createScreenSurface(Win32GraphicsConfig, WComponentPeer, int, boolean):::If possible, creates a D3DWindowSurfaceData (which is actually a back-buffer surface):::if->return->super->createScreenSurface->sd->if->canUseD3DOnScreen->try->D3DSurfaceData->createData->catch->finally->if->GDIWindowSurfaceData->createData->if->repaintPeerTarget->return
D3DScreenUpdateManager#canUseD3DOnScreen(WComponentPeer, Win32GraphicsConfig, int):::Determines if we can use a d3d surface for onscreen rendering for this peer:::if->return->d3dgc->d3dgd->d3dgc->getD3DDevice->peerName->peer->getClass->getName->r->peer->getBounds->target->peer->getTarget->fsw->d3dgd->getFullScreenWindow->return->WindowsFlags->isD3DOnScreenEnabled->d3dgd->isD3DEnabledOnDevice->peer->isAccelCapable->hasHWChildren->peerName->equals->peerName->equals->peerName->equals->peerName->equals->peerName->equals->peerName->equals
D3DScreenUpdateManager#createGraphics(SurfaceData, WComponentPeer, Color, Color, Font):::Creates a graphics object for the passed in surface data:::if->d3dw->if->d3dw->isSurfaceLost->validate->trackScreenSurface->return->new->SunGraphics2D->getGdiSurface->return->super->createGraphics
D3DScreenUpdateManager#wakeUpUpdateThread():::Wakes up the screen updater thread:::synchronized->runLock->notifyAll
D3DScreenUpdateManager#runUpdateNow():::Wakes up the screen updater thread and waits for the completion of the update:::synchronized->if->d3dwSurfaces->size->return->synchronized->runLock->notifyAll->while->try->runLock->wait->catch->finally
D3DSurfaceData#createData(WComponentPeer, Image):::Creates a SurfaceData object representing the back buffer of a double-buffered on-screen Window.:::gc->getGC->if->peer->isAccelCapable->return->caps->peer->getBackBufferCaps->vSyncType->if->getVSync->r->peer->getBounds->flip->caps->getFlipContents->swapEffect->if->else->if->else->return->peer->getColorModel->peer->getBackBuffersNum->new->D3DSurfaceData
D3DSurfaceData#createData(WComponentPeer):::Returns a WINDOW type of surface - a swap chain which serves as an on-screen surface, handled by the D3DScreenUpdateManager:::gc->getGC->if->peer->isAccelCapable->return->return->new->D3DWindowSurfaceData
D3DSurfaceData#createData(D3DGraphicsConfig, int, int, ColorModel, Image, int):::Creates a SurfaceData object representing an off-screen buffer (either a plain surface or Texture).:::if->isOpaque->cm->getTransparency->cap->if->gc->getD3DDevice->isCapPresent->ret->try->new->D3DSurfaceData->catch->if->if->getForcedAccelSurfaceType->new->D3DSurfaceData->finally->return
D3DSurfaceData#initSurface():::Initializes the appropriate D3D offscreen surface based on the value of the type parameter:::synchronized->status->new->Status->rq->D3DRenderQueue->getInstance->rq->lock->try->rq->new->Runnable->flushAndInvokeNow->if->throw->new->InvalidPipeException->catch->finally->rq->unlock
D3DSurfaceData#getContext():::Returns the D3DContext for the GraphicsConfig associated with this surface.:::return->graphicsDevice->getContext
D3DSurfaceData#getType():::Returns one of the surface type constants defined above.:::return
D3DSurfaceData#canRenderLCDText(SunGraphics2D):::For now, we can only render LCD text if:   - the pixel shaders are available, and   - blending is disabled, and   - the source color is opaque   - and the destination is opaque:::return->graphicsDevice->isCapPresent->getTransparency
D3DSurfaceData#disableAccelerationForSurface():::If acceleration should no longer be used for this surface:::if->sm->SurfaceManager->getManager->if->setSurfaceLost->setAccelerationEnabled
D3DSurfaceData#dispose(long):::Disposes the native resources associated with the given D3DSurfaceData (referenced by the pData parameter):::rq->D3DRenderQueue->getInstance->rq->lock->try->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->putLong->rq->flushNow->catch->finally->rq->unlock
D3DSurfaceData#getDestination():::Returns destination Image associated with this SurfaceData.:::return
D3DSurfaceData#restoreSurface():::Attempts to restore the surface by initializing the native data:::initSurface
D3DSurfaceData#setSurfaceLost(boolean):::We need to let the surface manager know that the surface is lost so that for example BufferStrategy.contentsLost() returns correct result:::super->setSurfaceLost->if->sm->SurfaceManager->getManager->sm->acceleratedSurfaceLost
D3DSurfaceData#getNativeResource(int):::Returns a pointer to the native resource of specified resType associated with this surface:::return->getNativeOps->getNativeResourceNative
D3DSurfaceData.D3DWindowSurfaceData#getReplacement():::  Overridden to use ScreenUpdateManager to obtain the replacement surface.:::mgr->ScreenUpdateManager->getInstance->return->mgr->getReplacementScreenSurface
D3DSurfaceData.D3DWindowSurfaceData#getDestination():::Returns destination Component associated with this SurfaceData.:::return->peer->getTarget
D3DSurfaceData#updateWindowAccelImpl(long, long, int, int):::Updates the layered window with the contents of the surface.:::
D3DVolatileSurfaceManager#initAcceleratedSurface():::Create a pbuffer-based SurfaceData object (or init the backbuffer of an existing window if this is a double buffered GraphicsConfig).:::sData->comp->vImg->getComponent->acc->AWTAccessor->getComponentAccessor->peer->acc->getPeer->try->forceback->if->booleanValue->if->D3DSurfaceData->createData->else->gc->vImg->getGraphicsConfig->cm->gc->vImg->getTransparency->getColorModel->type->vImg->getForcedAccelSurfaceType->if->D3DSurfaceData->vImg->getWidth->vImg->getHeight->createData->catch->finally->return
D3DVolatileSurfaceManager#restoreAcceleratedSurface():::Note that we create a new surface instead of restoring an old one:::synchronized->if->throw->new->InvalidPipeException->sData->initAcceleratedSurface->if->else->throw->new->InvalidPipeException
D3DVolatileSurfaceManager#restoreContents():::We're asked to restore contents by the accelerated surface, which means that it had been lost.:::acceleratedSurfaceLost->return->super->restoreContents
D3DVolatileSurfaceManager#handleVItoScreenOp(SurfaceData, SurfaceData):::If the destination surface's peer can potentially handle accelerated on-screen rendering then it is likely that the condition which resulted in VI to Screen operation is temporary, so this method sets the restore countdown in hope that the on-screen accelerated rendering will resume:::if->d3dsd->mgr->SurfaceManager->d3dsd->getDestination->getManager->if->vsm->if->d3dsd->setSurfaceLost->wsd->p->wsd->getPeer->if->D3DScreenUpdateManager->p->getGraphicsConfiguration->p->getBackBuffersNum->canUseD3DOnScreen->vsm->setRestoreCountdown->else->vsm->setAccelerationEnabled
