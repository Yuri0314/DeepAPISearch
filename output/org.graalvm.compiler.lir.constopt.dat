org.graalvm.compiler.lir.constopt.ConstantLoadOptimization_OptionDescriptors#get(String)->OptionDescriptor::: constant load optimization_ option descriptors get
org.graalvm.compiler.lir.constopt.ConstantLoadOptimization_OptionDescriptors#iterator()->Iterator::: constant load optimization_ option descriptors iterator
org.graalvm.compiler.lir.constopt.ConstantLoadOptimization#run(TargetDescription, LIRGenerationResult, PreAllocationOptimizationContext)->void::: constant load optimization run
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#forEachProperty(BiConsumer)->void::: node cost for each property
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#addUsage(UseEntry)->void::: node cost add usage
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#getUsages()->List::: node cost get usages
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#getBestCost()->double::: node cost get best cost
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#getNumMaterializations()->int::: node cost get num materializations
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#setBestCost(double)->void::: node cost set best cost
org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost#toString()->String::: node cost to string
org.graalvm.compiler.lir.constopt.ConstantTree#getUsages(AbstractBlockBase)->List::: constant tree get usages
org.graalvm.compiler.lir.constopt.ConstantTree#getOrInitCost(AbstractBlockBase)->NodeCost:::Returns the cost object associated with block
org.graalvm.compiler.lir.constopt.ConstantTree#getName(Flags)->String::: constant tree get name
org.graalvm.compiler.lir.constopt.ConstantTree#forEachPropertyPair(AbstractBlockBase, BiConsumer)->void::: constant tree for each property pair
org.graalvm.compiler.lir.constopt.ConstantTree#subTreeSize()->long::: constant tree sub tree size
org.graalvm.compiler.lir.constopt.ConstantTree#getStartBlock()->AbstractBlockBase::: constant tree get start block
org.graalvm.compiler.lir.constopt.ConstantTree#markBlocks()->void::: constant tree mark blocks
org.graalvm.compiler.lir.constopt.ConstantTree#isMarked(AbstractBlockBase)->boolean::: constant tree is marked
org.graalvm.compiler.lir.constopt.ConstantTree#isLeafBlock(AbstractBlockBase)->boolean::: constant tree is leaf block
org.graalvm.compiler.lir.constopt.ConstantTree#setSolution(AbstractBlockBase)->void::: constant tree set solution
org.graalvm.compiler.lir.constopt.ConstantTree#size()->int::: constant tree size
org.graalvm.compiler.lir.constopt.ConstantTree#traverseTreeWhileTrue(AbstractBlockBase, Predicate>)->void::: constant tree traverse tree while true
org.graalvm.compiler.lir.constopt.ConstantTreeAnalyzer#analyze(DebugContext, ConstantTree, AbstractBlockBase)->NodeCost::: constant tree analyzer analyze
org.graalvm.compiler.lir.constopt.DefUseTree#getVariable()->Variable::: def use tree get variable
org.graalvm.compiler.lir.constopt.DefUseTree#getConstant()->Constant::: def use tree get constant
org.graalvm.compiler.lir.constopt.DefUseTree#getInstruction()->LIRInstruction::: def use tree get instruction
org.graalvm.compiler.lir.constopt.DefUseTree#getBlock()->AbstractBlockBase::: def use tree get block
org.graalvm.compiler.lir.constopt.DefUseTree#toString()->String::: def use tree to string
org.graalvm.compiler.lir.constopt.DefUseTree#addUsage(AbstractBlockBase, LIRInstruction, Value)->void::: def use tree add usage
org.graalvm.compiler.lir.constopt.DefUseTree#usageCount()->int::: def use tree usage count
org.graalvm.compiler.lir.constopt.DefUseTree#forEach(Consumer)->void::: def use tree for each
org.graalvm.compiler.lir.constopt.UseEntry#getInstruction()->LIRInstruction::: use entry get instruction
org.graalvm.compiler.lir.constopt.UseEntry#getBlock()->AbstractBlockBase::: use entry get block
org.graalvm.compiler.lir.constopt.UseEntry#setValue(Value)->void::: use entry set value
org.graalvm.compiler.lir.constopt.UseEntry#getValue()->Value::: use entry get value
org.graalvm.compiler.lir.constopt.UseEntry#toString()->String::: use entry to string
org.graalvm.compiler.lir.constopt.VariableMap#get(Variable)->T::: variable map get
org.graalvm.compiler.lir.constopt.VariableMap#put(Variable, T)->T::: variable map put
org.graalvm.compiler.lir.constopt.VariableMap#remove(Variable)->T::: variable map remove
org.graalvm.compiler.lir.constopt.VariableMap#forEach(Consumer)->void::: variable map for each
org.graalvm.compiler.lir.constopt.VariableMap#filter(Predicate)->void:::Keeps only keys which match the given predicate.
