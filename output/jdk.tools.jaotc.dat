AOTCompilationTask#run():::Compile a method or a constructor.:::HotSpotJVMCIRuntime->runtime->AOTCompiler->JavaMethodInfo->uniqueMethodName->logCompilation->threadId->Thread->currentThread->getId->printCompilation->getValue->TTY->isSuppressed->GraalServices->isThreadAllocatedMemorySupported->if->TTY->getMethodDescription->println->start->allocatedBytesBefore->if->System->currentTimeMillis->GraalServices->getThreadAllocatedBytes->else->compResult->startTime->System->currentTimeMillis->snippetReflection->aotBackend->getProviders->getSnippetReflection->try->debug->DebugContext->new->GraalDebugHandlersFactory->create->a->debug->activate->aotBackend->compileMethod->catch->finally->endTime->System->currentTimeMillis->if->stop->System->currentTimeMillis->targetCodeSize->compResult->getTargetCodeSize->allocatedBytesAfter->GraalServices->getThreadAllocatedBytes->allocatedBytes->TTY->getMethodDescription->String->format->println->if->return->LogPrinter->toSeconds->writeLog->if->aotBackend->printCompiledMethod->aotBackend->getBackend->new->AOTHotSpotResolvedJavaMethod->new->CompiledMethodInfo
AOTCompilationTask#getHolder():::Returns the holder of this method as a AOTCompiledClass.:::return
AOTCompilationTask#getResult():::Returns the result of this compilation task.:::return
AOTCompiledClass.AOTKlassData#addDependentMethod(CompiledMethodInfo):::Add a method to the list of dependent methods.:::return->dependentMethods->add
AOTCompiledClass.AOTKlassData#getDependentMethods():::Return the array list of dependent class methods.:::return
AOTCompiledClass.AOTKlassData#hasDependentMethods():::Returns if this class has dependent methods.:::return->dependentMethods->isEmpty
AOTCompiledClass#getMethods():::Get the list of methods which should be compiled.:::m->return
AOTCompiledClass#getClassesCount():::Get the number of all AOT classes.:::return
AOTCompiledClass#getMethodCount():::Get the number of methods which should be compiled.:::return->methods->size
AOTCompiledClass#addMethod(ResolvedJavaMethod):::Add a method to the list of methods to be compiled.:::methods->add
AOTCompiledClass#hasMethods():::Returns if this class has methods which should be compiled.:::return->methods->isEmpty
AOTCompiledClass#addCompiledMethod(CompiledMethodInfo):::Add a method to the list of compiled methods:::return->compiledMethods->add
AOTCompiledClass#getCompiledMethods():::Return the array list of compiled class methods.:::return
AOTCompiledClass#hasCompiledMethods():::Returns if this class has successfully compiled methods.:::return->compiledMethods->isEmpty
AOTCompiledClass#addAOTKlassData(BinaryContainer, HotSpotResolvedObjectType):::Add a klass data.:::data->getAOTKlassData->if->new->AOTKlassData->klassData->type->getName->put->return
AOTCompiler#compileClasses(List):::Compile all methods in all classes passed.:::compileQueue->getCorePoolSize->printlnInfo->printInfo->foreach->foreach->c->getMethods->enqueueMethod->compileQueue->shutdown->compileQueue->awaitTermination->compiledClasses->new->ArrayList<>->foreach->if->compiledClass->hasCompiledMethods->compiledClasses->add->return
CallSiteRelocationSymbol#addExternalPltToGotRelocation(BinaryContainer, Symbol, int):::Add an RelocType#EXTERNAL_PLT_TO_GOT relocation to the BinaryContainer#getCodeContainer().:::container->binaryContainer->getCodeContainer->relocation->new->Relocation->binaryContainer->addRelocation
CodeSectionProcessor#process(AOTCompiledClass):::Method that looks at code section of a compiled result compClass and records function entry point symbols along with the text section contents:::compiledMethods->compClass->getCompiledMethods->foreach->compResult->methodInfo->getCompilationResult->targetCode->compResult->getTargetCode->targetCodeSize->compResult->getTargetCodeSize->compMethod->methodInfo->getMethodInfo->foreach->compResult->getInfopoints->if->callInfopoint->if->destOffset->entry->compMethod->getSymbolName->codeSection->binaryContainer->getCodeContainer->codeIdOffset->BinaryContainer->binaryContainer->getCodeSegmentSize->alignUp->methodInfo->setCodeId->binaryContainer->methodInfo->getCodeId->appendIntToCode->textBaseOffset->BinaryContainer->binaryContainer->getCodeEntryAlignment->alignUp->codeSection->createSymbol->methodInfo->setTextSectionOffset->binaryContainer->appendCodeBytes->currentStubOffset->BinaryContainer->alignUp->methodInfo->setStubsOffset->foreach->compResult->getInfopoints->if->callInfopoint->if->call->stub->CallInfo->isVirtualCall->addCallStub->targetSymbol->JavaMethodInfo->uniqueMethodName->methodInfo->addStubCode->stub->getSize->binaryContainer->addCodeSegments
Collector#collectMethodsToCompile(Set>, MetaAccessProvider):::Collect all method we should compile.:::total->count->classes->new->ArrayList<>->compilationRestrictions->collectSpecifiedMethods->foreach->resolvedJavaType->metaAccess->lookupJavaType->if->shouldCompileAnyMethodInClass->aotClass->new->AOTCompiledClass->c->getName->printlnVerbose->try->ctors->resolvedJavaType->getDeclaredConstructors->addMethods->catch->c->getName->handleLoadingError->finally->try->methods->resolvedJavaType->getDeclaredMethods->addMethods->catch->c->getName->handleLoadingError->finally->try->clinit->resolvedJavaType->getClassInitializer->if->addMethod->catch->c->getName->handleLoadingError->finally->if->aotClass->hasMethods->classes->add->aotClass->getMethodCount->printInfo->return
CompilationSpec#addCompileOnlyPattern(String):::Add a compileOnly directive to the compile-only list.:::if->pattern->contains->compileOnlyPatterns->Pattern->compile->add->else->compileOnlyStrings->add
CompilationSpec#addExcludePattern(String):::Add an exclude directive to the exclude list.:::if->pattern->contains->excludePatterns->Pattern->compile->add->else->excludeStrings->add
CompilationSpec#shouldCompileMethod(ResolvedJavaMethod):::Check if a given method is part of a restrictive compilation.:::if->compileWithRestrictions->compileMethod->compileOnlyStrings->isEmpty->compileOnlyPatterns->isEmpty->methodName->JavaMethodInfo->uniqueMethodName->if->compileOnlyStrings->contains->if->it->compileOnlyPatterns->iterator->while->it->hasNext->pattern->it->next->pattern->matcher->matches->if->excludeStrings->contains->if->it->excludePatterns->iterator->while->it->hasNext->pattern->it->next->pattern->matcher->matches->return->return
CompiledMethodInfo#setStubsOffset(int):::Offset into the code of this method where the stub section starts.:::
DataBuilder#getVMFunctionNameForAddress(long):::Get the C/C++ function name associated with the foreign call target address.:::return->vmAddresses->get
DataBuilder#getBackend():::Returns the host backend used for this compilation.:::return
DataBuilder#getBinaryContainer():::Returns the binary container for this compilation.:::return
DataBuilder#prepareData(DebugContext):::Prepare data with all compiled classes and stubs.:::try->t->new->Timer->codeSectionProcessor->new->CodeSectionProcessor->foreach->c->addAOTKlassData->codeSectionProcessor->process->catch->finally->stubCompiledCode->retrieveStubCode->try->t->new->Timer->printMemoryUsage->System->gc->catch->finally->metadataBuilder->try->t->new->Timer->new->MetadataBuilder->metadataBuilder->processMetadata->catch->finally->try->t->new->Timer->printMemoryUsage->System->gc->catch->finally->try->t->new->Timer->prepareStubsBinary->catch->finally->try->t->new->Timer->prepareCompiledBinary->catch->finally
DataPatchProcessor#process(CompiledMethodInfo, DataPatch):::Process a DataPatch generated by the compiler and create all needed binary section constructs.:::reference->if->processConstantReference->else->if->processDataSectionReference->else->throw->new->InternalError
InfopointProcessor#process(CompiledMethodInfo, Infopoint):::Parse an Infopoint generated by the compiler and create all needed binary section constructs.:::switch->processCallInfoPoint->break->break->throw->new->InternalError->if->return->bcp->getBytecodePosition->if->return->getVirtualObjectMapping->recordScopeKlasses
JavaMethodInfo#getNameAndSignature():::Name a java method with J.L.S:::
JavaMethodInfo#uniqueMethodName(ResolvedJavaMethod):::Name a java method with class and signature to make it unique.:::className->method->getDeclaringClass->toClassName->name->method->getName->method->getSignature->toMethodDescriptor->return
MarkProcessor#process(CompiledMethodInfo, Mark):::Parse a Mark generated by the compiler and create all needed binary section constructs.:::markId->MarkId->getEnum->switch->break->if->binaryContainer->getThreadLocalHandshakes->break->vmSymbolName->switch->BinaryContainer->getPollingPageSymbolName->break->BinaryContainer->getCardTableAddressSymbolName->break->BinaryContainer->getHeapTopAddressSymbolName->break->BinaryContainer->getHeapEndAddressSymbolName->break->BinaryContainer->getNarrowKlassBaseAddressSymbolName->break->BinaryContainer->getNarrowOopBaseAddressSymbolName->break->BinaryContainer->getCrcTableAddressSymbolName->break->BinaryContainer->getLogOfHeapRegionGrainBytesSymbolName->break->BinaryContainer->getInlineContiguousAllocationSupportedSymbolName->break->throw->new->InternalError->s->gotSymbol->binaryContainer->getGotSymbol->textBaseOffset->methodInfo->getTextSectionOffset->textOffset->reloc->binaryContainer->getCodeContainer->new->Relocation->binaryContainer->addRelocation->break->break->throw->new->InternalError
MetadataBuilder#processMetadata(List, AOTCompiledClass):::Process compiled methods and create method metadata.:::foreach->processMetadataClass->processMetadataClass
