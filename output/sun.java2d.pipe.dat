AAShapePipe#draw(SunGraphics2D, Shape)::: shape pipe draw:::bs->if->else->createStrokedShape->renderPath
AAShapePipe#fill(SunGraphics2D, Shape)::: shape pipe fill:::renderPath
AAShapePipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: shape pipe fill parallelogram:::ts->TILE_STATE_PROVIDER->acquire->try->abox->aatg->RDR_ENGINE->sg->getCompClip->getAATileGenerator->if->ts->computeBBox->renderTiles->catch->finally->TILE_STATE_PROVIDER->release
AAShapePipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: shape pipe draw parallelogram:::ts->TILE_STATE_PROVIDER->acquire->try->abox->aatg->RDR_ENGINE->sg->getCompClip->getAATileGenerator->if->ts->computeBBox->renderTiles->catch->finally->TILE_STATE_PROVIDER->release
AAShapePipe#renderPath(SunGraphics2D, Shape, BasicStroke)::: shape pipe render path:::adjust->thin->ts->TILE_STATE_PROVIDER->acquire->try->abox->aatg->RDR_ENGINE->sg->getCompClip->getAATileGenerator->if->renderTiles->catch->finally->TILE_STATE_PROVIDER->release
AAShapePipe#renderTiles(SunGraphics2D, Shape, AATileGenerator, int[], TileState)::: shape pipe render tiles:::context->try->outpipe->ts->computeDevBox->startSequence->x0->y0->x1->y1->tw->aatg->getTileWidth->th->aatg->getTileHeight->alpha->ts->getAlphaTile->atile->for->y->catch->finally->aatg->dispose->if->outpipe->endSequence
AAShapePipe.TileState#getAlphaTile(int)::: tile state get alpha tile:::t->if->new->byteArr->return
AAShapePipe.TileState#computeDevBox(int[])::: tile state compute dev box:::box->return
AAShapePipe.TileState#computeBBox(double, double, double, double)::: tile state compute box:::if->if->box->return
AATextRenderer#drawGlyphList(SunGraphics2D, GlyphList)::: text renderer draw glyph list:::DrawGlyphListAA
AATileGenerator#getTileWidth():::Gets the width of the tiles that the generator batches output into.:::
AATileGenerator#getTileHeight():::Gets the height of the tiles that the generator batches output into.:::
AATileGenerator#getTypicalAlpha():::Gets the typical alpha value that will characterize the current tile:::
AATileGenerator#nextTile():::Skips the current tile and moves on to the next tile:::
AATileGenerator#getAlpha(byte[], int, int):::Gets the alpha coverage values for the current tile:::
AATileGenerator#dispose():::Disposes this tile generator:::
AlphaColorPipe#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: alpha color pipe start sequence:::return
AlphaColorPipe#needTile(Object, int, int, int, int)::: alpha color pipe need tile:::return
AlphaColorPipe#renderPathTile(Object, byte[], int, int, int, int, int, int)::: alpha color pipe render path tile:::sg->sg->getSurfaceData->MaskFill
AlphaColorPipe#skipTile(Object, int, int)::: alpha color pipe skip tile:::return
AlphaColorPipe#endSequence(Object)::: alpha color pipe end sequence:::return
AlphaColorPipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: alpha color pipe fill parallelogram:::sg->getSurfaceData->FillAAPgram
AlphaColorPipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: alpha color pipe draw parallelogram:::sg->getSurfaceData->DrawAAPgram
AlphaPaintPipe#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: alpha paint pipe start sequence:::paintContext->sg->getDeviceColorModel->s->getBounds2D->sg->cloneTransform->sg->getRenderingHints->createContext->return->new->TileContext
AlphaPaintPipe#needTile(Object, int, int, int, int)::: alpha paint pipe need tile:::return
AlphaPaintPipe#renderPathTile(Object, byte[], int, int, int, int, int, int)::: alpha paint pipe render path tile:::context->paintCtxt->sg->dstData->srcData->lastRas->if->get->get->if->paintModel->for->rely
AlphaPaintPipe#skipTile(Object, int, int)::: alpha paint pipe skip tile:::return
AlphaPaintPipe#endSequence(Object)::: alpha paint pipe end sequence:::context->if->dispose->synchronized->if->if->cachedLastColorModel->get->new->WeakReference<>
BufferedBufImgOps#enableBufImgOp(RenderQueue, SurfaceData, BufferedImage, BufferedImageOp)::: buffered buf img ops enable buf img op:::if->enableConvolveOp->else->if->enableRescaleOp->else->if->enableLookupOp->else->throw->new->InternalError
BufferedBufImgOps#disableBufImgOp(RenderQueue, BufferedImageOp)::: buffered buf img ops disable buf img op:::if->disableConvolveOp->else->if->disableRescaleOp->else->if->disableLookupOp->else->throw->new->InternalError
BufferedBufImgOps#isConvolveOpValid(ConvolveOp)::: buffered buf img ops is convolve op valid:::kernel->cop->getKernel->kw->kernel->getWidth->kh->kernel->getHeight->if->return->return
BufferedBufImgOps#enableConvolveOp(RenderQueue, SurfaceData, ConvolveOp)::: buffered buf img ops enable convolve op:::edgeZero->cop->getEdgeCondition->kernel->cop->getKernel->kernelWidth->kernel->getWidth->kernelHeight->kernel->getHeight->kernelSize->sizeofFloat->totalBytesRequired->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->srcData->getNativeOps->putLong->buf->putInt->buf->putInt->buf->putInt->buf->kernel->getKernelData->put
BufferedBufImgOps#disableConvolveOp(RenderQueue)::: buffered buf img ops disable convolve op:::buf->rq->getBuffer->rq->ensureCapacity->buf->putInt
BufferedBufImgOps#isRescaleOpValid(RescaleOp, BufferedImage)::: buffered buf img ops is rescale op valid:::numFactors->rop->getNumFactors->srcCM->srcImg->getColorModel->if->throw->new->IllegalArgumentException->if->srcCM->getNumColorComponents->srcCM->getNumComponents->throw->new->IllegalArgumentException->csType->srcCM->getColorSpace->getType->if->return->if->return->return
BufferedBufImgOps#enableRescaleOp(RenderQueue, SurfaceData, BufferedImage, RescaleOp)::: buffered buf img ops enable rescale op:::srcCM->srcImg->getColorModel->nonPremult->srcCM->hasAlpha->srcCM->isAlphaPremultiplied->numFactors->rop->getNumFactors->origScaleFactors->rop->getScaleFactors->origOffsets->rop->getOffsets->normScaleFactors->normOffsets->if->new->floatArr->new->floatArr->for->i->else->if->new->floatArr->new->floatArr->for->i->else->if->srcCM->getNumComponents->nBits->srcCM->getComponentSize->maxValue->for->i->else->for->i->srcCM->getNumComponents->sizeofFloat->totalBytesRequired->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->srcData->getNativeOps->putLong->buf->putInt->buf->put->buf->put
BufferedBufImgOps#disableRescaleOp(RenderQueue)::: buffered buf img ops disable rescale op:::buf->rq->getBuffer->rq->ensureCapacity->buf->putInt
BufferedBufImgOps#isLookupOpValid(LookupOp, BufferedImage)::: buffered buf img ops is lookup op valid:::table->lop->getTable->numComps->table->getNumComponents->srcCM->srcImg->getColorModel->if->throw->new->IllegalArgumentException->if->srcCM->getNumComponents->srcCM->getNumColorComponents->throw->new->IllegalArgumentException->csType->srcCM->getColorSpace->getType->if->return->if->return->if->data->getTable->for->i->else->if->data->getTable->for->i->else->return->return
BufferedBufImgOps#enableLookupOp(RenderQueue, SurfaceData, BufferedImage, LookupOp)::: buffered buf img ops enable lookup op:::nonPremult->srcImg->getColorModel->hasAlpha->srcImg->isAlphaPremultiplied->table->lop->getTable->numBands->table->getNumComponents->offset->table->getOffset->bandLength->bytesPerElem->shortData->if->data->getTable->else->data->getTable->totalLutBytes->paddedLutBytes->padding->totalBytesRequired->buf->rq->getBuffer->rq->ensureCapacityAndAlignment->buf->putInt->buf->srcData->getNativeOps->putLong->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->if->data->getTable->for->i->else->data->getTable->for->i->if->buf->buf->position->position
BufferedBufImgOps#disableLookupOp(RenderQueue)::: buffered buf img ops disable lookup op:::buf->rq->getBuffer->rq->ensureCapacity->buf->putInt
BufferedContext#validateContext(AccelSurface, AccelSurface, Region, Composite, AffineTransform, Paint, SunGraphics2D, int):::Fetches the BufferedContextContext associated with the dst:::context->dstData->getContext->context->validate
BufferedContext#validateContext(AccelSurface):::Fetches the BufferedContextassociated with the surface and disables all context state settings:::validateContext
BufferedContext#validate(AccelSurface, AccelSurface, Region, Composite, AffineTransform, Paint, SunGraphics2D, int):::Validates the given parameters against the current state for this context:::updateClip->updatePaint->if->dstData->isValid->dstData->isSurfaceLost->srcData->isSurfaceLost->invalidateContext->throw->new->InvalidPipeException->if->newRGB->getRGB->if->if->else->else->if->validPaintRef->get->validatedSrcData->validSrcDataRef->get->validatedDstData->validDstDataRef->get->if->if->if->setSurfaces->new->WeakReference<>->new->WeakReference<>->validatedClip->validClipRef->get->if->if->if->validatedClip->isRectangular->clip->isRectangular->clip->getLoX->validatedClip->getLoX->clip->getLoY->validatedClip->getLoY->clip->getHiX->validatedClip->getHiX->clip->getHiY->validatedClip->getHiY->setClip->else->resetClip->new->WeakReference<>->if->validCompRef->get->if->setComposite->else->resetComposite->new->WeakReference<>->txChanged->if->if->resetTransform->else->if->equals->if->new->AffineTransform->else->setTransform->if->if->if->BufferedPaints->setPaint->else->BufferedPaints->resetPaint->new->WeakReference<>->dstData->markDirty
BufferedContext#invalidateSurfaces():::Invalidates the surfaces associated with this context:::validSrcDataRef->clear->validDstDataRef->clear
BufferedContext#setSurfaces(AccelSurface, AccelSurface)::: buffered context set surfaces:::rq->ensureCapacityAndAlignment->buf->putInt->buf->srcData->getNativeOps->putLong->buf->dstData->getNativeOps->putLong
BufferedContext#resetClip()::: buffered context reset clip:::rq->ensureCapacity->buf->putInt
BufferedContext#setClip(Region)::: buffered context set clip:::if->clip->isRectangular->rq->ensureCapacity->buf->putInt->buf->clip->getLoX->putInt->clip->getLoY->putInt->buf->clip->getHiX->putInt->clip->getHiY->putInt->else->rq->ensureCapacity->buf->putInt->buf->putInt->countIndex->buf->position->buf->putInt->spanCount->remainingSpans->buf->remaining->span->new->intArr->si->clip->getSpanIterator->while->si->nextSpan->if->buf->putInt->rq->flushNow->buf->putInt->buf->position->buf->putInt->buf->remaining->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->rq->ensureCapacity->buf->putInt
BufferedContext#resetComposite()::: buffered context reset composite:::rq->ensureCapacity->buf->putInt
BufferedContext#setComposite(Composite, int)::: buffered context set composite:::if->ac->rq->ensureCapacity->buf->putInt->buf->ac->getRule->putInt->buf->ac->getAlpha->putFloat->buf->putInt->else->if->xorPixel->getXorPixel->rq->ensureCapacity->buf->putInt->buf->putInt->else->throw->new->InternalError
BufferedContext#resetTransform()::: buffered context reset transform:::rq->ensureCapacity->buf->putInt
BufferedContext#setTransform(AffineTransform)::: buffered context set transform:::rq->ensureCapacityAndAlignment->buf->putInt->buf->xform->getScaleX->putDouble->buf->xform->getShearY->putDouble->buf->xform->getShearX->putDouble->buf->xform->getScaleY->putDouble->buf->xform->getTranslateX->putDouble->buf->xform->getTranslateY->putDouble
BufferedContext#invalidateContext():::Resets this context's surfaces and all attributes:::resetTransform->resetComposite->resetClip->BufferedPaints->resetPaint->invalidateSurfaces->validCompRef->clear->validClipRef->clear->validPaintRef->clear
BufferedContext#getRenderQueue():::Returns a singleton RenderQueue object used by the rendering pipeline.:::
BufferedContext#saveState():::Saves the state of this context:::
BufferedContext#restoreState():::Restores the native state of this context:::
BufferedMaskBlit#MaskBlit(SurfaceData, SurfaceData, Composite, Region, int, int, int, int, int, int, byte[], int, int)::: buffered mask blit  mask blit:::if->return->if->if->Blit->src->getSurfaceType->this->getDestType->getFromCache->blitop->Blit->return->acomp->if->acomp->getRule->rq->lock->try->validateContext->buf->rq->getBuffer->totalBytesRequired->rq->ensureCapacity->newpos->buf->getAddress->buf->position->src->getNativeOps->enqueueTile->buf->position->catch->finally->rq->unlock
BufferedMaskBlit#enqueueTile(long, int, SurfaceData, long, int, byte[], int, int, int, int, int, int, int, int, int)::: buffered mask blit enqueue tile:::
BufferedMaskBlit#validateContext(SurfaceData, Composite, Region):::Validates the context state using the given destination surface and composite/clip values.:::
BufferedMaskFill#MaskFill(SunGraphics2D, SurfaceData, Composite, int, int, int, int, byte[], int, int)::: buffered mask fill  mask fill:::acomp->if->acomp->getRule->rq->lock->try->validateContext->maskBytesRequired->if->else->totalBytesRequired->buf->rq->getBuffer->if->buf->capacity->if->buf->remaining->rq->flushNow->buf->putInt->buf->putInt->putInt->putInt->putInt->buf->putInt->buf->putInt->buf->putInt->if->padding->buf->put->if->buf->buf->position->position->else->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock
BufferedMaskFill#maskFill(int, int, int, int, int, int, int, byte[]):::Called as a separate Runnable when the operation is too large to fit on the RenderQueue:::
BufferedMaskFill#validateContext(SunGraphics2D, Composite, int):::Validates the state in the provided SunGraphics2D object and sets up any special resources for this operation (e.g:::
BufferedPaints#setPaint(RenderQueue, SunGraphics2D, Paint, int)::: buffered paints set paint:::if->setColor->else->useMask->switch->setGradientPaint->break->setLinearGradientPaint->break->setRadialGradientPaint->break->setTexturePaint->break->break
BufferedPaints#resetPaint(RenderQueue)::: buffered paints reset paint:::rq->ensureCapacity->buf->rq->getBuffer->buf->putInt
BufferedPaints#setColor(RenderQueue, int)::: buffered paints set color:::rq->ensureCapacity->buf->rq->getBuffer->buf->putInt->buf->putInt
BufferedPaints#setGradientPaint(RenderQueue, AffineTransform, Color, Color, Point2D, Point2D, boolean, boolean):::Note: This code is factored out into a separate static method so that it can be shared by both the Gradient and LinearGradient implementations:::pc->pixel1->pc->c1->getRGB->rgbToPixel->pixel2->pc->c2->getRGB->rgbToPixel->x->pt1->getX->y->pt1->getY->at->translate->pt2->getX->pt2->getY->len->Math->sqrt->at->rotate->at->scale->at->translate->p0->p1->p3->try->at->invert->at->getScaleX->at->getShearX->at->getTranslateX->catch->finally->rq->ensureCapacityAndAlignment->buf->rq->getBuffer->buf->putInt->buf->putInt->buf->putInt->buf->putDouble->putDouble->putDouble->buf->putInt->putInt
BufferedPaints#setGradientPaint(RenderQueue, SunGraphics2D, GradientPaint, boolean)::: buffered paints set gradient paint:::clone->paint->getColor1->paint->getColor2->paint->getPoint1->paint->getPoint2->paint->isCyclic->setGradientPaint
BufferedPaints#setTexturePaint(RenderQueue, SunGraphics2D, TexturePaint, boolean):::We use OpenGL's texture coordinate generator to automatically map the TexturePaint image to the geometry being rendered:::bi->paint->getImage->dstData->srcData->dstData->getSourceSurfaceData->filter->at->clone->anchor->paint->getAnchorRect->at->anchor->getX->anchor->getY->translate->at->anchor->getWidth->anchor->getHeight->scale->xp0->xp1->xp3->yp0->yp1->yp3->try->at->invert->at->getScaleX->at->getShearX->at->getTranslateX->at->getShearY->at->getScaleY->at->getTranslateY->catch->finally->rq->ensureCapacityAndAlignment->buf->rq->getBuffer->buf->putInt->buf->putInt->buf->putInt->buf->srcData->getNativeOps->putLong->buf->putDouble->putDouble->putDouble->buf->putDouble->putDouble->putDouble
BufferedPaints#convertSRGBtoLinearRGB(int):::Helper function to convert a color component in sRGB space to linear RGB space:::input->output->if->else->Math->pow->return->Math->round
BufferedPaints#colorToIntArgbPrePixel(Color, boolean):::Helper function to convert a (non-premultiplied) Color in sRGB space to an IntArgbPre pixel value, optionally in linear RGB space:::rgb->c->getRGB->if->return->a->r->g->b->if->convertSRGBtoLinearRGB->convertSRGBtoLinearRGB->convertSRGBtoLinearRGB->a2->return
BufferedPaints#convertToIntArgbPrePixels(Color[], boolean):::Converts the given array of Color objects into an int array containing IntArgbPre pixel values:::pixels->new->intArr->for->i->return
BufferedPaints#setLinearGradientPaint(RenderQueue, SunGraphics2D, LinearGradientPaint, boolean):::This method uses techniques that are nearly identical to those employed in setGradientPaint() above:::linear->paint->getColorSpace->colors->paint->getColors->numStops->pt1->paint->getStartPoint->pt2->paint->getEndPoint->at->paint->getTransform->at->preConcatenate->if->paint->getCycleMethod->isCyclic->paint->getCycleMethod->setGradientPaint->return->cycleMethod->paint->getCycleMethod->ordinal->fractions->paint->getFractions->pixels->convertToIntArgbPrePixels->x->pt1->getX->y->pt1->getY->at->translate->pt2->getX->pt2->getY->len->Math->sqrt->at->rotate->at->scale->p0->p1->p3->try->at->invert->at->getScaleX->at->getShearX->at->getTranslateX->catch->finally->rq->ensureCapacity->buf->rq->getBuffer->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putFloat->buf->putFloat->buf->putFloat->buf->put->buf->put
BufferedPaints#setRadialGradientPaint(RenderQueue, SunGraphics2D, RadialGradientPaint, boolean):::This method calculates six m** values and a focusX value that are used by the native fragment shader:::linear->paint->getColorSpace->cycleMethod->paint->getCycleMethod->ordinal->fractions->paint->getFractions->colors->paint->getColors->numStops->pixels->convertToIntArgbPrePixels->center->paint->getCenterPoint->focus->paint->getFocusPoint->radius->paint->getRadius->cx->center->getX->cy->center->getY->fx->focus->getX->fy->focus->getY->at->paint->getTransform->at->preConcatenate->at->transform->at->translate->at->rotate->at->scale->try->at->invert->catch->at->setToScale->finally->at->transform->Math->focus->getX->min->rq->ensureCapacity->buf->rq->getBuffer->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->at->getScaleX->putFloat->buf->at->getShearX->putFloat->buf->at->getTranslateX->putFloat->buf->at->getShearY->putFloat->buf->at->getScaleY->putFloat->buf->at->getTranslateY->putFloat->buf->putFloat->buf->put->buf->put
BufferedRenderPipe#getAAParallelogramPipe()::: buffered render pipe get parallelogram pipe:::return
BufferedRenderPipe#validateContext(SunGraphics2D):::Validates the state in the provided SunGraphics2D object and sets up any special resources for this operation (e.g:::
BufferedRenderPipe#validateContextAA(SunGraphics2D)::: buffered render pipe validate context a:::
BufferedRenderPipe#drawLine(SunGraphics2D, int, int, int, int)::: buffered render pipe draw line:::transx->transy->rq->lock->try->validateContext->rq->ensureCapacity->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->catch->finally->rq->unlock
BufferedRenderPipe#drawRect(SunGraphics2D, int, int, int, int)::: buffered render pipe draw rect:::rq->lock->try->validateContext->rq->ensureCapacity->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->catch->finally->rq->unlock
BufferedRenderPipe#fillRect(SunGraphics2D, int, int, int, int)::: buffered render pipe fill rect:::rq->lock->try->validateContext->rq->ensureCapacity->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->catch->finally->rq->unlock
BufferedRenderPipe#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: buffered render pipe draw round rect:::new->RoundRectangle2D.Float->draw
BufferedRenderPipe#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: buffered render pipe fill round rect:::new->RoundRectangle2D.Float->fill
BufferedRenderPipe#drawOval(SunGraphics2D, int, int, int, int)::: buffered render pipe draw oval:::new->Ellipse2D.Float->draw
BufferedRenderPipe#fillOval(SunGraphics2D, int, int, int, int)::: buffered render pipe fill oval:::new->Ellipse2D.Float->fill
BufferedRenderPipe#drawArc(SunGraphics2D, int, int, int, int, int, int)::: buffered render pipe draw arc:::new->Arc2D.Float->draw
BufferedRenderPipe#fillArc(SunGraphics2D, int, int, int, int, int, int)::: buffered render pipe fill arc:::new->Arc2D.Float->fill
BufferedRenderPipe#drawPoly(SunGraphics2D, int[], int[], int, boolean)::: buffered render pipe draw poly:::if->throw->new->NullPointerException->if->throw->new->ArrayIndexOutOfBoundsException->if->return->else->if->drawLine->return->rq->lock->try->validateContext->pointBytesRequired->totalBytesRequired->if->buf->capacity->if->buf->remaining->rq->flushNow->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->put->buf->put->else->rq->new->Runnable->flushAndInvokeNow->catch->finally->rq->unlock
BufferedRenderPipe#drawPoly(int[], int[], int, boolean, int, int)::: buffered render pipe draw poly:::
BufferedRenderPipe#drawPolyline(SunGraphics2D, int[], int[], int)::: buffered render pipe draw polyline:::drawPoly
BufferedRenderPipe#drawPolygon(SunGraphics2D, int[], int[], int)::: buffered render pipe draw polygon:::drawPoly
BufferedRenderPipe#fillPolygon(SunGraphics2D, int[], int[], int)::: buffered render pipe fill polygon:::new->Polygon->fill
BufferedRenderPipe.BufferedDrawHandler#validate(SunGraphics2D):::This method needs to be called prior to each draw/fillPath() operation to ensure the clip bounds are up to date.:::clip->sg2d->getCompClip->clip->getLoX->clip->getLoY->clip->getHiX->clip->getHiY->setBounds
BufferedRenderPipe.BufferedDrawHandler#drawLine(int, int, int, int)::: buffered draw handler draw line:::rq->ensureCapacity->buf->putInt->buf->putInt->buf->putInt->buf->putInt->buf->putInt
BufferedRenderPipe.BufferedDrawHandler#drawPixel(int, int)::: buffered draw handler draw pixel:::rq->ensureCapacity->buf->putInt->buf->putInt->buf->putInt
BufferedRenderPipe.BufferedDrawHandler#resetFillPath()::: buffered draw handler reset fill path:::buf->putInt->buf->position->buf->putInt->buf->remaining
BufferedRenderPipe.BufferedDrawHandler#updateScanlineCount()::: buffered draw handler update scanline count:::buf->putInt
BufferedRenderPipe.BufferedDrawHandler#startFillPath():::Called from fillPath() to indicate that we are about to start issuing drawScanline() calls.:::rq->ensureCapacity->resetFillPath
BufferedRenderPipe.BufferedDrawHandler#drawScanline(int, int, int)::: buffered draw handler draw scanline:::if->updateScanlineCount->rq->flushNow->resetFillPath->buf->putInt->buf->putInt->buf->putInt
BufferedRenderPipe.BufferedDrawHandler#endFillPath():::Called from fillPath() to indicate that we are done issuing drawScanline() calls.:::updateScanlineCount
BufferedRenderPipe#drawPath(SunGraphics2D, Path2D.Float, int, int)::: buffered render pipe draw path:::rq->lock->try->validateContext->drawHandler->validate->ProcessPath->drawPath->catch->finally->rq->unlock
BufferedRenderPipe#fillPath(SunGraphics2D, Path2D.Float, int, int)::: buffered render pipe fill path:::rq->lock->try->validateContext->drawHandler->validate->drawHandler->startFillPath->ProcessPath->fillPath->drawHandler->endFillPath->catch->finally->rq->unlock
BufferedRenderPipe#fillSpans(RenderQueue, long, int, int, SpanIterator, long, int, int)::: buffered render pipe fill spans:::
BufferedRenderPipe#fillSpans(SunGraphics2D, SpanIterator, int, int)::: buffered render pipe fill spans:::rq->lock->try->validateContext->rq->ensureCapacity->newpos->buf->getAddress->buf->position->buf->capacity->si->getNativeIterator->fillSpans->buf->position->catch->finally->rq->unlock
BufferedRenderPipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: buffered render pipe fill parallelogram:::rq->lock->try->validateContext->rq->ensureCapacity->buf->putInt->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->catch->finally->rq->unlock
BufferedRenderPipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: buffered render pipe draw parallelogram:::rq->lock->try->validateContext->rq->ensureCapacity->buf->putInt->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->catch->finally->rq->unlock
BufferedRenderPipe.AAParallelogramPipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: parallelogram pipe fill parallelogram:::rq->lock->try->validateContextAA->rq->ensureCapacity->buf->putInt->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->catch->finally->rq->unlock
BufferedRenderPipe.AAParallelogramPipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: parallelogram pipe draw parallelogram:::rq->lock->try->validateContextAA->rq->ensureCapacity->buf->putInt->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->buf->putFloat->catch->finally->rq->unlock
BufferedRenderPipe#draw(SunGraphics2D, Shape)::: buffered render pipe draw:::if->if->if->p->drawPolygon->return->p2df->transx->transy->if->if->else->new->Path2D.Float->else->new->Path2D.Float->drawPath->else->if->si->LoopPipe->getStrokeSpans->try->fillSpans->catch->finally->si->dispose->else->createStrokedShape->fill
BufferedRenderPipe#fill(SunGraphics2D, Shape)::: buffered render pipe fill:::transx->transy->if->p2df->if->if->else->new->Path2D.Float->else->new->Path2D.Float->fillPath->return->at->if->else->ssi->LoopPipe->getFillSSI->try->clip->sg2d->getCompClip->ssi->clip->getLoX->clip->getLoY->clip->getHiX->clip->getHiY->setOutputAreaXYXY->ssi->s->getPathIterator->appendPath->fillSpans->catch->finally->ssi->dispose
BufferedTextPipe#createPackedParams(SunGraphics2D, GlyphList):::Packs the given parameters into a single int value in order to save space on the rendering queue:::return->gl->usePositions->gl->isSubPixPos->gl->isRGBOrder
BufferedTextPipe#drawGlyphList(SunGraphics2D, GlyphList)::: buffered text pipe draw glyph list:::comp->if->rq->lock->try->validateContext->enqueueGlyphList->catch->finally->rq->unlock
BufferedTextPipe#enqueueGlyphList(SunGraphics2D, GlyphList)::: buffered text pipe enqueue glyph list:::buf->rq->getBuffer->totalGlyphs->gl->getNumGlyphs->glyphBytesRequired->posBytesRequired->gl->usePositions->totalBytesRequired->images->gl->getImages->glyphListOrigX->gl->getX->glyphListOrigY->gl->getY->rq->gl->getStrike->addReference->if->buf->capacity->if->buf->remaining->rq->flushNow->rq->ensureAlignment->buf->putInt->buf->putInt->buf->createPackedParams->putInt->buf->putFloat->buf->putFloat->buf->put->if->gl->usePositions->positions->gl->getPositions->buf->put->else->rq->new->Runnable->flushAndInvokeNow
BufferedTextPipe#drawGlyphList(int, boolean, boolean, boolean, int, float, float, long[], float[]):::Called as a separate Runnable when the operation is too large to fit on the RenderQueue:::
BufferedTextPipe#validateContext(SunGraphics2D, Composite):::Validates the state in the provided SunGraphics2D object.:::
CompositePipe#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: composite pipe start sequence:::
CompositePipe#needTile(Object, int, int, int, int)::: composite pipe need tile:::
CompositePipe#renderPathTile(Object, byte[], int, int, int, int, int, int)::: composite pipe render path tile:::
CompositePipe#skipTile(Object, int, int)::: composite pipe skip tile:::
CompositePipe#endSequence(Object)::: composite pipe end sequence:::
DrawImage#copyImage(SunGraphics2D, Image, int, int, Color)::: draw image copy image:::imgw->img->getWidth->imgh->img->getHeight->if->isSimpleTranslate->return->renderImageCopy->atfm->if->new->AffineTransform->atfm->translate->transformImage->return
DrawImage#copyImage(SunGraphics2D, Image, int, int, int, int, int, int, Color)::: draw image copy image:::if->isSimpleTranslate->return->renderImageCopy->scaleImage->return
DrawImage#scaleImage(SunGraphics2D, Image, int, int, int, int, Color)::: draw image scale image:::imgw->img->getWidth->imgh->img->getHeight->if->isSimpleTranslate->dx1->dy1->dx2->dy2->if->renderImageScale->return->atfm->if->new->AffineTransform->atfm->translate->atfm->scale->transformImage->return
DrawImage#transformImage(SunGraphics2D, Image, int, int, AffineTransform, int)::: draw image transform image:::txtype->extraAT->getType->imgw->img->getWidth->imgh->img->getHeight->checkfinalxform->if->tx->extraAT->getTranslateX->ty->extraAT->getTranslateY->getTranslateX->getTranslateY->itx->Math->floor->ity->Math->floor->if->closeToInteger->closeToInteger->renderImageCopy->return->else->if->coords->new->doubleArr->extraAT->transform->transform->if->tryCopyOrScale->return->else->tx->new->AffineTransform->tx->translate->tx->concatenate->if->transformImage->else->renderImageXform
DrawImage#transformImage(SunGraphics2D, Image, AffineTransform, int, int, int, int, int, Color)::: draw image transform image:::coords->new->doubleArr->tx->transform->if->Math->abs->Math->abs->tryCopyOrScale->return->renderImageXform
DrawImage#tryCopyOrScale(SunGraphics2D, Image, int, int, int, int, Color, int, double[])::: draw image try copy or scale:::dx1->dy1->dx2->dy2->dw->dh->if->return->if->closeToInteger->closeToInteger->idx->Math->floor->idy->Math->floor->if->closeToInteger->closeToInteger->renderImageCopy->return->if->if->renderImageScale->return->return
DrawImage#makeBufferedImage(Image, Color, int, int, int, int, int):::Return a non-accelerated BufferedImage of the requested type with the indicated subimage of the original image located at 0,0 in the new image:::width->height->bimg->new->BufferedImage->g2d->bimg->createGraphics->g2d->setComposite->bimg->setAccelerationPriority->if->g2d->setColor->g2d->fillRect->g2d->setComposite->g2d->copyImage->g2d->dispose->return
DrawImage#renderImageXform(SunGraphics2D, Image, AffineTransform, int, int, int, int, int, Color)::: draw image render image xform:::itx->try->tx->createInverse->catch->return->finally->coords->new->doubleArr->tx->transform->ddx1->ddy1->ddx2->ddy2->for->i->clip->sg->getCompClip->dx1->Math->Math->floor->clip->getLoX->max->dy1->Math->Math->floor->clip->getLoY->max->dx2->Math->Math->ceil->clip->getHiX->min->dy2->Math->Math->ceil->clip->getHiY->min->if->return->dstData->srcData->dstData->getSourceSurfaceData->if->getBufferedImage->dstData->getSourceSurfaceData->if->return->if->isBgOperation->bgAlpha->bgColor->getAlpha->type->makeBufferedImage->dstData->getSourceSurfaceData->srcType->srcData->getSurfaceType->helper->TransformHelper->getFromCache->if->type->srcData->getTransparency->makeBufferedImage->dstData->getSourceSurfaceData->srcData->getSurfaceType->TransformHelper->getFromCache->dstType->dstData->getSurfaceType->if->maskblit->MaskBlit->getFromCache->if->maskblit->getNativePrim->helper->Transform->return->w->h->tmpimg->new->BufferedImage->tmpData->SurfaceData->getPrimarySurfaceData->tmpType->tmpData->getSurfaceType->tmpmaskblit->MaskBlit->getFromCache->edges->new->intArr->helper->Transform->region->Region->getInstance->clip->getIntersection->blit->Blit->getFromCache->blit->Blit
DrawImage#renderImageCopy(SunGraphics2D, Image, Color, int, int, int, int, int, int)::: draw image render image copy:::clip->sg->getCompClip->dstData->attempts->while->srcData->dstData->getSourceSurfaceData->if->return->try->srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->blitSurfaceData->return->catch->if->SurfaceData->isNull->SurfaceData->isNull->throw->return->sg->getCompClip->if->SurfaceData->isNull->SurfaceData->isNull->return->finally
DrawImage#renderImageScale(SunGraphics2D, Image, Color, int, int, int, int, int, double, double, double, double)::: draw image render image scale:::if->return->clip->sg->getCompClip->dstData->attempts->while->srcData->dstData->getSourceSurfaceData->if->isBgOperation->return->try->srcType->srcData->getSurfaceType->dstType->dstData->getSurfaceType->return->scaleSurfaceData->catch->if->SurfaceData->isNull->throw->return->sg->getCompClip->if->SurfaceData->isNull->SurfaceData->isNull->return->finally
DrawImage#scaleImage(SunGraphics2D, Image, int, int, int, int, int, int, int, int, Color)::: draw image scale image:::srcW->srcH->dstW->dstH->srcX->srcY->dstX->dstY->srcWidthFlip->srcHeightFlip->dstWidthFlip->dstHeightFlip->if->else->if->else->if->else->if->else->if->return->if->isSimpleTranslate->ddx1->ddy1->ddx2->ddy2->if->renderImageScale->return->atfm->new->AffineTransform->atfm->translate->m00->m11->atfm->scale->atfm->translate->scaleX->SurfaceManager->getImageScaleX->scaleY->SurfaceManager->getImageScaleY->imgW->Math->img->getWidth->ceil->imgH->Math->img->getHeight->ceil->if->if->if->atfm->translate->if->atfm->translate->if->return->transformImage->return
DrawImage#closeToInteger(int, double)::: draw image close to integer:::return->Math->abs
DrawImage#isSimpleTranslate(SunGraphics2D)::: draw image is simple translate:::ts->if->return->if->return->if->return->return
DrawImage#isBgOperation(SurfaceData, Color)::: draw image is bg operation:::return->srcData->getTransparency
DrawImage#getBufferedImage(Image)::: draw image get buffered image:::if->return->return->getSnapshot
DrawImage#getTransformColorModel(SunGraphics2D, BufferedImage, AffineTransform)::: draw image get transform color model:::cm->bImg->getColorModel->dstCM->if->tx->isIdentity->return->type->tx->getType->needTrans->if->mtx->new->doubleArr->tx->getMatrix->if->if->raster->bImg->getRaster->icm->if->cm->getTransparency->if->ColorModel->getRGBdefault->else->matrix->new->doubleArr->tx->getMatrix->if->else->mapSize->icm->getMapSize->if->cmap->new->intArr->icm->getRGBs->icm->getPixelSize->new->IndexColorModel->else->ColorModel->getRGBdefault->else->if->cm->getTransparency->ColorModel->getRGBdefault->else->if->cm->getTransparency->ColorModel->getRGBdefault->return
DrawImage#blitSurfaceData(SunGraphics2D, Region, SurfaceData, SurfaceData, SurfaceType, SurfaceType, int, int, int, int, int, int, Color)::: draw image blit surface data:::if->return->comp->if->equals->srcData->getTransparency->bgColor->getTransparency->if->equals->return->if->isBgOperation->blit->Blit->getFromCache->blit->Blit->else->blit->BlitBg->getFromCache->blit->bgColor->getRGB->BlitBg
DrawImage#scaleSurfaceData(SunGraphics2D, Region, SurfaceData, SurfaceData, SurfaceType, SurfaceType, int, int, int, int, double, double, double, double)::: draw image scale surface data:::comp->if->equals->srcData->getTransparency->blit->ScaledBlit->getFromCache->if->blit->Scale->return->return
DrawImage#imageReady(ToolkitImage, ImageObserver)::: draw image image ready:::if->sunimg->hasError->if->observer->imageUpdate->return->return
DrawImage#copyImage(SunGraphics2D, Image, int, int, Color, ImageObserver)::: draw image copy image:::if->return->copyImage->else->sunimg->if->imageReady->return->ir->sunimg->getImageRep->return->ir->drawToBufImage
DrawImage#copyImage(SunGraphics2D, Image, int, int, int, int, int, int, Color, ImageObserver)::: draw image copy image:::if->return->copyImage->else->sunimg->if->imageReady->return->ir->sunimg->getImageRep->return->ir->drawToBufImage
DrawImage#scaleImage(SunGraphics2D, Image, int, int, int, int, Color, ImageObserver)::: draw image scale image:::if->return->scaleImage->else->sunimg->if->imageReady->return->ir->sunimg->getImageRep->return->ir->drawToBufImage
DrawImage#scaleImage(SunGraphics2D, Image, int, int, int, int, int, int, int, int, Color, ImageObserver)::: draw image scale image:::if->return->scaleImage->else->sunimg->if->imageReady->return->ir->sunimg->getImageRep->return->ir->drawToBufImage
DrawImage#transformImage(SunGraphics2D, Image, AffineTransform, ImageObserver)::: draw image transform image:::if->transformImage->return->else->sunimg->if->imageReady->return->ir->sunimg->getImageRep->return->ir->drawToBufImage
DrawImage#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: draw image transform image:::if->if->atop->atop->getTransform->atop->getInterpolationType->transformImage->return->else->op->filter->copyImage
DrawImagePipe#copyImage(SunGraphics2D, Image, int, int, Color, ImageObserver)::: draw image pipe copy image:::
DrawImagePipe#copyImage(SunGraphics2D, Image, int, int, int, int, int, int, Color, ImageObserver)::: draw image pipe copy image:::
DrawImagePipe#scaleImage(SunGraphics2D, Image, int, int, int, int, Color, ImageObserver)::: draw image pipe scale image:::
DrawImagePipe#scaleImage(SunGraphics2D, Image, int, int, int, int, int, int, int, int, Color, ImageObserver)::: draw image pipe scale image:::
DrawImagePipe#transformImage(SunGraphics2D, Image, AffineTransform, ImageObserver)::: draw image pipe transform image:::
DrawImagePipe#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: draw image pipe transform image:::
GeneralCompositePipe#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: general composite pipe start sequence:::hints->sg->getRenderingHints->model->sg->getDeviceColorModel->paintContext->s->getBounds2D->sg->cloneTransform->createContext->compositeContext->paintContext->getColorModel->createContext->return->new->TileContext
GeneralCompositePipe#needTile(Object, int, int, int, int)::: general composite pipe need tile:::return
GeneralCompositePipe#renderPathTile(Object, byte[], int, int, int, int, int, int):::GeneralCompositePipe.renderPathTile works with custom composite operator provided by an application:::context->paintCtxt->compCtxt->sg->srcRaster->paintCtxt->getRaster->paintModel->paintCtxt->getColorModel->dstRaster->dstIn->dstOut->sd->sg->getSurfaceData->sd->getRaster->if->dstOut->createWritableChild->else->dstRaster->createChild->dstIn->createCompatibleWritableRaster->compCtxt->compose->if->dstOut->getParent->if->setDataElements->else->cm->sg->getDeviceColorModel->resImg->cm->isAlphaPremultiplied->new->BufferedImage->resData->BufImgSurfaceData->createData->if->blit->Blit->resData->getSurfaceType->sd->getSurfaceType->getFromCache->blit->Blit->else->blit->MaskBlit->resData->getSurfaceType->sd->getSurfaceType->getFromCache->blit->MaskBlit
GeneralCompositePipe#skipTile(Object, int, int)::: general composite pipe skip tile:::return
GeneralCompositePipe#endSequence(Object)::: general composite pipe end sequence:::context->if->dispose->if->dispose
GlyphListLoopPipe#drawGlyphList(SunGraphics2D, GlyphList, int)::: glyph list loop pipe draw glyph list:::switch->DrawGlyphList->return->DrawGlyphListAA->return->DrawGlyphListLCD->return
GlyphListPipe#drawString(SunGraphics2D, String, double, double)::: glyph list pipe draw string:::info->sg2d->getFontInfo->if->drawString->return->devx->devy->if->origin->transform->else->gl->GlyphList->getInstance->if->gl->setFromString->drawGlyphList->gl->dispose->else->gl->dispose->tl->sg2d->getFont->sg2d->getFontRenderContext->new->TextLayout->tl->draw
GlyphListPipe#drawChars(SunGraphics2D, char[], int, int, int, int)::: glyph list pipe draw chars:::info->sg2d->getFontInfo->x->y->if->drawChars->return->if->origin->transform->else->gl->GlyphList->getInstance->if->gl->setFromChars->drawGlyphList->gl->dispose->else->gl->dispose->tl->new->String->sg2d->getFont->sg2d->getFontRenderContext->new->TextLayout->tl->draw
GlyphListPipe#drawGlyphVector(SunGraphics2D, GlyphVector, float, float)::: glyph list pipe draw glyph vector:::frc->gv->getFontRenderContext->info->sg2d->gv->getFont->getGVFontInfo->if->drawGlyphVector->return->if->origin->transform->else->gl->GlyphList->getInstance->gl->setFromGlyphVector->drawGlyphList->gl->dispose
GlyphListPipe#drawGlyphList(SunGraphics2D, GlyphList)::: glyph list pipe draw glyph list:::
GlyphListPipe#drawGlyphList(SunGraphics2D, GlyphList, int)::: glyph list pipe draw glyph list:::drawGlyphList
LCDTextRenderer#drawGlyphList(SunGraphics2D, GlyphList)::: text renderer draw glyph list:::DrawGlyphListLCD
LoopPipe#drawLine(SunGraphics2D, int, int, int, int)::: loop pipe draw line:::tX->tY->sg2d->getSurfaceData->DrawLine
LoopPipe#drawRect(SunGraphics2D, int, int, int, int)::: loop pipe draw rect:::sg2d->getSurfaceData->DrawRect
LoopPipe#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: loop pipe draw round rect:::new->RoundRectangle2D.Float->draw
LoopPipe#drawOval(SunGraphics2D, int, int, int, int)::: loop pipe draw oval:::new->Ellipse2D.Float->draw
LoopPipe#drawArc(SunGraphics2D, int, int, int, int, int, int)::: loop pipe draw arc:::new->Arc2D.Float->draw
LoopPipe#drawPolyline(SunGraphics2D, int[], int[], int)::: loop pipe draw polyline:::nPointsArray->sg2d->getSurfaceData->DrawPolygons
LoopPipe#drawPolygon(SunGraphics2D, int[], int[], int)::: loop pipe draw polygon:::nPointsArray->sg2d->getSurfaceData->DrawPolygons
LoopPipe#fillRect(SunGraphics2D, int, int, int, int)::: loop pipe fill rect:::sg2d->getSurfaceData->FillRect
LoopPipe#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: loop pipe fill round rect:::new->RoundRectangle2D.Float->fill
LoopPipe#fillOval(SunGraphics2D, int, int, int, int)::: loop pipe fill oval:::new->Ellipse2D.Float->fill
LoopPipe#fillArc(SunGraphics2D, int, int, int, int, int, int)::: loop pipe fill arc:::new->Arc2D.Float->fill
LoopPipe#fillPolygon(SunGraphics2D, int[], int[], int)::: loop pipe fill polygon:::sr->getFillSSI->try->sr->sg2d->getCompClip->setOutputArea->sr->appendPoly->fillSpans->catch->finally->sr->dispose
LoopPipe#draw(SunGraphics2D, Shape)::: loop pipe draw:::if->p2df->transX->transY->if->if->else->new->Path2D.Float->else->new->Path2D.Float->sg2d->getSurfaceData->DrawPath->return->if->createStrokedShape->fill->return->sr->getStrokeSpans->try->fillSpans->catch->finally->sr->dispose
LoopPipe#getFillSSI(SunGraphics2D):::Return a ShapeSpanIterator instance that normalizes as appropriate for a fill operation as per the settings in the specified SunGraphics2D object:::adjust->return->new->ShapeSpanIterator
LoopPipe#getStrokeSpans(SunGraphics2D, Shape)::: loop pipe get stroke spans:::sr->new->ShapeSpanIterator->try->sr->sg2d->getCompClip->setOutputArea->sr->setRule->bs->thin->normalize->RenderEngine->strokeTo->catch->sr->dispose->throw->t->getMessage->new->InternalError->finally->return
LoopPipe#fill(SunGraphics2D, Shape)::: loop pipe fill:::if->p2df->transX->transY->if->if->else->new->Path2D.Float->else->new->Path2D.Float->sg2d->getSurfaceData->FillPath->return->sr->getFillSSI->try->sr->sg2d->getCompClip->setOutputArea->at->sr->s->getPathIterator->appendPath->fillSpans->catch->finally->sr->dispose
LoopPipe#fillSpans(SunGraphics2D, SpanIterator)::: loop pipe fill spans:::if->filter->else->fs->if->fs->sg2d->getSurfaceData->FillSpans->return->spanbox->new->intArr->sd->sg2d->getSurfaceData->while->si->nextSpan->x->y->w->h->FillRect
LoopPipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: loop pipe fill parallelogram:::fp->fp->sg2d->getSurfaceData->FillParallelogram
LoopPipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double)::: loop pipe draw parallelogram:::dp->dp->sg2d->getSurfaceData->DrawParallelogram
NullPipe#drawLine(SunGraphics2D, int, int, int, int)::: null pipe draw line:::
NullPipe#drawRect(SunGraphics2D, int, int, int, int)::: null pipe draw rect:::
NullPipe#fillRect(SunGraphics2D, int, int, int, int)::: null pipe fill rect:::
NullPipe#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: null pipe draw round rect:::
NullPipe#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: null pipe fill round rect:::
NullPipe#drawOval(SunGraphics2D, int, int, int, int)::: null pipe draw oval:::
NullPipe#fillOval(SunGraphics2D, int, int, int, int)::: null pipe fill oval:::
NullPipe#drawArc(SunGraphics2D, int, int, int, int, int, int)::: null pipe draw arc:::
NullPipe#fillArc(SunGraphics2D, int, int, int, int, int, int)::: null pipe fill arc:::
NullPipe#drawPolyline(SunGraphics2D, int[], int[], int)::: null pipe draw polyline:::
NullPipe#drawPolygon(SunGraphics2D, int[], int[], int)::: null pipe draw polygon:::
NullPipe#fillPolygon(SunGraphics2D, int[], int[], int)::: null pipe fill polygon:::
NullPipe#draw(SunGraphics2D, Shape)::: null pipe draw:::
NullPipe#fill(SunGraphics2D, Shape)::: null pipe fill:::
NullPipe#drawString(SunGraphics2D, String, double, double)::: null pipe draw string:::
NullPipe#drawGlyphVector(SunGraphics2D, GlyphVector, float, float)::: null pipe draw glyph vector:::
NullPipe#drawChars(SunGraphics2D, char[], int, int, int, int)::: null pipe draw chars:::
NullPipe#copyImage(SunGraphics2D, Image, int, int, Color, ImageObserver)::: null pipe copy image:::return
NullPipe#copyImage(SunGraphics2D, Image, int, int, int, int, int, int, Color, ImageObserver)::: null pipe copy image:::return
NullPipe#scaleImage(SunGraphics2D, Image, int, int, int, int, Color, ImageObserver)::: null pipe scale image:::return
NullPipe#scaleImage(SunGraphics2D, Image, int, int, int, int, int, int, int, int, Color, ImageObserver)::: null pipe scale image:::return
NullPipe#transformImage(SunGraphics2D, Image, AffineTransform, ImageObserver)::: null pipe transform image:::return
NullPipe#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: null pipe transform image:::
OutlineTextRenderer#drawChars(SunGraphics2D, char[], int, int, int, int)::: outline text renderer draw chars:::s->new->String->drawString
OutlineTextRenderer#drawString(SunGraphics2D, String, double, double)::: outline text renderer draw string:::if->equals->return->tl->g2d->getFont->g2d->getFontRenderContext->new->TextLayout->s->tl->AffineTransform->getTranslateInstance->getOutline->textAAHint->g2d->getFontInfo->prevaaHint->if->g2d->validatePipe->else->if->g2d->validatePipe->g2d->fill->if->g2d->validatePipe
OutlineTextRenderer#drawGlyphVector(SunGraphics2D, GlyphVector, float, float)::: outline text renderer draw glyph vector:::s->gv->getOutline->prevaaHint->frc->gv->getFontRenderContext->aa->frc->isAntiAliased->if->if->g2d->gv->getFont->getGVFontInfo->if->g2d->validatePipe->else->if->g2d->validatePipe->g2d->fill->if->g2d->validatePipe
ParallelogramPipe#fillParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double)::: parallelogram pipe fill parallelogram:::
ParallelogramPipe#drawParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double):::Draw a Parallelogram with the indicated line widths assuming a standard BasicStroke with MITER joins:::
PixelDrawPipe#drawLine(SunGraphics2D, int, int, int, int)::: pixel draw pipe draw line:::
PixelDrawPipe#drawRect(SunGraphics2D, int, int, int, int)::: pixel draw pipe draw rect:::
PixelDrawPipe#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: pixel draw pipe draw round rect:::
PixelDrawPipe#drawOval(SunGraphics2D, int, int, int, int)::: pixel draw pipe draw oval:::
PixelDrawPipe#drawArc(SunGraphics2D, int, int, int, int, int, int)::: pixel draw pipe draw arc:::
PixelDrawPipe#drawPolyline(SunGraphics2D, int[], int[], int)::: pixel draw pipe draw polyline:::
PixelDrawPipe#drawPolygon(SunGraphics2D, int[], int[], int)::: pixel draw pipe draw polygon:::
PixelFillPipe#fillRect(SunGraphics2D, int, int, int, int)::: pixel fill pipe fill rect:::
PixelFillPipe#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: pixel fill pipe fill round rect:::
PixelFillPipe#fillOval(SunGraphics2D, int, int, int, int)::: pixel fill pipe fill oval:::
PixelFillPipe#fillArc(SunGraphics2D, int, int, int, int, int, int)::: pixel fill pipe fill arc:::
PixelFillPipe#fillPolygon(SunGraphics2D, int[], int[], int)::: pixel fill pipe fill polygon:::
PixelToParallelogramConverter#drawLine(SunGraphics2D, int, int, int, int)::: pixel to parallelogram converter draw line:::if->drawGeneralLine->super->drawLine
PixelToParallelogramConverter#drawRect(SunGraphics2D, int, int, int, int)::: pixel to parallelogram converter draw rect:::if->if->bs->if->if->bs->getLineJoin->bs->getDashArray->lw->bs->getLineWidth->drawRectangle->return->else->drawLine->return->super->drawRect
PixelToParallelogramConverter#fillRect(SunGraphics2D, int, int, int, int)::: pixel to parallelogram converter fill rect:::if->fillRectangle
PixelToParallelogramConverter#draw(SunGraphics2D, Shape)::: pixel to parallelogram converter draw:::if->bs->if->if->bs->getLineJoin->bs->getDashArray->r2d->w->r2d->getWidth->h->r2d->getHeight->x->r2d->getX->y->r2d->getY->if->lw->bs->getLineWidth->drawRectangle->return->else->if->l2d->if->l2d->getX1->l2d->getY1->l2d->getX2->l2d->getY2->drawGeneralLine->return->outpipe->draw
PixelToParallelogramConverter#fill(SunGraphics2D, Shape)::: pixel to parallelogram converter fill:::if->r2d->w->r2d->getWidth->h->r2d->getHeight->if->x->r2d->getX->y->r2d->getY->fillRectangle->return->outpipe->fill
PixelToParallelogramConverter#len(double, double)::: pixel to parallelogram converter len:::return->Math->abs->Math->abs->Math->sqrt
PixelToParallelogramConverter#normalize(double)::: pixel to parallelogram converter normalize:::return->Math->floor
PixelToParallelogramConverter#drawGeneralLine(SunGraphics2D, double, double, double, double)::: pixel to parallelogram converter draw general line:::if->return->bs->cap->bs->getEndCap->if->bs->getDashArray->return->lw->bs->getLineWidth->dx->dy->x1->y1->x2->y2->switch->coords->transform->break->tx->getTranslateX->ty->getTranslateY->break->break->throw->new->InternalError->if->if->ix1->Math->floor->iy1->Math->floor->ix2->Math->floor->iy2->Math->floor->drawLine->return->normalize->normalize->normalize->normalize->if->len->len->if->unitvector->deltaTransform->len->Math->max->len->len->udx->udy->if->if->return->else->px->py->if->outrenderer->fillParallelogram->return
PixelToParallelogramConverter#fillRectangle(SunGraphics2D, double, double, double, double)::: pixel to parallelogram converter fill rectangle:::px->py->dx1->dy1->dx2->dy2->txform->txform->getScaleX->txform->getShearY->txform->getShearX->txform->getScaleY->txform->getTranslateX->txform->getTranslateY->if->newx->normalize->newy->normalize->normalize->normalize->normalize->normalize->outrenderer->fillParallelogram
PixelToParallelogramConverter#drawRectangle(SunGraphics2D, double, double, double, double, double)::: pixel to parallelogram converter draw rectangle:::px->py->dx1->dy1->dx2->dy2->lw1->lw2->txform->txform->getScaleX->txform->getShearY->txform->getShearX->txform->getScaleY->txform->getTranslateX->txform->getTranslateY->len->len->if->newx->normalize->newy->normalize->normalize->normalize->normalize->normalize->Math->max->Math->max->len1->len->len2->len->if->fillOuterParallelogram->else->outrenderer->drawParallelogram
PixelToParallelogramConverter#fillOuterParallelogram(SunGraphics2D, double, double, double, double, double, double, double, double, double, double, double, double, double, double):::This utility function handles the case where a drawRectangle operation discovered that the interior hole in the rectangle or parallelogram has been completely filled in by the stroke width:::udx1->udy1->udx2->udy2->if->if->else->if->outrenderer->fillParallelogram
PixelToShapeConverter#drawLine(SunGraphics2D, int, int, int, int)::: pixel to shape converter draw line:::outpipe->new->Line2D.Float->draw
PixelToShapeConverter#drawRect(SunGraphics2D, int, int, int, int)::: pixel to shape converter draw rect:::outpipe->new->Rectangle->draw
PixelToShapeConverter#fillRect(SunGraphics2D, int, int, int, int)::: pixel to shape converter fill rect:::outpipe->new->Rectangle->fill
PixelToShapeConverter#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: pixel to shape converter draw round rect:::outpipe->new->RoundRectangle2D.Float->draw
PixelToShapeConverter#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: pixel to shape converter fill round rect:::outpipe->new->RoundRectangle2D.Float->fill
PixelToShapeConverter#drawOval(SunGraphics2D, int, int, int, int)::: pixel to shape converter draw oval:::outpipe->new->Ellipse2D.Float->draw
PixelToShapeConverter#fillOval(SunGraphics2D, int, int, int, int)::: pixel to shape converter fill oval:::outpipe->new->Ellipse2D.Float->fill
PixelToShapeConverter#drawArc(SunGraphics2D, int, int, int, int, int, int)::: pixel to shape converter draw arc:::outpipe->new->Arc2D.Float->draw
PixelToShapeConverter#fillArc(SunGraphics2D, int, int, int, int, int, int)::: pixel to shape converter fill arc:::outpipe->new->Arc2D.Float->fill
PixelToShapeConverter#makePoly(int[], int[], int, boolean)::: pixel to shape converter make poly:::gp->new->GeneralPath->if->gp->moveTo->for->i->if->gp->closePath->return
PixelToShapeConverter#drawPolyline(SunGraphics2D, int[], int[], int)::: pixel to shape converter draw polyline:::outpipe->makePoly->draw
PixelToShapeConverter#drawPolygon(SunGraphics2D, int[], int[], int)::: pixel to shape converter draw polygon:::outpipe->makePoly->draw
PixelToShapeConverter#fillPolygon(SunGraphics2D, int[], int[], int)::: pixel to shape converter fill polygon:::outpipe->makePoly->fill
Region#initIDs()::: region init ds:::
Region#dimAdd(int, int):::Adds the dimension dim to the coordinate start with appropriate clipping:::if->return->if->return->return
Region#clipAdd(int, int):::Adds the delta dv to the value v with appropriate clipping to the bounds of Integer resolution:::newv->if->return
Region#clipRound(double):::Returns the closest int to the argument, with ties rounding to negative infinity:::newv->if->return->if->return->return->Math->ceil
Region#clipScale(int, double):::Multiply the scale factor sv and the value v with appropriate clipping to the bounds of Integer resolution:::if->return->newv->if->return->if->return->return->Math->round
Region#getInstance(Shape, AffineTransform):::Returns a Region object covering the pixels which would be touched by a fill or clip operation on a Graphics implementation on the specified Shape object under the optionally specified AffineTransform object.:::return->getInstance
Region#getInstance(Region, Shape, AffineTransform):::Returns a Region object covering the pixels which would be touched by a fill or clip operation on a Graphics implementation on the specified Shape object under the optionally specified AffineTransform object further restricted by the specified device bounds:::return->getInstance
Region#getInstance(Region, boolean, Shape, AffineTransform):::Returns a Region object covering the pixels which would be touched by a fill or clip operation on a Graphics implementation on the specified Shape object under the optionally specified AffineTransform object further restricted by the specified device bounds:::if->isEmpty->return->box->new->intArr->sr->new->ShapeSpanIterator->try->sr->setOutputArea->sr->s->getPathIterator->appendPath->sr->getPathBox->return->Region->getInstance->catch->finally->sr->dispose
Region#getInstance(int, int, int, int, int[]):::Returns a Region object with a rectangle of interest specified by the indicated rectangular area in lox, loy, hix, hiy and edges array, which is located relative to the rectangular area:::y1->y2->if->return->bands->new->intArr->end->index->for->y->return->new->Region
Region#getInstance(Rectangle):::Returns a Region object with a rectangle of interest specified by the indicated Rectangle object:::return->Region->getInstanceXYWH
Region#getInstanceXYWH(int, int, int, int):::Returns a Region object with a rectangle of interest specified by the indicated rectangular area in x, y, width, height format:::return->Region->dimAdd->dimAdd->getInstanceXYXY
Region#getInstance(int[]):::Returns a Region object with a rectangle of interest specified by the indicated span array:::return->new->Region
Region#getInstanceXYXY(int, int, int, int):::Returns a Region object with a rectangle of interest specified by the indicated rectangular area in lox, loy, hix, hiy format:::return->new->Region
Region#getInstance(int[], SpanIterator):::Returns a Region object with a rectangle of interest specified by the indicated rectangular area in lox, loy, hix, hiy format:::ret->new->Region->ret->appendSpans->return
Region#appendSpans(SpanIterator):::Appends the list of spans returned from the indicated SpanIterator:::box->new->intArr->while->si->nextSpan->appendSpan->endRow->calcBBox
Region#getScaledRegion(double, double):::Returns a Region object that represents the same list of rectangles as the current Region object, scaled by the specified sx, sy factors.:::if->return->if->return->tlox->clipScale->tloy->clipScale->thix->clipScale->thiy->clipScale->ret->new->Region->bands->if->end->newbands->new->intArr->i->j->ncol->while->y1->y2->clipScale->clipScale->savej->if->while->x1->clipScale->x2->clipScale->if->else->if->else->if->if->else->else->return
Region#getTranslatedRegion(int, int):::Returns a Region object that represents the same list of rectangles as the current Region object, translated by the specified dx, dy translation factors.:::if->return->tlox->tloy->thix->thiy->if->return->getSafeTranslatedRegion->ret->new->Region->bands->if->end->newbands->new->intArr->i->ncol->while->while->return
Region#getSafeTranslatedRegion(int, int)::: region get safe translated region:::tlox->clipAdd->tloy->clipAdd->thix->clipAdd->thiy->clipAdd->ret->new->Region->bands->if->end->newbands->new->intArr->i->j->ncol->while->y1->y2->clipAdd->clipAdd->savej->if->while->x1->clipAdd->x2->clipAdd->if->else->if->else->if->if->else->else->return
Region#getIntersection(Rectangle):::Returns a Region object that represents the intersection of this object with the specified Rectangle:::return->getIntersectionXYWH
Region#getIntersectionXYWH(int, int, int, int):::Returns a Region object that represents the intersection of this object with the specified rectangular area:::return->dimAdd->dimAdd->getIntersectionXYXY
Region#getIntersection(Rectangle2D):::Returns a Region object that represents the intersection of this object with the specified Rectangle2D:::if->return->getIntersection->return->r->getMinX->r->getMinY->r->getMaxX->r->getMaxY->getIntersectionXYXY
Region#getIntersectionXYXY(double, double, double, double):::Returns a Region object that represents the intersection of this object with the specified rectangular area:::if->isNaN->isNaN->isNaN->isNaN->return->return->clipRound->clipRound->clipRound->clipRound->getIntersectionXYXY
Region#getIntersectionXYXY(int, int, int, int):::Returns a Region object that represents the intersection of this object with the specified rectangular area:::if->isInsideXYXY->return->ret->new->Region->if->ret->this->getSpanIterator->appendSpans->return
Region#getIntersection(Region):::Returns a Region object that represents the intersection of this object with the specified Region object:::if->this->isInsideQuickCheck->return->if->r->isInsideQuickCheck->return->ret->new->Region->if->ret->isEmpty->ret->filterSpans->return
Region#getUnion(Region):::Returns a Region object that represents the union of this object with the specified Region object:::if->r->isEmpty->r->isInsideQuickCheck->return->if->this->isEmpty->this->isInsideQuickCheck->return->ret->new->Region->ret->filterSpans->return
Region#getDifference(Region):::Returns a Region object that represents the difference of the specified Region object subtracted from this object:::if->r->intersectsQuickCheck->return->if->this->isInsideQuickCheck->return->ret->new->Region->ret->filterSpans->return
Region#getExclusiveOr(Region):::Returns a Region object that represents the exclusive or of this object with the specified Region object:::if->r->isEmpty->return->if->this->isEmpty->return->ret->new->Region->ret->filterSpans->return
Region#filterSpans(Region, Region, int)::: region filter spans:::abands->bbands->if->new->intArr->if->new->intArr->box->new->intArr->acolstart->ay1->ay2->acolend->bcolstart->by1->by2->bcolend->y->while->if->if->else->if->break->continue->if->if->else->if->break->continue->yend->if->if->Math->min->continue->Math->min->if->acol->while->appendSpan->else->if->Math->min->if->bcol->while->appendSpan->else->Math->min->acol->bcol->ax1->ax2->bx1->bx2->x->Math->min->if->while->if->if->else->if->break->continue->if->if->else->if->break->continue->xend->appendit->if->if->Math->min->else->Math->min->else->if->Math->min->else->Math->min->if->appendSpan->endRow->calcBBox
Region#getBoundsIntersection(Rectangle):::Returns a Region object that represents the bounds of the intersection of this object with the bounds of the specified Region object:::return->getBoundsIntersectionXYWH
Region#getBoundsIntersectionXYWH(int, int, int, int):::Returns a Region object that represents the bounds of the intersection of this object with the bounds of the specified rectangular area in x, y, width, height format:::return->dimAdd->dimAdd->getBoundsIntersectionXYXY
Region#getBoundsIntersectionXYXY(int, int, int, int):::Returns a Region object that represents the bounds of the intersection of this object with the bounds of the specified rectangular area in lox, loy, hix, hiy format:::if->return->return->new->Region
Region#getBoundsIntersection(Region):::Returns a Region object that represents the intersection of this object with the bounds of the specified Region object:::if->this->encompasses->return->if->r->encompasses->return->return->new->Region
Region#appendSpan(int[]):::Appends a single span defined by the 4 parameters spanlox, spanloy, spanhix, spanhiy:::spanlox->spanloy->spanhix->spanhiy->if->if->if->if->if->return->curYrow->if->if->new->intArr->else->needSpace->endRow->else->if->if->return->needSpace->else->throw->new->InternalError
Region#needSpace(int)::: region need space:::if->newbands->new->intArr->System->arraycopy
Region#endRow(int[])::: region end row:::cur->prev->if->bands->if->num->while->if->break->if->return
Region#calcBBox()::: region calc box:::bands->if->if->else->return->lox->hix->hiyindex->i->while->numbands->if->if
Region#getLoX():::Returns the lowest X coordinate in the Region.:::return
Region#getLoY():::Returns the lowest Y coordinate in the Region.:::return
Region#getHiX():::Returns the highest X coordinate in the Region.:::return
Region#getHiY():::Returns the highest Y coordinate in the Region.:::return
Region#getWidth():::Returns the width of this Region clipped to the range (0 - MAX_INT).:::if->return->w->if->return
Region#getHeight():::Returns the height of this Region clipped to the range (0 - MAX_INT).:::if->return->h->if->return
Region#isEmpty():::Returns true iff this Region encloses no area.:::return
Region#isRectangular():::Returns true iff this Region represents a single simple rectangular area.:::return
Region#contains(int, int):::Returns true iff this Region contains the specified coordinate.:::if->return->if->return->i->while->if->return->if->numspans->else->end->while->if->return->if->return->return->return
Region#isInsideXYWH(int, int, int, int):::Returns true iff this Region lies inside the indicated rectangular area specified in x, y, width, height format with appropriate clipping performed as per the dimAdd method.:::return->dimAdd->dimAdd->isInsideXYXY
Region#isInsideXYXY(int, int, int, int):::Returns true iff this Region lies inside the indicated rectangular area specified in lox, loy, hix, hiy format.:::return
Region#isInsideQuickCheck(Region):::Quickly checks if this Region lies inside the specified Region object:::return
Region#intersectsQuickCheckXYXY(int, int, int, int):::Quickly checks if this Region intersects the specified rectangular area specified in lox, loy, hix, hiy format:::return
Region#intersectsQuickCheck(Region):::Quickly checks if this Region intersects the specified Region object:::return
Region#encompasses(Region):::Quickly checks if this Region surrounds the specified Region object:::return
Region#encompassesXYWH(int, int, int, int):::Quickly checks if this Region surrounds the specified rectangular area specified in x, y, width, height format:::return->dimAdd->dimAdd->encompassesXYXY
Region#encompassesXYXY(int, int, int, int):::Quickly checks if this Region surrounds the specified rectangular area specified in lox, loy, hix, hiy format:::return
Region#getBounds(int[]):::Gets the bbox of the available spans, clipped to the OutputArea.:::
Region#clipBoxToBounds(int[]):::Clips the indicated bbox array to the bounds of this Region.:::if->if->if->if
Region#getIterator():::Gets an iterator object to iterate over the spans in this region.:::return->new->RegionIterator
Region#getSpanIterator():::Gets a span iterator object that iterates over the spans in this region:::return->new->RegionSpanIterator
Region#getSpanIterator(int[]):::Gets a span iterator object that iterates over the spans in this region but clipped to the bounds given in the argument (xlo, ylo, xhi, yhi).:::result->getSpanIterator->result->intersectClipBox->return
Region#filter(SpanIterator):::Returns a SpanIterator that is the argument iterator filtered by this region.:::if->si->intersectClipBox->else->new->RegionClipSpanIterator->return
Region#toString()::: region to string:::sb->new->StringBuilder->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->if->col->while->sb->append->sb->append->sb->append->sb->append->sb->append->end->while->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->sb->append->return->sb->toString
Region#hashCode()::: region hash code:::return->isEmpty
Region#equals(Object)::: region equals:::if->return->if->return->r->if->this->isEmpty->return->r->isEmpty->else->if->r->isEmpty->return->if->return->if->return->else->if->return->if->return->abands->bbands->for->i->return
RegionClipSpanIterator#getPathBox(int[])::: region clip span iterator get path box:::rgnbox->new->intArr->rgn->getBounds->spanIter->getPathBox->if->if->if->if
RegionClipSpanIterator#intersectClipBox(int, int, int, int)::: region clip span iterator intersect clip box:::spanIter->intersectClipBox
RegionClipSpanIterator#nextSpan(int[])::: region clip span iterator next span:::if->return->resultlox->resultloy->resulthix->resulthiy->doNextRow->while->if->if->spanIter->nextSpan->return->else->if->continue->if->continue->if->continue->if->continue->if->lwm->copyStateFrom->lwm->nextYRange->while->if->lwm->nextYRange->break->if->if->row->copyStateFrom->box->copyStateFrom->continue->if->ok->row->nextYRange->if->if->else->box->copyStateFrom->continue->if->ok->box->nextXBand->if->if->if->else->else->continue->if->else->if->else->if->else->if->else->if->continue->else->break->return
RegionClipSpanIterator#skipDownTo(int):::This method tells the iterator that it may skip all spans whose Y range is completely above the indicated Y coordinate.:::spanIter->skipDownTo
RegionClipSpanIterator#getNativeIterator():::This method returns a native pointer to a function block that can be used by a native method to perform the same iteration cycle that the above methods provide while avoiding upcalls to the Java object:::return
RegionClipSpanIterator#finalize()::: region clip span iterator finalize:::
RegionIterator#createCopy():::Returns a new RegionIterator object representing the same iteration state as this object to allow multiple iteration branches from the current position.:::r->new->RegionIterator->return
RegionIterator#copyStateFrom(RegionIterator):::Copies the iteration state from this RegionIterator object into another RegionIterator object to allow multiple iteration branches from the current position.:::if->throw->new->InternalError
RegionIterator#nextYRange(int[]):::Moves the iteration state to the beginning of the next Y range in the region returning true if one is found and recording the low and high Y coordinates of the range in the array at locations 1 and 3 respectively.:::if->return->return
RegionIterator#nextXBand(int[]):::Moves the iteration state to the beginning of the next X band in the current Y range returning true if one is found and recording the low and high X coordinates of the range in the array at locations 0 and 2 respectively.:::if->return->return
RegionSpanIterator#getPathBox(int[]):::Gets the bbox of the available region spans.:::
RegionSpanIterator#intersectClipBox(int, int, int, int):::Intersect the box used for clipping the output spans with the given box.:::if->if->if->if
RegionSpanIterator#nextSpan(int[]):::Fetches the next span that needs to be operated on:::if->return->if->getPathBox->return->curlox->curhix->curloy->curhiy->while->if->ri->nextXBand->if->ri->nextYRange->return->if->if->if->return->continue->if->if->if->break->return
RegionSpanIterator#skipDownTo(int):::This method tells the iterator that it may skip all spans whose Y range is completely above the indicated Y coordinate.:::
RegionSpanIterator#getNativeIterator():::This method returns a native pointer to a function block that can be used by a native method to perform the same iteration cycle that the above methods provide while avoiding upcalls to the Java object:::return
RenderBuffer#allocate(int):::Allocates a fresh buffer using the machine endianness.:::return->new->RenderBuffer
RenderBuffer#getAddress():::Returns the base address of the underlying memory buffer.:::return
RenderBuffer#capacity()::: render buffer capacity:::return
RenderBuffer#remaining()::: render buffer remaining:::return
RenderBuffer#position()::: render buffer position:::return
RenderBuffer#position(long)::: render buffer position:::
RenderBuffer#clear()::: render buffer clear:::
RenderBuffer#skip(long)::: render buffer skip:::return
RenderBuffer#putByte(byte)::: render buffer put byte:::unsafe->putByte->return
RenderBuffer#put(byte[])::: render buffer put:::return->put
RenderBuffer#put(byte[], int, int)::: render buffer put:::if->offsetInBytes->lengthInBytes->unsafe->copyMemory->position->position->else->end->for->i->return
RenderBuffer#putShort(short)::: render buffer put short:::unsafe->putShort->return
RenderBuffer#put(short[])::: render buffer put:::return->put
RenderBuffer#put(short[], int, int)::: render buffer put:::if->offsetInBytes->lengthInBytes->unsafe->copyMemory->position->position->else->end->for->i->return
RenderBuffer#putInt(int, int)::: render buffer put int:::unsafe->putInt->return
RenderBuffer#putInt(int)::: render buffer put int:::unsafe->putInt->return
RenderBuffer#put(int[])::: render buffer put:::return->put
RenderBuffer#put(int[], int, int)::: render buffer put:::if->offsetInBytes->lengthInBytes->unsafe->copyMemory->position->position->else->end->for->i->return
RenderBuffer#putFloat(float)::: render buffer put float:::unsafe->putFloat->return
RenderBuffer#put(float[])::: render buffer put:::return->put
RenderBuffer#put(float[], int, int)::: render buffer put:::if->offsetInBytes->lengthInBytes->unsafe->copyMemory->position->position->else->end->for->i->return
RenderBuffer#putLong(long)::: render buffer put long:::unsafe->putLong->return
RenderBuffer#put(long[])::: render buffer put:::return->put
RenderBuffer#put(long[], int, int)::: render buffer put:::if->offsetInBytes->lengthInBytes->unsafe->copyMemory->position->position->else->end->for->i->return
RenderBuffer#putDouble(double)::: render buffer put double:::unsafe->putDouble->return
RenderingEngine#getInstance():::Returns an instance of RenderingEngine as determined by the installation environment and runtime flags:::if->return->gpa->new->GetPropertyAction->reClass->AccessController->doPrivileged->if->try->cls->Class->forName->cls->getConstructor->newInstance->catch->finally->if->marlinREClass->try->cls->Class->forName->cls->getConstructor->newInstance->catch->finally->if->throw->new->InternalError->new->GetPropertyAction->verbose->AccessController->doPrivileged->if->verbose->startsWith->println->new->GetPropertyAction->reTrace->AccessController->doPrivileged->if->new->Tracer->return
RenderingEngine#createStrokedShape(Shape, float, int, int, float, float[], float):::Create a widened path as specified by the parameters:::
RenderingEngine#strokeTo(Shape, AffineTransform, BasicStroke, boolean, boolean, boolean, PathConsumer2D):::Sends the geometry for a widened path as specified by the parameters to the specified consumer:::
RenderingEngine#getAATileGenerator(Shape, AffineTransform, Region, BasicStroke, boolean, boolean, int[]):::Construct an antialiased tile generator for the given shape with the given rendering attributes and store the bounds of the tile iteration in the bbox parameter:::
RenderingEngine#getAATileGenerator(double, double, double, double, double, double, double, double, Region, int[]):::Construct an antialiased tile generator for the given parallelogram store the bounds of the tile iteration in the bbox parameter:::
RenderingEngine#getMinimumAAPenSize():::Returns the minimum pen width that the antialiasing rasterizer can represent without dropouts occurring.:::
RenderingEngine#feedConsumer(PathIterator, PathConsumer2D):::Utility method to feed a PathConsumer2D object from a given PathIterator:::coords->new->floatArr->while->pi->isDone->switch->pi->currentSegment->consumer->moveTo->break->consumer->lineTo->break->consumer->quadTo->break->consumer->curveTo->break->consumer->closePath->break->pi->next
RenderingEngine.Tracer#createStrokedShape(Shape, float, int, int, float, float[], float)::: tracer create stroked shape:::src->getClass->getName->println->return->target->createStrokedShape
RenderingEngine.Tracer#strokeTo(Shape, AffineTransform, BasicStroke, boolean, boolean, boolean, PathConsumer2D)::: tracer stroke to:::src->getClass->getName->consumer->getClass->getName->println->target->strokeTo
RenderingEngine.Tracer#getMinimumAAPenSize()::: tracer get minimum pen size:::println->return->target->getMinimumAAPenSize
RenderingEngine.Tracer#getAATileGenerator(Shape, AffineTransform, Region, BasicStroke, boolean, boolean, int[])::: tracer get tile generator:::s->getClass->getName->println->return->target->getAATileGenerator
RenderingEngine.Tracer#getAATileGenerator(double, double, double, double, double, double, double, double, Region, int[])::: tracer get tile generator:::println->return->target->getAATileGenerator
RenderQueue#lock():::Locks the queue for read/write access.:::SunToolkit->awtLock
RenderQueue#tryLock():::Attempts to lock the queue:::return->SunToolkit->awtTryLock
RenderQueue#unlock():::Unlocks the queue.:::SunToolkit->awtUnlock
RenderQueue#addReference(Object):::Adds the given Object to the set of hard references, which will prevent that Object from being disposed until the queue has been flushed completely:::refSet->add
RenderQueue#getBuffer():::Returns the encapsulated RenderBuffer object.:::return
RenderQueue#ensureCapacity(int):::Ensures that there will be enough room on the underlying buffer for the following operation:::if->buf->remaining->flushNow
RenderQueue#ensureCapacityAndAlignment(int, int):::Convenience method that is equivalent to calling ensureCapacity() followed by ensureAlignment():::ensureCapacity->ensureAlignment
RenderQueue#ensureAlignment(int):::Inserts a 4-byte NOOP token when necessary to ensure that all 8-byte parameters for the following operation are added to the underlying buffer with an 8-byte memory alignment.:::first8ByteValuePosition->buf->position->if->buf->putInt
RenderQueue#flushNow():::Immediately processes each operation currently pending on the buffer:::
RenderQueue#flushAndInvokeNow(Runnable):::Immediately processes each operation currently pending on the buffer, and then invokes the provided task:::
RenderQueue#flushNow(int):::Updates the current position of the underlying buffer, and then flushes the queue immediately:::buf->position->flushNow
ShapeDrawPipe#draw(SunGraphics2D, Shape)::: shape draw pipe draw:::
ShapeDrawPipe#fill(SunGraphics2D, Shape)::: shape draw pipe fill:::
ShapeSpanIterator#initIDs()::: shape span iterator init ds:::
ShapeSpanIterator#appendPath(PathIterator)::: shape span iterator append path:::coords->new->floatArr->pi->getWindingRule->setRule->while->pi->isDone->pi->currentSegment->addSegment->pi->next->pathDone
ShapeSpanIterator#appendPoly(int[], int[], int, int, int)::: shape span iterator append poly:::
ShapeSpanIterator#setNormalize(boolean)::: shape span iterator set normalize:::
ShapeSpanIterator#setOutputAreaXYWH(int, int, int, int)::: shape span iterator set output area h:::Region->dimAdd->Region->dimAdd->setOutputAreaXYXY
ShapeSpanIterator#setOutputAreaXYXY(int, int, int, int)::: shape span iterator set output area y:::
ShapeSpanIterator#setOutputArea(Rectangle)::: shape span iterator set output area:::setOutputAreaXYWH
ShapeSpanIterator#setOutputArea(Region)::: shape span iterator set output area:::r->getLoX->r->getLoY->r->getHiX->r->getHiY->setOutputAreaXYXY
ShapeSpanIterator#setRule(int)::: shape span iterator set rule:::
ShapeSpanIterator#addSegment(int, float[])::: shape span iterator add segment:::
ShapeSpanIterator#getPathBox(int[])::: shape span iterator get path box:::
ShapeSpanIterator#intersectClipBox(int, int, int, int)::: shape span iterator intersect clip box:::
ShapeSpanIterator#nextSpan(int[])::: shape span iterator next span:::
ShapeSpanIterator#skipDownTo(int):::This method tells the iterator that it may skip all spans whose Y range is completely above the indicated Y coordinate.:::
ShapeSpanIterator#getNativeIterator():::This method returns a native pointer to a function block that can be used by a native method to perform the same iteration cycle that the above methods provide while avoiding upcalls to the Java object:::
ShapeSpanIterator#dispose()::: shape span iterator dispose:::
ShapeSpanIterator#moveTo(float, float)::: shape span iterator move to:::
ShapeSpanIterator#lineTo(float, float)::: shape span iterator line to:::
ShapeSpanIterator#quadTo(float, float, float, float)::: shape span iterator quad to:::
ShapeSpanIterator#curveTo(float, float, float, float, float, float)::: shape span iterator curve to:::
ShapeSpanIterator#closePath()::: shape span iterator close path:::
ShapeSpanIterator#pathDone()::: shape span iterator path done:::
ShapeSpanIterator#getNativeConsumer()::: shape span iterator get native consumer:::
SolidTextRenderer#drawGlyphList(SunGraphics2D, GlyphList)::: solid text renderer draw glyph list:::DrawGlyphList
SpanClipRenderer#initIDs(Class, Class)::: span clip renderer init ds:::
SpanClipRenderer#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: span clip renderer start sequence:::ri->getIterator->return->outpipe->startSequence->new->SCRcontext
SpanClipRenderer#needTile(Object, int, int, int, int)::: span clip renderer need tile:::context->return->outpipe->needTile
SpanClipRenderer#renderPathTile(Object, byte[], int, int, int, int, int, int, ShapeSpanIterator)::: span clip renderer render path tile:::renderPathTile
SpanClipRenderer#renderPathTile(Object, byte[], int, int, int, int, int, int)::: span clip renderer render path tile:::context->ri->createCopy->band->if->size->if->if->new->byteArr->fillTile->else->eraseTile->if->outpipe->renderPathTile
SpanClipRenderer#fillTile(RegionIterator, byte[], int, int, int[])::: span clip renderer fill tile:::
SpanClipRenderer#eraseTile(RegionIterator, byte[], int, int, int[])::: span clip renderer erase tile:::
SpanClipRenderer#skipTile(Object, int, int)::: span clip renderer skip tile:::context->outpipe->skipTile
SpanClipRenderer#endSequence(Object)::: span clip renderer end sequence:::context->outpipe->endSequence
SpanIterator#getPathBox(int[]):::This method returns the bounding box of the spans that the iterator will be returning:::
SpanIterator#intersectClipBox(int, int, int, int):::This method constrains the spans returned by nextSpan() to the rectangle whose bounds are given.:::
SpanIterator#nextSpan(int[]):::This method returns the next span in the shape being iterated:::
SpanIterator#skipDownTo(int):::This method tells the iterator that it may skip all spans whose Y range is completely above the indicated Y coordinate:::
SpanIterator#getNativeIterator():::This method returns a native pointer to a function block that can be used by a native method to perform the same iteration cycle that the above methods provide while avoiding upcalls to the Java object:::
SpanShapeRenderer.Composite#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: composite start sequence:::return->comppipe->startSequence
SpanShapeRenderer.Composite#renderBox(Object, int, int, int, int)::: composite render box:::comppipe->renderPathTile
SpanShapeRenderer.Composite#endSequence(Object)::: composite end sequence:::comppipe->endSequence
SpanShapeRenderer.Simple#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: simple start sequence:::return
SpanShapeRenderer.Simple#renderBox(Object, int, int, int, int)::: simple render box:::sg2d->sd->sg2d->getSurfaceData->FillRect
SpanShapeRenderer.Simple#endSequence(Object)::: simple end sequence:::
SpanShapeRenderer#draw(SunGraphics2D, Shape)::: span shape renderer draw:::if->sr->LoopPipe->getStrokeSpans->try->sg->getCompClip->renderSpans->catch->finally->sr->dispose->else->createStrokedShape->fill
SpanShapeRenderer#fill(SunGraphics2D, Shape)::: span shape renderer fill:::if->getType->renderRect->return->clipRegion->sg->getCompClip->sr->LoopPipe->getFillSSI->try->sr->setOutputArea->sr->s->getPathIterator->appendPath->renderSpans->catch->finally->sr->dispose
SpanShapeRenderer#startSequence(SunGraphics2D, Shape, Rectangle, int[])::: span shape renderer start sequence:::
SpanShapeRenderer#renderBox(Object, int, int, int, int)::: span shape renderer render box:::
SpanShapeRenderer#endSequence(Object)::: span shape renderer end sequence:::
SpanShapeRenderer#renderRect(SunGraphics2D, Rectangle2D)::: span shape renderer render rect:::corners->r->getX->r->getY->r->getWidth->r->getHeight->if->return->transform->if->t->if->t->abox->devR->new->Rectangle->clipRegion->sg->getCompClip->clipRegion->clipBoxToBounds->if->return->context->startSequence->if->clipRegion->isRectangular->renderBox->else->sr->clipRegion->getSpanIterator->while->sr->nextSpan->renderBox->endSequence
SpanShapeRenderer#renderSpans(SunGraphics2D, Region, Shape, ShapeSpanIterator)::: span shape renderer render spans:::context->abox->new->intArr->try->sr->getPathBox->devR->new->Rectangle->clipRegion->clipBoxToBounds->if->return->sr->intersectClipBox->startSequence->spanClipLoop->catch->finally->if->endSequence
SpanShapeRenderer#spanClipLoop(Object, SpanIterator, Region, int[])::: span shape renderer span clip loop:::if->r->isRectangular->r->filter->while->sr->nextSpan->x->y->renderBox
TextPipe#drawString(SunGraphics2D, String, double, double)::: text pipe draw string:::
TextPipe#drawGlyphVector(SunGraphics2D, GlyphVector, float, float)::: text pipe draw glyph vector:::
TextPipe#drawChars(SunGraphics2D, char[], int, int, int, int)::: text pipe draw chars:::
TextRenderer#drawGlyphList(SunGraphics2D, GlyphList)::: text renderer draw glyph list:::num->gl->getNumGlyphs->clipRegion->sg2d->getCompClip->cx1->clipRegion->getLoX->cy1->clipRegion->getLoY->cx2->clipRegion->getHiX->cy2->clipRegion->getHiY->ctx->try->bounds->gl->getBounds->r->new->Rectangle->s->sg2d->untransformShape->outpipe->startSequence->for->i->catch->finally->if->outpipe->endSequence
ValidatePipe#validate(SunGraphics2D)::: validate pipe validate:::sg->validatePipe->return
ValidatePipe#drawLine(SunGraphics2D, int, int, int, int)::: validate pipe draw line:::if->validate->drawLine
ValidatePipe#drawRect(SunGraphics2D, int, int, int, int)::: validate pipe draw rect:::if->validate->drawRect
ValidatePipe#fillRect(SunGraphics2D, int, int, int, int)::: validate pipe fill rect:::if->validate->fillRect
ValidatePipe#drawRoundRect(SunGraphics2D, int, int, int, int, int, int)::: validate pipe draw round rect:::if->validate->drawRoundRect
ValidatePipe#fillRoundRect(SunGraphics2D, int, int, int, int, int, int)::: validate pipe fill round rect:::if->validate->fillRoundRect
ValidatePipe#drawOval(SunGraphics2D, int, int, int, int)::: validate pipe draw oval:::if->validate->drawOval
ValidatePipe#fillOval(SunGraphics2D, int, int, int, int)::: validate pipe fill oval:::if->validate->fillOval
ValidatePipe#drawArc(SunGraphics2D, int, int, int, int, int, int)::: validate pipe draw arc:::if->validate->drawArc
ValidatePipe#fillArc(SunGraphics2D, int, int, int, int, int, int)::: validate pipe fill arc:::if->validate->fillArc
ValidatePipe#drawPolyline(SunGraphics2D, int[], int[], int)::: validate pipe draw polyline:::if->validate->drawPolyline
ValidatePipe#drawPolygon(SunGraphics2D, int[], int[], int)::: validate pipe draw polygon:::if->validate->drawPolygon
ValidatePipe#fillPolygon(SunGraphics2D, int[], int[], int)::: validate pipe fill polygon:::if->validate->fillPolygon
ValidatePipe#draw(SunGraphics2D, Shape)::: validate pipe draw:::if->validate->draw
ValidatePipe#fill(SunGraphics2D, Shape)::: validate pipe fill:::if->validate->fill
ValidatePipe#drawString(SunGraphics2D, String, double, double)::: validate pipe draw string:::if->validate->drawString
ValidatePipe#drawGlyphVector(SunGraphics2D, GlyphVector, float, float)::: validate pipe draw glyph vector:::if->validate->drawGlyphVector
ValidatePipe#drawChars(SunGraphics2D, char[], int, int, int, int)::: validate pipe draw chars:::if->validate->drawChars
ValidatePipe#copyImage(SunGraphics2D, Image, int, int, Color, ImageObserver)::: validate pipe copy image:::if->validate->return->copyImage->else->return
ValidatePipe#copyImage(SunGraphics2D, Image, int, int, int, int, int, int, Color, ImageObserver)::: validate pipe copy image:::if->validate->return->copyImage->else->return
ValidatePipe#scaleImage(SunGraphics2D, Image, int, int, int, int, Color, ImageObserver)::: validate pipe scale image:::if->validate->return->scaleImage->else->return
ValidatePipe#scaleImage(SunGraphics2D, Image, int, int, int, int, int, int, int, int, Color, ImageObserver)::: validate pipe scale image:::if->validate->return->scaleImage->else->return
ValidatePipe#transformImage(SunGraphics2D, Image, AffineTransform, ImageObserver)::: validate pipe transform image:::if->validate->return->transformImage->else->return
ValidatePipe#transformImage(SunGraphics2D, BufferedImage, BufferedImageOp, int, int)::: validate pipe transform image:::if->validate->transformImage
