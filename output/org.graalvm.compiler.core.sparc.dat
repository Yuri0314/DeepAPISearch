SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_signExtend#match(NodeMatchRules, Object...)::: match generator_sign extend match:::return->signExtend
SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_signExtend#getName()::: match generator_sign extend get name:::return
SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareLogicCas#match(NodeMatchRules, Object...)::: match generator_if compare logic cas match:::return->ifCompareLogicCas
SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_ifCompareLogicCas#getName()::: match generator_if compare logic cas get name:::return
SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_zeroExtend#match(NodeMatchRules, Object...)::: match generator_zero extend match:::return->zeroExtend
SPARCNodeMatchRules_MatchStatementSet.MatchGenerator_zeroExtend#getName()::: match generator_zero extend get name:::return
SPARCNodeMatchRules_MatchStatementSet#forClass()::: node match rules_ match statement set for class:::return
SPARCNodeMatchRules_MatchStatementSet#statements()::: node match rules_ match statement set statements:::ZeroExtendNode_positions->MatchRuleRegistry->new->StringArr->findPositions->FloatEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->PointerEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IfNode_positions->MatchRuleRegistry->new->StringArr->findPositions->ObjectEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->IntegerEqualsNode_positions->MatchRuleRegistry->new->StringArr->findPositions->SignExtendNode_positions->MatchRuleRegistry->new->StringArr->findPositions->statements->Collections->Arrays->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchPattern->new->MatchStatement->asList->unmodifiableList->return
SPARCAddressLowering#lower(ValueNode, ValueNode)::: address lowering lower:::immBase->asImmediate->if->SPARCAssembler->isSimm13->return->immBase->asLong->lower->immOffset->asImmediate->if->SPARCAssembler->isSimm13->return->immOffset->asLong->lower->return->base->graph->new->SPARCIndexedAddressNode->unique
SPARCAddressLowering#lower(ValueNode, long)::: address lowering lower:::if->add->immX->add->getX->asImmediate->if->SPARCAssembler->immX->asLong->isSimm13->return->add->getY->immX->asLong->lower->immY->add->getY->asImmediate->if->SPARCAssembler->immY->asLong->isSimm13->return->add->getX->immY->asLong->lower->if->return->add->getX->add->getY->lower->return->base->graph->new->SPARCImmediateAddressNode->unique
SPARCAddressLowering#asImmediate(ValueNode)::: address lowering as immediate:::c->value->asJavaConstant->if->c->getJavaKind->isNumericInteger->return->else->return
SPARCArithmeticLIRGenerator#getLIRGen()::: arithmetic generator get gen:::return->super->getLIRGen
SPARCArithmeticLIRGenerator#emitBitCount(Value)::: arithmetic generator emit bit count:::result->getLIRGen->LIRKind->combine->changeType->newVariable->usedOperand->emitZeroExtend->asAllocatable->getLIRGen->g0->asValue->new->SPARCOP3Op->append->return
SPARCArithmeticLIRGenerator#emitBitScanForward(Value)::: arithmetic generator emit bit scan forward:::result->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->asAllocatable->getLIRGen->new->SPARCBitManipulationOp->append->return
SPARCArithmeticLIRGenerator#emitBitScanReverse(Value)::: arithmetic generator emit bit scan reverse:::result->getLIRGen->LIRKind->combine->changeType->newVariable->if->operand->getPlatformKind->getLIRGen->asAllocatable->getLIRGen->new->SPARCBitManipulationOp->append->else->getLIRGen->asAllocatable->getLIRGen->new->SPARCBitManipulationOp->append->return
SPARCArithmeticLIRGenerator#emitMathAbs(Value)::: arithmetic generator emit math abs:::result->getLIRGen->LIRKind->combine->newVariable->kind->inputValue->getPlatformKind->opf->switch->break->break->throw->GraalError->shouldNotReachHere->getLIRGen->g0->asValue->asAllocatable->new->SPARCOPFOp->append->return
SPARCArithmeticLIRGenerator#emitMathSqrt(Value)::: arithmetic generator emit math sqrt:::result->getLIRGen->LIRKind->combine->newVariable->kind->inputValue->getPlatformKind->opf->switch->break->break->throw->GraalError->shouldNotReachHere->getLIRGen->g0->asValue->asAllocatable->new->SPARCOPFOp->append->return
SPARCArithmeticLIRGenerator#emitNegate(Value)::: arithmetic generator emit negate:::inputKind->input->getPlatformKind->if->isNumericInteger->return->emitUnary->else->return->inputKind->equals->emitUnary
SPARCArithmeticLIRGenerator#emitNot(Value)::: arithmetic generator emit not:::return->emitUnary
SPARCArithmeticLIRGenerator#emitUnary(Opfs, Value)::: arithmetic generator emit unary:::result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->g0->asValue->asAllocatable->new->SPARCOPFOp->append->return
SPARCArithmeticLIRGenerator#emitUnary(Op3s, Value)::: arithmetic generator emit unary:::result->getLIRGen->LIRKind->combine->newVariable->getLIRGen->SPARCOP3Op->getLIRGen->loadSimm13->newUnary->append->return
SPARCArithmeticLIRGenerator#emitBinary(ValueKind, Opfs, Value, Value)::: arithmetic generator emit binary:::return->emitBinary
SPARCArithmeticLIRGenerator#emitBinary(ValueKind, Opfs, Value, Value, LIRFrameState)::: arithmetic generator emit binary:::result->getLIRGen->newVariable->getLIRGen->asAllocatable->asAllocatable->new->SPARCOPFOp->append->return
SPARCArithmeticLIRGenerator#emitBinary(ValueKind, Op3s, Value, int)::: arithmetic generator emit binary:::return->LIRKind->value->JavaConstant->forInt->new->ConstantValue->emitBinary
SPARCArithmeticLIRGenerator#emitBinary(ValueKind, Op3s, Value, Value)::: arithmetic generator emit binary:::return->emitBinary
SPARCArithmeticLIRGenerator#emitBinary(ValueKind, Op3s, Value, Value, LIRFrameState)::: arithmetic generator emit binary:::result->getLIRGen->newVariable->if->op3->isCommutative->isJavaConstant->getLIRGen->getMoveFactory->asJavaConstant->canInlineConstant->getLIRGen->getLIRGen->load->getLIRGen->loadSimm13->new->SPARCOP3Op->append->else->getLIRGen->getLIRGen->load->getLIRGen->loadSimm13->new->SPARCOP3Op->append->return
SPARCArithmeticLIRGenerator#isNumericInteger(PlatformKind)::: arithmetic generator is numeric integer:::return->isInteger
SPARCArithmeticLIRGenerator#emitAdd(LIRKind, Value, Value, boolean)::: arithmetic generator emit add:::if->a->getPlatformKind->isNumericInteger->return->emitBinary->else->isDouble->a->getPlatformKind->equals->return->emitBinary
SPARCArithmeticLIRGenerator#emitSub(LIRKind, Value, Value, boolean)::: arithmetic generator emit sub:::if->a->getPlatformKind->isNumericInteger->return->emitBinary->else->isDouble->a->getPlatformKind->equals->return->emitBinary
SPARCArithmeticLIRGenerator#emitMul(Value, Value, boolean)::: arithmetic generator emit mul:::resultKind->LIRKind->combine->aKind->a->getPlatformKind->if->isNumericInteger->if->result->getLIRGen->LIRKind->combine->newVariable->if->getLIRGen->getLIRGen->load->getLIRGen->load->getLIRGen->new->SPARCLMulccOp->append->else->if->getLIRGen->getLIRGen->load->getLIRGen->load->new->SPARCIMulccOp->append->else->throw->GraalError->shouldNotReachHere->return->else->return->emitBinary->else->isDouble->a->getPlatformKind->equals->return->emitBinary
SPARCArithmeticLIRGenerator#emitMulHigh(Value, Value)::: arithmetic generator emit mul high:::opcode->switch->a->getPlatformKind->break->break->throw->GraalError->shouldNotReachHere->return->emitMulHigh
SPARCArithmeticLIRGenerator#emitUMulHigh(Value, Value)::: arithmetic generator emit mul high:::switch->a->getPlatformKind->result->LIRKind->combine->emitZeroExtend->emitZeroExtend->emitBinary->return->LIRKind->combine->WORD->getSizeInBits->emitBinary->return->LIRKind->combine->emitBinary->throw->GraalError->shouldNotReachHere
SPARCArithmeticLIRGenerator#emitMulHigh(MulHigh, Value, Value)::: arithmetic generator emit mul high:::result->getLIRGen->LIRKind->combine->newVariable->mulHigh->getLIRGen->load->getLIRGen->load->getLIRGen->LIRKind->combine->newVariable->new->MulHighOp->getLIRGen->append->return
SPARCArithmeticLIRGenerator#emitDiv(Value, Value, LIRFrameState)::: arithmetic generator emit div:::resultKind->LIRKind->combine->if->isJavaConstant->asJavaConstant->isDefaultForKind->zero->LIRKind->value->asValue->return->emitBinary->else->if->a->getPlatformKind->isNumericInteger->return->emitSignExtend->emitSignExtend->emitBinary->else->isDouble->a->getPlatformKind->return->emitBinary
SPARCArithmeticLIRGenerator#emitRem(Value, Value, LIRFrameState)::: arithmetic generator emit rem:::result->getLIRGen->LIRKind->combine->newVariable->q1->q2->switch->a->getPlatformKind->as->emitSignExtend->bs->emitSignExtend->as->getValueKind->emitBinary->as->getValueKind->emitBinary->emitSub->break->result->getValueKind->emitBinary->result->getValueKind->emitBinary->emitSub->break->fremCall->getLIRGen->getForeignCalls->lookupForeignCall->getLIRGen->emitForeignCall->break->dremCall->getLIRGen->getForeignCalls->lookupForeignCall->getLIRGen->emitForeignCall->break->throw->GraalError->a->getPlatformKind->shouldNotReachHere->return
SPARCArithmeticLIRGenerator#emitURem(Value, Value, LIRFrameState)::: arithmetic generator emit rem:::result->getLIRGen->LIRKind->combine->newVariable->scratch1->getLIRGen->LIRKind->combine->newVariable->scratch2->getLIRGen->LIRKind->combine->newVariable->opcode->switch->a->getPlatformKind->break->break->throw->GraalError->shouldNotReachHere->getLIRGen->asAllocatable->asAllocatable->new->RemOp->append->return
SPARCArithmeticLIRGenerator#emitUDiv(Value, Value, LIRFrameState)::: arithmetic generator emit div:::return->LIRKind->combine->emitZeroExtend->emitZeroExtend->emitBinary
SPARCArithmeticLIRGenerator#emitAnd(Value, Value)::: arithmetic generator emit and:::resultKind->LIRKind->combine->return->emitBinary
SPARCArithmeticLIRGenerator#emitOr(Value, Value)::: arithmetic generator emit or:::resultKind->LIRKind->combine->return->emitBinary
SPARCArithmeticLIRGenerator#emitXor(Value, Value)::: arithmetic generator emit xor:::resultKind->LIRKind->combine->return->emitBinary
SPARCArithmeticLIRGenerator#emitShl(Value, Value)::: arithmetic generator emit shl:::aKind->a->getPlatformKind->resultKind->LIRKind->combine->changeType->op->switch->break->break->throw->GraalError->String->format->shouldNotReachHere->return->emitBinary
SPARCArithmeticLIRGenerator#emitShr(Value, Value)::: arithmetic generator emit shr:::aKind->a->getPlatformKind->resultKind->LIRKind->combine->changeType->op->switch->break->break->throw->GraalError->shouldNotReachHere->return->emitBinary
SPARCArithmeticLIRGenerator#emitUShr(Value, Value)::: arithmetic generator emit shr:::aKind->a->getPlatformKind->resultKind->LIRKind->combine->changeType->op->switch->break->break->throw->GraalError->shouldNotReachHere->return->emitBinary
SPARCArithmeticLIRGenerator#emitConvertMove(LIRKind, AllocatableValue)::: arithmetic generator emit convert move:::result->getLIRGen->newVariable->getLIRGen->emitMove->return
SPARCArithmeticLIRGenerator#emitFloatConvert(FloatConvert, Value)::: arithmetic generator emit float convert:::inputAllocatable->asAllocatable->result->switch->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCOPFOp->append->break->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCOPFOp->append->break->intEncodedFloatReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->intEncodedFloatReg->getValueKind->newVariable->moveBetweenFpGp->getLIRGen->new->SPARCOPFOp->append->break->convertedFloatReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->getLIRGen->new->SPARCOPFOp->append->break->longEncodedDoubleReg->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->convertedDoubleReg->getLIRGen->longEncodedDoubleReg->getValueKind->newVariable->getLIRGen->new->SPARCOPFOp->append->break->convertedFloatReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCArithmetic.FloatConvertOp->append->convertedIntReg->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->break->convertedDoubleReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCArithmetic.FloatConvertOp->append->convertedLongReg->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->break->convertedFloatReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCArithmetic.FloatConvertOp->append->convertedIntReg->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->break->convertedDoubleReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->new->SPARCArithmetic.FloatConvertOp->append->convertedLongReg->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->break->convertedDoubleReg->getLIRGen->LIRKind->combine->changeType->newVariable->getLIRGen->LIRKind->combine->changeType->newVariable->moveBetweenFpGp->getLIRGen->new->SPARCOPFOp->append->break->throw->GraalError->shouldNotReachHere->return
SPARCArithmeticLIRGenerator#getTempSlot(LIRKind)::: arithmetic generator get temp slot:::return->getLIRGen->getResult->getFrameMapBuilder->allocateSpillSlot
SPARCArithmeticLIRGenerator#moveBetweenFpGp(AllocatableValue, AllocatableValue)::: arithmetic generator move between fp gp:::tempSlot->dstKind->dst->getPlatformKind->srcKind->src->getPlatformKind->if->getLIRGen->getArchitecture->getFeatures->contains->else->LIRKind->value->getTempSlot->getLIRGen->new->MoveFpGp->append
SPARCArithmeticLIRGenerator#emitNarrow(Value, int)::: arithmetic generator emit narrow:::if->inputVal->getPlatformKind->resultKind->LIRKind->combine->changeType->result->getLIRGen->newVariable->getLIRGen->emitMove->return->else->return
SPARCArithmeticLIRGenerator#emitSignExtend(Value)::: arithmetic generator emit sign extend:::inputBits->inputValue->getPlatformKind->getSizeInBytes->return->XWORD->getSizeInBits->emitSignExtend->emitNarrow
SPARCArithmeticLIRGenerator#emitSignExtend(Value, int, int)::: arithmetic generator emit sign extend:::shiftKind->LIRKind->value->resultKind->LIRKind->combine->changeType->shiftCount->XWORD->getSizeInBits->if->return->else->if->isJavaConstant->javaConstant->asJavaConstant->constant->if->javaConstant->isNull->else->javaConstant->asLong->return->JavaConstant->forLong->new->ConstantValue->else->inputAllocatable->asAllocatable->result->getLIRGen->newVariable->if->WORD->getSizeInBits->XWORD->getSizeInBits->getLIRGen->g0->LIRKind->value->asValue->new->SPARCOP3Op->append->else->tmp->getLIRGen->resultKind->changeType->newVariable->getLIRGen->JavaConstant->forInt->new->ConstantValue->new->SPARCOP3Op->append->getLIRGen->JavaConstant->forInt->new->ConstantValue->new->SPARCOP3Op->append->return
SPARCArithmeticLIRGenerator#emitZeroExtend(Value)::: arithmetic generator emit zero extend:::inputBits->inputValue->getPlatformKind->getSizeInBytes->return->XWORD->getSizeInBits->emitZeroExtend->emitNarrow
SPARCArithmeticLIRGenerator#emitZeroExtend(Value, int, int)::: arithmetic generator emit zero extend:::if->return->result->getLIRGen->LIRKind->combine->WORD->getSizeInBits->changeType->newVariable->inputAllocatable->asAllocatable->if->getLIRGen->g0->asValue->new->SPARCOP3Op->append->else->mask->getLIRGen->LIRKind->value->mask->forLong->emitConstant->getLIRGen->new->SPARCOP3Op->append->return
SPARCArithmeticLIRGenerator#emitReinterpret(LIRKind, Value)::: arithmetic generator emit reinterpret:::fromKind->inputVal->getPlatformKind->toKind->to->getPlatformKind->input->asAllocatable->result->getLIRGen->newVariable->if->fromKind->isFloat->toKind->isFloat->moveBetweenFpGp->return->else->return->emitConvertMove
SPARCArithmeticLIRGenerator#emitLoad(LIRKind, Value, LIRFrameState)::: arithmetic generator emit load:::loadAddress->getLIRGen->asAddressValue->result->getLIRGen->getLIRGen->toRegisterKind->newVariable->getLIRGen->kind->getPlatformKind->new->LoadOp->append->return
SPARCArithmeticLIRGenerator#emitStore(ValueKind, Value, Value, LIRFrameState)::: arithmetic generator emit store:::storeAddress->getLIRGen->asAddressValue->if->isJavaConstant->c->asJavaConstant->if->c->isDefaultForKind->getLIRGen->kind->getPlatformKind->new->StoreConstantOp->append->return->input->getLIRGen->load->getLIRGen->kind->getPlatformKind->new->StoreOp->append
SPARCImmediateAddressNode#generate(NodeLIRBuilderTool)::: immediate address node generate:::tool->gen->getLIRGeneratorTool->baseValue->tool->gen->operand->asAllocatable->kind->tool->stamp->getLIRKind->baseReference->LIRKind->derivedBaseFromValue->if->kind->makeDerivedReference->gen->new->SPARCImmediateAddressValue->setResult
SPARCImmediateAddressNode#getBase()::: immediate address node get base:::return
SPARCImmediateAddressNode#getMaxConstantDisplacement()::: immediate address node get max constant displacement:::return
SPARCImmediateAddressNode#getIndex()::: immediate address node get index:::return
SPARCIndexedAddressNode#generate(NodeLIRBuilderTool)::: indexed address node generate:::tool->gen->getLIRGeneratorTool->baseValue->tool->gen->operand->asAllocatable->indexValue->tool->gen->operand->asAllocatable->baseReference->LIRKind->derivedBaseFromValue->indexReference->LIRKind->derivedBaseFromValue->kind->LIRKind->tool->stamp->getLIRKind->combineDerived->gen->new->SPARCIndexedAddressValue->setResult
SPARCIndexedAddressNode#getBase()::: indexed address node get base:::return
SPARCIndexedAddressNode#setBase(ValueNode)::: indexed address node set base:::updateUsages
SPARCIndexedAddressNode#getIndex()::: indexed address node get index:::return
SPARCIndexedAddressNode#setIndex(ValueNode)::: indexed address node set index:::updateUsages
SPARCIndexedAddressNode#getMaxConstantDisplacement()::: indexed address node get max constant displacement:::return
SPARCIntegerCompareCanonicalizationPhase#run(StructuredGraph)::: integer compare canonicalization phase run:::foreach->graph->getNodes->if->enode->enode->getX->min32->enode->getY->min32
SPARCIntegerCompareCanonicalizationPhase#min32(CompareNode, ValueNode)::: integer compare canonicalization phase min32:::s->v->stamp->if->bits->getBits->if->if->else->replacement->if->newConst->if->JavaConstant->v->asJavaConstant->asInt->forInt->else->if->JavaConstant->v->asJavaConstant->asLong->forLong->else->throw->GraalError->shouldNotReachHere->mask->CodeUtil->mask->v->graph->IntegerStamp->newConst->asLong->newConst->asLong->stampForMask->new->ConstantNode->addOrUnique->else->v->graph->new->SignExtendNode->addOrUnique->v->replaceAtUsages
SPARCLIRGenerator.ConstantTableBaseProvider#getConstantTableBase()::: constant table base provider get constant table base:::return
SPARCLIRGenerator#zapValueForKind(PlatformKind)::: generator zap value for kind:::dead->switch->return->JavaConstant->forByte->return->JavaConstant->forShort->return->JavaConstant->forInt->return->JavaConstant->forLong->return->JavaConstant->Float->intBitsToFloat->forFloat->return->JavaConstant->Double->longBitsToDouble->forDouble->throw->kind->toString->new->IllegalArgumentException
SPARCLIRGenerator#toRegisterKind(K):::The SPARC backend only uses WORD and DWORD values in registers because except to the ld/st instructions no instruction deals either with 32 or 64 bits:::switch->kind->getPlatformKind->return->kind->changeType->return
SPARCLIRGenerator#asAddressValue(Value)::: generator as address value:::if->return->else->kind->address->getValueKind->if->displacement->asLong->if->SPARCAssembler->isSimm13->return->asValue->new->SPARCImmediateAddressValue->return->asAllocatable->new->SPARCImmediateAddressValue
SPARCLIRGenerator#emitAddress(AllocatableValue)::: generator emit address:::result->LIRKind->target->getWordKind->value->newVariable->new->StackLoadAddressOp->append->return
SPARCLIRGenerator#emitReturn(JavaKind, Value)::: generator emit return:::operand->if->input->getValueKind->resultOperandFor->emitMove->new->ReturnOp->append
SPARCLIRGenerator#emitJump(LabelRef)::: generator emit jump:::new->SPARCJumpOp->append
SPARCLIRGenerator#emitCompareBranch(PlatformKind, Value, Value, Condition, boolean, LabelRef, LabelRef, double)::: generator emit compare branch:::left->right->actualCondition->if->isJavaConstant->load->loadSimm13->cond->mirror->else->load->loadSimm13->actualCmpKind->if->actualCmpKind->isInteger->new->SPARCControlFlow.CompareBranchOp->append->else->if->actualCmpKind->isFloat->emitFloatCompare->cf->SPARCControlFlow->fromCondition->new->SPARCControlFlow.BranchOp->append->else->throw->GraalError->shouldNotReachHere
SPARCLIRGenerator#emitOverflowCheckBranch(LabelRef, LabelRef, LIRKind, double)::: generator emit overflow check branch:::cmpKind->cmpLIRKind->getPlatformKind->new->BranchOp->append
SPARCLIRGenerator#emitIntegerTestBranch(Value, Value, LabelRef, LabelRef, double)::: generator emit integer test branch:::emitIntegerTest->left->getPlatformKind->new->BranchOp->append
SPARCLIRGenerator#emitIntegerTest(Value, Value)::: generator emit integer test:::if->LIRValueUtil->isVariable->SPARCOP3Op->load->loadSimm13->newBinaryVoid->append->else->SPARCOP3Op->load->loadSimm13->newBinaryVoid->append
SPARCLIRGenerator#loadSimm11(Value)::: generator load simm11:::if->isJavaConstant->c->asJavaConstant->if->c->isNull->SPARCAssembler->isSimm11->return->return->load
SPARCLIRGenerator#loadSimm13(Value)::: generator load simm13:::if->isJavaConstant->c->asJavaConstant->if->c->isNull->SPARCAssembler->isSimm13->return->return->load
SPARCLIRGenerator#loadNonConst(Value)::: generator load non const:::throw->GraalError->shouldNotReachHere
SPARCLIRGenerator#emitConditionalMove(PlatformKind, Value, Value, Condition, boolean, Value, Value)::: generator emit conditional move:::cmpSPARCKind->mirrored->emitCompare->actualTrueValue->actualFalseValue->valueKind->trueValue->getPlatformKind->cmove->if->valueKind->isFloat->load->load->valueKind->equals->else->if->valueKind->isInteger->loadSimm11->loadSimm11->else->throw->GraalError->shouldNotReachHere->result->trueValue->getValueKind->newVariable->finalCondition->SPARCControlFlow->cmpSPARCKind->isInteger->cond->mirror->fromCondition->cc->CC->forKind->new->CondMoveOp->append->return
SPARCLIRGenerator#emitCompare(SPARCKind, Value, Value):::This method emits the compare instruction, and may reorder the operands:::mirrored->if->cmpKind->isInteger->emitIntegerCompare->else->if->cmpKind->isFloat->emitFloatCompare->else->throw->GraalError->shouldNotReachHere->return
SPARCLIRGenerator#emitIntegerCompare(SPARCKind, Value, Value)::: generator emit integer compare:::mirrored->left->right->if->LIRValueUtil->isVariable->load->loadSimm13->else->load->loadSimm13->compareBytes->cmpKind->getSizeInBytes->if->left->getPlatformKind->getSizeInBytes->arithmeticLIRGen->cmpKind->getSizeInBits->XWORD->getSizeInBits->emitSignExtend->asAllocatable->if->right->getPlatformKind->getSizeInBytes->arithmeticLIRGen->cmpKind->getSizeInBits->XWORD->getSizeInBits->emitSignExtend->SPARCOP3Op->newBinaryVoid->append->return
SPARCLIRGenerator#emitFloatCompare(SPARCKind, Value, Value, CC)::: generator emit float compare:::floatCompareOpcode->switch->break->break->throw->GraalError->shouldNotReachHere->load->load->new->SPARCFloatCompareOp->append
SPARCLIRGenerator#emitIntegerTestMove(Value, Value, Value, Value)::: generator emit integer test move:::emitIntegerTest->result->trueValue->getValueKind->newVariable->flag->SPARCControlFlow->fromCondition->cc->CC->left->getPlatformKind->forKind->loadSimm11->loadSimm11->new->CondMoveOp->append->return
SPARCLIRGenerator#emitForeignCallOp(ForeignCallLinkage, Value, Value[], Value[], LIRFrameState)::: generator emit foreign call op:::maxOffset->linkage->getMaxCallTargetOffset->if->SPARCAssembler->isWordDisp30->new->SPARCCall.DirectNearForeignCallOp->append->else->new->SPARCCall.DirectFarForeignCallOp->append
SPARCLIRGenerator#emitStrategySwitch(SwitchStrategy, Variable, LabelRef[], LabelRef)::: generator emit strategy switch:::scratchValue->key->getValueKind->newVariable->base->foreach->strategy->getKeyConstants->if->getMoveFactory->canInlineConstant->constantTableBaseProvider->getConstantTableBase->break->createStrategySwitchOp->append
SPARCLIRGenerator#createStrategySwitchOp(AllocatableValue, SwitchStrategy, LabelRef[], LabelRef, Variable, Variable)::: generator create strategy switch op:::return->new->StrategySwitchOp
SPARCLIRGenerator#emitTableSwitch(int, LabelRef, LabelRef[], Value)::: generator emit table switch:::tmp->key->getValueKind->newVariable->emitMove->LIRKind->target->getWordKind->value->newVariable->new->TableSwitchOp->append
SPARCLIRGenerator#getArchitecture()::: generator get architecture:::return->target
SPARCLIRGenerator#emitByteSwap(Value)::: generator emit byte swap:::result->LIRKind->combine->newVariable->asAllocatable->new->SPARCByteSwapOp->append->return
SPARCLIRGenerator#emitArrayEquals(JavaKind, Value, Value, Value, int, boolean)::: generator emit array equals:::result->LIRKind->value->newVariable->load->load->asAllocatable->new->SPARCArrayEqualsOp->append->return
SPARCLIRGenerator#emitMembar(int)::: generator emit membar:::necessaryBarriers->target->requiredBarriers->if->target->new->MembarOp->append
SPARCLIRGenerator#emitDeoptimize(Value, Value, LIRFrameState)::: generator emit deoptimize:::new->ReturnOp->append
SPARCLIRGenerator#emitSignExtendLoad(LIRKind, LIRKind, Value, LIRFrameState)::: generator emit sign extend load:::loadAddress->asAddressValue->result->newVariable->kind->getPlatformKind->new->LoadOp->append->return
SPARCLIRGenerator#emitZeroExtendLoad(LIRKind, LIRKind, Value, LIRFrameState)::: generator emit zero extend load:::loadAddress->asAddressValue->result->newVariable->kind->getPlatformKind->new->LoadOp->append->return
SPARCLIRGenerator#emitNullCheck(Value, LIRFrameState)::: generator emit null check:::kind->address->getPlatformKind->asAddressValue->new->NullCheckOp->append
SPARCLIRGenerator#emitLoadConstantTableBase()::: generator emit load constant table base:::LIRKind->value->newVariable->nextPosition->getResult->getLIR->getCurrentBlock->getLIRforBlock->size->placeHolder->getCurrentBlock->new->NoOp->append->new->SPARCLoadConstantTableBaseOp
SPARCLIRGenerator#beforeRegisterAllocation()::: generator before register allocation:::lir->getResult->getLIR->loadConstantTableBaseOp->setAlive
SPARCLIRGenerator#emitPause()::: generator emit pause:::new->SPARCPauseOp->append
SPARCLIRGenerator#emitSpeculationFence()::: generator emit speculation fence:::throw->GraalError->unimplemented
SPARCLIRKindTool#getIntegerKind(int)::: kind tool get integer kind:::if->return->LIRKind->value->else->if->return->LIRKind->value->else->if->return->LIRKind->value->else->return->LIRKind->value
SPARCLIRKindTool#getFloatingKind(int)::: kind tool get floating kind:::switch->return->LIRKind->value->return->LIRKind->value->throw->GraalError->shouldNotReachHere
SPARCLIRKindTool#getObjectKind()::: kind tool get object kind:::return->LIRKind->reference
SPARCLIRKindTool#getWordKind()::: kind tool get word kind:::return->LIRKind->value
SPARCLIRKindTool#getNarrowOopKind()::: kind tool get narrow oop kind:::return->LIRKind->compressedReference
SPARCLIRKindTool#getNarrowPointerKind()::: kind tool get narrow pointer kind:::return->LIRKind->value
SparcLoweringProviderMixin#smallestCompareWidth()::: sparc lowering provider mixin smallest compare width:::return
SparcLoweringProviderMixin#supportBulkZeroing()::: sparc lowering provider mixin support bulk zeroing:::return
SPARCMoveFactory#createMove(AllocatableValue, Value)::: move factory create move:::srcIsSlot->isStackSlotValue->dstIsSlot->isStackSlotValue->if->isConstantValue->return->asConstant->createLoad->else->if->return->new->LoadAddressOp->else->if->throw->GraalError->src->getClass->dst->getClass->shouldNotReachHere->else->return->new->Move
SPARCMoveFactory#createStackMove(AllocatableValue, AllocatableValue)::: move factory create stack move:::return->new->SPARCMove.Move
SPARCMoveFactory#createLoad(AllocatableValue, Constant)::: move factory create load:::if->javaConstant->if->canInlineConstant->return->new->SPARCMove.LoadInlineConstant->else->return->constantTableBaseProvider->getConstantTableBase->new->SPARCMove.LoadConstantFromTable->else->if->return->new->SPARCMove.LoadDataAddressOp->else->throw->GraalError->src->getClass->toString->shouldNotReachHere
SPARCMoveFactory#createStackLoad(AllocatableValue, Constant)::: move factory create stack load:::if->throw->GraalError->shouldNotReachHere->return->createLoad
SPARCMoveFactory#canInlineConstant(Constant)::: move factory can inline constant:::if->c->switch->c->getJavaKind->return->SPARCAssembler->c->asInt->isSimm13->return->SPARCAssembler->c->asLong->isSimm13->return->c->isNull->return->return
SPARCMoveFactory#allowConstantToStackMove(Constant)::: move factory allow constant to stack move:::return
SPARCNodeLIRBuilder#peephole(ValueNode)::: node builder peephole:::return
SPARCNodeLIRBuilder#newJumpOp(LabelRef)::: node builder new jump op:::return->new->SPARCJumpOp
SPARCNodeLIRBuilder#getLIRGeneratorTool()::: node builder get generator tool:::return->super->getLIRGeneratorTool
SPARCNodeLIRBuilder#emitPrologue(StructuredGraph)::: node builder emit prologue:::getLIRGeneratorTool->emitLoadConstantTableBase->super->emitPrologue
SPARCNodeMatchRules#getState(Access)::: node match rules get state:::if->return->state->return
SPARCNodeMatchRules#getLirKind(LIRLowerableAccess)::: node match rules get lir kind:::return->gen->access->getAccessStamp->getLIRKind
SPARCNodeMatchRules#emitSignExtendMemory(Access, int, int)::: node match rules emit sign extend memory:::toKind->fromKind->if->return->switch->break->break->break->throw->GraalError->unimplemented->localFromKind->localToKind->return->return->getLIRGeneratorTool->LIRKind->value->LIRKind->value->access->getAddress->operand->getState->emitSignExtendLoad
SPARCNodeMatchRules#emitZeroExtendMemory(Access, int, int)::: node match rules emit zero extend memory:::toKind->fromKind->if->return->switch->break->break->break->throw->GraalError->unimplemented->localFromKind->localToKind->return->return->getLIRGeneratorTool->LIRKind->value->LIRKind->value->access->getAddress->operand->getState->emitZeroExtendLoad
SPARCNodeMatchRules#signExtend(SignExtendNode, Access)::: node match rules sign extend:::return->root->getInputBits->root->getResultBits->emitSignExtendMemory
SPARCNodeMatchRules#zeroExtend(ZeroExtendNode, Access)::: node match rules zero extend:::return->root->getInputBits->root->getResultBits->emitZeroExtendMemory
SPARCNodeMatchRules#ifCompareLogicCas(IfNode, CompareNode, ValueNode, LogicCompareAndSwapNode)::: node match rules if compare logic cas:::constant->value->asJavaConstant->if->cas->hasExactlyOneUsage->constantValue->constant->asLong->successIsTrue->if->else->if->else->return->return->kind->getLirKind->trueLabel->root->trueSuccessor->getLIRBlock->falseLabel->root->falseSuccessor->getLIRBlock->trueLabelProbability->root->root->trueSuccessor->probability->expectedValue->cas->getExpectedValue->operand->newValue->cas->getNewValue->operand->address->cas->getAddress->operand->condition->result->getLIRGeneratorTool->emitValueCompareAndSwap->getLIRGeneratorTool->kind->getPlatformKind->emitCompareBranch->return->return
SPARCNodeMatchRules#getLIRGeneratorTool()::: node match rules get generator tool:::return->super->getLIRGeneratorTool
SPARCNodeMatchRules#getArithmeticLIRGenerator()::: node match rules get arithmetic generator:::return->getLIRGeneratorTool->getArithmetic
SPARCSuitesCreator#createSuites(OptionValues)::: suites creator create suites:::s->super->createSuites->l->s->getLowTier->findPhase->while->PhaseSuite->findNextPhase->l->previous->l->new->SPARCIntegerCompareCanonicalizationPhase->add->return
