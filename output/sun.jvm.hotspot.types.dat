AddressField#getValue(Address):::This accessor requires that the field be nonstatic, or a WrongTypeException will be thrown.:::
AddressField#getValue():::This accessor requires that the field be static, or a WrongTypeException will be thrown.:::
CIntegerField#isUnsigned()::: integer field is unsigned:::
CIntegerField#getValue(Address):::The field must be nonstatic and of integer type, or a       WrongTypeException will be thrown.:::
CIntegerField#getValue():::The field must be static and of integer type, or a       WrongTypeException will be thrown.:::
CIntegerType#isUnsigned():::Is this integer type unsigned?:::
CIntegerType#maxValue():::What is the maximum value of this type? Note that this will not       work properly for unsigned long longs.:::
CIntegerType#minValue():::What is the minimum value of this type? Note that this will not       work properly for unsigned long longs.:::
Field#getName():::Get the name of this field:::
Field#getType():::Get the type of this field:::
Field#getSize():::Get the size, in bytes, of this field:::
Field#isStatic():::Is this a static field?:::
Field#getOffset():::The offset of this field, in bytes, in its containing data       structure, if nonstatic:::
Field#getStaticFieldAddress():::The address of this field, if it is a static field:::
Field#getJBoolean(Address):::<P> These accessors require that the field be nonstatic;       otherwise, a WrongTypeException will be thrown:::
Field#getJByte(Address)::: field get byte:::
Field#getJChar(Address)::: field get char:::
Field#getJShort(Address)::: field get short:::
Field#getJInt(Address)::: field get int:::
Field#getJLong(Address)::: field get long:::
Field#getJFloat(Address)::: field get float:::
Field#getJDouble(Address)::: field get double:::
Field#getCInteger(Address, CIntegerType)::: field get integer:::
Field#getAddress(Address)::: field get address:::
Field#getOopHandle(Address)::: field get oop handle:::
Field#getNarrowOopHandle(Address)::: field get narrow oop handle:::
Field#getJBoolean():::<P> These accessors require that the field be static; otherwise,       a WrongTypeException will be thrown:::
Field#getJByte()::: field get byte:::
Field#getJChar()::: field get char:::
Field#getJFloat()::: field get float:::
Field#getJDouble()::: field get double:::
Field#getJInt()::: field get int:::
Field#getJLong()::: field get long:::
Field#getJShort()::: field get short:::
Field#getCInteger(CIntegerType)::: field get integer:::
Field#getAddress()::: field get address:::
Field#getOopHandle()::: field get oop handle:::
Field#getNarrowOopHandle()::: field get narrow oop handle:::
JBooleanField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java boolean, or a WrongTypeException will be thrown.:::
JBooleanField#getValue():::The field must be static and the type of the field must be a       Java boolean, or a WrongTypeException will be thrown.:::
JByteField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java byte, or a WrongTypeException will be thrown.:::
JByteField#getValue():::The field must be static and the type of the field must be a       Java byte, or a WrongTypeException will be thrown.:::
JCharField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java char, or a WrongTypeException will be thrown.:::
JCharField#getValue():::The field must be static and the type of the field must be a       Java char, or a WrongTypeException will be thrown.:::
JDoubleField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java double, or a WrongTypeException will be thrown.:::
JDoubleField#getValue():::The field must be static and the type of the field must be a       Java double, or a WrongTypeException will be thrown.:::
JFloatField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java float, or a WrongTypeException will be thrown.:::
JFloatField#getValue():::The field must be static and the type of the field must be a       Java float, or a WrongTypeException will be thrown.:::
JIntField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java int, or a WrongTypeException will be thrown.:::
JIntField#getValue():::The field must be static and the type of the field must be a       Java int, or a WrongTypeException will be thrown.:::
JLongField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java long, or a WrongTypeException will be thrown.:::
JLongField#getValue():::The field must be static and the type of the field must be a       Java long, or a WrongTypeException will be thrown.:::
JShortField#getValue(Address):::The field must be nonstatic and the type of the field must be a       Java short, or a WrongTypeException will be thrown.:::
JShortField#getValue():::The field must be static and the type of the field must be a       Java short, or a WrongTypeException will be thrown.:::
NarrowOopField#getValue(Address):::The field must be nonstatic and the type of the field must be an       oop type, or a WrongTypeException will be thrown.:::
NarrowOopField#getValue():::The field must be static and the type of the field must be an       oop type, or a WrongTypeException will be thrown.:::
OopField#getValue(Address):::The field must be nonstatic and the type of the field must be an       oop type, or a WrongTypeException will be thrown.:::
OopField#getValue():::The field must be static and the type of the field must be an       oop type, or a WrongTypeException will be thrown.:::
PointerType#getTargetType():::Returns the target type of this PointerType.:::
Type#getName()::: type get name:::
Type#getSuperclass()::: type get superclass:::
Type#getSize():::The size in bytes, at the machine level, of this type:::
Type#isCIntegerType():::Indicates whether this type is a C integer type -- regardless of       size or signedness.:::
Type#isCStringType():::Indicates whether this type is const char*.:::
Type#isJavaPrimitiveType():::Indicates whether this type is one of the Java primitive types.:::
Type#isOopType():::Indicates whether this type is an oop type in the VM.:::
Type#isPointerType():::Indicates whether this type is a pointer type.:::
Type#getField(String, boolean, boolean):::This is permissive and returns the CField regardless of its type       as long as it is present:::
Type#getField(String, boolean):::This is permissive and returns the CField regardless of its type       as long as it is present -- it is equivalent to       getField(fieldName, searchSuperclassFields, true):::
Type#getField(String):::This is permissive and returns the CField regardless of its type       as long as it is present:::
Type#getField(String, Type, boolean):::If there is a mismatch between the declared type and the type       which would otherwise be returned from this routine, it throws a       WrongTypeException:::
Type#getField(String, Type):::If there is a mismatch between the declared type and the type       which would otherwise be returned from this routine, it throws a       WrongTypeException:::
Type#getFields():::Iterate over all of the fields in this type but <B>not</B> in       any of its superclasses:::
Type#getJBooleanField(String):::<P> These accessors are designed to allow strong type checking       of certain well-known types of fields, specifically Java       primitive and oop types:::
Type#getJByteField(String)::: type get byte field:::
Type#getJCharField(String)::: type get char field:::
Type#getJDoubleField(String)::: type get double field:::
Type#getJFloatField(String)::: type get float field:::
Type#getJIntField(String)::: type get int field:::
Type#getJLongField(String)::: type get long field:::
Type#getJShortField(String)::: type get short field:::
Type#getCIntegerField(String)::: type get integer field:::
Type#getOopField(String)::: type get oop field:::
Type#getNarrowOopField(String)::: type get narrow oop field:::
Type#getAddressField(String)::: type get address field:::
TypeDataBase#lookupType(String):::Equivalent to lookupType(cTypeName, true):::
TypeDataBase#lookupType(String, boolean):::For simplicity of the initial implementation, this is not       guaranteed to work for primitive types:::
TypeDataBase#lookupIntConstant(String):::Equivalent to lookupIntConstant(constantName, true):::
TypeDataBase#lookupIntConstant(String, boolean)::: type data base lookup int constant:::
TypeDataBase#lookupLongConstant(String):::Equivalent to lookupLongConstant(constantName, true):::
TypeDataBase#lookupLongConstant(String, boolean)::: type data base lookup long constant:::
TypeDataBase#getJBooleanType():::Accessors for types representing the Java primitive types; used       for both proper type checking and for walking down Java arrays.:::
TypeDataBase#getJByteType()::: type data base get byte type:::
TypeDataBase#getJCharType()::: type data base get char type:::
TypeDataBase#getJDoubleType()::: type data base get double type:::
TypeDataBase#getJFloatType()::: type data base get float type:::
TypeDataBase#getJIntType()::: type data base get int type:::
TypeDataBase#getJLongType()::: type data base get long type:::
TypeDataBase#getJShortType()::: type data base get short type:::
TypeDataBase#getAddressSize():::Returns the size of a C address in bytes:::
TypeDataBase#getOopSize():::Returns the size of an oop in bytes:::
TypeDataBase#addressTypeIsEqualToType(Address, Type):::<P> This is an experimental interface emulating C++'s run-time       type information (RTTI) mechanism: determines whether the given       address is a pointer to the start of a C++ object of precisely       the given type -- it does not search superclasses of the type:::
TypeDataBase#guessTypeForAddress(Address):::Helper routine for guessing the most derived type of a       polymorphic C++ object:::
TypeDataBase#findDynamicTypeForAddress(Address, Type):::Helper routine for guessing the most derived type of a       polymorphic C++ object:::
TypeDataBase#getTypes():::Returns an Iterator over the Types in the database.:::
TypeDataBase#getIntConstants():::Returns an Iterator over the String names of the integer       constants in the database.:::
TypeDataBase#getLongConstants():::Returns an Iterator over the String names of the long constants       in the database.:::
