sun.jvm.hotspot.types.AddressField#getValue(Address)->Address:::This accessor requires that the field be nonstatic, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.AddressField#getValue()->Address:::This accessor requires that the field be static, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.CIntegerField#isUnsigned()->boolean::: integer field is unsigned
sun.jvm.hotspot.types.CIntegerField#getValue(Address)->long:::The field must be nonstatic and of integer type, or a       WrongTypeException will be thrown.
sun.jvm.hotspot.types.CIntegerField#getValue()->long:::The field must be static and of integer type, or a       WrongTypeException will be thrown.
sun.jvm.hotspot.types.CIntegerType#isUnsigned()->boolean:::Is this integer type unsigned?
sun.jvm.hotspot.types.CIntegerType#maxValue()->long:::What is the maximum value of this type? Note that this will not       work properly for unsigned long longs.
sun.jvm.hotspot.types.CIntegerType#minValue()->long:::What is the minimum value of this type? Note that this will not       work properly for unsigned long longs.
sun.jvm.hotspot.types.Field#getName()->String:::Get the name of this field
sun.jvm.hotspot.types.Field#getType()->Type:::Get the type of this field
sun.jvm.hotspot.types.Field#getSize()->long:::Get the size, in bytes, of this field
sun.jvm.hotspot.types.Field#isStatic()->boolean:::Is this a static field?
sun.jvm.hotspot.types.Field#getOffset()->long:::The offset of this field, in bytes, in its containing data       structure, if nonstatic
sun.jvm.hotspot.types.Field#getStaticFieldAddress()->Address:::The address of this field, if it is a static field
sun.jvm.hotspot.types.Field#getJBoolean(Address)->boolean:::<P> These accessors require that the field be nonstatic;       otherwise, a WrongTypeException will be thrown
sun.jvm.hotspot.types.Field#getJByte(Address)->byte::: field get byte
sun.jvm.hotspot.types.Field#getJChar(Address)->char::: field get char
sun.jvm.hotspot.types.Field#getJShort(Address)->short::: field get short
sun.jvm.hotspot.types.Field#getJInt(Address)->int::: field get int
sun.jvm.hotspot.types.Field#getJLong(Address)->long::: field get long
sun.jvm.hotspot.types.Field#getJFloat(Address)->float::: field get float
sun.jvm.hotspot.types.Field#getJDouble(Address)->double::: field get double
sun.jvm.hotspot.types.Field#getCInteger(Address, CIntegerType)->long::: field get integer
sun.jvm.hotspot.types.Field#getAddress(Address)->Address::: field get address
sun.jvm.hotspot.types.Field#getOopHandle(Address)->OopHandle::: field get oop handle
sun.jvm.hotspot.types.Field#getNarrowOopHandle(Address)->OopHandle::: field get narrow oop handle
sun.jvm.hotspot.types.Field#getJBoolean()->boolean:::<P> These accessors require that the field be static; otherwise,       a WrongTypeException will be thrown
sun.jvm.hotspot.types.Field#getJByte()->byte::: field get byte
sun.jvm.hotspot.types.Field#getJChar()->char::: field get char
sun.jvm.hotspot.types.Field#getJFloat()->float::: field get float
sun.jvm.hotspot.types.Field#getJDouble()->double::: field get double
sun.jvm.hotspot.types.Field#getJInt()->int::: field get int
sun.jvm.hotspot.types.Field#getJLong()->long::: field get long
sun.jvm.hotspot.types.Field#getJShort()->short::: field get short
sun.jvm.hotspot.types.Field#getCInteger(CIntegerType)->long::: field get integer
sun.jvm.hotspot.types.Field#getAddress()->Address::: field get address
sun.jvm.hotspot.types.Field#getOopHandle()->OopHandle::: field get oop handle
sun.jvm.hotspot.types.Field#getNarrowOopHandle()->OopHandle::: field get narrow oop handle
sun.jvm.hotspot.types.JBooleanField#getValue(Address)->boolean:::The field must be nonstatic and the type of the field must be a       Java boolean, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JBooleanField#getValue()->boolean:::The field must be static and the type of the field must be a       Java boolean, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JByteField#getValue(Address)->byte:::The field must be nonstatic and the type of the field must be a       Java byte, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JByteField#getValue()->byte:::The field must be static and the type of the field must be a       Java byte, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JCharField#getValue(Address)->char:::The field must be nonstatic and the type of the field must be a       Java char, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JCharField#getValue()->char:::The field must be static and the type of the field must be a       Java char, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JDoubleField#getValue(Address)->double:::The field must be nonstatic and the type of the field must be a       Java double, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JDoubleField#getValue()->double:::The field must be static and the type of the field must be a       Java double, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JFloatField#getValue(Address)->float:::The field must be nonstatic and the type of the field must be a       Java float, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JFloatField#getValue()->float:::The field must be static and the type of the field must be a       Java float, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JIntField#getValue(Address)->int:::The field must be nonstatic and the type of the field must be a       Java int, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JIntField#getValue()->int:::The field must be static and the type of the field must be a       Java int, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JLongField#getValue(Address)->long:::The field must be nonstatic and the type of the field must be a       Java long, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JLongField#getValue()->long:::The field must be static and the type of the field must be a       Java long, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JShortField#getValue(Address)->short:::The field must be nonstatic and the type of the field must be a       Java short, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.JShortField#getValue()->short:::The field must be static and the type of the field must be a       Java short, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.NarrowOopField#getValue(Address)->OopHandle:::The field must be nonstatic and the type of the field must be an       oop type, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.NarrowOopField#getValue()->OopHandle:::The field must be static and the type of the field must be an       oop type, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.OopField#getValue(Address)->OopHandle:::The field must be nonstatic and the type of the field must be an       oop type, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.OopField#getValue()->OopHandle:::The field must be static and the type of the field must be an       oop type, or a WrongTypeException will be thrown.
sun.jvm.hotspot.types.PointerType#getTargetType()->Type:::Returns the target type of this PointerType.
sun.jvm.hotspot.types.Type#getName()->String::: type get name
sun.jvm.hotspot.types.Type#getSuperclass()->Type::: type get superclass
sun.jvm.hotspot.types.Type#getSize()->long:::The size in bytes, at the machine level, of this type
sun.jvm.hotspot.types.Type#isCIntegerType()->boolean:::Indicates whether this type is a C integer type -- regardless of       size or signedness.
sun.jvm.hotspot.types.Type#isCStringType()->boolean:::Indicates whether this type is const char*.
sun.jvm.hotspot.types.Type#isJavaPrimitiveType()->boolean:::Indicates whether this type is one of the Java primitive types.
sun.jvm.hotspot.types.Type#isOopType()->boolean:::Indicates whether this type is an oop type in the VM.
sun.jvm.hotspot.types.Type#isPointerType()->boolean:::Indicates whether this type is a pointer type.
sun.jvm.hotspot.types.Type#getField(String, boolean, boolean)->Field:::This is permissive and returns the CField regardless of its type       as long as it is present
sun.jvm.hotspot.types.Type#getField(String, boolean)->Field:::This is permissive and returns the CField regardless of its type       as long as it is present -- it is equivalent to       getField(fieldName, searchSuperclassFields, true)
sun.jvm.hotspot.types.Type#getField(String)->Field:::This is permissive and returns the CField regardless of its type       as long as it is present
sun.jvm.hotspot.types.Type#getField(String, Type, boolean)->Field:::If there is a mismatch between the declared type and the type       which would otherwise be returned from this routine, it throws a       WrongTypeException
sun.jvm.hotspot.types.Type#getField(String, Type)->Field:::If there is a mismatch between the declared type and the type       which would otherwise be returned from this routine, it throws a       WrongTypeException
sun.jvm.hotspot.types.Type#getFields()->Iterator:::Iterate over all of the fields in this type but <B>not</B> in       any of its superclasses
sun.jvm.hotspot.types.Type#getJBooleanField(String)->JBooleanField:::<P> These accessors are designed to allow strong type checking       of certain well-known types of fields, specifically Java       primitive and oop types
sun.jvm.hotspot.types.Type#getJByteField(String)->JByteField::: type get byte field
sun.jvm.hotspot.types.Type#getJCharField(String)->JCharField::: type get char field
sun.jvm.hotspot.types.Type#getJDoubleField(String)->JDoubleField::: type get double field
sun.jvm.hotspot.types.Type#getJFloatField(String)->JFloatField::: type get float field
sun.jvm.hotspot.types.Type#getJIntField(String)->JIntField::: type get int field
sun.jvm.hotspot.types.Type#getJLongField(String)->JLongField::: type get long field
sun.jvm.hotspot.types.Type#getJShortField(String)->JShortField::: type get short field
sun.jvm.hotspot.types.Type#getCIntegerField(String)->CIntegerField::: type get integer field
sun.jvm.hotspot.types.Type#getOopField(String)->OopField::: type get oop field
sun.jvm.hotspot.types.Type#getNarrowOopField(String)->NarrowOopField::: type get narrow oop field
sun.jvm.hotspot.types.Type#getAddressField(String)->AddressField::: type get address field
sun.jvm.hotspot.types.TypeDataBase#lookupType(String)->Type:::Equivalent to lookupType(cTypeName, true)
sun.jvm.hotspot.types.TypeDataBase#lookupType(String, boolean)->Type:::For simplicity of the initial implementation, this is not       guaranteed to work for primitive types
sun.jvm.hotspot.types.TypeDataBase#lookupIntConstant(String)->Integer:::Equivalent to lookupIntConstant(constantName, true)
sun.jvm.hotspot.types.TypeDataBase#lookupIntConstant(String, boolean)->Integer::: type data base lookup int constant
sun.jvm.hotspot.types.TypeDataBase#lookupLongConstant(String)->Long:::Equivalent to lookupLongConstant(constantName, true)
sun.jvm.hotspot.types.TypeDataBase#lookupLongConstant(String, boolean)->Long::: type data base lookup long constant
sun.jvm.hotspot.types.TypeDataBase#getJBooleanType()->Type:::Accessors for types representing the Java primitive types; used       for both proper type checking and for walking down Java arrays.
sun.jvm.hotspot.types.TypeDataBase#getJByteType()->Type::: type data base get byte type
sun.jvm.hotspot.types.TypeDataBase#getJCharType()->Type::: type data base get char type
sun.jvm.hotspot.types.TypeDataBase#getJDoubleType()->Type::: type data base get double type
sun.jvm.hotspot.types.TypeDataBase#getJFloatType()->Type::: type data base get float type
sun.jvm.hotspot.types.TypeDataBase#getJIntType()->Type::: type data base get int type
sun.jvm.hotspot.types.TypeDataBase#getJLongType()->Type::: type data base get long type
sun.jvm.hotspot.types.TypeDataBase#getJShortType()->Type::: type data base get short type
sun.jvm.hotspot.types.TypeDataBase#getAddressSize()->long:::Returns the size of a C address in bytes
sun.jvm.hotspot.types.TypeDataBase#getOopSize()->long:::Returns the size of an oop in bytes
sun.jvm.hotspot.types.TypeDataBase#addressTypeIsEqualToType(Address, Type)->boolean:::<P> This is an experimental interface emulating C++'s run-time       type information (RTTI) mechanism: determines whether the given       address is a pointer to the start of a C++ object of precisely       the given type -- it does not search superclasses of the type
sun.jvm.hotspot.types.TypeDataBase#guessTypeForAddress(Address)->Type:::Helper routine for guessing the most derived type of a       polymorphic C++ object
sun.jvm.hotspot.types.TypeDataBase#findDynamicTypeForAddress(Address, Type)->Type:::Helper routine for guessing the most derived type of a       polymorphic C++ object
sun.jvm.hotspot.types.TypeDataBase#getTypes()->Iterator:::Returns an Iterator over the Types in the database.
sun.jvm.hotspot.types.TypeDataBase#getIntConstants()->Iterator:::Returns an Iterator over the String names of the integer       constants in the database.
sun.jvm.hotspot.types.TypeDataBase#getLongConstants()->Iterator:::Returns an Iterator over the String names of the long constants       in the database.
