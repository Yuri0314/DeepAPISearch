Builder#newRequires(Set, String, String):::Returns a Requires for a dependence on a module with the given (and possibly empty) set of modifiers, and optionally the version recorded at compile time.:::version->if->ver->if->compiledVersion->ver->toString->equals->else->Version->parse->return->JLMA->newRequires
Builder#newRequires(Set, String):::Returns a Requires for a dependence on a module with the given (and possibly empty) set of modifiers, and optionally the version recorded at compile time.:::return->newRequires
Builder#newExports(Set, String, Set):::Returns a Exports for a qualified export, with the given (and possibly empty) set of modifiers, to a set of target modules.:::return->JLMA->newExports
Builder#newOpens(Set, String):::Returns an Opens for an unqualified open with a given set of modifiers.:::return->JLMA->newOpens
Builder#newOpens(Set, String, Set):::Returns an Opens for a qualified opens, with the given (and possibly empty) set of modifiers, to a set of target modules.:::return->JLMA->newOpens
Builder#newExports(Set, String):::Returns a Exports for an unqualified export with a given set of modifiers.:::return->JLMA->newExports
Builder#newProvides(String, List):::Returns a Provides for a service with a given list of implementation classes.:::return->JLMA->newProvides
Builder#open(boolean)::: builder open:::return
Builder#synthetic(boolean)::: builder synthetic:::return
Builder#mandated(boolean)::: builder mandated:::return
Builder#exports(Exports[]):::Sets module exports.:::Set->of->return
Builder#opens(Opens[]):::Sets module opens.:::Set->of->return
Builder#requires(Requires[]):::Sets module requires.:::Set->of->return
Builder#packages(Set):::Adds a set of (possible empty) packages.:::return
Builder#uses(Set):::Sets the set of service dependences.:::return
Builder#provides(Provides[]):::Sets module provides.:::Set->of->return
Builder#version(String):::Sets the module version.:::ver->if->v->ver->toString->equals->else->Version->parse->return
Builder#mainClass(String):::Sets the module main class.:::return
Builder#modifiers():::Returns an immutable set of the module modifiers derived from the flags.:::n->if->if->if->if->return->Set->of->else->mods->new->ModuleDescriptor.ModifierArr->if->if->if->return->Set->of
Builder#build(int):::Builds a ModuleDescriptor from the components.:::return->JLMA->modifiers->newModuleDescriptor
Checks#requireModuleName(String):::Checks a name to ensure that it's a legal module name.:::if->throw->new->IllegalArgumentException->next->off->while->name->indexOf->id->name->substring->if->isJavaIdentifier->throw->new->IllegalArgumentException->last->name->substring->if->isJavaIdentifier->throw->new->IllegalArgumentException->return
Checks#isModuleName(String):::Returns true if the given name is a legal module name.:::next->off->while->name->indexOf->id->name->substring->if->isJavaIdentifier->return->last->name->substring->return->isJavaIdentifier
Checks#requirePackageName(String):::Checks a name to ensure that it's a legal package name.:::return->requireTypeName
Checks#isPackageName(String):::Returns true if the given name is a legal package name.:::return->isTypeName
Checks#requireServiceTypeName(String):::Checks a name to ensure that it's a legal qualified class name:::return->requireQualifiedClassName
Checks#requireServiceProviderName(String):::Checks a name to ensure that it's a legal qualified class name.:::return->requireQualifiedClassName
Checks#requireQualifiedClassName(String, String):::Checks a name to ensure that it's a legal qualified class name in a named package.:::requireTypeName->if->name->indexOf->throw->new->IllegalArgumentException->return
Checks#isClassName(String):::Returns true if the given name is a legal class name.:::return->isTypeName
Checks#isTypeName(String):::Returns true if the given name is a legal type name.:::next->off->while->name->indexOf->id->name->substring->if->isJavaIdentifier->return->last->name->substring->return->isJavaIdentifier
Checks#requireTypeName(String, String):::Checks if the given name is a legal type name.:::if->throw->new->IllegalArgumentException->next->off->while->name->indexOf->id->name->substring->if->isJavaIdentifier->throw->new->IllegalArgumentException->last->name->substring->if->isJavaIdentifier->throw->new->IllegalArgumentException->return
Checks#isJavaIdentifier(CharSequence):::Returns true if the given char sequence is a legal Java identifier, otherwise false.:::if->cs->length->RESERVED->contains->return->first->Character->codePointAt->if->Character->isJavaIdentifierStart->return->i->Character->charCount->while->cs->length->cp->Character->codePointAt->if->Character->isJavaIdentifierPart->return->Character->charCount->return
DefaultRoots#compute(ModuleFinder, ModuleFinder):::Returns the default set of root modules for the unnamed module from the modules observable with the intersection of two module finders:::return->finder1->findAll->stream->ModuleResolution->doNotResolveByDefault->filter->ModuleReference->descriptor->map->finder2->descriptor->name->find->isPresent->exportsAPI->filter->ModuleDescriptor->name->map->Collectors->toSet->collect
DefaultRoots#compute(ModuleFinder):::Returns the default set of root modules for the unnamed module from the modules observable with the given module finder:::return->compute
DefaultRoots#exportsAPI(ModuleDescriptor):::Returns true if the given module exports a package to all modules:::return->descriptor->exports->stream->e->isQualified->filter->findAny->isPresent
ExplodedSystemModules#hasSplitPackages()::: exploded system modules has split packages:::return
ExplodedSystemModules#hasIncubatorModules()::: exploded system modules has incubator modules:::return
ExplodedSystemModules#moduleDescriptors()::: exploded system modules module descriptors:::throw->new->InternalError
ExplodedSystemModules#moduleTargets()::: exploded system modules module targets:::throw->new->InternalError
ExplodedSystemModules#moduleHashes()::: exploded system modules module hashes:::throw->new->InternalError
ExplodedSystemModules#moduleResolutions()::: exploded system modules module resolutions:::throw->new->InternalError
ExplodedSystemModules#moduleReads()::: exploded system modules module reads:::throw->new->InternalError
ExplodedSystemModules#concealedPackagesToOpen()::: exploded system modules concealed packages to open:::return->Map->of
ExplodedSystemModules#exportedPackagesToOpen()::: exploded system modules exported packages to open:::return->Map->of
IllegalAccessLogger.Builder#ensureNotComplete()::: builder ensure not complete:::if->throw->new->IllegalStateException
IllegalAccessLogger.Builder#logAccessToConcealedPackages(Module, Set):::Adding logging of reflective-access to any member of a type in otherwise concealed packages.:::ensureNotComplete->moduleToConcealedPackages->unmodifiableSet->put->return
IllegalAccessLogger.Builder#logAccessToExportedPackages(Module, Set):::Adding logging of reflective-access to non-public members/types in otherwise exported (not open) packages.:::ensureNotComplete->moduleToExportedPackages->unmodifiableSet->put->return
IllegalAccessLogger.Builder#complete():::Builds the IllegalAccessLogger and sets it as the system-wise logger.:::map1->unmodifiableMap->map2->unmodifiableMap->new->IllegalAccessLogger
IllegalAccessLogger#illegalAccessLogger():::Returns the system-wide IllegalAccessLogger or null if there is no logger.:::return
IllegalAccessLogger#isExportedForIllegalAccess(Module, String):::Returns true if the module exports a concealed package for illegal access.:::packages->moduleToConcealedPackages->get->if->packages->contains->return->return
IllegalAccessLogger#isOpenForIllegalAccess(Module, String):::Returns true if the module opens a concealed or exported package for illegal access.:::if->isExportedForIllegalAccess->return->packages->moduleToExportedPackages->get->if->packages->contains->return->return
IllegalAccessLogger#logIfExportedForIllegalAccess(Class, Class, Supplier):::Logs access to the member of a target class by a caller class if the class is in a package that is exported for illegal access:::targetModule->target->getModule->targetPackage->target->getPackageName->if->isExportedForIllegalAccess->callerModule->caller->getModule->if->JLA->isReflectivelyExported->whatSupplier->get->log
IllegalAccessLogger#logIfOpenedForIllegalAccess(Class, Class, Supplier):::Logs access to the member of a target class by a caller class if the class is in a package that is opened for illegal access:::targetModule->target->getModule->targetPackage->target->getPackageName->if->isOpenForIllegalAccess->callerModule->caller->getModule->if->JLA->isReflectivelyOpened->whatSupplier->get->log
IllegalAccessLogger#logIfOpenedForIllegalAccess(MethodHandles.Lookup, Class):::Logs access by caller lookup if the target class is in a package that is opened for illegal access.:::targetModule->target->getModule->targetPackage->target->getPackageName->if->isOpenForIllegalAccess->callerClass->caller->lookupClass->callerModule->callerClass->getModule->if->JLA->isReflectivelyOpened->url->codeSource->source->if->callerClass->getName->else->callerClass->getName->target->getName->log
IllegalAccessLogger#log(Class, String):::Logs access by a caller class:::url->codeSource->source->caller->getName->if->return->log
IllegalAccessLogger#log(Class, String, Supplier):::Log access by a caller:::if->synchronized->if->return->warningStream->loudWarning->println->return->stack->s->this->isJavaBase->dropWhile->limit->Collectors->toList->collect->walk->u->hash->new->Usage->added->synchronized->callerToUsages->new->Usages->computeIfAbsent->add->if->msg->msgSupplier->get->if->sb->new->StringBuilder->stack->sb->System->lineSeparator->append->append->forEach->sb->toString->warningStream->println
IllegalAccessLogger#codeSource(Class):::Returns the code source for the given class or null if there is no code source:::pa->clazz->getProtectionDomain->cs->AccessController->doPrivileged->getCodeSource->return->cs->getLocation
IllegalAccessLogger#loudWarning(Class, Supplier)::: illegal access logger loud warning:::sj->System->lineSeparator->new->StringJoiner->sj->add->sj->msgSupplier->get->add->sj->caller->getName->add->sj->add->sj->add->return->sj->toString
IllegalAccessLogger#isJavaBase(StackWalker.StackFrame):::Returns true if the stack frame is for a class in java.base.:::caller->frame->getDeclaringClass->getModule->return->caller->getName->equals
IllegalAccessLogger#hash(List):::Computes a hash code for the give stack frames:::hash->foreach->Objects->frame->getDeclaringClass->frame->getMethodName->frame->getByteCodeIndex->hash->return
IllegalAccessLogger.Usage#hashCode()::: usage hash code:::return->what->hashCode
IllegalAccessLogger.Usage#equals(Object)::: usage equals:::if->that->return->what->equals->else->return
IllegalAccessLogger.Usages#add(Usage)::: usages add:::return->putIfAbsent
IllegalAccessLogger.Usages#removeEldestEntry(Map.Entry)::: usages remove eldest entry:::return->size
IllegalAccessMaps#concealedPackagesToOpen():::Returns the map of concealed packages to open:::return
IllegalAccessMaps#exportedPackagesToOpen():::Returns the map of exported packages to open:::return
IllegalAccessMaps#generate(ModuleFinder):::Generate the maps of module to concealed and exported packages for the system modules that are observable with the given module finder.:::map->new->HashMap<>->finder->findAll->stream->ModuleReference->descriptor->map->md->packages->map->putIfAbsent->forEach->forEach->concealedPackagesToOpen->new->HashMap<>->exportedPackagesToOpen->new->HashMap<>->rn->in->getResourceAsStream->if->throw->new->InternalError->try->br->new->InputStreamReader->new->BufferedReader->br->lines->line->isEmpty->line->startsWith->filter->descriptor->map->get->if->isOpen->name->descriptor->name->if->isExported->exportedPackagesToOpen->new->HashSet<>->computeIfAbsent->add->else->concealedPackagesToOpen->new->HashSet<>->computeIfAbsent->add->forEach->catch->throw->new->UncheckedIOException->finally->return->new->IllegalAccessMaps
IllegalAccessMaps#isExported(ModuleDescriptor, String)::: illegal access maps is exported:::return->descriptor->exports->stream->e->source->equals->e->isQualified->anyMatch
IllegalAccessMaps#isOpen(ModuleDescriptor, String)::: illegal access maps is open:::return->descriptor->opens->stream->e->source->equals->e->isQualified->anyMatch
ModuleBootstrap#patcher():::Returns the ModulePatcher for the initial configuration.:::return
ModuleBootstrap#unlimitedFinder():::Returns the ModuleFinder for the initial configuration before observability is limited by the --limit-modules command line option.:::finder->if->return->ModuleFinder->ofSystem->else->return
ModuleBootstrap#limitedFinder():::Returns the ModuleFinder for the initial configuration.:::finder->if->return->unlimitedFinder->else->return
ModuleBootstrap#boot():::Initialize the module system, returning the boot layer.:::t0->System->nanoTime->upgradeModulePath->finderFor->appModulePath->finderFor->isPatched->patcher->hasPatches->mainModule->System->getProperty->addModules->addModules->limitModules->limitModules->traceOutput->trace->getAndRemoveProperty->if->Boolean->parseBoolean->t1->System->nanoTime->systemModules->systemModuleFinder->haveModulePath->needResolution->if->addModules->isEmpty->limitModules->isEmpty->SystemModuleFinders->systemModules->if->if->SystemModuleFinders->allSystemModules->if->SystemModuleFinders->of->else->new->ExplodedSystemModules->SystemModuleFinders->ofSystem->Counters->add->t2->System->nanoTime->base->systemModuleFinder->find->orElse->if->throw->new->InternalError->baseUri->base->location->orElse->if->throw->new->InternalError->BootLoader->loadModule->Modules->base->descriptor->defineModule->Counters->add->if->getAndRemoveProperty->errors->ModulePathValidator->scanAllModules->if->fail->t3->System->nanoTime->savedModuleFinder->finder->roots->if->if->ModuleFinder->compose->if->ModuleFinder->compose->else->new->HashSet<>->if->roots->add->addAllDefaultModules->addAllSystemModules->addAllApplicationModules->foreach->switch->break->break->break->roots->add->if->limitModules->isEmpty->limitFinder->if->roots->DefaultRoots->compute->addAll->if->f->systemModuleFinder->findAll->stream->ModuleReference->descriptor->map->ModuleDescriptor->name->map->f->find->isPresent->filter->roots->add->forEach->if->f->appModulePath->findAll->stream->ModuleReference->descriptor->map->ModuleDescriptor->name->map->f->find->isPresent->filter->roots->add->forEach->else->Counters->add->t4->System->nanoTime->cf->if->JLMA->resolveAndBind->else->map->systemModules->moduleReads->JLMA->newConfiguration->if->patcher->patchedModules->stream->cf->findModule->isPresent->filter->warnUnknownModule->forEach->Counters->add->t5->System->nanoTime->clf->ModuleLoaderMap->mappingFunction->if->foreach->cf->modules->mref->resolvedModule->reference->name->mref->descriptor->name->cl->clf->apply->if->if->upgradeModulePath->find->isPresent->fail->if->systemModuleFinder->find->isPresent->fail->if->systemModules->hasSplitPackages->checkSplitPackages->loadModules->Counters->add->t6->System->nanoTime->bootLayer->ModuleLayer->empty->defineModules->Counters->add->if->systemModules->hasIncubatorModules->checkIncubatingStatus->t7->System->nanoTime->addExtraReads->extraExportsOrOpens->addExtraExportsAndOpens->addIllegalAccess->Counters->add->if->new->SafeModuleFinder->if->new->SafeModuleFinder->Counters->add->Counters->publish->return
ModuleBootstrap#loadModules(Configuration, Function):::Load/register the modules to the built-in class loaders.:::foreach->cf->modules->mref->resolvedModule->reference->name->resolvedModule->name->loader->clf->apply->if->if->name->equals->BootLoader->loadModule->else->if->loadModule
ModuleBootstrap#checkSplitPackages(Configuration, Function):::Checks for split packages between modules defined to the built-in class loaders.:::packageToModule->new->HashMap<>->foreach->cf->modules->descriptor->resolvedModule->reference->descriptor->name->descriptor->name->loader->clf->apply->if->foreach->descriptor->packages->other->packageToModule->putIfAbsent->if->msg->throw->new->LayerInstantiationException
ModuleBootstrap#limitFinder(ModuleFinder, Set, Set):::Returns a ModuleFinder that limits observability to the given root modules, their transitive dependences, plus a set of other modules.:::cf->Configuration->empty->ModuleFinder->of->resolve->map->new->HashMap<>->cf->modules->stream->ResolvedModule->reference->map->map->mref->descriptor->name->put->forEach->otherMods->stream->finder->find->map->Optional->stream->flatMap->map->mref->descriptor->name->putIfAbsent->forEach->mrefs->map->values->new->HashSet<>->return->new->ModuleFinder
ModuleBootstrap#finderFor(String):::Creates a finder from the module path that is the value of the given system property and optionally patched by --patch-module:::s->System->getProperty->if->return->else->dirs->s->split->paths->new->PathArr->i->foreach->Path->of->return->ModulePath->of
ModuleBootstrap#initModulePatcher():::Initialize the module patcher for the initial configuration passed on the value of the --patch-module options.:::map->decode->return->new->ModulePatcher
ModuleBootstrap#addModules():::Returns the set of module names specified by --add-module options.:::prefix->index->value->getAndRemoveProperty->if->return->Set->of->else->modules->new->HashSet<>->while->foreach->value->split->if->s->length->modules->add->getAndRemoveProperty->return
ModuleBootstrap#limitModules():::Returns the set of module names specified by --limit-modules.:::value->getAndRemoveProperty->if->return->Set->of->else->names->new->HashSet<>->foreach->value->split->if->name->length->names->add->return
ModuleBootstrap#addExtraReads(ModuleLayer):::Process the --add-reads options to add any additional read edges that are specified on the command-line.:::map->decode->if->map->isEmpty->return->foreach->map->entrySet->mn->e->getKey->om->bootLayer->findModule->if->om->isPresent->warnUnknownModule->continue->m->om->get->foreach->e->getValue->if->ALL_UNNAMED->equals->Modules->addReadsAllUnnamed->else->bootLayer->findModule->if->om->isPresent->Modules->om->get->addReads->else->warnUnknownModule
ModuleBootstrap#addExtraExportsAndOpens(ModuleLayer):::Process the --add-exports and --add-opens options to export/open additional packages specified on the command-line.:::extraExportsOrOpens->prefix->extraExports->decode->if->extraExports->isEmpty->addExtraExportsOrOpens->extraOpens->decode->if->extraOpens->isEmpty->addExtraExportsOrOpens->return
ModuleBootstrap#addExtraExportsOrOpens(ModuleLayer, Map>, boolean)::: module bootstrap add extra exports or opens:::option->foreach->map->entrySet->key->e->getKey->s->key->split->if->unableToParse->fail->mn->pn->if->mn->isEmpty->pn->isEmpty->unableToParse->fail->m->om->bootLayer->findModule->if->om->isPresent->warnUnknownModule->continue->om->get->if->m->getDescriptor->packages->contains->warn->continue->foreach->e->getValue->allUnnamed->other->if->ALL_UNNAMED->equals->else->bootLayer->findModule->if->om->isPresent->om->get->else->warnUnknownModule->continue->if->if->Modules->addOpensToAllUnnamed->else->Modules->addExportsToAllUnnamed->else->if->Modules->addOpens->else->Modules->addExports
ModuleBootstrap#addIllegalAccess(ModuleFinder, SystemModules, ModuleLayer, boolean):::Process the --illegal-access option (and its default) to open packages of system modules in the boot layer to code in unnamed modules.:::value->getAndRemoveProperty->mode->if->switch->return->break->break->break->fail->return->builder->new->IllegalAccessLogger.Builder->map1->systemModules->concealedPackagesToOpen->map2->systemModules->exportedPackagesToOpen->if->map1->isEmpty->map2->isEmpty->maps->IllegalAccessMaps->limitedFinder->generate->maps->concealedPackagesToOpen->maps->exportedPackagesToOpen->foreach->bootLayer->modules->descriptor->m->getDescriptor->name->m->getName->if->descriptor->isOpen->continue->if->upgradeModulePath->find->isPresent->continue->concealedPackages->map1->Set->of->getOrDefault->exportedPackages->map2->Set->of->getOrDefault->if->new->HashSet<>->new->HashSet<>->iterator->concealedPackages->iterator->while->iterator->hasNext->pn->iterator->next->if->m->BootLoader->getUnnamedModule->isExported->iterator->remove->exportedPackages->add->exportedPackages->iterator->while->iterator->hasNext->pn->iterator->next->if->m->BootLoader->getUnnamedModule->isOpen->iterator->remove->builder->logAccessToConcealedPackages->builder->logAccessToExportedPackages->jla->SharedSecrets->getJavaLangAccess->jla->concealedPackages->iterator->exportedPackages->iterator->concat->addOpensToAllUnnamed->builder->complete
ModuleBootstrap#decode(String, String, boolean):::Decodes the values of --add-reads, -add-exports, --add-opens or --patch-modules options that are encoded in system properties.:::index->value->getAndRemoveProperty->if->return->Map->of->map->new->HashMap<>->while->pos->value->indexOf->if->option->unableToParse->fail->if->option->unableToParse->fail->key->value->substring->rhs->value->substring->if->rhs->isEmpty->option->unableToParse->fail->if->map->containsKey->option->fail->values->map->new->ArrayList<>->computeIfAbsent->ntargets->foreach->rhs->split->if->s->length->values->add->if->option->fail->getAndRemoveProperty->return
ModuleBootstrap#decode(String):::Decodes the values of --add-reads, -add-exports or --add-opens which use the "," to separate the RHS of the option value.:::return->decode
ModuleBootstrap#getAndRemoveProperty(String):::Gets and remove the named system property:::return->System->getProperties->remove
ModuleBootstrap#checkIncubatingStatus(Configuration):::Checks incubating status of modules in the configuration:::incubating->foreach->cf->modules->mref->resolvedModule->reference->if->ModuleResolution->hasIncubatingWarning->mn->mref->descriptor->name->if->else->if->warn
ModuleBootstrap#fail(String):::Throws a RuntimeException with the given message:::throw->new->RuntimeException
ModuleBootstrap#warn(String)::: module bootstrap warn:::println
ModuleBootstrap#warnUnknownModule(String, String)::: module bootstrap warn unknown module:::warn
ModuleBootstrap#unableToParse(String, String, String)::: module bootstrap unable to parse:::return
ModuleBootstrap#option(String)::: module bootstrap option:::switch->return->return->return->return->return->throw->new->IllegalArgumentException
ModuleBootstrap#concat(Iterator, Iterator):::Returns an iterator that yields all elements of the first iterator followed by all the elements of the second iterator.:::return->new->Iterator<T>
ModuleBootstrap.SafeModuleFinder#find(String)::: safe module finder find:::Objects->requireNonNull->nameToModule->if->mrefs->stream->Collectors->m->descriptor->name->Function->identity->toMap->collect->return->Optional->nameToModule->get->ofNullable
ModuleBootstrap.SafeModuleFinder#findAll()::: safe module finder find all:::return
ModuleBootstrap.Counters#add(String, long):::Add a counter:::if->counters->System->nanoTime->put
ModuleBootstrap.Counters#publish():::Publish the counters to the instrumentation buffer or stdout.:::if->foreach->counters->entrySet->name->e->getKey->value->e->getValue->if->PerfCounter->newPerfCounter->set->if->println
ModuleHashes.HashSupplier#generate(String)::: hash supplier generate:::
ModuleHashes#algorithm():::Returns the algorithm used to hash the modules ("SHA-256" for example).:::return
ModuleHashes#names():::Returns the set of module names for which hashes are recorded.:::return->nameToHash->keySet
ModuleHashes#hashFor(String):::Returns the hash for the given module name, null if there is no hash recorded for the module.:::return->nameToHash->get
ModuleHashes#hashes():::Returns unmodifiable map of module name to hash:::return
ModuleHashes#computeHash(Path, String):::Computes the hash for the given file with the given message digest algorithm.:::try->md->MessageDigest->getInstance->try->fc->FileChannel->open->bb->ByteBuffer->allocate->while->fc->read->bb->flip->md->update->bb->clear->catch->finally->return->md->digest->catch->throw->new->RuntimeException->throw->new->UncheckedIOException->finally
ModuleHashes#generate(Map, String):::Computes the hash for every entry in the given map, returning a ModuleHashes to encapsulate the result:::nameToHash->new->HashMap<>->foreach->map->entrySet->name->entry->getKey->path->entry->getValue->nameToHash->computeHash->put->return->new->ModuleHashes
ModuleHashes.Builder#hashForModule(String, byte[]):::Sets the module hash for the given module name:::nameToHash->put->return
ModuleHashes.Builder#build():::Builds a ModuleHashes.:::if->nameToHash->isEmpty->return->new->ModuleHashes->else->return
ModuleHashesBuilder#computeHashes(Set):::Returns a map of a module M to ModuleHashes for the modules that depend upon M directly or indirectly:::builder->new->Graph.Builder<>->todo->configuration->modules->new->ArrayDeque<>->visited->new->HashSet<>->rm->while->todo->poll->if->visited->add->builder->rm->name->addNode->foreach->rm->reads->if->visited->contains->todo->push->builder->rm->name->dm->name->addEdge->transposedGraph->builder->build->transpose->mods->new->HashSet<>->hashes->new->HashMap<>->builder->build->orderedNodes->roots->contains->mods->contains->filter->ns->transposedGraph->dfs->stream->n->equals->hashModuleCandidates->contains->filter->toSet->collect->mods->add->mods->addAll->if->ns->isEmpty->moduleToPath->ns->stream->Function->identity->this->moduleToPath->toMap->collect->hashes->ModuleHashes->generate->put->forEach->return
ModuleHashesBuilder#moduleToPath(String)::: module hashes builder module to path:::rm->configuration->findModule->new->InternalError->orElseThrow->uri->rm->reference->location->get->path->Path->of->fn->path->getFileName->toString->if->fn->endsWith->fn->endsWith->throw->new->UnsupportedOperationException->return
ModuleHashesBuilder.Graph#nodes()::: graph nodes:::return
ModuleHashesBuilder.Graph#edges()::: graph edges:::return
ModuleHashesBuilder.Graph#adjacentNodes(T)::: graph adjacent nodes:::return->edges->get
ModuleHashesBuilder.Graph#contains(T)::: graph contains:::return->nodes->contains
ModuleHashesBuilder.Graph#orderedNodes():::Returns nodes sorted in topological order.:::sorter->new->TopoSorter<>->return->stream
ModuleHashesBuilder.Graph#ordered(Consumer):::Traverses this graph and performs the given action in topological order.:::sorter->new->TopoSorter<>->sorter->ordered
ModuleHashesBuilder.Graph#reverse(Consumer):::Traverses this graph and performs the given action in reverse topological order.:::sorter->new->TopoSorter<>->sorter->reverse
ModuleHashesBuilder.Graph#transpose():::Returns a transposed graph from this graph.:::builder->new->Builder<>->nodes->builder->addNode->forEach->edges->keySet->edges->get->builder->addEdge->forEach->forEach->return->builder->build
ModuleHashesBuilder.Graph#dfs(T):::Returns all nodes reachable from the given root.:::return->Set->of->dfs
ModuleHashesBuilder.Graph#dfs(Set):::Returns all nodes reachable from the given set of roots.:::todo->new->ArrayDeque<>->visited->new->HashSet<>->u->while->todo->poll->if->visited->add->contains->adjacentNodes->stream->visited->contains->filter->todo->push->forEach->return
ModuleHashesBuilder.Graph#printGraph(PrintStream)::: graph print graph:::out->println->nodes->adjacentNodes->out->format->forEach->forEach
ModuleHashesBuilder.Graph.Builder#addNode(T)::: builder add node:::if->nodes->add->edges->new->HashSet<>->computeIfAbsent
ModuleHashesBuilder.Graph.Builder#addEdge(T, T)::: builder add edge:::addNode->addNode->edges->get->add
ModuleHashesBuilder.Graph.Builder#build()::: builder build:::return->new->Graph<T>
ModuleHashesBuilder.TopoSorter#ordered(Consumer)::: topo sorter ordered:::result->forEach
ModuleHashesBuilder.TopoSorter#reverse(Consumer)::: topo sorter reverse:::result->descendingIterator->forEachRemaining
ModuleHashesBuilder.TopoSorter#sort()::: topo sorter sort:::visited->new->HashSet<>->stack->new->ArrayDeque<>->visit->forEach
ModuleHashesBuilder.TopoSorter#children(T)::: topo sorter children:::return->graph->edges->get
ModuleHashesBuilder.TopoSorter#visit(T, Set, Deque)::: topo sorter visit:::if->visited->add->stack->push->children->visit->forEach->stack->pop->result->addLast->else->if->stack->contains->throw->children->new->IllegalArgumentException
ModuleInfo.Attributes#descriptor()::: attributes descriptor:::return
ModuleInfo.Attributes#target()::: attributes target:::return
ModuleInfo.Attributes#recordedHashes()::: attributes recorded hashes:::return
ModuleInfo.Attributes#moduleResolution()::: attributes module resolution:::return
ModuleInfo#read(InputStream, Supplier>):::Reads a module-info.class from the given input stream.:::try->return->new->ModuleInfo->new->DataInputStream->doRead->catch->throw->e->getMessage->invalidModuleDescriptor->throw->truncatedModuleDescriptor->finally
ModuleInfo#read(ByteBuffer, Supplier>):::Reads a module-info.class from the given byte buffer.:::try->return->new->ModuleInfo->new->DataInputWrapper->doRead->catch->throw->e->getMessage->invalidModuleDescriptor->throw->truncatedModuleDescriptor->throw->new->UncheckedIOException->finally
ModuleInfo#readIgnoringHashes(ByteBuffer, Supplier>):::Reads a module-info.class from the given byte buffer but ignore the ModuleHashes attribute.:::try->return->new->ModuleInfo->new->DataInputWrapper->doRead->catch->throw->e->getMessage->invalidModuleDescriptor->throw->truncatedModuleDescriptor->throw->new->UncheckedIOException->finally
ModuleInfo#doRead(DataInput):::Reads the input as a module-info class file.:::magic->in->readInt->if->throw->invalidModuleDescriptor->minor_version->in->readUnsignedShort->major_version->in->readUnsignedShort->if->throw->invalidModuleDescriptor->cpool->new->ConstantPool->access_flags->in->readUnsignedShort->if->throw->invalidModuleDescriptor->this_class->in->readUnsignedShort->mn->cpool->getClassName->if->equals->throw->invalidModuleDescriptor->super_class->in->readUnsignedShort->if->throw->invalidModuleDescriptor->interfaces_count->in->readUnsignedShort->if->throw->invalidModuleDescriptor->fields_count->in->readUnsignedShort->if->throw->invalidModuleDescriptor->methods_count->in->readUnsignedShort->if->throw->invalidModuleDescriptor->attributes_count->in->readUnsignedShort->attributes->new->HashSet<>->builder->allPackages->mainClass->moduleTarget->moduelHashes->moduleResolution->for->i->if->throw->invalidModuleDescriptor->if->builder->mainClass->usedPackageFinder->if->try->packageFinder->get->catch->throw->x->getCause->finally->if->knownPackages->JLMA->packages->if->allPackages->containsAll->missingPackages->new->HashSet<>->missingPackages->removeAll->missingPackage->missingPackages->iterator->next->tail->if->else->throw->invalidModuleDescriptor->builder->packages->descriptor->builder->build->return->new->Attributes
ModuleInfo#readModuleAttribute(DataInput, ConstantPool, int):::Reads the Module attribute, returning the ModuleDescriptor.Builder to build the corresponding ModuleDescriptor.:::module_name_index->in->readUnsignedShort->mn->cpool->getModuleName->module_flags->in->readUnsignedShort->modifiers->new->HashSet<>->open->if->modifiers->add->if->modifiers->add->if->modifiers->add->builder->JLMA->newModuleBuilder->module_version_index->in->readUnsignedShort->if->vs->cpool->getUtf8->builder->version->requires_count->in->readUnsignedShort->requiresJavaBase->for->i->if->mn->equals->if->throw->invalidModuleDescriptor->else->if->throw->invalidModuleDescriptor->exports_count->in->readUnsignedShort->if->for->i->opens_count->in->readUnsignedShort->if->if->throw->invalidModuleDescriptor->for->i->uses_count->in->readUnsignedShort->if->for->i->provides_count->in->readUnsignedShort->if->for->i->return
ModuleInfo#readModulePackagesAttribute(DataInput, ConstantPool):::Reads the ModulePackages attribute:::package_count->in->readUnsignedShort->packages->new->HashSet<>->for->i->return
ModuleInfo#readModuleMainClassAttribute(DataInput, ConstantPool):::Reads the ModuleMainClass attribute:::index->in->readUnsignedShort->return->cpool->getClassName
ModuleInfo#readModuleTargetAttribute(DataInput, ConstantPool):::Reads the ModuleTarget attribute:::targetPlatform->index->in->readUnsignedShort->if->cpool->getUtf8->return->new->ModuleTarget
ModuleInfo#readModuleHashesAttribute(DataInput, ConstantPool):::Reads the ModuleHashes attribute:::algorithm_index->in->readUnsignedShort->algorithm->cpool->getUtf8->hash_count->in->readUnsignedShort->map->new->HashMap<>->for->i->return->new->ModuleHashes
ModuleInfo#readModuleResolution(DataInput, ConstantPool):::Reads the ModuleResolution attribute.:::flags->in->readUnsignedShort->reason->if->if->if->throw->invalidModuleDescriptor->if->if->throw->invalidModuleDescriptor->return->new->ModuleResolution
ModuleInfo#isAttributeAtMostOnce(String):::Returns true if the given attribute can be present at most once in the class file:::if->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->name->equals->return->return
ModuleInfo#isAttributeDisallowed(String):::Return true if the given attribute name is the name of a pre-defined attribute in JVMS 4.7 that is not allowed in a module-info class.:::notAllowed->if->Set->of->return->notAllowed->contains
ModuleInfo.ConstantPool#getClassName(int)::: constant pool get class name:::checkIndex->e->if->throw->invalidModuleDescriptor->value->getUtf8->checkUnqualifiedName->return->value->replace
ModuleInfo.ConstantPool#getPackageName(int)::: constant pool get package name:::checkIndex->e->if->throw->invalidModuleDescriptor->value->getUtf8->checkUnqualifiedName->return->value->replace
ModuleInfo.ConstantPool#getModuleName(int)::: constant pool get module name:::checkIndex->e->if->throw->invalidModuleDescriptor->value->getUtf8->return->decodeModuleName
ModuleInfo.ConstantPool#getUtf8(int)::: constant pool get utf8:::checkIndex->e->if->throw->invalidModuleDescriptor->return
ModuleInfo.ConstantPool#checkIndex(int)::: constant pool check index:::if->throw->invalidModuleDescriptor
ModuleInfo.ConstantPool#checkUnqualifiedName(String, int, String)::: constant pool check unqualified name:::len->value->length->if->throw->invalidModuleDescriptor->for->i
ModuleInfo.ConstantPool#decodeModuleName(int, String):::"Decode" a module name that has been read from the constant pool.:::len->value->length->if->throw->invalidModuleDescriptor->i->while->cp->value->codePointAt->if->throw->Character->getName->invalidModuleDescriptor->if->return->decodeModuleName->Character->charCount->return
ModuleInfo.ConstantPool#decodeModuleName(int, int, String):::"Decode" a module name that has been read from the constant pool and partly checked for illegal characters (up to position i).:::sb->new->StringBuilder->j->while->cp->value->codePointAt->sb->appendCodePoint->Character->charCount->len->value->length->while->cp->value->codePointAt->if->throw->Character->getName->invalidModuleDescriptor->if->Character->charCount->if->throw->invalidModuleDescriptor->next->value->codePointAt->if->throw->invalidModuleDescriptor->sb->appendCodePoint->Character->charCount->else->sb->appendCodePoint->Character->charCount->return->sb->toString
ModuleInfo.DataInputWrapper#readFully(byte[])::: data input wrapper read fully:::readFully
ModuleInfo.DataInputWrapper#readFully(byte[], int, int)::: data input wrapper read fully:::try->bb->get->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#skipBytes(int)::: data input wrapper skip bytes:::skip->Math->bb->remaining->min->bb->bb->position->position->return
ModuleInfo.DataInputWrapper#readBoolean()::: data input wrapper read boolean:::try->ch->bb->get->return->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readByte()::: data input wrapper read byte:::try->return->bb->get->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readUnsignedByte()::: data input wrapper read unsigned byte:::try->return->bb->get->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readShort()::: data input wrapper read short:::try->return->bb->getShort->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readUnsignedShort()::: data input wrapper read unsigned short:::try->return->bb->getShort->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readChar()::: data input wrapper read char:::try->return->bb->getChar->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readInt()::: data input wrapper read int:::try->return->bb->getInt->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readLong()::: data input wrapper read long:::try->return->bb->getLong->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readFloat()::: data input wrapper read float:::try->return->bb->getFloat->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readDouble()::: data input wrapper read double:::try->return->bb->getDouble->catch->throw->e->getMessage->new->EOFException->finally
ModuleInfo.DataInputWrapper#readLine()::: data input wrapper read line:::throw->new->RuntimeException
ModuleInfo.DataInputWrapper#readUTF()::: data input wrapper read f:::return->DataInputStream->readUTF
ModuleInfo#invalidModuleDescriptor(String):::Returns an InvalidModuleDescriptorException with the given detail message:::return->new->InvalidModuleDescriptorException
ModuleInfo#truncatedModuleDescriptor():::Returns an InvalidModuleDescriptorException with a detail message to indicate that the class file is truncated.:::return->invalidModuleDescriptor
ModuleInfoExtender#packages(Set):::Sets the packages for the ModulePackages attribute:::Collections->unmodifiableSet->return
ModuleInfoExtender#version(Version):::Sets the value for the module version in the Module attribute:::return
ModuleInfoExtender#mainClass(String):::Sets the value of the ModuleMainClass attribute.:::return
ModuleInfoExtender#targetPlatform(String):::Sets the value for the ModuleTarget attribute.:::return
ModuleInfoExtender#hashes(ModuleHashes):::The ModuleHashes attribute will be emitted to the module-info with the hashes encapsulated in the given ModuleHashes object.:::return
ModuleInfoExtender#moduleResolution(ModuleResolution):::Sets the value for the ModuleResolution attribute.:::return
ModuleInfoExtender#write(OutputStream):::Outputs the modified module-info.class to the given output stream:::out->toByteArray->write
ModuleInfoExtender#toByteArray():::Returns the bytes of the modified module-info.class:::cw->new->ClassWriter->cr->new->ClassReader->cv->new->ClassVisitor->attrs->new->ArrayList<>->attrs->new->ModuleTargetAttribute->add->attrs->new->ModuleResolutionAttribute->add->attrs->new->ModuleHashesAttribute->add->cr->attrs->new->AttributeArr->toArray->accept->if->cw->new->ModuleTargetAttribute->visitAttribute->if->flags->moduleResolution->value->cw->new->ModuleResolutionAttribute->visitAttribute->if->algorithm->hashes->algorithm->names->new->ArrayList<>->values->new->ArrayList<>->foreach->hashes->names->names->add->values->hashes->hashFor->add->cw->new->ModuleHashesAttribute->visitAttribute->return->cw->toByteArray
ModuleInfoExtender#newExtender(InputStream):::Returns an Extender that may be used to add additional attributes to the module-info.class read from the given input stream.:::return->new->ModuleInfoExtender
ModuleInfoWriter#toModuleInfo(ModuleDescriptor, ModuleTarget):::Writes the given module descriptor to a module-info.class file, returning it in a byte array.:::cw->new->ClassWriter->cw->visit->moduleFlags->md->modifiers->stream->MODULE_MODS_TO_FLAGS->get->map->reduce->vs->md->rawVersion->orElse->mv->cw->md->name->visitModule->foreach->md->requires->flags->r->modifiers->stream->REQUIRES_MODS_TO_FLAGS->get->map->reduce->r->rawCompiledVersion->orElse->mv->r->name->visitRequire->foreach->md->exports->flags->e->modifiers->stream->EXPORTS_MODS_TO_FLAGS->get->map->reduce->targets->e->targets->toArray->mv->e->source->replace->visitExport->foreach->md->opens->flags->opens->modifiers->stream->OPENS_MODS_TO_FLAGS->get->map->reduce->targets->opens->targets->toArray->mv->opens->source->replace->visitOpen->md->uses->stream->sn->replace->map->mv->visitUse->forEach->foreach->md->provides->mv->p->service->replace->p->providers->stream->pn->replace->map->String[]->new->toArray->visitProvide->exported->md->exports->stream->ModuleDescriptor.Exports->source->map->open->md->opens->stream->ModuleDescriptor.Opens->source->map->exportedOrOpen->Stream->concat->distinct->count->if->md->packages->size->md->packages->stream->pn->replace->map->mv->visitPackage->forEach->md->mainClass->mc->replace->map->mv->visitMainClass->ifPresent->mv->visitEnd->if->target->targetPlatform->length->cw->target->targetPlatform->new->ModuleTargetAttribute->visitAttribute->cw->visitEnd->return->cw->toByteArray
ModuleInfoWriter#write(ModuleDescriptor, ModuleTarget, OutputStream):::Writes a module descriptor to the given output stream as a module-info.class.:::bytes->toModuleInfo->out->write
ModuleInfoWriter#write(ModuleDescriptor, OutputStream):::Writes a module descriptor to the given output stream as a module-info.class.:::write
ModuleInfoWriter#toByteBuffer(ModuleDescriptor):::Returns a ByteBuffer containing the given module descriptor in module-info.class format.:::bytes->toModuleInfo->return->ByteBuffer->wrap
ModuleLoaderMap.Mapper#apply(String)::: mapper apply:::return->map->get
ModuleLoaderMap#bootModules():::Returns the names of the modules defined to the boot loader.:::BOOT_MODULES->new->StringArr->bootModules->new->HashSet<>->foreach->bootModules->add->return
ModuleLoaderMap#platformModules():::Returns the names of the modules defined to the platform loader.:::PLATFORM_MODULES->new->StringArr->platformModules->new->HashSet<>->foreach->platformModules->add->return
ModuleLoaderMap#mappingFunction(Configuration):::Returns the function to map modules in the given configuration to the built-in class loaders.:::bootModules->bootModules->platformModules->platformModules->platformClassLoader->ClassLoaders->platformClassLoader->appClassLoader->ClassLoaders->appClassLoader->map->new->HashMap<>->foreach->cf->modules->mn->resolvedModule->name->if->bootModules->contains->if->platformModules->contains->map->put->else->map->put->return->new->Mapper
ModulePatcher#patchIfNeeded(ModuleReference):::Returns a module reference that interposes on the given module if needed:::descriptor->mref->descriptor->mn->descriptor->name->paths->map->get->if->return->packages->new->HashSet<>->isAutomatic->descriptor->isAutomatic->try->foreach->if->Files->isRegularFile->try->jf->file->toString->new->JarFile->jf->stream->e->isDirectory->e->getName->endsWith->filter->toPackageName->map->Checks->isPackageName->filter->packages->add->forEach->catch->finally->else->if->Files->isDirectory->top->Files->attrs->isRegularFile->find->path->toString->endsWith->isHidden->filter->toPackageName->map->Checks->isPackageName->filter->packages->add->forEach->catch->throw->new->UncheckedIOException->finally->packages->descriptor->packages->removeAll->if->packages->isEmpty->builder->JLMA->descriptor->name->descriptor->modifiers->newModuleBuilder->if->descriptor->isAutomatic->descriptor->requires->builder->requires->forEach->descriptor->exports->builder->exports->forEach->descriptor->opens->builder->opens->forEach->descriptor->uses->builder->uses->forEach->descriptor->provides->builder->provides->forEach->descriptor->version->builder->version->ifPresent->descriptor->mainClass->builder->mainClass->ifPresent->builder->descriptor->packages->packages->builder->packages->builder->build->location->mref->location->orElse->target->recordedHashes->hasher->mres->if->impl->impl->moduleTarget->impl->recordedHashes->impl->hasher->impl->moduleResolution->return->new->PatchedModuleReader->new->ModuleReferenceImpl
ModulePatcher#hasPatches():::Returns true is this module patcher has patches.:::return->map->isEmpty
ModulePatcher#patchedModules()::: module patcher patched modules:::return->map->keySet
ModulePatcher.PatchedModuleReader#closeAll(List):::Closes all resource finders.:::foreach->try->finder->close->catch->finally
ModulePatcher.PatchedModuleReader#codeSourceURL(ModuleReference):::Returns the code source URL for the given module.:::try->ouri->mref->location->if->ouri->isPresent->return->ouri->get->toURL->catch->finally->return
ModulePatcher.PatchedModuleReader#delegate():::Returns the ModuleReader to delegate to when the resource is not found in a patch location.:::r->if->synchronized->if->mref->open->return
ModulePatcher.PatchedModuleReader#findResourceInPatch(String):::Finds a resources in the patch locations:::if->name->equals->foreach->r->finder->find->if->return->return
ModulePatcher.PatchedModuleReader#findResource(String):::Finds a resource of the given name in the patched module.:::r->findResourceInPatch->if->return->bb->delegate->read->orElse->if->return->return->new->Resource
ModulePatcher.PatchedModuleReader#find(String)::: patched module reader find:::r->findResourceInPatch->if->uri->URI->r->getURL->toString->create->return->Optional->of->else->return->delegate->find
ModulePatcher.PatchedModuleReader#open(String)::: patched module reader open:::r->findResourceInPatch->if->return->Optional->r->getInputStream->of->else->return->delegate->open
ModulePatcher.PatchedModuleReader#read(String)::: patched module reader read:::r->findResourceInPatch->if->bb->r->getByteBuffer->return->Optional->of->else->return->delegate->read
ModulePatcher.PatchedModuleReader#release(ByteBuffer)::: patched module reader release:::if->bb->isDirect->try->delegate->release->catch->throw->new->InternalError->finally
ModulePatcher.PatchedModuleReader#list()::: patched module reader list:::s->delegate->list->foreach->Stream->finder->list->concat->return->s->distinct
ModulePatcher.PatchedModuleReader#close()::: patched module reader close:::closeAll->delegate->close
ModulePatcher.ResourceFinder#find(String)::: resource finder find:::
ModulePatcher.ResourceFinder#list()::: resource finder list:::
ModulePatcher.JarResourceFinder#close()::: jar resource finder close:::jf->close
ModulePatcher.JarResourceFinder#find(String)::: jar resource finder find:::entry->jf->getJarEntry->if->return->return->new->Resource
ModulePatcher.JarResourceFinder#list()::: jar resource finder list:::return->jf->stream->JarEntry->getName->map
ModulePatcher.ExplodedResourceFinder#close()::: exploded resource finder close:::
ModulePatcher.ExplodedResourceFinder#find(String)::: exploded resource finder find:::file->Resources->toFilePath->if->return->newResource->else->return
ModulePatcher.ExplodedResourceFinder#newResource(String, Path, Path)::: exploded resource finder new resource:::return->new->Resource
ModulePatcher.ExplodedResourceFinder#list()::: exploded resource finder list:::return->Files->walk->Resources->toResourceName->map->s->length->filter
ModulePatcher#toPackageName(Path, Path):::Derives a package name from the file path of an entry in an exploded patch:::entry->top->relativize->parent->entry->getParent->if->return->entry->toString->warnIfModuleInfo->else->return->parent->toString->replace
ModulePatcher#isHidden(Path):::Returns true if the given file exists and is a hidden file:::try->return->Files->isHidden->catch->return->finally
ModulePatcher#toPackageName(Path, JarEntry):::Derives a package name from the name of an entry in a JAR file.:::name->entry->getName->index->name->lastIndexOf->if->return->warnIfModuleInfo->else->return->name->substring->replace
ModulePatcher#warnIfModuleInfo(Path, String)::: module patcher warn if module info:::if->e->equals->println->return
ModulePath#of(ModulePatcher, Path...):::Returns a ModuleFinder that locates modules on the file system by searching a sequence of directories and/or packaged modules:::return->JarFile->runtimeVersion->new->ModulePath
ModulePath#of(Path...):::Returns a ModuleFinder that locates modules on the file system by searching a sequence of directories and/or packaged modules.:::return->of
ModulePath#of(Runtime.Version, boolean, Path...):::Returns a ModuleFinder that locates modules on the file system by searching a sequence of directories and/or packaged modules.:::return->new->ModulePath
ModulePath#find(String)::: module path find:::Objects->requireNonNull->m->cachedModules->get->if->return->Optional->of->while->hasNextEntry->scanNextEntry->cachedModules->get->if->return->Optional->of->return->Optional->empty
ModulePath#findAll()::: module path find all:::while->hasNextEntry->scanNextEntry->return->cachedModules->values->stream->Collectors->toSet->collect
ModulePath#hasNextEntry():::Returns true if there are additional entries to scan:::return
ModulePath#scanNextEntry():::Scans the next entry on the module path:::if->hasNextEntry->t0->System->nanoTime->entry->modules->scan->initialSize->cachedModules->size->foreach->modules->entrySet->cachedModules->e->getKey->e->getValue->putIfAbsent->added->cachedModules->size->moduleCount->add->scanTime->addElapsedTimeFrom
ModulePath#scan(Path):::Scan the given module path entry:::attrs->try->Files->readAttributes->catch->return->Map->of->throw->new->FindException->finally->try->if->attrs->isDirectory->mi->entry->resolve->if->Files->exists->return->scanDirectory->mref->readModule->if->name->mref->descriptor->name->return->Map->of->msg->if->entry->toString->endsWith->else->throw->new->FindException->catch->throw->new->FindException->finally
ModulePath#scanDirectory(Path):::Scans the given directory for packaged or exploded modules.:::nameToReference->new->HashMap<>->try->stream->Files->newDirectoryStream->foreach->attrs->try->Files->readAttributes->catch->continue->finally->mref->readModule->if->name->mref->descriptor->name->previous->nameToReference->put->if->fn1->fileName->fn2->fileName->throw->new->FindException->catch->finally->return
ModulePath#readModule(Path, BasicFileAttributes):::Reads a packaged or exploded module, returning a ModuleReference to the module:::try->if->attrs->isDirectory->return->readExplodedModule->if->attrs->isRegularFile->fn->entry->getFileName->toString->isDefaultFileSystem->isDefaultFileSystem->if->fn->endsWith->if->return->readJar->else->tmpdir->Files->createTempDirectory->target->Files->tmpdir->resolve->copy->return->readJar->if->fn->endsWith->return->readJMod->return->catch->throw->new->FindException->finally
ModulePath#fileName(ModuleReference):::Returns a string with the file name of the module if possible:::uri->mref->location->orElse->if->if->uri->getScheme->equalsIgnoreCase->file->Path->of->return->file->getFileName->toString->else->return->uri->toString->else->return
ModulePath#jmodPackages(JmodFile)::: module path jmod packages:::return->jf->stream->e->section->filter->JmodFile.Entry->name->map->this->toPackageName->map->Optional->stream->flatMap->Collectors->toSet->collect
ModulePath#readJMod(Path):::Returns a ModuleReference to a module in JMOD file on the file system.:::try->jf->new->JmodFile->attrs->try->in->jf->getInputStream->ModuleInfo->jmodPackages->read->catch->finally->return->ModuleReferences->newJModModule->catch->finally
ModulePath#toServiceName(String):::Returns the service type corresponding to the name of a services configuration file if it is a legal type name:::index->cf->lastIndexOf->if->cf->length->prefix->cf->substring->if->prefix->equals->sn->cf->substring->if->Checks->isClassName->return->Optional->of->return->Optional->empty
ModulePath#nextLine(BufferedReader):::Reads the next line from the given reader and trims it of comments and leading/trailing white space:::ln->reader->readLine->if->ci->ln->indexOf->if->ln->substring->ln->trim->return
ModulePath#deriveModuleDescriptor(JarFile):::Treat the given JAR file as a module as follows:  1:::man->jf->getManifest->attrs->moduleName->if->man->getMainAttributes->if->attrs->getValue->fn->jf->getName->i->fn->lastIndexOf->if->fn->substring->name->fn->fn->length->substring->vs->matcher->matcher->if->matcher->find->start->matcher->start->try->tail->name->substring->parse->catch->finally->name->substring->builder->if->try->ModuleDescriptor->newAutomaticModule->catch->throw->e->getMessage->new->FindException->finally->else->ModuleDescriptor->cleanModuleName->newAutomaticModule->if->builder->version->map->jf->versionedStream->e->isDirectory->filter->JarEntry->getName->map->e->endsWith->e->startsWith->filter->Collectors->e->startsWith->Collectors->toSet->partitioningBy->collect->classFiles->map->get->configFiles->map->get->packages->classFiles->stream->this->toPackageName->map->Optional->stream->flatMap->distinct->Collectors->toSet->collect->builder->packages->serviceNames->configFiles->stream->this->toServiceName->map->Optional->stream->flatMap->Collectors->toSet->collect->foreach->entry->jf->getJarEntry->providerClasses->new->ArrayList<>->try->in->jf->getInputStream->reader->new->InputStreamReader->new->BufferedReader->cn->while->nextLine->if->cn->length->pn->packageName->if->packages->contains->msg->throw->new->InvalidModuleDescriptorException->providerClasses->add->catch->finally->if->providerClasses->isEmpty->builder->provides->if->mainClass->attrs->getValue->if->mainClass->replace->if->Checks->isClassName->pn->packageName->if->packages->contains->builder->mainClass->return->builder->build
ModulePath#cleanModuleName(String):::Clean up candidate module name derived from a JAR file name.:::matcher->replaceAll->matcher->replaceAll->if->mn->length->mn->charAt->matcher->replaceAll->len->mn->length->if->mn->charAt->matcher->replaceAll->return
ModulePath#jarPackages(JarFile)::: module path jar packages:::return->jf->versionedStream->e->isDirectory->filter->JarEntry->getName->map->this->toPackageName->map->Optional->stream->flatMap->Collectors->toSet->collect
ModulePath#readJar(Path):::Returns a ModuleReference to a module in modular JAR file on the file system.:::try->jf->file->toFile->new->JarFile->attrs->entry->jf->getJarEntry->if->try->md->deriveModuleDescriptor->new->ModuleInfo.Attributes->catch->throw->jf->getName->new->FindException->finally->else->ModuleInfo->jf->getInputStream->jarPackages->read->return->ModuleReferences->newJarModule->catch->throw->new->FindException->finally
ModulePath#explodedPackages(Path)::: module path exploded packages:::try->return->Files->attrs->isRegularFile->isHidden->find->dir->relativize->map->this->toPackageName->map->Optional->stream->flatMap->Collectors->toSet->collect->catch->throw->new->UncheckedIOException->finally
ModulePath#readExplodedModule(Path):::Returns a ModuleReference to an exploded module on the file system or null if module-info.class not found.:::mi->dir->resolve->attrs->try->in->Files->newInputStream->ModuleInfo->new->BufferedInputStream->explodedPackages->read->catch->return->finally->return->ModuleReferences->newExplodedModule
ModulePath#packageName(String):::Maps a type name to its package name.:::index->cn->lastIndexOf->return->cn->substring
ModulePath#toPackageName(String):::Maps the name of an entry in a JAR or ZIP file to a package name.:::index->name->lastIndexOf->if->if->name->endsWith->name->equals->msg->throw->new->InvalidModuleDescriptorException->return->Optional->empty->pn->name->substring->replace->if->Checks->isPackageName->return->Optional->of->else->return->Optional->empty
ModulePath#toPackageName(Path):::Maps the relative path of an entry in an exploded module to a package name.:::parent->file->getParent->if->name->file->toString->if->name->endsWith->name->equals->msg->throw->new->InvalidModuleDescriptorException->return->Optional->empty->pn->parent->toString->replace->if->Checks->isPackageName->return->Optional->of->else->return->Optional->empty
ModulePath#isHidden(Path):::Returns true if the given file exists and is a hidden file:::try->return->Files->isHidden->catch->return->finally
ModulePath#isDefaultFileSystem(Path):::Return true if a path locates a path in the default file system:::return->path->getFileSystem->provider->getScheme->equalsIgnoreCase
ModulePathValidator#scanAllModules(PrintStream):::Scans and the validates all modules on the module path:::validator->new->ModulePathValidator->value->System->getProperty->if->Stream->value->split->of->Path->of->map->validator->scan->forEach->ModuleFinder->ofSystem->findAll->stream->Comparator->ModuleReference->descriptor->comparing->sorted->validator->process->forEach->System->getProperty->if->Stream->value->split->of->Path->of->map->validator->scan->forEach->return
ModulePathValidator#printModule(ModuleReference):::Prints the module location and name.:::mref->location->isJrt->filter->out->print->ifPresent->descriptor->mref->descriptor->out->descriptor->name->print->if->descriptor->isAutomatic->out->print->out->println
ModulePathValidator#process(ModuleReference):::Prints the module location and name, checks if the module is shadowed by a previously seen module, and finally checks for package conflicts with previously seen modules.:::name->mref->descriptor->name->previous->nameToModule->putIfAbsent->if->printModule->out->print->printModule->else->first->foreach->mref->descriptor->packages->packageToModule->putIfAbsent->if->if->printModule->mn->previous->descriptor->name->out->println
ModulePathValidator#scan(Path):::Scan an element on a module path:::attrs->try->Files->readAttributes->catch->return->out->println->return->finally->fn->entry->getFileName->toString->if->attrs->isRegularFile->fn->endsWith->scanModule->this->process->ifPresent->else->if->attrs->isDirectory->mi->entry->resolve->if->Files->exists->scanModule->this->process->ifPresent->else->scanDirectory
ModulePathValidator#scanDirectory(Path):::Scan the JAR files and exploded modules in a directory.:::try->stream->Files->newDirectoryStream->moduleToEntry->new->HashMap<>->foreach->attrs->try->Files->readAttributes->catch->out->println->continue->finally->mref->fn->entry->getFileName->toString->if->attrs->isRegularFile->fn->endsWith->scanModule->orElse->else->if->attrs->isDirectory->mi->entry->resolve->if->Files->exists->scanModule->orElse->if->name->mref->descriptor->name->previous->moduleToEntry->putIfAbsent->if->printModule->out->previous->getFileName->println->else->process->catch->out->println->finally
ModulePathValidator#scanModule(Path):::Scan a JAR file or exploded module.:::finder->ModuleFinder->of->try->return->finder->findAll->stream->findFirst->catch->out->println->out->e->getMessage->println->cause->e->getCause->if->out->println->return->Optional->empty->finally
ModulePathValidator#isJrt(URI):::Returns true if the given URI is a jrt URI:::return->uri->getScheme->equalsIgnoreCase
ModuleReferenceImpl#open()::: module reference impl open:::try->return->readerSupplier->get->catch->throw->e->getCause->finally
ModuleReferenceImpl#isPatched():::Returns true if this module has been patched via --patch-module.:::return
ModuleReferenceImpl#moduleTarget():::Returns the ModuleTarget or null if the no target platform.:::return
ModuleReferenceImpl#recordedHashes():::Returns the hashes recorded in this module or null if there are no hashes recorded.:::return
ModuleReferenceImpl#hasher():::Returns the supplier that computes the hash of this module.:::return
ModuleReferenceImpl#moduleResolution():::Returns the ModuleResolution flags.:::return
ModuleReferenceImpl#computeHash(String):::Computes the hash of this module:::result->if->return->if->return->hasher->generate->return
ModuleReferenceImpl#hashCode()::: module reference impl hash code:::hc->if->descriptor->hashCode->Objects->hashCode->Objects->hashCode->if->return
ModuleReferenceImpl#equals(Object)::: module reference impl equals:::if->return->that->return->Objects->this->descriptor->that->descriptor->equals->Objects->equals->Objects->equals
ModuleReferenceImpl#toString()::: module reference impl to string:::sb->new->StringBuilder->sb->append->sb->descriptor->name->append->sb->append->sb->append->if->isPatched->sb->append->sb->append->return->sb->toString
ModuleReferences#newModule(ModuleInfo.Attributes, URI, Supplier, ModulePatcher, HashSupplier):::Creates a ModuleReference to a possibly-patched module:::mref->attrs->descriptor->attrs->target->attrs->recordedHashes->attrs->moduleResolution->new->ModuleReferenceImpl->if->patcher->patchIfNeeded->return
ModuleReferences#newJarModule(ModuleInfo.Attributes, ModulePatcher, Path):::Creates a ModuleReference to a possibly-patched module in a modular JAR.:::uri->file->toUri->supplier->new->JarModuleReader->hasher->ModuleHashes->computeHash->return->newModule
ModuleReferences#newJModModule(ModuleInfo.Attributes, Path):::Creates a ModuleReference to a module in a JMOD file.:::uri->file->toUri->supplier->new->JModModuleReader->hasher->ModuleHashes->computeHash->return->newModule
ModuleReferences#newExplodedModule(ModuleInfo.Attributes, ModulePatcher, Path):::Creates a ModuleReference to a possibly-patched exploded module.:::supplier->new->ExplodedModuleReader->return->dir->toUri->newModule
ModuleReferences.SafeCloseModuleReader#implFind(String):::Returns a URL to  resource:::
ModuleReferences.SafeCloseModuleReader#implOpen(String):::Returns an input stream for reading a resource:::
ModuleReferences.SafeCloseModuleReader#implList():::Returns a stream of the names of resources in the module:::
ModuleReferences.SafeCloseModuleReader#implClose():::Closes the module reader:::
ModuleReferences.SafeCloseModuleReader#find(String)::: safe close module reader find:::readLock->lock->try->if->return->implFind->else->throw->new->IOException->catch->finally->readLock->unlock
ModuleReferences.SafeCloseModuleReader#open(String)::: safe close module reader open:::readLock->lock->try->if->return->implOpen->else->throw->new->IOException->catch->finally->readLock->unlock
ModuleReferences.SafeCloseModuleReader#list()::: safe close module reader list:::readLock->lock->try->if->return->implList->else->throw->new->IOException->catch->finally->readLock->unlock
ModuleReferences.SafeCloseModuleReader#close()::: safe close module reader close:::writeLock->lock->try->if->implClose->catch->finally->writeLock->unlock
ModuleReferences.JarModuleReader#newJarFile(Path)::: jar module reader new jar file:::try->return->path->toString->new->File->JarFile->runtimeVersion->new->JarFile->catch->throw->new->UncheckedIOException->finally
ModuleReferences.JarModuleReader#getEntry(String)::: jar module reader get entry:::return->jf->Objects->requireNonNull->getJarEntry
ModuleReferences.JarModuleReader#implFind(String)::: jar module reader impl find:::je->getEntry->if->if->jf->isMultiRelease->je->getRealName->if->je->isDirectory->name->endsWith->encodedPath->ParseUtil->encodePath->uris->return->Optional->URI->create->of->else->return->Optional->empty
ModuleReferences.JarModuleReader#implOpen(String)::: jar module reader impl open:::je->getEntry->if->return->Optional->jf->getInputStream->of->else->return->Optional->empty
ModuleReferences.JarModuleReader#implList()::: jar module reader impl list:::names->jf->versionedStream->JarEntry->getName->map->Collectors->toList->collect->return->names->stream
ModuleReferences.JarModuleReader#implClose()::: jar module reader impl close:::jf->close
ModuleReferences.JModModuleReader#newJmodFile(Path)::: mod module reader new jmod file:::try->return->new->JmodFile->catch->throw->new->UncheckedIOException->finally
ModuleReferences.JModModuleReader#getEntry(String)::: mod module reader get entry:::Objects->requireNonNull->return->jf->getEntry
ModuleReferences.JModModuleReader#implFind(String)::: mod module reader impl find:::je->getEntry->if->if->je->isDirectory->name->endsWith->encodedPath->ParseUtil->encodePath->uris->return->Optional->URI->create->of->else->return->Optional->empty
ModuleReferences.JModModuleReader#implOpen(String)::: mod module reader impl open:::je->getEntry->if->return->Optional->jf->getInputStream->of->else->return->Optional->empty
ModuleReferences.JModModuleReader#implList()::: mod module reader impl list:::names->jf->stream->e->section->filter->JmodFile.Entry->name->map->Collectors->toList->collect->return->names->stream
ModuleReferences.JModModuleReader#implClose()::: mod module reader impl close:::jf->close
ModuleReferences.ExplodedModuleReader#ensureOpen():::Throws IOException if the module reader is closed;:::if->throw->new->IOException
ModuleReferences.ExplodedModuleReader#find(String)::: exploded module reader find:::ensureOpen->path->Resources->toFilePath->if->try->return->Optional->path->toUri->of->catch->throw->e->getCause->finally->else->return->Optional->empty
ModuleReferences.ExplodedModuleReader#open(String)::: exploded module reader open:::ensureOpen->path->Resources->toFilePath->if->return->Optional->Files->newInputStream->of->else->return->Optional->empty
ModuleReferences.ExplodedModuleReader#read(String)::: exploded module reader read:::ensureOpen->path->Resources->toFilePath->if->return->Optional->ByteBuffer->Files->readAllBytes->wrap->of->else->return->Optional->empty
ModuleReferences.ExplodedModuleReader#list()::: exploded module reader list:::ensureOpen->return->Files->walk->Resources->toResourceName->map->s->length->filter
ModuleReferences.ExplodedModuleReader#close()::: exploded module reader close:::
ModuleResolution#value()::: module resolution value:::return
ModuleResolution#empty()::: module resolution empty:::return->new->ModuleResolution
ModuleResolution#doNotResolveByDefault()::: module resolution do not resolve by default:::return
ModuleResolution#hasDeprecatedWarning()::: module resolution has deprecated warning:::return
ModuleResolution#hasDeprecatedForRemovalWarning()::: module resolution has deprecated for removal warning:::return
ModuleResolution#hasIncubatingWarning()::: module resolution has incubating warning:::return
ModuleResolution#withDoNotResolveByDefault()::: module resolution with do not resolve by default:::return->new->ModuleResolution
ModuleResolution#withDeprecated()::: module resolution with deprecated:::if->throw->new->InternalError->return->new->ModuleResolution
ModuleResolution#withDeprecatedForRemoval()::: module resolution with deprecated for removal:::if->throw->new->InternalError->return->new->ModuleResolution
ModuleResolution#withIncubating()::: module resolution with incubating:::if->throw->new->InternalError->return->new->ModuleResolution
ModuleResolution#doNotResolveByDefault(ModuleReference)::: module resolution do not resolve by default:::if->mres->moduleResolution->if->return->mres->doNotResolveByDefault->return
ModuleResolution#hasIncubatingWarning(ModuleReference)::: module resolution has incubating warning:::if->mres->moduleResolution->if->return->mres->hasIncubatingWarning->return
ModuleResolution#toString()::: module resolution to string:::return->super->toString
Modules#defineModule(ClassLoader, ModuleDescriptor, URI):::Creates a new Module:::return->JLA->defineModule
Modules#addReads(Module, Module):::Updates m1 to read m2:::JLA->addReads
Modules#addReadsAllUnnamed(Module):::Update module m to read all unnamed modules.:::JLA->addReadsAllUnnamed
Modules#addExports(Module, String, Module):::Updates module m1 to export a package to module m2:::JLA->addExports
Modules#addExportsToAllUnnamed(Module, String):::Updates module m to export a package to all unnamed modules.:::JLA->addExportsToAllUnnamed
Modules#addOpens(Module, String, Module):::Updates module m1 to open a package to module m2:::JLA->addOpens
Modules#addOpensToAllUnnamed(Module, String):::Updates module m to open a package to all unnamed modules.:::JLA->addOpensToAllUnnamed
Modules#addUses(Module, Class):::Updates module m to use a service:::JLA->addUses
Modules#addProvides(Module, Class, Class):::Updates module m to provide a service:::layer->m->getLayer->pa->m->getClassLoader->loader->AccessController->doPrivileged->platformClassLoader->ClassLoaders->platformClassLoader->if->catalog->if->BootLoader->getServicesCatalog->else->ServicesCatalog->getServicesCatalog->catalog->addProvider->if->JLA->getServicesCatalog->addProvider
Modules#transformedByAgent(Module):::Called by the VM when code in the given Module has been transformed by an agent and so may have been instrumented to call into supporting classes on the boot class path or application class path.:::BootLoader->getUnnamedModule->addReads->ClassLoaders->appClassLoader->getUnnamedModule->addReads
Modules#loadModule(String):::Called by the VM to load a system module, typically "java.instrument" or "jdk.management.agent":::top->if->ModuleLayer->boot->module->top->findModule->orElse->if->return->empty->ModuleFinder->of->finder->ModuleBootstrap->unlimitedFinder->roots->Set->of->cf->top->configuration->resolveAndBind->clf->ModuleLoaderMap->mappingFunction->newLayer->top->defineModules->map->newLayer->modules->stream->Collectors->Module->getName->Function->identity->toMap->collect->layer->while->foreach->layer->modules->m->getDescriptor->exports->stream->ModuleDescriptor.Exports->isQualified->filter->e->targets->other->map->get->if->e->source->addExports->forEach->forEach->m->getDescriptor->opens->stream->ModuleDescriptor.Opens->isQualified->filter->o->targets->other->map->get->if->o->source->addOpens->forEach->forEach->parents->layer->parents->parents->isEmpty->parents->get->JLA->addNonExportedPackages->foreach->cf->modules->mref->resolvedModule->reference->mn->mref->descriptor->name->cl->clf->apply->if->BootLoader->loadModule->else->loadModule->return->newLayer->findModule->new->InternalError->orElseThrow
Modules#findLoadedModule(String):::Finds the module with the given name in the boot layer or any child layers created to load the "java.instrument" or "jdk.management.agent" modules into a running VM.:::top->if->ModuleLayer->boot->return->top->findModule
ModuleTarget#targetPlatform()::: module target target platform:::return
Resources#canEncapsulate(String):::Return true if a resource can be encapsulated:::len->name->length->if->name->endsWith->return->else->return->Checks->toPackageName->isPackageName
Resources#toPackageName(String):::Derive a package name for a resource:::index->name->lastIndexOf->if->name->length->return->else->return->name->substring->replace
Resources#toResourceName(Path, Path):::Returns a resource name corresponding to the relative file path between dir and file:::s->dir->relativize->toString->replace->if->s->length->Files->isDirectory->return
Resources#toFilePath(Path, String):::Returns a file path to a resource in a file tree:::expectDirectory->name->endsWith->if->name->name->length->substring->path->dir->getFileSystem->toSafeFilePath->if->file->dir->resolve->try->attrs->Files->readAttributes->if->attrs->isDirectory->attrs->isDirectory->return->catch->finally->return
Resources#toSafeFilePath(FileSystem, String):::Map a resource name to a "safe" file path:::next->off->while->name->indexOf->len->if->mayTranslate->return->rem->name->length->if->mayTranslate->return->path->if->fs->getPath->else->if->name->contains->return->fs->name->replace->getPath->return->path->getRoot
Resources#mayTranslate(String, int, int):::Returns true if the element in a resource name is a candidate to translate to the element of a file path.:::if->if->return->starsWithDot->name->charAt->if->return->if->name->charAt->return->return
ServicesCatalog.ServiceProvider#module()::: service provider module:::return
ServicesCatalog.ServiceProvider#providerName()::: service provider provider name:::return
ServicesCatalog.ServiceProvider#hashCode()::: service provider hash code:::return->Objects->hash
ServicesCatalog.ServiceProvider#equals(Object)::: service provider equals:::if->return->that->return->Objects->equals->Objects->equals
ServicesCatalog#create():::Creates a ServicesCatalog that supports concurrent registration and and lookup:::return->new->ServicesCatalog
ServicesCatalog#providers(String):::Returns the list of service provides for the given service type name, creating it if needed.:::list->map->get->if->new->CopyOnWriteArrayList<>->prev->map->putIfAbsent->if->return
ServicesCatalog#register(Module):::Registers the providers in the given module in this services catalog.:::descriptor->module->getDescriptor->foreach->descriptor->provides->service->provides->service->providerNames->provides->providers->count->providerNames->size->if->pn->providerNames->get->providers->new->ServiceProvider->add->else->list->new->ArrayList<>->foreach->list->new->ServiceProvider->add->providers->addAll
ServicesCatalog#addProvider(Module, Class, Class):::Add a provider in the given module to this services catalog:::list->service->getName->providers->list->impl->getName->new->ServiceProvider->add
ServicesCatalog#findServices(String):::Returns the (possibly empty) list of service providers that implement the given service type.:::return->map->List->of->getOrDefault
ServicesCatalog#getServicesCatalogOrNull(ClassLoader):::Returns the ServicesCatalog for the given class loader or null if there is none.:::return->CLV->get
ServicesCatalog#getServicesCatalog(ClassLoader):::Returns the ServicesCatalog for the given class loader, creating it if needed.:::catalog->CLV->get->if->create->previous->CLV->putIfAbsent->if->return
SystemModuleFinders#allSystemModules():::Returns the SystemModules object to reconstitute all modules:::if->return->SystemModulesMap->allSystemModules->else->return
SystemModuleFinders#systemModules(String):::Returns a SystemModules object to reconstitute the modules for the given initial module:::if->if->return->SystemModulesMap->defaultSystemModules->initialModules->SystemModulesMap->moduleNames->for->i->return
SystemModuleFinders#of(SystemModules):::Returns a ModuleFinder that is backed by the given SystemModules object.:::descriptors->systemModules->moduleDescriptors->targets->systemModules->moduleTargets->recordedHashes->systemModules->moduleHashes->moduleResolutions->systemModules->moduleResolutions->moduleCount->mrefs->new->ModuleReferenceArr->map->new->Map.EntryArr->nameToHash->generateNameToHash->for->i->return->new->SystemModuleFinder
SystemModuleFinders#ofSystem():::Returns the ModuleFinder to find all system modules:::finder->if->return->home->StaticProperty->javaHome->modules->Path->of->if->Files->isRegularFile->if->systemModules->allSystemModules->if->of->if->ofModuleInfos->return->dir->Path->of->if->Files->isDirectory->throw->new->InternalError->f->ModulePath->ModuleBootstrap->patcher->of->return->new->ModuleFinder
SystemModuleFinders#ofModuleInfos():::Parses the module-info.class of all module in the runtime image and returns a ModuleFinder to find the modules.:::nameToAttributes->new->HashMap<>->nameToHash->new->HashMap<>->reader->SystemImage->reader->foreach->reader->getModuleNames->loc->reader->findLocation->attrs->ModuleInfo->reader->getResourceBuffer->read->nameToAttributes->put->hashes->attrs->recordedHashes->if->foreach->hashes->names->nameToHash->hashes->hashFor->computeIfAbsent->mrefs->new->HashSet<>->nameToModule->new->HashMap<>->foreach->nameToAttributes->entrySet->mn->e->getKey->attrs->e->getValue->hashSupplier->hashSupplier->mref->attrs->descriptor->attrs->target->attrs->recordedHashes->attrs->moduleResolution->toModuleReference->mrefs->add->nameToModule->put->return->new->SystemModuleFinder
SystemModuleFinders.SystemModuleFinder#find(String)::: system module finder find:::Objects->requireNonNull->return->Optional->nameToModule->get->ofNullable
SystemModuleFinders.SystemModuleFinder#findAll()::: system module finder find all:::return
SystemModuleFinders#toModuleReference(ModuleDescriptor, ModuleTarget, ModuleHashes, HashSupplier, ModuleResolution):::Creates a ModuleReference to the system module.:::mn->descriptor->name->uri->JNUA->concat->create->readerSupplier->new->Supplier<>->mref->new->ModuleReferenceImpl->ModuleBootstrap->patcher->patchIfNeeded->return
SystemModuleFinders#generateNameToHash(ModuleHashes[]):::Generates a map of module name to hash value.:::nameToHash->secondSeen->foreach->if->if->mh->hashes->else->if->new->HashMap<>->nameToHash->mh->hashes->putAll->return->Map->of
SystemModuleFinders#hashSupplier(Map, String):::Returns a HashSupplier that returns the hash of the given module.:::hash->nameToHash->get->if->return->new->HashSupplier->else->return
SystemModuleFinders.SystemImage#reader()::: system image reader:::return
SystemModuleFinders.SystemModuleReader#checkPermissionToConnect(URI):::If there is a security manager set then check permission to connect to the run-time image.:::sm->System->getSecurityManager->if->try->uc->uri->toURL->openConnection->sm->uc->getPermission->checkPermission->catch->throw->new->UncheckedIOException->finally
SystemModuleFinders.SystemModuleReader#findImageLocation(String):::Returns the ImageLocation for the given resource, null if not found.:::Objects->requireNonNull->if->throw->new->IOException->imageReader->SystemImage->reader->if->return->imageReader->findLocation->else->return
SystemModuleFinders.SystemModuleReader#find(String)::: system module reader find:::location->findImageLocation->if->u->URI->create->return->Optional->of->else->return->Optional->empty
SystemModuleFinders.SystemModuleReader#open(String)::: system module reader open:::return->read->this->toInputStream->map
SystemModuleFinders.SystemModuleReader#toInputStream(ByteBuffer)::: system module reader to input stream:::try->rem->bb->remaining->bytes->new->byteArr->bb->get->return->new->ByteArrayInputStream->catch->finally->release
SystemModuleFinders.SystemModuleReader#read(String)::: system module reader read:::location->findImageLocation->if->return->Optional->SystemImage->reader->getResourceBuffer->of->else->return->Optional->empty
SystemModuleFinders.SystemModuleReader#release(ByteBuffer)::: system module reader release:::Objects->requireNonNull->ImageReader->releaseByteBuffer
SystemModuleFinders.SystemModuleReader#list()::: system module reader list:::if->throw->new->IOException->s->new->ModuleContentSpliterator->return->StreamSupport->stream
SystemModuleFinders.SystemModuleReader#close()::: system module reader close:::
SystemModuleFinders.ModuleContentSpliterator#next():::Returns the name of the next non-directory node or null if there are no remaining nodes to visit.:::for
SystemModuleFinders.ModuleContentSpliterator#tryAdvance(Consumer)::: module content spliterator try advance:::next->try->next->catch->throw->new->UncheckedIOException->finally->if->action->accept->return->else->return
SystemModuleFinders.ModuleContentSpliterator#trySplit()::: module content spliterator try split:::return
SystemModuleFinders.ModuleContentSpliterator#characteristics()::: module content spliterator characteristics:::return
SystemModuleFinders.ModuleContentSpliterator#estimateSize()::: module content spliterator estimate size:::return
SystemModules#hasSplitPackages():::Returns false if the module reconstituted by this SystemModules object have no overlapping packages:::
SystemModules#hasIncubatorModules():::Return false if the modules reconstituted by this SystemModules object do not include any incubator modules:::
SystemModules#moduleDescriptors():::Returns the non-empty array of ModuleDescriptor objects.:::
SystemModules#moduleTargets():::Returns the array of ModuleTarget objects:::
SystemModules#moduleHashes():::Returns the array of ModuleHashes objects:::
SystemModules#moduleResolutions():::Returns the array of ModuleResolution objects:::
SystemModules#moduleReads():::Returns the map representing readability graph for the modules reconstituted by this SystemModules object.:::
SystemModules#concealedPackagesToOpen():::Returns the map of module concealed packages to open:::
SystemModules#exportedPackagesToOpen():::Returns the map of module exported packages to open:::
SystemModulesMap#allSystemModules():::Returns the SystemModules object to reconstitute all modules or null if this is an exploded build.:::return
SystemModulesMap#defaultSystemModules():::Returns the SystemModules object to reconstitute default modules or null if this is an exploded build.:::return
SystemModulesMap#moduleNames():::Returns the array of initial module names identified at link time.:::return->new->StringArr
SystemModulesMap#classNames():::Returns the array of SystemModules class names:::return->new->StringArr
