FileCacheImageInputStream#isCached():::Returns true since this ImageInputStream caches data in order to allow seeking backwards.:::return
FileCacheImageInputStream#isCachedFile():::Returns true since this ImageInputStream maintains a file cache.:::return
FileCacheImageInputStream#isCachedMemory():::Returns false since this ImageInputStream does not maintain a main memory cache.:::return
FileCacheImageInputStream#close():::Closes this FileCacheImageInputStream, closing and removing the cache file:::super->close->disposerRecord->dispose->StreamCloser->removeFromQueue
FileCacheImageOutputStream#seek(long):::Sets the current stream position and resets the bit offset to 0:::checkClosed->if->throw->new->IndexOutOfBoundsException->cache->seek->cache->getFilePointer->Math->max
FileCacheImageOutputStream#isCached():::Returns true since this ImageOutputStream caches data in order to allow seeking backwards.:::return
FileCacheImageOutputStream#isCachedFile():::Returns true since this ImageOutputStream maintains a file cache.:::return
FileCacheImageOutputStream#isCachedMemory():::Returns false since this ImageOutputStream does not maintain a main memory cache.:::return
FileCacheImageOutputStream#close():::Closes this FileCacheImageOutputStream:::cache->length->seek->flushBefore->super->close->cache->close->cacheFile->delete->stream->flush->StreamCloser->removeFromQueue
FileImageInputStream#length():::Returns the length of the underlying file, or -1 if it is unknown.:::try->checkClosed->return->raf->length->catch->return->finally
FileImageOutputStream#seek(long):::Sets the current stream position and resets the bit offset to 0:::checkClosed->if->throw->new->IndexOutOfBoundsException->raf->seek->raf->getFilePointer
IIOByteBuffer#getData():::Returns a reference to the byte array:::return
IIOByteBuffer#setData(byte[]):::Updates the array reference that will be returned by subsequent calls to the getData method.:::
IIOByteBuffer#getOffset():::Returns the offset within the byte array returned by getData at which the data of interest start.:::return
IIOByteBuffer#setOffset(int):::Updates the value that will be returned by subsequent calls to the getOffset method.:::
IIOByteBuffer#getLength():::Returns the length of the data of interest within the byte array returned by getData.:::return
IIOByteBuffer#setLength(int):::Updates the value that will be returned by subsequent calls to the getLength method.:::
ImageInputStream#setByteOrder(ByteOrder):::Sets the desired byte order for future reads of data values from this stream:::
ImageInputStream#getByteOrder():::Returns the byte order with which data values will be read from this stream as an instance of the java.nio.ByteOrder enumeration.:::
ImageInputStream#read():::Reads a single byte from the stream and returns it as an integer between 0 and 255:::
ImageInputStream#read(byte[]):::Reads up to b.length bytes from the stream, and stores them into b starting at index 0:::
ImageInputStream#read(byte[], int, int):::Reads up to len bytes from the stream, and stores them into b starting at index off:::
ImageInputStream#readBytes(IIOByteBuffer, int):::Reads up to len bytes from the stream, and modifies the supplied IIOByteBuffer to indicate the byte array, offset, and length where the data may be found:::
ImageInputStream#readBoolean():::Reads a byte from the stream and returns a boolean value of true if it is nonzero, false if it is zero:::
ImageInputStream#readByte():::Reads a byte from the stream and returns it as a byte value:::
ImageInputStream#readUnsignedByte():::Reads a byte from the stream, and (conceptually) converts it to an int, masks it with 0xff in order to strip off any sign-extension bits, and returns it as a byte value:::
ImageInputStream#readShort():::Reads two bytes from the stream, and (conceptually) concatenates them according to the current byte order, and returns the result as a short value:::
ImageInputStream#readUnsignedShort():::Reads two bytes from the stream, and (conceptually) concatenates them according to the current byte order, converts the resulting value to an int, masks it with 0xffff in order to strip off any sign-extension buts, and returns the result as an unsigned int value:::
ImageInputStream#readChar():::Equivalent to readUnsignedShort, except that the result is returned using the char datatype:::
ImageInputStream#readInt():::Reads 4 bytes from the stream, and (conceptually) concatenates them according to the current byte order and returns the result as an int:::
ImageInputStream#readUnsignedInt():::Reads 4 bytes from the stream, and (conceptually) concatenates them according to the current byte order, converts the result to a long, masks it with 0xffffffffL in order to strip off any sign-extension bits, and returns the result as an unsigned long value:::
ImageInputStream#readLong():::Reads 8 bytes from the stream, and (conceptually) concatenates them according to the current byte order and returns the result as a long:::
ImageInputStream#readFloat():::Reads 4 bytes from the stream, and (conceptually) concatenates them according to the current byte order and returns the result as a float:::
ImageInputStream#readDouble():::Reads 8 bytes from the stream, and (conceptually) concatenates them according to the current byte order and returns the result as a double:::
ImageInputStream#readLine():::Reads the next line of text from the input stream:::
ImageInputStream#readUTF():::Reads in a string that has been encoded using a modified UTF-8 format:::
ImageInputStream#readFully(byte[], int, int):::Reads len bytes from the stream, and stores them into b starting at index off:::
ImageInputStream#readFully(byte[]):::Reads b.length bytes from the stream, and stores them into b starting at index 0:::
ImageInputStream#readFully(short[], int, int):::Reads len shorts (signed 16-bit integers) from the stream according to the current byte order, and stores them into s starting at index off:::
ImageInputStream#readFully(char[], int, int):::Reads len chars (unsigned 16-bit integers) from the stream according to the current byte order, and stores them into c starting at index off:::
ImageInputStream#readFully(int[], int, int):::Reads len ints (signed 32-bit integers) from the stream according to the current byte order, and stores them into i starting at index off:::
ImageInputStream#readFully(long[], int, int):::Reads len longs (signed 64-bit integers) from the stream according to the current byte order, and stores them into l starting at index off:::
ImageInputStream#readFully(float[], int, int):::Reads len floats (32-bit IEEE single-precision floats) from the stream according to the current byte order, and stores them into f starting at index off:::
ImageInputStream#readFully(double[], int, int):::Reads len doubles (64-bit IEEE double-precision floats) from the stream according to the current byte order, and stores them into d starting at index off:::
ImageInputStream#getStreamPosition():::Returns the current byte position of the stream:::
ImageInputStream#getBitOffset():::Returns the current bit offset, as an integer between 0 and 7, inclusive:::
ImageInputStream#setBitOffset(int):::Sets the bit offset to an integer between 0 and 7, inclusive:::
ImageInputStream#readBit():::Reads a single bit from the stream and returns it as an int with the value 0 or 1:::
ImageInputStream#readBits(int):::Reads a bitstring from the stream and returns it as a long, with the first bit read becoming the most significant bit of the output:::
ImageInputStream#length():::Returns the total length of the stream, if known:::
ImageInputStream#skipBytes(int):::Moves the stream position forward by a given number of bytes:::
ImageInputStream#skipBytes(long):::Moves the stream position forward by a given number of bytes:::
ImageInputStream#seek(long):::Sets the current stream position to the desired location:::
ImageInputStream#mark():::Marks a position in the stream to be returned to by a subsequent call to reset:::
ImageInputStream#reset():::Returns the stream pointer to its previous position, including the bit offset, at the time of the most recent unmatched call to mark:::
ImageInputStream#flushBefore(long):::Discards the initial portion of the stream prior to the indicated position:::
ImageInputStream#flush():::Discards the initial position of the stream prior to the current stream position:::
ImageInputStream#getFlushedPosition():::Returns the earliest position in the stream to which seeking may be performed:::
ImageInputStream#isCached():::Returns true if this ImageInputStream caches data itself in order to allow seeking backwards:::
ImageInputStream#isCachedMemory():::Returns true if this ImageInputStream caches data itself in order to allow seeking backwards, and the cache is kept in main memory:::
ImageInputStream#isCachedFile():::Returns true if this ImageInputStream caches data itself in order to allow seeking backwards, and the cache is kept in a temporary file:::
ImageInputStream#close():::Closes the stream:::
ImageInputStreamImpl#checkClosed():::Throws an IOException if the stream has been closed:::if->throw->new->IOException
ImageInputStreamImpl#read():::Reads a single byte from the stream and returns it as an int between 0 and 255:::
ImageInputStreamImpl#read(byte[]):::A convenience method that calls read(b, 0, b.length):::return->read
ImageInputStreamImpl#read(byte[], int, int):::Reads up to len bytes from the stream, and stores them into b starting at index off:::
ImageInputStreamImpl#length():::Returns -1L to indicate that the stream has unknown length:::return
ImageInputStreamImpl#skipBytes(int):::Advances the current stream position by calling seek(getStreamPosition() + n):::pos->getStreamPosition->seek->return->getStreamPosition
ImageInputStreamImpl#skipBytes(long):::Advances the current stream position by calling seek(getStreamPosition() + n):::pos->getStreamPosition->seek->return->getStreamPosition
ImageInputStreamImpl#mark():::Pushes the current stream position onto a stack of marked positions.:::try->markByteStack->Long->getStreamPosition->valueOf->push->markBitStack->Integer->getBitOffset->valueOf->push->catch->finally
ImageInputStreamImpl#reset():::Resets the current stream byte and bit positions from the stack of marked positions:::if->markByteStack->empty->return->pos->markByteStack->pop->longValue->if->throw->new->IIOException->seek->offset->markBitStack->pop->intValue->setBitOffset
ImageInputStreamImpl#isCached():::Default implementation returns false:::return
ImageInputStreamImpl#isCachedMemory():::Default implementation returns false:::return
ImageInputStreamImpl#isCachedFile():::Default implementation returns false:::return
ImageInputStreamImpl#finalize():::Finalizes this object prior to garbage collection:::if->try->close->catch->finally->super->finalize
ImageOutputStream#write(int):::Writes a single byte to the stream at the current position:::
ImageOutputStream#write(byte[]):::Writes a sequence of bytes to the stream at the current position:::
ImageOutputStream#write(byte[], int, int):::Writes a sequence of bytes to the stream at the current position:::
ImageOutputStream#writeBoolean(boolean):::Writes a boolean value to the stream:::
ImageOutputStream#writeByte(int):::Writes the 8 low-order bits of v to the stream:::
ImageOutputStream#writeShort(int):::Writes the 16 low-order bits of v to the stream:::
ImageOutputStream#writeChar(int):::This method is a synonym for #writeShort writeShort.:::
ImageOutputStream#writeInt(int):::Writes the 32 bits of v to the stream:::
ImageOutputStream#writeLong(long):::Writes the 64 bits of v to the stream:::
ImageOutputStream#writeFloat(float):::Writes a float value, which is comprised of four bytes, to the output stream:::
ImageOutputStream#writeDouble(double):::Writes a double value, which is comprised of four bytes, to the output stream:::
ImageOutputStream#writeBytes(String):::Writes a string to the output stream:::
ImageOutputStream#writeChars(String):::Writes a string to the output stream:::
ImageOutputStream#writeUTF(String):::Writes two bytes of length information to the output stream in network byte order, followed by the modified UTF-8 representation of every character in the string s:::
ImageOutputStream#writeShorts(short[], int, int):::Writes a sequence of shorts to the stream at the current position:::
ImageOutputStream#writeChars(char[], int, int):::Writes a sequence of chars to the stream at the current position:::
ImageOutputStream#writeInts(int[], int, int):::Writes a sequence of ints to the stream at the current position:::
ImageOutputStream#writeLongs(long[], int, int):::Writes a sequence of longs to the stream at the current position:::
ImageOutputStream#writeFloats(float[], int, int):::Writes a sequence of floats to the stream at the current position:::
ImageOutputStream#writeDoubles(double[], int, int):::Writes a sequence of doubles to the stream at the current position:::
ImageOutputStream#writeBit(int):::Writes a single bit, given by the least significant bit of the argument, to the stream at the current bit offset within the current byte position:::
ImageOutputStream#writeBits(long, int):::Writes a sequence of bits, given by the numBits least significant bits of the bits argument in left-to-right order, to the stream at the current bit offset within the current byte position:::
ImageOutputStream#flushBefore(long):::Flushes all data prior to the given position to the underlying destination, such as an OutputStream or File:::
ImageOutputStreamImpl#flushBits():::If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one:::checkClosed->if->offset->partialByte->read->if->else->getStreamPosition->seek->write
MemoryCache#loadFromStream(InputStream, long):::Ensures that at least pos bytes are cached, or the end of the source is reached:::if->return->offset->buf->len->if->getCacheBlock->while->if->try->new->byteArr->catch->throw->new->IOException->finally->left->nbytes->Math->min->stream->read->if->return->if->cache->add->if->return
MemoryCache#writeToStream(OutputStream, long, long):::Writes out a portion of the cache to an OutputStream:::if->throw->new->IndexOutOfBoundsException->if->throw->new->IndexOutOfBoundsException->if->return->bufIndex->if->throw->new->IndexOutOfBoundsException->offset->buf->getCacheBlock->while->if->getCacheBlock->nbytes->Math->min->stream->write
MemoryCache#write(byte[], int, int, long):::Overwrites and/or appends the cache from a byte array:::if->throw->new->NullPointerException->if->throw->new->IndexOutOfBoundsException->lastPos->if->pad->offset->while->buf->getCacheBlock->nbytes->Math->min->System->arraycopy
MemoryCache#write(int, long):::Overwrites or appends a single byte to the cache:::if->throw->new->ArrayIndexOutOfBoundsException->if->pad->buf->getCacheBlock->offset
MemoryCache#getLength():::Returns the total length of data that has been cached, regardless of whether any early blocks have been disposed:::return
MemoryCache#read(long):::Returns the single byte at the given position, as an int:::if->return->buf->getCacheBlock->if->return->return
MemoryCache#read(byte[], int, int, long):::Copy len bytes from the cache, starting at cache position pos, into the array b at offset off.:::if->throw->new->NullPointerException->if->throw->new->IndexOutOfBoundsException->if->throw->new->IndexOutOfBoundsException->index->offset->while->nbytes->Math->min->buf->getCacheBlock->System->arraycopy
MemoryCache#disposeBefore(long):::Free the blocks up to the position pos:::index->if->throw->new->IndexOutOfBoundsException->numBlocks->Math->cache->size->min->for->i
MemoryCache#reset():::Erase the entire cache contents and reset the length to 0:::cache->clear
MemoryCacheImageInputStream#isCached():::Returns true since this ImageInputStream caches data in order to allow seeking backwards.:::return
MemoryCacheImageInputStream#isCachedFile():::Returns false since this ImageInputStream does not maintain a file cache.:::return
MemoryCacheImageInputStream#isCachedMemory():::Returns true since this ImageInputStream maintains a main memory cache.:::return
MemoryCacheImageInputStream#close():::Closes this MemoryCacheImageInputStream, freeing the cache:::super->close->disposerRecord->dispose
MemoryCacheImageOutputStream#isCached():::Returns true since this ImageOutputStream caches data in order to allow seeking backwards.:::return
MemoryCacheImageOutputStream#isCachedFile():::Returns false since this ImageOutputStream does not maintain a file cache.:::return
MemoryCacheImageOutputStream#isCachedMemory():::Returns true since this ImageOutputStream maintains a main memory cache.:::return
MemoryCacheImageOutputStream#close():::Closes this MemoryCacheImageOutputStream:::length->cache->getLength->seek->flushBefore->super->close->cache->reset
