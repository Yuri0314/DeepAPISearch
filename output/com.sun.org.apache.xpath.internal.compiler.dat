Compiler#compileExpression(int):::Execute the XPath object from a given opcode position:::try->return->compile->catch->new->ObjectArr->error->finally->return
Compiler#compile(int):::This method handles the actual compilation process:::op->getOp->expr->switch->compile->break->or->break->and->break->notequals->break->equals->break->lte->break->lt->break->gte->break->gt->break->plus->break->minus->break->mult->break->div->break->mod->break->neg->break->string->break->bool->break->number->break->union->break->literal->break->variable->break->group->break->numberlit->break->arg->break->compileExtension->break->compileFunction->break->locationPath->break->break->matchPattern->break->locationPathPattern->break->new->ObjectArr->error->break->new->ObjectArr->Integer->getOp->toString->error->return
Compiler#compileOperation(Operation, int):::Bottle-neck compilation of an operation with left and right operands.:::leftPos->getFirstChildPos->rightPos->getNextOpPos->operation->compile->compile->setLeftRight->return
Compiler#compileUnary(UnaryOperation, int):::Bottle-neck compilation of a unary operation.:::rightPos->getFirstChildPos->unary->compile->setRight->return
Compiler#or(int):::Compile an 'or' operation.:::return->new->Or->compileOperation
Compiler#and(int):::Compile an 'and' operation.:::return->new->And->compileOperation
Compiler#notequals(int):::Compile a '!=' operation.:::return->new->NotEquals->compileOperation
Compiler#equals(int):::Compile a '=' operation.:::return->new->Equals->compileOperation
Compiler#lte(int):::Compile a '<=' operation.:::return->new->Lte->compileOperation
Compiler#lt(int):::Compile a '<' operation.:::return->new->Lt->compileOperation
Compiler#gte(int):::Compile a '>=' operation.:::return->new->Gte->compileOperation
Compiler#gt(int):::Compile a '>' operation.:::return->new->Gt->compileOperation
Compiler#plus(int):::Compile a '+' operation.:::return->new->Plus->compileOperation
Compiler#minus(int):::Compile a '-' operation.:::return->new->Minus->compileOperation
Compiler#mult(int):::Compile a '*' operation.:::return->new->Mult->compileOperation
Compiler#div(int):::Compile a 'div' operation.:::return->new->Div->compileOperation
Compiler#mod(int):::Compile a 'mod' operation.:::return->new->Mod->compileOperation
Compiler#neg(int):::Compile a unary '-' operation.:::return->new->Neg->compileUnary
Compiler#string(int):::Compile a 'string(...)' operation.:::return->new->com.sun.org.apache.xpath.internal.operations.String->compileUnary
Compiler#bool(int):::Compile a 'boolean(...)' operation.:::return->new->com.sun.org.apache.xpath.internal.operations.Bool->compileUnary
Compiler#number(int):::Compile a 'number(...)' operation.:::return->new->com.sun.org.apache.xpath.internal.operations.Number->compileUnary
Compiler#literal(int):::Compile a literal string value.:::getFirstChildPos->return->getTokenQueue->getOp->elementAt
Compiler#numberlit(int):::Compile a literal number value.:::getFirstChildPos->return->getTokenQueue->getOp->elementAt
Compiler#variable(int):::Compile a variable reference.:::var->new->Variable->getFirstChildPos->nsPos->getOp->namespace->getTokenQueue->elementAt->localname->getTokenQueue->getOp->elementAt->qname->new->QName->var->setQName->return
Compiler#group(int):::Compile an expression group.:::return->compile
Compiler#arg(int):::Compile a function argument.:::return->compile
Compiler#union(int):::Compile a location path union:::try->return->UnionPathIterator->createUnionIterator->catch->finally
Compiler#getLocationPathDepth():::Get the level of the location path or union being constructed.:::return
Compiler#getFunctionTable():::Get the function table:::return
Compiler#locationPath(int):::Compile a location path:::try->iter->WalkerFactory->newDTMIterator->return->catch->finally
Compiler#predicate(int):::Compile a location step predicate expression.:::return->compile
Compiler#matchPattern(int):::Compile an entire match pattern expression.:::try->nextOpPos->i->for->getOp->if->return->compile->up->new->UnionPattern->patterns->new->StepPatternArr->for->getOp->up->setPatterns->return->catch->finally
Compiler#locationPathPattern(int):::Compile a location match pattern unit expression.:::getFirstChildPos->return->stepPattern
Compiler#getWhatToShow(int):::Get a org.w3c.dom.traversal.NodeFilter bit set that tells what to show for a given node test.:::axesType->getOp->testType->getOp->switch->return->return->return->switch->return->return->return->if->getOp->return->else->return->return->return->switch->return->return->return->return->return
Compiler#stepPattern(int, int, StepPattern):::Compile a step pattern unit expression, used for both location paths and match patterns.:::startOpPos->stepType->getOp->if->return->addMagicSelf->endStep->getNextOpPos->pattern->argLen->switch->if->println->getOp->compileFunction->new->FunctionPattern->break->if->println->getArgLengthOfStep->getFirstChildPosOfStep->new->StepPattern->break->if->getStepLocalName->println->getArgLengthOfStep->getFirstChildPosOfStep->getStepNS->getStepLocalName->new->StepPattern->break->if->getStepLocalName->println->getArgLengthOfStep->getFirstChildPosOfStep->what->getWhatToShow->if->getWhatToShow->getStepNS->getStepLocalName->new->StepPattern->break->if->getStepLocalName->println->getArgLengthOfStep->getFirstChildPosOfStep->getWhatToShow->getStepNS->getStepLocalName->new->StepPattern->break->error->return->pattern->getCompiledPredicates->setPredicates->if->else->pattern->setRelativePathPattern->relativePathPattern->stepPattern->return
Compiler#getCompiledPredicates(int):::Compile a zero or more predicates for a given match pattern.:::count->countPredicates->if->predicates->new->ExpressionArr->compilePredicates->return->return
Compiler#countPredicates(int):::Count the number of predicates in the step.:::count->while->getOp->getNextOpPos->return
Compiler#compilePredicates(int, Expression[]):::Compiles predicates in the step.:::for->i->getOp
Compiler#compileFunction(int):::Compile a built-in XPath function.:::endFunc->getOp->getFirstChildPos->funcID->getOp->if->func->m_functionTable->getFunction->if->setFunctionTable->func->postCompileStep->try->i->for->p->getNextOpPos->func->checkNumberArgs->catch->name->m_functionTable->getFunctionName->m_errorHandler->XSLMessages->new->ObjectArr->wnae->getMessage->createXPATHMessage->new->TransformerException->fatalError->finally->return->else->error->return
Compiler#getNextMethodId():::Get the next available method id:::if->return
Compiler#compileExtension(int):::Compile an extension function.:::endExtFunc->getOp->getFirstChildPos->ns->getTokenQueue->getOp->elementAt->funcName->getTokenQueue->getOp->elementAt->extension->String->getNextMethodId->valueOf->new->FuncExtFunction->try->i->while->nextOpPos->getNextOpPos->extension->this->compile->setArg->catch->finally->return
Compiler#warn(String, Object[]):::Warn the user of an problem.:::fmsg->XSLMessages->createXPATHWarning->if->m_errorHandler->new->TransformerException->warning->else->m_locator->getSystemId->m_locator->getLineNumber->m_locator->getColumnNumber->println
Compiler#assertion(boolean, java.lang.String):::Tell the user of an assertion error, and probably throw an exception.:::if->fMsg->XSLMessages->new->ObjectArr->createXPATHMessage->throw->new->RuntimeException
Compiler#error(String, Object[]):::Tell the user of an error, and probably throw an exception.:::fmsg->XSLMessages->createXPATHMessage->if->m_errorHandler->new->TransformerException->fatalError->else->throw->new->TransformerException
Compiler#getNamespaceContext():::Get the current namespace context for the xpath.:::return
Compiler#setNamespaceContext(PrefixResolver):::Set the current namespace context for the xpath.:::
FuncLoader#getName():::Get the local class name of the function class:::return
FuncLoader#getFunction():::Get a Function instance that this instance is liaisoning for.:::try->className->if->className->indexOf->subString->className->className->lastIndexOf->substring->if->subString->equals->subString->equals->throw->new->TransformerException->return->ObjectFactory->newInstance->catch->throw->e->getException->new->TransformerException->finally
FunctionTable#getFunctionName(int):::Return the name of the a function in the static table:::if->return->getName->else->return->getName
FunctionTable#getFunction(int):::Obtain a new Function object from a function ID.:::try->if->return->getConstructor->newInstance->else->c->return->c->getConstructor->newInstance->catch->throw->ex->getMessage->new->TransformerException->finally
FunctionTable#getFunctionID(String):::Obtain a function ID from a given function name:::id->m_functionID_customer->get->if->m_functionID->get->return
FunctionTable#installFunction(String, Class):::Install a built-in function.:::funcIndex->funcIndexObj->getFunctionID->if->isAssignableFrom->throw->func->getName->getName->new->ClassCastException->if->if->m_functionID_customer->put->else->m_functionID_customer->put->return
FunctionTable#functionAvailable(String):::Tell if a built-in, non-namespaced function is available.:::tblEntry->m_functionID->get->if->return->else->m_functionID_customer->get->return
Keywords#getAxisName(String)::: keywords get axis name:::return->m_axisnames->get
Keywords#lookupNodeTest(String)::: keywords lookup node test:::return->m_nodetests->get
Keywords#getKeyWord(String)::: keywords get key word:::return->m_keywords->get
Keywords#getNodeType(String)::: keywords get node type:::return->m_nodetypes->get
Lexer#tokenize(String):::Walk through the expression and build a token queue, and a map of the top-level elements.:::tokenize
Lexer#tokenize(String, List):::Walk through the expression and build a token queue, and a map of the top-level elements.:::new->OpMapVector->nChars->pat->length->startSubstring->posOfNSSep->isStartOfPat->isAttrName->isNum->nesting->for->i->if->mapPatternElemPos->if->m_namespaceContext->handlesNullPrefixes->mapNSTokens->else->pat->substring->addToTokenQueue->if->m_compiler->getTokenQueueSize->m_processor->error->else->if->recordTokenString
Lexer#mapPatternElemPos(int, boolean, boolean):::Record the current position on the token queue as long as this is a top-level element:::if->if->patternMap->len->new->intArr->System->arraycopy->if->m_compiler->getTokenQueueSize->return
Lexer#getTokenQueuePosFromMap(int):::Given a map pos, return the corresponding token queue pos.:::pos->return
Lexer#resetTokenMark(int):::Reset token queue mark and m_token to a given position.:::qsz->m_compiler->getTokenQueueSize->if->m_compiler->getTokenQueue->elementAt->charAt->else
Lexer#getKeywordToken(String):::Given a string, return the corresponding keyword token.:::tok->try->itok->Keywords->getKeyWord->itok->intValue->catch->finally->return
Lexer#recordTokenString(List):::Record the current token in the passed vector.:::tokPos->getTokenQueuePosFromMap->resetTokenMark->if->m_processor->lookahead->tok->getKeywordToken->switch->targetStrings->add->break->targetStrings->add->break->targetStrings->add->break->targetStrings->add->break->targetStrings->add->break->targetStrings->add->break->targetStrings->add->else->if->m_processor->tokenIs->resetTokenMark->if->m_processor->lookahead->targetStrings->m_compiler->getTokenQueue->elementAt->add
Lexer#addToTokenQueue(String):::Add a token to the token queue.:::m_compiler->getTokenQueue->addElement
Lexer#mapNSTokens(String, int, int, int):::When a seperator token is found, see if there's a element name or the like to map.:::prefix->if->pat->substring->uName->if->prefix->equals->prefix->equals->try->if->prefix->length->m_namespaceContext->getNamespaceForPrefix->else->if->addToTokenQueue->s->pat->substring->if->s->length->addToTokenQueue->return->else->m_namespaceContext->getNamespaceForPrefix->catch->m_namespaceContext->getNamespaceForPrefix->finally->else->if->uName->length->addToTokenQueue->addToTokenQueue->s->pat->substring->if->s->length->addToTokenQueue->else->m_processor->new->StringArr->error->return
OpMap#toString():::Return the expression as a string for diagnostics.:::return
OpMap#getPatternString():::Return the expression as a string for diagnostics.:::return
OpMap#getTokenQueue():::Get the XPath as a list of tokens.:::return
OpMap#getToken(int):::Get the XPath as a list of tokens.:::return->m_tokenQueue->elementAt
OpMap#getTokenQueueSize():::Get size of the token queue.:::return->m_tokenQueue->size
OpMap#getOpMap():::Get the opcode list that describes the XPath operations:::return
OpMap#shrink():::Replace the large arrays with a small array.:::n->m_opMap->elementAt->m_opMap->setToSize->m_opMap->setElementAt->m_opMap->setElementAt->m_opMap->setElementAt->m_tokenQueue->size->m_tokenQueue->setToSize->m_tokenQueue->setElementAt->m_tokenQueue->setElementAt->m_tokenQueue->setElementAt
OpMap#getOp(int):::Given an operation position, return the current op.:::return->m_opMap->elementAt
OpMap#setOp(int, int):::Set the op at index to the given int.:::m_opMap->setElementAt
OpMap#getNextOpPos(int):::Given an operation position, return the end position, i.e:::return->m_opMap->elementAt
OpMap#getNextStepPos(int):::Given a location step position, return the end position, i.e:::stepType->getOp->if->return->getNextOpPos->else->if->newOpPos->getNextOpPos->while->getOp->getNextOpPos->getOp->if->return->return->else->throw->XSLMessages->new->ObjectArr->String->valueOf->createXPATHMessage->new->RuntimeException
OpMap#getNextOpPos(int[], int):::Given an operation position, return the end position, i.e:::return
OpMap#getFirstPredicateOpPos(int):::Given an FROM_stepType position, return the position of the first predicate, if there is one, or else this will point to the end of the FROM_stepType:::stepType->m_opMap->elementAt->if->return->m_opMap->elementAt->else->if->return->m_opMap->elementAt->else->if->return->else->new->ObjectArr->String->valueOf->error->return
OpMap#error(String, Object[]):::Tell the user of an error, and probably throw an exception.:::fmsg->createXPATHMessage->throw->new->javax.xml.transform.TransformerException
OpMap#getFirstChildPos(int):::Go to the first child of a given operation.:::return
OpMap#getArgLength(int):::Get the length of an operation.:::return->m_opMap->elementAt
OpMap#getArgLengthOfStep(int):::Given a location step, get the length of that step.:::return->m_opMap->elementAt
OpMap#getFirstChildPosOfStep(int):::Get the first child position of a given location step.:::return
OpMap#getStepTestType(int):::Get the test type of the step, i.e:::return->m_opMap->elementAt
OpMap#getStepNS(int):::Get the namespace of the step.:::argLenOfStep->getArgLengthOfStep->if->index->m_opMap->elementAt->if->return->m_tokenQueue->elementAt->else->if->return->else->return->else->return
OpMap#getStepLocalName(int):::Get the local name of the step.:::argLenOfStep->getArgLengthOfStep->index->switch->break->break->m_opMap->elementAt->break->m_opMap->elementAt->break->break->if->return->m_tokenQueue->elementAt->toString->else->if->return->else->return
OpMapVector#elementAt(int):::Get the nth element.:::return
OpMapVector#setElementAt(int, int):::Sets the component at the specified index of this vector to be the specified object:::if->oldSize->newMap->new->intArr->System->arraycopy
OpMapVector#setToSize(int)::: op map vector set to size:::newMap->new->intArr->System->arraycopy
XPathParser#initXPath(Compiler, String, PrefixResolver):::Given an string, init an XPath object for selections, in order that a parse doesn't have to be done each time the expression is evaluated.:::compiler->getFunctionTable->lexer->new->Lexer->lexer->tokenize->m_ops->setOp->m_ops->setOp->try->nextToken->Expr->if->extraTokens->while->nextToken->if->new->ObjectArr->error->catch->if->CONTINUE_AFTER_FATAL_ERROR->e->getMessage->equals->initXPath->else->throw->new->ObjectArr->error->finally->compiler->shrink
XPathParser#initMatchPattern(Compiler, String, PrefixResolver):::Given an string, init an XPath object for pattern matches, in order that a parse doesn't have to be done each time the expression is evaluated.:::compiler->getFunctionTable->lexer->new->Lexer->lexer->tokenize->m_ops->setOp->m_ops->setOp->nextToken->try->Pattern->catch->new->ObjectArr->error->finally->if->extraTokens->while->nextToken->if->new->ObjectArr->error->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->shrink
XPathParser#setErrorHandler(ErrorListener):::Allow an application to register an error event handler, where syntax errors will be sent:::
XPathParser#getErrorListener():::Return the current error listener.:::return
XPathParser#tokenIs(String):::Check whether m_token matches the target string.:::return->m_token->equals
XPathParser#tokenIs(char):::Check whether m_tokenChar==c.:::return
XPathParser#lookahead(char, int):::Look ahead of the current token in order to make a branching decision.:::pos->b->if->m_ops->getTokenQueueSize->m_ops->getTokenQueueSize->tok->elementAt->tok->length->tok->charAt->else->return
XPathParser#lookbehind(char, int):::Look behind the first character of the current token in order to make a branching decision.:::isToken->lookBehindPos->if->lookbehind->elementAt->if->lookbehind->length->c0->lookbehind->charAt->else->else->return
XPathParser#lookbehindHasToken(int):::look behind the current token in order to see if there is a useable token.:::hasToken->if->lookbehind->elementAt->c0->lookbehind->charAt->else->return
XPathParser#lookahead(String, int):::Look ahead of the current token in order to make a branching decision.:::isToken->if->m_ops->getTokenQueueSize->lookahead->elementAt->lookahead->equals->else->return
XPathParser#nextToken():::Retrieve the next token from the command and store it in m_token string.:::if->m_ops->getTokenQueueSize->elementAt->m_token->charAt->else
XPathParser#getTokenRelative(int):::Retrieve a token relative to the current token.:::tok->relative->if->m_ops->getTokenQueueSize->elementAt->else->return
XPathParser#prevToken():::Retrieve the previous token from the command and store it in m_token string.:::if->elementAt->m_token->charAt->else
XPathParser#consumeExpected(String):::Consume an expected token, throwing an exception if it isn't there.:::if->tokenIs->nextToken->else->new->ObjectArr->error->throw->new->XPathProcessorException
XPathParser#consumeExpected(char):::Consume an expected token, throwing an exception if it isn't there.:::if->tokenIs->nextToken->else->new->ObjectArr->String->valueOf->error->throw->new->XPathProcessorException
XPathParser#warn(String, Object[]):::Warn the user of a problem.:::fmsg->XSLMessages->createXPATHWarning->ehandler->this->getErrorListener->if->ehandler->new->TransformerException->warning->else->println
XPathParser#assertion(boolean, String):::Notify the user of an assertion error, and probably throw an exception.:::if->fMsg->XSLMessages->new->ObjectArr->createXPATHMessage->throw->new->RuntimeException
XPathParser#error(String, Object[]):::Notify the user of an error, and probably throw an exception.:::fmsg->XSLMessages->createXPATHMessage->ehandler->this->getErrorListener->te->new->TransformerException->if->ehandler->fatalError->else->throw
XPathParser#dumpRemainingTokenQueue():::Dump the remaining token queue:::q->returnMsg->if->m_ops->getTokenQueueSize->msg->while->m_ops->getTokenQueueSize->t->elementAt->else->return
XPathParser#getFunctionToken(String):::Given a string, return the corresponding function token.:::tok->id->try->Keywords->lookupNodeTest->if->m_functionTable->getFunctionID->catch->finally->return
XPathParser#insertOp(int, int, int):::Insert room for operation:::totalLen->m_ops->getOp->for->i->m_ops->setOp->m_ops->setOp
XPathParser#appendOp(int, int):::Insert room for operation:::totalLen->m_ops->getOp->m_ops->setOp->m_ops->setOp->m_ops->setOp
XPathParser#Expr():::Expr  ::=  OrExpr:::OrExpr
XPathParser#OrExpr():::OrExpr  ::=  AndExpr | OrExpr 'or' AndExpr:::opPos->m_ops->getOp->AndExpr->if->tokenIs->nextToken->insertOp->OrExpr->m_ops->m_ops->getOp->setOp
XPathParser#AndExpr():::AndExpr  ::=  EqualityExpr | AndExpr 'and' EqualityExpr:::opPos->m_ops->getOp->EqualityExpr->if->tokenIs->nextToken->insertOp->AndExpr->m_ops->m_ops->getOp->setOp
XPathParser#EqualityExpr(int)::: path parser  equality expr:::opPos->m_ops->getOp->if->RelationalExpr->if->if->tokenIs->lookahead->nextToken->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->EqualityExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->EqualityExpr->m_ops->m_ops->getOp->setOp->return
XPathParser#RelationalExpr(int):::.:::opPos->m_ops->getOp->if->AdditiveExpr->if->if->tokenIs->nextToken->if->tokenIs->nextToken->insertOp->else->insertOp->opPlusLeftHandLen->m_ops->getOp->RelationalExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->if->tokenIs->nextToken->insertOp->else->insertOp->opPlusLeftHandLen->m_ops->getOp->RelationalExpr->m_ops->m_ops->getOp->setOp->return
XPathParser#AdditiveExpr(int):::This has to handle construction of the operations so that they are evaluated in pre-fix order:::opPos->m_ops->getOp->if->MultiplicativeExpr->if->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->AdditiveExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->AdditiveExpr->m_ops->m_ops->getOp->setOp->return
XPathParser#MultiplicativeExpr(int):::This has to handle construction of the operations so that they are evaluated in pre-fix order:::opPos->m_ops->getOp->if->UnaryExpr->if->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->MultiplicativeExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->MultiplicativeExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->MultiplicativeExpr->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->insertOp->opPlusLeftHandLen->m_ops->getOp->MultiplicativeExpr->m_ops->m_ops->getOp->setOp->return
XPathParser#UnaryExpr():::UnaryExpr  ::=  UnionExpr | '-' UnaryExpr:::opPos->m_ops->getOp->isNeg->if->nextToken->appendOp->UnionExpr->if->m_ops->m_ops->getOp->setOp
XPathParser#StringExpr():::StringExpr  ::=  Expr:::opPos->m_ops->getOp->appendOp->Expr->m_ops->m_ops->getOp->setOp
XPathParser#BooleanExpr():::StringExpr  ::=  Expr:::opPos->m_ops->getOp->appendOp->Expr->opLen->m_ops->getOp->if->error->m_ops->setOp
XPathParser#NumberExpr():::NumberExpr  ::=  Expr:::opPos->m_ops->getOp->appendOp->Expr->m_ops->m_ops->getOp->setOp
XPathParser#UnionExpr():::The context of the right hand side expressions is the context of the left hand side expression:::opPos->m_ops->getOp->continueOrLoop->foundUnion->do->PathExpr->if->tokenIs->if->insertOp->nextToken->else->break->while->m_ops->m_ops->getOp->setOp
XPathParser#PathExpr():::PathExpr  ::=  LocationPath | FilterExpr | FilterExpr '/' RelativeLocationPath | FilterExpr '//' RelativeLocationPath:::opPos->m_ops->getOp->filterExprMatch->FilterExpr->if->locationPathStarted->if->tokenIs->nextToken->if->insertOp->if->RelativeLocationPath->error->if->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->else->LocationPath
XPathParser#FilterExpr():::FilterExpr  ::=  PrimaryExpr | FilterExpr Predicate:::opPos->m_ops->getOp->filterMatch->if->PrimaryExpr->if->tokenIs->insertOp->while->tokenIs->Predicate->else->else->return
XPathParser#PrimaryExpr():::PrimaryExpr  ::=  VariableReference | '(' Expr ')' | Literal | Number | FunctionCall:::matchFound->opPos->m_ops->getOp->if->appendOp->Literal->m_ops->m_ops->getOp->setOp->else->if->nextToken->appendOp->QName->m_ops->m_ops->getOp->setOp->else->if->nextToken->appendOp->Expr->consumeExpected->m_ops->m_ops->getOp->setOp->else->if->m_token->length->Character->m_token->charAt->isDigit->Character->isDigit->appendOp->Number->m_ops->m_ops->getOp->setOp->else->if->lookahead->lookahead->lookahead->FunctionCall->else->return
XPathParser#Argument():::Argument    ::=    Expr:::opPos->m_ops->getOp->appendOp->Expr->m_ops->m_ops->getOp->setOp
XPathParser#FunctionCall():::FunctionCall    ::=    FunctionName '(' ( Argument ( ',' Argument)*)? ')':::opPos->m_ops->getOp->if->lookahead->appendOp->m_ops->setOp->nextToken->consumeExpected->m_ops->setOp->nextToken->else->funcTok->getFunctionToken->if->new->ObjectArr->error->switch->return->appendOp->m_ops->setOp->nextToken->consumeExpected->while->tokenIs->if->tokenIs->error->Argument->if->tokenIs->consumeExpected->if->tokenIs->error->consumeExpected->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->return
XPathParser#LocationPath():::LocationPath ::= RelativeLocationPath | AbsoluteLocationPath:::opPos->m_ops->getOp->appendOp->seenSlash->tokenIs->if->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken->else->if->error->if->if->RelativeLocationPath->new->ObjectArr->error->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp
XPathParser#RelativeLocationPath():::RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | AbbreviatedRelativeLocationPath:::if->Step->return->while->tokenIs->nextToken->if->Step->error->return
XPathParser#Step():::Step    ::=    Basis Predicate | AbbreviatedStep:::opPos->m_ops->getOp->doubleSlash->tokenIs->if->nextToken->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->getOp->if->tokenIs->nextToken->if->tokenIs->error->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->else->if->tokenIs->nextToken->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->else->if->tokenIs->tokenIs->tokenIs->Character->m_token->charAt->isLetter->Basis->while->tokenIs->Predicate->m_ops->m_ops->getOp->setOp->else->if->error->return->return
XPathParser#Basis():::Basis    ::=    AxisName '::' NodeTest | AbbreviatedBasis:::opPos->m_ops->getOp->axesType->if->lookahead->AxisName->nextToken->nextToken->else->if->tokenIs->appendOp->nextToken->else->appendOp->m_ops->m_ops->getOp->setOp->NodeTest->m_ops->m_ops->getOp->setOp
XPathParser#AxisName():::Basis    ::=    AxisName '::' NodeTest | AbbreviatedBasis:::val->Keywords->getAxisName->if->new->ObjectArr->error->axesType->intValue->appendOp->return
XPathParser#NodeTest(int):::NodeTest    ::=    WildcardName | NodeType '(' ')' | 'processing-instruction' '(' Literal ')':::if->lookahead->nodeTestOp->Keywords->getNodeType->if->new->ObjectArr->error->else->nextToken->nt->intValue->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->consumeExpected->if->if->tokenIs->Literal->consumeExpected->else->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->if->lookahead->if->tokenIs->m_ops->m_ops->getOp->setOp->else->m_ops->m_ops->getOp->setOp->if->Character->isLetter->tokenIs->error->nextToken->consumeExpected->else->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->if->tokenIs->m_ops->m_ops->getOp->setOp->else->m_ops->m_ops->getOp->setOp->if->Character->isLetter->tokenIs->error->m_ops->m_ops->getOp->setOp->nextToken
XPathParser#Predicate():::Predicate ::= '[' PredicateExpr ']':::if->tokenIs->nextToken->PredicateExpr->consumeExpected
XPathParser#PredicateExpr():::PredicateExpr ::= Expr:::opPos->m_ops->getOp->appendOp->Expr->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp
XPathParser#QName():::QName ::=  (Prefix ':')? LocalPart Prefix ::=  NCName LocalPart ::=  NCName:::if->lookahead->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken->consumeExpected->else->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken
XPathParser#NCName():::NCName ::=  (Letter | '_') (NCNameChar) NCNameChar ::=  Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender:::m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken
XPathParser#Literal():::The value of the Literal is the sequence of characters inside the " or ' characters>:::last->m_token->length->c0->cX->m_token->charAt->if->tokenQueuePos->setElementAt->obj->m_token->substring->new->XString->setElementAt->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken->else->new->ObjectArr->error
XPathParser#Number():::Number ::= [0-9]+('.'[0-9]+)? | '.'[0-9]+:::if->num->try->if->m_token->indexOf->m_token->indexOf->throw->new->NumberFormatException->Double->valueOf->doubleValue->catch->new->ObjectArr->error->finally->new->XNumber->setElementAt->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken
XPathParser#Pattern():::Pattern  ::=  LocationPathPattern | Pattern '|' LocationPathPattern:::while->LocationPathPattern->if->tokenIs->nextToken->else->break
XPathParser#LocationPathPattern():::LocationPathPattern  ::=  '/' RelativePathPattern? | IdKeyPattern (('/' | '//') RelativePathPattern)? | '//'? RelativePathPattern:::opPos->m_ops->getOp->RELATIVE_PATH_NOT_PERMITTED->RELATIVE_PATH_PERMITTED->RELATIVE_PATH_REQUIRED->relativePathStatus->appendOp->if->lookahead->tokenIs->tokenIs->IdKeyPattern->if->tokenIs->nextToken->if->tokenIs->appendOp->nextToken->else->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->else->if->tokenIs->if->lookahead->appendOp->nextToken->else->appendOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->nextToken->else->if->if->tokenIs->RelativePathPattern->else->if->error->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp->m_ops->m_ops->getOp->setOp
XPathParser#IdKeyPattern():::IdKeyPattern  ::=  'id' '(' Literal ')' | 'key' '(' Literal ',' Literal ')' (Also handle doc()):::FunctionCall
XPathParser#RelativePathPattern():::RelativePathPattern  ::=  StepPattern | RelativePathPattern '/' StepPattern | RelativePathPattern '//' StepPattern:::trailingSlashConsumed->StepPattern->while->tokenIs->nextToken->StepPattern
XPathParser#StepPattern(boolean):::StepPattern  ::=  AbbreviatedNodeTestStep:::return->AbbreviatedNodeTestStep
XPathParser#AbbreviatedNodeTestStep(boolean):::AbbreviatedNodeTestStep    ::=    '@'? NodeTest Predicate:::opPos->m_ops->getOp->axesType->matchTypePos->if->tokenIs->appendOp->nextToken->else->if->this->lookahead->if->tokenIs->appendOp->else->if->tokenIs->m_ops->getOp->appendOp->else->this->new->ObjectArr->error->nextToken->nextToken->else->if->tokenIs->if->error->appendOp->nextToken->else->m_ops->getOp->appendOp->m_ops->m_ops->getOp->setOp->NodeTest->m_ops->m_ops->getOp->setOp->while->tokenIs->Predicate->trailingSlashConsumed->if->tokenIs->lookahead->m_ops->setOp->nextToken->else->m_ops->m_ops->getOp->setOp->return
