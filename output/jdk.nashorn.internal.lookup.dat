Lookup#emptyGetter(Object):::Empty getter implementation:::return
Lookup#emptySetter(Object, Object):::Empty setter implementation:::
Lookup#emptyGetter(Class):::Return a method handle to the empty getter, with a different return type value:::return->filterReturnType
Lookup#typeErrorThrower(Object):::Getter function that always throws type error:::throw->ScriptRuntime->safeToString->typeError
Lookup#filterArgumentType(MethodHandle, int, Class):::This method filters primitive argument types using JavaScript semantics:::to->mh->type->parameterType->if->else->if->if->return->MH->methodHandle->filterArguments->else->if->if->return->MH->methodHandle->filterArguments->else->if->return->MH->methodHandle->filterArguments->else->if->from->isPrimitive->if->return->MH->methodHandle->filterArguments->else->if->return->MH->methodHandle->filterArguments->else->if->return->MH->methodHandle->filterArguments->else->if->to->isPrimitive->return->return->MH->mh->type->changeParameterType->explicitCastArguments
Lookup#filterReturnType(MethodHandle, Class):::This method filters primitive return types using JavaScript semantics:::retType->mh->type->returnType->if->else->if->if->return->MH->methodHandle->filterReturnValue->else->if->if->return->MH->methodHandle->filterReturnValue->else->if->return->MH->methodHandle->filterReturnValue->else->if->retType->isPrimitive->if->return->MH->methodHandle->filterReturnValue->else->if->return->MH->methodHandle->filterReturnValue->else->if->return->MH->methodHandle->filterReturnValue->else->if->type->isPrimitive->return->return->MH->mh->type->changeReturnType->explicitCastArguments
MethodHandleFactory#stripName(Object):::Helper function that takes a class or an object with a toString override and shortens it to notation after last dot:::if->return->if->return->getSimpleName->return->obj->toString
MethodHandleFactory#getFunctionality():::Return the method handle functionality used for all method handle operations:::return
MethodHandleFactory#traceReturn(DebugLogger, Object):::Tracer that is applied before a value is returned from the traced function:::str->VOID_TAG->equals->stripName->value->getClass->stripName->if->err->else->if->logger->isEnabled->logger->log->return
MethodHandleFactory#traceArgs(DebugLogger, String, int, Object...):::Tracer that is applied before a function is called, printing the arguments:::sb->new->StringBuilder->sb->append->for->i->if->sb->toString->err->else->logger->log->stacktrace
MethodHandleFactory#addDebugPrintout(MethodHandle, Object):::Add a debug printout to a method handle, tracing parameters and return values Output will be unconditional to stderr:::return->addDebugPrintout
MethodHandleFactory#addDebugPrintout(DebugLogger, Level, MethodHandle, Object):::Add a debug printout to a method handle, tracing parameters and return values:::return->addDebugPrintout
MethodHandleFactory#addDebugPrintout(MethodHandle, int, boolean, Object):::Add a debug printout to a method handle, tracing parameters and return values Output will be unconditional to stderr:::return->addDebugPrintout
MethodHandleFactory#addDebugPrintout(DebugLogger, Level, MethodHandle, int, boolean, Object):::Add a debug printout to a method handle, tracing parameters and return values:::type->mh->type->if->logger->isLoggable->return->trace->MethodHandles->insertArguments->MethodHandles->trace->type->parameterCount->asCollector->type->changeReturnType->asType->foldArguments->retType->type->returnType->if->if->traceReturn->MethodHandles->insertArguments->MethodHandles->traceReturn->traceReturn->type->changeParameterType->changeReturnType->asType->filterReturnValue->else->MethodHandles->MethodHandles->insertArguments->filterReturnValue->return
MethodHandleFunctionality#filterArguments(MethodHandle, int, MethodHandle...):::Wrapper for MethodHandles#filterArguments(MethodHandle, int, MethodHandle...):::
MethodHandleFunctionality#filterReturnValue(MethodHandle, MethodHandle):::Wrapper for MethodHandles#filterReturnValue(MethodHandle, MethodHandle):::
MethodHandleFunctionality#guardWithTest(MethodHandle, MethodHandle, MethodHandle):::Wrapper for MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle):::
MethodHandleFunctionality#insertArguments(MethodHandle, int, Object...):::Wrapper for MethodHandles#insertArguments(MethodHandle, int, Object...):::
MethodHandleFunctionality#dropArguments(MethodHandle, int, Class...):::Wrapper for MethodHandles#dropArguments(MethodHandle, int, Class...):::
MethodHandleFunctionality#dropArguments(MethodHandle, int, List>):::Wrapper for MethodHandles#dropArguments(MethodHandle, int, List):::
MethodHandleFunctionality#foldArguments(MethodHandle, MethodHandle):::Wrapper for MethodHandles#foldArguments(MethodHandle, MethodHandle):::
MethodHandleFunctionality#explicitCastArguments(MethodHandle, MethodType):::Wrapper for MethodHandles#explicitCastArguments(MethodHandle, MethodType):::
MethodHandleFunctionality#arrayElementGetter(Class):::Wrapper for java.lang.invoke.MethodHandles#arrayElementGetter(Class):::
MethodHandleFunctionality#arrayElementSetter(Class):::Wrapper for java.lang.invoke.MethodHandles#arrayElementSetter(Class):::
MethodHandleFunctionality#throwException(Class, Class):::Wrapper for java.lang.invoke.MethodHandles#throwException(Class, Class):::
MethodHandleFunctionality#catchException(MethodHandle, Class, MethodHandle):::Wrapper for java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle):::
MethodHandleFunctionality#constant(Class, Object):::Wrapper for java.lang.invoke.MethodHandles#constant(Class, Object):::
MethodHandleFunctionality#identity(Class):::Wrapper for java.lang.invoke.MethodHandles#identity(Class):::
MethodHandleFunctionality#asType(MethodHandle, MethodType):::Wrapper for java.lang.invoke.MethodHandle#asType(MethodType):::
MethodHandleFunctionality#asCollector(MethodHandle, Class, int):::Wrapper for java.lang.invoke.MethodHandle#asCollector(Class, int):::
MethodHandleFunctionality#asSpreader(MethodHandle, Class, int):::Wrapper for java.lang.invoke.MethodHandle#asSpreader(Class, int):::
MethodHandleFunctionality#bindTo(MethodHandle, Object):::Wrapper for java.lang.invoke.MethodHandle#bindTo(Object):::
MethodHandleFunctionality#getter(MethodHandles.Lookup, Class, String, Class):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findGetter(Class, String, Class):::
MethodHandleFunctionality#staticGetter(MethodHandles.Lookup, Class, String, Class):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findStaticGetter(Class, String, Class):::
MethodHandleFunctionality#setter(MethodHandles.Lookup, Class, String, Class):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findSetter(Class, String, Class):::
MethodHandleFunctionality#staticSetter(MethodHandles.Lookup, Class, String, Class):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findStaticSetter(Class, String, Class):::
MethodHandleFunctionality#find(Method):::Wrapper for java.lang.invoke.MethodHandles.Lookup#unreflect(Method)  Unreflect a method as a method handle:::
MethodHandleFunctionality#findStatic(MethodHandles.Lookup, Class, String, MethodType):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findStatic(Class, String, MethodType):::
MethodHandleFunctionality#findVirtual(MethodHandles.Lookup, Class, String, MethodType):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findVirtual(Class, String, MethodType):::
MethodHandleFunctionality#findSpecial(MethodHandles.Lookup, Class, String, MethodType, Class):::Wrapper for java.lang.invoke.MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class):::
MethodHandleFunctionality#createSwitchPoint():::Wrapper for SwitchPoint creation:::
MethodHandleFunctionality#guardWithTest(SwitchPoint, MethodHandle, MethodHandle):::Wrapper for SwitchPoint#guardWithTest(MethodHandle, MethodHandle):::
MethodHandleFunctionality#type(Class, Class...):::Wrapper for MethodType#methodType(Class, Class...):::
