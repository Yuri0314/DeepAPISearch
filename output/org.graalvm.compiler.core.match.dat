MatchContext#setResult(ComplexMatchResult):::Mark the interior nodes with INTERIOR_MATCH and set the Value of the root to be the result:::value->new->ComplexMatchValue->emitNode->schedule->getBlockToNodesMap->get->get->debug->root->getDebug->if->debug->isLogEnabled->debug->rule->getName->rule->getPattern->log->debug->rule->formatMatch->log->foreach->if->continue->builder->setMatchResult->builder->setMatchResult->if->builder->gen->operand->new->ComplexMatchValue->setMatchResult
MatchContext#consume(Node, boolean, boolean):::Mark a node as consumed by the match:::if->consumed->add->return->if->builder->hasOperand->return->Result->rule->getPattern->alreadyUsed->consumed->add->return
MatchContext#namedNode(String):::Return the named node:::if->value->namedNodes->get->if->return->throw->new->GraalError
MatchPattern#matchUsage(Node, MatchContext):::Match any named nodes and ensure that the consumed nodes can be safely merged.:::result->matchUsage->if->context->validate->return
MatchPattern#matchShape(Node, MatchStatement):::Recursively match the shape of the tree without worry about named values:::return->matchShape
MatchPattern#formatMatch(Node):::For a node starting at root, produce a String showing the inputs that matched against this rule:::result->String->format->if->return->else->sb->new->StringBuilder->sb->append->sb->append->for->input->sb->append->return->sb->toString
MatchRuleRegistry#findPositions(NodeClass, String[]):::Convert a list of field names into org.graalvm.compiler.graph.Position objects that can be used to read them during a match:::result->new->PositionArr->for->i->return
MatchRuleRegistry#lookup(Class, OptionValues, DebugContext):::Collect all the MatchStatements defined by the superclass chain of theClass.:::result->registry->get->if->rules->createRules->registry->put->if->LogVerbose->getValue->try->s->debug->scope->debug->theClass->getSimpleName->log->cursor->result->getEntries->while->cursor->advance->debug->cursor->getKey->log->foreach->cursor->getValue->debug->statement->getPattern->log->catch->finally->if->result->size->return->return
MatchStatement#generate(NodeLIRBuilder, int, Node, Block, StructuredGraph.ScheduleResult):::Attempt to match the current statement against a Node.:::debug->node->getDebug->result->pattern->matchShape->if->return->context->new->MatchContext->pattern->matchUsage->if->value->generatorMethod->builder->getNodeMatchRules->buildArgList->match->if->context->setResult->MatchStatementSuccess->increment->DebugContext->getName->counter->increment->return->if->LogVerbose->node->getOptions->getValue->debug->context->getRoot->toString->context->getRoot->getClass->getSimpleName->getName->generatorMethod->getName->log->debug->formatMatch->log->else->if->LogVerbose->node->getOptions->getValue->debug->context->getRoot->toString->context->getRoot->getClass->getSimpleName->getName->log->return
