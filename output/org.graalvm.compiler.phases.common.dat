ConditionalEliminationPhase.Instance#recursiveFoldStampFromInfo(Node):::Recursively try to fold stamps within this expression using information from #getInfoElements(ValueNode):::return->recursiveFoldStamp
ConditionalEliminationPhase.Instance#foldPendingTest(DeoptimizingGuard, ValueNode, Stamp, GuardRewirer):::Look for a preceding guard whose condition is implied by thisGuard:::foreach->pendingCondition->pendingGuard->getCondition->result->if->unaryLogicNode->if->unaryLogicNode->getValue->unaryLogicNode->tryFold->else->if->binaryOpLogicNode->x->binaryOpLogicNode->getX->y->binaryOpLogicNode->getY->if->binaryOpLogicNode->getOtherSafeStamp->tryFold->else->if->binaryOpLogicNode->getOtherSafeStamp->tryFold->else->if->y->isConstant->and->if->and->getY->and->getX->andOp->ArithmeticOpTable->forStamp->getAnd->binaryOpLogicNode->andOp->getOtherSafeStamp->foldStamp->getOtherSafeStamp->tryFold->if->result->isKnown->if->thisGuard->getCondition->pendingGuard->asNode->canScheduleAbove->result->toBoolean->foldGuard->return->return
ConditionalEliminationPhase.GuardRewirer#rewire(GuardingNode, boolean, Stamp, ValueNode):::Called if the condition could be proven to have a constant value (result) under guard.:::
LockEliminationPhase#isCompatibleLock(AccessMonitorNode, AccessMonitorNode):::Check that the paired operations operate on the same object at the same lock depth.:::object1->GraphUtil->lock1->object->unproxify->object2->GraphUtil->lock2->object->unproxify->return->lock1->getMonitorId->getLockDepth->lock2->getMonitorId->getLockDepth
LoweringPhase#processBlock(Frame):::This state-machine resembles the following recursion:   void processBlock(Block block) {     preprocess();     // Process always reached block first:::state->f->while->nextState->if->f->preprocess->else->if->if->getDominator->f->enterAlwaysReached->else->else->if->if->n->n->getDominatedSibling->if->if->n->getDominatedSibling->else->if->else->f->enter->else->else->if->f->postprocess->else->throw->GraalError->shouldNotReachHere
