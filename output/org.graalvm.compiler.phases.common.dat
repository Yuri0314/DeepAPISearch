DeadCodeEliminationPhase_OptionDescriptors#get(String)::: dead code elimination phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
DeadCodeEliminationPhase_OptionDescriptors#iterator()::: dead code elimination phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
NodeCounterPhase_OptionDescriptors#get(String)::: node counter phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
NodeCounterPhase_OptionDescriptors#iterator()::: node counter phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
UseTrappingNullChecksPhase_OptionDescriptors#get(String)::: use trapping null checks phase_ option descriptors get:::switch->return->OptionDescriptor->create->return
UseTrappingNullChecksPhase_OptionDescriptors#iterator()::: use trapping null checks phase_ option descriptors iterator:::return->new->Iterator<OptionDescriptor>
AddressLoweringByUsePhase.AddressLoweringByUse#lower(ValueNode, Stamp, AddressNode)::: address lowering by use lower:::
AddressLoweringByUsePhase.AddressLoweringByUse#lower(AddressNode)::: address lowering by use lower:::
AddressLoweringByUsePhase#run(StructuredGraph)::: address lowering by use phase run:::foreach->graph->getNodes->address->lowered->if->readNode->stamp->readNode->stamp->readNode->getAddress->lowering->lower->else->if->javaReadNode->stamp->javaReadNode->stamp->javaReadNode->getAddress->lowering->lower->else->if->floatingReadNode->stamp->floatingReadNode->stamp->floatingReadNode->getAddress->lowering->lower->else->if->abstractWriteNode->stamp->abstractWriteNode->value->stamp->abstractWriteNode->getAddress->lowering->lower->else->if->prefetchAllocateNode->stamp->StampFactory->forKind->prefetchAllocateNode->inputs->first->lowering->lower->else->continue->if->node->replaceFirstInput->if->address->hasNoUsages->GraphUtil->killWithUnusedFloatingInputs->foreach->graph->getNodes->lowered->if->address->lowering->lower->else->continue->node->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs
AddressLoweringPhase.AddressLowering#preProcess(StructuredGraph)::: address lowering pre process:::
AddressLoweringPhase.AddressLowering#postProcess(AddressNode)::: address lowering post process:::
AddressLoweringPhase.AddressLowering#lower(ValueNode, ValueNode)::: address lowering lower:::
AddressLoweringPhase#run(StructuredGraph)::: address lowering phase run:::lowering->preProcess->foreach->graph->getNodes->lowered->if->address->lowering->address->getBase->address->getOffset->lower->lowering->postProcess->else->continue->node->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs
CanonicalizerPhase.CustomCanonicalizer#canonicalize(Node)::: custom canonicalizer canonicalize:::return
CanonicalizerPhase.CustomCanonicalizer#simplify(Node, SimplifierTool)::: custom canonicalizer simplify:::
CanonicalizerPhase#disableGVN()::: canonicalizer phase disable n:::
CanonicalizerPhase#disableReadCanonicalization()::: canonicalizer phase disable read canonicalization:::
CanonicalizerPhase#disableSimplification()::: canonicalizer phase disable simplification:::
CanonicalizerPhase#checkContract()::: canonicalizer phase check contract:::return
CanonicalizerPhase#run(StructuredGraph, CoreProviders)::: canonicalizer phase run:::new->Instance->run
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Mark)::: canonicalizer phase apply incremental:::applyIncremental
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Mark, boolean)::: canonicalizer phase apply incremental:::new->Instance->apply
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Iterable)::: canonicalizer phase apply incremental:::applyIncremental
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Iterable, boolean)::: canonicalizer phase apply incremental:::new->Instance->apply
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Iterable, Mark)::: canonicalizer phase apply incremental:::applyIncremental
CanonicalizerPhase#applyIncremental(StructuredGraph, CoreProviders, Iterable, Mark, boolean)::: canonicalizer phase apply incremental:::new->Instance->apply
CanonicalizerPhase#getNodeView()::: canonicalizer phase get node view:::return
CanonicalizerPhase.Instance#checkContract()::: instance check contract:::return
CanonicalizerPhase.Instance#run(StructuredGraph)::: instance run:::graph->getDebug->wholeGraph->newNodesMark->isStart->if->graph->createIterativeNodeWorkList->else->graph->createIterativeNodeWorkList->workList->addAll->if->workList->graph->getNewNodes->addAll->graph->getAssumptions->graph->getOptions->new->Tool->processWorkSet
CanonicalizerPhase.Instance#processWorkSet(StructuredGraph)::: instance process work set:::sum->listener->new->NodeEventListener->try->nes->graph->trackNodeEvents->foreach->changed->processNode->if->debug->isDumpEnabled->debug->dump->catch->finally->return
CanonicalizerPhase.Instance#processNode(Node)::: instance process node:::if->node->isAlive->return->COUNTER_PROCESSED_NODES->increment->if->GraphUtil->tryKillUnused->return->nodeClass->node->getNodeClass->graph->node->graph->if->tryCanonicalize->return->if->tryGlobalValueNumbering->return->if->valueNode->improvedStamp->tryInferStamp->constant->valueNode->stamp->asConstant->if->stampConstant->ConstantNode->valueNode->stamp->context->getMetaAccess->forConstant->debug->log->valueNode->replaceAtUsages->GraphUtil->tryKillUnused->return->else->if->if->tryCanonicalize->return->valueNode->usages->workList->add->forEach->return
CanonicalizerPhase.Instance#tryGlobalValueNumbering(Node, NodeClass)::: instance try global value numbering:::if->nodeClass->valueNumberable->newNode->node->graph->findDuplicate->if->node->replaceAtUsagesAndDelete->COUNTER_GLOBAL_VALUE_NUMBERING_HITS->increment->debug->log->return->return
CanonicalizerPhase.Instance#getCanonicalizeableContractAssertion(Node)::: instance get canonicalizeable contract assertion:::needsAssertion->if->mark->node->graph->getMark->return->else->return
CanonicalizerPhase.Instance#tryCanonicalize(Node, NodeClass)::: instance try canonicalize:::try->position->node->withNodeSourcePosition->scope->debug->withContext->if->canonical->customCanonicalizer->canonicalize->if->performReplacement->return->else->customCanonicalizer->simplify->if->node->isDeleted->return->if->nodeClass->isCanonicalizable->COUNTER_CANONICALIZATION_CONSIDERED_NODES->increment->canonical->try->verify->getCanonicalizeableContractAssertion->canonical->if->nodeClass->isCommutative->maybeCommuteInputs->catch->throw->new->GraalGraphError->addContext->finally->if->performReplacement->return->if->nodeClass->isSimplifiable->debug->log->COUNTER_SIMPLIFICATION_CONSIDERED_NODES->increment->node->simplify->if->node->isDeleted->debug->log->return->node->isDeleted->return->catch->throw->debug->handle->finally
CanonicalizerPhase.Instance#performReplacement(Node, Node)::: instance perform replacement:::if->debug->log->return->else->canonical->debug->log->COUNTER_CANONICALIZED_NODES->increment->graph->node->graph->if->canonical->isAlive->graph->addOrUniqueWithInputs->if->node->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs->else->fixed->if->fixed->replaceAtPredecessor->GraphUtil->killCFG->return->else->fixedWithNext->tool->fixedWithNext->next->addToWorkList->if->node->replaceAtUsages->GraphUtil->removeFixedWithUnusedInputs->else->if->graph->replaceFixedWithFloating->else->if->canonical->predecessor->graph->replaceFixedWithFixed->else->node->replaceAtUsages->GraphUtil->removeFixedWithUnusedInputs->return
CanonicalizerPhase.Instance#tryInferStamp(ValueNode):::Calls ValueNode#inferStamp() on the node and, if it returns true (which means that the stamp has changed), re-queues the node's usages:::if->node->isAlive->COUNTER_INFER_STAMP_CALLED->increment->if->node->inferStamp->COUNTER_STAMP_CHANGED->increment->foreach->node->usages->workList->add->return->return
CanonicalizerPhase.Instance.Tool#deleteBranch(Node)::: tool delete branch:::fixedBranch->fixedBranch->predecessor->replaceFirstSuccessor->GraphUtil->killCFG
CanonicalizerPhase.Instance.Tool#getMetaAccess()::: tool get meta access:::return->context->getMetaAccess
CanonicalizerPhase.Instance.Tool#getConstantReflection()::: tool get constant reflection:::return->context->getConstantReflection
CanonicalizerPhase.Instance.Tool#getConstantFieldProvider()::: tool get constant field provider:::return->context->getConstantFieldProvider
CanonicalizerPhase.Instance.Tool#addToWorkList(Node)::: tool add to work list:::workList->add
CanonicalizerPhase.Instance.Tool#addToWorkList(Iterable)::: tool add to work list:::workList->addAll
CanonicalizerPhase.Instance.Tool#removeIfUnused(Node)::: tool remove if unused:::GraphUtil->tryKillUnused
CanonicalizerPhase.Instance.Tool#canonicalizeReads()::: tool canonicalize reads:::return
CanonicalizerPhase.Instance.Tool#allUsagesAvailable()::: tool all usages available:::return
CanonicalizerPhase.Instance.Tool#getAssumptions()::: tool get assumptions:::return
CanonicalizerPhase.Instance.Tool#smallestCompareWidth()::: tool smallest compare width:::return->context->getLowerer->smallestCompareWidth
CanonicalizerPhase.Instance.Tool#getOptions()::: tool get options:::return
CanonicalizerPhase.Instance.Tool#stamp(ValueNode)::: tool stamp:::return->nodeView->stamp
CanonicalizerPhase#getCanonicalizeReads()::: canonicalizer phase get canonicalize reads:::return
ConditionalEliminationPhase#run(StructuredGraph, CoreProviders)::: conditional elimination phase run:::try->s->graph->getDebug->scope->blockToNodes->nodeToBlock->cfg->ControlFlowGraph->compute->if->if->cfg->new->MoveGuardsUpwards->graph->hasValueProxies->visitDominatorTree->try->scheduleScope->graph->getDebug->scope->SchedulePhase->run->catch->throw->graph->getDebug->handle->finally->r->graph->getLastSchedule->r->getBlockToNodesMap->r->getNodeToBlockMap->else->cfg->getNodeToBlock->getBlockToNodes->visitor->createVisitor->cfg->graph->hasValueProxies->visitDominatorTree->catch->finally
ConditionalEliminationPhase#getBlockToNodes(ControlFlowGraph)::: conditional elimination phase get block to nodes:::return
ConditionalEliminationPhase#createVisitor(StructuredGraph, ControlFlowGraph, BlockMap>, NodeMap, CoreProviders)::: conditional elimination phase create visitor:::return->new->Instance
ConditionalEliminationPhase.MoveGuardsUpwards#enter(Block)::: move guards upwards enter:::oldAnchorBlock->if->b->getDominator->b->getDominator->getPostdominator->beginNode->b->getBeginNode->if->mergeNode->mergeNode->anchorBlock->getBeginNode->replaceAtUsages->mergeNode->anchorBlock->getBeginNode->replaceAtUsages->endNode->b->getEndNode->if->node->trueSuccessor->node->trueSuccessor->trueGuards->EconomicMap->create->foreach->trueSuccessor->guards->condition->guard->getCondition->if->condition->hasMoreThanOneUsage->trueGuards->put->if->trueGuards->isEmpty->foreach->node->falseSuccessor->guards->snapshot->otherGuard->trueGuards->guard->getCondition->get->if->guard->isNegated->otherGuard->isNegated->speculation->otherGuard->getSpeculation->if->guard->getSpeculation->else->if->guard->getSpeculation->guard->getSpeculation->continue->try->closeable->guard->withNodeSourcePosition->newlyCreatedGuard->guard->getCondition->anchorBlock->getBeginNode->guard->getReason->guard->getAction->guard->isNegated->guard->getNoDeoptSuccessorPosition->new->GuardNode->newGuard->node->graph->unique->if->otherGuard->isAlive->otherGuard->replaceAndDelete->guard->replaceAndDelete->catch->finally->return
ConditionalEliminationPhase.MoveGuardsUpwards#exit(Block, Block)::: move guards upwards exit:::
ConditionalEliminationPhase.PhiInfoElement#set(EndNode, InfoElement)::: phi info element set:::if->EconomicMap->create->infoElements->put
ConditionalEliminationPhase.PhiInfoElement#get(EndNode)::: phi info element get:::if->return->return->infoElements->get
ConditionalEliminationPhase.GuardedCondition#getGuard()::: guarded condition get guard:::return
ConditionalEliminationPhase.GuardedCondition#getCondition()::: guarded condition get condition:::return
ConditionalEliminationPhase.GuardedCondition#isNegated()::: guarded condition is negated:::return
ConditionalEliminationPhase.Instance#processConditionAnchor(ConditionAnchorNode)::: instance process condition anchor:::node->condition->if->node->isNegated->node->guard->asNode->replaceAtUsages->GraphUtil->unlinkFixedNode->GraphUtil->killWithUnusedFloatingInputs->else->valueAnchor->node->graph->new->ValueAnchorNode->add->node->replaceAtUsages->node->graph->replaceFixedWithFixed->return->tryProveCondition
ConditionalEliminationPhase.Instance#processGuard(GuardNode)::: instance process guard:::if->node->getCondition->if->node->isNegated->node->guard->asNode->replaceAndDelete->if->isNegated->rebuildPiNodes->else->beginNode->node->getAnchor->if->beginNode->next->else->deopt->LogicConstantNode->node->graph->forBoolean->node->getReason->node->getAction->node->getSpeculation->node->isNegated->node->getNodeSourcePosition->new->FixedGuardNode->graph->node->graph->add->addAfterFixed->return->tryProveGuardCondition->node->getCondition->node->isNegated->registerNewCondition
ConditionalEliminationPhase.Instance#processFixedGuard(FixedGuardNode)::: instance process fixed guard:::if->node->condition->if->node->isNegated->node->guard->asNode->replaceAtUsages->GraphUtil->unlinkFixedNode->GraphUtil->killWithUnusedFloatingInputs->if->isNegated->rebuildPiNodes->else->node->LogicConstantNode->node->graph->forBoolean->node->isNegated->setCondition->debug->log->return->tryProveGuardCondition->node->condition->node->isNegated->registerNewCondition
ConditionalEliminationPhase.Instance#rebuildPiNodes(DeoptimizingGuard)::: instance rebuild pi nodes:::newCondition->guard->getCondition->if->inst->originalValue->GraphUtil->inst->getValue->skipPi->pi->foreach->guard->asNode->usages->filter->snapshot->if->existing->isAlive->continue->if->GraphUtil->existing->object->skipPi->continue->strongerStamp->existing->piStamp->inst->getCheckedStamp->join->inst->getCheckedStamp->equals->differentCheckedStamp->existing->piStamp->inst->getCheckedStamp->equals->differentObject->existing->object->inst->getValue->if->if->graph->inst->getValue->inst->getCheckedStamp->new->PiNode->unique->if->pi->stamp->existing->stamp->join->pi->stamp->equals->if->alternatePi->graph->existing->object->inst->getCheckedStamp->new->PiNode->unique->if->alternatePi->stamp->existing->stamp->join->alternatePi->stamp->equals->existing->replaceAndDelete->continue->existing->replaceAndDelete
ConditionalEliminationPhase.Instance#processIf(IfNode)::: instance process if:::node->condition->node->LogicConstantNode->node->graph->forBoolean->setCondition->survivingSuccessor->node->getSuccessor->survivingSuccessor->guard->asNode->replaceAtUsages->counterIfsKilled->increment->return->tryProveCondition
ConditionalEliminationPhase.Instance#enter(Block)::: instance enter:::infoElementsMark->undoOperations->size->conditionsMark->conditions->size->debug->log->pendingTests->clear->processNodes->return->new->Marks
ConditionalEliminationPhase.Instance#processNodes(Block)::: instance process nodes:::if->foreach->blockToNodes->get->if->n->isAlive->processNode->else->processBlock
ConditionalEliminationPhase.Instance#processBlock(Block)::: instance process block:::n->block->getBeginNode->endNode->block->getEndNode->debug->log->while->if->n->isDeleted->endNode->isDeleted->return->next->next->processNode->if->endNode->isAlive->processNode
ConditionalEliminationPhase.Instance#processNode(Node)::: instance process node:::try->closeable->node->withNodeSourcePosition->if->pendingTests->clear->if->introducePisForPhis->if->if->graph->hasValueProxies->return->processAbstractBegin->else->if->processFixedGuard->else->if->processGuard->else->if->processConditionAnchor->else->if->processIf->else->if->processEnd->catch->finally
ConditionalEliminationPhase.Instance#introducePisForPhis(MergeNode)::: instance introduce pis for phis:::mergeMap->get->if->entries->mergeMap->getEntries->while->entries->advance->phi->entries->getKey->if->phi->isDeleted->continue->phiInfoElements->entries->getValue->bestPossibleStamp->for->i->phi->valueCount->oldStamp->phi->stamp->if->oldStamp->tryImproveWith->allow->if->else->if->integerStamp->oldIntegerStamp->if->integerStamp->isPositive->oldIntegerStamp->isPositive->else->if->integerStamp->isNegative->oldIntegerStamp->isNegative->else->if->integerStamp->isStrictlyPositive->oldIntegerStamp->isStrictlyPositive->else->if->integerStamp->isStrictlyNegative->oldIntegerStamp->isStrictlyNegative->else->if->integerStamp->asConstant->else->if->oldStamp->isUnrestricted->else->bestPossibleStamp->asConstant->if->newPhi->graph->new->ValuePhiNode->addWithoutUnique->for->i->phi->valueCount->counterPhiStampsImproved->increment->phi->replaceAtUsagesAndDelete
ConditionalEliminationPhase.Instance#processEnd(EndNode)::: instance process end:::abstractMerge->end->merge->if->merge->mergeMap->get->foreach->merge->valuePhis->valueAt->phi->valueAt->infoElement->this->getInfoElements->while->newStamp->infoElement->getStamp->if->phi->stamp->tryImproveWith->if->EconomicMap->create->mergeMaps->put->phiInfoElement->mergeMap->get->if->new->PhiInfoElement->mergeMap->put->phiInfoElement->set->break->nextElement
ConditionalEliminationPhase.Instance#registerNewCondition(LogicNode, boolean, GuardingNode)::: instance register new condition:::if->unaryLogicNode->value->unaryLogicNode->getValue->if->maybeMultipleUsages->newStamp->unaryLogicNode->getSucceedingStampForValue->registerNewStamp->else->if->binaryOpLogicNode->x->binaryOpLogicNode->getX->y->binaryOpLogicNode->getY->if->x->isConstant->maybeMultipleUsages->newStampX->binaryOpLogicNode->getSafeStamp->getOtherSafeStamp->getSucceedingStampForX->registerNewStamp->if->y->isConstant->maybeMultipleUsages->newStampY->binaryOpLogicNode->getOtherSafeStamp->getSafeStamp->getSucceedingStampForY->registerNewStamp->if->if->y->isConstant->and->andX->and->getX->if->and->getY->maybeMultipleUsages->op->ArithmeticOpTable->x->stamp->forStamp->getOr->newStampX->op->getSafeStamp->getOtherSafeStamp->foldStamp->registerNewStamp->if->pendingTests->push->registerCondition
ConditionalEliminationPhase.Instance#recursiveFoldStamp(Node)::: instance recursive fold stamp:::if->unary->value->unary->getValue->infoElement->getInfoElements->while->result->unary->infoElement->getStamp->foldStamp->if->return->Pair->create->nextElement->else->if->binary->y->binary->getY->x->binary->getX->if->y->isConstant->infoElement->getInfoElements->while->result->binary->y->stamp->foldStamp->if->return->Pair->create->nextElement->return
ConditionalEliminationPhase.Instance#getSafeStamp(ValueNode):::Get the stamp that may be used for the value for which we are registering the condition:::return->x->stamp
ConditionalEliminationPhase.Instance#getOtherSafeStamp(ValueNode):::We can only use the stamp of a second value involved in the condition if we are sure that we are not implicitly creating a dependency on a pi node that is responsible for that stamp:::if->x->isConstant->x->graph->isAfterFixedReadPhase->return->x->stamp->return->x->stamp->unrestricted
ConditionalEliminationPhase.Instance#recursiveFoldStampFromInfo(Node):::Recursively try to fold stamps within this expression using information from #getInfoElements(ValueNode):::return->recursiveFoldStamp
ConditionalEliminationPhase.Instance#foldPendingTest(DeoptimizingGuard, ValueNode, Stamp, GuardRewirer):::Look for a preceding guard whose condition is implied by thisGuard:::foreach->pendingCondition->pendingGuard->getCondition->result->if->unaryLogicNode->if->unaryLogicNode->getValue->unaryLogicNode->tryFold->else->if->binaryOpLogicNode->x->binaryOpLogicNode->getX->y->binaryOpLogicNode->getY->if->binaryOpLogicNode->getOtherSafeStamp->tryFold->else->if->binaryOpLogicNode->getOtherSafeStamp->tryFold->else->if->y->isConstant->and->if->and->getY->and->getX->andOp->ArithmeticOpTable->forStamp->getAnd->binaryOpLogicNode->andOp->getOtherSafeStamp->foldStamp->getOtherSafeStamp->tryFold->if->result->isKnown->if->thisGuard->getCondition->pendingGuard->asNode->canScheduleAbove->result->toBoolean->foldGuard->return->return
ConditionalEliminationPhase.Instance#canScheduleAbove(Node, Node, ValueNode)::: instance can schedule above:::targetBlock->nodeToBlock->get->testBlock->nodeToBlock->get->if->if->foreach->blockToNodes->get->if->return->else->if->break->else->if->AbstractControlFlowGraph->dominates->return->v->new->InputFilter->n->applyInputs->return
ConditionalEliminationPhase.Instance#foldGuard(DeoptimizingGuard, DeoptimizingGuard, boolean, Stamp, GuardRewirer)::: instance fold guard:::action->otherGuard->getAction->thisGuard->getAction->mergeActions->if->otherGuard->getSpeculation->thisGuard->getSpeculation->condition->thisGuard->getCondition->copyWithInputs->thisGuard->setAction->rewirer->mustDeopt->otherGuard->isNegated->if->rewireGuardFunction->thisGuard->isNegated->rewire->if->otherGuard->thisGuard->isNegated->setCondition->otherGuard->setAction->otherGuard->thisGuard->getReason->setReason->return->condition->safeDelete->return->return->rewireGuards->return
ConditionalEliminationPhase.Instance#registerCondition(LogicNode, boolean, GuardingNode)::: instance register condition:::if->condition->hasMoreThanOneUsage->StampFactory->contradiction->StampFactory->tautology->registerNewStamp->conditions->new->GuardedCondition->push
ConditionalEliminationPhase.Instance#getInfoElements(ValueNode)::: instance get info elements:::if->return->infoElement->map->getAndGrow->if->map->GraphUtil->skipPi->getAndGrow->return
ConditionalEliminationPhase.Instance#rewireGuards(GuardingNode, boolean, ValueNode, Stamp, GuardRewirer)::: instance rewire guards:::counterStampsFound->increment->return->rewireGuardFunction->rewire
ConditionalEliminationPhase.Instance#tryProveCondition(LogicNode, GuardRewirer)::: instance try prove condition:::return->tryProveGuardCondition
ConditionalEliminationPhase.Instance#nextElement(InfoElement)::: instance next element:::parent->current->getParent->if->return->else->proxifiedInput->current->getProxifiedInput->if->piNode->return->piNode->getOriginalNode->getInfoElements->return
ConditionalEliminationPhase.Instance#tryProveGuardCondition(DeoptimizingGuard, LogicNode, GuardRewirer)::: instance try prove guard condition:::infoElement->getInfoElements->while->stamp->infoElement->getStamp->constant->stamp->asConstant->if->return->infoElement->getGuard->constant->asBoolean->rewireGuards->nextElement->foreach->result->guardedCondition->getCondition->guardedCondition->isNegated->implies->if->result->isKnown->return->result->toBoolean->rewireGuards->if->unaryLogicNode->value->unaryLogicNode->getValue->getInfoElements->while->stamp->infoElement->getStamp->result->unaryLogicNode->tryFold->if->result->isKnown->return->infoElement->getGuard->result->toBoolean->infoElement->getProxifiedInput->infoElement->getStamp->rewireGuards->nextElement->foldResult->recursiveFoldStampFromInfo->if->result->unaryLogicNode->foldResult->getRight->tryFold->if->result->isKnown->return->foldResult->getLeft->getGuard->result->toBoolean->foldResult->getLeft->getProxifiedInput->foldResult->getRight->rewireGuards->if->newStamp->unaryLogicNode->thisGuard->isNegated->getSucceedingStampForValue->if->foldPendingTest->return->else->if->binaryOpLogicNode->x->binaryOpLogicNode->getX->y->binaryOpLogicNode->getY->getInfoElements->while->result->binaryOpLogicNode->infoElement->getStamp->y->stamp->tryFold->if->result->isKnown->return->infoElement->getGuard->result->toBoolean->infoElement->getProxifiedInput->infoElement->getStamp->rewireGuards->nextElement->if->y->isConstant->foldResult->recursiveFoldStampFromInfo->if->result->binaryOpLogicNode->foldResult->getRight->y->stamp->tryFold->if->result->isKnown->return->foldResult->getLeft->getGuard->result->toBoolean->foldResult->getLeft->getProxifiedInput->foldResult->getRight->rewireGuards->else->getInfoElements->while->result->binaryOpLogicNode->x->stamp->infoElement->getStamp->tryFold->if->result->isKnown->return->infoElement->getGuard->result->toBoolean->infoElement->getProxifiedInput->infoElement->getStamp->rewireGuards->nextElement->if->y->isConstant->binary->if->binary->getY->isConstant->binary->getX->getInfoElements->while->newStampX->binary->infoElement->getStamp->binary->getY->stamp->foldStamp->result->binaryOpLogicNode->y->stamp->tryFold->if->result->isKnown->return->infoElement->getGuard->result->toBoolean->infoElement->getProxifiedInput->rewireGuards->nextElement->if->thisGuard->isNegated->if->y->isConstant->and->if->and->getY->op->ArithmeticOpTable->x->stamp->forStamp->getOr->newStampX->op->and->getX->getSafeStamp->getOtherSafeStamp->foldStamp->if->and->getX->foldPendingTest->return->if->if->x->isConstant->newStampX->binaryOpLogicNode->thisGuard->isNegated->getSafeStamp->getOtherSafeStamp->getSucceedingStampForX->if->foldPendingTest->return->if->y->isConstant->newStampY->binaryOpLogicNode->thisGuard->isNegated->getOtherSafeStamp->getSafeStamp->getSucceedingStampForY->if->foldPendingTest->return->else->if->shortCircuitOrNode->return->shortCircuitOrNode->getX->if->shortCircuitOrNode->isXNegated->return->rewireGuards->else->return->shortCircuitOrNode->getY->proxifiedInput->if->else->if->if->return->if->return->shortCircuitOrNode->isYNegated->rewireGuards->return->tryProveCondition->tryProveCondition->return
ConditionalEliminationPhase.Instance#registerNewStamp(ValueNode, Stamp, GuardingNode)::: instance register new stamp:::registerNewStamp
ConditionalEliminationPhase.Instance#registerNewStamp(ValueNode, Stamp, GuardingNode, boolean)::: instance register new stamp:::if->newStamp->isUnrestricted->return->value->stamp->while->proxiedValue->if->counterStampsRegistered->increment->debug->log->map->map->getAndGrow->new->InfoElement->setAndGrow->undoOperations->push->if->piNode->piNode->getOriginalNode->else->if->stampInverter->stampInverter->getValue->stampInverter->invertStamp->else->break
ConditionalEliminationPhase.Instance#processAbstractBegin(AbstractBeginNode)::: instance process abstract begin:::predecessor->beginNode->predecessor->if->ifNode->negated->ifNode->falseSuccessor->condition->ifNode->condition->registerNewCondition->else->if->typeSwitch->processTypeSwitch->else->if->integerSwitchNode->processIntegerSwitch
ConditionalEliminationPhase.Instance#maybeMultipleUsages(ValueNode)::: instance maybe multiple usages:::if->value->hasMoreThanOneUsage->return->else->return
ConditionalEliminationPhase.Instance#processIntegerSwitch(AbstractBeginNode, IntegerSwitchNode)::: instance process integer switch:::value->integerSwitchNode->value->if->maybeMultipleUsages->stamp->integerSwitchNode->getValueStampForSuccessor->if->registerNewStamp
ConditionalEliminationPhase.Instance#processTypeSwitch(AbstractBeginNode, TypeSwitchNode)::: instance process type switch:::hub->typeSwitch->value->if->loadHub->value->loadHub->getValue->if->maybeMultipleUsages->stamp->typeSwitch->getValueStampForSuccessor->if->registerNewStamp
ConditionalEliminationPhase.Instance#exit(Block, Marks)::: instance exit:::infoElementsMark->while->undoOperations->size->node->undoOperations->pop->if->node->isAlive->map->map->get->getParent->set->conditionsMark->while->conditions->size->conditions->pop
ConditionalEliminationPhase.InfoElementProvider#getInfoElements(ValueNode)::: info element provider get info elements:::
ConditionalEliminationPhase.InputFilter#apply(Node, Node)::: input filter apply:::if->return->if->return->curValue->if->curValue->isConstant->return->if->curValue->applyInputs->else->return
ConditionalEliminationPhase.GuardRewirer#rewire(GuardingNode, boolean, Stamp, ValueNode):::Called if the condition could be proven to have a constant value (result) under guard.:::
ConditionalEliminationPhase.InfoElement#getParent()::: info element get parent:::return
ConditionalEliminationPhase.InfoElement#getStamp()::: info element get stamp:::return
ConditionalEliminationPhase.InfoElement#getGuard()::: info element get guard:::return
ConditionalEliminationPhase.InfoElement#getProxifiedInput()::: info element get proxified input:::return
ConditionalEliminationPhase.InfoElement#toString()::: info element to string:::return
ConditionalEliminationPhase#codeSizeIncrease()::: conditional elimination phase code size increase:::return
DeadCodeEliminationPhase#run(StructuredGraph)::: dead code elimination phase run:::if->graph->getOptions->getValue->return->flood->graph->createNodeFlood->totalNodeCount->graph->getNodeCount->flood->graph->start->add->iterateSuccessorsAndInputs->changed->foreach->graph->getNodes->if->flood->guard->getAnchor->asNode->isMarked->flood->add->if->iterateSuccessorsAndInputs->totalMarkedCount->flood->getTotalMarkedCount->if->return->else->deleteNodes
DeadCodeEliminationPhase#iterateSuccessorsAndInputs(NodeFlood)::: dead code elimination phase iterate successors and inputs:::consumer->new->Node.EdgeVisitor->foreach->if->end->flood->end->merge->add->else->current->applySuccessors->current->applyInputs
DeadCodeEliminationPhase#deleteNodes(NodeFlood, StructuredGraph)::: dead code elimination phase delete nodes:::consumer->new->Node.EdgeVisitor->debug->graph->getDebug->foreach->graph->getNodes->if->flood->isMarked->node->markDeleted->node->applyInputs->counterNodesRemoved->increment
DeoptimizationGroupingPhase#run(StructuredGraph, MidTierContext)::: deoptimization grouping phase run:::cfg->foreach->graph->getNodes->iterator->fs->usages->filter->iterator->if->iterator->hasNext->continue->first->iterator->next->if->iterator->hasNext->continue->if->ControlFlowGraph->compute->merge->graph->new->MergeNode->add->firstEnd->graph->new->EndNode->add->actionAndReason->first->context->getMetaAccess->getActionAndReason->speculation->first->context->getMetaAccess->getSpeculation->reasonActionPhi->graph->StampFactory->actionAndReason->getStackKind->forKind->new->ValuePhiNode->addWithoutUnique->speculationPhi->graph->StampFactory->speculation->getStackKind->forKind->new->ValuePhiNode->addWithoutUnique->merge->addForwardEnd->reasonActionPhi->addInput->speculationPhi->addInput->first->replaceAtPredecessor->exitLoops->dynamicDeopt->try->position->first->withNodeSourcePosition->new->DynamicDeoptimizeNode->merge->graph->add->setNext->catch->finally->obsoletes->new->LinkedList<>->obsoletes->add->do->deopt->iterator->next->newEnd->graph->new->EndNode->add->merge->addForwardEnd->reasonActionPhi->deopt->context->getMetaAccess->getActionAndReason->addInput->speculationPhi->deopt->context->getMetaAccess->getSpeculation->addInput->deopt->replaceAtPredecessor->exitLoops->obsoletes->add->while->iterator->hasNext->dynamicDeopt->setStateBefore->foreach->obsolete->safeDelete
DeoptimizationGroupingPhase#exitLoops(AbstractDeoptimizeNode, EndNode, ControlFlowGraph)::: deoptimization grouping phase exit loops:::block->cfg->blockFor->loop->block->getLoop->while->end->graph->end->graph->loop->getHeader->getBeginNode->new->LoopExitNode->add->addBeforeFixed->loop->getParent
DeoptimizationGroupingPhase#codeSizeIncrease()::: deoptimization grouping phase code size increase:::return
ExpandLogicPhase#run(StructuredGraph)::: expand logic phase run:::foreach->graph->getNodes->processBinary->foreach->graph->getNodes->try->context->logic->withNodeSourcePosition->processNormalizeCompareNode->catch->finally->graph->setAfterExpandLogic
ExpandLogicPhase#processNormalizeCompareNode(NormalizeCompareNode)::: expand logic phase process normalize compare node:::equalComp->lessComp->graph->normalize->graph->x->normalize->getX->y->normalize->getY->if->x->stamp->graph->FloatEqualsNode->create->addOrUniqueWithInputs->graph->FloatLessThanNode->normalize->isUnorderedLess->create->addOrUniqueWithInputs->else->graph->IntegerEqualsNode->create->addOrUniqueWithInputs->graph->IntegerLessThanNode->create->addOrUniqueWithInputs->stamp->normalize->stamp->equalValue->graph->ConstantNode->forIntegerStamp->ConstantNode->forIntegerStamp->new->ConditionalNode->unique->value->graph->ConstantNode->forIntegerStamp->new->ConditionalNode->unique->normalize->replaceAtUsagesAndDelete
ExpandLogicPhase#processBinary(ShortCircuitOrNode)::: expand logic phase process binary:::while->binary->usages->isNotEmpty->usage->binary->usages->first->try->nsp->usage->withNodeSourcePosition->if->processBinary->else->if->binary->getX->binary->isXNegated->binary->getY->binary->isYNegated->binary->getShortCircuitProbability->processIf->else->if->binary->getX->binary->isXNegated->binary->getY->binary->isYNegated->processConditional->else->throw->GraalError->shouldNotReachHere->catch->finally->binary->safeDelete
ExpandLogicPhase#processIf(LogicNode, boolean, LogicNode, boolean, IfNode, double)::: expand logic phase process if:::trueTarget->ifNode->trueSuccessor->falseTarget->ifNode->falseSuccessor->firstIfTrueProbability->secondIfTrueProbability->ifNode->getTrueSuccessorProbability->sanitizeProbability->expectedOriginalIfTrueProbability->if->ifNode->getTrueSuccessorProbability->doubleEquals->ifNode->getTrueSuccessorProbability->ifNode->probability->sanitizeProbability->ifNode->clearSuccessors->graph->ifNode->graph->trueTargetMerge->graph->new->MergeNode->add->trueTargetMerge->setNext->firstTrueEnd->graph->new->EndNode->add->secondTrueEnd->graph->new->EndNode->add->trueTargetMerge->addForwardEnd->trueTargetMerge->addForwardEnd->firstTrueTarget->BeginNode->begin->firstTrueTarget->trueTarget->getNodeSourcePosition->setNodeSourcePosition->secondTrueTarget->BeginNode->begin->secondTrueTarget->trueTarget->getNodeSourcePosition->setNodeSourcePosition->if->if->secondIf->new->IfNode->secondIf->ifNode->getNodeSourcePosition->setNodeSourcePosition->secondIfBegin->BeginNode->graph->add->begin->secondIfBegin->falseTarget->getNodeSourcePosition->setNodeSourcePosition->firstIf->graph->new->IfNode->add->firstIf->ifNode->getNodeSourcePosition->setNodeSourcePosition->ifNode->replaceAtPredecessor->ifNode->safeDelete
ExpandLogicPhase#doubleEquals(double, double)::: expand logic phase double equals:::return
ExpandLogicPhase#sanitizeProbability(double)::: expand logic phase sanitize probability:::newValue->Math->Math->max->min->if->Double->isNaN->return
ExpandLogicPhase#processConditional(LogicNode, boolean, LogicNode, boolean, ConditionalNode)::: expand logic phase process conditional:::try->context->conditional->withNodeSourcePosition->trueTarget->conditional->trueValue->falseTarget->conditional->falseValue->graph->conditional->graph->secondConditional->graph->new->ConditionalNode->unique->firstConditional->graph->new->ConditionalNode->unique->conditional->replaceAndDelete->catch->finally
ExpandLogicPhase#checkContract()::: expand logic phase check contract:::return
FixReadsPhase#codeSizeIncrease()::: fix reads phase code size increase:::return
FixReadsPhase.FixReadsClosure#processNode(Node)::: fix reads closure process node:::if->mergeNode->foreach->mergeNode->memoryPhis->snapshot->memoryPhi->replaceAtUsages->memoryPhi->safeDelete->else->if->floatingAccessNode->floatingAccessNode->setLastLocationAccess->guard->floatingAccessNode->getGuard->if->floatingAccessNode->setGuard->GraphUtil->guard->asNode->tryKillUnused->fixedAccess->floatingAccessNode->asFixedNode->replaceCurrent->else->if->piNode->if->piNode->stamp->piNode->getOriginalNode->stamp->isCompatible->piNode->piNode->getOriginalNode->replaceAndDelete->else->if->memoryAccess->memoryAccess->setLastLocationAccess
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#getAssumptions()::: raw canonicalizer tool get assumptions:::return->graph->getAssumptions
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#getMetaAccess()::: raw canonicalizer tool get meta access:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#getConstantReflection()::: raw canonicalizer tool get constant reflection:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#getConstantFieldProvider()::: raw canonicalizer tool get constant field provider:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#canonicalizeReads()::: raw canonicalizer tool canonicalize reads:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#allUsagesAvailable()::: raw canonicalizer tool all usages available:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#smallestCompareWidth()::: raw canonicalizer tool smallest compare width:::return
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#getOptions()::: raw canonicalizer tool get options:::return->graph->getOptions
FixReadsPhase.RawConditionalEliminationVisitor.RawCanonicalizerTool#stamp(ValueNode)::: raw canonicalizer tool stamp:::return->getBestStamp
FixReadsPhase.RawConditionalEliminationVisitor#replaceInput(Position, Node, Node)::: raw conditional elimination visitor replace input:::p->set
FixReadsPhase.RawConditionalEliminationVisitor#replaceConstantInputs(Node)::: raw conditional elimination visitor replace constant inputs:::replacements->foreach->node->inputPositions->input->p->get->if->p->getInputType->if->valueNode->if->else->bestStamp->getBestStamp->constant->bestStamp->asConstant->if->if->floatStamp->if->floatStamp->contains->continue->counterConstantInputReplacements->node->getDebug->increment->stampConstant->ConstantNode->forConstant->replaceInput->return
FixReadsPhase.RawConditionalEliminationVisitor#processNode(Node)::: raw conditional elimination visitor process node:::if->replaceConstantInputs->if->registerCombinedStamps->if->processAbstractBegin->else->if->processIf->else->if->processIntegerSwitch->else->if->processBinary->else->if->processConditional->else->if->processUnary->else->if->processEnd
FixReadsPhase.RawConditionalEliminationVisitor#registerCombinedStamps(MergeNode)::: raw conditional elimination visitor register combined stamps:::endMap->endMaps->get->entries->endMap->getEntries->while->entries->advance->value->entries->getKey->if->value->isDeleted->continue->if->entries->getValue->registerNewValueStamp->counterBetterMergedStamps->increment
FixReadsPhase.RawConditionalEliminationVisitor#processEnd(EndNode)::: raw conditional elimination visitor process end:::abstractMerge->node->merge->if->merge->blockToNodeMap->getNodeToBlockMap->mergeBlock->blockToNodeMap->get->mergeBlockDominator->mergeBlock->getDominator->currentBlock->blockToNodeMap->get->currentEndMap->endMaps->get->if->currentEndMap->isEmpty->endMap->EconomicMap->create->foreach->merge->valuePhis->if->currentEndMap->containsKey->valueAt->phi->valueAt->bestStamp->getBestStamp->if->bestStamp->currentEndMap->get->meet->if->bestStamp->phi->stamp->equals->endMap->put->lastMark->undoOperations->size->while->mark->blockActionStart->get->for->i->currentBlock->getDominator->endMaps->put
FixReadsPhase.RawConditionalEliminationVisitor#getBlock(ValueNode, NodeMap)::: raw conditional elimination visitor get block:::if->phiNode->return->blockToNodeMap->phiNode->merge->get->return->blockToNodeMap->get
FixReadsPhase.RawConditionalEliminationVisitor#processUnary(UnaryNode)::: raw conditional elimination visitor process unary:::value->node->getValue->bestStamp->getBestStamp->newStamp->node->foldStamp->if->checkReplaceWithConstant->if->bestStamp->value->stamp->equals->newNode->node->canonical->if->if->newNode->isAlive->graph->addWithoutUniqueWithInputs->node->replaceAndDelete->GraphUtil->tryKillUnused->return->registerNewValueStamp
FixReadsPhase.RawConditionalEliminationVisitor#checkReplaceWithConstant(Stamp, ValueNode)::: raw conditional elimination visitor check replace with constant:::constant->newStamp->asConstant->if->stampConstant->ConstantNode->forConstant->debug->log->counterConstantReplacements->increment->node->replaceAtUsages->GraphUtil->tryKillUnused->return->return
FixReadsPhase.RawConditionalEliminationVisitor#processBinary(BinaryNode)::: raw conditional elimination visitor process binary:::x->node->getX->y->node->getY->xStamp->getBestStamp->yStamp->getBestStamp->newStamp->node->foldStamp->if->checkReplaceWithConstant->if->xStamp->x->stamp->equals->yStamp->y->stamp->equals->newNode->node->canonical->if->if->newNode->isAlive->graph->addWithoutUniqueWithInputs->node->replaceAndDelete->GraphUtil->tryKillUnused->GraphUtil->tryKillUnused->return->registerNewValueStamp
FixReadsPhase.RawConditionalEliminationVisitor#processIntegerSwitch(IntegerSwitchNode)::: raw conditional elimination visitor process integer switch:::bestStamp->node->value->getBestStamp->if->node->tryRemoveUnreachableKeys->debug->node->value->log->counterCanonicalizedSwitches->increment
FixReadsPhase.RawConditionalEliminationVisitor#processIf(IfNode)::: raw conditional elimination visitor process if:::result->node->condition->tryProveCondition->if->isTrue->survivingSuccessor->node->getSuccessor->survivingSuccessor->replaceAtUsages->survivingSuccessor->replaceAtPredecessor->node->replaceAtPredecessor->GraphUtil->killCFG->counterIfsKilled->increment
FixReadsPhase.RawConditionalEliminationVisitor#processConditional(ConditionalNode)::: raw conditional elimination visitor process conditional:::result->node->condition->tryProveCondition->if->isTrue->counterConditionalsKilled->increment->node->node->trueValue->node->falseValue->replaceAndDelete->else->trueStamp->node->trueValue->getBestStamp->falseStamp->node->falseValue->getBestStamp->trueStamp->meet->registerNewStamp
FixReadsPhase.RawConditionalEliminationVisitor#tryProveCondition(LogicNode)::: raw conditional elimination visitor try prove condition:::conditionStamp->this->getBestStamp->if->StampFactory->tautology->return->else->if->StampFactory->contradiction->return->if->unaryOpLogicNode->return->unaryOpLogicNode->this->unaryOpLogicNode->getValue->getBestStamp->tryFold->else->if->binaryOpLogicNode->return->binaryOpLogicNode->this->binaryOpLogicNode->getX->getBestStamp->this->binaryOpLogicNode->getY->getBestStamp->tryFold->return
FixReadsPhase.RawConditionalEliminationVisitor#processAbstractBegin(AbstractBeginNode)::: raw conditional elimination visitor process abstract begin:::predecessor->beginNode->predecessor->if->ifNode->negated->ifNode->falseSuccessor->condition->ifNode->condition->registerNewCondition->else->if->integerSwitchNode->registerIntegerSwitch
FixReadsPhase.RawConditionalEliminationVisitor#registerIntegerSwitch(AbstractBeginNode, IntegerSwitchNode)::: raw conditional elimination visitor register integer switch:::integerSwitchNode->value->integerSwitchNode->getValueStampForSuccessor->registerNewValueStamp
FixReadsPhase.RawConditionalEliminationVisitor#registerNewCondition(LogicNode, boolean)::: raw conditional elimination visitor register new condition:::if->unaryLogicNode->value->unaryLogicNode->getValue->newStamp->unaryLogicNode->getSucceedingStampForValue->registerNewValueStamp->else->if->binaryOpLogicNode->x->binaryOpLogicNode->getX->y->binaryOpLogicNode->getY->xStamp->getBestStamp->yStamp->getBestStamp->binaryOpLogicNode->getSucceedingStampForX->registerNewValueStamp->binaryOpLogicNode->getSucceedingStampForY->registerNewValueStamp->registerCondition
FixReadsPhase.RawConditionalEliminationVisitor#registerCondition(LogicNode, boolean)::: raw conditional elimination visitor register condition:::StampFactory->contradiction->StampFactory->tautology->registerNewStamp
FixReadsPhase.RawConditionalEliminationVisitor#registerNewValueStamp(ValueNode, Stamp)::: raw conditional elimination visitor register new value stamp:::if->value->isConstant->currentStamp->getBestStamp->betterStamp->currentStamp->tryImproveWith->if->registerNewStamp->return->return
FixReadsPhase.RawConditionalEliminationVisitor#registerNewStamp(ValueNode, Stamp)::: raw conditional elimination visitor register new stamp:::counterStampsRegistered->increment->debug->log->originalNode->stampMap->stampMap->getAndGrow->new->StampElement->setAndGrow->undoOperations->push
FixReadsPhase.RawConditionalEliminationVisitor#getBestStamp(ValueNode)::: raw conditional elimination visitor get best stamp:::originalNode->if->value->isAlive->return->value->stamp->currentStamp->stampMap->getAndGrow->if->return->value->stamp->return->currentStamp->getStamp
FixReadsPhase.RawConditionalEliminationVisitor#enter(Block)::: raw conditional elimination visitor enter:::mark->undoOperations->size->blockActionStart->put->foreach->schedule->getBlockToNodesMap->get->if->n->isAlive->processNode->return
FixReadsPhase.RawConditionalEliminationVisitor#exit(Block, Integer)::: raw conditional elimination visitor exit:::mark->while->undoOperations->size->node->undoOperations->pop->if->node->isAlive->stampMap->stampMap->get->getParent->set
FixReadsPhase#run(StructuredGraph, LowTierContext)::: fix reads phase run:::schedulePhase->apply->schedule->graph->getLastSchedule->fixReadsClosure->new->FixReadsClosure->foreach->schedule->getCFG->getBlocks->fixReadsClosure->processNodes->if->graph->getOptions->getValue->schedule->getCFG->createVisitor->visitDominatorTree->graph->setAfterFixReadPhase
FixReadsPhase.RawCEPhase#getName()::: raw phase get name:::return
FixReadsPhase.RawCEPhase#run(StructuredGraph, LowTierContext)::: raw phase run:::if->graph->getOptions->getValue->schedulePhase->new->SchedulePhase->schedulePhase->apply->schedule->graph->getLastSchedule->schedule->getCFG->context->getMetaAccess->new->RawConditionalEliminationVisitor->visitDominatorTree
FixReadsPhase#createVisitor(StructuredGraph, ScheduleResult, CoreProviders)::: fix reads phase create visitor:::return->context->getMetaAccess->new->RawConditionalEliminationVisitor
FixReadsPhase.StampElement#getParent()::: stamp element get parent:::return
FixReadsPhase.StampElement#getStamp()::: stamp element get stamp:::return
FixReadsPhase.StampElement#toString()::: stamp element to string:::result->new->StringBuilder->result->append->if->result->append->result->toString->append->result->append->return->result->toString
FixReadsPhase#setReplaceInputsWithConstants(boolean)::: fix reads phase set replace inputs with constants:::
FloatingReadPhase.MemoryMapImpl#getLastLocationAccess(LocationIdentity)::: memory map impl get last location access:::lastLocationAccess->if->locationIdentity->isImmutable->return->else->lastMemorySnapshot->get->if->lastMemorySnapshot->any->get->return
FloatingReadPhase.MemoryMapImpl#getLocations()::: memory map impl get locations:::return->lastMemorySnapshot->getKeys
FloatingReadPhase.MemoryMapImpl#getMap()::: memory map impl get map:::return
FloatingReadPhase#codeSizeIncrease()::: floating read phase code size increase:::return
FloatingReadPhase#removeExternallyUsedNodes(EconomicSet):::Removes nodes from a given set that (transitively) have a usage outside the set.:::change->do->for->iter->set->iterator->iter->hasNext->while->return
FloatingReadPhase#processNode(FixedNode, EconomicSet)::: floating read phase process node:::if->getLocationIdentity->processIdentity->else->if->foreach->getLocationIdentities->processIdentity
FloatingReadPhase#processIdentity(EconomicSet, LocationIdentity)::: floating read phase process identity:::if->identity->isMutable->currentState->add
FloatingReadPhase#processBlock(Block, EconomicSet)::: floating read phase process block:::foreach->b->getNodes->processNode
FloatingReadPhase#processLoop(HIRLoop, EconomicMap>)::: floating read phase process loop:::loopBegin->loop->getHeader->getBeginNode->result->modifiedInLoops->get->if->return->EconomicSet->create->foreach->loop->getChildren->result->processLoop->addAll->foreach->loop->getBlocks->if->b->getLoop->processBlock->modifiedInLoops->put->return
FloatingReadPhase#run(StructuredGraph)::: floating read phase run:::modifiedInLoops->if->graph->hasLoops->EconomicMap->create->cfg->ControlFlowGraph->compute->foreach->cfg->getLoops->loop->processLoop->listener->EnumSet->of->new->EconomicSetNodeEventListener->try->nes->graph->trackNodeEvents->ReentrantNodeIterator->new->FloatingReadClosure->graph->start->graph->start->new->MemoryMapImpl->apply->catch->finally->foreach->listener->getNodes->removeExternallyUsedNodes->if->n->isAlive->n->replaceAtUsages->GraphUtil->killWithUnusedFloatingInputs->if->graph->setAfterFloatingReadPhase
FloatingReadPhase#mergeMemoryMaps(AbstractMergeNode, List)::: floating read phase merge memory maps:::newState->new->MemoryMapImpl->keys->EconomicSet->create->foreach->keys->other->getLocations->addAll->foreach->mergedStatesCount->isPhi->merged->foreach->last->state->getLastLocationAccess->if->ValueNodeUtil->asNode->addInput->else->if->else->if->else->phi->merge->graph->new->MemoryPhiNode->addWithoutUnique->for->j->phi->ValueNodeUtil->asNode->addInput->put->return
FloatingReadPhase#checkNoImmutableLocations(EconomicSet)::: floating read phase check no immutable locations:::keys->forEach->return
FloatingReadPhase.FloatingReadClosure#processNode(FixedNode, MemoryMapImpl)::: floating read closure process node:::if->processAnchor->return->if->processAccess->if->processFloatable->else->if->processCheckpoint->else->if->processCheckpoint->if->node->graph->new->MemoryMapNode->unique->setMemoryMap->return
FloatingReadPhase.FloatingReadClosure#processAnchor(MemoryAnchorNode, MemoryMapImpl):::Improve the memory graph by re-wiring all usages of a MemoryAnchorNode to the real last access location.:::foreach->anchor->usages->snapshot->if->access->if->access->getLastLocationAccess->lastLocationAccess->state->access->getLocationIdentity->getLastLocationAccess->access->setLastLocationAccess->if->anchor->hasNoUsages->anchor->graph->removeFixed
FloatingReadPhase.FloatingReadClosure#processAccess(MemoryAccess, MemoryMapImpl)::: floating read closure process access:::locationIdentity->access->getLocationIdentity->if->locationIdentity->LocationIdentity->any->equals->lastLocationAccess->state->getLastLocationAccess->access->setLastLocationAccess
FloatingReadPhase.FloatingReadClosure#processCheckpoint(MemoryCheckpoint.Single, MemoryMapImpl)::: floating read closure process checkpoint:::checkpoint->getLocationIdentity->processIdentity
FloatingReadPhase.FloatingReadClosure#processCheckpoint(MemoryCheckpoint.Multi, MemoryMapImpl)::: floating read closure process checkpoint:::foreach->checkpoint->getLocationIdentities->processIdentity
FloatingReadPhase.FloatingReadClosure#processIdentity(LocationIdentity, MemoryCheckpoint, MemoryMapImpl)::: floating read closure process identity:::if->identity->isAny->clear->if->identity->isMutable->put
FloatingReadPhase.FloatingReadClosure#processFloatable(FloatableAccessNode, MemoryMapImpl)::: floating read closure process floatable:::graph->accessNode->graph->locationIdentity->accessNode->getLocationIdentity->if->accessNode->canFloat->lastLocationAccess->state->getLastLocationAccess->try->position->accessNode->withNodeSourcePosition->floatingNode->accessNode->asFloatingNode->graph->replaceFixedWithFloating->catch->finally
FloatingReadPhase.FloatingReadClosure#merge(AbstractMergeNode, List)::: floating read closure merge:::return->mergeMemoryMaps
FloatingReadPhase.FloatingReadClosure#afterSplit(AbstractBeginNode, MemoryMapImpl)::: floating read closure after split:::result->new->MemoryMapImpl->if->node->predecessor->invoke->node->predecessor->invoke->getLocationIdentity->put->return
FloatingReadPhase.FloatingReadClosure#processLoop(LoopBeginNode, MemoryMapImpl)::: floating read closure process loop:::modifiedLocations->modifiedInLoops->get->phis->EconomicMap->create->if->modifiedLocations->LocationIdentity->any->contains->EconomicSet->create->modifiedLocations->getKeys->addAll->foreach->createMemoryPhi->putAll->loopInfo->ReentrantNodeIterator->processLoop->endStateCursor->getEntries->while->endStateCursor->advance->endIndex->loop->endStateCursor->getKey->phiPredecessorIndex->phiCursor->phis->getEntries->while->phiCursor->advance->key->phiCursor->getKey->phi->phiCursor->getValue->phi->ValueNodeUtil->endStateCursor->getValue->getLastLocationAccess->asNode->initializeValueAt->return
FloatingReadPhase.FloatingReadClosure#createMemoryPhi(LoopBeginNode, MemoryMapImpl, EconomicMap, LocationIdentity)::: floating read closure create memory phi:::phi->loop->graph->new->MemoryPhiNode->addWithoutUnique->phi->ValueNodeUtil->initialState->getLastLocationAccess->asNode->addInput->phis->put
FrameStateAssignmentPhase.FrameStateAssignmentClosure#processNode(FixedNode, FrameState)::: frame state assignment closure process node:::currentState->if->deopt->if->deopt->canDeoptimize->deopt->stateBefore->GraalError->guarantee->deopt->setStateBefore->if->stateSplit->stateAfter->stateSplit->stateAfter->if->if->else->stateSplit->setStateAfter->if->deopt->if->deopt->canDeoptimize->GraalError->guarantee->deopt->computeStateDuring->if->deopt->if->deopt->canDeoptimize->deopt->stateAfter->GraalError->guarantee->deopt->setStateAfter->return
FrameStateAssignmentPhase.FrameStateAssignmentClosure#merge(AbstractMergeNode, List)::: frame state assignment closure merge:::singleFrameState->singleFrameState->return->merge->stateAfter
FrameStateAssignmentPhase.FrameStateAssignmentClosure#afterSplit(AbstractBeginNode, FrameState)::: frame state assignment closure after split:::return
FrameStateAssignmentPhase.FrameStateAssignmentClosure#processLoop(LoopBeginNode, FrameState)::: frame state assignment closure process loop:::return->ReentrantNodeIterator->processLoop
FrameStateAssignmentPhase#run(StructuredGraph)::: frame state assignment phase run:::if->graph->getGuardsStage->areFrameStatesAtSideEffects->ReentrantNodeIterator->new->FrameStateAssignmentClosure->graph->start->apply->graph->setGuardsStage->graph->getNodes->state->hasNoUsages->filter->GraphUtil->killWithUnusedFloatingInputs->forEach
FrameStateAssignmentPhase#hasFloatingDeopts(StructuredGraph)::: frame state assignment phase has floating deopts:::foreach->graph->getNodes->if->GraphUtil->isFloatingNode->deoptimizingNode->if->deoptimizingNode->canDeoptimize->return->return
FrameStateAssignmentPhase#singleFrameState(List)::: frame state assignment phase single frame state:::singleState->states->get->for->i->states->size->if->return->return
FrameStateAssignmentPhase#checkContract()::: frame state assignment phase check contract:::return
GuardLoweringPhase.LowerGuards#processNode(Node)::: lower guards process node:::if->guard->lowered->guard->lowerGuard->if->replaceCurrent->else->lowerToIf
GuardLoweringPhase.LowerGuards#lowerToIf(GuardNode)::: lower guards lower to if:::try->position->guard->withNodeSourcePosition->graph->guard->graph->fastPath->graph->new->BeginNode->add->fastPath->guard->getNoDeoptSuccessorPosition->setNodeSourcePosition->debugId->guard->getId->deopt->graph->guard->getAction->guard->getReason->guard->getSpeculation->new->DeoptimizeNode->add->deoptBranch->BeginNode->begin->trueSuccessor->falseSuccessor->insertLoopExits->if->guard->isNegated->else->ifNode->graph->guard->getCondition->new->IfNode->add->guard->replaceAndDelete->insert->catch->finally
GuardLoweringPhase.LowerGuards#insertLoopExits(DeoptimizeNode)::: lower guards insert loop exits:::loop->block->getLoop->graph->deopt->graph->while->exit->graph->loop->getHeader->getBeginNode->new->LoopExitNode->add->graph->addBeforeFixed->loop->getParent
GuardLoweringPhase#run(StructuredGraph, MidTierContext)::: guard lowering phase run:::if->graph->getGuardsStage->allowsFloatingGuards->schedulePhase->new->SchedulePhase->schedulePhase->apply->schedule->graph->getLastSchedule->foreach->schedule->getCFG->getBlocks->processBlock->graph->setGuardsStage
GuardLoweringPhase#assertNoGuardsLeft(StructuredGraph)::: guard lowering phase assert no guards left:::return
GuardLoweringPhase#processBlock(Block, ScheduleResult)::: guard lowering phase process block:::debug->block->getBeginNode->getDebug->debug->isDumpEnabledForMethod->debug->isLogEnabledForMethod->new->LowerGuards->processNodes
IncrementalCanonicalizerPhase#run(StructuredGraph, C)::: incremental canonicalizer phase run:::listener->new->EconomicSetNodeEventListener->try->nes->graph->trackNodeEvents->super->run->catch->finally->if->listener->getNodes->isEmpty->canonicalizer->listener->getNodes->applyIncremental
InsertGuardFencesPhase#run(StructuredGraph)::: insert guard fences phase run:::foreach->graph->getNodes->if->hasGuardUsages->if->MitigateSpeculativeExecutionAttacks->graph->getOptions->getValue->if->isDeoptGuard->graph->getDebug->log->continue->if->UseIndexMasking->graph->getOptions->getValue->if->isBoundsCheckGuard->graph->getDebug->log->continue->if->graph->getDebug->isLogEnabled->graph->getDebug->guardUsages->log->else->graph->getDebug->log->beginNode->setWithSpeculationFence->else->graph->getDebug->log
InsertGuardFencesPhase#isDeoptGuard(AbstractBeginNode)::: insert guard fences phase is deopt guard:::if->beginNode->predecessor->return->ifNode->beginNode->predecessor->otherBegin->if->ifNode->trueSuccessor->ifNode->falseSuccessor->else->ifNode->trueSuccessor->if->otherBegin->next->return->deopt->otherBegin->next->return->deopt->getAction->doesInvalidateCompilation
InsertGuardFencesPhase#isBoundsCheckGuard(AbstractBeginNode)::: insert guard fences phase is bounds check guard:::if->beginNode->predecessor->return->ifNode->beginNode->predecessor->otherBegin->if->ifNode->trueSuccessor->ifNode->falseSuccessor->else->ifNode->trueSuccessor->if->otherBegin->next->deopt->otherBegin->next->if->deopt->getReason->hasMultipleGuardUsages->return->else->if->beginNode->usages->filter->isNotEmpty->hasMultipleGuardUsages->return->foreach->beginNode->usages->foreach->usage->inputPositions->if->pos->getInputType->pos->get->if->if->piStamp->equals->return->else->if->if->NamedLocationIdentity->getLocationIdentity->isArrayLocation->return->else->return->break->return
InsertGuardFencesPhase#hasGuardUsages(Node)::: insert guard fences phase has guard usages:::foreach->n->usages->foreach->usage->inputPositions->if->pos->getInputType->pos->get->return->return
InsertGuardFencesPhase#hasMultipleGuardUsages(Node)::: insert guard fences phase has multiple guard usages:::foundOne->foreach->n->usages->foreach->usage->inputPositions->if->pos->getInputType->pos->get->if->return->return
InsertGuardFencesPhase#guardUsages(Node)::: insert guard fences phase guard usages:::ret->new->ArrayList<>->foreach->n->usages->foreach->usage->inputPositions->if->pos->getInputType->pos->get->ret->add->return
IterativeConditionalEliminationPhase#run(StructuredGraph, CoreProviders)::: iterative conditional elimination phase run:::maxIterations->graph->getOptions->getValue->listener->new->EconomicSetNodeEventListener->count->while->try->nes->graph->trackNodeEvents->new->ConditionalEliminationPhase->apply->catch->finally->if->listener->getNodes->isEmpty->break->canonicalizer->listener->getNodes->applyIncremental->listener->getNodes->clear->if->if->if->TTY->println->TTY->println->TTY->println->TTY->println->foreach->listener->getNodes->TTY->n->toString->println->foreach->n->inputs->TTY->println->TTY->println->try->debugNes->graph->new->TracingNodeEventListener->trackNodeEvents->canonicalizer->listener->getNodes->applyIncremental->catch->finally->if->throw->new->PermanentBailoutException->break
IterativeConditionalEliminationPhase#codeSizeIncrease()::: iterative conditional elimination phase code size increase:::return
LazyValue#get()::: lazy value get:::if->supplier->get->return
LockEliminationPhase#run(StructuredGraph)::: lock elimination phase run:::foreach->graph->getNodes->next->monitorExitNode->next->if->monitorEnterNode->if->isCompatibleLock->enterId->monitorEnterNode->getMonitorId->exitId->monitorExitNode->getMonitorId->if->enterId->replaceAndDelete->GraphUtil->removeFixedWithUnusedInputs->GraphUtil->removeFixedWithUnusedInputs
LockEliminationPhase#isCompatibleLock(AccessMonitorNode, AccessMonitorNode):::Check that the paired operations operate on the same object at the same lock depth.:::object1->GraphUtil->lock1->object->unproxify->object2->GraphUtil->lock2->object->unproxify->return->lock1->getMonitorId->getLockDepth->lock2->getMonitorId->getLockDepth
LoopSafepointInsertionPhase#checkContract()::: loop safepoint insertion phase check contract:::return
LoopSafepointInsertionPhase#run(StructuredGraph)::: loop safepoint insertion phase run:::if->GenLoopSafepoints->graph->getOptions->getValue->foreach->graph->getNodes->foreach->loopBeginNode->loopEnds->if->loopEndNode->canSafepoint->try->s->loopEndNode->withNodeSourcePosition->safepointNode->graph->new->SafepointNode->add->graph->addBeforeFixed->catch->finally
LoweringPhase.DummyGuardHandle#getGuard()::: dummy guard handle get guard:::return
LoweringPhase.DummyGuardHandle#setGuard(GuardingNode)::: dummy guard handle set guard:::updateUsagesInterface
LoweringPhase.DummyGuardHandle#asNode()::: dummy guard handle as node:::return
LoweringPhase#checkContract()::: lowering phase check contract:::return
LoweringPhase.LoweringToolImpl#getLoweringStage()::: lowering tool impl get lowering stage:::return
LoweringPhase.LoweringToolImpl#getProviders()::: lowering tool impl get providers:::return
LoweringPhase.LoweringToolImpl#getConstantReflection()::: lowering tool impl get constant reflection:::return->context->getConstantReflection
LoweringPhase.LoweringToolImpl#getConstantFieldProvider()::: lowering tool impl get constant field provider:::return->context->getConstantFieldProvider
LoweringPhase.LoweringToolImpl#getMetaAccess()::: lowering tool impl get meta access:::return->context->getMetaAccess
LoweringPhase.LoweringToolImpl#getLowerer()::: lowering tool impl get lowerer:::return->context->getLowerer
LoweringPhase.LoweringToolImpl#getReplacements()::: lowering tool impl get replacements:::return->context->getReplacements
LoweringPhase.LoweringToolImpl#getForeignCalls()::: lowering tool impl get foreign calls:::return->context->getForeignCalls
LoweringPhase.LoweringToolImpl#getCurrentGuardAnchor()::: lowering tool impl get current guard anchor:::return
LoweringPhase.LoweringToolImpl#createGuard(FixedNode, LogicNode, DeoptimizationReason, DeoptimizationAction)::: lowering tool impl create guard:::return->createGuard
LoweringPhase.LoweringToolImpl#getStampProvider()::: lowering tool impl get stamp provider:::return->context->getStampProvider
LoweringPhase.LoweringToolImpl#createGuard(FixedNode, LogicNode, DeoptimizationReason, DeoptimizationAction, Speculation, boolean, NodeSourcePosition)::: lowering tool impl create guard:::graph->before->graph->if->OptEliminateGuards->graph->getOptions->getValue->foreach->condition->usages->if->activeGuards->isNew->activeGuards->isMarked->isNegated->return->if->condition->graph->getGuardsStage->allowsFloatingGuards->fixedGuard->graph->new->FixedGuardNode->add->graph->addBeforeFixed->handle->graph->new->DummyGuardHandle->add->fixedGuard->lower->result->handle->getGuard->handle->safeDelete->return->else->newGuard->graph->new->GuardNode->unique->if->OptEliminateGuards->graph->getOptions->getValue->activeGuards->markAndGrow->return
LoweringPhase.LoweringToolImpl#lastFixedNode()::: lowering tool impl last fixed node:::return
LoweringPhase.LoweringToolImpl#setLastFixedNode(FixedWithNextNode)::: lowering tool impl set last fixed node:::
LoweringPhase#shouldDumpBeforeAtBasicLevel()::: lowering phase should dump before at basic level:::return
LoweringPhase#checkPostLowering(StructuredGraph, CoreProviders):::Checks that second lowering of a given graph did not introduce any new nodes.:::expectedMark->graph->getMark->lower->mark->graph->getMark->return
LoweringPhase#run(StructuredGraph, CoreProviders)::: lowering phase run:::lower
LoweringPhase#lower(StructuredGraph, CoreProviders, LoweringMode)::: lowering phase lower:::incrementalCanonicalizer->new->IncrementalCanonicalizerPhase<>->incrementalCanonicalizer->graph->getOptions->new->Round->appendPhase->incrementalCanonicalizer->apply
LoweringPhase#checkPostNodeLowering(Node, LoweringToolImpl, Mark, Collection):::Checks that lowering of a given node did not introduce any new Lowerable nodes that could be lowered in the current LoweringPhase:::graph->node->graph->postLoweringMark->graph->getMark->newNodesAfterLowering->graph->getNewNodes->if->if->unscheduledUsages->isEmpty->foreach->foreach->if->lower->mark->graph->getMark->if->graph->isAfterFloatingReadPhase->isAny->if->getLocationIdentity->isAny->else->foreach->getLocationIdentities->if->ident->isAny->if->cur->while->graph->isNew->if->cur->next->break->if->cur->next->cur->next->else->break->return
LoweringPhase.Round#getName()::: round get name:::switch->return->return->throw->GraalError->shouldNotReachHere
LoweringPhase.Round#checkContract()::: round check contract:::return
LoweringPhase.Round#run(StructuredGraph)::: round run:::schedulePhase->apply->graph->getLastSchedule->schedule->getCFG->computePostdominators->startBlock->schedule->getCFG->getStartBlock->rootFrame->graph->createNodeBitMap->startBlock->getBeginNode->new->ProcessFrame->LoweringPhase->processBlock
LoweringPhase.Round.ProcessFrame#preprocess()::: process frame preprocess:::Round.this->process
LoweringPhase.Round.ProcessFrame#enter(Block)::: process frame enter:::return->b->getBeginNode->new->ProcessFrame
LoweringPhase.Round.ProcessFrame#enterAlwaysReached(Block)::: process frame enter always reached:::newAnchor->if->b->getLoop->getLoop->b->isLoopHeader->b->getBeginNode->return->new->ProcessFrame
LoweringPhase.Round.ProcessFrame#postprocess()::: process frame postprocess:::if->block->getBeginNode->OptEliminateGuards->activeGuards->graph->getOptions->getValue->foreach->anchor->asNode->usages->filter->if->activeGuards->isMarkedAndGrow->activeGuards->clear
LoweringPhase.Round#process(Block, NodeBitMap, AnchoringNode)::: round process:::loweringTool->b->getBeginNode->new->LoweringToolImpl->nodes->schedule->nodesFor->foreach->if->node->isDeleted->continue->nextNode->if->next->else->loweringTool->lastFixedNode->next->if->unscheduledUsages->preLoweringMark->node->graph->getMark->try->s->node->graph->withNodeSourcePosition->lower->catch->finally->if->asNode->isDeleted->AbstractBeginNode->prevBegin->if->nextNode->isAlive->break->else->nextLastFixed->nextNode->predecessor->if->begin->node->graph->new->BeginNode->add->nextLastFixed->replaceFirstSuccessor->begin->setNext->loweringTool->setLastFixedNode->return->loweringTool->getCurrentGuardAnchor
LoweringPhase.Round#getUnscheduledUsages(Node):::Gets all usages of a floating, lowerable node that are unscheduled:::unscheduledUsages->new->ArrayList<>->if->foreach->node->usages->if->if->schedule->getCFG->getNodeToBlock->isNew->schedule->getCFG->blockFor->unscheduledUsages->add->return
LoweringPhase#processBlock(Frame):::This state-machine resembles the following recursion:   void processBlock(Block block) {     preprocess();     // Process always reached block first:::state->f->while->nextState->if->f->preprocess->else->if->if->getDominator->f->enterAlwaysReached->else->else->if->if->n->n->getDominatedSibling->if->if->n->getDominatedSibling->else->if->else->f->enter->else->else->if->f->postprocess->else->throw->GraalError->shouldNotReachHere
LoweringPhase#processBlockBounded(Frame)::: lowering phase process block bounded:::state->f->while->nextState->if->f->preprocess->else->if->if->getDominator->continueRecur->f->enterAlwaysReached->if->f->postprocess->continue->else->else->if->if->n->n->getDominatedSibling->if->if->n->getDominatedSibling->else->if->else->continueRecur->f->enter->if->f->postprocess->continue->else->else->if->f->postprocess->else->throw->GraalError->shouldNotReachHere
LoweringPhase.Frame#enterAlwaysReached(Block)::: frame enter always reached:::return->enter
LoweringPhase.Frame#enter(Block)::: frame enter:::
LoweringPhase.Frame#preprocess()::: frame preprocess:::
LoweringPhase.Frame#postprocess()::: frame postprocess:::
NodeCounterPhase#run(StructuredGraph, CoreProviders)::: node counter phase run:::foreach->graph->getNodes->nodeName->node->getNodeClass->getClazz->getSimpleName->DebugContext->counter->node->getDebug->increment
NonNullParametersPhase#run(StructuredGraph)::: non null parameters phase run:::nonNull->StampFactory->objectNonNull->foreach->graph->getNodes->if->param->stamp->paramStamp->param->stamp->param->paramStamp->join->setStamp
OptimizeDivPhase#run(StructuredGraph)::: optimize div phase run:::foreach->graph->getNodes->filter->if->divByNonZeroConstant->optimizeRem->foreach->graph->getNodes->filter->if->divByNonZeroConstant->optimizeSignedDiv
OptimizeDivPhase#codeSizeIncrease()::: optimize div phase code size increase:::return
OptimizeDivPhase#divByNonZeroConstant(IntegerDivRemNode)::: optimize div phase div by non zero constant:::return->divRemNode->getY->isConstant->divRemNode->getY->asJavaConstant->asLong
OptimizeDivPhase#optimizeRem(IntegerDivRemNode)::: optimize div phase optimize rem:::graph->rem->graph->div->findDivForRem->mul->BinaryArithmeticNode->rem->getY->mul->result->BinaryArithmeticNode->rem->getX->sub->graph->replaceFixedWithFloating
OptimizeDivPhase#findDivForRem(IntegerDivRemNode)::: optimize div phase find div for rem:::if->rem->next->div->rem->next->if->div->getOp->div->getType->rem->getType->div->getX->rem->getX->div->getY->rem->getY->return->if->rem->predecessor->div->rem->predecessor->if->div->getOp->div->getType->rem->getType->div->getX->rem->getX->div->getY->rem->getY->return->div->rem->graph->createDiv->addOrUniqueWithInputs->if->rem->graph->addAfterFixed->return
OptimizeDivPhase#createDiv(IntegerDivRemNode)::: optimize div phase create div:::return->SignedDivNode->rem->getX->rem->getY->rem->getZeroCheck->create
OptimizeDivPhase#optimizeSignedDiv(SignedDivNode)::: optimize div phase optimize signed div:::forX->div->getX->c->div->getY->asJavaConstant->asLong->dividendStamp->forX->stamp->bitSize->dividendStamp->getBits->nums->magicDivideConstants->magicNum->nums->getLeft->longValue->shiftNum->nums->getRight->intValue->m->ConstantNode->forLong->value->if->new->SignExtendNode->new->MulNode->if->NarrowNode->ConstantNode->forInt->new->RightShiftNode->create->if->BinaryArithmeticNode->add->else->BinaryArithmeticNode->sub->if->ConstantNode->forInt->new->RightShiftNode->else->ConstantNode->forInt->new->RightShiftNode->new->NarrowNode->else->new->IntegerMulHighNode->if->BinaryArithmeticNode->add->else->if->BinaryArithmeticNode->sub->if->ConstantNode->forInt->new->RightShiftNode->if->s->ConstantNode->forInt->sign->UnsignedRightShiftNode->create->BinaryArithmeticNode->add->else->if->dividendStamp->canBeNegative->s->ConstantNode->forInt->sign->UnsignedRightShiftNode->create->BinaryArithmeticNode->add->graph->div->graph->graph->graph->addOrUniqueWithInputs->replaceFixed
OptimizeDivPhase#magicDivideConstants(long, int):::Borrowed from Hacker's Delight by Henry S:::twoW->t->ad->Math->abs->anc->Long->remainderUnsigned->q1->Long->divideUnsigned->r1->Long->remainderUnsigned->q2->Long->divideUnsigned->r2->Long->remainderUnsigned->delta->p->do->if->Long->compareUnsigned->if->Long->compareUnsigned->while->Long->compareUnsigned->magic->CodeUtil->signExtend->if->return->Pair->create
ProfileCompiledMethodsPhase#getProperty(String, String)::: profile compiled methods phase get property:::value->Services->getSavedProperties->get->if->return->return
ProfileCompiledMethodsPhase#run(StructuredGraph)::: profile compiled methods phase run:::schedule->graph->getOptions->new->SchedulePhase->schedule->apply->cfg->ControlFlowGraph->compute->foreach->cfg->getLoops->loopProbability->cfg->loop->getHeader->getBeginNode->blockFor->getRelativeFrequency->if->loop->getHeader->getBeginNode->loop->getBlocks->loop->getChildren->graph->getLastSchedule->addSectionCounters->current->graph->start->while->current->next->current->next->Arrays->cfg->getBlocks->asList->cfg->getLoops->graph->getLastSchedule->addSectionCounters->if->foreach->graph->getNodes->if->invoke->DynamicCounterNode->invoke->callTarget->targetName->invoke->asNode->addCounterBefore
ProfileCompiledMethodsPhase#addSectionCounters(FixedWithNextNode, Collection, Collection>, ScheduleResult, ControlFlowGraph)::: profile compiled methods phase add section counters:::blocks->new->HashSet<>->foreach->blocks->loop->getBlocks->removeAll->increment->DynamicCounterNode->getSectionWeight->cfg->blockFor->getRelativeFrequency->clampIncrement->DynamicCounterNode->sectionHead->start->next->addCounterBefore->if->hasInvoke->DynamicCounterNode->sectionHead->start->next->addCounterBefore
ProfileCompiledMethodsPhase#sectionHead(Node)::: profile compiled methods phase section head:::if->return->node->toString->else->return
ProfileCompiledMethodsPhase#getSectionWeight(ScheduleResult, Collection)::: profile compiled methods phase get section weight:::count->foreach->blockProbability->block->getRelativeFrequency->foreach->schedule->getBlockToNodesMap->get->getNodeWeight->return
ProfileCompiledMethodsPhase#getNodeWeight(Node)::: profile compiled methods phase get node weight:::if->return->phiPredecessorCount->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->else->if->return->node->successors->count->else->if->return->node->successors->count->else->if->return->else->if->return->return
ProfileCompiledMethodsPhase#hasInvoke(Collection)::: profile compiled methods phase has invoke:::hasInvoke->foreach->foreach->block->getNodes->if->return
ProfileCompiledMethodsPhase#checkContract()::: profile compiled methods phase check contract:::return
PropagateDeoptimizeProbabilityPhase#run(StructuredGraph, CoreProviders)::: propagate deoptimize probability phase run:::if->graph->hasNode->stack->new->NodeStack->reachableSplits->EconomicMap->create->foreach->graph->getNodes->stack->AbstractBeginNode->prevBegin->push->while->stack->isEmpty->beginNode->stack->pop->fixedNode->beginNode->predecessor->if->else->if->mergeNode->foreach->mergeNode->forwardEnds->newBeginNode->AbstractBeginNode->prevBegin->stack->push->else->if->controlSplitNode->reachableSuccessors->reachableSplits->get->if->EconomicSet->create->reachableSplits->put->if->controlSplitNode->getSuccessorCount->reachableSuccessors->size->reachableSplits->removeKey->stack->AbstractBeginNode->controlSplitNode->predecessor->prevBegin->push->else->reachableSuccessors->add->else->stack->AbstractBeginNode->prevBegin->push->entries->reachableSplits->getEntries->while->entries->advance->controlSplitNode->entries->getKey->value->entries->getValue->foreach->probability->controlSplitNode->probability->if->controlSplitNode->setProbability
RemoveValueProxyPhase#run(StructuredGraph)::: remove value proxy phase run:::foreach->graph->getNodes->exit->removeProxies->frameState->exit->stateAfter->if->frameState->isExceptionHandlingBCI->exit->setStateAfter->GraphUtil->tryKillUnused->graph->setHasValueProxies
UseTrappingNullChecksPhase#run(StructuredGraph, LowTierContext)::: use trapping null checks phase run:::if->graph->getOptions->getValue->context->getTarget->return->implicitNullCheckLimit->context->getTarget->foreach->graph->getNodes->deopt->predecessor->deopt->getReason->deopt->getSpeculation->tryUseTrappingNullCheck->foreach->graph->getNodes->context->getMetaAccess->tryUseTrappingNullCheck
UseTrappingNullChecksPhase#tryUseTrappingNullCheck(MetaAccessProvider, DynamicDeoptimizeNode, long)::: use trapping null checks phase try use trapping null check:::predecessor->deopt->predecessor->if->merge->reason->deopt->getActionAndReason->reasonPhi->reasons->expectedPhis->if->if->reasonPhi->merge->return->reasonPhi->values->snapshot->else->if->reason->isConstant->merge->getDebug->log->return->speculation->deopt->getSpeculation->speculationPhi->speculations->if->if->speculationPhi->merge->return->speculationPhi->values->snapshot->if->merge->phis->count->return->index->predecessors->merge->cfgPredecessors->snapshot->foreach->endPredecesssor->end->predecessor->thisReason->reasons->get->thisSpeculation->speculations->get->if->merge->isAlive->deopt->predecessor->deopt->getSpeculation->deopt->getActionAndReason->if->thisReason->isConstant->thisSpeculation->isConstant->end->getDebug->log->continue->deoptimizationReason->metaAccessProvider->thisReason->asJavaConstant->decodeDeoptReason->speculationConstant->metaAccessProvider->thisSpeculation->asJavaConstant->deopt->graph->getSpeculationLog->decodeSpeculation->tryUseTrappingNullCheck
UseTrappingNullChecksPhase#tryUseTrappingNullCheck(AbstractDeoptimizeNode, Node, DeoptimizationReason, Speculation, long)::: use trapping null checks phase try use trapping null check:::if->deopt->getDebug->log->return->if->speculation->equals->deopt->getDebug->log->return->if->merge->if->merge->phis->isEmpty->foreach->merge->cfgPredecessors->snapshot->end->predecessor->checkPredecessor->else->if->checkPredecessor->else->deopt->getDebug->log
UseTrappingNullChecksPhase#checkPredecessor(AbstractDeoptimizeNode, Node, DeoptimizationReason, long)::: use trapping null checks phase check predecessor:::current->branch->while->if->branch->anchored->isNotEmpty->return->current->predecessor->if->ifNode->if->ifNode->trueSuccessor->return->condition->ifNode->condition->if->replaceWithTrappingNullCheck
UseTrappingNullChecksPhase#replaceWithTrappingNullCheck(AbstractDeoptimizeNode, IfNode, LogicNode, DeoptimizationReason, long)::: use trapping null checks phase replace with trapping null check:::debug->deopt->getDebug->counterTrappingNullCheck->increment->if->counterTrappingNullCheckDynamicDeoptimize->increment->if->counterTrappingNullCheckUnreached->increment->isNullNode->nonTrappingContinuation->ifNode->falseSuccessor->trappingContinuation->ifNode->trueSuccessor->trappingNullCheck->nextNonTrapping->nonTrappingContinuation->next->value->isNullNode->getValue->if->OptImplicitNullChecks->ifNode->graph->getOptions->getValue->if->fixedAccessNode->if->fixedAccessNode->canNullCheck->address->fixedAccessNode->getAddress->base->address->getBase->index->address->getIndex->if->getValue->if->getValue->if->address->getMaxConstantDisplacement->fixedAccessNode->deopt->stateBefore->setStateBefore->fixedAccessNode->setNullCheck->deopt->graph->removeSplit->counterTrappingNullCheckExistingRead->increment->deopt->getDebug->log->if->deopt->graph->new->NullCheckNode->add->deopt->graph->replaceSplit->deopt->getDebug->log->trappingNullCheck->deopt->stateBefore->setStateBefore->nonTrappingContinuation->replaceAtUsages->if->GraphUtil->unlinkFixedNode->nonTrappingContinuation->safeDelete->GraphUtil->killCFG->GraphUtil->tryKillUnused
VerifyHeapAtReturnPhase#run(StructuredGraph)::: verify heap at return phase run:::foreach->graph->getNodes->VerifyHeapNode->addBefore
WriteBarrierAdditionPhase#run(StructuredGraph, MidTierContext)::: write barrier addition phase run:::barrierSet->context->getGC->getBarrierSet->foreach->graph->getNodes->filter->try->scope->n->graph->withNodeSourcePosition->barrierSet->addBarriers->catch->finally
WriteBarrierAdditionPhase#checkContract()::: write barrier addition phase check contract:::return
