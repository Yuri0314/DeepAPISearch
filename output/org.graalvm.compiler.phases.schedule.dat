BlockClosure#apply(Block)::: block closure apply:::
MemoryScheduleVerification#check(Block, BlockMap>)::: memory schedule verification check:::ReentrantBlockIterator->new->MemoryScheduleVerification->apply->return
MemoryScheduleVerification#getInitialState()::: memory schedule verification get initial state:::return->EconomicSet->create
MemoryScheduleVerification#processBlock(Block, EconomicSet)::: memory schedule verification process block:::beginNode->block->getBeginNode->if->abstractMergeNode->foreach->abstractMergeNode->phis->if->memoryPhiNode->addFloatingReadUsages->foreach->blockToNodesMap->get->if->if->single->single->getLocationIdentity->processLocation->else->if->multi->foreach->multi->getLocationIdentities->processLocation->addFloatingReadUsages->else->if->addFloatingReadUsages->else->if->floatingReadNode->if->floatingReadNode->getLastLocationAccess->floatingReadNode->getLocationIdentity->isMutable->if->currentState->contains->currentState->remove->else->throw->block->getBeginNode->block->getLoop->blockToNodesMap->get->get->new->RuntimeException->return
MemoryScheduleVerification#addFloatingReadUsages(EconomicSet, Node)::: memory schedule verification add floating read usages:::foreach->n->usages->filter->if->read->getLastLocationAccess->read->getLocationIdentity->isMutable->currentState->add
MemoryScheduleVerification#processLocation(Node, LocationIdentity, EconomicSet)::: memory schedule verification process location:::if->location->isImmutable->return->foreach->cloneState->if->r->getLocationIdentity->overlaps->r->getDebug->log->currentState->remove
MemoryScheduleVerification#merge(Block, List>)::: memory schedule verification merge:::result->states->get->for->i->states->size->return
MemoryScheduleVerification#cloneState(EconomicSet)::: memory schedule verification clone state:::result->EconomicSet->create->if->result->addAll->return
MemoryScheduleVerification#processLoop(Loop, EconomicSet)::: memory schedule verification process loop:::l->foreach->l->getHeader->getBeginNode->memoryPhis->foreach->cloneState->if->r->getLocationIdentity->memoryPhi->getLocationIdentity->overlaps->initialState->remove->return->ReentrantBlockIterator->processLoop
SchedulePhase#verifyImmutableGraph(StructuredGraph)::: schedule phase verify immutable graph:::if->Assertions->assertionsEnabled->return->graph->new->NodeEventListener->trackNodeEvents->else->return
SchedulePhase#run(StructuredGraph)::: schedule phase run:::try->scope->verifyImmutableGraph->inst->new->Instance->inst->run->catch->finally
SchedulePhase#run(StructuredGraph, SchedulingStrategy, ControlFlowGraph)::: schedule phase run:::inst->new->Instance->inst->run
SchedulePhase.Instance#run(StructuredGraph, SchedulingStrategy, boolean)::: instance run:::if->ControlFlowGraph->compute->currentNodeMap->graph->createNodeMap->visited->graph->createNodeBitMap->earliestBlockToNodesMap->new->BlockMap<>->scheduleEarliestIterative->if->selectedStrategy->isEarliest->latestBlockToNodesMap->new->BlockMap<>->foreach->cfg->getBlocks->latestBlockToNodesMap->new->ArrayList<>->put->watchListMap->calcLatestBlocks->sortNodesLatestWithinBlock->cfg->setNodeToBlock->graph->new->ScheduleResult->setLastSchedule
SchedulePhase.Instance#calcLatestBlocks(SchedulingStrategy, NodeMap, BlockMap>, NodeBitMap, BlockMap>, boolean)::: instance calc latest blocks:::watchListMap->new->BlockMap<>->reversePostOrder->cfg->reversePostOrder->for->j->return
SchedulePhase.Instance#selectLatestBlock(Node, Block, Block, NodeMap, BlockMap>, LocationIdentity, BlockMap>)::: instance select latest block:::if->currentNodeMap->setAndGrow->if->latestBlock->canKill->if->watchListMap->get->watchListMap->new->ArrayList<>->put->watchListMap->get->add->latestBlockToNodesMap->get->add
SchedulePhase.Instance#checkLatestEarliestRelation(Node, Block, Block)::: instance check latest earliest relation:::return
SchedulePhase.Instance#verifySchedule(ControlFlowGraph, BlockMap>, NodeMap)::: instance verify schedule:::foreach->cfg->getBlocks->nodes->blockToNodesMap->get->foreach->g->n->graph->if->g->hasLoops->g->getGuardsStage->return
SchedulePhase.Instance#checkKillsBetween(Block, Block, LocationIdentity)::: instance check kills between:::current->latestBlock->getDominator->dominatorChain->new->ArrayList<>->dominatorChain->add->while->if->current->canKill->dominatorChain->clear->dominatorChain->add->current->getDominator->lastBlock->for->i->dominatorChain->size->if->lastBlock->getBeginNode->locationIdentity->lastBlock->getBeginNode->getLocationIdentity->if->locationIdentity->isAny->locationIdentity->equals->lastBlock->getDominator->return
SchedulePhase.Instance#fillKillSet(LocationSet, List)::: instance fill kill set:::if->killed->isAny->foreach->if->identity->getLocationIdentity->killed->add->if->killed->isAny->return->else->if->foreach->getLocationIdentities->killed->add->if->killed->isAny->return
SchedulePhase.Instance#sortNodesLatestWithinBlock(ControlFlowGraph, BlockMap>, BlockMap>, NodeMap, BlockMap>, NodeBitMap)::: instance sort nodes latest within block:::foreach->cfg->getBlocks->sortNodesLatestWithinBlock
SchedulePhase.Instance#sortNodesLatestWithinBlock(Block, BlockMap>, BlockMap>, NodeMap, BlockMap>, NodeBitMap)::: instance sort nodes latest within block:::earliestSorting->earliestBlockToNodesMap->get->result->earliestSorting->size->new->ArrayList<>->watchList->if->watchListMap->get->beginNode->b->getBeginNode->if->loopExitNode->foreach->loopExitNode->proxies->unprocessed->clear->value->proxy->value->if->nodeMap->get->unprocessed->isMarked->sortIntoList->endNode->b->getEndNode->fixedEndNode->if->isFixedEnd->foreach->if->if->checkWatchList->sortIntoList->else->if->nodeMap->get->floatingReadNode->if->isImplicitNullOpportunity->sortIntoList->else->location->floatingReadNode->getLocationIdentity->if->b->canKill->if->new->ArrayList<>->watchList->add->foreach->latestBlockToNodesMap->get->if->unprocessed->isMarked->sortIntoList->if->unprocessed->isMarked->sortIntoList->latestBlockToNodesMap->put
SchedulePhase.Instance#checkWatchList(Block, NodeMap, NodeBitMap, ArrayList, ArrayList, Node)::: instance check watch list:::if->watchList->isEmpty->if->identity->getLocationIdentity->checkWatchList->else->if->foreach->getLocationIdentities->checkWatchList
SchedulePhase.Instance#checkWatchList(ArrayList, LocationIdentity, Block, ArrayList, NodeMap, NodeBitMap)::: instance check watch list:::if->identity->isImmutable->else->if->identity->isAny->foreach->if->unprocessed->isMarked->sortIntoList->watchList->clear->else->index->while->watchList->size->r->watchList->get->locationIdentity->r->getLocationIdentity->if->unprocessed->isMarked->if->identity->overlaps->sortIntoList->else->continue->lastIndex->watchList->size->watchList->watchList->get->set->watchList->remove
SchedulePhase.Instance#sortIntoList(Node, Block, ArrayList, NodeMap, NodeBitMap, Node)::: instance sort into list:::if->return->unprocessed->clear->foreach->n->inputs->if->nodeMap->get->unprocessed->isMarked->sortIntoList->if->else->result->add
SchedulePhase.Instance#calcLatestBlock(Block, SchedulingStrategy, Node, NodeMap, LocationIdentity, BlockMap>, BlockMap>, NodeBitMap, boolean)::: instance calc latest block:::latestBlock->if->currentNode->hasUsages->else->foreach->currentNode->usages->if->visited->contains->continue->calcBlockForUsage->if->strategy->scheduleOutOfLoops->currentBlock->while->currentBlock->getLoopDepth->earliestBlock->getLoopDepth->earliestBlock->getDominator->previousCurrentBlock->currentBlock->getDominator->if->previousCurrentBlock->isLoopHeader->if->currentBlock->getRelativeFrequency->latestBlock->getRelativeFrequency->currentNode->graph->hasValueProxies->if->earliestBlock->getDominator->checkKillsBetween->if->strategy->considerImplicitNullChecks->isImplicitNullOpportunity->earliestBlock->getRelativeFrequency->latestBlock->getRelativeFrequency->selectLatestBlock
SchedulePhase.Instance#isImplicitNullOpportunity(Node, Block)::: instance is implicit null opportunity:::if->floatingReadNode->pred->block->getBeginNode->predecessor->if->ifNode->if->ifNode->condition->ifNode->getTrueSuccessorProbability->isNullNode->ifNode->condition->if->floatingReadNode->getAddress->getBase->getUnproxifiedUncompressed->isNullNode->getValue->getUnproxifiedUncompressed->return->return
SchedulePhase.Instance#getUnproxifiedUncompressed(Node)::: instance get unproxified uncompressed:::result->while->if->valueProxy->valueProxy->getOriginalNode->else->if->convertNode->if->convertNode->mayNullCheckSkipConversion->convertNode->getValue->else->break->else->break->return
SchedulePhase.Instance#calcBlockForUsage(Node, Node, Block, NodeMap)::: instance calc block for usage:::currentBlock->if->phi->merge->phi->merge->mergeBlock->currentNodeMap->get->for->i->phi->valueCount->else->if->abstractBeginNode->if->AbstractControlFlowGraph->currentNodeMap->get->commonDominatorTyped->else->otherBlock->currentNodeMap->get->getDominator->AbstractControlFlowGraph->commonDominatorTyped->else->otherBlock->currentNodeMap->get->if->proxyNode->currentNodeMap->proxyNode->proxyPoint->get->AbstractControlFlowGraph->commonDominatorTyped->return
SchedulePhase.Instance.MicroBlock#add(Node):::Adds a new floating node into the micro block.:::newTail->new->NodeEntry->if->else
SchedulePhase.Instance.MicroBlock#getNodeCount():::Number of nodes in this micro block.:::return
SchedulePhase.Instance.MicroBlock#getActualNodeCount()::: micro block get actual node count:::count->for->e->return
SchedulePhase.Instance.MicroBlock#getId():::The id of the micro block, with a block always associated with a lower id than its successors.:::return
SchedulePhase.Instance.MicroBlock#getFirstNode():::First node of the linked list of nodes of this micro block.:::return
SchedulePhase.Instance.MicroBlock#prependChildrenTo(MicroBlock):::Takes all nodes in this micro blocks and prepends them to the nodes of the given parameter.:::if
SchedulePhase.Instance.MicroBlock#toString()::: micro block to string:::return->String->format
SchedulePhase.Instance.MicroBlock#hashCode()::: micro block hash code:::return
SchedulePhase.Instance.NodeEntry#getNext()::: node entry get next:::return
SchedulePhase.Instance.NodeEntry#getNode()::: node entry get node:::return
SchedulePhase.Instance#scheduleEarliestIterative(BlockMap>, NodeMap, NodeBitMap, StructuredGraph, boolean, boolean)::: instance schedule earliest iterative:::entries->graph->createNodeMap->stack->new->NodeStack->startBlock->nextId->foreach->cfg->reversePostOrder->foreach->b->getBeginNode->getBlockNodes->microBlock->new->MicroBlock->entries->set->isNew->visited->checkAndMarkInc->if->if->graph->getGuardsStage->allowsFloatingGuards->graph->getNodes->isNotEmpty->if->GuardPriorities->graph->getOptions->getValue->guardsByPriority->new->EnumMap<>->foreach->graph->getNodes->guardsByPriority->guard->computePriority->new->ArrayList<>->computeIfAbsent->add->foreach->guardsByPriority->values->processNodes->GuardOrder->resortGuards->else->graph->getNodes->processNodes->else->foreach->cfg->reversePostOrder->foreach->b->getBeginNode->getBlockNodes->current->inputs->processNodes->if->visited->getCounter->graph->getNodeCount->changed->unmarkedPhi->do->foreach->graph->getNodes->foreach->loopBegin->phis->if->visited->isMarked->for->i->loopBegin->getLoopEndCount->else->while->if->visited->getCounter->graph->getNodeCount->foreach->graph->getNodes->if->visited->isMarked->n->clearInputs->n->markDeleted->foreach->cfg->reversePostOrder->fixedNode->b->getEndNode->if->controlSplitNode->endBlock->entries->get->primarySuccessor->controlSplitNode->getPrimarySuccessor->if->endBlock->entries->get->prependChildrenTo->else->foreach->cfg->reversePostOrder->totalCount->foreach->b->getBeginNode->getBlockNodes->microBlock->entries->get->microBlock->getNodeCount->nodes->new->ArrayList<>->blockToNodes->put->foreach->b->getBeginNode->getBlockNodes->microBlock->entries->get->nodeToBlock->set->nodes->add->next->microBlock->getFirstNode->while->nextNode->next->getNode->nodeToBlock->set->nodes->add->next->getNext
SchedulePhase.Instance#processNodes(NodeBitMap, NodeMap, NodeStack, MicroBlock, Iterable)::: instance process nodes:::foreach->if->entries->get->processStack
SchedulePhase.Instance#processStackPhi(NodeStack, PhiNode, NodeMap, NodeBitMap)::: instance process stack phi:::stack->pop->if->visited->checkAndMarkInc->mergeBlock->nodeToBlock->phiNode->merge->get->nodeToBlock->set->merge->phiNode->merge->for->i->merge->forwardEndCount
SchedulePhase.Instance#processStackProxy(NodeStack, ProxyNode, NodeMap, NodeBitMap)::: instance process stack proxy:::stack->pop->if->visited->checkAndMarkInc->nodeToBlock->nodeToBlock->proxyNode->proxyPoint->get->set->input->proxyNode->value->if->nodeToBlock->get->stack->push
SchedulePhase.Instance#processStack(Node, MicroBlock, NodeMap, NodeBitMap, NodeStack)::: instance process stack:::stack->push->current->while->if->processStackPhi->else->if->processStackProxy->else->currentBlock->nodeToMicroBlock->get->if->earliestBlock->processInputs->if->else->stack->pop->visited->checkAndMarkInc->nodeToMicroBlock->set->earliestBlock->add->else->stack->pop->if->stack->isEmpty->break->stack->peek
SchedulePhase.Instance.GuardOrder#resortGuards(StructuredGraph, NodeMap, NodeStack):::After an earliest schedule, this will re-sort guards to honor their StaticDeoptimizingNode#computePriority() priority:::blocksWithGuards->EconomicSet->create->foreach->graph->getNodes->block->entries->get->blocksWithGuards->add->priorities->graph->createNodeMap->blockNodes->graph->createNodeBitMap->foreach->newBlock->resortGuards->if
SchedulePhase.Instance.GuardOrder#resortGuards(MicroBlock, NodeStack, NodeBitMap, NodeMap):::This resorts guards within one micro-block:::if->propagatePriority->return->transitiveGuardPriorityGetter->priorities->get->globalGuardPriorityComparator->Comparator->comparing->GuardNode->computePriority->thenComparing->Node->hashCode->thenComparingInt->availableGuards->new->TreeSet<>->newBlock->block->getId->new->MicroBlock->sorted->sorted->invert->for->e->do->while->stack->isEmpty->stack->pop->checkIfAvailable->iterator->availableGuards->iterator->if->iterator->hasNext->iterator->next->addNodeToResort->iterator->remove->while->stack->isEmpty->availableGuards->isEmpty->blockNodes->clearAll->return
SchedulePhase.Instance.GuardOrder#checkIfAvailable(Node, NodeStack, NodeBitMap, Instance.MicroBlock, SortedSet, boolean):::This checks if n can be scheduled, if it is the case, it schedules it now by calling #addNodeToResort(Node, NodeStack, NodeBitMap, MicroBlock, boolean).:::if->sorted->isMarked->return->foreach->n->inputs->if->sorted->isMarked->return->if->availableGuardNodes->add->else->addNodeToResort
SchedulePhase.Instance.GuardOrder#addNodeToResort(Node, NodeStack, NodeBitMap, MicroBlock, boolean):::Add a node to the re-sorted micro-block:::sorted->mark->newBlock->add->if->foreach->n->usages->if->sorted->isMarked->stack->push
SchedulePhase.Instance.GuardOrder#propagatePriority(MicroBlock, NodeStack, NodeMap, NodeBitMap):::This fills in a map of transitive priorities (priorities):::lowestPriority->GuardPriority->highest->for->e->if->stack->clear->blockNodes->clearAll->return->do->current->stack->pop->priority->priorities->get->foreach->current->inputs->if->blockNodes->isMarked->continue->inputPriority->priorities->get->if->inputPriority->isLowerPriorityThan->priorities->set->stack->push->while->stack->isEmpty->return
SchedulePhase.Instance#processInputs(NodeMap, NodeStack, MicroBlock, Node):::Processes the inputs of given block:::if->current->getNodeClass->isLeafNode->return->earliestBlock->foreach->current->inputs->inputBlock->nodeToBlock->get->if->stack->push->else->if->inputBlock->getId->earliestBlock->getId->return
SchedulePhase.Instance#isFixedEnd(FixedNode)::: instance is fixed end:::return
SchedulePhase.Instance#printScheduleHelper(String)::: instance print schedule helper:::buf->new->Formatter->buf->getCFG->getStartBlock->getBeginNode->graph->format->foreach->getCFG->getBlocks->buf->b->getLoopDepth->format->buf->b->getDominator->format->buf->Arrays->b->getPredecessors->toString->format->buf->Arrays->b->getSuccessors->toString->format->if->blockToNodesMap->get->foreach->nodesFor->printNode->else->foreach->b->getNodes->printNode->buf->format->return->buf->toString
SchedulePhase.Instance#printNode(Node)::: instance print node:::buf->new->Formatter->buf->format->if->buf->getLocationIdentity->format->else->if->buf->format->foreach->getLocationIdentities->buf->format->else->if->frn->buf->frn->getLocationIdentity->format->buf->frn->getLastLocationAccess->format->buf->frn->getAddress->format->else->if->buf->getAnchor->format->n->getDebug->log
SchedulePhase.Instance#getCFG()::: instance get g:::return
SchedulePhase.Instance#nodesFor(Block):::Gets the nodes in a given block.:::return->blockToNodesMap->get
