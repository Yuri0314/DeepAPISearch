org.graalvm.compiler.asm.aarch64.AArch64Address#createAddress(AddressingMode, Register, Register, int, boolean, AArch64Assembler.ExtendType)->AArch64Address:::General address generation mechanism
org.graalvm.compiler.asm.aarch64.AArch64Address#createPostIndexedImmediateAddress(Register, int)->AArch64Address::: arch64 address create post indexed immediate address
org.graalvm.compiler.asm.aarch64.AArch64Address#createPreIndexedImmediateAddress(Register, int)->AArch64Address::: arch64 address create pre indexed immediate address
org.graalvm.compiler.asm.aarch64.AArch64Address#createScaledImmediateAddress(Register, int)->AArch64Address::: arch64 address create scaled immediate address
org.graalvm.compiler.asm.aarch64.AArch64Address#createUnscaledImmediateAddress(Register, int)->AArch64Address::: arch64 address create unscaled immediate address
org.graalvm.compiler.asm.aarch64.AArch64Address#createBaseRegisterOnlyAddress(Register)->AArch64Address::: arch64 address create base register only address
org.graalvm.compiler.asm.aarch64.AArch64Address#createRegisterOffsetAddress(Register, Register, boolean)->AArch64Address::: arch64 address create register offset address
org.graalvm.compiler.asm.aarch64.AArch64Address#createPairUnscaledImmediateAddress(Register, int)->AArch64Address::: arch64 address create pair unscaled immediate address
org.graalvm.compiler.asm.aarch64.AArch64Address#createExtendedRegisterOffsetAddress(Register, Register, boolean, AArch64Assembler.ExtendType)->AArch64Address::: arch64 address create extended register offset address
org.graalvm.compiler.asm.aarch64.AArch64Address#createPcLiteralAddress(int)->AArch64Address::: arch64 address create pc literal address
org.graalvm.compiler.asm.aarch64.AArch64Address#getBase()->Register::: arch64 address get base
org.graalvm.compiler.asm.aarch64.AArch64Address#getOffset()->Register::: arch64 address get offset
org.graalvm.compiler.asm.aarch64.AArch64Address#getImmediate()->int::: arch64 address get immediate
org.graalvm.compiler.asm.aarch64.AArch64Address#getImmediateRaw()->int::: arch64 address get immediate raw
org.graalvm.compiler.asm.aarch64.AArch64Address#isScaled()->boolean::: arch64 address is scaled
org.graalvm.compiler.asm.aarch64.AArch64Address#getExtendType()->AArch64Assembler.ExtendType::: arch64 address get extend type
org.graalvm.compiler.asm.aarch64.AArch64Address#getAddressingMode()->AddressingMode::: arch64 address get addressing mode
org.graalvm.compiler.asm.aarch64.AArch64Address#toString(int)->String::: arch64 address to string
org.graalvm.compiler.asm.aarch64.AArch64Address#lea(AArch64MacroAssembler, Register)->void:::Loads an address into Register r.
org.graalvm.compiler.asm.aarch64.AArch64Assembler.LogicalImmediateTable#isRepresentable(boolean, long)->Representable:::Tests whether an immediate can be encoded for logical instructions.
org.graalvm.compiler.asm.aarch64.AArch64Assembler.LogicalImmediateTable#isRepresentable(int)->Representable::: logical immediate table is representable
org.graalvm.compiler.asm.aarch64.AArch64Assembler.LogicalImmediateTable#getLogicalImmEncoding(boolean, long)->int::: logical immediate table get logical imm encoding
org.graalvm.compiler.asm.aarch64.AArch64Assembler#supports(CPUFeature)->boolean::: arch64 assembler supports
org.graalvm.compiler.asm.aarch64.AArch64Assembler#isFlagSet(Flag)->boolean::: arch64 assembler is flag set
org.graalvm.compiler.asm.aarch64.AArch64Assembler#b(ConditionFlag, int)->void:::Branch conditionally.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#b(ConditionFlag, int, int)->void:::Branch conditionally
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cbnz(int, Register, int)->void:::Compare register and branch if non-zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cbnz(int, Register, int, int)->void:::Compare register and branch if non-zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cbz(int, Register, int)->void:::Compare and branch if zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cbz(int, Register, int, int)->void:::Compare register and branch if zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#tbnz(Register, int, int)->void:::Test a single bit and branch if the bit is nonzero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#tbz(Register, int, int)->void:::Test a single bit and branch if the bit is zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#tbnz(Register, int, int, int)->void:::Test a single bit and branch if the bit is nonzero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#tbz(Register, int, int, int)->void:::Test a single bit and branch if the bit is zero.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#b(int)->void::: arch64 assembler b
org.graalvm.compiler.asm.aarch64.AArch64Assembler#b(int, int)->void::: arch64 assembler b
org.graalvm.compiler.asm.aarch64.AArch64Assembler#bl(int)->void:::Branch and link return address to register X30.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#blr(Register)->void:::Branches to address in register and writes return address into register X30.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#br(Register)->void:::Branches to address in register.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ret(Register)->void:::Return to address in register.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldr(int, Register, AArch64Address)->void:::Loads a srcSize value from address into rt zero-extending it.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldrs(int, int, Register, AArch64Address)->void:::Loads a srcSize value from address into rt sign-extending it.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#prfm(AArch64Address, PrefetchMode)->void::: arch64 assembler prfm
org.graalvm.compiler.asm.aarch64.AArch64Assembler#str(int, Register, AArch64Address)->void:::Stores register rt into memory pointed by address.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldp(int, Register, Register, AArch64Address)->void:::Load Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#stp(int, Register, Register, AArch64Address)->void:::Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldxr(int, Register, Register)->void:::Load address exclusive
org.graalvm.compiler.asm.aarch64.AArch64Assembler#stxr(int, Register, Register, Register)->void:::Store address exclusive
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldar(int, Register, Register)->void:::Load acquire
org.graalvm.compiler.asm.aarch64.AArch64Assembler#stlr(int, Register, Register)->void:::Store-release
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldaxr(int, Register, Register)->void:::Load acquire exclusive
org.graalvm.compiler.asm.aarch64.AArch64Assembler#stlxr(int, Register, Register, Register)->void:::Store-release exclusive
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cas(int, Register, Register, Register, boolean, boolean)->void:::Compare And Swap word or doubleword in memory
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ldadd(int, Register, Register, Register, boolean, boolean)->void:::Atomic add
org.graalvm.compiler.asm.aarch64.AArch64Assembler#swp(int, Register, Register, Register, boolean, boolean)->void:::Atomic swap
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adrp(Register)->void:::Address of page: sign extends 21-bit offset, shifts if left by 12 and adds it to the value of the PC with its bottom 12-bits cleared, writing the result to dst
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adr(Register, int)->void:::Adds a 21-bit signed offset to the program counter and writes the result to dst.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adr(Register, int, int)->void:::Adds a 21-bit signed offset to the program counter and writes the result to dst.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#add(int, Register, Register, int)->void:::dst = src + aimm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adds(int, Register, Register, int)->void:::dst = src + aimm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#sub(int, Register, Register, int)->void:::dst = src - aimm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#subs(int, Register, Register, int)->void:::dst = src - aimm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ccmp(int, Register, Register, int, ConditionFlag)->void::: arch64 assembler ccmp
org.graalvm.compiler.asm.aarch64.AArch64Assembler#isAimm(int)->boolean:::Checks whether immediate can be encoded as an arithmetic immediate.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#and(int, Register, Register, long)->void:::dst = src & bimm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ands(int, Register, Register, long)->void:::dst = src & bimm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#eor(int, Register, Register, long)->void:::dst = src ^ bimm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#orr(int, Register, Register, long)->void:::dst = src | bimm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#movz(int, Register, int, int)->void:::dst = uimm16 << shiftAmt.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#movn(int, Register, int, int)->void:::dst = ~(uimm16 << shiftAmt).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#movk(int, Register, int, int)->void:::dst<pos+15:pos> = uimm16.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#bfm(int, Register, Register, int, int)->void:::Bitfield move.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ubfm(int, Register, Register, int, int)->void:::Unsigned bitfield move.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#sbfm(int, Register, Register, int, int)->void:::Signed bitfield move.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#extr(int, Register, Register, Register, int)->void:::Extract
org.graalvm.compiler.asm.aarch64.AArch64Assembler#add(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 + shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adds(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 + shiftType(src2, imm) and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#sub(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 - shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#subs(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 - shiftType(src2, imm) and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#add(int, Register, Register, Register, ExtendType, int)->void:::dst = src1 + extendType(src2) << imm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#adds(int, Register, Register, Register, ExtendType, int)->void:::dst = src1 + extendType(src2) << imm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#sub(int, Register, Register, Register, ExtendType, int)->void:::dst = src1 - extendType(src2) << imm.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#subs(int, Register, Register, Register, ExtendType, int)->void:::dst = src1 - extendType(src2) << imm and sets flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#and(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ands(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & shiftType(src2, imm) and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#bic(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#bics(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & ~(shiftType(src2, imm)) and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#eon(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 ^ ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#eor(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 ^ shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#orr(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 | shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#orn(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 | ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#asr(int, Register, Register, Register)->void:::dst = src1 >> (src2 & log2(size)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#lsl(int, Register, Register, Register)->void:::dst = src1 << (src2 & log2(size)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#lsr(int, Register, Register, Register)->void:::dst = src1 >>> (src2 & log2(size)).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#ror(int, Register, Register, Register)->void:::dst = rotateRight(src1, (src2 & log2(size))).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cls(int, Register, Register)->void:::Counts leading sign bits
org.graalvm.compiler.asm.aarch64.AArch64Assembler#clz(int, Register, Register)->void:::Counts leading zeros.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#rbit(int, Register, Register)->void:::Reverses bits.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#rev(int, Register, Register)->void:::Reverses bytes.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#csel(int, Register, Register, Register, ConditionFlag)->void:::Conditional select
org.graalvm.compiler.asm.aarch64.AArch64Assembler#csneg(int, Register, Register, Register, ConditionFlag)->void:::Conditional select negate
org.graalvm.compiler.asm.aarch64.AArch64Assembler#csinc(int, Register, Register, Register, ConditionFlag)->void:::Conditional increase
org.graalvm.compiler.asm.aarch64.AArch64Assembler#madd(int, Register, Register, Register, Register)->void:::dst = src1 * src2 + src3.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#msub(int, Register, Register, Register, Register)->void:::dst = src3 - src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#smulh(Register, Register, Register)->void:::Signed multiply high
org.graalvm.compiler.asm.aarch64.AArch64Assembler#umulh(Register, Register, Register)->void:::unsigned multiply high
org.graalvm.compiler.asm.aarch64.AArch64Assembler#umaddl(Register, Register, Register, Register)->void:::unsigned multiply add-long
org.graalvm.compiler.asm.aarch64.AArch64Assembler#smaddl(Register, Register, Register, Register)->void:::signed multiply add-long
org.graalvm.compiler.asm.aarch64.AArch64Assembler#sdiv(int, Register, Register, Register)->void:::Signed divide
org.graalvm.compiler.asm.aarch64.AArch64Assembler#udiv(int, Register, Register, Register)->void:::Unsigned divide
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fldr(int, Register, AArch64Address)->void:::Floating point load.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fstr(int, Register, AArch64Address)->void:::Floating point store.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmov(int, Register, Register)->void:::Floating point move.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmovFpu2Cpu(int, Register, Register)->void:::Move size bits from floating point register unchanged to general purpose register.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmovCpu2Fpu(int, Register, Register)->void:::Move size bits from general purpose register unchanged to floating point register.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmov(int, Register, double)->void:::Move immediate into register.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#isDoubleImmediate(double)->boolean::: arch64 assembler is double immediate
org.graalvm.compiler.asm.aarch64.AArch64Assembler#isFloatImmediate(float)->boolean::: arch64 assembler is float immediate
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcvt(int, Register, Register)->void:::Convert float to double and vice-versa.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcvtzs(int, int, Register, Register)->void:::Convert floating point to integer
org.graalvm.compiler.asm.aarch64.AArch64Assembler#scvtf(int, int, Register, Register)->void:::Converts integer to floating point
org.graalvm.compiler.asm.aarch64.AArch64Assembler#frintz(int, Register, Register)->void:::Rounds floating-point to integral
org.graalvm.compiler.asm.aarch64.AArch64Assembler#frintn(int, Register, Register)->void:::Rounds floating-point to integral
org.graalvm.compiler.asm.aarch64.AArch64Assembler#frintm(int, Register, Register)->void:::Rounds floating-point to integral
org.graalvm.compiler.asm.aarch64.AArch64Assembler#frintp(int, Register, Register)->void:::Rounds floating-point to integral
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fabs(int, Register, Register)->void:::dst = |src|.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fneg(int, Register, Register)->void:::dst = -neg.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fsqrt(int, Register, Register)->void:::dst = Sqrt(src).
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fadd(int, Register, Register, Register)->void:::dst = src1 + src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fsub(int, Register, Register, Register)->void:::dst = src1 - src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmul(int, Register, Register, Register)->void:::dst = src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fdiv(int, Register, Register, Register)->void:::dst = src1 / src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmadd(int, Register, Register, Register, Register)->void:::dst = src1 * src2 + src3.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fmsub(int, Register, Register, Register, Register)->void:::dst = src3 - src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcmp(int, Register, Register)->void:::Compares src1 to src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcmpe(int, Register, Register)->void:::Signalling compares src1 to src2.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fccmp(int, Register, Register, int, ConditionFlag)->void:::Conditional compare
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcmpZero(int, Register)->void:::Compare register to 0.0 .
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcmpeZero(int, Register)->void:::Signalling compare register to 0.0 .
org.graalvm.compiler.asm.aarch64.AArch64Assembler#fcsel(int, Register, Register, Register, ConditionFlag)->void:::Conditional select
org.graalvm.compiler.asm.aarch64.AArch64Assembler#hlt(int)->void:::Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as UNALLOCATED instruction.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#brk(int)->void:::Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher exception level.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#hint(SystemHint)->void:::Architectural hints.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#clrex()->void:::Clear Exclusive: clears the local record of the executing processor that an address has had a request for an exclusive access.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#dmb(BarrierKind)->void:::Data Memory Barrier.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#mrs(Register, SystemRegister)->void::: arch64 assembler mrs
org.graalvm.compiler.asm.aarch64.AArch64Assembler#msr(SystemRegister, Register)->void::: arch64 assembler msr
org.graalvm.compiler.asm.aarch64.AArch64Assembler#annotatePatchingImmediate(int, Instruction, int, int, int)->void::: arch64 assembler annotate patching immediate
org.graalvm.compiler.asm.aarch64.AArch64Assembler#annotateImmediateMovSequence(int, int)->void::: arch64 assembler annotate immediate mov sequence
org.graalvm.compiler.asm.aarch64.AArch64Assembler#cnt(int, Register, Register)->void:::dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.
org.graalvm.compiler.asm.aarch64.AArch64Assembler#addv(int, SIMDElementSize, Register, Register)->void:::dst = src[0] + ....+ src[n].
org.graalvm.compiler.asm.aarch64.AArch64Assembler#umov(int, Register, int, Register)->void:::dst = src[srcIdx].
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister#getRegister()->Register::: scratch register get register
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister#close()->void::: scratch register close
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#getScratchRegister()->ScratchRegister::: arch64 macro assembler get scratch register
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#generateAddressPlan(long, boolean, int)->AddressGenerationPlan:::Generates an addressplan for an address of the form base + displacement [+ index [<< log2(transferSize)]] with the index register and scaling being optional.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#makeAddress(Register, long, Register, boolean, int, Register, boolean)->AArch64Address:::Returns an AArch64Address pointing to base + displacement + index << log2(transferSize).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#makeAddress(Register, long, Register, int, boolean)->AArch64Address:::Returns an AArch64Address pointing to base + displacement
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#makeAddress(Register, long, int)->AArch64Address:::Returns an AArch64Address pointing to base + displacement
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#loadAddress(Register, AArch64Address, int)->void:::Loads memory address into register.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#movx(Register, Register)->void::: arch64 macro assembler movx
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mov(int, Register, Register)->void::: arch64 macro assembler mov
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mov(Register, long)->void:::Loads immediate into register.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mov(Register, long, boolean)->void:::Loads immediate into register.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mov(Register, int)->void:::Loads immediate into register.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#movNativeAddress(Register, long)->void:::Generates a 48-bit immediate move code sequence
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#movNativeAddress(Register, long, boolean)->void:::Generates a 48-bit immediate move code sequence
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#movNarrowAddress(Register, long)->void:::Generates a 32-bit immediate move code sequence
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#nrInstructionsToMoveImmediate(long)->int::: arch64 macro assembler nr instructions to move immediate
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ldrs(int, int, Register, AArch64Address)->void:::Loads a srcSize value from address into rt sign-extending it if necessary.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ldr(int, Register, AArch64Address)->void:::Loads a srcSize value from address into rt zero-extending it if necessary.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cmov(int, Register, Register, Register, ConditionFlag)->void:::Conditional move
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cset(int, Register, ConditionFlag)->void:::Conditional set
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#add(int, Register, Register, Register)->void:::dst = src1 + src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#adds(int, Register, Register, Register)->void:::dst = src1 + src2 and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#subs(int, Register, Register, Register)->void:::dst = src1 - src2 and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#sub(int, Register, Register, Register)->void:::dst = src1 - src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#add(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 + shiftType(src2, shiftAmt & (size - 1)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#sub(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 + shiftType(src2, shiftAmt & (size-1)) and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#neg(int, Register, Register)->void:::dst = -src1.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#add(int, Register, Register, int)->void:::dst = src + immediate.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#add(int, Register, Register, long)->void:::dst = src + immediate.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#adds(int, Register, Register, int)->void:::dst = src + aimm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#sub(int, Register, Register, int)->void:::dst = src - immediate.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#subs(int, Register, Register, int)->void:::dst = src - aimm and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mul(int, Register, Register, Register)->void:::dst = src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#madd(int, Register, Register, Register, Register)->void:::dst = src3 + src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#msub(int, Register, Register, Register, Register)->void:::dst = src3 - src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mneg(int, Register, Register, Register)->void:::dst = 0 - src1 * src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#umulh(int, Register, Register, Register)->void:::unsigned multiply high
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#smulh(int, Register, Register, Register)->void:::signed multiply high
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#rem(int, Register, Register, Register)->void:::dst = src1 % src2
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#urem(int, Register, Register, Register)->void:::dst = src1 % src2
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isArithmeticImmediate(long)->boolean:::Add/subtract instruction encoding supports 12-bit immediate values.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isComparisonImmediate(long)->boolean:::Compare instructions are add/subtract instructions and so support 12-bit immediate values.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isMovableImmediate(long)->boolean:::Move wide immediate instruction encoding supports 16-bit immediate values which can be optionally-shifted by multiples of 16 (i.e
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#shl(int, Register, Register, long)->void:::dst = src << (shiftAmt & (size - 1)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#shl(int, Register, Register, Register)->void:::dst = src1 << (src2 & (size - 1)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#lshr(int, Register, Register, long)->void:::dst = src >>> (shiftAmt & (size - 1)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#lshr(int, Register, Register, Register)->void:::dst = src1 >>> (src2 & (size - 1)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ashr(int, Register, Register, long)->void:::dst = src >> (shiftAmt & log2(size)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ashr(int, Register, Register, Register)->void:::dst = src1 >> (src2 & log2(size)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#and(int, Register, Register, Register)->void:::dst = src1 & src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#eor(int, Register, Register, Register)->void:::dst = src1 ^ src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#or(int, Register, Register, Register)->void:::dst = src1 | src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#or(int, Register, Register, long)->void:::dst = src | bimm.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#not(int, Register, Register)->void:::dst = ~src.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#and(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#eor(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 ^ shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#or(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 | shiftType(src2, imm).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#bic(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 & ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#eon(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 ^ ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#orn(int, Register, Register, Register, ShiftType, int)->void:::dst = src1 | ~(shiftType(src2, imm)).
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#sxt(int, int, Register, Register)->void:::Sign-extend value from src into dst.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#csneg(int, Register, Register, ConditionFlag)->void:::dst = src if condition else -src.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isLogicalImmediate(long)->boolean::: arch64 macro assembler is logical immediate
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isLogicalImmediate(int)->boolean::: arch64 macro assembler is logical immediate
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#fmov(int, Register, Register)->void:::Moves integer to float, float to integer, or float to float
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#fmov(int, Register, double)->void::: arch64 macro assembler fmov
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isDoubleImmediate(double)->boolean::: arch64 macro assembler is double immediate
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isFloatImmediate(float)->boolean::: arch64 macro assembler is float immediate
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#fcmov(int, Register, Register, Register, ConditionFlag)->void:::Conditional move
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#frem(int, Register, Register, Register)->void:::dst = src1 % src2.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cmp(int, Register, Register)->void:::Compares x and y and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cmp(int, Register, int)->void:::Compares x to y and sets condition flags.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ands(int, Register, Register, Register)->void:::Sets condition flags according to result of x & y.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#mulvs(int, Register, Register, Register)->void:::Sets overflow flag according to result of x * y.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#adr(Register, Label)->void::: arch64 macro assembler adr
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cbnz(int, Register, Label)->void:::Compare register and branch if non-zero.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#cbz(int, Register, Label)->void:::Compare register and branch if zero.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#tbnz(Register, int, Label)->void:::Test a single bit and branch if the bit is nonzero.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#tbz(Register, int, Label)->void:::Test a single bit and branch if the bit is zero.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#branchConditionally(ConditionFlag, Label)->void:::Branches to label if condition is true.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#branchConditionally(ConditionFlag)->void:::Branches if condition is true
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#jmp(Label)->void:::Jumps to label
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#jmp(Register)->void:::Jump to address in dest.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#jmp()->void:::Immediate jump instruction fixed up by HotSpot c++ code.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#isBranchImmediateOffset(long)->boolean::: arch64 macro assembler is branch immediate offset
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#hlt(AArch64ExceptionCode)->void:::Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as UNALLOCATED instruction.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#brk(AArch64ExceptionCode)->void:::Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher exception level.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#pause()->void::: arch64 macro assembler pause
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#nop()->void:::Executes no-op instruction
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#csdb()->void:::Consumption of Speculative Data Barrier
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#ensureUniquePC()->void:::Same as #nop().
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#align(int)->void:::Aligns PC.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#patchJumpTarget(int, int)->void:::Patches jump targets when label gets bound.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#makeAddress(Register, int)->AArch64Address:::Generates an address of the form base + displacement
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#getPlaceholder(int)->AArch64Address::: arch64 macro assembler get placeholder
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#addressOf(Register)->void::: arch64 macro assembler address of
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#lea(Register, AArch64Address)->void:::Loads an address into Register d.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#popcnt(int, Register, Register, Register)->void:::Count the set bits of src register.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.MacroInstruction#patch(int, int, byte[])->void::: macro instruction patch
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler#adrpLdr(int, Register, AArch64Address)->void:::Emits elf patchable adrp ldr sequence.
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AdrpLdrMacroInstruction#toString()->String::: adrp ldr macro instruction to string
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AdrpLdrMacroInstruction#patch(int, int, byte[])->void::: adrp ldr macro instruction patch
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AdrpAddMacroInstruction#toString()->String::: adrp add macro instruction to string
org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AdrpAddMacroInstruction#patch(int, int, byte[])->void::: adrp add macro instruction patch
