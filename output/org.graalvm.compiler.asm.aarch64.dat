AArch64Address#createAddress(AddressingMode, Register, Register, int, boolean, AArch64Assembler.ExtendType):::General address generation mechanism:::return->new->AArch64Address
AArch64Address#lea(AArch64MacroAssembler, Register):::Loads an address into Register r.:::switch->if->base->equals->break->masm->add->break->masm->add->break->masm->getImmediate->mov->break->throw->GraalError->shouldNotReachHere
AArch64Assembler.LogicalImmediateTable#isRepresentable(boolean, long):::Tests whether an immediate can be encoded for logical instructions.:::pos->getLogicalImmTablePos->if->if->getLogicalImmTablePos->return->return->imm->return->imm->only64bit
AArch64Assembler#b(ConditionFlag, int):::Branch conditionally.:::b
AArch64Assembler#b(ConditionFlag, int, int):::Branch conditionally:::if->getConditionalBranchImm->emitInt->else->getConditionalBranchImm->emitInt
AArch64Assembler#cbnz(int, Register, int):::Compare register and branch if non-zero.:::generalFromSize->conditionalBranchInstruction
AArch64Assembler#cbnz(int, Register, int, int):::Compare register and branch if non-zero.:::generalFromSize->conditionalBranchInstruction
AArch64Assembler#cbz(int, Register, int):::Compare and branch if zero.:::generalFromSize->conditionalBranchInstruction
AArch64Assembler#cbz(int, Register, int, int):::Compare register and branch if zero.:::generalFromSize->conditionalBranchInstruction
AArch64Assembler#tbnz(Register, int, int):::Test a single bit and branch if the bit is nonzero.:::tbnz
AArch64Assembler#tbz(Register, int, int):::Test a single bit and branch if the bit is zero.:::tbz
AArch64Assembler#tbnz(Register, int, int, int):::Test a single bit and branch if the bit is nonzero.:::size->uimm5->imm14->NumUtil->getNbitNumberInt->type->generalFromSize->encoding->rd->if->emitInt->else->emitInt
AArch64Assembler#tbz(Register, int, int, int):::Test a single bit and branch if the bit is zero.:::size->uimm5->imm14->NumUtil->getNbitNumberInt->type->generalFromSize->encoding->rd->if->emitInt->else->emitInt
AArch64Assembler#bl(int):::Branch and link return address to register X30.:::unconditionalBranchImmInstruction
AArch64Assembler#blr(Register):::Branches to address in register and writes return address into register X30.:::unconditionalBranchRegInstruction
AArch64Assembler#br(Register):::Branches to address in register.:::unconditionalBranchRegInstruction
AArch64Assembler#ret(Register):::Return to address in register.:::unconditionalBranchRegInstruction
AArch64Assembler#ldr(int, Register, AArch64Address):::Loads a srcSize value from address into rt zero-extending it.:::transferSize->NumUtil->log2Ceil->loadStoreInstruction
AArch64Assembler#ldrs(int, int, Register, AArch64Address):::Loads a srcSize value from address into rt sign-extending it.:::transferSize->NumUtil->log2Ceil->generalFromSize->loadStoreInstruction
AArch64Assembler#str(int, Register, AArch64Address):::Stores register rt into memory pointed by address.:::transferSize->NumUtil->log2Ceil->loadStoreInstruction
AArch64Assembler#ldp(int, Register, Register, AArch64Address):::Load Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers.:::generalFromSize->loadStorePairInstruction
AArch64Assembler#stp(int, Register, Register, AArch64Address):::Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers.:::generalFromSize->loadStorePairInstruction
AArch64Assembler#ldxr(int, Register, Register):::Load address exclusive:::transferSize->NumUtil->log2Ceil->exclusiveLoadInstruction
AArch64Assembler#stxr(int, Register, Register, Register):::Store address exclusive:::transferSize->NumUtil->log2Ceil->exclusiveStoreInstruction
AArch64Assembler#ldar(int, Register, Register):::Load acquire:::transferSize->NumUtil->log2Ceil->exclusiveLoadInstruction
AArch64Assembler#stlr(int, Register, Register):::Store-release:::transferSize->NumUtil->log2Ceil->exclusiveStoreInstruction
AArch64Assembler#ldaxr(int, Register, Register):::Load acquire exclusive:::transferSize->NumUtil->log2Ceil->exclusiveLoadInstruction
AArch64Assembler#stlxr(int, Register, Register, Register):::Store-release exclusive:::transferSize->NumUtil->log2Ceil->exclusiveStoreInstruction
AArch64Assembler#cas(int, Register, Register, Register, boolean, boolean):::Compare And Swap word or doubleword in memory:::transferSize->NumUtil->log2Ceil->compareAndSwapInstruction
AArch64Assembler#ldadd(int, Register, Register, Register, boolean, boolean):::Atomic add:::transferSize->NumUtil->log2Ceil->loadAndAddInstruction
AArch64Assembler#swp(int, Register, Register, Register, boolean, boolean):::Atomic swap:::transferSize->NumUtil->log2Ceil->swapInstruction
AArch64Assembler#adrp(Register):::Address of page: sign extends 21-bit offset, shifts if left by 12 and adds it to the value of the PC with its bottom 12-bits cleared, writing the result to dst:::rd->emitInt
AArch64Assembler#adr(Register, int):::Adds a 21-bit signed offset to the program counter and writes the result to dst.:::rd->getPcRelativeImmEncoding->emitInt
AArch64Assembler#adr(Register, int, int):::Adds a 21-bit signed offset to the program counter and writes the result to dst.:::rd->getPcRelativeImmEncoding->emitInt
AArch64Assembler#add(int, Register, Register, int):::dst = src + aimm.:::generalFromSize->addSubImmInstruction
AArch64Assembler#adds(int, Register, Register, int):::dst = src + aimm and sets condition flags.:::generalFromSize->addSubImmInstruction
AArch64Assembler#sub(int, Register, Register, int):::dst = src - aimm.:::generalFromSize->addSubImmInstruction
AArch64Assembler#subs(int, Register, Register, int):::dst = src - aimm and sets condition flags.:::generalFromSize->addSubImmInstruction
AArch64Assembler#isAimm(int):::Checks whether immediate can be encoded as an arithmetic immediate.:::return->NumUtil->isUnsignedNbit->NumUtil->isUnsignedNbit
AArch64Assembler#and(int, Register, Register, long):::dst = src & bimm.:::generalFromSize->logicalImmInstruction
AArch64Assembler#ands(int, Register, Register, long):::dst = src & bimm and sets condition flags.:::generalFromSize->logicalImmInstruction
AArch64Assembler#eor(int, Register, Register, long):::dst = src ^ bimm.:::generalFromSize->logicalImmInstruction
AArch64Assembler#orr(int, Register, Register, long):::dst = src | bimm.:::generalFromSize->logicalImmInstruction
AArch64Assembler#movz(int, Register, int, int):::dst = uimm16 << shiftAmt.:::generalFromSize->moveWideImmInstruction
AArch64Assembler#movn(int, Register, int, int):::dst = ~(uimm16 << shiftAmt).:::generalFromSize->moveWideImmInstruction
AArch64Assembler#movk(int, Register, int, int):::dst<pos+15:pos> = uimm16.:::generalFromSize->moveWideImmInstruction
AArch64Assembler#bfm(int, Register, Register, int, int):::Bitfield move.:::generalFromSize->bitfieldInstruction
AArch64Assembler#ubfm(int, Register, Register, int, int):::Unsigned bitfield move.:::generalFromSize->bitfieldInstruction
AArch64Assembler#sbfm(int, Register, Register, int, int):::Signed bitfield move.:::generalFromSize->bitfieldInstruction
AArch64Assembler#extr(int, Register, Register, Register, int):::Extract:::type->generalFromSize->sf->rd->rs1->rs2->emitInt
AArch64Assembler#add(int, Register, Register, Register, ShiftType, int):::dst = src1 + shiftType(src2, imm).:::generalFromSize->addSubShiftedInstruction
AArch64Assembler#adds(int, Register, Register, Register, ShiftType, int):::dst = src1 + shiftType(src2, imm) and sets condition flags.:::generalFromSize->addSubShiftedInstruction
AArch64Assembler#sub(int, Register, Register, Register, ShiftType, int):::dst = src1 - shiftType(src2, imm).:::generalFromSize->addSubShiftedInstruction
AArch64Assembler#subs(int, Register, Register, Register, ShiftType, int):::dst = src1 - shiftType(src2, imm) and sets condition flags.:::generalFromSize->addSubShiftedInstruction
AArch64Assembler#add(int, Register, Register, Register, ExtendType, int):::dst = src1 + extendType(src2) << imm.:::generalFromSize->addSubExtendedInstruction
AArch64Assembler#adds(int, Register, Register, Register, ExtendType, int):::dst = src1 + extendType(src2) << imm and sets condition flags.:::generalFromSize->addSubExtendedInstruction
AArch64Assembler#sub(int, Register, Register, Register, ExtendType, int):::dst = src1 - extendType(src2) << imm.:::generalFromSize->addSubExtendedInstruction
AArch64Assembler#subs(int, Register, Register, Register, ExtendType, int):::dst = src1 - extendType(src2) << imm and sets flags.:::generalFromSize->addSubExtendedInstruction
AArch64Assembler#and(int, Register, Register, Register, ShiftType, int):::dst = src1 & shiftType(src2, imm).:::generalFromSize->logicalRegInstruction
AArch64Assembler#ands(int, Register, Register, Register, ShiftType, int):::dst = src1 & shiftType(src2, imm) and sets condition flags.:::generalFromSize->logicalRegInstruction
AArch64Assembler#bic(int, Register, Register, Register, ShiftType, int):::dst = src1 & ~(shiftType(src2, imm)).:::generalFromSize->logicalRegInstruction
AArch64Assembler#bics(int, Register, Register, Register, ShiftType, int):::dst = src1 & ~(shiftType(src2, imm)) and sets condition flags.:::generalFromSize->logicalRegInstruction
AArch64Assembler#eon(int, Register, Register, Register, ShiftType, int):::dst = src1 ^ ~(shiftType(src2, imm)).:::generalFromSize->logicalRegInstruction
AArch64Assembler#eor(int, Register, Register, Register, ShiftType, int):::dst = src1 ^ shiftType(src2, imm).:::generalFromSize->logicalRegInstruction
AArch64Assembler#orr(int, Register, Register, Register, ShiftType, int):::dst = src1 | shiftType(src2, imm).:::generalFromSize->logicalRegInstruction
AArch64Assembler#orn(int, Register, Register, Register, ShiftType, int):::dst = src1 | ~(shiftType(src2, imm)).:::generalFromSize->logicalRegInstruction
AArch64Assembler#asr(int, Register, Register, Register):::dst = src1 >> (src2 & log2(size)).:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#lsl(int, Register, Register, Register):::dst = src1 << (src2 & log2(size)).:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#lsr(int, Register, Register, Register):::dst = src1 >>> (src2 & log2(size)).:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#ror(int, Register, Register, Register):::dst = rotateRight(src1, (src2 & log2(size))).:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#cls(int, Register, Register):::Counts leading sign bits:::generalFromSize->dataProcessing1SourceOp
AArch64Assembler#clz(int, Register, Register):::Counts leading zeros.:::generalFromSize->dataProcessing1SourceOp
AArch64Assembler#rbit(int, Register, Register):::Reverses bits.:::generalFromSize->dataProcessing1SourceOp
AArch64Assembler#rev(int, Register, Register):::Reverses bytes.:::if->generalFromSize->dataProcessing1SourceOp->else->generalFromSize->dataProcessing1SourceOp
AArch64Assembler#csel(int, Register, Register, Register, ConditionFlag):::Conditional select:::generalFromSize->conditionalSelectInstruction
AArch64Assembler#csneg(int, Register, Register, Register, ConditionFlag):::Conditional select negate:::generalFromSize->conditionalSelectInstruction
AArch64Assembler#csinc(int, Register, Register, Register, ConditionFlag):::Conditional increase:::generalFromSize->conditionalSelectInstruction
AArch64Assembler#madd(int, Register, Register, Register, Register):::dst = src1 * src2 + src3.:::generalFromSize->mulInstruction
AArch64Assembler#msub(int, Register, Register, Register, Register):::dst = src3 - src1 * src2.:::generalFromSize->mulInstruction
AArch64Assembler#smulh(Register, Register, Register):::Signed multiply high:::rs1->rs2->emitInt
AArch64Assembler#umulh(Register, Register, Register):::unsigned multiply high:::rs1->rs2->emitInt
AArch64Assembler#umaddl(Register, Register, Register, Register):::unsigned multiply add-long:::rs1->rs2->emitInt
AArch64Assembler#smaddl(Register, Register, Register, Register):::signed multiply add-long:::rs1->rs2->rs3->emitInt
AArch64Assembler#sdiv(int, Register, Register, Register):::Signed divide:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#udiv(int, Register, Register, Register):::Unsigned divide:::generalFromSize->dataProcessing2SourceOp
AArch64Assembler#fldr(int, Register, AArch64Address):::Floating point load.:::transferSize->NumUtil->log2Ceil->loadStoreInstruction
AArch64Assembler#fstr(int, Register, AArch64Address):::Floating point store.:::transferSize->NumUtil->log2Ceil->loadStoreInstruction
AArch64Assembler#fmov(int, Register, Register):::Floating point move.:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#fmovFpu2Cpu(int, Register, Register):::Move size bits from floating point register unchanged to general purpose register.:::fmovCpuFpuInstruction
AArch64Assembler#fmovCpu2Fpu(int, Register, Register):::Move size bits from general purpose register unchanged to floating point register.:::fmovCpuFpuInstruction
AArch64Assembler#fmov(int, Register, double):::Move immediate into register.:::type->floatFromSize->immEncoding->if->getDoubleImmediate->else->getFloatImmediate->rd->emitInt
AArch64Assembler#fcvt(int, Register, Register):::Convert float to double and vice-versa.:::if->floatFromSize->fpDataProcessing1Source->else->floatFromSize->fpDataProcessing1Source
AArch64Assembler#fcvtzs(int, int, Register, Register):::Convert floating point to integer:::generalFromSize->floatFromSize->fcvtCpuFpuInstruction
AArch64Assembler#scvtf(int, int, Register, Register):::Converts integer to floating point:::floatFromSize->generalFromSize->fcvtCpuFpuInstruction
AArch64Assembler#frintz(int, Register, Register):::Rounds floating-point to integral:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#frintn(int, Register, Register):::Rounds floating-point to integral:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#frintm(int, Register, Register):::Rounds floating-point to integral:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#frintp(int, Register, Register):::Rounds floating-point to integral:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#fabs(int, Register, Register):::dst = |src|.:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#fneg(int, Register, Register):::dst = -neg.:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#fsqrt(int, Register, Register):::dst = Sqrt(src).:::floatFromSize->fpDataProcessing1Source
AArch64Assembler#fadd(int, Register, Register, Register):::dst = src1 + src2.:::floatFromSize->fpDataProcessing2Source
AArch64Assembler#fsub(int, Register, Register, Register):::dst = src1 - src2.:::floatFromSize->fpDataProcessing2Source
AArch64Assembler#fmul(int, Register, Register, Register):::dst = src1 * src2.:::floatFromSize->fpDataProcessing2Source
AArch64Assembler#fdiv(int, Register, Register, Register):::dst = src1 / src2.:::floatFromSize->fpDataProcessing2Source
AArch64Assembler#fmadd(int, Register, Register, Register, Register):::dst = src1 * src2 + src3.:::floatFromSize->fpDataProcessing3Source
AArch64Assembler#fmsub(int, Register, Register, Register, Register):::dst = src3 - src1 * src2.:::floatFromSize->fpDataProcessing3Source
AArch64Assembler#fcmp(int, Register, Register):::Compares src1 to src2.:::type->floatFromSize->rs1->rs2->emitInt
AArch64Assembler#fcmpe(int, Register, Register):::Signalling compares src1 to src2.:::type->floatFromSize->rs1->rs2->emitInt
AArch64Assembler#fccmp(int, Register, Register, int, ConditionFlag):::Conditional compare:::type->floatFromSize->rs1->rs2->emitInt
AArch64Assembler#fcmpZero(int, Register):::Compare register to 0.0 .:::type->floatFromSize->rs1->emitInt
AArch64Assembler#fcmpeZero(int, Register):::Signalling compare register to 0.0 .:::type->floatFromSize->rs1->emitInt
AArch64Assembler#fcsel(int, Register, Register, Register, ConditionFlag):::Conditional select:::type->floatFromSize->rd->rs1->rs2->emitInt
AArch64Assembler#hlt(int):::Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as UNALLOCATED instruction.:::exceptionInstruction
AArch64Assembler#brk(int):::Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher exception level.:::exceptionInstruction
AArch64Assembler#hint(SystemHint):::Architectural hints.:::emitInt
AArch64Assembler#clrex():::Clear Exclusive: clears the local record of the executing processor that an address has had a request for an exclusive access.:::emitInt
AArch64Assembler#dmb(BarrierKind):::Data Memory Barrier.:::emitInt
AArch64Assembler#cnt(int, Register, Register):::dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.:::rd->rs1->emitInt
AArch64Assembler#addv(int, SIMDElementSize, Register, Register):::dst = src[0] + ....+ src[n].:::rd->rs1->emitInt
AArch64Assembler#umov(int, Register, int, Register):::dst = src[srcIdx].:::simdDataType->simdFromSize->imm5->Integer->numberOfTrailingZeros->rd->rs1->emitInt
AArch64MacroAssembler#generateAddressPlan(long, boolean, int):::Generates an addressplan for an address of the form base + displacement [+ index [<< log2(transferSize)]] with the index register and scaling being optional.:::indexScaled->log2Scale->NumUtil->log2Ceil->scaledDisplacement->displacementScalable->if->return->new->AddressGenerationPlan->else->if->if->needsScratch->isArithmeticImmediate->return->new->AddressGenerationPlan->else->needsScratch->isArithmeticImmediate->return->new->AddressGenerationPlan->else->if->NumUtil->isUnsignedNbit->return->new->AddressGenerationPlan->else->if->NumUtil->isSignedNbit->return->new->AddressGenerationPlan->else->needsScratch->isArithmeticImmediate->return->new->AddressGenerationPlan
AArch64MacroAssembler#makeAddress(Register, long, Register, boolean, int, Register, boolean):::Returns an AArch64Address pointing to base + displacement + index << log2(transferSize).:::plan->index->equals->generateAddressPlan->log2Scale->NumUtil->log2Ceil->scaledDisplacement->newIndex->newBase->immediate->switch->if->else->break->if->mov->add->else->add->break->if->mov->add->else->add->break->throw->GraalError->shouldNotReachHere->addressingMode->extendType->if->if->newIndex->equals->else->if->return->AArch64Address->createAddress
AArch64MacroAssembler#makeAddress(Register, long, Register, int, boolean):::Returns an AArch64Address pointing to base + displacement:::return->makeAddress
AArch64MacroAssembler#makeAddress(Register, long, int):::Returns an AArch64Address pointing to base + displacement:::return->makeAddress
AArch64MacroAssembler#loadAddress(Register, AArch64Address, int):::Loads memory address into register.:::shiftAmt->NumUtil->log2Ceil->switch->address->getAddressingMode->scaledImmediate->address->getImmediateRaw->lowerBits->NumUtil->getNbitNumberInt->higherBits->NumUtil->getNbitNumberInt->firstAdd->if->address->getBase->add->if->src->address->getBase->add->break->immediate->address->getImmediateRaw->address->getBase->add->break->address->getBase->address->getOffset->address->isScaled->add->break->address->getBase->address->getOffset->address->getExtendType->address->isScaled->add->break->addressOf->break->address->getBase->movx->break->throw->GraalError->shouldNotReachHere
AArch64MacroAssembler#mov(Register, long):::Loads immediate into register.:::mov
AArch64MacroAssembler#mov(Register, long, boolean):::Loads immediate into register.:::if->movx->else->if->LogicalImmediateTable->isRepresentable->or->else->if->LogicalImmediateTable->isRepresentable->mov->sxt->else->mov64
AArch64MacroAssembler#mov(Register, int):::Loads immediate into register.:::mov
AArch64MacroAssembler#movNativeAddress(Register, long):::Generates a 48-bit immediate move code sequence:::movNativeAddress
AArch64MacroAssembler#movNativeAddress(Register, long, boolean):::Generates a 48-bit immediate move code sequence:::firstMove->pos->position->for->offset->if->annotateImmediateMovSequence
AArch64MacroAssembler#movNarrowAddress(Register, long):::Generates a 32-bit immediate move code sequence:::movz->movk
AArch64MacroAssembler#ldrs(int, int, Register, AArch64Address):::Loads a srcSize value from address into rt sign-extending it if necessary.:::if->super->ldr->else->super->ldrs
AArch64MacroAssembler#ldr(int, Register, AArch64Address):::Loads a srcSize value from address into rt zero-extending it if necessary.:::super->ldr
AArch64MacroAssembler#cmov(int, Register, Register, Register, ConditionFlag):::Conditional move:::super->csel
AArch64MacroAssembler#cset(int, Register, ConditionFlag):::Conditional set:::super->condition->negate->csinc
AArch64MacroAssembler#add(int, Register, Register, Register):::dst = src1 + src2.:::if->dst->equals->src1->equals->super->add->else->super->add
AArch64MacroAssembler#adds(int, Register, Register, Register):::dst = src1 + src2 and sets condition flags.:::if->dst->equals->src1->equals->super->adds->else->super->adds
AArch64MacroAssembler#subs(int, Register, Register, Register):::dst = src1 - src2 and sets condition flags.:::if->dst->equals->src1->equals->super->subs->else->super->subs
AArch64MacroAssembler#sub(int, Register, Register, Register):::dst = src1 - src2.:::if->dst->equals->src1->equals->super->sub->else->super->sub
AArch64MacroAssembler#add(int, Register, Register, Register, ShiftType, int):::dst = src1 + shiftType(src2, shiftAmt & (size - 1)).:::shift->clampShiftAmt->super->add
AArch64MacroAssembler#sub(int, Register, Register, Register, ShiftType, int):::dst = src1 + shiftType(src2, shiftAmt & (size-1)) and sets condition flags.:::shift->clampShiftAmt->super->sub
AArch64MacroAssembler#neg(int, Register, Register):::dst = -src1.:::sub
AArch64MacroAssembler#add(int, Register, Register, int):::dst = src + immediate.:::if->sub->else->if->isAimm->if->dst->equals->super->add->else->if->super->add->super->add->else->mov->add
AArch64MacroAssembler#add(int, Register, Register, long):::dst = src + immediate.:::if->NumUtil->isInt->add->else->mov->add
AArch64MacroAssembler#adds(int, Register, Register, int):::dst = src + aimm and sets condition flags.:::if->subs->else->if->dst->equals->super->adds
AArch64MacroAssembler#sub(int, Register, Register, int):::dst = src - immediate.:::if->add->else->if->isAimm->if->dst->equals->super->sub->else->if->super->sub->super->sub->else->mov->sub
AArch64MacroAssembler#subs(int, Register, Register, int):::dst = src - aimm and sets condition flags.:::if->adds->else->if->dst->equals->super->subs
AArch64MacroAssembler#mul(int, Register, Register, Register):::dst = src1 * src2.:::super->madd
AArch64MacroAssembler#madd(int, Register, Register, Register, Register):::dst = src3 + src1 * src2.:::super->madd
AArch64MacroAssembler#msub(int, Register, Register, Register, Register):::dst = src3 - src1 * src2.:::super->msub
AArch64MacroAssembler#mneg(int, Register, Register, Register):::dst = 0 - src1 * src2.:::super->msub
AArch64MacroAssembler#umulh(int, Register, Register, Register):::unsigned multiply high:::if->super->umulh->else->super->umaddl->lshr
AArch64MacroAssembler#smulh(int, Register, Register, Register):::signed multiply high:::if->super->smulh->else->super->smaddl->lshr
AArch64MacroAssembler#rem(int, Register, Register, Register):::dst = src1 % src2:::super->sdiv->super->msub
AArch64MacroAssembler#urem(int, Register, Register, Register):::dst = src1 % src2:::super->udiv->super->msub
AArch64MacroAssembler#isArithmeticImmediate(long):::Add/subtract instruction encoding supports 12-bit immediate values.:::return->NumUtil->Math->abs->isInt->Math->abs->isAimm
AArch64MacroAssembler#isComparisonImmediate(long):::Compare instructions are add/subtract instructions and so support 12-bit immediate values.:::return->isArithmeticImmediate
AArch64MacroAssembler#isMovableImmediate(long):::Move wide immediate instruction encoding supports 16-bit immediate values which can be optionally-shifted by multiples of 16 (i.e:::return->NumUtil->Math->abs->isInt->NumUtil->Math->abs->isUnsignedNbit
AArch64MacroAssembler#shl(int, Register, Register, long):::dst = src << (shiftAmt & (size - 1)).:::shift->clampShiftAmt->super->ubfm
AArch64MacroAssembler#shl(int, Register, Register, Register):::dst = src1 << (src2 & (size - 1)).:::super->lsl
AArch64MacroAssembler#lshr(int, Register, Register, long):::dst = src >>> (shiftAmt & (size - 1)).:::shift->clampShiftAmt->super->ubfm
AArch64MacroAssembler#lshr(int, Register, Register, Register):::dst = src1 >>> (src2 & (size - 1)).:::super->lsr
AArch64MacroAssembler#ashr(int, Register, Register, long):::dst = src >> (shiftAmt & log2(size)).:::shift->clampShiftAmt->super->sbfm
AArch64MacroAssembler#ashr(int, Register, Register, Register):::dst = src1 >> (src2 & log2(size)).:::super->asr
AArch64MacroAssembler#and(int, Register, Register, Register):::dst = src1 & src2.:::super->and
AArch64MacroAssembler#eor(int, Register, Register, Register):::dst = src1 ^ src2.:::super->eor
AArch64MacroAssembler#or(int, Register, Register, Register):::dst = src1 | src2.:::super->orr
AArch64MacroAssembler#or(int, Register, Register, long):::dst = src | bimm.:::super->orr
AArch64MacroAssembler#not(int, Register, Register):::dst = ~src.:::super->orn
AArch64MacroAssembler#and(int, Register, Register, Register, ShiftType, int):::dst = src1 & shiftType(src2, imm).:::super->and
AArch64MacroAssembler#eor(int, Register, Register, Register, ShiftType, int):::dst = src1 ^ shiftType(src2, imm).:::super->eor
AArch64MacroAssembler#or(int, Register, Register, Register, ShiftType, int):::dst = src1 | shiftType(src2, imm).:::super->orr
AArch64MacroAssembler#bic(int, Register, Register, Register, ShiftType, int):::dst = src1 & ~(shiftType(src2, imm)).:::super->bic
AArch64MacroAssembler#eon(int, Register, Register, Register, ShiftType, int):::dst = src1 ^ ~(shiftType(src2, imm)).:::super->eon
AArch64MacroAssembler#orn(int, Register, Register, Register, ShiftType, int):::dst = src1 | ~(shiftType(src2, imm)).:::super->orn
AArch64MacroAssembler#sxt(int, int, Register, Register):::Sign-extend value from src into dst.:::super->sbfm
AArch64MacroAssembler#csneg(int, Register, Register, ConditionFlag):::dst = src if condition else -src.:::super->condition->negate->csneg
AArch64MacroAssembler#fmov(int, Register, Register):::Moves integer to float, float to integer, or float to float:::if->dst->getRegisterCategory->equals->super->fmovFpu2Cpu->else->if->src->getRegisterCategory->equals->super->fmovCpu2Fpu->else->super->fmov
AArch64MacroAssembler#fcmov(int, Register, Register, Register, ConditionFlag):::Conditional move:::super->fcsel
AArch64MacroAssembler#frem(int, Register, Register, Register):::dst = src1 % src2.:::super->fdiv->super->frintz->super->fmsub
AArch64MacroAssembler#cmp(int, Register, Register):::Compares x and y and sets condition flags.:::super->subs
AArch64MacroAssembler#cmp(int, Register, int):::Compares x to y and sets condition flags.:::if->super->adds->else->super->subs
AArch64MacroAssembler#ands(int, Register, Register, Register):::Sets condition flags according to result of x & y.:::super->ands
AArch64MacroAssembler#mulvs(int, Register, Register, Register):::Sets overflow flag according to result of x * y.:::try->sc1->getScratchRegister->sc2->getScratchRegister->switch->rscratch1->sc1->getRegister->rscratch2->sc2->getRegister->mul->smulh->subs->mov->mov->cmov->cmp->break->rscratch1->sc1->getRegister->smaddl->mov->subs->mov->cmov->cmp->break->catch->finally
AArch64MacroAssembler#cbnz(int, Register, Label):::Compare register and branch if non-zero.:::if->label->isBound->offset->label->position->position->super->cbnz->else->label->position->addPatchAt->regEncoding->sizeEncoding->emitInt
AArch64MacroAssembler#cbz(int, Register, Label):::Compare register and branch if zero.:::if->label->isBound->offset->label->position->position->super->cbz->else->label->position->addPatchAt->regEncoding->sizeEncoding->emitInt
AArch64MacroAssembler#tbnz(Register, int, Label):::Test a single bit and branch if the bit is nonzero.:::if->label->isBound->offset->label->position->position->super->tbnz->else->label->position->addPatchAt->indexEncoding->regEncoding->emitInt
AArch64MacroAssembler#tbz(Register, int, Label):::Test a single bit and branch if the bit is zero.:::if->label->isBound->offset->label->position->position->super->tbz->else->label->position->addPatchAt->indexEncoding->regEncoding->emitInt
AArch64MacroAssembler#branchConditionally(ConditionFlag, Label):::Branches to label if condition is true.:::if->label->isBound->offset->label->position->position->super->b->else->label->position->addPatchAt->emitInt
AArch64MacroAssembler#branchConditionally(ConditionFlag):::Branches if condition is true:::super->b
AArch64MacroAssembler#jmp(Label):::Jumps to label:::if->label->isBound->offset->label->position->position->super->b->else->label->position->addPatchAt->emitInt
AArch64MacroAssembler#jmp(Register):::Jump to address in dest.:::super->br
AArch64MacroAssembler#jmp():::Immediate jump instruction fixed up by HotSpot c++ code.:::super->b
AArch64MacroAssembler#hlt(AArch64ExceptionCode):::Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as UNALLOCATED instruction.:::super->hlt
AArch64MacroAssembler#brk(AArch64ExceptionCode):::Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher exception level.:::super->brk
AArch64MacroAssembler#nop():::Executes no-op instruction:::super->hint
AArch64MacroAssembler#csdb():::Consumption of Speculative Data Barrier:::super->hint
AArch64MacroAssembler#ensureUniquePC():::Same as #nop().:::nop
AArch64MacroAssembler#align(int):::Aligns PC.:::if->position->return->offset->position->for->i
AArch64MacroAssembler#patchJumpTarget(int, int):::Patches jump targets when label gets bound.:::instruction->getInt->branchOffset->type->PatchLabelKind->fromEncoding->switch->cf->ConditionFlag->fromEncoding->super->b->break->super->b->break->offset->emitInt->break->information->sizeEncoding->regEncoding->reg->get->size->switch->super->cbnz->break->super->cbz->break->break->information->sizeEncoding->NumUtil->getNbitNumberInt->regEncoding->reg->get->if->NumUtil->isSignedNbit->throw->new->BranchTargetOutOfBoundsException->switch->super->tbnz->break->super->tbz->break->break->information->regEncoding->reg->get->super->adr->break->throw->GraalError->shouldNotReachHere
AArch64MacroAssembler#makeAddress(Register, int):::Generates an address of the form base + displacement:::return->makeAddress
AArch64MacroAssembler#lea(Register, AArch64Address):::Loads an address into Register d.:::a->lea
AArch64MacroAssembler#popcnt(int, Register, Register, Register):::Count the set bits of src register.:::fmov->fixedSize->cnt->addv->umov
AArch64MacroAssembler#adrpLdr(int, Register, AArch64Address):::Emits elf patchable adrp ldr sequence.:::if->codePatchingAnnotationConsumer->position->new->AdrpLdrMacroInstruction->accept->super->a->getBase->adrp->this->ldr
