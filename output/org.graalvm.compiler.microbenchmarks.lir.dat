GraalCompilerState#getMethodFromString(String):::Gets a Method from a method description string:::try->s0->methodDesc->split->if->throw->new->RuntimeException->className->clazz->Class->forName->s1->split->name->parameters->if->parametersPart->if->parametersPart->parametersPart->length->charAt->throw->new->RuntimeException->s2->parametersPart->parametersPart->length->substring->split->new->Class<?>Arr->for->i->return->GraalUtil->getMethod->catch->throw->new->RuntimeException->finally
GraalCompilerState#prepareRequest():::Copies the #originalGraph original graph and prepares the #request:::compilationId->backend->originalGraph->method->getCompilationIdentifier->originalGraph->originalGraph->getDebug->copyWithIdentifier->installedCodeOwner->graph->method->getProviders->getBackend->getDefaultGraphBuilderSuite->graph->getProfilingInfo->getOptions->createSuites->getOptions->createLIRSuites->graph->compilationId->new->CompilationResult->new->Request<>
GraalCompilerState#emitFrontEnd():::Executes the high-level (FrontEnd) part of the compiler.:::GraalCompiler->emitFrontEnd->freeze
GraalCompilerState#emitBackEnd():::Executes the low-level (BackEnd) part of the compiler.:::emitLIR->emitCode
GraalCompilerState#emitLIR():::Generates LIR and executes the LIR pipeline.:::generateLIR->emitLowLevel
GraalCompilerState#generateLIR():::Generates the initial LIR.:::preLIRGeneration->lirGeneration
GraalCompilerState#preLIRGeneration():::Sets up LIR generation.:::stub->getLastSchedule->cfg->schedule->getCFG->deepCopy->blocks->cfg->getBlocks->startBlock->cfg->getStartBlock->ComputeBlockOrder->computeCodeEmittingOrder->ComputeBlockOrder->computeLinearScanOrder->lir->getGraphOptions->getGraphDebug->new->LIR->lirBackend->lirBackend->graph->compilationId->newLIRGenerationResult->lirBackend->newLIRGenerator->lirBackend->newNodeLIRBuilder
GraalCompilerState#lirGeneration():::Executes the LIRGenerationPhase.:::context->new->LIRGenerationContext->new->LIRGenerationPhase->getTarget->apply
GraalCompilerState#emitLowLevel():::Executes the low-level compiler stages.:::preAllocationStage->allocationStage->postAllocationStage
GraalCompilerState#applyLIRPhase(LIRPhase, C):::Executes a LIRPhase within a given context.:::phase->getTarget->apply
GraalCompilerState#preAllocationStage():::Executes the PreAllocationStage:::getLIRSuites->getPreAllocationOptimizationStage->createPreAllocationOptimizationContext->applyLIRPhase
GraalCompilerState#allocationStage():::Executes the AllocationStage:::getLIRSuites->getAllocationStage->createAllocationContext->applyLIRPhase
GraalCompilerState#postAllocationStage():::Executes the PostAllocationStage:::getLIRSuites->getPostAllocationOptimizationStage->createPostAllocationOptimizationContext->applyLIRPhase
GraalCompilerState#emitCode():::Emits the machine code.:::bytecodeSize->method->getBytecodeSize->speculationLog->hasUnsafeAccess->setHasUnsafeAccess->LIRCompilerBackend->getAssumptions->method->getMethods->getFields->emitCode
GraalCompilerState.BackEndOnly#setupGraph():::Cannot do this Level#Trial only once since #emitCode() closes the CompilationResult.:::prepareRequest->emitFrontEnd
GraalCompilerState.PreAllocationStage#setupGraph():::No need to rebuild the graph for every invocation since it is not altered by the backend.:::initializeMethod->prepareRequest->emitFrontEnd
GraalCompilerState.AllocationStage#setupGraph():::No need to rebuild the graph for every invocation since it is not altered by the backend.:::initializeMethod->prepareRequest->emitFrontEnd
GraalCompilerState.PostAllocationStage#setupGraph():::No need to rebuild the graph for every invocation since it is not altered by the backend.:::initializeMethod->prepareRequest->emitFrontEnd
