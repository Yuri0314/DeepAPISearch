AbstractDateTimeDV#getAllowedFacets()::: abstract date time v get allowed facets:::return
AbstractDateTimeDV#isIdentical(Object, Object)::: abstract date time v is identical:::if->return->v1->v2->if->return->v1->equals->return
AbstractDateTimeDV#compare(Object, Object)::: abstract date time v compare:::return->compareDates
AbstractDateTimeDV#compareDates(DateTimeData, DateTimeData, boolean):::Compare algorithm described in dateDime (3.2.7):::if->return->compareOrder->c1->c2->tempDate->new->DateTimeData->if->cloneDate->normalize->compareOrder->if->return->cloneDate->normalize->compareOrder->if->return->return->else->if->cloneDate->if->dateToString->println->normalize->compareOrder->if->dateToString->println->dateToString->println->if->return->cloneDate->normalize->compareOrder->if->dateToString->println->if->return->return->return
AbstractDateTimeDV#compareOrder(DateTimeData, DateTimeData):::Given normalized values, determines order-relation between give date/time objects.:::if->if->return->if->return->if->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->return
AbstractDateTimeDV#getTime(String, int, int, DateTimeData):::Parses time hh:mm:ss.sss and time zone if any:::stop->parseInt->if->buffer->charAt->throw->new->RuntimeException->parseInt->if->buffer->charAt->throw->new->RuntimeException->sign->findUTCSign->parseSecond->if->getTimeZone
AbstractDateTimeDV#getDate(String, int, int, DateTimeData):::Parses date CCYY-MM-DD:::getYearMonth->if->buffer->charAt->throw->new->RuntimeException->stop->parseInt->return
AbstractDateTimeDV#getYearMonth(String, int, int, DateTimeData):::Parses date CCYY-MM:::if->buffer->charAt->i->indexOf->if->throw->new->RuntimeException->length->if->throw->new->RuntimeException->else->if->buffer->charAt->throw->new->RuntimeException->parseIntYear->if->buffer->charAt->throw->new->RuntimeException->parseInt->return
AbstractDateTimeDV#parseTimeZone(String, int, int, DateTimeData):::Shared code from Date and YearMonth datatypes:::if->if->isNextCharUTCSign->throw->new->RuntimeException->else->getTimeZone
AbstractDateTimeDV#getTimeZone(String, DateTimeData, int, int):::Parses time zone: 'Z' or {+,-} followed by hh:mm:::buffer->charAt->if->buffer->charAt->if->throw->new->RuntimeException->return->if->negate->buffer->charAt->stop->parseInt->if->buffer->charAt->throw->new->RuntimeException->parseInt->if->throw->new->RuntimeException->if->else->throw->new->RuntimeException->if->println
AbstractDateTimeDV#indexOf(String, int, int, char):::Computes index of given char within StringBuffer:::for->i->return
AbstractDateTimeDV#validateDateTime(DateTimeData):::Validates given date/time object accoring to W3C PR Schema [D.1 ISO 8601 Conventions]:::if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->maxDayInMonthFor->throw->new->RuntimeException->if->if->if->maxDayInMonthFor->if->if->else->if->else->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->else->if->throw->new->RuntimeException->else->if->throw->new->RuntimeException
AbstractDateTimeDV#findUTCSign(String, int, int):::Return index of UTC char: 'Z', '+', '-':::c->for->i->return
AbstractDateTimeDV#isNextCharUTCSign(String, int, int):::Returns true if the character at start is 'Z', '+' or '-'.:::if->c->buffer->charAt->return->return
AbstractDateTimeDV#parseInt(String, int, int):::Given start and end position, parses string value:::radix->result->digit->limit->multmin->i->do->buffer->charAt->getDigit->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->while->return
AbstractDateTimeDV#parseIntYear(String, int)::: abstract date time v parse int year:::radix->result->negative->i->limit->multmin->digit->if->buffer->charAt->else->while->buffer->charAt->getDigit->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->if->if->return->else->throw->new->NumberFormatException->return
AbstractDateTimeDV#normalize(DateTimeData):::If timezone present - normalize dateTime [E Adding durations to dateTimes]:::negate->if->println->println->temp->carry->fQuotient->mod->if->println->fQuotient->mod->if->println->println->while->maxDayInMonthFor->if->maxDayInMonthFor->else->if->else->break->modulo->fQuotient->if
AbstractDateTimeDV#saveUnnormalized(DateTimeData)::: abstract date time v save unnormalized:::
AbstractDateTimeDV#resetDateObj(DateTimeData):::Resets object representation of date/time:::
AbstractDateTimeDV#maxDayInMonthFor(int, int):::Given {year,month} computes maximum number of days for given month:::if->return->else->if->if->isLeapYear->return->else->return->else->return
AbstractDateTimeDV#isLeapYear(int)::: abstract date time v is leap year:::return
AbstractDateTimeDV#mod(int, int, int)::: abstract date time v mod:::return
AbstractDateTimeDV#fQuotient(int, int)::: abstract date time v f quotient:::return->Math->floor
AbstractDateTimeDV#modulo(int, int, int)::: abstract date time v modulo:::a->b->return->fQuotient->mod
AbstractDateTimeDV#fQuotient(int, int, int)::: abstract date time v f quotient:::return->fQuotient
AbstractDateTimeDV#dateToString(DateTimeData)::: abstract date time v date to string:::message->new->StringBuffer->append->message->append->append->message->append->append->message->append->append->message->append->append->message->append->append->append->return->message->toString
AbstractDateTimeDV#append(StringBuffer, int, int)::: abstract date time v append:::if->message->append->return->if->message->append->if->if->message->append->else->if->message->append->else->if->message->append->message->append->else->if->if->message->append->message->append->else->if->message->append
AbstractDateTimeDV#append(StringBuffer, double)::: abstract date time v append:::if->message->append->if->message->append->append2
AbstractDateTimeDV#append2(StringBuffer, double)::: abstract date time v append2:::intValue->if->message->append->else->append3
AbstractDateTimeDV#append3(StringBuffer, double)::: abstract date time v append3:::d->String->valueOf->eIndex->d->indexOf->if->message->append->return->exp->if->try->d->length->parseInt->catch->message->append->return->finally->message->append->for->i->end->while->c->d->charAt->if->break->for->i->else->try->d->length->parseInt->catch->message->append->return->finally->integerEnd->for->i->for->i
AbstractDateTimeDV#parseSecond(String, int, int)::: abstract date time v parse second:::dot->for->i->if->if->throw->new->NumberFormatException->else->if->throw->new->NumberFormatException->return->Double->buffer->substring->parseDouble
AbstractDateTimeDV#cloneDate(DateTimeData, DateTimeData)::: abstract date time v clone date:::
AbstractDateTimeDV.DateTimeData#equals(Object)::: date time data equals:::if->return->return->type->compareDates
AbstractDateTimeDV.DateTimeData#hashCode()::: date time data hash code:::tempDate->new->DateTimeData->type->cloneDate->type->normalize->return->type->dateToString->hashCode
AbstractDateTimeDV.DateTimeData#toString()::: date time data to string:::if->type->dateToString->return
AbstractDateTimeDV.DateTimeData#getYears()::: date time data get years:::if->return->return
AbstractDateTimeDV.DateTimeData#getMonths()::: date time data get months:::if->return->return
AbstractDateTimeDV.DateTimeData#getDays()::: date time data get days:::if->return->return
AbstractDateTimeDV.DateTimeData#getHours()::: date time data get hours:::if->return->return
AbstractDateTimeDV.DateTimeData#getMinutes()::: date time data get minutes:::if->return->return
AbstractDateTimeDV.DateTimeData#getSeconds()::: date time data get seconds:::if->return->return
AbstractDateTimeDV.DateTimeData#hasTimeZone()::: date time data has time zone:::return
AbstractDateTimeDV.DateTimeData#getTimeZoneHours()::: date time data get time zone hours:::return
AbstractDateTimeDV.DateTimeData#getTimeZoneMinutes()::: date time data get time zone minutes:::return
AbstractDateTimeDV.DateTimeData#getLexicalValue()::: date time data get lexical value:::return
AbstractDateTimeDV.DateTimeData#normalize()::: date time data normalize:::if->dt->this->clone->return->return
AbstractDateTimeDV.DateTimeData#isNormalized()::: date time data is normalized:::return
AbstractDateTimeDV.DateTimeData#clone()::: date time data clone:::dt->new->DateTimeData->return
AbstractDateTimeDV.DateTimeData#getXMLGregorianCalendar()::: date time data get gregorian calendar:::return->type->getXMLGregorianCalendar
AbstractDateTimeDV.DateTimeData#getDuration()::: date time data get duration:::return->type->getDuration
AbstractDateTimeDV#getXMLGregorianCalendar(DateTimeData)::: abstract date time v get gregorian calendar:::return
AbstractDateTimeDV#getDuration(DateTimeData)::: abstract date time v get duration:::return
AbstractDateTimeDV#getFractionalSecondsAsBigDecimal(DateTimeData)::: abstract date time v get fractional seconds as big decimal:::buf->new->StringBuffer->append3->value->buf->toString->index->value->indexOf->if->return->value->substring->_val->new->BigDecimal->if->_val->BigDecimal->valueOf->compareTo->return->return
AnyAtomicDV#getAllowedFacets()::: any atomic v get allowed facets:::return
AnyAtomicDV#getActualValue(String, ValidationContext)::: any atomic v get actual value:::return
AnySimpleDV#getAllowedFacets()::: any simple v get allowed facets:::return
AnySimpleDV#getActualValue(String, ValidationContext)::: any simple v get actual value:::return
AnyURIDV#getAllowedFacets()::: any v get allowed facets:::return
AnyURIDV#getActualValue(String, ValidationContext)::: any v get actual value:::try->if->content->length->encoded->encode->new->URI->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally->return
AnyURIDV#encode(String)::: any v encode:::len->anyURI->length->ch->buffer->new->StringBuffer->i->for->if->bytes->b->try->anyURI->substring->getBytes->catch->return->finally->for->if->buffer->length->return->buffer->toString->else->return
Base64BinaryDV#getAllowedFacets()::: base64 binary v get allowed facets:::return
Base64BinaryDV#getActualValue(String, ValidationContext)::: base64 binary v get actual value:::decoded->Base64->decode->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->return->new->XBase64
Base64BinaryDV#getDataLength(Object)::: base64 binary v get data length:::return->getLength
Base64BinaryDV.XBase64#toString()::: base64 to string:::if->Base64->encode->return
Base64BinaryDV.XBase64#equals(Object)::: base64 equals:::if->return->odata->len->if->return->for->i->return
Base64BinaryDV.XBase64#hashCode()::: base64 hash code:::hash->for->i->return
BaseDVFactory#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBaseTypes->get
BaseDVFactory#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBaseTypes->makeClone
BaseDVFactory#createTypeRestriction(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by restriction from another simple type.:::return->new->XSSimpleTypeDecl
BaseDVFactory#createTypeList(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by list from another simple type.:::return->new->XSSimpleTypeDecl
BaseDVFactory#createTypeUnion(String, String, short, XSSimpleType[], XSObjectList):::Create a new simple type which is derived by union from a list of other simple types.:::typeNum->mtypes->new->XSSimpleTypeDeclArr->System->arraycopy->return->new->XSSimpleTypeDecl
BaseDVFactory#createBuiltInTypes(SymbolHash)::: base factory create built in types:::ANYSIMPLETYPE->ANYURI->BASE64BINARY->BOOLEAN->BYTE->DATE->DATETIME->DAY->DECIMAL->INT->INTEGER->LONG->NEGATIVEINTEGER->MONTH->MONTHDAY->NONNEGATIVEINTEGER->NONPOSITIVEINTEGER->POSITIVEINTEGER->SHORT->STRING->TIME->UNSIGNEDBYTE->UNSIGNEDINT->UNSIGNEDLONG->UNSIGNEDSHORT->YEAR->YEARMONTH->facets->new->XSFacets->anySimpleType->types->put->stringDV->new->XSSimpleTypeDecl->types->put->types->new->XSSimpleTypeDecl->put->decimalDV->new->XSSimpleTypeDecl->types->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->integerDV->new->XSSimpleTypeDecl->types->put->nonPositiveDV->new->XSSimpleTypeDecl->nonPositiveDV->applyFacets1->types->put->negativeDV->new->XSSimpleTypeDecl->negativeDV->applyFacets1->types->put->longDV->new->XSSimpleTypeDecl->longDV->applyFacets1->types->put->intDV->new->XSSimpleTypeDecl->intDV->applyFacets1->types->put->shortDV->new->XSSimpleTypeDecl->shortDV->applyFacets1->types->put->byteDV->new->XSSimpleTypeDecl->byteDV->applyFacets1->types->put->nonNegativeDV->new->XSSimpleTypeDecl->nonNegativeDV->applyFacets1->types->put->unsignedLongDV->new->XSSimpleTypeDecl->unsignedLongDV->applyFacets1->types->put->unsignedIntDV->new->XSSimpleTypeDecl->unsignedIntDV->applyFacets1->types->put->unsignedShortDV->new->XSSimpleTypeDecl->unsignedShortDV->applyFacets1->types->put->unsignedByteDV->new->XSSimpleTypeDecl->unsignedByteDV->applyFacets1->types->put->positiveIntegerDV->new->XSSimpleTypeDecl->positiveIntegerDV->applyFacets1->types->put
BaseSchemaDVFactory#createBuiltInTypes(SymbolHash, XSSimpleTypeDecl)::: base schema factory create built in types:::ANYSIMPLETYPE->ANYURI->BASE64BINARY->BOOLEAN->BYTE->DATE->DATETIME->DAY->DECIMAL->DOUBLE->DURATION->ENTITY->ENTITIES->FLOAT->HEXBINARY->ID->IDREF->IDREFS->INT->INTEGER->LONG->NAME->NEGATIVEINTEGER->MONTH->MONTHDAY->NCNAME->NMTOKEN->NMTOKENS->LANGUAGE->NONNEGATIVEINTEGER->NONPOSITIVEINTEGER->NORMALIZEDSTRING->NOTATION->POSITIVEINTEGER->QNAME->SHORT->STRING->TIME->TOKEN->UNSIGNEDBYTE->UNSIGNEDINT->UNSIGNEDLONG->UNSIGNEDSHORT->YEAR->YEARMONTH->facets->new->XSFacets->builtInTypes->put->stringDV->new->XSSimpleTypeDecl->builtInTypes->put->builtInTypes->new->XSSimpleTypeDecl->put->decimalDV->new->XSSimpleTypeDecl->builtInTypes->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->durationDV->new->XSSimpleTypeDecl->builtInTypes->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->integerDV->new->XSSimpleTypeDecl->builtInTypes->put->nonPositiveDV->new->XSSimpleTypeDecl->nonPositiveDV->applyFacets1->builtInTypes->put->negativeDV->new->XSSimpleTypeDecl->negativeDV->applyFacets1->builtInTypes->put->longDV->new->XSSimpleTypeDecl->longDV->applyFacets1->builtInTypes->put->intDV->new->XSSimpleTypeDecl->intDV->applyFacets1->builtInTypes->put->shortDV->new->XSSimpleTypeDecl->shortDV->applyFacets1->builtInTypes->put->byteDV->new->XSSimpleTypeDecl->byteDV->applyFacets1->builtInTypes->put->nonNegativeDV->new->XSSimpleTypeDecl->nonNegativeDV->applyFacets1->builtInTypes->put->unsignedLongDV->new->XSSimpleTypeDecl->unsignedLongDV->applyFacets1->builtInTypes->put->unsignedIntDV->new->XSSimpleTypeDecl->unsignedIntDV->applyFacets1->builtInTypes->put->unsignedShortDV->new->XSSimpleTypeDecl->unsignedShortDV->applyFacets1->builtInTypes->put->unsignedByteDV->new->XSSimpleTypeDecl->unsignedByteDV->applyFacets1->builtInTypes->put->positiveIntegerDV->new->XSSimpleTypeDecl->positiveIntegerDV->applyFacets1->builtInTypes->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->normalizedDV->new->XSSimpleTypeDecl->normalizedDV->applyFacets1->builtInTypes->put->tokenDV->new->XSSimpleTypeDecl->tokenDV->applyFacets1->builtInTypes->put->languageDV->new->XSSimpleTypeDecl->languageDV->applyFacets1->builtInTypes->put->nameDV->new->XSSimpleTypeDecl->nameDV->applyFacets1->builtInTypes->put->ncnameDV->new->XSSimpleTypeDecl->ncnameDV->applyFacets1->builtInTypes->put->builtInTypes->new->XSSimpleTypeDecl->put->builtInTypes->new->XSSimpleTypeDecl->put->idrefDV->new->XSSimpleTypeDecl->builtInTypes->put->tempDV->new->XSSimpleTypeDecl->idrefsDV->new->XSSimpleTypeDecl->idrefsDV->applyFacets1->builtInTypes->put->entityDV->new->XSSimpleTypeDecl->builtInTypes->put->new->XSSimpleTypeDecl->entitiesDV->new->XSSimpleTypeDecl->entitiesDV->applyFacets1->builtInTypes->put->nmtokenDV->new->XSSimpleTypeDecl->nmtokenDV->applyFacets1->builtInTypes->put->new->XSSimpleTypeDecl->nmtokensDV->new->XSSimpleTypeDecl->nmtokensDV->applyFacets1->builtInTypes->put
BaseSchemaDVFactory#createTypeRestriction(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by restriction from another simple type.:::if->st->fDeclPool->getSimpleTypeDecl->return->st->setRestrictionValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#createTypeList(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by list from another simple type.:::if->st->fDeclPool->getSimpleTypeDecl->return->st->setListValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#createTypeUnion(String, String, short, XSSimpleType[], XSObjectList):::Create a new simple type which is derived by union from a list of other simple types.:::typeNum->mtypes->new->XSSimpleTypeDeclArr->System->arraycopy->if->st->fDeclPool->getSimpleTypeDecl->return->st->setUnionValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#setDeclPool(XSDeclarationPool)::: base schema factory set decl pool:::
BaseSchemaDVFactory#newXSSimpleTypeDecl():::Implementation internal *:::return->new->XSSimpleTypeDecl
BooleanDV#getAllowedFacets()::: boolean v get allowed facets:::return
BooleanDV#getActualValue(String, ValidationContext)::: boolean v get actual value:::ret->if->content->equals->content->equals->else->if->content->equals->content->equals->else->throw->new->ObjectArr->new->InvalidDatatypeValueException->return
DateDV#getActualValue(String, ValidationContext)::: date v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DateDV#parse(String):::Parses, validates and computes normalized version of dateTime object:::date->new->DateTimeData->len->str->length->end->getDate->parseTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
DateDV#dateToString(DateTimeData)::: date v date to string:::message->new->StringBuffer->append->message->append->append->message->append->append->append->return->message->toString
DateDV#getXMLGregorianCalendar(DateTimeData)::: date v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
DateTimeDV#getActualValue(String, ValidationContext)::: date time v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DateTimeDV#parse(String):::Parses, validates and computes normalized version of dateTime object:::date->new->DateTimeData->len->str->length->end->indexOf->dateEnd->getDate->getTime->if->throw->new->RuntimeException->validateDateTime->saveUnnormalized->if->normalize->return
DateTimeDV#getXMLGregorianCalendar(DateTimeData)::: date time v get gregorian calendar:::return->datatypeFactory->BigInteger->valueOf->getFractionalSecondsAsBigDecimal->date->hasTimeZone->newXMLGregorianCalendar
DayDV#getActualValue(String, ValidationContext)::: day v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DayDV#parse(String):::Parses, validates and computes normalized version of gDay object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->str->charAt->throw->new->SchemaDateTimeException->parseInt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
DayDV#dateToString(DateTimeData):::Converts gDay object representation to String:::message->new->StringBuffer->message->append->message->append->message->append->append->append->return->message->toString
DayDV#getXMLGregorianCalendar(DateTimeData)::: day v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
DayTimeDurationDV#getActualValue(String, ValidationContext)::: day time duration v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DayTimeDurationDV#getDuration(DateTimeData)::: day time duration v get duration:::sign->if->return->datatypeFactory->BigInteger->valueOf->BigInteger->valueOf->BigInteger->valueOf->String->valueOf->new->BigDecimal->newDuration
DecimalDV#getAllowedFacets()::: decimal v get allowed facets:::return
DecimalDV#getActualValue(String, ValidationContext)::: decimal v get actual value:::try->return->new->XDecimal->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DecimalDV#compare(Object, Object)::: decimal v compare:::return->compareTo
DecimalDV#getTotalDigits(Object)::: decimal v get total digits:::return
DecimalDV#getFractionDigits(Object)::: decimal v get fraction digits:::return
DecimalDV.XDecimal#initD(String)::: decimal init d:::len->content->length->if->throw->new->NumberFormatException->intStart->intEnd->fracStart->fracEnd->if->content->charAt->else->if->content->charAt->actualIntStart->while->content->charAt->for->TypeValidator->content->charAt->isDigit->if->if->content->charAt->throw->new->NumberFormatException->if->throw->new->NumberFormatException->while->content->charAt->for->fracPos->if->content->substring->if->content->substring->else->if->content->substring->else
DecimalDV.XDecimal#initI(String)::: decimal init i:::len->content->length->if->throw->new->NumberFormatException->intStart->intEnd->if->content->charAt->else->if->content->charAt->actualIntStart->while->content->charAt->for->TypeValidator->content->charAt->isDigit->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->if->content->substring->else
DecimalDV.XDecimal#equals(Object)::: decimal equals:::if->return->if->return->oval->if->return->if->return->return->ivalue->equals->fvalue->equals
DecimalDV.XDecimal#hashCode()::: decimal hash code:::hash->if->return->Objects->hashCode->Objects->hashCode->return
DecimalDV.XDecimal#compareTo(XDecimal)::: decimal compare to:::if->return->if->return->return->intComp
DecimalDV.XDecimal#intComp(XDecimal)::: decimal int comp:::if->return->ret->ivalue->compareTo->if->return->fvalue->compareTo->return
DecimalDV.XDecimal#toString()::: decimal to string:::if->makeCanonical->return
DecimalDV.XDecimal#makeCanonical()::: decimal make canonical:::if->if->else->return->if->return->buffer->new->StringBuilder->if->buffer->append->if->buffer->append->else->buffer->append->if->buffer->append->if->buffer->append->else->buffer->append->buffer->toString
DecimalDV.XDecimal#getBigDecimal()::: decimal get big decimal:::if->return->new->BigDecimal->return->toString->new->BigDecimal
DecimalDV.XDecimal#getBigInteger()::: decimal get big integer:::if->throw->new->NumberFormatException->if->return->if->return->new->BigInteger->return->new->BigInteger
DecimalDV.XDecimal#getLong()::: decimal get long:::if->throw->new->NumberFormatException->if->return->if->return->Long->parseLong->return->Long->parseLong
DecimalDV.XDecimal#getInt()::: decimal get int:::if->throw->new->NumberFormatException->if->return->if->return->Integer->parseInt->return->Integer->parseInt
DecimalDV.XDecimal#getShort()::: decimal get short:::if->throw->new->NumberFormatException->if->return->if->return->Short->parseShort->return->Short->parseShort
DecimalDV.XDecimal#getByte()::: decimal get byte:::if->throw->new->NumberFormatException->if->return->if->return->Byte->parseByte->return->Byte->parseByte
DoubleDV#getAllowedFacets()::: double v get allowed facets:::return
DoubleDV#getActualValue(String, ValidationContext)::: double v get actual value:::try->return->new->XDouble->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DoubleDV#compare(Object, Object)::: double v compare:::return->compareTo
DoubleDV#isIdentical(Object, Object)::: double v is identical:::if->return->isIdentical->return
DoubleDV#isPossibleFP(String):::Returns true if it's possible that the given string represents a valid floating point value (excluding NaN, INF and -INF).:::length->val->length->for->i->return
DoubleDV.XDouble#equals(Object)::: double equals:::if->return->if->return->oval->if->return->if->return->return
DoubleDV.XDouble#hashCode()::: double hash code:::if->return->v->Double->doubleToLongBits->return
DoubleDV.XDouble#isIdentical(XDouble)::: double is identical:::if->return->if->return->Double->doubleToLongBits->Double->doubleToLongBits->if->return->return
DoubleDV.XDouble#compareTo(XDouble)::: double compare to:::oval->if->return->if->return->if->return->if->if->return->return->return
DoubleDV.XDouble#toString()::: double to string:::if->if->else->if->else->if->else->if->else->Double->toString->if->canonical->indexOf->len->canonical->length->chars->new->charArr->canonical->getChars->edp->if->dp->canonical->indexOf->for->i->while->if->shift->else->nzp->while->for->i->j->if->shift->new->String->return
DoubleDV.XDouble#getValue()::: double get value:::return
DurationDV#getActualValue(String, ValidationContext)::: duration v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
DurationDV#parse(String, int):::Parses, validates and computes normalized version of duration object:::len->str->length->date->new->DateTimeData->start->c->str->charAt->if->throw->new->SchemaDateTimeException->else->if->str->charAt->throw->new->SchemaDateTimeException->negate->if->designator->endDate->indexOf->if->else->if->throw->new->SchemaDateTimeException->end->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->if->throw->new->SchemaDateTimeException->if->indexOf->if->parseInt->indexOf->if->parseInt->indexOf->if->parseSecond->if->str->charAt->throw->new->SchemaDateTimeException->if->throw->new->SchemaDateTimeException->return
DurationDV#compareDates(DateTimeData, DateTimeData, boolean):::Compares 2 given durations:::resultA->resultB->compareOrder->if->return->result->new->DateTimeDataArr->new->DateTimeData->new->DateTimeData->tempA->addDuration->tempB->addDuration->compareOrder->if->return->addDuration->addDuration->compareOrder->compareResults->if->return->addDuration->addDuration->compareOrder->compareResults->if->return->addDuration->addDuration->compareOrder->compareResults->return
DurationDV#compareResults(short, short, boolean)::: duration v compare results:::if->return->else->if->return->else->if->if->return->else->return->return
DurationDV#addDuration(DateTimeData, DateTimeData, DateTimeData)::: duration v add duration:::resetDateObj->temp->modulo->carry->fQuotient->dtemp->Math->floor->fQuotient->mod->fQuotient->mod->while->maxDayInMonthFor->if->maxDayInMonthFor->else->if->else->break->modulo->fQuotient->return
DurationDV#parseSecond(String, int, int)::: duration v parse second:::dot->for->i->if->throw->new->NumberFormatException->value->Double->buffer->substring->parseDouble->if->throw->new->NumberFormatException->return
DurationDV#dateToString(DateTimeData)::: duration v date to string:::message->new->StringBuffer->if->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->message->append->append2->message->append->return->message->toString
DurationDV#getDuration(DateTimeData)::: duration v get duration:::sign->if->return->datatypeFactory->BigInteger->valueOf->BigInteger->valueOf->BigInteger->valueOf->BigInteger->valueOf->BigInteger->valueOf->String->valueOf->new->BigDecimal->newDuration
EntityDV#getAllowedFacets()::: entity v get allowed facets:::return
EntityDV#getActualValue(String, ValidationContext)::: entity v get actual value:::if->XMLChar->isValidNCName->throw->new->ObjectArr->new->InvalidDatatypeValueException->return
EntityDV#checkExtraRules(Object, ValidationContext)::: entity v check extra rules:::if->context->isEntityUnparsed->throw->new->ObjectArr->new->InvalidDatatypeValueException
ExtendedSchemaDVFactoryImpl#createBuiltInTypes()::: extended schema factory impl create built in types:::ANYATOMICTYPE->DURATION->YEARMONTHDURATION->DAYTIMEDURATION->createBuiltInTypes->fBuiltInTypes->put->durationDV->fBuiltInTypes->get->fBuiltInTypes->new->XSSimpleTypeDecl->put->fBuiltInTypes->new->XSSimpleTypeDecl->put
ExtendedSchemaDVFactoryImpl#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBuiltInTypes->get
ExtendedSchemaDVFactoryImpl#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBuiltInTypes->makeClone
FloatDV#getAllowedFacets()::: float v get allowed facets:::return
FloatDV#getActualValue(String, ValidationContext)::: float v get actual value:::try->return->new->XFloat->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
FloatDV#compare(Object, Object)::: float v compare:::return->compareTo
FloatDV#isIdentical(Object, Object)::: float v is identical:::if->return->isIdentical->return
FloatDV.XFloat#equals(Object)::: float equals:::if->return->if->return->oval->if->return->if->return->return
FloatDV.XFloat#hashCode()::: float hash code:::return->Float->floatToIntBits
FloatDV.XFloat#isIdentical(XFloat)::: float is identical:::if->return->if->return->Float->floatToIntBits->Float->floatToIntBits->if->return->return
FloatDV.XFloat#compareTo(XFloat)::: float compare to:::oval->if->return->if->return->if->return->if->if->return->return->return
FloatDV.XFloat#toString()::: float to string:::if->if->else->if->else->if->else->if->else->Float->toString->if->canonical->indexOf->len->canonical->length->chars->new->charArr->canonical->getChars->edp->if->dp->canonical->indexOf->for->i->while->if->shift->else->nzp->while->for->i->j->if->shift->new->String->return
FloatDV.XFloat#getValue()::: float get value:::return
FullDVFactory#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fFullTypes->get
FullDVFactory#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fFullTypes->makeClone
FullDVFactory#createBuiltInTypes(SymbolHash)::: full factory create built in types:::BaseDVFactory->createBuiltInTypes->DOUBLE->DURATION->ENTITY->ENTITIES->FLOAT->HEXBINARY->ID->IDREF->IDREFS->NAME->NCNAME->NMTOKEN->NMTOKENS->LANGUAGE->NORMALIZEDSTRING->NOTATION->QNAME->STRING->TOKEN->facets->new->XSFacets->anySimpleType->stringDV->types->get->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->types->new->XSSimpleTypeDecl->put->normalizedDV->new->XSSimpleTypeDecl->normalizedDV->applyFacets1->types->put->tokenDV->new->XSSimpleTypeDecl->tokenDV->applyFacets1->types->put->languageDV->new->XSSimpleTypeDecl->languageDV->applyFacets1->types->put->nameDV->new->XSSimpleTypeDecl->nameDV->applyFacets1->types->put->ncnameDV->new->XSSimpleTypeDecl->ncnameDV->applyFacets1->types->put->types->new->XSSimpleTypeDecl->put->idrefDV->new->XSSimpleTypeDecl->types->put->tempDV->new->XSSimpleTypeDecl->idrefsDV->new->XSSimpleTypeDecl->idrefsDV->applyFacets1->types->put->entityDV->new->XSSimpleTypeDecl->types->put->new->XSSimpleTypeDecl->entitiesDV->new->XSSimpleTypeDecl->entitiesDV->applyFacets1->types->put->nmtokenDV->new->XSSimpleTypeDecl->nmtokenDV->applyFacets1->types->put->new->XSSimpleTypeDecl->nmtokensDV->new->XSSimpleTypeDecl->nmtokensDV->applyFacets1->types->put
HexBinaryDV#getAllowedFacets()::: hex binary v get allowed facets:::return
HexBinaryDV#getActualValue(String, ValidationContext)::: hex binary v get actual value:::decoded->HexBin->decode->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->return->new->XHex
HexBinaryDV#getDataLength(Object)::: hex binary v get data length:::return->getLength
HexBinaryDV.XHex#toString()::: hex to string:::if->HexBin->encode->return
HexBinaryDV.XHex#equals(Object)::: hex equals:::if->return->odata->len->if->return->for->i->return
HexBinaryDV.XHex#hashCode()::: hex hash code:::hash->for->i->return
IDDV#getAllowedFacets()::: v get allowed facets:::return
IDDV#getActualValue(String, ValidationContext)::: v get actual value:::if->XMLChar->isValidNCName->throw->new->ObjectArr->new->InvalidDatatypeValueException->return
IDDV#checkExtraRules(Object, ValidationContext)::: v check extra rules:::content->if->context->isIdDeclared->throw->new->ObjectArr->new->InvalidDatatypeValueException->context->addId
IDREFDV#getAllowedFacets()::: v get allowed facets:::return
IDREFDV#getActualValue(String, ValidationContext)::: v get actual value:::if->XMLChar->isValidNCName->throw->new->ObjectArr->new->InvalidDatatypeValueException->return
IDREFDV#checkExtraRules(Object, ValidationContext)::: v check extra rules:::context->addIdRef
IntegerDV#getActualValue(String, ValidationContext)::: integer v get actual value:::try->return->new->XDecimal->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
ListDV#getAllowedFacets()::: list v get allowed facets:::return
ListDV#getActualValue(String, ValidationContext)::: list v get actual value:::return
ListDV#getDataLength(Object)::: list v get data length:::return->getLength
ListDV.ListData#toString()::: list data to string:::if->len->buf->new->StringBuffer->if->buf->toString->append->for->i->buf->toString->return
ListDV.ListData#getLength()::: list data get length:::return
ListDV.ListData#equals(Object)::: list data equals:::if->return->odata->count->if->return->for->i->return
ListDV.ListData#hashCode()::: list data hash code:::hash->for->i->return
ListDV.ListData#contains(Object)::: list data contains:::for->i->return
ListDV.ListData#item(int)::: list data item:::if->return->return
ListDV.ListData#get(int)::: list data get:::if->return->throw->new->IndexOutOfBoundsException
ListDV.ListData#size()::: list data size:::return->getLength
MonthDayDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
MonthDayDV#parse(String):::Parses, validates and computes normalized version of gMonthDay object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->throw->new->SchemaDateTimeException->parseInt->start->if->str->charAt->throw->new->SchemaDateTimeException->parseInt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
MonthDayDV#dateToString(DateTimeData):::Converts gMonthDay object representation to String:::message->new->StringBuffer->message->append->message->append->append->message->append->append->append->return->message->toString
MonthDayDV#getXMLGregorianCalendar(DateTimeData)::: month day v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
MonthDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
MonthDV#parse(String):::Parses, validates and computes normalized version of gMonth object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->throw->new->SchemaDateTimeException->stop->parseInt->if->str->length->str->charAt->str->charAt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
MonthDV#dateToString(DateTimeData):::Converts month object representation to String:::message->new->StringBuffer->message->append->message->append->append->append->return->message->toString
MonthDV#getXMLGregorianCalendar(DateTimeData)::: month v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
PrecisionDecimalDV.XPrecisionDecimal#initD(String)::: precision decimal init d:::len->content->length->if->throw->new->NumberFormatException->intStart->intEnd->fracStart->fracEnd->if->content->charAt->else->if->content->charAt->actualIntStart->while->content->charAt->for->TypeValidator->content->charAt->isDigit->if->if->content->charAt->content->charAt->content->charAt->throw->new->NumberFormatException->if->content->charAt->for->TypeValidator->content->charAt->isDigit->else->Integer->content->substring->parseInt->if->throw->new->NumberFormatException->for->fracPos->if->content->substring->if->content->substring->if->Integer->content->substring->parseInt
PrecisionDecimalDV.XPrecisionDecimal#canonicalToStringForHashCode(String, String, int, int)::: precision decimal canonical to string for hash code:::if->equals->return->if->equals->return->builder->new->StringBuilder->ilen->ivalue->length->flen0->fvalue->length->lastNonZero->for->flen->iStart->exponent->for->fStart->if->ivalue->length->builder->append->builder->ivalue->charAt->append->else->if->for->if->builder->append->builder->fvalue->charAt->append->else->return->else->return->if->builder->append->while->builder->ivalue->charAt->append->while->builder->fvalue->charAt->append->if->builder->append->append->return->builder->toString
PrecisionDecimalDV.XPrecisionDecimal#equals(Object)::: precision decimal equals:::if->return->if->return->oval->return->this->compareTo
PrecisionDecimalDV.XPrecisionDecimal#hashCode()::: precision decimal hash code:::return->canonicalToStringForHashCode->hashCode
PrecisionDecimalDV.XPrecisionDecimal#compareFractionalPart(XPrecisionDecimal)::: precision decimal compare fractional part:::if->fvalue->equals->return->temp1->new->StringBuffer->temp2->new->StringBuffer->truncateTrailingZeros->return->temp1->toString->temp2->toString->compareTo
PrecisionDecimalDV.XPrecisionDecimal#truncateTrailingZeros(StringBuffer, StringBuffer)::: precision decimal truncate trailing zeros:::for->i->fValue->length->for->i->otherFValue->length
PrecisionDecimalDV.XPrecisionDecimal#compareTo(XPrecisionDecimal)::: precision decimal compare to:::if->return->if->ivalue->equals->equals->if->ivalue->equals->return->else->if->ivalue->equals->return->return->if->ivalue->equals->equals->if->ivalue->equals->return->else->if->ivalue->equals->return->return->if->return->return->compare
PrecisionDecimalDV.XPrecisionDecimal#compare(XPrecisionDecimal)::: precision decimal compare:::if->if->return->intComp->else->if->return->if->expDiff->buffer->new->StringBuffer->fbuffer->new->StringBuffer->for->i->return->buffer->toString->fbuffer->toString->compareDecimal->else->expDiff->buffer->new->StringBuffer->fbuffer->new->StringBuffer->for->i->return->buffer->toString->fbuffer->toString->compareDecimal->else->return->intComp
PrecisionDecimalDV.XPrecisionDecimal#intComp(XPrecisionDecimal)::: precision decimal int comp:::if->return->return->compareDecimal
PrecisionDecimalDV.XPrecisionDecimal#compareDecimal(String, String, String, String)::: precision decimal compare decimal:::ret->iValue->compareTo->if->return->if->fValue->equals->return->temp1->new->StringBuffer->temp2->new->StringBuffer->truncateTrailingZeros->temp1->toString->temp2->toString->compareTo->return
PrecisionDecimalDV.XPrecisionDecimal#toString()::: precision decimal to string:::if->makeCanonical->return
PrecisionDecimalDV.XPrecisionDecimal#makeCanonical()::: precision decimal make canonical:::
PrecisionDecimalDV.XPrecisionDecimal#isIdentical(XPrecisionDecimal)::: precision decimal is identical:::if->ivalue->equals->ivalue->equals->ivalue->equals->ivalue->equals->return->if->ivalue->equals->fvalue->equals->return->return
PrecisionDecimalDV#getAllowedFacets()::: precision decimal v get allowed facets:::return
PrecisionDecimalDV#getActualValue(String, ValidationContext)::: precision decimal v get actual value:::try->return->new->XPrecisionDecimal->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
PrecisionDecimalDV#compare(Object, Object)::: precision decimal v compare:::return->compareTo
PrecisionDecimalDV#getFractionDigits(Object)::: precision decimal v get fraction digits:::return
PrecisionDecimalDV#getTotalDigits(Object)::: precision decimal v get total digits:::return
PrecisionDecimalDV#isIdentical(Object, Object)::: precision decimal v is identical:::if->return->return->isIdentical
QNameDV#getAllowedFacets()::: name v get allowed facets:::return
QNameDV#getActualValue(String, ValidationContext)::: name v get actual value:::prefix->localpart->colonptr->content->indexOf->if->context->content->substring->getSymbol->content->substring->else->if->prefix->length->XMLChar->isValidNCName->throw->new->ObjectArr->new->InvalidDatatypeValueException->if->XMLChar->isValidNCName->throw->new->ObjectArr->new->InvalidDatatypeValueException->uri->context->getURI->if->prefix->length->throw->new->ObjectArr->new->InvalidDatatypeValueException->return->context->getSymbol->context->getSymbol->new->XQName
QNameDV#getDataLength(Object)::: name v get data length:::return->length
QNameDV.XQName#equals(Object):::Returns true if the two objects are equal.:::if->qname->return->return
QNameDV.XQName#toString()::: name to string:::return
QNameDV.XQName#getJAXPQName()::: name get name:::return->new->javax.xml.namespace.QName
QNameDV.XQName#getXNIQName()::: name get name:::return
SchemaDVFactoryImpl#createBuiltInTypes()::: schema factory impl create built in types:::createBuiltInTypes
SchemaDVFactoryImpl#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBuiltInTypes->get
SchemaDVFactoryImpl#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBuiltInTypes->makeClone
StringDV#getAllowedFacets()::: string v get allowed facets:::return
StringDV#getActualValue(String, ValidationContext)::: string v get actual value:::return
TimeDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
TimeDV#parse(String):::Parses, validates and computes normalized version of time object:::date->new->DateTimeData->len->str->length->getTime->validateDateTime->saveUnnormalized->if->normalize->return
TimeDV#dateToString(DateTimeData):::Converts time object representation to String:::message->new->StringBuffer->append->message->append->append->message->append->append->append->return->message->toString
TimeDV#getXMLGregorianCalendar(DateTimeData)::: time v get gregorian calendar:::return->datatypeFactory->getFractionalSecondsAsBigDecimal->date->hasTimeZone->newXMLGregorianCalendar
TypeValidator#getAllowedFacets()::: type validator get allowed facets:::
TypeValidator#getActualValue(String, ValidationContext)::: type validator get actual value:::
TypeValidator#checkExtraRules(Object, ValidationContext)::: type validator check extra rules:::
TypeValidator#isIdentical(Object, Object)::: type validator is identical:::return->value1->equals
TypeValidator#compare(Object, Object)::: type validator compare:::return
TypeValidator#getDataLength(Object)::: type validator get data length:::if->str->if->return->str->length->return->getCodePointLength->return
TypeValidator#getTotalDigits(Object)::: type validator get total digits:::return
TypeValidator#getFractionDigits(Object)::: type validator get fraction digits:::return
TypeValidator#getCodePointLength(String)::: type validator get code point length:::len->value->length->surrogatePairCount->for->i->return
TypeValidator#isDigit(char)::: type validator is digit:::return
TypeValidator#getDigit(char)::: type validator get digit:::return->isDigit
UnionDV#getAllowedFacets()::: union v get allowed facets:::return
UnionDV#getActualValue(String, ValidationContext)::: union v get actual value:::return
XSSimpleTypeDecl#getGDVs()::: simple type decl get vs:::return->gDVs->clone
XSSimpleTypeDecl#setDVs(TypeValidator[])::: simple type decl set vs:::
XSSimpleTypeDecl#setRestrictionValues(XSSimpleTypeDecl, String, String, short, XSObjectList)::: simple type decl set restriction values:::if->return->switch->break->break->break->calcFundamentalFacets->return
XSSimpleTypeDecl#setListValues(String, String, short, XSSimpleTypeDecl, XSObjectList)::: simple type decl set list values:::if->return->calcFundamentalFacets->return
XSSimpleTypeDecl#setUnionValues(String, String, short, XSSimpleTypeDecl[], XSObjectList)::: simple type decl set union values:::if->return->calcFundamentalFacets->return
XSSimpleTypeDecl#getType()::: simple type decl get type:::return
XSSimpleTypeDecl#getTypeCategory()::: simple type decl get type category:::return
XSSimpleTypeDecl#getName()::: simple type decl get name:::return->getAnonymous
XSSimpleTypeDecl#getTypeName()::: simple type decl get type name:::return
XSSimpleTypeDecl#getNamespace()::: simple type decl get namespace:::return
XSSimpleTypeDecl#getFinal()::: simple type decl get final:::return
XSSimpleTypeDecl#isFinal(short)::: simple type decl is final:::return
XSSimpleTypeDecl#getBaseType()::: simple type decl get base type:::return
XSSimpleTypeDecl#getAnonymous()::: simple type decl get anonymous:::return
XSSimpleTypeDecl#getVariety()::: simple type decl get variety:::return
XSSimpleTypeDecl#isIDType()::: simple type decl is type:::switch->return->return->fItemType->isIDType->for->i->return
XSSimpleTypeDecl#getWhitespace()::: simple type decl get whitespace:::if->throw->new->ObjectArr->new->DatatypeException->return
XSSimpleTypeDecl#getPrimitiveKind()::: simple type decl get primitive kind:::if->if->return->else->if->return->else->if->return->else->return->else->return
XSSimpleTypeDecl#getBuiltInKind():::Returns the closest built-in type category this type represents or derived from:::return
XSSimpleTypeDecl#getPrimitiveType():::If variety is atomic the primitive type definition (a built-in primitive datatype definition or the simple ur-type definition) is available, otherwise null.:::if->pri->while->return->else->return
XSSimpleTypeDecl#getItemType():::If variety is list the item type definition (an atomic or union simple type definition) is available, otherwise null.:::if->return->else->return
XSSimpleTypeDecl#getMemberTypes():::If variety is union the list of member type definitions (a non-empty sequence of simple type definitions) is available, otherwise an empty XSObjectList.:::if->return->new->XSObjectListImpl->else->return
XSSimpleTypeDecl#applyFacets(XSFacets, short, short, ValidationContext):::If <restriction> is chosen:::if->applyFacets
XSSimpleTypeDecl#applyFacets1(XSFacets, short, short):::built-in derived types by restriction:::try->applyFacets->catch->throw->new->RuntimeException->finally
XSSimpleTypeDecl#applyFacets1(XSFacets, short, short, short):::built-in derived types by restriction:::try->applyFacets->catch->throw->new->RuntimeException->finally
XSSimpleTypeDecl#applyFacets(XSFacets, short, short, short, ValidationContext):::If <restriction> is chosen, or built-in derived types by restriction:::if->return->tempInfo->new->ValidatedInfo->result->allowedFacet->getAllowedFacets->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->regex->try->context->getLocale->new->RegularExpression->catch->new->ObjectArr->e->getLocalizedMessage->reportError->finally->if->new->ArrayList<>->fPattern->add->new->ArrayList<>->fPatternStr->add->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->enumVals->size->enumVals->size->new->ValidatedInfoArr->enumNSDecls->ctx->new->ValidationContextImpl->for->i->if->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->if->compare->new->ObjectArr->reportError->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->needCheckBase->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->compare->if->new->ObjectArr->reportError->if->if->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->else->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->compare->if->new->ObjectArr->reportError->if->if->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->else->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->if->compare->new->ObjectArr->reportError->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->compare->if->new->ObjectArr->reportError->if->compare->if->new->ObjectArr->reportError->if->if->compare->new->ObjectArr->reportError->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->else->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->else->if->new->ObjectArr->Integer->toString->reportError->if->if->new->ObjectArr->whiteSpaceValue->whiteSpaceValue->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->if->if->if->if->else->for->i->size->if->if->for->i->getLength->else->if->if->if->if->if->if->if->if->if->calcFundamentalFacets
XSSimpleTypeDecl#validate(String, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->ob->getActualValue->validate->return
XSSimpleTypeDecl#getActualEnumValue(String, ValidationContext, ValidatedInfo)::: simple type decl get actual enum value:::return->fBase->validateWithInfo
XSSimpleTypeDecl#validateWithInfo(String, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->getActualValue->validate->return
XSSimpleTypeDecl#validate(Object, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->ob->getActualValue->validate->return
XSSimpleTypeDecl#validate(ValidationContext, ValidatedInfo):::validate an actual value against this DV:::if->if->context->needFacetChecking->checkFacets->if->context->needExtraChecking->checkExtraRules
XSSimpleTypeDecl#checkFacets(ValidatedInfo)::: simple type decl check facets:::ob->content->type->itemType->if->length->getDataLength->if->if->throw->new->ObjectArr->Integer->toString->Integer->toString->new->InvalidDatatypeValueException->if->if->throw->new->ObjectArr->Integer->toString->Integer->toString->new->InvalidDatatypeValueException->if->if->throw->new->ObjectArr->Integer->toString->Integer->toString->new->InvalidDatatypeValueException->if->present->enumSize->primitiveType1->convertToPrimitiveKind->for->i->if->sb->new->StringBuffer->appendEnumString->throw->new->ObjectArr->sb->toString->new->InvalidDatatypeValueException->if->scale->getFractionDigits->if->throw->new->ObjectArr->Integer->toString->Integer->toString->new->InvalidDatatypeValueException->if->totalDigits->getTotalDigits->if->throw->new->ObjectArr->Integer->toString->Integer->toString->new->InvalidDatatypeValueException->compare->if->compare->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->if->compare->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->if->compare->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->if->compare->if->throw->new->ObjectArr->new->InvalidDatatypeValueException
XSSimpleTypeDecl#checkExtraRules(ValidationContext, ValidatedInfo)::: simple type decl check extra rules:::ob->if->checkExtraRules->else->if->values->memberType->len->values->getLength->try->if->memberTypes->for->i->else->for->i->catch->finally->else->checkExtraRules
XSSimpleTypeDecl#getActualValue(Object, ValidationContext, ValidatedInfo, boolean)::: simple type decl get actual value:::nvalue->if->normalize->else->content->toString->if->regex->for->idx->fPattern->size->if->if->seenErr->if->XMLChar->isValidNmtoken->else->if->XMLChar->isValidName->else->if->XMLChar->isValidNCName->if->throw->new->ObjectArr->new->InvalidDatatypeValueException->avalue->getActualValue->return->else->if->parsedList->new->StringTokenizer->countOfTokens->parsedList->countTokens->avalue->new->ObjectArr->isUnion->fItemType->getVariety->itemTypes->new->shortArr->if->memberTypes->new->XSSimpleTypeDeclArr->for->i->v->new->ListDV.ListData->new->ShortListImpl->return->else->_content->content->toString->for->i->typesBuffer->new->StringBuffer->decl->for->i->throw->new->ObjectArr->typesBuffer->toString->new->InvalidDatatypeValueException
XSSimpleTypeDecl#isEqual(Object, Object)::: simple type decl is equal:::if->return->return->value1->equals
XSSimpleTypeDecl#isIdentical(Object, Object)::: simple type decl is identical:::if->return->return->isIdentical
XSSimpleTypeDecl#normalize(String, short)::: simple type decl normalize:::len->content->length->if->return->sb->new->StringBuffer->if->ch->for->i->else->ch->i->isLeading->for->return->sb->toString
XSSimpleTypeDecl#normalize(Object, short)::: simple type decl normalize:::if->return->if->norm_type->if->return->content->toString->else->if->return->XMLChar->content->toString->trim->if->strContent->content->toString->return->normalize->sb->len->sb->length->if->return->if->return->sb->toString->if->ch->for->i->else->ch->i->j->isLeading->for->sb->setLength->return->sb->toString
XSSimpleTypeDecl#reportError(String, Object[])::: simple type decl report error:::throw->new->InvalidDatatypeFacetException
XSSimpleTypeDecl#whiteSpaceValue(short)::: simple type decl white space value:::return
XSSimpleTypeDecl#getOrdered()::: Fundamental Facet: ordered.:::return
XSSimpleTypeDecl#getBounded():::Fundamental Facet: bounded.:::return
XSSimpleTypeDecl#getFinite():::Fundamental Facet: cardinality.:::return
XSSimpleTypeDecl#getNumeric():::Fundamental Facet: numeric.:::return
XSSimpleTypeDecl#isDefinedFacet(short):::Convenience method:::if->return->if->return->if->return->if->return->return
XSSimpleTypeDecl#getDefinedFacets():::[facets]: all facets defined on this type:::if->return->if->return->if->return->return
XSSimpleTypeDecl#isFixedFacet(short):::Convenience method:::if->return->if->return->return
XSSimpleTypeDecl#getFixedFacets():::[facets]: all defined facets for this type which are fixed.:::if->return->return
XSSimpleTypeDecl#getLexicalFacetValue(short):::Convenience method:::switch->return->Integer->toString->return->Integer->toString->return->Integer->toString->if->return->return->return->fMaxInclusive->toString->return->fMaxExclusive->toString->return->fMinExclusive->toString->return->fMinInclusive->toString->return->Integer->toString->if->return->return->Integer->toString->return
XSSimpleTypeDecl#getLexicalEnumeration():::A list of enumeration values if it exists, otherwise an empty StringList.:::if->if->return->size->strs->new->StringArr->for->i->new->StringListImpl->return
XSSimpleTypeDecl#getActualEnumeration():::A list of actual enumeration values if it exists, otherwise an empty ObjectList.:::if->new->AbstractObjectList->return
XSSimpleTypeDecl#getEnumerationItemTypeList():::A list of enumeration type values (as a list of ShortList objects) if it exists, otherwise returns null:::if->if->return->new->AbstractObjectList->return
XSSimpleTypeDecl#getEnumerationTypeList()::: simple type decl get enumeration type list:::if->if->return->list->new->shortArr->for->i->new->ShortListImpl->return
XSSimpleTypeDecl#getLexicalPattern():::A list of pattern values if it exists, otherwise an empty StringList.:::if->return->if->size->fPatternStr->size->strs->if->new->StringArr->else->if->new->StringArr->else->if->new->StringArr->else->if->new->StringArr->else->new->StringArr->for->i->new->StringListImpl->return
XSSimpleTypeDecl#getAnnotations():::[annotations]: a set of annotations for this simple type component if it exists, otherwise an empty XSObjectList.:::return
XSSimpleTypeDecl#calcFundamentalFacets()::: simple type decl calc fundamental facets:::setOrdered->setNumeric->setBounded->setCardinality
XSSimpleTypeDecl#setOrdered()::: simple type decl set ordered:::if->else->if->else->if->length->if->return->ancestorId->getPrimitiveDV->commonAnc->allFalse->for->i->if->else->if->else
XSSimpleTypeDecl#setNumeric()::: simple type decl set numeric:::if->else->if->else->if->memberTypes->for->i
XSSimpleTypeDecl#setBounded()::: simple type decl set bounded:::if->if->else->else->if->if->else->else->if->memberTypes->ancestorId->if->getPrimitiveDV->for->i
XSSimpleTypeDecl#specialCardinalityCheck()::: simple type decl special cardinality check:::if->return->return
XSSimpleTypeDecl#setCardinality()::: simple type decl set cardinality:::if->if->else->if->else->if->if->specialCardinalityCheck->else->else->else->if->if->else->else->if->memberTypes->for->i
XSSimpleTypeDecl#getPrimitiveDV(short)::: simple type decl get primitive v:::if->return->else->if->return->else->if->return->else->return
XSSimpleTypeDecl#derivedFromType(XSTypeDefinition, short)::: simple type decl derived from type:::if->return->while->if->ancestor->getBaseType->return->type->while->type->getBaseType->return
XSSimpleTypeDecl#derivedFrom(String, String, short)::: simple type decl derived from:::if->return->if->URI_SCHEMAFORSCHEMA->equals->ANY_TYPE->equals->return->type->while->ancestorName->type->getName->equals->type->getNamespace->ancestorNS->type->getNamespace->equals->type->getBaseType->return
XSSimpleTypeDecl#isDOMDerivedFrom(String, String, int):::Checks if a type is derived from another by restriction, given the name and namespace:::if->return->if->equals->equals->return->if->if->isDerivedByRestriction->return->if->if->isDerivedByList->return->if->if->isDerivedByUnion->return->if->return->if->return->isDerivedByAny->return
XSSimpleTypeDecl#isDerivedByAny(String, String, XSTypeDefinition):::Checks if a type is derived from another by any combination of restriction, list ir union:::derivedFrom->oldType->while->if->ancestorName->type->getName->equals->type->getNamespace->ancestorNS->type->getNamespace->equals->break->if->isDerivedByRestriction->return->else->if->isDerivedByList->return->else->if->isDerivedByUnion->return->if->getVariety->getVariety->type->getBaseType->else->if->getVariety->for->i->getMemberTypes->getLength->else->if->getVariety->getItemType->return
XSSimpleTypeDecl#isDerivedByRestriction(String, String, XSTypeDefinition):::DOM Level 3 Checks if a type is derived from another by restriction:::oldType->while->if->ancestorName->type->getName->equals->ancestorNS->type->getNamespace->equals->type->getNamespace->return->type->getBaseType->return
XSSimpleTypeDecl#isDerivedByList(String, String, XSTypeDefinition):::Checks if a type is derived from another by list:::if->getVariety->itemType->getItemType->if->if->isDerivedByRestriction->return->return
XSSimpleTypeDecl#isDerivedByUnion(String, String, XSTypeDefinition):::Checks if a type is derived from another by union:::if->getVariety->memberTypes->getMemberTypes->for->i->memberTypes->getLength->return
XSSimpleTypeDecl.ValidationContextImpl#setNSContext(NamespaceContext)::: validation context impl set context:::
XSSimpleTypeDecl.ValidationContextImpl#needFacetChecking()::: validation context impl need facet checking:::return->fExternal->needFacetChecking
XSSimpleTypeDecl.ValidationContextImpl#needExtraChecking()::: validation context impl need extra checking:::return->fExternal->needExtraChecking
XSSimpleTypeDecl.ValidationContextImpl#needToNormalize()::: validation context impl need to normalize:::return->fExternal->needToNormalize
XSSimpleTypeDecl.ValidationContextImpl#useNamespaces()::: validation context impl use namespaces:::return
XSSimpleTypeDecl.ValidationContextImpl#isEntityDeclared(String)::: validation context impl is entity declared:::return->fExternal->isEntityDeclared
XSSimpleTypeDecl.ValidationContextImpl#isEntityUnparsed(String)::: validation context impl is entity unparsed:::return->fExternal->isEntityUnparsed
XSSimpleTypeDecl.ValidationContextImpl#isIdDeclared(String)::: validation context impl is id declared:::return->fExternal->isIdDeclared
XSSimpleTypeDecl.ValidationContextImpl#addId(String)::: validation context impl add id:::fExternal->addId
XSSimpleTypeDecl.ValidationContextImpl#addIdRef(String)::: validation context impl add id ref:::fExternal->addIdRef
XSSimpleTypeDecl.ValidationContextImpl#getSymbol(String)::: validation context impl get symbol:::return->fExternal->getSymbol
XSSimpleTypeDecl.ValidationContextImpl#getURI(String)::: validation context impl get i:::if->return->fExternal->getURI->else->return->fNSContext->getURI
XSSimpleTypeDecl.ValidationContextImpl#getLocale()::: validation context impl get locale:::return->fExternal->getLocale
XSSimpleTypeDecl#reset()::: simple type decl reset:::if->return
XSSimpleTypeDecl#getNamespaceItem()::: simple type decl get namespace item:::return
XSSimpleTypeDecl#setNamespaceItem(XSNamespaceItem)::: simple type decl set namespace item:::
XSSimpleTypeDecl#toString()::: simple type decl to string:::return
XSSimpleTypeDecl#getFacets()::: A list of constraining facets if it exists, otherwise an empty XSObjectList:::if->facets->new->XSFacetImplArr->count->if->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->new->XSFacetImpl->else->if->Integer->toString->new->XSFacetImpl->if->fMaxInclusive->toString->new->XSFacetImpl->if->fMaxExclusive->toString->new->XSFacetImpl->if->fMinExclusive->toString->new->XSFacetImpl->if->fMinInclusive->toString->new->XSFacetImpl->new->XSObjectListImpl->return
XSSimpleTypeDecl#getFacet(int)::: simple type decl get facet:::if->list->getMultiValueFacets->for->i->list->getLength->else->list->getFacets->for->i->list->getLength->return
XSSimpleTypeDecl#getMultiValueFacets()::: A list of enumeration and pattern constraining facets if it exists, otherwise an empty XSObjectList.:::if->facets->new->XSMVFacetImplArr->count->if->this->getLexicalPattern->new->XSMVFacetImpl->if->this->getLexicalEnumeration->new->ObjectListImpl->new->XSMVFacetImpl->new->XSObjectListImpl->return
XSSimpleTypeDecl#getMinInclusiveValue()::: simple type decl get min inclusive value:::return
XSSimpleTypeDecl#getMinExclusiveValue()::: simple type decl get min exclusive value:::return
XSSimpleTypeDecl#getMaxInclusiveValue()::: simple type decl get max inclusive value:::return
XSSimpleTypeDecl#getMaxExclusiveValue()::: simple type decl get max exclusive value:::return
XSSimpleTypeDecl#setAnonymous(boolean)::: simple type decl set anonymous:::
XSSimpleTypeDecl.XSFacetImpl#getAnnotation():::Optional:::return->annotations->item
XSSimpleTypeDecl.XSFacetImpl#getAnnotations():::Optional:::return
XSSimpleTypeDecl.XSFacetImpl#getFacetKind()::: facet impl get facet kind:::return
XSSimpleTypeDecl.XSFacetImpl#getLexicalFacetValue()::: facet impl get lexical facet value:::return
XSSimpleTypeDecl.XSFacetImpl#getActualFacetValue()::: facet impl get actual facet value:::if->if->else->BigInteger->valueOf->return
XSSimpleTypeDecl.XSFacetImpl#getIntFacetValue()::: facet impl get int facet value:::return
XSSimpleTypeDecl.XSFacetImpl#getFixed()::: facet impl get fixed:::return
XSSimpleTypeDecl.XSFacetImpl#getName()::: facet impl get name:::return
XSSimpleTypeDecl.XSFacetImpl#getNamespace()::: facet impl get namespace:::return
XSSimpleTypeDecl.XSFacetImpl#getNamespaceItem()::: facet impl get namespace item:::return
XSSimpleTypeDecl.XSFacetImpl#getType()::: facet impl get type:::return
XSSimpleTypeDecl.XSMVFacetImpl#getFacetKind()::: facet impl get facet kind:::return
XSSimpleTypeDecl.XSMVFacetImpl#getAnnotations()::: facet impl get annotations:::return
XSSimpleTypeDecl.XSMVFacetImpl#getLexicalFacetValues()::: facet impl get lexical facet values:::return
XSSimpleTypeDecl.XSMVFacetImpl#getEnumerationValues()::: facet impl get enumeration values:::return
XSSimpleTypeDecl.XSMVFacetImpl#getName()::: facet impl get name:::return
XSSimpleTypeDecl.XSMVFacetImpl#getNamespace()::: facet impl get namespace:::return
XSSimpleTypeDecl.XSMVFacetImpl#getNamespaceItem()::: facet impl get namespace item:::return
XSSimpleTypeDecl.XSMVFacetImpl#getType()::: facet impl get type:::return
XSSimpleTypeDecl.AbstractObjectList#get(int)::: abstract object list get:::if->getLength->return->item->throw->new->IndexOutOfBoundsException
XSSimpleTypeDecl.AbstractObjectList#size()::: abstract object list size:::return->getLength
XSSimpleTypeDecl#getTypeNamespace()::: simple type decl get type namespace:::return->getNamespace
XSSimpleTypeDecl#isDerivedFrom(String, String, int)::: simple type decl is derived from:::return->isDOMDerivedFrom
XSSimpleTypeDecl#convertToPrimitiveKind(short)::: simple type decl convert to primitive kind:::if->return->if->return->if->return->return
XSSimpleTypeDecl#appendEnumString(StringBuffer)::: simple type decl append enum string:::sb->append->for->i->sb->append
XSSimpleTypeDelegate#getWrappedXSSimpleType()::: simple type delegate get wrapped simple type:::return
XSSimpleTypeDelegate#getAnnotations()::: simple type delegate get annotations:::return->type->getAnnotations
XSSimpleTypeDelegate#getBounded()::: simple type delegate get bounded:::return->type->getBounded
XSSimpleTypeDelegate#getBuiltInKind()::: simple type delegate get built in kind:::return->type->getBuiltInKind
XSSimpleTypeDelegate#getDefinedFacets()::: simple type delegate get defined facets:::return->type->getDefinedFacets
XSSimpleTypeDelegate#getFacets()::: simple type delegate get facets:::return->type->getFacets
XSSimpleTypeDelegate#getFacet(int)::: simple type delegate get facet:::return->type->getFacet
XSSimpleTypeDelegate#getFinite()::: simple type delegate get finite:::return->type->getFinite
XSSimpleTypeDelegate#getFixedFacets()::: simple type delegate get fixed facets:::return->type->getFixedFacets
XSSimpleTypeDelegate#getItemType()::: simple type delegate get item type:::return->type->getItemType
XSSimpleTypeDelegate#getLexicalEnumeration()::: simple type delegate get lexical enumeration:::return->type->getLexicalEnumeration
XSSimpleTypeDelegate#getLexicalFacetValue(short)::: simple type delegate get lexical facet value:::return->type->getLexicalFacetValue
XSSimpleTypeDelegate#getLexicalPattern()::: simple type delegate get lexical pattern:::return->type->getLexicalPattern
XSSimpleTypeDelegate#getMemberTypes()::: simple type delegate get member types:::return->type->getMemberTypes
XSSimpleTypeDelegate#getMultiValueFacets()::: simple type delegate get multi value facets:::return->type->getMultiValueFacets
XSSimpleTypeDelegate#getNumeric()::: simple type delegate get numeric:::return->type->getNumeric
XSSimpleTypeDelegate#getOrdered()::: simple type delegate get ordered:::return->type->getOrdered
XSSimpleTypeDelegate#getPrimitiveType()::: simple type delegate get primitive type:::return->type->getPrimitiveType
XSSimpleTypeDelegate#getVariety()::: simple type delegate get variety:::return->type->getVariety
XSSimpleTypeDelegate#isDefinedFacet(short)::: simple type delegate is defined facet:::return->type->isDefinedFacet
XSSimpleTypeDelegate#isFixedFacet(short)::: simple type delegate is fixed facet:::return->type->isFixedFacet
XSSimpleTypeDelegate#derivedFrom(String, String, short)::: simple type delegate derived from:::return->type->derivedFrom
XSSimpleTypeDelegate#derivedFromType(XSTypeDefinition, short)::: simple type delegate derived from type:::return->type->derivedFromType
XSSimpleTypeDelegate#getAnonymous()::: simple type delegate get anonymous:::return->type->getAnonymous
XSSimpleTypeDelegate#getBaseType()::: simple type delegate get base type:::return->type->getBaseType
XSSimpleTypeDelegate#getFinal()::: simple type delegate get final:::return->type->getFinal
XSSimpleTypeDelegate#getTypeCategory()::: simple type delegate get type category:::return->type->getTypeCategory
XSSimpleTypeDelegate#isFinal(short)::: simple type delegate is final:::return->type->isFinal
XSSimpleTypeDelegate#getName()::: simple type delegate get name:::return->type->getName
XSSimpleTypeDelegate#getNamespace()::: simple type delegate get namespace:::return->type->getNamespace
XSSimpleTypeDelegate#getNamespaceItem()::: simple type delegate get namespace item:::return->type->getNamespaceItem
XSSimpleTypeDelegate#getType()::: simple type delegate get type:::return->type->getType
XSSimpleTypeDelegate#applyFacets(XSFacets, short, short, ValidationContext)::: simple type delegate apply facets:::type->applyFacets
XSSimpleTypeDelegate#getPrimitiveKind()::: simple type delegate get primitive kind:::return->type->getPrimitiveKind
XSSimpleTypeDelegate#getWhitespace()::: simple type delegate get whitespace:::return->type->getWhitespace
XSSimpleTypeDelegate#isEqual(Object, Object)::: simple type delegate is equal:::return->type->isEqual
XSSimpleTypeDelegate#isIDType()::: simple type delegate is type:::return->type->isIDType
XSSimpleTypeDelegate#validate(ValidationContext, ValidatedInfo)::: simple type delegate validate:::type->validate
XSSimpleTypeDelegate#validate(String, ValidationContext, ValidatedInfo)::: simple type delegate validate:::return->type->validate
XSSimpleTypeDelegate#validate(Object, ValidationContext, ValidatedInfo)::: simple type delegate validate:::return->type->validate
XSSimpleTypeDelegate#toString()::: simple type delegate to string:::return->type->toString
YearDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
YearDV#parse(String):::Parses, validates and computes normalized version of gYear object:::date->new->DateTimeData->len->str->length->start->if->str->charAt->sign->findUTCSign->length->if->throw->new->RuntimeException->else->if->str->charAt->throw->new->RuntimeException->if->parseIntYear->else->parseIntYear->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
YearDV#dateToString(DateTimeData):::Converts year object representation to String:::message->new->StringBuffer->append->append->return->message->toString
YearDV#getXMLGregorianCalendar(DateTimeData)::: year v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
YearMonthDurationDV#getActualValue(String, ValidationContext)::: year month duration v get actual value:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
YearMonthDurationDV#getDuration(DateTimeData)::: year month duration v get duration:::sign->if->return->datatypeFactory->BigInteger->valueOf->BigInteger->valueOf->newDuration
YearMonthDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
YearMonthDV#parse(String):::Parses, validates and computes normalized version of gYearMonth object:::date->new->DateTimeData->len->str->length->end->getYearMonth->parseTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
YearMonthDV#dateToString(DateTimeData)::: year month v date to string:::message->new->StringBuffer->append->message->append->append->append->return->message->toString
YearMonthDV#getXMLGregorianCalendar(DateTimeData)::: year month v get gregorian calendar:::return->datatypeFactory->date->hasTimeZone->newXMLGregorianCalendar
