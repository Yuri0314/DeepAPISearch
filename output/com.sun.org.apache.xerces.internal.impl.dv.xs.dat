AbstractDateTimeDV#compareDates(DateTimeData, DateTimeData, boolean):::Compare algorithm described in dateDime (3.2.7):::if->return->compareOrder->c1->c2->tempDate->new->DateTimeData->if->cloneDate->normalize->compareOrder->if->return->cloneDate->normalize->compareOrder->if->return->return->else->if->cloneDate->if->dateToString->println->normalize->compareOrder->if->dateToString->println->dateToString->println->if->return->cloneDate->normalize->compareOrder->if->dateToString->println->if->return->return->return
AbstractDateTimeDV#compareOrder(DateTimeData, DateTimeData):::Given normalized values, determines order-relation between give date/time objects.:::if->if->return->if->return->if->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->if->return->return
AbstractDateTimeDV#getTime(String, int, int, DateTimeData):::Parses time hh:mm:ss.sss and time zone if any:::stop->parseInt->if->buffer->charAt->throw->new->RuntimeException->parseInt->if->buffer->charAt->throw->new->RuntimeException->sign->findUTCSign->parseSecond->if->getTimeZone
AbstractDateTimeDV#getDate(String, int, int, DateTimeData):::Parses date CCYY-MM-DD:::getYearMonth->if->buffer->charAt->throw->new->RuntimeException->stop->parseInt->return
AbstractDateTimeDV#getYearMonth(String, int, int, DateTimeData):::Parses date CCYY-MM:::if->buffer->charAt->i->indexOf->if->throw->new->RuntimeException->length->if->throw->new->RuntimeException->else->if->buffer->charAt->throw->new->RuntimeException->parseIntYear->if->buffer->charAt->throw->new->RuntimeException->parseInt->return
AbstractDateTimeDV#parseTimeZone(String, int, int, DateTimeData):::Shared code from Date and YearMonth datatypes:::if->if->isNextCharUTCSign->throw->new->RuntimeException->else->getTimeZone
AbstractDateTimeDV#getTimeZone(String, DateTimeData, int, int):::Parses time zone: 'Z' or {+,-} followed by hh:mm:::buffer->charAt->if->buffer->charAt->if->throw->new->RuntimeException->return->if->negate->buffer->charAt->stop->parseInt->if->buffer->charAt->throw->new->RuntimeException->parseInt->if->throw->new->RuntimeException->if->else->throw->new->RuntimeException->if->println
AbstractDateTimeDV#indexOf(String, int, int, char):::Computes index of given char within StringBuffer:::for->i->return
AbstractDateTimeDV#validateDateTime(DateTimeData):::Validates given date/time object accoring to W3C PR Schema [D.1 ISO 8601 Conventions]:::if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->maxDayInMonthFor->throw->new->RuntimeException->if->if->if->maxDayInMonthFor->if->if->else->if->else->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->if->throw->new->RuntimeException->else->if->throw->new->RuntimeException->else->if->throw->new->RuntimeException
AbstractDateTimeDV#findUTCSign(String, int, int):::Return index of UTC char: 'Z', '+', '-':::c->for->i->return
AbstractDateTimeDV#isNextCharUTCSign(String, int, int):::Returns true if the character at start is 'Z', '+' or '-'.:::if->c->buffer->charAt->return->return
AbstractDateTimeDV#parseInt(String, int, int):::Given start and end position, parses string value:::radix->result->digit->limit->multmin->i->do->buffer->charAt->getDigit->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->if->throw->new->NumberFormatException->while->return
AbstractDateTimeDV#normalize(DateTimeData):::If timezone present - normalize dateTime [E Adding durations to dateTimes]:::negate->if->println->println->temp->carry->fQuotient->mod->if->println->fQuotient->mod->if->println->println->while->maxDayInMonthFor->if->maxDayInMonthFor->else->if->else->break->modulo->fQuotient->if
AbstractDateTimeDV#resetDateObj(DateTimeData):::Resets object representation of date/time:::
AbstractDateTimeDV#maxDayInMonthFor(int, int):::Given {year,month} computes maximum number of days for given month:::if->return->else->if->if->isLeapYear->return->else->return->else->return
BaseDVFactory#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBaseTypes->get
BaseDVFactory#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBaseTypes->makeClone
BaseDVFactory#createTypeRestriction(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by restriction from another simple type.:::return->new->XSSimpleTypeDecl
BaseDVFactory#createTypeList(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by list from another simple type.:::return->new->XSSimpleTypeDecl
BaseDVFactory#createTypeUnion(String, String, short, XSSimpleType[], XSObjectList):::Create a new simple type which is derived by union from a list of other simple types.:::typeNum->mtypes->new->XSSimpleTypeDeclArr->System->arraycopy->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#createTypeRestriction(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by restriction from another simple type.:::if->st->fDeclPool->getSimpleTypeDecl->return->st->setRestrictionValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#createTypeList(String, String, short, XSSimpleType, XSObjectList):::Create a new simple type which is derived by list from another simple type.:::if->st->fDeclPool->getSimpleTypeDecl->return->st->setListValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#createTypeUnion(String, String, short, XSSimpleType[], XSObjectList):::Create a new simple type which is derived by union from a list of other simple types.:::typeNum->mtypes->new->XSSimpleTypeDeclArr->System->arraycopy->if->st->fDeclPool->getSimpleTypeDecl->return->st->setUnionValues->return->new->XSSimpleTypeDecl
BaseSchemaDVFactory#newXSSimpleTypeDecl():::Implementation internal *:::return->new->XSSimpleTypeDecl
DateDV#parse(String):::Parses, validates and computes normalized version of dateTime object:::date->new->DateTimeData->len->str->length->end->getDate->parseTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
DateTimeDV#parse(String):::Parses, validates and computes normalized version of dateTime object:::date->new->DateTimeData->len->str->length->end->indexOf->dateEnd->getDate->getTime->if->throw->new->RuntimeException->validateDateTime->saveUnnormalized->if->normalize->return
DayDV#parse(String):::Parses, validates and computes normalized version of gDay object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->str->charAt->throw->new->SchemaDateTimeException->parseInt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
DayDV#dateToString(DateTimeData):::Converts gDay object representation to String:::message->new->StringBuffer->message->append->message->append->message->append->append->append->return->message->toString
DoubleDV#isPossibleFP(String):::Returns true if it's possible that the given string represents a valid floating point value (excluding NaN, INF and -INF).:::length->val->length->for->i->return
DurationDV#parse(String, int):::Parses, validates and computes normalized version of duration object:::len->str->length->date->new->DateTimeData->start->c->str->charAt->if->throw->new->SchemaDateTimeException->else->if->str->charAt->throw->new->SchemaDateTimeException->negate->if->designator->endDate->indexOf->if->else->if->throw->new->SchemaDateTimeException->end->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->indexOf->if->if->throw->new->SchemaDateTimeException->parseInt->if->throw->new->SchemaDateTimeException->if->indexOf->if->parseInt->indexOf->if->parseInt->indexOf->if->parseSecond->if->str->charAt->throw->new->SchemaDateTimeException->if->throw->new->SchemaDateTimeException->return
DurationDV#compareDates(DateTimeData, DateTimeData, boolean):::Compares 2 given durations:::resultA->resultB->compareOrder->if->return->result->new->DateTimeDataArr->new->DateTimeData->new->DateTimeData->tempA->addDuration->tempB->addDuration->compareOrder->if->return->addDuration->addDuration->compareOrder->compareResults->if->return->addDuration->addDuration->compareOrder->compareResults->if->return->addDuration->addDuration->compareOrder->compareResults->return
ExtendedSchemaDVFactoryImpl#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBuiltInTypes->get
ExtendedSchemaDVFactoryImpl#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBuiltInTypes->makeClone
FullDVFactory#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fFullTypes->get
FullDVFactory#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fFullTypes->makeClone
MonthDayDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
MonthDayDV#parse(String):::Parses, validates and computes normalized version of gMonthDay object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->throw->new->SchemaDateTimeException->parseInt->start->if->str->charAt->throw->new->SchemaDateTimeException->parseInt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
MonthDayDV#dateToString(DateTimeData):::Converts gMonthDay object representation to String:::message->new->StringBuffer->message->append->message->append->append->message->append->append->append->return->message->toString
MonthDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
MonthDV#parse(String):::Parses, validates and computes normalized version of gMonth object:::date->new->DateTimeData->len->str->length->if->str->charAt->str->charAt->throw->new->SchemaDateTimeException->stop->parseInt->if->str->length->str->charAt->str->charAt->if->if->isNextCharUTCSign->throw->new->SchemaDateTimeException->else->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
MonthDV#dateToString(DateTimeData):::Converts month object representation to String:::message->new->StringBuffer->message->append->message->append->append->append->return->message->toString
SchemaDVFactoryImpl#getBuiltInType(String):::Get a built-in simple type of the given name REVISIT: its still not decided within the Schema WG how to define the          ur-types and if all simple types should be derived from a          complex type, so as of now we ignore the fact that anySimpleType          is derived from anyType, and pass 'null' as the base of          anySimpleType:::return->fBuiltInTypes->get
SchemaDVFactoryImpl#getBuiltInTypes():::get all built-in simple types, which are stored in a hashtable keyed by the name:::return->fBuiltInTypes->makeClone
TimeDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
TimeDV#parse(String):::Parses, validates and computes normalized version of time object:::date->new->DateTimeData->len->str->length->getTime->validateDateTime->saveUnnormalized->if->normalize->return
TimeDV#dateToString(DateTimeData):::Converts time object representation to String:::message->new->StringBuffer->append->message->append->append->message->append->append->append->return->message->toString
XSSimpleTypeDecl#getBuiltInKind():::Returns the closest built-in type category this type represents or derived from:::return
XSSimpleTypeDecl#getPrimitiveType():::If variety is atomic the primitive type definition (a built-in primitive datatype definition or the simple ur-type definition) is available, otherwise null.:::if->pri->while->return->else->return
XSSimpleTypeDecl#getItemType():::If variety is list the item type definition (an atomic or union simple type definition) is available, otherwise null.:::if->return->else->return
XSSimpleTypeDecl#getMemberTypes():::If variety is union the list of member type definitions (a non-empty sequence of simple type definitions) is available, otherwise an empty XSObjectList.:::if->return->new->XSObjectListImpl->else->return
XSSimpleTypeDecl#applyFacets(XSFacets, short, short, ValidationContext):::If <restriction> is chosen:::if->applyFacets
XSSimpleTypeDecl#applyFacets1(XSFacets, short, short):::built-in derived types by restriction:::try->applyFacets->catch->throw->new->RuntimeException->finally
XSSimpleTypeDecl#applyFacets1(XSFacets, short, short, short):::built-in derived types by restriction:::try->applyFacets->catch->throw->new->RuntimeException->finally
XSSimpleTypeDecl#applyFacets(XSFacets, short, short, short, ValidationContext):::If <restriction> is chosen, or built-in derived types by restriction:::if->return->tempInfo->new->ValidatedInfo->result->allowedFacet->getAllowedFacets->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->regex->try->context->getLocale->new->RegularExpression->catch->new->ObjectArr->e->getLocalizedMessage->reportError->finally->if->new->ArrayList<>->fPattern->add->new->ArrayList<>->fPatternStr->add->if->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->enumVals->size->enumVals->size->new->ValidatedInfoArr->enumNSDecls->ctx->new->ValidationContextImpl->for->i->if->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->if->compare->new->ObjectArr->reportError->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->needCheckBase->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->compare->if->new->ObjectArr->reportError->if->if->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->else->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->compare->if->new->ObjectArr->reportError->if->if->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->else->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->reportError->else->try->fBase->getActualValue->if->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->if->compare->new->ObjectArr->reportError->try->fBase->validate->catch->ide->getKey->ide->getArgs->reportError->new->ObjectArr->fBase->getName->reportError->finally->if->if->new->ObjectArr->reportError->else->if->if->if->new->ObjectArr->reportError->else->if->if->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->compare->if->new->ObjectArr->reportError->if->compare->if->new->ObjectArr->reportError->if->if->compare->new->ObjectArr->reportError->if->if->compare->new->ObjectArr->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->else->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->if->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->if->new->ObjectArr->Integer->toString->Integer->toString->reportError->else->if->new->ObjectArr->Integer->toString->reportError->if->if->new->ObjectArr->whiteSpaceValue->whiteSpaceValue->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->new->ObjectArr->reportError->if->if->if->if->if->else->for->i->size->if->if->for->i->getLength->else->if->if->if->if->if->if->if->if->if->calcFundamentalFacets
XSSimpleTypeDecl#validate(String, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->ob->getActualValue->validate->return
XSSimpleTypeDecl#validateWithInfo(String, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->getActualValue->validate->return
XSSimpleTypeDecl#validate(Object, ValidationContext, ValidatedInfo):::validate a value, and return the compiled form:::if->if->new->ValidatedInfo->else->needNormalize->context->needToNormalize->ob->getActualValue->validate->return
XSSimpleTypeDecl#validate(ValidationContext, ValidatedInfo):::validate an actual value against this DV:::if->if->context->needFacetChecking->checkFacets->if->context->needExtraChecking->checkExtraRules
XSSimpleTypeDecl#getOrdered()::: Fundamental Facet: ordered.:::return
XSSimpleTypeDecl#getBounded():::Fundamental Facet: bounded.:::return
XSSimpleTypeDecl#getFinite():::Fundamental Facet: cardinality.:::return
XSSimpleTypeDecl#getNumeric():::Fundamental Facet: numeric.:::return
XSSimpleTypeDecl#isDefinedFacet(short):::Convenience method:::if->return->if->return->if->return->if->return->return
XSSimpleTypeDecl#getDefinedFacets():::[facets]: all facets defined on this type:::if->return->if->return->if->return->return
XSSimpleTypeDecl#isFixedFacet(short):::Convenience method:::if->return->if->return->return
XSSimpleTypeDecl#getFixedFacets():::[facets]: all defined facets for this type which are fixed.:::if->return->return
XSSimpleTypeDecl#getLexicalFacetValue(short):::Convenience method:::switch->return->Integer->toString->return->Integer->toString->return->Integer->toString->if->return->return->return->fMaxInclusive->toString->return->fMaxExclusive->toString->return->fMinExclusive->toString->return->fMinInclusive->toString->return->Integer->toString->if->return->return->Integer->toString->return
XSSimpleTypeDecl#getLexicalEnumeration():::A list of enumeration values if it exists, otherwise an empty StringList.:::if->if->return->size->strs->new->StringArr->for->i->new->StringListImpl->return
XSSimpleTypeDecl#getActualEnumeration():::A list of actual enumeration values if it exists, otherwise an empty ObjectList.:::if->new->AbstractObjectList->return
XSSimpleTypeDecl#getEnumerationItemTypeList():::A list of enumeration type values (as a list of ShortList objects) if it exists, otherwise returns null:::if->if->return->new->AbstractObjectList->return
XSSimpleTypeDecl#getLexicalPattern():::A list of pattern values if it exists, otherwise an empty StringList.:::if->return->if->size->fPatternStr->size->strs->if->new->StringArr->else->if->new->StringArr->else->if->new->StringArr->else->if->new->StringArr->else->new->StringArr->for->i->new->StringListImpl->return
XSSimpleTypeDecl#getAnnotations():::[annotations]: a set of annotations for this simple type component if it exists, otherwise an empty XSObjectList.:::return
XSSimpleTypeDecl#isDOMDerivedFrom(String, String, int):::Checks if a type is derived from another by restriction, given the name and namespace:::if->return->if->equals->equals->return->if->if->isDerivedByRestriction->return->if->if->isDerivedByList->return->if->if->isDerivedByUnion->return->if->return->if->return->isDerivedByAny->return
XSSimpleTypeDecl#getFacets()::: A list of constraining facets if it exists, otherwise an empty XSObjectList:::if->facets->new->XSFacetImplArr->count->if->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->Integer->toString->new->XSFacetImpl->if->new->XSFacetImpl->else->if->Integer->toString->new->XSFacetImpl->if->fMaxInclusive->toString->new->XSFacetImpl->if->fMaxExclusive->toString->new->XSFacetImpl->if->fMinExclusive->toString->new->XSFacetImpl->if->fMinInclusive->toString->new->XSFacetImpl->new->XSObjectListImpl->return
XSSimpleTypeDecl#getMultiValueFacets()::: A list of enumeration and pattern constraining facets if it exists, otherwise an empty XSObjectList.:::if->facets->new->XSMVFacetImplArr->count->if->this->getLexicalPattern->new->XSMVFacetImpl->if->this->getLexicalEnumeration->new->ObjectListImpl->new->XSMVFacetImpl->new->XSObjectListImpl->return
YearDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
YearDV#parse(String):::Parses, validates and computes normalized version of gYear object:::date->new->DateTimeData->len->str->length->start->if->str->charAt->sign->findUTCSign->length->if->throw->new->RuntimeException->else->if->str->charAt->throw->new->RuntimeException->if->parseIntYear->else->parseIntYear->getTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
YearDV#dateToString(DateTimeData):::Converts year object representation to String:::message->new->StringBuffer->append->append->return->message->toString
YearMonthDV#getActualValue(String, ValidationContext):::Convert a string to a compiled form:::try->return->parse->catch->throw->new->ObjectArr->new->InvalidDatatypeValueException->finally
YearMonthDV#parse(String):::Parses, validates and computes normalized version of gYearMonth object:::date->new->DateTimeData->len->str->length->end->getYearMonth->parseTimeZone->validateDateTime->saveUnnormalized->if->normalize->return
