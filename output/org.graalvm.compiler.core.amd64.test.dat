AMD64AddressLoweringTest#checkAMD64()::: d64 address lowering test check d64:::getTarget->assumeTrue->getInitialOptions->getDebugContext->new->StructuredGraph.Builder->build->new->AMD64AddressLowering
AMD64AddressLoweringTest#convertBaseAndIndexToDisplacement()::: d64 address lowering test convert base and index to displacement:::base->graph->const64->unique->index->graph->const64->unique->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertBaseToDisplacement()::: d64 address lowering test convert base to displacement:::constantAddress->graph->const64->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertBaseAndShiftedIndexToDisplacement()::: d64 address lowering test convert base and shifted index to displacement:::base->graph->const64->addOrUniqueWithInputs->index->graph->const64->const32->new->LeftShiftNode->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertBaseAndNegatedShiftedIndexToDisplacement()::: d64 address lowering test convert base and negated shifted index to displacement:::base->graph->const64->addOrUniqueWithInputs->index->graph->const64->const32->new->LeftShiftNode->new->NegateNode->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertNegatedBaseAndNegatedShiftedIndexToDisplacement()::: d64 address lowering test convert negated base and negated shifted index to displacement:::base->graph->const64->new->NegateNode->addOrUniqueWithInputs->index->graph->const64->const32->new->LeftShiftNode->new->NegateNode->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertNegatedShiftedBaseAndNegatedIndexToDisplacement()::: d64 address lowering test convert negated shifted base and negated index to displacement:::base->graph->const64->const32->new->LeftShiftNode->new->NegateNode->addOrUniqueWithInputs->index->graph->const64->new->NegateNode->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#convertTwoLevelsOfNegatedShiftedBaseAndNegatedIndexToDisplacement()::: d64 address lowering test convert two levels of negated shifted base and negated index to displacement:::base->graph->const64->const32->new->LeftShiftNode->new->NegateNode->const32->new->LeftShiftNode->new->NegateNode->addOrUniqueWithInputs->index->graph->const64->new->NegateNode->const64->new->AddNode->new->NegateNode->addOrUniqueWithInputs->result->lowering->lower->assertAddress
AMD64AddressLoweringTest#const64(long)::: d64 address lowering test const64:::return->ConstantNode->forIntegerBits
AMD64AddressLoweringTest#const32(long)::: d64 address lowering test const32:::return->ConstantNode->forIntegerBits
AMD64AddressLoweringTest#assertAddress(AddressNode, ValueNode, ValueNode, Scale, int)::: d64 address lowering test assert address:::address->Assert->address->getBase->assertEquals->Assert->address->getIndex->assertEquals->Assert->address->getScale->assertEquals->Assert->address->getDisplacement->assertEquals
AMD64AllocatorTest#checkAMD64()::: d64 allocator test check d64:::getTarget->assumeTrue->RegisterPressure->getInitialOptions->getValue->assumeTrue
AMD64AllocatorTest#test1()::: d64 allocator test test1:::testAllocation
AMD64AllocatorTest#test1snippet(long)::: d64 allocator test test1snippet:::return
AMD64AllocatorTest#test2()::: d64 allocator test test2:::testAllocation
AMD64AllocatorTest#test2snippet(long)::: d64 allocator test test2snippet:::return
AMD64AllocatorTest#test3()::: d64 allocator test test3:::testAllocation
AMD64AllocatorTest#test3snippet(long)::: d64 allocator test test3snippet:::return
AMD64MatchRuleTest#checkAMD64()::: d64 match rule test check d64:::getTarget->assumeTrue
AMD64MatchRuleTest#test1Snippet(TestClass, TestClass, TestClass)::: d64 match rule test test1 snippet:::if->return->else->return
AMD64MatchRuleTest#test1():::Verifies, if the match rules in AMD64NodeMatchRules do work on the graphs by compiling and checking if the expected LIR instruction show up.:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
AMD64MatchRuleTest#testVolatileExtensionSnippet()::: d64 match rule test test volatile extension snippet:::return
AMD64MatchRuleTest#testVolatileExtension()::: d64 match rule test test volatile extension:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->ins->value->getPlatformKind->toString->value->getPlatformKind->equals->assertTrue->visitEachOutput->assertFalse->assertTrue
AMD64MatchRuleTest#testLoadTestNoMatchSnippet():::Can't match test and load of input because of volatile store in between.:::v->if->return->return
AMD64MatchRuleTest#testLoadTestNoMatch()::: d64 match rule test test load test no match:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
AMD64MatchRuleTest#testAddLoadSnippet():::Should match as an add with a memory operand.:::v1->v2->return
AMD64MatchRuleTest#testAddLoad()::: d64 match rule test test add load:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
AMD64MatchRuleTest#testAddLoadNoMatchSnippet():::Can't match as an add with a memory operand because the other add input is too late.:::v1->v2->return
AMD64MatchRuleTest#testAddLoadNoMatch()::: d64 match rule test test add load no match:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
AMD64MatchRuleTest#testVolatileExtensionDifferentBlocksSnippet(boolean):::sign extension and load are in different blocks but can still be matched as a single instruction.:::v->if->return->return
AMD64MatchRuleTest#testVolatileExtensionDifferentBlocks()::: d64 match rule test test volatile extension different blocks:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->ins->value->getPlatformKind->toString->value->getPlatformKind->equals->assertTrue->visitEachOutput->assertFalse->assertTrue
AMD64MatchRuleTest#testAddLoadDifferentBlocksNoMatchSnippet(boolean):::Add and load are not in the same block and one input is too late: can't match.:::v1->if->v2->return->return
AMD64MatchRuleTest#testAddLoadDifferentBlocksNoMatch()::: d64 match rule test test add load different blocks no match:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->codeEmittingOrder->foreach->lir->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
AMD64MatchRuleTest#testAddLoadDifferentBlocksSnippet(boolean):::Add and load are in different blocks but can still match.:::v2->v1->if->return->return
AMD64MatchRuleTest#testAddLoadDifferentBlocks()::: d64 match rule test test add load different blocks:::getResolvedJavaMethod->compile->lir->getLIR->found->foreach->lir->lir->codeEmittingOrder->getLIRforBlock->if->getOpcode->toString->equals->assertFalse->assertTrue
ConstantStackMoveTest#checkAMD64()::: constant stack move test check d64:::getTarget->assumeTrue
ConstantStackMoveTest.LoadConstantStackSpec#generate(LIRGeneratorTool)::: load constant stack spec generate:::frameMapBuilder->gen->getResult->getFrameMapBuilder->constantValue->JavaConstant->forBoxedPrimitive->s1->frameMapBuilder->LIRKind->gen->target->constantValue->getJavaKind->fromJavaKind->allocateSpillSlot->gen->emitMoveConstant->gen->emitBlackhole->gen->emitMove->setResult
ConstantStackMoveTest.LoadConstantStackSpecByte#get()::: load constant stack spec byte get:::return
ConstantStackMoveTest.LoadConstantStackSpecShort#get()::: load constant stack spec short get:::return
ConstantStackMoveTest.LoadConstantStackSpecInteger#get()::: load constant stack spec integer get:::return
ConstantStackMoveTest.LoadConstantStackSpecLong#get()::: load constant stack spec long get:::return
ConstantStackMoveTest.LoadConstantStackSpecFloat#get()::: load constant stack spec float get:::return
ConstantStackMoveTest.LoadConstantStackSpecDouble#get()::: load constant stack spec double get:::return
ConstantStackMoveTest#testCopyByte(LoadConstantStackSpecByte)::: constant stack move test test copy byte:::return->spec->get
ConstantStackMoveTest#testByte()::: constant stack move test test byte:::return->testCopyByte
ConstantStackMoveTest#runByte()::: constant stack move test run byte:::runTest
ConstantStackMoveTest#testCopyShort(LoadConstantStackSpecShort)::: constant stack move test test copy short:::return->spec->get
ConstantStackMoveTest#testShort()::: constant stack move test test short:::return->testCopyShort
ConstantStackMoveTest#runShort()::: constant stack move test run short:::runTest
ConstantStackMoveTest#testCopyInt(LoadConstantStackSpecInteger)::: constant stack move test test copy int:::return->spec->get
ConstantStackMoveTest#testInt()::: constant stack move test test int:::return->testCopyInt
ConstantStackMoveTest#runInt()::: constant stack move test run int:::runTest
ConstantStackMoveTest#testCopyLong(LoadConstantStackSpecLong)::: constant stack move test test copy long:::return->spec->get
ConstantStackMoveTest#testLong()::: constant stack move test test long:::return->testCopyLong
ConstantStackMoveTest#runLong()::: constant stack move test run long:::runTest
ConstantStackMoveTest#testCopyFloat(LoadConstantStackSpecFloat)::: constant stack move test test copy float:::return->spec->get
ConstantStackMoveTest#testFloat()::: constant stack move test test float:::return->testCopyFloat
ConstantStackMoveTest#runFloat()::: constant stack move test run float:::runTest
ConstantStackMoveTest#testCopyDouble(LoadConstantStackSpecDouble)::: constant stack move test test copy double:::return->spec->get
ConstantStackMoveTest#testDouble()::: constant stack move test test double:::return->testCopyDouble
ConstantStackMoveTest#runDouble()::: constant stack move test run double:::runTest
StackStoreTest#checkAMD64()::: stack store test check d64:::getTarget->assumeTrue
StackStoreTest#testShortStackSlot(LIRTestSpecification, int)::: stack store test test short stack slot:::return
StackStoreTest#testShortStackSlot2(LIRTestSpecification, int)::: stack store test test short stack slot2:::return
StackStoreTest#test0(int)::: stack store test test0:::return->testShortStackSlot
StackStoreTest#run0()::: stack store test run0:::runTest
StackStoreTest#test1(int)::: stack store test test1:::return->testShortStackSlot
StackStoreTest#run1()::: stack store test run1:::runTest
StackStoreTest#test2(int)::: stack store test test2:::return->testShortStackSlot2
StackStoreTest#run2()::: stack store test run2:::runTest
