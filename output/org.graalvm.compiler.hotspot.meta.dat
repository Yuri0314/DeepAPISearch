HotSpotForeignCallsProvider#getNativeABICallerSaveRegisters():::Gets the registers that must be saved across a foreign call into the runtime.:::
HotSpotForeignCallsProvider#getStubs():::Gets the set of stubs linked to by the foreign calls represented by this object.:::
HotSpotForeignCallsProviderImpl#register(HotSpotForeignCallLinkage):::Registers the linkage for a foreign call.:::foreignCalls->linkage->getDescriptor->put->return
HotSpotForeignCallsProviderImpl#isRegistered(ForeignCallDescriptor):::Return true if the descriptor has already been registered.:::return->foreignCalls->containsKey
HotSpotForeignCallsProviderImpl#registerStubCall(ForeignCallDescriptor, Transition, Reexecutability, LocationIdentity...):::Creates and registers the details for linking a foreign call to a Stub.:::return->HotSpotForeignCallLinkageImpl->create->register
HotSpotForeignCallsProviderImpl#registerForeignCall(ForeignCallDescriptor, long, CallingConvention.Type, RegisterEffect, Transition, Reexecutability, LocationIdentity...):::Creates and registers the linkage for a foreign call.:::resultType->descriptor->getResultType->return->HotSpotForeignCallLinkageImpl->create->register
HotSpotForeignCallsProviderImpl#linkForeignCall(OptionValues, HotSpotProviders, ForeignCallDescriptor, long, boolean, Transition, Reexecutability, LocationIdentity...):::Creates a ForeignCallStub stub for the foreign call described by descriptor if address != 0.:::if->stub->new->ForeignCallStub->linkage->stub->getLinkage->targetLinkage->stub->getTargetLinkage->linkage->setCompiledStub->register->register
HotSpotGCProvider#isWriteToNewObject(FixedAccessNode):::For initializing writes, the last allocation executed by the JVM is guaranteed to be automatically card marked so it's safe to skip the card mark in the emitted code.:::if->initializingWrite->getLocationIdentity->isInit->return->base->initializingWrite->getAddress->getBase->if->pred->initializingWrite->predecessor->while->if->return->if->initializingWrite->getDebug->log->return->pred->predecessor->initializingWrite->getDebug->log->return
HotSpotGraphBuilderPlugins#create(CompilerConfiguration, GraalHotSpotVMConfig, HotSpotWordTypes, MetaAccessProvider, ConstantReflectionProvider, SnippetReflectionProvider, ForeignCallsProvider, ReplacementsImpl, OptionValues):::Creates a Plugins object that should be used when running on HotSpot.:::invocationPlugins->new->HotSpotInvocationPlugins->plugins->new->Plugins->nodeIntrinsificationProvider->new->NodeIntrinsificationProvider->wordOperationPlugin->new->HotSpotWordOperationPlugin->nodePlugin->new->HotSpotNodePlugin->plugins->appendTypePlugin->plugins->appendNodePlugin->if->GeneratePIC->getValue->plugins->constantReflection->getMethodHandleAccess->new->MethodHandlePlugin->appendNodePlugin->plugins->appendInlineInvokePlugin->if->InlineDuringParsing->getValue->plugins->new->InlineDuringParsingPlugin->appendInlineInvokePlugin->if->GeneratePIC->getValue->plugins->new->HotSpotClassInitializationPlugin->setClassInitializationPlugin->if->TieredAOT->getValue->plugins->new->HotSpotAOTProfilingPlugin->setProfilingPlugin->invocationPlugins->new->Runnable->defer->return
HotSpotObjdumpDisassemblerProvider#quoteShellArg(String):::Reliably quote a string as a single shell command argument.:::if->arg->isEmpty->return->m->SAFE_SHELL_ARG->matcher->if->m->matches->return->return->arg->replace
HotSpotRegistersProvider#getThreadRegister():::Gets the register holding the current thread.:::
HotSpotRegistersProvider#getHeapBaseRegister():::Gets the register holding the heap base address for compressed pointers.:::
HotSpotRegistersProvider#getStackPointerRegister():::Gets the stack pointer register.:::
HotSpotSuitesProvider#withNodeSourcePosition(PhaseSuite):::Modifies a given GraphBuilderConfiguration to record per node source information.:::newGbs->gbs->copy->graphBuilderPhase->newGbs->findPhase->previous->graphBuilderConfig->graphBuilderPhase->getGraphBuilderConfig->newGraphBuilderPhase->graphBuilderConfig->withNodeSourcePosition->new->GraphBuilderPhase->newGbs->findPhase->set->return
