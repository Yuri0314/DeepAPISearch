BatchEnvironment#createClassPath(String):::Create a ClassPath object for rmic from a class path string.:::paths->classPaths->return
BatchEnvironment#createClassPath(String, String):::Create a ClassPath object for rmic from the relevant command line options for class path and boot class path.:::path->new->Path->if->System->getProperty->if->path->addFiles->path->expandJarClassPaths->path->emptyPathDefault->if->System->getProperty->if->path->addFiles->return->path->path->size->new->StringArr->toArray->new->ClassPath
BatchEnvironment#getMain():::Get the instance of Main which created this environment.:::return
BatchEnvironment#getClassPath():::Get the ClassPath.:::return
BatchEnvironment#addGeneratedFile(File):::Remember a generated source file generated so that it can be removed later, if appropriate.:::generatedFiles->addElement
BatchEnvironment#deleteGeneratedFiles():::Delete all the generated source files made during the execution of this environment (those that have been registered with the "addGeneratedFile" method).:::synchronized->enumeration->generatedFiles->elements->while->enumeration->hasMoreElements->file->enumeration->nextElement->file->delete->generatedFiles->removeAllElements
BatchEnvironment#shutdown():::Release resources, if any.:::super->shutdown
BatchEnvironment#errorString(String, Object, Object, Object):::Return the formatted, localized string for a named error message and supplied arguments:::if->err->startsWith->err->startsWith->result->Main->arg0->toString->arg1->toString->arg2->toString->getText->if->err->startsWith->return->else->return->super->errorString
BatchEnvironment#reset()::: batch environment reset:::
BatchEnvironment.Path.PathIterator#iterator()::: path iterator iterator:::return->new->Iterator<String>
BatchEnvironment.Path.PathIterator#size()::: path iterator size:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#isEmpty()::: path iterator is empty:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#contains(Object)::: path iterator contains:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#toArray()::: path iterator to array:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#toArray(T[])::: path iterator to array:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#add(String)::: path iterator add:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#remove(Object)::: path iterator remove:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#containsAll(Collection)::: path iterator contains all:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#addAll(Collection)::: path iterator add all:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#removeAll(Collection)::: path iterator remove all:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#retainAll(Collection)::: path iterator retain all:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#clear()::: path iterator clear:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#equals(Object)::: path iterator equals:::throw->new->UnsupportedOperationException
BatchEnvironment.Path.PathIterator#hashCode()::: path iterator hash code:::throw->new->UnsupportedOperationException
BatchEnvironment.Path#isZip(String):::Is this the name of a zip file?:::return->new->File->isFile
BatchEnvironment.Path#expandJarClassPaths(boolean)::: path expand jar class paths:::return
BatchEnvironment.Path#emptyPathDefault(String)::: path empty path default:::return
BatchEnvironment.Path#addDirectories(String, boolean)::: path add directories:::if->foreach->new->PathIterator->addDirectory->return
BatchEnvironment.Path#addDirectories(String)::: path add directories:::return->addDirectories
BatchEnvironment.Path#addDirectory(String, boolean)::: path add directory:::if->new->File->isDirectory->return->foreach->new->File->list->canonicalized->direntry->toLowerCase->if->canonicalized->endsWith->canonicalized->endsWith->addFile
BatchEnvironment.Path#addFiles(String, boolean)::: path add files:::if->foreach->new->PathIterator->addFile->return
BatchEnvironment.Path#addFiles(String)::: path add files:::return->addFiles
BatchEnvironment.Path#addFile(String, boolean)::: path add file:::if->contains->return->ele->new->File->if->ele->exists->if->return->if->ele->isFile->arcname->file->toLowerCase->if->arcname->endsWith->arcname->endsWith->return->super->add->if->isZip->addJarClassPath
BatchEnvironment.Path#addJarClassPath(String, boolean)::: path add jar class path:::try->jarParent->new->File->getParent->jar->new->JarFile->try->man->jar->getManifest->if->return->attr->man->getMainAttributes->if->return->path->attr->getValue->if->return->for->st->new->StringTokenizer->st->hasMoreTokens->catch->finally->jar->close->catch->finally
Generator#parseArgs(String[], Main):::Examine and consume command line arguments.:::
Generator#generate(BatchEnvironment, ClassDefinition, File):::Generate output:::
IndentingWriter#write(int):::Write a single character.:::checkWrite->super->write
IndentingWriter#write(char[], int, int):::Write a portion of an array of characters.:::if->checkWrite->super->write
IndentingWriter#write(String, int, int):::Write a portion of a String.:::if->checkWrite->super->write
IndentingWriter#newLine():::Write a line separator:::super->newLine
IndentingWriter#checkWrite():::Check if an indent needs to be written before writing the next character:::if->i->while->super->write->while->super->write
IndentingWriter#indentIn():::Increase the current indent by the indent step.:::
IndentingWriter#indentOut():::Decrease the current indent by the indent step.:::if
IndentingWriter#pI():::Indent in.:::indentIn
IndentingWriter#pO():::Indent out.:::indentOut
IndentingWriter#p(String):::Write string.:::write
IndentingWriter#pln():::End current line.:::newLine
IndentingWriter#pln(String):::Write string; end current line.:::p->pln
IndentingWriter#plnI(String):::Write string; end current line; indent in.:::p->pln->pI
IndentingWriter#pO(String):::Indent out; write string.:::pO->p
IndentingWriter#pOln(String):::Indent out; write string; end current line.:::pO->pln
IndentingWriter#pOlnI(String):::Indent out; write string; end current line; indent in:::pO->pln->pI
IndentingWriter#p(Object):::Write Object.:::o->toString->write
IndentingWriter#pln(Object):::Write Object; end current line.:::o->toString->p->pln
IndentingWriter#plnI(Object):::Write Object; end current line; indent in.:::o->toString->p->pln->pI
IndentingWriter#pO(Object):::Indent out; write Object.:::pO->o->toString->p
IndentingWriter#pOln(Object):::Indent out; write Object; end current line.:::o->toString->pO->pln
IndentingWriter#pOlnI(Object):::Indent out; write Object; end current line; indent in:::o->toString->pO->pln->pI
Main#output(String):::Output a message.:::out->new->PrintStream->out->println
Main#error(String):::Top level error message:::getText->output
Main#error(String, String)::: main error:::getText->output
Main#error(String, String, String)::: main error:::getText->output
Main#usage():::Usage:::error
Main#compile(String[]):::Run the compiler:::if->parseArgs->return->if->classes->size->usage->return->if->foreach->if->getText->output->break->return->doCompile
Main#getDestinationDir():::Get the destination directory.:::return
Main#parseArgs(String[]):::Parse the arguments for compile.:::System->currentTimeMillis->new->Vector<>->getArray->if->return->new->Vector<>->try->CommandLine->parse->catch->e->getMessage->error->return->e->new->PrintStream->printStackTrace->return->finally->for->i->for->i->if->generators->size->addGenerator->return
Main#checkGeneratorArg(String[], int):::If this argument is for a generator, instantiate it, call parseArgs(...) and add generator to generators vector:::result->if->startsWith->arg->substring->toLowerCase->for->i->return
Main#addGenerator(String):::Instantiate and add a generator to the generators array.:::gen->className->getString->if->error->return->try->Class->forName->newInstance->catch->error->return->finally->generators->addElement->envClass->env->getString->if->try->Class->forName->if->environmentClass->isAssignableFrom->envClass->asSubclass->else->if->envClass->isAssignableFrom->environmentClass->getName->envClass->getName->error->return->catch->error->return->finally->return
Main#getArray(String, boolean):::Grab a resource string and parse it into an array of strings:::result->value->getString->if->if->error->return->else->return->new->StringArr->parser->new->StringTokenizer->count->parser->countTokens->new->StringArr->for->i->return
Main#getEnv():::Get the correct type of BatchEnvironment:::classPath->BatchEnvironment->createClassPath->result->try->ctorArgTypes->ctorArgs->constructor->environmentClass->getConstructor->constructor->newInstance->result->reset->catch->environmentClass->getName->error->finally->return
Main#doCompile():::Do the compile with the switches and files already supplied:::env->getEnv->noMemoryErrorString->getText->stackOverflowErrorString->getText->try->for->i->classes->size->if->compileAllClasses->catch->env->output->return->env->output->return->if->env->dump->env->error->ee->new->PrintStream->printStackTrace->if->env->dump->env->error->ee->new->PrintStream->printStackTrace->finally->env->flushErrors->status->if->msg->if->getText->else->getText->if->if->getText->else->getText->output->else->if->if->getText->output->else->getText->output->if->env->deleteGeneratedFiles->if->env->verbose->System->currentTimeMillis->Long->toString->getText->output->env->shutdown->return
Main#compileAllClasses(BatchEnvironment)::: main compile all classes:::buf->new->ByteArrayOutputStream->done->do->for->e->env->getClasses->e->hasMoreElements->while
Main#compileClass(ClassDeclaration, ByteArrayOutputStream, BatchEnvironment)::: main compile class:::done->env->flushErrors->src->switch->c->getStatus->if->env->dependencies->break->env->loadDefinition->if->c->getStatus->break->if->c->getClassDefinition->isInsideLocal->break->if->throw->new->IOException->c->getClassDefinition->src->check->c->setDefinition->c->getClassDefinition->if->src->getError->c->setDefinition->break->buf->reset->src->compile->c->setDefinition->src->cleanup->if->src->getError->break->pkgName->c->getName->getQualifier->toString->replace->className->c->getName->getFlatName->toString->replace->file->if->if->pkgName->length->new->File->if->file->exists->file->mkdirs->new->File->else->new->File->else->classfile->src->getSource->if->classfile->isZipped->env->classfile->getPath->error->break->classfile->getPath->new->File->file->getParent->new->File->try->out->file->getPath->new->FileOutputStream->buf->writeTo->out->close->if->env->verbose->file->getPath->getText->output->catch->env->file->getPath->error->finally->return
Main#main(String[]):::Main program:::compiler->new->Main->System->compiler->compile->exit
Main#getString(String):::Return the string value of a named resource in the rmic.properties resource bundle:::if->initResources->if->try->return->resourcesExt->getString->catch->finally->try->return->resources->getString->catch->finally->return
Main#initResources()::: main init resources:::try->ResourceBundle->getBundle->try->ResourceBundle->getBundle->catch->finally->catch->throw->e->getClassName->new->Error->finally
Main#getText(String)::: main get text:::message->getString->if->return
Main#getText(String, int)::: main get text:::return->Integer->toString->getText
Main#getText(String, String)::: main get text:::return->getText
Main#getText(String, String, String)::: main get text:::return->getText
Main#getText(String, String, String, String)::: main get text:::format->getString->if->args->new->StringArr->return->format
Names#stubFor(Identifier):::Return stub class name for impl class name.:::return->Identifier->lookup
Names#skeletonFor(Identifier):::Return skeleton class name for impl class name.:::return->Identifier->lookup
Names#mangleClass(Identifier):::If necessary, convert a class name to its mangled form, i.e:::if->className->isInner->return->mangled->Identifier->className->getFlatName->toString->replace->lookup->if->mangled->isInner->throw->new->Error->return->Identifier->className->getQualifier->lookup
RemoteClass#forClass(BatchEnvironment, ClassDefinition):::Create a RemoteClass object representing the remote meta-information of the given class:::rc->new->RemoteClass->if->rc->initialize->return->else->return
RemoteClass#getClassDefinition():::Return the ClassDefinition for this class.:::return
RemoteClass#getName():::Return the name of the class represented by this object.:::return->implClassDef->getName
RemoteClass#getRemoteInterfaces():::Return an array of ClassDefinitions representing all of the remote interfaces implemented by this class:::return->remoteInterfaces->clone
RemoteClass#getRemoteMethods():::Return an array of RemoteClass.Method objects representing all of the remote methods implemented by this class, i.e:::return->remoteMethods->clone
RemoteClass#getInterfaceHash():::Return the "interface hash" used to match a stub/skeleton pair for this class in the JDK 1.1 version of the stub/skeleton protocol.:::return
RemoteClass#toString():::Return string representation of this object, consisting of the string "remote class " followed by the class name.:::return->implClassDef->getName->toString
RemoteClass#initialize():::Validate that the remote implementation class is properly formed and fill in the data structures required by the public interface.:::if->implClassDef->isInterface->env->implClassDef->getName->error->return->try->env->getClassDeclaration->getClassDefinition->env->getClassDeclaration->getClassDefinition->env->getClassDeclaration->getClassDefinition->catch->env->error->return->finally->remotesImplemented->new->Vector<ClassDefinition>->for->classDef->methods->new->Hashtable<String,Method>->errors->for->enumeration->remotesImplemented->elements->enumeration->hasMoreElements->if->return->remotesImplemented->size->new->ClassDefinitionArr->remotesImplemented->copyInto->orderedKeys->methods->size->new->StringArr->count->for->enumeration->methods->elements->enumeration->hasMoreElements->methods->size->new->MethodArr->for->i->computeInterfaceHash->return
RemoteClass#collectRemoteMethods(ClassDefinition, Hashtable):::Collect and validate all methods from given interface and all of its superinterfaces as remote methods:::if->interfaceDef->isInterface->throw->interfaceDef->getName->new->Error->errors->for->member->interfaceDef->getFirstMember->member->getNextMember->try->superDefs->interfaceDef->getInterfaces->for->i->catch->env->interfaceDef->getName->error->return->finally->return
RemoteClass#computeInterfaceHash():::Compute the "interface hash" of the stub/skeleton pair for this remote implementation class:::hash->sink->new->ByteArrayOutputStream->try->md->MessageDigest->getInstance->out->new->DigestOutputStream->new->DataOutputStream->out->writeInt->for->i->out->flush->hashArray->md->digest->for->i->Math->min->catch->throw->new->Error->throw->new->Error->finally->return
RemoteClass#sortClassDeclarations(ClassDeclaration[]):::Sort array of class declarations alphabetically by their mangled fully-qualified class name:::for->i
RemoteClass.Method#getMemberDefinition():::Return the definition of the actual class member corresponing to this method of a remote interface:::return
RemoteClass.Method#getName():::Return the name of this method.:::return->memberDef->getName
RemoteClass.Method#getType():::Return the type of this method.:::return->memberDef->getType
RemoteClass.Method#getExceptions():::Return an array of the exception classes declared to be thrown by this remote method:::return->exceptions->clone
RemoteClass.Method#getMethodHash():::Return the "method hash" used to identify this remote method in the JDK 1.2 version of the stub protocol.:::return
RemoteClass.Method#toString():::Return the string representation of this method.:::return->memberDef->toString
RemoteClass.Method#getOperationString():::Return the string representation of this method appropriate for the construction of a java.rmi.server.Operation object.:::return->memberDef->toString
RemoteClass.Method#getNameAndDescriptor():::Return a string consisting of this method's name followed by its method descriptor, using the Java VM's notation for method descriptors (see section 4.3.3 of The Java Virtual Machine Specification).:::return->memberDef->getName->toString->memberDef->getType->getTypeSignature
RemoteClass.Method#clone():::Cloning is supported by returning a shallow copy of this object.:::try->return->super->clone->catch->throw->new->Error->finally
RemoteClass.Method#mergeWith(Method):::Return a new Method object that is a legal combination of this method object and another one:::if->getName->other->getName->equals->getType->other->getType->equals->throw->other->getNameAndDescriptor->getNameAndDescriptor->new->Error->legalExceptions->new->Vector<ClassDeclaration>->try->collectCompatibleExceptions->collectCompatibleExceptions->catch->env->getClassDefinition->getName->error->return->finally->merged->clone->legalExceptions->size->new->ClassDeclarationArr->legalExceptions->copyInto->return
RemoteClass.Method#collectCompatibleExceptions(ClassDeclaration[], ClassDeclaration[], Vector):::Add to the supplied list all exceptions in the "from" array that are subclasses of an exception in the "with" array.:::for->i
RemoteClass.Method#computeMethodHash():::Compute the "method hash" of this remote method:::hash->sink->new->ByteArrayOutputStream->try->md->MessageDigest->getInstance->out->new->DigestOutputStream->new->DataOutputStream->methodString->getNameAndDescriptor->if->env->verbose->println->out->writeUTF->out->flush->hashArray->md->digest->for->i->Math->min->catch->throw->new->Error->throw->new->Error->finally->return
RMIGenerator#parseArgs(String[], Main):::Examine and consume command line arguments.:::explicitVersion->for->i->return
RMIGenerator#generate(BatchEnvironment, ClassDefinition, File):::Generate the source files for the stub and/or skeleton classes needed by RMI for the given remote implementation class.:::remoteClass->RemoteClass->forClass->if->return->gen->try->new->RMIGenerator->catch->env->error->return->finally->gen->generate
RMIGenerator#generate()::: generator generate:::env->addGeneratedFile->try->out->new->FileOutputStream->new->OutputStreamWriter->new->IndentingWriter->writeStub->out->close->if->env->verbose->env->Main->stubFile->getPath->getText->output->env->ClassFile->newClassFile->parseFile->catch->env->stubFile->toString->error->return->finally->if->env->addGeneratedFile->try->out->new->FileOutputStream->new->OutputStreamWriter->new->IndentingWriter->writeSkeleton->out->close->if->env->verbose->env->Main->skeletonFile->getPath->getText->output->env->ClassFile->newClassFile->parseFile->catch->env->stubFile->toString->error->return->finally->else->outputDir->Util->getOutputDirectoryFor->skeletonClassFile->skeletonClassName->getName->toString->new->File->skeletonFile->delete->skeletonClassFile->delete
RMIGenerator#sourceFileForClass(Identifier, Identifier, File, BatchEnvironment):::Return the File object that should be used as the source file for the given Java class, using the supplied destination directory for the top of the package hierarchy.:::packageDir->Util->getOutputDirectoryFor->outputName->Names->mangleClass->getName->toString->outputFileName->return->new->File
RMIGenerator#writeStub(IndentingWriter):::Write the stub for the remote class to a stream.:::p->pln->p->pln->p->pln->if->remoteClassName->isQualified->p->remoteClassName->getQualifier->pln->p->pln->p->Names->stubClassName->getName->mangleClass->plnI->p->pln->remoteInterfaces->remoteClass->getRemoteInterfaces->if->p->p->for->i->p->pln->p->pOlnI->if->writeOperationsArray->p->pln->writeInterfaceHash->p->pln->if->p->pln->p->pln->if->if->p->pln->writeMethodFieldDeclarations->p->pln->p->plnI->p->plnI->if->p->plnI->p->plnI->p->pln->p->pln->p->pln->p->pln->p->pOln->p->pO->p->pln->writeMethodFieldInitializers->p->pOlnI->if->p->pln->else->p->plnI->p->pln->p->pO->p->pOln->p->pOln->p->pln->writeStubConstructors->p->pln->if->p->pln->for->i->p->pOln
RMIGenerator#writeStubConstructors(IndentingWriter):::Write the constructors for the stub class.:::p->pln->if->p->Names->stubClassName->getName->mangleClass->plnI->p->pln->p->pOln->p->Names->stubClassName->getName->mangleClass->plnI->p->pln->p->pOln
RMIGenerator#writeStubMethod(IndentingWriter, int):::Write the stub method for the remote method with the given "opnum".:::method->methodName->method->getName->methodType->method->getType->paramTypes->methodType->getArgumentTypes->paramNames->nameParameters->returnType->methodType->getReturnType->exceptions->method->getExceptions->p->methodType->methodName->toString->typeString->pln->p->p->for->i->p->plnI->if->p->p->for->i->p->pln->p->pOlnI->catchList->computeUniqueCatchList->if->catchList->size->p->plnI->if->p->plnI->if->if->returnType->isType->p->p->p->p->if->p->p->for->i->p->p->else->p->p->p->method->getMethodHash->pln->if->returnType->isType->p->unwrapArgumentCode->pln->if->p->pOlnI->if->p->pln->if->p->plnI->p->pln->writeMarshalArguments->p->pOlnI->p->pln->p->pOln->p->pln->if->returnType->isType->p->pln->else->p->pln->p->plnI->p->pln->objectRead->writeUnmarshalArgument->p->pln->p->pOlnI->p->pln->if->p->pOlnI->p->pln->p->pOlnI->p->pln->p->pOln->p->pln->if->p->pOln->if->catchList->size->for->enumeration->catchList->elements->enumeration->hasMoreElements->p->pOlnI->p->pln->p->pOln->p->pOln
RMIGenerator#computeUniqueCatchList(ClassDeclaration[]):::Compute the exceptions which need to be caught and rethrown in a stub method before wrapping Exceptions in UnexpectedExceptions, given the exceptions declared in the throws clause of the method:::uniqueList->new->Vector<>->uniqueList->addElement->uniqueList->addElement->for->i->return
RMIGenerator#writeSkeleton(IndentingWriter):::Write the skeleton for the remote class to a stream.:::if->throw->new->Error->p->pln->p->pln->p->pln->if->remoteClassName->isQualified->p->remoteClassName->getQualifier->pln->p->pln->p->Names->skeletonClassName->getName->mangleClass->plnI->p->pln->p->pOlnI->writeOperationsArray->p->pln->writeInterfaceHash->p->pln->p->plnI->p->pln->p->pOln->p->pln->p->plnI->p->pln->p->pOlnI->if->p->plnI->if->for->opnum->p->pOlnI->p->pln->if->p->pOln->p->pOlnI->p->plnI->p->pln->p->pO->if->p->pOln->p->pln->p->pln->p->plnI->for->opnum->p->pOlnI->p->pln->p->pOln->p->pOln->p->pOln
RMIGenerator#writeSkeletonDispatchCase(IndentingWriter, int):::Write the case block for the skeleton's dispatch method for the remote method with the given "opnum".:::method->methodName->method->getName->methodType->method->getType->paramTypes->methodType->getArgumentTypes->paramNames->nameParameters->returnType->methodType->getReturnType->p->methodType->methodName->toString->typeString->pOlnI->p->pOlnI->if->for->i->p->plnI->p->pln->objectsRead->writeUnmarshalArguments->p->pOlnI->p->pln->if->p->pOlnI->p->pln->p->pOlnI->p->pln->p->pOln->else->p->pln->if->returnType->isType->p->p->p->p->for->i->p->pln->p->plnI->if->returnType->isType->p->p->p->pln->if->returnType->isType->writeMarshalArgument->p->pln->p->pOlnI->p->pln->p->pOln->p->pln->p->pOlnI->p->pln
RMIGenerator#writeOperationsArray(IndentingWriter):::Write declaration and initializer for "operations" static array.:::p->plnI->for->i->p->pln->p->pOln
RMIGenerator#writeInterfaceHash(IndentingWriter):::Write declaration and initializer for "interfaceHash" static field.:::p->remoteClass->getInterfaceHash->pln
RMIGenerator#writeMethodFieldDeclarations(IndentingWriter):::Write declaration for java.lang.reflect.Method static fields corresponding to each remote method in a stub.:::for->i
RMIGenerator#writeMethodFieldInitializers(IndentingWriter):::Write code to initialize the static fields for each method using the Java Reflection API.:::for->i
RMIGenerator#nameMethodFields(RemoteClass.Method[]):::Generate an array of names for fields that correspond to the given array of remote methods:::names->new->StringArr->for->i->return
RMIGenerator#nameParameters(Type[]):::Generate an array of names for parameters corresponding to the given array of types for the parameters:::names->new->StringArr->for->i->return
RMIGenerator#generateNameFromType(Type):::Generate a readable string representing the given type suitable for embedding within a Java identifier.:::typeCode->type->getTypeCode->switch->return->type->toString->return->type->getElementType->generateNameFromType->return->Names->type->getClassName->getName->mangleClass->toString->throw->new->Error
RMIGenerator#writeMarshalArgument(IndentingWriter, String, Type, String):::Write a snippet of Java code to marshal a value named "name" of type "type" to the java.io.ObjectOutput stream named "stream":::typeCode->type->getTypeCode->switch->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->throw->new->Error
RMIGenerator#writeMarshalArguments(IndentingWriter, String, Type[], String[]):::Write Java statements to marshal a series of values in order as named in the "names" array, with types as specified in the "types" array", to the java.io.ObjectOutput stream named "stream".:::if->throw->new->Error->for->i
RMIGenerator#writeUnmarshalArgument(IndentingWriter, String, Type, String):::Write a snippet of Java code to unmarshal a value of type "type" from the java.io.ObjectInput stream named "stream" into a variable named "name" (if "name" is null, the value in unmarshalled and discarded):::readObject->if->p->p->typeCode->type->getTypeCode->switch->type->getTypeCode->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->p->p->break->throw->new->Error->return
RMIGenerator#writeUnmarshalArguments(IndentingWriter, String, Type[], String[]):::Write Java statements to unmarshal a series of values in order of types as in the "types" array from the java.io.ObjectInput stream named "stream" into variables as named in "names" (for any element of "names" that is null, the corresponding value is unmarshalled and discarded).:::if->throw->new->Error->readObject->for->i->return
RMIGenerator#wrapArgumentCode(Type, String):::Return a snippet of Java code to wrap a value named "name" of type "type" into an object as appropriate for use by the Java Reflection API:::typeCode->type->getTypeCode->switch->return->return->return->return->return->return->return->return->return->throw->new->Error
RMIGenerator#unwrapArgumentCode(Type, String):::Return a snippet of Java code to unwrap a value named "name" into a value of type "type", as appropriate for the Java Reflection API:::typeCode->type->getTypeCode->switch->return->return->return->return->return->return->return->return->return->throw->new->Error
Util#getOutputDirectoryFor(Identifier, File, BatchEnvironment):::Return the directory that should be used for output for a given class.:::outputDir->className->theClass->getFlatName->toString->replace->qualifiedClassName->packagePath->packageName->theClass->getQualifier->toString->if->packageName->length->packageName->replace->if->if->new->File->ensureDirectory->else->else->workingDirPath->System->getProperty->workingDir->new->File->if->else->new->File->ensureDirectory->return
Util#ensureDirectory(File, BatchEnvironment)::: util ensure directory:::if->dir->exists->dir->mkdirs->if->dir->exists->env->dir->getAbsolutePath->error->throw->new->InternalError
